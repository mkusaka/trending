<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-26T01:42:23Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>aaronolsen/linkR</title>
    <updated>2023-05-26T01:42:23Z</updated>
    <id>tag:github.com,2023-05-26:/aaronolsen/linkR</id>
    <link href="https://github.com/aaronolsen/linkR" rel="alternate"></link>
    <summary type="html">&lt;p&gt;R package for simulating and analyzing the kinematics of 2D and 3D linkage mechanisms&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>softdorothy/GliderPRO</title>
    <updated>2023-05-26T01:42:23Z</updated>
    <id>tag:github.com,2023-05-26:/softdorothy/GliderPRO</id>
    <link href="https://github.com/softdorothy/GliderPRO" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Sources for the Macintosh game, Glider PRO, written by John Calhoun and published by Casady &amp; Green Inc.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Glider PRO&lt;/h1&gt; &#xA;&lt;p&gt;Sources for the Macintosh game, Glider PRO, written by John Calhoun and published by Casady &amp;amp; Greene Inc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/softdorothy/glider_pro/raw/master/GliderProSplash.png&#34; alt=&#34;Splash screen&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Additional credits:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Demo House and CD Demo House are by John Calhoun and Kim Money.&lt;/li&gt; &#xA; &lt;li&gt;Davis Station, Metropolis and Titanic are by Jonathan Chin (alias Paul Finn) and John Calhoun.&lt;/li&gt; &#xA; &lt;li&gt;Grand Prix, Leviathan, ImagineHouse PRO II and In The Mirror are by Jonathan Chin (alias Paul Finn).&lt;/li&gt; &#xA; &lt;li&gt;Land of Illusion, Nemo&#39;s Market, Rainbow&#39;s End and SpacePods are by Ward Hartenstein.&lt;/li&gt; &#xA; &lt;li&gt;Slumberland is by John Calhoun (first house and top of fourth house) Jonathan Chin (second house), Steve Sullivan (third house) and Ward Hartenstein (bottom of fourth house).&lt;/li&gt; &#xA; &lt;li&gt;Teddy World is by Shawn Brenneman.&lt;/li&gt; &#xA; &lt;li&gt;The Asylum Pro is by Steve Sullivan.&lt;/li&gt; &#xA; &lt;li&gt;PICT resource 3975 (Ozma) is derived from an illustration by John R. Neill from &lt;a href=&#34;https://www.gutenberg.org/files/33361/33361-h/33361-h.htm&#34;&gt;Ozma of Oz&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;PICT resource 153 (About box) features a portion of &lt;a href=&#34;http://www.comicstriplibrary.org/display/116&#34;&gt;this Little Nemo comic&lt;/a&gt; by Winsor McCay.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Legal The source for Glider PRO is released under the GNU General Public License 2 as published by the Free Software Foundation.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mjskay/ggblend</title>
    <updated>2023-05-26T01:42:23Z</updated>
    <id>tag:github.com,2023-05-26:/mjskay/ggblend</id>
    <link href="https://github.com/mjskay/ggblend" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Support for blend modes in ggplot2&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ggblend: Blending and compositing algebra for ggplot2&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://lifecycle.r-lib.org/articles/stages.html#experimental&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/lifecycle-experimental-orange.svg?sanitize=true&#34; alt=&#34;Lifecycle: experimental&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://CRAN.R-project.org/package=ggblend&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version/ggblend&#34; alt=&#34;CRAN status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.codecov.io/gh/mjskay/ggblend?branch=main&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/mjskay/ggblend/branch/main/graph/badge.svg?sanitize=true&#34; alt=&#34;Codecov test coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mjskay/ggblend/actions&#34;&gt;&lt;img src=&#34;https://github.com/mjskay/ggblend/workflows/R-CMD-check/badge.svg?sanitize=true&#34; alt=&#34;R-CMD-check&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://doi.org/10.5281/zenodo.7963886&#34;&gt;&lt;img src=&#34;https://zenodo.org/badge/DOI/10.5281/zenodo.7963886.svg?sanitize=true&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;&lt;em&gt;ggblend&lt;/em&gt; is a small algebra of operations for blending, copying, adjusting, and compositing layers in &lt;em&gt;ggplot2&lt;/em&gt;. It allows you to easily copy and adjust the aesthetics or parameters of an existing layer, to partition a layer into multiple pieces for re-composition, and to combine layers (or partitions of layers) using blend modes (like &lt;code&gt;&#34;multiply&#34;&lt;/code&gt;, &lt;code&gt;&#34;overlay&#34;&lt;/code&gt;, etc).&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;ggblend&lt;/em&gt; requires R ≥ 4.2, as blending and compositing support was added in that version of R.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install &lt;em&gt;ggblend&lt;/em&gt; from CRAN as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#34;ggblend&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can install the development version of &lt;em&gt;ggblend&lt;/em&gt; using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;remotes::install_github(&#34;mjskay/ggblend&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Blending within one geometry&lt;/h2&gt; &#xA;&lt;p&gt;We’ll construct a simple dataset with two semi-overlapping point clouds. We’ll have two versions of the dataset: one with all the &lt;code&gt;&#34;a&#34;&lt;/code&gt; points listed first, and one with all the &lt;code&gt;&#34;b&#34;&lt;/code&gt; points listed first.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)&#xA;library(ggblend)&#xA;theme_set(ggdist::theme_ggdist() + theme(&#xA;  plot.title = element_text(size = rel(1), lineheight = 1.1, face = &#34;bold&#34;),&#xA;  plot.subtitle = element_text(face = &#34;italic&#34;),&#xA;  panel.border = element_rect(color = &#34;gray75&#34;, fill = NA)&#xA;))&#xA;&#xA;set.seed(1234)&#xA;df_a = data.frame(x = rnorm(500, 0), y = rnorm(500, 1), set = &#34;a&#34;)&#xA;df_b = data.frame(x = rnorm(500, 1), y = rnorm(500, 2), set = &#34;b&#34;)&#xA;&#xA;df_ab = rbind(df_a, df_b) |&amp;gt;&#xA;  transform(order = &#34;draw a then b&#34;)&#xA;&#xA;df_ba = rbind(df_b, df_a) |&amp;gt;&#xA;  transform(order = &#34;draw b then a&#34;)&#xA;&#xA;df = rbind(df_ab, df_ba)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A typical scatterplot of such data suffers from the problem that how many points appear to be in each group depends on the drawing order (&lt;em&gt;a then b&lt;/em&gt; versus &lt;em&gt;b then a&lt;/em&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df |&amp;gt;&#xA;  ggplot(aes(x, y, color = set)) +&#xA;  geom_point(size = 3, alpha = 0.5) +&#xA;  scale_color_brewer(palette = &#34;Set1&#34;) +&#xA;  facet_grid(~ order) +&#xA;  labs(title = &#34;geom_point() without blending&#34;, subtitle = &#34;Draw order matters.&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-scatter_noblend-1.png&#34; width=&#34;672&#34;&gt; &#xA;&lt;p&gt;A &lt;em&gt;commutative&lt;/em&gt; blend mode, like &lt;code&gt;&#34;multiply&#34;&lt;/code&gt; or &lt;code&gt;&#34;darken&#34;&lt;/code&gt;, is one potential solution that does not depend on drawing order. We can apply a &lt;code&gt;blend()&lt;/code&gt; operation to geom_point()` to achieve this. There three ways to do this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;blend(geom_point(...), &#34;multiply&#34;)&lt;/code&gt; (normal function application)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;geom_point(...) |&amp;gt; blend(&#34;multiply&#34;)&lt;/code&gt; (piping)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;geom_point(...) * blend(&#34;multiply&#34;)&lt;/code&gt; (algebraic operations)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Function application and piping are equivalent. &lt;strong&gt;In this case&lt;/strong&gt;, all three approaches are equivalent. As we will see later, the multiplication approach is useful when we want a shorthand for applying the same operation to multiple layers in a list without combining those layers first (in other words, multiplication of operations over layers is &lt;em&gt;distributive&lt;/em&gt; in an algebraic sense).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df |&amp;gt;&#xA;  ggplot(aes(x, y, color = set)) +&#xA;  geom_point(size = 3, alpha = 0.5) |&amp;gt; blend(&#34;multiply&#34;) +&#xA;  scale_color_brewer(palette = &#34;Set1&#34;) +&#xA;  facet_grid(~ order) +&#xA;  labs(&#xA;    title = &#34;geom_point(alpha = 0.5) |&amp;gt; blend(&#39;multiply&#39;)&#34;,&#xA;    subtitle = &#34;Draw order does not matter, but color is too dark.&#34;&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-scatter_blend-1.png&#34; width=&#34;672&#34;&gt; &#xA;&lt;p&gt;Now the output is identical no matter the draw order, although the output is quite dark.&lt;/p&gt; &#xA;&lt;h2&gt;Partitioning layers&lt;/h2&gt; &#xA;&lt;p&gt;Part of the reason the output is very dark above is that all of the points are being multiply-blended together. When many objects (here, individual points) are multiply-blended on top of each other, the output tends to get dark very quickly.&lt;/p&gt; &#xA;&lt;p&gt;However, we really only need the two sets to be multiply-blended with each other. Within each set, we can use regular alpha blending. To do that, we can partition the geometry by &lt;code&gt;set&lt;/code&gt; and then blend. Each partition will be blended normally within the set, and then the resulting sets will be multiply-blended together just once:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df |&amp;gt;&#xA;  ggplot(aes(x, y, color = set)) +&#xA;  geom_point(size = 3, alpha = 0.5) |&amp;gt; partition(vars(set)) |&amp;gt; blend(&#34;multiply&#34;) +&#xA;  scale_color_brewer(palette = &#34;Set1&#34;) +&#xA;  facet_grid(~ order) +&#xA;  labs(&#xA;    title = &#34;geom_point(alpha = 0.5) |&amp;gt; partition(vars(set)) |&amp;gt; blend(&#39;multiply&#39;)&#34;,&#xA;    subtitle = &#34;Light outside the intersection, but still dark inside the intersection.&#34;&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-scatter_partition_blend-1.png&#34; width=&#34;672&#34;&gt; &#xA;&lt;p&gt;That’s getting there: points outside the intersection of the two sets look good, but the intersection is still a bit dark.&lt;/p&gt; &#xA;&lt;p&gt;Let’s try combining two blend modes to address this: we’ll use a &lt;code&gt;&#34;lighten&#34;&lt;/code&gt; blend mode (which is also commutative) to make the overlapping regions lighter, and then draw the &lt;code&gt;&#34;multiply&#34;&lt;/code&gt;-blended version on top at an &lt;code&gt;alpha&lt;/code&gt; of less than 1:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df |&amp;gt;&#xA;  ggplot(aes(x, y, color = set)) +&#xA;  geom_point(size = 3, alpha = 0.5) |&amp;gt; partition(vars(set)) |&amp;gt; blend(&#34;lighten&#34;) +&#xA;  geom_point(size = 3, alpha = 0.5) |&amp;gt; partition(vars(set)) |&amp;gt; blend(&#34;multiply&#34;, alpha = 0.5) +&#xA;  scale_color_brewer(palette = &#34;Set1&#34;) +&#xA;  facet_grid(~ order) +&#xA;  labs(&#xA;    title = &#xA;      &#34;geom_point(size = 3, alpha = 0.5) |&amp;gt; partition(vars(set)) |&amp;gt; blend(&#39;lighten&#39;) + \ngeom_point(size = 3, alpha = 0.5) |&amp;gt; partition(vars(set)) |&amp;gt; blend(&#39;multiply&#39;, alpha = 0.5)&#34;,&#xA;    subtitle = &#39;A good compromise, but a long specification.&#39;&#xA;  ) +&#xA;  theme(plot.subtitle = element_text(lineheight = 1.2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-scatter_lighten_multiply-1.png&#34; width=&#34;672&#34;&gt; &#xA;&lt;p&gt;Now it’s a little easier to see both overlap and density, and the output remains independent of draw order.&lt;/p&gt; &#xA;&lt;p&gt;However, it is a little verbose to need to copy out a layer multiple times:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;geom_point(size = 3, alpha = 0.5) |&amp;gt; partition(vars(set)) * blend(&#34;lighten&#34;) +&#xA;geom_point(size = 3, alpha = 0.5) |&amp;gt; partition(vars(set)) * blend(&#34;multiply&#34;, alpha = 0.5) +&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can simplify this is two ways: first, &lt;code&gt;partition(vars(set))&lt;/code&gt; is equivalent to setting &lt;code&gt;aes(partition = set)&lt;/code&gt;, so we can move the partition specification into the global plot aesthetics, since it is the same on every layer.&lt;/p&gt; &#xA;&lt;p&gt;Second, operations and layers in &lt;em&gt;ggblend&lt;/em&gt; act as a small algebra. Operations and sums of operations can be multiplied by layers and lists of layers, and those operations are distributed over the layers (This is where &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;|&amp;gt;&lt;/code&gt; differ: &lt;code&gt;|&amp;gt;&lt;/code&gt; does not distribute operations like &lt;code&gt;blend()&lt;/code&gt; over layers, which is useful if you want to use a blend to combine multiple layers together, rather than applying that blend to each layer individually).&lt;/p&gt; &#xA;&lt;p&gt;Thus, we can “factor out” &lt;code&gt;geom_point(size = 3, alpha = 0.5)&lt;/code&gt; from the above expression, yielding this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;geom_point(size = 3, alpha = 0.5) * (blend(&#34;lighten&#34;) + blend(&#34;multiply&#34;, alpha = 0.5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both expressions are equivalent. Thus we can rewrite the previous example like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df |&amp;gt;&#xA;  ggplot(aes(x, y, color = set, partition = set)) +&#xA;  geom_point(size = 3, alpha = 0.5) * (blend(&#34;lighten&#34;) + blend(&#34;multiply&#34;, alpha = 0.5)) +&#xA;  scale_color_brewer(palette = &#34;Set1&#34;) +&#xA;  facet_grid(~ order) +&#xA;  labs(&#xA;    title = &#34;geom_point(aes(partition = set)) * (blend(&#39;lighten&#39;) + blend(&#39;multiply&#39;, alpha = 0.5))&#34;,&#xA;    subtitle = &#34;Two order-independent blends on one layer using the distributive law.&#34;&#xA;  ) +&#xA;  theme(plot.subtitle = element_text(lineheight = 1.2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-scatter_lighten_multiply_stacked-1.png&#34; width=&#34;672&#34;&gt; &#xA;&lt;h2&gt;Blending multiple geometries&lt;/h2&gt; &#xA;&lt;p&gt;We can also blend geometries together by passing a list of geometries to &lt;code&gt;blend()&lt;/code&gt;. These lists can include already-blended geometries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df |&amp;gt;&#xA;  ggplot(aes(x, y, color = set, partition = set)) +&#xA;  list(&#xA;    geom_point(size = 3, alpha = 0.5) * (blend(&#34;lighten&#34;) + blend(&#34;multiply&#34;, alpha = 0.5)),&#xA;    geom_vline(xintercept = 0, color = &#34;gray75&#34;, linewidth = 1.5),&#xA;    geom_hline(yintercept = 0, color = &#34;gray75&#34;, linewidth = 1.5)&#xA;  ) |&amp;gt; blend(&#34;hard.light&#34;) +&#xA;  scale_color_brewer(palette = &#34;Set1&#34;) +&#xA;  facet_grid(~ order) +&#xA;  labs(&#xA;    title = &#34;Blending multiple geometries together in a list&#34;,&#xA;    subtitle = &#34;Careful! The point layer blend is incorrect!&#34;&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-scatter_blend_geom_incorrect-1.png&#34; width=&#34;672&#34;&gt; &#xA;&lt;p&gt;Whoops!! If you look closely, the blending of the &lt;code&gt;geom_point()&lt;/code&gt; layers appears to have changed. Recall that this expression:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;geom_point(size = 3, alpha = 0.5) * (blend(&#34;lighten&#34;) + blend(&#34;multiply&#34;, alpha = 0.5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Is equivalent to specifying two separate layers, one with &lt;code&gt;blend(&#34;lighten&#34;)&lt;/code&gt; and the other with &lt;code&gt;blend(&#34;multiply&#34;, alpha = 0.65))&lt;/code&gt;. Thus, when you apply &lt;code&gt;|&amp;gt; blend(&#34;hard.light&#34;)&lt;/code&gt; to the &lt;code&gt;list()&lt;/code&gt; of layers, it will use a hard light blend mode to blend these two layers together, when previously they would be blended using the normal (or &lt;code&gt;&#34;over&#34;&lt;/code&gt;) blend mode.&lt;/p&gt; &#xA;&lt;p&gt;We can gain back the original appearance by blending these two layers together with &lt;code&gt;|&amp;gt; blend()&lt;/code&gt; prior to applying the hard light blend:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df |&amp;gt;&#xA;  ggplot(aes(x, y, color = set, partition = set)) +&#xA;  list(&#xA;    geom_point(size = 3, alpha = 0.5) * (blend(&#34;lighten&#34;) + blend(&#34;multiply&#34;, alpha = 0.5)) |&amp;gt; blend(),&#xA;    geom_vline(xintercept = 0, color = &#34;gray75&#34;, linewidth = 1.5),&#xA;    geom_hline(yintercept = 0, color = &#34;gray75&#34;, linewidth = 1.5)&#xA;  ) |&amp;gt; blend(&#34;hard.light&#34;) +&#xA;  scale_color_brewer(palette = &#34;Set1&#34;) +&#xA;  facet_grid(~ order) +&#xA;  labs(title = &#34;Blending multiple geometries together&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-scatter_blend_geom-1.png&#34; width=&#34;672&#34;&gt; &#xA;&lt;h2&gt;Partitioning and blending lineribbons&lt;/h2&gt; &#xA;&lt;p&gt;Another case where it’s useful to have finer-grained control of blending within a given geometry is when drawing overlapping uncertainty bands. Here, we’ll show how to use &lt;code&gt;blend()&lt;/code&gt; with &lt;code&gt;stat_lineribbon()&lt;/code&gt; from &lt;a href=&#34;https://mjskay.github.io/ggdist/&#34;&gt;ggdist&lt;/a&gt; to create overlapping gradient ribbons depicting uncertainty.&lt;/p&gt; &#xA;&lt;p&gt;We’ll fit a model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;m_mpg = lm(mpg ~ hp * cyl, data = mtcars)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And generate some confidence distributions for the mean using &lt;a href=&#34;https://pkg.mitchelloharawild.com/distributional/&#34;&gt;distributional&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;predictions = unique(mtcars[, c(&#34;cyl&#34;, &#34;hp&#34;)])&#xA;&#xA;predictions$mu_hat = with(predict(m_mpg, newdata = predictions, se.fit = TRUE), &#xA;  distributional::dist_student_t(df = df, mu = fit, sigma = se.fit)&#xA;)&#xA;&#xA;predictions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;##                     cyl  hp                     mu_hat&#xA;## Mazda RX4             6 110 t(28, 20.28825, 0.7984429)&#xA;## Datsun 710            4  93 t(28, 25.74371, 0.8818612)&#xA;## Hornet Sportabout     8 175 t(28, 15.56144, 0.8638133)&#xA;## Valiant               6 105 t(28, 20.54952, 0.8045354)&#xA;## Duster 360            8 245 t(28, 14.66678, 0.9773475)&#xA;## Merc 240D             4  62   t(28, 28.58736, 1.21846)&#xA;## Merc 230              4  95 t(28, 25.56025, 0.9024699)&#xA;## Merc 280              6 123  t(28, 19.60892, 0.842354)&#xA;## Merc 450SE            8 180 t(28, 15.49754, 0.8332276)&#xA;## Cadillac Fleetwood    8 205 t(28, 15.17801, 0.7674501)&#xA;## Lincoln Continental   8 215 t(28, 15.05021, 0.7866649)&#xA;## Chrysler Imperial     8 230 t(28, 14.85849, 0.8606705)&#xA;## Fiat 128              4  66   t(28, 28.22044, 1.12188)&#xA;## Honda Civic           4  52  t(28, 29.50466, 1.491467)&#xA;## Toyota Corolla        4  65  t(28, 28.31217, 1.145154)&#xA;## Toyota Corona         4  97 t(28, 25.37679, 0.9280143)&#xA;## Dodge Challenger      8 150  t(28, 15.88096, 1.077004)&#xA;## Porsche 914-2         4  91 t(28, 25.92718, 0.8665404)&#xA;## Lotus Europa          4 113   t(28, 23.9091, 1.262843)&#xA;## Ford Pantera L        8 264  t(28, 14.42394, 1.166062)&#xA;## Ferrari Dino          6 175  t(28, 16.89163, 1.550885)&#xA;## Maserati Bora         8 335   t(28, 13.5165, 2.045807)&#xA;## Volvo 142E            4 109  t(28, 24.27603, 1.162526)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A basic plot based on examples in &lt;code&gt;vignette(&#34;freq-uncertainty-vis&#34;, package = &#34;ggdist&#34;)&lt;/code&gt; and &lt;code&gt;vignette(&#34;lineribbon&#34;, package = &#34;ggdist&#34;)&lt;/code&gt; may have issues when lineribbons overlap:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;predictions |&amp;gt;&#xA;  ggplot(aes(x = hp, fill = ordered(cyl), color = ordered(cyl))) +&#xA;  ggdist::stat_lineribbon(&#xA;    aes(ydist = mu_hat, fill_ramp = after_stat(.width)),&#xA;    .width = ppoints(40)&#xA;  ) +&#xA;  geom_point(aes(y = mpg), data = mtcars) +&#xA;  scale_fill_brewer(palette = &#34;Set2&#34;) +&#xA;  scale_color_brewer(palette = &#34;Dark2&#34;) +&#xA;  ggdist::scale_fill_ramp_continuous(range = c(1, 0)) +&#xA;  labs(&#xA;    title = &#34;ggdist::stat_lineribbon()&#34;,&#xA;    subtitle = &#34;Overlapping lineribbons obscure each other.&#34;, &#xA;    color = &#34;cyl&#34;, fill = &#34;cyl&#34;, y = &#34;mpg&#34;&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-lineribbon_noblend-1.png&#34; width=&#34;672&#34;&gt; &#xA;&lt;p&gt;Notice the overlap of the orange (&lt;code&gt;cyl = 6&lt;/code&gt;) and purple (&lt;code&gt;cyl = 8&lt;/code&gt;) lines.&lt;/p&gt; &#xA;&lt;p&gt;If we add a &lt;code&gt;partition = cyl&lt;/code&gt; aesthetic mapping, we can blend the geometries for the different levels of &lt;code&gt;cyl&lt;/code&gt; together with a &lt;code&gt;blend()&lt;/code&gt; call around &lt;code&gt;ggdist::stat_lineribbon()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are many ways we could add the partition to the plot:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add &lt;code&gt;partition = cyl&lt;/code&gt; to the existing &lt;code&gt;aes(...)&lt;/code&gt; call. However, this leaves the partitioning information far from the call to &lt;code&gt;blend()&lt;/code&gt;, so the relationship between them is less clear.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;aes(partition = cyl)&lt;/code&gt; to the &lt;code&gt;stat_lineribbon(...)&lt;/code&gt; call. This is a more localized change (better!), but will raise a warning if &lt;code&gt;stat_lineribbon()&lt;/code&gt; itself does not recognized the &lt;code&gt;partition&lt;/code&gt; aesthetic.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;|&amp;gt; adjust(aes(partition = cyl))&lt;/code&gt; after &lt;code&gt;stat_lineribbon(...)&lt;/code&gt; to add the &lt;code&gt;partition&lt;/code&gt; aesthetic to it (this will bypass the warning).&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;|&amp;gt; partition(vars(cyl))&lt;/code&gt; after &lt;code&gt;stat_lineribbon(...)&lt;/code&gt; to add the &lt;code&gt;partition&lt;/code&gt; aesthetic. This is an alias for the &lt;code&gt;adjust()&lt;/code&gt; approach that is intended to be clearer. It takes a specification for a partition that is similar to &lt;code&gt;facet_wrap()&lt;/code&gt;: either a one-sided formula or a call to &lt;code&gt;vars()&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Let’s try the fourth approach:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;predictions |&amp;gt;&#xA;  ggplot(aes(x = hp, fill = ordered(cyl), color = ordered(cyl))) +&#xA;  ggdist::stat_lineribbon(&#xA;    aes(ydist = mu_hat, fill_ramp = after_stat(.width)),&#xA;    .width = ppoints(40)&#xA;  ) |&amp;gt; partition(vars(cyl)) |&amp;gt; blend(&#34;multiply&#34;) +&#xA;  geom_point(aes(y = mpg), data = mtcars) +&#xA;  scale_fill_brewer(palette = &#34;Set2&#34;) +&#xA;  scale_color_brewer(palette = &#34;Dark2&#34;) +&#xA;  ggdist::scale_fill_ramp_continuous(range = c(1, 0)) +&#xA;  labs(&#xA;    title = &#34;ggdist::stat_lineribbon() |&amp;gt; partition(vars(cyl)) |&amp;gt; blend(&#39;multiply&#39;)&#34;,&#xA;    subtitle = &#34;Overlapping lineribbons blend together independent of draw order.&#34;,&#xA;    color = &#34;cyl&#34;, fill = &#34;cyl&#34;, y = &#34;mpg&#34;&#xA;  ) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-lineribbon_blend-1.png&#34; width=&#34;672&#34;&gt; &#xA;&lt;p&gt;Now the overlapping ribbons are blended together.&lt;/p&gt; &#xA;&lt;h2&gt;Highlighting geoms using &lt;code&gt;copy_under()&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;A common visualization technique to make a layer more salient (especially in the presence of many other competing layers) is to add a small outline around it. For some geometries (like &lt;code&gt;geom_point()&lt;/code&gt;) this is easy; but for others (like &lt;code&gt;geom_line()&lt;/code&gt;), there’s no easy way to do this without manually copying the layer.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;em&gt;ggblend&lt;/em&gt; layer algebra makes this straightforward using the &lt;code&gt;adjust()&lt;/code&gt; operation combined with operator addition and multiplication. For example, given a layer like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;geom_line(linewidth = 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To add a white outline, you might want something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;geom_line(color = &#34;white&#34;, linewidth = 2.5) + geom_line(linewidth = 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, we’d rather not have to write the &lt;code&gt;geom_line()&lt;/code&gt; specification twice If we factor out the differences between the first and second layer, we can use the &lt;code&gt;adjust()&lt;/code&gt; operation (which lets you change the aesthetics and parameters of a layer) along with the distributive law to factor out &lt;code&gt;geom_line(linewidth = 1)&lt;/code&gt; and write the above specification as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;geom_line(linewidth = 1) * (adjust(color = &#34;white&#34;, linewidth = 2.5) + 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;copy_under(...)&lt;/code&gt; operation, which is a synonym for &lt;code&gt;adjust(...) + 1&lt;/code&gt;, also implements this pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;geom_line(linewidth = 1) * copy_under(color = &#34;white&#34;, linewidth = 2.5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here’s an example highlighting the fit lines from our previous lineribbon example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;predictions |&amp;gt;&#xA;  ggplot(aes(x = hp, fill = ordered(cyl), color = ordered(cyl))) +&#xA;  ggdist::stat_ribbon(&#xA;    aes(ydist = mu_hat, fill_ramp = after_stat(.width)),&#xA;    .width = ppoints(40)&#xA;  ) |&amp;gt; partition(vars(cyl)) |&amp;gt; blend(&#34;multiply&#34;) +&#xA;  geom_line(aes(y = median(mu_hat)), linewidth = 1) |&amp;gt; copy_under(color = &#34;white&#34;, linewidth = 2.5) +&#xA;  geom_point(aes(y = mpg), data = mtcars) +&#xA;  scale_fill_brewer(palette = &#34;Set2&#34;) +&#xA;  scale_color_brewer(palette = &#34;Dark2&#34;) +&#xA;  ggdist::scale_fill_ramp_continuous(range = c(1, 0)) +&#xA;  labs(&#xA;    title = &#34;geom_line() |&amp;gt; copy_under(color = &#39;white&#39;, linewidth = 2.5)&#34;, &#xA;    subtitle = &#34;Highlights the line layer without manually copying its specification.&#34;,&#xA;    color = &#34;cyl&#34;, fill = &#34;cyl&#34;, y = &#34;mpg&#34;&#xA;  ) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-lineribbon_blend_highlight-1.png&#34; width=&#34;672&#34;&gt; &#xA;&lt;p&gt;Note that the implementation of &lt;code&gt;copy_under(...)&lt;/code&gt; is simply a synonym for &lt;code&gt;adjust(...) + 1&lt;/code&gt;; we can see this if we look at &lt;code&gt;copy_under()&lt;/code&gt; itself:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;copy_under()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## &amp;lt;operation&amp;gt;: (adjust() + 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In fact, not that it is particularly useful, but addition and multiplication of layer operations is expanded appropriately:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(adjust() + 3) * 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## &amp;lt;operation&amp;gt;: (adjust() + 1 + 1 + 1 + adjust() + 1 + 1 + 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I hesitate to imagine what that feature might be useful for…&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility with other packages&lt;/h2&gt; &#xA;&lt;p&gt;In theory &lt;em&gt;ggblend&lt;/em&gt; should be compatible with other packages, though in more complex cases (blending lists of geoms or using the &lt;code&gt;partition&lt;/code&gt; aesthetic) it is possible it may fail, as these features are a bit more hackish. I have done some testing with a few other layer-manipulating packages—including &lt;a href=&#34;https://gganimate.com/&#34;&gt;gganimate&lt;/a&gt;, &lt;a href=&#34;https://eliocamp.github.io/ggnewscale/&#34;&gt;ggnewscale&lt;/a&gt;, and &lt;a href=&#34;https://github.com/clauswilke/relayer&#34;&gt;relayer&lt;/a&gt;—and they appear to be compatible.&lt;/p&gt; &#xA;&lt;p&gt;As a hard test, here is all three features applied to a modified version of the Gapminder example used in the &lt;a href=&#34;https://gganimate.com/&#34;&gt;gganimate documentation&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(gganimate)&#xA;library(gapminder)&#xA;&#xA;p = gapminder |&amp;gt;&#xA;  ggplot(aes(gdpPercap, lifeExp, size = pop, color = continent)) +&#xA;  list(&#xA;    geom_point(show.legend = c(size = FALSE)) |&amp;gt; partition(vars(continent)) |&amp;gt; blend(&#34;multiply&#34;),&#xA;    geom_hline(yintercept = 70, linewidth = 1.5, color = &#34;gray75&#34;)&#xA;  ) |&amp;gt; blend(&#34;hard.light&#34;) +&#xA;  scale_color_manual(&#xA;    # same as colorspace::lighten(continent_colors, 0.35)&#xA;    values = c(&#xA;      Africa = &#34;#BE7658&#34;, Americas = &#34;#E95866&#34;, Asia = &#34;#7C5C86&#34;, &#xA;      Europe = &#34;#659C5D&#34;, Oceania = &#34;#7477CA&#34;&#xA;    ),&#xA;    guide = guide_legend(override.aes = list(size = 4))&#xA;  ) +&#xA;  scale_size(range = c(2, 12)) +&#xA;  scale_x_log10(labels = scales::label_dollar(scale_cut = scales::cut_short_scale())) +&#xA;  scale_y_continuous(breaks = seq(20, 80, by = 10)) +&#xA;  labs(&#xA;    title = &#39;Gapminder with gganimate and ggblend&#39;, &#xA;    subtitle = &#39;Year: {frame_time}&#39;, &#xA;    x = &#39;GDP per capita&#39;, &#xA;    y = &#39;Life expectancy&#39;&#xA;  )  +&#xA;  transition_time(year) +&#xA;  ease_aes(&#39;linear&#39;)&#xA;&#xA;animate(p, type = &#34;cairo&#34;, width = 600, height = 400, res = 100)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mjskay/ggblend/main/man/figures/README-gapminder-1.gif&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt;</summary>
  </entry>
</feed>