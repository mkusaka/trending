<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-23T01:43:13Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cran/woylier</title>
    <updated>2023-05-23T01:43:13Z</updated>
    <id>tag:github.com,2023-05-23:/cran/woylier</id>
    <link href="https://github.com/cran/woylier" rel="alternate"></link>
    <summary type="html">&lt;p&gt;❗ This is a read-only mirror of the CRAN R package repository. woylier — Alternative Tour Frame Interpolation Method&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;woylier &lt;a href=&#34;https://numbats.github.io/woylier/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cran/woylier/master/man/figures/logo.png&#34; align=&#34;right&#34; height=&#34;138.5&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;The &#34;woylier&#34; package provides alternative method for generating a tour path by interpolating between d-D frames in p-D space rather than d-D planes.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install the development version of woylier from &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;devtools&#34;)&#xA;devtools::install_github(&#34;numbats/woylier&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>microsoft/finnts</title>
    <updated>2023-05-23T01:43:13Z</updated>
    <id>tag:github.com,2023-05-23:/microsoft/finnts</id>
    <link href="https://github.com/microsoft/finnts" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Microsoft Finance Time Series Forecasting Framework (FinnTS) is a forecasting package that utilizes cutting-edge time series forecasting and parallelization on the cloud to produce accurate forecasts for financial data.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Microsoft Finance Time Series Forecasting Framework&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cran.r-project.org/package=finnts&#34;&gt;&lt;img src=&#34;http://www.r-pkg.org/badges/version/finnts&#34; alt=&#34;CRAN_Status_Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;The Microsoft Finance Time Series Forecasting Framework, aka finnts or Finn, is an automated forecasting framework for producing financial forecasts. While it was built for corporate finance activities, it can easily expand to any time series forecasting problem!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automated feature engineering, back testing, and model selection.&lt;/li&gt; &#xA; &lt;li&gt;Access to 25+ models. Both univariate and multivariate models.&lt;/li&gt; &#xA; &lt;li&gt;Azure integration to run thousands of time series in parallel within the cloud.&lt;/li&gt; &#xA; &lt;li&gt;Supports daily, weekly, monthly, quarterly, and yearly forecasts.&lt;/li&gt; &#xA; &lt;li&gt;Handles external regressors, either purely historical or historical+future values.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;CRAN version&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#34;finnts&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Development version&lt;/h3&gt; &#xA;&lt;p&gt;To get a bug fix or to use a feature from the development version, you can install the development version of finnts from GitHub.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;devtools&#34;)&#xA;devtools::install_github(&#34;microsoft/finnts&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(finnts)&#xA;&#xA;# prepare historical data&#xA;hist_data &amp;lt;- timetk::m4_monthly %&amp;gt;%&#xA;  dplyr::rename(Date = date) %&amp;gt;%&#xA;  dplyr::mutate(id = as.character(id))&#xA;&#xA;# call main finnts modeling function&#xA;finn_output &amp;lt;- forecast_time_series(&#xA;  input_data = hist_data,&#xA;  combo_variables = c(&#34;id&#34;),&#xA;  target_variable = &#34;value&#34;,&#xA;  date_type = &#34;month&#34;,&#xA;  forecast_horizon = 3,&#xA;  back_test_scenarios = 6, &#xA;  models_to_run = c(&#34;arima&#34;, &#34;ets&#34;), &#xA;  run_global_models = FALSE, &#xA;  run_model_parallel = FALSE&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit &lt;a href=&#34;https://cla.opensource.microsoft.com&#34;&gt;https://cla.opensource.microsoft.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.&lt;/p&gt; &#xA;&lt;p&gt;This project has adopted the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/&#34;&gt;Microsoft Open Source Code of Conduct&lt;/a&gt;. For more information see the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/faq/&#34;&gt;Code of Conduct FAQ&lt;/a&gt; or contact &lt;a href=&#34;mailto:opencode@microsoft.com&#34;&gt;opencode@microsoft.com&lt;/a&gt; with any additional questions or comments.&lt;/p&gt; &#xA;&lt;h2&gt;Trademarks&lt;/h2&gt; &#xA;&lt;p&gt;This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow &lt;a href=&#34;https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks&#34;&gt;Microsoft&#39;s Trademark &amp;amp; Brand Guidelines&lt;/a&gt;. Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party&#39;s policies.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cran/idmact</title>
    <updated>2023-05-23T01:43:13Z</updated>
    <id>tag:github.com,2023-05-23:/cran/idmact</id>
    <link href="https://github.com/cran/idmact" rel="alternate"></link>
    <summary type="html">&lt;p&gt;❗ This is a read-only mirror of the CRAN R package repository. idmact — Interpreting Differences Between Mean ACT Scores. Homepage: https://github.com/mncube/idmact Report bugs for this package: https://github.com/mncube/idmact/issues&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;idmact&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;The goal of idmact is to provide an implementation of the &lt;a href=&#34;https://www.act.org/content/dam/act/unsecured/documents/ACT_RR98-01.pdf&#34;&gt;Schiel (1998)&lt;/a&gt; algorithm for interpreting differences between mean ACT assessment scores.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install the released version of idmact from &lt;a href=&#34;https://CRAN.R-project.org&#34;&gt;CRAN&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#34;idmact&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can install the development version of idmact from &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;devtools&#34;)&#xA;devtools::install_github(&#34;mncube/idmact&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Main Algorithm&lt;/h2&gt; &#xA;&lt;p&gt;The idmact package provides tools designed to examine the significance of differences between mean ACT scale scores over time. The fundamental algorithm for composite scale scores consists of the following six steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add one unit to the raw score of one or more subjects for each student to derive adjusted raw scores.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Convert adjusted raw scores to adjusted scale scores using the form’s raw score to scale score map. Note that perfect raw scores are always converted to the maximum allowable scale score, irrespective of the adjustment in step one.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For each student, sum the adjusted scale scores across all subject areas, divide this sum by the number of subject areas, and round to the nearest integer. This produces each student’s adjusted composite scale score.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Calculate the adjusted mean composite scale score across all students (m_adj).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Calculate the unadjusted mean composite scale score across all observations (m_unadj).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Compute the difference between the adjusted and unadjusted mean composite scale scores to get the delta composite: deltac = m_adj - m_unadj&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;While this algorithm was initially developed to address the challenges in interpreting differences between mean ACT scale scores, it can also be beneficial in other contexts. These may include situations where different forms of an assessment have varying raw score to scale score maps, particularly when the relationship between raw and scale scores is complex and/or proprietary.&lt;/p&gt; &#xA;&lt;h2&gt;Single Subject Example&lt;/h2&gt; &#xA;&lt;p&gt;In the subsequent example, we’ll use the algorithm described above to interpret differences between two forms of a hypothetical assessment. Both forms share the same range of raw scores and scale scores. However, the conversion map from raw scores to scale scores differs between the two assessments. To keep this example straightforward, we’ll simulate a single data set of raw scores and then use the algorithm to compare mean differences in scale scores between the two assessments. This initial example will concentrate on a single subject area, hence step 3 of the algorithm will not be included.&lt;/p&gt; &#xA;&lt;h3&gt;Generate Data and Maps&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(idmact)&#xA;&#xA;# Create 100 raw scores&#xA;set.seed(279)&#xA;raw_scores &amp;lt;- as.list(sample(1:100, 100, replace = TRUE))&#xA;&#xA;# Map between raw scores and scale scores for each form&#xA;&#xA;## Each form has scale scores ranging from 1 to 12&#xA;map_scale &amp;lt;- c(1:12)&#xA;&#xA;## Each assessment has raw scores ranging from 1 - 100&#xA;map_raw_formA &amp;lt;- list(1:5, 6:20, 21:25, 26:40, 41:45, 46:50, 51:55,&#xA;                   56:75, 76:80, 81:85, 86:90, 91:100)&#xA;&#xA;map_raw_formB &amp;lt;- list(1:10, 11:20, 21:30, 31:40, 41:50, 51:55, 56:65,&#xA;                   66:75, 76:85, 86:90, 91:95, 96:100)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Format Map&lt;/h3&gt; &#xA;&lt;p&gt;In the raw score to scale score map presented above, vectors/lists were utilized to efficiently map each of the 100 raw scores to each of the 12 scale scores. Use the map_elongate function to expand the raw and scale sections of the map into a format where each portion is a list of 100. This is the map format required for the idmact_subj function, which implements the subject-level algorithm.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;formA &amp;lt;- map_elongate(map_raw = map_raw_formA,&#xA;                      map_scale = map_scale)&#xA;&#xA;formB &amp;lt;- map_elongate(map_raw = map_raw_formB,&#xA;                      map_scale = map_scale)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run Subject Level Algorithm&lt;/h3&gt; &#xA;&lt;p&gt;Utilize the raw data and the maps stored in formA and formB to calculate and compare the subject-level delta (deltas). In the algorithm below, each raw score is increased by 1 using the default value of the inc parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;resA &amp;lt;- idmact_subj(raw = raw_scores,&#xA;                    map_raw = formA$map_raw,&#xA;                    map_scale = formA$map_scale)&#xA;&#xA;&#xA;resB &amp;lt;- idmact_subj(raw = raw_scores,&#xA;                    map_raw = formB$map_raw,&#xA;                    map_scale = formB$map_scale)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compare Results&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cat(&#34;Form A subject level delta:&#34;, resA$deltas, &#34;\n&#34;)&#xA;#&amp;gt; Form A subject level delta: 0.11&#xA;cat(&#34;Form B subject level delta:&#34;, resB$deltas)&#xA;#&amp;gt; Form B subject level delta: 0.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this section, the function idmact_subj is used to calculate the ‘delta’ for each form (A and B). The ‘delta’ is the difference between the mean adjusted scale score and the mean unadjusted scale score. This ‘delta’ value provides an estimate of how much the mean scale score would increase if every student were to answer one additional item correctly on the test.&lt;/p&gt; &#xA;&lt;p&gt;In the provided example:&lt;/p&gt; &#xA;&lt;p&gt;For Form A, the subject level delta is 0.11, meaning the mean scale score is expected to increase by 0.11 if every student answers one additional item correctly.&lt;/p&gt; &#xA;&lt;p&gt;For Form B, the subject level delta is 0.1, suggesting that the mean scale score would increase by 0.1 under the same conditions.&lt;/p&gt; &#xA;&lt;p&gt;The results indicate that Form A is more responsive to increases in raw scores, as a one unit increase in raw score leads to a larger increase in the mean scale score for Form A compared to Form B.&lt;/p&gt; &#xA;&lt;h2&gt;Composite Example&lt;/h2&gt; &#xA;&lt;p&gt;The idmact_comp function can be used to calculate the delta for composite scores (deltac). In the example below, raw scores for an additional subject area (‘s2’) will be created and combined with the data from the previous example to demonstrate idmact_comp.&lt;/p&gt; &#xA;&lt;h3&gt;Generate Data and Maps&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Create 100 raw scores&#xA;set.seed(250)&#xA;raw_scores_s2 &amp;lt;- as.list(sample(1:100, 100, replace = TRUE))&#xA;&#xA;# Subject two will use the same ranges for raw scores and scale scores as in&#xA;# the previous example, but the map will be slightly different. &#xA;map_raw_formA_s2 &amp;lt;- list(1:10, 11:25, 26:30, 31:40, 41:45, 46:50, 51:60,&#xA;                         61:75, 76:80, 81:85, 86:90, 91:100)&#xA;&#xA;map_raw_formB_s2 &amp;lt;- list(1:10, 11:16, 17:25, 26:35, 36:45, 46:55, 56:60,&#xA;                         61:75, 76:85, 86:90, 91:95, 96:100)&#xA;&#xA;formA_s2 &amp;lt;- map_elongate(map_raw = map_raw_formA_s2,&#xA;                         map_scale = map_scale)&#xA;&#xA;formB_s2 &amp;lt;- map_elongate(map_raw = map_raw_formB_s2,&#xA;                         map_scale = map_scale)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run Composite Level Algorithm&lt;/h3&gt; &#xA;&lt;p&gt;In the algorithm below, each raw score for each subject is incremented by 1.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;resA_comp &amp;lt;- idmact_comp(raw = list(raw_scores, raw_scores_s2),&#xA;                         inc = list(1, 1),&#xA;                         map_raw = list(formA$map_raw, formA_s2$map_raw),&#xA;                         map_scale = list(formA$map_scale, formA_s2$map_scale))&#xA;&#xA;resB_comp &amp;lt;- idmact_comp(raw = list(raw_scores, raw_scores_s2),&#xA;                         inc = list(1, 1),&#xA;                         map_raw = list(formB$map_raw, formB_s2$map_raw),&#xA;                         map_scale = list(formB$map_scale, formB_s2$map_scale))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compare Composite Results&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cat(&#34;Form A composite level delta:&#34;, resA_comp$composite_results$deltac, &#34;\n&#34;)&#xA;#&amp;gt; Form A composite level delta: 0.08&#xA;cat(&#34;Form B composite level delta:&#34;, resB_comp$composite_results$deltac)&#xA;#&amp;gt; Form B composite level delta: 0.08&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the composite example, two subjects are considered instead of one, and the idmact_comp function is used to calculate the composite level delta (deltac). The composite level delta is calculated in a similar way to the subject level delta, but it considers the total adjusted and unadjusted scale scores across all subjects, rather than just one.&lt;/p&gt; &#xA;&lt;p&gt;In the provided example:&lt;/p&gt; &#xA;&lt;p&gt;For both Form A and Form B, the composite level delta is 0.08. This means that if every student were to answer one additional item correctly on each form, the mean composite scale score is expected to increase by 0.08.&lt;/p&gt; &#xA;&lt;p&gt;This suggests that, when considering multiple subjects, both Form A and Form B respond similarly to increases in raw scores.&lt;/p&gt; &#xA;&lt;h3&gt;See Subject Area 2 Results&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cat(&#34;Form A subject area 2 delta:&#34;, resA_comp$subject_results[[2]]$deltas, &#34;\n&#34;)&#xA;#&amp;gt; Form A subject area 2 delta: 0.05&#xA;cat(&#34;Form B subject area 2 delta:&#34;, resB_comp$subject_results[[2]]$deltas)&#xA;#&amp;gt; Form B subject area 2 delta: 0.08&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This section presents the ‘delta’ for the second subject area specifically. The ‘delta’ for the second subject area is calculated in the same way as the subject level delta mentioned in the first section, but it only considers the scores for the second subject.&lt;/p&gt; &#xA;&lt;p&gt;In the provided example:&lt;/p&gt; &#xA;&lt;p&gt;For Form A, the subject area 2 delta is 0.05, suggesting that the mean scale score for the second subject would increase by 0.05 if every student answered one additional item correctly.&lt;/p&gt; &#xA;&lt;p&gt;For Form B, the subject area 2 delta is 0.08, meaning that the mean scale score for the second subject would increase by 0.08 under the same conditions.&lt;/p&gt; &#xA;&lt;p&gt;These results indicate that, for the second subject area specifically, Form B is more responsive to increases in raw scores.&lt;/p&gt;</summary>
  </entry>
</feed>