<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-24T01:35:12Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>l-magnificence/Mime</title>
    <updated>2024-07-24T01:35:12Z</updated>
    <id>tag:github.com,2024-07-24:/l-magnificence/Mime</id>
    <link href="https://github.com/l-magnificence/Mime" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Machine learning-based integration model with elegant performance&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mime&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;The &lt;code&gt;Mime&lt;/code&gt; package provides a user-friendly solution for constructing machine learning-based integration models from transcriptomic data.&lt;/p&gt; &#xA;&lt;p&gt;With the widespread use of high-throughput sequencing technologies, understanding biology and cancer heterogeneity has been revolutionized. Mime streamlines the process of developing predictive models with high accuracy, leveraging complex datasets to identify critical genes associated with disease progression, patient outcomes, and therapeutic response.&lt;/p&gt; &#xA;&lt;p&gt;It offers four main applications:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Establishing prognosis models using 10 machine learning algorithms.&lt;/li&gt; &#xA; &lt;li&gt;Building binary response models with 7 machine learning algorithms.&lt;/li&gt; &#xA; &lt;li&gt;Conducting core feature selection related to prognosis using 8 machine learning methods.&lt;/li&gt; &#xA; &lt;li&gt;Visualizing the performance of each model. &lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/graph.jpg&#34; alt=&#34;Screenshot&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;You can install the development version of Mime like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# options(&#34;repos&#34;= c(CRAN=&#34;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&#34;))&#xA;# options(BioC_mirror=&#34;http://mirrors.tuna.tsinghua.edu.cn/bioconductor/&#34;)&#xA;if (!requireNamespace(&#34;BiocManager&#34;, quietly = TRUE)) install.packages(&#34;BiocManager&#34;)&#xA;&#xA;depens&amp;lt;-c(&#39;GSEABase&#39;, &#39;GSVA&#39;, &#39;cancerclass&#39;, &#39;mixOmics&#39;, &#39;sparrow&#39;, &#39;sva&#39; , &#39;ComplexHeatmap&#39; )&#xA;for(i in 1:length(depens)){&#xA;  depen&amp;lt;-depens[i]&#xA;  if (!requireNamespace(depen, quietly = TRUE))  BiocManager::install(depen,update = FALSE)&#xA;}&#xA;&#xA;if (!requireNamespace(&#34;CoxBoost&#34;, quietly = TRUE))&#xA;  devtools::install_github(&#34;binderh/CoxBoost&#34;)&#xA;&#xA;if (!requireNamespace(&#34;fastAdaboost&#34;, quietly = TRUE))&#xA;  devtools::install_github(&#34;souravc83/fastAdaboost&#34;)&#xA;&#xA;if (!requireNamespace(&#34;Mime&#34;, quietly = TRUE))&#xA;  devtools::install_github(&#34;l-magnificence/Mime&#34;)&#xA;  &#xA;library(Mime1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;This is a basic example which shows you how to use &lt;code&gt;Mime&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p&gt;Mime need multiple cohorts containing transcriptional sequencing data with information of survival or clinical response to therapy as well as a gene set as inputs. You can dowmload the example data in &lt;code&gt;External data&lt;/code&gt; file to check the format of input.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;load(&#34;./Example.cohort.Rdata&#34;)&#xA;list_train_vali_Data[[&#34;Dataset1&#34;]][1:5,1:5]&#xA;#&amp;gt;               ID    OS.time OS   MT-CO1   MT-CO3&#xA;#&amp;gt;  TCGA.DH.A66B.01 1281.65322  0 13.77340 13.67931&#xA;#&amp;gt;  TCGA.HT.7607.01   96.19915  1 14.96535 14.31857&#xA;#&amp;gt;  TCGA.DB.A64Q.01  182.37755  0 13.90659 13.65321&#xA;#&amp;gt;  TCGA.DU.8167.01  471.97707  0 14.90695 14.59776&#xA;#&amp;gt;  TCGA.HT.7610.01 1709.53901  0 15.22784 14.62756&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first column &lt;code&gt;ID&lt;/code&gt; is the sample ID, second to third column &lt;code&gt;OS.time&lt;/code&gt; and &lt;code&gt;OS&lt;/code&gt; are the survival time and status of patients, other columns are the gene expression level scaled with log2(x+1). &lt;code&gt;Dataset1&lt;/code&gt; is the training dataset, while other Datasets as validation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;load(&#34;./Example.ici.Rdata&#34;)&#xA;list_train_vali_Data[[&#34;training&#34;]][1:5,1:5]&#xA;#&amp;gt;                                   ID Var      FTH1   EEF1A1      ACTB&#xA;#&amp;gt;                      SAMf2ce197162ce   N 10.114846 4.817746 11.230180&#xA;#&amp;gt;                           ERR2208915   Y  2.044180 5.038854  3.977902&#xA;#&amp;gt; G138701_RCCBMS-00141-T_v1_RNA_OnPrem   Y  5.406008 5.341635  5.366668&#xA;#&amp;gt;                      SAMe41b1e773582   N  9.215794 4.707360 11.412721&#xA;#&amp;gt;                      SAM5ffd7e4cd794   N  9.003710 3.908884 10.440559&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first column &lt;code&gt;ID&lt;/code&gt; is the sample ID, second column &lt;code&gt;Var&lt;/code&gt; is the theraputic response of patients (&lt;code&gt;N&lt;/code&gt;: No response; &lt;code&gt;Y&lt;/code&gt;: response), other columns are the gene expression level scaled with log2(x+1). &lt;code&gt;training&lt;/code&gt; is the training dataset, while other Datasets as validation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;load(&#34;./genelist.Rdata&#34;)&#xA;#&amp;gt; [1] &#34;MYC&#34;    &#34;CTNNB1&#34; &#34;JAG2&#34;   &#34;NOTCH1&#34; &#34;DLL1&#34;   &#34;AXIN2&#34;  &#34;PSEN2&#34;  &#34;FZD1&#34;   &#34;NOTCH4&#34; &#34;LEF1&#34;   &#34;AXIN1&#34;  &#34;NKD1&#34;   &#34;WNT5B&#34; &#xA;#&amp;gt;[14] &#34;CUL1&#34;   &#34;JAG1&#34;   &#34;MAML1&#34;  &#34;KAT2A&#34;  &#34;GNAI1&#34;  &#34;WNT6&#34;   &#34;PTCH1&#34;  &#34;NCOR2&#34;  &#34;DKK4&#34;   &#34;HDAC2&#34;  &#34;DKK1&#34;   &#34;TCF7&#34;   &#34;WNT1&#34;  &#xA;#&amp;gt;[27] &#34;NUMB&#34;   &#34;ADAM17&#34; &#34;DVL2&#34;   &#34;PPARD&#34;  &#34;NCSTN&#34;  &#34;HDAC5&#34;  &#34;CCND2&#34;  &#34;FRAT1&#34;  &#34;CSNK1E&#34; &#34;RBPJ&#34;   &#34;FZD8&#34;   &#34;TP53&#34;   &#34;SKP2&#34;  &#xA;#&amp;gt;[40] &#34;HEY2&#34;   &#34;HEY1&#34;   &#34;HDAC11&#34;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This gene set is associated with Wnt/Î²-catenin signalling from MSigDB.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We recommend training dataset with more than 100 samples and gene set with more than 50 genes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;1. Construct predicting models for prognosis&lt;/h3&gt; &#xA;&lt;h4&gt;1.1 Select the optimal model&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(Mime)&#xA;load(&#34;./Example.cohort.Rdata&#34;)&#xA;load(&#34;./genelist.Rdata&#34;)&#xA;res &amp;lt;- ML.Dev.Prog.Sig(train_data = list_train_vali_Data$Dataset1,&#xA;                     list_train_vali_Data = list_train_vali_Data,&#xA;                     unicox.filter.for.candi = T,&#xA;                     unicox_p_cutoff = 0.05,&#xA;                     candidate_genes = genelist,&#xA;                     mode = &#39;all&#39;,nodesize =5,seed = 5201314 )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ML.Dev.Prog.Sig()&lt;/code&gt; provides three modes including &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;single&lt;/code&gt;, and &lt;code&gt;double&lt;/code&gt;. &lt;code&gt;all&lt;/code&gt; means using all ten algorithms and the combinations. &lt;code&gt;single&lt;/code&gt; means using only one of the ten algorithms. &lt;code&gt;double&lt;/code&gt; means using the combination with two algorithms. In most casees, we will generally use &lt;code&gt;all&lt;/code&gt; mode to analysis data.&lt;/li&gt; &#xA; &lt;li&gt;If you set &lt;code&gt;unicox.filter.for.candi&lt;/code&gt; as &lt;code&gt;T&lt;/code&gt; (default), &lt;code&gt;Mime&lt;/code&gt; will firstly perform univariable cox regression among provided genes in the training dataset to screen out the prognostic variables which are then used to construct models.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Plot C-index of each model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cindex_dis_all(res,validate_set = names(list_train_vali_Data)[-1],order =names(list_train_vali_Data),width = 0.35)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can find that &lt;code&gt;StepCox[forward] + plsRcox&lt;/code&gt; have the highest C-index. &lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/cindex_dis_all.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Plot C-index of specific model among different datasets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cindex_dis_select(res,&#xA;                  model=&#34;StepCox[forward] + plsRcox&#34;,&#xA;                  order= names(list_train_vali_Data))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If input object &lt;code&gt;res&lt;/code&gt; is from mode &lt;code&gt;all&lt;/code&gt; used in &lt;code&gt;ML.Dev.Prog.Sig()&lt;/code&gt;, you should define model as specific model name, while define model as &lt;code&gt;SOD&lt;/code&gt;. &lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/cindex_specific_model.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Plot survival curve of patients according to risk score calculated by specific model among different datasets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;survplot &amp;lt;- vector(&#34;list&#34;,2) &#xA;for (i in c(1:2)) {&#xA;  print(survplot[[i]]&amp;lt;-rs_sur(res, model_name = &#34;StepCox[forward] + plsRcox&#34;,dataset = names(list_train_vali_Data)[i],&#xA;                              #color=c(&#34;blue&#34;,&#34;green&#34;),&#xA;                              median.line = &#34;hv&#34;,&#xA;                              cutoff = 0.5,&#xA;                              conf.int = T,&#xA;                              xlab=&#34;Day&#34;,pval.coord=c(1000,0.9)))&#xA;}&#xA;aplot::plot_list(gglist=survplot,ncol=2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/sur_km.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;1.2 Calculate AUC scores of each model&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;all.auc.1y &amp;lt;- cal_AUC_ml_res(res.by.ML.Dev.Prog.Sig = res,train_data = list_train_vali_Data[[&#34;Dataset1&#34;]],&#xA;                            inputmatrix.list = list_train_vali_Data,mode = &#39;all&#39;,AUC_time = 1,&#xA;                            auc_cal_method=&#34;KM&#34;)&#xA;all.auc.3y &amp;lt;- cal_AUC_ml_res(res.by.ML.Dev.Prog.Sig = res,train_data = list_train_vali_Data[[&#34;Dataset1&#34;]],&#xA;                            inputmatrix.list = list_train_vali_Data,mode = &#39;all&#39;,AUC_time = 3,&#xA;                            auc_cal_method=&#34;KM&#34;)&#xA;all.auc.5y &amp;lt;- cal_AUC_ml_res(res.by.ML.Dev.Prog.Sig = res,train_data = list_train_vali_Data[[&#34;Dataset1&#34;]],&#xA;                            inputmatrix.list = list_train_vali_Data,mode = &#39;all&#39;,AUC_time = 5,&#xA;                            auc_cal_method=&#34;KM&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cal_AUC_ml_res()&lt;/code&gt; also provides three modes, which should be consistent with mode uesd by &lt;code&gt;ML.Dev.Prog.Sig()&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AUC_time&lt;/code&gt; for 1 year, 2 years, 3 years......, We recommend using the shortest survival time among all datasets.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here, we only plot 1-year AUC predicted by all models:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;auc_dis_all(all.auc.1y,&#xA;            dataset = names(list_train_vali_Data),&#xA;            validate_set=names(list_train_vali_Data)[-1],&#xA;            order= names(list_train_vali_Data),&#xA;            width = 0.35,&#xA;            year=1)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/auc1y_dis_all.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Plot ROC of specific model among different datasets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;roc_vis(all.auc.1y,&#xA;        model_name = &#34;StepCox[forward] + plsRcox&#34;,&#xA;        dataset = names(list_train_vali_Data),&#xA;        order= names(list_train_vali_Data),&#xA;        anno_position=c(0.65,0.55),&#xA;        year=1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/auc1y_roc.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Plot 1, 3, and 5-year AUC of specific model among different datasets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;auc_dis_select(list(all.auc.1y,all.auc.3y,all.auc.5y),&#xA;               model_name=&#34;StepCox[forward] + plsRcox&#34;,&#xA;               dataset = names(list_train_vali_Data),&#xA;               order= names(list_train_vali_Data),&#xA;               year=c(1,3,5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/auc_specific_model.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;1.3 Meta-analysis of univariate cox regression for specific model&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;unicox.rs.res &amp;lt;- cal_unicox_ml_res(res.by.ML.Dev.Prog.Sig = res,optimal.model = &#34;StepCox[forward] + plsRcox&#34;,type =&#39;categorical&#39;)&#xA;metamodel &amp;lt;- cal_unicox_meta_ml_res(input = unicox.rs.res)&#xA;meta_unicox_vis(metamodel,&#xA;                dataset = names(list_train_vali_Data))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;type&lt;/code&gt; includes &lt;code&gt;categorical&lt;/code&gt; and &lt;code&gt;continuous&lt;/code&gt;. &lt;code&gt;categorical&lt;/code&gt; means that the patients are divided into two subgroups based on the median of the risk score. &lt;code&gt;continuous&lt;/code&gt; means performing the univariable Cox regression bu using the continuous risk score.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/meta_rs.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;1.4 Comparison with previously pblished models&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rs.glioma.lgg.gbm &amp;lt;- cal_RS_pre.prog.sig(use_your_own_collected_sig = F,type.sig = c(&#39;LGG&#39;,&#39;GBM&#39;,&#39;Glioma&#39;),&#xA;                                        list_input_data = list_train_vali_Data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cal_RS_pre.prog.sig()&lt;/code&gt; will calculate the risk score based on the signatures from previous papers.&lt;/li&gt; &#xA; &lt;li&gt;If &lt;code&gt;use_your_own_collected_sig&lt;/code&gt; is set as T, you should provide a data frame containing the information of the signatures. The column names of the data frame are model, PMID, Cancer, Author, Coef and symbol. The &lt;code&gt;model&lt;/code&gt; consists of the first name of the first author and PMID of paper. &lt;code&gt;Cancer&lt;/code&gt; uses abbreviations like the format of TCGA. &lt;code&gt;Author&lt;/code&gt; is the first name of the first author. &lt;code&gt;Coef&lt;/code&gt; is the coefficient of each variable. &lt;code&gt;symbol&lt;/code&gt; is the gene name. Otherwise, we use our collected models of glioma.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Compare the HR of specific model with previously published models:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;HR_com(rs.glioma.lgg.gbm,&#xA;       res,&#xA;       model_name=&#34;StepCox[forward] + plsRcox&#34;,&#xA;       dataset=names(list_train_vali_Data),&#xA;       type = &#34;categorical&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/hr_comp.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cc.glioma.lgg.gbm &amp;lt;- cal_cindex_pre.prog.sig(use_your_own_collected_sig = F,type.sig = c(&#39;Glioma&#39;,&#39;LGG&#39;,&#39;GBM&#39;),&#xA;                                            list_input_data = list_train_vali_Data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cal_cindex_pre.prog.sig()&lt;/code&gt; will calculate the C-index based on the signatures from previous papers like the fuction &lt;code&gt;cal_RS_pre.prog.sig()&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Compare the C-index of specific model with previously published models:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cindex_comp(cc.glioma.lgg.gbm,&#xA;            res,&#xA;            model_name=&#34;StepCox[forward] + plsRcox&#34;,&#xA;            dataset=names(list_train_vali_Data))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/cindex_comp.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;auc.glioma.lgg.gbm.1 &amp;lt;- cal_auc_pre.prog.sig(use_your_own_collected_sig = F,&#xA;                                            type.sig = c(&#39;Glioma&#39;,&#39;LGG&#39;,&#39;GBM&#39;),&#xA;                                            list_input_data = list_train_vali_Data,AUC_time = 1,&#xA;                                            auc_cal_method = &#39;KM&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cal_auc_pre.prog.sig()&lt;/code&gt; will calculate the AUC based on the signatures from previous papers like the fuction &lt;code&gt;cal_RS_pre.prog.sig()&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AUC_time&lt;/code&gt; is like the requirement by &lt;code&gt;cal_AUC_ml_res()&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Compare the AUC of specific model with previously published models:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;auc_comp(auc.glioma.lgg.gbm.1,&#xA;         all.auc.1y,&#xA;         model_name=&#34;StepCox[forward] + plsRcox&#34;,&#xA;         dataset=names(list_train_vali_Data))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/auc_comp_1y.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;1.5 Immune infiltration analysis&lt;/h4&gt; &#xA;&lt;p&gt;After completing the risk grouping, users can perform downstream analysis on the grouped data. Here, we combine Mime with the R package immunedeconv to assist users in quickly previewing immune infiltration. If users require a more precise immune infiltration analysis, they can fine-tune the parameters themselves.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;devo &amp;lt;- TME_deconvolution_all(list_train_vali_Data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you want to use this function, you should install package &lt;code&gt;immunedeconv&lt;/code&gt; ahead.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TME_deconvolution_all()&lt;/code&gt; includes 10 deconvolution methods (&#34;quantiseq&#34;, &#34;xcell&#34;, &#34;epic&#34;, &#34;abis&#34;, &#34;mcp_counter&#34;, &#34;estimate&#34;, &#34;cibersort&#34;, &#34;cibersort_abs&#34;, &#34;timer&#34;, &#34;consensus_tme&#34;) from &lt;code&gt;immunedeconv::deconvolution_methods&lt;/code&gt;. By default, deconvolution methods are set as (&#34;xcell&#34;, &#34;epic&#34;, &#34;abis&#34;, &#34;estimate&#34;, &#34;cibersort&#34;, &#34;cibersort_abs&#34;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Show the results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;immuno_heatmap(res,&#xA;               devo,&#xA;               model_name=&#34;StepCox[backward] + plsRcox&#34;,&#xA;               dataset=&#34;Dataset1&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/immune_heatmap_Mime_dataset1.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;2. Construct predicting models for response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;load(&#34;./Example.ici.Rdata&#34;)&#xA;load(&#34;./genelist.Rdata&#34;)&#xA;res.ici &amp;lt;- ML.Dev.Pred.Category.Sig(train_data = list_train_vali_Data$training,&#xA;                                      list_train_vali_Data = list_train_vali_Data,&#xA;                                      candidate_genes = genelist,&#xA;                                      methods = c(&#39;nb&#39;,&#39;svmRadialWeights&#39;,&#39;rf&#39;,&#39;kknn&#39;,&#39;adaboost&#39;,&#39;LogitBoost&#39;,&#39;cancerclass&#39;),&#xA;                                      seed = 5201314,&#xA;                                      cores_for_parallel = 60&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ML.Dev.Pred.Category.Sig()&lt;/code&gt; develop the predictive model for the binary variables with machine learning algorithms.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Plot AUC of different methods among different datasets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;auc_vis_category_all(res.ici,dataset = c(&#34;training&#34;,&#34;validation&#34;),&#xA;                     order= c(&#34;training&#34;,&#34;validation&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/ICI_response_auc_all.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Plot ROC of specific method among different datasets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot_list&amp;lt;-list()&#xA;methods &amp;lt;- c(&#39;nb&#39;,&#39;svmRadialWeights&#39;,&#39;rf&#39;,&#39;kknn&#39;,&#39;adaboost&#39;,&#39;LogitBoost&#39;,&#39;cancerclass&#39;)&#xA;for (i in methods) {&#xA;  plot_list[[i]]&amp;lt;-roc_vis_category(res.ici,model_name = i,dataset = c(&#34;training&#34;,&#34;validation&#34;),&#xA;                                   order= c(&#34;training&#34;,&#34;validation&#34;),&#xA;                                   anno_position=c(0.4,0.25))&#xA;}&#xA;aplot::plot_list(gglist=plot_list,ncol=3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/ICI_response_roc_all.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Compared AUC with other published models associated with immunotherapy response:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;auc.other.pre &amp;lt;- cal_auc_previous_sig(list_train_vali_Data = list_train_vali_Data,seed = 5201314,&#xA;                                      train_data = list_train_vali_Data$training,&#xA;                                      cores_for_parallel = 32)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cal_auc_previous_sig()&lt;/code&gt; will calculate the AUC based on the signatures from previous papers for immunotherapy response.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cores_for_parallel&lt;/code&gt; means the cores you can choose for parallel operation. If multi-cores condition is error, please set &lt;code&gt;cores_for_parallel&lt;/code&gt; as 1.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Plot comparison results of specific model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;auc_category_comp(res.ici,&#xA;                  auc.other.pre,&#xA;                  model_name=&#34;svmRadialWeights&#34;,&#xA;                  dataset=names(list_train_vali_Data))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/ICI_response_auc_comp.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;3. Core feature selection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;load(&#34;./Example.cohort.Rdata&#34;)&#xA;load(&#34;./genelist.Rdata&#34;)&#xA;res.feature.all &amp;lt;- ML.Corefeature.Prog.Screen(InputMatrix = list_train_vali_Data$Dataset1,&#xA;                                            candidate_genes = genelist,&#xA;                                            mode = &#34;all&#34;,nodesize =5,seed = 5201314 )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ML.Corefeature.Prog.Screen()&lt;/code&gt; provides three modes including &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;single&lt;/code&gt;, and &lt;code&gt;all_without_SVM&lt;/code&gt;. &lt;code&gt;all&lt;/code&gt; mode means using all eight methods (&#34;RSF&#34;, &#34;Enet&#34;, &#34;Boruta&#34;, &#34;Xgboost&#34;, &#34;SVM-REF&#34;, &#34;Lasso&#34;, &#34;CoxBoost&#39;, &#34;StepCox&#34;) for selecting. &lt;code&gt;single&lt;/code&gt; mode means using only one method for running. If you use &lt;code&gt;single&lt;/code&gt; mode, &lt;code&gt;single_ml&lt;/code&gt; should be specified among eight methods. Since SVM takes too long time, we define other seven methods used for selecting as &lt;code&gt;all_without_SVM&lt;/code&gt; mode.&lt;/li&gt; &#xA; &lt;li&gt;The output genes are closely associated with patient outcome and higher frequence of screening means more critical.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Upset plot of genes filtered by different methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;core_feature_select(res.feature.all)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/core_feature_intersect.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Plot the rank of genes filtered by different methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;core_feature_rank(res.feature.all, top=20)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/core_feature_intersect_rank.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here, we randomly select top two genes to analyze their correlation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dataset_col&amp;lt;-c(&#34;#3182BDFF&#34;,&#34;#E6550DFF&#34;)&#xA;corplot &amp;lt;- list()&#xA;for (i in c(1:2)) {&#xA;  print(corplot[[i]]&amp;lt;-cor_plot(list_train_vali_Data[[i]],&#xA;                               dataset=names(list_train_vali_Data)[i],&#xA;                               color = dataset_col[i],&#xA;                               feature1=&#34;PSEN2&#34;,&#xA;                               feature2=&#34;WNT5B&#34;,&#xA;                               method=&#34;pearson&#34;))&#xA;}&#xA;aplot::plot_list(gglist=corplot,ncol=2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/gene_cor.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Plot survival curve of patients according to median expression level of specific gene among different datasets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;survplot &amp;lt;- vector(&#34;list&#34;,2) &#xA;for (i in c(1:2)) {&#xA;  print(survplot[[i]]&amp;lt;-core_feature_sur(&#34;PSEN2&#34;, &#xA;                                        InputMatrix=list_train_vali_Data[[i]],&#xA;                                        dataset = names(list_train_vali_Data)[i],&#xA;                                        #color=c(&#34;blue&#34;,&#34;green&#34;),&#xA;                                        median.line = &#34;hv&#34;,&#xA;                                        cutoff = 0.5,&#xA;                                        conf.int = T,&#xA;                                        xlab=&#34;Day&#34;,pval.coord=c(1000,0.9)))&#xA;}&#xA;aplot::plot_list(gglist=survplot,ncol=2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/l-magnificence/Mime/raw/main/fig/gene_km.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Citations&lt;/h2&gt; &#xA;&lt;p&gt;If you use &lt;strong&gt;&lt;em&gt;Mime&lt;/em&gt;&lt;/strong&gt; in the study, please cite the following publication:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Liu H, Zhang W, Zhang Y, et al. Mime: A flexible machine-learning framework to construct and visualize models for clinical characteristics prediction and feature selection. Comput Struct Biotechnol J. 2024.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;Any technical question please list in Issues section.&lt;/p&gt;</summary>
  </entry>
</feed>