<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-24T01:38:11Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tylermorganwall/rayshader</title>
    <updated>2022-10-24T01:38:11Z</updated>
    <id>tag:github.com,2022-10-24:/tylermorganwall/rayshader</id>
    <link href="https://github.com/tylermorganwall/rayshader" rel="alternate"></link>
    <summary type="html">&lt;p&gt;R Package for 2D and 3D mapping and data visualization&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rayshader&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/raylogosmall.png&#34; align=&#34;right&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/smallhobart.gif&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;rayshader&lt;/strong&gt; is an open source package for producing 2D and 3D data visualizations in R. &lt;strong&gt;rayshader&lt;/strong&gt; uses elevation data in a base R matrix and a combination of raytracing, hillshading algorithms, and overlays to generate stunning 2D and 3D maps. In addition to maps, &lt;strong&gt;rayshader&lt;/strong&gt; also allows the user to translate &lt;strong&gt;ggplot2&lt;/strong&gt; objects into beautiful 3D data visualizations.&lt;/p&gt; &#xA;&lt;p&gt;The models can be rotated and examined interactively or the camera movement can be scripted to create animations. Scenes can also be rendered using a high-quality pathtracer, &lt;strong&gt;rayrender&lt;/strong&gt;. The user can also create a cinematic depth of field post-processing effect to direct the user’s focus to important regions in the figure. The 3D models can also be exported to a 3D-printable format with a built-in STL export function, and can be exported to an OBJ file.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# To install the latest version from Github:&#xA;# install.packages(&#34;devtools&#34;)&#xA;devtools::install_github(&#34;tylermorganwall/rayshader&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Ubuntu, the following libraries are required:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;libpng-dev libjpeg-dev libfreetype6-dev libglu1-mesa-dev libgl1-mesa-dev pandoc zlib1g-dev libicu-dev libgdal-dev gdal-bin libgeos-dev libproj-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Functions&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/smallfeature.png&#34;&gt; &#xA;&lt;p&gt;Rayshader has seven functions related to mapping:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ray_shade()&lt;/code&gt; uses user specified light directions to calculate a global shadow map for an elevation matrix. By default, this also scales the light intensity at each point by the dot product of the mean ray direction and the surface normal (also implemented in function &lt;code&gt;lamb_shade&lt;/code&gt;, this can be turned off by setting &lt;code&gt;lambert=FALSE&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sphere_shade()&lt;/code&gt; maps an RGB texture to a hillshade by spherical mapping. A texture can be generated with the &lt;code&gt;create_texture&lt;/code&gt; function, or loaded from an image. &lt;code&gt;sphere_shade&lt;/code&gt; also includes 7 built-in palettes: “imhof1”, “imhof2”, “imhof3”, imhof4“,”desert“,”bw“,”unicorn&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ambient_shade()&lt;/code&gt; creates an ambient occlusion shadow layer, darkening areas that have less scattered light from the atmosphere. This results in valleys being darker than flat areas and ridges.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;texture_shade()&lt;/code&gt; calculates a shadow for each point on the surface using the method described by Leland Brown in “Texture Shading: A New Technique for Depicting Terrain Relief.”&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;height_shade()&lt;/code&gt; calculates a color for each point on the surface using a direct elevation-to-color mapping.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lamb_shade()&lt;/code&gt; uses a single user specified light direction to calculate a local shadow map based on the dot product between the surface normal and the light direction for an elevation matrix.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;add_shadow()&lt;/code&gt; takes two of the shadow maps above and combines them, scaling the second one (or, if the second is an RGB array, the matrix) as specified by the user.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;add_overlay()&lt;/code&gt; takes a 3 or 4-layer RGB/RGBA array and overlays it on the current map. If the map includes transparency, this is taken into account when overlaying the image. Otherwise, the user can specify a single color that will be marked as completely transparent, or set the full overlay as partly transparent.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;create_texture()&lt;/code&gt; programmatically creates texture maps given five colors: a highlight, a shadow, a left fill light, a right fill light, and a center color for flat areas. The user can also optionally specify the colors at the corners, but &lt;code&gt;create_texture&lt;/code&gt; will interpolate those if they aren’t given.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Rayshader also has functions to add water and generate overlays:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;detect_water()&lt;/code&gt; uses a flood-fill algorithm to detect bodies of water of a user-specified minimum area.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;add_water()&lt;/code&gt; uses the output of &lt;code&gt;detect_water&lt;/code&gt; to add a water color to the map. The user can input their own color, or pass the name of one of the pre-defined palettes from &lt;code&gt;sphere_shade&lt;/code&gt; to get a matching hue.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate_altitude_overlay()&lt;/code&gt; uses a hillshade and the height map to generate a semi-transparent hillshade whose transparency varies with altitude.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate_compass_overlay()&lt;/code&gt; generates an overlay with a compass.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate_contour_overlay()&lt;/code&gt; calculates and returns an overlay of contour lines.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate_label_overlay()&lt;/code&gt; this uses the &lt;code&gt;maptools::placeLabel()&lt;/code&gt; function to generate labels for the given scene. Either use an &lt;code&gt;sf&lt;/code&gt; object or manually specify the x/y coordinates and label.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate_line_overlay()&lt;/code&gt; generates an overlay of lines, using an &lt;code&gt;sf&lt;/code&gt; object with LINESTRING geometry.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate_point_overlay()&lt;/code&gt; generates an overlay of points, using an &lt;code&gt;sf&lt;/code&gt; object with POINT geometry.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate_polygon_overlay()&lt;/code&gt; generates an overlay of points, using an &lt;code&gt;sf&lt;/code&gt; object with POLYGON geometry.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate_scalebar_overlay()&lt;/code&gt; this function creates an overlay with a scale bar of a user-specified length. It uses the coordinates of the map (specified by passing an extent) and then creates a scale bar at a specified x/y proportion across the map. If the map is not projected (i.e.&amp;nbsp;is in lat/long coordinates) this function will use the &lt;code&gt;geosphere&lt;/code&gt; package to create a scale bar of the proper length.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;generate_waterline_overlay()&lt;/code&gt; generates a semi-transparent waterline overlay to layer onto an existing map using a height map or a boolean matrix.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also included are functions to add additional effects and information to your 3D visualizations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;render_highquality()&lt;/code&gt; renders in the scene with a built-in pathtracer, powered by the &lt;strong&gt;rayrender&lt;/strong&gt; package. Use this for high-quality maps with realistic light transport.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_depth()&lt;/code&gt; generates a depth of field effect for the 3D map. The user can specify the focal distance, focal length, and f-stop of the camera, as well as aperture shape and bokeh intensity. This either plots the image to the local device, or saves it to a file if given a filename.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_label()&lt;/code&gt; adds a text label to the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinate of the map at a specified altitude &lt;code&gt;z&lt;/code&gt; (in units of the matrix). The altitude can either be specified relative to the elevation at that point (the default), or absolutely.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_water()&lt;/code&gt; adds a 3D tranparent water layer to 3D maps, after the rgl device has already been created. This can either add to a map that does not already have a water layer, or replace an existing water layer on the map.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_compass()&lt;/code&gt; places a compass on the map in 3D.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_path()&lt;/code&gt; adds a 3D path to the current scene, using latitude/longitude or coordinates in the reference system defined by the extent object. If no altitude is provided, the path will be elevated a constant offset above the heightmap.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_points()&lt;/code&gt; Adds 3D points to the current scene, using latitude/longitude or coordinates in the reference system defined by the extent object. If no altitude is provided, the points will be elevated a constant offset above the heightmap.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_polygons()&lt;/code&gt; Adds 3D polygons to the current scene, using latitude/longitude or coordinates in the reference system defined by the extent object.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_scalebar()&lt;/code&gt; places a scalebar on the map in 3D.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And several helper functions for converting rasters to matrices:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;raster_to_matrix()&lt;/code&gt; converts a &lt;code&gt;raster&lt;/code&gt; objects into a matrix.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;resize_matrix()&lt;/code&gt; resizes a matrix (preserving contents) by specifying the desired output dimensions or a scaling factor.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And four functions to display and save your visualizations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;plot_map()&lt;/code&gt; Plots the current map. Accepts either a matrix or an array.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;write_png()&lt;/code&gt; Writes the current map to disk with a user-specified filename.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;plot_3d()&lt;/code&gt; Creates a 3D map, given a texture and an elevation matrix. You can customize the appearance of the map, as well as add a user-defined water level.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_camera()&lt;/code&gt; Changes the camera orientation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_snapshot()&lt;/code&gt; Saves an image of the current 3D view to disk (if given a filename), or plots the 3D view to the current device (useful for including images in R Markdown files).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;render_movie()&lt;/code&gt; Creates and saves a mp4/gif file of the camera rotating around the 3D scene by either using a built-in orbit or by using one provided by the user.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Finally, rayshader has a single function to generate 3D plots using ggplot2 objects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;plot_gg()&lt;/code&gt; Takes a ggplot2 object (or a list of two ggplot2 objects) and uses the fill or color aesthetic to transform the plot into a 3D surface. You can pass any of the arguments used to specify the camera and the background/shadow colors in &lt;code&gt;plot_3d()&lt;/code&gt;, and manipulate the displayed 3D plot using &lt;code&gt;render_camera()&lt;/code&gt; and &lt;code&gt;render_depth()&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All of these functions are designed to be used with the magrittr pipe &lt;code&gt;%&amp;gt;%&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Rayshader can be used for two purposes: both creating hillshaded maps and 3D data visualizations plots. First, let’s look at rayshader’s mapping capabilities. For the latter, scroll below.&lt;/p&gt; &#xA;&lt;h2&gt;Mapping with rayshader&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(rayshader)&#xA;&#xA;#Here, I load a map with the raster package.&#xA;loadzip = tempfile() &#xA;download.file(&#34;https://tylermw.com/data/dem_01.tif.zip&#34;, loadzip)&#xA;localtif = raster::raster(unzip(loadzip, &#34;dem_01.tif&#34;))&#xA;unlink(loadzip)&#xA;&#xA;#And convert it to a matrix:&#xA;elmat = raster_to_matrix(localtif)&#xA;&#xA;#We use another one of rayshader&#39;s built-in textures:&#xA;elmat %&amp;gt;%&#xA;  sphere_shade(texture = &#34;desert&#34;) %&amp;gt;%&#xA;  plot_map()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_basicmapping-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#sphere_shade can shift the sun direction:&#xA;elmat %&amp;gt;%&#xA;  sphere_shade(sunangle = 45, texture = &#34;desert&#34;) %&amp;gt;%&#xA;  plot_map()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_basicmapping-2.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#detect_water and add_water adds a water layer to the map:&#xA;elmat %&amp;gt;%&#xA;  sphere_shade(texture = &#34;desert&#34;) %&amp;gt;%&#xA;  add_water(detect_water(elmat), color = &#34;desert&#34;) %&amp;gt;%&#xA;  plot_map()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_basicmapping-3.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#And we can add a raytraced layer from that sun direction as well:&#xA;elmat %&amp;gt;%&#xA;  sphere_shade(texture = &#34;desert&#34;) %&amp;gt;%&#xA;  add_water(detect_water(elmat), color = &#34;desert&#34;) %&amp;gt;%&#xA;  add_shadow(ray_shade(elmat), 0.5) %&amp;gt;%&#xA;  plot_map()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_basicmapping-4.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#And here we add an ambient occlusion shadow layer, which models &#xA;#lighting from atmospheric scattering:&#xA;&#xA;elmat %&amp;gt;%&#xA;  sphere_shade(texture = &#34;desert&#34;) %&amp;gt;%&#xA;  add_water(detect_water(elmat), color = &#34;desert&#34;) %&amp;gt;%&#xA;  add_shadow(ray_shade(elmat), 0.5) %&amp;gt;%&#xA;  add_shadow(ambient_shade(elmat), 0) %&amp;gt;%&#xA;  plot_map()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_basicmapping-5.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;Rayshader also supports 3D mapping by passing a texture map (either external or one produced by rayshader) into the &lt;code&gt;plot_3d&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;elmat %&amp;gt;%&#xA;  sphere_shade(texture = &#34;desert&#34;) %&amp;gt;%&#xA;  add_water(detect_water(elmat), color = &#34;desert&#34;) %&amp;gt;%&#xA;  add_shadow(ray_shade(elmat, zscale = 3), 0.5) %&amp;gt;%&#xA;  add_shadow(ambient_shade(elmat), 0) %&amp;gt;%&#xA;  plot_3d(elmat, zscale = 10, fov = 0, theta = 135, zoom = 0.75, phi = 45, windowsize = c(1000, 800))&#xA;Sys.sleep(0.2)&#xA;render_snapshot()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_three-d-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can add a scale bar, as well as a compass using &lt;code&gt;render_scalebar()&lt;/code&gt; and &lt;code&gt;render_compass()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;render_camera(fov = 0, theta = 60, zoom = 0.75, phi = 45)&#xA;render_scalebar(limits=c(0, 5, 10),label_unit = &#34;km&#34;,position = &#34;W&#34;, y=50,&#xA;                scale_length = c(0.33,1))&#xA;render_compass(position = &#34;E&#34;)&#xA;render_snapshot(clear=TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/scalebar-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;Rayshader also includes the option to add a procedurally-generated cloud layer (and optionally, shadows):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;elmat %&amp;gt;%&#xA;  sphere_shade(texture = &#34;desert&#34;) %&amp;gt;%&#xA;  add_water(detect_water(elmat), color = &#34;lightblue&#34;) %&amp;gt;%&#xA;  add_shadow(cloud_shade(elmat, zscale = 10, start_altitude = 500, end_altitude = 1000,), 0) %&amp;gt;%&#xA;  plot_3d(elmat, zscale = 10, fov = 0, theta = 135, zoom = 0.75, phi = 45, windowsize = c(1000, 800),&#xA;          background=&#34;darkred&#34;)&#xA;render_camera(theta = 20, phi=40,zoom= 0.64, fov= 56 )&#xA;&#xA;render_clouds(elmat, zscale = 10, start_altitude = 800, end_altitude = 1000, attenuation_coef = 2, clear_clouds = T)&#xA;render_snapshot(clear=TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/clouds-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rgl::rgl.clear()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These clouds can be customized:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;elmat %&amp;gt;%&#xA;  sphere_shade(texture = &#34;desert&#34;) %&amp;gt;%&#xA;  add_water(detect_water(elmat), color = &#34;lightblue&#34;) %&amp;gt;%&#xA;  add_shadow(cloud_shade(elmat,zscale = 10, start_altitude = 500, end_altitude = 700, &#xA;                         sun_altitude = 45, attenuation_coef = 2, offset_y = 300,&#xA;              cloud_cover = 0.55, frequency = 0.01, scale_y=3, fractal_levels = 32), 0) %&amp;gt;%&#xA;  plot_3d(elmat, zscale = 10, fov = 0, theta = 135, zoom = 0.75, phi = 45, windowsize = c(1000, 800),&#xA;          background=&#34;darkred&#34;)&#xA;render_camera(theta = 125, phi=22,zoom= 0.47, fov= 60 )&#xA;&#xA;render_clouds(elmat, zscale = 10, start_altitude = 500, end_altitude = 700, &#xA;              sun_altitude = 45, attenuation_coef = 2, offset_y = 300,&#xA;              cloud_cover = 0.55, frequency = 0.01, scale_y=3, fractal_levels = 32, clear_clouds = T)&#xA;render_snapshot(clear=TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/clouds2-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also render using the built-in pathtracer, powered by &lt;a href=&#34;https://www.rayrender.net&#34;&gt;rayrender&lt;/a&gt;. Simply replace &lt;code&gt;render_snapshot()&lt;/code&gt; with &lt;code&gt;render_highquality()&lt;/code&gt;. When &lt;code&gt;render_highquality()&lt;/code&gt; is called, there’s no need to pre-compute the shadows with any of the &lt;code&gt;_shade()&lt;/code&gt; functions, so we remove those:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;elmat %&amp;gt;%&#xA;  sphere_shade(texture = &#34;desert&#34;) %&amp;gt;%&#xA;  add_water(detect_water(elmat), color = &#34;desert&#34;) %&amp;gt;%&#xA;  plot_3d(elmat, zscale = 10, fov = 0, theta = 60, zoom = 0.75, phi = 45, windowsize = c(1000, 800))&#xA;&#xA;render_scalebar(limits=c(0, 5, 10),label_unit = &#34;km&#34;,position = &#34;W&#34;, y=50,&#xA;                scale_length = c(0.33,1))&#xA;&#xA;render_compass(position = &#34;E&#34;)&#xA;Sys.sleep(0.2)&#xA;render_highquality(samples=200, scale_text_size = 24,clear=TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_three-dhq-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also easily add a water layer by setting &lt;code&gt;water = TRUE&lt;/code&gt; in &lt;code&gt;plot_3d()&lt;/code&gt; (and setting &lt;code&gt;waterdepth&lt;/code&gt; if the water level is not 0), or by using the function &lt;code&gt;render_water()&lt;/code&gt; after the 3D map has been rendered. You can customize the appearance and transparancy of the water layer via function arguments. Here’s an example using bathymetric/topographic data of Monterey Bay, CA (included with rayshader):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;montshadow = ray_shade(montereybay, zscale = 50, lambert = FALSE)&#xA;montamb = ambient_shade(montereybay, zscale = 50)&#xA;montereybay %&amp;gt;%&#xA;    sphere_shade(zscale = 10, texture = &#34;imhof1&#34;) %&amp;gt;%&#xA;    add_shadow(montshadow, 0.5) %&amp;gt;%&#xA;    add_shadow(montamb, 0) %&amp;gt;%&#xA;    plot_3d(montereybay, zscale = 50, fov = 0, theta = -45, phi = 45, &#xA;            windowsize = c(1000, 800), zoom = 0.75,&#xA;            water = TRUE, waterdepth = 0, wateralpha = 0.5, watercolor = &#34;lightblue&#34;,&#xA;            waterlinecolor = &#34;white&#34;, waterlinealpha = 0.5)&#xA;Sys.sleep(0.2)&#xA;render_snapshot(clear=TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_three-d-water-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;Water is also supported in &lt;code&gt;render_highquality()&lt;/code&gt;. We load the &lt;code&gt;rayrender&lt;/code&gt; package to change the ground material to include a checker pattern. By default, the camera looks at the origin, but we shift it down slightly to center the map.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(rayrender)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## &#xA;## Attaching package: &#39;rayrender&#39;&#xA;&#xA;## The following object is masked from &#39;package:rgl&#39;:&#xA;## &#xA;##     text3d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;montereybay %&amp;gt;%&#xA;    sphere_shade(zscale = 10, texture = &#34;imhof1&#34;) %&amp;gt;%&#xA;    plot_3d(montereybay, zscale = 50, fov = 70, theta = 270, phi = 30, &#xA;            windowsize = c(1000, 800), zoom = 0.6,  &#xA;            water = TRUE, waterdepth = 0, wateralpha = 0.5, watercolor = &#34;#233aa1&#34;,&#xA;            waterlinecolor = &#34;white&#34;, waterlinealpha = 0.5)&#xA;Sys.sleep(0.2)&#xA;render_highquality(lightdirection = c(-45,45), lightaltitude  = 30, clamp_value = 10, &#xA;                   samples = 256, camera_lookat= c(0,-50,0),&#xA;                   ground_material = diffuse(color=&#34;grey50&#34;,checkercolor = &#34;grey20&#34;, checkerperiod = 100),&#xA;                   clear = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/hq-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;Rayshader also has map shapes other than rectangular included &lt;code&gt;c(&#34;hex&#34;, &#34;circle&#34;)&lt;/code&gt;, and you can customize the map into any shape you want by setting the areas you do not want to display to &lt;code&gt;NA&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;par(mfrow = c(1, 2)) &#xA;montereybay %&amp;gt;% &#xA;    sphere_shade(zscale = 10, texture = &#34;imhof1&#34;) %&amp;gt;% &#xA;    add_shadow(montshadow, 0.5) %&amp;gt;%&#xA;    add_shadow(montamb, 0) %&amp;gt;%&#xA;    plot_3d(montereybay, zscale = 50, fov = 0, theta = -45, phi = 45, windowsize = c(1000, 800), zoom = 0.6,&#xA;            water = TRUE, waterdepth = 0, wateralpha = 0.5, watercolor = &#34;lightblue&#34;,&#xA;            waterlinecolor = &#34;white&#34;, waterlinealpha = 0.5, baseshape = &#34;circle&#34;)&#xA;&#xA;render_snapshot(clear = TRUE)&#xA;&#xA;montereybay %&amp;gt;% &#xA;    sphere_shade(zscale = 10, texture = &#34;imhof1&#34;) %&amp;gt;% &#xA;    add_shadow(montshadow, 0.5) %&amp;gt;%&#xA;    add_shadow(montamb, 0) %&amp;gt;%&#xA;    plot_3d(montereybay, zscale = 50, fov = 0, theta = -45, phi = 45, windowsize = c(1000, 800), zoom = 0.6,&#xA;            water = TRUE, waterdepth = 0, wateralpha = 0.5, watercolor = &#34;lightblue&#34;,&#xA;            waterlinecolor = &#34;white&#34;, waterlinealpha = 0.5, baseshape = &#34;hex&#34;)&#xA;&#xA;render_snapshot(clear = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_three-d-shapes-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;Adding text labels is done with the &lt;code&gt;render_label()&lt;/code&gt; function, which also allows you to customize the line type, color, and size along with the font:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;montereybay %&amp;gt;% &#xA;    sphere_shade(zscale = 10, texture = &#34;imhof1&#34;) %&amp;gt;% &#xA;    add_shadow(montshadow, 0.5) %&amp;gt;%&#xA;    add_shadow(montamb,0) %&amp;gt;%&#xA;    plot_3d(montereybay, zscale = 50, fov = 0, theta = -100, phi = 30, windowsize = c(1000, 800), zoom = 0.6,&#xA;            water = TRUE, waterdepth = 0, waterlinecolor = &#34;white&#34;, waterlinealpha = 0.5,&#xA;            wateralpha = 0.5, watercolor = &#34;lightblue&#34;)&#xA;render_label(montereybay, x = 350, y = 160, z = 1000, zscale = 50,&#xA;             text = &#34;Moss Landing&#34;, textsize = 2, linewidth = 5)&#xA;render_label(montereybay, x = 220, y = 70, z = 7000, zscale = 50,&#xA;             text = &#34;Santa Cruz&#34;, textcolor = &#34;darkred&#34;, linecolor = &#34;darkred&#34;,&#xA;             textsize = 2, linewidth = 5)&#xA;render_label(montereybay, x = 300, y = 270, z = 4000, zscale = 50,&#xA;             text = &#34;Monterey&#34;, dashed = TRUE, textsize = 2, linewidth = 5)&#xA;render_label(montereybay, x = 50, y = 270, z = 1000, zscale = 50,  textcolor = &#34;white&#34;, linecolor = &#34;white&#34;,&#xA;             text = &#34;Monterey Canyon&#34;, relativez = FALSE, textsize = 2, linewidth = 5) &#xA;Sys.sleep(0.2)&#xA;render_snapshot(clear=TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_three-d-labels-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;Labels are also supported in &lt;code&gt;render_highquality()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;render_highquality(samples=256, line_radius = 1, text_size = 18, text_offset = c(0,12,0),&#xA;                   clamp_value=10, clear = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_hqlabels-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;3D paths, points, and polygons can be added directly from spatial objects from the &lt;code&gt;sf&lt;/code&gt; library:&lt;/p&gt; &#xA;&lt;p&gt;Polygons:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;montereybay %&amp;gt;%&#xA;  sphere_shade(texture = &#34;desert&#34;) %&amp;gt;%&#xA;  add_shadow(ray_shade(montereybay,zscale=50)) %&amp;gt;%&#xA;  plot_3d(montereybay,water=TRUE, windowsize=c(1000,800), watercolor=&#34;dodgerblue&#34;)&#xA;render_camera(theta=-60,  phi=60, zoom = 0.85, fov=30)&#xA;&#xA;#We will apply a negative buffer to create space between adjacent polygons:&#xA;sf::sf_use_s2(FALSE) &#xA;mont_county_buff = sf::st_simplify(sf::st_buffer(monterey_counties_sf,-0.003), dTolerance=0.004)&#xA;&#xA;render_polygons(mont_county_buff,  &#xA;                extent = attr(montereybay,&#34;extent&#34;), data_column_top = &#34;ALAND&#34;,&#xA;                scale_data = 300/(2.6E9), color=&#34;chartreuse4&#34;,&#xA;                parallel=TRUE)&#xA;render_highquality(clamp_value=10,samples=256)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_polygon-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;render_polygons(clear_previous = TRUE)&#xA;render_camera(theta=225, phi=30,zoom=0.37,fov=48)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Points:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;moss_landing_coord = c(36.806807, -121.793332) &#xA;x_vel_out = -0.001 + rnorm(1000)[1:500]/1000&#xA;y_vel_out = rnorm(1000)[1:500]/200&#xA;z_out = c(seq(0,2000,length.out = 180), seq(2000,0,length.out=10), &#xA;          seq(0,2000,length.out = 100), seq(2000,0,length.out=10))&#xA;&#xA;bird_track_lat = list()&#xA;bird_track_long = list()&#xA;bird_track_lat[[1]] = moss_landing_coord[1]&#xA;bird_track_long[[1]] = moss_landing_coord[2]&#xA;&#xA;for(i in 2:500) {&#xA;  bird_track_lat[[i]] = bird_track_lat[[i-1]] + y_vel_out[i]&#xA;  bird_track_long[[i]] = bird_track_long[[i-1]] + x_vel_out[i]&#xA;}&#xA;&#xA;render_points(extent = attr(montereybay,&#34;extent&#34;), &#xA;              lat = unlist(bird_track_lat), long = unlist(bird_track_long), &#xA;              altitude = z_out, zscale=50, color=&#34;red&#34;)&#xA;render_highquality(point_radius = 1, samples = 256)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_points-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;render_points(clear_previous = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Paths:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;render_path(extent = attr(montereybay,&#34;extent&#34;),  &#xA;            lat = unlist(bird_track_lat), long = unlist(bird_track_long), &#xA;            altitude = z_out, zscale=50,color=&#34;white&#34;, antialias=TRUE)&#xA;render_highquality(line_radius = 1,samples=256, clear=TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_paths-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also apply a post-processing effect to the 3D maps to render maps with depth of field with the &lt;code&gt;render_depth()&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;elmat %&amp;gt;%&#xA;  sphere_shade(texture = &#34;desert&#34;) %&amp;gt;%&#xA;  add_water(detect_water(elmat), color = &#34;desert&#34;) %&amp;gt;%&#xA;  add_shadow(ray_shade(elmat, zscale = 3), 0.5) %&amp;gt;%&#xA;  add_shadow(ambient_shade(elmat), 0) %&amp;gt;%&#xA;  plot_3d(elmat, zscale = 10, fov = 30, theta = -225, phi = 25, windowsize = c(1000, 800), zoom = 0.3)&#xA;Sys.sleep(0.2)&#xA;render_depth(focallength = 800, clear = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## Focus distance: 1732.75&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_three-d-depth-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;h2&gt;3D plotting with rayshader and ggplot2&lt;/h2&gt; &#xA;&lt;p&gt;Rayshader can also be used to make 3D plots out of ggplot2 objects using the &lt;code&gt;plot_gg()&lt;/code&gt; function. Here, I turn a color density plot into a 3D density plot. &lt;code&gt;plot_gg()&lt;/code&gt; detects that the user mapped the &lt;code&gt;fill&lt;/code&gt; aesthetic to color and uses that information to project the figure into 3D.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## &#xA;## Attaching package: &#39;ggplot2&#39;&#xA;&#xA;## The following object is masked from &#39;package:rayrender&#39;:&#xA;## &#xA;##     arrow&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggdiamonds = ggplot(diamonds) +&#xA;  stat_density_2d(aes(x = x, y = depth, fill = stat(nlevel)), &#xA;                  geom = &#34;polygon&#34;, n = 200, bins = 50,contour = TRUE) +&#xA;  facet_wrap(clarity~.) +&#xA;  scale_fill_viridis_c(option = &#34;A&#34;)&#xA;&#xA;par(mfrow = c(1, 2))&#xA;&#xA;plot_gg(ggdiamonds, width = 5, height = 5, raytrace = FALSE, preview = TRUE)&#xA;plot_gg(ggdiamonds, width = 5, height = 5, multicore = TRUE, scale = 250, &#xA;        zoom = 0.7, theta = 10, phi = 30, windowsize = c(800, 800))&#xA;Sys.sleep(0.2)&#xA;render_snapshot(clear = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_ggplots-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;Rayshader will automatically ignore lines and other elements that should not be mapped to 3D. Here’s a contour plot of the &lt;code&gt;volcano&lt;/code&gt; dataset.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(reshape2)&#xA;#Contours and other lines will automatically be ignored. Here is the volcano dataset:&#xA;&#xA;ggvolcano = volcano %&amp;gt;% &#xA;  melt() %&amp;gt;%&#xA;  ggplot() +&#xA;  geom_tile(aes(x = Var1, y = Var2, fill = value)) +&#xA;  geom_contour(aes(x = Var1, y = Var2, z = value), color = &#34;black&#34;) +&#xA;  scale_x_continuous(&#34;X&#34;, expand = c(0, 0)) +&#xA;  scale_y_continuous(&#34;Y&#34;, expand = c(0, 0)) +&#xA;  scale_fill_gradientn(&#34;Z&#34;, colours = terrain.colors(10)) +&#xA;  coord_fixed()&#xA;&#xA;par(mfrow = c(1, 2))&#xA;plot_gg(ggvolcano, width = 7, height = 4, raytrace = FALSE, preview = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## Warning: Removed 1861 row(s) containing missing values (geom_path).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot_gg(ggvolcano, multicore = TRUE, raytrace = TRUE, width = 7, height = 4, &#xA;        scale = 300, windowsize = c(1400, 866), zoom = 0.6, phi = 30, theta = 30)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## Warning: Removed 1861 row(s) containing missing values (geom_path).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Sys.sleep(0.2)&#xA;&#xA;render_snapshot(clear = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_ggplots_2-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;Rayshader also detects when the user passes the &lt;code&gt;color&lt;/code&gt; aesthetic, and maps those values to 3D. If both &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;fill&lt;/code&gt; are passed, however, rayshader will default to &lt;code&gt;fill&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mtplot = ggplot(mtcars) + &#xA;  geom_point(aes(x = mpg, y = disp, color = cyl)) + &#xA;  scale_color_continuous(limits = c(0, 8))&#xA;&#xA;par(mfrow = c(1, 2))&#xA;plot_gg(mtplot, width = 3.5, raytrace = FALSE, preview = TRUE)&#xA;&#xA;plot_gg(mtplot, width = 3.5, multicore = TRUE, windowsize = c(800, 800), &#xA;        zoom = 0.85, phi = 35, theta = 30, sunangle = 225, soliddepth = -100)&#xA;Sys.sleep(0.2)&#xA;render_snapshot(clear = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_ggplots_3-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;Utilize combinations of line color and fill to create different effects. Here is a terraced hexbin plot, created by mapping the line colors of the hexagons to black.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a = data.frame(x = rnorm(20000, 10, 1.9), y = rnorm(20000, 10, 1.2))&#xA;b = data.frame(x = rnorm(20000, 14.5, 1.9), y = rnorm(20000, 14.5, 1.9))&#xA;c = data.frame(x = rnorm(20000, 9.5, 1.9), y = rnorm(20000, 15.5, 1.9))&#xA;data = rbind(a, b, c)&#xA;&#xA;#Lines&#xA;pp = ggplot(data, aes(x = x, y = y)) +&#xA;  geom_hex(bins = 20, size = 0.5, color = &#34;black&#34;) +&#xA;  scale_fill_viridis_c(option = &#34;C&#34;)&#xA;&#xA;par(mfrow = c(1, 2))&#xA;plot_gg(pp, width = 5, height = 4, scale = 300, raytrace = FALSE, preview = TRUE)&#xA;plot_gg(pp, width = 5, height = 4, scale = 300, multicore = TRUE, windowsize = c(1000, 800))&#xA;render_camera(fov = 70, zoom = 0.5, theta = 130, phi = 35)&#xA;Sys.sleep(0.2)&#xA;render_snapshot(clear = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_ggplots_4-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also use the &lt;code&gt;render_depth()&lt;/code&gt; function to direct the viewer’s focus to a important areas in the figure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;par(mfrow = c(1, 1))&#xA;plot_gg(pp, width = 5, height = 4, scale = 300, multicore = TRUE, windowsize = c(1200, 960),&#xA;        fov = 70, zoom = 0.4, theta = 330, phi = 40)&#xA;Sys.sleep(0.2)&#xA;render_depth(focallength = 100,clear=TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## Focus distance: 2001.41&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_ggplots_5-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;Finally, you can increase the allowable error in triangulating the model to vastly reduce the size. Here, we reduce the model to 1/100th of it’s raw (un-triangulated) size, while maintaining model quality. This can improve the performance when rendering 3D ggplots with &lt;code&gt;render_highquality()&lt;/code&gt;, as well as improve performance on slower computers. This triangulation is powered by the {terrainmeshr} package.&lt;/p&gt; &#xA;&lt;p&gt;Here, we make a 3D ggplot out of glass, using a triangulated model and &lt;code&gt;render_highquality()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tempfilehdr = tempfile(fileext = &#34;.hdr&#34;)&#xA;download.file(&#34;https://www.tylermw.com/data/venice_sunset_2k.hdr&#34;,tempfilehdr)&#xA;&#xA;par(mfrow = c(1, 1))&#xA;plot_gg(pp, width = 5, height = 4, scale = 300, raytrace = FALSE, windowsize = c(1200, 960),&#xA;        fov = 70, zoom = 0.4, theta = 330, phi = 20,  max_error = 0.01, verbose = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## 98.8% reduction: Number of triangles reduced from 3600000 to 43606. Error: 0.009982&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Sys.sleep(0.2)&#xA;render_highquality(samples = 256, aperture=30, light = FALSE, focal_distance = 1700,&#xA;                   obj_material = rayrender::dielectric(attenuation = c(1,1,0.3)/200), &#xA;                   ground_material = rayrender::diffuse(checkercolor = &#34;grey80&#34;,sigma=90,checkerperiod = 100),&#xA;                   environment_light = tempfilehdr, camera_lookat = c(0,-150,0))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/rayshader/master/man/figures/README_ggplots_6-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>grantmcdermott/etwfe</title>
    <updated>2022-10-24T01:38:11Z</updated>
    <id>tag:github.com,2022-10-24:/grantmcdermott/etwfe</id>
    <link href="https://github.com/grantmcdermott/etwfe" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Extended two-way fixed effects&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Extended two-way fixed effects (ETWFE)&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/grantmcdermott/etwfe/actions/workflows/R-CMD-check.yaml&#34;&gt;&lt;img src=&#34;https://github.com/grantmcdermott/etwfe/actions/workflows/R-CMD-check.yaml/badge.svg?sanitize=true&#34; alt=&#34;R-CMD-check&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;The goal of &lt;strong&gt;etwfe&lt;/strong&gt; is to estimate extended (Mundlak) two-way fixed effects &lt;em&gt;a la&lt;/em&gt; &lt;a href=&#34;https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3906345&#34;&gt;Wooldridge (2021)&lt;/a&gt;. Briefly, Wooldridge proposes a set of saturated interaction effects to overcome the potential bias problems of vanilla TWFE in difference-in-differences designs. The Wooldridge solution is intuitive and elegant, but rather tedious and error prone to code up manually. This package aims to simplify the process by providing convenience functions that do the work for you. &lt;strong&gt;etwfe&lt;/strong&gt; thus provides an R equivalent of the &lt;a href=&#34;https://ideas.repec.org/c/boc/bocode/s459114.html&#34;&gt;&lt;code&gt;JWDID&lt;/code&gt;&lt;/a&gt; Stata module and, indeed, shares some of the core design elements (albeit with some internal differences).&lt;/p&gt; &#xA;&lt;p&gt;While I’ve tested &lt;strong&gt;ewtfe&lt;/strong&gt; against common use cases, please note that the package is still under early development and should be considered experimental. I plan (hope) to add some more features and the documentation could also be improved. You can help by identifying any bugs and filing issues.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install the development version of &lt;strong&gt;etwfe&lt;/strong&gt; from &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;remotes&#34;)&#xA;remotes::install_github(&#34;grantmcdermott/etwfe&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;To demonstrate the core functionality of &lt;strong&gt;etwfe&lt;/strong&gt;, we’ll use the &lt;code&gt;mpdta&lt;/code&gt; dataset from the &lt;strong&gt;did&lt;/strong&gt; package (which you’ll need to install separately).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;did&#34;)&#xA;data(&#34;mpdta&#34;, package = &#34;did&#34;)&#xA;head(mpdta)&#xA;#&amp;gt;     year countyreal     lpop     lemp first.treat treat&#xA;#&amp;gt; 866 2003       8001 5.896761 8.461469        2007     1&#xA;#&amp;gt; 841 2004       8001 5.896761 8.336870        2007     1&#xA;#&amp;gt; 842 2005       8001 5.896761 8.340217        2007     1&#xA;#&amp;gt; 819 2006       8001 5.896761 8.378161        2007     1&#xA;#&amp;gt; 827 2007       8001 5.896761 8.487352        2007     1&#xA;#&amp;gt; 937 2003       8019 2.232377 4.997212        2007     1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now let’s see a simple example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(etwfe)&#xA;&#xA;mod = &#xA;  etwfe(&#xA;    fml  = lemp ~ lpop, # outcome ~ controls&#xA;    tvar = year,        # time variable&#xA;    gvar = first.treat, # group variable&#xA;    data = mpdta,       # dataset&#xA;    vcov = ~countyreal  # vcov adjustment (here: clustered)&#xA;    )&#xA;&#xA;mod&#xA;#&amp;gt; OLS estimation, Dep. Var.: lemp&#xA;#&amp;gt; Observations: 2,500 &#xA;#&amp;gt; Fixed-effects: first.treat: 4,  year: 5&#xA;#&amp;gt; Varying slopes: lpop (first.treat: 4),  lpop (year: 5)&#xA;#&amp;gt; Standard-errors: Clustered (countyreal) &#xA;#&amp;gt;                                               Estimate Std. Error   t value   Pr(&amp;gt;|t|)    &#xA;#&amp;gt; .Dtreat:first.treat::2004:year::2004         -0.021248   0.021728 -0.977890 3.2860e-01    &#xA;#&amp;gt; .Dtreat:first.treat::2004:year::2005         -0.081850   0.027375 -2.989963 2.9279e-03 ** &#xA;#&amp;gt; .Dtreat:first.treat::2004:year::2006         -0.137870   0.030795 -4.477097 9.3851e-06 ***&#xA;#&amp;gt; .Dtreat:first.treat::2004:year::2007         -0.109539   0.032322 -3.389024 7.5694e-04 ***&#xA;#&amp;gt; .Dtreat:first.treat::2006:year::2006          0.002537   0.018883  0.134344 8.9318e-01    &#xA;#&amp;gt; .Dtreat:first.treat::2006:year::2007         -0.045093   0.021987 -2.050907 4.0798e-02 *  &#xA;#&amp;gt; .Dtreat:first.treat::2007:year::2007         -0.045955   0.017975 -2.556568 1.0866e-02 *  &#xA;#&amp;gt; .Dtreat:first.treat::2004:year::2004:lpop_dm  0.004628   0.017584  0.263184 7.9252e-01    &#xA;#&amp;gt; .Dtreat:first.treat::2004:year::2005:lpop_dm  0.025113   0.017904  1.402661 1.6134e-01    &#xA;#&amp;gt; .Dtreat:first.treat::2004:year::2006:lpop_dm  0.050735   0.021070  2.407884 1.6407e-02 *  &#xA;#&amp;gt; .Dtreat:first.treat::2004:year::2007:lpop_dm  0.011250   0.026617  0.422648 6.7273e-01    &#xA;#&amp;gt; .Dtreat:first.treat::2006:year::2006:lpop_dm  0.038935   0.016472  2.363731 1.8474e-02 *  &#xA;#&amp;gt; .Dtreat:first.treat::2006:year::2007:lpop_dm  0.038060   0.022477  1.693276 9.1027e-02 .  &#xA;#&amp;gt; .Dtreat:first.treat::2007:year::2007:lpop_dm -0.019835   0.016198 -1.224528 2.2133e-01    &#xA;#&amp;gt; ... 10 variables were removed because of collinearity (.Dtreat:first.treat::2006:year::2004, .Dtreat:first.treat::2006:year::2005 and 8 others [full set in $collin.var])&#xA;#&amp;gt; ---&#xA;#&amp;gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1&#xA;#&amp;gt; RMSE: 0.537131     Adj. R2: 0.87167 &#xA;#&amp;gt;                  Within R2: 8.449e-4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can perhaps tell, &lt;code&gt;etwfe()&lt;/code&gt; is effectively a wrapper around &lt;code&gt;fixest::feols()&lt;/code&gt; here.[^1] The resulting object is thus fully compatible with other &lt;strong&gt;fixest&lt;/strong&gt; methods and functions like &lt;code&gt;etable()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fixest::etable(mod, signif.code = NA)&#xA;#&amp;gt;                                                                   mod&#xA;#&amp;gt; Dependent Var.:                                                  lemp&#xA;#&amp;gt;                                                                      &#xA;#&amp;gt; .Dtreat x first.treat = 2004 x year = 2004           -0.0213 (0.0217)&#xA;#&amp;gt; .Dtreat x first.treat = 2004 x year = 2005           -0.0819 (0.0274)&#xA;#&amp;gt; .Dtreat x first.treat = 2004 x year = 2006           -0.1379 (0.0308)&#xA;#&amp;gt; .Dtreat x first.treat = 2004 x year = 2007           -0.1095 (0.0323)&#xA;#&amp;gt; .Dtreat x first.treat = 2006 x year = 2006            0.0025 (0.0189)&#xA;#&amp;gt; .Dtreat x first.treat = 2006 x year = 2007           -0.0451 (0.0220)&#xA;#&amp;gt; .Dtreat x first.treat = 2007 x year = 2007           -0.0459 (0.0180)&#xA;#&amp;gt; .Dtreat x lpop_dm x first.treat = 2004 x year = 2004  0.0046 (0.0176)&#xA;#&amp;gt; .Dtreat x lpop_dm x first.treat = 2004 x year = 2005  0.0251 (0.0179)&#xA;#&amp;gt; .Dtreat x lpop_dm x first.treat = 2004 x year = 2006  0.0507 (0.0211)&#xA;#&amp;gt; .Dtreat x lpop_dm x first.treat = 2004 x year = 2007  0.0112 (0.0266)&#xA;#&amp;gt; .Dtreat x lpop_dm x first.treat = 2006 x year = 2006  0.0389 (0.0165)&#xA;#&amp;gt; .Dtreat x lpop_dm x first.treat = 2006 x year = 2007  0.0381 (0.0225)&#xA;#&amp;gt; .Dtreat x lpop_dm x first.treat = 2007 x year = 2007 -0.0198 (0.0162)&#xA;#&amp;gt; Fixed-Effects:                                       ----------------&#xA;#&amp;gt; first.treat                                                       Yes&#xA;#&amp;gt; year                                                              Yes&#xA;#&amp;gt; Varying Slopes:                                      ----------------&#xA;#&amp;gt; lpop (first.treat)                                                Yes&#xA;#&amp;gt; lpop (year)                                                       Yes&#xA;#&amp;gt; ________________________________________             ________________&#xA;#&amp;gt; S.E.: Clustered                                        by: countyreal&#xA;#&amp;gt; Observations                                                    2,500&#xA;#&amp;gt; R2                                                            0.87321&#xA;#&amp;gt; Within R2                                                     0.00084&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While everyone likes a nice regression table, the raw coefficients from an &lt;code&gt;etwfe()&lt;/code&gt; estimation are not necessarily meaningful in of themselves. Instead, we probably want to aggregate them along some dimension of interest (e.g., an event study). A natural way to perform these aggregations is by calculating marginal effects. The &lt;strong&gt;etwfe&lt;/strong&gt; package provides another convenience function for doing this, &lt;code&gt;emfx()&lt;/code&gt;, which is itself a thin(ish) wrapper around &lt;code&gt;marginaleffects::marginaleffects()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Other type options incl. &#34;simple&#34; (default), &#34;calendar&#34;, and &#34;group&#34;&#xA;emfx(mod, type = &#34;event&#34;)&#xA;#&amp;gt;      Term    Contrast event   Effect Std. Error z value   Pr(&amp;gt;|z|)    2.5 %   97.5 %&#xA;#&amp;gt; 1 .Dtreat mean(dY/dX)     0 -0.03321    0.01337  -2.484 0.01297951 -0.05941 -0.00701&#xA;#&amp;gt; 2 .Dtreat mean(dY/dX)     1 -0.05735    0.01715  -3.343 0.00082830 -0.09097 -0.02373&#xA;#&amp;gt; 3 .Dtreat mean(dY/dX)     2 -0.13787    0.03079  -4.477 7.5665e-06 -0.19823 -0.07751&#xA;#&amp;gt; 4 .Dtreat mean(dY/dX)     3 -0.10954    0.03232  -3.389 0.00070142 -0.17289 -0.04619&#xA;#&amp;gt; &#xA;#&amp;gt; Model type:  etwfe &#xA;#&amp;gt; Prediction type:  response&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/jmwooldridge&#34;&gt;Jeffrey Wooldridge&lt;/a&gt; for the &lt;a href=&#34;https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3906345&#34;&gt;underlying theory&lt;/a&gt; behind ETWFE.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/lrberge&#34;&gt;Laurent Bergé&lt;/a&gt; (&lt;a href=&#34;https://lrberge.github.io/fixest/&#34;&gt;&lt;strong&gt;fixest&lt;/strong&gt;&lt;/a&gt;) and &lt;a href=&#34;https://twitter.com/VincentAB&#34;&gt;Vincent Arel-Bundock&lt;/a&gt; (&lt;a href=&#34;https://vincentarelbundock.github.io/marginaleffects&#34;&gt;&lt;strong&gt;marginaleffects&lt;/strong&gt;&lt;/a&gt;) for maintaining the two wonderful R packages that do most of the heavy lifting under the hood here.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/friosavila&#34;&gt;Fernando Rios-Avila&lt;/a&gt; for the &lt;a href=&#34;https://ideas.repec.org/c/boc/bocode/s459114.html&#34;&gt;&lt;code&gt;JWDID&lt;/code&gt;&lt;/a&gt; Stata module, which has provided a welcome foil for unit testing and whose elegant design helped inform my own choices for this R equivalent.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[^1]: See the &lt;code&gt;?etwfe&lt;/code&gt; helpfile for information about other function arguments that can be used to customize the underlying estimation. There are many options, from defining bespoke reference groups to support for nonlinear models (e.g., logit and Poisson).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cran/spmodel</title>
    <updated>2022-10-24T01:38:11Z</updated>
    <id>tag:github.com,2022-10-24:/cran/spmodel</id>
    <link href="https://github.com/cran/spmodel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;❗ This is a read-only mirror of the CRAN R package repository. spmodel — Spatial Statistical Modeling and Prediction&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;spmodel: Spatial Statistical Modeling and Prediction&lt;/h1&gt; &#xA;&lt;p&gt;spmodel is an R package used to fit, summarize, and predict for a variety spatial of statistical models. Parameters are estimated using various methods. Additional modeling features include anisotropy, random effects, partition factors, big data approaches, and more. Model-fit statistics are used to summarize, visualize, and compare models. Predictions at unobserved locations are readily obtainable.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Install and load the most recent approved version from CRAN by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install the most recent approved version from CRAN&#xA;install.packages(&#34;spmodel&#34;)&#xA;# load the most recent approved version from CRAN&#xA;library(spmodel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install and load the most recent development version of&lt;code&gt;spmodel&lt;/code&gt; from GitHub by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Installing from GitHub requires you first install the remotes package&#xA;install.packages(&#34;remotes&#34;)&#xA;&#xA;# install the most recent development version from GitHub&#xA;remotes::install_github(&#34;USEPA/spmodel&#34;, ref = &#34;main&#34;)&#xA;# load the most recent development version from GitHub&#xA;library(spmodel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install the most recent development version of &lt;code&gt;spmodel&lt;/code&gt; from GitHub with package vignettes by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install the most recent development version from GitHub with package vignettes&#xA;devtools::install_github(&#34;USEPA/spmodel&#34;, ref = &#34;main&#34;, build_vignettes=TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;View the vignettes in RStudio by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vignette(&#34;basics&#34;, &#34;spmodel&#34;) # an overview of basic features&#xA;vignette(&#34;guide&#34;, &#34;spmodel&#34;) # a detailed guide with to spmodel&#xA;vignette(&#34;technical&#34;, &#34;spmodel&#34;) # technical details regarding many functions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Further detail regarding spmodel is contained in the package&#39;s documentation manual.&lt;/p&gt; &#xA;&lt;h2&gt;Citation&lt;/h2&gt; &#xA;&lt;p&gt;If you use spmodel in a formal publication or report, please cite it. Citing spmodel lets us devote more resources to it in the future. View the spmodel citation by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;citation(package = &#34;spmodel&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;#&amp;gt; &#xA;#&amp;gt; To cite spmodel in publications use:&#xA;#&amp;gt; &#xA;#&amp;gt;   Dumelle, Michael., Higham, Matt., and Ver Hoef, Jay M. (2022).&#xA;#&amp;gt;   spmodel: Spatial Statistical Modeling and Prediction. R package version 0.1.1.&#xA;#&amp;gt; &#xA;#&amp;gt; A BibTeX entry for LaTeX users is&#xA;#&amp;gt; &#xA;#&amp;gt;   @Manual{,&#xA;#&amp;gt;     title = {spmodel: Spatial Statistical Modeling and Prediction},&#xA;#&amp;gt;     author = {Michael Dumelle and Matt Higham and Jay M. {Ver Hoef}},&#xA;#&amp;gt;     year = {2022},&#xA;#&amp;gt;     note = {R package version 0.1.1},&#xA;#&amp;gt;   }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Code Coverage&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://cran.r-project.org/package=covr&#34;&gt;covr&lt;/a&gt; package measures the percentage of code being exercised by a set of tests as an indirect measure of test quality and completeness. spmodel&#39;s code coverage is 95.81%.&lt;/p&gt; &#xA;&lt;h2&gt;Package Contributions&lt;/h2&gt; &#xA;&lt;p&gt;We encourage users submit GitHub issues and enhancement requests so we may continue to improve spmodel.&lt;/p&gt; &#xA;&lt;h2&gt;EPA Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;The United States Environmental Protection Agency (EPA) GitHub project code is provided on an &#34;as is&#34; basis and the user assumes responsibility for its use. EPA has relinquished control of the information and no longer has responsibility to protect the integrity , confidentiality, or availability of the information. Any reference to specific commercial products, processes, or services by service mark, trademark, manufacturer, or otherwise, does not constitute or imply their endorsement, recommendation or favoring by EPA. The EPA seal and logo shall not be used in any manner to imply endorsement of any commercial product or activity by EPA or the United States Government.&lt;/p&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;This project is licensed under the GNU General Public License, &lt;a href=&#34;https://cran.r-project.org/web/licenses/GPL-3&#34;&gt;GPL-3&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>