<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-31T01:38:26Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>moodymudskipper/typed</title>
    <updated>2022-08-31T01:38:26Z</updated>
    <id>tag:github.com,2022-08-31:/moodymudskipper/typed</id>
    <link href="https://github.com/moodymudskipper/typed" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Support Types for Variables, Arguments, and Return Values&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.com/moodymudskipper/typed&#34;&gt;&lt;img src=&#34;https://travis-ci.com/moodymudskipper/typed.svg?branch=iteration2&#34; alt=&#34;Travis build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/moodymudskipper/typed?branch=master&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/moodymudskipper/typed/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;Codecov test coverage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;h1&gt;typed &lt;img src=&#34;https://raw.githubusercontent.com/moodymudskipper/typed/master/man/figures/logo.png&#34; align=&#34;right&#34; height=&#34;139&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;{typed}&lt;/em&gt; implements a type system for R, it has 3 main features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;set variable types in a script or the body of a function, so they can’t be assigned illegal values&lt;/li&gt; &#xA; &lt;li&gt;set argument types in a function definition&lt;/li&gt; &#xA; &lt;li&gt;set return type of a function&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The user can define their own types, or leverage assertions from other packages.&lt;/p&gt; &#xA;&lt;p&gt;Under the hood variable types use active bindings, so once a variable is restricted by an assertion, it cannot be modified in a way that would not satisfy it.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install CRAN version with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#34;typed&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or development version with :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;remotes::install_github(&#34;moodymudskipper/typed&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And attach with :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# masking warning about overriding `?`&#xA;library(typed, warn.conflicts = FALSE) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Set variable type&lt;/h2&gt; &#xA;&lt;h3&gt;Question mark notation and &lt;code&gt;declare&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Here are examples on how we would set types&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Character() ? x # restrict x to &#34;character&#34; type&#xA;x &amp;lt;- &#34;a&#34;&#xA;x&#xA;#&amp;gt; [1] &#34;a&#34;&#xA;&#xA;Integer(3) ? y &amp;lt;- 1:3 # restrict y to &#34;integer&#34; type of length 3&#xA;y&#xA;#&amp;gt; [1] 1 2 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We cannot assign values of the wrong type to &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; anymore.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 2&#xA;#&amp;gt; Error: type mismatch&#xA;#&amp;gt; `typeof(value)`: &#34;double&#34;   &#xA;#&amp;gt; `expected`:      &#34;character&#34;&#xA;&#xA;y &amp;lt;- 4:5&#xA;#&amp;gt; Error: length mismatch&#xA;#&amp;gt; `length(value)`: 2&#xA;#&amp;gt;      `expected`: 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But the right type will work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(&#34;b&#34;, &#34;c&#34;)&#xA;&#xA;y &amp;lt;- c(1L, 10L, 100L)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;declare&lt;/code&gt; is a strict equivalent, slightly more efficient, which looks like &lt;code&gt;base::assign&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;declare(&#34;x&#34;, Character())&#xA;x &amp;lt;- &#34;a&#34;&#xA;x&#xA;#&amp;gt; [1] &#34;a&#34;&#xA;&#xA;declare(&#34;y&#34;, Integer(3), 1:3)&#xA;y&#xA;#&amp;gt; [1] 1 2 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Assertion factories and assertions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;Character&lt;/code&gt; are function factories (functions that return functions), thus &lt;code&gt;Integer(3)&lt;/code&gt; and &lt;code&gt;Character()&lt;/code&gt; are functions.&lt;/p&gt; &#xA;&lt;p&gt;The latter functions operate checks on a value and in case of success return this value, generally unmodified. For instance :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Integer(3)(1:2)&#xA;#&amp;gt; Error: length mismatch&#xA;#&amp;gt; `length(value)`: 2&#xA;#&amp;gt;      `expected`: 3&#xA;&#xA;Character()(3)&#xA;#&amp;gt; Error: type mismatch&#xA;#&amp;gt; `typeof(value)`: &#34;double&#34;   &#xA;#&amp;gt; `expected`:      &#34;character&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We call &lt;code&gt;Integer(3)&lt;/code&gt; and &lt;code&gt;Character()&lt;/code&gt; assertions, and we call &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;Character&lt;/code&gt; assertion factories.&lt;/p&gt; &#xA;&lt;p&gt;The package contains many assertion factories (see &lt;code&gt;?assertion_factories&lt;/code&gt;), the main ones are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Any&lt;/code&gt; (No default restriction)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Logical&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Character&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;List&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Environment&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Factor&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Matrix&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Data.frame&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Time&lt;/code&gt; (POSIXct)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Custom assertions&lt;/h3&gt; &#xA;&lt;p&gt;As we’ve seen with &lt;code&gt;Integer(3)&lt;/code&gt;, passing arguments to a assertion factory restricts the type.&lt;/p&gt; &#xA;&lt;p&gt;For instance &lt;code&gt;Integer&lt;/code&gt; has arguments &lt;code&gt;length&lt;/code&gt; &lt;code&gt;null_ok&lt;/code&gt; and &lt;code&gt;...&lt;/code&gt;, we already used &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;null_ok&lt;/code&gt; is convenient to allow a default &lt;code&gt;NULL&lt;/code&gt; value in addition to the &lt;code&gt;&#34;integer&#34;&lt;/code&gt; type. In the dots we can use arguments named as functions and with the value of the expected result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Integer(anyNA = FALSE) ? x &amp;lt;- c(1L, 2L, NA)&#xA;#&amp;gt; Error: `anyNA` mismatch&#xA;#&amp;gt; `anyNA(value)`: TRUE &#xA;#&amp;gt; `expected`:     FALSE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Useful arguments might be for instance, &lt;code&gt;anyDuplicated = 0L&lt;/code&gt;, &lt;code&gt;names = NULL&lt;/code&gt;, &lt;code&gt;attributes = NULL&lt;/code&gt;… Any available function can be used.&lt;/p&gt; &#xA;&lt;p&gt;That makes assertion factories very flexible! If it is still not flexible enough, one can provide conditions using formulas in the &lt;code&gt;...&lt;/code&gt;. Be careful to skip all named arguments by adding comas, or name the formula arguments &lt;code&gt;...&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fruit &amp;lt;- Character(1, ... = &#34;`value` is not a fruit!&#34; ~ . %in% c(&#34;apple&#34;, &#34;pear&#34;, &#34;cherry&#34;))&#xA;&#xA;fruit ? x &amp;lt;- &#34;potatoe&#34;&#xA;#&amp;gt; Error: `value` is not a fruit!&#xA;#&amp;gt; `value %in% c(&#34;apple&#34;, &#34;pear&#34;, &#34;cherry&#34;)`: FALSE&#xA;#&amp;gt; `expected`:                                TRUE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The arguments can differ between assertion factories, for instance &lt;code&gt;Data.frame&lt;/code&gt; has &lt;code&gt;nrow&lt;/code&gt;, &lt;code&gt;ncol&lt;/code&gt;, &lt;code&gt;each&lt;/code&gt;, &lt;code&gt;null_ok&lt;/code&gt; and &lt;code&gt;...&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Data.frame() ? x &amp;lt;- iris&#xA;Data.frame(ncol = 2) ? x &amp;lt;- iris&#xA;#&amp;gt; Error: Column number mismatch&#xA;#&amp;gt; `ncol(value)`: 5&#xA;#&amp;gt;    `expected`: 2&#xA;Data.frame(each = Double()) ? x &amp;lt;- iris&#xA;#&amp;gt; Error: column 5 (&#34;Species&#34;) type mismatch&#xA;#&amp;gt; `typeof(value)`: &#34;integer&#34;&#xA;#&amp;gt; `expected`:      &#34;double&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Leverage assertions from other packages, build your own assertion factories&lt;/h3&gt; &#xA;&lt;p&gt;Some great packages provide assertions, and they can be used with &lt;code&gt;typed&lt;/code&gt; provided that they take the object as a first input and return the object if no failure. Richie Cotton’s &lt;em&gt;{assertive}&lt;/em&gt; and Michel Lang’s &lt;em&gt;{checkmate}&lt;/em&gt; both qualify.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(assertive)&#xA;assert_is_monotonic_increasing ? z&#xA;z &amp;lt;- 3:1&#xA;#&amp;gt; Error: is_monotonic_increasing : The values of assigned_value are not monotonic increasing.&#xA;#&amp;gt;   Position ValueBefore ValueAfter&#xA;#&amp;gt; 1      1/2           3          2&#xA;#&amp;gt; 2      2/3           2          1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to use more than the first argument, we should create an assertion factory :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Monotonic_incr &amp;lt;- as_assertion_factory(assert_is_monotonic_increasing)&#xA;Monotonic_incr(strictly = TRUE) ? z&#xA;z &amp;lt;- c(1, 1, 2)&#xA;#&amp;gt; Error: is_monotonic_increasing : The values of value are not strictly monotonic increasing.&#xA;#&amp;gt;   Position ValueBefore ValueAfter&#xA;#&amp;gt; 1      1/2           1          1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;as_assertion_factory&lt;/code&gt; can be used to create your own assertion factories from scratch too, in fact &lt;a href=&#34;https://github.com/moodymudskipper/typed/raw/master/R/06_native_types.R&#34;&gt;it’s used to build the native assertion factories of this package&lt;/a&gt; .&lt;/p&gt; &#xA;&lt;h3&gt;Constants&lt;/h3&gt; &#xA;&lt;p&gt;To define a constant, we just surround the variable by parentheses (think of them as a protection)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Double() ? (x) &amp;lt;- 1&#xA;x &amp;lt;- 2&#xA;#&amp;gt; Error: Can&#39;t assign to a constant&#xA;&#xA;? (y) &amp;lt;- 1&#xA;y &amp;lt;- 2&#xA;#&amp;gt; Error: Can&#39;t assign to a constant&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Set argument type&lt;/h2&gt; &#xA;&lt;p&gt;We can set argument types this way :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;add &amp;lt;- ? function (x= ? Double(), y= 1 ? Double()) {&#xA;  x + y&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we started the definition with a &lt;code&gt;?&lt;/code&gt;, and that we gave a default to &lt;code&gt;y&lt;/code&gt;, but not &lt;code&gt;x&lt;/code&gt;. Note also the &lt;code&gt;=&lt;/code&gt; sign next to &lt;code&gt;x&lt;/code&gt;, necessary even when we have no default value. If you forget it you’ll have an error “unexpected &lt;code&gt;?&lt;/code&gt; in …”.&lt;/p&gt; &#xA;&lt;p&gt;This created the following function, by adding checks at the top of the body&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;add&#xA;#&amp;gt; # typed function&#xA;#&amp;gt; function (x, y = 1) &#xA;#&amp;gt; {&#xA;#&amp;gt;     check_arg(x, Double())&#xA;#&amp;gt;     check_arg(y, Double())&#xA;#&amp;gt;     x + y&#xA;#&amp;gt; }&#xA;#&amp;gt; # Arg types:&#xA;#&amp;gt; # x: Double()&#xA;#&amp;gt; # y: Double()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let’s test it by providing a right and wrong type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;add(2, 3)&#xA;#&amp;gt; [1] 5&#xA;add(2, 3L)&#xA;#&amp;gt; Error: In `add(2, 3L)` at `check_arg(y, Double())`:&#xA;#&amp;gt; wrong argument to function, type mismatch&#xA;#&amp;gt; `typeof(value)`: &#34;integer&#34;&#xA;#&amp;gt; `expected`:      &#34;double&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to restrict &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to the type “integer” in the rest of the body of the function we can use the &lt;code&gt;?+&lt;/code&gt; notation :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;add &amp;lt;- ? function (x= ?+ Double(), y= 1 ?+ Double()) {&#xA;  x + y&#xA;}&#xA;&#xA;add&#xA;#&amp;gt; # typed function&#xA;#&amp;gt; function (x, y = 1) &#xA;#&amp;gt; {&#xA;#&amp;gt;     check_arg(x, Double(), .bind = TRUE)&#xA;#&amp;gt;     check_arg(y, Double(), .bind = TRUE)&#xA;#&amp;gt;     x + y&#xA;#&amp;gt; }&#xA;#&amp;gt; # Arg types:&#xA;#&amp;gt; # x: Double()&#xA;#&amp;gt; # y: Double()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We see that it is translated into a &lt;code&gt;check_arg&lt;/code&gt; call containing a &lt;code&gt;.bind = TRUE&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;p&gt;I we want to restrict the quoted expression rather than the value of an argument, we can use &lt;code&gt;?~&lt;/code&gt; :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;identity_sym_only &amp;lt;- ? function (x= ?~ Symbol()) {&#xA;  x&#xA;}&#xA;&#xA;a &amp;lt;- 1&#xA;identity_sym_only(a)&#xA;#&amp;gt; [1] 1&#xA;identity_sym_only(a + a)&#xA;#&amp;gt; Error: In `identity_sym_only(a + a)` at `check_arg(substitute(x), Symbol())`:&#xA;#&amp;gt; wrong argument to function, type mismatch&#xA;#&amp;gt; `typeof(value)`: &#34;language&#34;&#xA;#&amp;gt; `expected`:      &#34;symbol&#34;&#xA;&#xA;identity_sym_only&#xA;#&amp;gt; # typed function&#xA;#&amp;gt; function (x) &#xA;#&amp;gt; {&#xA;#&amp;gt;     check_arg(substitute(x), Symbol())&#xA;#&amp;gt;     x&#xA;#&amp;gt; }&#xA;#&amp;gt; &amp;lt;bytecode: 0x000000001cb34218&amp;gt;&#xA;#&amp;gt; # Arg types:&#xA;#&amp;gt; # x: ~Symbol()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We see that it is translated into a &lt;code&gt;check_arg&lt;/code&gt; call containing a call to &lt;code&gt;substitute&lt;/code&gt; as the first argument. The &lt;code&gt;~&lt;/code&gt; is kept in the attributes of the function.&lt;/p&gt; &#xA;&lt;p&gt;We can also check the &lt;code&gt;...&lt;/code&gt;, for instance use &lt;code&gt;function(... = ? Integer())&lt;/code&gt; to check that only integers are passed to the dots, and use &lt;code&gt;function(... = ?~ Symbol())&lt;/code&gt; to check that all quoted values passed to &lt;code&gt;...&lt;/code&gt; are symbols.&lt;/p&gt; &#xA;&lt;p&gt;The special assertion factory &lt;code&gt;Dots&lt;/code&gt; can also be used, in that case the checks will apply to &lt;code&gt;list(...)&lt;/code&gt; rather than to each element individually, for instance &lt;code&gt;function(... = ? Dots(2))&lt;/code&gt; makes sure the dots were fed 2 values. In a similar fashion &lt;code&gt;function(... = ?~ Dots(2))&lt;/code&gt; can be used to apply checks to the list of quoted argument passed to &lt;code&gt;...&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Set function return type&lt;/h2&gt; &#xA;&lt;p&gt;To set a return type we use &lt;code&gt;?&lt;/code&gt; before the function definition as in the previous section, but we type an assertion on the left hand side.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;add_or_subtract &amp;lt;- Double() ? function (x, y, subtract = FALSE) {&#xA;  if(subtract) return(x - y)&#xA;  x + y&#xA;}&#xA;add_or_subtract&#xA;#&amp;gt; # typed function&#xA;#&amp;gt; function (x, y, subtract = FALSE) &#xA;#&amp;gt; {&#xA;#&amp;gt;     if (subtract) &#xA;#&amp;gt;         return(check_output(x - y, Double()))&#xA;#&amp;gt;     check_output(x + y, Double())&#xA;#&amp;gt; }&#xA;#&amp;gt; # Return type: Double()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We see that the returned values have been wrapped inside &lt;code&gt;check_output&lt;/code&gt; calls.&lt;/p&gt; &#xA;&lt;h2&gt;Putting it all together, write packages using {typed}&lt;/h2&gt; &#xA;&lt;p&gt;Let’s define our function for our package and document it with &lt;em&gt;{roxygen2}&lt;/em&gt;. It is documented as usual,except that you’ll need to make sure to add the &lt;code&gt;@name&lt;/code&gt; tag.&lt;/p&gt; &#xA;&lt;p&gt;We declare types for the return value, for all arguments, and we declare a string &lt;code&gt;msg&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#&#39; add_or_subtract&#xA;#&#39;&#xA;#&#39; @param x double of length 1&#xA;#&#39; @param y double of length 1&#xA;#&#39; @param subtract whether to subtract instead of adding&#xA;#&#39; @export&#xA;#&#39; @name add_or_subtract&#xA;add_or_subtract &amp;lt;- &#xA;  Double(1) ? function (&#xA;    x= ? Double(1), &#xA;    y= ? Double(1), &#xA;    subtract = FALSE ? Logical(1, anyNA = FALSE)&#xA;    ) {&#xA;    Character(1) ? msg&#xA;    if(subtract) {&#xA;      msg &amp;lt;- &#34;subtracting&#34;&#xA;      message(msg)&#xA;      return(x - y)&#xA;    }&#xA;      msg &amp;lt;- &#34;adding&#34;&#xA;      message(msg)&#xA;    x + y&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The created function will be the following, we see that &lt;code&gt;Character(1) ? msg&lt;/code&gt; was changed into a &lt;code&gt;declare&lt;/code&gt; call too, this is both for efficiency and readability. Unfamiliar users might be intimidated by &lt;code&gt;?&lt;/code&gt; and calls to &lt;code&gt;?&lt;/code&gt; don’t print nicely.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;add_or_subtract&#xA;#&amp;gt; # typed function&#xA;#&amp;gt; function (x, y, subtract = FALSE) &#xA;#&amp;gt; {&#xA;#&amp;gt;     check_arg(x, Double(1))&#xA;#&amp;gt;     check_arg(y, Double(1))&#xA;#&amp;gt;     check_arg(subtract, Logical(1, anyNA = FALSE))&#xA;#&amp;gt;     declare(&#34;msg&#34;, Character(1))&#xA;#&amp;gt;     if (subtract) {&#xA;#&amp;gt;         msg &amp;lt;- &#34;subtracting&#34;&#xA;#&amp;gt;         message(msg)&#xA;#&amp;gt;         return(check_output(x - y, Double(1)))&#xA;#&amp;gt;     }&#xA;#&amp;gt;     msg &amp;lt;- &#34;adding&#34;&#xA;#&amp;gt;     message(msg)&#xA;#&amp;gt;     check_output(x + y, Double(1))&#xA;#&amp;gt; }&#xA;#&amp;gt; # Return type: Double(1)&#xA;#&amp;gt; # Arg types:&#xA;#&amp;gt; # x: Double(1)&#xA;#&amp;gt; # y: Double(1)&#xA;#&amp;gt; # subtract: Logical(1, anyNA = FALSE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that your package would import &lt;em&gt;{typed}&lt;/em&gt; but &lt;code&gt;?&lt;/code&gt; won’t be exposed to the user, they will see it in the code but will be able to use &lt;code&gt;?&lt;/code&gt; just as before. In fact the most common standard use &lt;code&gt;?mean&lt;/code&gt; still works even when &lt;em&gt;{typed}&lt;/em&gt; is attached.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;This is inspired in good part by Jim Hester and Gabor Csardi’s work and many great efforts on static typing, assertions, or annotations in R, in particular:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Gabor Csardy’s &lt;em&gt;{argufy}&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Richie Cotton’s &lt;em&gt;{assertive}&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Tony Fishettti’s &lt;em&gt;{assertr&lt;/em&gt;}&lt;/li&gt; &#xA; &lt;li&gt;Hadley Wickham’s &lt;em&gt;{assertthat}&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Michel Lang’s &lt;em&gt;{checkmate}&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Joe Thorley’s &lt;em&gt;{checkr}&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Joe Thorley’s &lt;em&gt;{chk}&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Aviral Goel’s &lt;em&gt;{contractr}&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Stefan Bache’s &lt;em&gt;{ensurer}&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Brian Lee Yung Rowe’s &lt;em&gt;{lambda.r}&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Kun Ren’s &lt;em&gt;{rtype}&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Jim Hester’s &lt;em&gt;{types}&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>tra418/BIS-411-Fall-2022</title>
    <updated>2022-08-31T01:38:26Z</updated>
    <id>tag:github.com,2022-08-31:/tra418/BIS-411-Fall-2022</id>
    <link href="https://github.com/tra418/BIS-411-Fall-2022" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Repo for BIS 411 course&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BIS-411-Fall-2022&lt;/h1&gt; &#xA;&lt;p&gt;Repo for BIS 411 course&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kostis-christodoulou/am01</title>
    <updated>2022-08-31T01:38:26Z</updated>
    <id>tag:github.com,2022-08-31:/kostis-christodoulou/am01</id>
    <link href="https://github.com/kostis-christodoulou/am01" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AM01&lt;/h1&gt; &#xA;&lt;p&gt;All course files (data, code, etc.) used in AM01, September 2022&lt;/p&gt; &#xA;&lt;p&gt;If you install the &lt;strong&gt;usethis&lt;/strong&gt; package and type tyhe following in RStudio&#39;s console&lt;/p&gt; &#xA;&lt;p&gt;usethis::use_course(&#34;&lt;a href=&#34;https://github.com/kostis-christodoulou/am01/archive/refs/heads/master.zip&#34;&gt;https://github.com/kostis-christodoulou/am01/archive/refs/heads/master.zip&lt;/a&gt;&#34;)&lt;/p&gt; &#xA;&lt;p&gt;will allow you to download and unpack a ZIP file into a local folder of files, and open up the associated &lt;em&gt;.RProj&lt;/em&gt; file, so you work inside an RStudio Project.&lt;/p&gt;</summary>
  </entry>
</feed>