<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-13T01:35:06Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>t-kalinowski/quickr</title>
    <updated>2025-06-13T01:35:06Z</updated>
    <id>tag:github.com,2025-06-13:/t-kalinowski/quickr</id>
    <link href="https://github.com/t-kalinowski/quickr" rel="alternate"></link>
    <summary type="html">&lt;p&gt;R to Fortran Transpiler&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;quickr &lt;img src=&#34;https://raw.githubusercontent.com/t-kalinowski/quickr/main/man/figures/logo.png&#34; align=&#34;right&#34; height=&#34;138&#34;&gt;&lt;/h1&gt; &#xA;&lt;!-- &lt;img&#xA;src=&#34;https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExMjBhNWt1Z3Q4ZW56cG00c2hncmtwbGJycm53M3JxYWdscjRkaDJobCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/12haGO61oFZ28w/giphy.gif&#34;&#xA;alt=&#34;An animated GIF showing two characters in a spaceship cockpit rapidly accelerating into hyperspace, with stars stretching into bright streaks, creating a sensation of rapid acceleration and motion.&#34; /&gt; --&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;The goal of quickr is to make your R code run quicker.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;R is an extremely flexible and dynamic language, but that flexibility and dynamicism can come at the expense of speed. This package lets you trade back some of that flexibility for some speed, for the context of a single function.&lt;/p&gt; &#xA;&lt;!-- Programming language design requires some hard decisions and trade-ofs. --&gt; &#xA;&lt;!-- When you want to have it all, you typically end up have two (or more!) languages. --&gt; &#xA;&lt;!-- An interpreted, dynamic language full of conveniences, and a staticly-typed, explicit, high-performance language. --&gt; &#xA;&lt;!-- This is sometimes called the &#34;Two Language Problem&#34;. --&gt; &#xA;&lt;!-- Like [Numba](https://numba.pydata.org) in Python, or the [Julia](https://julialang.org) language, quickr is a solution to the [two-language problem](https://juliadatascience.io/julia_accomplish). --&gt; &#xA;&lt;!-- Unlike those tools however, quickr does not bundle most of LLVM, keeping dependencies lightweight. --&gt; &#xA;&lt;!-- Quickr works by translating the R code to Fortran. --&gt; &#xA;&lt;!-- Fortran might seem like a surprising choice, but it has many compelling properties: --&gt; &#xA;&lt;!-- -   Superb performance. --&gt; &#xA;&lt;!--     As a stalwart of the numerical computing community, Fortran has accrued the benefit of countless person-hours from top-tier computer scientists and compiler engineers. --&gt; &#xA;&lt;!--     There is a reason that over 20% of R itself, (and numpy, and ...) are still in Fortran, and it&#39;s not merely because of legacy. --&gt; &#xA;&lt;!--     And this trend of compiler engineers focusing on Fortran is not stopping. --&gt; &#xA;&lt;!-- -   Large overlap with R semantics and syntax for numerical computing. --&gt; &#xA;&lt;!--     Fortran and R have very similar syntax for operating on arrays. --&gt; &#xA;&lt;!--     Like R, Fortran has builtin-in support for nd-arrays, provides vectorized operators on arrays, convenient array slicing semantics that match many capabilities of R&#39;s `[` , 1-based indexing, and a well-populated collection of operators for working on those arrays like `min`, `max`, `any` `all`, etc. --&gt; &#xA;&lt;!--     This means that it&#39;s relatively straightforward to translate R to Fortran, often just a 1:1 mapping of semantics, with some changes to syntax. --&gt; &#xA;&lt;!--     This is also why Fortran has such superb performance, and why it attracts compiler engineers to work on it. --&gt; &#xA;&lt;!--     Because the language spec guarantees things like, static shapes for nd-arrays, views of those arrays, etc, it provides many opportunities for compiler engineers to do things like generate SIMD instructions, or automatically parallelize code. --&gt; &#xA;&lt;!-- -   Excellent support in R. --&gt; &#xA;&lt;!--     One of the original motivations for R was to serve as a front-end for Fortran. --&gt; &#xA;&lt;!--     Since it&#39;s inception, R has supported Fortran extensions, and supported them well. --&gt; &#xA;&lt;!--     It also means that any computing environment where R build tools are available, Fortran is supported. --&gt; &#xA;&lt;!--     The barrier to entry and thorny questions, that, for example, using Rust in CRAN might raise, is non-existent for Fortran. --&gt; &#xA;&lt;p&gt;The main exported function is &lt;code&gt;quick()&lt;/code&gt;, here is how you use it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(quickr)&#xA;&#xA;convolve &amp;lt;- quick(function(a, b) {&#xA;  declare(type(a = double(NA)),&#xA;          type(b = double(NA)))&#xA;  ab &amp;lt;- double(length(a) + length(b) - 1)&#xA;  for (i in seq_along(a)) {&#xA;    for (j in seq_along(b)) {&#xA;      ab[i+j-1] &amp;lt;- ab[i+j-1] + a[i] * b[j]&#xA;    }&#xA;  }&#xA;  ab&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;quick()&lt;/code&gt; returns a quicker R function. How much quicker? Let’s benchmark it! For reference, we’ll also compare it to a &lt;a href=&#34;https://cran.r-project.org/doc/FAQ/R-exts.html#Calling-_002eCall-1&#34;&gt;pure-C&lt;/a&gt; implementation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;slow_convolve &amp;lt;- function(a, b) {&#xA;  declare(type(a = double(NA)),&#xA;          type(b = double(NA)))&#xA;  ab &amp;lt;- double(length(a) + length(b) - 1)&#xA;  for (i in seq_along(a)) {&#xA;    for (j in seq_along(b)) {&#xA;      ab[i+j-1] &amp;lt;- ab[i+j-1] + a[i] * b[j]&#xA;    }&#xA;  }&#xA;  ab&#xA;}&#xA;&#xA;library(quickr)&#xA;quick_convolve &amp;lt;- quick(slow_convolve)&#xA;&#xA;convolve_c &amp;lt;- inline::cfunction(&#xA;  sig = c(a = &#34;SEXP&#34;, b = &#34;SEXP&#34;), body = r&#34;({&#xA;    int na, nb, nab;&#xA;    double *xa, *xb, *xab;&#xA;    SEXP ab;&#xA;&#xA;    a = PROTECT(Rf_coerceVector(a, REALSXP));&#xA;    b = PROTECT(Rf_coerceVector(b, REALSXP));&#xA;    na = Rf_length(a); nb = Rf_length(b); nab = na + nb - 1;&#xA;    ab = PROTECT(Rf_allocVector(REALSXP, nab));&#xA;    xa = REAL(a); xb = REAL(b); xab = REAL(ab);&#xA;    for(int i = 0; i &amp;lt; nab; i++) xab[i] = 0.0;&#xA;    for(int i = 0; i &amp;lt; na; i++)&#xA;        for(int j = 0; j &amp;lt; nb; j++)&#xA;            xab[i + j] += xa[i] * xb[j];&#xA;    UNPROTECT(3);&#xA;    return ab;&#xA;})&#34;)&#xA;&#xA;&#xA;&#xA;a &amp;lt;- runif (100000); b &amp;lt;- runif (100)&#xA;&#xA;timings &amp;lt;- bench::mark(&#xA;  r = slow_convolve(a, b),&#xA;  quickr = quick_convolve(a, b),&#xA;  c = convolve_c(a, b),&#xA;  min_time = 2&#xA;)&#xA;timings&#xA;#&amp;gt; # A tibble: 3 × 6&#xA;#&amp;gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`&#xA;#&amp;gt;   &amp;lt;bch:expr&amp;gt; &amp;lt;bch:tm&amp;gt; &amp;lt;bch:tm&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;bch:byt&amp;gt;    &amp;lt;dbl&amp;gt;&#xA;#&amp;gt; 1 r             1.05s    1.05s     0.955     847KB    0.955&#xA;#&amp;gt; 2 quickr        4.8ms   5.09ms   195.        782KB    3.07 &#xA;#&amp;gt; 3 c            4.73ms   5.04ms   196.        782KB    3.09&#xA;plot(timings) + bench::scale_x_bench_time(base = NULL)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/t-kalinowski/quickr/main/man/figures/README-unnamed-chunk-3-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;p&gt;In the case of &lt;code&gt;convolve()&lt;/code&gt;, &lt;code&gt;quick()&lt;/code&gt; returns a function approximately &lt;em&gt;200&lt;/em&gt; times quicker, giving similar performance to the C function.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;quick()&lt;/code&gt; can accelerate any R function, with some restrictions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Function arguments must have their types and shapes declared using &lt;code&gt;declare()&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Only atomic vectors, matrices, and array are currently supported: &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;logical&lt;/code&gt;, and &lt;code&gt;complex&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The return value must be an atomic array (e.g., not a list)&lt;/li&gt; &#xA; &lt;li&gt;Named variables must have consistent shapes throughout their lifetimes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NA&lt;/code&gt; values are not supported.&lt;/li&gt; &#xA; &lt;li&gt;Only a subset of R’s vocabulary is currently supported.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- --&gt; &#xA;&lt;pre&gt;&lt;code&gt;#&amp;gt;  [1] -         :         !=        (         [         [&amp;lt;-       {        &#xA;#&amp;gt;  [8] *         /         &amp;amp;         &amp;amp;&amp;amp;        %/%       %%        ^        &#xA;#&amp;gt; [15] +         &amp;lt;         &amp;lt;-        &amp;lt;=        =         ==        &amp;gt;        &#xA;#&amp;gt; [22] &amp;gt;=        |         ||        Arg       Conj      Fortran   Im       &#xA;#&amp;gt; [29] Mod       Re        abs       acos      asin      atan      c        &#xA;#&amp;gt; [36] cat       cbind     ceiling   character cos       declare   double   &#xA;#&amp;gt; [43] exp       floor     for       if        ifelse    integer   length   &#xA;#&amp;gt; [50] log       log10     logical   matrix    max       min       numeric  &#xA;#&amp;gt; [57] print     prod      raw       seq       sin       sqrt      sum      &#xA;#&amp;gt; [64] tan       which.max which.min&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Many of these restrictions are expected to be relaxed as the project matures. However, quickr is intended primarily for high-performance numerical computing, so features like polymorphic dispatch or support for complex or dynamic types are out of scope.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;declare(type())&lt;/code&gt; syntax:&lt;/h2&gt; &#xA;&lt;p&gt;The shape and mode of all function arguments must be declared. Local and return variables may optionally also be declared.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;declare(type())&lt;/code&gt; also has support for declaring size constraints, or size relationships between variables. Here are some examples of declare calls:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;declare(type(x = double(NA))) # x is a 1-d double vector of any length&#xA;declare(type(x = double(10))) # x is a 1-d double vector of length 10&#xA;declare(type(x = double(1)))  # x is a scalar double&#xA;&#xA;declare(type(x = integer(2, 3)))  # x is a 2-d integer matrix with dim (2, 3)&#xA;declare(type(x = integer(NA, 3))) # x is a 2-d integer matrix with dim (&amp;lt;any&amp;gt;, 3)&#xA;&#xA;# x is a 4-d logical matrix with dim (&amp;lt;any&amp;gt;, 24, 24, 3)&#xA;declare(type(x = logical(NA, 24, 24, 3)))&#xA;&#xA;# x and y are 1-d double vectors of any length&#xA;declare(type(x = double(NA)),&#xA;        type(y = double(NA)))&#xA;&#xA;# x and y are 1-d double vectors of the same length&#xA;declare(&#xA;  type(x = double(n)),&#xA;  type(y = double(n)),&#xA;)&#xA;&#xA;# x and y are 1-d double vectors, where length(y) == length(x) + 2&#xA;declare(type(x = double(n)),&#xA;        type(y = double(n+2)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;More examples:&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;viterbi&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The Viterbi algorithm is an example of a dynamic programming algorithm within the family of Hidden Markov Models (&lt;a href=&#34;https://en.wikipedia.org/wiki/Viterbi_algorithm&#34;&gt;https://en.wikipedia.org/wiki/Viterbi_algorithm&lt;/a&gt;). Here, &lt;code&gt;quick()&lt;/code&gt; makes the &lt;code&gt;viterbi()&lt;/code&gt; approximately 50 times faster.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;slow_viterbi &amp;lt;- function(observations, states, initial_probs, transition_probs, emission_probs) {&#xA;    declare(&#xA;      type(observations = integer(num_steps)),&#xA;      type(states = integer(num_states)),&#xA;      type(initial_probs = double(num_states)),&#xA;      type(transition_probs = double(num_states, num_states)),&#xA;      type(emission_probs = double(num_states, num_obs)),&#xA;    )&#xA;&#xA;    trellis &amp;lt;- matrix(0, nrow = length(states), ncol = length(observations))&#xA;    backpointer &amp;lt;- matrix(0L, nrow = length(states), ncol = length(observations))&#xA;    trellis[, 1] &amp;lt;- initial_probs * emission_probs[, observations[1]]&#xA;&#xA;    for (step in 2:length(observations)) {&#xA;      for (current_state in 1:length(states)) {&#xA;        probabilities &amp;lt;- trellis[, step - 1] * transition_probs[, current_state]&#xA;        trellis[current_state, step] &amp;lt;- max(probabilities) * emission_probs[current_state, observations[step]]&#xA;        backpointer[current_state, step] &amp;lt;- which.max(probabilities)&#xA;      }&#xA;    }&#xA;&#xA;    path &amp;lt;- integer(length(observations))&#xA;    path[length(observations)] &amp;lt;- which.max(trellis[, length(observations)])&#xA;    for (step in seq(length(observations) - 1, 1)) {&#xA;      path[step] &amp;lt;- backpointer[path[step + 1], step + 1]&#xA;    }&#xA;&#xA;    out &amp;lt;- states[path]&#xA;    out&#xA;}&#xA;&#xA;quick_viterbi &amp;lt;- quick(slow_viterbi)&#xA;&#xA;set.seed(1234)&#xA;num_steps &amp;lt;- 16&#xA;num_states &amp;lt;- 8&#xA;num_obs &amp;lt;- 16&#xA;&#xA;observations &amp;lt;- sample(1:num_obs, num_steps, replace = TRUE)&#xA;states &amp;lt;- 1:num_states&#xA;initial_probs &amp;lt;- runif (num_states)&#xA;initial_probs &amp;lt;- initial_probs / sum(initial_probs)  # normalize to sum to 1&#xA;transition_probs &amp;lt;- matrix(runif (num_states * num_states), nrow = num_states)&#xA;transition_probs &amp;lt;- transition_probs / rowSums(transition_probs)  # normalize rows&#xA;emission_probs &amp;lt;- matrix(runif (num_states * num_obs), nrow = num_states)&#xA;emission_probs &amp;lt;- emission_probs / rowSums(emission_probs)  # normalize rows&#xA;&#xA;timings &amp;lt;- bench::mark(&#xA;  slow_viterbi = slow_viterbi(observations, states, initial_probs,&#xA;                              transition_probs, emission_probs),&#xA;  quick_viterbi = quick_viterbi(observations, states, initial_probs,&#xA;                                transition_probs, emission_probs)&#xA;)&#xA;timings&#xA;#&amp;gt; # A tibble: 2 × 6&#xA;#&amp;gt;   expression         min   median `itr/sec` mem_alloc `gc/sec`&#xA;#&amp;gt;   &amp;lt;bch:expr&amp;gt;    &amp;lt;bch:tm&amp;gt; &amp;lt;bch:tm&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;bch:byt&amp;gt;    &amp;lt;dbl&amp;gt;&#xA;#&amp;gt; 1 slow_viterbi  143.04µs    162µs     6047.     178KB     14.5&#xA;#&amp;gt; 2 quick_viterbi   2.43µs   2.53µs   368609.        0B      0&#xA;plot(timings)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/t-kalinowski/quickr/main/man/figures/README-unnamed-chunk-6-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;h3&gt;Diffusion simulation&lt;/h3&gt; &#xA;&lt;p&gt;Simulate how heat spreads over time across a 2D grid, using the &lt;a href=&#34;https://en.wikipedia.org/wiki/Finite_difference&#34;&gt;finite difference method&lt;/a&gt; applied to the &lt;a href=&#34;https://en.wikipedia.org/wiki/Heat_equation&#34;&gt;Heat Equation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here, &lt;code&gt;quick()&lt;/code&gt; returns a function over 100 time faster.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;diffuse_heat &amp;lt;- function(nx, ny, dx, dy, dt, k, steps) {&#xA;  declare(&#xA;    type(nx = integer(1)),&#xA;    type(ny = integer(1)),&#xA;    type(dx = integer(1)),&#xA;    type(dy = integer(1)),&#xA;    type(dt = double(1)),&#xA;    type(k = double(1)),&#xA;    type(steps = integer(1))&#xA;  )&#xA;&#xA;  # Initialize temperature grid&#xA;  temp &amp;lt;- matrix(0, nx, ny)&#xA;  temp[nx / 2, ny / 2] &amp;lt;- 100  # Initial heat source in the center&#xA;&#xA;  # Time stepping&#xA;  for (step in seq_len(steps)) {&#xA;    # Apply boundary conditions&#xA;    temp[1, ] &amp;lt;- 0&#xA;    temp[nx, ] &amp;lt;- 0&#xA;    temp[, 1] &amp;lt;- 0&#xA;    temp[, ny] &amp;lt;- 0&#xA;&#xA;    # Update using finite differences&#xA;    temp_new &amp;lt;- temp&#xA;    for (i in 2:(nx - 1)) {&#xA;      for (j in 2:(ny - 1)) {&#xA;        temp_new[i, j] &amp;lt;- temp[i, j] + k * dt *&#xA;          ((temp[i + 1, j] - 2 * temp[i, j] + temp[i - 1, j]) /&#xA;             dx ^ 2 + (temp[i, j + 1] - 2 * temp[i, j] + temp[i, j - 1]) / dy ^ 2)&#xA;      }&#xA;    }&#xA;    temp &amp;lt;- temp_new&#xA;&#xA;  }&#xA;&#xA;  temp&#xA;}&#xA;&#xA;quick_diffuse_heat &amp;lt;- quick(diffuse_heat)&#xA;&#xA;# Parameters&#xA;nx &amp;lt;- 100L      # Grid size in x&#xA;ny &amp;lt;- 100L      # Grid size in y&#xA;dx &amp;lt;- 1L        # Grid spacing&#xA;dy &amp;lt;- 1L        # Grid spacing&#xA;dt &amp;lt;- 0.01      # Time step&#xA;k &amp;lt;- 0.1        # Thermal diffusivity&#xA;steps &amp;lt;- 500L   # Number of time steps&#xA;&#xA;timings &amp;lt;- bench::mark(&#xA;  diffuse_heat = diffuse_heat(nx, ny, dx, dy, dt, k, steps),&#xA;  quick_diffuse_heat = quick_diffuse_heat(nx, ny, dx, dy, dt, k, steps)&#xA;)&#xA;#&amp;gt; Warning: Some expressions had a GC in every iteration; so filtering is&#xA;#&amp;gt; disabled.&#xA;summary(timings, relative = TRUE)&#xA;#&amp;gt; Warning: Some expressions had a GC in every iteration; so filtering is&#xA;#&amp;gt; disabled.&#xA;#&amp;gt; # A tibble: 2 × 6&#xA;#&amp;gt;   expression           min median `itr/sec` mem_alloc `gc/sec`&#xA;#&amp;gt;   &amp;lt;bch:expr&amp;gt;         &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;&#xA;#&amp;gt; 1 diffuse_heat        127.   122.        1      1014.      Inf&#xA;#&amp;gt; 2 quick_diffuse_heat    1      1       121.        1       NaN&#xA;plot(timings)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/t-kalinowski/quickr/main/man/figures/README-unnamed-chunk-7-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;h3&gt;Rolling Mean&lt;/h3&gt; &#xA;&lt;p&gt;Here is quickr used to calculate a rolling mean. Note that the CRAN package RcppRoll already provides a highly optimized rolling mean, which we include in the benchmarks for comparison.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;slow_roll_mean &amp;lt;- function(x, weights, normalize = TRUE) {&#xA;  declare(&#xA;    type(x = double(NA)),&#xA;    type(weights = double(NA)),&#xA;    type(normalize = logical(1))&#xA;  )&#xA;  out &amp;lt;- double(length(x) - length(weights) + 1)&#xA;  n &amp;lt;- length(weights)&#xA;  if (normalize)&#xA;    weights &amp;lt;- weights/sum(weights)*length(weights)&#xA;&#xA;  for(i in seq_along(out)) {&#xA;    out[i] &amp;lt;- sum(x[i:(i+n-1)] * weights) / length(weights)&#xA;  }&#xA;  out&#xA;}&#xA;&#xA;quick_roll_mean &amp;lt;- quick(slow_roll_mean)&#xA;&#xA;x &amp;lt;- dnorm(seq(-3, 3, len = 100000))&#xA;weights &amp;lt;- dnorm(seq(-1, 1, len = 100))&#xA;&#xA;timings &amp;lt;- bench::mark(&#xA;  r = slow_roll_mean(x, weights),&#xA;  rcpp = RcppRoll::roll_mean(x, weights = weights),&#xA;  quickr = quick_roll_mean(x, weights = weights)&#xA;)&#xA;#&amp;gt; Warning: Some expressions had a GC in every iteration; so filtering is&#xA;#&amp;gt; disabled.&#xA;timings&#xA;#&amp;gt; # A tibble: 3 × 6&#xA;#&amp;gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`&#xA;#&amp;gt;   &amp;lt;bch:expr&amp;gt; &amp;lt;bch:tm&amp;gt; &amp;lt;bch:tm&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;bch:byt&amp;gt;    &amp;lt;dbl&amp;gt;&#xA;#&amp;gt; 1 r           105.4ms 109.13ms      7.42  124.31MB    22.3 &#xA;#&amp;gt; 2 rcpp         19.7ms  19.84ms     49.4     4.44MB     1.98&#xA;#&amp;gt; 3 quickr          7ms   7.09ms    138.    781.35KB     2.00&#xA;&#xA;timings$expression &amp;lt;- factor(names(timings$expression), rev(names(timings$expression)))&#xA;plot(timings) + bench::scale_x_bench_time(base = NULL)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/t-kalinowski/quickr/main/man/figures/README-unnamed-chunk-8-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;h2&gt;Using &lt;code&gt;quickr&lt;/code&gt; in an R package&lt;/h2&gt; &#xA;&lt;p&gt;When called in a package, &lt;code&gt;quick()&lt;/code&gt; will pre-compile the quick functions and place them in the &lt;code&gt;./src&lt;/code&gt; directory. Run &lt;code&gt;devtools::load_all()&lt;/code&gt; or &lt;code&gt;quickr::compile_package()&lt;/code&gt; to ensure that the generated files in &lt;code&gt;./src&lt;/code&gt; and &lt;code&gt;./R&lt;/code&gt; are in sync with each other.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install quickr from CRAN with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#34;quickr&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can install the development version of quickr from &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;pak&#34;)&#xA;pak::pak(&#34;t-kalinowski/quickr&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will also need a C and Fortran compiler, preferably the same ones used to build R itself.&lt;/p&gt; &#xA;&lt;p&gt;On macOS:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Make sure xcode tools and gfortran are installed, as described in &lt;a href=&#34;https://mac.r-project.org/tools/&#34;&gt;https://mac.r-project.org/tools/&lt;/a&gt;. In Terminal, run:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;sudo xcode-select --install&#xA;# curl -LO https://mac.r-project.org/tools/gfortran-12.2-universal.pkg # R 4.4&#xA;curl -LO https://mac.r-project.org/tools/gfortran-14.2-universal.pkg   # R 4.5&#xA;sudo installer -pkg gfortran-12.2-universal.pkg -target /&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;On Windows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the latest version of &lt;a href=&#34;https://cran.r-project.org/bin/windows/Rtools/&#34;&gt;Rtools&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;On Linux:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The “Install Required Dependencies” section &lt;a href=&#34;https://docs.posit.co/resources/install-r-source.html#install-required-dependencies&#34;&gt;here&lt;/a&gt; provides detailed instructions for installing R build tools on various Linux flavors.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>