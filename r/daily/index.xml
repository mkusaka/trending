<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-07T01:43:23Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sachit27/greenR</title>
    <updated>2023-08-07T01:43:23Z</updated>
    <id>tag:github.com,2023-08-07:/sachit27/greenR</id>
    <link href="https://github.com/sachit27/greenR" rel="alternate"></link>
    <summary type="html">&lt;p&gt;greenR is an R package that enables the quantification, analysis, and visualization of urban greenness within city networks. It leverages data from OpenStreetMap (www.openstreetmap.org) and is implemented as both an R package and a Shiny web application for user-friendly interaction.&lt;/p&gt;&lt;hr&gt;&lt;p float=&#34;left&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/sachit27/greenR/main/img/logo.png&#34; width=&#34;230&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/sachit27/greenR/main/img/zh_network.png&#34; width=&#34;250&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/sachit27/greenR/main/img/zh_gi.png&#34; width=&#34;300&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;greenR: Green Index Quantification&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;greenR is an open-source R package designed to tackle the challenging task of quantifying urban greenness. Leveraging crowd-sourced data from OpenStreetMap (OSM), greenR provides a new and scalable method to assign green indices to individual street segments. The greenR package offers a comprehensive solution by facilitating green index quantification, analysis, and visualization.&lt;/p&gt; &#xA;&lt;p&gt;Accompanied by a Shiny app, greenR can empower researchers, planners, policy-makers, and citizens to study urban greenness patterns across cities.&lt;/p&gt; &#xA;&lt;p&gt;For more detailed information about the motivation, methodology, and validation, please have a look at this &lt;a href=&#34;https://www.researchgate.net/publication/372909423_greenR_An_Open-Source_Framework_for_Quantifying_Urban_Greenness&#34;&gt;Preprint&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;The functionality in this repository is implemented in the R package greenR. This package is currently not available on CRAN but can be obtained via GitHub by running the command below in R.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;remotes&#34;) # Uncomment if you do not have the &#39;remotes&#39; package installed&#xA;remotes::install_github(&#34;sachit27/greenR&#34;, dependencies = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can also use devtools to install the package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(devtools)&#xA;devtools::install_github(&#34;sachit27/greenR&#34;, dependencies = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After installation, you can load the package into the R session using the following command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(greenR)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Specify the city or neighborhood and download the data&lt;/h2&gt; &#xA;&lt;p&gt;The first step is to acquire data. This provides a systematic approach to collecting the requisite geospatial data from OSM, thereby serving as the foundation for all subsequent analyses. The users can simply specify any city or neighborhood (that has data available in OSM database). This function looks in the internal database and finds any city and downloads OSM data for the specified spatial area with regard to three key environmental features: highways, green areas, and trees.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;data &amp;lt;- get_osm_data(&#34;City of London, United Kingdom&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;data &amp;lt;- get_osm_data(&#34;Fulham, London, United Kingdom&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Calculate the green index for the specified city&lt;/h2&gt; &#xA;&lt;p&gt;This function takes as input the OSM data, a Coordinate Reference System (CRS) code, and parameter D for the distance decay functions. The algorithm extracts the highways, green areas, and trees data from the input list and transforms the data into the given CRS. The CRS affects how distances, areas, and other measurements are calculated. Different CRSs may represent the Earth&#39;s surface in ways that either exaggerate or minimize certain dimensions. So, using the wrong CRS can lead to incorrect calculations and analyses. If you&#39;re focusing on a city or other localized area, you&#39;ll likely want to use a CRS that is tailored to that specific location. This could be a local city grid system or other local CRS that has been designed to minimize distortions in that area. This function then defines distance decay functions for green areas and trees using the parameter D. For each edge in the highway data, the function calculates the green index using the decay functions and returns a data frame with the green index for each edge. By default, D is specified to 100 (distance decay parameter) but it can be changed by the user. Similarly, the users must specify the CRS (&lt;a href=&#34;https://epsg.io/&#34;&gt;https://epsg.io/&lt;/a&gt;). The green index ranges from 0 to 1 and it represents the relative greenness of each section, factoring in proximity to green spaces and tree density.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;green_index &amp;lt;- calculate_green_index(data, 4326, 100)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Create the green index plot&lt;/h2&gt; &#xA;&lt;p&gt;This function creates a color-coded map of the green index across the city&#39;s network, allowing for extensive customization and interactive exploration. Each edge is plotted and color-coded based on its green index, providing an intuitive, easy-to-understand depiction of the city&#39;s spatial distribution of greenery.&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Customization&lt;/strong&gt;: Customize the appearance of the plot by adjusting parameters such as color palette, text size, resolution, title, axis labels, legend position, line width, and line type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Interactive Plotting&lt;/strong&gt;: Choose to render the plot interactively using Plotly, enabling zooming, panning, and tooltips for a more immersive experience.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Export Options&lt;/strong&gt;: Save the plot in various formats like PNG, PDF, and JPEG.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;plot_green_index&lt;/code&gt; function to create the plot. The function allows for various customization options and can also render an interactive plot using Plotly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;# Create a static plot&#xA;map &amp;lt;- plot_green_index(green_index)&#xA;&#xA;# Create an interactive plot using Plotly&#xA;map &amp;lt;- plot_green_index(green_index, interactive = TRUE)&#xA;&#xA;# Customize the plot&#xA;map &amp;lt;- plot_green_index(green_index, colors = c(&#34;#FF0000&#34;, &#34;#00FF00&#34;), line_width = 1, line_type = &#34;dashed&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Calculate the percentage of edges with a certain green index&lt;/h2&gt; &#xA;&lt;p&gt;This function groups the edges by their respective green index and calculates the percentage of edges for each green index. For easier interpretation, we categorize the index into three tiers: Low ( &amp;lt; 0.4), Medium (0.4-0.7), and High (&amp;gt; 0.7).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;percentage &amp;lt;- calculate_percentage(green_index)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Data export and sharing&lt;/h2&gt; &#xA;&lt;p&gt;These functions allow the user to download the green index values as a GeoJson file as well as a Leaflet map. The GeoJSON file retains the geographical properties of the data and can be readily employed in a broad range of GIS applications. The Leaflet map, saved as an HTML file, provides an interactive user experience, facilitating dynamic exploration of the data. The users should specify the file path to save these files.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;download_file &amp;lt;- save_json(green_index, File Path)&#xA;map &amp;lt;- save_as_leaflet(green_index, File Path)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Shiny Application&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sachit27/greenR/main/img/shiny.png&#34; alt=&#34;Map&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can make your own greenness analysis without having to code using an R Shiny implementation of the package. It is easily accessible from within R by calling the function &lt;code&gt;run_app()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Handling SSL Certificate Errors&lt;/h2&gt; &#xA;&lt;p&gt;If you encounter an error related to SSL certificate authentication, such as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;Error in curl::curl_fetch_memory(url, handle = handle) :&#xA;Peer certificate cannot be authenticated with given CA certificates: SSL certificate problem: certificate has expired&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It may be necessary to update the CA certificates on your system.&lt;/p&gt; &#xA;&lt;h2&gt;Important Performance Notice&lt;/h2&gt; &#xA;&lt;p&gt;This package, &#39;greenR&#39; provides tools to measure and visualize the &#39;greenness&#39; of urban areas. It performs intensive computations that require robust computational resources, particularly when analyzing large urban networks.&lt;/p&gt; &#xA;&lt;p&gt;Please be aware of the following:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Processing time: Depending on the size of the area under analysis, computations may take a considerable amount of time. Larger areas, like whole cities or metropolitan regions, will take longer to process compared to small neighborhoods or districts.&lt;/li&gt; &#xA; &lt;li&gt;Computational resources: Due to the computational intensity of these tasks, it is recommended to run this package on a machine with a strong CPU and sufficient RAM. Please ensure your machine meets these requirements before starting the computation to prevent any interruptions or crashes.&lt;/li&gt; &#xA; &lt;li&gt;Testing: If you are using &#39;greenR&#39; for the first time, or if you&#39;re testing on a new machine, it is suggested to begin with a smaller area - such as a specific neighborhood or small town. This will give you a rough idea of how long the computations might take and how well your machine can handle them.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Remember, performance can greatly vary based on the size of the network and the hardware of your machine.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;The OSM data is available under the Open Database License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Merck/gMCPShiny</title>
    <updated>2023-08-07T01:43:23Z</updated>
    <id>tag:github.com,2023-08-07:/Merck/gMCPShiny</id>
    <link href="https://github.com/Merck/gMCPShiny" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Shiny app for graphical multiplicity control&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;gMCPShiny &lt;img src=&#34;https://raw.githubusercontent.com/Merck/gMCPShiny/main/man/figures/logo.png&#34; align=&#34;right&#34; width=&#34;120&#34;&gt;&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Merck/gMCPShiny/actions/workflows/R-CMD-check.yaml&#34;&gt;&lt;img src=&#34;https://github.com/Merck/gMCPShiny/actions/workflows/R-CMD-check.yaml/badge.svg?sanitize=true&#34; alt=&#34;R-CMD-check&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.codecov.io/gh/Merck/gMCPShiny?branch=main&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/Merck/gMCPShiny/branch/main/graph/badge.svg?sanitize=true&#34; alt=&#34;Codecov test coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://rinpharma.shinyapps.io/gmcp/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Shiny-shinyapps.io-blue&#34; alt=&#34;shinyapps.io&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;A Shiny app for graphical multiplicity control.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# The easiest way to get gMCPShiny is to install:&#xA;install.packages(&#34;gMCPShiny&#34;)&#xA;&#xA;# Alternatively, install development version from GitHub:&#xA;# install.packages(&#34;remotes&#34;)&#xA;remotes::install_github(&#34;Merck/gMCPShiny&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;To run the app locally:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;gMCPShiny::run_app()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Deployed instances&lt;/h2&gt; &#xA;&lt;h3&gt;Production version&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://rinpharma.shinyapps.io/gmcp/&#34;&gt;https://rinpharma.shinyapps.io/gmcp/&lt;/a&gt; (faster and more scalable access)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gmcp.shinyapps.io/prod/&#34;&gt;https://gmcp.shinyapps.io/prod/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Development version&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gmcp.shinyapps.io/devel/&#34;&gt;https://gmcp.shinyapps.io/devel/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>jfeldman396/QRSubsets</title>
    <updated>2023-08-07T01:43:23Z</updated>
    <id>tag:github.com,2023-08-07:/jfeldman396/QRSubsets</id>
    <link href="https://github.com/jfeldman396/QRSubsets" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Bayesian Subset Selection and Uncertainty Quantification for Quantile Regression&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>