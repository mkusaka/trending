<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-27T01:39:19Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>moodymudskipper/unglue</title>
    <updated>2022-11-27T01:39:19Z</updated>
    <id>tag:github.com,2022-11-27:/moodymudskipper/unglue</id>
    <link href="https://github.com/moodymudskipper/unglue" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Extract matched substrings using a pattern, similar to what package glue does in reverse&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://codecov.io/gh/moodymudskipper/unglue?branch=master&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/moodymudskipper/unglue/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;Codecov test coverage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;h1&gt;unglue &lt;img src=&#34;https://raw.githubusercontent.com/moodymudskipper/unglue/master/man/figures/logo.png&#34; align=&#34;right&#34; height=&#34;139&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;The package &lt;em&gt;unglue&lt;/em&gt; features functions such as &lt;code&gt;unglue()&lt;/code&gt;, &lt;code&gt;unglue_data()&lt;/code&gt; and &lt;code&gt;unglue_unnest()&lt;/code&gt; which provide in many cases a more readable alternative to base regex functions. Simple cases indeed don’t require regex knowledge at all.&lt;/p&gt; &#xA;&lt;p&gt;It uses a syntax inspired from the functions of Jim Hester’s &lt;em&gt;glue&lt;/em&gt; package to extract matched substrings using a pattern, but is not endorsed by the authors of &lt;em&gt;glue&lt;/em&gt; nor &lt;em&gt;tidyverse&lt;/em&gt; packages.&lt;/p&gt; &#xA;&lt;p&gt;It is completely dependency free, though formula notation of functions is supported if &lt;em&gt;rlang&lt;/em&gt; is installed.&lt;/p&gt; &#xA;&lt;h2&gt;Installation:&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# CRAN version:&#xA;install.packages(&#34;unglue&#34;)&#xA;# Development version:&#xA;remotes::install_github(&#34;moodymudskipper/unglue&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;using an example from &lt;code&gt;?glue::glue&lt;/code&gt; backwards&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(unglue)&#xA;library(glue)&#xA;library(magrittr)&#xA;library(utils)&#xA;glued_data &amp;lt;- head(mtcars) %&amp;gt;% glue_data(&#34;{rownames(.)} has {hp} hp&#34;)&#xA;glued_data&#xA;#&amp;gt; Mazda RX4 has 110 hp&#xA;#&amp;gt; Mazda RX4 Wag has 110 hp&#xA;#&amp;gt; Datsun 710 has 93 hp&#xA;#&amp;gt; Hornet 4 Drive has 110 hp&#xA;#&amp;gt; Hornet Sportabout has 175 hp&#xA;#&amp;gt; Valiant has 105 hp&#xA;unglue_data(glued_data, &#34;{rownames(.)} has {hp} hp&#34;)&#xA;#&amp;gt;         rownames...  hp&#xA;#&amp;gt; 1         Mazda RX4 110&#xA;#&amp;gt; 2     Mazda RX4 Wag 110&#xA;#&amp;gt; 3        Datsun 710  93&#xA;#&amp;gt; 4    Hornet 4 Drive 110&#xA;#&amp;gt; 5 Hornet Sportabout 175&#xA;#&amp;gt; 6           Valiant 105&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;use several patterns, the first that matches will be used&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;facts &amp;lt;- c(&#34;Antarctica is the largest desert in the world!&#34;,&#xA;&#34;The largest country in Europe is Russia!&#34;,&#xA;&#34;The smallest country in Europe is Vatican!&#34;,&#xA;&#34;Disneyland is the most visited place in Europe! Disneyland is in Paris!&#34;,&#xA;&#34;The largest island in the world is Green Land!&#34;)&#xA;facts_df &amp;lt;- data.frame(id = 1:5, facts)&#xA;&#xA;patterns &amp;lt;- c(&#34;The {adjective} {place_type} in {bigger_place} is {place}!&#34;,&#xA;            &#34;{place} is the {adjective} {place_type=[^ ]+} in {bigger_place}!{=.*}&#34;)&#xA;unglue_data(facts, patterns)&#xA;#&amp;gt;        place    adjective place_type bigger_place&#xA;#&amp;gt; 1 Antarctica      largest     desert    the world&#xA;#&amp;gt; 2     Russia      largest    country       Europe&#xA;#&amp;gt; 3    Vatican     smallest    country       Europe&#xA;#&amp;gt; 4 Disneyland most visited      place       Europe&#xA;#&amp;gt; 5 Green Land      largest     island    the world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the second pattern uses some regex, regex needs to be typed after an &lt;code&gt;=&lt;/code&gt; sign, if its has no left hand side then the expression won’t be attributed to a variable. in fact the pattern &lt;code&gt;&#34;{foo}&#34;&lt;/code&gt; is a shorthand for &lt;code&gt;&#34;{foo=.*?}&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;escaping characters&lt;/h3&gt; &#xA;&lt;p&gt;Special characters outside of the curly braces should not be escaped.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sentences &amp;lt;- c(&#34;666 is [a number]&#34;, &#34;foo is [a word]&#34;, &#34;42 is [the answer]&#34;, &#34;Area 51 is [unmatched]&#34;)&#xA;patterns2 &amp;lt;- c(&#34;{number=\\d+} is [{what}]&#34;, &#34;{word=\\D+} is [{what}]&#34;)&#xA;unglue_data(sentences, patterns2)&#xA;#&amp;gt;   number       what word&#xA;#&amp;gt; 1    666   a number &amp;lt;NA&amp;gt;&#xA;#&amp;gt; 2   &amp;lt;NA&amp;gt;     a word  foo&#xA;#&amp;gt; 3     42 the answer &amp;lt;NA&amp;gt;&#xA;#&amp;gt; 4   &amp;lt;NA&amp;gt;       &amp;lt;NA&amp;gt; &amp;lt;NA&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;type conversion&lt;/h3&gt; &#xA;&lt;p&gt;In order to convert types automatically we can set &lt;code&gt;convert = TRUE&lt;/code&gt;, in the example above the column &lt;code&gt;number&lt;/code&gt; will be converted to numeric.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;unglue_data(sentences, patterns2, convert = TRUE)&#xA;#&amp;gt;   number       what word&#xA;#&amp;gt; 1    666   a number &amp;lt;NA&amp;gt;&#xA;#&amp;gt; 2     NA     a word  foo&#xA;#&amp;gt; 3     42 the answer &amp;lt;NA&amp;gt;&#xA;#&amp;gt; 4     NA       &amp;lt;NA&amp;gt; &amp;lt;NA&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;convert = TRUE&lt;/code&gt; triggers the use of &lt;code&gt;utils::type.convert&lt;/code&gt; with parameter &lt;code&gt;as.is = TRUE&lt;/code&gt;. We can also set &lt;code&gt;convert&lt;/code&gt; to another conversion function such as &lt;code&gt;readr::type_convert&lt;/code&gt;, or to a formula is &lt;em&gt;rlang&lt;/em&gt; is installed.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;unglue_unnest()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;unglue_unnest()&lt;/code&gt; is named as a tribute to &lt;code&gt;tidyr::unnest()&lt;/code&gt; as it’s equivalent to using successively &lt;code&gt;unglue()&lt;/code&gt; and &lt;code&gt;unnest()&lt;/code&gt; on a data frame column. It is similar to &lt;code&gt;tidyr::extract()&lt;/code&gt; in its syntax and efforts were made to make it as consistent as possible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;unglue_unnest(facts_df, facts, patterns)&#xA;#&amp;gt;   id      place    adjective place_type bigger_place&#xA;#&amp;gt; 1  1 Antarctica      largest     desert    the world&#xA;#&amp;gt; 2  2     Russia      largest    country       Europe&#xA;#&amp;gt; 3  3    Vatican     smallest    country       Europe&#xA;#&amp;gt; 4  4 Disneyland most visited      place       Europe&#xA;#&amp;gt; 5  5 Green Land      largest     island    the world&#xA;unglue_unnest(facts_df, facts, patterns, remove = FALSE)&#xA;#&amp;gt;   id                                                                   facts&#xA;#&amp;gt; 1  1                          Antarctica is the largest desert in the world!&#xA;#&amp;gt; 2  2                                The largest country in Europe is Russia!&#xA;#&amp;gt; 3  3                              The smallest country in Europe is Vatican!&#xA;#&amp;gt; 4  4 Disneyland is the most visited place in Europe! Disneyland is in Paris!&#xA;#&amp;gt; 5  5                          The largest island in the world is Green Land!&#xA;#&amp;gt;        place    adjective place_type bigger_place&#xA;#&amp;gt; 1 Antarctica      largest     desert    the world&#xA;#&amp;gt; 2     Russia      largest    country       Europe&#xA;#&amp;gt; 3    Vatican     smallest    country       Europe&#xA;#&amp;gt; 4 Disneyland most visited      place       Europe&#xA;#&amp;gt; 5 Green Land      largest     island    the world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;unglue_vec()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;While &lt;code&gt;unglue()&lt;/code&gt; returns a list of data frames, &lt;code&gt;unglue_vec()&lt;/code&gt; returns a character vector (unless &lt;code&gt;convert = TRUE&lt;/code&gt;), if several matches are found in a string the extracted match will be chosen by name or by position.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;unglue_vec(sentences, patterns2, &#34;number&#34;)&#xA;#&amp;gt; [1] &#34;666&#34; NA    &#34;42&#34;  NA&#xA;unglue_vec(sentences, patterns2, 1)&#xA;#&amp;gt; [1] &#34;666&#34; &#34;foo&#34; &#34;42&#34;  NA&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;unglue_detect()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;unglue_detect()&lt;/code&gt; returns a logical vector, it’s convenient to check that the input was matched by a pattern, or to subset the input to take a look at unmatched elements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;unglue_detect(sentences, patterns2)&#xA;#&amp;gt; [1]  TRUE  TRUE  TRUE FALSE&#xA;subset(sentences, !unglue_detect(sentences, patterns2))&#xA;#&amp;gt; [1] &#34;Area 51 is [unmatched]&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;unglue_regex()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;unglue_regex()&lt;/code&gt; returns a character vector of regex patterns, all over functions are wrapped around it and it can be used to leverage the &lt;em&gt;unglue&lt;/em&gt; in other functions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;unglue_regex(patterns)&#xA;#&amp;gt;            The {adjective} {place_type} in {bigger_place} is {place}! &#xA;#&amp;gt;                                &#34;^The (.*?) (.*?) in (.*?) is (.*?)!$&#34; &#xA;#&amp;gt; {place} is the {adjective} {place_type=[^ ]+} in {bigger_place}!{=.*} &#xA;#&amp;gt;                            &#34;^(.*?) is the (.*?) ([^ ]+) in (.*?)!.*$&#34;&#xA;unglue_regex(patterns, named_capture = TRUE)&#xA;#&amp;gt;                                 The {adjective} {place_type} in {bigger_place} is {place}! &#xA;#&amp;gt;     &#34;^The (?&amp;lt;adjective&amp;gt;.*?) (?&amp;lt;place_type&amp;gt;.*?) in (?&amp;lt;bigger_place&amp;gt;.*?) is (?&amp;lt;place&amp;gt;.*?)!$&#34; &#xA;#&amp;gt;                      {place} is the {adjective} {place_type=[^ ]+} in {bigger_place}!{=.*} &#xA;#&amp;gt; &#34;^(?&amp;lt;place&amp;gt;.*?) is the (?&amp;lt;adjective&amp;gt;.*?) (?&amp;lt;place_type&amp;gt;[^ ]+) in (?&amp;lt;bigger_place&amp;gt;.*?)!.*$&#34;&#xA;unglue_regex(patterns, attributes = TRUE)&#xA;#&amp;gt;            The {adjective} {place_type} in {bigger_place} is {place}! &#xA;#&amp;gt;                                &#34;^The (.*?) (.*?) in (.*?) is (.*?)!$&#34; &#xA;#&amp;gt; {place} is the {adjective} {place_type=[^ ]+} in {bigger_place}!{=.*} &#xA;#&amp;gt;                            &#34;^(.*?) is the (.*?) ([^ ]+) in (.*?)!.*$&#34; &#xA;#&amp;gt; attr(,&#34;groups&#34;)&#xA;#&amp;gt; attr(,&#34;groups&#34;)$`The {adjective} {place_type} in {bigger_place} is {place}!`&#xA;#&amp;gt;    adjective   place_type bigger_place        place &#xA;#&amp;gt;            1            2            3            4 &#xA;#&amp;gt; &#xA;#&amp;gt; attr(,&#34;groups&#34;)$`{place} is the {adjective} {place_type=[^ ]+} in {bigger_place}!{=.*}`&#xA;#&amp;gt;        place    adjective   place_type bigger_place &#xA;#&amp;gt;            1            2            3            4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;unglue_sub()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;unglue_sub()&lt;/code&gt; substitute substrings using strings or replacement functions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;unglue_sub(&#xA;  c(&#34;a and b&#34;, &#34;foo or BAR&#34;),&#xA;  c(&#34;{x} and {y}&#34;, &#34;{x} or {z}&#34;),&#xA;  list(x= &#34;XXX&#34;, y = toupper, z = ~tolower(.)))&#xA;#&amp;gt; [1] &#34;XXX and B&#34;  &#34;XXX or bar&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;duplicated labels&lt;/h3&gt; &#xA;&lt;p&gt;We can ensure that a pattern is repeated by repeating its label&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;unglue_data(c(&#34;black is black&#34;,&#34;black is dark&#34;), &#34;{color} is {color}&#34;)&#xA;#&amp;gt;   color&#xA;#&amp;gt; 1 black&#xA;#&amp;gt; 2  &amp;lt;NA&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can change this behavior by feeding a function to the &lt;code&gt;multiple&lt;/code&gt; parameter, in that case this function will be applied on the matches.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;unglue_data(c(&#34;System: Windows, Version: 10&#34;,&#34;System: Ubuntu, Version: 18&#34;), &#xA;            &#34;System: {OS}, Version: {OS}&#34;, multiple = paste)&#xA;#&amp;gt;           OS&#xA;#&amp;gt; 1 Windows 10&#xA;#&amp;gt; 2  Ubuntu 18&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>cjbayesian/walmart</title>
    <updated>2022-11-27T01:39:19Z</updated>
    <id>tag:github.com,2022-11-27:/cjbayesian/walmart</id>
    <link href="https://github.com/cjbayesian/walmart" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Visualize walmart store openings&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Walmart Store Opening Visualization&lt;/h1&gt; &#xA;&lt;p&gt;A time series visualization of Walmart store openings in the US.&lt;/p&gt; &#xA;&lt;p&gt;Author: Corey Chivers&lt;/p&gt; &#xA;&lt;p&gt;Contact: &lt;a href=&#34;mailto:corey.chivers@mail.mcgill.ca&#34;&gt;corey.chivers@mail.mcgill.ca&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Date: 2012-08-26&lt;/p&gt; &#xA;&lt;p&gt;Video: &lt;a href=&#34;http://bayesianbiologist.com/2012/08/26/walmart-invasion/&#34;&gt;BayesianBiologist&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Walmart data from: (&lt;a href=&#34;http://www.econ.umn.edu/~holmes/data/WalMart/index.html&#34;&gt;http://www.econ.umn.edu/~holmes/data/WalMart/index.html&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;Zipcode data from: (&lt;a href=&#34;http://www.boutell.com/zipcodes/&#34;&gt;http://www.boutell.com/zipcodes/&lt;/a&gt;)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dlebauer/pecan-priors</title>
    <updated>2022-11-27T01:39:19Z</updated>
    <id>tag:github.com,2022-11-27:/dlebauer/pecan-priors</id>
    <link href="https://github.com/dlebauer/pecan-priors" rel="alternate"></link>
    <summary type="html">&lt;p&gt;demonstration of methods used to elicit priors from data and expert knowledge&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;update: this code is now being maintained at &lt;a href=&#34;https://github.com/PecanProject/pecan/raw/master/modules/priors/vignettes/priors_demo.Rmd&#34;&gt;https://github.com/PecanProject/pecan/blob/master/modules/priors/vignettes/priors_demo.Rmd&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Generating Priors based on Data and / or Expert knowledge:&lt;/h1&gt; &#xA;&lt;h2&gt;Fitting priors to data (point estimates, all grass species in GLOPNET).&lt;/h2&gt; &#xA;&lt;h3&gt;Example: Specific Leaf Area based on all grasses&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r&#34;&gt;library(PEcAn.priors)&#xA;library(DEoptim)&#xA;set.seed(1)&#xA;iter &amp;lt;-10000 #jags chain and misc simulation length; 1k for test, 10k for real&#xA;inits &amp;lt;- list(list(.RNG.seed = 1,&#xA;                   .RNG.name = &#34;base::Mersenne-Twister&#34;),&#xA;              list(.RNG.seed = 2,&#xA;                   .RNG.name = &#34;base::Mersenne-Twister&#34;),&#xA;              list(.RNG.seed = 3,&#xA;                   .RNG.name = &#34;base::Mersenne-Twister&#34;),&#xA;              list(.RNG.seed = 4,&#xA;                   .RNG.name = &#34;base::Mersenne-Twister&#34;))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MLE Fit to glopnet Specific Leaf Area data&lt;/h3&gt; &#xA;&lt;p&gt;fit.dist function is in &lt;code&gt;PEcAn.priors::fit.dist&lt;/code&gt; (See source code: &lt;a href=&#34;https://github.com/PecanProject/pecan/raw/master/modules/priors/R/priors.R&#34;&gt;https://github.com/PecanProject/pecan/blob/master/modules/priors/R/priors.R&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;devtools::install_github(&#34;pecanproject/pecan/modules/priors&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r&#34;&gt;&#xA;# devtools::install(&#34;pecanproject/pecan/modules/priors&#34;)&#xA;glopnet.data &amp;lt;- read.csv(&#39;inst/extdata/glopnet.csv&#39;) # Wright et. al. 2004 supplementary file &#xA;glopnet.grass &amp;lt;- glopnet.data[which(glopnet.data$GF == &#39;G&#39;), ] # GF = growth form; G=grass &#xA;&#xA;## turnover time (tt)&#xA;glopnet.grass$tt    &amp;lt;- 12/10^(glopnet.grass$log.LL)&#xA;ttdata &amp;lt;- data.frame(tt = glopnet.grass$tt[!is.na(glopnet.grass$tt)])&#xA;## specific leaf area&#xA;##glopnet.grass$sla   &amp;lt;- 1000/ (0.48 * 10^glopnet.grass$log.LMA)&#xA;glopnet.grass$sla   &amp;lt;- 1000/ (10^glopnet.grass$log.LMA)&#xA;sladata &amp;lt;- data.frame(sla = glopnet.grass$sla[!is.na(glopnet.grass$sla)])&#xA;&#xA;&#xA;dists &amp;lt;- c(&#39;gamma&#39;, &#39;lognormal&#39;,&#39;weibull&#39;, &#39;f&#39;)&#xA;fit.dist &amp;lt;- PEcAn.priors::fit.dist&#xA;prior.dists &amp;lt;- rbind(&#39;SLA&#39; = fit.dist(sladata, dists ), &#xA;                     &#39;leaf_turnover_rate&#39; = fit.dist(ttdata, dists))&#xA;&#xA;slaprior &amp;lt;- with(prior.dists[&#39;SLA&#39;,], prior.density(distribution, a, b))&#xA;ttprior &amp;lt;- with(prior.dists[&#39;leaf_turnover_rate&#39;,], prior.density(distribution, a, b))&#xA;&#xA;prior.figures[[&#39;SLA&#39;]]                &amp;lt;- priorfig(priordata = sladata, &#xA;                                                  priordensity = slaprior, &#xA;                                                  trait = &#39;SLA&#39;)&#xA;prior.figures[[&#39;leaf_turnover_rate&#39;]] &amp;lt;- priorfig(priordata = ttdata, &#xA;                                                  priordensity = ttprior, &#xA;                                                  trait = &#39;leaf_turnover_rate&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;fit.dist&lt;/code&gt; function takes a vector of point estimates (in this case 125 observations of Specific Leaf Area from GLOPNET database are stored in &lt;code&gt;sladata&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;First, it prints out the fits of a subset of distributions (the &#39;f&#39; distribution could not be fit). Second, it prints the&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;dists =  c(&#39;gamma&#39;, &#39;lognormal&#39;,&#39;weibull&#39;, &#39;f&#39;)&#xA;fit.dist(sladata, dists )&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;priorfig&lt;/code&gt; function visualizes the chosen prior (line), with its mean and 95%CI (dots) as well as the data used to generate the figure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r&#34;&gt;## priorfig(priordata = sladata, &#xA;##                                                  priordensity = slaprior, &#xA;##                                                  trait = &#39;SLA&#39;)&#xA;print(prior.figures$SLA)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Fitting priors to data with uncertainty estimates (generating posterior predictive distribution of an unobserved C4 grass species based on values collected from many PFTs.&lt;/h2&gt; &#xA;&lt;h3&gt;Vcmax data from Wullschleger (1993)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;wullschleger.data &amp;lt;- read.csv(&#39;inst/extdata/wullschleger1993updated.csv&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Classify Wullschleger Data into Functional Types&lt;/h3&gt; &#xA;&lt;h4&gt;1. query functional types from BETY&lt;/h4&gt; &#xA;&lt;p&gt;This code is not run here - data are provided in .csv file below. This code requires connection to the BETYdb MySQL server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r&#34;&gt;wullschleger.species &amp;lt;- vecpaste(unique(wullschleger.data$AcceptedSymbol))&#xA;## load functional type data from BETY&#xA;con &amp;lt;- function() {query.bety.con(username = &#34;bety&#34;, password = &#34;bety&#34;, &#xA;                                   host = &#34;localhost&#34;, dbname = &#34;bety&#34;)}&#xA;functional.data &amp;lt;- query.bety(paste(&#34;select distinct AcceptedSymbol, scientificname, GrowthHabit, Category from species where AcceptedSymbol in (&#34;, wullschleger.species, &#34;) and GrowthHabit is not NULL and Category is not NULL;&#34;), con())&#xA;write.csv(functional.data, &#39;inst/extdata/wullschleger_join_usdaplants.csv&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Picking up with the Wullschleger dataset joined to USDA Plants functional type classifications ...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r&#34;&gt;functional.data &amp;lt;- read.csv(&#39;inst/extdata/wullschleger_join_usdaplants.csv&#39;)&#xA;&#xA;subshrubs &amp;lt;- rownames(wullschleger.data) %in% c(grep(&#39;Shrub&#39;,wullschleger.data$GrowthHabit), grep(&#39;Subshrub&#39;, wullschleger.data$GrowthHabit))&#xA;########## 2. Merge functional type information into Wullschleger data&#xA;wullschleger.data &amp;lt;- merge(wullschleger.data, functional.data, by = &#39;AcceptedSymbol&#39;)&#xA;########## 3. Classify by functional type&#xA;## grass: any Graminoid Monocot&#xA;grass &amp;lt;- with(wullschleger.data, GrowthHabit == &#39;Graminoid&#39; &amp;amp; Category == &#39;Monocot&#39;)&#xA;## forbs/herbs = forb&#xA;forb &amp;lt;- with(wullschleger.data, GrowthHabit == &#39;Forb/herb&#39; | GrowthHabit == &#39;Vine, Forb/herb&#39;)&#xA;## woody = Shrubs, Subshrubs or Trees, add category to a few with missing information, &#xA;woody &amp;lt;- with(wullschleger.data, scientificname %in% c(&#39;Acacia ligulata&#39;, &#39;Acacia mangium&#39;, &#39;Arbutus unedo&#39;, &#39;Eucalyptus pauciflora&#39;, &#39;Malus&#39;, &#39;Salix&#39;) |  rownames(wullschleger.data) %in% c(grep(&#39;Shrub&#39;, GrowthHabit), grep(&#39;Subshrub&#39;, GrowthHabit), grep(&#39;Tree&#39;, GrowthHabit)))&#xA;## gymnosperms&#xA;gymnosperm &amp;lt;- wullschleger.data$Category == &#39;Gymnosperm&#39;&#xA;## ambiguous is both woody and herbaceous, will drop&#xA;ambiguous &amp;lt;- wullschleger.data$GrowthHabit %in% c(&#34;Subshrub, Shrub, Forb/herb, Tree&#34;, &#34;Tree, Subshrub, Shrub&#34;, &#34;Tree, Shrub, Subshrub, Forb/herb&#34;, &#34;Subshrub, Forb/herb&#34;)&#xA;&#xA;wullschleger.data$functional.type[grass] &amp;lt;- 1&#xA;wullschleger.data$functional.type[forb]  &amp;lt;- 3&#xA;wullschleger.data$functional.type[woody &amp;amp; !gymnosperm] &amp;lt;- 4&#xA;wullschleger.data$functional.type[woody &amp;amp; gymnosperm] &amp;lt;- 5&#xA;wullschleger.data &amp;lt;- subset(wullschleger.data, !ambiguous)     &#xA;&#xA;############# Estimating SE and n ##################################&#xA;##verr, jerr: the &#34;asymptotic&#34; errors for Vcmax, Jmax using SAS nlim&#xA;##vucl,vlcl,jlcl,jucl: are upper and lower confidence limits of 95%CI&#xA;&#xA;##Calculate SD as (1/2 the 95%CI)/1.96&#xA;wullschleger.data$vsd &amp;lt;- (wullschleger.data$vucl-wullschleger.data$vlcl)/(2*1.96)&#xA;&#xA;##Calculate effective N as (SE/SD)^2 + 1&#xA;wullschleger.data$neff &amp;lt;- (wullschleger.data$vse/wullschleger.data$vsd)^2 + 1&#xA;wullschleger.data$se   &amp;lt;- sqrt(wullschleger.data$vsd*sqrt(wullschleger.data$neff))&#xA;## recode species to numeric&#xA;species &amp;lt;- unique(wullschleger.data$scientificname)&#xA;sp &amp;lt;- rep(NA, nrow(wullschleger.data))&#xA;for(i in seq(species)){&#xA;  sp[wullschleger.data$scientificname == species[i]] &amp;lt;- i&#xA;} &#xA;&#xA;############# Scale values to 25C ##################################&#xA;wullschleger.data$corrected.vcmax &amp;lt;- arrhenius.scaling(wullschleger.data$vcmax, &#xA;                                     old.temp = wullschleger.data$temp, &#xA;                                     new.temp = 25)&#xA;&#xA;############# Create data.frame for JAGS model ##################################&#xA;wullschleger.data &amp;lt;- data.frame(Y  = wullschleger.data$corrected.vcmax,&#xA;                                obs.prec = 1 / (sqrt(wullschleger.data$neff) * wullschleger.data$se),&#xA;                                sp = sp,&#xA;                                ft = wullschleger.data$functional.type,&#xA;                                n  = wullschleger.data$neff)&#xA;## Summarize data by species&#xA;wullschleger.vcmax &amp;lt;- ddply(wullschleger.data, &#xA;                            .(sp),&#xA;                            summarise, &#xA;                            Y = mean(Y), &#xA;                            obs.prec = 1/sqrt(sum((1/obs.prec)^2)), &#xA;                            ft = mean(ft), # identity&#xA;                            n =  sum(n)) [,-1]&#xA;                                        &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Add data from C4 species&lt;/h5&gt; &#xA;&lt;p&gt;Few measurements of Vcmax for C4 species were available.&lt;/p&gt; &#xA;&lt;h6&gt;Miscanthus: Wang D, Maughan MW, Sun J, Feng X, Miguez FE, Lee DK, Dietze MC, 2011. Impact of canopy nitrogen allocation on growth and photosynthesis of miscanthus (Miscanthus x giganteus). Oecologia, in press&lt;/h6&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;dwang.vcmax &amp;lt;- c(19.73, 40.35, 33.02, 21.28, 31.45, 27.83, 9.69, 15.99, 18.88, 11.45, 15.81, 27.61, 13, 21.25, 22.01, 10.37, 12.37, 22.8, 12.24, 15.85, 21.93, 23.48, 31.51, 23.16, 18.55, 17.06, 20.27, 30.41)&#xA;dwang.vcmax &amp;lt;- data.frame(Y = mean(dwang.vcmax), &#xA;                          obs.prec = 1/sd(dwang.vcmax),&#xA;                          ft = 2,         #C4 Grass&#xA;                          n = length(dwang.vcmax))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;Muhlenbergia glomerata&lt;/h6&gt; &#xA;&lt;p&gt;Kubien and Sage 2004. Low-temperature photosynthetic performance of a C4 grass and a co-occurring C3 grass native to high latitudes. Plant, Cell &amp;amp; Environment DOI: 10.1111/j.1365-3040.2004.01196.x&lt;/p&gt; &#xA;&lt;p&gt;Data from figure 5 in Kubien and Sage (2004), average across plants grown at 14/10 degrees and 26/22 degrees&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;kubien.vcmax &amp;lt;- data.frame(Y = mean(23.4, 24.8), &#xA;                           obs.prec = 1/sqrt(2.6^2 + 2.5^2), &#xA;                           n = 8, &#xA;                           ft = 2)                      &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h6&gt;Zea Mays (Corn)&lt;/h6&gt; &#xA;&lt;p&gt;Massad, Tuzet, Bethenod 2007. The effect of temperature on C4-type leaf photosynthesis parameters. Plant, Cell &amp;amp; Environment 30(9) 1191-1204. DOI: 10.1111/j.1365-3040.2007.01691.x&lt;/p&gt; &#xA;&lt;p&gt;data from fig 6a&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;massad.vcmax.data &amp;lt;- data.frame(vcmax = c(17.1, 17.2, 17.6, 18, 18.3, 18.5, 20.4, 22.9, 22.9, 21.9, 21.8, 22.7, 22.3, 25.3, 24.4, 25.5, 25.5, 24.9, 31.2, 30.8, 31.6, 31.7, 32.5, 34.1, 34.2, 33.9, 35.4, 36, 36, 37.5, 38.2, 38.1, 37.4, 37.7, 25.2, 25.5), &#xA;                                temp = c(20.5, 24.6, 21, 19, 21.9, 15, 19.6, 14.3, 20.8, 23.4, 24.8, 25.9, 24.1, 22.8, 27.9, 31.7, 35.5, 39.3, 37.9, 42.4, 41.5, 48.7, 33.3, 33.3, 31.5, 39.1, 38.8, 43.3, 50, 38.4, 35.7, 34.4, 31.9, 33.9, 32.1, 33.7))&#xA;massad.vcmax &amp;lt;- with(massad.vcmax.data, arrhenius.scaling(old.temp = temp, &#xA;                                                          new.temp = 25, &#xA;                                                          observed.value = vcmax))&#xA;&#xA;massad.vcmax &amp;lt;- data.frame(Y  = mean(massad.vcmax),&#xA;                           obs.prec = 1/(sd(massad.vcmax)),&#xA;                           n  = length(massad.vcmax),&#xA;                           ft = 2)&#xA;&#xA;##### Combine all data sets&#xA;all.vcmax.data &amp;lt;- rbind(wullschleger.vcmax,&#xA;                        dwang.vcmax, &#xA;                        ## xfeng.vcmax, &#xA;                        kubien.vcmax, &#xA;                        massad.vcmax)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;take a look at the raw data by functional type:&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;qplot(data = all.vcmax.data, x = factor(ft), y = Y, geom = &#39;boxplot&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Add unobserved C4 species so JAGS calculates posterior predictive distribution&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;vcmax.data &amp;lt;- rbind(all.vcmax.data, &#xA;                    data.frame(Y = NA, obs.prec = NA, ft = 2, n = 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Write and Run Meta-analysis&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;writeLines(con = &#34;vcmax.prior.bug&#34;, &#xA;           text =  &#34;model{  &#xA;             for (k in 1:length(Y)){&#xA;               Y[k]  ~ dnorm(beta.ft[ft[k]], tau.y[k])T(0,)&#xA;               tau.y[k] &amp;lt;- prec.y*n[k]&#xA;               u1[k] &amp;lt;- n[k]/2                             &#xA;               u2[k] &amp;lt;- n[k]/(2*prec.y)&#xA;               obs.prec[k] ~ dgamma(u1[k], u2[k])&#xA;             }&#xA;             for (f in 1:5){&#xA;               beta.ft[f] ~ dnorm(0, tau.ft)&#xA;             }&#xA;             tau.ft ~ dgamma(0.1, 0.1)&#xA;             prec.y    ~ dgamma(0.1, 0.1)     &#xA;             sd.y      &amp;lt;- 1 / sqrt(prec.y)&#xA;             ## estimating posterior predictive for new C4 species&#xA;             pi.pavi &amp;lt;- Y[length(Y)]&#x9;     &#xA;             diff &amp;lt;- beta.ft[1] - beta.ft[2]&#xA;           }&#34;)&#xA;&#xA;j.model  &amp;lt;- jags.model(file = &#34;vcmax.prior.bug&#34;, &#xA;                       data = vcmax.data, &#xA;                       n.adapt = 500, &#xA;                       n.chains = 4,&#xA;                       inits = inits)&#xA;&#xA;mcmc.object &amp;lt;- coda.samples(model = j.model, variable.names = c(&#39;pi.pavi&#39;, &#39;beta.ft&#39;, &#39;diff&#39;),&#xA;                            n.iter = iter)&#xA;mcmc.o     &amp;lt;- window(mcmc.object, start = iter/2, thin = 10)&#xA;pi.pavi    &amp;lt;- data.frame(vcmax = unlist(mcmc.o[,&#39;pi.pavi&#39;]))&#xA;vcmax.dist &amp;lt;- fit.dist(pi.pavi, n = sum(!is.na(vcmax.data$Y)))&#xA;&#xA;prior.dists   &amp;lt;- rbind(prior.dists, &#39;Vcmax&#39; = vcmax.dist)&#xA;vcmax.density &amp;lt;- with(vcmax.dist, prior.density(distribution, a, b), xlim = c(0,50))&#xA;&#xA;######### Vcmax Prior Plot&#xA;vcmax.c4 &amp;lt;- all.vcmax.data$ft == 2&#xA;vcmax.data &amp;lt;- transform(all.vcmax.data, mean = Y, se =  1/(sqrt(n) * obs.prec))[,c(&#39;ft&#39;, &#39;mean&#39;, &#39;se&#39;)]&#xA;#vcmax.mean &amp;lt;- all.vcmax.data$Y[!c4,]&#xA;#vcmax.se   &amp;lt;- with(all.vcmax.data[!c4,], 1/(sqrt(n) * obs.prec))#[reorder]&#xA;#c4.mean &amp;lt;- all.vcmax.data$Y)[c4]&#xA;#c4.se   &amp;lt;- with(all.vcmax.data, 1 / (sqrt(n) * obs.prec) )[c4]&#xA;&#xA;prior.figures[[&#39;Vcmax&#39;]] &amp;lt;- &#xA;  priorfig(priordensity = vcmax.density, &#xA;                                     trait = &#39;Vcmax&#39;, &#xA;                                     xlim = range(c(0, max(vcmax.data$mean)))) + &#xA;  geom_point(data = subset(vcmax.data, ft != 2), &#xA;             aes(x=mean, y = (sum(vcmax.c4) + 1:sum(!vcmax.c4))/3000), color = &#39;grey60&#39;) +&#xA;  geom_segment(data = subset(vcmax.data, ft != 2),&#xA;               aes(x = mean - se, xend = mean + se, &#xA;                   y = (sum(vcmax.c4) + 1:sum(!vcmax.c4))/3000, &#xA;                   yend = (sum(vcmax.c4) + 1:sum(!vcmax.c4))/3000),&#xA;               color = &#39;grey60&#39;) +&#xA;  ## darker color for C4 grasses&#xA;  geom_point(data = subset(vcmax.data, ft == 2),&#xA;             aes(x=mean, y = 1:sum(vcmax.c4)/2000), size = 3) +&#xA;  geom_segment(data = subset(vcmax.data, ft == 2),&#xA;               aes(x = mean - se, xend = mean + se, &#xA;                   y = 1:sum(vcmax.c4)/2000, yend = 1:sum(vcmax.c4)/2000))&#xA;&#xA;print(prior.figures[[&#39;Vcmax&#39;]])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Fitting priors to expert constraint ().&lt;/h2&gt; &#xA;&lt;h3&gt;Example: Minimum temperature of Photosynthesis&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r&#34;&gt;TBD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Other Examples / Approaches&lt;/h2&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Estimating priors for the DALEC model in [models/dalec/inst/DALEC_priors.R](&lt;a href=&#34;https://github.com/PecanProject/pecan/raw/master/models/dalec/inst/DALEC_priors.R&#34;&gt;https://github.com/PecanProject/pecan/blob/master/models/dalec/inst/DALEC_priors.R&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Package &lt;code&gt;rriskDistributions&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;http://cran.r-project.org/web/packages/rriskDistributions/index.html&#34;&gt;rriskDistributions&lt;/a&gt; useful for estimating priors ...&lt;/p&gt; &#xA;&lt;p&gt;as well as individual functions for each distribution such as &lt;code&gt;get.&amp;lt;somedist&amp;gt;.par&lt;/code&gt; that provide nice diagnostic plots (e.g. compare chosen points to cdf) for example, to compute the parameters of a Gamma distribution that fits a median of 2.5 and has a 95%CI of [1, 10]:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(rriskDistributions)&#xA;get.gamma.par(p = c(0.025, 0.50, 0.975), q = c(1, 2.5, 10), tol = 0.1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function &lt;code&gt;fit.pecr&lt;/code&gt; provides a GUI to explore the fits of a range of distributions, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-{r&#34;&gt;fit.perc(p = c(0.1, 0.5, 0.9), q = c(30, 60, 90), tolConv = 0.1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;produces this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/18092793/fit.perc_example.PNG&#34; alt=&#34;image of rriskDistributions example that uses GUI&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>