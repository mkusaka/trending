<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-17T01:52:59Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sykdomspulsen-org/spldata</title>
    <updated>2022-06-17T01:52:59Z</updated>
    <id>tag:github.com,2022-06-17:/sykdomspulsen-org/spldata</id>
    <link href="https://github.com/sykdomspulsen-org/spldata" rel="alternate"></link>
    <summary type="html">&lt;p&gt;spldata contains preformatted structural data for Norway.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;spldata &lt;a href=&#34;https://docs.sykdomspulsen.no/spldata&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sykdomspulsen-org/spldata/main/man/figures/logo.png&#34; align=&#34;right&#34; width=&#34;120&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.sykdomspulsen.no/spldata&#34;&gt;spldata&lt;/a&gt; contains preformatted structural data for Norway.&lt;/p&gt; &#xA;&lt;p&gt;Datasets relating to maps, population in municipalities, municipality/county matching, and how different municipalities have merged/redistricted over time from 2006 to 2020.&lt;/p&gt; &#xA;&lt;p&gt;Read the introduction vignette &lt;a href=&#34;http://docs.sykdomspulsen.no/splmaps/articles/spldata.html&#34;&gt;here&lt;/a&gt; or run &lt;code&gt;help(package=&#34;spldata&#34;)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;splverse&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.sykdomspulsen.no/packages&#34;&gt;&lt;img src=&#34;https://docs.sykdomspulsen.no/packages/splverse.png&#34; align=&#34;right&#34; width=&#34;120&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://docs.sykdomspulsen.no/packages&#34;&gt;splverse&lt;/a&gt; is a set of R packages developed to help solve problems that frequently occur when performing infectious disease surveillance.&lt;/p&gt; &#xA;&lt;p&gt;If you want to install the dev versions (or access packages that haven&#39;t been released on CRAN), run &lt;code&gt;usethis::edit_r_profile()&lt;/code&gt; to edit your &lt;code&gt;.Rprofile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Then write in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;options(&#xA;  repos = structure(c(&#xA;    SPLVERSE  = &#34;https://docs.sykdomspulsen.no/drat/&#34;,&#xA;    CRAN      = &#34;https://cran.rstudio.com&#34;&#xA;  ))&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Save the file and restart R.&lt;/p&gt; &#xA;&lt;p&gt;You can now install &lt;a href=&#34;https://docs.sykdomspulsen.no/packages&#34;&gt;splverse&lt;/a&gt; packages from our &lt;a href=&#34;https://docs.sykdomspulsen.no/drat&#34;&gt;drat repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;install.packages(&#34;splmaps&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>hadley/mastering-shiny</title>
    <updated>2022-06-17T01:52:59Z</updated>
    <id>tag:github.com,2022-06-17:/hadley/mastering-shiny</id>
    <link href="https://github.com/hadley/mastering-shiny" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mastering Shiny: a book&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/hadley/mastering-shiny/actions?workflow=.github/workflows/build-book.yaml&#34;&gt;&lt;img src=&#34;https://github.com/hadley/mastering-shiny/workflows/.github/workflows/build-book.yaml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;This is the work-in-progress repo for the book &lt;em&gt;Mastering Shiny&lt;/em&gt; by Hadley Wickham. It is licensed under the Creative Commons &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/4.0/&#34;&gt;Attribution-NonCommercial-NoDerivatives 4.0 International License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Built with &lt;a href=&#34;https://bookdown.org/yihui/bookdown/&#34;&gt;bookdown&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Images&lt;/h2&gt; &#xA;&lt;p&gt;There are three directories for images:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;diagrams/&lt;/code&gt; contains omnigraffle diagrams. Source of truth is &lt;code&gt;.graffle&lt;/code&gt; files. Can delete all subdirectories.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;screenshots/&lt;/code&gt; contains programmatic screenshots. Source of truth is book code. Can delete all subdirectories.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;images/&lt;/code&gt; contains images created some other way. Images are source of truth and should not be deleted.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>FelixTheStudent/cellpypes</title>
    <updated>2022-06-17T01:52:59Z</updated>
    <id>tag:github.com,2022-06-17:/FelixTheStudent/cellpypes</id>
    <link href="https://github.com/FelixTheStudent/cellpypes" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cell type pipes for R&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;cellpypes – Cell type pipes for R&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/#pipe-your-types&#34;&gt;Pipe your types!&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/#citation&#34;&gt;Citation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/#cellpypes-input&#34;&gt;cellpypes input&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/#list-of-functions&#34;&gt;List of functions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/#annotating-pbmcs&#34;&gt;Annotating PBMCs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/#understanding-how-cellpypes-works&#34;&gt;Understanding how cellpypes works&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/#function-demos&#34;&gt;Function demos&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/#faq&#34;&gt;FAQ&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- README.md is generated from README.Rmd. Please edit that file --&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://doi.org/10.5281/zenodo.6555728&#34;&gt;&lt;img src=&#34;https://zenodo.org/badge/DOI/10.5281/zenodo.6555728.svg?sanitize=true&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;h1&gt;Pipe your types!&lt;/h1&gt; &#xA;&lt;p&gt;Cellpypes uses the popular piping operator &lt;code&gt;%&amp;gt;%&lt;/code&gt; to manually annotate cell types in single-cell RNA sequencing data. It can be applied to UMI data (e.g.&amp;nbsp;10x Genomics).&lt;/p&gt; &#xA;&lt;p&gt;Define gene rules interactively:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/man/figures/01_CD3_MS4A1.gif&#34; alt=&#34;Pype or pype not. There is no try.&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Adjust the threshold until the selected cells agree well with marker gene expression.&lt;/li&gt; &#xA; &lt;li&gt;Use positive (CD3E+) and negative (MS4A1-) markers to annotate any subpopulation of interest.&lt;/li&gt; &#xA; &lt;li&gt;Explore with &lt;code&gt;feat&lt;/code&gt;, select with &lt;code&gt;rule&lt;/code&gt;, visualize with &lt;code&gt;plot_last&lt;/code&gt; or &lt;code&gt;plot_classes&lt;/code&gt; and get cell type labels with &lt;code&gt;classify&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Resolve detailed cell type subsets. Switch between cell type hierarchy levels in your analysis:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/man/figures/02_hierarchy.gif&#34; alt=&#34;A Jedi’s strength lies in his marker genes.&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Install cellpypes with the following commands:&lt;/p&gt; &#xA;&lt;!-- You can install the released version of cellpypes from [CRAN](https://CRAN.R-project.org) with: --&gt; &#xA;&lt;!-- ``` r --&gt; &#xA;&lt;!-- install.packages(&#34;cellpypes&#34;) --&gt; &#xA;&lt;!-- ``` --&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;devtools&#34;)&#xA;devtools::install_github(&#34;FelixTheStudent/cellpypes&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Citation&lt;/h1&gt; &#xA;&lt;p&gt;To cite cellpypes, download your favorite citation style from &lt;a href=&#34;https://zenodo.org/record/6555728#.YoNNl1xBxH4&#34;&gt;zenodo&lt;/a&gt;, type &lt;code&gt;citation(&#34;cellpypes&#34;)&lt;/code&gt; in R or simply use:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Frauhammer, Felix, &amp;amp; Anders, Simon. (2022). cellpypes: Cell Type Pipes for R (0.1.1). Zenodo. &lt;a href=&#34;https://doi.org/10.5281/zenodo.6555728&#34;&gt;https://doi.org/10.5281/zenodo.6555728&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;cellpypes input&lt;/h1&gt; &#xA;&lt;p&gt;cellpypes input has four slots:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;raw&lt;/code&gt;: (sparse) matrix with genes in rows, cells in columns&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;totalUMI&lt;/code&gt;: the colSums of obj$raw&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;embed&lt;/code&gt;: two-dimensional embedding of the cells, provided as data.frame or tibble with two columns and one row per cell.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;neighbors&lt;/code&gt;: index matrix with one row per cell and k-nearest neighbor indices in columns. We recommend k=50, but generally 15&amp;lt;k&amp;lt;100 works well. Here are two ways to get the &lt;code&gt;neighbors&lt;/code&gt; index matrix: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Use &lt;code&gt;find_knn(featureMatrix)$idx&lt;/code&gt;, where featureMatrix could be principal components, latent variables or normalized genes (features in rows, cells in columns).&lt;/li&gt; &#xA;   &lt;li&gt;use &lt;code&gt;as(seurat@graphs[[&#34;RNA_nn&#34;]], &#34;dgCMatrix&#34;)&amp;gt;.1&lt;/code&gt; to extract the kNN graph computed on RNA. This also works with RNA_snn, wknn/wsnn or any other available graph – check with &lt;code&gt;names(seurat@graphs)&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Examples for cellpypes input:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Object from scratch:&#xA;obj &amp;lt;- list(&#xA;  raw = counts,              # raw UMI, cells in columns&#xA;  neighbors = knn_ids,       # neighbor indices, cells in rows, k columns&#xA;  embed = umap,              # 2D embedding, cells in rows&#xA;  totalUMI = library_sizes   # colSums of raw, one value per cell&#xA;)&#xA;&#xA;# Object from Seurat:&#xA;obj &amp;lt;- list(&#xA;    raw      =SeuratObject::GetAssayData(seurat, &#34;counts&#34;),&#xA;    neighbors=as(seurat@graphs[[&#34;RNA_nn&#34;]], &#34;dgCMatrix&#34;)&amp;gt;.1, # sometims &#34;wknn&#34;&#xA;    embed    =FetchData(seurat, dimension_names),&#xA;    totalUMI = seurat$nCount_RNA&#xA;)&#xA;&#xA;# Object from Seurat (experimental short-cut):&#xA;obj &amp;lt;- pype_from_seurat(seurat_object)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;List of functions&lt;/h1&gt; &#xA;&lt;p&gt;Functions for manual classification:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;feat&lt;/code&gt;: feature plot (UMAP colored by gene expression)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rule&lt;/code&gt;: add a cell type rule&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;plot_last&lt;/code&gt;: plot the most recent rule or class&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;classify&lt;/code&gt;: classify cells by evaluating cell type rules&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;plot_classes&lt;/code&gt;: call and visualize &lt;code&gt;classify&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Functions for pseudobulking and differential gene expression (DE) analysis:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;class_to_deseq2&lt;/code&gt;: Create DESeq2 object for a given cell type&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pseudobulk&lt;/code&gt;: Form pseudobulks from single-cells&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pseudobulk_id&lt;/code&gt;: Generate unique IDs to identify pseudobulks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Annotating PBMCs&lt;/h1&gt; &#xA;&lt;p&gt;Here, we annotate the same PBMC data set as in the popular &lt;a href=&#34;https://satijalab.org/seurat/articles/pbmc3k_tutorial.html&#34;&gt;Seurat tutorial&lt;/a&gt;, using the Seurat object &lt;code&gt;seurat_object&lt;/code&gt; that comes out of it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(cellpypes)&#xA;library(tidyverse) # provides piping operator %&amp;gt;%&#xA;&#xA;&#xA;pype &amp;lt;- seurat_object %&amp;gt;%&#xA;  pype_from_seurat %&amp;gt;%&#xA;  rule(&#34;B&#34;,           &#34;MS4A1&#34;,   &#34;&amp;gt;&#34;, 1)                    %&amp;gt;%&#xA;  rule(&#34;CD14+ Mono&#34;,  &#34;CD14&#34;,    &#34;&amp;gt;&#34;, 1)                    %&amp;gt;%&#xA;  rule(&#34;CD14+ Mono&#34;,  &#34;LYZ&#34;,     &#34;&amp;gt;&#34;, 20)                   %&amp;gt;%&#xA;  rule(&#34;FCGR3A+ Mono&#34;,&#34;MS4A7&#34;,   &#34;&amp;gt;&#34;, 2)                    %&amp;gt;%&#xA;  rule(&#34;NK&#34;,          &#34;GNLY&#34;,    &#34;&amp;gt;&#34;, 75)                   %&amp;gt;%&#xA;  rule(&#34;DC&#34;,          &#34;FCER1A&#34;,  &#34;&amp;gt;&#34;, 1)                    %&amp;gt;%&#xA;  rule(&#34;Platelet&#34;,    &#34;PPBP&#34;,    &#34;&amp;gt;&#34;, 30)                   %&amp;gt;%&#xA;  rule(&#34;T&#34;,           &#34;CD3E&#34;,    &#34;&amp;gt;&#34;, 3.5)                  %&amp;gt;% &#xA;  rule(&#34;CD8+ T&#34;,      &#34;CD8A&#34;,    &#34;&amp;gt;&#34;, .8,  parent=&#34;T&#34;)      %&amp;gt;%&#xA;  rule(&#34;CD4+ T&#34;,      &#34;CD4&#34;,     &#34;&amp;gt;&#34;, .05, parent=&#34;T&#34;)      %&amp;gt;%&#xA;  rule(&#34;Naive CD4+&#34;,  &#34;CCR7&#34;,    &#34;&amp;gt;&#34;, 1.5, parent=&#34;CD4+ T&#34;) %&amp;gt;%&#xA;  rule(&#34;Memory CD4+&#34;,  &#34;S100A4&#34;, &#34;&amp;gt;&#34;, 13,  parent=&#34;CD4+ T&#34;)&#xA;&#xA;plot_classes(pype)+ggtitle(&#34;PBMCs annotated with cellpypes&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/man/figures/README-pbmc_rules-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;p&gt;All major cell types are annotated with cell pypes. Note how there are naive CD8+ T cells among the naive CD4 cells. While overlooked in the &lt;a href=&#34;https://satijalab.org/seurat/articles/pbmc3k_tutorial.html&#34;&gt;original tutorial&lt;/a&gt;, the marker-based nature of cellpypes revealed this. This is a good example for &lt;em&gt;cellpype&lt;/em&gt;’s resolution limit: If UMAP cannot separate cells properly, cellpypes will also struggle – but at least it will be obvious. In practice, one would re-cluster the T cells and try to separate naive CD8+ from naive CD4+, or train a specialized machine learning algorithm to discriminate these two cell types in particular.&lt;/p&gt; &#xA;&lt;h1&gt;Understanding how cellpypes works&lt;/h1&gt; &#xA;&lt;p&gt;cellpypes works with &lt;strong&gt;classes&lt;/strong&gt; defined by gene-based rules.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Whether your classes correspond to biologically relevant &lt;strong&gt;cell types&lt;/strong&gt; is best answered in a passionate discussion on their marker genes you should have with your peers.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Until you are sure, “MS4A1+” is a better class name than “B cell”.&lt;/p&gt; &#xA;&lt;h3&gt;CP10K measure UMI fractions&lt;/h3&gt; &#xA;&lt;p&gt;cellpypes uses CP10K (counts per 10 thousand) in functions &lt;code&gt;rule&lt;/code&gt; and &lt;code&gt;feat&lt;/code&gt;. This is why and what that means:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For marker genes, CP10K typically lie in the human-friendly range between 0.1 and 10 CP10K.&lt;/li&gt; &#xA; &lt;li&gt;A typical mammalian cell can be expected to have around 10K UMIs in total (&lt;a href=&#34;http://book.bionumbers.org/how-many-mrnas-are-in-a-cell/&#34;&gt;100K mRNAs&lt;/a&gt; captured with &lt;a href=&#34;https://kb.10xgenomics.com/hc/en-us/articles/360001539051-What-fraction-of-mRNA-transcripts-are-captured-per-cell-&#34;&gt;10 % conversion rate&lt;/a&gt;), so 1 CP10K means roughly 1 UMI in a typical cell.&lt;/li&gt; &#xA; &lt;li&gt;If one out of 10 thousand mRNA molecules in cells originated from CD3E, then we’d expect to observe 1 CP10K in our UMI count matrix. In reality, there is technical noise, so we might see 1 CP10K in some cells and other values in others – but by design, UMI fractions and mRNA fractions are highly correlated!&lt;/li&gt; &#xA; &lt;li&gt;CP10K are a noisy estimate of mRNA fractions. Cellpypes models this uncertainty during manual thresholding by considering the UMI counts of nearest neighbor cells as well. When deciding if cells are positive (or negative) for a marker gene, the functions &lt;code&gt;classify&lt;/code&gt;, &lt;code&gt;plot_last&lt;/code&gt; and &lt;code&gt;plot_classes&lt;/code&gt; leave cells unassigned if there was not enough evidence.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Intuition behind cell pypes&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;cellpypes compares the expression of a cell and its nearest neighbors to a user-provided threshold, taking the uncertainty due to technical noise into account.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;cellpypes assumes a cell’s nearest neighbors are transcriptionally highly similar, so that the technical noise dominates the biological variation. This means that the UMI counts for a given marker gene, say CD3E, came from cells that roughly had the same fraction of CD3E mRNA. We can not use this reasoning to infer the individual cell’s mRNA fraction reliably (which is why &lt;a href=&#34;https://f1000research.com/articles/7-1740&#34;&gt;imputation introduces artifacts&lt;/a&gt;), but we can decide with reasonable confidence whether this cell was at least part of a subpopulation in which many cells expressed this gene highly. In other words:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;In cellpypes logic, CD3E+ cells are virtually indistinguishable from cells with high CD3E expression. We just can’t prove they all had CD3E mRNA due to data sparsity.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Math/statistics behind cellpypes&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;cellpypes models UMI counts as negative binomial (NB) random variable with a fixed overdisperions of 0.01 (&lt;code&gt;size&lt;/code&gt; parameter of 100 in R’s &lt;code&gt;pnbinom&lt;/code&gt;), as recommended by Lause, Berens and Kobak (&lt;a href=&#34;https://genomebiology.biomedcentral.com/articles/10.1186/s13059-021-02451-7#Sec1&#34;&gt;Genome Biology 2021&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;The marker gene UMI counts are summed up across a cell and its neighbors, forming the pooled counts &lt;code&gt;K&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Summation allows cellpypes to use the NB distribution when comparing expression &lt;code&gt;K&lt;/code&gt; with the user-provided threshold &lt;code&gt;t&lt;/code&gt;, because &lt;a href=&#34;https://en.wikipedia.org/wiki/Negative_binomial_distribution#Distribution_of_a_sum_of_geometrically_distributed_random_variables&#34;&gt;the sum across NB random variables is again an NB random variable&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;cellpypes checks if the summed counts &lt;code&gt;K&lt;/code&gt; are likely to have come from an NB distribution with rate parameter &lt;code&gt;t*S&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the CP10K threshold supplied through the &lt;code&gt;rule&lt;/code&gt; function, and &lt;code&gt;S&lt;/code&gt; is the sum of totalUMI counts from the cell and its neighbors. If it is very likely, the counts are too close to the threshold to decide and the cell is left unassigned. If &lt;code&gt;K&lt;/code&gt; lies above the expectancy &lt;code&gt;t*S&lt;/code&gt;, the cell is marked as positive, if below, it is marked as negative for the given marker gene.&lt;/li&gt; &#xA; &lt;li&gt;The threshold &lt;code&gt;t&lt;/code&gt; is chosen such that it separates positive from negative cells, so will typically lie directly between these two populations. This means that the above procedure should not be considered a hypothesis test, because &lt;code&gt;t&lt;/code&gt; is picked deliberately to make the null hypothesis (H0: &lt;code&gt;K&lt;/code&gt; came from &lt;code&gt;Pois(t*S)&lt;/code&gt;) unlikely.&lt;/li&gt; &#xA; &lt;li&gt;Instead, cellpypes is a tool to quantify uncertainty around the threshold &lt;code&gt;t&lt;/code&gt;. If cells were sequenced deeply, &lt;code&gt;S&lt;/code&gt; becomes larger, which means we have more information to decide.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Function demos&lt;/h1&gt; &#xA;&lt;p&gt;The following has a short demo of every function. Let’s say you have completed the &lt;a href=&#34;https://satijalab.org/seurat/articles/pbmc3k_tutorial.html&#34;&gt;Seurat pbmc2700 tutorial&lt;/a&gt; (or it’s &lt;a href=&#34;https://satijalab.org/seurat/articles/essential_commands.html#seurat-standard-worflow-1&#34;&gt;shortcut&lt;/a&gt;), then you can start pyping from this &lt;code&gt;pbmc&lt;/code&gt; object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pbmc &amp;lt;- pype_from_seurat(seurat_object)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;feat&lt;/h3&gt; &#xA;&lt;p&gt;Visualize marker gene expression with &lt;code&gt;feat&lt;/code&gt; (short for feature plot):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pbmc %&amp;gt;% &#xA;  feat(c(&#34;NKG7&#34;, &#34;MS4A1&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/man/figures/README-feat-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://CRAN.R-project.org/package=viridis&#34;&gt;viridis color scale&lt;/a&gt; is used because it encodes higher expression with higher color intensity, and is robust to colorblindness.&lt;/li&gt; &#xA; &lt;li&gt;Default UMAP setting produce crowded embeddings. To avoid overplotting, we recommend playing with UMAP’s &lt;code&gt;min_dist&lt;/code&gt; and &lt;code&gt;spread&lt;/code&gt; parameters. Compute UMAP with &lt;code&gt;spread&lt;/code&gt;=5 and you’ll be able to see much more in your embeddings!&lt;/li&gt; &#xA; &lt;li&gt;Manual thresholding is easier if you know whether your gene is expressed highly or lowly. In above example, I’d start with a large threshold for NKG7 (e.g.&amp;nbsp;10 CP10K) and a moderate one for MS4A1 (e.g.&amp;nbsp;1 CP10K), simply because NKG7 goes up to 381 CP10K in some cells.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;rule and plot_last&lt;/h3&gt; &#xA;&lt;p&gt;Create a few cell type &lt;code&gt;rule&lt;/code&gt;s and plot the most recent one with &lt;code&gt;plot_last&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pbmc %&amp;gt;%&#xA;  rule(&#34;CD14+ Mono&#34;,  &#34;CD14&#34;,    &#34;&amp;gt;&#34;, 1)                    %&amp;gt;%&#xA;  rule(&#34;CD14+ Mono&#34;,  &#34;LYZ&#34;,     &#34;&amp;gt;&#34;, 20)                   %&amp;gt;%&#xA;  # uncomment this line to have a look at the LYZ+ rule:&#xA;  # plot_last()   &#xA;  rule(&#34;Tcell&#34;,       &#34;CD3E&#34;,    &#34;&amp;gt;&#34;, 3.5)                  %&amp;gt;% &#xA;  rule(&#34;CD8+ T&#34;,      &#34;CD8A&#34;,    &#34;&amp;gt;&#34;, 1,  parent=&#34;Tcell&#34;)   %&amp;gt;%&#xA;  plot_last()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/man/figures/README-unnamed-chunk-5-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;plot_last&lt;/code&gt; function plots the last rule you have added to the object. You can move it between any of the above lines to look at the preceding rule, as indicated by the commented &lt;code&gt;plot_last&lt;/code&gt; call above.&lt;/li&gt; &#xA; &lt;li&gt;Try lower and higher thresholds, until there is good agreement between positive cells (left plot) and high marker gene expression (right plot).&lt;/li&gt; &#xA; &lt;li&gt;cellpypes classes (aka cell types) can have as many rules as you want. CD14+ monocytes have two in this example.&lt;/li&gt; &#xA; &lt;li&gt;You can build hierarchy with the &lt;code&gt;parent&lt;/code&gt; argument, to arbitrary depths. In this example, CD8+ T cells are &lt;code&gt;CD3E+CD8A+&lt;/code&gt;, not just &lt;code&gt;CD8A+&lt;/code&gt;, because their ancestor &lt;code&gt;Tcell&lt;/code&gt; had a rule for CD3E.&lt;/li&gt; &#xA; &lt;li&gt;Above code chunk is a neat way to document your cell type assignment. You can generate a template with neat text alignment with &lt;code&gt;pype_code_template()&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;classify and plot_classes&lt;/h3&gt; &#xA;&lt;p&gt;Get cell type labels with &lt;code&gt;classify&lt;/code&gt; or plot them directly with &lt;code&gt;plot_classes&lt;/code&gt; (which wraps ggplot2 code around &lt;code&gt;classify&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# rules for several cell types:&#xA;pbmc2 &amp;lt;- pbmc %&amp;gt;%&#xA;  rule(&#34;Bcell&#34;,       &#34;MS4A1&#34;,   &#34;&amp;gt;&#34;, 1)                    %&amp;gt;%&#xA;  rule(&#34;CD14+ Mono&#34;,  &#34;CD14&#34;,    &#34;&amp;gt;&#34;, 1)                    %&amp;gt;%&#xA;  rule(&#34;CD14+ Mono&#34;,  &#34;LYZ&#34;,     &#34;&amp;gt;&#34;, 20)                   %&amp;gt;%&#xA;  rule(&#34;Tcell&#34;,       &#34;CD3E&#34;,    &#34;&amp;gt;&#34;, 3.5)                  %&amp;gt;% &#xA;  rule(&#34;CD8+ T&#34;,      &#34;CD8A&#34;,    &#34;&amp;gt;&#34;, 1,  parent=&#34;Tcell&#34;)   &#xA;&#xA;pbmc2 %&amp;gt;% plot_classes()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/man/figures/README-unnamed-chunk-6-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pbmc2 %&amp;gt;% plot_classes(c(&#34;Tcell&#34;, &#34;CD8+ T&#34;)) + ggtitle(&#34;T cells&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/FelixTheStudent/cellpypes/main/man/figures/README-unnamed-chunk-6-2.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(classify(pbmc2))&#xA;#&amp;gt; [1] Unassigned Bcell      Unassigned Unassigned Unassigned Unassigned&#xA;#&amp;gt; Levels: Bcell CD14+ Mono CD8+ T Unassigned&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;By default, &lt;code&gt;classify&lt;/code&gt;/&lt;code&gt;plot_classes&lt;/code&gt; will use all classes at the end of the hierarchy. T cells are not plotted in the first example because they are not the end, they have a ‘child’ called &lt;code&gt;CD8+ T&lt;/code&gt;. You can still have them in the same plot, by specifically asking for &lt;code&gt;plot_classes(c(&#34;Tcell&#34;, &#34;CD8+ T&#34;))&lt;/code&gt; (second example).&lt;/li&gt; &#xA; &lt;li&gt;If cell types overlap, &lt;code&gt;classify&lt;/code&gt; returns &lt;code&gt;Unassigned&lt;/code&gt; for cells with mutually exclusive labels (such as &lt;code&gt;Tcell&lt;/code&gt; and &lt;code&gt;Bcell&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;For this reason it matters whether you call &lt;code&gt;classify(&#34;Tcell&#34;)&lt;/code&gt; or &lt;code&gt;classify(c(&#34;Tcell&#34;,&#34;Bcell&#34;)&lt;/code&gt; – the overlap is masked with &lt;code&gt;Unassigned&lt;/code&gt; in this second call, but not in the first.&lt;/li&gt; &#xA; &lt;li&gt;If a cell gets multiple labels but from the same lineage (e.g.&amp;nbsp;&lt;code&gt;Tcell&lt;/code&gt; and &lt;code&gt;CD8+ T&lt;/code&gt;), the more detailed class is returned (&lt;code&gt;CD8+ T&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;class_to_deseq2&lt;/h3&gt; &#xA;&lt;p&gt;Let’s imagine the PBMC data had multiple patients and treatment conditions (we made them up here for illustraion):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(pbmc_meta)&#xA;#&amp;gt;    patient treatment&#xA;#&amp;gt; 1 patient1   treated&#xA;#&amp;gt; 2 patient5   treated&#xA;#&amp;gt; 3 patient1   control&#xA;#&amp;gt; 4 patient1   treated&#xA;#&amp;gt; 5 patient2   treated&#xA;#&amp;gt; 6 patient4   control&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Every row in &lt;code&gt;pbmc_meta&lt;/code&gt; corresponds to one cell in the &lt;code&gt;pbmc&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;With cellpypes, you can directly pipe a given cell type into DESeq2 to create a DESeq2 DataSet (dds) and test it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(DESeq2)&#xA;dds &amp;lt;- pbmc %&amp;gt;% &#xA;  rule(&#34;Bcell&#34;,   &#34;MS4A1&#34;,   &#34;&amp;gt;&#34;, 1)     %&amp;gt;%&#xA;  rule(&#34;Tcell&#34;,   &#34;CD3E&#34;,    &#34;&amp;gt;&#34;, 3.5)   %&amp;gt;% &#xA;  class_to_deseq2(pbmc_meta, &#34;Tcell&#34;, ~ treatment)&#xA;#&amp;gt; converting counts to integer mode&#xA;# test for differential expression and get DE genes:&#xA;dds &amp;lt;- DESeq(dds)&#xA;#&amp;gt; estimating size factors&#xA;#&amp;gt; estimating dispersions&#xA;#&amp;gt; gene-wise dispersion estimates&#xA;#&amp;gt; mean-dispersion relationship&#xA;#&amp;gt; final dispersion estimates&#xA;#&amp;gt; fitting model and testing&#xA;data.frame(results(dds)) %&amp;gt;% arrange(padj) %&amp;gt;% head&#xA;#&amp;gt;                  baseMean log2FoldChange     lfcSE         stat    pvalue&#xA;#&amp;gt; AL627309.1     0.25114064    -0.46193495 2.2886865 -0.201834087 0.8400464&#xA;#&amp;gt; AP006222.2     0.15001429     0.01895508 3.1165397  0.006082093 0.9951472&#xA;#&amp;gt; RP11-206L10.2  0.08742633    -0.46193859 3.1165397 -0.148221631 0.8821679&#xA;#&amp;gt; LINC00115      0.58340105     0.43747304 1.5879796  0.275490341 0.7829395&#xA;#&amp;gt; SAMD11         0.08742633    -0.46193859 3.1165397 -0.148221631 0.8821679&#xA;#&amp;gt; NOC2L         12.53882917    -0.57349677 0.3465506 -1.654871847 0.0979505&#xA;#&amp;gt;                    padj&#xA;#&amp;gt; AL627309.1    0.9998786&#xA;#&amp;gt; AP006222.2    0.9998786&#xA;#&amp;gt; RP11-206L10.2 0.9998786&#xA;#&amp;gt; LINC00115     0.9998786&#xA;#&amp;gt; SAMD11        0.9998786&#xA;#&amp;gt; NOC2L         0.9998786&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this dummy example, there is no real DE to find because we assigned cells randomly to treated/control.&lt;/p&gt; &#xA;&lt;h3&gt;pseudobulk and pseudobulk_id&lt;/h3&gt; &#xA;&lt;p&gt;Instead of piping into DESeq2 directly, you can also form pseudobulks with &lt;code&gt;pseudobulk&lt;/code&gt; and helper function &lt;code&gt;pseudobulk_id&lt;/code&gt;. This can be applied to any single-cell count data, independent from cellpypes. For example, &lt;code&gt;counts&lt;/code&gt; could be &lt;code&gt;seurat@assays$RNA@counts&lt;/code&gt; and &lt;code&gt;meta_df&lt;/code&gt; could be selected columns from &lt;code&gt;seurat@meta.data&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pbmc3 &amp;lt;- pbmc %&amp;gt;% rule(&#34;Tcell&#34;,   &#34;CD3E&#34;,    &#34;&amp;gt;&#34;, 3.5)&#xA;is_class &amp;lt;- classify(pbmc3) == &#34;Tcell&#34; &#xA;counts &amp;lt;- pseudobulk(pbmc$raw[,is_class], &#xA;                     pseudobulk_id(pbmc_meta[is_class,]))&#xA;counts[35:37, 1:3]&#xA;#&amp;gt; 3 x 3 Matrix of class &#34;dgeMatrix&#34;&#xA;#&amp;gt;            patient1.control patient1.treated patient2.control&#xA;#&amp;gt; AL645608.1                0                0                0&#xA;#&amp;gt; NOC2L                    13                6               16&#xA;#&amp;gt; KLHL17                    0                0                0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;FAQ&lt;/h1&gt; &#xA;&lt;h3&gt;Should I report bugs?&lt;/h3&gt; &#xA;&lt;p&gt;Yes. Do it. You can &lt;a href=&#34;https://github.com/FelixTheStudent/cellpypes/issues&#34;&gt;search similar problems or create new issues on gitHub&lt;/a&gt;. If you want to be nice and like fast help for free, try to provide a &lt;a href=&#34;https://en.wikipedia.org/wiki/Minimal_reproducible_example&#34;&gt;minimal example&lt;/a&gt; of your problem if possible. Make sure to include the version of your cellpypes installation, obtained e.g.&amp;nbsp;with &lt;code&gt;packageVersion(&#34;cellpypes&#34;)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Why are some cells unassigned?&lt;/h3&gt; &#xA;&lt;p&gt;Unassigned cells (grey) are not necessarily bad but a way to respect the signal-to-noise limit. Unassigned cells arise for two reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Not enough signal for any rule to apply. For example, outlier cells typically get few neighbors in Seurat’s SNN graph, making them negative for most rules.&lt;/li&gt; &#xA; &lt;li&gt;Not enough separation. If two classes are highly similar, such as CD4+ and CD8+ T cell subsets, cells in the noisy class border may be positive for rules from both classes. By default, cellpypes sets them to &lt;code&gt;Unassigned&lt;/code&gt;, but this behavior can be controlled with the &lt;code&gt;replace_overlap_with&lt;/code&gt; argument in &lt;code&gt;classify&lt;/code&gt; and &lt;code&gt;plot_classes&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How is DE different from cluster markers?&lt;/h3&gt; &#xA;&lt;p&gt;In cellpypes logic, Differential Expression (DE) analysis refers to comparing multiple samples (patients/mice/…) from at least two different groups (control/treated/…). These so called &lt;a href=&#34;https://www.nature.com/articles/s41467-020-19894-4&#34;&gt;multi-condition multi-sample comparisons&lt;/a&gt; have individuals, not cells, as unit of replication, and give reliable p-values.&lt;/p&gt; &#xA;&lt;p&gt;Finding cluster markers, in contrast, is circular and results in invalid p-values (which are useful for ranking marker genes, not for determining significance). The circularity comes from first using gene expression differences to find clusters, and then testing the null hypothesis that the same genes have no differences between clusters.&lt;/p&gt; &#xA;&lt;h3&gt;Why pseudobulks?&lt;/h3&gt; &#xA;&lt;p&gt;Pseudobulk approaches have been shown to perform as advertised, while many single-cell methods do not adjust p-values correctly and fail to control the false-discovery rate. Note that DESeq2, however, requires you to &lt;a href=&#34;https://pubmed.ncbi.nlm.nih.gov/29481549/&#34;&gt;filter out lowly expressed genes&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>