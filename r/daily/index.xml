<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-04T01:37:19Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tidyverse/stringr</title>
    <updated>2022-11-04T01:37:19Z</updated>
    <id>tag:github.com,2022-11-04:/tidyverse/stringr</id>
    <link href="https://github.com/tidyverse/stringr" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fresh approach to string manipulation in R&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;stringr &lt;a href=&#34;https://stringr.tidyverse.org&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tidyverse/stringr/main/man/figures/logo.png&#34; align=&#34;right&#34; height=&#34;139&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cran.r-project.org/package=stringr&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version/stringr&#34; alt=&#34;CRAN status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/tidyverse/stringr/actions&#34;&gt;&lt;img src=&#34;https://github.com/tidyverse/stringr/workflows/R-CMD-check/badge.svg?sanitize=true&#34; alt=&#34;R-CMD-check&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.codecov.io/gh/tidyverse/stringr?branch=main&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/tidyverse/stringr/branch/main/graph/badge.svg?sanitize=true&#34; alt=&#34;Codecov test coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://lifecycle.r-lib.org/articles/stages.html#stable&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/lifecycle-stable-brightgreen.svg?sanitize=true&#34; alt=&#34;Lifecycle: stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Strings are not glamorous, high-profile components of R, but they do play a big role in many data cleaning and preparation tasks. The stringr package provides a cohesive set of functions designed to make working with strings as easy as possible. If you’re not familiar with strings, the best place to start is the &lt;a href=&#34;https://r4ds.had.co.nz/strings.html&#34;&gt;chapter on strings&lt;/a&gt; in R for Data Science.&lt;/p&gt; &#xA;&lt;p&gt;stringr is built on top of &lt;a href=&#34;https://github.com/gagolews/stringi&#34;&gt;stringi&lt;/a&gt;, which uses the &lt;a href=&#34;https://icu.unicode.org&#34;&gt;ICU&lt;/a&gt; C library to provide fast, correct implementations of common string manipulations. stringr focusses on the most important and commonly used string manipulation functions whereas stringi provides a comprehensive set covering almost anything you can imagine. If you find that stringr is missing a function that you need, try looking in stringi. Both packages share similar conventions, so once you’ve mastered stringr, you should find stringi similarly easy to use.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# The easiest way to get stringr is to install the whole tidyverse:&#xA;install.packages(&#34;tidyverse&#34;)&#xA;&#xA;# Alternatively, install just stringr:&#xA;install.packages(&#34;stringr&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Cheatsheet&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rstudio/cheatsheets/raw/main/strings.pdf&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rstudio/cheatsheets/main/pngs/thumbnails/strings-cheatsheet-thumbs.png&#34; width=&#34;630&#34; height=&#34;242&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;All functions in stringr start with &lt;code&gt;str_&lt;/code&gt; and take a vector of strings as the first argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(&#34;why&#34;, &#34;video&#34;, &#34;cross&#34;, &#34;extra&#34;, &#34;deal&#34;, &#34;authority&#34;)&#xA;str_length(x) &#xA;#&amp;gt; [1] 3 5 5 5 4 9&#xA;str_c(x, collapse = &#34;, &#34;)&#xA;#&amp;gt; [1] &#34;why, video, cross, extra, deal, authority&#34;&#xA;str_sub(x, 1, 2)&#xA;#&amp;gt; [1] &#34;wh&#34; &#34;vi&#34; &#34;cr&#34; &#34;ex&#34; &#34;de&#34; &#34;au&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Most string functions work with regular expressions, a concise language for describing patterns of text. For example, the regular expression &lt;code&gt;&#34;[aeiou]&#34;&lt;/code&gt; matches any single character that is a vowel:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_subset(x, &#34;[aeiou]&#34;)&#xA;#&amp;gt; [1] &#34;video&#34;     &#34;cross&#34;     &#34;extra&#34;     &#34;deal&#34;      &#34;authority&#34;&#xA;str_count(x, &#34;[aeiou]&#34;)&#xA;#&amp;gt; [1] 0 3 1 2 2 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are seven main verbs that work with patterns:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;str_detect(x, pattern)&lt;/code&gt; tells you if there’s any match to the pattern:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_detect(x, &#34;[aeiou]&#34;)&#xA;#&amp;gt; [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;str_count(x, pattern)&lt;/code&gt; counts the number of patterns:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_count(x, &#34;[aeiou]&#34;)&#xA;#&amp;gt; [1] 0 3 1 2 2 4&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;str_subset(x, pattern)&lt;/code&gt; extracts the matching components:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_subset(x, &#34;[aeiou]&#34;)&#xA;#&amp;gt; [1] &#34;video&#34;     &#34;cross&#34;     &#34;extra&#34;     &#34;deal&#34;      &#34;authority&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;str_locate(x, pattern)&lt;/code&gt; gives the position of the match:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_locate(x, &#34;[aeiou]&#34;)&#xA;#&amp;gt;      start end&#xA;#&amp;gt; [1,]    NA  NA&#xA;#&amp;gt; [2,]     2   2&#xA;#&amp;gt; [3,]     3   3&#xA;#&amp;gt; [4,]     1   1&#xA;#&amp;gt; [5,]     2   2&#xA;#&amp;gt; [6,]     1   1&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;str_extract(x, pattern)&lt;/code&gt; extracts the text of the match:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_extract(x, &#34;[aeiou]&#34;)&#xA;#&amp;gt; [1] NA  &#34;i&#34; &#34;o&#34; &#34;e&#34; &#34;e&#34; &#34;a&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;str_match(x, pattern)&lt;/code&gt; extracts parts of the match defined by parentheses:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# extract the characters on either side of the vowel&#xA;str_match(x, &#34;(.)[aeiou](.)&#34;)&#xA;#&amp;gt;      [,1]  [,2] [,3]&#xA;#&amp;gt; [1,] NA    NA   NA  &#xA;#&amp;gt; [2,] &#34;vid&#34; &#34;v&#34;  &#34;d&#34; &#xA;#&amp;gt; [3,] &#34;ros&#34; &#34;r&#34;  &#34;s&#34; &#xA;#&amp;gt; [4,] NA    NA   NA  &#xA;#&amp;gt; [5,] &#34;dea&#34; &#34;d&#34;  &#34;a&#34; &#xA;#&amp;gt; [6,] &#34;aut&#34; &#34;a&#34;  &#34;t&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;str_replace(x, pattern, replacement)&lt;/code&gt; replaces the matches with new text:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_replace(x, &#34;[aeiou]&#34;, &#34;?&#34;)&#xA;#&amp;gt; [1] &#34;why&#34;       &#34;v?deo&#34;     &#34;cr?ss&#34;     &#34;?xtra&#34;     &#34;d?al&#34;      &#34;?uthority&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;str_split(x, pattern)&lt;/code&gt; splits up a string into multiple pieces:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_split(c(&#34;a,b&#34;, &#34;c,d,e&#34;), &#34;,&#34;)&#xA;#&amp;gt; [[1]]&#xA;#&amp;gt; [1] &#34;a&#34; &#34;b&#34;&#xA;#&amp;gt; &#xA;#&amp;gt; [[2]]&#xA;#&amp;gt; [1] &#34;c&#34; &#34;d&#34; &#34;e&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As well as regular expressions (the default), there are three other pattern matching engines:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;fixed()&lt;/code&gt;: match exact bytes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;coll()&lt;/code&gt;: match human letters&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;boundary()&lt;/code&gt;: match boundaries&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;RStudio Addin&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://www.garrickadenbuie.com/project/regexplain/&#34;&gt;RegExplain RStudio addin&lt;/a&gt; provides a friendly interface for working with regular expressions and functions from stringr. This addin allows you to interactively build your regexp, check the output of common string matching functions, consult the interactive help pages, or use the included resources to learn regular expressions.&lt;/p&gt; &#xA;&lt;p&gt;This addin can easily be installed with devtools:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;devtools&#34;)&#xA;devtools::install_github(&#34;gadenbuie/regexplain&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compared to base R&lt;/h2&gt; &#xA;&lt;p&gt;R provides a solid set of string operations, but because they have grown organically over time, they can be inconsistent and a little hard to learn. Additionally, they lag behind the string operations in other programming languages, so that some things that are easy to do in languages like Ruby or Python are rather hard to do in R.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Uses consistent function and argument names. The first argument is always the vector of strings to modify, which makes stringr work particularly well in conjunction with the pipe:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;letters %&amp;gt;%&#xA;  .[1:10] %&amp;gt;% &#xA;  str_pad(3, &#34;right&#34;) %&amp;gt;%&#xA;  str_c(letters[2:11])&#xA;#&amp;gt;  [1] &#34;a  b&#34; &#34;b  c&#34; &#34;c  d&#34; &#34;d  e&#34; &#34;e  f&#34; &#34;f  g&#34; &#34;g  h&#34; &#34;h  i&#34; &#34;i  j&#34; &#34;j  k&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Simplifies string operations by eliminating options that you don’t need 95% of the time.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Produces outputs than can easily be used as inputs. This includes ensuring that missing inputs result in missing outputs, and zero length inputs result in zero length outputs.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Learn more in &lt;code&gt;vignette(&#34;from-base&#34;)&lt;/code&gt;&lt;/p&gt;</summary>
  </entry>
</feed>