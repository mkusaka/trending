<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-11T01:52:16Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>twbattaglia/RNAseq-workflow</title>
    <updated>2022-08-11T01:52:16Z</updated>
    <id>tag:github.com,2022-08-11:/twbattaglia/RNAseq-workflow</id>
    <link href="https://github.com/twbattaglia/RNAseq-workflow" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A repository for setting up a RNAseq workflow&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Differential Gene Expression using RNA-Seq (Workflow)&lt;/h1&gt; &#xA;&lt;h5&gt;Thomas W. Battaglia (02/15/17)&lt;/h5&gt; &#xA;&lt;h3&gt;Introduction&lt;/h3&gt; &#xA;&lt;p&gt;RNAseq is becoming the one of the most prominent methods for measuring celluar responses. Not only does RNAseq have the ability to analyze differences in gene expression between samples, but can discover new isoforms and analyze SNP variations. This tutorial will cover the basic workflow for processing and analyzing differential gene expression data and is meant to give a general method for setting up an environment and running alignment tools. Be aware that is not meant to be used for all types of analyses and data-types, and the alignment tools are not for every analysis. Additionally, this tutorial is focused on giving a general sense of the flow when performing these analysis. For larger scale studies, it is highly reccomended to use a HPC environment for increased RAM and computational power.&lt;/p&gt; &#xA;&lt;h3&gt;Getting Setup&lt;/h3&gt; &#xA;&lt;h4&gt;A. Installating Miniconda (if needed)&lt;/h4&gt; &#xA;&lt;p&gt;Miniconda is a comprehensive and easy to use package manager for Python (among other things). Miniconda is meant to replace your current Python installation with one that has more features and is modular, so you can delete it without any damage to your system. Not only does it allow you to install Python packages, you can create virtual environments and have access to large bioinformatics repositories (&lt;strong&gt;Bioconda&lt;/strong&gt; &lt;a href=&#34;https://bioconda.github.io/&#34;&gt;https://bioconda.github.io/&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Download the Miniconda3 installer to your home directory (Only for macOS)&#xA;wget https://repo.continuum.io/miniconda/Miniconda3-latest-MacOSX-x86_64.sh -O ~/miniconda.sh&#xA;&#xA;# Download the Miniconda3 installer to your home directory (Only for LINUX or Cluster)&#xA;wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda.sh&#xA;&#xA;# Run the miniconda installation&#xA;bash miniconda.sh -b -f -p ~/miniconda&#xA;&#xA;# Add miniconda to the system path&#xA;echo &#39;PATH=&#34;$HOME/miniconda/bin:$PATH&#39; &amp;gt;&amp;gt; ~/.bash_profile&#xA;&#xA;# Source system file to activate miniconda&#xA;source ~/.bash_profile&#xA;&#xA;# Add bioinformatic channels for downloading required packages&#xA;conda config --add channels conda-forge&#xA;conda config --add channels defaults&#xA;conda config --add channels r&#xA;conda config --add channels bioconda&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;B. Setting Up the Folder Structure&lt;/h4&gt; &#xA;&lt;p&gt;Organizing is key to proper reproducible research. During the processing and analysis steps, many files are created. To best organize the analysis and increase the reproducibility of your analysis, it is best to use a simple folder structure. An intuitive struture allows other researchers and collaborators to find certain files and follow the steps used. The structure within this repository is just one way of organizing the data, but you can choose whichever way is the most comfortable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install git (if needed)&#xA;conda install -c anaconda git wget --yes&#xA;&#xA;# Clone this repository with folder structure into the current working folder&#xA;git clone https://github.com/twbattaglia/RNAseq-workflow new_workflow&#xA;&#xA;# Change directory into the new folder&#xA;cd new_workflow&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Folder breakdown&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;── new_workflow/&#xA;  │&amp;nbsp;&amp;nbsp; └── annotation/               &amp;lt;- Genome annotation file (.GTF/.GFF)&#xA;  │&amp;nbsp;&amp;nbsp;&#xA;  │&amp;nbsp;&amp;nbsp; └── genome/                   &amp;lt;- Host genome file (.FASTA)&#xA;  │&amp;nbsp;&amp;nbsp;&#xA;  │&amp;nbsp;&amp;nbsp; └── input/                    &amp;lt;- Location of input  RNAseq data&#xA;  │&amp;nbsp;&amp;nbsp;&#xA;  │&amp;nbsp;&amp;nbsp; └── output/                   &amp;lt;- Data generated during processing steps&#xA;  │&amp;nbsp;&amp;nbsp;     ├── 1_initial_qc/         &amp;lt;- Main alignment files for each sample&#xA;  │&amp;nbsp;&amp;nbsp;     ├── 2_trimmed_output/     &amp;lt;-  Log from running STAR alignment step&#xA;  │&amp;nbsp;&amp;nbsp;     ├── 3_rRNA/               &amp;lt;- STAR alignment counts output (for comparison with featureCounts)&#xA;  │&amp;nbsp;&amp;nbsp;         ├── aligned/          &amp;lt;-  Sequences that aligned to rRNA databases (rRNA contaminated)&#xA;  │&amp;nbsp;&amp;nbsp;         ├── filtered/         &amp;lt;-  Sequences with rRNA sequences removed  (rRNA-free)&#xA;  │&amp;nbsp;&amp;nbsp;         ├── logs/             &amp;lt;- logs from running SortMeRNA&#xA;  │&amp;nbsp;&amp;nbsp;     ├── 4_aligned_sequences/  &amp;lt;- Main alignment files for each sample&#xA;  │&amp;nbsp;&amp;nbsp;         ├── aligned_bam/      &amp;lt;-  Alignment files generated from STAR (.BAM)&#xA;  │&amp;nbsp;&amp;nbsp;         ├── aligned_logs/     &amp;lt;- Log from running STAR alignment step&#xA;  │&amp;nbsp;&amp;nbsp;     ├── 5_final_counts/       &amp;lt;- Summarized gene counts across all samples&#xA;  │&amp;nbsp;&amp;nbsp;     ├── 6_multiQC/            &amp;lt;- Overall report of logs for each step&#xA;  │&amp;nbsp;&amp;nbsp;&#xA;  │&amp;nbsp;&amp;nbsp; └── sortmerna_db/             &amp;lt;- Folder to store the rRNA databases for SortMeRNA&#xA;  │&amp;nbsp;&amp;nbsp;     ├── index/                &amp;lt;- indexed versions of the rRNA sequences for faster alignment&#xA;  │&amp;nbsp;&amp;nbsp;     ├── rRNA_databases/       &amp;lt;- rRNA sequences from bacteria, archea and eukaryotes&#xA;  │&amp;nbsp;&amp;nbsp;&#xA;  │&amp;nbsp;&amp;nbsp; └── star_index/               &amp;lt;-  Folder to store the indexed genome files from STAR &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;C. Download Host Genome&lt;/h4&gt; &#xA;&lt;p&gt;To find either differentially expressed genes or isoform transcripts, you first need a reference genome to compare to. For any alignment, we need the host genome in &lt;code&gt;.fasta&lt;/code&gt; format, but we also need an annotation file in &lt;code&gt;.GTF/.GFF&lt;/code&gt;, which relates the coordinates in the genome to an annotated gene identifier. Both of these files are required to perform an alignment and generate gene abundance counts. Be aware that the different resources (Ensembl, UCSC, RefSeq, Gencode) have different versions of the same species genome and annotation files cannot be mixed between versions. In this workflow, we will focus on the Gencode&#39;s genome. (&lt;a href=&#34;https://www.gencodegenes.org/&#34;&gt;https://www.gencodegenes.org/&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;See here for a listing of genomes/annotation beyond mouse and human: &lt;a href=&#34;http://useast.ensembl.org/info/data/ftp/index.html&#34;&gt;http://useast.ensembl.org/info/data/ftp/index.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Mouse (Gencode)&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Download genome fasta file into the genome/ folder&#xA;wget -P genome/ ftp://ftp.sanger.ac.uk/pub/gencode/Gencode_mouse/release_M12/GRCm38.p5.genome.fa.gz&#xA;&#xA;# Download annotation file into the annotation/ folder&#xA;wget -P annotation/ ftp://ftp.sanger.ac.uk/pub/gencode/Gencode_mouse/release_M12/gencode.vM12.annotation.gtf.gz&#xA;&#xA;# Decompress files for use with tools&#xA;gunzip genome/GRCm38.p4.genome.fa.gz&#xA;gunzip annotation/gencode.vM12.annotation.gtf.gz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Human (Gencode)&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Download genome fasta file into the genome/ folder&#xA;wget -p genome/ ftp://ftp.sanger.ac.uk/pub/gencode/Gencode_human/release_25/GRCh38.p7.genome.fa.gz&#xA;&#xA;# Download annotation file into the annotation/ folder&#xA;wget -P annotation/ ftp://ftp.sanger.ac.uk/pub/gencode/Gencode_human/release_25/gencode.v25.annotation.gtf.gz&#xA;&#xA;# Decompress files for use with tools&#xA;gunzip genome/GRCh38.p7.genome.fa.gz&#xA;gunzip annotation/gencode.v25.annotation.gtf.gz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Workflow&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twbattaglia/RNAseq-workflow/master/README_files/rnaseq_workflow.jpg&#34; alt=&#34;RNAseq Workflow&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Example data: If you would like to use example data for practicing the workflow, run the command below to download mouse RNAseq data.&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget -P input/ ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR137/001/SRR1374921/SRR1374921.fastq.gz&#xA;wget -P input/ ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR137/002/SRR1374922/SRR1374922.fastq.gz&#xA;wget -P input/ ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR137/003/SRR1374923/SRR1374923.fastq.gz&#xA;wget -P input/ ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR137/004/SRR1374924/SRR1374924.fastq.gz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 1. Analysing Sequence Quality with FastQC&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.bioinformatics.babraham.ac.uk/projects/fastqc/&#34;&gt;http://www.bioinformatics.babraham.ac.uk/projects/fastqc/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Description&lt;/h4&gt; &#xA;&lt;p&gt;&#34;FastQC aims to provide a simple way to do some quality control checks on raw sequence data coming from high throughput sequencing pipelines. It provides a modular set of analyses which you can use to give a quick impression of whether your data has any problems of which you should be aware before doing any further analysis.&#34;&lt;/p&gt; &#xA;&lt;p&gt;The first step before processing any samples is to analyze the quality of the data. Within the &lt;code&gt;fastq&lt;/code&gt; file is quality information that refers to the accuracy (% confidence) of each base call. &lt;strong&gt;FastQC&lt;/strong&gt; looks at different aspects of the sample sequences to determine any irregularies or features that make affect your results (adapter contamination, sequence duplication levels, etc.)&lt;/p&gt; &#xA;&lt;h4&gt;Installation&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;conda install -c bioconda fastqc --yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Command&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Help&#xA;fastqc -h&#xA;&#xA;# Run FastQC&#xA;fastqc \&#xA;-o results/1_initial_qc/ \&#xA;--noextract \&#xA;input/sample.fastq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;── results/1_initial_qc/&#xA;    └──  sample_fastqc.html   &amp;lt;-  HTML file of FastQC fquality analysis figures&#xA;    └──  sample_fastqc.zip    &amp;lt;- FastQC report data&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 2. Removing Low Quality Sequences with Trim_Galore!&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.bioinformatics.babraham.ac.uk/projects/trim_galore/&#34;&gt;http://www.bioinformatics.babraham.ac.uk/projects/trim_galore/&lt;/a&gt; &lt;a href=&#34;http://journal.embnet.org/index.php/embnetjournal/article/view/200&#34;&gt;http://journal.embnet.org/index.php/embnetjournal/article/view/200&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Description&lt;/h4&gt; &#xA;&lt;p&gt;&#34;Trim Galore! is a wrapper script to automate quality and adapter trimming as well as quality control, with some added functionality to remove biased methylation positions for RRBS sequence files (for directional, non-directional (or paired-end) sequencing).&#34;&lt;/p&gt; &#xA;&lt;p&gt;After analyzing the quality of the data, the next step is to remove sequences/nucleotides that do not meet your quality standards. There are a multitude of quality control pacakges, but trim_galore combines &lt;strong&gt;Cutadapt&lt;/strong&gt; (&lt;a href=&#34;http://cutadapt.readthedocs.io/en/stable/guide.html&#34;&gt;http://cutadapt.readthedocs.io/en/stable/guide.html&lt;/a&gt;) and &lt;strong&gt;FastQC&lt;/strong&gt; to remove low quality sequences while performing quality analysis to see the effect of filtering.&lt;/p&gt; &#xA;&lt;p&gt;The 2 most import parameters to select are what the minimum Phred score (1-30) and a minimum sequencing length. There are different views on this parameter and you can see the papers below for more information about which parameters to use. A good estimate is typically a Phred score of 20 (99% confidence) and a minimum of 50-70% of the sequence length.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-016-0956-2&#34;&gt;https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-016-0956-2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0881-8&#34;&gt;https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0881-8&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.epigenesys.eu/images/stories/protocols/pdf/20150303161357_p67.pdf&#34;&gt;http://www.epigenesys.eu/images/stories/protocols/pdf/20150303161357_p67.pdf&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Installation&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;conda install -c bioconda trim-galore --yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Command&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Help&#xA;trim_galore -h&#xA;&#xA;# Run Trim Galore!&#xA;trim_galore \&#xA;--quality 20 \&#xA;--fastqc \&#xA;--length 25 \&#xA;--output_dir results/2_trimmed_output/ \&#xA;input/sample.fastq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;── results/2_trimmed_output/&#xA;     └──  sample_trimmed.fq                 &amp;lt;-  Trimmed sequencing file (.fastq)&#xA;     └──  sample_trimmed.html               &amp;lt;- HTML file of FastQC fquality analysis figures&#xA;     └──  sample_trimmed.zip                &amp;lt;- FastQC report data&#xA;     └──  sample.fastq.trimming_report.txt  &amp;lt;-   Cutadapt trimming report&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 3. Removing rRNA Sequences with SortMeRNA&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://bioinfo.lifl.fr/RNA/sortmerna/&#34;&gt;http://bioinfo.lifl.fr/RNA/sortmerna/&lt;/a&gt; &lt;a href=&#34;http://bioinformatics.oxfordjournals.org/content/28/24/3211&#34;&gt;http://bioinformatics.oxfordjournals.org/content/28/24/3211&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Description&lt;/h4&gt; &#xA;&lt;p&gt;&#34;SortMeRNA is a program tool for filtering, mapping and OTU-picking NGS reads in metatranscriptomic and metagenomic data. The core algorithm is based on approximate seeds and allows for fast and sensitive analyses of nucleotide sequences. The main application of SortMeRNA is filtering ribosomal RNA from metatranscriptomic data.&#34;&lt;/p&gt; &#xA;&lt;p&gt;Once we have removed low quality sequences and remove any adapter contamination, we can then proceed to an additional (and optional) step to remove rRNA sequences from the samples. If your samples were not prepared with an rRNA depletion protocol before library preparation, it is reccomended to run this step to computational remove any rRNA sequence contiamation that may otheriwse take up a majority of the aligned sequences.&lt;/p&gt; &#xA;&lt;h4&gt;Installation&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;conda install -c bioconda sortmerna --yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Generating Indexes&lt;/h4&gt; &#xA;&lt;p&gt;Before we can run the &lt;code&gt;sortmerna&lt;/code&gt; command, we must first download and process the eukaryotic, archeal and bacterial rRNA databases. The &lt;code&gt;sortmerna_db/&lt;/code&gt; folder will be the location that we will keep the files necessary to run &lt;strong&gt;SortMeRNA&lt;/strong&gt;. These databases only need to be created once, so any future RNAseq experiements can use these files.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Download the sortmerna package (~2min) into sortmerna_db folder&#xA;wget -P sortmerna_db https://github.com/biocore/sortmerna/archive/2.1b.zip&#xA;&#xA;# Decompress folder &#xA;unzip sortmerna_db/2.1b.zip -d sortmerna_db&#xA;&#xA;# Move the database into the correct folder&#xA;mv sortmerna_db/sortmerna-2.1b/rRNA_databases/ sortmerna_db/&#xA;&#xA;# Remove unnecessary folders&#xA;rm sortmerna_db/2.1b.zip&#xA;rm -r sortmerna_db/sortmerna-2.1b&#xA;&#xA;# Save the location of all the databases into one folder&#xA;sortmernaREF=sortmerna_db/rRNA_databases/silva-arc-16s-id95.fasta,sortmerna_db/index/silva-arc-16s-id95:\&#xA;sortmerna_db/rRNA_databases/silva-arc-23s-id98.fasta,sortmerna_db/index/silva-arc-23s-id98:\&#xA;sortmerna_db/rRNA_databases/silva-bac-16s-id90.fasta,sortmerna_db/index/silva-bac-16s-id95:\&#xA;sortmerna_db/rRNA_databases/silva-bac-23s-id98.fasta,sortmerna_db/index/silva-bac-23s-id98:\&#xA;sortmerna_db/rRNA_databases/silva-euk-18s-id95.fasta,sortmerna_db/index/silva-euk-18s-id95:\&#xA;sortmerna_db/rRNA_databases/silva-euk-28s-id98.fasta,sortmerna_db/index/silva-euk-28s-id98&#xA;&#xA;# Run the indexing command (~8 minutes)&#xA;indexdb_rna --ref $sortmernaREF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Command&lt;/h4&gt; &#xA;&lt;h6&gt;Note: Be sure the input files are not compressed&lt;/h6&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Help&#xA;sortmerna -h&#xA;&#xA;# Save variable of rRNA databases&#xA;# Save the location of all the databases into one folder&#xA;sortmernaREF=sortmerna_db/rRNA_databases/silva-arc-16s-id95.fasta,sortmerna_db/index/silva-arc-16s-id95:\&#xA;sortmerna_db/rRNA_databases/silva-arc-23s-id98.fasta,sortmerna_db/index/silva-arc-23s-id98:\&#xA;sortmerna_db/rRNA_databases/silva-bac-16s-id90.fasta,sortmerna_db/index/silva-bac-16s-id95:\&#xA;sortmerna_db/rRNA_databases/silva-bac-23s-id98.fasta,sortmerna_db/index/silva-bac-23s-id98:\&#xA;sortmerna_db/rRNA_databases/silva-euk-18s-id95.fasta,sortmerna_db/index/silva-euk-18s-id95:\&#xA;sortmerna_db/rRNA_databases/silva-euk-28s-id98.fasta,sortmerna_db/index/silva-euk-28s-id98&#xA;&#xA;# Run SortMeRNA (~15min)&#xA;sortmerna \&#xA;--ref $sortmernaREF \&#xA;--reads results/2_trimmed_output/sample_trimmed.fq \&#xA;--aligned results/3_rRNA/aligned/sample_aligned.fq \&#xA;--other results/3_rRNA/filtered/sample_filtered.fq \&#xA;--fastx \&#xA;--log \&#xA;-a 4 \&#xA;-v&#xA;&#xA;# Move logs into the correct folder&#xA;mv -v results/3_rRNA/aligned//sample_aligned.log results/3_rRNA/logs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;── results/3_rRNA/&#xA;    └── aligned/sample_aligned.fq     &amp;lt;-  sequences with rRNA contamination&#xA;    └── filtered/sample_filtered.fq   &amp;lt;- sequences without any rRNA contamination&#xA;    └── logs/sample_aligned.log       &amp;lt;- log from SortMeRNA analysis&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 4. Aligning to Genome with STAR-aligner&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/alexdobin/STAR&#34;&gt;https://github.com/alexdobin/STAR&lt;/a&gt; &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/23104886&#34;&gt;https://www.ncbi.nlm.nih.gov/pubmed/23104886&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Description&lt;/h4&gt; &#xA;&lt;p&gt;&#34;To align our large (&amp;gt;80 billon reads) ENCODE Transcriptome RNA-seq dataset, we developed the Spliced Transcripts Alignment to a Reference (STAR) software based on a previously undescribed RNA-seq alignment algorithm that uses sequential maximum mappable seed search in uncompressed suffix arrays followed by seed clustering and stitching procedure. STAR outperforms other aligners by a factor of &amp;gt;50 in mapping speed, aligning to the human genome 550 million 2 × 76 bp paired-end reads per hour on a modest 12-core server, while at the same time improving alignment sensitivity and precision.&#34;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;STAR&lt;/strong&gt; aligner is a very fast and efficent spliced aligner tools for aligning RNAseq data to genomes. The &lt;strong&gt;STAR&lt;/strong&gt; aligner has the capabilities to discover non-canonical splices and chimeric (fusion) transcripts, but for our use case, we will be using to to align full length RNA sequences to a genome. The output of the tool is a &lt;code&gt;.BAM&lt;/code&gt; file which representes the coordinated that each sequence has aligned to. &lt;code&gt;.BAM&lt;/code&gt; files are the same as &lt;code&gt;.SAM&lt;/code&gt; files, but the are in binary format so you can not view the contents, yet this trade off reduces the size of the file dramatically.&lt;/p&gt; &#xA;&lt;h4&gt;Installation&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;conda install -c bioconda star --yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Generating Indexes&lt;/h4&gt; &#xA;&lt;p&gt;Similar to the &lt;strong&gt;SortMeRNA&lt;/strong&gt; step, we must first generate an index of the genome we want to align to, so that there tools can efficently map over millions of sequences. The &lt;code&gt;star_index&lt;/code&gt; folder will be the location that we will keep the files necessary to run &lt;strong&gt;STAR&lt;/strong&gt; and due to the nature of the program, it can take up to 30GB of space. This step only needs to be run once and can be used for any subsequent RNAseq alignment analyses.&lt;/p&gt; &#xA;&lt;h5&gt;Note the two inputs for this command are the genome located in the (genome/ folder) and the annotation file located in the (annotation/ folder)&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;# This can take up to 30 minutes to complete&#xA;STAR \&#xA;--runMode genomeGenerate \&#xA;--genomeDir star_index \&#xA;--genomeFastaFiles genome/* \&#xA;--sjdbGTFfile annotation/* \&#xA;--runThreadN 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Command&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Help&#xA;STAR -h&#xA;&#xA;# Run STAR (~10min)&#xA;STAR \&#xA;--genomeDir star_index \&#xA;--readFilesIn filtered/sample_filtered.fq  \&#xA;--runThreadN 4 \&#xA;--outSAMtype BAM SortedByCoordinate \&#xA;--quantMode GeneCounts&#xA;&#xA;# Move the BAM file into the correct folder&#xA;mv -v results/4_aligned_sequences/sampleAligned.sortedByCoord.out.bam results/4_aligned_sequences/aligned_bam/&#xA;&#xA;# Move the logs into the correct folder&#xA;mv -v results/4_aligned_sequences/${BN}Log.final.out results/4_aligned_sequences/aligned_logs/&#xA;mv -v results/4_aligned_sequences/sample*Log.out results/4_aligned_sequences/aligned_logs/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;── results/4_aligned_sequences/&#xA;    └── aligned_bam/sampleAligned.sortedByCoord.out.bam   &amp;lt;- Sorted BAM alignment fole&#xA;    └── aligned_logs/sampleLog.final.out                  &amp;lt;- Log of STAR alignment rate&#xA;    └── aligned_logs/sampleLog.out                        &amp;lt;- Log of steps take during STAR alignment&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 5. Summarizing Gene Counts with featureCounts&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/24227677&#34;&gt;https://www.ncbi.nlm.nih.gov/pubmed/24227677&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Description&lt;/h4&gt; &#xA;&lt;p&gt;&#34;featureCounts is a highly efficient general-purpose read summarization program that counts mapped reads for genomic features such as genes, exons, promoter, gene bodies, genomic bins and chromosomal locations. It can be used to count both RNA-seq and genomic DNA-seq reads. featureCounts takes as input SAM/BAM files and an annotation file including chromosomal coordinates of features. It outputs numbers of reads assigned to features (or meta-features). It also outputs stat info for the overall summrization results, including number of successfully assigned reads and number of reads that failed to be assigned due to various reasons (these reasons are included in the stat info).&#34;&lt;/p&gt; &#xA;&lt;p&gt;Now that we have our .BAM alignment files, we can then proceed to try and summarize these coordinates into genes and abundances. To do this we must summarize the reads using &lt;strong&gt;featureCounts&lt;/strong&gt; or any other read summarizer tool, and produce a table of genes by samples with raw sequence abundances. This table will then be used to perform statistical analysis and find differentially expressed genes.&lt;/p&gt; &#xA;&lt;h4&gt;Installation&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;conda install -c bioconda subread --yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Command&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Help&#xA;featureCounts -h&#xA;&#xA;# Change directory into the aligned .BAM folder&#xA;cd results/4_aligned_sequences/aligned_bam&#xA;&#xA;# Store list of files as a variable&#xA;dirlist=$(ls -t ./*.bam | tr &#39;\n&#39; &#39; &#39;)&#xA;echo $dirlist&#xA;&#xA;# Run featureCounts on all of the samples (~10 minutes)&#xA;featureCounts \&#xA;-a ../../annotation/* \&#xA;-o ../../results/5_final_counts/final_counts.txt \&#xA;-g &#39;gene_name&#39; \&#xA;-T 4 \&#xA;$dirlist&#xA;&#xA;# Change directory back to main folder&#xA;cd ../../../&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;── results/5_final_counts/&#xA;    └── final_counts.txt                &amp;lt;- Final gene counts across all samples&#xA;    └── final_counts.txt.summary        &amp;lt;- Summary of gene summarization &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 6. Generating analysis report with multiQC&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://multiqc.info/&#34;&gt;http://multiqc.info/&lt;/a&gt; &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/27312411&#34;&gt;https://www.ncbi.nlm.nih.gov/pubmed/27312411&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Description&lt;/h4&gt; &#xA;&lt;p&gt;&#34;We present MultiQC, a tool to create a single report visualising output from multiple tools across many samples, enabling global trends and biases to be quickly identified. MultiQC can plot data from many common bioinformatics tools and is built to allow easy extension and customization.&#34;&lt;/p&gt; &#xA;&lt;p&gt;During the qulaity filtering, rRNA removal, &lt;strong&gt;STAR&lt;/strong&gt; alignment and gene summarization, there has been a creation of multiple log files which contain metrics the measure the quality of the respective step. Instead of iterating through many many different log files, we can use the summarization tool &lt;strong&gt;MultiQC&lt;/strong&gt; which will search for all relavent files and produce rich figures that show data from different steps logs files. This step is extremely useful when determining how well sequences aligned to a genome and dermining how many sequences were lost at each step.&lt;/p&gt; &#xA;&lt;h4&gt;Installation&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;conda install -c bioconda multiqc --yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Command&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Help&#xA;multiqc -h &#xA;&#xA;# Run multiqc and output results into final folder&#xA;multiqc results \&#xA;--outdir results/6_multiQC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;── results/6_multiQC/&#xA;    └── multiqc_report.html     &amp;lt;- Beautiful figures representing the logs from each step&#xA;    └── multiqc_data/           &amp;lt;-  Folder of data that multiqc found from various log files&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 7. Importing Gene Counts into R/RStudio&lt;/h3&gt; &#xA;&lt;p&gt;Once the workflow has completed, you can now use the gene count table as an input into &lt;strong&gt;DESeq2&lt;/strong&gt; for statistical analysis using the R-programming language. It is highly reccomended to use &lt;strong&gt;RStudio&lt;/strong&gt; when writing R code and generating R-related analyses. You can download &lt;strong&gt;RStudio&lt;/strong&gt; for your system here: &lt;a href=&#34;https://www.rstudio.com/products/rstudio/download/&#34;&gt;https://www.rstudio.com/products/rstudio/download/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;7a. Install required R-libraries&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;source(&#34;https://bioconductor.org/biocLite.R&#34;)&#xA;biocLite(&#34;DESeq2&#34;) ; library(DESeq2)&#xA;biocLite(&#34;ggplot2&#34;) ; library(ggplot2)&#xA;biocLite(&#34;clusterProfiler&#34;) ; library(clusterProfiler)&#xA;biocLite(&#34;biomaRt&#34;) ; library(biomaRt)&#xA;biocLite(&#34;ReactomePA&#34;) ; library(ReactomePA)&#xA;biocLite(&#34;DOSE&#34;) ; library(DOSE)&#xA;biocLite(&#34;KEGG.db&#34;) ; library(KEGG.db)&#xA;biocLite(&#34;org.Mm.eg.db&#34;) ; library(org.Mm.eg.db)&#xA;biocLite(&#34;org.Hs.eg.db&#34;) ; library(org.Hs.eg.db)&#xA;biocLite(&#34;pheatmap&#34;) ; library(pheatmap)&#xA;biocLite(&#34;genefilter&#34;) ; library(genefilter)&#xA;biocLite(&#34;RColorBrewer&#34;) ; library(RColorBrewer)&#xA;biocLite(&#34;GO.db&#34;) ; library(GO.db)&#xA;biocLite(&#34;topGO&#34;) ; library(topGO)&#xA;biocLite(&#34;dplyr&#34;) ; library(dplyr)&#xA;biocLite(&#34;gage&#34;) ; library(gage)&#xA;biocLite(&#34;ggsci&#34;) ; library(ggsci)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;7b. Import featureCounts output&lt;/h5&gt; &#xA;&lt;p&gt;One you have an R environment appropriatley set up, you can begin to import the &lt;strong&gt;featureCounts&lt;/strong&gt; table found within the &lt;code&gt;5_final_counts&lt;/code&gt; folder. This tutorial will use &lt;strong&gt;DESeq2&lt;/strong&gt; to normalize and perform the statistical analysis between sample groups. Be sure to know the full location of the &lt;code&gt;final_counts.txt&lt;/code&gt; file generate from &lt;strong&gt;featureCounts&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Note: If you would like to use an example final_counts.txt table, look into the example/ folder.&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Import gene counts table&#xA;# - skip first row (general command info)&#xA;# - make row names the gene identifiers&#xA;countdata &amp;lt;- read.table(&#34;example/final_counts.txt&#34;, header = TRUE, skip = 1, row.names = 1)&#xA;&#xA;# Remove .bam + &#39;..&#39; from column identifiers&#xA;colnames(countdata) &amp;lt;- gsub(&#34;.bam&#34;, &#34;&#34;, colnames(countdata), fixed = T)&#xA;colnames(countdata) &amp;lt;- gsub(&#34;.bam&#34;, &#34;&#34;, colnames(countdata), fixed = T)&#xA;colnames(countdata) &amp;lt;- gsub(&#34;..&#34;, &#34;&#34;, colnames(countdata), fixed = T)&#xA;&#xA;# Remove length/char columns&#xA;countdata &amp;lt;- countdata[ ,c(-1:-5)]&#xA;&#xA;# Make sure ID&#39;s are correct&#xA;head(countdata)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;##               SRR1374924 SRR1374923 SRR1374921 SRR1374922&#xA;## 4933401J01Rik          0          0          0          0&#xA;## Gm26206                0          0          0          0&#xA;## Xkr4                 214        302        459        425&#xA;## Gm18956                0          0          0          0&#xA;## Gm37180                4          2          3          1&#xA;## Gm37363                1          0          0          1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;7c. Import metadata text file. The SampleID&#39;s must be the first column.&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Import metadata file&#xA;# - make row names the matching sampleID&#39;s from the countdata&#xA;metadata &amp;lt;- read.delim(&#34;example/metadata.txt&#34;, row.names = 1)&#xA;&#xA;# Add sampleID&#39;s to the mapping file&#xA;metadata$sampleid &amp;lt;- row.names(metadata)&#xA;&#xA;# Reorder sampleID&#39;s to match featureCounts column order. &#xA;metadata &amp;lt;- metadata[match(colnames(countdata), metadata$sampleid), ]&#xA;&#xA;# Make sure ID&#39;s are correct&#xA;head(metadata)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;##            Group Replicate   sampleid&#xA;## SRR1374924 HiGlu      Rep2 SRR1374924&#xA;## SRR1374923 HiGlu      Rep1 SRR1374923&#xA;## SRR1374921 LoGlu      Rep1 SRR1374921&#xA;## SRR1374922 LoGlu      Rep2 SRR1374922&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;7d. Make DESeq2 object from counts and metadata&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# - countData : count dataframe&#xA;# - colData : sample metadata in the dataframe with row names as sampleID&#39;s&#xA;# - design : The design of the comparisons to use. &#xA;#            Use (~) before the name of the column variable to compare&#xA;ddsMat &amp;lt;- DESeqDataSetFromMatrix(countData = countdata,&#xA;                                 colData = metadata,&#xA;                                 design = ~Group)&#xA;&#xA;&#xA;# Find differential expressed genes&#xA;ddsMat &amp;lt;- DESeq(ddsMat)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## estimating size factors&#xA;&#xA;## estimating dispersions&#xA;&#xA;## gene-wise dispersion estimates&#xA;&#xA;## mean-dispersion relationship&#xA;&#xA;## final dispersion estimates&#xA;&#xA;## fitting model and testing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;7e. Get basic statisics about the number of significant genes&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Get results from testing with FDR adjust pvalues&#xA;results &amp;lt;- results(ddsMat, pAdjustMethod = &#34;fdr&#34;, alpha = 0.05)&#xA;&#xA;# Generate summary of testing. &#xA;summary(results)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## &#xA;## out of 10448 with nonzero total read count&#xA;## adjusted p-value &amp;lt; 0.05&#xA;## LFC &amp;gt; 0 (up)     : 996, 9.5% &#xA;## LFC &amp;lt; 0 (down)   : 767, 7.3% &#xA;## outliers [1]     : 0, 0% &#xA;## low counts [2]   : 4709, 45% &#xA;## (mean count &amp;lt; 7)&#xA;## [1] see &#39;cooksCutoff&#39; argument of ?results&#xA;## [2] see &#39;independentFiltering&#39; argument of ?results&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Check directionality of the log2 fold changes&#xA;## Log2 fold change is set as (LoGlu / HiGlu)&#xA;## Postive fold changes = Increased in LoGlu&#xA;## Negative fold changes = Decreased in LoGlu&#xA;mcols(results, use.names = T)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## DataFrame with 6 rows and 2 columns&#xA;##                        type                                  description&#xA;##                 &amp;lt;character&amp;gt;                                  &amp;lt;character&amp;gt;&#xA;## baseMean       intermediate    mean of normalized counts for all samples&#xA;## log2FoldChange      results log2 fold change (MAP): Group LoGlu vs HiGlu&#xA;## lfcSE               results         standard error: Group LoGlu vs HiGlu&#xA;## stat                results         Wald statistic: Group LoGlu vs HiGlu&#xA;## pvalue              results      Wald test p-value: Group LoGlu vs HiGlu&#xA;## padj                results                        fdr adjusted p-values&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 8. Annotate gene symbols&lt;/h3&gt; &#xA;&lt;p&gt;After alignment and summarization, we only have the annotated gene symbols. To get more information about significant genes, we can use annoated databases to convert gene symbols to full gene names and entrez ID&#39;s for further analysis.&lt;/p&gt; &#xA;&lt;h5&gt;8a. Gather gene annotation information&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Mouse genome database (Select the correct one)&#xA;library(org.Mm.eg.db) &#xA;&#xA;# Add gene full name&#xA;results$description &amp;lt;- mapIds(x = org.Mm.eg.db,&#xA;                              keys = row.names(results),&#xA;                              column = &#34;GENENAME&#34;,&#xA;                              keytype = &#34;SYMBOL&#34;,&#xA;                              multiVals = &#34;first&#34;)&#xA;&#xA;# Add gene symbol&#xA;results$symbol &amp;lt;- row.names(results)&#xA;&#xA;# Add ENTREZ ID&#xA;results$entrez &amp;lt;- mapIds(x = org.Mm.eg.db,&#xA;                         keys = row.names(results),&#xA;                         column = &#34;ENTREZID&#34;,&#xA;                         keytype = &#34;SYMBOL&#34;,&#xA;                         multiVals = &#34;first&#34;)&#xA;&#xA;# Add ENSEMBL&#xA;results$ensembl &amp;lt;- mapIds(x = org.Mm.eg.db,&#xA;                          keys = row.names(results),&#xA;                          column = &#34;ENSEMBL&#34;,&#xA;                          keytype = &#34;SYMBOL&#34;,&#xA;                          multiVals = &#34;first&#34;)&#xA;&#xA;# Subset for only significant genes (q &amp;lt; 0.05)&#xA;results_sig &amp;lt;- subset(results, padj &amp;lt; 0.05)&#xA;head(results_sig)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;## log2 fold change (MAP): Group LoGlu vs HiGlu &#xA;## Wald test p-value: Group LoGlu vs HiGlu &#xA;## DataFrame with 6 rows and 10 columns&#xA;##         baseMean log2FoldChange      lfcSE       stat       pvalue&#xA;##        &amp;lt;numeric&amp;gt;      &amp;lt;numeric&amp;gt;  &amp;lt;numeric&amp;gt;  &amp;lt;numeric&amp;gt;    &amp;lt;numeric&amp;gt;&#xA;## Xkr4    344.0867      0.6419222 0.16930869   3.791431 1.497817e-04&#xA;## Mrpl15  863.0433      0.3980896 0.11919087   3.339934 8.379824e-04&#xA;## Tcea1   934.6538      1.3944884 0.11488584  12.138036 6.640062e-34&#xA;## St18   4881.5741     -0.9991301 0.06848944 -14.588091 3.344260e-48&#xA;## Pcmtd1 2074.3123      0.3902411 0.08594089   4.540808 5.603899e-06&#xA;## Sntg1   477.2279      0.7318962 0.14674529   4.987527 6.115693e-07&#xA;##                padj&#xA;##           &amp;lt;numeric&amp;gt;&#xA;## Xkr4   9.001016e-04&#xA;## Mrpl15 4.075577e-03&#xA;## Tcea1  4.763415e-32&#xA;## St18   4.463420e-46&#xA;## Pcmtd1 4.574790e-05&#xA;## Sntg1  6.082836e-06&#xA;##                                                                         description&#xA;##                                                                         &amp;lt;character&amp;gt;&#xA;## Xkr4                                              X-linked Kx blood group related 4&#xA;## Mrpl15                                          mitochondrial ribosomal protein L15&#xA;## Tcea1                                     transcription elongation factor A (SII) 1&#xA;## St18                                               suppression of tumorigenicity 18&#xA;## Pcmtd1 protein-L-isoaspartate (D-aspartate) O-methyltransferase domain containing 1&#xA;## Sntg1                                                           syntrophin, gamma 1&#xA;##             symbol      entrez            ensembl&#xA;##        &amp;lt;character&amp;gt; &amp;lt;character&amp;gt;        &amp;lt;character&amp;gt;&#xA;## Xkr4          Xkr4      497097 ENSMUSG00000051951&#xA;## Mrpl15      Mrpl15       27395 ENSMUSG00000033845&#xA;## Tcea1        Tcea1       21399 ENSMUSG00000033813&#xA;## St18          St18      240690 ENSMUSG00000033740&#xA;## Pcmtd1      Pcmtd1      319263 ENSMUSG00000051285&#xA;## Sntg1        Sntg1       71096 ENSMUSG00000025909&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;8b. Write all the important results to .txt files&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Write normalized gene counts to a .txt file&#xA;write.table(x = as.data.frame(counts(ddsMat), normalized = T), &#xA;            file = &#39;normalized_counts.txt&#39;, &#xA;            sep = &#39;\t&#39;, &#xA;            quote = F,&#xA;            col.names = NA)&#xA;&#xA;# Write significant normalized gene counts to a .txt file&#xA;write.table(x = counts(ddsMat[row.names(results_sig)], normalized = T), &#xA;            file = &#39;normalized_counts_significant.txt&#39;, &#xA;            sep = &#39;\t&#39;, &#xA;            quote = F, &#xA;            col.names = NA)&#xA;&#xA;# Write the annotated results table to a .txt file&#xA;write.table(x = as.data.frame(results), &#xA;            file = &#34;results_gene_annotated.txt&#34;, &#xA;            sep = &#39;\t&#39;, &#xA;            quote = F,&#xA;            col.names = NA)&#xA;&#xA;# Write significant annotated results table to a .txt file&#xA;write.table(x = as.data.frame(results_sig), &#xA;            file = &#34;results_gene_annotated_significant.txt&#34;, &#xA;            sep = &#39;\t&#39;, &#xA;            quote = F,&#xA;            col.names = NA)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 9. Plotting Gene Expression Data&lt;/h3&gt; &#xA;&lt;p&gt;There are multiple ways to plot gene expression data. Below we are only listing a few popular methods, but there are many more resources (&lt;strong&gt;Going Further&lt;/strong&gt;) that will walk through different R commands/packages for plotting.&lt;/p&gt; &#xA;&lt;h5&gt;9a. PCA plot&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Convert all samples to rlog&#xA;ddsMat_rlog &amp;lt;- rlog(ddsMat, blind = FALSE)&#xA;&#xA;# Plot PCA by column variable&#xA;plotPCA(ddsMat_rlog, intgroup = &#34;Group&#34;, ntop = 500) +&#xA;  theme_bw() + # remove default ggplot2 theme&#xA;  geom_point(size = 5) + # Increase point size&#xA;  scale_y_continuous(limits = c(-5, 5)) + # change limits to fix figure dimensions&#xA;  ggtitle(label = &#34;Principal Component Analysis (PCA)&#34;, &#xA;          subtitle = &#34;Top 500 most variable genes&#34;) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twbattaglia/RNAseq-workflow/master/README_files/figure-markdown_github/pca_plot-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;9b. Heatmap&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Convert all samples to rlog&#xA;ddsMat_rlog &amp;lt;- rlog(ddsMat, blind = FALSE)&#xA;&#xA;# Gather 30 significant genes and make matrix&#xA;mat &amp;lt;- assay(ddsMat_rlog[row.names(results_sig)])[1:40, ]&#xA;&#xA;# Choose which column variables you want to annotate the columns by.&#xA;annotation_col = data.frame(&#xA;  Group = factor(colData(ddsMat_rlog)$Group), &#xA;  Replicate = factor(colData(ddsMat_rlog)$Replicate),&#xA;  row.names = colData(ddsMat_rlog)$sampleid&#xA;)&#xA;&#xA;# Specify colors you want to annotate the columns by.&#xA;ann_colors = list(&#xA;  Group = c(LoGlu = &#34;lightblue&#34;, HiGlu = &#34;darkorange&#34;),&#xA;  Replicate = c(Rep1 = &#34;darkred&#34;, Rep2 = &#34;forestgreen&#34;)&#xA;)&#xA;&#xA;# Make Heatmap with pheatmap function.&#xA;## See more in documentation for customization&#xA;pheatmap(mat = mat, &#xA;         color = colorRampPalette(brewer.pal(9, &#34;YlOrBr&#34;))(255), &#xA;         scale = &#34;row&#34;, # Scale genes to Z-score (how many standard deviations)&#xA;         annotation_col = annotation_col, # Add multiple annotations to the samples&#xA;         annotation_colors = ann_colors,# Change the default colors of the annotations&#xA;         fontsize = 6.5, # Make fonts smaller&#xA;         cellwidth = 55, # Make the cells wider&#xA;         show_colnames = F)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twbattaglia/RNAseq-workflow/master/README_files/figure-markdown_github/heatmap_plot-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;9c. Volcano Plot&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Gather Log-fold change and FDR-corrected pvalues from DESeq2 results&#xA;## - Change pvalues to -log10 (1.3 = 0.05)&#xA;data &amp;lt;- data.frame(gene = row.names(results),&#xA;                   pval = -log10(results$padj), &#xA;                   lfc = results$log2FoldChange)&#xA;&#xA;# Remove any rows that have NA as an entry&#xA;data &amp;lt;- na.omit(data)&#xA;&#xA;# Color the points which are up or down&#xA;## If fold-change &amp;gt; 0 and pvalue &amp;gt; 1.3 (Increased significant)&#xA;## If fold-change &amp;lt; 0 and pvalue &amp;gt; 1.3 (Decreased significant)&#xA;data &amp;lt;- mutate(data, color = case_when(data$lfc &amp;gt; 0 &amp;amp; data$pval &amp;gt; 1.3 ~ &#34;Increased&#34;,&#xA;                                       data$lfc &amp;lt; 0 &amp;amp; data$pval &amp;gt; 1.3 ~ &#34;Decreased&#34;,&#xA;                                       data$pval &amp;lt; 1.3 ~ &#34;nonsignificant&#34;))&#xA;&#xA;# Make a basic ggplot2 object with x-y values&#xA;vol &amp;lt;- ggplot(data, aes(x = lfc, y = pval, color = color))&#xA;&#xA;# Add ggplot2 layers&#xA;vol +   &#xA;  ggtitle(label = &#34;Volcano Plot&#34;, subtitle = &#34;Colored by fold-change direction&#34;) +&#xA;  geom_point(size = 2.5, alpha = 0.8, na.rm = T) +&#xA;  scale_color_manual(name = &#34;Directionality&#34;,&#xA;                     values = c(Increased = &#34;#008B00&#34;, Decreased = &#34;#CD4F39&#34;, nonsignificant = &#34;darkgray&#34;)) +&#xA;  theme_bw(base_size = 14) + # change overall theme&#xA;  theme(legend.position = &#34;right&#34;) + # change the legend&#xA;  xlab(expression(log[2](&#34;LoGlu&#34; / &#34;HiGlu&#34;))) + # Change X-Axis label&#xA;  ylab(expression(-log[10](&#34;adjusted p-value&#34;))) + # Change Y-Axis label&#xA;  geom_hline(yintercept = 1.3, colour = &#34;darkgrey&#34;) + # Add p-adj value cutoff line&#xA;  scale_y_continuous(trans = &#34;log1p&#34;) # Scale yaxis due to large p-values&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twbattaglia/RNAseq-workflow/master/README_files/figure-markdown_github/volcano_plot-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;9d. MA Plot&lt;/h5&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/MA_plot&#34;&gt;https://en.wikipedia.org/wiki/MA_plot&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plotMA(results, ylim = c(-5, 5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twbattaglia/RNAseq-workflow/master/README_files/figure-markdown_github/ma_plot-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;9e. Plot Dispersions&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plotDispEsts(ddsMat)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twbattaglia/RNAseq-workflow/master/README_files/figure-markdown_github/dispersions-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;9f. Single gene plot&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Convert all samples to rlog&#xA;ddsMat_rlog &amp;lt;- rlog(ddsMat, blind = FALSE)&#xA;&#xA;# Get gene with highest expression&#xA;top_gene &amp;lt;- rownames(results)[which.min(results$log2FoldChange)]&#xA;&#xA;# Plot single gene&#xA;plotCounts(dds = ddsMat, &#xA;           gene = top_gene, &#xA;           intgroup = &#34;Group&#34;, &#xA;           normalized = T, &#xA;           transform = T)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twbattaglia/RNAseq-workflow/master/README_files/figure-markdown_github/single_plot-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 10. Finding Pathways from Differential Expressed Genes&lt;/h3&gt; &#xA;&lt;p&gt;Pathway enrichment analysis is a great way to generate overall conclusions based on the individual gene changes. Sometimes individiual gene changes are overwheling and are difficult to interpret. But by analyzing the pathways the genes fall into, we can gather a top level view of gene responses. You can find more information about &lt;strong&gt;clusterProfiler&lt;/strong&gt; here: &lt;a href=&#34;http://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html&#34;&gt;http://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;10a. Set up matrix to take into account EntrezID&#39;s and fold changes for each gene&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Remove any genes that do not have any entrez identifiers&#xA;results_sig_entrez &amp;lt;- subset(results_sig, is.na(entrez) == FALSE)&#xA;&#xA;# Create a matrix of gene log2 fold changes&#xA;gene_matrix &amp;lt;- results_sig_entrez$log2FoldChange&#xA;&#xA;# Add the entrezID&#39;s as names for each logFC entry&#xA;names(gene_matrix) &amp;lt;- results_sig_entrez$entrez&#xA;&#xA;# View the format of the gene matrix&#xA;##- Names = ENTREZ ID&#xA;##- Values = Log2 Fold changes&#xA;head(gene_matrix)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;##     497097      27395      21399     240690     319263      71096 &#xA;##  0.6419222  0.3980896  1.3944884 -0.9991301  0.3902411  0.7318962&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;10b. Enrich genes using the KEGG database&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;kegg_enrich &amp;lt;- enrichKEGG(gene = names(gene_matrix),&#xA;                          organism = &#39;mouse&#39;,&#xA;                          pvalueCutoff = 0.05, &#xA;                          qvalueCutoff = 0.10)&#xA;&#xA;# Plot results&#xA;barplot(kegg_enrich, &#xA;        drop = TRUE, &#xA;        showCategory = 10, &#xA;        title = &#34;KEGG Enrichment Pathways&#34;,&#xA;        font.size = 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twbattaglia/RNAseq-workflow/master/README_files/figure-markdown_github/kegg_enrich-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h5&gt;10c. Enrich genes using the Gene Onotlogy&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;go_enrich &amp;lt;- enrichGO(gene = names(gene_matrix),&#xA;                      OrgDb = &#39;org.Mm.eg.db&#39;, &#xA;                      readable = T,&#xA;                      ont = &#34;BP&#34;,&#xA;                      pvalueCutoff = 0.05, &#xA;                      qvalueCutoff = 0.10)&#xA;&#xA;# Plot results&#xA;barplot(go_enrich, &#xA;        drop = TRUE, &#xA;        showCategory = 10, &#xA;        title = &#34;GO Biological Pathways&#34;,&#xA;        font.size = 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twbattaglia/RNAseq-workflow/master/README_files/figure-markdown_github/go_enrich-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 11. Plotting KEGG Pathways&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pathview&lt;/strong&gt; is a package that can take KEGG identifier and overlay fold changes to the genes which are found to be significantly different. &lt;strong&gt;Pathview&lt;/strong&gt; also works with other organisms found in the KEGG database and can plot any of the KEGG pathways for the particular organism.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Load pathview&#xA;biocLite(&#34;pathview&#34;) ; library(pathview)&#xA;&#xA;# Plot specific KEGG pathways (with fold change) &#xA;## pathway.id : KEGG pathway identifier&#xA;pathview(gene.data = gene_matrix, &#xA;         pathway.id = &#34;04070&#34;, &#xA;         species = &#34;mouse&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twbattaglia/RNAseq-workflow/master/README_files/mmu04070.pathview.png&#34; alt=&#34;KEGG Pathways&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Going further with RNAseq analysis&lt;/h3&gt; &#xA;&lt;p&gt;You can the links below for a more in depth walk through of RNAseq analysis using R:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.bioconductor.org/help/workflows/rnaseqGene/&#34;&gt;http://www.bioconductor.org/help/workflows/rnaseqGene/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://bioconnector.org/workshops/r-rnaseq-airway.html&#34;&gt;http://bioconnector.org/workshops/r-rnaseq-airway.html&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www-huber.embl.de/users/klaus/Teaching/DESeq2Predoc2014.html&#34;&gt;http://www-huber.embl.de/users/klaus/Teaching/DESeq2Predoc2014.html&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www-huber.embl.de/users/klaus/Teaching/DESeq2.pdf&#34;&gt;http://www-huber.embl.de/users/klaus/Teaching/DESeq2.pdf&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://web.stanford.edu/class/bios221/labs/rnaseq/lab_4_rnaseq.html&#34;&gt;https://web.stanford.edu/class/bios221/labs/rnaseq/lab_4_rnaseq.html&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.rna-seqblog.com/which-method-should-you-use-for-normalization-of-rna-seq-data/&#34;&gt;http://www.rna-seqblog.com/which-method-should-you-use-for-normalization-of-rna-seq-data/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.rna-seqblog.com/category/technology/methods/data-analysis/data-visualization/&#34;&gt;http://www.rna-seqblog.com/category/technology/methods/data-analysis/data-visualization/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.rna-seqblog.com/category/technology/methods/data-analysis/pathway-analysis/&#34;&gt;http://www.rna-seqblog.com/category/technology/methods/data-analysis/pathway-analysis/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.rna-seqblog.com/inferring-metabolic-pathway-activity-levels-from-rna-seq-data/&#34;&gt;http://www.rna-seqblog.com/inferring-metabolic-pathway-activity-levels-from-rna-seq-data/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;Citations:&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Andrews S. (2010). FastQC: a quality control tool for high throughput sequence data. Available online at: &lt;a href=&#34;http://www.bioinformatics.babraham.ac.uk/projects/fastqc&#34;&gt;http://www.bioinformatics.babraham.ac.uk/projects/fastqc&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Martin, Marcel. Cutadapt removes adapter sequences from high-throughput sequencing reads. EMBnet.journal, [S.l.], v. 17, n. 1, p. pp. 10-12, may. 2011. ISSN 2226-6089. Available at: &lt;a href=&#34;http://journal.embnet.org/index.php/embnetjournal/article/view/200&#34;&gt;http://journal.embnet.org/index.php/embnetjournal/article/view/200&lt;/a&gt;. &lt;a href=&#34;doi:http://dx.doi.org/10.14806/ej.17.1.200&#34;&gt;doi:http://dx.doi.org/10.14806/ej.17.1.200&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Kopylova E., Noé L. and Touzet H., &#34;SortMeRNA: Fast and accurate filtering of ribosomal RNAs in metatranscriptomic data&#34;, Bioinformatics (2012), doi: 10.1093/bioinformatics/bts611&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Dobin A, Davis CA, Schlesinger F, et al. STAR: ultrafast universal RNA-seq aligner. Bioinformatics. 2013;29(1):15-21. &lt;a href=&#34;doi:10.1093/bioinformatics/bts635&#34;&gt;doi:10.1093/bioinformatics/bts635&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Lassmann et al. (2010) &#34;SAMStat: monitoring biases in next generation sequencing data.&#34; Bioinformatics &lt;a href=&#34;doi:10.1093/bioinformatics/btq614&#34;&gt;doi:10.1093/bioinformatics/btq614&lt;/a&gt; [PMID: 21088025]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Liao Y, Smyth GK and Shi W (2014). featureCounts: an efficient general purpose program for assigning sequence reads to genomic features. Bioinformatics, 30(7):923-30.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Love MI, Huber W and Anders S (2014). “Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2.” Genome Biology, 15, pp. 550.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Yu G, Wang L, Han Y and He Q (2012). “clusterProfiler: an R package for comparing biological themes among gene clusters.” OMICS: A Journal of Integrative Biology, 16(5), pp. 284-287.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Philip Ewels, Måns Magnusson, Sverker Lundin and Max Käller. &#34;MultiQC: Summarize analysis results for multiple tools and samples in a single report&#34; Bioinformatics (2016). doi: 10.1093/bioinformatics/btw354. PMID: 27312411&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>cj-holmes/isocuboids</title>
    <updated>2022-08-11T01:52:16Z</updated>
    <id>tag:github.com,2022-08-11:/cj-holmes/isocuboids</id>
    <link href="https://github.com/cj-holmes/isocuboids" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A package for transforming images/pictures or matrices into pseudo 3D isometric height maps&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;isocuboids &lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/hex-logo.png&#34; align=&#34;right&#34; height=&#34;139&#34;&gt;&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://lifecycle.r-lib.org/articles/stages.html#experimental&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/lifecycle-experimental-orange.svg?sanitize=true&#34; alt=&#34;Lifecycle: experimental&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;An &lt;strong&gt;experimental&lt;/strong&gt; and &lt;strong&gt;in development&lt;/strong&gt; R package for the production of isometric pseudo 3-D images.&lt;/p&gt; &#xA;&lt;p&gt;Pseudo, because (for images) the height of the cuboids can be mapped to different aspects of the pixel colour (or position), creating a ‘fake 3D’ effect which may have no correlation to any form of ‘real’ height. Shading of the cuboid faces is also done naively - it’s a simple reduction in brightness, so there is no clever physics going on here!&lt;/p&gt; &#xA;&lt;p&gt;I am developing this project for fun and personal learning. If it’s useful to you in any way, that’s great news, but please bear the following in mind…&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There are some incredibly cool R packages for doing this type of thing properly… &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/tylermorganwall/rayshader&#34;&gt;rayshader&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/coolbutuseless/ggrgl&#34;&gt;ggrgl&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/coolbutuseless/isocubes&#34;&gt;isocubes&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;All of my knowledge on isometric projections has come from &lt;a href=&#34;https://en.wikipedia.org/wiki/Isometric_projection&#34;&gt;this&lt;/a&gt; wikipedia article&lt;/li&gt; &#xA; &lt;li&gt;This package is written purely in R (there is no C++ code) so it is slow to run for large numbers of cuboids &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Anything above a few hundred cuboids square becomes slow to render&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;I don’t know what I’m doing!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Overview&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For &lt;strong&gt;images/pictures&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;use &lt;code&gt;cuboid_image()&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Each pixel is turned into a cuboid that has its height (from the zero ground plane) modified in proportion to some (chosen) aspect of the pixel colour.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;For &lt;strong&gt;matrices&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;cuboid_matrix()&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;The height of the cuboid is mapped to the value of the individual matrix elements.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Images&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(tidyverse)&#xA;library(magick)&#xA;library(isocuboids)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Read an image&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;i &amp;lt;- &#39;https://tatianamowry.files.wordpress.com/2018/06/skull-dm.png&#39;&#xA;image_read(i)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-3-1.png&#34; width=&#34;30%&#34;&gt; &#xA;&lt;h2&gt;Defaults&lt;/h2&gt; &#xA;&lt;p&gt;By default, images are resized to be 60 cuboids wide &lt;code&gt;res = 60&lt;/code&gt; and rendered as an isometric view. Cuboid heights are mapped to the brightness value of their corresponding pixel and scaled to range between 1 and 10 units high&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cuboid_image(i)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-4-1.png&#34; width=&#34;75%&#34;&gt; &#xA;&lt;h2&gt;Orientation perspective&lt;/h2&gt; &#xA;&lt;p&gt;The orientation applied to the image before projection. This changes the perspective of the final output. Note that this is a transformation of the incoming image - the origin of the coordinate system is unchanged.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cuboid_image(i, orientation = 1)&#xA;cuboid_image(i, orientation = 2)&#xA;cuboid_image(i, orientation = 3)&#xA;cuboid_image(i, orientation = 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-5-1.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-5-2.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-5-3.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-5-4.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Fill colour and shading&lt;/h2&gt; &#xA;&lt;p&gt;The fill colour and degree of side shading can be modified with the &lt;code&gt;cuboid_fill&lt;/code&gt; and &lt;code&gt;shading&lt;/code&gt; values&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cuboid_image(i, cuboid_fill = hcl.colors(20, &#34;viridis&#34;))&#xA;cuboid_image(i, cuboid_fill = &#34;antiquewhite&#34;)&#xA;cuboid_image(i, cuboid_fill = hcl.colors(20, &#34;plasma&#34;), shading = c(0, 0, 0.7))&#xA;cuboid_image(i, cuboid_fill = hcl.colors(20, &#34;plasma&#34;), shading = c(0, 0.7, 0))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-6-1.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-6-2.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-6-3.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-6-4.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Height scale&lt;/h2&gt; &#xA;&lt;p&gt;The overall scaling of the cuboid height can be set with &lt;code&gt;height_scale&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cuboid_image(i, height_scale = c(0, 0))&#xA;cuboid_image(i, height_scale = c(0, 10))&#xA;cuboid_image(i, height_scale = c(30, 40))&#xA;cuboid_image(i, height_scale = c(40, 30), cuboid_fill = hcl.colors(20, &#34;plasma&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-7-1.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-7-2.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-7-3.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-7-4.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Return data&lt;/h2&gt; &#xA;&lt;p&gt;For fine control, a dataframe of the projected coordinates and polygon groups/colours can be returned&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df &amp;lt;- cuboid_image(i, return_data = TRUE, height_scale = c(1, 10))&#xA;head(df)&#xA;#&amp;gt; # A tibble: 6 × 21&#xA;#&amp;gt;       x     z col           r     g     b     h     s     v cuboid…¹     y face &#xA;#&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;&#xA;#&amp;gt; 1    59    59 #000000ff     0     0     0     0     0     0     3600     1 right&#xA;#&amp;gt; 2    59    59 #000000ff     0     0     0     0     0     0     3600     1 right&#xA;#&amp;gt; 3    59    59 #000000ff     0     0     0     0     0     0     3600     1 right&#xA;#&amp;gt; 4    59    59 #000000ff     0     0     0     0     0     0     3600     1 right&#xA;#&amp;gt; 5    59    59 #000000ff     0     0     0     0     0     0     3600     1 left &#xA;#&amp;gt; 6    59    59 #000000ff     0     0     0     0     0     0     3600     1 left &#xA;#&amp;gt; # … with 9 more variables: ux &amp;lt;dbl&amp;gt;, uy &amp;lt;dbl&amp;gt;, uz &amp;lt;dbl&amp;gt;, px &amp;lt;dbl&amp;gt;, py &amp;lt;dbl&amp;gt;,&#xA;#&amp;gt; #   pz &amp;lt;dbl&amp;gt;, v_adjusted &amp;lt;dbl&amp;gt;, col_adjusted &amp;lt;chr&amp;gt;, plot_group &amp;lt;fct&amp;gt;, and&#xA;#&amp;gt; #   abbreviated variable name ¹​cuboid_id&#xA;#&amp;gt; # ℹ Use `colnames()` to see all variable names&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Filter rows and columns&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Slices in z&#xA;df |&amp;gt; &#xA;    filter(z %in% c(40, 20)) |&amp;gt; &#xA;    ggplot()+ &#xA;    geom_polygon(aes(x = px, y = py, fill = I(col_adjusted), group = plot_group), col = NA)+&#xA;    coord_equal()&#xA;&#xA;# A ring of coordinates&#xA;df |&amp;gt; &#xA;    mutate(&#xA;        xn = x - max(x)/2,&#xA;        zn = z - max(z)/2,&#xA;        r = sqrt(xn^2 + zn^2)) |&amp;gt; &#xA;    filter(between(r, 22, 24)) |&amp;gt; &#xA;    ggplot()+ &#xA;    geom_polygon(aes(x = px, y = py, fill = I(col_adjusted), group = plot_group), col = NA)+&#xA;    coord_equal()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-9-1.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-9-2.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Highlight specific cuboid faces&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df |&amp;gt; &#xA;    mutate(&#xA;        xn = x - max(x)/2,&#xA;        zn = z - max(z)/2,&#xA;        r = sqrt(xn^2 + zn^2),&#xA;        col_adjusted = &#xA;            case_when(&#xA;                y == max(y) &amp;amp; face == &#34;top&#34; ~ &#34;red&#34;,&#xA;                y == max(y) &amp;amp; face == &#34;left&#34; ~ &#34;red3&#34;,&#xA;                y == max(y) &amp;amp; face == &#34;right&#34; ~ &#34;red4&#34;,&#xA;                between(r, 22, 24) &amp;amp; face == &#34;top&#34; ~ &#34;blue&#34;,&#xA;                between(r, 22, 24) &amp;amp; face == &#34;left&#34; ~ &#34;blue3&#34;,&#xA;                between(r, 22, 24) &amp;amp; face == &#34;right&#34; ~ &#34;blue4&#34;,&#xA;                TRUE ~col_adjusted)) |&amp;gt; &#xA;    ggplot() + &#xA;    geom_polygon(&#xA;        aes(x = px, y = py, fill = I(col_adjusted), group = plot_group), &#xA;        col = NA) +&#xA;    coord_equal()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-10-1.png&#34; width=&#34;75%&#34;&gt; &#xA;&lt;p&gt;Split the plot through facetting&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df |&amp;gt; &#xA;    ggplot() + &#xA;    geom_polygon(&#xA;        aes(x = px, y = py, fill = I(col_adjusted), group = plot_group), &#xA;        col = NA) +&#xA;    coord_fixed()+&#xA;    facet_wrap(~z &amp;gt; 30, ncol=1)&#xA;&#xA;df |&amp;gt; &#xA;    ggplot() + &#xA;    geom_polygon(&#xA;        aes(x = px, y = py, fill = I(col_adjusted), group = plot_group), &#xA;        col = NA) +&#xA;    coord_fixed()+&#xA;    facet_wrap(~ x &amp;lt; 30 &amp;amp; y &amp;gt; 5, ncol = 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-11-1.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-11-2.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Height mapping&lt;/h2&gt; &#xA;&lt;p&gt;Cuboid height is mapped from the image pixel values. By default, brightness &lt;code&gt;v&lt;/code&gt; is used. Any function of the following parameters can be passed to &lt;code&gt;height_map&lt;/code&gt; - red &lt;code&gt;r&lt;/code&gt; - green &lt;code&gt;g&lt;/code&gt; - blue &lt;code&gt;b&lt;/code&gt; - hue &lt;code&gt;h&lt;/code&gt; - saturation &lt;code&gt;s&lt;/code&gt; - brightness &lt;code&gt;v&lt;/code&gt; - x-position &lt;code&gt;x&lt;/code&gt; - z-position &lt;code&gt;z&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;i2 &amp;lt;- &#xA;    image_read(&#39;https://www.r-project.org/logo/Rlogo.png&#39;) |&amp;gt; &#xA;    image_background(&#34;white&#34;)&#xA;&#xA;i2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-12-1.png&#34; width=&#34;20%&#34;&gt; &#xA;&lt;p&gt;Various functions of the x and z coordinates&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cuboid_image(i2, &#xA;             height_map = sin(scales::rescale(x,c(0,4*pi))), &#xA;             crop_square = FALSE,&#xA;             height_scale = c(1, 10))&#xA;&#xA;cuboid_image(i2, &#xA;             height_map = z^3,&#xA;             crop_square = FALSE,&#xA;             height_scale = c(1, 30), a1 = 80)&#xA;&#xA;cuboid_image(i2, &#xA;             height_map = ((x - (max(x)/2))^2) + ((z - (max(z)/2))^2),&#xA;             crop_square = FALSE, &#xA;             height_scale = c(1, 30))&#xA;&#xA;cuboid_image(i2, &#xA;             crop_square = FALSE, &#xA;             height_map = (x-(max(x)/2))^3, &#xA;             height_scale = c(1, 50))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-13-1.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-13-2.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-13-3.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-13-4.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Demonstration of mapping various different colour values to height.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Create a &#39;rainbow&#39; colour image&#xA;i3 &amp;lt;- &#xA;    rep(viridis::turbo(100), each = 40) |&amp;gt; &#xA;    matrix(ncol = 100) |&amp;gt; &#xA;    image_read()&#xA;&#xA;i3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-14-1.png&#34; width=&#34;30%&#34;&gt; &#xA;&lt;p&gt;Map hue, red, green and blue to height&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cuboid_image(i3, res = NULL, height_map = h, crop_square = FALSE)&#xA;cuboid_image(i3, res = NULL, height_map = r, crop_square = FALSE)&#xA;cuboid_image(i3, res = NULL, height_map = g, crop_square = FALSE)&#xA;cuboid_image(i3, res = NULL, height_map = b, crop_square = FALSE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-15-1.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-15-2.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-15-3.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-15-4.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Pre-edit with {magick}&lt;/h2&gt; &#xA;&lt;p&gt;Edit the image before passing into &lt;code&gt;cuboid_image()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;image_read(i) |&amp;gt; &#xA;    image_resize(&#34;60x60&#34;) |&amp;gt; &#xA;    image_motion_blur(angle = 45, radius = 6, sigma = 20) |&amp;gt; &#xA;    cuboid_image(res = NULL)&#xA;&#xA;image_read(i) |&amp;gt; &#xA;    image_resize(&#34;60x60&#34;) |&amp;gt;&#xA;    image_canny() |&amp;gt; &#xA;    cuboid_image(res = NULL, orientation = 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-16-1.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-16-2.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Scan through an image&lt;/h2&gt; &#xA;&lt;p&gt;Scan through an image creating cross sectional plots&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Set aesthetics for visualisation&#xA;res &amp;lt;- 60&#xA;from &amp;lt;- 1 # height scale min&#xA;to &amp;lt;- 10 # height scale max&#xA;&#xA;img &amp;lt;-&#xA;    image_read(&#39;https://tatianamowry.files.wordpress.com/2018/06/skull-dm.png&#39;) |&amp;gt; &#xA;    image_resize(paste0(res, &#34;x&#34;, res, &#34;^&#34;)) |&amp;gt; &#xA;    image_crop(paste0(res, &#34;x&#34;, res), gravity = &#34;center&#34;)&#xA;&#xA;# Overall isometric angles plot&#xA;df1 &amp;lt;- &#xA;    cuboid_image(&#xA;        img,&#xA;        res = NULL,&#xA;        height_scale = c(from, to),&#xA;        return_data = TRUE)&#xA;&#xA;# Cross section 1&#xA;df2 &amp;lt;- &#xA;    cuboid_image(&#xA;        img,&#xA;        res = NULL,&#xA;        height_scale = c(from, to),&#xA;        return_data = TRUE,&#xA;        a1 = 0, &#xA;        a2 = 0,&#xA;        shading = c(0,0,0))&#xA;&#xA;# Cross section 2&#xA;df3 &amp;lt;- &#xA;    cuboid_image(&#xA;        img,&#xA;        res = NULL,&#xA;        height_scale = c(from, to),&#xA;        return_data = TRUE,&#xA;        a1 = 90, &#xA;        a2 = 0, &#xA;        shading = c(0,0,0))&#xA;&#xA;for(i in df1$z |&amp;gt; unique() |&amp;gt; sort()){&#xA;&#xA;    # Isometric plot&#xA;    p1 &amp;lt;-&#xA;        df1 |&amp;gt; &#xA;        mutate(col_adjusted = case_when(&#xA;            z == i &amp;amp; x == i &amp;amp; face == &#34;top&#34; ~ &#34;purple&#34;,&#xA;            z == i &amp;amp; x == i &amp;amp; face == &#34;left&#34; ~ &#34;purple3&#34;,&#xA;            z == i &amp;amp; x == i &amp;amp; face == &#34;right&#34; ~ &#34;purple4&#34;,&#xA;            z == i &amp;amp; face == &#34;top&#34; ~ &#34;red&#34;,&#xA;            z == i &amp;amp; face == &#34;left&#34; ~ &#34;red3&#34;,&#xA;            z == i &amp;amp; face == &#34;right&#34; ~ &#34;red4&#34;,&#xA;            x == i &amp;amp; face == &#34;top&#34; ~ &#34;blue&#34;,&#xA;            x == i &amp;amp; face == &#34;left&#34; ~ &#34;blue3&#34;,&#xA;            x == i &amp;amp; face == &#34;right&#34; ~ &#34;blue4&#34;,&#xA;            TRUE ~ col_adjusted)) |&amp;gt; &#xA;        ggplot() +&#xA;        geom_polygon(aes(px, py, fill = I(col_adjusted), group = plot_group))+&#xA;        coord_equal()+&#xA;        theme(axis.title = element_blank())&#xA;    &#xA;    # Cross section 1&#xA;    p2 &amp;lt;-&#xA;        df2 |&amp;gt; &#xA;        filter(z == i) |&amp;gt; &#xA;        ggplot() +&#xA;        geom_polygon(aes(px, py, fill = I(col_adjusted), group = plot_group))+&#xA;        coord_equal(ylim = c(from, to))+&#xA;        theme(panel.border = element_rect(colour = &#34;red&#34;, fill = NA, size = 1),&#xA;              axis.title = element_blank())&#xA;    &#xA;    # Cross section 2&#xA;    p3 &amp;lt;-&#xA;        df3 |&amp;gt; &#xA;        filter(x == i) |&amp;gt; &#xA;        ggplot() +&#xA;        geom_polygon(aes(px, py, fill = I(col_adjusted), group = plot_group))+&#xA;        coord_equal(ylim = c(from, to))+&#xA;        theme(panel.border = element_rect(colour = &#34;blue&#34;, fill = NA, size = 1),&#xA;              axis.title = element_blank())&#xA;    &#xA;    # Output&#xA;    p4 &amp;lt;- patchwork::wrap_plots(p1, p2, p3, ncol =1)&#xA;    ggsave(paste0(&#34;data-raw/animation/&#34;,i,&#34;.jpg&#34;), width = 6, height = 6, bg = &#34;white&#34;)&#xA;}&#xA;&#xA;# Read image files in correct order!&#xA;s &amp;lt;-&#xA;    tibble(f = list.files(&#39;data-raw/animation/&#39;, pattern = &#39;.jpg&#39;, full.names = T)) |&amp;gt; &#xA;    mutate(n = str_extract(f, &#34;[0-9]+(?=\\.jpg)&#34;) |&amp;gt; as.integer()) |&amp;gt; &#xA;    arrange(n) |&amp;gt; &#xA;    pull(f) |&amp;gt; &#xA;    image_read()&#xA;&#xA;# Make smaller&#xA;s_small &amp;lt;- image_resize(s, &#34;600x&#34;)&#xA;&#xA;# Save animated gif&#xA;image_write_gif(s_small, &#39;data-raw/animation/anim.gif&#39;, delay = 0.15)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-18-1.gif&#34; width=&#34;75%&#34;&gt; &#xA;&lt;h1&gt;Matrices&lt;/h1&gt; &#xA;&lt;p&gt;For matrices, the matrix is not resized and the height of the cuboids is mapped directly to the values contained in the matrix.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cuboid_matrix(matrix(1))&#xA;cuboid_matrix(matrix(1:5), show_height_plane = TRUE)&#xA;cuboid_matrix(matrix(1:5), show_height_plane = TRUE, orientation = 4)&#xA;cuboid_matrix(matrix(seq(0,2,l=25), nrow=5), show_height_plane = TRUE, cuboid_col = 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-19-1.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-19-2.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-19-3.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-19-4.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Some examples with the &lt;code&gt;volcano&lt;/code&gt; data&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cuboid_matrix(volcano |&amp;gt; scales::rescale(c(0,20)))&#xA;cuboid_matrix(volcano |&amp;gt; scales::rescale(c(20,0)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-20-1.png&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-20-2.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Generate terrain&lt;/h2&gt; &#xA;&lt;p&gt;Generate fake terrain using &lt;code&gt;{ambient}&lt;/code&gt; noise. Shamelessly stolen from &lt;a href=&#34;https://coolbutuseless.github.io/2022/07/01/isocubes-v0.1.2-update-with-signed-distance-fields/&#34;&gt;coolbutuseless&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- 50&#xA;set.seed(s)&#xA;&#xA;expand_grid(x=1:s, y=1:s) |&amp;gt;&#xA;    mutate(n = ambient::gen_perlin(x, y, frequency = 0.06)) |&amp;gt;&#xA;    pull(n) |&amp;gt; &#xA;    cut(5, labels=FALSE) |&amp;gt;&#xA;    matrix(ncol = s) |&amp;gt; &#xA;    cuboid_matrix(cuboid_fill = topo.colors(20))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-21-1.png&#34; width=&#34;75%&#34;&gt; &#xA;&lt;h2&gt;Penrose stairs&lt;/h2&gt; &#xA;&lt;p&gt;An approximation of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Penrose_stairs&#34;&gt;Penrose stairs&lt;/a&gt;. This is not exact, I used trial and error to get the correct spacing for the stairs to line up!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;d &amp;lt;- seq(2, by=0.214, l=14)&#xA;&#xA;m &amp;lt;-&#xA;    matrix(&#xA;        c(rev(d[1:6]),&#xA;          d[7], 0, 0, 0, 0, 0,&#xA;          d[8], 0, 0, 0, 0, 0,&#xA;          d[9], 0, 0, 0, 0, 0,&#xA;          d[10], 0, d[14], 0, 0, 0,&#xA;          d[11:13], 0, 0, 0), ncol = 6, byrow = T)&#xA;&#xA;cuboid_matrix(m, cuboid_col = 1, show_axes = F, return_data = T) |&amp;gt;&#xA;    filter(!(x &amp;gt; 2 &amp;amp; z &amp;lt; 5)) |&amp;gt;&#xA;    ggplot()+&#xA;    geom_polygon(aes(px, py, group = plot_group, fill=face), col = 1)+&#xA;    coord_equal()+&#xA;    theme(legend.position = &#34;&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cj-holmes/isocuboids/main/man/figures/README-unnamed-chunk-22-1.png&#34; width=&#34;75%&#34;&gt;</summary>
  </entry>
  <entry>
    <title>r-lib/asciicast</title>
    <updated>2022-08-11T01:52:16Z</updated>
    <id>tag:github.com,2022-08-11:/r-lib/asciicast</id>
    <link href="https://github.com/r-lib/asciicast" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Turn R scripts into terminal screencasts&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;asciicast&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Turn R scripts into terminal screencasts&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://lifecycle.r-lib.org/articles/stages.html#experimental&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/lifecycle-experimental-orange.svg?sanitize=true&#34; alt=&#34;Lifecycle: experimental&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://cran.r-project.org/package=asciicast&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version/asciicast&#34; alt=&#34;CRAN status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.codecov.io/gh/r-lib/asciicast?branch=main&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/r-lib/asciicast/branch/main/graph/badge.svg?sanitize=true&#34; alt=&#34;Codecov test coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/r-lib/asciicast/actions/workflows/R-CMD-check.yaml&#34;&gt;&lt;img src=&#34;https://github.com/r-lib/asciicast/actions/workflows/R-CMD-check.yaml/badge.svg?sanitize=true&#34; alt=&#34;R-CMD-check&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;asciicast takes an R script and turns it into an &lt;a href=&#34;https://asciinema.org/&#34;&gt;asciinema&lt;/a&gt; cast. It can simulate typing, and records all terminal output in real time as it happens.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Input is an R script, output is a &lt;a href=&#34;https://github.com/asciinema/asciinema/raw/develop/doc/asciicast-v2.md&#34;&gt;v2 asciicast recording&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Record all terminal output in real time, as it happens.&lt;/li&gt; &#xA; &lt;li&gt;Simulate typing in the commands, with a configurable, randomized speed.&lt;/li&gt; &#xA; &lt;li&gt;Alternatively, whole comment blocks or expressions can just appear on the screen.&lt;/li&gt; &#xA; &lt;li&gt;Convert casts to SVG images using &lt;a href=&#34;https://github.com/marionebl/svg-term&#34;&gt;svg-term&lt;/a&gt;. The package comes with its own svg-term bundle, no external dependencies are needed.&lt;/li&gt; &#xA; &lt;li&gt;Render a single frame of a cast as an SVG image.&lt;/li&gt; &#xA; &lt;li&gt;Configurable delay at the beginning, at the end and between paragraphs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.htmlwidgets.org&#34;&gt;HTML widget&lt;/a&gt;, to be used in Rmarkdown documents, e.g.&amp;nbsp;in vignettes.&lt;/li&gt; &#xA; &lt;li&gt;Read casts from asciinema JSON files (version 2), or from &lt;a href=&#34;https://asciinema.org&#34;&gt;https://asciinema.org&lt;/a&gt; directly.&lt;/li&gt; &#xA; &lt;li&gt;Special knitr engine to create R markdown files with ascii casts. See the &lt;code&gt;asciicast-demo&lt;/code&gt; vignette.&lt;/li&gt; &#xA; &lt;li&gt;Create ascii casts in GitHub READMEs via animated SVG files. See an example in &lt;code&gt;inst/examples&lt;/code&gt; or the &lt;code&gt;README.Rmd&lt;/code&gt; source of the README file you are reading.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;asciicast works best in an UTF-8 locale. It also works well if all output is ASCII, but non-ASCII output might cause problems (&lt;a href=&#34;https://github.com/r-lib/asciicast/issues/36&#34;&gt;https://github.com/r-lib/asciicast/issues/36&lt;/a&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install the released version of asciicast from &lt;a href=&#34;https://CRAN.R-project.org&#34;&gt;CRAN&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#34;asciicast&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/r-lib/asciicast/tree/main/inst/examples&#34;&gt;&lt;code&gt;inst/examples&lt;/code&gt; directory&lt;/a&gt; for these examples.&lt;/p&gt; &#xA;&lt;h3&gt;Hello world&lt;/h3&gt; &#xA;&lt;p&gt;The input script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;print(&#34;Hello world!&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/r-lib/asciicast/main/man/figures/README-/unnamed-chunk-3.svg?sanitize=true&#34; width=&#34;100%&#34;&gt; &#xA;&lt;h3&gt;Asciicast demo in asciicast&lt;/h3&gt; &#xA;&lt;p&gt;Input script that uses asciicast itself:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#&#39; Title: asciicast example recorded in asciicast&#xA;#&#39; Empty_wait: 3&#xA;#&#39; End_wait: 20&#xA;&#xA;# An example for using asciicast, recorded in asciicast itself!      #!&#xA;&#xA;# First, save the R code you want to run, in a script file.          #!&#xA;# The file can contain any code, including interactive code,         #!&#xA;# as long as it is a syntactically valid R file.                     #!&#xA;&#xA;# Second, perform the recording with the `record()` function.        #!&#xA;# We are recording an example file now, that comes with the package. #!&#xA;&#xA;src &amp;lt;- system.file(&#34;examples&#34;, &#34;hello.R&#34;, package = &#34;asciicast&#34;)&#xA;cast &amp;lt;- asciicast::record(src)&#xA;&#xA;# `cast` is an `asciicast` object, which has some metadata and the   #!&#xA;# recording itself:                                                  #!&#xA;&#xA;cast&#xA;&#xA;# You can write `cast` to a JSON file that can be played by any      #!&#xA;# asciinema player. Or you can write it to an SVG file that can      #!&#xA;# be embedded into a web page, or a GitHub README.                   #!&#xA;&#xA;svg &amp;lt;- tempfile(fileext = &#34;.svg&#34;)&#xA;asciicast::write_svg(cast, svg, window = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/r-lib/asciicast/main/man/figures/README-/unnamed-chunk-5.svg?sanitize=true&#34; width=&#34;100%&#34;&gt; &#xA;&lt;h3&gt;Errors are recorded&lt;/h3&gt; &#xA;&lt;p&gt;Input script with errors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#&#39; End_wait: 20&#xA;# Demonstrate that errors are handled well&#xA;&#xA;# Base R error&#xA;library(&#34;not-this-really&#34;)&#xA;traceback()&#xA;&#xA;# callr errors are saved to `.Last.error`, including a stack trace&#xA;library(cli)&#xA;callr::r(function() library(&#34;another-failure&#34;))&#xA;.Last.error&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/r-lib/asciicast/main/man/figures/README-/unnamed-chunk-7.svg?sanitize=true&#34; width=&#34;100%&#34;&gt; &#xA;&lt;h2&gt;Related tools&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;asciinema: &lt;a href=&#34;https://asciinema.org/&#34;&gt;https://asciinema.org/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The original terminal session recorder: &lt;a href=&#34;https://github.com/asciinema/asciinema&#34;&gt;https://github.com/asciinema/asciinema&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;svg-term: &lt;a href=&#34;https://github.com/marionebl/svg-term&#34;&gt;https://github.com/marionebl/svg-term&lt;/a&gt;, &lt;a href=&#34;https://github.com/marionebl/svg-term-cli&#34;&gt;https://github.com/marionebl/svg-term-cli&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT @ &lt;a href=&#34;https://github.com/rstudio&#34;&gt;RStudio&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>