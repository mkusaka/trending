<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-11T01:43:48Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>JosiahParry/valve</title>
    <updated>2023-07-11T01:43:48Z</updated>
    <id>tag:github.com,2023-07-11:/JosiahParry/valve</id>
    <link href="https://github.com/JosiahParry/valve" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Redirects your plumbing for you.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Valve&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;Redirects your plumbing for you.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;code&gt;valve&lt;/code&gt; creates multi-threaded &lt;a href=&#34;https://www.rplumber.io/&#34;&gt;Plumber APIs&lt;/a&gt; powered by Rust&#39;s &lt;a href=&#34;https://github.com/tokio-rs/tokio&#34;&gt;tokio&lt;/a&gt; and &lt;a href=&#34;https://github.com/tokio-rs/axum&#34;&gt;axum&lt;/a&gt; web frameworks. Plumber connections are automatically spawned, pooled, and terminated using &lt;a href=&#34;https://docs.rs/deadpool/&#34;&gt;deadpool&lt;/a&gt;. App connections are automatically pooled by &lt;a href=&#34;https://docs.rs/hyper/latest/hyper/client/index.html&#34;&gt;hyper&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Valve is a Rust CLI with an accompanying R package. Running Valve from an R session will block the session. If you are comfortable, it is recommended to install the cli so you can run Valve from your terminal so that you can call the plumber APIs from your R session.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Plumber is an R package that creates RESTful APIs from R functions. It is limited in that each API is a single R process and thus a single thread. Multiple queries are executed in the sequence that they came in. Scaling plumber APIs is not easy. The intention of valve is to be able to make scaling plumber APIs, and thus R itself, easier. We can make R better by leveraging Rust&#39;s &lt;a href=&#34;https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html&#34;&gt;&#34;fearless concurrency.&#34;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Cli Instructions&lt;/h3&gt; &#xA;&lt;p&gt;To install the executable only run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo install valve-rs --no-default-features&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;R package instructions&lt;/h3&gt; &#xA;&lt;p&gt;There is an R package to simplify the use of Valve for those who are not familiar with Rust or CLI tools. It is available as a binary for Windows, Linux, and MacOSX thanks to &lt;a href=&#34;https://r-universe.dev/&#34;&gt;R-universe&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#34;valve&#34;, repos = c(&#34;https://josiahparry.r-universe.dev&#34;, &#34;https://cloud.r-project.org&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When the R package is built it also includes the binary executable at &lt;code&gt;inst/valve&lt;/code&gt;. So if you ever find yourself needing the executable &lt;code&gt;system.file(&#34;valve&#34;, package = &#34;valve&#34;)&lt;/code&gt; will point you right to it! This will always be the version of the executable that your R package is using.&lt;/p&gt; &#xA;&lt;p&gt;You can verify the binary works for your machine by running the below. If you have a Windows machine include &lt;code&gt;system.file(&#34;valve.exe&#34;, package = &#34;valve&#34;)&lt;/code&gt; for the executable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# get executable path and included api paths&#xA;valve_executable &amp;lt;- system.file(&#34;valve&#34;, package = &#34;valve&#34;)&#xA;plumber_api_path &amp;lt;- system.file(&#34;plumber.R&#34;, package = &#34;valve&#34;)&#xA;&#xA;# check that they exist&#xA;file.exists(c(valve_executable, plumber_api_path))&#xA;&#xA;# run Valve from the R-package&#39;s executable&#xA;processx::run(&#xA;  valve_executable,&#xA;  args = c(&#34;-f&#34;, plumber_api_path),&#xA;  echo = TRUE&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Creating a Valve app&lt;/h2&gt; &#xA;&lt;p&gt;To run a plumber API concurrently using the R package, use &lt;code&gt;valve_run()&lt;/code&gt;. The most important argument is &lt;code&gt;filepath&lt;/code&gt; which determines which Plumber API will be executed as well as specifying the &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; to determine &lt;em&gt;where&lt;/em&gt; your app will run. Additional configuration can be done with the &lt;code&gt;n_max&lt;/code&gt;, &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;check_unused&lt;/code&gt;, and &lt;code&gt;max_age&lt;/code&gt; argument to specify &lt;em&gt;how&lt;/em&gt; your app will scale. By default, the app will be run on host &lt;code&gt;127.0.0.1&lt;/code&gt; and on port &lt;code&gt;3000&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(valve)&#xA;# get included plumber API path&#xA;plumber_api_path &amp;lt;- system.file(&#34;plumber.R&#34;, package = &#34;valve&#34;)&#xA;&#xA;valve_run(plumber_api_path, n_max = 5)&#xA;#&amp;gt; Docs hosted at &amp;lt;http://127.0.0.1:3000/__docs__/&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using the cli:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;valve -f plumber.R -n 5 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Understanding the parameters:&lt;/h3&gt; &#xA;&lt;p&gt;The arguments that you provide determines how Valve will scale up and down the application is requests come in.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;host&lt;/code&gt; (&lt;code&gt;--host&lt;/code&gt;): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;defaults to &lt;code&gt;127.0.0.1&lt;/code&gt;. Defines which host the Axum app and the plumber API will be hosted on.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;port&lt;/code&gt; (&lt;code&gt;--port&lt;/code&gt;): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;defaults to &lt;code&gt;3000&lt;/code&gt;. Defines which port the main Axum app will be listening on.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;file&lt;/code&gt; (&lt;code&gt;--file&lt;/code&gt;): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;defaults to &lt;code&gt;plumber.R&lt;/code&gt;. The path to the R script that defines the plumber API.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;workers&lt;/code&gt; (&lt;code&gt;--workers&lt;/code&gt;): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;default &lt;code&gt;3&lt;/code&gt;. Determines how many workers are set in the &lt;a href=&#34;https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html#method.worker_threads&#34;&gt;Tokio &lt;code&gt;Runtime&lt;/code&gt;&lt;/a&gt;. These workers handle incoming requests and return responses.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;n_max&lt;/code&gt; (&lt;code&gt;--n-max&lt;/code&gt;): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;default &lt;code&gt;3&lt;/code&gt;. Refers to the maximum number of background Plumber APIs that can be spawned whereas &lt;code&gt;workers&lt;/code&gt; specifies how many main worker threads are available to handle incoming requests. Generally, the number of &lt;code&gt;workers&lt;/code&gt; should be equal to the number of plumber APIs since because plumber is single threaded. This is the default. If &lt;code&gt;workers&lt;/code&gt; is less than &lt;code&gt;n_max&lt;/code&gt;, you&#39;ll never spawn the maximum number of APIs.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;check_unused&lt;/code&gt; (&lt;code&gt;--check-unused&lt;/code&gt;): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;default &lt;code&gt;10&lt;/code&gt;. The time interval, in seconds, to check for unused connections.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max_age&lt;/code&gt; (&lt;code&gt;--max-age&lt;/code&gt;): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;default &lt;code&gt;300&lt;/code&gt; (five minutes). Specifies how long a connection can go unused without being terminated. If a connection reaches this age it will be terminated in the next pool check (interval determined by check_unused),&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!--&#xA;## How it all works&#xA;&#xA;By default, valve creates an app hosted at  `127.0.0.1:3000`. &#xA;It looks for a file called `plumber.R` in the working directory. &#xA;&#xA;The app that is spun up has 3 Axum workers (`workers`) which handle the incoming requests. &#xA;The app also will create a pool of `n-max` plumber APIs which too is set to 3. &#xA;The number of workers and the maximum number of plumber APIs should, generally,&#xA;be the same. If there are more workers than API connections, then there will be &#xA;a worker waiting for a plumber API connection to free up before it can be used. &#xA;--&gt; &#xA;&lt;h2&gt;Example: Calling valve with multiple workers&lt;/h2&gt; &#xA;&lt;p&gt;The way valve works is by accepting requests on a main port (3000 by default) and then distributing the requests round robin to the plumber APIs that are spawned on random ports. Requests are captured by &lt;code&gt;axum&lt;/code&gt; and proxied to a plumber API process.&lt;/p&gt; &#xA;&lt;p&gt;You can run the example plumber API included with Valve in the background in R using this code chunk:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# create temp file&#xA;tmp &amp;lt;- tempfile(fileext = &#34;.R&#34;)&#xA;&#xA;# create script lines&#xA;valve_script &amp;lt;- &#39;&#xA;plumber_api_path &amp;lt;- system.file(&#34;plumber.R&#34;, package = &#34;valve&#34;)&#xA;valve::valve_run(plumber_api_path, workers = 5)&#xA;&#39;&#xA;# write to temp&#xA;writeLines(valve_script, tmp)&#xA;&#xA;# run in the background&#xA;rstudioapi::jobRunScript(tmp)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or launch it directly from the terminal via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;valve -f $(Rscript -e &#39;cat(system.file(&#34;plumber.R&#34;, package = &#34;valve&#34;))&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the Valve app is running in the background we can begin the example. First I&#39;m going to define a function to call the &lt;code&gt;/sleep&lt;/code&gt; endpoint. The function will take two parameters: the port and the duration of sleep. The port will be used to change between the valve app and a single plumber API.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sleep &amp;lt;- function(port, secs) {&#xA;  httr2::request(&#xA;        paste0(&#34;127.0.0.1:&#34;, port, &#34;/sleep?zzz=&#34;, secs)&#xA;    ) |&amp;gt; &#xA;    httr2::req_perform() |&amp;gt; &#xA;    httr2::resp_body_string()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using this function we&#39;ll create 5 total R sessions each will make a request to sleep for 2 seconds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(furrr)&#xA;plan(multisession, workers = 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;First, we&#39;ll ping the main valve app which will distribute requests. The first time this is ran might be slow since there will not be any plumber APIs in the pool yet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;start &amp;lt;- Sys.time()&#xA;multi_sleep &amp;lt;- future_map(1:5, ~ sleep(3000, 2))&#xA;multi_total &amp;lt;- Sys.time() - start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, we select only one of the available plumber APIs and query it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;start &amp;lt;- Sys.time()&#xA;single_sleep &amp;lt;- furrr::future_map(1:5, ~ sleep(53869, 2))&#xA;single_total &amp;lt;- Sys.time() - start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice the performance difference.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;print(paste0(&#34;Multiple Plumber APIs: &#34;, round(multi_total, 2)))&#xA;#&amp;gt; [1] &#34;Multiple Plumber APIs: 2.63&#34;&#xA;print(paste0(&#34;One Plumber API: &#34;, round(single_total, 2)))&#xA;#&amp;gt; [1] &#34;One Plumber API: 10.08&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the former each worker gets to make the request in approximately the same amount of time. The latter has to wait for each subsequent step to finish before the next one can occur. So we&#39;ve effectively distributed the work load.&lt;/p&gt; &#xA;&lt;h2&gt;How Valve Works&lt;/h2&gt; &#xA;&lt;p&gt;The architecture, at a high level, is captured by this diagram.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/JosiahParry/valve/main/man/figures/valve-diagram.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are really three key components to this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the Tokio &lt;code&gt;Runtime&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;the Axum &lt;code&gt;Router&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;and the connection &lt;code&gt;Pool&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Request handling&lt;/h3&gt; &#xA;&lt;p&gt;The tokio &lt;a href=&#34;https://docs.rs/tokio/latest/tokio/runtime/struct.Runtime.html&#34;&gt;&lt;code&gt;Runtime&lt;/code&gt;&lt;/a&gt; is what allows Valve to be asynchronous. It handles I/O, tasks, and all that jazz. It is also what backs &lt;code&gt;Axum&lt;/code&gt;. In Valve, we &lt;a href=&#34;https://github.com/JosiahParry/valve/raw/aeebc19e868d39014419129fa07da42cc9113ee7/src/rust/src/lib.rs#L23&#34;&gt;define an asynchronous runtime&lt;/a&gt; with a pre-defined number of &lt;code&gt;workers&lt;/code&gt;. These workers are what handle the incoming requests.&lt;/p&gt; &#xA;&lt;p&gt;When a request is picked up, it is then sent to the Axum &lt;a href=&#34;https://docs.rs/axum/latest/axum/struct.Router.html&#34;&gt;&lt;code&gt;Router&lt;/code&gt;&lt;/a&gt;. The router takes the incoming requests and sends them to the appropriate endpoint.&lt;/p&gt; &#xA;&lt;p&gt;The routes that are defined are &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;/*key&lt;/code&gt;. &lt;code&gt;/&lt;/code&gt; is a permanent redirect to the plumber API documentation. Whereas &lt;code&gt;/*key&lt;/code&gt; captures every other request. These requests have a special handler that, in short, act as a reverse proxy between Axum and a plumber API. The handler captures the request and grabs a Plumber connection from the &lt;a href=&#34;https://docs.rs/deadpool/latest/deadpool/managed/struct.Pool.html&#34;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&#34;https://github.com/JosiahParry/valve/raw/aeebc19e868d39014419129fa07da42cc9113ee7/src/rust/src/plumber.rs#L24&#34;&gt;Plumber struct&lt;/a&gt; contains the host and port that the APIs live on. The request is then parsed, and redirected to the plumber API. The &lt;a href=&#34;https://github.com/JosiahParry/valve/raw/aeebc19e868d39014419129fa07da42cc9113ee7/src/rust/src/plumber.rs#L74&#34;&gt;response is captured and returned as a response&lt;/a&gt; to the Axum router.&lt;/p&gt; &#xA;&lt;h3&gt;Connection pooling&lt;/h3&gt; &#xA;&lt;p&gt;Valve implements a custom &lt;a href=&#34;https://docs.rs/deadpool/latest/deadpool/managed/index.html&#34;&gt;managed&lt;/a&gt; Pool for plumber APIs. The pool consists of &lt;code&gt;Plumber&lt;/code&gt; struct which contain the host, port, and the &lt;a href=&#34;https://doc.rust-lang.org/std/process/struct.Child.html&#34;&gt;child process&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When Deadpool spawns a new connection for the pool, it thus spawns a new plumber API. This is done using &lt;a href=&#34;https://doc.rust-lang.org/std/process/struct.Command.html&#34;&gt;&lt;code&gt;Command::new()&lt;/code&gt;&lt;/a&gt; to create a detached child process. A random port is generated, checked, and then assigned to the plumber API. Then the process is started by calling &lt;code&gt;R -e &#34;plumber::plumb(&#39;{filepath}&#39;)$run(host = &#39;{host}&#39;, port = {port})&#34;&lt;/code&gt; via &lt;code&gt;Command&lt;/code&gt;. This means that &lt;em&gt;R must be on the path&lt;/em&gt; and that if there are multiple installs of R, whichever one is on the path will be used.&lt;/p&gt; &#xA;&lt;p&gt;To prevent plumber APIs being spawned too frequently they are kept alive for duration defined by &lt;code&gt;max_age&lt;/code&gt;. A connection can be unused for that duration. If it exceeds that age without being used, Deadpool will prune the connection and terminate the process. This check happens on a &lt;a href=&#34;https://github.com/JosiahParry/valve/raw/aeebc19e868d39014419129fa07da42cc9113ee7/src/rust/src/start.rs#L56C4-L56C4&#34;&gt;separate thread&lt;/a&gt; occurring every &lt;code&gt;check_unused&lt;/code&gt; seconds.&lt;/p&gt; &#xA;&lt;h2&gt;Benchmarks with drill&lt;/h2&gt; &#xA;&lt;p&gt;Simple benchmarks using drill can be found in &lt;code&gt;inst/bench-sleep-plumber.yml&lt;/code&gt; and &lt;code&gt;bench-sleep-valve.yml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The bench mark calls the &lt;code&gt;/sleep&lt;/code&gt; endpoint and sleeps for 500ms for 100 times with 5 concurrent threads. This alone can illustrate how much we can speed up a single plumber API&#39;s response time with valve.&lt;/p&gt; &#xA;&lt;p&gt;Plumber&#39;s benchmark:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Time taken for tests      50.7 seconds&#xA;Total requests            100&#xA;Successful requests       100&#xA;Failed requests           0&#xA;Requests per second       1.97 [#/sec]&#xA;Median time per request   2540ms&#xA;Average time per request  2482ms&#xA;Sample standard deviation 272ms&#xA;99.0&#39;th percentile        2556ms&#xA;99.5&#39;th percentile        2556ms&#xA;99.9&#39;th percentile        2556ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Valve&#39;s benchmark:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Time taken for tests      10.2 seconds&#xA;Total requests            100&#xA;Successful requests       100&#xA;Failed requests           0&#xA;Requests per second       9.78 [#/sec]&#xA;Median time per request   510ms&#xA;Average time per request  510ms&#xA;Sample standard deviation 2ms&#xA;99.0&#39;th percentile        516ms&#xA;99.5&#39;th percentile        518ms&#xA;99.9&#39;th percentile        518ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;With all that said....&lt;/h3&gt; &#xA;&lt;p&gt;valve is best suited for light to medium sized work loads. Each background plumber API will hold their own copy of their R objects. So if you are serving a machine learning model that is a GB big, that model will have to be copied into each thread and that can be quickly bloat up your ram. So be smart! If you have massive objects in your R session, try and reduce the clutter and thin it out.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tylermorganwall/tree3d</title>
    <updated>2023-07-11T01:43:48Z</updated>
    <id>tag:github.com,2023-07-11:/tylermorganwall/tree3d</id>
    <link href="https://github.com/tylermorganwall/tree3d" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/tylermorganwall/tree3d/actions/workflows/R-CMD-check.yaml&#34;&gt;&lt;img src=&#34;https://github.com/tylermorganwall/tree3d/actions/workflows/R-CMD-check.yaml/badge.svg?sanitize=true&#34; alt=&#34;R-CMD-check&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;h1&gt;tree3d: 3D Tree Models &lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/tree3d/main/man/figures/tree3d_hexlogo_small.png&#34; align=&#34;right&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;tree3d&lt;/code&gt; is an R package that provides highly customizable 3D tree models for data visualization and 3D scene creation. &lt;code&gt;tree3d&lt;/code&gt; allows you to generate tree models as OBJ files, which can then easily be integrated into your data visualization, animation, or 3D rendering workflows.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Variety of tree models&lt;/strong&gt;: Includes both planar and solid tree models.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Multiple crown types&lt;/strong&gt;: Provides a wide range of crown types, including: columnar, oval, palm, pyramidal, rounded, spreading, vase, and weeping. Each type offers a unique visual aesthetic to represent different types of trees.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Customizable dimensions and color&lt;/strong&gt;: Allows you to adjust the diameter, height, and color of both the tree’s crown and trunk individually. This flexibility allows you to customize the tree model for your specific use case.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;tree3d&lt;/code&gt; can currently be installed from Github.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#34;remotes&#34;)&#xA;remotes::install_github(&#34;tylermorganwall/tree3d&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Let’s load the sandbox data included in the Github repository. We will then unzip the file, and then load the shapefiles into R using {sf}.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(tree3d)&#xA;library(sf)&#xA;#&amp;gt; Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE&#xA;library(terra)&#xA;#&amp;gt; terra 1.7.18&#xA;library(rayshader)&#xA;&#xA;# Download the sample data&#xA;temp_download = tempfile(fileext = &#34;.zip&#34;)&#xA;download.file(&#34;https://github.com/tylermorganwall/tree3d/raw/main/inst/extdata/tree3d_sandbox_data.zip&#34;, temp_download)&#xA;&#xA;# Unzip and get directory&#xA;unzip(temp_download, exdir = tempdir())&#xA;zipdir = paste0(tempdir(), .Platform$file.sep, &#xA;                &#34;sandbox_data&#34;, .Platform$file.sep)&#xA;&#xA;# Load all files&#xA;poly_boundary = sf::st_read(paste0(zipdir, &#34;Area_Boundary_subset.shp&#34;), quiet = TRUE)&#xA;baseline_tree = sf::st_read(paste0(zipdir, &#34;Baseline_Trees_Z_clip.shp&#34;), quiet = TRUE)&#xA;building_baseline = sf::st_read(paste0(zipdir, &#34;Buildings_Baseline_2020_Z_clip.shp&#34;), quiet = TRUE)&#xA;parcels = sf::st_read(paste0(zipdir, &#34;Parcels_2020_clip.shp&#34;), quiet = TRUE)&#xA;&#xA;dem = terra::rast(paste0(zipdir, &#34;DEM_2013_subset_zero.tif&#34;))&#xA;&#xA;# Inspect the tree data&#xA;head(baseline_tree)&#xA;#&amp;gt; Simple feature collection with 6 features and 8 fields&#xA;#&amp;gt; Geometry type: POINT&#xA;#&amp;gt; Dimension:     XYZ&#xA;#&amp;gt; Bounding box:  xmin: 493801.7 ymin: 5452079 xmax: 493951.7 ymax: 5452181&#xA;#&amp;gt; z_range:       zmin: 7.19 zmax: 16.25&#xA;#&amp;gt; Projected CRS: NAD83 / UTM zone 10N&#xA;#&amp;gt;             Species Height      Type Location MatureSize Diameter  CrownType&#xA;#&amp;gt; 1 Prunus cerasifera   7.19 Deciduous   Street      Small      4.6 spreading1&#xA;#&amp;gt; 2  Acer x freemanii  16.25 Deciduous   Street      Large     12.1       oval&#xA;#&amp;gt; 3  Acer x freemanii  16.22 Deciduous   Street      Large      7.5       oval&#xA;#&amp;gt; 4    Fraxinus ornus   8.09 Deciduous   Street     Medium      4.1       oval&#xA;#&amp;gt; 5  Parrotia persica   9.20 Deciduous   Street     Medium      4.1 spreading1&#xA;#&amp;gt; 6       Sorbus aria   9.67 Deciduous   Street     Medium      5.3       oval&#xA;#&amp;gt;   Color                       geometry&#xA;#&amp;gt; 1  &amp;lt;NA&amp;gt; POINT Z (493937.4 5452179 7...&#xA;#&amp;gt; 2  &amp;lt;NA&amp;gt; POINT Z (493951.7 5452079 1...&#xA;#&amp;gt; 3  &amp;lt;NA&amp;gt; POINT Z (493831.7 5452181 1...&#xA;#&amp;gt; 4  &amp;lt;NA&amp;gt; POINT Z (493801.7 5452167 8...&#xA;#&amp;gt; 5  &amp;lt;NA&amp;gt; POINT Z (493845.4 5452181 9.2)&#xA;#&amp;gt; 6  &amp;lt;NA&amp;gt; POINT Z (493898.5 5452165 9...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that our data is loaded, let’s generate a 3D map with rayshader. We will load in our&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#Use rayshader to convert the DEM to a matrix and generate a 3D mesh&#xA;dem_mat = raster_to_matrix(dem)&#xA;dem_mat |&amp;gt;&#xA;  constant_shade(&#34;#6dbd83&#34;) |&amp;gt;&#xA;  add_overlay(generate_polygon_overlay(poly_boundary, extent = ext(dem),&#xA;                                       heightmap = dem_mat,&#xA;                                       palette = &#34;#bcebc9&#34;)) |&amp;gt;&#xA;  add_overlay(generate_polygon_overlay(parcels, extent = ext(dem),&#xA;                                       heightmap = dem_mat,&#xA;                                       palette = &#34;#afe0bd&#34;)) |&amp;gt;&#xA;  plot_3d(dem_mat, background = &#34;lightblue&#34;, windowsize = 800)&#xA;&#xA;#Render the buildings as extruded polygons&#xA;render_polygons(building_baseline, &#xA;                extent = ext(dem), &#xA;                data_column_top = &#34;height_ag&#34;, &#xA;                clear_previous = TRUE, &#xA;                color = &#34;white&#34;, &#xA;                heightmap = dem_mat)&#xA;render_camera(theta = 44, phi = 36, zoom = 0.7, fov = 50, shift_vertical = -30)&#xA;render_snapshot()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/tree3d/main/man/figures/README-unnamed-chunk-4-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;p&gt;Now that we have our 3D map generated, let’s add our custom trees using rayshader’s &lt;code&gt;render_trees()&lt;/code&gt; function. &lt;code&gt;tree3d&lt;/code&gt; provides &lt;code&gt;get_crown_file()&lt;/code&gt; and &lt;code&gt;get_trunk_file()&lt;/code&gt;, which allows access to the separate 3D models included in the package. Passing in each model separately gives you full control over the size, shape, and colors of the trees.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Render the trees, using data from `baseline_tree` to draw each tree individually&#xA;for(i in seq_len(nrow(baseline_tree))) {&#xA;  single_tree_info = baseline_tree[i,]&#xA;  tree_defaults = get_tree_data(single_tree_info$CrownType)&#xA;  latlongheight = as.matrix(st_geometry(single_tree_info)[[1]])&#xA;  render_tree(long = latlongheight[1], lat = latlongheight[2], &#xA;              extent = ext(dem), heightmap = dem_mat, &#xA;              tree_height = single_tree_info$Height,&#xA;              crown_width = single_tree_info$Diameter,&#xA;              trunk_height_ratio = tree_defaults$trunk_crown_ratio,&#xA;              custom_obj_crown = get_crown_file(tree = single_tree_info$CrownType),&#xA;              custom_obj_trunk = get_trunk_file())&#xA;}&#xA;render_camera(40, 23,  0.25, 90)&#xA;render_snapshot()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/tree3d/main/man/figures/README-unnamed-chunk-5-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;p&gt;We can also generate high quality renders with our trees using rayshader:. Here, we use the solid models.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;render_tree(clear_previous = TRUE)&#xA;for(i in seq_len(nrow(baseline_tree))) {&#xA;  single_tree_info = baseline_tree[i,]&#xA;  tree_defaults = get_tree_data(single_tree_info$CrownType)&#xA;  latlongheight = as.matrix(st_geometry(single_tree_info)[[1]])&#xA;  render_tree(long = latlongheight[1], lat = latlongheight[2], &#xA;              extent = ext(dem), heightmap = dem_mat, &#xA;              tree_height = single_tree_info$Height,&#xA;              crown_width = single_tree_info$Diameter,&#xA;              trunk_height_ratio = tree_defaults$trunk_crown_ratio,&#xA;              custom_obj_crown = get_crown_file(tree = single_tree_info$CrownType,&#xA;                                                solid = TRUE),&#xA;              custom_obj_trunk = get_trunk_file())&#xA;}&#xA;render_camera(40, 23,  0.10, 90)&#xA;render_snapshot()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/tree3d/main/man/figures/README-hq-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;render_highquality(min_variance = 0,&#xA;                   sample_method = &#34;sobol&#34;,&#xA;                   samples = 2048, &#xA;                   lightaltitude = 30,&#xA;                   lightdirection = 45)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/tree3d/main/man/figures/README-hq-2.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;p&gt;We can also extract 3D tree information from lidar data using the lidR package and use that data to generate 3D trees. Here, we’ll use random trees from the package to fill in our scene.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(lidR)&#xA;library(sf)&#xA;library(terra)&#xA;&#xA;#We will use the lidR package to generate a DEM and detect the crown tops of trees, and&#xA;#then use rayshader to render 3D tree models scaled to those heights on the map.&#xA;#Load the example data from the lidR package&#xA;LASfile = system.file(&#34;extdata&#34;, &#34;Topography.laz&#34;, package=&#34;lidR&#34;)&#xA;las = lidR::readLAS(LASfile, filter = &#34;-inside 273450 5274350 273550 5274450&#34;)&#xA;&#xA;#Convert the lidar point data to a DEM and detect the location of trees from the same data&#xA;dem = lidR::rasterize_terrain(las, algorithm = lidR::tin())&#xA;tree_top_data = lidR::locate_trees(las, lidR::lmf(ws = 5))&#xA;tree_locations = sf::st_coordinates(tree_top_data)&#xA;&#xA;#Convert DEM to a matrix and extract the extent of the scene&#xA;dem_matrix = raster_to_matrix(dem)&#xA;dem_extent = terra::ext(dem)&#xA;extent_values = dem_extent@ptr$vector&#xA;&#xA;#Plot the ground&#xA;dem_matrix |&amp;gt;&#xA;  height_shade() |&amp;gt;&#xA;  add_shadow(texture_shade(dem_matrix),0.2) |&amp;gt;&#xA;  add_shadow(lamb_shade(dem_matrix),0) |&amp;gt;&#xA;  plot_3d(dem_matrix, windowsize = 800, zscale = 2)&#xA;render_snapshot()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/tree3d/main/man/figures/README-lidar-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;&#xA;#Get tree data&#xA;tree_df = tree3d::get_tree_data()&#xA;tree_df&#xA;#&amp;gt;          name solid_available trunk_color tree_color trunk_crown_ratio&#xA;#&amp;gt; 1    columnar            TRUE     #8C6F5B    #A2C683         0.3333333&#xA;#&amp;gt; 2  pyramidal1            TRUE     #8C6F5B    #066038         0.1666667&#xA;#&amp;gt; 3  pyramidal2            TRUE     #8C6F5B    #447765         0.1666667&#xA;#&amp;gt; 4        oval            TRUE     #8C6F5B    #CBD362         0.3333333&#xA;#&amp;gt; 5        palm           FALSE     #8C6F5B    #CCB471         0.5000000&#xA;#&amp;gt; 6     rounded           FALSE     #8C6F5B    #7CB262         0.3333333&#xA;#&amp;gt; 7  spreading1            TRUE     #8C6F5B    #DB8952         0.3333333&#xA;#&amp;gt; 8  spreading2           FALSE     #8C6F5B    #E0A854         0.3333333&#xA;#&amp;gt; 9        vase           FALSE     #8C6F5B    #75C165         0.3333333&#xA;#&amp;gt; 10    weeping            TRUE     #8C6F5B    #AECCB1         0.3333333&#xA;&#xA;set.seed(1)&#xA;random_trees = tree_df[sample(1:10, nrow(tree_locations), replace=TRUE),]&#xA;random_trees$solid_available = ifelse(random_trees$solid_available, &#xA;                                      sample(c(TRUE,FALSE),1),&#xA;                                      FALSE)&#xA;head(random_trees)&#xA;#&amp;gt;           name solid_available trunk_color tree_color trunk_crown_ratio&#xA;#&amp;gt; 9         vase           FALSE     #8C6F5B    #75C165         0.3333333&#xA;#&amp;gt; 4         oval            TRUE     #8C6F5B    #CBD362         0.3333333&#xA;#&amp;gt; 7   spreading1            TRUE     #8C6F5B    #DB8952         0.3333333&#xA;#&amp;gt; 1     columnar            TRUE     #8C6F5B    #A2C683         0.3333333&#xA;#&amp;gt; 2   pyramidal1            TRUE     #8C6F5B    #066038         0.1666667&#xA;#&amp;gt; 7.1 spreading1            TRUE     #8C6F5B    #DB8952         0.3333333&#xA;&#xA;render_camera(theta=45,phi=30,zoom=0.3,fov=90, shift_vertical = -10)&#xA;for(i in seq_len(nrow(tree_locations))) {&#xA;  trunk_ratio_single = tree_df$trunk_crown_ratio[which(tree_df$name == random_trees[i,1])]&#xA;  render_tree(lat = tree_locations[i,2], long = tree_locations[i,1],&#xA;              custom_obj_crown = get_crown_file(random_trees[i,1], resolution = &#34;high&#34;,&#xA;                                                solid = random_trees[i,2]),&#xA;              custom_obj_trunk = get_trunk_file(),&#xA;              absolute_height = TRUE, &#xA;              tree_height = tree_locations[i,3],&#xA;              trunk_height_ratio = trunk_ratio_single,&#xA;              crown_width_ratio = 0.75 + 0.25 * runif(1),&#xA;              crown_color = random_trees[i,4],&#xA;              angle = c(0,360*runif(1),0),&#xA;              extent = dem, &#xA;              zscale = 2, &#xA;              heightmap = dem_matrix)&#xA;}&#xA;render_snapshot()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/tylermorganwall/tree3d/main/man/figures/README-lidar-2.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;We would like to acknowledge the following people/organizations for their contributions to the package:&lt;/p&gt; &#xA;&lt;p&gt;elementslab (in the University of British Columbia) for supporting the development of the 3D tree models&lt;/p&gt;</summary>
  </entry>
</feed>