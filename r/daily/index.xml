<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-28T01:37:02Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>msfidelis/analise-identificao-urnas-eletronicas</title>
    <updated>2022-11-28T01:37:02Z</updated>
    <id>tag:github.com,2022-11-28:/msfidelis/analise-identificao-urnas-eletronicas</id>
    <link href="https://github.com/msfidelis/analise-identificao-urnas-eletronicas" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Sumário&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#introdu%C3%A7%C3%A3o&#34;&gt;Introdução&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#importante&#34;&gt;IMPORTANTE&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#objetivo&#34;&gt;Objetivo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#dados-utilizados&#34;&gt;Dados utilizados&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#problema-apresentado-no-relat%C3%B3rio&#34;&gt;Problema apresentado no relatório&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#encontrando-o-problema-apresentado-nas-fontes-de-dados&#34;&gt;Encontrando o problema apresentado nas fontes de dados&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#importando-os-dados&#34;&gt;Importando os Dados para Análise&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#gerando-uma-tabela-de-frequencias-dos-identificadores-iniciais&#34;&gt;Gerando uma tabela de frequências dos Identificadores Iniciais&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#simula%C3%A7%C3%A3o-de-auditoria-de-dados&#34;&gt;Simulação e Auditoria de Dados&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#data-minning-e-enriquecimento-dos-dataframes&#34;&gt;Data Minning e Enriquecimento dos Dataframes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#hashing-de-identifica%C3%A7%C3%A3o-de-urnas-atrav%C3%A9s-da-metadados-categ%C3%B3ricos&#34;&gt;Hashing de Identificação de Urnas através da metadados categóricos&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#compara%C3%A7%C3%A3o-da-auditoria-via-id-e-auditoria-via-hashing-de-urnas&#34;&gt;Comparação da Auditoria via ID e Auditoria via Hashing de urnas&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#compara%C3%A7%C3%A3o-da-auditoria-via-id-e-auditoria-via-hashing-dos-modelos-apontados-como-problem%C3%A1ticos&#34;&gt;Comparação da Auditoria via ID e Auditoria via Hashing dos modelos apontados como “problemáticos”&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#gamedays-de-auditoria---sempre-em-constru%C3%A7%C3%A3o&#34;&gt;Game Days de Auditoria&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#correla%C3%A7%C3%A3o-entre-urna-identificada-vs-boletim-de-urna&#34;&gt;Correlação entre Urna Identificada vs Boletim de Urna&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#me-diga-qual-urna-estava-na-se%C3%A7%C3%A3o-x-do-local-y-da-zona-z&#34;&gt;Me diga qual, urna estava na seção X do local Y da zona Z?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/#me-d%C3%AA-somente-os-logs-de-uma-determinada-urna&#34;&gt;Me dê somente os logs de determinada urna&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Conclusão&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Introdução&lt;/h1&gt; &#xA;&lt;p&gt;A partir das constantes ações do &lt;strong&gt;Partido Liberal (PL)&lt;/strong&gt;, liderado atualmente por &lt;strong&gt;Valdemar da Costa Neto&lt;/strong&gt;, para desqualificar o processo eleitoral e descredibilizar as instituições, afim de garantir mais um mandato para seu candidato &lt;strong&gt;Jair Messias Bolsonaro&lt;/strong&gt; por meios não democráticos, foram apresentados uma série de relatórios e discursos, afim de alegar a &lt;strong&gt;total impossibilidade&lt;/strong&gt; de auditoria das urnas cujos modelos são anteriores a 2020.&lt;/p&gt; &#xA;&lt;p&gt;Será apresentado uma prova de conceito afim de criar um hash único de trabalho das urnas para identificá-las e diferenciá-las nas análises de logs para auditoria unitária ou em massa, e também correlacionar as mesmas em outros datasets e boletins públicos.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;IMPORTANTE&lt;/h2&gt; &#xA;&lt;p&gt;Essa análise, proposta de auditoria e identificação de urnas, é feita inicialmente por um civil, por vontade própria, livre que qualquer financiamento de qualquer grupo ou partido político. Afim de estabelecer modelos técnicos para auditoria de dados e resultados eleitorais de forma otimizada e segura.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Objetivo&lt;/h1&gt; &#xA;&lt;p&gt;O Objetivo desta análise é exemplificar que é possível, sim, auditar todos os modelos de urnas eletrônicas sem a necessidade da identificação da mesma via log.&lt;/p&gt; &#xA;&lt;p&gt;Serão apresentadas técnicas e ferramentas de mercado, ferramentas de análise estatística e ciência de dados com exemplos práticos e com todos os scripts de análise e datasets públicos e abertos.&lt;/p&gt; &#xA;&lt;p&gt;Tanto quanto os dados, todas as ferramentas utilizadas são Open Source e estão disponíveis para todos acessarem e utilizarem de forma livre.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Problema apresentado no relatório&lt;/h1&gt; &#xA;&lt;p&gt;Esta prova de conceito foi construída com base no relatório preliminar emitido pelo PL no dia 15/11/2022 e no relatório consolidado emitido dia 22/11/2022.&lt;/p&gt; &#xA;&lt;p&gt;Ambos o relatórios apresentam pontos de auditoria referentes aos modelos anteriores ao UE2022, contestando a falta de possibilidade de auditar e correlacionar dados.&lt;/p&gt; &#xA;&lt;p&gt;&#34;Arquivo digital Log de Urna: um prontuário digital que requer a autenticação em cada linha de registro de atividade&#34;&lt;/p&gt; &#xA;&lt;p&gt;&#34;Cada urna eletrônica gera o seu respectivo arquivo digital LOG cuja razão fundamental de existir é registrar, como num prontuário médico, em cada linha do arquivo, uma atividade realizada pela urna, naquele dado instante. Cada linha do LOG inclui duas informações essenciais e necessárias, para validação do registro, lidas diretamente do hardware:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;carimbo de tempo, composto por data e hora:minuto:segundo, lidos do relógio do equipamento&lt;/li&gt; &#xA; &lt;li&gt;código de identificação da urna eletrônica, lido da memória permanente e indelével (ROM) do equipamento&#34;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;O objetivo do relatório claramente não é gerar uma investigação para que o Tribunal Superior Eleitoral (TSE) possa responder tecnicamente, e apresentar alternativas para a possibilidade de auditoria e correlação através de fallbacks sistêmicos. Pois, no próprio documento preliminar, é clara a intenção do Partido Liberal (PL) de invalidar os votos dos cidadãos que exerceram seu papel democrático de escolha de representantes públicos, afim de eleger o eventual candidato de seu partido, Jair Messias Bolsonaro.&lt;/p&gt; &#xA;&lt;p&gt;&#34;A partir disso, conclui que &#34;os votos válidos e auditáveis do segundo turno&#34; atestariam resultado diferente e dariam 51,05% dos votos a Bolsonaro. O documento indica que as urnas 2020 seriam as únicas que teriam &#34;elementos de auditoria válida e que atestam a autenticidade do resultado eleitoral com a certeza necessária – na concepção do próprio Tribunal Superior Eleitoral&#34;&lt;/p&gt; &#xA;&lt;p&gt;&#34;Nesta perspectiva técnica, não é possível validar os resultados gerados em todas as urnas eletrônicas de modelos 2009, 2010, 2011, 2013 e 2015, resultados estes que deveriam ser desconsiderados na totalização das eleições no segundo turno, em função do mau funcionamento destas urnas.&lt;/p&gt; &#xA;&lt;p&gt;Nada mais havendo a considerar damos por encerrado este relatório&#34;&lt;/p&gt; &#xA;&lt;h3&gt;Referências&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cdn.oantagonista.com/uploads/2022/11/PL-Relatorio-Tecnico-Logs-Invalidos-das-Urnas-Eletronicas-v0.7-15-11-2022.pdf&#34;&gt;Relatório Técnico Preliminar - Logs Inválidos das Urnas Eletrônicas - Fiscalização das Eleições de 2022 no TSE - por Partido Liberal (PL) - 15/11/2022&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cdn.oantagonista.com/uploads/2022/11/PL-Adendo-ao-Relatorio-Tecnico-sobre-o-Mau-Funcionamento-das-Urnas-Eletronicas-v1.5-22-11-2022.pdf&#34;&gt;Adendo ao Relatório Técnico Mau Funcionamento das Urnas Eletrônicas - Fiscalização das Eleições de 2022 no TSE - por Partido Liberal (PL) - 23/11/2022&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Dados Utilizados&lt;/h1&gt; &#xA;&lt;p&gt;Para a realização das análises vamos utilizar as mesmas fontes de dados utilizadas no relatório do PL. Embora numa condição menor em termos de amostras por conta de limitações de hardware.&lt;/p&gt; &#xA;&lt;p&gt;Serão analisadas 20 Urnas eletrônicas da cidade de Salto - São Paulo, sendo 16 delas anteriores ao modelo EU2022&lt;/p&gt; &#xA;&lt;h3&gt;Referências dos Dados&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://resultados.tse.jus.br/oficial/app/index.html#/eleicao;e=e545;uf=sp;ufbu=sp;mubu=70050;zn=0221;se=0004/dados-de-urna/log-da-urna&#34;&gt;Resultados das Urnas - Resultados TSE&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dadosabertos.tse.jus.br/dataset/resultados-2022-boletim-de-urna&#34;&gt;Boletim das Urnas - Dados Abertos&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Encontrando o problema apresentado nas fontes de dados&lt;/h1&gt; &#xA;&lt;p&gt;Para iniciarmos a análise vamos tentar chegar na mesma conclusão que os analistas contratados pelo PL chegaram no relatório preliminar. Encontrar o campo que foi apontado como problemático.&lt;/p&gt; &#xA;&lt;p&gt;Realizei o Download de logs de 20 urnas usadas em 20 seções eleitorais da cidade de Salto, São Paulo. Cidade na qual resido. Código Município 70050.&lt;/p&gt; &#xA;&lt;p&gt;Os arquivos estão na &lt;a href=&#34;https://www.reviversoft.com/pt/file-extensions/dat&#34;&gt;extensão .dat&lt;/a&gt;. Arquivos em texto simples que estavam separando as variáveis das observações a partir da tabs.&lt;/p&gt; &#xA;&lt;p&gt;Feita a primeira análise a olho nu, precisei identificar o chartset para fazer a futura análise com a devida qualidade. O mesmo se encontrava em charset &lt;a href=&#34;https://pt.wikipedia.org/wiki/ISO/IEC_8859-1&#34;&gt;iso-8859-1&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/charset.png&#34; alt=&#34;charset&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Importando os Dados&lt;/h2&gt; &#xA;&lt;p&gt;Para executar a análise vou estar utilizando o ferramental da &lt;a href=&#34;https://rlang.r-lib.org&#34;&gt;linguagem R&lt;/a&gt;, linguagem normalmente utilizada para realizar tarefas de Estatística, Machine Learning, e Data Science.&lt;/p&gt; &#xA;&lt;p&gt;O primeiro passo foi juntar todos os datasets reunidos das urnas em um único dataframe para ajudar na manipulação e análise.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;datasets_logs &amp;lt;- c(&#xA;  &#34;logd-00407-0001.dat&#34;,&#xA;  &#34;logd-00407-0002.dat&#34;,&#xA;  &#34;logd-00407-0003.dat&#34;,&#xA;  &#34;logd-00407-0004.dat&#34;, &#xA;  &#34;logd-00407-0005.dat&#34;,&#xA;  &#34;logd-00407-0006.dat&#34;,&#xA;  &#34;logd-00407-0007.dat&#34;,&#xA;  &#34;logd-00407-0008.dat&#34;,&#xA;  &#34;logd-00407-0009.dat&#34;,&#xA;  &#34;logd-00407-0010.dat&#34;,&#xA;  &#34;logd-00407-0011.dat&#34;,&#xA;  &#34;logd-00407-0012.dat&#34;,&#xA;  &#34;logd-00407-0013.dat&#34;,&#xA;  &#34;logd-00407-0014.dat&#34;,&#xA;  &#34;logd-00407-0015.dat&#34;,&#xA;  &#34;logd-00407-0028.dat&#34;,&#xA;  &#34;logd-00407-0075.dat&#34;,&#xA;  &#34;logd-00407-0122.dat&#34;,&#xA;  &#34;logd-00407-0147.dat&#34;,&#xA;  &#34;logd-00407-0253.dat&#34;&#xA;)&#xA;&#xA;## Criando um Dummy Dataset vazio&#xA;logs &amp;lt;- read.table(datasets_logs[1], &#xA;                  header=FALSE, &#xA;                  skip=0, &#xA;                  sep=&#34;\t&#34;, &#xA;                  nrows = 1,&#xA;                  fileEncoding=&#34;iso-8859-1&#34;&#xA;)&#xA;&#xA;## ...&#xA;&#xA;for (d in datasets_logs) {&#xA;  tmp &amp;lt;- read.table(d, &#xA;          header=FALSE, &#xA;          skip=0, &#xA;          sep=&#34;\t&#34;, &#xA;          fileEncoding=&#34;iso-8859-1&#34;&#xA;  )&#xA;  logs &amp;lt;- rbind(logs, tmp)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Os arquivos possuem 6 colunas. Contendo principalmente o &lt;code&gt;datetime&lt;/code&gt; do log, o &lt;code&gt;log level&lt;/code&gt; algo que a priori parece ser o identificador único da urna, apontado como fator impossibilitador de auditorias pelo relatório, a linha de log propriamente dita e um identificador único que parece ser o log.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/formato-inicial.png&#34; alt=&#34;formato inicial&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Gerando uma tabela de frequências dos Identificadores Iniciais&lt;/h2&gt; &#xA;&lt;p&gt;Vamos gerar uma tabela de frequências, para contar a ocorrência de cada linha de log separando pelos id&#39;s de urna encontrados no campo &lt;code&gt;V3&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;initial_table &amp;lt;- table(logs$vV)&#xA;initial_table&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/analise-inicial-freq-logs.png&#34; alt=&#34;tabela-de-frequencias-raw&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Como foram importados dados de 20 urnas distintas, eram esperados logs agrupados de 20 identificadores, porém temos uma quantidade muito discrepante de logs a partir do Identificador &lt;code&gt;67305985&lt;/code&gt;. Mesmo ID apontado no relatório. Por fim chegamos na linha de raciocínio do relatório. De 20 observações, 16 estão apresentando logs com o mesmo identificador. Dado esse ponto, é dito pela consultoria, em nome do Partido Liberal, que seria terminantemente impossível utilizar os logs para auditar as urnas e conferir informações.&lt;/p&gt; &#xA;&lt;p&gt;O objetivo dessa análise é aplicar técnicas de mercado exploratórias para não só conseguir auditar e checar votos, como também enriquecer os dados além da informação bruta para análises estatísticas, aplicar modelos de Machine Learning e enriquecer ainda mais os datasets públicos e confiabilidade.&lt;/p&gt; &#xA;&lt;p&gt;Veremos como nos passos a seguir.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Simulação de Auditoria de Dados&lt;/h1&gt; &#xA;&lt;p&gt;A partir deste ponto, vou guiar a análise como se eu mesmo, assumindo um papel de auditor ou cientista de dados, precisasse estabelecer formas de gerar informação útil com a massa de dados para análises em escala.&lt;/p&gt; &#xA;&lt;h2&gt;Data Minning e Enriquecimento dos Dataframes&lt;/h2&gt; &#xA;&lt;p&gt;Como os arquivos de logs são verbosos, mas não possuem muitas observações em na dimensão de variáveis, a ideia inicial é percorrer superficialmente os dados gerados nas linhas de logs para ver que tipo de informações encontramos.&lt;/p&gt; &#xA;&lt;p&gt;Usando um editor de texto, abrimos um dos arquivos da amostra, encontramos informações interessantes como &lt;code&gt;Modelo de Urna&lt;/code&gt;, &lt;code&gt;Município&lt;/code&gt;, &lt;code&gt;Zona Eleitoral&lt;/code&gt;, &lt;code&gt;Seção Eleitoral&lt;/code&gt;, &lt;code&gt;Local de Votação&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/primeira-analise.png&#34; alt=&#34;primeira analise&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Para um check-up mais leigo, esses dados já serviriam. Pois, o próprio Tribunal Supremo Eleitoral utiliza a sequência de &lt;code&gt;Município&lt;/code&gt;/&lt;code&gt;Zona&lt;/code&gt;/&lt;code&gt;Seção&lt;/code&gt; para se organizar e disponibilizar os dados no portal.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/busca-tse.png&#34; alt=&#34;Busca TSE&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Vamos normalizar e enriquecer as linhas de log do Dataframe.&lt;/p&gt; &#xA;&lt;p&gt;Para realizar essa ação, vamos utilizar o ferramental para aplicar Regex nas linhas de logs procurando por determinadas ocorrências de padrão de texto, e recuperando os valores.&lt;/p&gt; &#xA;&lt;p&gt;Antes disso, vamos criar e renomear as variáveis do dataframe para uma melhor identificação visual e facilitar a manipulação dos dados.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# ...&#xA;names(logs) &amp;lt;- c(&#34;datetime&#34;, &#34;log_level&#34;, &#34;id_urna&#34;, &#34;cod&#34;, &#34;log&#34;, &#34;log_id&#34;, &#34;modelo_urna&#34;, &#34;municipio&#34;, &#34;zona_eleitoral&#34;, &#34;local_votacao&#34;, &#34;secao_eleitoral&#34;)&#xA;# ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Em seguida vamos reimportar todos os datasets, já percorrendo cada um deles e aplicando as regras de regex, normalização para as novas variáveis a partir dos valores recuperados.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## Fazendo o merge de todos os datasets&#xA;for (d in datasets_logs) {&#xA;  tmp &amp;lt;- read.table(d, &#xA;          header=FALSE, &#xA;          skip=0, &#xA;          sep=&#34;\t&#34;, &#xA;          fileEncoding=&#34;iso-8859-1&#34;&#xA;  )&#xA;  names(tmp) &amp;lt;- c(&#34;datetime&#34;, &#34;log_level&#34;, &#34;id_urna&#34;, &#34;cod&#34;, &#34;log&#34;, &#34;log_id&#34;)&#xA;  &#xA;  ## Enriquecimento inicial - Numero do modelo da urna&#xA;  str_find_pattern &amp;lt;- &#34;Identificação do Modelo de Urna: &#34;&#xA;  tmp$modelo_urna &amp;lt;- str_remove(grep(str_find_pattern, tmp$log,  value = TRUE)[1],str_find_pattern)&#xA;  &#xA;  ## Enriquecimento inicial - Municipio&#xA;  str_find_pattern &amp;lt;- &#34;Município: &#34;&#xA;  tmp$municipio &amp;lt;- str_remove(grep(str_find_pattern, tmp$log,  value = TRUE)[1],str_find_pattern)&#xA;  &#xA;  ## Enriquecimento inicial - Zona Eleitoral&#xA;  str_find_pattern &amp;lt;- &#34;Zona Eleitoral: &#34;&#xA;  tmp$zona_eleitoral &amp;lt;- str_remove(grep(str_find_pattern, tmp$log,  value = TRUE)[1],str_find_pattern)&#xA;  &#xA;  ## Enriquecimento inicial - Local de Votação&#xA;  str_find_pattern &amp;lt;- &#34;Local de Votação: &#34;&#xA;  tmp$local_votacao &amp;lt;- str_remove(grep(str_find_pattern, tmp$log,  value = TRUE)[1],str_find_pattern)&#xA;  &#xA;  ## Enriquecimento inicial - Sessão Eleitoral&#xA;  str_find_pattern &amp;lt;- &#34;Seção Eleitoral:&#34;&#xA;  tmp$secao_eleitoral &amp;lt;- str_trim(&#xA;    str_remove(grep(str_find_pattern, tmp$log,  value = TRUE)[1],str_find_pattern), &#xA;    side = c(&#34;both&#34;, &#34;left&#34;, &#34;right&#34;)&#xA;  )&#xA;  &#xA;  logs &amp;lt;- rbind(logs, tmp)&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A partir desse ponto, já evoluímos nosso dataframe&lt;/p&gt; &#xA;&lt;h3&gt;A partir desse ponto, evoluímos o dataframe disso:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/formato-inicial.png&#34; alt=&#34;dataframe-antes&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Para isso, um dataframe mais rico e amigável:&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/dataframe-regex.png&#34; alt=&#34;dataframe-antes&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Portanto, vamos explorar estatisticamente essa transformação para validarmos se está cobrindo o total de 20 observações de urnas.&lt;/p&gt; &#xA;&lt;p&gt;Primeiramente vamos avaliar a quantidade de seções eleitorais.&lt;/p&gt; &#xA;&lt;h4&gt;Quantidade de Modelos&lt;/h4&gt; &#xA;&lt;p&gt;Inicialmente conseguimos identificar a quantidade de modelos de urnas utilizados na amostra, totalizando&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Modelos&lt;/th&gt; &#xA;   &lt;th&gt;Quantidade&lt;/th&gt; &#xA;   &lt;th&gt;%&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;UE2009&lt;/td&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;40%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;UE2010&lt;/td&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;30%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;UE2015&lt;/td&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;10%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;UE2020&lt;/td&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;20%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/quantidade-modelos.png&#34; alt=&#34;Quantidade de Modelos&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Logs por Modelo de Urna&lt;/h4&gt; &#xA;&lt;p&gt;Uma observação ainda crua, mas que já pode ser extraída é a quantidade de logs por cada modelo de urna observado&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/modelos-logs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Logs por Seção Eleitoral&lt;/h4&gt; &#xA;&lt;p&gt;Por fim conseguimos pela primeira vez identificar 20 observações de 20 urnas a partir do enriquecimento dos dados que mineramos dos logs&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/secao-eleitoral-logs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Hashing de Identificação de Urnas através da metadados categóricos&lt;/h1&gt; &#xA;&lt;p&gt;A partir do momento que coletamos dados minerados, podemos começar a pensar numa forma de gerar um identificador único para cada modelo de urna através de uma técnica de &lt;a href=&#34;https://pt.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_hash&#34;&gt;Hashing&lt;/a&gt; de metadados.&lt;/p&gt; &#xA;&lt;p&gt;Uma função hash é um algoritmo que mapeia dados de comprimento variável para dados de comprimento fixo. Os valores retornados por uma função hash são chamados valores hash, códigos hash, somas hash, checksums ou simplesmente hashes&lt;/p&gt; &#xA;&lt;p&gt;As técnicas de Hashing é amplamente conhecida em diversas áreas e tem muitos usos no universo de tecnologia e engenharia de software. Mas principalmente para garantir integridade de algum dado. O conceito de Hash para olhos mais leigos é: &lt;code&gt;transformar uma abundante quantidade de dados, em uma pequena quantidade de informações&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Basicamente trocar um número grande de caracteres, palavras, números por um hash correspondente aqueles dados sem volta. Apenas sendo possível chegar ao resultado inicial através de &lt;code&gt;colisão&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Um exemplo prático, sem relação com a análise:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&#xA;❯ echo &#34;AAAAAAAAAAAAAAAAAAAA&#34; | md5&#xA;0a1f01f5d83b5dc40dec529fffdb3e6d&#xA;&#xA;&#xA;❯ echo &#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque sit amet lorem nec tortor venenatis vulputate. Donec eu pretium leo. Cras auctor tristique mi ut pharetra. Proin eget nulla id risus vestibulum dictum porttitor vel mauris.&#34; | md5&#xA;145ff0b0832aaf363cb04eb80cd6ac82&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Dessa forma conseguimos fornecemos uma string pequena, ou gigante, como argumento para uma função hash, neste caso, &lt;code&gt;MD5&lt;/code&gt;, e ela nos retorna o conjunto de caracteres correspondentes em formato de hash.&lt;/p&gt; &#xA;&lt;p&gt;Esta técnica é utilizada para checar integridade, pois se 1 byte for alterado, o resultado do hashing é completamente diferente.&lt;/p&gt; &#xA;&lt;p&gt;Exemplo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;❯ echo &#34;AAAAAAAAAAAAAAAAAAAA&#34; | md5&#xA;0a1f01f5d83b5dc40dec529fffdb3e6d&#xA;&#xA;❯ echo &#34;AAAAAAAAAAAAAAAAAAAa&#34; | md5&#xA;7159e41ca576aef10be31376206dbd86&#xA;&#xA;❯ echo &#34;AAAAAAAAAAAAAAAAAAAB&#34; | md5&#xA;b8a1a140172867f6d0d3a07fa7e7310c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;O objetivo é utilizar os metadados que não mudam, e não se repetem inicialmente em hashes e gerar um novo identificador único para a urna de determinada seção eleitoral.&lt;/p&gt; &#xA;&lt;h2&gt;Qual o motivo de eu ter escolhido uma estratégia de Hashing??&lt;/h2&gt; &#xA;&lt;p&gt;Durante minha carreira eu já tive a oportunidade de auditar alguns sistemas grandes e distribuídos de diversos segmentos de mercado.&lt;/p&gt; &#xA;&lt;p&gt;Essa técnica foi a primeira que me veio em mente, pois me lembrou de episódios onde haviam diversos logs distribuídos e sem padrão, de softwares como Snort, pFSense, Nginx, Apaches, Aplicações e não existia algo parecido com um &lt;code&gt;trace-id&lt;/code&gt; para fazer uma identificação de ponta a ponta para seguir algum vetor de ataque de segurança, ou problema funcional.&lt;/p&gt; &#xA;&lt;p&gt;Dessa forma, a estratégia de hashing nos permite pegar dados que são comuns entre diversas fontes, e criar um &lt;code&gt;trace-id&lt;/code&gt; para efetuarmos uma determinada análise ou responder alguma pergunta especifica de observabilidade para um ambiente em determinada situação.&lt;/p&gt; &#xA;&lt;p&gt;Softwares de APM, muito conhecidos de mercado utilizam estratégias parecidas para quando não conseguem enviar ou receber um id de identificação de origem entre sistemas que se comunicam.&lt;/p&gt; &#xA;&lt;p&gt;Dessa forma, achei muito viável utilizar a técnica de hashing de metadados para criar correlações entre urnas e documentos públicos.&lt;/p&gt; &#xA;&lt;h3&gt;Criando um Hashing Identificador para a Urna / Seção&lt;/h3&gt; &#xA;&lt;p&gt;Vamos gerar uma seed de caracteres concatenando informações como &lt;code&gt;municipio&lt;/code&gt;, &lt;code&gt;zona_eleitoral&lt;/code&gt;, &lt;code&gt;local_votacao&lt;/code&gt;, &lt;code&gt;secao_eleitoral&lt;/code&gt;, &lt;code&gt;modelo_urna&lt;/code&gt;, &lt;code&gt;id_urna&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;dessa forma &lt;code&gt;MUNICIPIO-ZONA-LOCAL-SECAO-MODELO-ID&lt;/code&gt;, tendo um resultado final parecido com &lt;code&gt;70050-0221-1015-0001-UE2020-2122186&lt;/code&gt;, e logo depois criar outro campo no nosso dataframe chamado &lt;code&gt;hash_urna&lt;/code&gt;, onde vamos armazenar o nosso identificador único. Dessa forma conseguindo ver de qual urna &#34;&#34;&#34;hasheada&#34;&#34;&#34;, veio determinado log. Para realizar isso vamos usar a biblioteca &lt;code&gt;digest&lt;/code&gt; do &lt;code&gt;R&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## Gerando uma seed para vincular a auditoria das urnas&#xA;logs$urna_seed &amp;lt;- paste(&#xA;  logs$municipio,&#xA;  logs$zona_eleitoral,&#xA;  logs$local_votacao,&#xA;  logs$secao_eleitoral,&#xA;  logs$modelo_urna,&#xA;  logs$id_urna, &#xA;  sep = &#34;-&#34;)&#xA;&#xA;logs$hash_urna &amp;lt;- sapply(logs$urna_seed, digest, algo=&#34;md5&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/hash-urna.png&#34; alt=&#34;Hash Urna&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Comparação da Auditoria via ID e Auditoria via Hashing de urnas&lt;/h1&gt; &#xA;&lt;p&gt;Primeiramente vamos gerar a comparação com base no erro apontado do PL de não identificação, se baseando no dado que chamamos de &lt;code&gt;id_urna&lt;/code&gt;. Vamos gerar a tabela de frequência dos logs baseados nesse valor&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## Tabela de frequencias id_urna&#xA;freq_table_id &amp;lt;- sort(table(logs$id_urna))&#xA;freq_table_id &amp;lt;- as.data.frame(freq_table_id)&#xA;names(freq_table_id) &amp;lt;- c(&#34;id_urna&#34;, &#34;frequencia&#34;)&#xA;freq_table_id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/id-urna.png&#34; alt=&#34;Hash Urna&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Agora vamos aplicar a mesma tecnica baseado no nosso campo identificador &lt;code&gt;hash_urna&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## Tabela de frequencias - hash_urna&#xA;freq_table_hash &amp;lt;- sort(table(logs$hash_urna))&#xA;freq_table_hash &amp;lt;- as.data.frame(freq_table_hash)&#xA;names(freq_table_hash) &amp;lt;- c(&#34;identificado_urna&#34;, &#34;frequencia&#34;)&#xA;freq_table_hash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/hash-urna-sort.png&#34; alt=&#34;Hash Urna&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Dessa forma conseguimos chegar num identificador da urna em seu horário de atividade. Conseguimos identificar e trabalhar nos dados da mesma através do campo que substituímos com o &lt;code&gt;hash_urna&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Comparação da Auditoria via ID e Auditoria via Hashing dos modelos apontados como “problemáticos”&lt;/h1&gt; &#xA;&lt;p&gt;A ideia deste tópico é realizar o mesmo teste de frequencia, mas tendo como amostra somente os modelos anteriores ao &lt;code&gt;UE2022&lt;/code&gt; cujo identificador foi dado como empecilho para validação dos dados.&lt;/p&gt; &#xA;&lt;p&gt;Primeiro passo é selecionar somente os modelos com o &lt;code&gt;id_urna&lt;/code&gt; igual a &lt;code&gt;67305985&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;### Codigo das urnas apontado como erro&#xA;codigo_urna_analise &amp;lt;- 67305985&#xA;urnas_analise &amp;lt;- subset(logs, id_urna == codigo_urna_analise)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Segundo passos é repetir o teste da tabela de frequência para pegar as urnas &#34;não identificáveis&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;### Tabela de frequencia do id_urna dos modelos antigos&#xA;freq_table_urnas_analise &amp;lt;- table(urnas_analise$id_urna)&#xA;freq_table_urnas_analise &amp;lt;- as.data.frame(freq_table_urnas_analise)&#xA;names(freq_table_urnas_analise) &amp;lt;- c(&#34;id_urna&#34;, &#34;frequencia&#34;)&#xA;freq_table_urnas_analise&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Geramos o gráfico de teste&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/logs-antigos-id.png&#34; alt=&#34;Logs ID Antigos&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Terceiro passo é gerar a tabela de frequência com as urnas agora, identificáveis&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;### Tabela de frequencia do hash_urna dos modelos antigos&#xA;freq_table_urnas_analise &amp;lt;- table(urnas_analise$hash_urna)&#xA;freq_table_urnas_analise &amp;lt;- as.data.frame(freq_table_urnas_analise)&#xA;names(freq_table_urnas_analise) &amp;lt;- c(&#34;hash_urna&#34;, &#34;frequencia&#34;)&#xA;freq_table_urnas_analise&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/logs-antigos-hash.png&#34; alt=&#34;Logs Hash Antigos&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;GameDays de Auditoria - Sempre em Construção&lt;/h1&gt; &#xA;&lt;p&gt;Essa seção é feita para validarmos o modelo de auditoria respondendo a perguntas que um auditor faria. A ideia não é usar apenas a técnica de hashing, mas também vários modelos de Machine Learning para exploração dos dados.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Correlação entre Urna Identificada vs Boletim de Urna&lt;/h2&gt; &#xA;&lt;p&gt;Um teste interessante é correlação entre o Boletim de Urna e a própria Urna. O Boletim de Urna é um dataset totalmente diferente dos logs, disponibilizado de outra fonte, ainda do TSE.&lt;/p&gt; &#xA;&lt;p&gt;Os boletins são emitidos por estado. Sendo assim iremos realizar o teste com base no boletim do Segundo Turno de São Paulo.&lt;/p&gt; &#xA;&lt;p&gt;[Boletim das Urnas - SP - Boletim de Urna - Segundo turno - 31.10.2022&lt;/p&gt; &#xA;&lt;p&gt;](&lt;a href=&#34;https://dadosabertos.tse.jus.br/dataset/resultados-2022-boletim-de-urna/resource/5729e0c0-c756-4ecf-8556-d98340135428&#34;&gt;https://dadosabertos.tse.jus.br/dataset/resultados-2022-boletim-de-urna/resource/5729e0c0-c756-4ecf-8556-d98340135428&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;Primeiro passo é importar o boletim, que veio em formato CSV diferente dos logs que são distribuídos em DAT.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;boletim &amp;lt;- read.csv(&#34;bweb_2t_SP_311020221535/bweb_2t_SP_311020221535.csv&#34;, &#xA;                    sep = &#34;;&#34;, &#xA;                    dec = &#34;.&#34;, &#xA;                    fileEncoding=&#34;iso-8859-1&#34;&#xA;)&#xA;&#xA;colnames(boletim)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/colnames-boletim.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Durante a primeira análise podemos ver que o número de informações em forma de variáveis do boletim é bem maior que o dos logs de forma crua. Porém, não temos informações como &lt;code&gt;codigo da urna&lt;/code&gt;, &lt;code&gt;modelo da urna&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Mas temos informações que podemos cruzar com o outro dataset dos logs, como &lt;code&gt;CD_MUNICIPIO&lt;/code&gt;, &lt;code&gt;NR_ZONA&lt;/code&gt;, &lt;code&gt;NR_SECAO&lt;/code&gt;, &lt;code&gt;NR_LOCAL_VOTACAO&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Hashing do Boletim&lt;/h3&gt; &#xA;&lt;p&gt;Antes de aplicarmos a técnica de hashing, vamos efetuar alguns procedimentos para facilitar o cruzamento dos dados. A primeira dessas coisas será efetuar a normalização de alguns campos para ficarem iguais aos que existem nos logs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Normalizando o NR_ZONA com padding de 4 zeros&#xA;boletim$NR_ZONA_NORM &amp;lt;- sprintf(&#34;%04d&#34;,boletim$NR_ZONA)&#xA;&#xA;# Normalizando o NR_SECAO com padding de 4 zeros&#xA;boletim$NR_SECAO_NORM &amp;lt;- sprintf(&#34;%04d&#34;,boletim$NR_SECAO)&#xA;&#xA;colnames(boletim)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Em seguida recuperamos somente os boletins do Município isolado da amostra, sendo ele &lt;code&gt;70050&lt;/code&gt; da cidade de Salto, São Paulo.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;boletim_salto_sp &amp;lt;- subset(boletim, CD_MUNICIPIO == 70050)&#xA;boletim_salto_sp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Vamos aplicar a técnica de hashing inicialmente no primeiro dataframe dos logs. Inicialmente criando uma seed e posteriormente gerar um hash &lt;code&gt;MD5&lt;/code&gt; dela no campo &lt;code&gt;hash_identificacao_boletim&lt;/code&gt;. Vamos utilizar somente as informações que existem no boletim.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;logs$boletim_seed &amp;lt;- paste(&#xA;  logs$municipio,&#xA;  logs$zona_eleitoral,&#xA;  logs$local_votacao,&#xA;  logs$secao_eleitoral,&#xA;  sep = &#34;-&#34;)&#xA;&#xA;&#xA;## Gerando um hash de identificação do Boletim&#xA;logs$hash_identificacao_boletim &amp;lt;- sapply(logs$boletim_seed, digest, algo=&#34;md5&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;O mesmo passo será repetido no dataframe do Boletim de Urna.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;boletim_salto_sp$SEED_IDENTIFICACAO &amp;lt;- paste(&#xA;  boletim_salto_sp$CD_MUNICIPIO,&#xA;  boletim_salto_sp$NR_ZONA_NORM,&#xA;  boletim_salto_sp$NR_LOCAL_VOTACAO,&#xA;  boletim_salto_sp$NR_SECAO_NORM,&#xA;  sep = &#34;-&#34;&#xA;)&#xA;&#xA;## Gerando a hash de identificação da urna no boletim&#xA;boletim_salto_sp$HASH_IDENTIFICACAO &amp;lt;- sapply(boletim_salto_sp$SEED_IDENTIFICACAO, digest, algo=&#34;md5&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Criamos agora o campo &lt;code&gt;HASH_IDENTIFICACAO&lt;/code&gt; no Boletim de Urna.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/hash-identificacao.png&#34; alt=&#34;hash identificacao&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Agora precisamos criar um dataframe de join, isolando todos os &lt;code&gt;hash_urnas&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Separando os hashes unicos pra melhorar a performance do update do dataset&#xA;unique_hashes &amp;lt;- logs %&amp;gt;% distinct(hash_identificacao_boletim, hash_urna, hash_urna, modelo_urna)&#xA;unique_hashes &amp;lt;- as.data.frame(unique_hashes)&#xA;unique_hashes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Agora vamos percorrer esse data frame de comparação para fazer um update em todas as linhas do Boletim que fizeram parte da contabilização das urnas utilizadas na amostra, adicionando&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Adicionando as informações da urna no boletim com base no HASH_IDENTIFICAO&#xA;&#xA;# Adiciona o HASH_URNA e MODELO_URNA&#xA;for (i in 1:nrow(unique_hashes)) {&#xA;  h &amp;lt;- unique_hashes[i, &#34;hash_identificacao_boletim&#34;]&#xA;  boletim_salto_sp$HASH_URNA[boletim_salto_sp$HASH_IDENTIFICACAO == h] &amp;lt;- unique_hashes[i, &#34;hash_urna&#34;]&#xA;&#xA;  boletim_salto_sp$MODELO_URNA[boletim_salto_sp$HASH_IDENTIFICACAO == h] &amp;lt;- unique_hashes[i, &#34;modelo_urna&#34;]  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Agora vamos isolar as linhas do boletim que correspondem as nossas urnas de amostra&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Removendo as urnas que não foram incluídas na análise&#xA;boletim_salto_sp_amostra &amp;lt;- as.data.frame(boletim_salto_sp[rowSums(is.na(boletim_salto_sp)) == 0,])&#xA;table(boletim_salto_sp_amostra$HASH_IDENTIFICACAO)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Agora vamos checar se conseguimos correlacionar a amostra com seu devido boletim.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;boletim_salto_sp_amostra_resumido &amp;lt;- boletim_salto_sp_amostra %&amp;gt;% &#xA;  select(HASH_URNA, MODELO_URNA, DS_ELEICAO, DS_CARGO_PERGUNTA, DS_TIPO_VOTAVEL, NM_VOTAVEL, QT_VOTOS)&#xA;&#xA;View(boletim_salto_sp_amostra_resumido)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/vinculo-boletim.png&#34; alt=&#34;Vinculo do Boletim&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Agora conseguimos saber de qual urna foram apuradas as informações do Boletim.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Me diga qual, urna estava na seção X do local Y da zona Z??&lt;/h2&gt; &#xA;&lt;p&gt;Para responder isso podemos criar um subset baseado nos critérios levantados.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## &#34;Me diga qual urna estava na seção X do local Y da zona Z&#34;&#xA;&#xA;urna_x &amp;lt;- subset(logs, secao_eleitoral == &#34;0001&#34; | local_votacao == &#34;1015&#34; | zona_eleitoral == &#34;0221&#34;)&#xA;urna_x_view &amp;lt;- urna_x %&amp;gt;% select(hash_urna,datetime, modelo_urna, municipio, zona_eleitoral, secao_eleitoral)&#xA;&#xA;View(head(urna_x_view, 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/qual-urna.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Me dê somente os logs de uma determinada urna!&lt;/h2&gt; &#xA;&lt;p&gt;Para responder essa pergunta podemos criar um subset procurando pela respectiva hash_urna.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## &#34;Me dê somente os logs da urna hash_id:1a2097e964d5e77e355e30744484aa2c&#34;&#xA;&#xA;urna_x &amp;lt;- subset(logs, hash_urna == &#34;1a2097e964d5e77e355e30744484aa2c&#34;)&#xA;urna_x_view &amp;lt;- urna_x %&amp;gt;% select(hash_urna,datetime, modelo_urna, municipio, zona_eleitoral, secao_eleitoral,  log)&#xA;&#xA;View(urna_x_view)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/msfidelis/analise-identificao-urnas-eletronicas/main/img/logs-urna-x.png&#34; alt=&#34;Logs Urna&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>thedatacollective/tdcstyle</title>
    <updated>2022-11-28T01:37:02Z</updated>
    <id>tag:github.com,2022-11-28:/thedatacollective/tdcstyle</id>
    <link href="https://github.com/thedatacollective/tdcstyle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Style data.table according to the opinions of TheDataCollective&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;tdcstyle&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;{tdcstyle}&lt;/code&gt; provides &lt;code&gt;tdc_style&lt;/code&gt;, an opinionated &lt;code&gt;{data.table}&lt;/code&gt; styler that builds on &lt;code&gt;tidyverse_style&lt;/code&gt; for &lt;code&gt;{styler}&lt;/code&gt;. It tries, with varying success to, balance readability with concise expressions.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;style()&lt;/code&gt; function styles the active file, or the active text selection (if made), with preference given to active selection.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This is built for the dev version of &lt;code&gt;{data.table}&lt;/code&gt; that makes use of the &lt;code&gt;let()&lt;/code&gt; function. A much nicer alternative to &lt;code&gt;:=()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install the development version of tdcstyle like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;remotes::install_github(&#34;thedatacollective/tdcstyle&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Plug it into styler with: &lt;code&gt;styler::style_file(&amp;lt;path&amp;gt;, style = tdcstyle::tdc_style)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;OR make a binding for &lt;code&gt;tdcstyle::style()&lt;/code&gt; which uses the &lt;code&gt;{rstudioapi}&lt;/code&gt; to style the active file or actively selected text.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Highlights&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Split out filters onto new lines, lead by &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. Parenthesised parts of the filter are not split.&lt;/li&gt; &#xA; &lt;li&gt;argument alignment for &lt;code&gt;let&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;pull up trailing brackets&lt;/li&gt; &#xA; &lt;li&gt;In multiline expressions, push filter onto a new line&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;      donors[&#xA;        is.na(force_reason)&#xA;        | (is.na(other_reason) &amp;amp; cashemerg_hag_amount &amp;gt;= 1000),&#xA;        let(force_include = &#34;Y&#34;,&#xA;            force_reason = &#34;01. High Mid Value Cash/Emerg&#34;,&#xA;            pack = &#34;MV&#34;)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Put internal data.table syntax sugar functions on new lines:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;      mailingbase[,&#xA;        .(this = that + 1,&#xA;          foo = func(bar)),&#xA;        .(foo, bar)]&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pair &lt;code&gt;fcase&lt;/code&gt; condition / expressions on same lines:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;&#xA;      mailingbase[&#xA;        is.na(VP1),&#xA;        let(VP1 = fcase(&#xA;            segment == &#34;Active Donors&#34;, &#34;1.2 Active Donors (AD)&#34;,&#xA;            segment == &#34;Flood Emergency&#34;, &#34;1.3 Flood Emergency&#34;&#xA;            default == &#34;Standard&#34;&#xA;            ))]&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Substitute &lt;code&gt;:=()&lt;/code&gt; for &lt;code&gt;let()&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;VSCode Binding&lt;/h2&gt; &#xA;&lt;p&gt;From the command palette acessed &lt;code&gt;Preferences: Open Keyboard Shortcuts (JSON)&lt;/code&gt;, and add a new binding like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;key&#34;: &#34;&amp;lt;YOUR BINDING&amp;gt;&#34;,&#xA;  &#34;command&#34;: &#34;r.runCommand&#34;,&#xA;  &#34;args&#34;: &#34;tdcstyle::style()&#34;&#xA;},&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RStudio users can do something similar with &lt;a href=&#34;https://github.com/gadenbuie/shrtcts&#34;&gt;{shrtcts}&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Options&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;tdcstyle.exapnd_args&lt;/code&gt; Set to &lt;code&gt;TRUE&lt;/code&gt; to enable &lt;code&gt;{grrkstyle}&lt;/code&gt;-esque expassion of function arguments onto new lines. &lt;code&gt;FALSE&lt;/code&gt; by default.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Free software by:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/thedatacollective/tdcstyle/main/inst/images/thedatacollective.png&#34; alt=&#34;The data collective logo&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>r-rust/hellorust</title>
    <updated>2022-11-28T01:37:02Z</updated>
    <id>tag:github.com,2022-11-28:/r-rust/hellorust</id>
    <link href="https://github.com/r-rust/hellorust" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Template R package with rust bindings&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Hello Rust&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/r-rust/hellorust/actions?workflow=R-CMD-check&#34;&gt;&lt;img src=&#34;https://github.com/r-rust/hellorust/workflows/R-CMD-check/badge.svg?sanitize=true&#34; alt=&#34;R build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Minimal Examples of Using Rust Code in R&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Rust is a modern alternative to C and compiled rust code is ABI compatible with C. Many Rust libraries include C API headers so that the compiled rust code can be called from R/C/C++ as if it were C code. This package shows how to do this. The &lt;a href=&#34;https://github.com/r-rust&#34;&gt;r-rust&lt;/a&gt; organization contains several more simple R packages interfacing with cargo crates.&lt;/p&gt; &#xA;&lt;p&gt;To learn more about using Rust code in R packages, also have a look at the &lt;a href=&#34;https://github.com/r-rust/faq&#34;&gt;r-rust FAQ&lt;/a&gt; and the &lt;a href=&#34;https://jeroen.github.io/erum2018/&#34;&gt;slides&lt;/a&gt; about this project presented at eRum2018!&lt;/p&gt; &#xA;&lt;h2&gt;Package Structure&lt;/h2&gt; &#xA;&lt;p&gt;Bundle your rust code in a the embedded cargo package (see the &lt;code&gt;Cargo.toml&lt;/code&gt; file) and then the &lt;a href=&#34;https://raw.githubusercontent.com/r-rust/hellorust/master/src/Makevars&#34;&gt;src/Makevars&lt;/a&gt; file is written such that R will automatically build the rust modules when the R package is installed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hellorust&#xA;├─ configure            ← checks if &#39;cargo&#39; is installed&#xA;├─ src&#xA;│  ├─ myrustlib            ← bundled cargo package with your code&#xA;│  |  ├─ Cargo.toml          ← cargo dependencies and metadata&#xA;│  |  ├─ src                 ← rust source code&#xA;│  |  └─ api.h               ← C headers for exported rust API&#xA;|  |&#xA;│  ├─ Makevars          ← Ties everything together&#xA;│  └─ wrapper.c         ← C code for R package&#xA;├─ DESCRIPTION&#xA;└─ R                    ← Standard R+C stuff&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installing this package&lt;/h2&gt; &#xA;&lt;p&gt;If Rust is available, clone this repository and run the regular &lt;code&gt;R CMD INSTALL&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;R CMD INSTALL hellorust&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, to download and install from within R itself:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;remotes&#34;)&#xA;remotes::install_github(&#34;r-rust/hellorust&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;What is Cargo&lt;/h2&gt; &#xA;&lt;p&gt;The standard rust toolchain includes a great package manager &lt;code&gt;cargo&lt;/code&gt; with a corresponding registry &lt;a href=&#34;https://crates.io/&#34;&gt;crates.io&lt;/a&gt;. Cargo makes it very easy to build a rust package including all dependencies into a static library that can easily be linked into an R package.&lt;/p&gt; &#xA;&lt;p&gt;This is perfect for R because we can compile and link all rust code at build-time without any system dependencies. Rust itself has no substantial runtime so the resulting R package is entirely self contained. Indeed, rust has been designed specifically to serve well as an embedded language.&lt;/p&gt; &#xA;&lt;h2&gt;Installing Rust on Linux / MacOS&lt;/h2&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;cargo&lt;/code&gt; is only needed at &lt;strong&gt;build-time&lt;/strong&gt;. Rust has &lt;strong&gt;no runtime dependencies&lt;/strong&gt;. The easiest way to install the latest version of Rust (including cargo) is from: &lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you may install cargo from your OS package manager:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Debian/Ubuntu: &lt;code&gt;sudo apt-get install cargo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fedora/CentOS*: &lt;code&gt;sudo yum install cargo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;MacOS: &lt;code&gt;brew install rustc&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*Note that on CentOS you first need to enable EPEL via &lt;code&gt;sudo yum install epel-release&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installing Rust for R on Windows&lt;/h2&gt; &#xA;&lt;p&gt;In order for rust to work with R you need to install the toolchain using &lt;code&gt;rustup&lt;/code&gt; and then add the &lt;code&gt;x86_64-pc-windows-gnu&lt;/code&gt; target. First download &lt;a href=&#34;https://win.rustup.rs/&#34;&gt;rustup-init.exe&lt;/a&gt; and then install the default toolchain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rustup-init.exe -y --default-host x86_64-pc-windows-gnu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or if rust is already installed (for example on GitHub actions), you can simply add the target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rustup target add x86_64-pc-windows-gnu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To compile 32bit packages also add the &lt;code&gt;i686-pc-windows-gnu&lt;/code&gt; target, but 32-bit is no longer supported as of R 4.2.&lt;/p&gt; &#xA;&lt;h2&gt;GitHub Actions&lt;/h2&gt; &#xA;&lt;p&gt;To use GitHub actions, you can use the &lt;a href=&#34;https://github.com/r-lib/actions/raw/HEAD/.github/workflows/check-standard.yaml&#34;&gt;standard r workflow&lt;/a&gt; script in combination with this extra step:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- name: Add Rtools targets to Rust&#xA;  if: runner.os == &#39;Windows&#39;&#xA;  run: |&#xA;    rustup target add i686-pc-windows-gnu&#xA;    rustup target add x86_64-pc-windows-gnu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;In the real world&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://cran.r-project.org/web/packages/gifski/index.html&#34;&gt;gifski&lt;/a&gt; package has been on CRAN since 2018, and uses this same structure.&lt;/p&gt; &#xA;&lt;p&gt;However, do note that for the CRAN release we used a hack in &lt;code&gt;src/Makevars.win&lt;/code&gt; to download a precompiled version of the gifski crate on Windows, because the CRAN winbuilder did not have a Rust compiler installed.&lt;/p&gt; &#xA;&lt;h2&gt;More Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Erum2018 &lt;a href=&#34;https://jeroen.github.io/erum2018/&#34;&gt;slides&lt;/a&gt; about this project presented by Jeroen&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/1.6.0/book/rust-inside-other-languages.html&#34;&gt;Rust Inside Other Languages&lt;/a&gt; chapter from official rust documentation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/extendr&#34;&gt;extendr&lt;/a&gt;: a more advanced R extension interface using Rust&lt;/li&gt; &#xA; &lt;li&gt;Duncan&#39;s proof of concept: &lt;a href=&#34;https://github.com/duncantl/RCallRust&#34;&gt;RCallRust&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>