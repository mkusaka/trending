<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-20T01:33:49Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pvk99/DM_Group_6</title>
    <updated>2024-03-20T01:33:49Z</updated>
    <id>tag:github.com,2024-03-20:/pvk99/DM_Group_6</id>
    <link href="https://github.com/pvk99/DM_Group_6" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Repository for the group project of Data Management - Group 6&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DM_Group_6&lt;/h1&gt; &#xA;&lt;p&gt;Repository for the group project of Data Management - Group 6&lt;/p&gt; &#xA;&lt;p&gt;Our e-commerce database project is for a UK-based online small-scale retail shop. We initiate a structured approach to data management, encompassing design, translation, generation, version control, and analysis.&lt;/p&gt; &#xA;&lt;p&gt;We begin by designing an e-commerce workflow diagram to map out our online retail processes, covering everything from products to orders and transactions. This blueprint serves as the foundation for our database structure, which we create using SQL.&lt;/p&gt; &#xA;&lt;p&gt;Using R programming, we generate synthetic data tailored to our structure, ensuring it reflects real-world retail transactions and is accurate. We then employ GitHub for version control, facilitating seamless collaboration and accountability.&lt;/p&gt; &#xA;&lt;p&gt;Finally, we conduct advanced data analysis to measure our enterprise&#39;s performance. Presenting our findings, we empower stakeholders with actionable insights to drive strategic decision-making and foster business growth.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>atsyplenkov/centerline</title>
    <updated>2024-03-20T01:33:49Z</updated>
    <id>tag:github.com,2024-03-20:/atsyplenkov/centerline</id>
    <link href="https://github.com/atsyplenkov/centerline" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An R package to retrieve the centerline of polygons&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;centerline&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/atsyplenkov/centerline/actions/workflows/R-CMD-check.yaml&#34;&gt;&lt;img src=&#34;https://github.com/atsyplenkov/centerline/actions/workflows/R-CMD-check.yaml/badge.svg?sanitize=true&#34; alt=&#34;R-CMD-check&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://lifecycle.r-lib.org/articles/stages.html#experimental&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/lifecycle-experimental-orange.svg?sanitize=true&#34; alt=&#34;Lifecycle: experimental&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://CRAN.R-project.org/package=centerline&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version/centerline.png&#34; alt=&#34;CRAN status&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/r-package/v/atsyplenkov/centerline?label=github.png&#34; alt=&#34;GitHub R package version&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/last-commit/atsyplenkov/centerline.png&#34; alt=&#34;GitHub last commit&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;The &lt;code&gt;centerline&lt;/code&gt; R package simplifies the extraction of linear features from complex polygons, such as roads or rivers, by computing their centerlines (or median-axis) using Voronoi diagrams. It uses the super-fast &lt;a href=&#34;https://paleolimbot.github.io/geos/index.html&#34;&gt;&lt;code&gt;geos&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://andyteucher.ca/rmapshaper/index.html&#34;&gt;&lt;code&gt;rmapshaper&lt;/code&gt;&lt;/a&gt; libraries in the background.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install the development version of &lt;code&gt;centerline&lt;/code&gt; from &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;devtools&#34;)&#xA;devtools::install_github(&#34;atsyplenkov/centerline&#34;)&#xA;&#xA;# OR&#xA;&#xA;# install.packages(&#34;pak&#34;)&#xA;pak::pak(&#34;atsyplenkov/centerline&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples for closed geometries&lt;/h2&gt; &#xA;&lt;p&gt;At the heart of this package is the &lt;code&gt;cnt_skeleton&lt;/code&gt; function, which efficiently computes the skeleton of closed 2D polygonal geometries. The function uses &lt;a href=&#34;http://andyteucher.ca/rmapshaper/reference/ms_simplify.html&#34;&gt;&lt;code&gt;rmapshaper::ms_simplify()&lt;/code&gt;&lt;/a&gt; by default to keep the most important nodes and reduce noise from the beginning. However, it has option to densify the amount of points using &lt;a href=&#34;https://paleolimbot.github.io/geos/reference/geos_centroid.html&#34;&gt;&lt;code&gt;geos::geos_densify&lt;/code&gt;&lt;/a&gt;, which can produce more smooth results.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(centerline)&#xA;library(terra)&#xA;#&amp;gt; terra 1.7.65&#xA;&#xA;# Load Polygon Of Interest (POI)&#xA;polygon &amp;lt;- &#xA;  terra::vect(&#xA;    system.file(&#xA;      &#34;extdata/example.gpkg&#34;, package = &#34;centerline&#34;&#xA;    ), &#xA;    layer = &#34;polygon&#34;&#xA;  )&#xA;&#xA;# Find POI&#39;s skeleton&#xA;pol_skeleton &amp;lt;- &#xA;  cnt_skeleton(polygon, keep = 1) &#xA;&#xA;# Simplified POI&#39;s skeleton&#xA;pol_skeleton_simplify &amp;lt;- &#xA;  cnt_skeleton(polygon, keep = .1) &#xA;&#xA;# Densified POI&#39;s skeleton&#xA;pol_skeleton_densify &amp;lt;- &#xA;  cnt_skeleton(polygon, keep = 1.5) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Plot’s code&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Plot&#xA;par(&#xA;  mar = c(0.5, 0.5, 0.2, 0.2),&#xA;  mfrow = c(1, 3),&#xA;  oma = c(0, 0, 0.2, 0.2)&#xA;)&#xA;&#xA;# Raw&#xA;plot(pol_skeleton,&#xA;     col = &#34;dodgerblue3&#34;)&#xA;plot(polygon,&#xA;     border = &#34;grey20&#34;,&#xA;     main = &#34;Original&#34;,&#xA;     add = T)&#xA;&#xA;# Simplified&#xA;plot(pol_skeleton_simplify,&#xA;     col = &#34;dodgerblue3&#34;)&#xA;plot(polygon,&#xA;     border = &#34;grey20&#34;,&#xA;     main = &#34;Simplified&#34;,&#xA;     add = T)&#xA;&#xA;# Densified&#xA;plot(pol_skeleton_densify,&#xA;     col = &#34;dodgerblue3&#34;)&#xA;plot(polygon,&#xA;     border = &#34;grey20&#34;,&#xA;     main = &#34;Densified&#34;,&#xA;     add = T)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/atsyplenkov/centerline/master/man/figures/README-plot-1-1.png&#34; style=&#34;width:100.0%&#34;&gt; &#xA;&lt;p&gt;However, the above-generated lines are not exactly a centerline of a polygon. One way to find the centerline of a closed polygon is to define both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; points. For example, in the case of landslides, it could be the landslide initiation point and landslide terminus.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Load points data&#xA;points &amp;lt;- &#xA;  terra::vect(&#xA;    system.file(&#xA;      &#34;extdata/example.gpkg&#34;, package = &#34;centerline&#34;&#xA;    ),&#xA;    layer = &#34;polygon_points&#34;&#xA;  )&#xA;&#xA;# Connect points&#xA;# For original skeleton&#xA;pol_path &amp;lt;-&#xA;  cnt_path(&#xA;    skeleton = pol_skeleton,&#xA;    start_point = terra::subset(points, points$type == &#34;start&#34;),&#xA;    end_point = terra::subset(points, points$type != &#34;start&#34;)&#xA;  )&#xA;&#xA;# For simplified skeleton&#xA;pol_path_simplify &amp;lt;-&#xA;  cnt_path(&#xA;    skeleton = pol_skeleton_simplify,&#xA;    start_point = terra::subset(points, points$type == &#34;start&#34;),&#xA;    end_point = terra::subset(points, points$type != &#34;start&#34;)&#xA;  )&#xA;&#xA;# For densified skeleton&#xA;pol_path_dens &amp;lt;-&#xA;  cnt_path(&#xA;    skeleton = pol_skeleton_densify,&#xA;    start_point = terra::subset(points, points$type == &#34;start&#34;),&#xA;    end_point = terra::subset(points, points$type != &#34;start&#34;)&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Plot’s code&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Plot&#xA;par(mfrow = c(1, 3)) &#xA;&#xA;# Original&#xA;plot(polygon, border = &#34;grey20&#34;, &#xA;     main = paste0(&#34;Original path (L = &#34;,&#xA;                   round(terra::perim(pol_path[[1]]), 2), &#34; m)&#34;))&#xA;plot(pol_path[[1]], lwd = 3, add = T)&#xA;plot(points[1, ], col = &#34;coral2&#34;,  add = T)&#xA;plot(points[2, ], col = &#34;green4&#34;,  add = T)&#xA;&#xA;# Simplified&#xA;plot(polygon, border = &#34;grey20&#34;, &#xA;     main = paste0(&#34;Simplified path (L = &#34;,&#xA;                   round(terra::perim(pol_path_simplify[[1]]), 2), &#34; m)&#34;))&#xA;plot(pol_path_simplify[[1]], lwd = 3, add = T)&#xA;plot(points[1, ], col = &#34;coral2&#34;,  add = T)&#xA;plot(points[2, ], col = &#34;green4&#34;,  add = T)&#xA;&#xA;# Densified&#xA;plot(polygon, border = &#34;grey20&#34;, &#xA;     main = paste0(&#34;Densified path (L = &#34;,&#xA;                   round(terra::perim(pol_path_dens[[1]]), 2), &#34; m)&#34;))&#xA;plot(pol_path_dens[[1]], lwd = 3, add = T)&#xA;plot(points[1, ], col = &#34;coral2&#34;,  add = T)&#xA;plot(points[2, ], col = &#34;green4&#34;,  add = T)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/atsyplenkov/centerline/master/man/figures/README-plot-2-1.png&#34; style=&#34;width:100.0%&#34;&gt; &#xA;&lt;p&gt;And what if we don’t know the starting and ending locations? What if we just want to place our label accurately in the middle of our polygon? In this case, one may find the &lt;code&gt;cnt_path_guess&lt;/code&gt; function useful. It returns the line connecting the most distant points, i.e., the polygon’s length. Such an approach is used in limnology for measuring &lt;a href=&#34;https://www.lakescientist.com/lake-shape/&#34;&gt;lake lengths&lt;/a&gt;, for example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(sf)&#xA;&#xA;lake &amp;lt;- &#xA;  st_read(&#xA;    system.file(&#34;extdata/example.gpkg&#34;, package = &#34;centerline&#34;),&#xA;    layer = &#34;lake&#34;,&#xA;    quiet = T&#xA;  ) |&amp;gt; &#xA;  st_cast(&#34;POLYGON&#34;)&#xA;&#xA;lake_centerline &amp;lt;- &#xA;  cnt_path_guess(lake, keep = 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Plot’s code&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)&#xA;#&amp;gt; Warning: package &#39;ggplot2&#39; was built under R version 4.3.3&#xA;library(geomtextpath)&#xA;library(smoothr)&#xA;#&amp;gt; Warning: package &#39;smoothr&#39; was built under R version 4.3.3&#xA;#&amp;gt; &#xA;#&amp;gt; Attaching package: &#39;smoothr&#39;&#xA;#&amp;gt; The following object is masked from &#39;package:terra&#39;:&#xA;#&amp;gt; &#xA;#&amp;gt;     densify&#xA;#&amp;gt; The following object is masked from &#39;package:stats&#39;:&#xA;#&amp;gt; &#xA;#&amp;gt;     smooth&#xA;&#xA;lake_centerline_s &amp;lt;- &#xA;  lake_centerline |&amp;gt; &#xA;  st_union() |&amp;gt; &#xA;  st_line_merge() |&amp;gt; &#xA;  st_simplify(dTolerance = 150)  |&amp;gt; &#xA;  smooth(&#34;chaikin&#34;)&#xA;&#xA;cnt2 &amp;lt;- &#xA;  rbind(&#xA;    st_as_sf(lake_centerline_s),&#xA;    st_as_sf(lake_centerline_s)&#xA;  )&#xA;&#xA;cnt2$lc &amp;lt;- c(&#34;black&#34;, NA_character_)&#xA;cnt2$ll &amp;lt;- c(&#34;&#34;, lake$name)&#xA;&#xA;ggplot() +&#xA;  geom_sf(&#xA;    data = lake,&#xA;    fill = &#34;#c8e8f1&#34;,&#xA;    color = NA&#xA;  ) +&#xA;  geom_textsf(&#xA;    data = cnt2,&#xA;    aes(&#xA;      linecolor = lc,&#xA;      label = ll&#xA;    ),&#xA;    color = &#34;#458894&#34;,&#xA;    size = 8,&#xA;    family = &#34;Liberation Mono&#34;&#xA;  ) +&#xA;  scale_color_identity() +&#xA;  facet_wrap(~lc) +&#xA;  theme_void() +&#xA;  theme(strip.text = element_blank())&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&#xA;#&amp;gt; Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :&#xA;#&amp;gt; font family not found in Windows font database&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/atsyplenkov/centerline/master/man/figures/README-plot-3-1.png&#34; style=&#34;width:100.0%&#34;&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;centerline 📦&#xA;├── Closed geometries (e.g., lakes)&#xA;│   ├── When we do know starting and ending points (e.g., landslides) ✅&#xA;│   │   ├── centerline::cnt_skeleton ✅&#xA;│   │   └── centerline::cnt_path ✅&#xA;│   └── When we do NOT have points (e.g., lakes) ✅&#xA;│       ├── centerline::cnt_skeleton ✅&#xA;│       └── centerline::cnt_path_guess ✅&#xA;├── Linear objects (e.g., roads or rivers)  🔲&#xA;└── Collapse parallel lines to centerline 🔲&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Alternatives&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;R&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/RichardPatterson/midlines&#34;&gt;midlines&lt;/a&gt; - A more hydrology-oriented library that provides a multi-step approach to generate a smooth centerline of complex curved polygons (like rivers).&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/AntoniusGolly/cmgo&#34;&gt;cmgo&lt;/a&gt; - The main aim of the package is to propose a workflow to extract channel bank metrics, and as a part of that workflow, centerline extraction was implemented.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;🐍 Python: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/fitodic/centerline/tree/master&#34;&gt;centerline&lt;/a&gt; library&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;🦀 Rust: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://codeberg.org/eadf/centerline_rs&#34;&gt;centerline_rs&lt;/a&gt; library&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;JS&lt;/strong&gt; Javascript: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://observablehq.com/@veltman/centerline-labeling&#34;&gt;Centerline labeling blogpost&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>gertvv/rsmaa</title>
    <updated>2024-03-20T01:33:49Z</updated>
    <id>tag:github.com,2024-03-20:/gertvv/rsmaa</id>
    <link href="https://github.com/gertvv/rsmaa" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SMAA implementation for R&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SMAA for R&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.com/gertvv/rsmaa&#34;&gt;&lt;img src=&#34;https://travis-ci.com/gertvv/rsmaa.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;An R package for the Stochastic Multi-criteria Acceptability Analysis (SMAA) family of Multiple Criteria Decision Analysis (MCDA) methods.&lt;/p&gt; &#xA;&lt;h2&gt;Integration tests&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;itest&lt;/code&gt; directory contains examples that are too time-consuming or take too much space to submit to CRAN.&lt;/p&gt;</summary>
  </entry>
</feed>