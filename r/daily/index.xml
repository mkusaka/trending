<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-15T01:51:52Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Zaoqu-Liu/IRLS</title>
    <updated>2022-07-15T01:51:52Z</updated>
    <id>tag:github.com,2022-07-15:/Zaoqu-Liu/IRLS</id>
    <link href="https://github.com/Zaoqu-Liu/IRLS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Machine learning-based integrative analysis develops an immune-derived lncRNA signature for improving clinical outcomes in colorectal cancer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;IRLS&lt;/h1&gt; &#xA;&lt;p&gt;Machine learning-based integrative analysis develops an immune-derived lncRNA signature for improving clinical outcomes in colorectal cancer&lt;/p&gt; &#xA;&lt;h2&gt;Consensus clustering&lt;/h2&gt; &#xA;&lt;p&gt;According to the infiltration profile of various immune cells, a resampling-based method termed consensus clustering was applied for cluster discovery. This process was performed by ConsensusClusterPlus package[1]. Subsample 80% of samples at each iteration and partition each subsample into up to k (max K = 9) groups by k-means algorithm upon Euclidean distance. This process was repeated for 1,000 repetitions. Subsequently, the consensus score matrix, cumulative distribution function (CDF) curve, proportion of ambiguous clustering (PAC) score, and Nbclust were synthetically used to determine the optimal number of clusters. A higher consensus score between two samples indicates they are more likely to be grouped into the same cluster in different iterations. The consensus values range from 0 (never clustered together) to 1 (always clustered together) marked by white to dark brown. In the CDF curve of a consensus matrix, the lower left portion represents sample pairs rarely clustered together, the upper right portion represents those almost always clustered together, whereas the middle segment represents those with ambiguous assignments in different clustering runs. The &#34;proportion of ambiguous clustering&#34; (PAC) measure quantifies this middle segment; and is defined as the fraction of sample pairs with consensus indices falling in the interval (u1, u2) ∈ [0, 1] where u1 is a value close to 0 and u2 is a value close to 1 (for instance u1=0.1 and u2=0.9). A low value of PAC indicates a flat middle segment, and a low rate of discordant assignments across permuted clustering runs. PAC for each K is CDFk(u2) - CDFk(u1)[2]. According to his criterion, we can therefore infer the optimal number of clusters by the K value having the lowest PAC. The Nbclust uses 26 mathematic criteria to select the optimal number.&lt;/p&gt; &#xA;&lt;h2&gt;Signature generated from machine learning based integrative approaches&lt;/h2&gt; &#xA;&lt;p&gt;To develop a consensus immune-related lncRNA signature (IRLS) with high accuracy and stability performance, we integrated 10 machine learning algorithms and 101 algorithm combinations. The integrative algorithms included random survival forest (RSF), elastic network (Enet), Lasso, Ridge, stepwise Cox, CoxBoost, partial least squares regression for Cox (plsRcox), supervised principal components (SuperPC), generalized boosted regression modeling (GBM), and survival support vector machine (survival-SVM). The RSF model was implemented via the randomForestSRC package. RSF had two parameters ntree and mtry, where ntree represented the number of trees in the forest and mtry was the number of randomly selected variables for splitting at each node. We used a grid-search on ntree and mtry using leave-one-out cross-validation (LOOCV) framework. All the pairs of (ntree, mtry) are formed and the one with the best C-index value is identified as the optimized parameters. The Enet, Lasso, and Ridge were implemented via the glmnet package. The regularization parameter, λ, was determined by LOOCV, whereas the L1-L2 trade-off parameter, α, was set to 0-1 (interval =0.1). The stepwise Cox model was implemented via survival package. A stepwise algorithm using the AIC (Akaike information criterion) was applied, and the direction mode of stepwise search was set to &#34;both&#34;, &#34;backward&#34;, and &#34;forward&#34;, respectively. The CoxBoost model was implemented via CoxBoost package, which is used to fit a Cox proportional hazards model by componentwise likelihood-based boosting. For the CoxBoost model, we used LOOCV routine optimCoxBoostPenalty function to first determine the optimal penalty (amount of shrinkage). Once this parameter was determined, the other tuning parameter of the algorithm, namely, the number of boosting steps to perform, was selected via the function cv.CoxBoost. The dimension of the selected multivariate Cox model was finally set by the principal routine CoxBoost. The plsRcox model was implemented via plsRcox package. The cv.plsRcox function was used to determine the number of components requested, and the plsRcox function was applied to fit a partial least squares regression generalized linear model. The SuperPC model was implemented via superpc package, is a generalization of principal component analysis, which generates a linear combination of the features or variables of interest that capture the directions of largest variation in a dataset. The superpc.cv function used a form of LOOCV to estimate the optimal feature threshold in supervised principal components. To avoid problems with fitting Cox models to small validation datasets, it uses the &#34;pre-validation&#34; approach. The GBM model was implemented via superpc package. Using the LOOCV, the cv.gbm function selected index for number trees with minimum cross-validation error. The gbm function was used to fit the generalized boosted regression model. The survival-SVM model was implemented via survivalsvm package. The regression approach takes censoring into account when formulating the inequality constraints of the support vector problem.&lt;/p&gt; &#xA;&lt;h2&gt;Cells infiltration estimation&lt;/h2&gt; &#xA;&lt;p&gt;The single sample gene set enrichment analysis (ssGSEA) implemented in R package GSVA was employed to quantify the relative infiltration of 28 immune cells in CRC[22]. Six other algorithms including TIMER, quanTIseq, MCP-counter, xCell, EPIC, and ESTIMATE, were further performed to verify the stability and robustness of the ssGSEA results.&lt;/p&gt; &#xA;&lt;h2&gt;Weighted gene co-expression network analysis (WGCNA)&lt;/h2&gt; &#xA;&lt;p&gt;Co-expression lncRNA networks were generated using WGCNA package. An appropriate soft threshold β was calculated to meet the criteria for scale-free network. Further, the weighted adjacency matrix was converted into a topological overlap matrix (TOM), and the corresponding dissimilarity was generated (1-TOM). The dynamic tree cutting approach was employed to conduct the module identification. To recognize lncRNAs modules significantly corelated with immune cluster, the module that displayed the highest correlation was selected for further study. lncRNAs with both high gene significance (GS) and module membership (MM) were defined as immune-related lncRNAs.&lt;/p&gt; &#xA;&lt;h2&gt;ImmLnc analysis framework&lt;/h2&gt; &#xA;&lt;p&gt;ImmLnc is an integrated algorithm for identifying lncRNA modulators of immune-related pathways. First, the ESTIMATE algorithm was used to infer tumor purity. Second, we calculated the partial correlation coefficient (PCC) between a specific lncRNA and all mRNAs by adjusting the tumor purity as a covariable. Final, all mRNAs were ranked by the correlation coefficient with a specific lncRNA, and the ranked gene list was further subjected to GSEA procedure to investigate whether the immune genes were enriched in the top or bottom of the gene list. As recommended, lncRES scores &amp;gt;0.995 and FDR &amp;lt;0.05 were considered statistically significant[9, 19].&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>rstudio-education/shiny.rstudio.com-tutorial</title>
    <updated>2022-07-15T01:51:52Z</updated>
    <id>tag:github.com,2022-07-15:/rstudio-education/shiny.rstudio.com-tutorial</id>
    <link href="https://github.com/rstudio-education/shiny.rstudio.com-tutorial" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Slides and exercises for the video tutorial at https://shiny.rstudio.com/tutorial/&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;shiny.rstudio.com-tutorial&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains the slides and exercises for the video tutorial at &lt;a href=&#34;https://shiny.rstudio.com/tutorial&#34;&gt;https://shiny.rstudio.com/tutorial&lt;/a&gt;. You can either clone the repository or download its contents as a zipped folder by clicking on the green &#34;Clone or download&#34; button on the upper right corner.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>insightsengineering/teal.modules.hermes</title>
    <updated>2022-07-15T01:51:52Z</updated>
    <id>tag:github.com,2022-07-15:/insightsengineering/teal.modules.hermes</id>
    <link href="https://github.com/insightsengineering/teal.modules.hermes" rel="alternate"></link>
    <summary type="html">&lt;p&gt;RNA-seq analysis modules to add to a teal application&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;teal.modules.hermes: Teal Modules for RNAseq Data Analysis&lt;/h1&gt; &#xA;&lt;p&gt;Welcome to &lt;code&gt;teal.modules.hermes&lt;/code&gt;! Jump right into an ad-hoc module example or read a bit more about what is what, i.e. how the pieces fit together.&lt;/p&gt; &#xA;&lt;h2&gt;Ad-hoc module example&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s assume you have a function &lt;code&gt;awesome_plot()&lt;/code&gt; which takes a count matrix and makes an awesome plot out of it. Now you would like to make a Shiny app where you can filter patients, samples, select the experiment out of your &lt;code&gt;MultiAssayExperiment&lt;/code&gt; (MAE), select the count matrix from the experiment, etc. Nothing is easier than that with &lt;code&gt;teal.modules.hermes&lt;/code&gt;! We show you below how to quickly spin up your UI, server and put them together into a nice little app.&lt;/p&gt; &#xA;&lt;h3&gt;UI function&lt;/h3&gt; &#xA;&lt;p&gt;In &lt;code&gt;teal.modules.hermes&lt;/code&gt; we provide modules that make the experiment and assay selection super easy, see here for the UI part:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ui &amp;lt;- function(id,&#xA;               datasets,&#xA;               mae_name) {&#xA;  ns &amp;lt;- NS(id)&#xA;&#xA;  teal.widgets::standard_layout(&#xA;    encoding = div(&#xA;      experimentSpecInput(ns(&#34;experiment&#34;), datasets, mae_name),&#xA;      assaySpecInput(ns(&#34;assay&#34;))&#xA;    ),&#xA;    output = plotOutput(ns(&#34;awesome_plot&#34;))&#xA;  )&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Server function&lt;/h3&gt; &#xA;&lt;p&gt;Similarly for the server we use the modules, and call then our awesome plotting function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;srv &amp;lt;- function(input,&#xA;                output,&#xA;                session,&#xA;                datasets,&#xA;                mae_name) {&#xA;  experiment &amp;lt;- experimentSpecServer(&#xA;    &#34;experiment&#34;,&#xA;    datasets = datasets,&#xA;    mae_name = mae_name,&#xA;    name_annotation = NULL  # If you have a gene name column in your rowData, can specify here.&#xA;  )&#xA;  assay &amp;lt;- assaySpecServer(&#34;assay&#34;, experiment$assays)&#xA;  output$awesome_plot &amp;lt;- renderPlot({&#xA;    data &amp;lt;- experiment$data()&#xA;    assay &amp;lt;- assay()&#xA;    req(assay %in% SummarizedExperiment::assayNames(data))&#xA;    counts &amp;lt;- SummarizedExperiment::assay(data, assay)&#xA;    awesome_plot(counts)&#xA;  })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;App function&lt;/h3&gt; &#xA;&lt;p&gt;Now let&#39;s assume you want to spin up your app for an MAE.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(teal.modules.hermes)&#xA;awesome_app &amp;lt;- function(mae, label = &#34;My awesome app&#34;) {&#xA;  mae_name &amp;lt;- &#34;MAE&#34;&#xA;  mae &amp;lt;- hermes::lapply(mae, hermes::HermesData)&#xA;  mae_data &amp;lt;- dataset(mae_name, mae)&#xA;  data &amp;lt;- teal_data(mae_data)&#xA;  app &amp;lt;- init(&#xA;    data = data,&#xA;    modules = root_modules(&#xA;      module(&#xA;        label = label,&#xA;        server = srv,&#xA;        server_args = list(mae_name = mae_name),&#xA;        ui = ui,&#xA;        ui_args = list(mae_name = mae_name),&#xA;        filters = mae_name&#xA;      )&#xA;    )&#xA;  )&#xA;  shinyApp(app$ui, app$server)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Testing it&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s test this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;awesome_plot &amp;lt;- image&#xA;awesome_app(hermes::multi_assay_experiment)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;What is what&lt;/h2&gt; &#xA;&lt;h3&gt;What is &lt;code&gt;teal&lt;/code&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;teal&lt;/code&gt; is a shiny-based interactive exploration framework for analyzing clinical trials data. &lt;code&gt;teal&lt;/code&gt; currently provides a dynamic filtering facility and diverse data viewers. &lt;code&gt;teal&lt;/code&gt; shiny applications are built using standard &lt;a href=&#34;https://shiny.rstudio.com/articles/modules.html&#34;&gt;shiny modules&lt;/a&gt;. See &lt;a href=&#34;https://insightsengineering.github.io/teal&#34;&gt;github&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;What is &lt;code&gt;hermes&lt;/code&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;hermes&lt;/code&gt; facilitates preprocessing, analyzing, and reporting of RNA-seq data. The core functionality is built on the BioConductor ecosystem, especially the &lt;code&gt;SummarizedExperiment&lt;/code&gt; class from which the &lt;code&gt;HermesData&lt;/code&gt; class inherits. See the &lt;a href=&#34;https://insightsengineering.github.io/hermes/articles/hermes.html&#34;&gt;vignette&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;So what is then &lt;code&gt;teal.modules.hermes&lt;/code&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;teal.modules.hermes&lt;/code&gt; provides &lt;code&gt;teal&lt;/code&gt; modules (which can be used as part of any &lt;code&gt;teal&lt;/code&gt; app), for interactive RNA-seq data analysis using &lt;code&gt;hermes&lt;/code&gt;. Again it is heavily built on the BioConductor classes, in particular &lt;code&gt;MultiAssayExperiment&lt;/code&gt; (MAE) which is expected to contain the &lt;code&gt;HermesData&lt;/code&gt; experiments.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;For releases from August 2022 it is recommended that you &lt;a href=&#34;https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token&#34;&gt;create and use a Github PAT&lt;/a&gt; to install the latest version of this package. Once you have the PAT, run the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Sys.setenv(GITHUB_PAT = &#34;your_access_token_here&#34;)&#xA;if (!require(&#34;remotes&#34;)) install.packages(&#34;remotes&#34;)&#xA;remotes::install_github(&#34;insightsengineering/teal.modules.hermes@*release&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A stable release of all &lt;code&gt;NEST&lt;/code&gt; packages from June 2022 is also available &lt;a href=&#34;https://github.com/insightsengineering/depository#readme&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>