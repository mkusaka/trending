<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-31T01:35:38Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rpradosiqueira/sidrar</title>
    <updated>2023-10-31T01:35:38Z</updated>
    <id>tag:github.com,2023-10-31:/rpradosiqueira/sidrar</id>
    <link href="https://github.com/rpradosiqueira/sidrar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A R interface to IBGE&#39;s SIDRA API&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;sidrar&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://CRAN.R-project.org/package=sidrar&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version/sidrar&#34; alt=&#34;CRAN_Status_Badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://CRAN.R-project.org/package=sidrar&#34;&gt;&lt;img src=&#34;https://cranlogs.r-pkg.org/badges/grand-total/sidrar&#34; alt=&#34;CRAC_Downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The goal of &lt;em&gt;sidrar&lt;/em&gt; is to provide direct access to the data of IBGE&#39;s (Brazilian Institute of Geography and Statistics) SIDRA API within the R environment in an easy and flexible way. SIDRA is the acronym to &#34;Sistema IBGE de Recuperação Automática&#34; and it is the system where IBGE makes aggregate data from their researches available.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install the release version from CRAN:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#34;sidrar&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or the development version from github&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;devtools&#34;)&#xA;devtools::install_github(&#34;rpradosiqueira/sidrar&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Functions&lt;/h2&gt; &#xA;&lt;p&gt;For the time being, the &#34;sidrar&#34; package contains only three functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;get_sidra          It recovers data from the given table&#xA;                   according to the parameters&#xA;                   &#xA;info_sidra         It allows you to check what parameters&#xA;                   are available for a table&#xA;                   &#xA;search_sidra       It searches which tables have a particular &#xA;                   word in their names&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s assume that we want the IPCA (Índice de Preços ao Consumidor Amplo) for the city of Campo Grande/MS. However, we want to recover only the overall percentage rate in the last 12 months. To do this simply execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(sidrar)&#xA;&#xA;get_sidra(x = 1419,&#xA;          variable = 63,&#xA;          period = c(last = &#34;12&#34;),&#xA;          geo = &#34;City&#34;,&#xA;          geo.filter = 5002704,&#xA;          classific = &#34;c315&#34;,&#xA;          category = list(7169),&#xA;          header = FALSE,&#xA;          format = 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To more examples, see the vignette &lt;a href=&#34;https://CRAN.R-project.org/package=sidrar/vignettes/Introduction_to_sidrar.html&#34;&gt;&#34;Introduction to sidrar&#34;&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>YuLab-SMU/ggsc</title>
    <updated>2023-10-31T01:35:38Z</updated>
    <id>tag:github.com,2023-10-31:/YuLab-SMU/ggsc</id>
    <link href="https://github.com/YuLab-SMU/ggsc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>r-dbi/RPostgres</title>
    <updated>2023-10-31T01:35:38Z</updated>
    <id>tag:github.com,2023-10-31:/r-dbi/RPostgres</id>
    <link href="https://github.com/r-dbi/RPostgres" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A DBI-compliant interface to PostgreSQL&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RPostgres&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/r-dbi/RPostgres/actions&#34;&gt;&lt;img src=&#34;https://github.com/r-dbi/RPostgres/workflows/rcc/badge.svg?sanitize=true&#34; alt=&#34;rcc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.codecov.io/gh/r-dbi/RPostgres?branch=main&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/r-dbi/RPostgres/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;Codecov test coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://CRAN.R-project.org/package=RPostgres&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version/RPostgres&#34; alt=&#34;CRAN status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;RPostgres is an DBI-compliant interface to the postgres database. It&#39;s a ground-up rewrite using C++ and &lt;a href=&#34;https://github.com/r-lib/cpp11&#34;&gt;cpp11&lt;/a&gt;. Compared to RPostgreSQL, it:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Has full support for parameterised queries via &lt;code&gt;dbSendQuery()&lt;/code&gt;, and &lt;code&gt;dbBind()&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatically cleans up open connections and result sets, ensuring that you don&#39;t need to worry about leaking connections or memory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Is a little faster, saving ~5 ms per query. (For reference, it takes around 5ms to retrieve a 1000 x 25 result set from a local database, so this is decent speed up for smaller queries.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A simplified build process that relies on system libpq.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;# Install the latest RPostgres release from CRAN:&#xA;install.packages(&#34;RPostgres&#34;)&#xA;&#xA;# Or the the development version from GitHub:&#xA;# install.packages(&#34;remotes&#34;)&#xA;remotes::install_github(&#34;r-dbi/RPostgres&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Discussions associated with DBI and related database packages take place on &lt;a href=&#34;https://stat.ethz.ch/mailman/listinfo/r-sig-db&#34;&gt;R-SIG-DB&lt;/a&gt;. The website &lt;a href=&#34;https://db.rstudio.com/&#34;&gt;Databases using R&lt;/a&gt; describes the tools and best practices in this ecosystem.&lt;/p&gt; &#xA;&lt;h2&gt;Basic usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;library(DBI)&#xA;# Connect to the default postgres database&#xA;con &amp;lt;- dbConnect(RPostgres::Postgres())&#xA;&#xA;dbListTables(con)&#xA;dbWriteTable(con, &#34;mtcars&#34;, mtcars)&#xA;dbListTables(con)&#xA;&#xA;dbListFields(con, &#34;mtcars&#34;)&#xA;dbReadTable(con, &#34;mtcars&#34;)&#xA;&#xA;# You can fetch all results:&#xA;res &amp;lt;- dbSendQuery(con, &#34;SELECT * FROM mtcars WHERE cyl = 4&#34;)&#xA;dbFetch(res)&#xA;dbClearResult(res)&#xA;&#xA;# Or a chunk at a time&#xA;res &amp;lt;- dbSendQuery(con, &#34;SELECT * FROM mtcars WHERE cyl = 4&#34;)&#xA;while(!dbHasCompleted(res)){&#xA;  chunk &amp;lt;- dbFetch(res, n = 5)&#xA;  print(nrow(chunk))&#xA;}&#xA;# Clear the result&#xA;dbClearResult(res)&#xA;&#xA;# Disconnect from the database&#xA;dbDisconnect(con)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Connecting to a specific Postgres instance&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;library(DBI)&#xA;# Connect to a specific postgres database i.e. Heroku&#xA;con &amp;lt;- dbConnect(RPostgres::Postgres(),dbname = &#39;DATABASE_NAME&#39;, &#xA;                 host = &#39;HOST&#39;, # i.e. &#39;ec2-54-83-201-96.compute-1.amazonaws.com&#39;&#xA;                 port = 5432, # or any other port specified by your DBA&#xA;                 user = &#39;USERNAME&#39;,&#xA;                 password = &#39;PASSWORD&#39;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Design notes&lt;/h2&gt; &#xA;&lt;p&gt;The original DBI design imagined that each package could instantiate X drivers, with each driver having Y connections and each connection having Z results. This turns out to be too general: a driver has no real state, for PostgreSQL each connection can only have one result set. In the RPostgres package there&#39;s only one class on the C side: a connection, which optionally contains a result set. On the R side, the driver class is just a dummy class with no contents (used only for dispatch), and both the connection and result objects point to the same external pointer.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Please note that the &#39;RPostgres&#39; project is released with a &lt;a href=&#34;https://rpostgres.r-dbi.org/code_of_conduct&#34;&gt;Contributor Code of Conduct&lt;/a&gt;. By contributing to this project, you agree to abide by its terms.&lt;/p&gt;</summary>
  </entry>
</feed>