<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-05T01:35:56Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>r-lidar/lidR</title>
    <updated>2025-06-05T01:35:56Z</updated>
    <id>tag:github.com,2025-06-05:/r-lidar/lidR</id>
    <link href="https://github.com/r-lidar/lidR" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Airborne LiDAR data manipulation and visualisation for forestry application&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lidR &lt;img src=&#34;https://raw.githubusercontent.com/r-lidar/lidR/master/man/figures/logo200x231.png&#34; align=&#34;right&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/Licence-GPL--3-blue.svg?sanitize=true&#34; alt=&#34;license&#34;&gt; &lt;a href=&#34;https://github.com/r-lidar/lidR/actions&#34;&gt;&lt;img src=&#34;https://github.com/r-lidar/lidR/workflows/R-CMD-check/badge.svg?sanitize=true&#34; alt=&#34;R build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.codecov.io/gh/r-lidar/lidR?branch=master&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/r-lidar/lidR/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;Codecov test coverage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;R package for Airborne LiDAR Data Manipulation and Visualization for Forestry Applications&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The lidR package provides functions to read and write &lt;code&gt;.las&lt;/code&gt; and &lt;code&gt;.laz&lt;/code&gt; files, plot point clouds, compute metrics using an area-based approach, compute digital canopy models, thin LiDAR data, manage a collection of LAS/LAZ files, automatically extract ground inventories, process a collection of tiles using multicore processing, segment individual trees, classify points from geographic data, and provides other tools to manipulate LiDAR data in a &lt;strong&gt;research and development context.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üìñ Read &lt;a href=&#34;https://r-lidar.github.io/lidRbook/index.html&#34;&gt;the book&lt;/a&gt; to get started with the lidR package.&lt;/li&gt; &#xA; &lt;li&gt;üíª Install &lt;code&gt;lidR&lt;/code&gt; from R with: &lt;code&gt;install.packages(&#34;lidR&#34;)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;üíµ &lt;a href=&#34;https://github.com/sponsors/Jean-Romain&#34;&gt;Sponsor &lt;code&gt;lidR&lt;/code&gt;&lt;/a&gt;. It is free and open source, but requires time and effort to develop and maintain.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;lidR&lt;/code&gt; has been cited by more than 1,000 scientific papers. To cite the package use &lt;code&gt;citation()&lt;/code&gt; from within R:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;citation(&#34;lidR&#34;)&#xA;#&amp;gt; Roussel, J.R., Auty, D., Coops, N. C., Tompalski, P., Goodbody, T. R. H., S√°nchez Meador, A., Bourdon, J.F., De Boissieu, F., Achim, A. (2021). lidR : An R package for analysis of Airborne Laser Scanning (ALS) data. Remote Sensing of Environment, 251 (August), 112061. &amp;lt;doi:10.1016/j.rse.2020.112061&amp;gt;.&#xA;#&amp;gt; Jean-Romain Roussel and David Auty (2023). Airborne LiDAR Data Manipulation and Visualization for Forestry Applications. R package version 3.1.0. https://cran.r-project.org/package=lidR&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also be interested by our new &lt;a href=&#34;https://github.com/r-lidar/lasR&#34;&gt;&lt;code&gt;lasR&lt;/code&gt;&lt;/a&gt; package.&lt;/p&gt; &#xA;&lt;h1&gt;Key features&lt;/h1&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://raw.githubusercontent.com/Jean-Romain/storage/master/README/point-cloud-rotating.gif&#34;&gt; &#xA;&lt;h3&gt;Read and display a las file&lt;/h3&gt; &#xA;&lt;p&gt;In R-fashion style the function &lt;code&gt;plot&lt;/code&gt;, based on &lt;code&gt;rgl&lt;/code&gt;, enables the user to display, rotate and zoom a point cloud.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;las &amp;lt;- readLAS(&#34;&amp;lt;file.las&amp;gt;&#34;)&#xA;plot(las)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compute a canopy height model&lt;/h3&gt; &#xA;&lt;img align=&#34;left&#34; src=&#34;https://raw.githubusercontent.com/Jean-Romain/storage/master/README/chm-Khosravipour.png&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;lidR&lt;/code&gt; has several algorithms from the literature to compute canopy height models either point-to-raster based or triangulation based. This allows testing and comparison of some methods that rely on a CHM, such as individual tree segmentation or the computation of a canopy roughness index.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;las &amp;lt;- readLAS(&#34;&amp;lt;file.las&amp;gt;&#34;)&#xA;&#xA;# Khosravipour et al. pitfree algorithm&#xA;thr &amp;lt;- c(0,2,5,10,15)&#xA;edg &amp;lt;- c(0, 1.5)&#xA;chm &amp;lt;- rasterize_canopy(las, 1, pitfree(thr, edg))&#xA;&#xA;plot(chm)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Read and display a catalog of las files&lt;/h3&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://raw.githubusercontent.com/Jean-Romain/storage/master/README/catalog-plot_interactive.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;lidR&lt;/code&gt; enables the user to manage, use and process a collection of &lt;code&gt;las&lt;/code&gt; files. The function &lt;code&gt;readLAScatalog&lt;/code&gt; builds a &lt;code&gt;LAScatalog&lt;/code&gt; object from a folder. The function &lt;code&gt;plot&lt;/code&gt; displays this collection on an interactive map using the &lt;code&gt;mapview&lt;/code&gt; package (if installed).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ctg &amp;lt;- readLAScatalog(&#34;&amp;lt;folder/&amp;gt;&#34;)&#xA;plot(ctg, map = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From a &lt;code&gt;LAScatalog&lt;/code&gt; object the user can (for example) extract some regions of interest (ROI) with &lt;code&gt;clip_roi()&lt;/code&gt;. Using a catalog for the extraction of the ROI guarantees fast and memory-efficient clipping. &lt;code&gt;LAScatalog&lt;/code&gt; objects allow many other manipulations that can be done with multicore processing.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h3&gt;Individual tree segmentation&lt;/h3&gt; &#xA;&lt;img align=&#34;left&#34; src=&#34;https://raw.githubusercontent.com/Jean-Romain/storage/master/README/its-rotating-tree-segmented.gif&#34;&gt; &#xA;&lt;p&gt;The &lt;code&gt;segment_trees()&lt;/code&gt; function has several algorithms from the literature for individual tree segmentation, based either on the digital canopy model or on the point-cloud. Each algorithm has been coded from the source article to be as close as possible to what was written in the peer-reviewed papers. Our goal is to make published algorithms usable, testable and comparable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;las &amp;lt;- readLAS(&#34;&amp;lt;file.las&amp;gt;&#34;)&#xA;&#xA;las &amp;lt;- segment_trees(las, li2012())&#xA;col &amp;lt;- random.colors(200)&#xA;plot(las, color = &#34;treeID&#34;, colorPalette = col)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Wall-to-wall dataset processing&lt;/h3&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://raw.githubusercontent.com/Jean-Romain/storage/master/README/catalog-processing.gif&#34;&gt; &#xA;&lt;p&gt;Most of the lidR functions can seamlessly process a set of tiles and return a continuous output. Users can create their own methods using the &lt;code&gt;LAScatalog&lt;/code&gt; processing engine via the &lt;code&gt;catalog_apply()&lt;/code&gt; function. Among other features the engine takes advantage of point indexation with lax files, takes care of processing tiles with a buffer and allows for processing big files that do not fit in memory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Load a LAScatalog instead of a LAS file&#xA;ctg &amp;lt;- readLAScatalog(&#34;&amp;lt;path/to/folder/&amp;gt;&#34;)&#xA;&#xA;# Process it like a LAS file&#xA;chm &amp;lt;- rasterize_canopy(ctg, 2, p2r())&#xA;col &amp;lt;- random.colors(50)&#xA;plot(chm, col = col)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Full waveform&lt;/h3&gt; &#xA;&lt;img align=&#34;left&#34; src=&#34;https://raw.githubusercontent.com/Jean-Romain/storage/master/FWF/fwf.gif&#34;&gt; &#xA;&lt;p&gt;lidR can read full waveform data from LAS files and provides interpreter functions to convert the raw data into something easier to manage and display in R. The support of FWF is still in the early stages of development.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fwf &amp;lt;- readLAS(&#34;&amp;lt;fullwaveform.las&amp;gt;&#34;)&#xA;&#xA;# Interpret the waveform into something easier to manage&#xA;las &amp;lt;- interpret_waveform(fwf)&#xA;&#xA;# Display discrete points and waveforms&#xA;x &amp;lt;- plot(fwf, colorPalette = &#34;red&#34;, bg = &#34;white&#34;)&#xA;plot(las, color = &#34;Amplitude&#34;, add = x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;About&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;lidR&lt;/code&gt; is developed openly by &lt;a href=&#34;https://www.r-lidar.com/&#34;&gt;r-lidar&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The development of &lt;code&gt;lidR&lt;/code&gt; was made possible through the financial support of &lt;a href=&#34;https://www.ulaval.ca/en&#34;&gt;Laval University&lt;/a&gt;, the &lt;a href=&#34;https://awareproject.ca/&#34;&gt;AWARE project&lt;/a&gt; and &lt;a href=&#34;https://www.quebec.ca/en/government/ministere/ressources-naturelles-forets&#34;&gt;Ministry of Natural Ressources and Forests&lt;/a&gt; of Qu√©bec. To continue the development of this free software, we now offer consulting, programming, and training services. For more information, please visit &lt;a href=&#34;https://www.r-lidar.com/&#34;&gt;our website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Install dependencies on GNU/Linux&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Ubuntu&#xA;sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable&#xA;sudo apt-get update&#xA;sudo apt-get install libgdal-dev libgeos++-dev libudunits2-dev libproj-dev libx11-dev libgl1-mesa-dev libglu1-mesa-dev libfreetype6-dev libxt-dev libfftw3-dev&#xA;&#xA;# Fedora&#xA;sudo dnf install gdal-devel geos-devel udunits2-devel proj-devel mesa-libGL-devel mesa-libGLU-devel freetype-devel libjpeg-turbo-devel&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>tidyverse/ragnar</title>
    <updated>2025-06-05T01:35:56Z</updated>
    <id>tag:github.com,2025-06-05:/tidyverse/ragnar</id>
    <link href="https://github.com/tidyverse/ragnar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ragnar &lt;img src=&#34;https://raw.githubusercontent.com/tidyverse/ragnar/main/man/figures/logo.png&#34; align=&#34;right&#34; height=&#34;138&#34;&gt;&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tidyverse/ragnar/actions/workflows/R-CMD-check.yaml&#34;&gt;&lt;img src=&#34;https://github.com/tidyverse/ragnar/actions/workflows/R-CMD-check.yaml/badge.svg?sanitize=true&#34; alt=&#34;R-CMD-check&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;&lt;code&gt;ragnar&lt;/code&gt; is an R package that helps implement Retrieval-Augmented Generation (RAG) workflows. It focuses on providing a complete solution with sensible defaults, while still giving the knowledgeable user precise control over each steps. We don‚Äôt believe that you can fully automate the creation of a good RAG system, so it‚Äôs important that &lt;code&gt;ragnar&lt;/code&gt; is not a black box. &lt;code&gt;ragnar&lt;/code&gt; is designed to be transparent. You can inspect easily outputs at intermediate steps to understand what‚Äôs happening.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install ragnar from CRAN with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&#34;ragnar&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Key Steps&lt;/h2&gt; &#xA;&lt;h3&gt;1. Document Processing&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ragnar&lt;/code&gt; works with a wide variety of document types, using &lt;a href=&#34;https://github.com/microsoft/markitdown&#34;&gt;MarkItDown&lt;/a&gt; to convert content to Markdown.&lt;/p&gt; &#xA;&lt;p&gt;Key functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_read()&lt;/code&gt;: Convert a file or URL to a dataframe&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;read_as_markdown&lt;/code&gt;: Convert a file or URL to markdown&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_find_links()&lt;/code&gt;: Find all links in a webpage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;2. Text Chunking&lt;/h3&gt; &#xA;&lt;p&gt;Next we divide each document into chunks. Ragnar defaults to a strategy that preserves some of the semantics of the document, but provide plenty of opportunities to tweak the approach.&lt;/p&gt; &#xA;&lt;p&gt;Key functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_chunk()&lt;/code&gt;: Higher-level function that both identifies semantic boundaries and chunks text.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_segment()&lt;/code&gt;: Lower-level function that identifies semantic boundaries.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_chunk_segments()&lt;/code&gt;: Lower-level function that chunks pre-segmented text.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;3. Context Augmentation (Optional)&lt;/h3&gt; &#xA;&lt;p&gt;RAG applications benefit from augmenting text chunks with additional context, such as document headings and subheadings. &lt;code&gt;ragnar&lt;/code&gt; makes it easy to keep track of headings and subheadings as part of chunking, which can then be used to support template-based augmentation. (See examples below)&lt;/p&gt; &#xA;&lt;p&gt;Key functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_read()&lt;/code&gt;: Use &lt;code&gt;frame_by_tags&lt;/code&gt; and/or &lt;code&gt;split_by_tags&lt;/code&gt; arguments to associate text chunks with their document position.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;markdown_segment()&lt;/code&gt;: Segment markdown text into a character vector using semantic tags (e.g., headings, paragraphs, or code chunks).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;markdown_frame()&lt;/code&gt;: Convert markdown text into a dataframe.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;4. Embedding&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ragnar&lt;/code&gt; can help compute embeddings for each chunk. The goal is for &lt;code&gt;ragnar&lt;/code&gt; to provide access to embeddings from popular LLM providers. Currently &lt;code&gt;ollama&lt;/code&gt; and &lt;code&gt;openai&lt;/code&gt; providers are supported.&lt;/p&gt; &#xA;&lt;p&gt;Key functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;embed_ollama()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;embed_openai()&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that calling the embedding function directly is typically not necessary. Instead, the embedding function is specified when a store is first created, and then automatically called when needed by &lt;code&gt;ragnar_retreive()&lt;/code&gt; and &lt;code&gt;ragnar_store_insert()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;5. Storage&lt;/h3&gt; &#xA;&lt;p&gt;Processed data is stored in a format optimized for efficient searching, using &lt;code&gt;duckdb&lt;/code&gt; by default. The API is designed to be extensible, allowing additional packages to implement support for different storage providers.&lt;/p&gt; &#xA;&lt;p&gt;Key functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_store_create()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_store_connect()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_store_insert()&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;6. Retrieval&lt;/h3&gt; &#xA;&lt;p&gt;Given a prompt, retrieve related chunks based on embedding distance or bm25 text search.&lt;/p&gt; &#xA;&lt;p&gt;Key functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_retrieve()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_retrieve_vss()&lt;/code&gt;: Retrieve using &lt;a href=&#34;https://duckdb.org/docs/stable/core_extensions/vss&#34;&gt;&lt;code&gt;vss&lt;/code&gt; DuckDB extension&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_retrieve_bm25()&lt;/code&gt;: Retrieve using &lt;a href=&#34;https://duckdb.org/docs/stable/core_extensions/full_text_search&#34;&gt;&lt;code&gt;full-text search DuckDB extension&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;7. Chat Augmentation&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ragnar&lt;/code&gt; can equip an &lt;code&gt;ellmer::Chat&lt;/code&gt; object with a retrieve tool that enables an LLM to retreive content from a store on-demand.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ragnar_register_tool_retrieve(chat, store)&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Here‚Äôs an example of using &lt;code&gt;ragnar&lt;/code&gt; to create a knowledge store from the &lt;em&gt;R for Data Science (2e)&lt;/em&gt; book:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ragnar)&#xA;&#xA;base_url &amp;lt;- &#34;https://r4ds.hadley.nz&#34;&#xA;pages &amp;lt;- ragnar_find_links(base_url)&#xA;#&amp;gt; ‚†ô Finding links: 38 | On queue: 0 | Current depth: 0 | [0s]&#xA;&#xA;store_location &amp;lt;- &#34;r4ds.ragnar.duckdb&#34;&#xA;&#xA;store &amp;lt;- ragnar_store_create(&#xA;  store_location,&#xA;  embed = \(x) ragnar::embed_openai(x, model = &#34;text-embedding-3-small&#34;)&#xA;)&#xA;&#xA;&#xA;for (page in pages) {&#xA;  message(&#34;ingesting: &#34;, page)&#xA;  chunks &amp;lt;- page |&amp;gt;&#xA;    ragnar_read(frame_by_tags = c(&#34;h1&#34;, &#34;h2&#34;, &#34;h3&#34;)) |&amp;gt;&#xA;    ragnar_chunk(boundaries = c(&#34;paragraph&#34;, &#34;sentence&#34;)) |&amp;gt;&#xA;    # add context to chunks&#xA;    dplyr::mutate(&#xA;      text = glue::glue(&#xA;        r&#34;---(&#xA;        # Excerpt from the book &#34;R for Data Science (2e)&#34;&#xA;        link: {origin}&#xA;        chapter: {h1}&#xA;        section: {h2}&#xA;        subsection: {h3}&#xA;        content: {text}&#xA;&#xA;        )---&#34;&#xA;      )&#xA;    )&#xA;&#xA;  ragnar_store_insert(store, chunks)&#xA;}&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/arrow.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/base-R.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/communicate.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/communication.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/data-import.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/data-tidy.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/data-transform.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/data-visualize.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/databases.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/datetimes.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/EDA.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/factors.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/functions.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/import.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/intro.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/iteration.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/joins.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/layers.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/logicals.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/missing-values.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/numbers.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/preface-2e.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/program.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/quarto-formats.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/quarto.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/rectangling.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/regexps.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/spreadsheets.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/strings.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/transform.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/visualize.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/webscraping.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/whole-game.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/workflow-basics.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/workflow-help.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/workflow-scripts.html&#xA;#&amp;gt; ingesting: https://r4ds.hadley.nz/workflow-style.html&#xA;&#xA;&#xA;ragnar_store_build_index(store)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the store is set up, you can then retrieve the most relevant text chunks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#&#39; ## Retrieving Chunks&#xA;&#xA;library(ragnar)&#xA;store_location &amp;lt;- &#34;r4ds.ragnar.duckdb&#34;&#xA;store &amp;lt;- ragnar_store_connect(store_location, read_only = TRUE)&#xA;&#xA;text &amp;lt;- &#34;How can I subset a dataframe with a logical vector?&#34;&#xA;&#xA;&#xA;#&#39; # Retrieving Chunks&#xA;#&#39; Once the store is set up, retrieve the most relevant text chunks like this&#xA;&#xA;embedding_near_chunks &amp;lt;- ragnar_retrieve_vss(store, text, top_k = 3)&#xA;embedding_near_chunks&#xA;#&amp;gt; # A tibble: 3 √ó 6&#xA;#&amp;gt;      id metric_name     metric_value origin                          hash  text &#xA;#&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;                  &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                           &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;&#xA;#&amp;gt; 1   630 cosine_distance        0.394 https://r4ds.hadley.nz/logical‚Ä¶ 943f‚Ä¶ &#34;# E‚Ä¶&#xA;#&amp;gt; 2   653 cosine_distance        0.399 https://r4ds.hadley.nz/logical‚Ä¶ 943f‚Ä¶ &#34;# E‚Ä¶&#xA;#&amp;gt; 3   632 cosine_distance        0.401 https://r4ds.hadley.nz/logical‚Ä¶ 943f‚Ä¶ &#34;# E‚Ä¶&#xA;embedding_near_chunks$text[1] |&amp;gt; cat(sep = &#34;\n~~~~~~~~\n&#34;)&#xA;#&amp;gt; # Excerpt from the book &#34;R for Data Science (2e)&#34;&#xA;#&amp;gt; link: https://r4ds.hadley.nz/logicals.html&#xA;#&amp;gt; chapter: # 12&amp;nbsp; Logical vectors&#xA;#&amp;gt; section: ## 12.1 Introduction&#xA;#&amp;gt; subsection: NA&#xA;#&amp;gt; content: In this chapter, you‚Äôll learn tools for working with logical vectors. Logical vectors are the simplest type of vector because each element can only be one of three possible values: `TRUE`, `FALSE`, and `NA`. It‚Äôs relatively rare to find logical vectors in your raw data, but you‚Äôll create and manipulate them in the course of almost every analysis.&#xA;#&amp;gt; &#xA;#&amp;gt; We‚Äôll begin by discussing the most common way of creating logical vectors: with numeric comparisons. Then you‚Äôll learn about how you can use Boolean algebra to combine different logical vectors, as well as some useful summaries. We‚Äôll finish off with `[if_else()](https://dplyr.tidyverse.org/reference/if_else.html)` and `[case_when()](https://dplyr.tidyverse.org/reference/case_when.html)`, two useful functions for making conditional changes powered by logical vectors.&#xA;&#xA;bm25_near_chunks &amp;lt;- ragnar_retrieve_bm25(store, text, top_k = 3)&#xA;bm25_near_chunks&#xA;#&amp;gt; # A tibble: 3 √ó 6&#xA;#&amp;gt;      id metric_name metric_value origin                              hash  text &#xA;#&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;              &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                               &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;&#xA;#&amp;gt; 1   988 bm25               0.661 https://r4ds.hadley.nz/webscraping‚Ä¶ 8629‚Ä¶ &#34;# E‚Ä¶&#xA;#&amp;gt; 2   842 bm25               0.665 https://r4ds.hadley.nz/regexps.html 15ee‚Ä¶ &#34;# E‚Ä¶&#xA;#&amp;gt; 3   337 bm25               0.667 https://r4ds.hadley.nz/datetimes.h‚Ä¶ fd3e‚Ä¶ &#34;# E‚Ä¶&#xA;bm25_near_chunks$text[1] |&amp;gt; cat(sep = &#34;\n~~~~~~~~\n&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;#&amp;gt; # Excerpt from the book &#34;R for Data Science (2e)&#34;&#xA;#&amp;gt; link: https://r4ds.hadley.nz/webscraping.html&#xA;#&amp;gt; chapter: # 24&amp;nbsp; Web scraping&#xA;#&amp;gt; section: ## 24.4 Extracting data&#xA;#&amp;gt; subsection: ### 24.4.2 Nesting selections&#xA;#&amp;gt; content: In most cases, you‚Äôll use `[html_elements()](https://rvest.tidyverse.org/reference/html_element.html)` and `[html_element()](https://rvest.tidyverse.org/reference/html_element.html)` together, typically using `[html_elements()](https://rvest.tidyverse.org/reference/html_element.html)` to identify elements that will become observations then using `[html_element()](https://rvest.tidyverse.org/reference/html_element.html)` to find elements that will become variables. Let‚Äôs see this in action using a simple example. Here we have an unordered list (`&amp;lt;ul&amp;gt;)` where each list item (`&amp;lt;li&amp;gt;`) contains some information about four characters from StarWars:&#xA;#&amp;gt; &#xA;#&amp;gt; ```&#xA;#&amp;gt; html &amp;lt;- minimal_html(&#34;&#xA;#&amp;gt;   &amp;lt;ul&amp;gt;&#xA;#&amp;gt;     &amp;lt;li&amp;gt;&amp;lt;b&amp;gt;C-3PO&amp;lt;/b&amp;gt; is a &amp;lt;i&amp;gt;droid&amp;lt;/i&amp;gt; that weighs &amp;lt;span class=&#39;weight&#39;&amp;gt;167 kg&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&#xA;#&amp;gt;     &amp;lt;li&amp;gt;&amp;lt;b&amp;gt;R4-P17&amp;lt;/b&amp;gt; is a &amp;lt;i&amp;gt;droid&amp;lt;/i&amp;gt;&amp;lt;/li&amp;gt;&#xA;#&amp;gt;     &amp;lt;li&amp;gt;&amp;lt;b&amp;gt;R2-D2&amp;lt;/b&amp;gt; is a &amp;lt;i&amp;gt;droid&amp;lt;/i&amp;gt; that weighs &amp;lt;span class=&#39;weight&#39;&amp;gt;96 kg&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&#xA;#&amp;gt;     &amp;lt;li&amp;gt;&amp;lt;b&amp;gt;Yoda&amp;lt;/b&amp;gt; weighs &amp;lt;span class=&#39;weight&#39;&amp;gt;66 kg&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&#xA;#&amp;gt;   &amp;lt;/ul&amp;gt;&#xA;#&amp;gt;   &#34;)&#xA;#&amp;gt; ```&#xA;#&amp;gt; &#xA;#&amp;gt; We can use `[html_elements()](https://rvest.tidyverse.org/reference/html_element.html)` to make a vector where each element corresponds to a different character:&#xA;#&amp;gt; &#xA;#&amp;gt; ```&#xA;#&amp;gt; characters &amp;lt;- html |&amp;gt; html_elements(&#34;li&#34;)&#xA;#&amp;gt; characters&#xA;#&amp;gt; #&amp;gt; {xml_nodeset (4)}&#xA;#&amp;gt; #&amp;gt; [1] &amp;lt;li&amp;gt;\n&amp;lt;b&amp;gt;C-3PO&amp;lt;/b&amp;gt; is a &amp;lt;i&amp;gt;droid&amp;lt;/i&amp;gt; that weighs &amp;lt;span class=&#34;weight&#34;&amp;gt; ...&#xA;#&amp;gt; #&amp;gt; [2] &amp;lt;li&amp;gt;\n&amp;lt;b&amp;gt;R4-P17&amp;lt;/b&amp;gt; is a &amp;lt;i&amp;gt;droid&amp;lt;/i&amp;gt;\n&amp;lt;/li&amp;gt;&#xA;#&amp;gt; #&amp;gt; [3] &amp;lt;li&amp;gt;\n&amp;lt;b&amp;gt;R2-D2&amp;lt;/b&amp;gt; is a &amp;lt;i&amp;gt;droid&amp;lt;/i&amp;gt; that weighs &amp;lt;span class=&#34;weight&#34;&amp;gt; ...&#xA;#&amp;gt; #&amp;gt; [4] &amp;lt;li&amp;gt;\n&amp;lt;b&amp;gt;Yoda&amp;lt;/b&amp;gt; weighs &amp;lt;span class=&#34;weight&#34;&amp;gt;66 kg&amp;lt;/span&amp;gt;\n&amp;lt;/li&amp;gt;&#xA;#&amp;gt; ```&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;&#xA;# get both vss and bm26&#xA;relevant_chunks &amp;lt;- ragnar_retrieve(&#xA;  store,&#xA;  text,&#xA;  top_k = 3&#xA;)&#xA;relevant_chunks&#xA;#&amp;gt; # A tibble: 6 √ó 6&#xA;#&amp;gt;      id origin                                hash  text  cosine_distance   bm25&#xA;#&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;                                 &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;           &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;&#xA;#&amp;gt; 1   630 https://r4ds.hadley.nz/logicals.html  943f‚Ä¶ &#34;# E‚Ä¶           0.394 NA    &#xA;#&amp;gt; 2   653 https://r4ds.hadley.nz/logicals.html  943f‚Ä¶ &#34;# E‚Ä¶           0.399 NA    &#xA;#&amp;gt; 3   632 https://r4ds.hadley.nz/logicals.html  943f‚Ä¶ &#34;# E‚Ä¶           0.401 NA    &#xA;#&amp;gt; 4   988 https://r4ds.hadley.nz/webscraping.h‚Ä¶ 8629‚Ä¶ &#34;# E‚Ä¶          NA      0.661&#xA;#&amp;gt; 5   842 https://r4ds.hadley.nz/regexps.html   15ee‚Ä¶ &#34;# E‚Ä¶          NA      0.665&#xA;#&amp;gt; 6   337 https://r4ds.hadley.nz/datetimes.html fd3e‚Ä¶ &#34;# E‚Ä¶          NA      0.667&#xA;&#xA;#&#39;  Register ellmer tool&#xA;#&#39; You can register an ellmer tool to let the LLM retrieve chunks.&#xA;system_prompt &amp;lt;- stringr::str_squish(&#xA;  r&#34;--(&#xA;  You are an expert R programmer and mentor. You are concise.&#xA;  You always respond by first direct quoting material from book or documentation,&#xA;  then adding your own additional context and interpertation.&#xA;  Always include links to the source materials used.&#xA;  )--&#34;&#xA;)&#xA;chat &amp;lt;- ellmer::chat_openai(&#xA;  system_prompt,&#xA;  model = &#34;gpt-4.1&#34;,&#xA;  params = ellmer::params(temperature = .5)&#xA;)&#xA;&#xA;ragnar_register_tool_retrieve(chat, store, top_k = 10)&#xA;&#xA;chat$chat(&#34;How can I subset a dataframe?&#34;)&#xA;#&amp;gt; ‚óØ [tool call] rag_retrieve_from_store_001(text = &#34;subset a dataframe&#34;)&#xA;#&amp;gt; ‚óè #&amp;gt; # Excerpt from the book &#34;R for Data Science (2e)&#34;&#xA;#&amp;gt;   #&amp;gt; link: https://r4ds.hadley.nz/functions.html&#xA;#&amp;gt;   #&amp;gt; chapter: # 25  Functions&#xA;#&amp;gt;   #&amp;gt; section: ## 25.3 Data frame functions&#xA;#&amp;gt;   #&amp;gt; subsection: ### 25.3.3 Common use cases&#xA;#&amp;gt;   #&amp;gt; ‚Ä¶&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;#&amp;gt; From &#34;R for Data Science (2e)&#34;:&#xA;#&amp;gt; &#xA;#&amp;gt; &amp;gt; Several dplyr verbs are special cases of `[`:  &#xA;#&amp;gt; &amp;gt; &#xA;#&amp;gt; &amp;gt; * `[filter()](https://dplyr.tidyverse.org/reference/filter.html)` is &#xA;#&amp;gt; equivalent to subsetting the rows with a logical vector, taking care to exclude&#xA;#&amp;gt; missing values:&#xA;#&amp;gt; &amp;gt; &#xA;#&amp;gt; &amp;gt;   ```&#xA;#&amp;gt; &amp;gt;   df |&amp;gt; filter(x &amp;gt; 1)&#xA;#&amp;gt; &amp;gt;   # same as&#xA;#&amp;gt; &amp;gt;   df[!is.na(df$x) &amp;amp; df$x &amp;gt; 1, ]&#xA;#&amp;gt; &amp;gt;   ```&#xA;#&amp;gt; &amp;gt; * Both `[select()](https://dplyr.tidyverse.org/reference/select.html)` and &#xA;#&amp;gt; `[relocate()](https://dplyr.tidyverse.org/reference/relocate.html)` are similar&#xA;#&amp;gt; to subsetting the columns with a character vector:&#xA;#&amp;gt; &amp;gt; &#xA;#&amp;gt; &amp;gt;   ```&#xA;#&amp;gt; &amp;gt;   df |&amp;gt; select(x, z)&#xA;#&amp;gt; &amp;gt;   # same as&#xA;#&amp;gt; &amp;gt;   df[, c(&#34;x&#34;, &#34;z&#34;)]&#xA;#&amp;gt; &amp;gt;   ```&#xA;#&amp;gt; &amp;gt; &#xA;#&amp;gt; &amp;gt; Base R also provides a function that combines the features of `filter()` and &#xA;#&amp;gt; `select()` called [`subset()`](https://rdrr.io/r/base/subset.html):&#xA;#&amp;gt; &#xA;#&amp;gt; &amp;gt; ```&#xA;#&amp;gt; &amp;gt; df |&amp;gt; filter(x &amp;gt; 1) |&amp;gt; select(y, z)&#xA;#&amp;gt; &amp;gt; # same as&#xA;#&amp;gt; &amp;gt; df |&amp;gt; subset(x &amp;gt; 1, c(y, z))&#xA;#&amp;gt; &amp;gt; ```&#xA;#&amp;gt; &#xA;#&amp;gt; ([source](https://r4ds.hadley.nz/base-R.html#selecting-multiple-elements-with))&#xA;#&amp;gt; &#xA;#&amp;gt; Additional context:&#xA;#&amp;gt; &#xA;#&amp;gt; - **Base R**:  &#xA;#&amp;gt;   - Subset rows: `df[rows, ]` (where `rows` is a logical or integer vector)&#xA;#&amp;gt;   - Subset columns: `df[, cols]` (where `cols` is a name, number, or character &#xA;#&amp;gt; vector)&#xA;#&amp;gt;   - Both: `df[rows, cols]`&#xA;#&amp;gt;   - Use `drop = FALSE` to always return a data frame: `df[, &#34;x&#34;, drop = FALSE]`&#xA;#&amp;gt; &#xA;#&amp;gt; - **dplyr** (tidyverse):  &#xA;#&amp;gt;   - Subset rows: `df |&amp;gt; filter(condition)`&#xA;#&amp;gt;   - Subset columns: `df |&amp;gt; select(col1, col2)`&#xA;#&amp;gt;   - Both: `df |&amp;gt; filter(condition) |&amp;gt; select(col1, col2)`&#xA;#&amp;gt; &#xA;#&amp;gt; - **subset()**:  &#xA;#&amp;gt;   - `subset(df, condition, select = c(cols))`&#xA;#&amp;gt; &#xA;#&amp;gt; Choose the style that matches your workflow (base R or tidyverse).  &#xA;#&amp;gt; - For more: [dplyr filter](https://dplyr.tidyverse.org/reference/filter.html), &#xA;#&amp;gt; [dplyr select](https://dplyr.tidyverse.org/reference/select.html), &#xA;#&amp;gt; [base::subset](https://rdrr.io/r/base/subset.html).&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>