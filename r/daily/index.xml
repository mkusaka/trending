<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub R Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-11T01:44:03Z</updated>
  <subtitle>Daily Trending of R in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>yukiyanai/rgamer</title>
    <updated>2023-03-11T01:44:03Z</updated>
    <id>tag:github.com,2023-03-11:/yukiyanai/rgamer</id>
    <link href="https://github.com/yukiyanai/rgamer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;rgamer: An R package for teaching and learning game theory&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rgamer &lt;img src=&#34;https://raw.githubusercontent.com/yukiyanai/rgamer/master/logo.png&#34; align=&#34;right&#34; alt=&#34;&#34; width=&#34;120&#34;&gt;&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://lifecycle.r-lib.org/articles/stages.html#stable&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/lifecycle-stable-green.svg?sanitize=true&#34; alt=&#34;Lifecycle: stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://CRAN.R-project.org/package=rgamer&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version/rgamer&#34; alt=&#34;CRAN status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/yukiyanai/rgamer&#34;&gt;&lt;img src=&#34;https://travis-ci.org/yukiyanai/rgamer.svg?branch=master&#34; alt=&#34;Travis build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/yukiyanai/rgamer?branch=master&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/yukiyanai/rgamer/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;Codecov test coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/yukiyanai/rgamer/actions&#34;&gt;&lt;img src=&#34;https://github.com/yukiyanai/rgamer/workflows/R-CMD-check/badge.svg?sanitize=true&#34; alt=&#34;R-CMD-check&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The goal of &lt;code&gt;rgamer&lt;/code&gt; is to help students learn Game Theory using R. The functions prepared by the package not only solve basic games such as two-person normal-form games but also provides the users with visual displays that highlight some aspects of the games — payoff matrix, best response correspondence, etc. In addition, it suggests some numerical solutions for games of which it is difficult — or even seems impossible — to derive a closed-form analytical solution.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;!--&#xA;#You can install the released version of rgamer from [CRAN](https://CRAN.R-project.org) with:&#xA;&#xA;```r&#xA;install.packages(&#34;rgamer&#34;)&#xA;#&gt; Warning: package &#39;rgamer&#39; is not available for this version of R&#xA;#&gt; &#xA;#&gt; A version of this package for your version of R might be available elsewhere,&#xA;#&gt; see the ideas at&#xA;#&gt; https://cran.r-project.org/doc/manuals/r-patched/R-admin.html#Installing-packages&#xA;```&#xA;--&gt; &#xA;&lt;p&gt;You can install the development version from &lt;a href=&#34;https://github.com/&#34;&gt;GitHub&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;remotes&#34;)&#xA;remotes::install_github(&#34;yukiyanai/rgamer&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# install.packages(&#34;devtools&#34;)&#xA;devtools::install_github(&#34;yukiyanai/rgamer&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(rgamer)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example 1&lt;/h3&gt; &#xA;&lt;p&gt;An example of a normal-form game (prisoner’s dilemma).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Player: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7B&#34; alt=&#34;\{&#34; title=&#34;{&#34;&gt;Kamijo, Yanai&lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7D&#34; alt=&#34;\}&#34; title=&#34;}&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Strategy: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7B&#34; alt=&#34;\{&#34; title=&#34;{&#34;&gt;(Stays silent, Betrays), (Stays silent, Betrays)&lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7D&#34; alt=&#34;\}&#34; title=&#34;}&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Payoff: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7B&#34; alt=&#34;\{&#34; title=&#34;{&#34;&gt;(-1, 0, -3, -2), (-1, -3, 0, -2)&lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7D&#34; alt=&#34;\}&#34; title=&#34;}&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;First, you define the game by &lt;code&gt;normal_form()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;game1 &amp;lt;- normal_form(&#xA;  players = c(&#34;Kamijo&#34;, &#34;Yanai&#34;),&#xA;  s1 = c(&#34;Stays silent&#34;, &#34;Betrays&#34;), &#xA;  s2 = c(&#34;Stays silent&#34;, &#34;Betrays&#34;), &#xA;  payoffs1 = c(-1,  0, -3, -2), &#xA;  payoffs2 = c(-1, -3,  0, -2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can specify payoffs for each cell of the game matrix as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;game1b &amp;lt;- normal_form(&#xA;  players = c(&#34;Kamijo&#34;, &#34;Yanai&#34;),&#xA;  s1 = c(&#34;Stays silent&#34;, &#34;Betrays&#34;), &#xA;  s2 = c(&#34;Stays silent&#34;, &#34;Betrays&#34;), &#xA;  cells = list(c(-1, -1), c(-3,  0),&#xA;               c( 0, -3), c(-2, -2)),&#xA;  byrow = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can pass it to &lt;code&gt;solve_nfg()&lt;/code&gt; function to get the table of the game and the Nash equilibrium.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s_game1 &amp;lt;- solve_nfg(game1, show_table = FALSE)&#xA;#&amp;gt; Pure-strategy NE: [Betrays, Betrays]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s_game1$table&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table class=&#34; lightable-classic table&#34; style=&#34;font-family: Arial; margin-left: auto; margin-right: auto; width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th style=&#34;empty-cells: hide;&#34; colspan=&#34;2&#34;&gt; &lt;/th&gt; &#xA;   &lt;th style=&#34;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; font-weight: bold; &#34; colspan=&#34;2&#34;&gt; &#xA;    &lt;div style=&#34;border-bottom: 1px solid #111111; margin-bottom: -1px; &#34;&gt; &#xA;     &lt;p&gt;Yanai&lt;/p&gt; &#xA;    &lt;/div&gt; &lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th style=&#34;text-align:left;&#34;&gt; &lt;/th&gt; &#xA;   &lt;th style=&#34;text-align:center;&#34;&gt; strategy &lt;/th&gt; &#xA;   &lt;th style=&#34;text-align:center;&#34;&gt; Stays silent &lt;/th&gt; &#xA;   &lt;th style=&#34;text-align:center;&#34;&gt; Betrays &lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td style=&#34;text-align:left;font-weight: bold;&#34;&gt; Kamijo &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; Stays silent &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; -1, -1 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; -3, 0^ &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td style=&#34;text-align:left;font-weight: bold;&#34;&gt; &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; Betrays &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0^, -3 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; -2^, -2^ &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Example 2&lt;/h3&gt; &#xA;&lt;p&gt;An example of a coordination game.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Player: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7B&#34; alt=&#34;\{&#34; title=&#34;{&#34;&gt;Kamijo, Yanai &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7D&#34; alt=&#34;\}&#34; title=&#34;}&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Strategy: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7B&#34; alt=&#34;\{&#34; title=&#34;{&#34;&gt;(Stag, Hare), (Stag, Hare)&lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7D&#34; alt=&#34;\}&#34; title=&#34;}&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Payoff: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7B&#34; alt=&#34;\{&#34; title=&#34;{&#34;&gt;(10, 8, 0, 7), (10, 0, 8, 7)&lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7D&#34; alt=&#34;\}&#34; title=&#34;}&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Define the game by &lt;code&gt;normal_form()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;game2 &amp;lt;- normal_form(&#xA;  players = c(&#34;Kamijo&#34;, &#34;Yanai&#34;),&#xA;  s1 = c(&#34;Stag&#34;, &#34;Hare&#34;), &#xA;  s2 = c(&#34;Stag&#34;, &#34;Hare&#34;), &#xA;  payoffs1 = c(10, 8, 0, 7), &#xA;  payoffs2 = c(10, 0, 8, 7))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can pass it to &lt;code&gt;solve_nfg()&lt;/code&gt; function to get NEs. Set &lt;code&gt;mixed = TRUE&lt;/code&gt; to find mixed-strategy NEs well.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s_game2 &amp;lt;- solve_nfg(game2, mixed = TRUE, show_table = FALSE)&#xA;#&amp;gt; Pure-strategy NE: [Stag, Stag], [Hare, Hare]&#xA;#&amp;gt; Mixed-strategy NE: [(7/9, 2/9), (7/9, 2/9)]&#xA;#&amp;gt; The obtained mixed-strategy NE might be only a part of the solutions.&#xA;#&amp;gt; Please examine br_plot (best response plot) carefully.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a 2-by-2 game, you can plot the best response correspondences as well.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s_game2$br_plot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yukiyanai/rgamer/master/man/figures/README-unnamed-chunk-13-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Example 3&lt;/h3&gt; &#xA;&lt;p&gt;An example of a normal-form game:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Player: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7BA%2C%20B%5C%7D&#34; alt=&#34;\{A, B\}&#34; title=&#34;{A, B}&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Strategy: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7Bx%20%5Cin%20%5B0%2C%2030%5D%2C%20y%20%5Cin%20%5B0%2C%2030%5D%20%5C%7D&#34; alt=&#34;\{x \in [0, 30], y \in [0, 30] \}&#34; title=&#34;{x \in [0, 30], y \in [0, 30] }&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Payoff: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7Bf_x%28x%2C%20y%29%20%3D%20-x%5E2%20%2B%20%2828%20-%20y%29x%2C%20f_y%28x%2C%20y%29%20%3D%20-y%5E2%20%2B%20%2828%20-%20x%29%20y%5C%7D&#34; alt=&#34;\{f_x(x, y) = -x^2 + (28 - y)x, f_y(x, y) = -y^2 + (28 - x) y\}&#34; title=&#34;{f_x(x, y) = -x^2 + (28 - y)x, f_y(x, y) = -y^2 + (28 - x) y}&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can define a game by specifying payoff functions as character vectors using &lt;code&gt;normal_form()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;game3 &amp;lt;- normal_form(&#xA;  players = c(&#34;A&#34;, &#34;B&#34;),&#xA;  payoffs1 = &#34;-x^2 + (28 - y) * x&#34;,&#xA;  payoffs2 = &#34;-y^2 + (28 - x) * y&#34;,&#xA;  par1_lim = c(0, 30),&#xA;  par2_lim = c(0, 30),&#xA;  pars = c(&#34;x&#34;, &#34;y&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can pass it to &lt;code&gt;solve_nfg()&lt;/code&gt;, which displays the best response correspondences by default.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s_game3 &amp;lt;- solve_nfg(game3)&#xA;#&amp;gt; approximated NE: (9.3, 9.3)&#xA;#&amp;gt; The obtained NE might be only a part of the solutions.&#xA;#&amp;gt; Please examine br_plot (best response plot) carefully.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yukiyanai/rgamer/master/man/figures/README-unnamed-chunk-15-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Example 4&lt;/h3&gt; &#xA;&lt;p&gt;An example of a normal-form game:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Player: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7B%20A%2C%20B%20%5C%7D&#34; alt=&#34;\{ A, B \}&#34; title=&#34;{ A, B }&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Strategy: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7Bx%20%5Cin%20%5B0%2C%2030%5D%2C%20y%20%5Cin%20%5B0%2C%2030%5D%5C%7D&#34; alt=&#34;\{x \in [0, 30], y \in [0, 30]\}&#34; title=&#34;{x \in [0, 30], y \in [0, 30]}&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Payoff: &lt;img src=&#34;https://latex.codecogs.com/png.latex?%5C%7Bf_x%28x%2C%20y%29%20%3D%20-x%5Ea%20%2B%20%28b%20-%20y%29x%2C%20f_y%28x%2C%20y%29%20%3D%20-y%5Es%20%2B%20%28t%20-%20x%29%20y%5C%7D&#34; alt=&#34;\{f_x(x, y) = -x^a + (b - y)x, f_y(x, y) = -y^s + (t - x) y\}&#34; title=&#34;{f_x(x, y) = -x^a + (b - y)x, f_y(x, y) = -y^s + (t - x) y}&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can define a normal-form game by specifying payoffs by R functions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;f_x &amp;lt;- function(x, y, a, b) {&#xA;  -x^a + (b - y) * x&#xA;}&#xA;f_y &amp;lt;- function(x, y, s, t) {&#xA;  -y^s + (t - x) * y&#xA;}&#xA;game4 &amp;lt;- normal_form(&#xA;  players = c(&#34;A&#34;, &#34;B&#34;),&#xA;  payoffs1 = f_x,&#xA;  payoffs2 = f_y,&#xA;  par1_lim = c(0, 30),&#xA;  par2_lim = c(0, 30),&#xA;  pars = c(&#34;x&#34;, &#34;y&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can approximate a solution numerically by &lt;code&gt;solve_nfg()&lt;/code&gt;. Note that you need to set the parameter values of the function that should be treated as constants by arguments &lt;code&gt;cons1&lt;/code&gt; and &lt;code&gt;cons2&lt;/code&gt;, each of which accepts a named list. In addition, you can suppress the plot of best responses by &lt;code&gt;plot = FALSE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s_game4 &amp;lt;- solve_nfg(&#xA;  game = game4,&#xA;  cons1 = list(a = 2, b = 28),&#xA;  cons2 = list(s = 2, t = 28),&#xA;  plot = FALSE)&#xA;#&amp;gt; approximated NE: (9.3, 9.3)&#xA;#&amp;gt; The obtained NE might be only a part of the solutions.&#xA;#&amp;gt; Please examine br_plot (best response plot) carefully.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can increase the precision of approximation by &lt;code&gt;precision&lt;/code&gt;, which takes a natural number (default is &lt;code&gt;precision = 1&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s_game4b &amp;lt;- solve_nfg(&#xA;  game = game4,&#xA;  cons1 = list(a = 2, b = 28),&#xA;  cons2 = list(s = 2, t = 28),&#xA;  precision = 3)&#xA;#&amp;gt; approximated NE: (9.333, 9.333)&#xA;#&amp;gt; The obtained NE might be only a part of the solutions.&#xA;#&amp;gt; Please examine br_plot (best response plot) carefully.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yukiyanai/rgamer/master/man/figures/README-unnamed-chunk-18-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can extract the best response plot with NE marked as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s_game4b$br_plot_NE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yukiyanai/rgamer/master/man/figures/README-unnamed-chunk-19-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Example 5&lt;/h2&gt; &#xA;&lt;p&gt;You can define payoffs by R functions and evaluate them at some discretized values by setting &lt;code&gt;discretize = TRUE&lt;/code&gt;. The following is a Bertrand competition example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;func_price1 &amp;lt;- function(p, q) {&#xA;  if (p &amp;lt; q) {&#xA;    profit &amp;lt;- p&#xA;  } else if (p == q) {&#xA;    profit &amp;lt;- 0.5 * p&#xA;  } else {&#xA;    profit &amp;lt;- 0&#xA;  }&#xA;  profit&#xA;}&#xA;&#xA;func_price2 &amp;lt;- function(p, q){&#xA;  if (p &amp;gt; q) {&#xA;    profit &amp;lt;- q&#xA;  } else if (p == q) {&#xA;    profit &amp;lt;- 0.5 * q&#xA;  } else {&#xA;    profit &amp;lt;- 0&#xA;  }&#xA;  profit&#xA;}&#xA;&#xA;game5 &amp;lt;- normal_form(&#xA;  payoffs1 = func_price1,&#xA;  payoffs2 = func_price2,&#xA;  pars = c(&#34;p&#34;, &#34;q&#34;),&#xA;  par1_lim = c(0, 10),&#xA;  par2_lim = c(0, 10),&#xA;  discretize = TRUE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can examine the specified part of the game.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s_game5 &amp;lt;- solve_nfg(game5, mark_br = FALSE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table class=&#34; lightable-classic table&#34; style=&#34;font-family: Arial; margin-left: auto; margin-right: auto; width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th style=&#34;empty-cells: hide;&#34; colspan=&#34;2&#34;&gt; &lt;/th&gt; &#xA;   &lt;th style=&#34;padding-bottom:0; padding-left:3px;padding-right:3px;text-align: center; font-weight: bold; &#34; colspan=&#34;6&#34;&gt; &#xA;    &lt;div style=&#34;border-bottom: 1px solid #111111; margin-bottom: -1px; &#34;&gt; &#xA;     &lt;p&gt;Player 2&lt;/p&gt; &#xA;    &lt;/div&gt; &lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th style=&#34;text-align:left;&#34;&gt; &lt;/th&gt; &#xA;   &lt;th style=&#34;text-align:center;&#34;&gt; strategy &lt;/th&gt; &#xA;   &lt;th style=&#34;text-align:center;&#34;&gt; 0 &lt;/th&gt; &#xA;   &lt;th style=&#34;text-align:center;&#34;&gt; 2 &lt;/th&gt; &#xA;   &lt;th style=&#34;text-align:center;&#34;&gt; 4 &lt;/th&gt; &#xA;   &lt;th style=&#34;text-align:center;&#34;&gt; 6 &lt;/th&gt; &#xA;   &lt;th style=&#34;text-align:center;&#34;&gt; 8 &lt;/th&gt; &#xA;   &lt;th style=&#34;text-align:center;&#34;&gt; 10 &lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td style=&#34;text-align:left;font-weight: bold;&#34;&gt; Player 1 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td style=&#34;text-align:left;font-weight: bold;&#34;&gt; &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 2 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 1, 1 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 2, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 2, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 2, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 2, 0 &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td style=&#34;text-align:left;font-weight: bold;&#34;&gt; &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 4 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 2 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 2, 2 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 4, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 4, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 4, 0 &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td style=&#34;text-align:left;font-weight: bold;&#34;&gt; &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 6 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 2 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 4 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 3, 3 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 6, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 6, 0 &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td style=&#34;text-align:left;font-weight: bold;&#34;&gt; &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 8 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 2 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 4 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 6 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 4, 4 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 8, 0 &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td style=&#34;text-align:left;font-weight: bold;&#34;&gt; &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 10 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 0 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 2 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 4 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 6 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 0, 8 &lt;/td&gt; &#xA;   &lt;td style=&#34;text-align:center;&#34;&gt; 5, 5 &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Example 6&lt;/h2&gt; &#xA;&lt;p&gt;You can draw a tree of an extensive form game.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;game6 &amp;lt;- extensive_form(&#xA;  players = list(&#34;Yanai&#34;, &#xA;                 rep(&#34;Kamijo&#34;, 2),&#xA;                 rep(NA, 4)),&#xA;  actions = list(c(&#34;stat&#34;, &#34;game&#34;),&#xA;                  c(&#34;stat&#34;, &#34;game&#34;), c(&#34;stat&#34;, &#34;game&#34;)),&#xA;  payoffs = list(Yanai = c(2, 0, 0, 1),&#xA;                 Kamijo = c(1, 0, 0, 2)),&#xA;  direction = &#34;right&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yukiyanai/rgamer/master/man/figures/README-unnamed-chunk-23-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt; &#xA;&lt;p&gt;And you can find the solution of the game by &lt;code&gt;solve_efg()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s_game6 &amp;lt;- solve_efg(game6)&#xA;#&amp;gt; backward induction: [(stat), (stat, game)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can see the path played under a solution by &lt;code&gt;show_path()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;show_path(s_game6)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yukiyanai/rgamer/master/man/figures/README-unnamed-chunk-25-1.png&#34; alt=&#34;&#34;&gt;&#xA; &lt;!-- --&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>const-ae/lemur</title>
    <updated>2023-03-11T01:44:03Z</updated>
    <id>tag:github.com,2023-03-11:/const-ae/lemur</id>
    <link href="https://github.com/const-ae/lemur" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Latent Embedding Multivariate Regression&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Latent Embedding Multivariate Regression (LEMUR)&lt;/h1&gt; &#xA;&lt;!-- badges: start --&gt; &#xA;&lt;!-- badges: end --&gt; &#xA;&lt;p&gt;The goal of lemur is to enable easy analysis of multi-condition single-cell data. Lemur fits latent embedding regression, which means that it tries to find the PCA embedding for each condition and parameterizes the transition from one embedding to the other. For this task, lemur uses geodesic regression on the Grassmann manifold, which is solved efficiently using tangent-space linear modelling. The result is an interpretable model of the gene expression for arbitrary experimental designs that can be expressed using a design matrix.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Lemur depends on features from &lt;a href=&#34;https://github.com/const-ae/glmGamPoi&#34;&gt;&lt;code&gt;glmGamPoi&lt;/code&gt;&lt;/a&gt; which are only available in the development version, so please install &lt;code&gt;glmGamPoi&lt;/code&gt; from Github before proceeding with lemur’s installation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;devtools::install_github(&#34;const-ae/glmGamPoi&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can install the released version of lemur from Github&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;devtools::install_github(&#34;const-ae/lemur&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;A word of caution&lt;/h2&gt; &#xA;&lt;p&gt;This package is being actively developed and I am still making breaking changes. I am delighted if you decide to try out the package and please open an issue if you think you found a bug, have an idea for a cool feature, or any question about how LEMUR works. Consider this a &lt;em&gt;beta&lt;/em&gt; release with the goal to gather feedback but be aware that code written against the current version of lemur might not work in the future.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(lemur)&#xA;library(SingleCellExperiment)&#xA;&#xA;fit &amp;lt;- lemur(sce, design = ~ patient_id + condition, n_embedding = 15)&#xA;fit &amp;lt;- align_harmony(fit)   # This step is optional&#xA;fit &amp;lt;- test_de(fit, contrast = cond(condition = &#34;ctrl&#34;) - cond(condition = &#34;panobinostat&#34;))&#xA;nei &amp;lt;- find_de_neighborhoods(fit, counts = counts(sce), group_by = vars(patient_id, condition))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;We will demonstrate &lt;code&gt;lemur&lt;/code&gt; using a dataset by Zhao et al.&amp;nbsp;(2021). The data consists of tumor biopsies from five glioblastomas which were treated using panobinostat or used as a control. Accordingly there are ten samples (patient-treatment combinations) which we will analyze using a paired experimental design.&lt;/p&gt; &#xA;&lt;p&gt;We start by loading some packages which are necessary to analyze the data:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(tidyverse)&#xA;library(SingleCellExperiment)&#xA;library(lemur)&#xA;set.seed(1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use a reduced-size version of the glioblastoma data that ships with the &lt;code&gt;lemur&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lemur::glioblastoma_example_data&#xA;#&amp;gt; class: SingleCellExperiment &#xA;#&amp;gt; dim: 300 5000 &#xA;#&amp;gt; metadata(0):&#xA;#&amp;gt; assays(2): counts logcounts&#xA;#&amp;gt; rownames(300): ENSG00000210082 ENSG00000118785 ... ENSG00000167468&#xA;#&amp;gt;   ENSG00000139289&#xA;#&amp;gt; rowData names(6): gene_id symbol ... strand. source&#xA;#&amp;gt; colnames(5000): CGCCAGAGCGCA AGCTTTACTGCG ... TGAACAGTGCGT TGACCGGAATGC&#xA;#&amp;gt; colData names(10): patient_id treatment_id ... sample_id id&#xA;#&amp;gt; reducedDimNames(0):&#xA;#&amp;gt; mainExpName: NULL&#xA;#&amp;gt; altExpNames(0):&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Initially, the data separates by the known covariates &lt;code&gt;patient_id&lt;/code&gt; and &lt;code&gt;condition&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;orig_umap &amp;lt;- uwot::umap(as.matrix(t(logcounts(glioblastoma_example_data))))&#xA;&#xA;as_tibble(orig_umap) %&amp;gt;%&#xA;  bind_cols(as_tibble(colData(glioblastoma_example_data))) %&amp;gt;%&#xA;  ggplot(aes(x = V1, y = V2)) +&#xA;    geom_point(aes(color = patient_id, shape = condition), size = 0.5) +&#xA;    labs(title = &#34;UMAP of logcounts&#34;)&#xA;#&amp;gt; Warning: The `x` argument of `as_tibble.matrix()` must have unique column names if&#xA;#&amp;gt; `.name_repair` is omitted as of tibble 2.0.0.&#xA;#&amp;gt; ℹ Using compatibility `.name_repair`.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/const-ae/lemur/master/man/figures/README-raw_umap-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;p&gt;We fit the LEMUR model by calling &lt;code&gt;lemur()&lt;/code&gt;. We provide the experimental design using a formula. The elements of the formula can refer to columns of the &lt;code&gt;colData&lt;/code&gt; of the &lt;code&gt;SingleCellExperiment&lt;/code&gt; object. We also set the number of latent dimensions which has a similar interpretation as the number of dimensions in PCA. Optionally, we can further align corresponding cells either using manually annotated cell types (&lt;code&gt;align_by_grouping&lt;/code&gt;) or an automated alignment procedure (e.g., &lt;code&gt;align_harmony&lt;/code&gt;, &lt;code&gt;align_neighbors&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fit &amp;lt;- lemur(glioblastoma_example_data, design = ~ patient_id + condition, n_embedding = 15, verbose = FALSE)&#xA;&#xA;# We can regularize the alignment either using ridge regression&#xA;# or by allowing only rotations or stretching&#xA;fit &amp;lt;- align_harmony(fit, stretching = FALSE)&#xA;#&amp;gt; Select cells that are considered close with &#39;harmony&#39;&#xA;&#xA;fit&#xA;#&amp;gt; class: lemur_fit &#xA;#&amp;gt; dim: 300 5000 &#xA;#&amp;gt; metadata(12): n_ambient n_embedding ... alignment_design&#xA;#&amp;gt;   alignment_design_matrix&#xA;#&amp;gt; assays(1): expr&#xA;#&amp;gt; rownames(300): ENSG00000210082 ENSG00000118785 ... ENSG00000167468&#xA;#&amp;gt;   ENSG00000139289&#xA;#&amp;gt; rowData names(6): gene_id symbol ... strand. source&#xA;#&amp;gt; colnames(5000): CGCCAGAGCGCA AGCTTTACTGCG ... TGAACAGTGCGT TGACCGGAATGC&#xA;#&amp;gt; colData names(10): patient_id treatment_id ... sample_id id&#xA;#&amp;gt; reducedDimNames(2): linearFit embedding&#xA;#&amp;gt; mainExpName: NULL&#xA;#&amp;gt; altExpNames(0):&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;lemur()&lt;/code&gt; function returns an object that extends &lt;code&gt;SingleCellExperiment&lt;/code&gt; and thus supports subsetting and all the familiar data acessor methods (e.g., &lt;code&gt;nrow&lt;/code&gt;, &lt;code&gt;assay&lt;/code&gt;, &lt;code&gt;colData&lt;/code&gt;, &lt;code&gt;rowData&lt;/code&gt;). In addition, &lt;code&gt;lemur&lt;/code&gt; overloads the &lt;code&gt;$&lt;/code&gt; operator to allow easy access to additional fields that are produced by the LEMUR model. For example the low-dimensional embedding can be accessed using &lt;code&gt;fit$embedding&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;umap &amp;lt;- uwot::umap(t(fit$embedding))&#xA;&#xA;as_tibble(umap) %&amp;gt;%&#xA;  bind_cols(as_tibble(fit$colData)) %&amp;gt;%&#xA;  ggplot(aes(x = V1, y = V2)) +&#xA;    geom_point(aes(color = patient_id, shape = condition), size = 0.5) +&#xA;    labs(title = &#34;UMAP of latent space from LEMUR&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/const-ae/lemur/master/man/figures/README-lemur_umap-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;p&gt;The &lt;code&gt;test_de&lt;/code&gt; function takes a &lt;code&gt;lemur_fit_obj&lt;/code&gt; and returns with a new assay &lt;code&gt;&#34;DE&#34;&lt;/code&gt; with the predicted difference between two conditions specified in the &lt;code&gt;contrast&lt;/code&gt;. Note that &lt;code&gt;lemur&lt;/code&gt; implements a special notation for contrasts. Instead of providing a contrast vector or design matrix column names, you provide for each &lt;em&gt;condition&lt;/em&gt; the levels and &lt;code&gt;lemur&lt;/code&gt; automatically forms the contrast vector. This makes the contrast more readable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fit &amp;lt;- test_de(fit, contrast = cond(condition = &#34;panobinostat&#34;) - cond(condition = &#34;ctrl&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can pick any gene and show the differential expression pattern on the UMAP plot:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# EEF1A1&#xA;gene_sel &amp;lt;- &#34;ENSG00000156508&#34;&#xA;&#xA;as_tibble(umap) %&amp;gt;%&#xA;  mutate(expr = assay(fit, &#34;DE&#34;)[gene_sel,]) %&amp;gt;%&#xA;  ggplot(aes(x = V1, y = V2)) +&#xA;    geom_point(aes(color = expr)) +&#xA;    scale_color_gradient2() +&#xA;    labs(title = &#34;Differential expression on UMAP plot&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/const-ae/lemur/master/man/figures/README-umap_de-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;p&gt;Alternatively, we can use the matrix of differential expression values (&lt;code&gt;assay(fit, &#34;DE&#34;)&lt;/code&gt;) to guide the selection of cell neighborhoods that show consistent differential expression. If we provide a count matrix, the function uses a pseudobulked differential expression test to confirm the gene expression differences on the count level.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;neighborhoods &amp;lt;- find_de_neighborhoods(fit, counts = counts(glioblastoma_example_data),&#xA;                                      group_by = vars(patient_id, condition),&#xA;                                      include_complement = FALSE, verbose = FALSE)&#xA;#&amp;gt; dimnames(.) &amp;lt;- NULL translated to&#xA;#&amp;gt; dimnames(.) &amp;lt;- list(NULL,NULL)&#xA;as_tibble(neighborhoods) %&amp;gt;%&#xA;  arrange(pval) %&amp;gt;%&#xA;  left_join(as_tibble(rowData(fit)), by = c(&#34;name&#34; = &#34;gene_id&#34;))&#xA;#&amp;gt; # A tibble: 300 × 16&#xA;#&amp;gt;    name        region indices n_cells   mean    pval adj_p…¹ f_sta…²   df1   df2&#xA;#&amp;gt;    &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt;  &amp;lt;I&amp;lt;lis&amp;gt;   &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;&#xA;#&amp;gt;  1 ENSG000001… 1      &amp;lt;int&amp;gt;      3780  1.32  8.71e-6 0.00261   140.      1  6.80&#xA;#&amp;gt;  2 ENSG000001… 1      &amp;lt;int&amp;gt;      3975  2.08  1.40e-4 0.0178     58.6     1  6.80&#xA;#&amp;gt;  3 ENSG000001… 1      &amp;lt;int&amp;gt;      3582 -0.538 2.05e-4 0.0178     51.7     1  6.80&#xA;#&amp;gt;  4 ENSG000001… 1      &amp;lt;int&amp;gt;      2267 -0.369 2.68e-4 0.0178     47.3     1  6.80&#xA;#&amp;gt;  5 ENSG000001… 1      &amp;lt;int&amp;gt;      3850  0.637 3.36e-4 0.0178     43.9     1  6.80&#xA;#&amp;gt;  6 ENSG000000… 1      &amp;lt;int&amp;gt;      3150 -0.290 4.16e-4 0.0178     40.9     1  6.80&#xA;#&amp;gt;  7 ENSG000001… 1      &amp;lt;int&amp;gt;      2889 -1.49  4.61e-4 0.0178     39.5     1  6.80&#xA;#&amp;gt;  8 ENSG000001… 1      &amp;lt;int&amp;gt;      3970  0.596 5.58e-4 0.0178     37.0     1  6.80&#xA;#&amp;gt;  9 ENSG000000… 1      &amp;lt;int&amp;gt;      4040 -0.422 6.07e-4 0.0178     36.0     1  6.80&#xA;#&amp;gt; 10 ENSG000001… 1      &amp;lt;int&amp;gt;       534  0.641 6.45e-4 0.0178     35.2     1  6.80&#xA;#&amp;gt; # … with 290 more rows, 6 more variables: lfc &amp;lt;dbl&amp;gt;, symbol &amp;lt;chr&amp;gt;,&#xA;#&amp;gt; #   chromosome &amp;lt;fct&amp;gt;, gene_length &amp;lt;int&amp;gt;, strand. &amp;lt;fct&amp;gt;, source &amp;lt;fct&amp;gt;, and&#xA;#&amp;gt; #   abbreviated variable names ¹​adj_pval, ²​f_statistic&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can now specifically select regions with significant differential expression:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# HLA-DRB1&#xA;sel_gene &amp;lt;- &#34;ENSG00000196126&#34;&#xA;&#xA;as_tibble(umap) %&amp;gt;%&#xA;  mutate(expr = assay(fit, &#34;DE&#34;)[sel_gene,]) %&amp;gt;%&#xA;  ggplot(aes(x = V1, y = V2)) +&#xA;    geom_point(aes(color = expr)) +&#xA;    scale_color_gradient2() +&#xA;    labs(title = &#34;Differential expression on UMAP plot&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/const-ae/lemur/master/man/figures/README-umap_de2-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;p&gt;To plot the boundaries of the differential expression neighborhood, we create a helper dataframe and use the &lt;code&gt;geom_density2d&lt;/code&gt; function from &lt;code&gt;ggplot2&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;neighborhood_coordinates &amp;lt;- neighborhoods %&amp;gt;%&#xA;  filter(name == sel_gene) %&amp;gt;%&#xA;  mutate(cell_id = map(indices, \(idx) colnames(fit)[idx])) %&amp;gt;%&#xA;  unnest(c(indices, cell_id)) %&amp;gt;%&#xA;  left_join(as_tibble(umap, rownames = &#34;cell_id&#34;), by = &#34;cell_id&#34;) %&amp;gt;%&#xA;  dplyr::select(name, cell_id, V1, V2)&#xA;&#xA;as_tibble(umap) %&amp;gt;%&#xA;  mutate(expr = assay(fit, &#34;DE&#34;)[sel_gene,]) %&amp;gt;%&#xA;  ggplot(aes(x = V1, y = V2)) +&#xA;    geom_point(aes(color = expr)) +&#xA;    scale_color_gradient2() +&#xA;    geom_density2d(data = neighborhood_coordinates, breaks = 0.1, &#xA;                   contour_var = &#34;ndensity&#34;, color = &#34;black&#34;) +&#xA;    labs(title = &#34;Differential expression with neighborhood boundary&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/const-ae/lemur/master/man/figures/README-umap_de3-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;p&gt;To get a better idea of the expression differences across all genes, we make a vulcano plot of the differential expression results.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;neighborhoods %&amp;gt;%&#xA;  ggplot(aes(x = lfc, y = -log10(pval))) +&#xA;    geom_point(aes(color  = adj_pval &amp;lt; 0.1)) +&#xA;    labs(title = &#34;Vulcano plot of the neighborhoods&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/const-ae/lemur/master/man/figures/README-volcano_plot-1.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;neighborhoods %&amp;gt;%&#xA;  ggplot(aes(x = n_cells, y = -log10(pval))) +&#xA;    geom_point(aes(color  = adj_pval &amp;lt; 0.1)) +&#xA;    labs(title = &#34;Neighborhood size vs neighborhood significance&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/const-ae/lemur/master/man/figures/README-volcano_plot-2.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;h1&gt;Session Info&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sessionInfo()&#xA;#&amp;gt; R version 4.2.1 RC (2022-06-17 r82503)&#xA;#&amp;gt; Platform: x86_64-apple-darwin17.0 (64-bit)&#xA;#&amp;gt; Running under: macOS Big Sur ... 10.16&#xA;#&amp;gt; &#xA;#&amp;gt; Matrix products: default&#xA;#&amp;gt; BLAS:   /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib&#xA;#&amp;gt; LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib&#xA;#&amp;gt; &#xA;#&amp;gt; locale:&#xA;#&amp;gt; [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8&#xA;#&amp;gt; &#xA;#&amp;gt; attached base packages:&#xA;#&amp;gt; [1] stats4    stats     graphics  grDevices utils     datasets  methods  &#xA;#&amp;gt; [8] base     &#xA;#&amp;gt; &#xA;#&amp;gt; other attached packages:&#xA;#&amp;gt;  [1] lubridate_1.9.2             forcats_1.0.0              &#xA;#&amp;gt;  [3] stringr_1.5.0               dplyr_1.1.0                &#xA;#&amp;gt;  [5] purrr_1.0.1                 readr_2.1.4                &#xA;#&amp;gt;  [7] tidyr_1.3.0                 tibble_3.1.8               &#xA;#&amp;gt;  [9] ggplot2_3.4.1               tidyverse_2.0.0            &#xA;#&amp;gt; [11] SingleCellExperiment_1.20.0 SummarizedExperiment_1.28.0&#xA;#&amp;gt; [13] Biobase_2.58.0              GenomicRanges_1.50.2       &#xA;#&amp;gt; [15] GenomeInfoDb_1.34.9         IRanges_2.32.0             &#xA;#&amp;gt; [17] S4Vectors_0.36.2            BiocGenerics_0.44.0        &#xA;#&amp;gt; [19] MatrixGenerics_1.10.0       matrixStats_0.63.0         &#xA;#&amp;gt; [21] lemur_0.0.8                &#xA;#&amp;gt; &#xA;#&amp;gt; loaded via a namespace (and not attached):&#xA;#&amp;gt;  [1] splines_4.2.1             DelayedMatrixStats_1.20.0&#xA;#&amp;gt;  [3] expm_0.999-7              highr_0.10               &#xA;#&amp;gt;  [5] GenomeInfoDbData_1.2.9    yaml_2.3.7               &#xA;#&amp;gt;  [7] pillar_1.8.1              lattice_0.20-45          &#xA;#&amp;gt;  [9] glue_1.6.2                digest_0.6.31            &#xA;#&amp;gt; [11] XVector_0.38.0            colorspace_2.1-0         &#xA;#&amp;gt; [13] cowplot_1.1.1             htmltools_0.5.4          &#xA;#&amp;gt; [15] Matrix_1.5-3              pkgconfig_2.0.3          &#xA;#&amp;gt; [17] zlibbioc_1.44.0           scales_1.2.1             &#xA;#&amp;gt; [19] tzdb_0.3.0                pracma_2.4.2             &#xA;#&amp;gt; [21] timechange_0.2.0          generics_0.1.3           &#xA;#&amp;gt; [23] farver_2.1.1              ellipsis_0.3.2           &#xA;#&amp;gt; [25] withr_2.5.0               harmony_0.1.1            &#xA;#&amp;gt; [27] cli_3.6.0                 magrittr_2.0.3           &#xA;#&amp;gt; [29] evaluate_0.20             fansi_1.0.4              &#xA;#&amp;gt; [31] MASS_7.3-58.2             tools_4.2.1              &#xA;#&amp;gt; [33] hms_1.1.2                 lifecycle_1.0.3          &#xA;#&amp;gt; [35] munsell_0.5.0             DelayedArray_0.24.0      &#xA;#&amp;gt; [37] irlba_2.3.5.1             isoband_0.2.7            &#xA;#&amp;gt; [39] compiler_4.2.1            rlang_1.0.6              &#xA;#&amp;gt; [41] grid_4.2.1                RCurl_1.98-1.10          &#xA;#&amp;gt; [43] rstudioapi_0.14           RcppAnnoy_0.0.20         &#xA;#&amp;gt; [45] glmGamPoi_1.11.7          bitops_1.0-7             &#xA;#&amp;gt; [47] labeling_0.4.2            rmarkdown_2.20           &#xA;#&amp;gt; [49] gtable_0.3.1              codetools_0.2-19         &#xA;#&amp;gt; [51] R6_2.5.1                  knitr_1.42               &#xA;#&amp;gt; [53] fastmap_1.1.1             uwot_0.1.14              &#xA;#&amp;gt; [55] utf8_1.2.3                stringi_1.7.12           &#xA;#&amp;gt; [57] Rcpp_1.0.10               vctrs_0.5.2              &#xA;#&amp;gt; [59] tidyselect_1.2.0          xfun_0.37                &#xA;#&amp;gt; [61] sparseMatrixStats_1.10.0&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>