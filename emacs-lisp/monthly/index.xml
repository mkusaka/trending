<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-01T02:09:07Z</updated>
  <subtitle>Monthly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>emacs-helm/helm</title>
    <updated>2023-09-01T02:09:07Z</updated>
    <id>tag:github.com,2023-09-01:/emacs-helm/helm</id>
    <link href="https://github.com/emacs-helm/helm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs incremental completion and selection narrowing framework&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?sanitize=true&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/helm&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/helm-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/helm&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/helm-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt;Emacs-Helm&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://avatars3.githubusercontent.com/u/1541688?v=3&amp;amp;s=200&#34; alt=&#34;Emacs-helm&#34; title=&#34;&#34;&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p align=&#34;justify&#34;&gt; &lt;b&gt;Helm&lt;/b&gt; is an Emacs framework for incremental completions and narrowing selections. It provides an easy-to-use API for developers wishing to build their own Helm applications in Emacs, powerful search tools and dozens of already built-in commands providing completion to almost everything. It is a must-have for anyone using Emacs as a main work environment. Helm has been widely adopted by many Emacs power-users. It is available in Melpa and can be easily installed from the Emacs package manager. &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://emacs-helm.github.io/helm/&#34;&gt;&lt;b&gt;Homepage&lt;/b&gt;&lt;/a&gt; | &lt;a href=&#34;https://github.com/emacs-helm/helm/releases&#34;&gt;&lt;b&gt;Downloads&lt;/b&gt;&lt;/a&gt; | &lt;a href=&#34;https://github.com/emacs-helm/helm/wiki#install&#34;&gt;&lt;b&gt;Get started&lt;/b&gt;&lt;/a&gt; | &lt;a href=&#34;https://github.com/emacs-helm/helm/wiki&#34;&gt;&lt;b&gt;Helm wiki&lt;/b&gt;&lt;/a&gt; | &lt;a href=&#34;https://github.com/emacs-helm/helm/wiki/FAQ&#34;&gt;&lt;b&gt;FAQ&lt;/b&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p align=&#34;center&#34;&gt; Helm in action searching with &lt;a href=&#34;https://github.com/ggreer/the_silver_searcher&#34; &lt;b&gt;Grep Ag&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/emacs-helm/helm/raw/master/images/helm-grep-ag-persistent.png?raw=true&#34; alt=&#34;Emacs-helm grep ag&#34; title=&#34;&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Maintainance of Helm is a lot of work please consider making a donation, thank you!&lt;/p&gt; &#xA;&lt;a href=&#34;https://www.patreon.com/user?u=86324343&#34;&gt; &lt;img title=&#34;Donate monthly using Patreon&#34; alt=&#34;Donate monthly using Patreon&#34; style=&#34;height: 50px; width: auto;&#34; src=&#34;https://github.com/emacs-helm/helm/raw/master/images/patreon-25x.png?raw=true&#34;&gt;&lt;/a&gt;</summary>
  </entry>
  <entry>
    <title>mickeynp/combobulate</title>
    <updated>2023-09-01T02:09:07Z</updated>
    <id>tag:github.com,2023-09-01:/mickeynp/combobulate</id>
    <link href="https://github.com/mickeynp/combobulate" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Structured Editing and Navigation in Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;==================================================== Structured Navigation and Editing with Combobulate&lt;/h1&gt; &#xA;&lt;p&gt;.. image:: docs/combobulate.png&lt;/p&gt; &#xA;&lt;h1&gt;What is Combobulate?&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Combobulate is under active development. Expect bugs.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Combobulate is a package that adds structured editing and movement to a wide range of programming languages. Unlike most programming major modes that use error-prone imperative code and regular expressions to determine what&#39;s what in your code, Combobulate uses Emacs 29&#39;s tree-sitter library. Tree-sitter maintains a &lt;em&gt;concrete syntax tree&lt;/em&gt; of your code; it gives Combobulate absolute clarity of all aspects of your code, enabling more correct movement and editing than you would otherwise have.&lt;/p&gt; &#xA;&lt;p&gt;Combobulate extends the existing editing and navigation capabilities of Emacs in addition to adding a range of new features you can&#39;t easily do in Emacs without Combobulate.&lt;/p&gt; &#xA;&lt;p&gt;Combobulate&#39;s design philosophy is this:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;It must be extensible and &lt;em&gt;relatively&lt;/em&gt; easy to add new languages.&lt;/p&gt; &lt;p&gt;Open &lt;code&gt;combobulate-&amp;lt;lang&amp;gt;.el&lt;/code&gt; to see how each mode is defined.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Commands should broadly work the same across all languages.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A strong emphasis on extending and enriching the existing movement and editing commands where possible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Combobulate must have a shallow learning curve.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you want a guided tour, then I recommend you read &lt;code&gt;Combobulate: Structured Movement and Editing with Tree-Sitter &amp;lt;https://www.masteringemacs.org/article/combobulate-structured-movement-editing-treesitter&amp;gt;&lt;/code&gt;__ for an in-depth overview.&lt;/p&gt; &#xA;&lt;h2&gt;What does Combobulate do exactly?&lt;/h2&gt; &#xA;&lt;p&gt;.. image:: docs/sibling-nav-jsx.gif&lt;/p&gt; &#xA;&lt;p&gt;Combobulate is meant as a companion to the existing movement and editing facilities in Emacs. It&#39;s designed to sympathetically improve or supplant editing and movement in many major modes that are otherwise lacking or incorrect. There&#39;s a large emphasis on Combobulate being both easy to use, and a natural extension to Emacs&#39;s already-powerful editing and movement commands.&lt;/p&gt; &#xA;&lt;p&gt;For instance, navigating up or down list structures with &lt;code&gt;C-M-u&lt;/code&gt; and &lt;code&gt;C-M-d&lt;/code&gt; is much improved. Whether you&#39;re navigating in or out of structures in Python or JSX elements in Typescript of Javascript.&lt;/p&gt; &#xA;&lt;p&gt;Combobulate also improves list-like navigation bound to &lt;code&gt;C-M-n&lt;/code&gt; and &lt;code&gt;C-M-p&lt;/code&gt;. They now understand hierarchical code much better, and they will navigate between statements in code as well as parameters in functions or key pairs in dictionaries.&lt;/p&gt; &#xA;&lt;p&gt;.. image:: docs/drag-complex.gif&lt;/p&gt; &#xA;&lt;p&gt;Combobulate also adds code editing commands, such as the ability to drag logical pieces of code up or down, if they span multiple lines. It can also expand the region one syntactically interesting unit at time: first the string point is in, then the list that is in, and so on.&lt;/p&gt; &#xA;&lt;p&gt;Combobulate can also place cursors (using the optional &lt;em&gt;multiple cursors&lt;/em&gt; package) at syntactically important points in your code, like: dictionary elements; function arguments; or attributes in JSX elements.&lt;/p&gt; &#xA;&lt;p&gt;.. image:: docs/clone-dwim.gif&lt;/p&gt; &#xA;&lt;p&gt;You can clone code and experimentally splice code, much like Paredit. Combobulate also comes with a simple code templating tool that you can use to insert or modify code, such as wrapping a code block in an &lt;code&gt;if&lt;/code&gt; statement in Python, or a JSX element in an expression statement.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started with Combobulate&lt;/h2&gt; &#xA;&lt;p&gt;+--------------------+--------------------+ |Language |Supported? | +--------------------+--------------------+ |CSS |✅ | +--------------------+--------------------+ |HTML |✅ (See notes) | +--------------------+--------------------+ |JSON |✅ | +--------------------+--------------------+ |Javascript+JSX |✅ | +--------------------+--------------------+ |Typescript+TSX |✅ | +--------------------+--------------------+ |Python |✅ | +--------------------+--------------------+ |YAML |✅ | +--------------------+--------------------+&lt;/p&gt; &#xA;&lt;p&gt;When you have installed Combobulate correctly -- see below -- then it&#39;ll turn on when you open a file in one of its supported major modes. If it does not do this, try &lt;code&gt;M-x combobulate-mode&lt;/code&gt; to activate Combobulate&#39;s minor mode.&lt;/p&gt; &#xA;&lt;p&gt;If it&#39;s working, you&#39;ll see a &lt;code&gt;©&lt;/code&gt; appear in your mode line.&lt;/p&gt; &#xA;&lt;p&gt;At that point, Combobulate is now working. Combobulate rebinds a wide range of common navigation and editing keys. You can see a complete list by typing &lt;code&gt;M-x describe-keymap RET combobulate-key-map&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note that Combobulate may enable or disable keys depending on the major mode it is active in.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, Combobulate ships with a Magit-like transient UI that you can access by typing &lt;code&gt;C-c o o&lt;/code&gt;. It exists primarily to teach you about Combobulate&#39;s capabilities: every key binding in it is also available without the popup.&lt;/p&gt; &#xA;&lt;p&gt;(HTML support is supported, but uses an as-yet work-in-progress and unreleased major mode to do this. More details coming soon.)&lt;/p&gt; &#xA;&lt;p&gt;Top Tips for using Combobulate&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#xA;Unlike most of Emacs&#39;s major modes and the specialized movement and editing they (may) offer, Combobulate is quite strict. It&#39;s strict about *where* you invoke certain commands or key bindings, and what happens when you type in different parts of the same line of code.&#xA;&#xA;That is because of the *concrete syntax tree*. Place your point anywhere in your source code and there might be 5, 10, 15 or more &#34;nodes&#34; in the tree where that point intersects wildly different nodes.&#xA;&#xA;For example: your point is on a string; but it&#39;s also in a list; which is in a dictionary; which is in an expression statement; which is in a ``for``-loop; which is in a function, and so on.&#xA;&#xA;Because a *concrete syntax tree* is so exacting and so detailed, it&#39;s hard for Combobulate to infer what you want to do with the same casual insouciance of commands that don&#39;t use a syntax tree: there are simply too choices, and too many nodes.&#xA;&#xA;You, the human, know which node you want -- but Combobulate does not necessarily know that!&#xA;&#xA;So, for best results, put your point at the *beginning* of the thing you want to interact with --- at least until you&#39;ve gotten the hang of how Combobulate decides what it thinks you&#39;re asking for.&#xA;&#xA;Finally, note that any command that edits your code is at best a &#34;best guess&#34; effort. Carefully scrutinize what Combobulate does after you invoke any command that edits.&#xA;&#xA;How do I install Combobulate?&#xA;-----------------------------&#xA;&#xA;Combobulate is not on MELPA or any other package repository, yet. For Combobulate to install properly you must meet the following requirements:&#xA;&#xA;1. You must be running Emacs 29 or later.&#xA;2. Your Emacs *must* be compiled with tree-sitter support. Read `How to Get Started with Tree Sitter &amp;lt;https://www.masteringemacs.org/article/how-to-get-started-tree-sitter&amp;gt;`__ to learn how to compile Emacs and install tree-sitter.&#xA;&#xA;   In ``C-h v system-configuration-features`` look for ``TREE_SITTER``.&#xA;3. You must have language grammars installed for the languages you want to use Combobulate with.&#xA;&#xA;   **However**, you can optionally ask Emacs to download, compile and install these language grammars, but you&#39;ll need a suitable C compiler. If you&#39;re using Linux, then no problem. Non-Linux users may need to install or configure their operating system to do this.&#xA;&#xA;4. You&#39;re interested in using Combobulate with one of these supported Languages:&#xA;&#xA;     CSS, Typescript+TSX, Javascript, Python, or YAML.&#xA;&#xA;   (Adding support for new languages is reasonably easy though!)&#xA;5. You have a git checkout of Combobulate ready.&#xA;&#xA;Here&#39;s a verbose example of how to configure Combobulate in Emacs with ``use-package``. Note that if you already know how to install tree-sitter  grammars, then you can leave out the code that does this in the ``:preface``.&#xA;&#xA;Also note that this example uses ``major-mode-remap-alist`` to turn your regular major modes into the tree-sitter-enabled modes.&#xA;&#xA;.. code-block:: elisp&#xA;&#xA;    ;; `M-x combobulate&#39; (default: `C-c o o&#39;) to start using Combobulate&#xA;    (use-package treesit&#xA;      :preface&#xA;      (defun mp-setup-install-grammars ()&#xA;        &#34;Install Tree-sitter grammars if they are absent.&#34;&#xA;        (interactive)&#xA;        (dolist (grammar&#xA;                 &#39;((css &#34;https://github.com/tree-sitter/tree-sitter-css&#34;)&#xA;                   (javascript . (&#34;https://github.com/tree-sitter/tree-sitter-javascript&#34; &#34;master&#34; &#34;src&#34;))&#xA;                   (python &#34;https://github.com/tree-sitter/tree-sitter-python&#34;)&#xA;                   (tsx . (&#34;https://github.com/tree-sitter/tree-sitter-typescript&#34; &#34;master&#34; &#34;tsx/src&#34;))&#xA;                   (yaml &#34;https://github.com/ikatyang/tree-sitter-yaml&#34;)))&#xA;          (add-to-list &#39;treesit-language-source-alist grammar)&#xA;          ;; Only install `grammar&#39; if we don&#39;t already have it&#xA;          ;; installed. However, if you want to *update* a grammar then&#xA;          ;; this obviously prevents that from happening.&#xA;          (unless (treesit-language-available-p (car grammar))&#xA;            (treesit-install-language-grammar (car grammar)))))&#xA;&#xA;      ;; Optional, but recommended. Tree-sitter enabled major modes are&#xA;      ;; distinct from their ordinary counterparts.&#xA;      ;;&#xA;      ;; You can remap major modes with `major-mode-remap-alist&#39;. Note&#xA;      ;; that this does *not* extend to hooks! Make sure you migrate them&#xA;      ;; also&#xA;      (dolist (mapping &#39;((python-mode . python-ts-mode)&#xA;                         (css-mode . css-ts-mode)&#xA;                         (typescript-mode . tsx-ts-mode)&#xA;                         (json-mode . json-ts-mode)&#xA;                         (js-mode . js-ts-mode)&#xA;                         (css-mode . css-ts-mode)&#xA;                         (yaml-mode . yaml-ts-mode)))&#xA;        (add-to-list &#39;major-mode-remap-alist mapping))&#xA;&#xA;      :config&#xA;      (mp-setup-install-grammars)&#xA;      ;; Do not forget to customize Combobulate to your liking:&#xA;      ;;&#xA;      ;;  M-x customize-group RET combobulate RET&#xA;      ;;&#xA;      (use-package combobulate&#xA;        :preface&#xA;        ;; You can customize Combobulate&#39;s key prefix here.&#xA;        ;; Note that you may have to restart Emacs for this to take effect!&#xA;        (setq combobulate-key-prefix &#34;C-c o&#34;)&#xA;&#xA;        ;; Optional, but recommended.&#xA;        ;;&#xA;        ;; You can manually enable Combobulate with `M-x&#xA;        ;; combobulate-mode&#39;.&#xA;        :hook ((python-ts-mode . combobulate-mode)&#xA;               (js-ts-mode . combobulate-mode)&#xA;               (css-ts-mode . combobulate-mode)&#xA;               (yaml-ts-mode . combobulate-mode)&#xA;               (json-ts-mode . combobulate-mode)&#xA;               (typescript-ts-mode . combobulate-mode)&#xA;               (tsx-ts-mode . combobulate-mode))&#xA;        ;; Amend this to the directory where you keep Combobulate&#39;s source&#xA;        ;; code.&#xA;        :load-path (&#34;path-to-git-checkout-of-combobulate&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>rejeep/f.el</title>
    <updated>2023-09-01T02:09:07Z</updated>
    <id>tag:github.com,2023-09-01:/rejeep/f.el</id>
    <link href="https://github.com/rejeep/f.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Modern API for working with files and directories in Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;-&lt;em&gt;- mode: org -&lt;/em&gt;-&lt;/h1&gt; &#xA;&lt;p&gt;#+title: f.el&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/rejeep/f.el/actions/workflows/workflow.yml][file:https://github.com/rejeep/f.el/actions/workflows/workflow.yml/badge.svg]] [[https://coveralls.io/r/rejeep/f.el][file:https://img.shields.io/coveralls/rejeep/f.el.svg]] [[https://melpa.org/#/f][file:https://melpa.org/packages/f-badge.svg]] [[https://stable.melpa.org/#/f][file:https://stable.melpa.org/packages/f-badge.svg]]&lt;/p&gt; &#xA;&lt;p&gt;Much inspired by [[https://github.com/magnars][@magnars]]s excellent [[https://github.com/magnars/s.el][s.el]] and [[https://github.com/magnars/dash.el][dash.el]], [[https://github.com/rejeep/f.el][f.el]] is a modern API for working with files and directories in Emacs.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation :noexport: It’s available on [[https://melpa.org/#/f][Melpa]] and [[https://stable.melpa.org/#/f][Melpa Stable]]. #+begin_src text M-x package-install f #+end_src&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Or you can just dump &lt;del&gt;f.el&lt;/del&gt; in your load path somewhere.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Table of Contents :TOC_3_gh:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#contributing][Contributing]]&lt;/li&gt; &#xA; &lt;li&gt;[[#documentation-and-examples][Documentation and examples]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#paths][Paths]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-join][f-join]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-split][f-split]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-expand][f-expand]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-filename][f-filename]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-dirname][f-dirname]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-common-parent][f-common-parent]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-ext][f-ext]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-no-ext][f-no-ext]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-swap-ext][f-swap-ext]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-base][f-base]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-relative][f-relative]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-short][f-short]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-long][f-long]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-canonical][f-canonical]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-slash][f-slash]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-full][f-full]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-uniquify][f-uniquify]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-uniquify-alist][f-uniquify-alist]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#io][I/O]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-read-bytes][f-read-bytes]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-write-bytes][f-write-bytes]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-append-bytes][f-append-bytes]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-read-text][f-read-text]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-write-text][f-write-text]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-append-text][f-append-text]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#destructive][Destructive]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-mkdir][f-mkdir]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-mkdir-full-path][f-mkdir-full-path]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-delete][f-delete]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-symlink][f-symlink]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-move][f-move]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-copy][f-copy]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-copy-contents][f-copy-contents]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-touch][f-touch]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#predicates][Predicates]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-exists-p][f-exists-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-directory-p][f-directory-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-file-p][f-file-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-symlink-p][f-symlink-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-readable-p][f-readable-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-writable-p][f-writable-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-executable-p][f-executable-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-absolute-p][f-absolute-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-relative-p][f-relative-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-root-p][f-root-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-ext-p][f-ext-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-same-p][f-same-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-parent-of-p][f-parent-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-child-of-p][f-child-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-ancestor-of-p][f-ancestor-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-descendant-of-p][f-descendant-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-hidden-p][f-hidden-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-empty-p][f-empty-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-newer-p][f-newer-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-older-p][f-older-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-same-time-p][f-same-time-p]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#stats][Stats]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-size][f-size]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-depth][f-depth]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-change-time][f-change-time]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-modification-time][f-modification-time]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-access-time][f-access-time]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#misc][Misc]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-this-file][f-this-file]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-path-separator][f-path-separator]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-glob][f-glob]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-entries][f-entries]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-directories][f-directories]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-files][f-files]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-root][f-root]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-traverse-upwards][f-traverse-upwards]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-with-sandbox][f-with-sandbox]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#example][Example]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#using-standard-emacs-builtin-functions][Using standard Emacs builtin functions]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#using-fel][Using f.el]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Contributing Check [[file:./CONTRIBUTING.org]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Documentation and examples ** Paths *** f-join #+begin_example (f-join &amp;amp;rest args)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Join ARGS to a single path.&lt;/p&gt; &#xA;&lt;p&gt;Be aware if one of the arguments is an absolute path, ‘f-join’ will discard all the preceeding arguments and make this absolute path the new root of the generated path. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-join &#34;path&#34;) ;; =&amp;gt; &#34;path&#34; (f-join &#34;path&#34; &#34;to&#34;) ;; =&amp;gt; &#34;path/to&#34; (f-join &#34;/&#34; &#34;path&#34; &#34;to&#34; &#34;heaven&#34;) ;; =&amp;gt; &#34;/path/to/heaven&#34; (f-join &#34;path&#34; &#34;/to&#34; &#34;file&#34;) ;; =&amp;gt; &#34;/to/file&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-split #+begin_example (f-split path)&lt;/p&gt; &#xA;&lt;p&gt;Split PATH and return list containing parts. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-split &#34;path&#34;) ;; =&amp;gt; &#39;(&#34;path&#34;) (f-split &#34;path/to&#34;) ;; =&amp;gt; &#39;(&#34;path&#34; &#34;to&#34;) (f-split &#34;/path/to/heaven&#34;) ;; =&amp;gt; &#39;(&#34;/&#34; &#34;path&#34; &#34;to&#34; &#34;heaven&#34;) (f-split &#34;&lt;del&gt;/back/to/earth&#34;) ;; =&amp;gt; &#39;(&#34;&lt;/del&gt;&#34; &#34;back&#34; &#34;to&#34; &#34;earth&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-expand #+begin_example (f-expand path &amp;amp;optional dir)&lt;/p&gt; &#xA;&lt;p&gt;Expand PATH relative to DIR (or ‘default-directory’). PATH and DIR can be either a directory names or directory file names. Return a directory name if PATH is a directory name, and a directory file name otherwise. File name handlers are ignored. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-expand &#34;name&#34;) ;; =&amp;gt; &#34;/default/directory/name&#34; (f-expand &#34;name&#34; &#34;other/directory&#34;) ;; =&amp;gt; &#34;other/directory/name&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-filename #+begin_example (f-filename path)&lt;/p&gt; &#xA;&lt;p&gt;Return the name of PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-filename &#34;path/to/file.ext&#34;) ;; =&amp;gt; &#34;file.ext&#34; (f-filename &#34;path/to/directory&#34;) ;; =&amp;gt; &#34;directory&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-dirname #+begin_example (f-dirname path)&lt;/p&gt; &#xA;&lt;p&gt;Return the parent directory to PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-parent&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-dirname &#34;path/to/file.ext&#34;) ;; =&amp;gt; &#34;path/to&#34; (f-dirname &#34;path/to/directory&#34;) ;; =&amp;gt; &#34;path/to&#34; (f-dirname &#34;/&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-common-parent #+begin_example (f-common-parent paths)&lt;/p&gt; &#xA;&lt;p&gt;Return the deepest common parent directory of PATHS. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-common-parent &#39;(&#34;foo/bar/baz&#34; &#34;foo/bar/qux&#34; &#34;foo/bar/mux&#34;)) ;; =&amp;gt; &#34;foo/bar/&#34; (f-common-parent &#39;(&#34;/foo/bar/baz&#34; &#34;/foo/bar/qux&#34; &#34;/foo/bax/mux&#34;)) ;; =&amp;gt; &#34;/foo/&#34; (f-common-parent &#39;(&#34;foo/bar/baz&#34; &#34;quack/bar/qux&#34; &#34;lack/bar/mux&#34;)) ;; =&amp;gt; &#34;&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-ext #+begin_example (f-ext path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-name-extension&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-ext &#34;path/to/file&#34;) ;; =&amp;gt; nil (f-ext &#34;path/to/file.txt&#34;) ;; =&amp;gt; txt (f-ext &#34;path/to/file.txt.org&#34;) ;; =&amp;gt; org #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-no-ext #+begin_example (f-no-ext path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-name-sans-extension&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-no-ext &#34;path/to/file&#34;) ;; =&amp;gt; path/to/file (f-no-ext &#34;path/to/file.txt&#34;) ;; =&amp;gt; path/to/file (f-no-ext &#34;path/to/file.txt.org&#34;) ;; =&amp;gt; path/to/file.txt #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-swap-ext #+begin_example (f-swap-ext path ext)&lt;/p&gt; &#xA;&lt;p&gt;Return PATH but with EXT as the new extension. EXT must not be nil or empty. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-swap-ext &#34;path/to/file.ext&#34; &#34;org&#34;) ;; =&amp;gt; &#34;path/to/file.org&#34; (f-swap-ext &#34;path/to/file.ext&#34; &#34;&#34;) ;; =&amp;gt; error #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-base #+begin_example (f-base path)&lt;/p&gt; &#xA;&lt;p&gt;Return the name of PATH, excluding the extension of file. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-base &#34;path/to/file.ext&#34;) ;; =&amp;gt; &#34;file&#34; (f-base &#34;path/to/directory&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-relative #+begin_example (f-relative path &amp;amp;optional dir)&lt;/p&gt; &#xA;&lt;p&gt;Convert FILENAME to be relative to DIRECTORY (default: ‘default-directory’). This function returns a relative file name that is equivalent to FILENAME when used with that default directory as the default. If FILENAME is a relative file name, it will be interpreted as existing in ‘default-directory’. If FILENAME and DIRECTORY lie on different machines or on different drives on a DOS/Windows machine, it returns FILENAME in expanded form.&lt;/p&gt; &#xA;&lt;p&gt;(fn FILENAME &amp;amp;optional DIRECTORY) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-relative &#34;/some/path/relative/to/my/file.txt&#34; &#34;/some/path/&#34;) ;; =&amp;gt; relative/to/my/file.txt (f-relative &#34;/default/directory/my/file.txt&#34;) ;; =&amp;gt; my/file.txt #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-short #+begin_example (f-short path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;abbreviate-file-name&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-abbrev&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-short &#34;/Users/foo/Code/bar&#34;) ;; =&amp;gt; ~/Code/bar (f-short &#34;/path/to/Code/bar&#34;) ;; =&amp;gt; /path/to/Code/bar #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-long #+begin_example (f-long path)&lt;/p&gt; &#xA;&lt;p&gt;Return long version of PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-long &#34;~/Code/bar&#34;) ;; =&amp;gt; /Users/foo/Code/bar (f-long &#34;/path/to/Code/bar&#34;) ;; =&amp;gt; /path/to/Code/bar #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-canonical #+begin_example (f-canonical path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-truename&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-canonical &#34;/path/to/real/file&#34;) ;; =&amp;gt; /path/to/real/file (f-canonical &#34;/link/to/file&#34;) ;; =&amp;gt; /path/to/real/file #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-slash #+begin_example (f-slash path)&lt;/p&gt; &#xA;&lt;p&gt;Append slash to PATH unless one already.&lt;/p&gt; &#xA;&lt;p&gt;Some functions, such as ‘call-process’ requires there to be an ending slash. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-slash &#34;/path/to/file&#34;) ;; =&amp;gt; /path/to/file (f-slash &#34;/path/to/dir&#34;) ;; =&amp;gt; /path/to/dir/ (f-slash &#34;/path/to/dir/&#34;) ;; =&amp;gt; /path/to/dir/ #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-full #+begin_example (f-full path)&lt;/p&gt; &#xA;&lt;p&gt;Return absolute path to PATH, with ending slash. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-full &#34;&lt;del&gt;/path/to/file&#34;) ;; =&amp;gt; /home/foo/path/to/file (f-full &#34;&lt;/del&gt;/path/to/dir&#34;) ;; =&amp;gt; /home/foo/path/to/dir/ (f-full &#34;~/path/to/dir/&#34;) ;; =&amp;gt; /home/foo/path/to/dir/ #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-uniquify #+begin_example (f-uniquify paths)&lt;/p&gt; &#xA;&lt;p&gt;Return unique suffixes of FILES.&lt;/p&gt; &#xA;&lt;p&gt;This function expects no duplicate paths. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;(&#34;bar&#34; &#34;baz&#34; &#34;quux&#34;) (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;(&#34;foo/bar&#34; &#34;www/bar&#34; &#34;quux&#34;) (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/www/bar/quux&#34;)) ;; =&amp;gt; &#39;(&#34;foo/bar&#34; &#34;www/bar&#34; &#34;quux&#34;) (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/home/www/bar&#34; &#34;/home/www/baz&#34; &#34;/var/foo&#34; &#34;/opt/foo/www/baz&#34;)) ;; =&amp;gt; &#39;(&#34;foo/bar&#34; &#34;www/bar&#34; &#34;foo/baz&#34; &#34;home/www/baz&#34; &#34;foo/www/baz&#34; &#34;foo&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-uniquify-alist #+begin_example (f-uniquify-alist paths)&lt;/p&gt; &#xA;&lt;p&gt;Return alist mapping FILES to unique suffixes of FILES.&lt;/p&gt; &#xA;&lt;p&gt;This function expects no duplicate paths. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;bar&#34;) (&#34;/foo/baz&#34; . &#34;baz&#34;) (&#34;/foo/quux&#34; . &#34;quux&#34;)) (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;foo/bar&#34;) (&#34;/www/bar&#34; . &#34;www/bar&#34;) (&#34;/foo/quux&#34; . &#34;quux&#34;)) (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/www/bar/quux&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;foo/bar&#34;) (&#34;/www/bar&#34; . &#34;www/bar&#34;) (&#34;/www/bar/quux&#34; . &#34;quux&#34;)) (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/home/www/bar&#34; &#34;/home/www/baz&#34; &#34;/var/foo&#34; &#34;/opt/foo/www/baz&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;foo/bar&#34;) (&#34;/home/www/bar&#34; . &#34;www/bar&#34;) (&#34;/foo/baz&#34; . &#34;foo/baz&#34;) (&#34;/home/www/baz&#34; . &#34;home/www/baz&#34;) (&#34;/opt/foo/www/baz&#34; . &#34;foo/www/baz&#34;) (&#34;/var/foo&#34; . &#34;foo&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** I/O *** f-read-bytes #+begin_example (f-read-bytes path)&lt;/p&gt; &#xA;&lt;p&gt;Read binary data from PATH.&lt;/p&gt; &#xA;&lt;p&gt;Return the binary data as unibyte string. The optional second and third arguments BEG and END specify what portion of the file to read. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-read-bytes &#34;path/to/binary/data&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-write-bytes #+begin_example (f-write-bytes data path)&lt;/p&gt; &#xA;&lt;p&gt;Write binary DATA to PATH.&lt;/p&gt; &#xA;&lt;p&gt;DATA is a unibyte string. PATH is a file name to write to. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-write-bytes (unibyte-string 72 101 108 108 111 32 119 111 114 108 100) &#34;path/to/binary/data&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-append-bytes #+begin_example (f-append-bytes text coding path)&lt;/p&gt; &#xA;&lt;p&gt;Append binary DATA to PATH.&lt;/p&gt; &#xA;&lt;p&gt;If PATH does not exist, it is created. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-append-bytes &#34;path/to/file&#34; (unibyte-string 72 101 108 108 111 32 119 111 114 108 100)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-read-text #+begin_example (f-read-text path &amp;amp;optional coding)&lt;/p&gt; &#xA;&lt;p&gt;Read text with PATH, using CODING.&lt;/p&gt; &#xA;&lt;p&gt;CODING defaults to ‘utf-8’.&lt;/p&gt; &#xA;&lt;p&gt;Return the decoded text as multibyte string. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-read&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-read-text &#34;path/to/file.txt&#34; &#39;utf-8) (f-read &#34;path/to/file.txt&#34; &#39;utf-8) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-write-text #+begin_example (f-write-text text coding path)&lt;/p&gt; &#xA;&lt;p&gt;Write TEXT with CODING to PATH.&lt;/p&gt; &#xA;&lt;p&gt;TEXT is a multibyte string. CODING is a coding system to encode TEXT with. PATH is a file name to write to. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-write&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-write-text &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) (f-write &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-append-text #+begin_example (f-append-text text coding path)&lt;/p&gt; &#xA;&lt;p&gt;Append TEXT with CODING to PATH.&lt;/p&gt; &#xA;&lt;p&gt;If PATH does not exist, it is created. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-append&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-append-text &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) (f-append &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Destructive *** f-mkdir #+begin_example (f-mkdir &amp;amp;rest dirs)&lt;/p&gt; &#xA;&lt;p&gt;Create directories DIRS.&lt;/p&gt; &#xA;&lt;p&gt;DIRS should be a successive list of directories forming together a full path. The easiest way to call this function with a fully formed path is using ‘f-split’ alongside it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(apply #&#39;f-mkdir (f-split &#34;path/to/file&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Although it works sometimes, it is not recommended to use fully formed paths in the function. In this case, it is recommended to use ‘f-mkdir-full-path’ instead. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-mkdir &#34;dir&#34;) ;; creates /default/directory/dir (f-mkdir &#34;other&#34; &#34;dir&#34;) ;; creates /default/directory/other/dir (f-mkdir &#34;/&#34; &#34;some&#34; &#34;path&#34;) ;; creates /some/path (f-mkdir &#34;~&#34; &#34;yet&#34; &#34;another&#34; &#34;dir&#34;) ;; creates ~/yet/another/dir #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-mkdir-full-path #+begin_example (f-mkdir-full-path dir)&lt;/p&gt; &#xA;&lt;p&gt;Create DIR from a full path.&lt;/p&gt; &#xA;&lt;p&gt;This function is similar to ‘f-mkdir’ except it can accept a full path instead of requiring several successive directory names. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-mkdir-full-path &#34;dir&#34;) ;; creates /default/directory/dir (f-mkdir-full-path &#34;other/dir&#34;) ;; creates /default/directory/other/dir (f-mkdir-full-path &#34;/some/path&#34;) ;; creates /some/path (f-mkdir-full-path &#34;~/yet/another/dir&#34;) ;; creates ~/yet/another/dir #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-delete #+begin_example (f-delete path &amp;amp;optional force)&lt;/p&gt; &#xA;&lt;p&gt;Delete PATH, which can be file or directory.&lt;/p&gt; &#xA;&lt;p&gt;If FORCE is t, a directory will be deleted recursively. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-delete &#34;dir&#34;) (f-delete &#34;other/dir&#34; t) (f-delete &#34;path/to/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-symlink #+begin_example (f-symlink source path)&lt;/p&gt; &#xA;&lt;p&gt;Create a symlink to SOURCE from PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-symlink &#34;path/to/source&#34; &#34;path/to/link&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-move #+begin_example (f-move from to)&lt;/p&gt; &#xA;&lt;p&gt;Move or rename FROM to TO. If TO is a directory name, move FROM into TO. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-move &#34;path/to/file.txt&#34; &#34;new-file.txt&#34;) (f-move &#34;path/to/file.txt&#34; &#34;other/path&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-copy #+begin_example (f-copy from to)&lt;/p&gt; &#xA;&lt;p&gt;Copy file or directory FROM to TO. If FROM names a directory and TO is a directory name, copy FROM into TO as a subdirectory. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-copy &#34;path/to/file.txt&#34; &#34;new-file.txt&#34;) (f-copy &#34;path/to/dir&#34; &#34;other/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-copy-contents #+begin_example (f-copy-contents from to)&lt;/p&gt; &#xA;&lt;p&gt;Copy contents in directory FROM, to directory TO. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-copy-contents &#34;path/to/dir&#34; &#34;path/to/other/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-touch #+begin_example (f-touch path)&lt;/p&gt; &#xA;&lt;p&gt;Update PATH last modification date or create if it does not exist. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-touch &#34;path/to/existing/file.txt&#34;) (f-touch &#34;path/to/non/existing/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Predicates *** f-exists-p #+begin_example (f-exists-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-exists-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-exists?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-exists-p &#34;path/to/file.txt&#34;) (f-exists-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-directory-p #+begin_example (f-directory-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-directory-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Aliases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;f-directory?&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-dir-p&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-dir?&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-directory-p &#34;path/to/file.txt&#34;) ;; =&amp;gt; nil (f-directory-p &#34;path/to/dir&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-file-p #+begin_example (f-file-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-regular-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-file?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-file-p &#34;path/to/file.txt&#34;) ;; =&amp;gt; t (f-file-p &#34;path/to/dir&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-symlink-p #+begin_example (f-symlink-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is symlink, false otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-symlink?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-symlink-p &#34;path/to/file.txt&#34;) ;; =&amp;gt; nil (f-symlink-p &#34;path/to/dir&#34;) ;; =&amp;gt; nil (f-symlink-p &#34;path/to/link&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-readable-p #+begin_example (f-readable-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-readable-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-readable?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-readable-p &#34;path/to/file.txt&#34;) (f-readable-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-writable-p #+begin_example (f-writable-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-writable-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-writable?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-writable-p &#34;path/to/file.txt&#34;) (f-writable-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-executable-p #+begin_example (f-executable-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-executable-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-executable?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-executable-p &#34;path/to/file.txt&#34;) (f-executable-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-absolute-p #+begin_example (f-absolute-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-name-absolute-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-absolute?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-absolute-p &#34;path/to/dir&#34;) ;; =&amp;gt; nil (f-absolute-p &#34;/full/path/to/dir&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-relative-p #+begin_example (f-relative-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is relative, false otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-relative?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-relative-p &#34;path/to/dir&#34;) ;; =&amp;gt; t (f-relative-p &#34;/full/path/to/dir&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-root-p #+begin_example (f-root-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is root directory, false otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-root?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-root-p &#34;/&#34;) ;; =&amp;gt; t (f-root-p &#34;/not/root&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-ext-p #+begin_example (f-ext-p path ext)&lt;/p&gt; &#xA;&lt;p&gt;Return t if extension of PATH is EXT, false otherwise.&lt;/p&gt; &#xA;&lt;p&gt;If EXT is nil or omitted, return t if PATH has any extension, false otherwise.&lt;/p&gt; &#xA;&lt;p&gt;The extension, in a file name, is the part that follows the last ’.’, excluding version numbers and backup suffixes. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-ext?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-ext-p &#34;path/to/file.el&#34; &#34;el&#34;) ;; =&amp;gt; t (f-ext-p &#34;path/to/file.el&#34; &#34;txt&#34;) ;; =&amp;gt; nil (f-ext-p &#34;path/to/file.el&#34;) ;; =&amp;gt; t (f-ext-p &#34;path/to/file&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-same-p #+begin_example (f-same-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A and PATH-B are references to same file. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Aliases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;f-same?&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-equal-p&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-equal?&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-same-p &#34;foo.txt&#34; &#34;foo.txt&#34;) ;; =&amp;gt; t (f-same-p &#34;/path/to/foo.txt&#34; &#34;/path/to/bar.txt&#34;) ;; =&amp;gt; nil (f-same-p &#34;foo/bar/../baz&#34; &#34;foo/baz&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-parent-of-p #+begin_example (f-parent-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is parent of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-parent-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-parent-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; t (f-parent-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil (f-parent-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-child-of-p #+begin_example (f-child-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is child of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-child-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-child-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; nil (f-child-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; t (f-child-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-ancestor-of-p #+begin_example (f-ancestor-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is ancestor of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-ancestor-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-ancestor-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; t (f-ancestor-of-p &#34;/path&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; t (f-ancestor-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil (f-ancestor-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-descendant-of-p #+begin_example (f-descendant-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is desendant of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-descendant-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-descendant-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; t (f-descendant-of-p &#34;/path/to/dir&#34; &#34;/path&#34;) ;; =&amp;gt; t (f-descendant-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; nil (f-descendant-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-hidden-p #+begin_example (f-hidden-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is hidden, nil otherwise.&lt;/p&gt; &#xA;&lt;p&gt;BEHAVIOR controls when a path should be considered as hidden depending on its value. Beware, if PATH begins with &#34;./&#34;, the current dir &#34;.&#34; will not be considered as hidden.&lt;/p&gt; &#xA;&lt;p&gt;When BEHAVIOR is nil, it will only check if the path begins with a dot, as in .a/b/c, and return t if there is one. This is the old behavior of f.el left as default for backward-compatibility purposes.&lt;/p&gt; &#xA;&lt;p&gt;When BEHAVIOR is ANY, return t if any of the elements of PATH is hidden, nil otherwise.&lt;/p&gt; &#xA;&lt;p&gt;When BEHAVIOR is LAST, return t only if the last element of PATH is hidden, nil otherwise.&lt;/p&gt; &#xA;&lt;p&gt;TODO: Hidden directories and files on Windows are marked differently than on *NIX systems. This should be properly implemented. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-hidden?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-hidden-p &#34;path/to/foo&#34;) ;; =&amp;gt; nil (f-hidden-p &#34;.path/to/foo&#34;) ;; =&amp;gt; t (f-hidden-p &#34;path/.to/foo&#34;) ;; =&amp;gt; nil (f-hidden-p &#34;path/to/.foo&#34;) ;; =&amp;gt; nil (f-hidden-p &#34;.path/to/foo&#34; &#39;any) ;; =&amp;gt; t (f-hidden-p &#34;path/.to/foo&#34; &#39;any) ;; =&amp;gt; t (f-hidden-p &#34;path/to/.foo&#34; &#39;any) ;; =&amp;gt; t (f-hidden-p &#34;.path/to/foo&#34; &#39;last) ;; =&amp;gt; nil (f-hidden-p &#34;path/.to/foo&#34; &#39;last) ;; =&amp;gt; nil (f-hidden-p &#34;path/to/.foo&#34; &#39;last) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-empty-p #+begin_example (f-empty-p path)&lt;/p&gt; &#xA;&lt;p&gt;If PATH is a file, return t if the file in PATH is empty, nil otherwise. If PATH is directory, return t if directory has no files, nil otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-empty?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-empty-p &#34;/path/to/empty-file&#34;) ;; =&amp;gt; t (f-empty-p &#34;/path/to/file-with-contents&#34;) ;; =&amp;gt; nil (f-empty-p &#34;/path/to/empty-dir/&#34;) ;; =&amp;gt; t (f-empty-p &#34;/path/to/dir-with-contents/&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-newer-p #+begin_example (f-newer-p file other &amp;amp;optional method)&lt;/p&gt; &#xA;&lt;p&gt;Compare if FILE is newer than OTHER.&lt;/p&gt; &#xA;&lt;p&gt;For more info on METHOD, see ‘f--date-compare’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-newer?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-newer-p &#34;newer.txt&#34; &#34;older.txt&#34;) ;; t (f-newer-p &#34;older.txt&#34;&#34;newer.txt&#34; ) ;; nil (f-newer-p &#34;same1.txt&#34; &#34;same2.txt&#34;) ;; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-older-p #+begin_example (f-older-p file other &amp;amp;optional method)&lt;/p&gt; &#xA;&lt;p&gt;Compare if FILE is older than OTHER.&lt;/p&gt; &#xA;&lt;p&gt;For more info on METHOD, see ‘f--date-compare’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-older?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-older-p &#34;older.txt&#34; &#34;newer.txt&#34;) ;; t (f-older-p &#34;newer.txt&#34;&#34;older.txt&#34; ) ;; nil (f-older-p &#34;same1.txt&#34; &#34;same2.txt&#34;) ;; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-same-time-p #+begin_example (f-same-time-p file other &amp;amp;optional method)&lt;/p&gt; &#xA;&lt;p&gt;Check if FILE and OTHER share the same access or modification time.&lt;/p&gt; &#xA;&lt;p&gt;For more info on METHOD, see ‘f--date-compare’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-same-time?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-same-time-p &#34;same1.txt&#34; &#34;same2.txt&#34;) ;; t (f-same-time-p &#34;newer.txt&#34; &#34;older.txt&#34;) ;; nil (f-same-time-p &#34;older.txt&#34; &#34;newer.txt&#34;) ;; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Stats *** f-size #+begin_example (f-size path)&lt;/p&gt; &#xA;&lt;p&gt;Return size of PATH.&lt;/p&gt; &#xA;&lt;p&gt;If PATH is a file, return size of that file. If PATH is directory, return sum of all files in PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-size &#34;path/to/file.txt&#34;) (f-size &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-depth #+begin_example (f-depth path)&lt;/p&gt; &#xA;&lt;p&gt;Return the depth of PATH.&lt;/p&gt; &#xA;&lt;p&gt;At first, PATH is expanded with ‘f-expand’. Then the full path is used to detect the depth. ’/’ will be zero depth, ’/usr’ will be one depth. And so on. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-depth &#34;/&#34;) ;; 0 (f-depth &#34;/var/&#34;) ;; 1 (f-depth &#34;/usr/local/bin&#34;) ;; 3 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-change-time #+begin_example (f-change-time path &amp;amp;optional timestamp-p)&lt;/p&gt; &#xA;&lt;p&gt;Return the last status change time of PATH.&lt;/p&gt; &#xA;&lt;p&gt;The status change time (ctime) of PATH in the same format as ‘current-time’. For details on TIMESTAMP-P and the format of the returned value, see ‘f--get-time’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-change-time &#34;path/to/file.txt&#34;) ;; (25517 48756 26337 111000) (f-change-time &#34;path/to/dir&#34;) ;; (25517 57887 344657 210000) (f-change-time &#34;path/to/file.txt&#34; t) ;; (1672330868026337111 . 1000000000) (f-change-time &#34;path/to/dir&#34; t) ;; (1672339999344657210 . 1000000000) (f-change-time &#34;path/to/file.txt&#34;&#39;seconds) ;; 1672330868 (f-change-time &#34;path/to/dir&#34;&#39;seconds) ;; 1672339999 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-modification-time #+begin_example (f-modification-time path &amp;amp;optional timestamp-p)&lt;/p&gt; &#xA;&lt;p&gt;Return the last modification time of PATH. The modification time (mtime) of PATH in the same format as ‘current-time’. For details on TIMESTAMP-P and the format of the returned value, see ‘f--get-time’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-modification-time &#34;path/to/file.txt&#34;) ;; (25517 48756 26337 111000) (f-modification-time &#34;path/to/dir&#34;) ;; (25517 57887 344657 210000) (f-modification-time &#34;path/to/file.txt&#34; t) ;; (1672330868026337111 . 1000000000) (f-modification-time &#34;path/to/dir&#34; t) ;; (1672339999344657210 . 1000000000) (f-modification-time &#34;path/to/file.txt&#34; &#39;seconds) ;; 1672330868 (f-modification-time &#34;path/to/dir&#34; &#39;seconds) ;; 1672339999 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-access-time #+begin_example (f-access-time path &amp;amp;optional timestamp-p)&lt;/p&gt; &#xA;&lt;p&gt;Return the last access time of PATH. The access time (atime) of PATH is in the same format as ‘current-time’. For details on TIMESTAMP-P and the format of the returned value, see ‘f--get-time’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-access-time &#34;path/to/file.txt&#34;) ;; (25517 48756 26337 111000) (f-access-time &#34;path/to/dir&#34;) ;; (25517 57887 344657 210000) (f-access-time &#34;path/to/file.txt&#34; t) ;; (1672330868026337111 . 1000000000) (f-access-time &#34;path/to/dir&#34; t) ;; (1672339999344657210 . 1000000000) (f-access-time &#34;path/to/file.txt&#34; &#39;seconds) ;; 1672330868 (f-access-time &#34;path/to/dir&#34; &#39;seconds) ;; 1672339999 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Misc *** f-this-file #+begin_example (f-this-file)&lt;/p&gt; &#xA;&lt;p&gt;Return path to this file. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-this-file) ;; =&amp;gt; /path/to/this/file #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-path-separator #+begin_example (f-path-separator)&lt;/p&gt; &#xA;&lt;p&gt;Return path separator. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-path-separator) ;; =&amp;gt; / #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-glob #+begin_example (f-glob pattern &amp;amp;optional path)&lt;/p&gt; &#xA;&lt;p&gt;Find PATTERN in PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-glob &#34;path/to/&lt;em&gt;.el&#34;) (f-glob &#34;&lt;/em&gt;.el&#34; &#34;path/to&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-entries #+begin_example (f-entries path &amp;amp;optional fn recursive)&lt;/p&gt; &#xA;&lt;p&gt;Find all files and directories in PATH.&lt;/p&gt; &#xA;&lt;p&gt;FN - called for each found file and directory. If FN returns a thruthy value, file or directory will be included. RECURSIVE - Search for files and directories recursive. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-entries &#34;path/to/dir&#34;) (f-entries &#34;path/to/dir&#34; (lambda (file) (s-matches? &#34;test&#34; file))) (f-entries &#34;path/to/dir&#34; nil t) (f--entries &#34;path/to/dir&#34; (s-matches? &#34;test&#34; it)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-directories #+begin_example (f-directories path &amp;amp;optional fn recursive)&lt;/p&gt; &#xA;&lt;p&gt;Find all directories in PATH. See ‘f-entries’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-directories &#34;path/to/dir&#34;) (f-directories &#34;path/to/dir&#34; (lambda (dir) (equal (f-filename dir) &#34;test&#34;))) (f-directories &#34;path/to/dir&#34; nil t) (f--directories &#34;path/to/dir&#34; (equal (f-filename it) &#34;test&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-files #+begin_example (f-files path &amp;amp;optional fn recursive)&lt;/p&gt; &#xA;&lt;p&gt;Find all files in PATH. See ‘f-entries’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-files &#34;path/to/dir&#34;) (f-files &#34;path/to/dir&#34; (lambda (file) (equal (f-ext file) &#34;el&#34;))) (f-files &#34;path/to/dir&#34; nil t) (f--files &#34;path/to/dir&#34; (equal (f-ext it) &#34;el&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-root #+begin_example (f-root)&lt;/p&gt; &#xA;&lt;p&gt;Return absolute root. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-root) ;; =&amp;gt; &#34;/&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-traverse-upwards #+begin_example (f-traverse-upwards fn &amp;amp;optional path)&lt;/p&gt; &#xA;&lt;p&gt;Traverse up as long as FN return nil, starting at PATH.&lt;/p&gt; &#xA;&lt;p&gt;If FN returns a non-nil value, the path sent as argument to FN is returned. If no function callback return a non-nil value, nil is returned. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-traverse-upwards (lambda (path) (f-exists? (f-expand &#34;.git&#34; path))) start-path)&lt;/p&gt; &#xA;&lt;p&gt;(f--traverse-upwards (f-exists? (f-expand &#34;.git&#34; it)) start-path) ;; same as above #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-with-sandbox #+begin_example (f-with-sandbox path-or-paths &amp;amp;rest body)&lt;/p&gt; &#xA;&lt;p&gt;Only allow PATH-OR-PATHS and descendants to be modified in BODY. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-with-sandbox foo-path (f-touch (f-expand &#34;foo&#34; foo-path))) (f-with-sandbox (list foo-path bar-path) (f-touch (f-expand &#34;foo&#34; foo-path)) (f-touch (f-expand &#34;bar&#34; bar-path))) (f-with-sandbox foo-path (f-touch (f-expand &#34;bar&#34; bar-path))) ;; &#34;Destructive operation outside sandbox&#34; #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here&#39;s an example of a function that finds the Git project root.&lt;/p&gt; &#xA;&lt;p&gt;** Using standard Emacs builtin functions #+begin_src emacs-lisp (defun find-git-root (&amp;amp;optional dir) (unless dir (setq dir (expand-file-name (file-name-directory (buffer-file-name))))) (let ((parent (expand-file-name &#34;..&#34; dir))) (unless (equal parent dir) (if (file-exists-p (expand-file-name &#34;.git&#34; dir)) dir (find-git-root parent))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Using f.el #+begin_src emacs-lisp (defun find-git-root (&amp;amp;optional dir) (interactive) (unless dir (setq dir (f-dirname (buffer-file-name)))) (let ((parent (f-parent dir))) (unless (f-root? parent) (if (f-exists? (f-expand &#34;.git&#34; dir)) dir (find-git-root parent))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Now, try writing it even simpler yourself. Hint, check out &lt;del&gt;f-traverse-upwards&lt;/del&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>