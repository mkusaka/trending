<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-01T02:12:30Z</updated>
  <subtitle>Monthly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>minad/marginalia</title>
    <updated>2023-06-01T02:12:30Z</updated>
    <id>tag:github.com,2023-06-01:/minad/marginalia</id>
    <link href="https://github.com/minad/marginalia" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ“œ marginalia.el - Marginalia in the minibuffer&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: marginalia.el - Marginalia in the minibuffer #+author: Omar AntolÃ­n Camarena, Daniel Mendler #+language: en #+export_file_name: marginalia.texi #+texinfo_dir_category: Emacs misc features #+texinfo_dir_title: Marginalia: (marginalia). #+texinfo_dir_desc: Marginalia in the minibuffer&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img alt=&#34;GNU Emacs&#34; src=&#34;https://github.com/minad/corfu/raw/screenshots/emacs.svg?raw=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://elpa.gnu.org/packages/marginalia.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/marginalia.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://elpa.gnu.org/devel/marginalia.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/marginalia.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/marginalia&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/marginalia-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://stable.melpa.org/#/marginalia&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/marginalia-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/4/4f/Marginalia_%285095211566%29.jpg&#34; align=&#34;right&#34; width=&#34;30%&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This package provides =marginalia-mode= which adds marginalia to the minibuffer completions. [[https://en.wikipedia.org/wiki/Marginalia][Marginalia]] are marks or annotations placed at the margin of the page of a book or in this case helpful colorful annotations placed at the margin of the minibuffer for your completion candidates. Marginalia can only add annotations to the completion candidates. It cannot modify the appearance of the candidates themselves, which are shown unaltered as supplied by the original command.&lt;/p&gt; &#xA;&lt;p&gt;The annotations are added based on the completion category. For example =find-file= reports the =file= category and =M-x= reports the =command= category. You can cycle between more or less detailed annotators or even disable the annotator with command =marginalia-cycle=.&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;img src=&#34;https://github.com/minad/marginalia/raw/screenshots/marginalia-mode.png?raw=true&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+toc: headlines 8&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is recommended to use Marginalia together with either the [[https://github.com/minad/vertico][Vertico]], [[https://github.com/protesilaos/mct][Mct]], [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Icomplete.html][Icomplete]] or the default completion UI. Furthermore Marginalia can be combined with [[https://github.com/oantolin/embark][Embark]] for action support and [[https://github.com/minad/consult][Consult]], which provides many useful commands.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Enable rich annotations using the Marginalia package (use-package marginalia ;; Bind &lt;code&gt;marginalia-cycle&#39; locally in the minibuffer. To make the binding ;; available in the *Completions* buffer, add it to the ;; &lt;/code&gt;completion-list-mode-map&#39;. :bind (:map minibuffer-local-map (&#34;M-A&#34; . marginalia-cycle))&lt;/p&gt; &#xA;&lt;p&gt;;; The :init section is always executed. :init&lt;/p&gt; &#xA;&lt;p&gt;;; Marginalia must be actived in the :init section of use-package such that ;; the mode gets enabled right away. Note that this forces loading the ;; package. (marginalia-mode)) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Information shown by the annotators&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In general, to learn more about what different annotations mean, a good starting point is to look at &lt;del&gt;marginalia-annotator-registry&lt;/del&gt;, and follow up to the annotation function of the category you are interested in.&lt;/p&gt; &#xA;&lt;p&gt;For example the annotations for Elisp symbols include their symbol class - =v= for variable, =f= for function, =c= for command, etc. For more information on what the different classifications mean, see the docstring of &lt;del&gt;marginalia--symbol-class&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Adding custom annotators or classifiers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;IMPORTANT NOTICE FOR PACKAGE AUTHORS&lt;/em&gt;: The intention of the Marginalia package is to give the user means to overwrite completion categories and to add custom annotators for existing commands in their user configuration. &lt;em&gt;Marginalia is a user facing package and is not intended to be used as a library&lt;/em&gt;. Therefore Marginalia does not expose library functions as part of its public API. If you add your own completion commands to your package we recommend to specify an =annotation-function= or an =affixation-function=, avoiding the Marginalia dependency this way. The =annotation-function= and =affixation-function= are documented in the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion.html][Elisp manual]]. If you use =consult--read=, you can specify an =:annotate= keyword argument. There is an exception to our recommendation: If you want to implement annotations for an existing package =hypothetic.el=, which does not have annotations and where annotations cannot be added, then the creation of a =marginalia-hypothetic.el= package is a good idea, since Marginalia provides the facilities to enhance existing commands from the outside. If you have questions feel free to ask on the Marginalia issue tracker.&lt;/p&gt; &#xA;&lt;p&gt;Commands that support minibuffer completion use a completion table of all the available candidates. Candidates are associated with a &lt;em&gt;category&lt;/em&gt; such as =command=, =file=, =face=, or =variable= depending on what the candidates are. Based on the category of the candidates, Marginalia selects an &lt;em&gt;annotator&lt;/em&gt; to generate annotations for display for each candidate.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, not all commands (including Emacs&#39; builtin ones) specify the category of their candidates. To compensate for this shortcoming, Marginalia hooks into the Emacs completion framework and runs the &lt;em&gt;classifiers&lt;/em&gt; listed in the variable =marginalia-classifiers=, which use the command&#39;s prompt or other properties of the candidates to specify the completion category.&lt;/p&gt; &#xA;&lt;p&gt;For example, the =marginalia-classify-by-prompt= classifier checks the minibuffer prompt against regexps listed in the =marginalia-prompt-categories= alist to determine a category. The following is already included but would be a way to assign the category =face= to all candidates from commands with prompts that include the word &#34;face&#34;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (add-to-list &#39;marginalia-prompt-categories &#39;(&#34;\&amp;lt;face\&amp;gt;&#34; . face)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =marginalia-classify-by-command-name= classifier uses the alist =marginalia-command-categories= to specify the completion category based on the command name. This is particularly useful if the prompt classifier yields a false positive.&lt;/p&gt; &#xA;&lt;p&gt;Completion categories are also important for [[https://github.com/oantolin/embark][Embark]], which associates actions based on the completion category and benefits from Marginalia&#39;s classifiers.&lt;/p&gt; &#xA;&lt;p&gt;Once the category of the candidates is known, Marginalia looks in the =marginalia-annotator-registry= to find the associated annotator to use. An annotator is a function that takes a completion candidate string as an argument and returns an annotation string to be displayed after the candidate in the minibuffer. More than one annotator can be assigned to each each category, displaying more, less or different information. Use the =marginalia-cycle= command to cycle between the annotations of different annotators defined for the current category.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of a basic face annotator:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun my-face-annotator (cand) (when-let (sym (intern-soft cand)) (concat (propertize &#34; &#34; &#39;display &#39;(space :align-to center)) (propertize &#34;The quick brown fox jumps over the lazy dog&#34; &#39;face sym)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Look at Marginalia&#39;s various annotators for examples of formatting annotations. In particular, the helper function =marginalia--fields= can be used to format information into columns.&lt;/p&gt; &#xA;&lt;p&gt;After defining a new annotator, associate it with a category in the annotator registry as follows:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (add-to-list &#39;marginalia-annotator-registry &#39;(face my-face-annotator marginalia-annotate-face builtin none)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This makes the =my-face-annotator= the first of four annotators for the face category. The others are the annotator provided by Marginalia (=marginalia-annotate-face=), the =builtin= annotator as defined by Emacs and the =none= annotator, which disables the annotations. With this setting, after invoking =M-x describe-face RET= you can cycle between all of these annotators using =marginalia-cycle=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Disabling annotators, builtin or lightweight annotators&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Marginalia activates rich annotators by default. Depending on your preference you may want to use the builtin annotators or even no annotators by default and only activate the annotators on demand by invoking &lt;del&gt;marginalia-cycle&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to use the builtin annotators by default, you can use the following command. Replace =builtin= by =none= to disable annotators by default.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun marginalia-use-builtin () (interactive) (mapc (lambda (x) (setcdr x (cons &#39;builtin (remq &#39;builtin (cdr x))))) marginalia-annotator-registry)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If a completion category supports two annotators, you can toggle between those using this command.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun marginalia-toggle () (interactive) (mapc (lambda (x) (setcdr x (append (reverse (remq &#39;none (remq &#39;builtin (cdr x)))) &#39;(builtin none)))) marginalia-annotator-registry)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;After cycling the annotators you may want to automatically save the configuration. This can be achieved using an advice which calls &lt;del&gt;customize-save-variable&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (advice-add #&#39;marginalia-cycle :after (lambda () (let ((inhibit-message t)) (customize-save-variable &#39;marginalia-annotator-registry marginalia-annotator-registry)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In order to disable an annotator permanently, the &lt;del&gt;marginalia-annotator-registry&lt;/del&gt; can be modified. For example if you prefer to never see file annotations, you can delete all file annotators from the registry.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq marginalia-annotator-registry (assq-delete-all &#39;file marginalia-annotator-registry)) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Icons in the minibuffer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Icons in the minibuffer completion UI are a commonly requested feature. Marginalia focuses on text annotations only. The following packages are compatible with Marginalia and use special fonts to add icons in front of completion candidates. There also exist related packages to enhance Dired, Ibuffer and other modes with icons consistently.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/iyefrat/all-the-icons-completion][all-the-icons-completion]]: Relies on the =all-the-icons.el= package which configures multiple icon fonts.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/rainstormstudio/nerd-icons-completion][nerd-icons-completion]]: Relies on patched fonts including icons. This package works even in the terminal where only a single font can be used.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since this package is part of [[https://elpa.gnu.org/packages/marginalia.html][GNU ELPA]] contributions require a copyright assignment to the FSF.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>oantolin/embark</title>
    <updated>2023-06-01T02:12:30Z</updated>
    <id>tag:github.com,2023-06-01:/oantolin/embark</id>
    <link href="https://github.com/oantolin/embark" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs Mini-Buffer Actions Rooted in Keymaps&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Embark: Emacs Mini-Buffer Actions Rooted in Keymaps #+OPTIONS: d:nil #+EXPORT_FILE_NAME: embark.texi #+TEXINFO_DIR_CATEGORY: Emacs misc features #+TEXINFO_DIR_TITLE: Embark: (embark). #+TEXINFO_DIR_DESC: Emacs Mini-Buffer Actions Rooted in Keymaps&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;http://elpa.gnu.org/packages/embark.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/embark.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/devel/embark.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/embark.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/embark&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/embark-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://stable.melpa.org/#/embark&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/embark-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Overview&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Embark makes it easy to choose a command to run based on what is near point, both during a minibuffer completion session (in a way familiar to Helm or Counsel users) and in normal buffers. Bind the command =embark-act= to a key and it acts like prefix-key for a keymap of /actions/ (commands) relevant to the /target/ around point. With point on an URL in a buffer you can open the URL in a browser or eww or download the file it points to. If while switching buffers you spot an old one, you can kill it right there and continue to select another. Embark comes preconfigured with over a hundred actions for common types of targets such as files, buffers, identifiers, s-expressions, sentences; and it is easy to add more actions and more target types. Embark can also collect all the candidates in a minibuffer to an occur-like buffer or export them to a buffer in a major-mode specific to the type of candidates, such as dired for a set of files, ibuffer for a set of buffers, or customize for a set of variables.&lt;/p&gt; &#xA;&lt;p&gt;** Acting on targets&lt;/p&gt; &#xA;&lt;p&gt;You can think of =embark-act= as a keyboard-based version of a right-click contextual menu. The =embark-act= command (which you should bind to a convenient key), acts as a prefix for a keymap offering you relevant /actions/ to use on a /target/ determined by the context:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In the minibuffer, the target is the current top completion candidate.&lt;/li&gt; &#xA; &lt;li&gt;In the =&lt;em&gt;Completions&lt;/em&gt;= buffer the target is the completion at point.&lt;/li&gt; &#xA; &lt;li&gt;In a regular buffer, the target is the region if active, or else the file, symbol, URL, s-expression or defun at point.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Multiple targets can be present at the same location and you can cycle between them by repeating the =embark-act= key binding. The type of actions offered depend on the type of the target. Here is a sample of a few of the actions offered in the default configuration:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For files you get offered actions like deleting, copying, renaming, visiting in another window, running a shell command on the file, etc.&lt;/li&gt; &#xA; &lt;li&gt;For buffers the actions include switching to or killing the buffer.&lt;/li&gt; &#xA; &lt;li&gt;For package names the actions include installing, removing or visiting the homepage.&lt;/li&gt; &#xA; &lt;li&gt;For Emacs Lisp symbols the actions include finding the definition, looking up documentation, evaluating (which for a variable immediately shows the value, but for a function lets you pass it some arguments first). There are some actions specific to variables, such as setting the value directly or though the customize system, and some actions specific to commands, such as binding it to a key.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default when you use =embark-act= if you don&#39;t immediately select an action, after a short delay Embark will pop up a buffer showing a list of actions and their corresponding key bindings. If you are using =embark-act= outside the minibuffer, Embark will also highlight the current target. These behaviors are configurable via the variable =embark-indicators=. Instead of selecting an action via its key binding, you can select it by name with completion by typing =C-h= after =embark-act=.&lt;/p&gt; &#xA;&lt;p&gt;Everything is easily configurable: determining the current target, classifying it, and deciding which actions are offered for each type in the classification. The above introduction just mentions part of the default configuration.&lt;/p&gt; &#xA;&lt;p&gt;Configuring which actions are offered for a type is particularly easy and requires no programming: the variable =embark-keymap-alist= associates target types with variables containing keymaps, and those keymaps containing bindings for the actions. (To examine the available categories and their associated keymaps, you can use =C-h v embark-keymap-alist= or customize that variable.) For example, in the default configuration the type =file= is associated with the symbol =embark-file-map=. That symbol names a keymap with single-letter key bindings for common Emacs file commands, for instance =c= is bound to =copy-file=. This means that if you are in the minibuffer after running a command that prompts for a file, such as =find-file= or =rename-file=, you can copy a file by running =embark-act= and then pressing =c=.&lt;/p&gt; &#xA;&lt;p&gt;These action keymaps are very convenient but not strictly necessary when using =embark-act=: you can use any command that reads from the minibuffer as an action and the target of the action will be inserted at the first minibuffer prompt. After running =embark-act= all of your key bindings and even =execute-extended-command= can be used to run a command. For example, if you want to replace all occurrences of the symbol at point, just use =M-%= as the action, there is no need to bind =query-replace= in one of Embark&#39;s keymaps. Also, those action keymaps are normal Emacs keymaps and you should feel free to bind in them whatever commands you find useful as actions and want to be available through convenient bindings.&lt;/p&gt; &#xA;&lt;p&gt;The actions in =embark-general-map= are available no matter what type of completion you are in the middle of. By default this includes bindings to save the current candidate in the kill ring and to insert the current candidate in the previously selected buffer (the buffer that was current when you executed a command that opened up the minibuffer).&lt;/p&gt; &#xA;&lt;p&gt;Emacs&#39;s minibuffer completion system includes metadata indicating the /category/ of what is being completed. For example, =find-file=&#39;s metadata indicates a category of =file= and =switch-to-buffer=&#39;s metadata indicates a category of =buffer=. Embark has the related notion of the /type/ of a target for actions, and by default when category metadata is present it is taken to be the type of minibuffer completion candidates when used as targets. Emacs commands often do not set useful category metadata so the [[https://github.com/minad/marginalia][Marginalia]] package, which supplies this missing metadata, is highly recommended for use with Embark.&lt;/p&gt; &#xA;&lt;p&gt;Embark&#39;s default configuration has actions for the following target types: files, buffers, symbols, packages, URLs, bookmarks, and as a somewhat special case, actions for when the region is active. You can read about the [[https://github.com/oantolin/embark/wiki/Default-Actions][default actions and their key bindings]] on the GitHub project wiki.&lt;/p&gt; &#xA;&lt;p&gt;** The default action on a target&lt;/p&gt; &#xA;&lt;p&gt;Embark has a notion of default action for a target:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If the target is a minibuffer completion candidate, then the default action is whatever command opened the minibuffer in the first place. For example if you run =kill-buffer=, then the default action will be to kill buffers.&lt;/li&gt; &#xA; &lt;li&gt;If the target comes from a regular buffer (i.e., not a minibuffer), then the default action is whatever is bound to =RET= in the keymap of actions for that type of target. For example, in Embark&#39;s default configuration for a URL found at point the default action is =browse-url=, because =RET= is bound to =browse-url= in the =embark-url-map= keymap.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To run the default action you can press =RET= after running =embark-act=. Note that if there are several different targets at a given location, each has its own default action, so first cycle to the target you want and then press =RET= to run the corresponding default action.&lt;/p&gt; &#xA;&lt;p&gt;There is also =embark-dwim= which runs the default action for the first target found. It&#39;s pretty handy in non-minibuffer buffers: with Embark&#39;s default configuration it will:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open the file at point.&lt;/li&gt; &#xA; &lt;li&gt;Open the URL at point in a web browser (using the =browse-url= command).&lt;/li&gt; &#xA; &lt;li&gt;Compose a new email to the email address at point.&lt;/li&gt; &#xA; &lt;li&gt;In an Emacs Lisp buffer, if point is on an opening parenthesis or right after a closing one, it will evaluate the corresponding expression.&lt;/li&gt; &#xA; &lt;li&gt;Go to the definition of an Emacs Lisp function, variable or macro at point.&lt;/li&gt; &#xA; &lt;li&gt;Find the file corresponding to an Emacs Lisp library at point.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Working with sets of possible targets&lt;/p&gt; &#xA;&lt;p&gt;Besides acting individually on targets, Embark lets you work collectively on a set of target /candidates/. For example, while you are in the minibuffer the candidates are simply the possible completions of your input. Embark provides three main commands to work on candidate sets:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The =embark-act-all= command runs the same action on each of the current candidates. It is just like using =embark-act= on each candidate in turn. (Because you can easily act on many more candidates than you meant to, by default Embark asks you to confirm uses of =embark-act-all=; you can turn this off by setting the user option =embark-confirm-act-all= to =nil=.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The =embark-collect= command produces a buffer listing all the current candidates, for you to peruse and run actions on at your leisure. The candidates are displayed as a list showing additional annotations.&lt;/p&gt; &lt;p&gt;The Embark Collect buffer is somewhat &#34;dired-like&#34;: you can select and deselect candidates through the =embark-select= action (bound to =SPC=). In an Embark Collect buffer =embark-act= is bound to =a= and =embark-act-all= is bound to =A=; =embark-act-all= will act on all currently marked candidates if there any, and will act on all candidates if none are marked. In particular, this means that =a SPC= will toggle whether the candidate at point is selected, and =A SPC= will select all candidates if none are selected, or deselect all selected candidates if there are some.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The =embark-export= command tries to open a buffer in an appropriate major mode for the set of candidates. If the candidates are files export produces a Dired buffer; if they are buffers, you get an Ibuffer buffer; and if they are packages you get a buffer in package menu mode.&lt;/p&gt; &lt;p&gt;If you use the grepping commands from the [[https://github.com/minad/consult/][Consult]] package, =consult-grep=, =consult-git-grep= or =consult-ripgrep=, then you should install the =embark-consult= package, which adds support for exporting a list of grep results to an honest grep-mode buffer, on which you can even use [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]] if you wish.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When in doubt choosing between exporting and collecting, a good rule of thumb is to always prefer =embark-export= since when an exporter to a special major mode is available for a given type of target, it will be more featureful than an Embark collect buffer, and if no such exporter is configured the =embark-export= command falls back to the generic =embark-collect=.&lt;/p&gt; &#xA;&lt;p&gt;These commands are always available as &#34;actions&#34; (although they do not act on just the current target but on all candidates) for =embark-act= and are bound to =A=, =S= (for &#34;snapshot&#34;), and =E=, respectively, in =embark-general-map=. This means that you do not have to bind your own key bindings for these (although you can, of course!), just a key binding for =embark-act=.&lt;/p&gt; &#xA;&lt;p&gt;In Embark Collect or Embark Export buffers that were obtained by running =embark-collect= or =embark-export= from within a minibuffer completion session, =g= is bound to a command that restarts the completion session, that is, the command that opened the minibuffer is run again and the minibuffer contents restored. You can then interact normally with the command, perhaps editing the minibuffer contents, and, if you wish, you can rerun =embark-collect= or =embark-export= to get an updated buffer.&lt;/p&gt; &#xA;&lt;p&gt;*** Selecting some targets to make an ad hoc candidate set&lt;/p&gt; &#xA;&lt;p&gt;The commands for working with sets of candidates just described, namely =embark-act-all=, =embark-export= and =embark-collect= by default work with all candidates defined in the current context. For example, in the minibuffer they operate on all currently completion candidates, or in a dired buffer they work on all marked files (or all files if none are marked). Embark also has a notion of /selection/, where you can accumulate an ad hoc list of targets for these commands to work on.&lt;/p&gt; &#xA;&lt;p&gt;The selection is controlled by using the =embark-select= action (which must be run as an action through =embark-act=), bound to =SPC= in =embark-general-map= so that it is always available. Calling this action on a target toggles its membership in the current buffer&#39;s Embark selection; that is, it adds it to selection if not selected and removes it from the selection if it was selected. Whenever the selection for a buffer is non-empty, the commands =embark-act-all=, =embark-export= and =embark-collect= will act on the selection.&lt;/p&gt; &#xA;&lt;p&gt;To deselect all selected targets, you can use the =embark-select= action through =embark-act-all=, since this will run =embark-select= on each member of the current selection. Similarly if no targets are selected and you are in a minibuffer completion session, running =embark-select= from =embark-act-all= will select all the current completion candidates.&lt;/p&gt; &#xA;&lt;p&gt;By default, whenever some targets are selected in the current buffer, a count of selected targets appears in the mode line. This can be turned off or customized through the =embark-selection-indicator= user option.&lt;/p&gt; &#xA;&lt;p&gt;The selection functionality is supported in every buffer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In the minibuffer this gives a convenient way to act on several completion candidates that don&#39;t follow any simple pattern: just go through the completions selecting the ones you want, then use =embark-act-all=. For example, you could attach several files at once to an email.&lt;/li&gt; &#xA; &lt;li&gt;For Embark Collect buffers this functionality enables a dired-like workflow, in which you mark various candidates and apply an action to all at once. (It supersedes a previous ad hoc dired-like interface that was implemented only in Embark Collect buffers, with a slightly different interface.)&lt;/li&gt; &#xA; &lt;li&gt;In a eww buffer you could use this to select various links you wish to follow up on, and then collect them into a buffer. Similarly, while reading Emacs&#39;s info manual you could select some symbols you want to read more about and export them to an =apropos-mode= buffer.&lt;/li&gt; &#xA; &lt;li&gt;You can use selections in regular text or programming buffers to do complex editing operations. For example, if you have three paragraphs scattered over a file and you want to bring them together, you can select each one, insert them all somewhere and finally delete all of them (from their original locations).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** =embark-live= a live-updating variant of =embark-collect=&lt;/p&gt; &#xA;&lt;p&gt;Finally, there is also an =embark-live= variant of the =embark-collect= command which automatically updates the collection after each change in the source buffer. Users of a completion UI that automatically updates and displays the candidate list (such as Vertico, Icomplete, Fido-mode, or MCT) will probably not want to use =embark-live= from the minibuffer as they will then have two live updating displays of the completion candidates!&lt;/p&gt; &#xA;&lt;p&gt;A more likely use of =embark-live= is to be called from a regular buffer to display a sort of live updating &#34;table of contents&#34; for the buffer. This depends on having appropriate candidate collectors configured in =embark-candidate-collectors=. There are not many in Embark&#39;s default configuration, but you can try this experiment: open a dired buffer in a directory that has very many files, mark a few, and run =embark-live=. You&#39;ll get an Embark Collect buffer containing only the marked files, which updates as you mark or unmark files in dired. To make =embark-live= genuinely useful other candidate collectors are required. The =embark-consult= package (documented near the end of this manual) contains a few: one for imenu items and one for outline headings as used by =outline-minor-mode=. Those collectors really do give =embark-live= a table-of-contents feel.&lt;/p&gt; &#xA;&lt;p&gt;** Switching to a different command without losing what you&#39;ve typed&lt;/p&gt; &#xA;&lt;p&gt;Embark also has the =embark-become= command which is useful for when you run a command, start typing at the minibuffer and realize you meant a different command. The most common case for me is that I run =switch-to-buffer=, start typing a buffer name and realize I haven&#39;t opened the file I had in mind yet! I&#39;ll use this situation as a running example to illustrate =embark-become=. When this happens I can, of course, press =C-g= and then run =find-file= and open the file, but this requires retyping the portion of the file name you already typed. This process can be streamlined with =embark-become=: while still in the =switch-to-buffer= you can run =embark-become= and effectively make the =switch-to-buffer= command become =find-file= for this run.&lt;/p&gt; &#xA;&lt;p&gt;You can bind =embark-become= to a key in =minibuffer-local-map=, but it is also available as an action under the letter =B= (uppercase), so you don&#39;t need a binding if you already have one for =embark-act=. So, assuming I have =embark-act= bound to, say, =C-.=, once I realize I haven&#39;t open the file I can type =C-. B C-x C-f= to have =switch-to-buffer= become =find-file= without losing what I have already typed in the minibuffer.&lt;/p&gt; &#xA;&lt;p&gt;But for even more convenience, =embark-become= offers shorter key bindings for commands you are likely to want the current command to become. When you use =embark-become= it looks for the current command in all keymaps named in the list =embark-become-keymaps= and then activates all keymaps that contain it. For example, the default value of =embark-become-keymaps= contains a keymap =embark-become-file+buffer-map= with bindings for several commands related to files and buffers, in particular, it binds =switch-to-buffer= to =b= and =find-file= to =f=. So when I accidentally try to switch to a buffer for a file I haven&#39;t opened yet, =embark-become= finds that the command I ran, =switch-to-buffer=, is in the keymap =embark-become-file+buffer-map=, so it activates that keymap (and any others that also contain a binding for =switch-to-buffer=). The end result is that I can type =C-. B f= to switch to =find-file=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Quick start&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The easiest way to install Embark is from GNU ELPA, just run =M-x package-install RET embark RET=. (It is also available on MELPA.) It is highly recommended to also install [[https://github.com/minad/marginalia][Marginalia]] (also available on GNU ELPA), so that Embark can offer you preconfigured actions in more contexts. For =use-package= users, the following is a very reasonable starting configuration:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (use-package marginalia :ensure t :config (marginalia-mode))&lt;/p&gt; &#xA;&lt;p&gt;(use-package embark :ensure t&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:bind&#xA;((&#34;C-.&#34; . embark-act)         ;; pick some comfortable binding&#xA; (&#34;C-;&#34; . embark-dwim)        ;; good alternative: M-.&#xA; (&#34;C-h B&#34; . embark-bindings)) ;; alternative for `describe-bindings&#39;&#xA;&#xA;:init&#xA;&#xA;;; Optionally replace the key help with a completing-read interface&#xA;(setq prefix-help-command #&#39;embark-prefix-help-command)&#xA;&#xA;;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc&#xA;;; strategy, if you want to see the documentation from multiple providers.&#xA;(add-hook &#39;eldoc-documentation-functions #&#39;embark-eldoc-first-target)&#xA;;; (setq eldoc-documentation-strategy #&#39;eldoc-documentation-compose-eagerly)&#xA;&#xA;:config&#xA;&#xA;;; Hide the mode line of the Embark live/completions buffers&#xA;(add-to-list &#39;display-buffer-alist&#xA;             &#39;(&#34;\\`\\*Embark Collect \\(Live\\|Completions\\)\\*&#34;&#xA;               nil&#xA;               (window-parameters (mode-line-format . none)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;;; Consult users will also want the embark-consult package. (use-package embark-consult :ensure t ; only need to install it, embark loads it after consult if found :hook (embark-collect-mode . consult-preview-at-point-mode)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;About the suggested key bindings for =embark-act= and =embark-dwim=:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Those key bindings are unlikely to work in the terminal, but terminal users are probably well aware of this and will know to select different bindings.&lt;/li&gt; &#xA; &lt;li&gt;The suggested =C-.= binding is used by default in (at least some installations of) GNOME to input emojis, and Emacs doesn&#39;t even get a chance to respond to the binding. You can select a different key binding for =embark-act= or use =ibus-setup= to change the shortcut for emoji insertion (Emacs 29 will likely use =C-x 8 e e=, in case you want to set the same one system-wide).&lt;/li&gt; &#xA; &lt;li&gt;The suggested alternative of =M-.= for =embark-dwim= is bound by default to =xref-find-definitions=. That is a very useful command but overwriting it with =embark-dwim= is sensible since in Embark&#39;s default configuration, =embark-dwim= will also find the definition of the identifier at point. (Note that =xref-find-definitions= with a prefix argument prompts you for an identifier, =embark-dwim= does not cover this case).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Other Embark commands such as =embark-act-all=, =embark-become=, =embark-collect=, and =embark-export= can be run through =embark-act= as actions bound to =A=, =B=, =S= (for &#34;snapshot&#34;), and =E= respectively, and thus don&#39;t really need a dedicated key binding, but feel free to bind them directly if you so wish. If you do choose to bind them directly, you&#39;ll probably want to bind them in =minibuffer-local-map=, since they are most useful in the minibuffer (in fact, =embark-become= only works in the minibuffer).&lt;/p&gt; &#xA;&lt;p&gt;The command =embark-dwim= executes the default action at point. Another good keybinding for =embark-dwim= is =M-.= since =embark-dwim= acts like =xref-find-definitions= on the symbol at point. =C-.= can be seen as a right-click context menu at point and =M-.= acts like left-click. The keybindings are mnemonic, both act at the point (=.=).&lt;/p&gt; &#xA;&lt;p&gt;Embark needs to know what your minibuffer completion system considers to be the list of candidates and which one is the current candidate. Embark works out of the box if you use Emacs&#39;s default tab completion, the built-in =icomplete-mode= or =fido-mode=, or the third-party packages [[https://github.com/minad/vertico][Vertico]] or [[https://github.com/abo-abo/swiper][Ivy]].&lt;/p&gt; &#xA;&lt;p&gt;If you are a [[https://emacs-helm.github.io/helm/][Helm]] or [[https://github.com/abo-abo/swiper][Ivy]] user you are unlikely to want Embark since those packages include comprehensive functionality for acting on minibuffer completion candidates. (Embark does come with Ivy integration despite this.)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Advanced configuration ** Showing information about available targets and actions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default, if you run =embark-act= and do not immediately select an action, after a short delay Embark will pop up a buffer called =&lt;em&gt;Embark Actions&lt;/em&gt;= containing a list of available actions with their key bindings. You can scroll that buffer with the mouse of with the usual commands =scroll-other-window= and =scroll-other-window-down= (bound by default to =C-M-v= and =C-M-S-v=).&lt;/p&gt; &#xA;&lt;p&gt;That functionality is provided by the =embark-mixed-indicator=, but Embark has other indicators that can provide information about the target and its type, what other targets you can cycle to, and which actions have key bindings in the action map for the current type of target. Any number of indicators can be active at once and the user option =embark-indicators= should be set to a list of the desired indicators.&lt;/p&gt; &#xA;&lt;p&gt;Embark comes with the following indicators:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark-minimal-indicator=: shows a messages in the echo area or minibuffer prompt showing the current target and the types of all targets starting with the current one; this one is on by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark-highlight-indicator=: highlights the target at point; also on by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark-verbose-indicator=: displays a table of actions and their key bindings in a buffer; this is not on by default, in favor of the mixed indicator described next.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark-mixed-indicator=: starts out by behaving as the minimal indicator but after a short delay acts as the verbose indicator; this is on by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark-isearch-highlight-indicator=: this only does something when the current target is the symbol at point, in which case it lazily highlights all occurrences of that symbol in the current buffer, like isearch; also on by default.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Users of the popular [[https://github.com/justbur/emacs-which-key][which-key]] package may prefer to use the =embark-which-key-indicator= from the [[https://github.com/oantolin/embark/wiki/Additional-Configuration#use-which-key-like-a-key-menu-prompt][Embark wiki]]. Just copy its definition from the wiki into your configuration and customize the =embark-indicators= user option to exclude the mixed and verbose indicators and to include =embark-which-key-indicator=.&lt;/p&gt; &#xA;&lt;p&gt;** Selecting commands via completions instead of key bindings&lt;/p&gt; &#xA;&lt;p&gt;As an alternative to reading the list of actions in the verbose or mixed indicators (see the previous section for a description of these), you can press the =embark-help-key=, which is =C-h= by default (but you may prefer =?= to free up =C-h= for use as a prefix) after running =embark-act=. Pressing the help key will prompt you for the name of an action with completion (but feel free to enter a command that is not among the offered candidates!), and will also remind you of the key bindings. You can press =embark-keymap-prompter-key=, which is =@= by default, at the prompt and then one of the key bindings to enter the name of the corresponding action.&lt;/p&gt; &#xA;&lt;p&gt;You may think that with the =&lt;em&gt;Embark Actions&lt;/em&gt;= buffer popping up to remind you of the key bindings you&#39;d never want to use completion to select an action by name, but personally I find that typing a small portion of the action name to narrow down the list of candidates feels significantly faster than visually scanning the entire list of actions.&lt;/p&gt; &#xA;&lt;p&gt;If you find you prefer entering actions that way, you can configure embark to always prompt you for actions by setting the variable =embark-prompter= to =embark-completing-read-prompter=.&lt;/p&gt; &#xA;&lt;p&gt;** Quitting the minibuffer after an action&lt;/p&gt; &#xA;&lt;p&gt;By default, if you call =embark-act= from the minibuffer it quits the minibuffer after performing the action. You can change this by setting the user option =embark-quit-after-action= to =nil=. Having =embark-act= /not/ quit the minibuffer can be useful to turn commands into little &#34;thing managers&#34;. For example, you can use =find-file= as a little file manager or =describe-package= as a little package manager: you can run those commands, perform a series of actions, and then quit the command.&lt;/p&gt; &#xA;&lt;p&gt;If you want to control the quitting behavior in a fine-grained manner depending on the action, you can set =embark-quit-after-action= to an alist, associating commands to either =t= for quitting or =nil= for not quitting. When using an alist, you can use the special key =t= to specify the default behavior. For example, to specify that by default actions should not quit the minibuffer but that using =kill-buffer= as an action should quit, you can use the following configuration:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq embark-quit-after-action &#39;((kill-buffer . t) (t . nil))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The variable =embark-quit-after-action= only specifies a default, that is, it only controls whether or not =embark-act= quits the minibuffer when you call it without a prefix argument, and you can select the opposite behavior to what the variable says by calling =embark-act= with =C-u=. Also note that both the variable =embark-quit-after-action= and =C-u= have no effect when you call =embark-act= outside the minibuffer.&lt;/p&gt; &#xA;&lt;p&gt;If you find yourself using the quitting and non-quitting variants of =embark-act= about equally often, independently of the action, you may prefer to simply have separate commands for them instead of a single command that you call with =C-u= half the time. You could, for example, keep the default exiting behavior of =embark-act= and define a non-quitting version as follows:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun embark-act-noquit () &#34;Run action but don&#39;t quit the minibuffer afterwards.&#34; (interactive) (let ((embark-quit-after-action nil)) (embark-act))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Running some setup after injecting the target&lt;/p&gt; &#xA;&lt;p&gt;You can customize what happens after the target is inserted at the minibuffer prompt of an action. There are =embark-target-injection-hooks=, that are run by default after injecting the target into the minibuffer. The variable =embark-target-injection-hooks= is an alist associating commands to their setup hooks. There are two special keys: if no setup hook is specified for a given action, the hook associated to =t= is run; and the hook associated to =:always= is run regardless of the action. (This variable used to have the less explicit name of =embark-setup-action-hooks=, so please update your configuration.)&lt;/p&gt; &#xA;&lt;p&gt;For example, consider using =shell-command= as an action during file completion. It would be useful to insert a space before the target file name and to leave the point at the beginning, so you can immediately type the shell command to run on that file. That&#39;s why in Embark&#39;s default configuration there is an entry in =embark-target-injection-hooks= associating =shell-command= to a hook that includes =embark--shell-prep=, a simple helper function that quotes all the spaces in the file name, inserts an extra space at the beginning of the line and leaves point to the left of it.&lt;/p&gt; &#xA;&lt;p&gt;Now, the preparation that =embark--shell-prep= does would be useless if Embark did what it normally does after it inserts the target of the action at the minibuffer prompt, which is to &#34;press =RET=&#34; for you, accepting the target as is; if Embark did that for =shell-command= you wouldn&#39;t get a chance to type in the command to execute! That is why in Embark&#39;s default configuration the entry for =shell-command= in =embark-target-injection-hooks= also contains the function =embark--allow-edit=.&lt;/p&gt; &#xA;&lt;p&gt;Embark used to have a dedicated variable =embark-allow-edit-actions= to which you could add commands for which Embark should forgo pressing =RET= for you after inserting the target. Since its effect can also be achieved via the general =embark-target-injection-hooks= mechanism, that variable has been removed to simply Embark. Be sure to update your configuration; if you had something like:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (add-to-list &#39;embark-allow-edit-actions &#39;my-command) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;you should replace it with:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (push &#39;embark--allow-edit (alist-get &#39;my-command embark-target-injection-hooks)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Also note that while you could abuse =embark--allow-edit= so that you have to confirm &#34;dangerous&#34; actions such as =delete-file=, it is better to implement confirmation by adding the =embark--confirm= function to the appropriate entry of a different hook alist, namely, =embark-pre-action-hooks=.&lt;/p&gt; &#xA;&lt;p&gt;Besides =embark--allow-edit=, Embark comes with another function that is of general utility in action setup hooks: =embark--ignore-target=. Use it for commands that do prompt you in the minibuffer but for which inserting the target would be inappropriate. This is not a common situation but does occasionally arise. For example it is used by default for =shell-command-on-region=: that command is used as an action for region targets, and it prompts you for a shell command; you typically do /not/ want the target, that is the contents of the region, to be entered at that prompt!&lt;/p&gt; &#xA;&lt;p&gt;** Running hooks before, after or around an action&lt;/p&gt; &#xA;&lt;p&gt;Embark has three variables, =embark-pre-action-hooks=, =embark-post-action-hooks= and =embark-around-action-hooks=, which are alists associating commands to hooks that should run before or after or as around advice for the command when used as an action. As with =embark-target-injection-hooks=, there are two special keys for the alists: =t= designates the default hook to run when no specific hook is specified for a command; and the hook associated to =:always= runs regardless.&lt;/p&gt; &#xA;&lt;p&gt;The default values of those variables are fairly extensive, adding creature comforts to make running actions a smooth experience. Embark comes with several functions intended to be added to these hooks, and used in the default values of =embark-pre-action-hooks=, =embark-post-action-hooks= and =embark-around-action-hooks=.&lt;/p&gt; &#xA;&lt;p&gt;For pre-action hooks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark--confirm= :: Prompt the user for confirmation before executing the action. This is used be default for commands deemed &#34;dangerous&#34;, or, more accurately, hard to undo, such as =delete-file= and =kill-buffer=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark--unmark-target= :: Unmark the active region. Use this for commands you want to act on the region contents but without the region being active. The default configuration uses this function as a pre-action hook for =occur= and =query-replace=, for example, so that you can use them as actions with region targets to search the whole buffer for the text contained in the region. Without this pre-action hook using =occur= as an action for a region target would be pointless: it would search for the the region contents /in the region/, (typically, due to the details of regexps) finding only one match!&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark--beginning-of-target= :: Move to the beginning of the target (for targets that report bounds). This is used by default for backward motion commands such as =backward-sexp=, so that they don&#39;t accidentally leave you on the current target.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark--end-of-target= :: Move to the end of the target. This is used similarly to the previous function, but also for commands that act on the last s-expression like =eval-last-sexp=. This allow you to act on an s-expression from anywhere inside it and still use =eval-last-sexp= as an action.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark--xref-push-markers= :: Push the current location on the xref marker stack. Use this for commands that take you somewhere and for which you&#39;d like to be able to come back to where you were using =xref-pop-marker-stack=. This is used by default for =find-library=.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For post-action hooks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=embark--restart= :: Restart the command currently prompting in the minibuffer, so that the list of completion candidates is updated. This is useful as a post action hook for commands that delete or rename a completion candidate; for example the default value of =embark-post-action-hooks= uses it for =delete-file=, =kill-buffer=, =rename-file=, =rename-buffer=, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For around-action hooks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark--mark-target= :: Save existing mark and point location, mark the target and run the action. Most targets at point outside the minibuffer report which region of the buffer they correspond to (this is the information used by =embark-highlight-indicator= to know what portion of the buffer to highlight); this function marks that region. It is useful as an around action hook for commands that expect a region to be marked, for example, it is used by default for =indent-region= so that it works on s-expression targets, or for =fill-region= so that it works on paragraph targets.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark--cd= :: Run the action with =default-directory= set to the directory associated to the current target. The target should be of type =file=, =buffer=, =bookmark= or =library=, and the associated directory is what you&#39;d expect in each case.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark--narrow-to-target= :: Run the action with buffer narrowed to current target. Use this as an around hook to localize the effect of actions that don&#39;t already work on just the region. In the default configuration it is used for =repunctuate-sentences=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=embark--save-excursion= :: Run the action restoring point at the end. The current default configuration doesn&#39;t use this but it is available for users.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Creating your own keymaps&lt;/p&gt; &#xA;&lt;p&gt;All internal keymaps are defined with the standard helper macro =defvar-keymap=. For example a simple version of the file action keymap could be defined as follows:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (defvar-keymap embark-file-map :doc &#34;Example keymap with a few file actions&#34; :parent embark-general-map &#34;d&#34; #&#39;delete-file &#34;r&#34; #&#39;rename-file &#34;c&#34; #&#39;copy-file) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;These action keymaps are perfectly normal Emacs keymaps. You may want to inherit from the =embark-general-map= if you want to access the default Embark actions. Note that =embark-collect= and =embark-export= are also made available via =embark-general-map=.&lt;/p&gt; &#xA;&lt;p&gt;** Defining actions for new categories of targets&lt;/p&gt; &#xA;&lt;p&gt;It is easy to configure Embark to provide actions for new types of targets, either in the minibuffer or outside it. I present below two very detailed examples of how to do this. At several points I&#39;ll explain more than one way to proceed, typically with the easiest option first. I include the alternative options since there will be similar situations where the easiest option is not available.&lt;/p&gt; &#xA;&lt;p&gt;*** New minibuffer target example - tab-bar tabs&lt;/p&gt; &#xA;&lt;p&gt;As an example, take the new [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Tab-Bars.html][tab bars]] from Emacs 27. I&#39;ll explain how to configure Embark to offer tab-specific actions when you use the tab-bar-mode commands that mention tabs by name. The configuration explained here is now built-in to Embark (and Marginalia), but it&#39;s still a good self-contained example. In order to setup up tab actions you would need to: (1) make sure Embark knows those commands deal with tabs, (2) define a keymap for tab actions and configure Embark so it knows that&#39;s the keymap you want.&lt;/p&gt; &#xA;&lt;p&gt;**** Telling Embark about commands that prompt for tabs by name&lt;/p&gt; &#xA;&lt;p&gt;For step (1), it would be great if the =tab-bar-mode= commands reported the completion category =tab= when asking you for a tab with completion. (All built-in Emacs commands that prompt for file names, for example, do have metadata indicating that they want a =file=.) They do not, unfortunately, and I will describe a couple of ways to deal with this.&lt;/p&gt; &#xA;&lt;p&gt;Maybe the easiest thing is to configure [[https://github.com/minad/marginalia][Marginalia]] to enhance those commands. All of the =tab-bar-*-tab-by-name= commands have the words &#34;tab by name&#34; in the minibuffer prompt, so you can use:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (add-to-list &#39;marginalia-prompt-categories &#39;(&#34;tab by name&#34; . tab)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s it! But in case you are ever in a situation where you don&#39;t already have commands that prompt for the targets you want, I&#39;ll describe how writing your own command with appropriate =category= metadata looks:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun my-select-tab-by-name (tab) (interactive (list (let ((tab-list (or (mapcar (lambda (tab) (cdr (assq &#39;name tab))) (tab-bar-tabs)) (user-error &#34;No tabs found&#34;)))) (completing-read &#34;Tabs: &#34; (lambda (string predicate action) (if (eq action &#39;metadata) &#39;(metadata (category . tab)) (complete-with-action action tab-list string predicate))))))) (tab-bar-select-tab-by-name tab)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;As you can see, the built-in support for setting the category meta-datum is not very easy to use or pretty to look at. To help with this I recommend the =consult--read= function from the excellent [[https://github.com/minad/consult/][Consult]] package. With that function we can rewrite the command as follows:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun my-select-tab-by-name (tab) (interactive (list (let ((tab-list (or (mapcar (lambda (tab) (cdr (assq &#39;name tab))) (tab-bar-tabs)) (user-error &#34;No tabs found&#34;)))) (consult--read tab-list :prompt &#34;Tabs: &#34; :category &#39;tab)))) (tab-bar-select-tab-by-name tab)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Much nicer! No matter how you define the =my-select-tab-by-name= command, the first approach with Marginalia and prompt detection has the following advantages: you get the =tab= category for all the =tab-bar-*-bar-by-name= commands at once, also, you enhance built-in commands, instead of defining new ones.&lt;/p&gt; &#xA;&lt;p&gt;**** Defining and configuring a keymap for tab actions&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say we want to offer select, rename and close actions for tabs (in addition to Embark general actions, such as saving the tab name to the kill-ring, which you get for free). Then this will do:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defvar-keymap embark-tab-actions :doc &#34;Keymap for actions for tab-bar tabs (when mentioned by name).&#34; :parent embark-general-map &#34;s&#34; #&#39;tab-bar-select-tab-by-name &#34;r&#34; #&#39;tab-bar-rename-tab-by-name &#34;k&#34; #&#39;tab-bar-close-tab-by-name)&lt;/p&gt; &#xA;&lt;p&gt;(add-to-list &#39;embark-keymap-alist &#39;(tab . embark-tab-actions)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;What if after using this for a while you feel closing the tab without confirmation is dangerous? You have a couple of options:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;You can keep using the =tab-bar-close-tab-by-name= command, but have Embark ask you for confirmation: #+begin_src emacs-lisp (push #&#39;embark--confirm (alist-get &#39;tab-bar-close-tab-by-name embark-pre-action-hooks)) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can write your own command that prompts for confirmation and use that instead of =tab-bar-close-tab-by-name= in the above keymap: #+begin_src emacs-lisp (defun my-confirm-close-tab-by-name (tab) (interactive &#34;sTab to close: &#34;) (when (y-or-n-p (format &#34;Close tab &#39;%s&#39;? &#34; tab)) (tab-bar-close-tab-by-name tab))) #+end_src&lt;/p&gt; &lt;p&gt;Notice that this is a command you can also use directly from =M-x= independently of Embark. Using it from =M-x= leaves something to be desired, though, since you don&#39;t get completion for the tab names. You can fix this if you wish as described in the previous section.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;*** New target example in regular buffers - short Wikipedia links&lt;/p&gt; &#xA;&lt;p&gt;Say you want to teach Embark to treat text of the form =wikipedia:Garry_Kasparov= in any regular buffer as a link to Wikipedia, with actions to open the Wikipedia page in eww or an external browser or to save the URL of the page in the kill-ring. We can take advantage of the actions that Embark has preconfigured for URLs, so all we need to do is teach Embark that =wikipedia:Garry_Kasparov= stands for the URL =&lt;a href=&#34;https://en.wikipedia.org/wiki/Garry_Kasparov=&#34;&gt;https://en.wikipedia.org/wiki/Garry_Kasparov=&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can be as fancy as you want with the recognized syntax. Here, to keep the example simple, I&#39;ll assume the link matches the regexp =wikipedia:[[:alnum:]_]+=. We will write a function that looks for a match surrounding point, and returns a dotted list of the form =&#39;(url URL-OF-THE-PAGE START . END)= where =START= and =END= are the buffer positions bounding the target, and are used by Embark to highlight it if you have =embark-highlight-indicator= included in the list =embark-indicators=. (There are a couple of other options for the return value of a target finder: the bounding positions are optional and a single target finder is allowed to return multiple targets; see the documentation for =embark-target-finders= for details.)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun my-short-wikipedia-link () &#34;Target a link at point of the form wikipedia:Page_Name.&#34; (save-excursion (let* ((start (progn (skip-chars-backward &#34;[:alnum:]&lt;em&gt;:&#34;) (point))) (end (progn (skip-chars-forward &#34;[:alnum:]&lt;/em&gt;:&#34;) (point))) (str (buffer-substring-no-properties start end))) (save-match-data (when (string-match &#34;wikipedia:\([[:alnum:]_]+\)&#34; str) `(url ,(format &#34;&lt;a href=&#34;https://en.wikipedia.org/wiki/%s&#34;&gt;https://en.wikipedia.org/wiki/%s&lt;/a&gt;&#34; (match-string 1 str)) ,start . ,end))))))&lt;/p&gt; &#xA;&lt;p&gt;(add-to-list &#39;embark-target-finders &#39;my-short-wikipedia-link) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;How does Embark call the actions?&lt;/p&gt; &lt;p&gt;Embark actions are normal Emacs commands, that is, functions with an interactive specification. In order to execute an action, Embark calls the command with =call-interactively=, so the command reads user input exactly as if run directly by the user. For example the command may open a minibuffer and read a string (=read-from-minibuffer=) or open a completion interface (=completing-read=). If this happens, Embark takes the target string and inserts it automatically into the minibuffer, simulating user input this way. After inserting the string, Embark exits the minibuffer, submitting the input. (The immediate minibuffer exit can be disabled for specific actions in order to allow editing the input; this is done by adding the =embark--allow-edit= function to the appropriate entry of =embark-target-injection-hooks=). Embark inserts the target string at the first minibuffer opened by the action command, and if the command happens to prompt the user for input more than once, the user still interacts with the second and further prompts in the normal fashion. Note that if a command does not prompt the user for input in the minibuffer, Embark still allows you to use it as an action, but of course, never inserts the target anywhere. (There are plenty of examples in the default configuration of commands that do not prompt the user bound to keys in the action maps, most of the region actions, for instance.)&lt;/p&gt; &lt;p&gt;This is how Embark manages to reuse normal commands as actions. The mechanism allows you to use as Embark actions commands that were not written with Embark in mind (and indeed almost all actions that are bound by default in Embark&#39;s action keymaps are standard Emacs commands). It also allows you to write new custom actions in such a way that they are useful even without Embark.&lt;/p&gt; &lt;p&gt;Staring from version 28.1, Emacs has a variable =y-or-n-p-use-read-key=, which when set to =t= causes =y-or-n-p= to use =read-key= instead of =read-from-minibuffer=. Setting =y-or-n-p-use-read-key= to =t= is recommended for Embark users because it keeps Embark from attempting to insert the target at a =y-or-n-p= prompt, which would almost never be sensible. Also consider this as a warning to structure your own action commands so that if they use =y-or-n-p=, they do so only after the prompting for the target.&lt;/p&gt; &lt;p&gt;Here is a simple example illustrating the various ways of reading input from the user mentioned above. Bind the following commands to the =embark-symbol-map= to be used as actions, then put the point on some symbol and run them with =embark-act=:&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp (defun example-action-command1 () (interactive) (message &#34;The input was `%s&#39;.&#34; (read-from-minibuffer &#34;Input: &#34;)))&lt;/p&gt; &lt;p&gt;(defun example-action-command2 (arg input1 input2) (interactive &#34;P\nsInput 1: \nsInput 2: &#34;) (message &#34;The first input %swas &lt;code&gt;%s&#39;, and the second was &lt;/code&gt;%s&#39;.&#34; (if arg &#34;truly &#34; &#34;&#34;) input1 input2))&lt;/p&gt; &lt;p&gt;(defun example-action-command3 () (interactive) (message &#34;Your selection was `%s&#39;.&#34; (completing-read &#34;Select: &#34; &#39;(&#34;E&#34; &#34;M&#34; &#34;B&#34; &#34;A&#34; &#34;R&#34; &#34;K&#34;))))&lt;/p&gt; &lt;p&gt;(defun example-action-command4 () (interactive) (message &#34;I don&#39;t prompt you for input and thus ignore the target!&#34;))&lt;/p&gt; &lt;p&gt;(keymap-set embark-symbol-map &#34;X 1&#34; #&#39;example-action-command1) (keymap-set embark-symbol-map &#34;X 2&#34; #&#39;example-action-command2) (keymap-set embark-symbol-map &#34;X 3&#34; #&#39;example-action-command3) (keymap-set embark-symbol-map &#34;X 4&#34; #&#39;example-action-command4) #+end_src&lt;/p&gt; &lt;p&gt;Also note that if you are using the key bindings to call actions, you can pass prefix arguments to actions in the normal way. For example, you can use =C-u X2= with the above demonstration actions to make the message printed by =example-action-command2= more emphatic. This ability to pass prefix arguments to actions is useful for some actions in the default configuration, such as =embark-shell-command-on-buffer=.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Non-interactive functions as actions&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, Embark does support one other type of action: a non-interactive function of a single argument. The target is passed as argument to the function. For example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun example-action-function (target) (message &#34;The target was `%s&#39;.&#34; target))&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(keymap-set embark-symbol-map &#34;X 4&#34; #&#39;example-action-function)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Note that normally binding non-interactive functions in a keymap is useless, since when attempting to run them using the key binding you get an error message similar to &#34;Wrong type argument: commandp, example-action-function&#34;. In general it is more flexible to write any new Embark actions as commands, that is, as interactive functions, because that way you can also run them directly, without Embark. But there are a couple of reasons to use non-interactive functions as actions:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;You may already have the function lying around, and it is convenient to simply reuse it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For command actions the targets can only be simple string, with no text properties. For certain advanced uses you may want the action to receive a string /with/ some text properties, or even a non-string target.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Embark, Marginalia and Consult&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Embark cooperates well with the [[https://github.com/minad/marginalia][Marginalia]] and [[https://github.com/minad/consult][Consult]] packages. Neither of those packages is a dependency of Embark, but both are highly recommended companions to Embark, for opposite reasons: Marginalia greatly enhances Embark&#39;s usefulness, while Embark can help enhance Consult.&lt;/p&gt; &#xA;&lt;p&gt;In the remainder of this section I&#39;ll explain what exactly Marginalia does for Embark, and what Embark can do for Consult.&lt;/p&gt; &#xA;&lt;p&gt;** Marginalia&lt;/p&gt; &#xA;&lt;p&gt;Embark comes with actions for symbols (commands, functions, variables with actions such as finding the definition, looking up the documentation, evaluating, etc.) in the =embark-symbol-map= keymap, and for packages (actions like install, delete, browse url, etc.) in the =embark-package-keymap=.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately Embark does not automatically offers you these keymaps when relevant, because many built-in Emacs commands don&#39;t report accurate category metadata. For example, a command like =describe-package=, which reads a package name from the minibuffer, does not have metadata indicating this fact.&lt;/p&gt; &#xA;&lt;p&gt;In an earlier Embark version, there were functions to supply this missing metadata, but they have been moved to Marginalia, which augments many Emacs command to report accurate category metadata. Simply activating =marginalia-mode= allows Embark to offer you the package and symbol actions when appropriate again. Candidate annotations in the Embark collect buffer are also provided by the Marginalia package:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If you install Marginalia and activate =marginalia-mode=, Embark Collect buffers will use the Marginalia annotations automatically.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you don&#39;t install Marginalia, you will see only the annotations that come with Emacs (such as key bindings in =M-x=, or the unicode characters in =C-x 8 RET=).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Consult&lt;/p&gt; &#xA;&lt;p&gt;The excellent Consult package provides many commands that use minibuffer completion, via the =completing-read= function; plenty of its commands can be considered enhanced versions of built-in Emacs commands, and some are completely new functionality. One common enhancement provided in all commands for which it makes sense is preview functionality, for example =consult-buffer= will show you a quick preview of a buffer before you actually switch to it.&lt;/p&gt; &#xA;&lt;p&gt;If you use both Consult and Embark you should install the =embark-consult= package which provides integration between the two. It provides exporters for several Consult commands and also tweaks the behavior of many Consult commands when used as actions with =embark-act= in subtle ways that you may not even notice, but make for a smoother experience. You need only install it to get these benefits: Embark will automatically load it after Consult if found.&lt;/p&gt; &#xA;&lt;p&gt;The =embark-consult= package provides the following exporters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You can use =embark-export= from =consult-line=, =consult-outline=, or =consult-mark= to obtain an =occur-mode= buffer. As with the built-in =occur= command you use that buffer to jump to a match and after that, you can then use =next-error= and =previous-error= to navigate to other matches. You can also press =e= to activate =occur-edit-mode= and edit the matches in place!&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can export from any of the Consult asynchronous search commands, =consult-grep=, =consult-git-grep=, or =consult-ripgrep= to get a =grep-mode= buffer. Here too you can use =next-error= and =previous-error= to navigate among matches, and, if you install the [[http://github.com/mhayashi1120/Emacs-wgrep/raw/master/wgrep.el ][wgrep]] package, you can use it to edit the matches in place.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In both cases, pressing =g= will rerun the Consult command you had exported from and re-enter the input you had typed (which is similar to reverting but a little more flexible). You can then proceed to re-export if that&#39;s what you want, but you can also edit the input changing the search terms or simply cancel if you see you are done with that search.&lt;/p&gt; &#xA;&lt;p&gt;The =embark-consult= also contains some candidates collectors that allow you to run =embark-live= to get a live-updating table of contents for your buffer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=embark-consult-outline-candidates= produces the outline headings of the current buffer, using =consult-outline=.&lt;/li&gt; &#xA; &lt;li&gt;=embark-consult-imenu-candidates= produces the imenu items of the current buffer, using =consult-imenu=.&lt;/li&gt; &#xA; &lt;li&gt;=embark-consult-imenu-or-outline-candidates= is a simple combination of the two previous functions: it produces imenu items in buffers deriving from =prog-mode= and otherwise outline headings.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The way to configure =embark-live= (or =embark-collect= and =embark-export= for that matter) to use one of these function is to add it at the end of the =embark-candidate-collectors= list. The =embark-consult= package by default adds the last one, which seems to be the most sensible default.&lt;/p&gt; &#xA;&lt;p&gt;Besides those exporters and candidate collectors, the =embark-consult= package provides many subtle tweaks and small integrations between Embark and Consult. Some examples are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The asynchronous search commands will start in the directory associated to the Embark target if that target is a file, buffer, bookmark or Emacs Lisp library.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For all other target types, a Consult search command (asynchronous or not) will search for the text of the target but leave the minibuffer open so you can interact with the Consult command.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=consult-imenu= will search for the target and take you directly to the location if it matches a unique imenu entry, otherwise it will leave the minibuffer open so you can navigate among the matches.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Resources&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to learn more about how others have used Embark here are some links to read:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://karthinks.com/software/fifteen-ways-to-use-embark/][Fifteen ways to use Embark]], a blog post by Karthik Chikmagalur.&lt;/li&gt; &#xA; &lt;li&gt;[[https://protesilaos.com/dotemacs/][Protesilaos Stavrou&#39;s dotemacs]], look for the section called &#34;Extended minibuffer actions and more (embark.el and prot-embark.el)&#34;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And some videos to watch:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://protesilaos.com/codelog/2021-01-09-emacs-embark-extras/][Embark and my extras]] by Protesilaos Stavrou.&lt;/li&gt; &#xA; &lt;li&gt;[[https://youtu.be/qpoQiiinCtY][Embark -- Key features and tweaks]] by Raoul Comninos on the Emacs-Elements YouTube channel.&lt;/li&gt; &#xA; &lt;li&gt;[[https://youtu.be/WsxXr1ncukY][Livestreamed: Adding an Embark context action to send a stream message]] by Sacha Chua.&lt;/li&gt; &#xA; &lt;li&gt;[[https://youtu.be/qk2Is_sC8Lk][System Crafters Live! - The Many Uses of Embark]] by David Wilson.&lt;/li&gt; &#xA; &lt;li&gt;[[https://youtu.be/5ffb2at2d7w][Using Emacs Episode 80 - Vertico, Marginalia, Consult and Embark]] by Mike Zamansky.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Contributions to Embark are very welcome. There is a [[https://github.com/oantolin/embark/issues/95][wish list]] for actions, target finders, candidate collectors and exporters. For other ideas you have for Embark, feel free to open an issue on the [[https://github.com/oantolin/embark/issues][issue tracker]]. Any neat configuration tricks you find might be a good fit for the [[https://github.com/oantolin/embark/wiki][wiki]].&lt;/p&gt; &#xA;&lt;p&gt;Code contributions are very welcome too, but since Embark is now on GNU ELPA, copyright assignment to the FSF is required before you can contribute code.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Acknowledgments&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;While I, Omar AntolÃ­n Camarena, have written most of the Embark code and remain very stubborn about some of the design decisions, Embark has received substantial help from a number of other people which this document has neglected to mention for far too long. In particular, Daniel Mendler has been absolutely invaluable, implementing several important features, and providing a lot of useful advice.&lt;/p&gt; &#xA;&lt;p&gt;Code contributions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/minad][Daniel Mendler]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/clemera/][Clemens Radermacher]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://codeberg.org/jao/][JosÃ© Antonio Ortega Ruiz]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/iyefrat][Itai Y. Efrat]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/a13][a13]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/jakanakaevangeli][jakanakaevangeli]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mihakam][mihakam]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/leungbk][Brian Leung]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/karthink][Karthik Chikmagalur]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/roshanshariff][Roshan Shariff]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/condy0919][condy0919]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/DamienCassou][Damien Cassou]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/JimDBh][JimDBh]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Advice and useful discussions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/minad][Daniel Mendler]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://gitlab.com/protesilaos/][Protesilaos Stavrou]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/clemera/][Clemens Radermacher]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/hmelman/][Howard Melman]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/astoff][Augusto Stoffel]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/bdarcus][Bruce d&#39;Arcus]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/jdtsmith][JD Smith]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/karthink][Karthik Chikmagalur]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/jakanakaevangeli][jakanakaevangeli]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/iyefrat][Itai Y. Efrat]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mohkale][Mohsin Kaleem]]&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>joddie/pcre2el</title>
    <updated>2023-06-01T02:12:30Z</updated>
    <id>tag:github.com,2023-06-01:/joddie/pcre2el</id>
    <link href="https://github.com/joddie/pcre2el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;convert between PCRE, Emacs and rx regexp syntax&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;pcre2el: convert between PCRE, Emacs and rx regexp syntax&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Overview =pcre2el= or =rxt= (RegeXp Translator or RegeXp Tools) is a utility for working with regular expressions in Emacs, based on a recursive-descent parser for regexp syntax. In addition to converting (a subset of) PCRE syntax into its Emacs equivalent, it can do the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;convert Emacs syntax to PCRE&lt;/li&gt; &#xA; &lt;li&gt;convert either syntax to =rx=, an S-expression based regexp syntax&lt;/li&gt; &#xA; &lt;li&gt;untangle complex regexps by showing the parse tree in =rx= form and highlighting the corresponding chunks of code&lt;/li&gt; &#xA; &lt;li&gt;show the complete list of strings (productions) matching a regexp, provided the list is finite&lt;/li&gt; &#xA; &lt;li&gt;provide live font-locking of regexp syntax (so far only for Elisp buffers -- other modes on the TODO list)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Usage Enable =rxt-mode= or its global equivalent =rxt-global-mode= to get the default key-bindings. There are three sets of commands: commands that take a PCRE regexp, commands which take an Emacs regexp, and commands that try to do the right thing based on the current mode. Currently, this means Emacs syntax in =emacs-lisp-mode= and =lisp-interaction-mode=, and PCRE syntax everywhere else.&lt;/p&gt; &#xA;&lt;p&gt;The default key bindings all begin with =C-c /= and have a mnemonic structure: =C-c / &lt;source&gt; &#xA; &lt;target&gt;&#xA;  =, or just =C-c / &#xA;  &lt;target&gt;&#xA;   = for the &#34;do what I mean&#34; commands. The complete list of key bindings is given here and explained in more detail below:&#xA;  &lt;/target&gt;&#xA; &lt;/target&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&#34;Do-what-I-mean&#34; commands:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;=C-c / /= :: =rxt-explain=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / c= :: =rxt-convert-syntax=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / x= :: =rxt-convert-to-rx=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / â€²= :: =rxt-convert-to-strings=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Commands that work on a PCRE regexp:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;=C-c / p e= :: =rxt-pcre-to-elisp=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / %= :: =pcre-query-replace-regexp=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / p x= :: =rxt-pcre-to-rx=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / p s= :: =rxt-pcre-to-sre=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / p â€²= :: =rxt-pcre-to-strings=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / p /= :: =rxt-explain-pcre=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Commands that work on an Emacs regexp:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;=C-c / e /= :: =rxt-explain-elisp=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / e p= :: =rxt-elisp-to-pcre=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / e x= :: =rxt-elisp-to-rx=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / e s= :: =rxt-elisp-to-sre=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / e â€²= :: =rxt-elisp-to-strings=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / e t= :: =rxt-toggle-elisp-rx=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / t= :: =rxt-toggle-elisp-rx=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Interactive input and output When used interactively, the conversion commands can read a regexp either from the current buffer or from the minibuffer. The output is displayed in the minibuffer and copied to the kill-ring.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- When called with a prefix argument (=C-u=), they read a regular&#xA;  expression from the minibuffer literally, without further&#xA;  processing -- meaning there&#39;s no need to double the backslashes if&#xA;  it&#39;s an Emacs regexp.  This is the same way commands like&#xA;  =query-replace-regexp= read input.&#xA;&#xA;- When the region is active, they use they the region contents,&#xA;  again literally (without any translation of string syntax).&#xA;&#xA;- With neither a prefix arg nor an active region, the behavior&#xA;  depends on whether the command expects an Emacs regexp or&#xA;  a PCRE one.&#xA;&#xA;  Commands that take an Emacs regexp behave like =C-x C-e=: they&#xA;  evaluate the sexp before point (which could be simply a string&#xA;  literal) and use its value. This is designed for use in Elisp&#xA;  buffers. As a special case, if point is *inside* a string, it&#39;s&#xA;  first moved to the string end, so in practice they should work&#xA;  as long as point is somewhere within the regexp literal.&#xA;&#xA;  Commands that take a PCRE regexp try to read a Perl-style&#xA;  delimited regex literal *after* point in the current buffer,&#xA;  including its flags. For example, putting point before the =m=&#xA;  in the following example and doing =C-c / p e=&#xA;  (=rxt-pcre-to-elisp=) displays =\(?:bar\|foo\)=, correctly&#xA;  stripping out the whitespace and comment:&#xA;&#xA;  : $x =~ m/  foo   |  (?# comment) bar /x&#xA;&#xA;  The PCRE reader currently only works with =/ ... /= delimiters. It&#xA;  will ignore any preceding =m=, =s=, or =qr= operator, as well as&#xA;  the replacement part of an =s= construction.&#xA;&#xA;  Readers for other PCRE-using languages are on the TODO list.&#xA;&#xA;The translation functions display their result in the minibuffer&#xA;and copy it to the kill ring. When translating something into&#xA;Elisp syntax, you might need to use the result either literally&#xA;(e.g. for interactive input to a command like&#xA;=query-replace-regexp=), or as a string to paste into Lisp code.&#xA;To allow both uses, =rxt-pcre-to-elisp= copies both versions&#xA;successively to the kill-ring. The literal regexp without string&#xA;quoting is the top element of the kill-ring, while the Lisp string&#xA;is the second-from-top. You can paste the literal regexp somewhere&#xA;by doing =C-y=, or the Lisp string by =C-y M-y=.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Syntax conversion commands =rxt-convert-syntax= (=C-c / c=) converts between Emacs and PCRE syntax, depending on the major mode in effect when called. Alternatively, you can specify the conversion direction explicitly by using either =rxt-pcre-to-elisp= (=C-c / p e=) or =rxt-elisp-to-pcre= (=C-c / e p=).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Similarly, =rxt-convert-to-rx= (=C-c / x=) converts either kind of&#xA;syntax to =rx= form, while =rxt-convert-pcre-to-rx= (=C-c / p x=)&#xA;and =rxt-convert-elisp-to-rx= (=C-c / e x=) convert to =rx= from a&#xA;specified source type.&#xA;&#xA;In Elisp buffers, you can use =rxt-toggle-elisp-rx= (=C-c / t= or&#xA;=C-c / e t=) to switch the regexp at point back and forth between&#xA;string and =rx= syntax. Point should either be within an =rx= or&#xA;=rx-to-string= form or a string literal for this to work.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** PCRE mode (experimental) If you want to use emulated PCRE regexp syntax in all Emacs commands, try =pcre-mode=, which uses Emacs&#39;s advice system to make all commands that read regexps using the minibuffer use emulated PCRE syntax. It should also work with Isearch.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This feature is still fairly experimental.  It may fail to work or&#xA;do the wrong thing with certain commands.  Please report bugs.&#xA;&#xA;=pcre-query-replace-regexp= was originally defined to do&#xA;query-replace using emulated PCRE regexps, and is now made&#xA;somewhat obsolete by =pcre-mode=.  It is bound to =C-c / %= by&#xA;default, by analogy with =M-%=.  Put the following in your&#xA;=.emacs= if you want to use PCRE-style query replacement&#xA;everywhere:&#xA;&#xA;: (global-set-key [(meta %)] &#39;pcre-query-replace-regexp)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Explain regexps When syntax-highlighting isn&#39;t enough to untangle some gnarly regexp you find in the wild, try the &#39;explain&#39; commands: =rxt-explain= (=C-c / /=), =rxt-explain-pcre= (=C-c / p=) and =rxt-explain-elisp= (=C-c / e=). These display the original regexp along with its pretty-printed =rx= equivalent in a new buffer. Moving point around either in the original regexp or the =rx= translation highlights corresponding pieces of syntax, which can aid in seeing things like the scope of quantifiers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;I call them &#34;explain&#34; commands because the =rx= form is close to a&#xA;plain syntax tree, and this plus the wordiness of the operators&#xA;usually helps to clarify what is going on.  People who dislike&#xA;Lisp syntax might disagree with this assessment.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Generate all matching strings (productions) Occasionally you come across a regexp which is designed to match a finite set of strings, e.g. a set of keywords, and it would be useful to recover the original set. (In Emacs you can generate such regexps using =regexp-opt=). The commands =rxt-convert-to-strings= (=C-c / â€²=), =rxt-pcre-to-strings= (=C-c / p â€²=) or =rxt-elisp-to-strings= (=C-c / e â€²=) accomplish this by generating all the matching strings (&#34;productions&#34;) of a regexp. (The productions are copied to the kill ring as a Lisp list).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;An example in Lisp code:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;: (regexp-opt &#39;(&#34;cat&#34; &#34;caterpillar&#34; &#34;catatonic&#34;)) : ;; =&amp;gt; &#34;\(?:cat\(?:atonic\|erpillar\)?\)&#34; : (rxt-elisp-to-strings &#34;\(?:cat\(?:atonic\|erpillar\)?\)&#34;) : ;; =&amp;gt; &#39;(&#34;cat&#34; &#34;caterpillar&#34; &#34;catatonic&#34;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;For obvious reasons, these commands only work with regexps that&#xA;don&#39;t include any unbounded quantifiers like =+= or =*=. They also&#xA;can&#39;t enumerate all the characters that match a named character&#xA;class like =[[:alnum:]]=. In either case they will give a (hopefully&#xA;meaningful) error message. Due to the nature of permutations, it&#39;s&#xA;still possible for a finite regexp to generate a huge number of&#xA;productions, which will eat memory and slow down your Emacs. Be&#xA;ready with =C-g= if necessary.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** RE-Builder support The Emacs RE-Builder is a useful visual tool which allows using several different built-in syntaxes via =reb-change-syntax= (=C-c TAB=). It supports Elisp read and literal syntax and =rx=, but it can only convert from the symbolic forms to Elisp, not the other way. This package hacks the RE-Builder to also work with emulated PCRE syntax, and to convert transparently between Elisp, PCRE and rx syntaxes. PCRE mode reads a delimited Perl-like literal of the form =/ ... /=, and it should correctly support using the =x= and =s= flags.&lt;/p&gt; &#xA;&lt;p&gt;*** Use from Lisp&lt;/p&gt; &#xA;&lt;p&gt;Example of using the conversion functions: : (rxt-pcre-to-elisp &#34;(abc|def)\w+\d+&#34;) : ;; =&amp;gt; &#34;\(\(?:abc\|def\)\)[_[:alnum:]]+[[:digit:]]+&#34;&lt;/p&gt; &#xA;&lt;p&gt;All the conversion functions take a single string argument, the regexp to translate:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=rxt-pcre-to-elisp=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-pcre-to-rx=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-pcre-to-sre=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-pcre-to-strings=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-elisp-to-pcre=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-elisp-to-rx=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-elisp-to-sre=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-elisp-to-strings=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Bugs and Limitations *** Limitations on PCRE syntax PCRE has a complicated syntax and semantics, only some of which can be translated into Elisp. The following subset of PCRE should be correctly parsed and converted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- parenthesis grouping =( .. )=, including shy matches =(?: ... )=&#xA;- backreferences (various syntaxes), but only up to 9 per expression    &#xA;- alternation =|=&#xA;- greedy and non-greedy quantifiers =*=, =*?=, =+=, =+?=, =?= and =??=&#xA;  (all of which are the same in Elisp as in PCRE)&#xA;- numerical quantifiers ={M,N}=&#xA;- beginning/end of string =\A=, =\Z=&#xA;- string quoting =\Q .. \E=&#xA;- word boundaries =\b=, =\B= (these are the same in Elisp)&#xA;- single character escapes =\a=, =\c=, =\e=, =\f=, =\n=, =\r=,&#xA;  =\t=, =\x=, and =\octal digits= (but see below about non-ASCII&#xA;  characters)&#xA;- character classes =[...]= including Posix escapes&#xA;- character classes =\d=, =\D=, =\h=, =\H=, =\s=, =\S=, =\v=, =\V=&#xA;  both within character class brackets and outside&#xA;- word and non-word characters =\w= and =\W=&#xA;  (Emacs has the same syntax, but its meaning is different)&#xA;- =s= (single line) and =x= (extended syntax) flags, in regexp&#xA;  literals, or set within the expression via =(?xs-xs)= or =(?xs-xs:&#xA;  .... )= syntax&#xA;- comments =(?# ... )=&#xA;&#xA;Most of the more esoteric PCRE features can&#39;t really be supported&#xA;by simple translation to Elisp regexps. These include the&#xA;different lookaround assertions, conditionals, and the&#xA;&#34;backtracking control verbs&#34; =(* ...)= . OTOH, there are a few&#xA;other syntaxes which are currently unsupported and possibly could be:&#xA;&#xA;- =\L=, =\U=, =\l=, =\u= case modifiers&#xA;- =\g{...}= backreferences&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Other limitations&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The order of alternatives and characters in char classes sometimes gets shifted around, which is annoying.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Although the string parser tries to interpret PCRE&#39;s octal and hexadecimal escapes correctly, there are problems with matching 8-bit characters that I don&#39;t use enough to properly understand, e.g.: : (string-match-p (rxt-pcre-to-elisp &#34;\377&#34;) &#34;\377&#34;) =&amp;gt; nil A fix for this would be welcome.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Most of PCRE&#39;s rules for how =^=, =\A=, =$= and =\Z= interact with newlines are not implemented, since they seem less relevant to Emacs&#39;s buffer-oriented rather than line-oriented model. However, the different meanings of the =.= metacharacter &lt;em&gt;are&lt;/em&gt; implemented (it matches newlines with the =/s= flag, but not otherwise).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Not currently namespace clean (both =rxt-= and a couple of =pcre-= functions).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** TODO:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Python-specific extensions to PCRE?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Language-specific stuff to enable regexp font-locking and explaining in different modes. Each language would need two functions, which could be kept in an alist:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt; &lt;p&gt;A function to read PCRE regexps, taking the string syntax into account. E.g., Python has single-quoted, double-quoted and raw strings, each with different quoting rules. PHP has the kind of belt-and-suspenders solution you would expect: regexps are in strings, /and/ you have to include the =/ ... /= delimiters! Duh.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;A function to copy faces back from the parsed string to the original buffer text. This has to recognize any escape sequences so they can be treated as a single character.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Internal details Internally, =rxt= defines an abstract syntax tree data type for regular expressions, parsers for Elisp and PCRE syntax, and &#34;unparsers&#34; from to PCRE, rx, and SRE syntax. Converting from a parsed syntax tree to Elisp syntax is a two-step process: first convert to =rx= form, then let =rx-to-string= do the heavy lifting. See =rxt-parse-re=, =rxt-adt-&amp;gt;pcre=, =rxt-adt-&amp;gt;rx=, and =rxt-adt-&amp;gt;sre=, and the section beginning &#34;Regexp ADT&#34; in pcre2el.el for details.&lt;/p&gt; &#xA;&lt;p&gt;This code is partially based on Olin Shivers&#39; reference SRE implementation in scsh, although it is simplified in some respects and extended in others. See =scsh/re.scm=, =scsh/spencer.scm= and =scsh/posixstr.scm= in the =scsh= source tree for details. In particular, =pcre2el= steals the idea of an abstract data type for regular expressions and the general structure of the string regexp parser and unparser. The data types for character sets are extended in order to support symbolic translation between character set expressions without assuming a small (Latin1) character set. The string parser is also extended to parse a bigger variety of constructions, including POSIX character classes and various Emacs and Perl regexp assertions. Otherwise, only the bare minimum of scsh&#39;s abstract data type is implemented.&lt;/p&gt; &#xA;&lt;p&gt;** Soapbox Emacs regexps have their annoyances, but it is worth getting used to them. The Emacs assertions for word boundaries, symbol boundaries, and syntax classes depending on the syntax of the mode in effect are especially useful. (PCRE has =\b= for word-boundary, but AFAIK it doesn&#39;t have separate assertions for beginning-of-word and end-of-word). Other things that might be done with huge regexps in other languages can be expressed more understandably in Elisp using combinations of `save-excursion&#39; with the various searches (regexp, literal, skip-syntax-forward, sexp-movement functions, etc.).&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s not much point in using =rxt-pcre-to-elisp= to use PCRE notation in a Lisp program you&#39;re going to maintain, since you still have to double all the backslashes. Better to just use the converted result (or better yet, the =rx= form).&lt;/p&gt; &#xA;&lt;p&gt;** History and acknowledgments This was originally created out of an answer to a stackoverflow question: &lt;a href=&#34;http://stackoverflow.com/questions/9118183/elisp-mechanism-for-converting-pcre-regexps-to-emacs-regexps&#34;&gt;http://stackoverflow.com/questions/9118183/elisp-mechanism-for-converting-pcre-regexps-to-emacs-regexps&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Thanks to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Wes Hardaker (hardaker) for the initial inspiration and subsequent hacking&lt;/li&gt; &#xA; &lt;li&gt;priyadarshan for requesting RX/SRE support&lt;/li&gt; &#xA; &lt;li&gt;Daniel Colascione (dcolascione) for a patch to support Emacs&#39;s explicitly-numbered match groups&lt;/li&gt; &#xA; &lt;li&gt;Aaron Meurer (asmeurer) for requesting Isearch support&lt;/li&gt; &#xA; &lt;li&gt;Philippe Vaucher (silex) for a patch to support =ibuffer-do-replace-regexp= in PCRE mode&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>