<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-09-01T01:48:53Z</updated>
  <subtitle>Monthly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>s-kostyaev/ellama</title>
    <updated>2024-09-01T01:48:53Z</updated>
    <id>tag:github.com,2024-09-01:/s-kostyaev/ellama</id>
    <link href="https://github.com/s-kostyaev/ellama" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ellama is a tool for interacting with large language models from Emacs.&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;Ellama&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[[http://www.gnu.org/licenses/gpl-3.0.txt][file:https://img.shields.io/badge/license-GPL_3-green.svg]] [[https://melpa.org/#/ellama][file:https://melpa.org/packages/ellama-badge.svg]] [[https://stable.melpa.org/#/ellama][file:https://stable.melpa.org/packages/ellama-badge.svg]] [[https://elpa.gnu.org/packages/ellama.html][file:https://elpa.gnu.org/packages/ellama.svg]]&lt;/p&gt; &#xA;&lt;p&gt;Ellama is a tool for interacting with large language models from Emacs. It allows you to ask questions and receive responses from the LLMs. Ellama can perform various tasks such as translation, code review, summarization, enhancing grammar/spelling or wording and more through the Emacs interface. Ellama natively supports streaming output, making it effortless to use with your preferred text editor.&lt;/p&gt; &#xA;&lt;p&gt;The name &#34;ellama&#34; is derived from &#34;Emacs Large LAnguage Model Assistant&#34;. Previous sentence was written by Ellama itself.&lt;/p&gt; &#xA;&lt;p&gt;** Installation&lt;/p&gt; &#xA;&lt;p&gt;Just &lt;del&gt;M-x&lt;/del&gt; &lt;del&gt;package-install&lt;/del&gt; @@html:&lt;kbd&gt;@@Enter@@html:&lt;/kbd&gt;@@ &lt;del&gt;ellama&lt;/del&gt; @@html:&lt;kbd&gt;@@Enter@@html:&lt;/kbd&gt;@@. By default it uses [[https://github.com/jmorganca/ollama][ollama]] provider and [[https://ollama.ai/library/zephyr][zephyr]] model. If you ok with it, you need to install [[https://github.com/jmorganca/ollama][ollama]] and pull [[https://ollama.ai/library/zephyr][zephyr]] like this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC shell ollama pull zephyr #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;del&gt;ellama&lt;/del&gt; with other model or other llm provider. In that case you should customize ellama configuration like this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp ;; YOU DON&#39;T NEED NONE OF THIS CODE FOR SIMPLE INSTALL ;; IT IS AN EXAMPLE OF CUSTOMIZATION. (use-package ellama :init ;; setup key bindings (setopt ellama-keymap-prefix &#34;C-c e&#34;) ;; language you want ellama to translate to (setopt ellama-language &#34;German&#34;) ;; could be llm-openai for example (require &#39;llm-ollama) (setopt ellama-provider (make-llm-ollama ;; this model should be pulled to use it ;; value should be the same as you print in terminal during pull :chat-model &#34;llama3:8b-instruct-q8_0&#34; :embedding-model &#34;nomic-embed-text&#34; :default-chat-non-standard-params &#39;((&#34;num_ctx&#34; . 8192)))) ;; Predefined llm providers for interactive switching. ;; You shouldn&#39;t add ollama providers here - it can be selected interactively ;; without it. It is just example. (setopt ellama-providers &#39;((&#34;zephyr&#34; . (make-llm-ollama :chat-model &#34;zephyr:7b-beta-q6_K&#34; :embedding-model &#34;zephyr:7b-beta-q6_K&#34;)) (&#34;mistral&#34; . (make-llm-ollama :chat-model &#34;mistral:7b-instruct-v0.2-q6_K&#34; :embedding-model &#34;mistral:7b-instruct-v0.2-q6_K&#34;)) (&#34;mixtral&#34; . (make-llm-ollama :chat-model &#34;mixtral:8x7b-instruct-v0.1-q3_K_M-4k&#34; :embedding-model &#34;mixtral:8x7b-instruct-v0.1-q3_K_M-4k&#34;)))) ;; Naming new sessions with llm (setopt ellama-naming-provider (make-llm-ollama :chat-model &#34;llama3:8b-instruct-q8_0&#34; :embedding-model &#34;nomic-embed-text&#34; :default-chat-non-standard-params &#39;((&#34;stop&#34; . (&#34;\n&#34;))))) (setopt ellama-naming-scheme &#39;ellama-generate-name-by-llm) ;; Translation llm provider (setopt ellama-translation-provider (make-llm-ollama :chat-model &#34;phi3:14b-medium-128k-instruct-q6_K&#34; :embedding-model &#34;nomic-embed-text&#34;))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;** Commands&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-chat&lt;/p&gt; &#xA;&lt;p&gt;Ask Ellama about something by entering a prompt in an interactive buffer and continue conversation. If called with universal argument (&lt;del&gt;C-u&lt;/del&gt;) will start new session with llm model interactive selection. [[imgs/ellama-ask.gif]]&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-ask-about&lt;/p&gt; &#xA;&lt;p&gt;Ask Ellama about a selected region or the current buffer. [[imgs/ellama-ask-about.gif]]&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-ask-selection&lt;/p&gt; &#xA;&lt;p&gt;Send selected region or current buffer to ellama chat.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-ask-line&lt;/p&gt; &#xA;&lt;p&gt;Send current line to ellama chat.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-complete&lt;/p&gt; &#xA;&lt;p&gt;Complete text in current buffer with ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-translate&lt;/p&gt; &#xA;&lt;p&gt;Ask Ellama to translate a selected region or word at the point. [[imgs/ellama-translate.gif]]&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-translate-buffer&lt;/p&gt; &#xA;&lt;p&gt;Translate current buffer.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-define-word&lt;/p&gt; &#xA;&lt;p&gt;Find the definition of the current word using Ellama. [[imgs/ellama-define-word.gif]]&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-summarize&lt;/p&gt; &#xA;&lt;p&gt;Summarize a selected region or the current buffer using Ellama. [[imgs/ellama-summarize.gif]]&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-summarize-killring&lt;/p&gt; &#xA;&lt;p&gt;Summarize text from the kill ring.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-code-review&lt;/p&gt; &#xA;&lt;p&gt;Review code in a selected region or the current buffer using Ellama. [[imgs/ellama-code-review.gif]]&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-change&lt;/p&gt; &#xA;&lt;p&gt;Change text in a selected region or the current buffer according to a provided change.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-make-list&lt;/p&gt; &#xA;&lt;p&gt;Create a markdown list from the active region or the current buffer using Ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-make-table&lt;/p&gt; &#xA;&lt;p&gt;Create a markdown table from the active region or the current buffer using Ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-summarize-webpage&lt;/p&gt; &#xA;&lt;p&gt;Summarize a webpage fetched from a URL using Ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-provider-select&lt;/p&gt; &#xA;&lt;p&gt;Select ellama provider.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-code-complete&lt;/p&gt; &#xA;&lt;p&gt;Complete selected code or code in the current buffer according to a provided change using Ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-code-add&lt;/p&gt; &#xA;&lt;p&gt;Add new code according to a description, generating it with a provided context from the selected region or the current buffer using Ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-code-edit&lt;/p&gt; &#xA;&lt;p&gt;Change selected code or code in the current buffer according to a provided change using Ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-code-improve&lt;/p&gt; &#xA;&lt;p&gt;Change selected code or code in the current buffer according to a provided change using Ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-generate-commit-message&lt;/p&gt; &#xA;&lt;p&gt;Generate commit message based on diff.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-improve-wording&lt;/p&gt; &#xA;&lt;p&gt;Enhance the wording in the currently selected region or buffer using Ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-improve-grammar Enhance the grammar and spelling in the currently selected region or buffer using Ellama. [[imgs/ellama-enhance-grammar-spelling.gif]]&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-improve-conciseness&lt;/p&gt; &#xA;&lt;p&gt;Make the text of the currently selected region or buffer concise and simple using Ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-make-format&lt;/p&gt; &#xA;&lt;p&gt;Render the currently selected text or the text in the current buffer as a specified format using Ellama.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-load-session&lt;/p&gt; &#xA;&lt;p&gt;Load ellama session from file.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-session-remove&lt;/p&gt; &#xA;&lt;p&gt;Remove ellama session.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-session-switch&lt;/p&gt; &#xA;&lt;p&gt;Change current active session.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-session-rename&lt;/p&gt; &#xA;&lt;p&gt;Rename current ellama session.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-context-add-file&lt;/p&gt; &#xA;&lt;p&gt;Add file to context.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-context-add-buffer&lt;/p&gt; &#xA;&lt;p&gt;Add buffer to context.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-context-add-selection&lt;/p&gt; &#xA;&lt;p&gt;Add selected region to context.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-context-add-info-node&lt;/p&gt; &#xA;&lt;p&gt;Add info node to context.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-chat-translation-enable&lt;/p&gt; &#xA;&lt;p&gt;Chat translation enable.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-chat-translation-disable&lt;/p&gt; &#xA;&lt;p&gt;Chat translation disable.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-solve-reasoning-problem&lt;/p&gt; &#xA;&lt;p&gt;Solve reasoning problem with [[https://arxiv.org/pdf/2406.12442][Absctraction of Thought]] technique. It uses a chain of multiple messages to LLM and help it to provide much better answers on reasoning problems. Even small LLMs like [[https://ollama.com/library/phi3][phi3-mini]] provides much better results on reasoning tasks using AoT.&lt;/p&gt; &#xA;&lt;p&gt;*** ellama-solve-domain-specific-problem&lt;/p&gt; &#xA;&lt;p&gt;Solve domain specific problem with simple chain. It makes LLMs act like a professional and adds a planning step.&lt;/p&gt; &#xA;&lt;p&gt;** Keymap&lt;/p&gt; &#xA;&lt;p&gt;Here is a table of keybindings and their associated functions in Ellama, using the &lt;del&gt;ellama-keymap-prefix&lt;/del&gt; prefix (not set by default):&lt;/p&gt; &#xA;&lt;p&gt;| Keymap | Function | Description | |--------+---------------------------------+------------------------------| | &#34;c c&#34; | ellama-code-complete | Code complete | | &#34;c a&#34; | ellama-code-add | Code add | | &#34;c e&#34; | ellama-code-edit | Code edit | | &#34;c i&#34; | ellama-code-improve | Code improve | | &#34;c r&#34; | ellama-code-review | Code review | | &#34;c m&#34; | ellama-generate-commit-message | Generate commit message | | &#34;s s&#34; | ellama-summarize | Summarize | | &#34;s w&#34; | ellama-summarize-webpage | Summarize webpage | | &#34;s c&#34; | ellama-summarize-killring | Summarize killring | | &#34;s l&#34; | ellama-load-session | Session Load | | &#34;s r&#34; | ellama-session-rename | Session rename | | &#34;s d&#34; | ellama-session-remove | Session delete | | &#34;s a&#34; | ellama-session-switch | Session activate | | &#34;i w&#34; | ellama-improve-wording | Improve wording | | &#34;i g&#34; | ellama-improve-grammar | Improve grammar and spelling | | &#34;i c&#34; | ellama-improve-conciseness | Improve conciseness | | &#34;m l&#34; | ellama-make-list | Make list | | &#34;m t&#34; | ellama-make-table | Make table | | &#34;m f&#34; | ellama-make-format | Make format | | &#34;a a&#34; | ellama-ask-about | Ask about | | &#34;a i&#34; | ellama-chat | Chat (ask interactively) | | &#34;a l&#34; | ellama-ask-line | Ask current line | | &#34;a s&#34; | ellama-ask-selection | Ask selection | | &#34;t t&#34; | ellama-translate | Text translate | | &#34;t b&#34; | ellama-translate-buffer | Translate buffer | | &#34;t e&#34; | ellama-chat-translation-enable | Translation enable | | &#34;t d&#34; | ellama-chat-translation-disable | Translation disable | | &#34;t c&#34; | ellama-complete | Text complete | | &#34;d w&#34; | ellama-define-word | Define word | | &#34;x b&#34; | ellama-context-add-buffer | Context add buffer | | &#34;x f&#34; | ellama-context-add-file | Context add file | | &#34;x s&#34; | ellama-context-add-selection | Context add selection | | &#34;x i&#34; | ellama-context-add-info-node | Context add info node | | &#34;p s&#34; | ellama-provider-select | Provider select |&lt;/p&gt; &#xA;&lt;p&gt;** Configuration&lt;/p&gt; &#xA;&lt;p&gt;The following variables can be customized for the Ellama client:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-enable-keymap&lt;/del&gt;: Enable the Ellama keymap.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-keymap-prefix&lt;/del&gt;: The keymap prefix for Ellama.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-user-nick&lt;/del&gt;: The user nick in logs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-assistant-nick&lt;/del&gt;: The assistant nick in logs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-language&lt;/del&gt;: The language for Ollama translation. Default language is english.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-provider&lt;/del&gt;: llm provider for ellama. Default provider is &lt;del&gt;ollama&lt;/del&gt; with [[https://ollama.ai/library/zephyr][zephyr]] model. There are many supported providers: &lt;del&gt;ollama&lt;/del&gt;, &lt;del&gt;open ai&lt;/del&gt;, &lt;del&gt;vertex&lt;/del&gt;, &lt;del&gt;GPT4All&lt;/del&gt;. For more information see [[https://elpa.gnu.org/packages/llm.html][llm documentation]].&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-providers&lt;/del&gt;: association list of model llm providers with name as key.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-spinner-type&lt;/del&gt;: Spinner type for ellama. Default type is &lt;del&gt;progress-bar&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-ollama-binary&lt;/del&gt;: Path to ollama binary.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-auto-scroll&lt;/del&gt;: If enabled ellama buffer will scroll automatically during generation. Disabled by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-fill-paragraphs&lt;/del&gt;: Option to customize ellama paragraphs filling behaviour.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-name-prompt-words-count&lt;/del&gt;: Count of words in prompt to generate name.&lt;/li&gt; &#xA; &lt;li&gt;Prompt templates for every command.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-chat-done-callback&lt;/del&gt;: Callback that will be called on ellama chat response generation done. It should be a function with single argument generated text string.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-nick-prefix-depth&lt;/del&gt;: User and assistant nick prefix depth. Default value is 2.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-sessions-directory&lt;/del&gt;: Directory for saved ellama sessions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-major-mode&lt;/del&gt;: Major mode for ellama commands. Org mode by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-long-lines-length&lt;/del&gt;: Long lines length for fill paragraph call. Too low value can break generated code by splitting long comment lines. Default value 100.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-session-auto-save&lt;/del&gt;: Automatically save ellama sessions if set. Enabled by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-naming-scheme&lt;/del&gt;: How to name new sessions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-naming-provider&lt;/del&gt;: LLM provider for generating session names by LLM. If not set &lt;del&gt;ellama-provider&lt;/del&gt; will be used.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-chat-translation-enabled&lt;/del&gt;: Enable chat translations if set.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-translation-provider&lt;/del&gt;: LLM translation provider. &lt;del&gt;ellama-provider&lt;/del&gt; will be used if not set.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ellama-show-quotes&lt;/del&gt;: Show quotes content in chat buffer. Disabled by default.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Acknowledgments&lt;/p&gt; &#xA;&lt;p&gt;Thanks [[https://github.com/jmorganca][Jeffrey Morgan]] for excellent project [[https://github.com/jmorganca/ollama][ollama]]. This project cannot exist without it.&lt;/p&gt; &#xA;&lt;p&gt;Thanks [[https://github.com/zweifisch][zweifisch]] - I got some ideas from [[https://github.com/zweifisch/ollama][ollama.el]] what ollama client in Emacs can do.&lt;/p&gt; &#xA;&lt;p&gt;Thanks [[https://github.com/David-Kunz][Dr. David A. Kunz]] - I got more ideas from [[https://github.com/David-Kunz/gen.nvim][gen.nvim]].&lt;/p&gt; &#xA;&lt;p&gt;Thanks [[https://github.com/ahyatt][Andrew Hyatt]] for &lt;del&gt;llm&lt;/del&gt; library. Without it only &lt;del&gt;ollama&lt;/del&gt; would be supported.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To contribute, submit a pull request or report a bug. This library is part of GNU ELPA; major contributions must be from someone with FSF papers. Alternatively, you can write a module and share it on a different archive like MELPA.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>magit/transient</title>
    <updated>2024-09-01T01:48:53Z</updated>
    <id>tag:github.com,2024-09-01:/magit/transient</id>
    <link href="https://github.com/magit/transient" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Transient commands&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;Transient command menus&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Transient is the library used to implement the keyboard-driven “menus” in [[https://github.com/magit/magit/][Magit]]. It is distributed as a separate package, so that it can be used to implement similar menus in [[https://melpa.org/#/transient][other packages]].&lt;/p&gt; &#xA;&lt;p&gt;** Some things that Transient can do&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Display current state of arguments&lt;/li&gt; &#xA; &lt;li&gt;Display and manage lifecycle of modal bindings&lt;/li&gt; &#xA; &lt;li&gt;Contextual user interface&lt;/li&gt; &#xA; &lt;li&gt;Flow control for wizard-like composition of interactive forms&lt;/li&gt; &#xA; &lt;li&gt;History &amp;amp; persistence&lt;/li&gt; &#xA; &lt;li&gt;Rendering arguments for controlling CLI programs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Complexity in CLI programs&lt;/p&gt; &#xA;&lt;p&gt;Complexity tends to grow with time. How do you manage the complexity of commands? Consider the humble shell command =ls=. It now has over /fifty/ command line options. Some of these are boolean flags (=ls -l=). Some take arguments (=ls --sort=s=). Some have no effect unless paired with other flags (=ls -lh=). Some are mutually exclusive. Some shell commands even have so many options that they introduce /subcommands/ (=git branch=, =git commit=), each with their own rich set of options (=git branch -f=).&lt;/p&gt; &#xA;&lt;p&gt;** Using Transient for composing interactive commands&lt;/p&gt; &#xA;&lt;p&gt;What about Emacs commands used interactively? How do these handle options? One solution is to make many versions of the same command, so you don&#39;t need to! Consider: =delete-other-windows= vs. =delete-other-windows-vertically= (among many similar examples).&lt;/p&gt; &#xA;&lt;p&gt;Some Emacs commands will simply prompt you for the next &#34;argument&#34; (=M-x switch-to-buffer=). Another common solution is to use prefix arguments which usually start with =C-u=. Sometimes these are sensibly numerical in nature (=C-u 4 M-x forward-paragraph= to move forward 4 paragraphs). But sometimes they function instead as boolean &#34;switches&#34; (=C-u C-SPACE= to jump to the last mark instead of just setting it, =C-u C-u C-SPACE= to unconditionally set the mark). Since there aren&#39;t many standards for the use of prefix options, you have to read the command&#39;s documentation to find out what the possibilities are.&lt;/p&gt; &#xA;&lt;p&gt;But when an Emacs command grows to have a truly large set of options and arguments, with dependencies between them, lots of option values, etc., these simple approaches just don&#39;t scale. Transient is designed to solve this issue. Think of it as the humble prefix argument =C-u=, /raised to the power of 10/. Like =C-u=, it is key driven. Like the shell, it supports boolean &#34;flag&#34; options, options that take arguments, and even &#34;sub-commands&#34;, with their own options. But instead of searching through a man page or command documentation, well-designed transients /guide/ their users to the relevant set of options (and even their possible values!) directly, taking into account any important pre-existing Emacs settings. And while for shell commands like =ls=, there is only one way to &#34;execute&#34; (hit =Return=!), transients can &#34;execute&#34; using multiple different keys tied to one of many self-documenting /actions/ (imagine having 5 different colored return keys on your keyboard!). Transients make navigating and setting large, complex groups of command options and arguments easy. Fun even. Once you&#39;ve tried it, it&#39;s hard to go back to the =C-u what can I do here again?= way.&lt;/p&gt; &#xA;&lt;p&gt;[[http://readme.emacsair.me/transient.png]]&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;br&gt;&lt;br&gt; #+html: &lt;a href=&#34;https://github.com/magit/transient/actions/workflows/compile.yml&#34;&gt;&lt;img alt=&#34;Compile&#34; src=&#34;https://github.com/magit/transient/actions/workflows/compile.yml/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://github.com/magit/transient/actions/workflows/manual.yml&#34;&gt;&lt;img alt=&#34;Manual&#34; src=&#34;https://github.com/magit/transient/actions/workflows/manual.yml/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://elpa.gnu.org/packages/transient.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://emacsair.me/assets/badges/gnu-elpa.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://stable.melpa.org/#/transient&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/transient-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/transient&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/transient-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jwiegley/emacs-async</title>
    <updated>2024-09-01T01:48:53Z</updated>
    <id>tag:github.com,2024-09-01:/jwiegley/emacs-async</id>
    <link href="https://github.com/jwiegley/emacs-async" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple library for asynchronous processing in Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?sanitize=true&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.gnu.org/packages/async.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/packages/async.svg?sanitize=true&#34; alt=&#34;GNU ELPA&#34; title=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/async&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/async-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34; title=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/async&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/async-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34; title=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;emacs-async&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;async.el&lt;/code&gt; is a module for doing asynchronous processing in Emacs. Some async applications are provided as well with this package:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dired-async&lt;/li&gt; &#xA; &lt;li&gt;smtp-mail-async&lt;/li&gt; &#xA; &lt;li&gt;async-bytecomp&lt;/li&gt; &#xA; &lt;li&gt;async-package&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Install&lt;/h1&gt; &#xA;&lt;p&gt;You can install emacs-async package from MELPA using package.el.&lt;/p&gt; &#xA;&lt;p&gt;You can also install from sources, in this case you should install using make and make install to ensure emacs-async is installed in a standard load-path destination where other packages can find it easily when compiling.&lt;/p&gt; &#xA;&lt;h2&gt;Install dired-async&lt;/h2&gt; &#xA;&lt;p&gt;Add to your &lt;code&gt;.emacs.el&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(autoload &#39;dired-async-mode &#34;dired-async.el&#34; nil t)&#xA;(dired-async-mode 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will allow you to run asynchronously the dired commands for copying, renaming and symlinking. If you are a &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;helm&lt;/a&gt; user, this will allow you to copy, rename etc... asynchronously from &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;helm&lt;/a&gt;. Note that with &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;helm&lt;/a&gt; you can disable this by running the copy, rename etc... commands with a prefix argument.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t want to make dired/helm asynchronous disable it with &lt;code&gt;dired-async-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Debian and Ubuntu&lt;/h3&gt; &#xA;&lt;p&gt;Users of Debian 9 or later or Ubuntu 16.04 or later may simply &lt;code&gt;apt-get install elpa-async&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Authentication and user interaction&lt;/h2&gt; &#xA;&lt;p&gt;Some authentications require user interaction, for example answering to a prompt, entering a passwords etc. Your async implementation should avoid any such user interaction, to avoid being stuck with a prompt you will not be able to answer to in the child emacs. For all what is remote (mails, tramp etc...) you have to let emacs manage your identification with &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/auth.html&#34;&gt;auth-sources&lt;/a&gt;, so that you do not have to enter a password.&lt;/p&gt; &#xA;&lt;p&gt;Basically all you need is something like this in your init file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(use-package auth-source&#xA;  :no-require t&#xA;  :config (setq auth-sources &#39;(&#34;~/.authinfo.gpg&#34; &#34;~/.netrc&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And a &#34;~/.authinfo.gpg&#34; file containing entries such as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;default port sudo login root password xxxxxxxx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;machine xxxxx port xxx login xxx password xxxxxxx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;for more specific hosts (smtp, mails etc...)&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/auth.html&#34;&gt;auth-sources manual&lt;/a&gt; for more infos.&lt;/p&gt; &#xA;&lt;p&gt;However, when choosing the destination with completion (e.g. helm) and you have no &#34;.authinfo&#34; file or just no entry for this host, tramp will prompt for password and offer you to save it, if you answer &#39;yes&#39; you will be able to achieve you async operation as the child Emacs will use this just created &#34;.authinfo&#34; file, if you say &#39;no&#39;, your dired-async process will hang forever because child emacs is waiting for password.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: For all your async implementations in emacs-26+ versions that handle remote files (tramp), you will have to let-bind &lt;code&gt;async-quiet-switch&lt;/code&gt; to &lt;code&gt;-q&lt;/code&gt; to workaround a tramp bug that prevent &lt;code&gt;emacs -Q&lt;/code&gt; to use &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/auth.html&#34;&gt;auth-sources&lt;/a&gt; mechanism.&lt;/p&gt; &#xA;&lt;h2&gt;Enable asynchronous compilation of your (M)elpa packages&lt;/h2&gt; &#xA;&lt;p&gt;By default emacs package.el compile packages in its running emacs session. This is not a problem when installing a new package (which is not actually loaded in current emacs) but it may create errors and bad compilation when upgrading a package (old version of package is already loaded and running in current emacs). You can remedy to this by allowing async to compile your packages asynchronously, (helm and magit actually do this by default, so if you are using these packages they will compile asynchronously) to do this, add to your init file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(async-bytecomp-package-mode 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can control which packages will compile async with &lt;code&gt;async-bytecomp-allowed-packages&lt;/code&gt;. Set it to &lt;code&gt;&#39;(all)&lt;/code&gt; to be sure you will compile all packages asynchronously.&lt;/p&gt; &#xA;&lt;h2&gt;Install/upgrade packages asynchronously&lt;/h2&gt; &#xA;&lt;p&gt;When using &lt;code&gt;async-bytecomp-package-mode&lt;/code&gt; only compilation is done async. To do all async (download and (re)install) the function &lt;code&gt;async-package-do-action&lt;/code&gt; is provided, it is used by Helm packages UI.&lt;/p&gt; &#xA;&lt;h2&gt;Send mails asynchronously with smtp mail async&lt;/h2&gt; &#xA;&lt;p&gt;To enable this feature, ensure smtp-mail-async.el is loaded and use&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;(setq message-send-mail-function &#39;async-smtpmail-send-it)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;WARNINGS:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;When using recent emacs (25+) the network security manager maybe called interactively in child emacs and make &lt;code&gt;async-smtpmail-send-it&lt;/code&gt; fail, so be sure to send email once synchronously before using &lt;code&gt;async-smtpmail-send-it&lt;/code&gt; as your &lt;code&gt;message-send-mail-function&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You may loose your sent mail if your network is down, so ensure to queue your mails if so. you can do this automatically, see &lt;a href=&#34;https://github.com/jwiegley/emacs-async/issues/64&#34;&gt;issue #64&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Async usage&lt;/h1&gt; &#xA;&lt;p&gt;The interface is intended to be very easy to use:&lt;/p&gt; &#xA;&lt;h2&gt;async-start&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-start START-FUNC FINISH-FUNC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Execute START-FUNC (often a lambda) in a subordinate Emacs process. When done, the return value is passed to FINISH-FUNC. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-start&#xA;   ;; What to do in the child process&#xA;   (lambda ()&#xA;     (message &#34;This is a test&#34;)&#xA;     (sleep-for 3)&#xA;     222)&#xA;&#xA;   ;; What to do when it finishes&#xA;   (lambda (result)&#xA;     (message &#34;Async process done, result should be 222: %s&#34; result)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If FINISH-FUNC is &lt;code&gt;nil&lt;/code&gt; or missing, a future is returned that can be inspected using &lt;code&gt;async-get&lt;/code&gt;, blocking until the value is ready. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(let ((proc (async-start&#xA;               ;; What to do in the child process&#xA;               (lambda ()&#xA;                 (message &#34;This is a test&#34;)&#xA;                 (sleep-for 3)&#xA;                 222))))&#xA;&#xA;    (message &#34;I&#39;m going to do some work here&#34;) ;; ....&#xA;&#xA;    (message &#34;Waiting on async process, result should be 222: %s&#34;&#xA;             (async-get proc)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t want to use a callback, and you don&#39;t care about any return value from the child process, pass the &lt;code&gt;&#39;ignore&lt;/code&gt; symbol as the second argument (if you don&#39;t, and never call &lt;code&gt;async-get&lt;/code&gt;, it will leave &lt;code&gt;*emacs*&lt;/code&gt; process buffers hanging around):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-start&#xA; (lambda ()&#xA;   (delete-file &#34;a remote file on a slow link&#34; nil))&#xA; &#39;ignore)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: Even when FINISH-FUNC is present, a future is still returned except that it yields no value (since the value is passed to FINISH-FUNC). Calling &lt;code&gt;async-get&lt;/code&gt; on such a future always returns &lt;code&gt;nil&lt;/code&gt;. It can still be useful, however, as an argument to &lt;code&gt;async-ready&lt;/code&gt; or &lt;code&gt;async-wait&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;async-start-process&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-start-process NAME PROGRAM FINISH-FUNC &amp;amp;rest PROGRAM-ARGS&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Start the executable PROGRAM asynchronously. See &lt;code&gt;async-start&lt;/code&gt;. PROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the process object when done. If FINISH-FUNC is &lt;code&gt;nil&lt;/code&gt;, the future object will return the process object when the program is finished. Set DEFAULT-DIRECTORY to change PROGRAM&#39;s current working directory.&lt;/p&gt; &#xA;&lt;h2&gt;async-get&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-get FUTURE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Get the value from an asynchronously called function when it is ready. FUTURE is returned by &lt;code&gt;async-start&lt;/code&gt; or &lt;code&gt;async-start-process&lt;/code&gt; when its FINISH-FUNC is &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;async-ready&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-ready FUTURE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Query a FUTURE to see if its function&#39;s value is ready -- i.e., if no blocking would result from a call to &lt;code&gt;async-get&lt;/code&gt; on that FUTURE.&lt;/p&gt; &#xA;&lt;h2&gt;async-wait&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-wait FUTURE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Wait for FUTURE to become ready.&lt;/p&gt; &#xA;&lt;h2&gt;async-inject-variables&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-inject-variables INCLUDE-REGEXP &amp;amp;optional PREDICATE EXCLUDE-REGEXP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Return a &lt;code&gt;setq&lt;/code&gt; form that replicates part of the calling environment. It sets the value for every variable matching INCLUDE-REGEXP and also PREDICATE. It will not perform injection for any variable matching EXCLUDE-REGEXP (if present). It is intended to be used as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-start&#xA;   `(lambda ()&#xA;      (require &#39;smtpmail)&#xA;      (with-temp-buffer&#xA;        (insert ,(buffer-substring-no-properties (point-min) (point-max)))&#xA;        ;; Pass in the variable environment for smtpmail&#xA;        ,(async-inject-variables &#34;\\`\\(smtpmail\\|\\(user-\\)?mail\\)-&#34;)&#xA;        (smtpmail-send-it)))&#xA;   &#39;ignore)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;async-let&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-let BINDINGS &amp;amp;rest FORMS&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Allow to establish let bindings asynchronously. Each value of binding can refer to the symbols already bound in BINDINGS (like &lt;code&gt;let*&lt;/code&gt;). FORMS are executed once BINDINGS have been evaluated, but without blocking emacs.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-let ((x &#34;hello&#34;)&#xA;            (y &#34;world&#34;))&#xA;  (message &#34;%s %s&#34; x y))&#xA;  &#xA;(async-let ((x (* 5 2))&#xA;            (y (+ x 4))&#xA;            (z (+ x y)))&#xA;  (message &#34;%d + %d = %d&#34; x y z))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that if you bind something to nil and set it afterward in body, the evaluation of this binding will NOT be asynchronous, but will happen in you current emacs, blocking it if the evaluation of this value is sufficiently important, e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-let ((x &#34;hello&#34;)&#xA;            (y &#34;world&#34;)&#xA;            z)&#xA;  (setq z (+ 1 2)) ;; Huge calculation of Z will block emacs.&#xA;  (message &#34;%s %s %d&#34; x y z))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;IOW if the calculation of Z is huge and you want it asynchronous evaluate it in BINDINGS but not in FORMS.&lt;/p&gt;</summary>
  </entry>
</feed>