<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-07-01T01:49:38Z</updated>
  <subtitle>Monthly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rust-lang/rust-mode</title>
    <updated>2025-07-01T01:49:38Z</updated>
    <id>tag:github.com,2025-07-01:/rust-lang/rust-mode</id>
    <link href="https://github.com/rust-lang/rust-mode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs configuration for Rust&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rust-mode&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://elpa.nongnu.org/nongnu/rust-mode.html&#34;&gt;&lt;img src=&#34;https://elpa.nongnu.org/nongnu/rust-mode.svg?sanitize=true&#34; alt=&#34;NonGNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/rust-mode&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/rust-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/rust-lang/rust-mode/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/rust-lang/rust-mode/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-refresh-toc --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#rust-mode&#34;&gt;rust-mode&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#known-issues&#34;&gt;Known issues&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#melpa&#34;&gt;Melpa&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#manual-installation&#34;&gt;Manual installation&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#feature-guide&#34;&gt;Feature guide&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#indentation&#34;&gt;Indentation&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#code-formatting&#34;&gt;Code formatting&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#prettifying&#34;&gt;Prettifying&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#running--testing--compiling-code&#34;&gt;Running / testing / compiling code&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#clippy&#34;&gt;Clippy&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#easy-insertion-of-dbg&#34;&gt;Easy insertion of dbg!&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#more-commands&#34;&gt;More commands&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#tree-sitter&#34;&gt;tree-sitter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#lsp&#34;&gt;LSP&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#eglot&#34;&gt;eglot&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#lsp-mode&#34;&gt;lsp-mode&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#auto-completion&#34;&gt;Auto-completion&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#other-recommended-packages&#34;&gt;Other recommended packages&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#flycheck&#34;&gt;flycheck&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#cargoel&#34;&gt;cargo.el&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#cargo-mode&#34;&gt;cargo-mode&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#rustic&#34;&gt;rustic&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#optional-features&#34;&gt;Optional features&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#for-package-maintainers&#34;&gt;For package maintainers&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#tests&#34;&gt;Tests&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;rust-mode&lt;/code&gt; makes editing &lt;a href=&#34;http://rust-lang.org&#34;&gt;Rust&lt;/a&gt; code with Emacs enjoyable. It requires Emacs 25 or later, and is included in both &lt;a href=&#34;https://github.com/bbatsov/prelude&#34;&gt;Emacs Prelude&lt;/a&gt; and &lt;a href=&#34;https://github.com/syl20bnr/spacemacs&#34;&gt;Spacemacs&lt;/a&gt; by default.&lt;/p&gt; &#xA;&lt;p&gt;This mode provides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Syntax highlighting (for Font Lock Mode)&lt;/li&gt; &#xA; &lt;li&gt;Indentation&lt;/li&gt; &#xA; &lt;li&gt;Integration with Cargo, clippy and rustfmt&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This mode does &lt;em&gt;not&lt;/em&gt; provide auto completion, or jumping to function / trait definitions. See &lt;a href=&#34;https://raw.githubusercontent.com/rust-lang/rust-mode/master/#auto-completion&#34;&gt;Auto-completion&lt;/a&gt; below for tips on how to enable this.&lt;/p&gt; &#xA;&lt;p&gt;If you are missing features in rust-mode, please check out &lt;a href=&#34;https://github.com/emacs-rustic/rustic&#34;&gt;rustic&lt;/a&gt; before you open a feature request. It depends on rust-mode and provides additional features. This allows us to keep rust-mode light-weight for users that are happy with basic functionality.&lt;/p&gt; &#xA;&lt;h2&gt;Known issues&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;rust-syntax-propertize&lt;/code&gt; and &lt;code&gt;adaptive-wrap-prefix-mode&lt;/code&gt; can lead to severe lag when editing larger files (&lt;a href=&#34;https://github.com/brotzeit/rustic/issues/107&#34;&gt;https://github.com/brotzeit/rustic/issues/107&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Melpa&lt;/h3&gt; &#xA;&lt;p&gt;The package is available on MELPA. Add this to your init.el.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;package)&#xA;(add-to-list &#39;package-archives&#xA;             &#39;(&#34;melpa&#34; . &#34;https://melpa.org/packages/&#34;) t)&#xA;(package-initialize)&#xA;(package-refresh-contents)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can install &lt;code&gt;rust-mode&lt;/code&gt; with:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;M-x package-install rust-mode&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;And put this in your config to load rust-mode automatically:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;(require &#39;rust-mode)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;NonGNU ELPA&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://elpa.nongnu.org/&#34;&gt;NonGNU ELPA&lt;/a&gt; can be used out of the box in emacs28.&lt;/p&gt; &#xA;&lt;p&gt;For older versions you need to add something like the following to your init file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(with-eval-after-load &#39;package (add-to-list &#39;package-archives &#39;(&#34;nongnu&#34; . &#34;https://elpa.nongnu.org/nongnu/&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Manual installation&lt;/h3&gt; &#xA;&lt;p&gt;Clone this repository locally, and add this to your init.el:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-to-list &#39;load-path &#34;/path/to/rust-mode/&#34;)&#xA;(autoload &#39;rust-mode &#34;rust-mode&#34; nil t)&#xA;(add-to-list &#39;auto-mode-alist &#39;(&#34;\\.rs\\&#39;&#34; . rust-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Feature guide&lt;/h2&gt; &#xA;&lt;h3&gt;Indentation&lt;/h3&gt; &#xA;&lt;p&gt;Commands like &lt;kbd&gt;TAB&lt;/kbd&gt; should indent correctly.&lt;/p&gt; &#xA;&lt;p&gt;The Rust style guide recommends spaces rather than tabs for indentation; to follow the recommendation add this to your init.el, which forces indentation to always use spaces.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-hook &#39;rust-mode-hook&#xA;          (lambda () (setq indent-tabs-mode nil)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since Emacs ≥ 24.4, &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/emacs/Indent-Convenience.html&#34;&gt;&lt;code&gt;electric-indent-mode&lt;/code&gt;&lt;/a&gt; is turned on by default. If you do not like it, call &lt;code&gt;(electric-indent-mode 0)&lt;/code&gt; in &lt;code&gt;rust-mode-hook&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Code formatting&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;rust-format-buffer&lt;/code&gt; function will format your code with &lt;a href=&#34;https://github.com/rust-lang/rustfmt&#34;&gt;rustfmt&lt;/a&gt; if installed. By default, this is bound to &lt;kbd&gt;C-c C-f&lt;/kbd&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The variable &lt;code&gt;rust-format-on-save&lt;/code&gt; enables automatic formatting on save. For example, add the following in your init.el to enable format on save:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq rust-format-on-save t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Prettifying&lt;/h3&gt; &#xA;&lt;p&gt;You can toggle prettification of your code by running &lt;code&gt;M-x prettify-symbols-mode&lt;/code&gt;. If you&#39;d like to automatically enable this for all rust files, add the following to your init.el.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-hook &#39;rust-mode-hook&#xA;          (lambda () (prettify-symbols-mode)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can add your own prettifications to &lt;code&gt;rust-prettify-symbols-alist&lt;/code&gt;. For example, to display &lt;code&gt;x.add(y)&lt;/code&gt; as &lt;code&gt;x∔(y)&lt;/code&gt;, simply add to your init file &lt;code&gt;(push &#39;(&#34;.add&#34; . ?∔) rust-prettify-symbols-alist)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Running / testing / compiling code&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;rust-run&lt;/code&gt;, &lt;code&gt;rust-test&lt;/code&gt;, &lt;code&gt;rust-compile&lt;/code&gt; and &lt;code&gt;rust-check&lt;/code&gt; functions shell out to Cargo to run, test, build and check your code. Under the hood, these use the standard Emacs &lt;code&gt;compile&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;By default these are bound to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;kbd&gt;C-c C-c C-u&lt;/kbd&gt; &lt;code&gt;rust-compile&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;C-c C-c C-k&lt;/kbd&gt; &lt;code&gt;rust-check&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;C-c C-c C-t&lt;/kbd&gt; &lt;code&gt;rust-test&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;C-c C-c C-r&lt;/kbd&gt; &lt;code&gt;rust-run&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To run programs requiring user input use universal argument when invoking &lt;code&gt;rust-run&lt;/code&gt; (&lt;kbd&gt;C-u C-c C-c C-r&lt;/kbd&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Clippy&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;rust-run-clippy&lt;/code&gt; runs &lt;a href=&#34;https://github.com/rust-lang/rust-clippy&#34;&gt;Clippy&lt;/a&gt;, a linter. By default, this is bound to &lt;kbd&gt;C-c C-c C-l&lt;/kbd&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Easy insertion of dbg!&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;rust-dbg-wrap-or-unwrap&lt;/code&gt; either wraps or unwraps the current region in &lt;code&gt;dbg!&lt;/code&gt;. This can be useful for easily adding debug lines to your program.&lt;/p&gt; &#xA;&lt;p&gt;This is bound to &lt;kbd&gt;C-c C-d&lt;/kbd&gt; by default.&lt;/p&gt; &#xA;&lt;h3&gt;More commands&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;rust-toggle-mutability&lt;/code&gt; toggle mut for var defined at current line&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;tree-sitter&lt;/h2&gt; &#xA;&lt;p&gt;You can try the new native treesitter mode &lt;code&gt;rust-ts-mode&lt;/code&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package rust-mode&#xA;  :init&#xA;  (setq rust-mode-treesitter-derive t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case you want to use treesitter but can&#39;t use Emacs 29.1, you can take a look at &lt;a href=&#34;https://github.com/emacs-tree-sitter/elisp-tree-sitter&#34;&gt;tree-sitter&lt;/a&gt;. When the dependencies are installed you can activate the feature with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package tree-sitter&#xA;  :config&#xA;  (require &#39;tree-sitter-langs)&#xA;  (global-tree-sitter-mode)&#xA;  (add-hook &#39;tree-sitter-after-on-hook #&#39;tree-sitter-hl-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;LSP&lt;/h2&gt; &#xA;&lt;h3&gt;eglot&lt;/h3&gt; &#xA;&lt;p&gt;A lightweight lsp client.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-hook &#39;rust-mode-hook &#39;eglot-ensure)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;lsp-mode&lt;/h3&gt; &#xA;&lt;p&gt;Provides more features and you can enhance the functionality by using additional packages. You can find more information in the &lt;a href=&#34;https://emacs-lsp.github.io/lsp-mode/page/installation/#vanilla-emacs&#34;&gt;lsp-mode wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-hook &#39;rust-mode-hook #&#39;lsp)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Auto-completion&lt;/h2&gt; &#xA;&lt;p&gt;You can either use a lsp client or &lt;a href=&#34;https://github.com/racer-rust/racer&#34;&gt;racer&lt;/a&gt; with &lt;a href=&#34;https://github.com/racer-rust/emacs-racer#installation&#34;&gt;emacs-racer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that racer and rls are considered deprecated. You should use rust-analyzer instead.&lt;/p&gt; &#xA;&lt;h2&gt;Other recommended packages&lt;/h2&gt; &#xA;&lt;h3&gt;flycheck&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/flycheck/flycheck&#34;&gt;flycheck&lt;/a&gt; allows highlighting compile errors and Clippy lints inline.&lt;/p&gt; &#xA;&lt;h3&gt;cargo.el&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kwrooijen/cargo.el&#34;&gt;cargo.el&lt;/a&gt; provides a minor mode for integration with Cargo, Rust&#39;s package manager.&lt;/p&gt; &#xA;&lt;h3&gt;cargo-mode&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ayrat555/cargo-mode&#34;&gt;cargo-mode&lt;/a&gt; is an Emacs minor mode which allows to dynamically select a Cargo command. The reasons behind this package can be found in &lt;a href=&#34;https://www.badykov.com/emacs/2021/05/29/emacs-cargo-mode/&#34;&gt;the post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;rustic&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/emacs-rustic/rustic&#34;&gt;rustic&lt;/a&gt; is based on rust-mode, extending it with other features such as integration with LSP and with flycheck.&lt;/p&gt; &#xA;&lt;h2&gt;Optional features&lt;/h2&gt; &#xA;&lt;p&gt;The features of the following files can be disabled with &lt;code&gt;rust-load-optional-libraries&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;rust-cargo.el&lt;/li&gt; &#xA; &lt;li&gt;rust-compile.el&lt;/li&gt; &#xA; &lt;li&gt;rust-playpen.el&lt;/li&gt; &#xA; &lt;li&gt;rust-rustfmt.el&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;They are disabled by default when you use rustic as it has its own implementations for those features.&lt;/p&gt; &#xA;&lt;h2&gt;Customization&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;rust-cargo-default-arguments&lt;/code&gt; set additional cargo args used for check,compile,run,test&lt;/p&gt; &#xA;&lt;h2&gt;For package maintainers&lt;/h2&gt; &#xA;&lt;h3&gt;Tests&lt;/h3&gt; &#xA;&lt;p&gt;Run elisp tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are very welcome. We are also looking for additional maintainers.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>polymode/polymode</title>
    <updated>2025-07-01T01:49:38Z</updated>
    <id>tag:github.com,2025-07-01:/polymode/polymode</id>
    <link href="https://github.com/polymode/polymode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Framework for Multiple Major Modes in Emacs (core library)&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;!-- [![Build Status](https://travis-ci.org/vspinu/polymode.svg?branch=master)](https://travis-ci.org/vspinu/polymode)  --&gt; &lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?sanitize=true&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/polymode&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/polymode-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- &lt;a href=&#34;https://stable.melpa.org/#/polymode&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/polymode-badge.svg&#34;/&gt;&lt;/a&gt; --&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/polymode/polymode/master/docs/img/large-icon.png&#34; width=&#34;25%&#34; alt=&#34;Polymode Logo&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Polymode is a framework for multiple major modes (MMM) inside a single Emacs buffer. It is fast and has a simple but flexible object-oriented design. Creating new polymodes normally takes a few lines of code.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://polymode.github.io/installation/&#34;&gt;Installation&lt;/a&gt; instructions and the full documentation are available at &lt;a href=&#34;https://polymode.github.io/&#34;&gt;https://polymode.github.io/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/polymode/polymode/master/docs/img/Rmd.png&#34; width=&#34;500px&#34;&gt; &lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>stevemolitor/claude-code.el</title>
    <updated>2025-07-01T01:49:38Z</updated>
    <id>tag:github.com,2025-07-01:/stevemolitor/claude-code.el</id>
    <link href="https://github.com/stevemolitor/claude-code.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Claude Code Emacs integration&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;claude-code.el&lt;/h1&gt; &#xA;&lt;p&gt;An Emacs interface for &lt;a href=&#34;https://github.com/anthropics/claude-code&#34;&gt;Claude Code CLI&lt;/a&gt;, providing integration between Emacs and Claude AI for coding assistance.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Seamless Emacs Integration&lt;/strong&gt; - Start, manage, and interact with Claude without leaving Emacs&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Stay in Your Buffer&lt;/strong&gt; - Send code, regions, or commands to Claude while keeping your focus&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Fix Errors Instantly&lt;/strong&gt; - Point at a flycheck/flymake error and ask Claude to fix it&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Multiple Instances&lt;/strong&gt; - Run separate Claude sessions for different projects or tasks&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Quick Responses&lt;/strong&gt; - Answer Claude with a keystroke (&#xA;  &lt;return&gt;&#xA;   /&#xA;   &lt;escape&gt;&#xA;    /1/2/3) without switching buffers&#xA;   &lt;/escape&gt;&#xA;  &lt;/return&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Smart Context&lt;/strong&gt; - Optionally include file paths and line numbers when sending commands to Claude&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Transient Menu&lt;/strong&gt; - Access all commands and slash commands through a transient menu&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Continue Conversations&lt;/strong&gt; - Resume previous sessions or fork to earlier points&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Read-Only Mode&lt;/strong&gt; - Toggle to select and copy text with normal Emacs commands and keybindings&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Mode Cycling&lt;/strong&gt; - Quick switch between default, auto-accept edits, and plan modes&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Desktop Notifications&lt;/strong&gt; - Get notified when Claude finishes processing&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Terminal Choice&lt;/strong&gt; - Works with both eat and vterm backends&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Fully Customizable&lt;/strong&gt; - Configure keybindings, notifications, and display preferences&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation {#installation}&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Emacs 30.0 or higher&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anthropics/claude-code&#34;&gt;Claude Code CLI&lt;/a&gt; installed and configured&lt;/li&gt; &#xA; &lt;li&gt;Required: transient (0.7.5+)&lt;/li&gt; &#xA; &lt;li&gt;Optional: eat (0.9.2+) for eat backend, vterm for vterm backend&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Using builtin use-package (Emacs 30+)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; add melp to package archives, as vterm is on melpa:&#xA;;; vterm is on melpa&#xA;(require &#39;package)&#xA;(add-to-list &#39;package-archives &#39;(&#34;melpa&#34; . &#34;https://melpa.org/packages/&#34;) t)&#xA;(package-initialize)&#xA;&#xA;;; for eat terminal backend:&#xA;(use-package eat :ensure t)&#xA;&#xA;;; for vterm terminal backend:&#xA;(use-package vterm :ensure t)&#xA;&#xA;;; install claude-code.el&#xA;(use-package claude-code :ensure t&#xA;  :vc (:url &#34;https://github.com/stevemolitor/claude-code.el&#34; :rev :newest)&#xA;  :config (claude-code-mode)&#xA;  :bind-keymap (&#34;C-c c&#34; . claude-code-command-map))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using straight.el&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; for eat terminal backend:&#xA;(use-package eat&#xA;  :straight (:type git&#xA;                   :host codeberg&#xA;                   :repo &#34;akib/emacs-eat&#34;&#xA;                   :files (&#34;*.el&#34; (&#34;term&#34; &#34;term/*.el&#34;) &#34;*.texi&#34;&#xA;                           &#34;*.ti&#34; (&#34;terminfo/e&#34; &#34;terminfo/e/*&#34;)&#xA;                           (&#34;terminfo/65&#34; &#34;terminfo/65/*&#34;)&#xA;                           (&#34;integration&#34; &#34;integration/*&#34;)&#xA;                           (:exclude &#34;.dir-locals.el&#34; &#34;*-tests.el&#34;))))&#xA;&#xA;;; for vterm terminal backend:&#xA;(use-package vterm :straight t)&#xA;&#xA;;; install claude-code.el:&#xA;(use-package claude-code&#xA;  :straight (:type git :host github :repo &#34;stevemolitor/claude-code.el&#34; :branch &#34;main&#34;&#xA;                   :files (&#34;*.el&#34; (:exclude &#34;images/*&#34;)))&#xA;  :bind-keymap&#xA;  (&#34;C-c c&#34; . claude-code-command-map) ;; or your preferred key&#xA;  :config&#xA;  (claude-code-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Setting Prefix Key&lt;/h3&gt; &#xA;&lt;p&gt;You need to set your own key binding for the Claude Code command map, as described in the &lt;a href=&#34;https://raw.githubusercontent.com/stevemolitor/claude-code.el/main/#installation&#34;&gt;Installation&lt;/a&gt; section. The examples in this README use &lt;code&gt;C-c c&lt;/code&gt; as the prefix key.&lt;/p&gt; &#xA;&lt;h3&gt;Picking Eat or Vterm&lt;/h3&gt; &#xA;&lt;p&gt;By default claude-code.el uses the &lt;code&gt;eat&lt;/code&gt; backend. If you prefer vterm customize &lt;code&gt;claude-code-terminal-backend&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq claude-code-terminal-backend &#39;vterm)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transient Menu&lt;/h3&gt; &#xA;&lt;p&gt;You can see a menu of the important commands by invoking the transient, &lt;code&gt;claude-code-transient&lt;/code&gt; (&lt;code&gt;C-c c m&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/stevemolitor/claude-code.el/main/images/transient.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Starting and Stopping Claude&lt;/h3&gt; &#xA;&lt;p&gt;To start Claude, run &lt;code&gt;claude-code&lt;/code&gt; (&lt;code&gt;C-c c c&lt;/code&gt;). This will start a new Claude instance in the root project directory of the buffer file, or the current directory if outside of a project. Claude-code.el uses Emacs built-in &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/emacs/Projects.html&#34;&gt;project.el&lt;/a&gt; which works with most version control systems.&lt;/p&gt; &#xA;&lt;p&gt;To start Claude in a specific directory use &lt;code&gt;claude-code-start-in-directory&lt;/code&gt; (&lt;code&gt;C-c c d&lt;/code&gt;). It will prompt you for the directory.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;claude-code-continue&lt;/code&gt; command will continue the previous conversation, and &lt;code&gt;claude-code-resume&lt;/code&gt; will let you pick from a list of previous sessions.&lt;/p&gt; &#xA;&lt;p&gt;To kill the Claude process and close its window use &lt;code&gt;claude-code-kill&lt;/code&gt; (&lt;code&gt;C-c c k&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Sending Commands to Claude&lt;/h3&gt; &#xA;&lt;p&gt;Once Claude has started, you can switch to the Claude buffer and start entering prompts. Alternately, you can send prompts to Claude using the minibuffer via &lt;code&gt;claude-code-send-command&lt;/code&gt; (&lt;code&gt;C-c c s&lt;/code&gt;). &lt;code&gt;claude-code-send-command-with-context&lt;/code&gt; (&lt;code&gt;C-c c x&lt;/code&gt;) will also send the current file name and line number to Claude. This is useful for asking things like &#34;what does this code do?&#34;, or &#34;fix the bug in this code&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;claude-code-send-region&lt;/code&gt; (&lt;code&gt;C-c c r&lt;/code&gt;) command to send the selected region to Claude, or the entire buffer if no region is selected. This command is useful for writing a prompt in a regular Emacs buffer and sending it to Claude. With a single prefix arg (&lt;code&gt;C-u C-c c r&lt;/code&gt;) it will prompt for extra context before sending the region to Claude.&lt;/p&gt; &#xA;&lt;p&gt;If you put your cursor over a flymake or flycheck error, you can ask Claude to fix it via &lt;code&gt;claude-code-fix-error-at-point&lt;/code&gt; (&lt;code&gt;C-c c e&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;To show and hide the Claude buffer use &lt;code&gt;claude-code-toggle&lt;/code&gt; (&lt;code&gt;C-c c t&lt;/code&gt;). To jump to the Claude buffer use &lt;code&gt;claude-code-switch-to-buffer&lt;/code&gt; (&lt;code&gt;C-c c b&lt;/code&gt;). This will open the buffer if hidden.&lt;/p&gt; &#xA;&lt;h3&gt;Managing Claude Windows&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;claude-code-toggle&lt;/code&gt; (&lt;code&gt;C-c c t&lt;/code&gt;) will show and hide the Claude window. Use the &lt;code&gt;claude-code-switch-to-buffer&lt;/code&gt; (&lt;code&gt;C-c c b&lt;/code&gt;) command to switch to the Claude window even if it is hidden.&lt;/p&gt; &#xA;&lt;p&gt;To enter read-only mode in the Claude buffer use &lt;code&gt;claude-code-toggle-read-only-mode&lt;/code&gt; (&lt;code&gt;C-c c z&lt;/code&gt;). In this mode you can select and copy text, and use regular Emacs keybindings. To exit read-only mode invoke &lt;code&gt;claude-code-toggle-read-only-mode&lt;/code&gt; again.&lt;/p&gt; &#xA;&lt;h3&gt;Quick Responses&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes you want to send a quick response to Claude without switching to the Claude buffer. The following commands let you answer a query from Claude without leaving your current editing buffer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;claude-code-send-return&lt;/code&gt; (&lt;code&gt;C-c c y&lt;/code&gt;) - send the return or enter key to Claude, commonly used to respond with &#34;Yes&#34; to Claude queriesy&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;claude-code-send-escape&lt;/code&gt; (&lt;code&gt;C-c c n&lt;/code&gt;) - send the escape key, to say &#34;No&#34; to Claude or to cancel a running Claude action&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;claude-code-send-1&lt;/code&gt; (&lt;code&gt;C-c c 1&lt;/code&gt;) - send &#34;1&#34; to Claude, to choose option &#34;1&#34; in response to a Claude query&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;claude-code-send-2&lt;/code&gt; (&lt;code&gt;C-c c 2&lt;/code&gt;) - send &#34;2&#34; to Claude&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;claude-code-send-3&lt;/code&gt; (&lt;code&gt;C-c c 3&lt;/code&gt;) - send &#34;3&#34; to Claude&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Working with Multiple Claude Instances&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;claude-code.el&lt;/code&gt; supports running multiple Claude instances across different projects and directories. Each Claude instance is associated with a specific directory (project root, file directory, or current directory).&lt;/p&gt; &#xA;&lt;h4&gt;Instance Management&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When you start Claude with &lt;code&gt;claude-code&lt;/code&gt;, it creates an instance for the current directory&lt;/li&gt; &#xA; &lt;li&gt;If a Claude instance already exists for the directory, you&#39;ll be prompted to name the new instance (e.g., &#34;tests&#34;, &#34;docs&#34;)&lt;/li&gt; &#xA; &lt;li&gt;You can also use &lt;code&gt;claude-code-new-instance&lt;/code&gt; to explicitly create a new instance with a custom name&lt;/li&gt; &#xA; &lt;li&gt;Buffer names follow the format: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;*claude:/path/to/directory:instance-name*&lt;/code&gt; (e.g., &lt;code&gt;*claude:/home/user/project:tests*&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;If you&#39;re in a directory without a Claude instance but have instances running in other directories, you&#39;ll be prompted to select one&lt;/li&gt; &#xA; &lt;li&gt;Your selection is remembered for that directory, so you won&#39;t be prompted again&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Instance Selection&lt;/h3&gt; &#xA;&lt;p&gt;Commands that operate on an instance (&lt;code&gt;claude-send-command&lt;/code&gt;, &lt;code&gt;claude-code-switch-to-buffer&lt;/code&gt;, &lt;code&gt;claude-code-kill&lt;/code&gt;, etc.) will prompt you for the Claude instance if there is more than one instance associated with the current buffer&#39;s project.&lt;/p&gt; &#xA;&lt;p&gt;If the buffer file is not associated with a running Claude instance, you can select an instance running in a different project. This is useful when you want Claude to analyze dependent projects or files that you have checked out in sibling directories.&lt;/p&gt; &#xA;&lt;p&gt;Claude-code.el remembers which buffers are associated with which Claude instances, so you won&#39;t be repeatedly prompted. This association also helps claude-code.el &#34;do the right thing&#34; when killing a Claude process and deleting its associated buffer.&lt;/p&gt; &#xA;&lt;h3&gt;Multiple Instances Per Directory&lt;/h3&gt; &#xA;&lt;p&gt;You can run multiple Claude instances for the same directory to support different workflows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The first instance in a directory is the &#34;default&#34; instance&lt;/li&gt; &#xA; &lt;li&gt;Additional instances require a name when created (e.g., &#34;tests&#34;, &#34;docs&#34;, &#34;refactor&#34;)&lt;/li&gt; &#xA; &lt;li&gt;When multiple instances exist for a directory, commands that interact with Claude will prompt you to select which instance to use&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;C-u claude-code-switch-to-buffer&lt;/code&gt; to see all Claude instances across all directories (not just the current directory)&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;claude-code-select-buffer&lt;/code&gt; as a dedicated command to always show all Claude instances across all directories&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This allows you to have separate Claude conversations for different aspects of your work within the same project, such as one instance for writing code and another for writing tests.&lt;/p&gt; &#xA;&lt;h2&gt;Working in the Claude Buffer&lt;/h2&gt; &#xA;&lt;p&gt;claude-code.el is designed to support using Claude Code in Emacs using the minibuffer and regular Emacs buffers, with normal keybindings and full Emacs editing facilities. However, claude-code.el also adds a few niceties for working in the Claude Code terminal buffer:&lt;/p&gt; &#xA;&lt;p&gt;You can type &lt;code&gt;C-g&lt;/code&gt; as an alternative to escape. Also claude-code.el supports several options for entering newlines in the Claude Code session:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Default (newline-on-shift-return)&lt;/strong&gt;: Press &lt;code&gt;Shift-Return&lt;/code&gt; to insert a newline, &lt;code&gt;Return&lt;/code&gt; to send your message&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Alt-return style&lt;/strong&gt;: Press &lt;code&gt;Alt-Return&lt;/code&gt; to insert a newline, &lt;code&gt;Return&lt;/code&gt; to send&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Shift-return to send&lt;/strong&gt;: Press &lt;code&gt;Return&lt;/code&gt; to insert a newline, &lt;code&gt;Shift-Return&lt;/code&gt; to send&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Super-return to send&lt;/strong&gt;: Press &lt;code&gt;Return&lt;/code&gt; to insert a newline, &lt;code&gt;Command-Return&lt;/code&gt; (macOS) to send&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can change this behavior by customizing &lt;code&gt;claude-code-newline-keybinding-style&lt;/code&gt; (see &lt;a href=&#34;https://raw.githubusercontent.com/stevemolitor/claude-code.el/main/#customization&#34;&gt;Customization&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Command Reference&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-transient&lt;/code&gt; (&lt;code&gt;C-c c m&lt;/code&gt;) - Show all commands (transient menu)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code&lt;/code&gt; (&lt;code&gt;C-c c c&lt;/code&gt;) - Start Claude. With prefix arg (&lt;code&gt;C-u&lt;/code&gt;), switches to the Claude buffer after creating. With double prefix (&lt;code&gt;C-u C-u&lt;/code&gt;), prompts for the project directory&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-start-in-directory&lt;/code&gt; (&lt;code&gt;C-c c d&lt;/code&gt;) - Prompt for a directory and start Claude there. With prefix arg (&lt;code&gt;C-u&lt;/code&gt;), switches to the Claude buffer after creating&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-continue&lt;/code&gt; (&lt;code&gt;C-c c C&lt;/code&gt;) - Start Claude and continue the previous conversation. With prefix arg (&lt;code&gt;C-u&lt;/code&gt;), switches to the Claude buffer after creating. With double prefix (&lt;code&gt;C-u C-u&lt;/code&gt;), prompts for the project directory&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-resume&lt;/code&gt; (&lt;code&gt;C-c c R&lt;/code&gt;) - Resume a specific Claude session from an interactive list. With prefix arg (&lt;code&gt;C-u&lt;/code&gt;), switches to the Claude buffer after creating. With double prefix (&lt;code&gt;C-u C-u&lt;/code&gt;), prompts for the project directory&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-new-instance&lt;/code&gt; (&lt;code&gt;C-c c i&lt;/code&gt;) - Create a new Claude instance with a custom name. Always prompts for instance name, unlike &lt;code&gt;claude-code&lt;/code&gt; which uses &#34;default&#34; when no instances exist. With prefix arg (&lt;code&gt;C-u&lt;/code&gt;), switches to the Claude buffer after creating. With double prefix (&lt;code&gt;C-u C-u&lt;/code&gt;), prompts for the project directory&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-kill&lt;/code&gt; (&lt;code&gt;C-c c k&lt;/code&gt;) - Kill Claude session&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-kill-all&lt;/code&gt; (&lt;code&gt;C-c c K&lt;/code&gt;) - Kill ALL Claude instances across all directories&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-send-command&lt;/code&gt; (&lt;code&gt;C-c c s&lt;/code&gt;) - Send command to Claude. With prefix arg (&lt;code&gt;C-u&lt;/code&gt;), switches to the Claude buffer after sending&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-send-command-with-context&lt;/code&gt; (&lt;code&gt;C-c c x&lt;/code&gt;) - Send command with current file and line context. With prefix arg (&lt;code&gt;C-u&lt;/code&gt;), switches to the Claude buffer after sending&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-send-region&lt;/code&gt; (&lt;code&gt;C-c c r&lt;/code&gt;) - Send the current region or buffer to Claude. With prefix arg (&lt;code&gt;C-u&lt;/code&gt;), prompts for instructions to add to the text. With double prefix (&lt;code&gt;C-u C-u&lt;/code&gt;), adds instructions and switches to Claude buffer&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-fix-error-at-point&lt;/code&gt; (&lt;code&gt;C-c c e&lt;/code&gt;) - Ask Claude to fix the error at the current point (works with flycheck, flymake, and any system that implements help-at-pt). With prefix arg (&lt;code&gt;C-u&lt;/code&gt;), switches to the Claude buffer after sending&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-fork&lt;/code&gt; (&lt;code&gt;C-c c f&lt;/code&gt;) - Fork conversation (jump to previous conversation by sending escape-escape to Claude)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-slash-commands&lt;/code&gt; (&lt;code&gt;C-c c /&lt;/code&gt;) - Access Claude slash commands menu&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-toggle&lt;/code&gt; (&lt;code&gt;C-c c t&lt;/code&gt;) - Toggle Claude window&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-switch-to-buffer&lt;/code&gt; (&lt;code&gt;C-c c b&lt;/code&gt;) - Switch to the Claude buffer. With prefix arg (&lt;code&gt;C-u&lt;/code&gt;), shows all Claude instances across all directories&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-select-buffer&lt;/code&gt; (&lt;code&gt;C-c c B&lt;/code&gt;) - Select and switch to a Claude buffer from all running instances across all projects and directories&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-toggle-read-only-mode&lt;/code&gt; (&lt;code&gt;C-c c z&lt;/code&gt;) - Toggle between read-only mode and normal mode in Claude buffer (useful for selecting and copying text)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-cycle-mode&lt;/code&gt; (&lt;code&gt;C-c c TAB&lt;/code&gt;) - Send Shift-Tab to Claude to cycle between default mode, auto-accept edits mode, and plan mode&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-send-return&lt;/code&gt; (&lt;code&gt;C-c c y&lt;/code&gt;) - Send return key to Claude (useful for confirming with Claude without switching to the Claude REPL buffer) (useful for responding with &#34;Yes&#34; to Claude)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-send-escape&lt;/code&gt; (&lt;code&gt;C-c c n&lt;/code&gt;) - Send escape key to Claude (useful for saying &#34;No&#34; when Claude asks for confirmation without switching to the Claude REPL buffer)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-send-1&lt;/code&gt; (&lt;code&gt;C-c c 1&lt;/code&gt;) - Send &#34;1&#34; to Claude (useful for selecting the first option when Claude presents a numbered menu)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-send-2&lt;/code&gt; (&lt;code&gt;C-c c 2&lt;/code&gt;) - Send &#34;2&#34; to Claude (useful for selecting the second option when Claude presents a numbered menu)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;claude-code-send-3&lt;/code&gt; (&lt;code&gt;C-c c 3&lt;/code&gt;) - Send &#34;3&#34; to Claude (useful for selecting the third option when Claude presents a numbered menu)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Desktop Notifications&lt;/h2&gt; &#xA;&lt;p&gt;claude-code.el notifies you when Claude finishes processing and is waiting for input. By default, it displays a message in the minibuffer and pulses the modeline for visual feedback.&lt;/p&gt; &#xA;&lt;h3&gt;macOS Native Notifications&lt;/h3&gt; &#xA;&lt;p&gt;To use macOS native notifications with sound, add this to your configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun my-claude-notify (title message)&#xA;  &#34;Display a macOS notification with sound.&#34;&#xA;  (call-process &#34;osascript&#34; nil nil nil&#xA;                &#34;-e&#34; (format &#34;display notification \&#34;%s\&#34; with title \&#34;%s\&#34; sound name \&#34;Glass\&#34;&#34;&#xA;                             message title)))&#xA;&#xA;(setq claude-code-notification-function #&#39;my-claude-notify)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will display a system notification with a &#34;Glass&#34; sound effect when Claude is ready. You can change the sound name to any system sound (e.g., &#34;Ping&#34;, &#34;Hero&#34;, &#34;Morse&#34;, etc.) or remove the &lt;code&gt;sound name&lt;/code&gt; part for silent notifications.&lt;/p&gt; &#xA;&lt;h3&gt;Linux Native Notifications&lt;/h3&gt; &#xA;&lt;p&gt;For Linux desktop notifications, you can use &lt;code&gt;notify-send&lt;/code&gt; (GNOME/Unity) or &lt;code&gt;kdialog&lt;/code&gt; (KDE):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; For GNOME/Unity desktops&#xA;(defun my-claude-notify (title message)&#xA;  &#34;Display a Linux notification using notify-send.&#34;&#xA;  (if (executable-find &#34;notify-send&#34;)&#xA;      (call-process &#34;notify-send&#34; nil nil nil title message)&#xA;    (message &#34;%s: %s&#34; title message)))&#xA;&#xA;(setq claude-code-notification-function #&#39;my-claude-notify)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To add sound on Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun my-claude-notify-with-sound (title message)&#xA;  &#34;Display a Linux notification with sound.&#34;&#xA;  (when (executable-find &#34;notify-send&#34;)&#xA;    (call-process &#34;notify-send&#34; nil nil nil title message))&#xA;  ;; Play sound if paplay is available&#xA;  (when (executable-find &#34;paplay&#34;)&#xA;    (call-process &#34;paplay&#34; nil nil nil &#34;/usr/share/sounds/freedesktop/stereo/message.oga&#34;)))&#xA;&#xA;(setq claude-code-notification-function #&#39;my-claude-notify-with-sound)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Windows Native Notifications&lt;/h3&gt; &#xA;&lt;p&gt;For Windows, you can use PowerShell to create toast notifications:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun my-claude-notify (title message)&#xA;  &#34;Display a Windows notification using PowerShell.&#34;&#xA;  (call-process &#34;powershell&#34; nil nil nil&#xA;                &#34;-NoProfile&#34; &#34;-Command&#34;&#xA;                (concat &#34;[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null; &#34;&#xA;                        &#34;$template = &#39;&amp;lt;toast&amp;gt;&amp;lt;visual&amp;gt;&amp;lt;binding template=\&#34;ToastGeneric\&#34;&amp;gt;&amp;lt;text&amp;gt;&#34; title &#34;&amp;lt;/text&amp;gt;&amp;lt;text&amp;gt;&#34; message &#34;&amp;lt;/text&amp;gt;&amp;lt;/binding&amp;gt;&amp;lt;/visual&amp;gt;&amp;lt;/toast&amp;gt;&#39;; &#34;&#xA;                        &#34;$xml = New-Object Windows.Data.Xml.Dom.XmlDocument; &#34;&#xA;                        &#34;$xml.LoadXml($template); &#34;&#xA;                        &#34;$toast = [Windows.UI.Notifications.ToastNotification]::new($xml); &#34;&#xA;                        &#34;[Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier(&#39;Emacs&#39;).Show($toast)&#34;)))&#xA;&#xA;(setq claude-code-notification-function #&#39;my-claude-notify)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: Linux and Windows examples are untested. Feedback and improvements are welcome!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Tips and Tricks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Paste images&lt;/strong&gt;: Use &lt;code&gt;C-v&lt;/code&gt; to paste images into the Claude window. Note that on macOS, this is &lt;code&gt;Control-v&lt;/code&gt;, not &lt;code&gt;Command-v&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Paste text&lt;/strong&gt;: Use &lt;code&gt;C-y&lt;/code&gt; (&lt;code&gt;yank&lt;/code&gt;) to paste text into the Claude window.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Save files before sending commands&lt;/strong&gt;: Claude reads files directly from disk, not from Emacs buffers. Always save your files (&lt;code&gt;C-x C-s&lt;/code&gt;) before sending commands that reference file content. Consider enabling &lt;code&gt;global-auto-revert-mode&lt;/code&gt; to automatically sync Emacs buffers with file changes made by Claude: &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-auto-revert-mode 1)&#xA;;; If files aren&#39;t reliably auto-reverting after Claude makes changes,&#xA;;; disable file notification and use polling instead:&#xA;(setq auto-revert-use-notify nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Customization {#customization}&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; Set your key binding for the command map&#xA;(global-set-key (kbd &#34;C-c C-a&#34;) claude-code-command-map)&#xA;&#xA;;; Set terminal type for the Claude terminal emulation (default is &#34;xterm-256color&#34;)&#xA;;; This determines terminal capabilities like color support&#xA;;; See the documentation for eat-term-name for more information&#xA;(setq claude-code-term-name &#34;xterm-256color&#34;)&#xA;&#xA;;; Change the path to the Claude executable (default is &#34;claude&#34;)&#xA;;; Useful if Claude is not in your PATH or you want to use a specific version&#xA;(setq claude-code-program &#34;/usr/local/bin/claude&#34;)&#xA;&#xA;;; Set command line arguments for Claude&#xA;;; For example, to enable verbose output&#xA;(setq claude-code-program-switches &#39;(&#34;--verbose&#34;))&#xA;&#xA;;; Add hooks to run after Claude is started&#xA;(add-hook &#39;claude-code-start-hook &#39;my-claude-setup-function)&#xA;&#xA;;; Adjust initialization delay (default is 0.1 seconds)&#xA;;; This helps prevent terminal layout issues if the buffer is displayed before Claude is fully ready&#xA;(setq claude-code-startup-delay 0.2)&#xA;&#xA;;; Configure the buffer size threshold for confirmation prompt (default is 100000 characters)&#xA;;; If a buffer is larger than this threshold, claude-code-send-region will ask for confirmation&#xA;;; before sending the entire buffer to Claude&#xA;(setq claude-code-large-buffer-threshold 100000)&#xA;&#xA;;; Configure key binding style for entering newlines and sending messages in Claude buffers&#xA;;; Available styles:&#xA;;;   &#39;newline-on-shift-return - S-return inserts newline, RET sends message (default)&#xA;;;   &#39;newline-on-alt-return   - M-return inserts newline, RET sends message&#xA;;;   &#39;shift-return-to-send    - RET inserts newline, S-return sends message&#xA;;;   &#39;super-return-to-send    - RET inserts newline, s-return sends message (Command+Return on macOS)&#xA;(setq claude-code-newline-keybinding-style &#39;newline-on-shift-return)&#xA;&#xA;;; Enable or disable notifications when Claude finishes and awaits input (default is t)&#xA;(setq claude-code-enable-notifications t)&#xA;&#xA;;; Customize the notification function (default is claude-code--default-notification)&#xA;;; The function should accept two arguments: title and message&#xA;;; The default function displays a message and pulses the modeline for visual feedback&#xA;(setq claude-code-notification-function &#39;claude-code--default-notification)&#xA;&#xA;;; Example: Use your own notification function&#xA;(defun my-claude-notification (title message)&#xA;  &#34;Custom notification function for Claude Code.&#34;&#xA;  ;; Your custom notification logic here&#xA;  (message &#34;[%s] %s&#34; title message))&#xA;(setq claude-code-notification-function &#39;my-claude-notification)&#xA;&#xA;;; Configure kill confirmation behavior (default is t)&#xA;;; When t, claude-code-kill prompts for confirmation before killing instances&#xA;;; When nil, kills Claude instances without confirmation&#xA;(setq claude-code-confirm-kill t)&#xA;&#xA;;; Enable/disable window resize optimization (default is t)&#xA;;; When enabled, terminal reflows are only triggered when window width changes,&#xA;;; not when only height changes. This prevents unnecessary redraws when splitting&#xA;;; windows vertically, improving performance and reducing visual artifacts.&#xA;;; Set to nil if you experience issues with terminal display after resizing.&#xA;(setq claude-code-optimize-window-resize t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Customizing Window Position&lt;/h3&gt; &#xA;&lt;p&gt;You can control how the Claude Code window appears using Emacs&#39; &lt;code&gt;display-buffer-alist&lt;/code&gt;. For example, to make the Claude window appear in a persistent side window on the right side of your screen with 33% width:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-to-list &#39;display-buffer-alist&#xA;                 &#39;(&#34;^\\*claude&#34;&#xA;                   (display-buffer-in-side-window)&#xA;                   (side . right)&#xA;                   (window-width . 90)&#xA;                   (window-parameters . ((no-delete-other-windows . t)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This layout works best on wide screens.&lt;/p&gt; &#xA;&lt;h3&gt;Font Setup&lt;/h3&gt; &#xA;&lt;p&gt;Claude Code uses a lot of special unicode characters, and most common programming fonts don&#39;t include them all. To ensure that Claude renders special characters correctly in Emacs, you need to either use a font with really good unicode support, or set up fallback fonts for Emacs to use when your preferred font does not have a character.&lt;/p&gt; &#xA;&lt;h3&gt;Using System Fonts as Fallbacks&lt;/h3&gt; &#xA;&lt;p&gt;If you don&#39;t want to install any new fonts, you can use fonts already on your system as fallbacks. Here&#39;s a good setup for macOS, assuming your default, preferred font is &#34;Maple Mono&#34;. Substitute &#34;Maple Mono&#34; with whatever your default font is, and add this to your &lt;code&gt;init.el&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; important - tell emacs to use our fontset settings&#xA;(setq use-default-font-for-symbols nil)&#xA;&#xA;;; add least preferred fonts first, most preferred last&#xA;(set-fontset-font t &#39;symbol &#34;STIX Two Math&#34; nil &#39;prepend)&#xA;(set-fontset-font t &#39;symbol &#34;Zapf Dingbats&#34; nil &#39;prepend)&#xA;(set-fontset-font t &#39;symbol &#34;Menlo&#34; nil &#39;prepend)&#xA;&#xA;;; add your default, preferred font last&#xA;(set-fontset-font t &#39;symbol &#34;Maple Mono&#34; nil &#39;prepend)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The configuration on Linux or Windows will depend on the fonts available on your system. To test if your system has a certain font, evaluate this expression:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(find-font (font-spec :family &#34;DejaVu Sans Mono&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Linux it might look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq use-default-font-for-symbols nil)&#xA;(set-fontset-font t &#39;symbol &#34;DejaVu Sans Mono&#34; nil &#39;prepend)&#xA;&#xA;;; your preferred, default font:&#xA;(set-fontset-font t &#39;symbol &#34;Maple Mono&#34; nil &#39;prepend)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using JuliaMono as Fallback&lt;/h3&gt; &#xA;&lt;p&gt;A cross-platform approach is to install a fixed-width font with really good unicode symbols support. &lt;a href=&#34;https://juliamono.netlify.app/&#34;&gt;JuliaMono&lt;/a&gt; has excellent Unicode symbols support. To let the Claude Code buffer use Julia Mono for rendering Unicode characters while still using your default font for ASCII characters add this elisp code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq use-default-font-for-symbols nil)&#xA;(set-fontset-font t &#39;unicode (font-spec :family &#34;JuliaMono&#34;))&#xA;&#xA;;; your preferred, default font:&#xA;(set-fontset-font t &#39;symbol &#34;Maple Mono&#34; nil &#39;prepend)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using a Custom Claude Code Font&lt;/h3&gt; &#xA;&lt;p&gt;If instead you want to use a particular font just for the Claude Code REPL but use a different font everywhere else you can customize the &lt;code&gt;claude-code-repl-face&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(custom-set-faces&#xA;   &#39;(claude-code-repl-face ((t (:family &#34;JuliaMono&#34;)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(If you set the Claude Code font to &#34;JuliaMono&#34;, you can skip all the fontset fallback configurations above.)&lt;/p&gt; &#xA;&lt;h3&gt;Reducing Flickering on Window Configuration Changes&lt;/h3&gt; &#xA;&lt;p&gt;To reduce flickering in the Claude buffer on window configuration changes, you can adjust eat latency variables in a hook. This reduces flickering at the cost of some increased latency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;  ;; reduce flickering&#xA;  (add-hook &#39;claude-code-start-hook&#xA;            (lambda ()&#xA;              (setq-local eat-minimum-latency 0.033&#xA;                          eat-maximum-latency 0.1)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: Recent changes to claude-code.el have fixed flickering issues, making customization of these latency values less necessary.&lt;/p&gt; &#xA;&lt;h3&gt;Fixing Spaces Between Vertical Bars&lt;/h3&gt; &#xA;&lt;p&gt;If you see spaces between vertical bars in Claude&#39;s output, you can fix this by adjusting the &lt;code&gt;line-spacing&lt;/code&gt; value. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; Set line spacing to reduce gaps between vertical bars&#xA;(setq line-spacing 0.1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or to apply it only to Claude buffers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-hook &#39;claude-code-start-hook&#xA;          (lambda ()&#xA;            ;; Reduce line spacing to fix vertical bar gaps&#xA;            (setq-local line-spacing 0.1))) &#xA;&#xA;## Demo&#xA;&#xA;### GIF Demo&#xA;&#xA;![Claude Code Emacs Demo](./images/demo.gif)&#xA;&#xA;This [demo](./demo.gif) shows claude-code.el in action, including accessing the transient menu, sending commands with file context, and fixing errors.&#xA;&#xA;### Video Demo&#xA;&#xA;[![The Emacs Claude Code Package](https://img.youtube.com/vi/K8sCVLmFyyU/0.jpg)](https://www.youtube.com/watch?v=K8sCVLmFyyU)&#xA;&#xA;Check out this [video demo](https://www.youtube.com/watch?v=K8sCVLmFyyU) demonstrating the claude-code.el package. This video was kindly created and shared by a user of the package.&#xA;&#xA;### Eat-specific Customization&#xA;&#xA;When using the eat terminal backend, there are additional customization options available:&#xA;&#xA;```elisp&#xA;;; Customize cursor type in read-only mode (default is &#39;(box nil nil))&#xA;;; The format is (CURSOR-ON BLINKING-FREQUENCY CURSOR-OFF)&#xA;;; Cursor type options: &#39;box, &#39;hollow, &#39;bar, &#39;hbar, or nil&#xA;(setq claude-code-eat-read-only-mode-cursor-type &#39;(bar nil nil))&#xA;&#xA;;; Control eat scrollback size for longer conversations&#xA;;; The default is 131072 characters, which is usually sufficient&#xA;;; For very long Claude sessions, you may want to increase it&#xA;;; WARNING: Setting to nil (unlimited) is NOT recommended with Claude Code&#xA;;; as it can cause severe performance issues with long sessions&#xA;(setq eat-term-scrollback-size 500000)  ; Increase to 500k characters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Vterm-specific Customization&lt;/h3&gt; &#xA;&lt;p&gt;When using the vterm terminal backend, there are additional customization options available:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; Enable/disable buffering to prevent flickering on multi-line input (default is t)&#xA;;; When enabled, vterm output that appears to be redrawing multi-line input boxes&#xA;;; will be buffered briefly (1ms) and processed in a single batch&#xA;;; This prevents flickering when Claude redraws its input box as it expands&#xA;(setq claude-code-vterm-buffer-multiline-output t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Vterm Scrollback Configuration&lt;/h4&gt; &#xA;&lt;p&gt;Vterm has its own scrollback limit that is separate from claude-code.el settings. By default, vterm limits scrollback to 1000 lines. To allow scrolling back to the top of long Claude conversations, you can increase &lt;code&gt;vterm-max-scrollback&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; Increase vterm scrollback to 100000 lines (the maximum allowed)&#xA;;; Note: This increases memory usage&#xA;(setq vterm-max-scrollback 100000)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you prefer not to set this globally, you can set it only for Claude buffers using a hook:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-hook &#39;claude-code-start-hook&#xA;          (lambda ()&#xA;            ;; Only increase scrollback for vterm backend&#xA;            (when (eq claude-code-terminal-backend &#39;vterm)&#xA;              (setq-local vterm-max-scrollback 100000))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This ensures that only Claude buffers have increased scrollback, while other vterm buffers maintain the default limit.&lt;/p&gt; &#xA;&lt;h4&gt;Vterm Window Width Configuration&lt;/h4&gt; &#xA;&lt;p&gt;Vterm has a minimum window width setting that affects how text wraps. By default, &lt;code&gt;vterm-min-window-width&lt;/code&gt; is set to 80 columns. If you resize the Claude window to be narrower than this limit, the Claude input box may wrap incorrectly, causing display issues.&lt;/p&gt; &#xA;&lt;p&gt;If you prefer to use Claude in a narrow window (for example, in a side window), you can adjust &lt;code&gt;vterm-min-window-width&lt;/code&gt;. Note that this must be set as a custom variable, either via &lt;code&gt;custom-set-variables&lt;/code&gt; or &lt;code&gt;setop&lt;/code&gt;, &lt;code&gt;setq&lt;/code&gt; won&#39;t work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; Allow vterm windows to be as narrow as 40 columns&#xA;(setopt vterm-min-window-width 40)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is particularly useful if you like to keep Claude in a narrow side window while coding in your main window.&lt;/p&gt; &#xA;&lt;h4&gt;Vterm Timer Delay&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;vterm-timer-delay&lt;/code&gt; variable controls how often vterm refreshes its buffer when receiving data. This delay (in seconds) helps manage performance when processing large amounts of output. Setting it to &lt;code&gt;nil&lt;/code&gt; disables the delay entirely.&lt;/p&gt; &#xA;&lt;p&gt;The default value of &lt;code&gt;0.1&lt;/code&gt; seconds works well with Claude Code. Since Claude often sends large bursts of data when generating code or explanations, reducing this delay or disabling it (&lt;code&gt;nil&lt;/code&gt;) can significantly degrade performance. Stick with the default, or use a slightly higher value unless you experience specific display issues.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome! Please feel free to submit a Pull Request.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the Apache License 2.0 - see the LICENSE file for details.&lt;/p&gt;</summary>
  </entry>
</feed>