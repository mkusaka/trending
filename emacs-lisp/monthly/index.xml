<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-01T01:50:45Z</updated>
  <subtitle>Monthly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>abo-abo/ace-window</title>
    <updated>2024-08-01T01:50:45Z</updated>
    <id>tag:github.com,2024-08-01:/abo-abo/ace-window</id>
    <link href="https://github.com/abo-abo/ace-window" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Quickly switch windows in Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ace-window&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://elpa.gnu.org/packages/ace-window.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/packages/ace-window.svg?sanitize=true&#34; alt=&#34;GNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/ace-window&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/ace-window-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/ace-window&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/ace-window-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;GNU Emacs package for selecting a window to switch to&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What and why&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;m sure you&#39;re aware of the &lt;code&gt;other-window&lt;/code&gt; command. While it&#39;s great for two windows, it quickly loses its value when there are more windows. You need to call it many times, and since it&#39;s not easily predictable, you have to check each time if you&#39;re in the window that you wanted.&lt;/p&gt; &#xA;&lt;p&gt;Another approach is to use &lt;code&gt;windmove-left&lt;/code&gt;, &lt;code&gt;windmove-up&lt;/code&gt;, etc. These are fast and predictable. Their disadvantage is that they need 4 key bindings. The default ones are shift+arrows, which are hard to reach.&lt;/p&gt; &#xA;&lt;p&gt;This package aims to take the speed and predictability of &lt;code&gt;windmove&lt;/code&gt; and pack it into a single key binding, similar to &lt;code&gt;other-window&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;Just assign &lt;code&gt;ace-window&lt;/code&gt; to a short key binding, as switching windows is a common task. I suggest &lt;kbd&gt;M-o&lt;/kbd&gt;, as it&#39;s short and not bound to anything important in the default Emacs.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;When there are two windows, &lt;code&gt;ace-window&lt;/code&gt; will call &lt;code&gt;other-window&lt;/code&gt; (unless &lt;code&gt;aw-dispatch-always&lt;/code&gt; is set non-nil). If there are more, each window will have the first character of its window label highlighted at the upper left of the window. Pressing that character will either switch to that window or filter to the next character needed to select a specific window. Note that, unlike &lt;code&gt;ace-jump-mode&lt;/code&gt;, the position of point will not be changed, i.e. the same behavior as that of &lt;code&gt;other-window&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A special character defined by &lt;code&gt;aw-make-frame-char&lt;/code&gt; (default = &lt;code&gt;z&lt;/code&gt;) means create a new frame and use its window as the target. The new frame&#39;s location is set relative to the prior selected frame&#39;s location and given by &lt;code&gt;aw-frame-offset&lt;/code&gt;. The new frame&#39;s size is given by &lt;code&gt;aw-frame-size&lt;/code&gt;. See their documentation strings for more information.&lt;/p&gt; &#xA;&lt;p&gt;The windows are ordered top-down, left-to-right. This means that if you remember your window layouts, you can switch windows without even looking at the leading char. For instance, the top left window will always be &lt;code&gt;1&lt;/code&gt; (or &lt;code&gt;a&lt;/code&gt; if you use letters for window characters).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ace-window&lt;/code&gt; works across multiple frames, as you can see from the &lt;a href=&#34;http://oremacs.com/download/ace-window.gif&#34;&gt;in-action gif&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Swap and delete window&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You can swap windows by calling &lt;code&gt;ace-window&lt;/code&gt; with a prefix argument &lt;kbd&gt;C-u&lt;/kbd&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can delete the selected window by calling &lt;code&gt;ace-window&lt;/code&gt; with a double prefix argument, i.e. &lt;kbd&gt;C-u C-u&lt;/kbd&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Change the action midway&lt;/h2&gt; &#xA;&lt;p&gt;You can also start by calling &lt;code&gt;ace-window&lt;/code&gt; and then decide to switch the action to &lt;code&gt;delete&lt;/code&gt; or &lt;code&gt;swap&lt;/code&gt; etc. By default the bindings are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;kbd&gt;x&lt;/kbd&gt; - delete window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;m&lt;/kbd&gt; - swap windows&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;M&lt;/kbd&gt; - move window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;c&lt;/kbd&gt; - copy window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;j&lt;/kbd&gt; - select buffer&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;n&lt;/kbd&gt; - select the previous window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;u&lt;/kbd&gt; - select buffer in the other window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;c&lt;/kbd&gt; - split window fairly, either vertically or horizontally&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;v&lt;/kbd&gt; - split window vertically&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;b&lt;/kbd&gt; - split window horizontally&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;o&lt;/kbd&gt; - maximize current window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;?&lt;/kbd&gt; - show these command bindings&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For proper operation, these keys &lt;em&gt;must not&lt;/em&gt; be in &lt;code&gt;aw-keys&lt;/code&gt;. Additionally, if you want these keys to work with fewer than three windows, you need to have &lt;code&gt;aw-dispatch-always&lt;/code&gt; set to &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Customization&lt;/h2&gt; &#xA;&lt;p&gt;Aside from binding &lt;code&gt;ace-window&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(global-set-key (kbd &#34;M-o&#34;) &#39;ace-window)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;the following customizations are available:&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-keys&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;aw-keys&lt;/code&gt; - the list of initial characters used in window labels:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setq aw-keys &#39;(?a ?s ?d ?f ?g ?h ?j ?k ?l))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;aw-keys&lt;/code&gt; are 0-9 by default, which is reasonable, but in the setup above, the keys are on the home row.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-scope&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The default one is &lt;code&gt;global&lt;/code&gt;, which means that &lt;code&gt;ace-window&lt;/code&gt; will work across frames. If you set this to &lt;code&gt;frame&lt;/code&gt;, &lt;code&gt;ace-window&lt;/code&gt; will offer you only the windows of the current frame.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-background&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;ace-window&lt;/code&gt; temporarily sets a gray background and removes color from available windows in order to make the window-switching characters more visible. This is the behavior inherited from &lt;code&gt;ace-jump-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This behavior might not be necessary, as you already know the locations where to look, i.e. the top-left corners of each window. So you can turn off the gray background with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setq aw-background nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-dispatch-always&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When non-nil, &lt;code&gt;ace-window&lt;/code&gt; will issue a &lt;code&gt;read-char&lt;/code&gt; even for one window. This will make &lt;code&gt;ace-window&lt;/code&gt; act differently from &lt;code&gt;other-window&lt;/code&gt; for one or two windows. This is useful to change the action midway and execute an action other than the default &lt;em&gt;jump&lt;/em&gt; action. By default, this is set to &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-dispatch-alist&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This is the list of actions you can trigger from &lt;code&gt;ace-window&lt;/code&gt; other than the &lt;em&gt;jump&lt;/em&gt; default. By default it is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defvar aw-dispatch-alist&#xA;  &#39;((?x aw-delete-window &#34;Delete Window&#34;)&#xA;&#x9;(?m aw-swap-window &#34;Swap Windows&#34;)&#xA;&#x9;(?M aw-move-window &#34;Move Window&#34;)&#xA;&#x9;(?c aw-copy-window &#34;Copy Window&#34;)&#xA;&#x9;(?j aw-switch-buffer-in-window &#34;Select Buffer&#34;)&#xA;&#x9;(?n aw-flip-window)&#xA;&#x9;(?u aw-switch-buffer-other-window &#34;Switch Buffer Other Window&#34;)&#xA;&#x9;(?c aw-split-window-fair &#34;Split Fair Window&#34;)&#xA;&#x9;(?v aw-split-window-vert &#34;Split Vert Window&#34;)&#xA;&#x9;(?b aw-split-window-horz &#34;Split Horz Window&#34;)&#xA;&#x9;(?o delete-other-windows &#34;Delete Other Windows&#34;)&#xA;&#x9;(?? aw-show-dispatch-help))&#xA;  &#34;List of actions for `aw-dispatch-default&#39;.&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using ace-window, if the action character is followed by a string, then &lt;code&gt;ace-window&lt;/code&gt; will be invoked again to select the target window for the action. Otherwise, the current window is selected.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-minibuffer-flag&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When non-nil, also display &lt;code&gt;ace-window-mode&lt;/code&gt; string in the minibuffer when &lt;code&gt;ace-window&lt;/code&gt; is active. This is useful when there are many side-by-side windows and the &lt;code&gt;ace-window-mode&lt;/code&gt; string is cutoff in the minor mode area of the modeline.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-ignored-buffers&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;List of buffers and major-modes to ignore when choosing a window from the window list. Active only when &lt;code&gt;aw-ignore-on&lt;/code&gt; is non-nil. Windows displaying these buffers can still be chosen by typing their specific labels.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-ignore-on&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When t, &lt;code&gt;ace-window&lt;/code&gt; will ignore buffers and major-modes in &lt;code&gt;aw-ignored-buffers&lt;/code&gt;. Use M-0 &lt;code&gt;ace-window&lt;/code&gt; to toggle this value. :type &#39;boolean)&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-ignore-current&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When t, &lt;code&gt;ace-window&lt;/code&gt; will ignore `selected-window&#39;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacs-lsp/lsp-ui</title>
    <updated>2024-08-01T01:50:45Z</updated>
    <id>tag:github.com,2024-08-01:/emacs-lsp/lsp-ui</id>
    <link href="https://github.com/emacs-lsp/lsp-ui" rel="alternate"></link>
    <summary type="html">&lt;p&gt;UI integrations for lsp-mode&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lsp-ui&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://melpa.org/#/lsp-ui&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/lsp-ui-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/lsp-ui&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/lsp-ui-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/swuxy5AAgT&#34;&gt;&lt;img src=&#34;https://discordapp.com/api/guilds/789885435026604033/widget.png?style=shield&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/emacs-lsp/lsp-ui/actions&#34;&gt;&lt;img src=&#34;https://github.com/emacs-lsp/lsp-ui/workflows/CI/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-refresh-toc --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/#lsp-ui&#34;&gt;lsp-ui&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/#intro&#34;&gt;Intro&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/#lsp-ui-sideline&#34;&gt;lsp-ui-sideline:&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/#lsp-ui-peek&#34;&gt;lsp-ui-peek:&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/#lsp-ui-doc&#34;&gt;lsp-ui-doc&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/#lsp-ui-imenu&#34;&gt;lsp-ui-imenu&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;h2&gt;Intro&lt;/h2&gt; &#xA;&lt;p&gt;This package contains all the higher level UI modules of &lt;code&gt;lsp-mode&lt;/code&gt;, like flycheck support and code lenses.&lt;/p&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;lsp-mode&lt;/code&gt; automatically activates &lt;code&gt;lsp-ui&lt;/code&gt; unless &lt;code&gt;lsp-auto-configure&lt;/code&gt; is set to &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You only have to put &lt;code&gt;(use-package lsp-ui)&lt;/code&gt; in your config and the package will work out of the box. (&lt;a href=&#34;https://github.com/jwiegley/use-package&#34;&gt;use-package&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;Or use the builtin package manager.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x package-install [RET] lsp-ui [RET]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;lsp-ui-sideline:&lt;/h2&gt; &#xA;&lt;p&gt;Show informations of the symbols on the current line. It also show flycheck diagnostics and LSP code actions &lt;img src=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/images/lsp-line.gif&#34; alt=&#34;lsp-line&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Customization:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-sideline-show-diagnostics&lt;/code&gt; show diagnostics messages in sideline&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-sideline-show-hover&lt;/code&gt; show hover messages in sideline&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-sideline-show-code-actions&lt;/code&gt; show code actions in sideline&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-sideline-update-mode&lt;/code&gt; When set to &#39;line&#39; the information will be updated when user changes current line otherwise the information will be updated when user changes current point&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-sideline-delay&lt;/code&gt; seconds to wait before showing sideline&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;lsp-ui-peek:&lt;/h2&gt; &#xA;&lt;p&gt;Add &lt;a href=&#34;https://code.visualstudio.com/docs/editor/editingevolved#_peek&#34;&gt;peek&lt;/a&gt; feature &lt;img src=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/images/lsp-xref.gif&#34; alt=&#34;lsp-xref&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You may remap &lt;code&gt;xref-find-{definitions,references}&lt;/code&gt; (bound to &lt;kbd&gt;M-.&lt;/kbd&gt; &lt;kbd&gt;M-?&lt;/kbd&gt; by default):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(define-key lsp-ui-mode-map [remap xref-find-definitions] #&#39;lsp-ui-peek-find-definitions)&#xA;(define-key lsp-ui-mode-map [remap xref-find-references] #&#39;lsp-ui-peek-find-references)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is a window-local jump list dedicated to cross references:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(lsp-ui-peek-jump-backward)&#xA;(lsp-ui-peek-jump-forward)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other cross references:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(lsp-ui-peek-find-workspace-symbol &#34;pattern 0&#34;)&#xA;;; If the server supports custom cross references&#xA;(lsp-ui-peek-find-custom &#39;base &#34;$cquery/base&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Customization:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-peek-enable&lt;/code&gt; enable ‘lsp-ui-peek’&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-peek-show-directory&lt;/code&gt; show the directory of files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;lsp-ui-doc&lt;/h2&gt; &#xA;&lt;p&gt;Show object documentation at point in a child frame. &lt;img src=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/images/lsp-ui-doc.gif&#34; alt=&#34;lsp-ui-doc&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Show documentation in a WebKit widget &lt;img src=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/images/lsp-ui-doc-webkit.png&#34; alt=&#34;lsp-ui-doc-webkit&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Focus into lsp-ui-doc-frame &lt;img src=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/images/lsp-ui-doc-focus-frame.gif&#34; alt=&#34;lsp-ui-doc-focus-frame&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Customization:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-doc-enable&lt;/code&gt; Enable lsp-ui-doc&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-doc-position&lt;/code&gt; Where to display the doc (top, bottom or at-point)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-doc-side&lt;/code&gt; Where to display the doc (left or right)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-doc-delay&lt;/code&gt; Number of seconds before showing the doc&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-doc-show-with-cursor&lt;/code&gt; When non-nil, move the cursor over a symbol to show the doc&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-doc-show-with-mouse&lt;/code&gt; When non-nil, move the mouse pointer over a symbol to show the doc&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;lsp-ui-imenu&lt;/h2&gt; &#xA;&lt;p&gt;Show imenu entries.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/emacs-lsp/lsp-ui/master/images/lsp-ui-imenu.png&#34; alt=&#34;lsp-ui-doc&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Customization:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-imenu-kind-position&lt;/code&gt; place to show entries kind&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-imenu-buffer-position&lt;/code&gt; place to show the buffer window&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-imenu-window-width&lt;/code&gt; set window width&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-imenu-window-fix-width&lt;/code&gt; when non-nil, the window will not be resizable (eg. unaffected by &lt;code&gt;balance-windows&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-imenu--custom-mode-line-format&lt;/code&gt; mode line format&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-imenu-auto-refresh&lt;/code&gt; auto refresh when necessary&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lsp-ui-imenu-refresh-delay&lt;/code&gt; delay to refresh imenu&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Any kind of help is appreciated. If you want to help us maintaining this package, &lt;a href=&#34;https://github.com/emacs-lsp/lsp-ui/issues/332&#34;&gt;leave a note&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dominikh/go-mode.el</title>
    <updated>2024-08-01T01:50:45Z</updated>
    <id>tag:github.com,2024-08-01:/dominikh/go-mode.el</id>
    <link href="https://github.com/dominikh/go-mode.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs mode for the Go programming language&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This is go-mode, the Emacs mode for editing Go code.&lt;/p&gt; &#xA;&lt;p&gt;It is a complete rewrite of the go-mode that shipped with Go 1.0.3 and before, and was part of Go 1.1 until Go 1.3. Beginning with Go 1.4, editor integration will not be part of the Go distribution anymore, making this repository the canonical place for go-mode.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;p&gt;In addition to normal features, such as fontification and indentation, and close integration with familiar Emacs functionality (for example syntax-based navigation like &lt;code&gt;beginning-of-defun&lt;/code&gt;), go-mode comes with the following extra features to provide an improved experience:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Integration with &lt;code&gt;gofmt&lt;/code&gt; by providing a command of the same name, and &lt;code&gt;gofmt-before-save&lt;/code&gt;, which can be used in a hook to format Go buffers before saving them.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Setting the &lt;code&gt;gofmt-command&lt;/code&gt; variable also allows using &lt;code&gt;goimports&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Setting the &lt;code&gt;gofmt-args&lt;/code&gt; variable with a list of arguments allows using e.g. &lt;code&gt;gofmt -s&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Integration with &lt;code&gt;godoc&lt;/code&gt; via the functions &lt;code&gt;godoc&lt;/code&gt; and &lt;code&gt;godoc-at-point&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Integration with the Playground&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;go-play-buffer&lt;/code&gt; and &lt;code&gt;go-play-region&lt;/code&gt; to send code to the Playground&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;go-download-play&lt;/code&gt; to download a Playground entry into a new buffer&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Managing imports&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A function for jumping to the file&#39;s imports (&lt;code&gt;go-goto-imports&lt;/code&gt; - &lt;code&gt;C-c C-f i&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;A function for adding imports, including tab completion (&lt;code&gt;go-import-add&lt;/code&gt;, bound to &lt;code&gt;C-c C-a&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;It is recommended that you use &lt;code&gt;goimports&lt;/code&gt; or the &lt;code&gt;organize-imports&lt;/code&gt; feature of &lt;code&gt;gopls&lt;/code&gt; to manage adding/removing/organizing imports automatically.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Integration with godef&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;godef-describe&lt;/code&gt; (&lt;code&gt;C-c C-d&lt;/code&gt;) to describe expressions&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;godef-jump&lt;/code&gt; (&lt;code&gt;C-c C-j&lt;/code&gt;) and &lt;code&gt;godef-jump-other-window&lt;/code&gt; (&lt;code&gt;C-x 4 C-c C-j&lt;/code&gt;) to jump to declarations&lt;/li&gt; &#xA;   &lt;li&gt;This requires you to install godef via &lt;code&gt;go install github.com/rogpeppe/godef@latest&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Basic support for imenu (functions and variables)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Built-in support for displaying code coverage as calculated by &lt;code&gt;go test&lt;/code&gt; (&lt;code&gt;go-coverage&lt;/code&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Several functions for jumping to and manipulating the individual parts of function signatures. These functions support anonymous functions, but are smart enough to skip them when required (e.g. when jumping to a method receiver or docstring.)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Jump to the argument list (&lt;code&gt;go-goto-arguments&lt;/code&gt; - &lt;code&gt;C-c C-f a&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the docstring, create it if it does not exist yet (&lt;code&gt;go-goto-docstring&lt;/code&gt; - &lt;code&gt;C-c C-f d&lt;/code&gt;).&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the function keyword (&lt;code&gt;go-goto-function&lt;/code&gt; - &lt;code&gt;C-c C-f f&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the function name (&lt;code&gt;go-goto-function-name&lt;/code&gt; - &lt;code&gt;C-c C-f n&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the return values (&lt;code&gt;go-goto-return-values&lt;/code&gt; - &lt;code&gt;C-c C-f r&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the method receiver, adding a pair of parentheses if no method receiver exists (&lt;code&gt;go-goto-method-receiver&lt;/code&gt; - &lt;code&gt;C-c C-f m&lt;/code&gt;).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;All of these functions accept a prefix argument (&lt;code&gt;C-u&lt;/code&gt;), causing them to skip anonymous functions.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;MELPA&lt;/h2&gt; &#xA;&lt;p&gt;The recommended way of installing go-mode is via &lt;a href=&#34;http://www.emacswiki.org/emacs/ELPA&#34;&gt;ELPA&lt;/a&gt;, the Emacs package manager, and the &lt;a href=&#34;http://emacsredux.com/blog/2014/05/16/melpa-stable/&#34;&gt;MELPA Stable repository&lt;/a&gt;, which provides an up-to-date version of go-mode.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re not familiar with ELPA yet, consider reading &lt;a href=&#34;http://xahlee.info/emacs/emacs/emacs_package_system.html&#34;&gt;this guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Manual&lt;/h2&gt; &#xA;&lt;p&gt;To install go-mode manually, check out the &lt;code&gt;go-mode.el&lt;/code&gt; repository in a directory of your choice, add it to your load path and configure Emacs to automatically load it when opening a &lt;code&gt;.go&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(add-to-list &#39;load-path &#34;/place/where/you/put/it/&#34;)&#xA;(autoload &#39;go-mode &#34;go-mode&#34; nil t)&#xA;(add-to-list &#39;auto-mode-alist &#39;(&#34;\\.go\\&#39;&#34; . go-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Either evaluate the statements with &lt;code&gt;C-x C-e&lt;/code&gt;, or restart Emacs.&lt;/p&gt; &#xA;&lt;h1&gt;Other extensions&lt;/h1&gt; &#xA;&lt;p&gt;There are several third party extensions that can enhance the Go experience in Emacs.&lt;/p&gt; &#xA;&lt;h2&gt;Gopls integration&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/golang/tools/raw/master/gopls/README.md&#34;&gt;Gopls&lt;/a&gt; is the official language server protocol (lsp) implementation provided by the Go team. It is intended to replace the existing third party tools for code formatting (gofmt), automatic imports (goimports), code navigation (godef/guru), type and function descriptions (godoc/godef), error checking, auto completion (gocode), variable and type renaming (rename), and more. Once gopls is stable the older tools will no longer be supported.&lt;/p&gt; &#xA;&lt;p&gt;Gopls is a supported backend for &lt;a href=&#34;https://github.com/emacs-lsp/lsp-mode&#34;&gt;lsp-mode&lt;/a&gt;. It will be used automatically by lsp-mode if &lt;code&gt;gopls&lt;/code&gt; is found in your PATH. You can install gopls via: &lt;code&gt;go install golang.org/x/tools/gopls@latest&lt;/code&gt;. To enable lsp-mode for go buffers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(add-hook &#39;go-mode-hook &#39;lsp-deferred)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Syntax/error checking&lt;/h2&gt; &#xA;&lt;p&gt;There are two ways of using flymake with Go:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dougm/goflymake&#34;&gt;goflymake&lt;/a&gt;, which internally uses &lt;code&gt;go build&lt;/code&gt; to capture all errors that a regular compilation would also produce&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://marmalade-repo.org/packages/flymake-go&#34;&gt;flymake-go&lt;/a&gt; for a more lightweight solution that only uses &lt;code&gt;gofmt&lt;/code&gt; and as such is only able to catch syntax errors. Unlike goflymake, however, it does not require an additional executable.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Additionally, there is &lt;a href=&#34;https://github.com/flycheck/flycheck&#34;&gt;flycheck&lt;/a&gt;, a modern replacement for flymake, which comes with built-in support for Go. In addition to using &lt;code&gt;go build&lt;/code&gt; or &lt;code&gt;gofmt&lt;/code&gt;, it also has support for &lt;code&gt;go vet&lt;/code&gt;, &lt;code&gt;golint&lt;/code&gt; and &lt;code&gt;errcheck&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Auto completion&lt;/h2&gt; &#xA;&lt;p&gt;For auto completion, take a look at &lt;a href=&#34;https://github.com/nsf/gocode&#34;&gt;gocode&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;eldoc&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/syohex/emacs-go-eldoc&#34;&gt;https://github.com/syohex/emacs-go-eldoc&lt;/a&gt; provides eldoc functionality for go-mode.&lt;/p&gt; &#xA;&lt;h2&gt;Snippets&lt;/h2&gt; &#xA;&lt;p&gt;I maintain a set of YASnippet snippets for go-mode at &lt;a href=&#34;https://github.com/dominikh/yasnippet-go&#34;&gt;https://github.com/dominikh/yasnippet-go&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Integration with errcheck&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dominikh/go-errcheck.el&#34;&gt;https://github.com/dominikh/go-errcheck.el&lt;/a&gt; provides integration with &lt;a href=&#34;https://github.com/kisielk/errcheck&#34;&gt;errcheck&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Stability&lt;/h1&gt; &#xA;&lt;p&gt;go-mode.el has regular, tagged releases and is part of the MELPA Stable repository. These tagged releases are intended to provide a stable experience. APIs added in tagged releases will usually not be removed or changed in future releases.&lt;/p&gt; &#xA;&lt;p&gt;Changes made on the master branch, which is tracked by the normal MELPA repository, however, are under active development. New APIs are experimental and may be changed or removed before the next release. Furthermore, there is a higher chance for bugs.&lt;/p&gt; &#xA;&lt;p&gt;If you want a stable experience, use MELPA Stable. If you want cutting edge features, or &#34;beta-test&#34; future releases, use MELPA or the master branch.&lt;/p&gt;</summary>
  </entry>
</feed>