<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-01T01:47:24Z</updated>
  <subtitle>Monthly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>lizqwerscott/mcp.el</title>
    <updated>2025-06-01T01:47:24Z</updated>
    <id>tag:github.com,2025-06-01:/lizqwerscott/mcp.el</id>
    <link href="https://github.com/lizqwerscott/mcp.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An Mcp client inside Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: MCP.el - Model Context Protocol for Emacs&lt;/p&gt; &#xA;&lt;p&gt;[[https://www.gnu.org/licenses/gpl-3.0][https://img.shields.io/badge/License-GPLv3-blue.svg]]&lt;/p&gt; &#xA;&lt;p&gt;This is an Emacs client for interfacing with [[https://modelcontextprotocol.io/introduction][MCP]], supporting connections to MCP servers.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Structured communication with MCP servers&lt;/li&gt; &#xA; &lt;li&gt;Support for filesystem and generic MCP servers&lt;/li&gt; &#xA; &lt;li&gt;Extensible tool and prompt system&lt;/li&gt; &#xA; &lt;li&gt;Asynchronous and synchronous operations&lt;/li&gt; &#xA; &lt;li&gt;Resource management capabilities&lt;/li&gt; &#xA; &lt;li&gt;Intuitive interface for managing server lifecycle (start/stop/restart)&lt;/li&gt; &#xA; &lt;li&gt;Integration with popular Emacs packages (e.g., gptel, llm)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Emacs 30 or higher version&lt;/li&gt; &#xA; &lt;li&gt;Add the following code to your configuration file ~/.emacs: #+begin_src elisp (add-to-list &#39;load-path &#34;&amp;lt;path-to-mcp.el&amp;gt;&#34;) (require &#39;mcp-hub) #+end_src&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage ** Mcp hub *** Configuring MCP Servers #+begin_src elisp (setq mcp-hub-servers &#39;((&#34;filesystem&#34; . (:command &#34;npx&#34; :args (&#34;-y&#34; &#34;@modelcontextprotocol/server-filesystem&#34; &#34;/home/lizqwer/MyProject/&#34;))) (&#34;fetch&#34; . (:command &#34;uvx&#34; :args (&#34;mcp-server-fetch&#34;))) (&#34;qdrant&#34; . (:url &#34;&lt;a href=&#34;http://localhost:8000/sse&#34;&gt;http://localhost:8000/sse&lt;/a&gt;&#34;)) (&#34;graphlit&#34; . ( :command &#34;npx&#34; :args (&#34;-y&#34; &#34;graphlit-mcp-server&#34;) :env ( :GRAPHLIT_ORGANIZATION_ID &#34;your-organization-id&#34; :GRAPHLIT_ENVIRONMENT_ID &#34;your-environment-id&#34; :GRAPHLIT_JWT_SECRET &#34;your-jwt-secret&#34;))))) #+end_src You can use =mcp-hub-start-all-server= to start all MCP servers, such as launching all MCP servers after starting Emacs. #+begin_src elisp (add-hook &#39;after-init-hook #&#39;mcp-hub-start-all-server) #+end_src *** Managing MCP Servers Use =mcp-hub= to launch the server management interface, which will automatically start all configured MCP servers.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+html: &lt;img src=&#34;https://github.com/user-attachments/assets/31877c0b-d71a-491d-9830-2afed8d6218a&#34; alt=&#34;mcp-hub&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** Keymap | key | function | description | |-----+----------------------------+-----------------------------------------| | l | mcp-hub-view-log | View server logs | | s | mcp-hub-start-server | Start server under cursor | | k | mcp-hub-close-server | Stop server under cursor | | r | mcp-hub-restart-server | Restart server under cursor | | S | mcp-hub-start-all-server | Start all configured servers | | R | mcp-hub-restart-all-server | Restart all configured servers | | K | mcp-hub-close-all-server | Stop all running servers | *** use with [[https://github.com/karthink/gptel][gptel]] For =gptel= integration, See the [[https://github.com/karthink/gptel?tab=readme-ov-file#model-context-protocol-mcp-integration][gptel mcp]] for details. ** Example [[https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem][filesystem]] server. *** Establish the connection first. #+begin_src elisp (mcp-connect-server &#34;filesystem&#34; :command &#34;npx&#34; :args &#39;(&#34;-y&#34; &#34;@modelcontextprotocol/server-filesystem&#34; &#34;~/Downloads/&#34;) :initial-callback #&#39;(lambda (connection) (message &#34;%s connection&#34; (jsonrpc-name connection))) :tools-callback #&#39;(lambda (connection tools) (message &#34;%s tools: %s&#34; (jsonrpc-name connection) tools)) :prompts-callback #&#39;(lambda (connection prompts) (message &#34;%s prompts: %s&#34; (jsonrpc-name connection) prompts)) :resources-callback #&#39;(lambda (connection resources) (message &#34;%s resources: %s&#34; (jsonrpc-name connection) resources))) #+end_src *** Define the use of tools. The current text is being tested using the [[https://github.com/karthink/gptel/issues/514][gptel tool]] branch.Use =mcp-make-text-tool= to create standard tool call data ([[https://github.com/ahyatt/llm/discussions/124][Discussions]]).It is recommended to create tools within the tools-callback or wait for the mcp connect server to complete. #+begin_src elisp (mcp-make-text-tool &#34;filesystem&#34; &#34;write_file&#34;) #+end_src This will generate a data structure where the function is an auto-generated synchronous or asynchronous lambda function for accessing the MCP server. #+begin_src elisp (list :function #&#39;(lambda (&amp;amp;rest args) ;; Synchronous or asynchronous access to the MCP server&#39;s Lambda function. ) :name &#34;write_file&#34; :async nil :description &#34;Create a new file or completely overwrite an existing file with new content. Use with caution as it will overwrite existing files without warning. Handles text content with proper encoding. Only works within allowed directories.&#34; :args ((:type &#34;string&#34; :name &#34;path&#34; :description &#34;path&#34;) (:type &#34;string&#34; :name &#34;content&#34; :description &#34;content&#34;)) :category &#34;files&#34;) #+end_src *** Disconnect from the server. #+begin_src elisp (mcp-stop-server &#34;filesystem&#34;) #+end_src *** Manual function call **** Synchronize #+begin_src elisp (let ((connection (gethash &#34;filesystem&#34; mcp-server-connections))) (mcp-call-tool connection &#34;write_file&#34; &#39;(:path &#34;filename or file path&#34; :content &#34;the file content&#34;))) #+end_src **** Asynchronous #+begin_src elisp (let ((connection (gethash &#34;filesystem&#34; mcp-server-connections))) (mcp-async-call-tool connection &#34;write_file&#34; &#39;(:path &#34;filename or file path&#34; :content &#34;the file content&#34;) #&#39;(lambda (res) ;; handle res (mcp--parse-tool-call-result res)) #&#39;(lambda (code message) ;; handle error (format &#34;call %s tool error with %s: %s&#34; tool-name code message)))) #+end_src *** Manual get prompt Since the [[https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem][filesystem]] lacks prompts, the [[https://github.com/modelcontextprotocol/servers/tree/main/src/everything][everything]] server is used for demonstration. **** Synchronize #+begin_src elisp (let ((connection (gethash &#34;everything&#34; mcp-server-connections))) (mcp-get-prompt connection &#34;complex_prompt&#34; &#39;(:temperature &#34;1.0&#34;))) #+end_src **** Asynchronous #+begin_src elisp (let ((connection (gethash &#34;everything&#34; mcp-server-connections))) (mcp-async-get-prompt connection &#34;complex_prompt&#34; &#39;(:temperature &#34;1.0&#34;) #&#39;(lambda (res) (message &#34;prompt: %s&#34; res)) #&#39;(lambda (code message) (message &#34;error call: %s, %s&#34; code message)))) #+end_src *** Manual get resources Since the [[https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem][filesystem]] lacks resources, the [[https://github.com/modelcontextprotocol/servers/tree/main/src/everything][everything]] server is used for demonstration. **** Synchronize #+begin_src elisp (let ((connection (gethash &#34;everything&#34; mcp-server-connections))) (mcp-read-resource connection &#34;test://static/resource/1&#34;)) #+end_src **** Asynchronous #+begin_src elisp (let ((connection (gethash &#34;everything&#34; mcp-server-connections))) (mcp-async-read-resource connection &#34;test://static/resource/1&#34; #&#39;(lambda (resource) (message &#34;res: %s&#34; resource)))) #+end_src *** Get resource templates Since the [[https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem][filesystem]] lacks resources, the [[https://github.com/modelcontextprotocol/servers/tree/main/src/everything][everything]] server is used for demonstration. #+begin_src elisp (let ((connection (gethash &#34;everything&#34; mcp-server-connections))) (mcp-async-list-resource-templates connection #&#39;(lambda (connection templates) (message &#34;%s&#34; templates)))) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Roadmap&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; HTTP SSE based MCP server connections&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; mcp marketplace (browser and auto install mcp server)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Simplified integration with other Emacs AI clients&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Expanded documentation&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Full MCP protocol client implementation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;License This project is licensed under the GNU General Public License v3.0 - see the [[file:LICENSE][LICENSE]] file for details.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>emacs-evil/evil-collection</title>
    <updated>2025-06-01T01:47:24Z</updated>
    <id>tag:github.com,2025-06-01:/emacs-evil/evil-collection</id>
    <link href="https://github.com/emacs-evil/evil-collection" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A set of keybindings for evil-mode&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Evil Collection #+STARTUP: noindent&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/emacs-evil/evil-collection/actions][file:https://github.com/emacs-evil/evil-collection/workflows/CI/badge.svg?branch=master]] [[https://melpa.org/#/evil-collection][file:https://melpa.org/packages/evil-collection-badge.svg]] [[https://stable.melpa.org/#/evil-collection][file:https://stable.melpa.org/packages/evil-collection-badge.svg]]&lt;/p&gt; &#xA;&lt;p&gt;This is a collection of [[https://github.com/emacs-evil/evil][Evil]] bindings for /the parts of Emacs/ that Evil does not cover properly by default, such as &lt;del&gt;help-mode&lt;/del&gt;, &lt;del&gt;M-x calendar&lt;/del&gt;, Eshell and more.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Warning:&lt;/em&gt; Expect some default bindings to change in the future.&lt;/p&gt; &#xA;&lt;p&gt;** Preliminaries&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-overriding-maps&lt;/del&gt; is assumed as &lt;del&gt;nil&lt;/del&gt; to reduce redundant &lt;del&gt;w/W/l/f/t&lt;/del&gt; etc evil bindings. See [[https://github.com/emacs-evil/evil-collection/pull/501][Fixup Info-mode]] for example.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;** Goals&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Reduce context switching: As soon as &#34;moving around&#34; gets hardwired to &lt;del&gt;&#xA;    &lt;hjkl&gt;&lt;/hjkl&gt;&lt;/del&gt;, it becomes frustratingly inefficient not to have it everywhere.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Community work: setting up bindings is tremendous work and joining force can only save hours for all of Evil users out there. While not everyone may agree on the chosen bindings, it helps to have something to start with rather than nothing at all. In the end, users are free to override a subset of the proposed bindings to best fit their needs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Consistency: Having all bindings defined in one place allows for enforcing consistency across special modes and coordinating the community work to define a reference implementation.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;** Installation&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Get the package, either from MELPA:&lt;/p&gt; &lt;p&gt;: M-x package-install RET evil-collection RET&lt;/p&gt; &lt;p&gt;Or clone / download this repository and modify your &lt;del&gt;load-path&lt;/del&gt;:&lt;/p&gt; &lt;p&gt;: (add-to-list &#39;load-path (expand-file-name &#34;/path/to/evil-collection/&#34; user-emacs-directory))&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Register the bindings, either all at once with&lt;/p&gt; &lt;p&gt;: (evil-collection-init)&lt;/p&gt; &lt;p&gt;or mode-by-mode, for instance:&lt;/p&gt; &lt;p&gt;: (with-eval-after-load &#39;calendar (evil-collection-calendar-setup))&lt;/p&gt; &lt;p&gt;or by providing an argument to &lt;del&gt;evil-collection-init&lt;/del&gt;:&lt;/p&gt; &lt;p&gt;: (evil-collection-init &#39;calendar)&lt;/p&gt; &lt;p&gt;a list can also be provided to &lt;del&gt;evil-collection-init&lt;/del&gt;:&lt;/p&gt; &lt;p&gt;: (evil-collection-init &#39;(calendar dired calc ediff))&lt;/p&gt; &lt;p&gt;The list of supported modes is configured by &lt;del&gt;evil-collection-mode-list&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;del&gt;evil-collection&lt;/del&gt; assumes &lt;del&gt;evil-want-keybinding&lt;/del&gt; is set to &lt;del&gt;nil&lt;/del&gt; and &lt;del&gt;evil-want-integration&lt;/del&gt; is set to &lt;del&gt;t&lt;/del&gt; before loading &lt;del&gt;evil&lt;/del&gt; and &lt;del&gt;evil-collection&lt;/del&gt;. Note some other packages may load evil (e.g. evil-leader) so bear that in mind when determining when to set the variables.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/emacs-evil/evil-collection/issues/60&#34;&gt;https://github.com/emacs-evil/evil-collection/issues/60&lt;/a&gt; and &lt;a href=&#34;https://github.com/emacs-evil/evil/pull/1087&#34;&gt;https://github.com/emacs-evil/evil/pull/1087&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes (setq evil-want-integration t) ;; This is optional since it&#39;s already set to t by default. (setq evil-want-keybinding nil) (require &#39;evil) (when (require &#39;evil-collection nil t) (evil-collection-init)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s another full TLDR &lt;del&gt;use-package&lt;/del&gt; example.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes (use-package evil :ensure t :init (setq evil-want-integration t) ;; This is optional since it&#39;s already set to t by default. (setq evil-want-keybinding nil) :config (evil-mode 1))&lt;/p&gt; &#xA;&lt;p&gt;(use-package evil-collection :after evil :ensure t :config (evil-collection-init)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;NOTE: If you don&#39;t like surprises but still want to use &lt;del&gt;evil-collection-init&lt;/del&gt;, setting &lt;del&gt;evil-collection-mode-list&lt;/del&gt; to nil and adding each mode manually might be a better option.&lt;/p&gt; &#xA;&lt;p&gt;** Configuration Modify &lt;del&gt;evil-collection-mode-list&lt;/del&gt; to disable or add any modes that should be evilified by &lt;del&gt;evil-collection&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;| Variable | Default | Description | |--------------------------------------------+---------+-------------------------------------------------------------------| | evil-collection-calendar-want-org-bindings | nil | Set up Org functions in calendar keymap. | | evil-collection-outline-bind-tab-p | nil | Enable &#xA; &lt;tab&gt;&#xA;  -based bindings in Outline mode. | | evil-collection-term-sync-state-and-mode-p | t | Synchronize insert/normal state with char/line-mode in term-mode. | | evil-collection-setup-minibuffer | nil | Set up Vim style bindings in the minibuffer. | | evil-collection-setup-debugger-keys | t | Set up debugger keys for certain modes. | | evil-collection-want-unimpaired-p | t | Set up unimpaired bindings globally. | | evil-collection-want-find-usages-bindings | t | Bind -find references-, etc to various modes. | | evil-collection-config | * | List of mode specific configurations. | | evil-collection-key-whitelist | nil | List of keys Evil Collection is allowed to bind to. | | evil-collection-key-blacklist | nil | List of keys Evil Collection is not allowed to bind to. | | evil-collection-state-passlist | nil | List of Evil States Evil Collection is allowed to bind to. | | evil-collection-state-denylist | nil | List of Evil States Evil Collection is not allowed to bind to. |&#xA; &lt;/tab&gt;&lt;/p&gt; &#xA;&lt;p&gt;For example, if you want to enable Evil in the minibuffer, you&#39;ll have to turn it on explicitly by customizing &lt;del&gt;evil-collection-setup-minibuffer&lt;/del&gt; to &lt;del&gt;t&lt;/del&gt;. Some minibuffer-related packages such as Helm rely on this option.&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;use-package&lt;/del&gt; example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes (use-package evil-collection :custom (evil-collection-setup-minibuffer t) :init (evil-collection-init)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;evil-collection-config&lt;/del&gt; can also be modified to configure specific modes. At the moment, it can be used to defer binding keys to those specific modes in order to improve startup time.&lt;/p&gt; &#xA;&lt;p&gt;** Guidelines&lt;/p&gt; &#xA;&lt;p&gt;The following rules serve as guiding principles to define the set of standard Evil bindings for various modes. Since special modes are by definition structurally incomparable, those rules cannot be expected to be applied universally.&lt;/p&gt; &#xA;&lt;p&gt;The rules are more-or-less sorted by priority.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Don&#39;t bind anything to &lt;del&gt;:&lt;/del&gt; nor &lt;del&gt;&#xA;    &lt;escape&gt;&lt;/escape&gt;&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Keep the movement keys when possible and sensible.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;h&lt;/del&gt;, &lt;del&gt;j&lt;/del&gt;, &lt;del&gt;k&lt;/del&gt;, &lt;del&gt;l&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;w&lt;/del&gt;, &lt;del&gt;W&lt;/del&gt;, &lt;del&gt;b&lt;/del&gt;, &lt;del&gt;B&lt;/del&gt;, &lt;del&gt;e&lt;/del&gt;, &lt;del&gt;E&lt;/del&gt;, &lt;del&gt;ge&lt;/del&gt;, &lt;del&gt;gE&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;f&lt;/del&gt;, &lt;del&gt;F&lt;/del&gt;, &lt;del&gt;t&lt;/del&gt;, &lt;del&gt;T&lt;/del&gt;, &lt;del&gt;;&lt;/del&gt;, =,=&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;gg&lt;/del&gt;, &lt;del&gt;G&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;|&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;(&lt;/del&gt;, &lt;del&gt;)&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;{&lt;/del&gt;, &lt;del&gt;}&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;%&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;+&lt;/del&gt;, &lt;del&gt;-&lt;/del&gt;, &lt;del&gt;0&lt;/del&gt;, &lt;del&gt;^&lt;/del&gt;, &lt;del&gt;$&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;C-i&lt;/del&gt;, &lt;del&gt;C-o&lt;/del&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Keep the yanking and register keys when possible and sensible.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;y&lt;/del&gt;, &lt;del&gt;Y&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;=&#34;=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Keep the search keys when possible and sensible.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;/&lt;/del&gt;, &lt;del&gt;?&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;#&lt;/del&gt;, &lt;del&gt;*&lt;/del&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Keep the mark keys when possible and sensible.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;m&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;=&#39;=, =~=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Keep the windowing keys when possible and sensible.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;H&lt;/del&gt;, &lt;del&gt;L&lt;/del&gt;, &lt;del&gt;M&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;C-e&lt;/del&gt;, &lt;del&gt;C-y&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;C-f&lt;/del&gt;, &lt;del&gt;C-b&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;C-d&lt;/del&gt;, &lt;del&gt;C-u&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;C-w&lt;/del&gt;-prefixed bindings.&lt;/li&gt; &#xA;   &lt;li&gt;Some &lt;del&gt;z&lt;/del&gt;-prefixed bindings (see below).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The following keys are free when insert state does not make sense in the current mode:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;a&lt;/del&gt;, &lt;del&gt;A&lt;/del&gt;, &lt;del&gt;i&lt;/del&gt;, &lt;del&gt;I&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;c&lt;/del&gt;, &lt;del&gt;C&lt;/del&gt;, &lt;del&gt;r&lt;/del&gt;, &lt;del&gt;R&lt;/del&gt;, &lt;del&gt;s&lt;/del&gt;, &lt;del&gt;S&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;d&lt;/del&gt;, &lt;del&gt;D&lt;/del&gt;, &lt;del&gt;x&lt;/del&gt;, &lt;del&gt;X&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;o&lt;/del&gt;, &lt;del&gt;O&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;p&lt;/del&gt;, &lt;del&gt;P&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;=&lt;/del&gt;, &lt;del&gt;&amp;lt;&lt;/del&gt;, &lt;del&gt;&amp;gt;&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;J&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;=~=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Any of those keys can be set to be a prefix key.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Prefix keys: &lt;del&gt;g&lt;/del&gt; and &lt;del&gt;z&lt;/del&gt; are the ubiquitous prefix keys.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;g&lt;/del&gt; generally stands for &#34;go&#34; and is best used for movements.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;z&lt;/del&gt; is used for scrolling, folding, spell-checking and more.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Macro and action keys&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;@&lt;/del&gt;, &lt;del&gt;q&lt;/del&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;.&lt;/del&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ensure terminal compatibility without sacrificing GUI key bindings.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Tab key &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Tab key is recognized as &lt;del&gt;&#xA;       &lt;tab&gt;&lt;/tab&gt;&lt;/del&gt; in GUI and &lt;del&gt;TAB&lt;/del&gt; in terminal. &lt;del&gt;TAB&lt;/del&gt; equals &lt;del&gt;C-i&lt;/del&gt;.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;del&gt;C-i&lt;/del&gt; is bound to jumping forward for vim compatibility. If Shift+Tab is not relevant, just bind &lt;del&gt;g TAB&lt;/del&gt; to the function that Tab is bound to. If Shift+Tab is relevant, bind &lt;del&gt;g]&lt;/del&gt; and &lt;del&gt;g TAB&lt;/del&gt; to the function that Tab is bound to, and bind &lt;del&gt;g[&lt;/del&gt; to the function that Shift+Tab is bound to for terminal compatibility.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Enter key &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Enter key is recognized as &lt;del&gt;&#xA;       &lt;return&gt;&lt;/return&gt;&lt;/del&gt; in GUI and &lt;del&gt;RET&lt;/del&gt; in terminal. &lt;del&gt;RET&lt;/del&gt; equals &lt;del&gt;Ctrl+m&lt;/del&gt;.&lt;/li&gt; &#xA;     &lt;li&gt;Bind only &lt;del&gt;RET&lt;/del&gt; and &lt;del&gt;M-RET&lt;/del&gt;. Or, bind &lt;del&gt;RET&lt;/del&gt; and &lt;del&gt;M-RET&lt;/del&gt; to the same functions &lt;del&gt;&#xA;       &lt;return&gt;&lt;/return&gt;&lt;/del&gt; and &lt;del&gt;&#xA;       &lt;m-return&gt;&lt;/m-return&gt;&lt;/del&gt; are bound to.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;del&gt;S-RET&lt;/del&gt; is impossible on terminal. Bind &lt;del&gt;&#xA;       &lt;s-return&gt;&lt;/s-return&gt;&lt;/del&gt; and a vacant key to the same function for terminal compatibility.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;** Rationale&lt;/p&gt; &#xA;&lt;p&gt;Many special modes share the same set of similar actions. Those actions should share the same bindings across all modes whenever feasible.&lt;/p&gt; &#xA;&lt;p&gt;*** Motion (&lt;del&gt;[&lt;/del&gt;, &lt;del&gt;]&lt;/del&gt;, &lt;del&gt;{&lt;/del&gt;, &lt;del&gt;}&lt;/del&gt;, &lt;del&gt;(&lt;/del&gt;, &lt;del&gt;)&lt;/del&gt;, &lt;del&gt;gj&lt;/del&gt;, &lt;del&gt;gk&lt;/del&gt;, &lt;del&gt;C-j&lt;/del&gt;, &lt;del&gt;C-k&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;[&lt;/del&gt; and &lt;del&gt;]&lt;/del&gt;: Use &lt;del&gt;[-&lt;/del&gt; and &lt;del&gt;]-&lt;/del&gt; prefixed keys for navigation between sections.&lt;/p&gt; &lt;p&gt;If the mode makes no difference between the end of a section and the beginning of the next, use &lt;del&gt;[&lt;/del&gt; and &lt;del&gt;]&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;gj&lt;/del&gt; and &lt;del&gt;gk&lt;/del&gt;: synonym for &lt;del&gt;[&lt;/del&gt; and &lt;del&gt;]&lt;/del&gt;. That&#39;s what [[evilmagit][evil-magit]] does.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Question:&lt;/em&gt; Should &lt;del&gt;gj&lt;/del&gt; / &lt;del&gt;gk&lt;/del&gt; rather be synonyms for &lt;del&gt;C-j&lt;/del&gt; / &lt;del&gt;C-k&lt;/del&gt;? They cannot emulate the behaviour of &lt;del&gt;[]&lt;/del&gt; or &lt;del&gt;][&lt;/del&gt;.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;del&gt;C-j&lt;/del&gt;, &lt;del&gt;C-k&lt;/del&gt;: If there is granularity, i.e. subsections, use &lt;del&gt;C-j&lt;/del&gt; and &lt;del&gt;C-k&lt;/del&gt; to browse them. This reflects [[evilmagit][evil-magit]] and [[evilmu4e][evil-mu4e]] default bindings.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;del&gt;{&lt;/del&gt;, &lt;del&gt;}&lt;/del&gt;: If there is no paragraph structure, &lt;del&gt;{&lt;/del&gt; and &lt;del&gt;}&lt;/del&gt; can be used for sub-sectioning.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;del&gt;(&lt;/del&gt;, &lt;del&gt;)&lt;/del&gt;: If there is no sentence structure, &lt;del&gt;(&lt;/del&gt; and &lt;del&gt;)&lt;/del&gt; can be used for sub-sectioning.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;del&gt;HJKL&lt;/del&gt;: &lt;del&gt;hjkl&lt;/del&gt; can be used for atomic movements, but &lt;del&gt;HJKL&lt;/del&gt; can usually not be used because &lt;del&gt;H&lt;/del&gt;, &lt;del&gt;K&lt;/del&gt; and &lt;del&gt;L&lt;/del&gt; are all universal (&lt;del&gt;J&lt;/del&gt; is &lt;del&gt;evil-join&lt;/del&gt; and usually does not make sense in special modes).&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;del&gt;C-h&lt;/del&gt; should not be remapped: Since we have &lt;del&gt;C-j&lt;/del&gt; and &lt;del&gt;C-k&lt;/del&gt; for vertical motion, it would make sense to use &lt;del&gt;C-h&lt;/del&gt; and &lt;del&gt;C-l&lt;/del&gt; for horizontal motion. There are some shortcomings though:&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt; &lt;p&gt;In Vim, &lt;del&gt;C-h&lt;/del&gt; works as backspace, but Evil does not follow that behaviour.&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;In Emacs, it is a prefix key for all help-related commands, and so is &lt;del&gt;&#xA;        &lt;f1&gt;&lt;/f1&gt;&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;Most importantly, &lt;del&gt;C-h&lt;/del&gt; is too widespread and ubiquitous to be replaced. So we don&#39;t.&lt;/p&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;del&gt;C-l&lt;/del&gt;: As a consequence of the former point, &lt;del&gt;C-l&lt;/del&gt; is available.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;del&gt;M-&#xA;      &lt;hjkl&gt;&lt;/hjkl&gt;&lt;/del&gt;: Those keys are usually free in Evil but still bound to their Emacs default (e.g. &lt;del&gt;M-l&lt;/del&gt; is &lt;del&gt;downcase-word&lt;/del&gt;). Besides, if &lt;del&gt;C-j&lt;/del&gt; and &lt;del&gt;C-k&lt;/del&gt; are already used, having &lt;del&gt;M-j&lt;/del&gt; and &lt;del&gt;M-k&lt;/del&gt; might add up to the confusion.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Quitting (&lt;del&gt;q&lt;/del&gt;, &lt;del&gt;ZQ&lt;/del&gt;, &lt;del&gt;ZZ&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;p&gt;In Vim, &lt;del&gt;q&lt;/del&gt; is for recording macros. Vim quits with &lt;del&gt;ZZ&lt;/del&gt; or &lt;del&gt;ZQ&lt;/del&gt;. In most Emacs special modes, it stands for quitting while macros are recorded/played with &lt;del&gt;&#xA;  &lt;f3&gt;&lt;/f3&gt;&lt;/del&gt; and &lt;del&gt;&#xA;  &lt;f4&gt;&lt;/f4&gt;&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A good rule of thumb would be:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Always bind &lt;del&gt;q&lt;/del&gt;, &lt;del&gt;ZZ&lt;/del&gt; and &lt;del&gt;ZQ&lt;/del&gt; to the mode specific quitting functions. If there is none,&lt;/li&gt; &#xA; &lt;li&gt;Bind &lt;del&gt;q&lt;/del&gt; and &lt;del&gt;ZZ&lt;/del&gt; to &lt;del&gt;quit-window&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;Bind &lt;del&gt;ZQ&lt;/del&gt; to &lt;del&gt;evil-quit&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;If macros don&#39;t make sense in current mode, then &lt;del&gt;@&lt;/del&gt; is available.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Refreshing / Reverting (&lt;del&gt;gr&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;gr&lt;/del&gt; is used for refreshing in [[evilmagit][evil-magit]], [[evilmu4e][evil-mu4e]], and some Spacemacs configurations (org-agenda and neotree among others).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;C-l&lt;/del&gt; is traditionally used to refresh the terminal screen. Since there does not seem to be any existing use of it, we leave the binding free for other uses.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Marking&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;m&lt;/del&gt; defaults to &lt;del&gt;evil-set-marker&lt;/del&gt; which might not be very useful in special modes. =&#39;= can still be used as it can jump to other buffers.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;m&lt;/del&gt;: Mark or toggle mark, depending on what the mode offers. In visual mode, always mark. With a numeric argument, toggle mark on that many following lines.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;u&lt;/del&gt;: Unmark current selection.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;U&lt;/del&gt;: Unmark all.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=&lt;del&gt;=: Toggle all marks. This mirrors the &#34;invert-char&#34; Vim command bound to =&lt;/del&gt;= by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;M&lt;/del&gt;: Mark all, if available. Otherwise use =U~=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;*&lt;/del&gt;: Mark-prefix or mark all if current mode has no prefix. &lt;del&gt;*&lt;/del&gt; is traditionally a wildcard.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;%&lt;/del&gt;: Mark regexp.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;x&lt;/del&gt;: Execute action on marks. This mirrors Dired&#39;s binding of &lt;del&gt;x&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If &lt;del&gt;*&lt;/del&gt; is used for marking, then &lt;del&gt;#&lt;/del&gt; is free.&lt;/p&gt; &#xA;&lt;p&gt;Also note that Emacs inconsistently uses &lt;del&gt;u&lt;/del&gt; and &lt;del&gt;U&lt;/del&gt; to unmark.&lt;/p&gt; &#xA;&lt;p&gt;*** Selecting / Filtering / Narrowing / Searching&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;s&lt;/del&gt; and &lt;del&gt;S&lt;/del&gt; seem to be used in some places like [[mu4e][mu4e]].&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;s&lt;/del&gt;: [s]elect/[s]earch/filter candidates according to a pattern.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;S&lt;/del&gt;: Remove filter and select all.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;=&lt;/del&gt; is usually free and its significance is obvious. It&#39;s taken for zooming though.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;|&lt;/del&gt; is not free but the pipe symbolic is very tantalizing.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Sorting&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;o&lt;/del&gt;: Change the sort [o]rder.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;O&lt;/del&gt;: Sort in reverse order.&lt;/p&gt; &lt;p&gt;There is no real consensus around which key to bind to sorting. What others do by default:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;del&gt;package-menu&lt;/del&gt; uses &lt;del&gt;S&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;del&gt;M-x proced&lt;/del&gt; and Dired use &lt;del&gt;s&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;del&gt;profiler&lt;/del&gt; uses &lt;del&gt;A&lt;/del&gt; and &lt;del&gt;D&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;[[mu4e][mu4e]] uses &lt;del&gt;O&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;[[http://www.nongnu.org/ranger/][ranger]] uses &lt;del&gt;o&lt;/del&gt;, inspired from [[http://mutt.org][Mutt]].&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Go to definition (&lt;del&gt;gd&lt;/del&gt;, &lt;del&gt;gD&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;gd&lt;/del&gt;: [g]o to [d]efinition. This is mostly for programming modes. If there&#39;s a corresponding &#39;pop&#39; action, use &lt;del&gt;C-t&lt;/del&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Go to references, etc (&lt;del&gt;gr&lt;/del&gt;, &lt;del&gt;gA&lt;/del&gt;) When &lt;del&gt;evil-collection-want-find-usages-bindings&lt;/del&gt; is set to t:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;gr&lt;/del&gt;: [g] to [r]eferences. This binding is also used for refresh/reverting modes in non programming modes but is usually empty for programming modes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;gA&lt;/del&gt;: [g]o to [A]ssignments.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Additional bindings: There may be additional binds under this category. Please file a Pull Request if so.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Go to current entity&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;.&lt;/del&gt;: go to current entity (day for calendar, playing track for [[EMMS][EMMS]]). Bind only if more relevant than &lt;del&gt;evil-repeat&lt;/del&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Open thing at point (&lt;del&gt;RET&lt;/del&gt;, &lt;del&gt;S-RET&lt;/del&gt;, &lt;del&gt;M-RET&lt;/del&gt;, &lt;del&gt;go&lt;/del&gt;, &lt;del&gt;gO&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;RET&lt;/del&gt;, &lt;del&gt;S-RET&lt;/del&gt;, &lt;del&gt;M-RET&lt;/del&gt;: Open thing at point in current window, open in other window and display in other window respectively. The latter is like the former with the focus remaining on the current window.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;go&lt;/del&gt;, &lt;del&gt;gO&lt;/del&gt;: When available, same as &lt;del&gt;S-RET&lt;/del&gt; and &lt;del&gt;M-RET&lt;/del&gt; respectively. This is useful in terminals where &lt;del&gt;S-RET&lt;/del&gt; and &lt;del&gt;M-RET&lt;/del&gt; might not work.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Emacs-style jumping (&lt;del&gt;J&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;J&lt;/del&gt;: [[mu4e][mu4e]] has &lt;del&gt;j&lt;/del&gt; and [[evil-mu4e][evil-mu4e]] uses &lt;del&gt;J&lt;/del&gt;, so we use &lt;del&gt;J&lt;/del&gt; too.&lt;/p&gt; &lt;p&gt;Some special modes like [[mu4e][mu4e]] and ibuffer offer to &#34;jump&#34; to a different buffer. This sometimes depends on the thing at point.&lt;/p&gt; &lt;p&gt;This is not related to Evil jumps like &lt;del&gt;C-i&lt;/del&gt; and &lt;del&gt;C-o&lt;/del&gt;, nor to &#34;go to definition&#34;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Browse URL (&lt;del&gt;gx&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;gx&lt;/del&gt;: go to URL. This is a default Vim binding.&lt;/p&gt; &#xA;&lt;p&gt;*** Help (&lt;del&gt;?&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;g?&lt;/del&gt; : is the standard key for help related commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;?&lt;/del&gt; in places where backward search is not very useful.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** History browsing (&lt;del&gt;C-n&lt;/del&gt;, &lt;del&gt;C-p&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;C-n&lt;/del&gt; and &lt;del&gt;C-p&lt;/del&gt; are standard bindings to browse the history elements.&lt;/p&gt; &#xA;&lt;p&gt;*** Bookmarking&lt;/p&gt; &#xA;&lt;p&gt;?&lt;/p&gt; &#xA;&lt;p&gt;*** REPL (&lt;del&gt;gz&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;p&gt;If the mode has a Go To REPL-type command, set it to &lt;del&gt;gz&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;*** Zooming (&lt;del&gt;+&lt;/del&gt;, &lt;del&gt;-&lt;/del&gt;, &lt;del&gt;=&lt;/del&gt;, &lt;del&gt;0&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;+&lt;/del&gt; and &lt;del&gt;-&lt;/del&gt; have obvious meanings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;0&lt;/del&gt; has a somewhat intuitive meaning, plus it is next to &lt;del&gt;+&lt;/del&gt; and &lt;del&gt;-&lt;/del&gt; on QWERTY.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;=&lt;/del&gt; is useful as a synonym for &lt;del&gt;+&lt;/del&gt; because it is the unshifted key of &lt;del&gt;+&lt;/del&gt; on QWERTY.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Debugging&lt;/p&gt; &#xA;&lt;p&gt;When debugging is on, debugger keys takes the most precedence.&lt;/p&gt; &#xA;&lt;p&gt;These keys will be set when there&#39;s an available command for them.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;n&lt;/del&gt; : Step Over&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;i&lt;/del&gt; : Step Into&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;o&lt;/del&gt; : Step Out&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;c&lt;/del&gt; : Continue/Resume Execution&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;L&lt;/del&gt; : Locals&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;t&lt;/del&gt; : Tracing&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;q&lt;/del&gt; : Quit Debugging&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;H&lt;/del&gt; : Continue until Point&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;e&lt;/del&gt; : Evaluate Expression&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;b&lt;/del&gt; : Set Breakpoint&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;u&lt;/del&gt; : Unset Breakpoint&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;&amp;gt;&lt;/del&gt; : Navigate to Next Frame&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;&amp;lt;&lt;/del&gt; : Navigate to Previous Frame&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;g?&lt;/del&gt; : Help&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;J&lt;/del&gt; : Jump to debugger location&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;R&lt;/del&gt; : Restart&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For debugging outside of debugger being on (e.g. setting initial breakpoints), we use similar keys to [[https://github.com/realgud/realgud][realgud]].&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;f5&lt;/del&gt; Start/Continue/Resume Execution&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;S-f5&lt;/del&gt; Continue Execution&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;Mouse-1&lt;/del&gt; Toggle Breakpoint&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f9&lt;/del&gt; Toggle Breakpoint&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f10&lt;/del&gt; Step Over&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f11&lt;/del&gt; Step Into&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;S-f11&lt;/del&gt; Step Out&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Editable Buffers&lt;/p&gt; &#xA;&lt;p&gt;For buffers where insert-state doesn&#39;t make sense but buffer can be edited, (e.g. wdired or wgrep), pressing &lt;del&gt;i&lt;/del&gt; will change into editable state.&lt;/p&gt; &#xA;&lt;p&gt;When this editable state is turned on,&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;ZQ&lt;/del&gt; will abort and clear any changes. &lt;del&gt;ZZ&lt;/del&gt; will finish and save any changes. &lt;del&gt;ESC&lt;/del&gt; will exit editable state.&lt;/p&gt; &#xA;&lt;p&gt;*** :q/:wq/etc&lt;/p&gt; &#xA;&lt;p&gt;Modes with commands that can be bound to :q/:wq/etc will have those keys remapped.&lt;/p&gt; &#xA;&lt;p&gt;** Key Translation&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;evil-collection-translate-key&lt;/del&gt; allows binding a key to the definition of another key in the same keymap (comparable to how Vim&#39;s keybindings work). Its arguments are the &lt;del&gt;states&lt;/del&gt; and &lt;del&gt;keymaps&lt;/del&gt; to bind/look up the key(s) in followed optionally by keyword arguments (currently only &lt;del&gt;:destructive&lt;/del&gt;) and key/replacement pairs. &lt;del&gt;states&lt;/del&gt; should be nil for non-evil keymaps, and both &lt;del&gt;states&lt;/del&gt; and &lt;del&gt;keymaps&lt;/del&gt; can be a single symbol or a list of symbols.&lt;/p&gt; &#xA;&lt;p&gt;This function can be useful for making key swaps/cycles en masse. For example, someone who uses an alternate keyboard layout may want to retain the &lt;del&gt;hjkl&lt;/del&gt; positions for directional movement in dired, the calendar, etc.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example for Colemak of making swaps in a single keymap:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (evil-collection-translate-key nil &#39;evil-motion-state-map ;; colemak hnei is qwerty hjkl &#34;n&#34; &#34;j&#34; &#34;e&#34; &#34;k&#34; &#34;i&#34; &#34;l&#34; ;; add back nei &#34;j&#34; &#34;e&#34; &#34;k&#34; &#34;n&#34; &#34;l&#34; &#34;i&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of using &lt;del&gt;evil-collection-setup-hook&lt;/del&gt; to cycle the keys for all modes in &lt;del&gt;evil-collection-mode-list&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun my-hjkl-rotation (_mode mode-keymaps &amp;amp;rest _rest) (evil-collection-translate-key &#39;normal mode-keymaps &#34;n&#34; &#34;j&#34; &#34;e&#34; &#34;k&#34; &#34;i&#34; &#34;l&#34; &#34;j&#34; &#34;e&#34; &#34;k&#34; &#34;n&#34; &#34;l&#34; &#34;i&#34;))&lt;/p&gt; &#xA;&lt;p&gt;;; called after evil-collection makes its keybindings (add-hook &#39;evil-collection-setup-hook #&#39;my-hjkl-rotation)&lt;/p&gt; &#xA;&lt;p&gt;(evil-collection-init) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;A more common use case of &lt;del&gt;evil-collection-translate-key&lt;/del&gt; would be for keeping the functionality of some keys that users may bind globally. For example, &lt;del&gt;SPC&lt;/del&gt;, &lt;del&gt;[&lt;/del&gt;, and &lt;del&gt;]&lt;/del&gt; are bound in some modes. If you use these keys as global prefix keys that you never want to be overridden, you&#39;ll want to give them higher priority than other evil keybindings (e.g. those made by &lt;del&gt;(evil-define-key &#39;normal some-map ...)&lt;/del&gt;). To do this, you can create an &#34;intercept&#34; map and bind your prefix keys in it instead of in &lt;del&gt;evil-normal-state-map&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defvar my-intercept-mode-map (make-sparse-keymap) &#34;High precedence keymap.&#34;)&lt;/p&gt; &#xA;&lt;p&gt;(define-minor-mode my-intercept-mode &#34;Global minor mode for higher precedence evil keybindings.&#34; :global t)&lt;/p&gt; &#xA;&lt;p&gt;(my-intercept-mode)&lt;/p&gt; &#xA;&lt;p&gt;(dolist (state &#39;(normal visual insert)) (evil-make-intercept-map ;; NOTE: This requires an evil version from 2018-03-20 or later (evil-get-auxiliary-keymap my-intercept-mode-map state t t) state))&lt;/p&gt; &#xA;&lt;p&gt;(evil-define-key &#39;normal my-intercept-mode-map (kbd &#34;SPC f&#34;) &#39;find-file) ;; ... #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can then define replacement keys:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun my-prefix-translations (_mode mode-keymaps &amp;amp;rest _rest) (evil-collection-translate-key &#39;normal mode-keymaps &#34;C-SPC&#34; &#34;SPC&#34; ;; these need to be unbound first; this needs to be in same statement &#34;[&#34; nil &#34;]&#34; nil &#34;[[&#34; &#34;[&#34; &#34;]]&#34; &#34;]&#34;))&lt;/p&gt; &#xA;&lt;p&gt;(add-hook &#39;evil-collection-setup-hook #&#39;my-prefix-translations)&lt;/p&gt; &#xA;&lt;p&gt;(evil-collection-init) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;By default, the first invocation of &lt;del&gt;evil-collection-translate-key&lt;/del&gt; will make a backup of the keymap. Each subsequent invocation will look up keys in the backup instead of the original. This means that a call to &lt;del&gt;evil-collection-translate-key&lt;/del&gt; will always have the same behavior even if evaluated multiple times. When &lt;del&gt;:destructive t&lt;/del&gt; is specified, keys are looked up in the keymap as it is currently. This means that a call to &lt;del&gt;evil-collection-translate-key&lt;/del&gt; that swapped two keys would continue to swap/unswap them with each call. Therefore when &lt;del&gt;:destructive t&lt;/del&gt; is used, all cycles/swaps must be done within a single call to &lt;del&gt;evil-collection-translate-key&lt;/del&gt;. To make a comparison to Vim keybindings, &lt;del&gt;:destructive t&lt;/del&gt; is comparable to Vim&#39;s &lt;del&gt;map&lt;/del&gt;, and &lt;del&gt;:destructive nil&lt;/del&gt; is comparable to Vim&#39;s &lt;del&gt;noremap&lt;/del&gt; (where the &#34;original&#34; keybindings are those that existed in the keymap when &lt;del&gt;evil-collection-translate-key&lt;/del&gt; was first called). You&#39;ll almost always want to use the default behavior (especially in your init file). The limitation of &lt;del&gt;:destructive nil&lt;/del&gt; is that you can&#39;t translate a key to another key that was defined after the first &lt;del&gt;evil-collection-translate-key&lt;/del&gt;, so &lt;del&gt;:destructive t&lt;/del&gt; may be useful for interactive experimentation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;evil-collection-swap-key&lt;/del&gt; is also provided as a wrapper around &lt;del&gt;evil-collection-translate-key&lt;/del&gt; that allows swapping keys:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (evil-collection-swap-key nil &#39;evil-motion-state-map &#34;;&#34; &#34;:&#34;) ;; is equivalent to (evil-collection-translate-key nil &#39;evil-motion-state-map &#34;;&#34; &#34;:&#34; &#34;:&#34; &#34;;&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In some cases, keys are bound through &lt;code&gt;evil-define-minor-mode-key&lt;/code&gt; and may need to be translated using &lt;del&gt;evil-collection-translate-minor-mode-key&lt;/del&gt; and/or &lt;del&gt;evil-collection-swap-minor-mode-key&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (evil-collection-swap-minor-mode-key &#39;(normal motion) &#39;(evil-snipe-local-mode evil-snipe-override-local-mode) &#34;k&#34; &#34;s&#34; ;; Set this to t to make this swap the keys everytime ;; this expression is evaluated. :destructive nil)&lt;/p&gt; &#xA;&lt;p&gt;(evil-collection-translate-minor-mode-key &#39;(normal motion) &#39;(evil-snipe-local-mode evil-snipe-override-local-mode) &#34;k&#34; &#34;s&#34; &#34;s&#34; &#34;k&#34; ;; Set this to t to make this swap the keys everytime ;; this expression is evaluated. :destructive nil) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Third-party packages&lt;/p&gt; &#xA;&lt;p&gt;Third-party packages are provided by several parties:&lt;/p&gt; &#xA;&lt;p&gt;| Major mode | Evil bindings | |------------+--------------------------| | ledger | [[https://github.com/atheriel/evil-ledger][evil-ledger]] | | lispy | [[https://github.com/noctuid/lispyville][lispyville]] or [[https://github.com/sp3ctum/evil-lispy][evil-lispy]] | | org | [[https://github.com/GuiltyDolphin/org-evil][org-evil]] or [[https://github.com/Somelauw/evil-org-mode][evil-org]] | | markdown | [[https://github.com/Somelauw/evil-markdown][evil-markdown]] |&lt;/p&gt; &#xA;&lt;p&gt;Also &lt;del&gt;evil-collection&lt;/del&gt; has minimal support (&lt;del&gt;TAB&lt;/del&gt;, &lt;del&gt;S-TAB&lt;/del&gt; and sentence/paragraph forwarding) for &lt;del&gt;markdown&lt;/del&gt; and &lt;del&gt;org&lt;/del&gt; if you prefer less packages installed.&lt;/p&gt; &#xA;&lt;p&gt;Should you know any suitable package not mentioned in this list, let us know and file an issue.&lt;/p&gt; &#xA;&lt;p&gt;Other references:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/syl20bnr/spacemacs/blob/master/doc/CONVENTIONS.org#key-bindings-conventions][Spacemacs]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/doomemacs/doomemacs/tree/master/modules/editor/evil][Doom Emacs]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** FAQ&lt;/p&gt; &#xA;&lt;p&gt;*** Making SPC work similarly to [[https://github.com/syl20bnr/spacemacs][spacemacs]].&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;evil-collection&lt;/del&gt; binds over SPC in many packages. To use SPC as a leader key with the [[https://github.com/noctuid/general.el][general]] library:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes (use-package general :ensure t :init (setq general-override-states &#39;(insert emacs hybrid normal visual motion operator replace)) :config (general-define-key :states &#39;(normal visual motion) :keymaps &#39;override &#34;SPC&#34; &#39;hydra-space/body)) ;; Replace &#39;hydra-space/body with your leader function. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;See [[https://github.com/noctuid/evil-guide][noctuid&#39;s evil guide]] for other approaches.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Unintialized mode maps in &lt;del&gt;evil-collection-setup-hook&lt;/del&gt;. &lt;del&gt;evil-collection-setup-hook&lt;/del&gt; is ran with a list of keymaps passed into it. Some misconfigured modes may not have yet initialized their keymap at this time so the value of the variable may be nil. In that case, an alternative is to use a mode-hook to do any custom settings.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes (add-hook &#39;evil-collection-setup-hook (lambda (_mode keymaps) (add-hook &#39;ediff-mode-hook (lambda () (... keymaps ...))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;View [[https://github.com/emacs-evil/evil-collection/issues/196][196]] for more info. *** Don&#39;t allow Evil-Collection to bind some keys. Look into &lt;del&gt;evil-collection-key-whitelist&lt;/del&gt; and &lt;del&gt;evil-collection-key-blacklist&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes ;; Don&#39;t allow Evil Collection to bind to gfu and gfp. (setq evil-collection-key-blacklist &#39;(&#34;gfu&#34; &#34;gfp&#34;)) #+end_src *** Modes left behind&lt;/p&gt; &#xA;&lt;p&gt;Some modes might still remain unsupported by this package. Should you be missing your &lt;del&gt;&#xA;  &lt;hjkl&gt;&lt;/hjkl&gt;&lt;/del&gt;, please feel free to do a pull request.&lt;/p&gt; &#xA;&lt;p&gt;*** Writing a new binding&lt;/p&gt; &#xA;&lt;p&gt;This [[template][yasnippet template]] can be used to bootstrap a new binding.&lt;/p&gt; &#xA;&lt;p&gt;For example, if we were to want to add &lt;del&gt;evil-collection&lt;/del&gt; support to &lt;del&gt;eldoc&lt;/del&gt;. (e.g.) There is a package that contains:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes (provide &#39;eldoc) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Create a directory named eldoc under [[modes-directory][modes/]]. Create a file named evil-collection-eldoc.el under the newly created eldoc directory. Then use the above template as an example or, using [[yasnippet][yasnippet]], &lt;del&gt;yas-expand&lt;/del&gt; the above template which will result in something like below:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes ;;; evil-collection-eldoc.el --- Bindings for `eldoc&#39; -&lt;em&gt;- lexical-binding: t -&lt;/em&gt;-&lt;/p&gt; &#xA;&lt;p&gt;;; Copyright (C) 2022 James Nguyen&lt;/p&gt; &#xA;&lt;p&gt;;; Author: James Nguyen &lt;a href=&#34;mailto:james@jojojames.com&#34;&gt;james@jojojames.com&lt;/a&gt; ;; Maintainer: James Nguyen &lt;a href=&#34;mailto:james@jojojames.com&#34;&gt;james@jojojames.com&lt;/a&gt; ;; URL: &lt;a href=&#34;https://github.com/emacs-evil/evil-collection&#34;&gt;https://github.com/emacs-evil/evil-collection&lt;/a&gt; ;; Version: 0.0.2 ;; Package-Requires: ((emacs &#34;27.1&#34;)) ;; Keywords: evil, emacs, convenience, tools&lt;/p&gt; &#xA;&lt;p&gt;;; This program is free software; you can redistribute it and/or modify ;; it under the terms of the GNU General Public License as published by ;; the Free Software Foundation, either version 3 of the License, or ;; (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;;; This program is distributed in the hope that it will be useful, ;; but WITHOUT ANY WARRANTY; without even the implied warranty of ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ;; GNU General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;;; You should have received a copy of the GNU General Public License ;; along with this program. If not, see &lt;a href=&#34;http://www.gnu.org/licenses/&#34;&gt;http://www.gnu.org/licenses/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;;;; Commentary: ;;; Bindings for eldoc.&lt;/p&gt; &#xA;&lt;p&gt;;;; Code: (require &#39;evil-collection) (require &#39;eldoc nil t)&lt;/p&gt; &#xA;&lt;p&gt;(defvar eldoc-mode-map) (defconst evil-collection-eldoc-maps &#39;(eldoc-mode-map))&lt;/p&gt; &#xA;&lt;p&gt;(defun evil-collection-eldoc-setup () &#34;Set up `evil&#39; bindings for eldoc.&#34; (evil-collection-define-key &#39;normal &#39;eldoc-mode-map ))&lt;/p&gt; &#xA;&lt;p&gt;(provide &#39;evil-collection-eldoc) ;;; evil-collection-eldoc.el ends here #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Finally, add &lt;del&gt;eldoc&lt;/del&gt; to &lt;del&gt;evil-collection--supported-modes&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes (defvar evil-collection--supported-modes &lt;code&gt;( ;; ... eldoc ;; ... ) &#34;List of modes supported by evil-collection. Elements are either target mode symbols or lists which &lt;/code&gt;car&#39; is the mode symbol and `cdr&#39; the packages to register.&#34;) #+end_src ** Submitting Issues&lt;/p&gt; &#xA;&lt;p&gt;When reproducing issues, you can use this emacs -Q recipe.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes (setq user-emacs-directory &#34;~/.emacs.1.d&#34;) (setq package-user-dir (format &#34;%s/elpa/%s/&#34; user-emacs-directory emacs-major-version))&lt;/p&gt; &#xA;&lt;p&gt;(setq package-enable-at-startup nil package-archives &#39;((&#34;melpa&#34; . &#34;&lt;a href=&#34;https://melpa.org/packages/&#34;&gt;https://melpa.org/packages/&lt;/a&gt;&#34;) (&#34;gnu&#34; . &#34;&lt;a href=&#34;http://elpa.gnu.org/packages/&#34;&gt;http://elpa.gnu.org/packages/&lt;/a&gt;&#34;)))&lt;/p&gt; &#xA;&lt;p&gt;(require &#39;package) (package-initialize) (unless (package-installed-p &#39;use-package) (package-refresh-contents) (package-install &#39;use-package)) (require &#39;use-package) (setq use-package-always-ensure t)&lt;/p&gt; &#xA;&lt;p&gt;(use-package evil :ensure t :init (setq evil-want-keybinding nil) :config (evil-mode 1))&lt;/p&gt; &#xA;&lt;p&gt;(use-package evil-collection :after evil :ensure t :config (evil-collection-init)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Contributing We welcome any additional modes that are not already supported.&lt;/p&gt; &#xA;&lt;p&gt;All bindings in &lt;del&gt;evil-collection&lt;/del&gt; are open to change so if there&#39;s a better or more consistent binding, please [[https://github.com/emacs-evil/evil-collection/issues][open an issue]] or [[https://github.com/emacs-evil/evil-collection/pulls][submit a pull request]].&lt;/p&gt; &#xA;&lt;p&gt;Follow [[https://github.com/bbatsov/emacs-lisp-style-guide/][The Emacs Lisp Style Guide]] for coding conventions.&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/erlang/otp/wiki/writing-good-commit-messages][Erlang/OTP]] has a good read for helpful commit messages.&lt;/p&gt; &#xA;&lt;p&gt;#+LINK: EMMS &lt;a href=&#34;https://www.gnu.org/software/emms/&#34;&gt;https://www.gnu.org/software/emms/&lt;/a&gt; #+LINK: evilmagit &lt;a href=&#34;https://github.com/emacs-evil/evil-magit&#34;&gt;https://github.com/emacs-evil/evil-magit&lt;/a&gt; #+LINK: evilmu4e &lt;a href=&#34;https://github.com/JorisE/evil-mu4e&#34;&gt;https://github.com/JorisE/evil-mu4e&lt;/a&gt; #+LINK: mu4e &lt;a href=&#34;https://www.djcbsoftware.nl/code/mu/mu4e.html&#34;&gt;https://www.djcbsoftware.nl/code/mu/mu4e.html&lt;/a&gt; #+LINK: yasnippet &lt;a href=&#34;https://github.com/joaotavora/yasnippet&#34;&gt;https://github.com/joaotavora/yasnippet&lt;/a&gt; #+LINK: template &lt;a href=&#34;https://github.com/emacs-evil/evil-collection/raw/master/yasnippet_evil-collection&#34;&gt;https://github.com/emacs-evil/evil-collection/blob/master/yasnippet_evil-collection&lt;/a&gt; #+LINK: modes-directory &lt;a href=&#34;https://github.com/emacs-evil/evil-collection/tree/master/modes&#34;&gt;https://github.com/emacs-evil/evil-collection/tree/master/modes&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>radian-software/apheleia</title>
    <updated>2025-06-01T01:47:24Z</updated>
    <id>tag:github.com,2025-06-01:/radian-software/apheleia</id>
    <link href="https://github.com/radian-software/apheleia" rel="alternate"></link>
    <summary type="html">&lt;p&gt;🌷 Run code formatter on buffer contents without moving point, using RCS patches and dynamic programming.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Apheleia&lt;/h1&gt; &#xA;&lt;p&gt;Good code is automatically formatted by tools like &lt;a href=&#34;https://github.com/python/black&#34;&gt;Black&lt;/a&gt; or &lt;a href=&#34;https://prettier.io/&#34;&gt;Prettier&lt;/a&gt; so that you and your team spend less time on formatting and more time on building features. It&#39;s best if your editor can run code formatters each time you save a file, so that you don&#39;t have to look at badly formatted code or get surprised when things change just before you commit. However, running a code formatter on save suffers from the following two problems:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;It takes some time (e.g. around 200ms for Black on an empty file), which makes the editor feel less responsive.&lt;/li&gt; &#xA; &lt;li&gt;It invariably moves your cursor (point) somewhere unexpected if the changes made by the code formatter are too close to point&#39;s position.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Apheleia is an &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt; package which solves both of these problems comprehensively for all languages, allowing you to say goodbye to language-specific packages such as &lt;a href=&#34;https://github.com/proofit404/blacken&#34;&gt;Blacken&lt;/a&gt; and &lt;a href=&#34;https://github.com/prettier/prettier-emacs&#34;&gt;prettier-js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The approach is as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run code formatters on &lt;code&gt;after-save-hook&lt;/code&gt;, rather than &lt;code&gt;before-save-hook&lt;/code&gt;, and do so asynchronously. Once the formatter has finished running, check if the buffer has been modified since it started; only apply the changes if not.&lt;/li&gt; &#xA; &lt;li&gt;After running the code formatter, generate an &lt;a href=&#34;https://web.archive.org/web/20220527003730/https://tools.ietf.org/doc/tcllib/html/rcs.html#section4&#34;&gt;RCS patch&lt;/a&gt; showing the changes and then apply it to the buffer. This prevents changes elsewhere in the buffer from moving point. If a patch region happens to include point, then use a &lt;a href=&#34;https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm&#34;&gt;dynamic programming algorithm for string alignment&lt;/a&gt; to determine where point should be moved so that it remains in the same place relative to its surroundings. Finally, if the vertical position of point relative to the window has changed, adjust the scroll position to maintain maximum visual continuity. (This includes iterating through all windows displaying the buffer, if there are more than one.) The dynamic programming algorithm runs in quadratic time, which is why it is only applied if necessary and to a single patch region.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Apheleia is available on &lt;a href=&#34;https://melpa.org/&#34;&gt;MELPA&lt;/a&gt;. It is easiest to install it using &lt;a href=&#34;https://github.com/radian-software/straight.el&#34;&gt;&lt;code&gt;straight.el&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(straight-use-package &#39;apheleia)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, you may install using any other package manager if you prefer.&lt;/p&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;Emacs 27 or later is supported. Apheleia does not include any formatters. You must install any formatter separately that you wish to use. As long as it is on &lt;code&gt;$PATH&lt;/code&gt; then Apheleia will pick it up automatically; missing formatters will silently be skipped, but errors from invoking installed formatters will be reported on buffer save.&lt;/p&gt; &#xA;&lt;p&gt;It is recommended to have Bash installed, as this is used as a dependency for Apheleia to invoke certain formatters (e.g. Node.js-based formatters).&lt;/p&gt; &#xA;&lt;p&gt;Windows support is not guaranteed due to lack of support for common open standards on this platform. Pull requests adjusting Apheleia for improved cross-platform portability will be accepted, but no guarantees are made about stability on Windows.&lt;/p&gt; &#xA;&lt;h2&gt;User guide&lt;/h2&gt; &#xA;&lt;p&gt;To your init-file, add the following form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(apheleia-global-mode +1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The autoloading has been configured so that this will &lt;em&gt;not&lt;/em&gt; cause Apheleia to be loaded until you save a file.&lt;/p&gt; &#xA;&lt;p&gt;By default, Apheleia is configured to format with &lt;a href=&#34;https://github.com/python/black&#34;&gt;Black&lt;/a&gt;, &lt;a href=&#34;https://prettier.io/&#34;&gt;Prettier&lt;/a&gt;, and &lt;a href=&#34;https://golang.org/cmd/gofmt/&#34;&gt;Gofmt&lt;/a&gt; on save in all relevant major modes. To configure this, you can adjust the values of the following variables:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-formatters&lt;/code&gt;: Alist mapping names of formatters (symbols like &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;prettier&lt;/code&gt;) to commands used to run those formatters (such as &lt;code&gt;(&#34;black&#34; &#34;-&#34;)&lt;/code&gt; and &lt;code&gt;(npx &#34;prettier&#34; input)&lt;/code&gt;). See the docstring for more information. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can manipulate this alist using standard Emacs functions. For example, to add some command-line options to Black, you could use:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setf (alist-get &#39;black apheleia-formatters)&#xA;      &#39;(&#34;black&#34; &#34;--option&#34; &#34;...&#34; &#34;-&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;There are a list of symbols that are interpreted by apheleia specially when formatting a command (example: &lt;code&gt;npx&lt;/code&gt;). Any non-string entries in a formatter that doesn&#39;t equal one of these symbols is evaluated and replaced in place. This can be used to pass certain flags to the formatter process depending on the state of the current buffer. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(push &#39;(shfmt . (&#34;beautysh&#34;&#xA;                 &#34;-filename&#34; filepath&#xA;                 (when-let ((indent (bound-and-true-p sh-basic-offset)))&#xA;                   (list &#34;--indent-size&#34; (number-to-string indent)))&#xA;                 (when indent-tabs-mode &#34;--tab&#34;)&#xA;                 &#34;-&#34;))&#xA;      apheleia-formatters)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This adds an entry to &lt;code&gt;apheleia-formatters&lt;/code&gt; for the &lt;code&gt;beautysh&lt;/code&gt; formatter. The evaluated entries makes it so that the &lt;code&gt;--tab&lt;/code&gt; flag is only passed to &lt;code&gt;beautysh&lt;/code&gt; when the value of &lt;code&gt;indent-tabs-mode&lt;/code&gt; is true. Similarly the indent-size flag is passed the exact value of the &lt;code&gt;sh-basic-offset&lt;/code&gt; variable only when it is bound. Observe that one of these evaluations returns a list of flags whereas the other returns a single string. These are substituted into the command as you&#39;d expect.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can also use Apheleia to format buffers that have no underlying files. In this case the value of &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;filepath&lt;/code&gt; will be the name of the current buffer with any special characters for the file-system (such as &lt;code&gt;*&lt;/code&gt; on windows) being stripped out.&lt;/p&gt; &lt;p&gt;This is also how the extension for any temporary files apheleia might create will be determined. If you&#39;re using a formatter that determines the file-type from the extension you should name such buffers such that their suffixed with the extension. For example a buffer called &lt;code&gt;*foo-bar.c*&lt;/code&gt; that has no associated file will have an implicit file-name of &lt;code&gt;foo-bar.c&lt;/code&gt; and any temporary files will be suffixed with a &lt;code&gt;.c&lt;/code&gt; extension.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can implement formatters as arbitrary Elisp functions which operate directly on a buffer, without needing to invoke an external command. This can be useful to integrate with e.g. language servers. See the docstring for more information on the expected interface for Elisp formatters.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-mode-alist&lt;/code&gt;: Alist mapping major modes and filename regexps to names of formatters to use in those modes and files. See the docstring for more information. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can use this variable to configure multiple formatters for the same buffer by setting the &lt;code&gt;cdr&lt;/code&gt; of an entry to a list of formatters to run instead of a single formatter. For example you may want to run &lt;code&gt;isort&lt;/code&gt; and &lt;code&gt;black&lt;/code&gt; one after the other.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setf (alist-get &#39;isort apheleia-formatters)&#xA;      &#39;(&#34;isort&#34; &#34;--stdout&#34; &#34;-&#34;))&#xA;(setf (alist-get &#39;python-mode apheleia-mode-alist)&#xA;      &#39;(isort black))&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This will make apheleia run &lt;code&gt;isort&lt;/code&gt; on the current buffer and then &lt;code&gt;black&lt;/code&gt; on the result of &lt;code&gt;isort&lt;/code&gt; and then use the final output to format the current buffer.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: At the moment there&#39;s no smart or configurable error handling in place. This means if one of the configured formatters fail (for example if &lt;code&gt;isort&lt;/code&gt; isn&#39;t installed) then apheleia just doesn&#39;t format the buffer at all, even if &lt;code&gt;black&lt;/code&gt; is installed.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; If a formatter uses &lt;code&gt;file&lt;/code&gt; (rather than &lt;code&gt;filepath&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt; or none of these keywords), it can&#39;t be chained after another formatter, because &lt;code&gt;file&lt;/code&gt; implies that the formatter must read from the &lt;em&gt;original&lt;/em&gt; file, not an intermediate temporary file. For this reason it&#39;s suggested to avoid the use of &lt;code&gt;file&lt;/code&gt; in general.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-formatter&lt;/code&gt;: Optional buffer-local variable specifying the formatter to use in this buffer. Overrides &lt;code&gt;apheleia-mode-alist&lt;/code&gt;. You can set this in a local variables list, or in &lt;code&gt;.dir-locals.el&lt;/code&gt; (e.g. &lt;code&gt;((python-mode . ((apheleia-formatter . (isort black)))))&lt;/code&gt;), or in a custom hook of your own that sets the local variable conditionally.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-inhibit&lt;/code&gt;: Optional buffer-local variable, if set to non-nil then Apheleia does not turn on automatically even if &lt;code&gt;apheleia-global-mode&lt;/code&gt; is on.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can run &lt;code&gt;M-x apheleia-mode&lt;/code&gt; to toggle automatic formatting on save in a single buffer, or &lt;code&gt;M-x apheleia-global-mode&lt;/code&gt; to toggle the default setting for all buffers. Also, even if &lt;code&gt;apheleia-mode&lt;/code&gt; is not enabled, you can run &lt;code&gt;M-x apheleia-format-buffer&lt;/code&gt; to manually invoke the configured formatter for the current buffer. Running with a prefix argument will cause the command to prompt you for which formatter to run.&lt;/p&gt; &#xA;&lt;p&gt;Apheleia does not currently support TRAMP, and is therefore automatically disabled for remote files.&lt;/p&gt; &#xA;&lt;p&gt;If an error occurs while formatting, a message is displayed in the echo area. You can jump to the error by invoking &lt;code&gt;M-x apheleia-goto-error&lt;/code&gt;, or manually switch to the log buffer mentioned in the message.&lt;/p&gt; &#xA;&lt;p&gt;You can configure error reporting using the following user options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-hide-log-buffers&lt;/code&gt;: By default, errors from formatters are put in buffers named like &lt;code&gt;*apheleia-cmdname-log*&lt;/code&gt;. If you customize this user option to non-nil then a space is prepended to the names of these buffers, hiding them by default in &lt;code&gt;switch-to-buffer&lt;/code&gt; (you must type a space to see them).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-log-only-errors&lt;/code&gt;: By default, only failed formatter runs are logged. If you customize this user option to nil then all runs are logged, along with whether or not they succeeded. This could be helpful in debugging.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following user options are also available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-post-format-hook&lt;/code&gt;: Normal hook run after Apheleia formats a buffer. Run if the formatting is successful, even when no changes are made to the buffer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-max-alignment-size&lt;/code&gt;: The maximum number of characters that a diff region can have to be processed using Apheleia&#39;s dynamic programming algorithm for point alignment. This cannot be too big or Emacs will hang noticeably on large reformatting operations, since the DP algorithm is quadratic-time.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-mode-lighter&lt;/code&gt;: &lt;code&gt;apheleia-mode&lt;/code&gt; lighter displayed in the mode-line. If you don&#39;t want to display it, use nil. Otherwise, its value must be a string.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Apheleia exposes some hooks for advanced customization:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;apheleia-formatter-exited-hook&lt;/code&gt;: Abnormal hook which is run after a formatter has completely finished running for a buffer. Not run if the formatting was interrupted and no action was taken. Receives two arguments: the symbol for the formatter that was run (e.g. &lt;code&gt;black&lt;/code&gt;, or it could be a list if multiple formatters were run in a chain), and a boolean for whether there was an error.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;apheleia-inhibit-functions&lt;/code&gt;: List of functions to run before turning on Apheleia automatically from &lt;code&gt;apheleia-global-mode&lt;/code&gt;. If one of these returns non-nil then &lt;code&gt;apheleia-mode&lt;/code&gt; is not enabled in the buffer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;apheleia-skip-functions&lt;/code&gt;: List of functions to run before &lt;em&gt;each&lt;/em&gt; Apheleia formatter invocation. If one of these returns non-nil then the formatter is not run, even if &lt;code&gt;apheleia-mode&lt;/code&gt; is enabled.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Formatter configuration&lt;/h3&gt; &#xA;&lt;p&gt;There is no configuration interface in Apheleia for formatter behavior. The way to configure a formatter is by editing a standard config file that it reads (e.g. &lt;code&gt;.prettierrc.json&lt;/code&gt;), or setting an environment variable that it reads, or by changing the entry in &lt;code&gt;apheleia-formatters&lt;/code&gt; to customize the command-line arguments.&lt;/p&gt; &#xA;&lt;p&gt;There is one exception to this, which is that Apheleia&#39;s default command-line arguments for the built-in formatters will automatically check Emacs&#39; indentation options for the corresponding major mode, and pass that information to the formatter. This way, the indentation (tabs vs spaces, and how many) applied by the formatter will match what electric indentation in Emacs is doing, preventing a shuffle back and forth as you type.&lt;/p&gt; &#xA;&lt;p&gt;This behavior can be disabled by setting &lt;code&gt;apheleia-formatters-respect-indent-level&lt;/code&gt; to nil.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;Try running your formatter outside of Emacs to verify it works there. Check what command-line options it is configured with in &lt;code&gt;apheleia-formatters&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To debug internal bugs, race conditions, or performance issues, try setting &lt;code&gt;apheleia-log-debug-info&lt;/code&gt; to non-nil and check the contents of &lt;code&gt;*apheleia-debug-log*&lt;/code&gt;. It will have detailed trace information about most operations performed by Apheleia.&lt;/p&gt; &#xA;&lt;h3&gt;Known issues&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;process aphelieia-whatever no longer connected to pipe; closed it&lt;/code&gt;: This happens on older Emacs versions when formatting a buffer with size greater than 65,536 characters. There is no known workaround besides disabling &lt;code&gt;apheleia-mode&lt;/code&gt; for the affected buffer, or upgrading to a more recent version of Emacs. See &lt;a href=&#34;https://github.com/radian-software/apheleia/issues/20&#34;&gt;#20&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/radian-software/contributor-guide&#34;&gt;the contributor guide for my projects&lt;/a&gt; for general information, and the following sections for Apheleia-specific details.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s also a &lt;a href=&#34;https://github.com/radian-software/apheleia/wiki&#34;&gt;wiki&lt;/a&gt; that could do with additions/clarity. Any improvement suggestions should be submitted as an issue.&lt;/p&gt; &#xA;&lt;h3&gt;Adding a formatter&lt;/h3&gt; &#xA;&lt;p&gt;I have done my best to make it straightforward to add a formatter. You just follow these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install your formatter on your machine so you can test.&lt;/li&gt; &#xA; &lt;li&gt;Create an entry in &lt;code&gt;apheleia-formatters&lt;/code&gt; with how to run it. (See the docstring of this variable for explanation about the available keywords.)&lt;/li&gt; &#xA; &lt;li&gt;Add entries for the relevant major modes in &lt;code&gt;apheleia-mode-alist&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;See if it works for you!&lt;/li&gt; &#xA; &lt;li&gt;Add a file at &lt;code&gt;test/formatters/installers/yourformatter.bash&lt;/code&gt; which explains how to install the formatter on Ubuntu. This will be used by CI.&lt;/li&gt; &#xA; &lt;li&gt;Test with &lt;code&gt;make fmt-build FORMATTERS=yourformatter&lt;/code&gt; to do the installation, then &lt;code&gt;make fmt-docker&lt;/code&gt; to start a shell with the formatter available. Verify it runs in this environment.&lt;/li&gt; &#xA; &lt;li&gt;Add an example input (pre-formatting) and output (post-formatting) file at &lt;code&gt;test/formatters/samplecode/yourformatter/in.whatever&lt;/code&gt; and &lt;code&gt;test/formatters/samplecode/yourformatter/out.whatever&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Verify that the tests are passing, using &lt;code&gt;make fmt-test FORMATTERS=yourformatter&lt;/code&gt; from inside the &lt;code&gt;fmt-docker&lt;/code&gt; shell.&lt;/li&gt; &#xA; &lt;li&gt;Submit a pull request, CI should now be passing!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;I got the idea for using RCS patches to avoid moving point too much from &lt;a href=&#34;https://github.com/prettier/prettier-emacs&#34;&gt;prettier-js&lt;/a&gt;, although that package does not implement the dynamic programming algorithm which Apheleia uses to guarantee stability of point even within a formatted region.&lt;/p&gt; &#xA;&lt;p&gt;Note that despite this inspiration, Apheleia is a clean-room implementation which is free of the copyright terms of prettier-js.&lt;/p&gt;</summary>
  </entry>
</feed>