<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-01T01:53:19Z</updated>
  <subtitle>Monthly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>purcell/emacs-reformatter</title>
    <updated>2024-12-01T01:53:19Z</updated>
    <id>tag:github.com,2024-12-01:/purcell/emacs-reformatter</id>
    <link href="https://github.com/purcell/emacs-reformatter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Define commands which run reformatters on the current Emacs buffer&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;http://melpa.org/#/reformatter&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/reformatter-badge.svg?sanitize=true&#34; alt=&#34;Melpa Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/reformatter&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/reformatter-badge.svg?sanitize=true&#34; alt=&#34;Melpa Stable Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.nongnu.org/nongnu/reformatter.html&#34;&gt;&lt;img src=&#34;https://elpa.nongnu.org/nongnu/reformatter.svg?sanitize=true&#34; alt=&#34;NonGNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/purcell/emacs-reformatter/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/purcell/emacs-reformatter/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.patreon.com/sanityinc&#34;&gt;&lt;img alt=&#34;Support me&#34; src=&#34;https://img.shields.io/badge/Support%20Me-%F0%9F%92%97-ff69b4.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Define commands which run reformatters on the current Emacs buffer&lt;/h1&gt; &#xA;&lt;p&gt;This library lets elisp authors easily define an idiomatic command to reformat the current buffer using a command-line program, together with an optional minor mode which can apply this command automatically on save.&lt;/p&gt; &#xA;&lt;p&gt;By default, reformatter.el expects programs to read from stdin and write to stdout, and you should prefer this mode of operation where possible. If this isn&#39;t possible with your particular formatting program, refer to the options for &lt;code&gt;reformatter-define&lt;/code&gt;, and see the examples in the package&#39;s tests.&lt;/p&gt; &#xA;&lt;p&gt;In its initial release it supports only reformatters which can read from stdin and write to stdout, but a more versatile interface will be provided as development continues.&lt;/p&gt; &#xA;&lt;p&gt;As an example, let&#39;s define a reformat command that applies the &#34;dhall format&#34; command. We&#39;ll assume here that we&#39;ve already defined a variable &lt;code&gt;dhall-command&lt;/code&gt; which holds the string name or path of the dhall executable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(reformatter-define dhall-format&#xA;  :program dhall-command&#xA;  :args &#39;(&#34;format&#34;)&#xA;  :lighter &#34; DF&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;reformatter-define&lt;/code&gt; macro expands to code which generates &lt;code&gt;dhall-format-buffer&lt;/code&gt; and &lt;code&gt;dhall-format-region&lt;/code&gt; interactive commands, and a local minor mode called &lt;code&gt;dhall-format-on-save-mode&lt;/code&gt;. The &lt;code&gt;:args&lt;/code&gt; and &lt;code&gt;:program&lt;/code&gt; expressions will be evaluated at runtime, so they can refer to variables that may (later) have a buffer-local value. A custom variable will be generated for the mode lighter, with the supplied value becoming the default.&lt;/p&gt; &#xA;&lt;p&gt;The generated minor mode allows idiomatic per-directory or per-file customisation, via the &#34;modes&#34; support baked into Emacs&#39; file-local and directory-local variables mechanisms. For example, users of the above example might add the following to a project-specific &lt;code&gt;.dir-locals.el&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;((dhall-mode&#xA;   (mode . dhall-format-on-save)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the documentation for &lt;code&gt;reformatter-define&lt;/code&gt;, which provides a number of options for customising the generated code.&lt;/p&gt; &#xA;&lt;p&gt;Library authors might like to provide autoloads for the generated code, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;;;;###autoload (autoload &#39;dhall-format-buffer &#34;current-file&#34; nil t)&#xA;;;;###autoload (autoload &#39;dhall-format-region &#34;current-file&#34; nil t)&#xA;;;;###autoload (autoload &#39;dhall-format-on-save-mode &#34;current-file&#34; nil t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples of usage in the wild&lt;/h2&gt; &#xA;&lt;p&gt;To find reverse dependencies, look for &#34;Needed by&#34; on the &lt;a href=&#34;https://melpa.org/#/reformatter&#34;&gt;MELPA page for reformatter&lt;/a&gt;. Here are some specific examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/psibi/dhall-mode/raw/master/dhall-mode.el&#34;&gt;dhall-mode.el&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jcollard/elm-mode/raw/master/elm-format.el&#34;&gt;elm-format.el&lt;/a&gt;, in &lt;code&gt;elm-mode&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/purcell/sqlformat/raw/master/sqlformat.el&#34;&gt;sqlformat.el&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/purcell/emacs.d/raw/14f645a9bde04498ce2b60de268c2cbafa13604a/lisp/init-purescript.el#L18-L19&#34;&gt;Here&lt;/a&gt; is the author defining a reformatter in his own configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Rationale&lt;/h2&gt; &#xA;&lt;p&gt;I contribute to a number of Emacs programming language modes and tools, and increasingly use code reformatters in my daily work. It&#39;s surprisingly difficult to write robust, correct code to apply these reformatters, given that it must consider such issues as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Missing programs&lt;/li&gt; &#xA; &lt;li&gt;Buffers not yet saved to a file&lt;/li&gt; &#xA; &lt;li&gt;Displaying error output&lt;/li&gt; &#xA; &lt;li&gt;Colorising ANSI escape sequences in any error output&lt;/li&gt; &#xA; &lt;li&gt;Handling file encodings correctly&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With this library, I hope to help the community standardise on best practices, and make things easier for tool authors and end users alike.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;How is this different from &lt;a href=&#34;https://github.com/lassik/emacs-format-all-the-code&#34;&gt;format-all.el&lt;/a&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;format-all&lt;/code&gt; is a very different approach: it aims to provide a single minor mode which you then enable and configure to do the right thing (including nothing) for all the languages you use. It even tries to tell you how to install missing programs. It&#39;s an interesting project, but IMO it&#39;s hard to design the configuration for such a grand unified approach, and it can get complex. For example, you&#39;d have to be able to configure which of two possible reformatters you want to use for a specific language, and to be able to do that on a per-project basis.&lt;/p&gt; &#xA;&lt;p&gt;In contrast reformatter produces small, self-contained and separate formatters and minor modes which all work consistently and are individually configured. It makes it possible to replace existing formatter code, and it&#39;s also very convenient for users to define their own ad-hoc reformatter wrappers&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Manual&lt;/h3&gt; &#xA;&lt;p&gt;Ensure &lt;code&gt;reformatter.el&lt;/code&gt; is in a directory on your load-path, and add the following to your &lt;code&gt;~/.emacs&lt;/code&gt; or &lt;code&gt;~/.emacs.d/init.el&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;reformatter)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MELPA&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re an Emacs 24 user or you have a recent version of &lt;code&gt;package.el&lt;/code&gt; you can install &lt;code&gt;reformatter&lt;/code&gt; from the &lt;a href=&#34;http://melpa.org&#34;&gt;MELPA&lt;/a&gt; repository. The version of &lt;code&gt;reformatter&lt;/code&gt; there will always be up-to-date.&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Author: Steve Purcell &#xA; &lt;steve at sanityinc dot com&gt;&lt;/steve&gt;&lt;/p&gt; &#xA;&lt;p&gt;Homepage: &lt;a href=&#34;https://github.com/purcell/emacs-reformatter&#34;&gt;https://github.com/purcell/emacs-reformatter&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.patreon.com/sanityinc&#34;&gt;üíù Support this project and my other Open Source work&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://uk.linkedin.com/in/stevepurcell&#34;&gt;üíº LinkedIn profile&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.sanityinc.com/&#34;&gt;‚úç sanityinc.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>clojure-emacs/clojure-mode</title>
    <updated>2024-12-01T01:53:19Z</updated>
    <id>tag:github.com,2024-12-01:/clojure-emacs/clojure-mode</id>
    <link href="https://github.com/clojure-emacs/clojure-mode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs support for the Clojure(Script) programming language&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/clojure-emacs/clojure-mode&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/clojure-emacs/clojure-mode.svg?style=svg&#34; alt=&#34;circleci&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/clojure-mode&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/clojure-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/clojure-mode&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/clojure-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.nongnu.org/nongnu/clojure-mode.html&#34;&gt;&lt;img src=&#34;https://elpa.nongnu.org/nongnu/clojure-mode.svg?sanitize=true&#34; alt=&#34;NonGNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.com/invite/nFPpynQPME&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/chat-on%20discord-7289da.svg?sanitize=true&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.gnu.org/copyleft/gpl.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?sanitize=true&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Clojure Mode&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt; is an Emacs major mode that provides font-lock (syntax highlighting), indentation, navigation and refactoring support for the &lt;a href=&#34;https://clojure.org&#34;&gt;Clojure(Script) programming language&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;This documentation tracks the &lt;code&gt;master&lt;/code&gt; branch of &lt;code&gt;clojure-mode&lt;/code&gt;. Some of the features and settings discussed here might not be available in older releases (including the current stable release). Please, consult the relevant git tag (e.g. &lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode/tree/v5.19.0&#34;&gt;5.19.0&lt;/a&gt;) if you need documentation for a specific &lt;code&gt;clojure-mode&lt;/code&gt; release.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Available on the major &lt;code&gt;package.el&lt;/code&gt; community maintained repos - &lt;a href=&#34;https://stable.melpa.org&#34;&gt;MELPA Stable&lt;/a&gt; and &lt;a href=&#34;https://melpa.org&#34;&gt;MELPA&lt;/a&gt; repos.&lt;/p&gt; &#xA;&lt;p&gt;MELPA Stable is the recommended repo as it has the latest stable version. MELPA has a development snapshot for users who don&#39;t mind (infrequent) breakage but don&#39;t want to run from a git checkout.&lt;/p&gt; &#xA;&lt;p&gt;You can install &lt;code&gt;clojure-mode&lt;/code&gt; using the following command:&lt;/p&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x&lt;/kbd&gt; &lt;code&gt;package-install&lt;/code&gt; &lt;kbd&gt;[RET]&lt;/kbd&gt; &lt;code&gt;clojure-mode&lt;/code&gt; &lt;kbd&gt;[RET]&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;p&gt;or if you&#39;d rather keep it in your dotfiles:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(unless (package-installed-p &#39;clojure-mode)&#xA;  (package-install &#39;clojure-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the installation doesn&#39;t work try refreshing the package list:&lt;/p&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x&lt;/kbd&gt; &lt;code&gt;package-refresh-contents&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Bundled major modes&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;clojure-mode&lt;/code&gt; package actually bundles together several major modes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;clojure-mode&lt;/code&gt; is a major mode for editing Clojure code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clojurescript-mode&lt;/code&gt; is a major mode for editing ClojureScript code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clojurec-mode&lt;/code&gt; is a major mode for editing &lt;code&gt;.cljc&lt;/code&gt; source files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All the major modes derive from &lt;code&gt;clojure-mode&lt;/code&gt; and provide more or less the same functionality. Differences can be found mostly in the font-locking - e.g. ClojureScript has some built-in constructs that are not present in Clojure.&lt;/p&gt; &#xA;&lt;p&gt;The proper major mode is selected automatically based on the extension of the file you&#39;re editing.&lt;/p&gt; &#xA;&lt;p&gt;Having separate major modes gives you the flexibility to attach different hooks to them and to alter their behavior individually (e.g. add extra font-locking just to &lt;code&gt;clojurescript-mode&lt;/code&gt;) .&lt;/p&gt; &#xA;&lt;p&gt;Note that all modes derive from &lt;code&gt;clojure-mode&lt;/code&gt;, so things you add to &lt;code&gt;clojure-mode-hook&lt;/code&gt; and &lt;code&gt;clojure-mode-map&lt;/code&gt; will affect all the derived modes as well.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;In the spirit of Emacs, pretty much everything you can think of in &lt;code&gt;clojure-mode&lt;/code&gt; is configurable.&lt;/p&gt; &#xA;&lt;p&gt;To see a list of available configuration options do &lt;code&gt;M-x customize-group RET clojure&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Indentation options&lt;/h3&gt; &#xA;&lt;p&gt;The default indentation rules in &lt;code&gt;clojure-mode&lt;/code&gt; are derived from the &lt;a href=&#34;https://guide.clojure.style&#34;&gt;community Clojure Style Guide&lt;/a&gt;. Please, refer to the guide for the general Clojure indentation rules.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like to use the alternative &#34;fixed/tonsky&#34; indentation style you should update your configuration accordingly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(setq clojure-indent-style &#39;always-indent&#xA;      clojure-indent-keyword-style &#39;always-indent&#xA;      clojure-enable-indent-specs nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Read on for more details on the available indentation-related configuration options.&lt;/p&gt; &#xA;&lt;h4&gt;Indentation of docstrings&lt;/h4&gt; &#xA;&lt;p&gt;By default multi-line docstrings are indented with 2 spaces, as this is a somewhat common standard in the Clojure community. You can however adjust this by modifying &lt;code&gt;clojure-docstring-fill-prefix-width&lt;/code&gt;. Set it to 0 if you don&#39;t want multi-line docstrings to be indented at all (which is pretty common in most lisps).&lt;/p&gt; &#xA;&lt;h4&gt;Indentation of function forms&lt;/h4&gt; &#xA;&lt;p&gt;The indentation of function forms is configured by the variable &lt;code&gt;clojure-indent-style&lt;/code&gt;. It takes three possible values:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;always-align&lt;/code&gt; (the default)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(some-function&#xA; 10&#xA; 1&#xA; 2)&#xA;(some-function 10&#xA;               1&#xA;               2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;always-indent&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(some-function&#xA;  10&#xA;  1&#xA;  2)&#xA;(some-function 10&#xA;  1&#xA;  2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;align-arguments&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(some-function&#xA;  10&#xA;  1&#xA;  2)&#xA;(some-function 10&#xA;               1&#xA;               2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Prior to clojure-mode 5.10, the configuration options for &lt;code&gt;clojure-indent-style&lt;/code&gt; used to be keywords, but now they are symbols. Keywords will still be supported at least until clojure-mode 6.&lt;/p&gt; &#xA;&lt;h4&gt;Indentation of keywords&lt;/h4&gt; &#xA;&lt;p&gt;Similarly we have the &lt;code&gt;clojure-indent-keyword-style&lt;/code&gt;, which works in the following way:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;always-align&lt;/code&gt; (default) - All args are vertically aligned with the first arg in case (A), and vertically aligned with the function name in case (B).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(:require [foo.bar]&#xA;          [bar.baz])&#xA;(:require&#xA; [foo.bar]&#xA; [bar.baz])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;always-indent&lt;/code&gt; - All args are indented like a macro body.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(:require [foo.bar]&#xA;   [bar.baz])&#xA;(:x&#xA;   location&#xA;   0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;align-arguments&lt;/code&gt; - Case (A) is indented like &lt;code&gt;always-align&lt;/code&gt;, and case (B) is indented like a macro body.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(:require [foo.bar]&#xA;          [bar.baz])&#xA;(:x&#xA;   location&#xA;   0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Indentation of macro forms&lt;/h4&gt; &#xA;&lt;p&gt;The indentation of special forms and macros with bodies is controlled via &lt;code&gt;put-clojure-indent&lt;/code&gt;, &lt;code&gt;define-clojure-indent&lt;/code&gt; and &lt;code&gt;clojure-backtracking-indent&lt;/code&gt;. Nearly all special forms and built-in macros with bodies have special indentation settings in &lt;code&gt;clojure-mode&lt;/code&gt;. You can add/alter the indentation settings in your personal config. Let&#39;s assume you want to indent &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(-&amp;gt;&amp;gt; something&#xA;  ala&#xA;  bala&#xA;  portokala)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can do so by putting the following in your config:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(put-clojure-indent &#39;-&amp;gt; 1)&#xA;(put-clojure-indent &#39;-&amp;gt;&amp;gt; 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means that the body of the &lt;code&gt;-&amp;gt;/-&amp;gt;&amp;gt;&lt;/code&gt; is after the first argument.&lt;/p&gt; &#xA;&lt;p&gt;A more compact way to do the same thing is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(define-clojure-indent&#xA;  (-&amp;gt; 1)&#xA;  (-&amp;gt;&amp;gt; 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To indent something like a definition (&lt;code&gt;defn&lt;/code&gt;) you can do something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(put-clojure-indent &#39;&amp;gt;defn :defn)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify different indentation settings for symbols prefixed with some ns (or ns alias):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(put-clojure-indent &#39;do 0)&#xA;(put-clojure-indent &#39;my-ns/do 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The bodies of certain more complicated macros and special forms (e.g. &lt;code&gt;letfn&lt;/code&gt;, &lt;code&gt;deftype&lt;/code&gt;, &lt;code&gt;extend-protocol&lt;/code&gt;, etc) are indented using a contextual backtracking indentation method, require more sophisticated indent specifications. Here are a few examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(define-clojure-indent&#xA;  (implement &#39;(1 (1)))&#xA;  (letfn     &#39;(1 ((:defn)) nil))&#xA;  (proxy     &#39;(2 nil nil (1)))&#xA;  (reify     &#39;(:defn (1)))&#xA;  (deftype   &#39;(2 nil nil (1)))&#xA;  (defrecord &#39;(2 nil nil (1)))&#xA;  (specify   &#39;(1 (1)))&#xA;  (specify   &#39;(1 (1))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These follow the same rules as the &lt;code&gt;:style/indent&lt;/code&gt; metadata specified by &lt;a href=&#34;https://github.com/clojure-emacs/cider-nrepl&#34;&gt;cider-nrepl&lt;/a&gt;. For instructions on how to write these specifications, see &lt;a href=&#34;https://docs.cider.mx/cider/indent_spec.html&#34;&gt;this document&lt;/a&gt;. The only difference is that you&#39;re allowed to use lists instead of vectors.&lt;/p&gt; &#xA;&lt;p&gt;The indentation of &lt;a href=&#34;https://docs.cider.mx/cider/indent_spec.html#special-arguments&#34;&gt;special arguments&lt;/a&gt; is controlled by &lt;code&gt;clojure-special-arg-indent-factor&lt;/code&gt;, which by default indents special arguments a further &lt;code&gt;lisp-body-indent&lt;/code&gt; when compared to ordinary arguments.&lt;/p&gt; &#xA;&lt;p&gt;An example of the default formatting is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defrecord MyRecord&#xA;    [my-field])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;defrecord&lt;/code&gt; has two special arguments, followed by the form&#39;s body - namely the record&#39;s name and its fields vector.&lt;/p&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;clojure-special-arg-indent-factor&lt;/code&gt; to 1, results in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defrecord MyRecord&#xA;  [my-field])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can completely disable the effect of indentation specs like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(setq clojure-enable-indent-specs nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Indentation of Comments&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt; differentiates between comments like &lt;code&gt;;&lt;/code&gt;, &lt;code&gt;;;&lt;/code&gt;, etc. By default &lt;code&gt;clojure-mode&lt;/code&gt; treats &lt;code&gt;;&lt;/code&gt; as inline comments and &lt;em&gt;always&lt;/em&gt; indents those. You can change this behaviour like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(add-hook &#39;clojure-mode-hook (lambda () (setq-local comment-column 0)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You might also want to change &lt;code&gt;comment-add&lt;/code&gt; to 0 in that way, so that Emacs comment functions (e.g. &lt;code&gt;comment-region&lt;/code&gt;) would use &lt;code&gt;;&lt;/code&gt; by default instead of &lt;code&gt;;;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Check out &lt;a href=&#34;https://guide.clojure.style/#comments&#34;&gt;this section&lt;/a&gt; of the Clojure style guide to understand better the semantics of the different comment levels and why &lt;code&gt;clojure-mode&lt;/code&gt; treats them differently by default.&lt;/p&gt; &#xA;&lt;h3&gt;Vertical alignment&lt;/h3&gt; &#xA;&lt;p&gt;You can vertically align sexps with &lt;code&gt;C-c SPC&lt;/code&gt;. For instance, typing this combo on the following form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(def my-map&#xA;  {:a-key 1&#xA;   :other-key 2})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Leads to the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(def my-map&#xA;  {:a-key     1&#xA;   :other-key 2})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can also be done automatically (as part of indentation) by turning on &lt;code&gt;clojure-align-forms-automatically&lt;/code&gt;. This way it will happen whenever you select some code and hit &lt;code&gt;TAB&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Font-locking&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt; features static font-locking (syntax highlighting) that you can extend yourself if needed. As typical for Emacs, it&#39;s based on regular expressions. You can find the default font-locking rules in &lt;code&gt;clojure-font-lock-keywords&lt;/code&gt;. Here&#39;s how you can add font-locking for built-in Clojure functions and vars:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(defvar clojure-built-in-vars&#xA;  &#39;(;; clojure.core&#xA;    &#34;accessor&#34; &#34;aclone&#34;&#xA;    &#34;agent&#34; &#34;agent-errors&#34; &#34;aget&#34; &#34;alength&#34; &#34;alias&#34;&#xA;    &#34;all-ns&#34; &#34;alter&#34; &#34;alter-meta!&#34; &#34;alter-var-root&#34; &#34;amap&#34;&#xA;    ;; omitted for brevity&#xA;    ))&#xA;&#xA;(defvar clojure-built-in-dynamic-vars&#xA;  &#39;(;; clojure.test&#xA;    &#34;*initial-report-counters*&#34; &#34;*load-tests*&#34; &#34;*report-counters*&#34;&#xA;    &#34;*stack-trace-depth*&#34; &#34;*test-out*&#34; &#34;*testing-contexts*&#34; &#34;*testing-vars*&#34;&#xA;    ;; clojure.xml&#xA;    &#34;*current*&#34; &#34;*sb*&#34; &#34;*stack*&#34; &#34;*state*&#34;&#xA;    ))&#xA;&#xA;(font-lock-add-keywords &#39;clojure-mode&#xA;                        `((,(concat &#34;(\\(?:\.*/\\)?&#34;&#xA;                                    (regexp-opt clojure-built-in-vars t)&#xA;                                    &#34;\\&amp;gt;&#34;)&#xA;                           1 font-lock-builtin-face)))&#xA;&#xA;(font-lock-add-keywords &#39;clojure-mode&#xA;                        `((,(concat &#34;\\&amp;lt;&#34;&#xA;                                    (regexp-opt clojure-built-in-dynamic-vars t)&#xA;                                    &#34;\\&amp;gt;&#34;)&#xA;                           0 font-lock-builtin-face)))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The package &lt;code&gt;clojure-mode-extra-font-locking&lt;/code&gt; provides such additional font-locking for Clojure built-ins.&lt;/p&gt; &#xA;&lt;p&gt;As you might imagine one problem with this font-locking approach is that because it&#39;s based on regular expressions you&#39;ll get some false positives here and there (there&#39;s no namespace information, and no way for &lt;code&gt;clojure-mode&lt;/code&gt; to know what var a symbol resolves to). That&#39;s why &lt;code&gt;clojure-mode&lt;/code&gt;&#39;s font-locking defaults are conservative and minimalistic.&lt;/p&gt; &#xA;&lt;p&gt;Precise font-locking requires additional data that can obtained from a running REPL (that&#39;s how CIDER&#39;s &lt;a href=&#34;https://docs.cider.mx/cider/config/syntax_highlighting.html&#34;&gt;dynamic font-locking&lt;/a&gt; works) or from static code analysis.&lt;/p&gt; &#xA;&lt;p&gt;When it comes to non built-in definitions, &lt;code&gt;clojure-mode&lt;/code&gt; needs to be manually instructed how to handle the docstrings and highlighting. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(put &#39;&amp;gt;defn &#39;clojure-doc-string-elt 2)&#xA;&#xA;(font-lock-add-keywords &#39;clojure-mode&#xA;                        `((,(concat &#34;(\\(?:&#34; clojure--sym-regexp &#34;/\\)?&#34;&#xA;                                    &#34;\\(&amp;gt;defn\\)\\&amp;gt;&#34;)&#xA;                           1 font-lock-keyword-face)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;clojure-doc-string-elt&lt;/code&gt; attribute is processed by the function &lt;code&gt;clojure-font-lock-syntactic-face-function&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Refactoring support&lt;/h2&gt; &#xA;&lt;p&gt;The available refactorings were originally created and maintained by the &lt;code&gt;clj-refactor.el&lt;/code&gt; team. The ones implemented in Elisp only are gradually migrated to &lt;code&gt;clojure-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Threading macros related features&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-thread&lt;/code&gt;: Thread another form into the surrounding thread. Both &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; variants are supported.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-thread.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-unwind&lt;/code&gt;: Unwind a threaded expression. Supports both &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-unwind.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-thread-first-all&lt;/code&gt;: Introduce the thread first macro (&lt;code&gt;-&amp;gt;&lt;/code&gt;) and rewrite the entire form. With a prefix argument do not thread the last form.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-thread-first-all.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-thread-last-all&lt;/code&gt;: Introduce the thread last macro and rewrite the entire form. With a prefix argument do not thread the last form.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-thread-last-all.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-unwind-all&lt;/code&gt;: Fully unwind a threaded expression removing the threading macro.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-unwind-all.gif&#34;&gt; &#xA;&lt;h3&gt;Cycling things&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-cycle-privacy&lt;/code&gt;: Cycle privacy of &lt;code&gt;def&lt;/code&gt;s or &lt;code&gt;defn&lt;/code&gt;s. Use metadata explicitly with setting &lt;code&gt;clojure-use-metadata-for-privacy&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; for &lt;code&gt;defn&lt;/code&gt;s too.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-cycle-privacy.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-cycle-not&lt;/code&gt;: Add or remove a &lt;code&gt;not&lt;/code&gt; form around the current form.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-cycle-not.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-cycle-when&lt;/code&gt;: Find the closest &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;when-not&lt;/code&gt; up the syntax tree and toggle it.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-cycle-when.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-cycle-if&lt;/code&gt;: Find the closest &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;if-not&lt;/code&gt; up the syntax tree and toggle it. Also transpose the &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;then&lt;/code&gt; branches, keeping the semantics the same as before.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-cycle-if.gif&#34;&gt; &#xA;&lt;h3&gt;Convert collection&lt;/h3&gt; &#xA;&lt;p&gt;Convert any given collection at point to list, quoted list, map, vector or set.&lt;/p&gt; &#xA;&lt;h3&gt;Let expression&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-introduce-let&lt;/code&gt;: Introduce a new &lt;code&gt;let&lt;/code&gt; form. Put the current form into its binding form with a name provided by the user as a bound name. If called with a numeric prefix put the let form Nth level up in the form hierarchy.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-introduce-let.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-move-to-let&lt;/code&gt;: Move the current form to the closest &lt;code&gt;let&lt;/code&gt;&#39;s binding form. Replace all occurrences of the form in the body of the let.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-move-to-let.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-let-forward-slurp-sexp&lt;/code&gt;: Slurp the next form after the &lt;code&gt;let&lt;/code&gt; into the &lt;code&gt;let&lt;/code&gt;. Replace all occurrences of the bound forms in the form added to the &lt;code&gt;let&lt;/code&gt; form. If called with a prefix argument slurp the next n forms.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-let-forward-slurp-sexp.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-let-backward-slurp-sexp&lt;/code&gt;: Slurp the form before the &lt;code&gt;let&lt;/code&gt; into the &lt;code&gt;let&lt;/code&gt;. Replace all occurrences of the bound forms in the form added to the &lt;code&gt;let&lt;/code&gt; form. If called with a prefix argument slurp the previous n forms.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-let-backward-slurp-sexp.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;paredit-convolute-sexp&lt;/code&gt; is advised to replace occurrences of bound forms with their bound names when convolute is used on a let form.&lt;/p&gt; &#xA;&lt;h3&gt;Rename ns alias&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-rename-ns-alias&lt;/code&gt;: Rename an alias inside a namespace declaration, and all of its usages in the buffer&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-rename-ns-alias.gif&#34;&gt; &#xA;&lt;p&gt;If there is an active selected region, only rename usages of aliases within the region, without affecting the namespace declaration.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-rename-ns-alias-region.gif&#34;&gt; &#xA;&lt;h3&gt;Add arity to a function&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-add-arity&lt;/code&gt;: Add a new arity to an existing single-arity or multi-arity function.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-add-arity.gif&#34;&gt; &#xA;&lt;h2&gt;Related packages&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode/raw/master/clojure-mode-extra-font-locking.el&#34;&gt;clojure-mode-extra-font-locking&lt;/a&gt; provides additional font-locking for built-in methods and macros. The font-locking is pretty imprecise, because it doesn&#39;t take namespaces into account and it won&#39;t font-lock a function at all possible positions in a sexp, but if you don&#39;t mind its imperfections you can easily enable it:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(require &#39;clojure-mode-extra-font-locking)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The code in &lt;code&gt;clojure-mode-font-locking&lt;/code&gt; used to be bundled with &lt;code&gt;clojure-mode&lt;/code&gt; before version 3.0.&lt;/p&gt; &#xA;&lt;p&gt;You can also use the code in this package as a basis for extending the font-locking further (e.g. functions/macros from more namespaces). Generally you should avoid adding special font-locking for things that don&#39;t have fairly unique names, as this will result in plenty of incorrect font-locking. CIDER users should avoid this package, as CIDER does its own dynamic font-locking, which is namespace-aware and doesn&#39;t produce almost any false positives.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/clojure-emacs/clj-refactor.el&#34;&gt;clj-refactor&lt;/a&gt; provides refactoring support.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Enabling &lt;code&gt;CamelCase&lt;/code&gt; support for editing commands(like &lt;code&gt;forward-word&lt;/code&gt;, &lt;code&gt;backward-word&lt;/code&gt;, etc) in &lt;code&gt;clojure-mode&lt;/code&gt; is quite useful since we often have to deal with Java class and method names. The built-in Emacs minor mode &lt;code&gt;subword-mode&lt;/code&gt; provides such functionality:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-hook &#39;clojure-mode-hook #&#39;subword-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The use of &lt;a href=&#34;https://mumble.net/~campbell/emacs/paredit.html&#34;&gt;paredit&lt;/a&gt; when editing Clojure (or any other Lisp) code is highly recommended. It helps ensure the structure of your forms is not compromised and offers a number of operations that work on code structure at a higher level than just characters and words. To enable it for Clojure buffers:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-hook &#39;clojure-mode-hook #&#39;paredit-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Fuco1/smartparens&#34;&gt;smartparens&lt;/a&gt; is an excellent (newer) alternative to paredit. Many Clojure hackers have adopted it recently and you might want to give it a try as well. To enable &lt;code&gt;smartparens&lt;/code&gt; use the following code:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-hook &#39;clojure-mode-hook #&#39;smartparens-strict-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Fanael/rainbow-delimiters&#34;&gt;RainbowDelimiters&lt;/a&gt; is a minor mode which highlights parentheses, brackets, and braces according to their depth. Each successive level is highlighted in a different color. This makes it easy to spot matching delimiters, orient yourself in the code, and tell which statements are at a given depth. Assuming you&#39;ve already installed &lt;code&gt;RainbowDelimiters&lt;/code&gt; you can enable it like this:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-hook &#39;clojure-mode-hook #&#39;rainbow-delimiters-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Malabarba/aggressive-indent-mode&#34;&gt;aggressive-indent-mode&lt;/a&gt; automatically adjust the indentation of your code, while you&#39;re writing it. Using it together with &lt;code&gt;clojure-mode&lt;/code&gt; is highly recommended. Provided you&#39;ve already installed &lt;code&gt;aggressive-indent-mode&lt;/code&gt; you can enable it like this:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-hook &#39;clojure-mode-hook #&#39;aggressive-indent-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;REPL Interaction&lt;/h2&gt; &#xA;&lt;p&gt;One of the fundamental aspects of Lisps in general, and Clojure in particular, is the notion of interactive programming - building your programs by continuously changing the state of the running Lisp program (as opposed to doing something more traditional like making a change and re-running the program afterwards to see the changes in action). To get the most of clojure-mode you&#39;ll have to combine it with some tool which will allow you to interact with your Clojure program (a.k.a. process/REPL).&lt;/p&gt; &#xA;&lt;p&gt;A number of options exist for connecting to a running Clojure process and evaluating code interactively.&lt;/p&gt; &#xA;&lt;h3&gt;Basic REPL&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/clojure-emacs/inf-clojure&#34;&gt;inf-clojure&lt;/a&gt; provides basic interaction with a Clojure REPL process. It&#39;s very similar in nature and supported functionality to &lt;code&gt;inferior-lisp-mode&lt;/code&gt; for Common Lisp.&lt;/p&gt; &#xA;&lt;h3&gt;CIDER&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;CIDER&lt;/a&gt; is a powerful Clojure interactive development environment, similar to SLIME for Common Lisp.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re into Clojure and Emacs you should definitely check it out.&lt;/p&gt; &#xA;&lt;h2&gt;Tutorials&lt;/h2&gt; &#xA;&lt;p&gt;Tutorials, targeting Emacs beginners, are available at &lt;a href=&#34;https://clojure-doc.org/articles/tutorials/editors/&#34;&gt;clojure-doc.org&lt;/a&gt; and &lt;a href=&#34;https://www.braveclojure.com/basic-emacs/&#34;&gt;Clojure for the Brave and the True&lt;/a&gt;. Keep in mind, however, that they might be out-of-date.&lt;/p&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt; is a capable tool, but it&#39;s certainly not perfect. This section lists a couple of general design problems/limitations that might affect your experience negatively.&lt;/p&gt; &#xA;&lt;h3&gt;General Issues&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt; derives a lot of functionality directly from &lt;code&gt;lisp-mode&lt;/code&gt; (an Emacs major mode for Common Lisp), which simplified the initial implementation, but also made it harder to implement certain functionality. Down the road it&#39;d be nice to fully decouple &lt;code&gt;clojure-mode&lt;/code&gt; from &lt;code&gt;lisp-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode/issues/270&#34;&gt;this ticket&lt;/a&gt; for a bit more details.&lt;/p&gt; &#xA;&lt;h3&gt;Indentation Performance&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt;&#39;s indentation engine is a bit slow. You can speed things up significantly by disabling &lt;code&gt;clojure-use-backtracking-indent&lt;/code&gt;, but this will break the indentation of complex forms like &lt;code&gt;deftype&lt;/code&gt;, &lt;code&gt;defprotocol&lt;/code&gt;, &lt;code&gt;reify&lt;/code&gt;, &lt;code&gt;letfn&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;We should look into ways to optimize the performance of the backtracking indentation logic. See &lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode/issues/606&#34;&gt;this ticket&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Font-locking Implementation&lt;/h3&gt; &#xA;&lt;p&gt;As mentioned &lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode#font-locking&#34;&gt;above&lt;/a&gt;, the font-locking is implemented in terms of regular expressions which makes it both slow and inaccurate.&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;An extensive changelog is available &lt;a href=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/CHANGELOG.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright ¬© 2007-2024 Jeffrey Chu, Lennart Staflin, Phil Hagelberg, Bozhidar Batsov, Artur Malabarba, Magnar Sveen and &lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode/contributors&#34;&gt;contributors&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Distributed under the GNU General Public License; type &lt;kbd&gt;C-h C-c&lt;/kbd&gt; to view it.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tumashu/posframe</title>
    <updated>2024-12-01T01:53:19Z</updated>
    <id>tag:github.com,2024-12-01:/tumashu/posframe</id>
    <link href="https://github.com/tumashu/posframe" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Pop a posframe (just a child-frame) at point, posframe is a **GNU ELPA** package!&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Created 2021-06-01 Tue 10:41&lt;/h1&gt; &#xA;&lt;p&gt;#+TITLE: Pop a posframe (just a frame) at point #+AUTHOR: Feng Shu&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;http://elpa.gnu.org/packages/posframe.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/posframe.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/devel/posframe.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/posframe.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/posframe&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/posframe-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;What is posframe? Posframe can pop up a frame at point, this &lt;em&gt;posframe&lt;/em&gt; is a child-frame connected to its root window&#39;s buffer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The main advantages are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;It is fast enough for daily usage :-)&lt;/li&gt; &#xA; &lt;li&gt;It works well with CJK languages.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;NOTE:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;For MacOS users, posframe needs Emacs version &amp;gt;= 26.0.91&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;GNOME users with GTK3 builds need Emacs 27 or later. See variable `posframe-gtk-resize-child-frames&#39; which auto-detects this configuration.&lt;/p&gt; &lt;p&gt;More details:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;[[https://git.savannah.gnu.org/cgit/emacs.git/commit/?h=emacs-27&amp;amp;id=c49d379f17bcb0ce82604def2eaa04bda00bd5ec][Fix some problems with moving and resizing child frames]]&lt;/li&gt; &#xA;   &lt;li&gt;[[https://lists.gnu.org/archive/html/emacs-devel/2020-01/msg00343.html][Emacs&#39;s set-frame-size can not work well with gnome-shell?]]&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;[[file:./snapshots/posframe-1.png]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_example (require &#39;posframe) #+end_example&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Create a posframe&lt;/p&gt; &#xA;&lt;p&gt;*** Simple way #+begin_example (when (posframe-workable-p) (posframe-show &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34; :string &#34;This is a test&#34; :position (point))) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;*** Advanced way #+begin_example (defvar my-posframe-buffer &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;)&lt;/p&gt; &#xA;&lt;p&gt;(with-current-buffer (get-buffer-create my-posframe-buffer) (erase-buffer) (insert &#34;Hello world&#34;))&lt;/p&gt; &#xA;&lt;p&gt;(when (posframe-workable-p) (posframe-show my-posframe-buffer :position (point))) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;*** Arguments&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example C-h f posframe-show #+end_example&lt;/p&gt; &#xA;&lt;p&gt;** Hide a posframe #+begin_example (posframe-hide &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;** Hide all posframes #+begin_example M-x posframe-hide-all #+end_example&lt;/p&gt; &#xA;&lt;p&gt;** Delete a posframe&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Delete posframe and its buffer #+begin_example (posframe-delete &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;) #+end_example&lt;/li&gt; &#xA; &lt;li&gt;Only delete the frame #+begin_example (posframe-delete-frame &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;) #+end_example ** Delete all posframes #+begin_example M-x posframe-delete-all #+end_example&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note: this command will delete all posframe buffers. You probably shouldn&#39;t use it if you are sharing a buffer between posframe and other packages.&lt;/p&gt; &#xA;&lt;p&gt;** posframe-arghandler&lt;/p&gt; &#xA;&lt;p&gt;posframe-arghandler feature has been removed from posframe-1.1, user can use advice feature instead.&lt;/p&gt; &#xA;&lt;p&gt;** Mouse banish Default setting will work well in most case, but for EXWM user, suggest use the below config.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq posframe-mouse-banish-function #&#39;posframe-mouse-banish-simple) #+end_src&lt;/p&gt;</summary>
  </entry>
</feed>