<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-06T01:50:41Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>emacs-evil/goto-chg</title>
    <updated>2023-08-06T01:50:41Z</updated>
    <id>tag:github.com,2023-08-06:/emacs-evil/goto-chg</id>
    <link href="https://github.com/emacs-evil/goto-chg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>Wilfred/elisp-refs</title>
    <updated>2023-08-06T01:50:41Z</updated>
    <id>tag:github.com,2023-08-06:/Wilfred/elisp-refs</id>
    <link href="https://github.com/Wilfred/elisp-refs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;semantic code search for emacs lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;elisp-refs&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://coveralls.io/github/Wilfred/elisp-refs?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/Wilfred/elisp-refs/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/elisp-refs&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/elisp-refs-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;elisp-refs is an intelligent code search for Emacs lisp.&lt;/p&gt; &#xA;&lt;p&gt;It can find references to functions, macros or variables. Unlike a dumb text search, elisp-refs actually parses the code, so it&#39;s never confused by comments or variables with the same name as functions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Wilfred/elisp-refs/master/refs_screenshot.png&#34; alt=&#34;screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is particularly useful for finding all the places a function is used, or finding examples of usage.&lt;/p&gt; &#xA;&lt;p&gt;Interested readers may enjoy my blog post: &lt;a href=&#34;http://www.wilfred.me.uk/blog/2016/09/30/searching-a-million-lines-of-lisp/&#34;&gt;Searching A Million Lines Of Lisp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install from MELPA (recommended) or just add elisp-refs to your &lt;code&gt;load-path&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Commands available&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-refs-function&lt;/code&gt; (find function calls)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-refs-macro&lt;/code&gt; (find macro calls)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-refs-variable&lt;/code&gt; (find variable references)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-refs-special&lt;/code&gt; (find special form calls)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-refs-symbol&lt;/code&gt; (find all references to a symbol)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These command search all the files currently loaded in your Emacs instance.&lt;/p&gt; &#xA;&lt;p&gt;If called with a prefix, you can limit search results to specific directories. For example:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;C-u M-x elisp-refs-macro RET pcase RET ~/.emacs.d/elpa/magit-20160927.510 RET&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;will search for uses of &lt;code&gt;pcase&lt;/code&gt; in magit:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Wilfred/elisp-refs/master/refs_filtered.png&#34; alt=&#34;filtering screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Semantic analysis&lt;/h2&gt; &#xA;&lt;p&gt;elisp-refs has &lt;em&gt;street smarts&lt;/em&gt;: given &lt;code&gt;(defun foo (bar) (baz))&lt;/code&gt;, it understands that &lt;code&gt;bar&lt;/code&gt; is a variable and &lt;code&gt;baz&lt;/code&gt; is a function.&lt;/p&gt; &#xA;&lt;p&gt;elisp-refs understands the following forms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;defun&lt;/code&gt; &lt;code&gt;defsubst&lt;/code&gt; &lt;code&gt;defmacro&lt;/code&gt; &lt;code&gt;cl-defun&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lambda&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;let&lt;/code&gt; &lt;code&gt;let*&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;funcall&lt;/code&gt; &lt;code&gt;apply&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;sharp quoted expressions (e.g. &lt;code&gt;#&#39;some-func&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;elisp-refs understands elisp special forms, and a few common macros. However, it &lt;strong&gt;cannot understand arbitrary macros&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Therefore elisp-refs will assume that &lt;code&gt;(other-macro (foo bar))&lt;/code&gt; is a function call to &lt;code&gt;foo&lt;/code&gt;. If this is incorrect, you may wish to use the command &lt;code&gt;elisp-refs-symbol&lt;/code&gt; to find all references to the &lt;code&gt;foo&lt;/code&gt; symbol.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;other-macro&lt;/code&gt; is a common macro, please consider submitting a patch to &lt;code&gt;elisp-refs--function-p&lt;/code&gt; to make elisp-refs smarter.&lt;/p&gt; &#xA;&lt;p&gt;elisp-refs also does not support &lt;strong&gt;indirect calls&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;;; Since we do a simple syntax tree walk, this isn&#39;t treated as a&#xA;;; call to foo.&#xA;(let ((x (symbol-function &#39;foo)))&#xA;  (funcall x))&#xA;&#xA;;; Similarly, indirect function calls are not treated as&#xA;;; function calls.&#xA;(defun call-func (x)&#xA;  (funcall x))&#xA;(call-func &#39;foo)&#xA;&#xA;;; However, if you use sharp quoting, elisp-refs knows it&#39;s a function&#xA;reference!&#xA;(call-func #&#39;foo)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running tests&lt;/h2&gt; &#xA;&lt;p&gt;You can run the tests with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cask install&#xA;$ cask exec ert-runner&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;elisp-refs is CPU-intensive elisp and has been carefully optimised. You can run the benchmark script with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cask install&#xA;$ ./bench.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;New features are carefully measured to ensure performance does not get worse.&lt;/p&gt; &#xA;&lt;p&gt;See elisp-refs-bench.el for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Alternative Projects&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;xref-find-references&lt;/strong&gt;: This command is included in Emacs 25.1, but it&#39;s based on a text search. It is confused by comments and strings, and cannot distinguish between functions and variables.&lt;/p&gt; &#xA;&lt;p&gt;xrefs-find-references is also line oriented, so it does not show the whole sexp that matched your search. Since it requires text files, it doesn&#39;t search built-in .el.gz files.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;TAGS&lt;/strong&gt;: It is possible to record function references in TAGS files. Whilst &lt;a href=&#34;https://github.com/universal-ctags/ctags&#34;&gt;universal-ctags&lt;/a&gt; (formerly known as exuberant-ctags) does provide the ability to find references, it is not supported in its lisp parser.&lt;/p&gt; &#xA;&lt;p&gt;etags, the TAGS implementation shipped with Emacs, cannot find references (to my knowledge).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://elpa.gnu.org/packages/el-search.html&#34;&gt;el-search&lt;/a&gt;&lt;/strong&gt; allows you to search for arbitrary forms in elisp files. It&#39;s slower, but a much more general tool. Its design greatly influenced elisp-refs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/purcell/elisp-slime-nav&#34;&gt;elisp-slime-nav&lt;/a&gt;&lt;/strong&gt; finds definitions, not references. It&#39;s a great complementary tool.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>denrat/term-cursor.el</title>
    <updated>2023-08-06T01:50:41Z</updated>
    <id>tag:github.com,2023-08-06:/denrat/term-cursor.el</id>
    <link href="https://github.com/denrat/term-cursor.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Bring GUI Emacs cursor behaviour to the terminal&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;term-cursor.el&lt;/h1&gt; &#xA;&lt;p&gt;Display Emacs cursor in terminal as it would be in GUI, with or without &lt;code&gt;evil-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Requires Emacs 26.&lt;/p&gt; &#xA;&lt;h2&gt;Compliance&lt;/h2&gt; &#xA;&lt;p&gt;For now, only VT520-compliant terminals are supported out of the box. You can still use &lt;a href=&#34;https://raw.githubusercontent.com/denrat/term-cursor.el/master/#my-terminal-is-not-supported&#34;&gt;your own escape codes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Tested in kitty, iTerm2, Alacritty and Terminal.app on macOS Mojave. Contribution is welcome.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using &lt;code&gt;quelpa&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(quelpa &#39;(term-cursor :repo &#34;h0d/term-cursor.el&#34; :fetcher github))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Manual&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; Once `term-cursor.el&#39; has been added to load path&#xA;(require &#39;term-cursor)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;MELPA pending.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; In a buffer&#xA;(term-cursor-mode)&#xA;&#xA;;; For all buffers&#xA;(global-term-cursor-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;My terminal is not supported&lt;/h2&gt; &#xA;&lt;p&gt;If you know the escape codes for your terminal, you can specify them in your configuration or through &lt;code&gt;M-x customize&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq term-cursor-bar-escape-code        &#34;&amp;lt;your escape code&amp;gt;&#34;)&#xA;(setq term-cursor-underline-escape-code  &#34;&amp;lt;your escape code&amp;gt;&#34;)&#xA;(setq term-cursor-block-escape-code      &#34;&amp;lt;your escape code&amp;gt;&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>