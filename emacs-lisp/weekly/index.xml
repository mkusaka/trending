<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-23T01:53:02Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>minad/jinx</title>
    <updated>2023-04-23T01:53:02Z</updated>
    <id>tag:github.com,2023-04-23:/minad/jinx</id>
    <link href="https://github.com/minad/jinx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸª„ Enchanted Spell Checker&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: jinx.el - Enchanted Spell Checker #+author: Daniel Mendler #+language: en #+export_file_name: jinx.texi #+texinfo_dir_category: Emacs misc features #+texinfo_dir_title: Jinx: (jinx). #+texinfo_dir_desc: Enchanted Spell Checker&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img alt=&#34;GNU Emacs&#34; src=&#34;https://github.com/minad/corfu/raw/screenshots/emacs.svg?raw=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://elpa.gnu.org/packages/jinx.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/jinx.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://elpa.gnu.org/devel/jinx.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/jinx.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/jinx&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/jinx-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://stable.melpa.org/#/jinx&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/jinx-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Jinx is a fast just-in-time spell-checker for Emacs. Jinx highlights misspelled words in the text of the visible portion of the buffer. For efficiency, Jinx highlights misspellings lazily, recognizes window boundaries and text folding, if any. For example, when unfolding or scrolling, only the newly visible part of the text is checked if it has not been checked before. Each misspelling can be corrected from a list of dictionary words presented as a completion menu.&lt;/p&gt; &#xA;&lt;p&gt;Installing Jinx is straight-forward and configuring takes not much intervention. Jinx can safely co-exist with Emacs&#39;s built-in spell-checker.&lt;/p&gt; &#xA;&lt;p&gt;Jinx&#39;s high performance and low resource usage comes from directly calling the widely-used API of the Enchant library (see [[https://abiword.github.io/enchant/][libenchant]]). Jinx automatically compiles =jinx-mod.c= and loads the dynamic module at startup. By binding directly to the native Enchant API, Jinx avoids the slower backend process communication with Aspell. Thanks to the Enchant API, this method is widely used by other text editors and supports [[https://nuspell.github.io/][Nuspell]], [[http://hunspell.github.io/][Hunspell]], [[http://aspell.net/][Aspell]] and a few lesser known backends.&lt;/p&gt; &#xA;&lt;p&gt;Jinx supports spell-checking multiple languages in the same buffer. See the =jinx-languages= variable to customize for multiple languages. Jinx can flexibly ignore misspellings via faces (=jinx-exclude-faces= and =jinx-include-faces=), regular expressions (=jinx-exclude-regexps=), and programmable predicates. Jinx comes preconfigured for the most important Emacs major modes. For modes listed in =jinx-camel-modes= composite words in camelCase and PascalCase are accepted.&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;img src=&#34;https://github.com/minad/jinx/raw/screenshots/screenshot.png?raw=true&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installing Jinx&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Jinx can be installed from GNU ELPA and MELPA directly or with =package-install=.&lt;/p&gt; &#xA;&lt;p&gt;Jinx requires =libenchant=. Enchant library is a required dependency for Jinx to compile its module at install time. If =pkg-config= is available when installing Jinx, Jinx will use =pkg-config= to locate =libenchant=.&lt;/p&gt; &#xA;&lt;p&gt;On Debian or Ubuntu, install the packages =libenchant-2-dev= and =pkg-config=. On Fedora or RHEL, install the package =enchant2-devel=. On Mac, install =enchant2= and =pkgconfig=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using Jinx&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Jinx has two modes: the command, =global-jinx-mode= activates globally; and the command, =jinx-mode=, for activating for specific modes.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Alternative 1: Enable Jinx globally (add-hook &#39;emacs-startup-hook #&#39;global-jinx-mode)&lt;/p&gt; &#xA;&lt;p&gt;;; Alternative 2: Enable Jinx per mode (dolist (hook &#39;(text-mode-hook prog-mode-hook conf-mode-hook)) (add-hook hook #&#39;jinx-mode)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Jinx autoloads the commands =jinx-correct= and =jinx-languages=. Invoking =jinx-correct= corrects the misspellings. Binding =jinx-correct= to =M-$= chord takes over that chord from Emacs&#39;s default assignment to =ispell word=. Since Jinx is independent of the Emacs&#39;s Ispell package, =M-$= can be re-used.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (keymap-global-set &#34;&#xA; &lt;remap&gt; &#xA;  &lt;ispell-word&gt;&#xA;   &#34; #&#39;jinx-correct) #+end_src&#xA;  &lt;/ispell-word&gt;&#xA; &lt;/remap&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=M-$= triggers correction for the misspelled word next to point.&lt;/li&gt; &#xA; &lt;li&gt;=C-u M-$= triggers correction for the entire buffer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Suggested corrections are displayed via a completion menu. You can press digit keys to quickly select a suggestion. Furthermore the menu offers options to save the word temporarily for the current session, in the personal dictionary or in the file-local variables. Note that you can enter arbitrary input at the correction prompt in order to make the correction. By pressing =M-n= (=M-p=) again in the correction menu, you can skip to the next (previous) misspelling.&lt;/p&gt; &#xA;&lt;p&gt;A sample configuration with the popular =use-package= macro is shown here:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (use-package jinx :hook (emacs-startup . global-jinx-mode) :bind ([remap ispell-word] . jinx-correct)) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enchant backends and personal dictionaries&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Enchant uses different backends for different languages (to be spell-checked). The backends are ordered as specified in the configuration file =~/.config/enchant/enchant.ordering=. For most languages, Enchant uses Hunspell by default.&lt;/p&gt; &#xA;&lt;p&gt;Depending on the backend the personal dictionary will be taken from different locations, e.g., =&lt;del&gt;/.aspell.LANG.pws= or =&lt;/del&gt;/.config/enchant/=. It is possible to symlink different personal dictionaries such that they are shared by different spell checkers. See the [[https://abiword.github.io/enchant/src/enchant.html][Enchant manual]] for details.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alternative spell-checking packages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There exist multiple alternative spell-checking packages for Emacs, most famously the builtin ispell.el and flyspell.el packages. The main advantages of Jinx are its automatic checking of the visible text, its sharp focus on performance and the ability to easily use multiple dictionaries at once. The following three alternative packages come closest to the behavior of Jinx.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://github.com/astoff/jit-spell][jit-spell]]: Jinx UI borrows ideas from Augusto Stoffel&#39;s Jit-spell. Jit-spell uses the less efficient Ispell process communication instead Jinx&#39;s calling native API. Since Jit-spell highlights misspellings in the entire buffer and does not confine to just the visible text, Jit-spell affected load and latency negatively in my tests ([[https://github.com/astoff/jit-spell/issues/9][issue on github]]).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://codeberg.org/ideasman42/emacs-spell-fu][spell-fu]]: The idea to check words just in the visible text came from Campbell Barton&#39;s spell-fu package. Spell-fu is fast but incurs high memory overhead on account of its dictionary in a hash table. For languages with compound words and inflected word forms, this overhead magnifies ([[https://codeberg.org/ideasman42/emacs-spell-fu/issues/40][issue on codeberg]]). By accessing the Enchant API directly, Jinx avoids any overhead. Jinx also benefits from the advanced spell-checker algorithms of Enchant (affixation, compound words, etc.).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;flyspell: Flyspell is Emacs&#39;s built-in package. Flyspell highlights misspellings while typing. Only the word under the cursor is spell-checked. Jinx, on the other hand, is more effective because it automatically checks for misspellings in the entire visible text of the buffer at once. Flyspell can check the entire buffer but must be instructed to do so via the command =flyspell-buffer=.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since this package is part of [[https://elpa.gnu.org/packages/jinx.html][GNU ELPA]] contributions require a copyright assignment to the FSF.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacs-straight/map</title>
    <updated>2023-04-23T01:53:02Z</updated>
    <id>tag:github.com,2023-04-23:/emacs-straight/map</id>
    <link href="https://github.com/emacs-straight/map" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mirror of the map package from GNU ELPA, current as of 2023-04-23&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>jacktasia/dumb-jump</title>
    <updated>2023-04-23T01:53:02Z</updated>
    <id>tag:github.com,2023-04-23:/jacktasia/dumb-jump</id>
    <link href="https://github.com/jacktasia/dumb-jump" rel="alternate"></link>
    <summary type="html">&lt;p&gt;an Emacs &#34;jump to definition&#34; package for 50+ languages&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;dumb-jump&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/jacktasia/dumb-jump/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://coveralls.io/github/jacktasia/dumb-jump?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/jacktasia/dumb-jump/badge.svg?branch=master&amp;amp;service=github&amp;amp;x=1&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/dumb-jump&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/dumb-jump-badge.svg?x=6&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/dumb-jump&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/dumb-jump-badge.svg?x=1&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jacktasia/dumb-jump/master/media/dumb-jump-example-v2.gif?raw=true&#34; alt=&#34;Dumb Jump GIF&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Dumb Jump&lt;/strong&gt; is an Emacs &#34;jump to definition&#34; package with support for 50+ programming languages that favors &#34;just working&#34;. This means minimal -- and ideally zero -- configuration with absolutely no stored indexes (TAGS) or persistent background processes. Dumb Jump requires at least GNU Emacs &lt;code&gt;24.3&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;How it works&lt;/h4&gt; &#xA;&lt;p&gt;Dumb Jump uses &lt;a href=&#34;https://github.com/ggreer/the_silver_searcher&#34;&gt;The Silver Searcher&lt;/a&gt; &lt;code&gt;ag&lt;/code&gt;, &lt;a href=&#34;https://github.com/BurntSushi/ripgrep&#34;&gt;ripgrep&lt;/a&gt; &lt;code&gt;rg&lt;/code&gt;, or &lt;code&gt;grep&lt;/code&gt; to find potential definitions of a function or variable under point. It uses a set of regular expressions based on the file extension, or &lt;code&gt;major-mode&lt;/code&gt;, of the current buffer. The matches are run through a shared set of heuristic methods to find the best candidate to jump to. If it can&#39;t decide it will present the user with a list in a pop-menu, helm, or ivy (see &lt;code&gt;dumb-jump-selector&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;Success Rate&lt;/h4&gt; &#xA;&lt;p&gt;For the currently &lt;a href=&#34;https://raw.githubusercontent.com/jacktasia/dumb-jump/master/#supported-languages&#34;&gt;supported languages&lt;/a&gt; it seems to do a good job of finding what you want. If you find a case where it does not work as expected do not hesitate to &lt;a href=&#34;https://github.com/jacktasia/dumb-jump/issues&#34;&gt;open an issue&lt;/a&gt;. It can be slow if it needs to use &lt;code&gt;grep&lt;/code&gt; and/or a project is large. Although it can be sped up by &lt;a href=&#34;https://github.com/ggreer/the_silver_searcher#installing&#34;&gt;installing &lt;code&gt;ag&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://github.com/BurntSushi/ripgrep#installation&#34;&gt;installing &lt;code&gt;rg&lt;/code&gt;&lt;/a&gt; and/or creating a &lt;code&gt;.dumbjump&lt;/code&gt; file in your project&#39;s root directory with paths that should be excluded (&lt;a href=&#34;https://raw.githubusercontent.com/jacktasia/dumb-jump/master/#configuration&#34;&gt;see configuration&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Supported Languages&lt;/h2&gt; &#xA;&lt;p&gt;There is currently basic support for the following languages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Apex&lt;/li&gt; &#xA; &lt;li&gt;Bash&lt;/li&gt; &#xA; &lt;li&gt;C/C++&lt;/li&gt; &#xA; &lt;li&gt;C#&lt;/li&gt; &#xA; &lt;li&gt;Clojure&lt;/li&gt; &#xA; &lt;li&gt;CoffeeScript&lt;/li&gt; &#xA; &lt;li&gt;Common Lisp&lt;/li&gt; &#xA; &lt;li&gt;Coq&lt;/li&gt; &#xA; &lt;li&gt;Crystal&lt;/li&gt; &#xA; &lt;li&gt;Dart&lt;/li&gt; &#xA; &lt;li&gt;Elixir&lt;/li&gt; &#xA; &lt;li&gt;Emacs Lisp&lt;/li&gt; &#xA; &lt;li&gt;Erlang&lt;/li&gt; &#xA; &lt;li&gt;F#&lt;/li&gt; &#xA; &lt;li&gt;Faust&lt;/li&gt; &#xA; &lt;li&gt;Fennel&lt;/li&gt; &#xA; &lt;li&gt;Fortran&lt;/li&gt; &#xA; &lt;li&gt;Go&lt;/li&gt; &#xA; &lt;li&gt;Groovy&lt;/li&gt; &#xA; &lt;li&gt;Haskell&lt;/li&gt; &#xA; &lt;li&gt;Java&lt;/li&gt; &#xA; &lt;li&gt;JavaScript&lt;/li&gt; &#xA; &lt;li&gt;Julia&lt;/li&gt; &#xA; &lt;li&gt;Kotlin&lt;/li&gt; &#xA; &lt;li&gt;LaTeX&lt;/li&gt; &#xA; &lt;li&gt;Lua&lt;/li&gt; &#xA; &lt;li&gt;Matlab&lt;/li&gt; &#xA; &lt;li&gt;Nim&lt;/li&gt; &#xA; &lt;li&gt;Nix&lt;/li&gt; &#xA; &lt;li&gt;Objective-C&lt;/li&gt; &#xA; &lt;li&gt;OCaml&lt;/li&gt; &#xA; &lt;li&gt;OpenSCAD&lt;/li&gt; &#xA; &lt;li&gt;Org mode&lt;/li&gt; &#xA; &lt;li&gt;Pascal&lt;/li&gt; &#xA; &lt;li&gt;Perl&lt;/li&gt; &#xA; &lt;li&gt;PHP&lt;/li&gt; &#xA; &lt;li&gt;Protocol Buffers&lt;/li&gt; &#xA; &lt;li&gt;Python&lt;/li&gt; &#xA; &lt;li&gt;R&lt;/li&gt; &#xA; &lt;li&gt;Racket&lt;/li&gt; &#xA; &lt;li&gt;Ruby&lt;/li&gt; &#xA; &lt;li&gt;Rust&lt;/li&gt; &#xA; &lt;li&gt;Sass&lt;/li&gt; &#xA; &lt;li&gt;Scala&lt;/li&gt; &#xA; &lt;li&gt;Scheme&lt;/li&gt; &#xA; &lt;li&gt;SML&lt;/li&gt; &#xA; &lt;li&gt;Solidity&lt;/li&gt; &#xA; &lt;li&gt;SQL&lt;/li&gt; &#xA; &lt;li&gt;Swift&lt;/li&gt; &#xA; &lt;li&gt;SystemVerilog&lt;/li&gt; &#xA; &lt;li&gt;Tcl&lt;/li&gt; &#xA; &lt;li&gt;Terraform / HCL&lt;/li&gt; &#xA; &lt;li&gt;TypeScript&lt;/li&gt; &#xA; &lt;li&gt;Vala&lt;/li&gt; &#xA; &lt;li&gt;VHDL&lt;/li&gt; &#xA; &lt;li&gt;Zig&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you have any issues with the existing languages, or you want support for another one, then please &lt;a href=&#34;https://github.com/jacktasia/dumb-jump/issues&#34;&gt;open an issue&lt;/a&gt;. PRs are also welcome. If you&#39;d like to add a language these PRs for &lt;a href=&#34;https://github.com/jacktasia/dumb-jump/pull/33&#34;&gt;lua&lt;/a&gt; and &lt;a href=&#34;https://github.com/jacktasia/dumb-jump/pull/57&#34;&gt;rust&lt;/a&gt; are good examples.&lt;/p&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;p&gt;The recommended way to install Dumb Jump is via &lt;code&gt;package.el&lt;/code&gt;. It&#39;s available on &lt;a href=&#34;http://melpa.org/#/dumb-jump&#34;&gt;MELPA&lt;/a&gt;: &lt;kbd&gt;M-x&lt;/kbd&gt; &lt;code&gt;package-install dumb-jump&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Spacemacs&lt;/h4&gt; &#xA;&lt;p&gt;If you&#39;re using an up-to-date Spacemacs, then you already have Dumb Jump by default just make sure you install &lt;code&gt;ag&lt;/code&gt; or &lt;code&gt;rg&lt;/code&gt; (see below) to ensure you have the best experience.&lt;/p&gt; &#xA;&lt;h4&gt;Installing &lt;code&gt;ag&lt;/code&gt; or &lt;code&gt;rg&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Dumb Jump performs best with The Silver Searcher &lt;code&gt;ag&lt;/code&gt; (&lt;a href=&#34;https://github.com/ggreer/the_silver_searcher#installing&#34;&gt;ag install instructions&lt;/a&gt;) or ripgrep &lt;code&gt;rg&lt;/code&gt; (&lt;a href=&#34;https://github.com/BurntSushi/ripgrep#installation&#34;&gt;rg install instructions&lt;/a&gt;) installed on your system.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h4&gt;Basic&lt;/h4&gt; &#xA;&lt;p&gt;To enable the &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/emacs/Xref.html&#34;&gt;xref&lt;/a&gt; backend, evaluate&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(add-hook &#39;xref-backend-functions #&#39;dumb-jump-xref-activate)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or add it to your initialisation file. Using this, you can now use &lt;kbd&gt;M-.&lt;/kbd&gt; (or &lt;kbd&gt;gd&lt;/kbd&gt; when using Evil).&lt;/p&gt; &#xA;&lt;p&gt;Xref can be customized to use &lt;code&gt;completing-read&lt;/code&gt; to select a target. That way a completion framework of your choice (Icomplete, Helm, Ivy, ...) will be used instead of the default pop-up buffer. To do this, evaluate&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(setq xref-show-definitions-function #&#39;xref-show-definitions-completing-read)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the function &lt;code&gt;xref-show-definitions-completing-read&lt;/code&gt; requires at least Xref 1.1.0. This can either be downloaded from ELPA or is bundled with Emacs 28.1 or newer.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h5&gt;Excluding project directories&lt;/h5&gt; &#xA;&lt;p&gt;Dumb Jump will automatically look for a project root. If it&#39;s not finding one then either put a &lt;code&gt;.dumbjump&lt;/code&gt; file in your project root and optionally add excluded directories to make it faster.&lt;/p&gt; &#xA;&lt;p&gt;Project root directory denoters: &lt;code&gt;.dumbjump&lt;/code&gt; &lt;code&gt;.projectile&lt;/code&gt; &lt;code&gt;.git&lt;/code&gt; &lt;code&gt;.hg&lt;/code&gt; &lt;code&gt;.fslckout&lt;/code&gt; &lt;code&gt;.bzr&lt;/code&gt; &lt;code&gt;_darcs&lt;/code&gt; &lt;code&gt;.svn&lt;/code&gt; &lt;code&gt;Makefile&lt;/code&gt; &lt;code&gt;PkgInfo&lt;/code&gt; &lt;code&gt;-pkg.el&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to stop a directory from registering as the project root (and have Dumb Jump keep looking) add an empty &lt;code&gt;.dumbjumpignore&lt;/code&gt; file in that directory.&lt;/p&gt; &#xA;&lt;h5&gt;Example &lt;code&gt;.dumbjump&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;-tests&#xA;-node_modules&#xA;-build&#xA;-images&#xA;+../some-lib/src&#xA;+/usr/lib/src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt; When adding paths outside of the project (using &lt;code&gt;+&lt;/code&gt;) ensure you use &lt;code&gt;dumb-jump-force-searcher&lt;/code&gt; of either &lt;code&gt;&#39;ag&lt;/code&gt; or &lt;code&gt;&#39;rg&lt;/code&gt; (see below). This is required because the default searcher (&lt;code&gt;git-grep&lt;/code&gt;) won&#39;t be able to search outside of the project root. This edge case will be fixed in a future release. That is, &lt;code&gt;git-grep&lt;/code&gt; will NOT be set as the default searcher if a &lt;code&gt;.dumbjump&lt;/code&gt; is present with a &lt;code&gt;+&lt;/code&gt; path outside of the repo.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;.emacs&lt;/code&gt; options&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(setq dumb-jump-default-project &#34;~/code&#34;)&lt;/code&gt; to change default project if one is not found (defaults to &lt;code&gt;~&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(setq dumb-jump-quiet t)&lt;/code&gt; if Dumb Jump is too chatty.&lt;/li&gt; &#xA; &lt;li&gt;To support more languages and/or definition types customize &lt;code&gt;dumb-jump-find-rules&lt;/code&gt; variable.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(setq dumb-jump-force-searcher &#39;rg)&lt;/code&gt; to force the search program Dumb Jump should use. It will &lt;em&gt;always&lt;/em&gt; use this searcher. If not set (&lt;code&gt;nil&lt;/code&gt;) Dumb Jump will use &lt;code&gt;git-grep&lt;/code&gt; if it&#39;s a git project and if not will try searchers in the following order &lt;code&gt;ag&lt;/code&gt;, &lt;code&gt;rg&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt; (first installed wins). This is necessary if you want full control over the searcher Dumb Jump uses.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(setq dumb-jump-prefer-searcher &#39;rg)&lt;/code&gt; to let Dumb Jump know your searcher preference. If set this will still use &lt;code&gt;git-grep&lt;/code&gt; if it&#39;s a git project (because it&#39;s the fastest), but will you use whatever you set here in any other situation. If not set Dumb Jump will follow the same order as mentioned in the &lt;code&gt;dumb-jump-force-searcher&lt;/code&gt; description. At this time setting this value is only necessary if you prefer &lt;code&gt;rg&lt;/code&gt; but have &lt;code&gt;ag&lt;/code&gt; installed too.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(setq dumb-jump-git-grep-search-args &#34;&#34;)&lt;/code&gt; to set additional command line arguments when using git-grep for searching (defaults to &lt;code&gt;&#34;&#34;&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(setq dumb-jump-ag-search-args &#34;&#34;)&lt;/code&gt; to set additional command line arguments when using ag for searching (defaults to &lt;code&gt;&#34;&#34;&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(setq dumb-jump-rg-search-args &#34;&#34;)&lt;/code&gt; to set additional command line arguments when using rg for searching (defaults to &lt;code&gt;&#34;--pcre2&#34;&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;If your project has multi-line method signatures &lt;a href=&#34;https://github.com/jacktasia/dumb-jump/issues/129&#34;&gt;you should use &lt;code&gt;ag&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://github.com/jacktasia/dumb-jump/issues/255&#34;&gt;&lt;code&gt;rg&lt;/code&gt; version &lt;code&gt;0.10.0&lt;/code&gt; or higher&lt;/a&gt;.&lt;/h4&gt; &#xA;&lt;p&gt;To learn more about how Dumb Jump picks a searcher see &lt;a href=&#34;https://github.com/jacktasia/dumb-jump/issues/109&#34;&gt;this issue&lt;/a&gt; and this &lt;a href=&#34;https://github.com/jacktasia/dumb-jump/pull/111&#34;&gt;pull request&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Hydra for effieciency&lt;/h5&gt; &#xA;&lt;p&gt;If you have &lt;a href=&#34;https://github.com/abo-abo/hydra&#34;&gt;Hydra&lt;/a&gt; installed, the following is an example hydra for easily using Dumb-Jump and not needing to remember the bindings or function names:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(defhydra dumb-jump-hydra (:color blue :columns 3)&#xA;    &#34;Dumb Jump&#34;&#xA;    (&#34;j&#34; dumb-jump-go &#34;Go&#34;)&#xA;    (&#34;o&#34; dumb-jump-go-other-window &#34;Other window&#34;)&#xA;    (&#34;e&#34; dumb-jump-go-prefer-external &#34;Go external&#34;)&#xA;    (&#34;x&#34; dumb-jump-go-prefer-external-other-window &#34;Go external other window&#34;)&#xA;    (&#34;i&#34; dumb-jump-go-prompt &#34;Prompt&#34;)&#xA;    (&#34;l&#34; dumb-jump-quick-look &#34;Quick look&#34;)&#xA;    (&#34;b&#34; dumb-jump-back &#34;Back&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can be explicitly bound or used inside another hydra (if you already use something like &lt;a href=&#34;https://github.com/abo-abo/avy&#34;&gt;Avy&lt;/a&gt;/&lt;a href=&#34;https://github.com/winterTTr/ace-jump-mode&#34;&gt;Ace&lt;/a&gt; or similar for general &#34;jumping&#34;).&lt;/p&gt; &#xA;&lt;h4&gt;Debugging a jump&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;kbd&gt;M-x&lt;/kbd&gt; &lt;code&gt;set-variable dumb-jump-debug t&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;try to jump&lt;/li&gt; &#xA; &lt;li&gt;go to buffer &lt;code&gt;*Messages*&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;More details &lt;a href=&#34;http://p.cweiske.de/506&#34;&gt;here&lt;/a&gt;. Thanks to @cweiske and @Glumanda99&lt;/p&gt; &#xA;&lt;h2&gt;Obsolete commands and options&lt;/h2&gt; &#xA;&lt;p&gt;Older versions of dumb jump didn&#39;t use xref, and instead had custom commands. These, while marked obsolete, can still be used:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-go&lt;/code&gt; (former) core functionality. Attempts to jump to the definition for the thing under point. This has been replaced in the new interface with &lt;code&gt;xref-find-definitions&lt;/code&gt; (&lt;kbd&gt;M-.&lt;/kbd&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-back&lt;/code&gt; jumps back to where you were when you jumped. These are chained so if you go down a rabbit hole you can get back out or where you want to be. This has been replaced with &lt;code&gt;xref-pop-marker-stack&lt;/code&gt; (&lt;kbd&gt;M-,&lt;/kbd&gt;), but is mostly equivalent.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-quick-look&lt;/code&gt; like &lt;code&gt;dumb-jump-go&lt;/code&gt; but &lt;strong&gt;only&lt;/strong&gt; shows tooltip with &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, and &lt;code&gt;context&lt;/code&gt; it does not jump.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-go-other-window&lt;/code&gt; exactly like &lt;code&gt;dumb-jump-go&lt;/code&gt; but uses &lt;code&gt;find-file-other-window&lt;/code&gt; instead of &lt;code&gt;find-file&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-go-prefer-external&lt;/code&gt; like &lt;code&gt;dumb-jump-go&lt;/code&gt; but will prefer definitions not in the current buffer&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-go-prefer-external-other-window&lt;/code&gt; expected combination of &lt;code&gt;dumb-jump-go-prefer-external&lt;/code&gt; and &lt;code&gt;dumb-jump-go-other-window&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-go-prompt&lt;/code&gt; exactly like &lt;code&gt;dumb-jump-go&lt;/code&gt; but prompts user for function to jump to&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A few user options only have an effect when used with the legacy interface. These are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-after-jump-hook&lt;/code&gt; (use &lt;code&gt;xref-after-jump-hook&lt;/code&gt; instead)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-before-jump-hook&lt;/code&gt; (use &lt;code&gt;xref-after-return-hook&lt;/code&gt; instead)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-selector&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-aggressive&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-use-visible-window&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dumb-jump-confirm-jump-to-modified-file&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The minor mode &lt;code&gt;dumb-jump-mode&lt;/code&gt; binds a few of these commands by default.&lt;/p&gt; &#xA;&lt;p&gt;If you still use Emacs 24 or older, you won&#39;t have xref, and have to use the legacy interface instead. In that case, there will also be no &#34;obsolete&#34; warnings.&lt;/p&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;I wanted &#34;jump to definition&#34; functionality to &#34;just work&#34; in emacs. I use IntelliJ for Java and this functionality is basically the only thing I miss when I switch back to emacs for work in other languages. There are certainly other packages that offer this type of functionality, but they all require significantly more configuration and are often limited to a particular language. An alternative may be worth setting up if you are in a specific project or language often (see &lt;a href=&#34;https://raw.githubusercontent.com/jacktasia/dumb-jump/master/#alternatives&#34;&gt;alternatives&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Feedback is very welcome via GitHub issues. I will consider supporting other languages either via issue request or PR. If submitting a PR then please add tests as well.&lt;/p&gt; &#xA;&lt;h2&gt;Running Tests&lt;/h2&gt; &#xA;&lt;p&gt;Opening a PR will use CircleCI to run all the tests against all the supported emacs versions and search programs.&lt;/p&gt; &#xA;&lt;h3&gt;Running tests locally&lt;/h3&gt; &#xA;&lt;p&gt;There are a lot of options for running the tests locally:&lt;/p&gt; &#xA;&lt;h4&gt;Basic/Classic&lt;/h4&gt; &#xA;&lt;p&gt;requires &lt;a href=&#34;https://github.com/cask/cask&#34;&gt;Cask&lt;/a&gt; using your local emacs&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /path/to/dumb-jump&#xA;cask&#xA;make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Concurrent&lt;/h4&gt; &#xA;&lt;p&gt;requires golang and &lt;a href=&#34;https://github.com/cask/cask&#34;&gt;Cask&lt;/a&gt; using your local emacs&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /path/to/dumb-jump&#xA;cask&#xA;make test-concurrent&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Docker (latest emacs)&lt;/h4&gt; &#xA;&lt;p&gt;only requires docker and runs tests against emacs 26.1&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /path/to/dumb-jump&#xA;cask&#xA;make test-in-docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Docker (all supported emacs versions)&lt;/h4&gt; &#xA;&lt;p&gt;only requires docker and runs tests against all supported emacs versions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /path/to/dumb-jump&#xA;cask&#xA;make test-all-in-docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Alternatives&lt;/h2&gt; &#xA;&lt;p&gt;Here is a list of potential alternative packages for emacs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/emacs/Tags-Tables.html&#34;&gt;Tags&lt;/a&gt; supports multiple languages&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.gnu.org/software/global/&#34;&gt;GNU Global&lt;/a&gt; supports multiple languages&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://ternjs.net/&#34;&gt;Tern&lt;/a&gt; for JavaScript&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jorgenschaefer/elpy&#34;&gt;elpy&lt;/a&gt; for Python&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dgutov/robe&#34;&gt;robe&lt;/a&gt; for Ruby&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Most of these were sourced from this &lt;a href=&#34;http://emacs.stackexchange.com/questions/10125/can-emacs-support-go-to-declaration-of-function-in-an-entire-project&#34;&gt;emacs StackExchange answer&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>