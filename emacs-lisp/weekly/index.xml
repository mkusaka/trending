<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-21T01:55:55Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Alexander-Miller/pfuture</title>
    <updated>2022-08-21T01:55:55Z</updated>
    <id>tag:github.com,2022-08-21:/Alexander-Miller/pfuture</id>
    <link href="https://github.com/Alexander-Miller/pfuture" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;-&lt;em&gt;- fill-column: 100; eval: (auto-fill-mode t) -&lt;/em&gt;-&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Content :TOC:noexport:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#pfuture][Pfuture]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#what-it-is][What it is]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#practical-examples][Practical examples]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#with-a-future-object][With a Future object]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#with-a-callback][With a Callback]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#about-asyncel][About async.el]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pfuture ** What it is&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;pfuture.el offers a set of simple functions wrapping Emacs&#39; existing process creation capabilities. It allows to conveniently deal with external processes in an asynchronous manner without having to worry about stdout buffers and filter- &amp;amp; sentinel-functions.&lt;/p&gt; &#xA;&lt;p&gt;The following examples practically demonstrate its capabilities. Detailed and formal documentation can be found in each function&#39;s eldoc.&lt;/p&gt; &#xA;&lt;p&gt;** Practical examples&lt;/p&gt; &#xA;&lt;p&gt;Pfuture has 2 entry points.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;pfuture-new&lt;/del&gt; creates a &lt;del&gt;future&lt;/del&gt; object that can be stored, passed around to other functions and awaited to completion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;pfuture-callback&lt;/del&gt; allows starting an external process in a fire-and-forget fashion, alongside callbacks to execute when the process succeeds or fails, with full access to its output.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** With a Future object&lt;/p&gt; &#xA;&lt;p&gt;We can use pfuture to start an artficially long-running process (simulated with a sleep of 3 seconds) twice and wait until both futures complete. Despite sleeping twice only 3 seconds will have passed since the processes run in parallel.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (let ((start (float-time)) (future1 (pfuture-new &#34;sleep&#34; &#34;3&#34;)) (future2 (pfuture-new &#34;sleep&#34; &#34;3&#34;)) (future3 (pfuture-new &#34;echo&#34; &#34;All futures have finished after %s seconds.&#34;))) (pfuture-await future1 :timeout 4 :just-this-one nil) (pfuture-await future2 :timeout 4 :just-this-one nil) (pfuture-await future3 :timeout 4 :just-this-one nil) (message (pfuture-result future3) (round (- (float-time) start)))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Stdout and stderr in future objects are separate:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (let ((future (pfuture-new &#34;ls&#34; &#34;nonexsitent_file&#34;))) (pfuture-await-to-finish future) (message &#34;Future stdout: [%s]&#34; (string-trim (pfuture-result future))) (message &#34;Future stderr: [%s]&#34; (string-trim (pfuture-stderr future)))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Calls to &lt;del&gt;pfuture-await&lt;/del&gt; (and especially &lt;del&gt;pfuture-await-to-finish&lt;/del&gt;) are blocking, so it is important to set an appropriate timeout (default is 1 second) or to be really sure that the process is going to terminate.&lt;/p&gt; &#xA;&lt;p&gt;*** With a Callback&lt;/p&gt; &#xA;&lt;p&gt;Here we start another process and instead of keeping the future around and eventually awaiting it we can simply define what steps to take once the process has completed, depending on whether it failed or not.&lt;/p&gt; &#xA;&lt;p&gt;(Note that &lt;del&gt;pfuture-callback&lt;/del&gt; requires lexical scope)&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (defun showcase-error-callback (process status output) (message &#34;Pfuture Error!&#34;) (message &#34;Process: %s&#34; process) (message &#34;Status: %s&#34; status) (message &#34;Output: %s&#34; output))&lt;/p&gt; &#xA;&lt;p&gt;(let ((debug-callback (lambda (pfuture-process status _pfuture-buffer) (message &#34;Pfuture Debug: Process [%s] changed sttaus to [%s]&#34; pfuture-process status)))) (pfuture-callback [&#34;ls&#34; &#34;-alh&#34; &#34;.&#34;] :directory &#34;~/Documents/git/pfuture&#34; :name &#34;Pfuture Example&#34; :on-success (message &#34;Pfuture Finish:\n%s&#34; (pfuture-callback-output)) :on-error #&#39;showcase-error-callback :on-status-change debug-callback)) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;** About async.el&lt;/p&gt; &#xA;&lt;p&gt;You might be inclined to compare both packages since they both, at first glance, handle asynchronous processes, but in truth they have very little in common outside of their general asynchronous nature.&lt;/p&gt; &#xA;&lt;p&gt;Async.el allows you to start and handle an asynchronous Emacs instance, running Elisp code. Pfuture lets you start any external command like &lt;del&gt;git&lt;/del&gt; or &lt;del&gt;ls&lt;/del&gt; (as its mostly a wrapper around &lt;del&gt;make-process&lt;/del&gt;), and then read its output. So while the two packages may appear similar at first there is really nothing to compare.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>progfolio/elpaca</title>
    <updated>2022-08-21T01:55:55Z</updated>
    <id>tag:github.com,2022-08-21:/progfolio/elpaca</id>
    <link href="https://github.com/progfolio/elpaca" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An elisp package manager&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: Elpaca: An Elisp Package Manager #+author: Nicholas Vollmer #+options: exports:both&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;/p&gt;&#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/progfolio/elpaca/master/images/elpaca.svg?sanitize=true&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;/p&gt;&#xA;&lt;p align=&#34;center&#34;&gt; &#34;Chews data, spits packages.&#34;&lt;/p&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;Elpaca is an elisp package manager. It allows users to find, install, update, and remove third-party packages for Emacs. It is a replacement for the built-in Emacs package manager, package.el.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation If you&#39;re impatient, take a look at the [[#example-configuration][example configuration]] ** Requirements&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Emacs &amp;gt;= 27.1&lt;/li&gt; &#xA; &lt;li&gt;git (minimum version TBD)&lt;/li&gt; &#xA; &lt;li&gt;Windows users must be able to create symlinks. ** Bootstrap Snippet To install Elpaca, add the following bootstrapping snippet to your init.el. It must come before any calls to other Elpaca functions/macros. This will clone Elpaca into your =user-emacs-directory= under the =elpaca= subdirectory. It then builds and activates Elpaca.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (declare-function elpaca-generate-autoloads &#34;elpaca&#34;) (defvar elpaca-directory (expand-file-name &#34;elpaca/&#34; user-emacs-directory)) (when-let ((elpaca-repo (expand-file-name &#34;repos/elpaca/&#34; elpaca-directory)) (elpaca-build (expand-file-name &#34;builds/elpaca/&#34; elpaca-directory)) (elpaca-target (if (file-exists-p elpaca-build) elpaca-build elpaca-repo)) (elpaca-url &#34;&lt;a href=&#34;https://www.github.com/progfolio/elpaca.git&#34;&gt;https://www.github.com/progfolio/elpaca.git&lt;/a&gt;&#34;) ((add-to-list &#39;load-path elpaca-target)) ((not (file-exists-p elpaca-repo))) (buffer (get-buffer-create &#34;&lt;em&gt;elpaca-bootstrap&lt;/em&gt;&#34;))) (condition-case-unless-debug err (progn (unless (zerop (call-process &#34;git&#34; nil buffer t &#34;clone&#34; elpaca-url elpaca-repo)) (error &#34;%s&#34; (list (with-current-buffer buffer (buffer-string))))) (byte-recompile-directory elpaca-repo 0 &#39;force) (require &#39;elpaca) (elpaca-generate-autoloads &#34;elpaca&#34; elpaca-repo) (kill-buffer buffer)) ((error) (delete-directory elpaca-directory &#39;recursive) (with-current-buffer buffer (goto-char (point-max)) (insert (format &#34;\n%S&#34; err)) (display-buffer buffer))))) (require &#39;elpaca-autoloads) (add-hook &#39;after-init-hook #&#39;elpaca-process-queues) (elpaca (elpaca :host github :repo &#34;progfolio/elpaca&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll also want to disable package.el in your [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][early-init file]], and remove anything related to package.el in your init file. e.g. calls to &lt;del&gt;(package-activate-all)&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (setq package-enable-at-startup nil) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Basic concepts&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The =elpaca-example= macro in the following examples reduces verbosity. It is not part of Elpaca.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t :exports none :results silent (defun elpaca-example-sort-plist (plist) &#34;Return copy of PLIST with :package followed by lexically sorted kew/val pairs.&#34; `(:package ,(plist-get plist :package) ,@(cl-loop for k in (cl-sort (cl-loop for key in plist by #&#39;cddr unless (eq key :package) collect key) #&#39;string&amp;lt; :key #&#39;symbol-name) append (list k (plist-get plist k)))))&lt;/p&gt; &#xA;&lt;p&gt;(defmacro elpaca-example (&amp;amp;rest body) &#34;Execute BODY with a clean elpaca environment.&#34; `(let (elpaca-cache-menu-items elpaca-order-functions elpaca-recipe-functions (elpaca-menu-functions &#39;(elpaca-example-menu))) (elpaca-example-sort-plist ,@body))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Examples will use the following [[#menus][recipe menu]], which offers a &#34;burger&#34; package recipe:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t :results silent (defun elpaca-example-menu (_) &#39;((burger . (:recipe (:buns 2 :lettuce t :tomato t :beef t :cheese t :cook well-done :from elpaca-example-menu))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Recipes :PROPERTIES: :CUSTOM_ID: recipes :END: A recipe provides Elpaca with the metadata necessary to build and install a package. It is a list of the form:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (ITEM . PROPS) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;/ITEM/ is a symbol uniquely identifying the package. /PROPS/ is a plist with any of the following recipe keywords:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;:host | :fetcher :: A symbol or string representing the hosting service of the repository.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github) (example :fetcher gitlab) (example :host &#34;www.example.com&#34;) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;:repo :: A string of the form =USER/REPO=.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github :repo &#34;user/example&#34;) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;:branch :: The repository branch to check out when installing the package.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github :repo &#34;user/example&#34; :branch &#34;main&#34;) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;:tag :: The tag to check out when installing the package.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github :repo &#34;user/example&#34; :tag &#34;v1.0&#34;) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;:ref :: The [[https://git-scm.com/book/en/v2/Git-Internals-Git-References][git ref]] to check out when installing the package.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github :repo &#34;user/example&#34; :ref &#34;a76ca0a&#34;) ;; Check out a specific commit. #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;:depth :: The package repository&#39;s history depth.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (example :depth 1) ;; Shallow clone with history truncated to 1 commit. (example :depth nil) ;; Full repository clone. #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;:remotes :: A list of repository [[https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes][remotes]]. The first element is the default remote when installing the package. If it is a string, it names the default remote. The remaining elements are lists of the form:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (NAME . PROPS) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;/NAME/ is a string used to name the remote. /PROPS/ are recipe keyword/value pairs used to override values previously declared in the recipe.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (example :remotes (&#34;origin&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github :repo &#34;original/example&#34; :remotes (&#34;origin&#34; (&#34;fork&#34; :host gitlab :repo &#34;user/example-fork.el&#34;))) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;:main :: The name of the main elisp file. When provided this can speed up the process of cloning and loading a package&#39;s dependencies.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (example :main &#34;example.el&#34;) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;:build :: A list of build steps, nil or t. If the list starts with the symbol =:not=. The set difference of =elpaca-default-build-steps= and the remaining elements of the list are used.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (example :build (:not autoloads)) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;:inherit :: When non-nil, inherit /PROPS/ from =elpaca-order-functions= and possibly =elpaca-menu-functions=. For example, without inheritance: #+name: recipe-inheritance-nil #+begin_src emacs-lisp :lexical t :results raw code :exports both (elpaca-example (elpaca-recipe &#39;(burger :inherit nil))) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;returns the recipe as declared:&lt;/p&gt; &#xA;&lt;p&gt;#+results: recipe-inheritance-nil #+begin_src emacs-lisp (:package &#34;burger&#34; :inherit nil) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;With inheritance enabled: #+name: recipe-inheritance-menu #+begin_src emacs-lisp :lexical t :results raw code :exports both (elpaca-example (elpaca-recipe &#39;(burger :inherit t))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;the elpaca-example-menu provides the rest of the &#34;burger&#34; recipe.&lt;/p&gt; &#xA;&lt;p&gt;#+results: recipe-inheritance-menu #+begin_src emacs-lisp (:package &#34;burger&#34; :beef t :buns 2 :cheese t :cook well-done :from elpaca-example-menu :inherit t :lettuce t :tomato t) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Inheritance precedence :PROPERTIES: :CUSTOM_ID: inheritance-precedence :END: The following list shows the order of precedence for inheritance. Each item takes precedence over the items which follow it.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;elpaca-recipe-functions&lt;/li&gt; &#xA; &lt;li&gt;declared recipe&lt;/li&gt; &#xA; &lt;li&gt;elpaca-order-functions&lt;/li&gt; &#xA; &lt;li&gt;elpaca-menu-functions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+name: recipe-inheritance-precedence #+begin_src emacs-lisp :lexical t :results raw code :exports both (elpaca-example (let ((elpaca-recipe-functions (lambda (recipe) &#39;(:from recipe-functions :cheese extra))) (elpaca-order-functions (lambda (order) &#39;(:from order-functions :tomato nil)))) (elpaca-recipe &#39;(burger)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+results: recipe-inheritance-precedence #+begin_src emacs-lisp (:package &#34;burger&#34; :beef t :buns 2 :cheese extra :cook well-done :from recipe-functions :lettuce t :tomato nil) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** elpaca-recipe-functions :PROPERTIES: :CUSTOM_ID: elpaca-recipe-functions :END: The abnormal hook =elpaca-recipe-functions= runs via =run-hook-with-args-until-success= just before installing the package. Each function in the list should accept the current recipe as its sole argument and return either nil or a plist. The first function to return a plist has its return value merged with the current recipe.&lt;/p&gt; &#xA;&lt;p&gt;This is useful if you want to guarantee the values of certain keywords despite allowing recipe inheritance.&lt;/p&gt; &#xA;&lt;p&gt;#+name: recipe-functions-example #+begin_src emacs-lisp :lexical t :exports both :results raw code (elpaca-example (let ((elpaca-recipe-functions &#39;((lambda (recipe) &#34;If a recipe calls for cheese, I always want extra.&#34; (when (plist-get recipe :cheese) (list :cheese &#39;extra)))))) (elpaca-recipe &#39;(burger)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+results: recipe-functions-example #+begin_src emacs-lisp (:package &#34;burger&#34; :beef t :buns 2 :cheese extra :cook well-done :from elpaca-example-menu :lettuce t :tomato t) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Menus :PROPERTIES: :CUSTOM_ID: menus :END: A menu is a function which returns an alist of the form: #+begin_src emacs-lisp :lexical t ((ITEM . DATA)...) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;/ITEM/ is a symbol uniquely identifying a package. /DATA/ is a plist of package metadata. /DATA/ must contain the following keywords:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;:recipe :: A package [[#recipes][recipe.]]&lt;/li&gt; &#xA; &lt;li&gt;:source :: A string naming the menu.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It may also provide additional information about a package. For example, the Elpaca UI utilizes the following keywords when present:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;:url :: The package&#39;s website URL.&lt;/li&gt; &#xA; &lt;li&gt;:description :: A description of the package.&lt;/li&gt; &#xA; &lt;li&gt;:date :: The time of package&#39;s last update.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The function must accept one of the following /REQUEST/ symbols as an argument:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;index :: Return the alist described above&lt;/li&gt; &#xA; &lt;li&gt;update :: update the menu&#39;s alist.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (defun elpaca-menu-minimal (request_) &#34;A minimal menu example. Ignore REQUEST, as this is a static, curated list of packages.&#34; &#39;((example :source &#34;EXAMPLE&#34; :recipe (example :host github :repo &#34;user/example&#34;)) (two :source &#34;EXAMPLE&#34; :recipe (two :host gitlab :repo &#34;user/two&#34;)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Menus allow one to offer Elpaca users curated lists of package recipes. For example, [[https://www.github.com/progfolio/melpulls][melpulls]] implements an Elpaca menu for pending MELPA packages.&lt;/p&gt; &#xA;&lt;p&gt;*** elpaca-menu-functions The =elpaca-menu-functions= variable contains menu functions for the following package sources by default:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://www.github.com/melpa/melpa][MELPA]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://git.savannah.gnu.org/cgit/emacs/org-mode.git/][Org]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://git.sr.ht/~bzg/org-contrib][Org-contrib]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://www.github.com/emacs-straight/gnu-elpa-mirror][GNU ELPA Mirror]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://elpa.nongnu.org][NonGNU ELPA]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Menus are checked in order until one returns the requested menu item or the menu list is exhausted.&lt;/p&gt; &#xA;&lt;p&gt;** Orders :PROPERTIES: :CUSTOM_ID: orders :END:&lt;/p&gt; &#xA;&lt;p&gt;At a minimum, an order is a symbol which represents the name of a [[#menus][menu]] item:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca &#39;example) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;An order may also be a partial or full recipe:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca &#39;(example :host gitlab)) (elpaca &#39;(example :host gitlab :repo &#34;user/example&#34; :inherit nil)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** elpaca-order-functions The abnormal hook =elpaca-order-functions= runs via =run-hook-with-args-until-success= before =elpaca-menu-functions=. Each function in the list should accept the current order as its sole argument and return either nil or a plist. The first function to return a plist has its return value merged with the current order.&lt;/p&gt; &#xA;&lt;p&gt;This is useful for declaring default order properties. For example, the following function disables recipe inheritance by default:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t :results raw code :exports both (elpaca-example (let ((elpaca-order-functions &#39;((lambda (_) &#39;(:inherit nil))))) (elpaca-recipe &#39;burger))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: #+begin_src emacs-lisp (:package &#34;burger&#34; :inherit nil) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Queues :PROPERTIES: :CUSTOM_ID: queues :END: Elpaca installs packages asynchronously. [[#orders][Orders]] are automatically queued in a list. A queue is considered &#34;processed&#34; when all of its orders have either finished or failed.&lt;/p&gt; &#xA;&lt;p&gt;Queues make it possible to ensure a package is installed, activated, and configured prior to other packages. The =elpaca-queue= macro wraps calls to =elpaca=, ensuring those orders are processed in their own queue. This is especially useful when one wants to install a package to use later on in their init file. For example, a package which implements an Elpaca [[#menus][menu]]:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca-queue (elpaca &#39;(melpulls :host github :repo &#34;progfolio/melpulls&#34;)) (add-to-list &#39;elpaca-menu-functions #&#39;melpulls) (elpaca-update-menus #&#39;melpulls)) ;; Implicitly queued into a new queue. (elpaca &#39;menu-item-available-in-melpulls) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installing Packages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;elpaca :: =(order &amp;amp;rest body)= Installs /ORDER/ and executes /BODY/ after processing ORDER&#39;s [[#queues][queue]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;/ORDER/ is an [[#orders][order]] as described above.&lt;/p&gt; &#xA;&lt;p&gt;This macro is for programmatic use in one&#39;s init file. Any of the following will install the &#34;example&#34; package:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca example) ;; recipe looked up in `elpaca-menu-functions&#39;. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca example (message &#34;Messaged after the order&#39;s queue has processed.&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca (example :host github :repo &#34;user/example&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca `(example :host github :repo &#34;user/example&#34; ,@(when (eq system-type &#39;darwin) ;; backqouting supported (list :pre-build ((message &#34;Mac specific pre-build&#34;)))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If /ORDER/ is nil, /BODY/ is still executed after processing the current [[#queues][queue]].&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca &#39;first (message &#34;First configured&#34;)) ;; If this weren&#39;t wrapped in an `elpaca&#39; call, it would be executed FIRST ;; Due to the &#34;first&#34; and &#34;third&#34; package installing asynchronously. (elpaca nil (message &#34;Second&#34;)) (elpaca &#39;third (message &#34;Third configured&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;elpaca-use-package :: =(order &amp;amp;rest body)=&lt;/p&gt; &lt;p&gt;A wrapper for the [[https://github.com/jwiegley/use-package][use-package]] macro. /ORDER/ is the same as above. /BODY/ must conform to use-package&#39;s /ARGS/.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca use-package (require &#39;use-package)) ; install use-package (elpaca-use-package (example :host github :repo &#34;user/example&#34;) :config (message &#34;Example configured&#34;)) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Finding, Updating, Removing Packages The =elpaca-manger= command will pop to the Elpaca manager buffer. From this buffer you can search and act on all the packages Elpaca knows about.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following commands are available in the Elpaca manager buffer:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t :exports results table replace (with-temp-buffer (describe-map-tree elpaca-ui-mode-map) (goto-char (point-min)) (let (rows) (while (re-search-forward &#34;elpaca&#34; nil &#39;noerror) (push (split-string (buffer-substring-no-properties (line-beginning-position) (line-end-position)) &#34;\t+&#34;) rows)) (setq rows (mapcar (lambda (it) (append (list (car (split-string (documentation (intern (cadr it))) &#34;\n&#34;))) it)) rows)) (setq rows (cl-sort (mapcar #&#39;nreverse rows) #&#39;string&amp;lt; :key #&#39;cadr)) (push &#39;hline rows) (push (list &#34;Command&#34; &#34;Default Binding&#34; &#34;Description&#34;) rows) rows)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: | Command | Default Binding | Description | |----------------------------+-----------------+-----------------------------------------------------------------| | elpaca-ui-send-input | ! | Send input string to current process. | | elpaca-ui-search-installed | I | Search for &#34;#unique #installed&#34; | | elpaca-ui-search-marked | M | Search for &#34;#unique #marked&#34; | | elpaca-ui-search-orphaned | O | Search for &#34;#unique #orphan&#34; | | elpaca-ui-search-refresh | R | Rerun the current search for BUFFER. | | elpaca-ui-search-tried | T | Search for &#34;#unique #installed !#declared&#34; | | elpaca-ui-unmark | U | Unmark current package. | | elpaca-ui-browse-package | b | Browse current package’s URL via ‘browse-url’. | | elpaca-ui-mark-delete | d | Mark package for delete action. | | elpaca-ui-mark-install | i | Mark package for install action. | | elpaca-log | l | Display ‘elpaca-log-buffer’. | | elpaca-manager | m | Display elpaca’s package management UI. | | elpaca-ui-mark-rebuild | r | Mark package for rebuild action. | | elpaca-ui-search | s | Filter current buffer by QUERY. If QUERY is nil, prompt for it. | | elpaca-status | t | Log most recent events for packages. | | elpaca-ui-mark-update | u | Mark package for update action. | | elpaca-visit | v | Open ITEM’s local repository directory. | | elpaca-ui-execute-marks | x | Execute each action in ‘elpaca-ui-marked-packages’. |&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example configuration :PROPERTIES: :CUSTOM_ID: example-configuration :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following is an example init.el using Elpaca:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t :tangle ./test/example-init.el :results silent ;;; init-elpaca.el --- ELPACA INIT DEMO -&lt;em&gt;- lexical-binding: t; -&lt;/em&gt;- ;; Bootstrap Elpaca (declare-function elpaca-generate-autoloads &#34;elpaca&#34;) (defvar elpaca-directory (expand-file-name &#34;elpaca/&#34; user-emacs-directory)) (when-let ((elpaca-repo (expand-file-name &#34;repos/elpaca/&#34; elpaca-directory)) (elpaca-build (expand-file-name &#34;builds/elpaca/&#34; elpaca-directory)) (elpaca-target (if (file-exists-p elpaca-build) elpaca-build elpaca-repo)) (elpaca-url &#34;&lt;a href=&#34;https://www.github.com/progfolio/elpaca.git&#34;&gt;https://www.github.com/progfolio/elpaca.git&lt;/a&gt;&#34;) ((add-to-list &#39;load-path elpaca-target)) ((not (file-exists-p elpaca-repo))) (buffer (get-buffer-create &#34;&lt;em&gt;elpaca-bootstrap&lt;/em&gt;&#34;))) (condition-case-unless-debug err (progn (unless (zerop (call-process &#34;git&#34; nil buffer t &#34;clone&#34; elpaca-url elpaca-repo)) (error &#34;%s&#34; (list (with-current-buffer buffer (buffer-string))))) (byte-recompile-directory elpaca-repo 0 &#39;force) (require &#39;elpaca) (elpaca-generate-autoloads &#34;elpaca&#34; elpaca-repo) (kill-buffer buffer)) ((error) (delete-directory elpaca-directory &#39;recursive) (with-current-buffer buffer (goto-char (point-max)) (insert (format &#34;\n%S&#34; err)) (display-buffer buffer))))) (require &#39;elpaca-autoloads) (add-hook &#39;after-init-hook #&#39;elpaca-process-queues) (elpaca (elpaca :host github :repo &#34;progfolio/elpaca&#34;))&lt;/p&gt; &#xA;&lt;p&gt;;; Install use-package (elpaca use-package (require &#39;use-package)) ;; Install evil and configure via `use-package&#39; (elpaca-use-package evil :demand t) ;; Install a package from a user-provided recipe (elpaca (yodel :host github :repo &#34;progfolio/yodel&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;h1&gt;LocalWords: elpaca Elpaca elisp repo minibuffer website init ui UI unmark Unmark plist alist MELPA programmatic&lt;/h1&gt;</summary>
  </entry>
  <entry>
    <title>haskell/haskell-mode</title>
    <updated>2022-08-21T01:55:55Z</updated>
    <id>tag:github.com,2022-08-21:/haskell/haskell-mode</id>
    <link href="https://github.com/haskell/haskell-mode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs mode for Haskell&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img src=&#34;https://rawgithub.com/haskell/haskell-mode/master/images/haskell-mode.svg?sanitize=true&#34; width=&#34;35&#34; height=&#34;35&#34;&gt; Haskell Mode for Emacs&lt;/h1&gt; &#xA;&lt;p&gt;This is an Emacs mode for editing, developing and debugging Haskell programs. &lt;a href=&#34;http://haskell.github.io/haskell-mode/&#34;&gt;Home page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/haskell/haskell-mode&#34;&gt;&lt;img src=&#34;https://travis-ci.org/haskell/haskell-mode.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/haskell/haskell-mode/actions&#34;&gt;&lt;img src=&#34;https://github.com/haskell/haskell-mode/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/haskell-mode&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/haskell-mode-badge.svg?sanitize=true&#34; alt=&#34;Melpa Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/haskell-mode&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/haskell-mode-badge.svg?sanitize=true&#34; alt=&#34;Melpa Stable Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/haskell/haskell-mode/raw/master/COPYING&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL3-blue.svg?sanitize=true&#34; alt=&#34;License GPL3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/HaskellMode&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/HaskellMode.svg?style=social&#34; alt=&#34;Twitter Follow&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;I just want to thank everybody involved in one way or another with the Haskell Emacs tooling. It is one of the best language experiences I had in Emacs. -- &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/2xjum3/haskellmode_february_2015_developments/cp0qa9a&#34;&gt;cocreature, 2015-03-01&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;I&#39;ve been using it for a long time and love it. Great work on haskell-mode! Keep up the good work! -- &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/316hcm/month_in_haskell_mode_march_2015/cpyutph&#34;&gt;LukeHoersten, 2015-04-02&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This sounds wonderful. Does anything similar exist for Vim? -- &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/3bsa0f/month_in_haskell_mode_june_2015/cspdbb6&#34;&gt;earldouglas, 2015-07-02&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Users manual: &lt;a href=&#34;http://haskell.github.io/haskell-mode/manual/latest/&#34;&gt;latest version&lt;/a&gt;, older versions: &lt;a href=&#34;http://haskell.github.io/haskell-mode/manual/13.12/&#34;&gt;13.12&lt;/a&gt;, &lt;a href=&#34;http://haskell.github.io/haskell-mode/manual/13.14/&#34;&gt;13.14&lt;/a&gt;, &lt;a href=&#34;http://haskell.github.io/haskell-mode/manual/13.16/&#34;&gt;13.16&lt;/a&gt;, &lt;a href=&#34;http://haskell.github.io/haskell-mode/manual/13.18/&#34;&gt;13.18&lt;/a&gt;, &lt;a href=&#34;http://haskell.github.io/haskell-mode/manual/13.20/&#34;&gt;13.20&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Installation&lt;/h2&gt; &#xA;&lt;p&gt;Make sure you have this in your &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html&#34;&gt;init file&lt;/a&gt; (usually &lt;code&gt;~/.emacs&lt;/code&gt;). If you already have &lt;code&gt;custom-set-variables&lt;/code&gt;, merge its contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;package)&#xA;(custom-set-variables&#xA; ;; custom-set-variables was added by Custom.&#xA; ;; If you edit it by hand, you could mess it up, so be careful.&#xA; ;; Your init file should contain only one such instance.&#xA; ;; If there is more than one, they won&#39;t work right.&#xA; &#39;(package-archives&#xA;   (quote&#xA;    ((&#34;gnu&#34; . &#34;https://elpa.gnu.org/packages/&#34;)&#xA;     (&#34;melpa&#34; . &#34;https://melpa.org/packages/&#34;)))))&#xA;(package-initialize)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run emacs, and evaluate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x package-refresh-contents&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then follow by&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x package-install RET haskell-mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Voilà! &lt;code&gt;haskell-mode&lt;/code&gt; is installed! You should be able to edit Haskell source code in color now.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Haskell-mode&lt;/code&gt; has much much more to offer but the above should get you going!&lt;/p&gt; &#xA;&lt;h2&gt;Advanced configuration&lt;/h2&gt; &#xA;&lt;p&gt;For setup instructions, please consult the integrated &lt;code&gt;haskell-mode&lt;/code&gt; Info manual which can be accessed after installation via &lt;code&gt;M-x info-display-manual [RET] haskell-mode&lt;/code&gt;. Alternatively, you can also direct your browser to the &lt;a href=&#34;http://haskell.github.io/haskell-mode/manual/latest/&#34;&gt;the online haskell-mode manual&lt;/a&gt; for setup and user guide.&lt;/p&gt; &#xA;&lt;h2&gt;Installation - more information&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;haskell-mode&lt;/code&gt; supports GNU Emacs version 25.1 or later.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;haskell-mode&lt;/code&gt; is available from &lt;a href=&#34;http://stable.melpa.org&#34;&gt;MELPA Stable&lt;/a&gt; (releases) and &lt;a href=&#34;http://melpa.org&#34;&gt;MELPA&lt;/a&gt; (git snapshots). The latter will generally be considerably more up-to-date, and is recommended for most users.&lt;/p&gt; &#xA;&lt;p&gt;Other means of obtaining &lt;code&gt;haskell-mode&lt;/code&gt; include &lt;a href=&#34;https://github.com/dimitri/el-get&#34;&gt;el-get&lt;/a&gt;, &lt;a href=&#34;https://github.com/bbatsov/prelude&#34;&gt;Emacs Prelude&lt;/a&gt; and &lt;a href=&#34;https://packages.debian.org/search?keywords=haskell-mode&#34;&gt;Debian package&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation from git repository&lt;/h2&gt; &#xA;&lt;p&gt;Running &lt;code&gt;haskell-mode&lt;/code&gt; directly from sources is easy but requires a little preparation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;git clone https://github.com/haskell/haskell-mode.git&lt;/code&gt; into a suitable directory, e.g. &lt;code&gt;~/lib/emacs/haskell-mode/&lt;/code&gt; where &lt;code&gt;~&lt;/code&gt; stands for your home directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Assuming you have unpacked the various haskell-mode modules (&lt;code&gt;haskell-mode.el&lt;/code&gt; and the rest) in the directory &lt;code&gt;~/lib/emacs/haskell-mode/&lt;/code&gt;, you need to generate various files, the autoloads file (&lt;code&gt;haskell-mode-autoloads.el&lt;/code&gt;) is one among them. Invoke:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make EMACS=/path/to/your/emacs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then adding the following command to your &lt;code&gt;.emacs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-to-list &#39;load-path &#34;~/lib/emacs/haskell-mode/&#34;)&#xA;(require &#39;haskell-mode-autoloads)&#xA;(add-to-list &#39;Info-default-directory-list &#34;~/lib/emacs/haskell-mode/&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installation from git repository on macOS&lt;/h3&gt; &#xA;&lt;p&gt;There are a couple of things to note if you want to install directly from git on macOS systems, as of version 10.13 High Sierra:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The version of makeinfo that is installed by default in /usr/bin is quite old and will cause the above make command to exit with an error. Installing the texinfo package using &lt;a href=&#34;https://brew.sh&#34;&gt;Homebrew&lt;/a&gt; will fix this. Be sure to follow the post-install instructions to add its bin directory to your shell&#39;s PATH variable.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you are running an Emacs distribution packaged as a macOS application. such as the one available at &lt;a href=&#34;https://emacsformacosx.com/&#34;&gt;https://emacsformacosx.com/&lt;/a&gt;, you&#39;ll need to add its executable to your PATH before the system&#39;s default Emacs version. That project&#39;s &lt;a href=&#34;https://emacsformacosx.com/tips&#34;&gt;Tips and Tricks&lt;/a&gt; page has detailed instructions.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you followed the above you are just a couple of steps away from contributing to &lt;code&gt;haskell-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;haskell-mode&lt;/code&gt; is actively seeking contributions from users of &lt;code&gt;haskell-mode&lt;/code&gt;. For more information have a look at &lt;a href=&#34;https://github.com/haskell/haskell-mode/wiki/Contributing&#34;&gt;the wiki page on contributing&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>