<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-31T02:10:25Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>minad/vertico</title>
    <updated>2022-07-31T02:10:25Z</updated>
    <id>tag:github.com,2022-07-31:/minad/vertico</id>
    <link href="https://github.com/minad/vertico" rel="alternate"></link>
    <summary type="html">&lt;p&gt;💫 vertico.el - VERTical Interactive COmpletion&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: vertico.el - VERTical Interactive COmpletion #+author: Daniel Mendler #+language: en #+export_file_name: vertico.texi #+texinfo_dir_category: Emacs misc features #+texinfo_dir_title: Vertico: (vertico). #+texinfo_dir_desc: VERTical Interactive COmpletion.&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img alt=&#34;GNU Emacs&#34; src=&#34;https://github.com/minad/corfu/raw/screenshots/emacs.svg?raw=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/packages/vertico.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/vertico.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/devel/vertico.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/vertico.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Vertigomovie_restoration.jpg/800px-Vertigomovie_restoration.jpg&#34; align=&#34;right&#34; width=&#34;30%&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Vertico provides a performant and minimalistic vertical completion UI based on the default completion system. The main focus of Vertico is to provide a UI which behaves /correctly/ under all circumstances. By reusing the built-in facilities system, Vertico achieves /full compatibility/ with built-in Emacs completion commands and completion tables. Vertico only provides the completion UI but aims to be highly flexible, extensible and modular. Additional enhancements are available as [[#extensions][extensions]] or [[#complementary-packages][complementary packages]]. The code base is small and maintainable. The main &lt;del&gt;vertico.el&lt;/del&gt; package is only about 600 lines of code without white space and comments.&lt;/p&gt; &#xA;&lt;p&gt;#+toc: headlines 8&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Vertical display with arrow key navigation. See the [[#extensions][extensions]] for additional display modes.&lt;/li&gt; &#xA; &lt;li&gt;Prompt shows the current candidate index and the total number of candidates.&lt;/li&gt; &#xA; &lt;li&gt;The current candidate is inserted with =TAB= and selected with =RET=.&lt;/li&gt; &#xA; &lt;li&gt;Non-existing candidates can be submitted with =M-RET= or by moving the point to the prompt.&lt;/li&gt; &#xA; &lt;li&gt;Configurable sorting by history position, length and alphabetically.&lt;/li&gt; &#xA; &lt;li&gt;Long candidates with newlines are formatted to take up less space.&lt;/li&gt; &#xA; &lt;li&gt;Deferred completion style highlighting for performance.&lt;/li&gt; &#xA; &lt;li&gt;Annotations are displayed next to the candidates (&lt;del&gt;annotation-&lt;/del&gt; and &lt;del&gt;affixation-function&lt;/del&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Support for candidate grouping and group cycling commands (&lt;del&gt;group-function&lt;/del&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[[https://github.com/minad/vertico/blob/screenshots/vertico-mx.png?raw=true]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Key bindings&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Vertico defines its own local keymap in the minibuffer which is derived from &lt;del&gt;minibuffer-local-map&lt;/del&gt;. The keymap keeps most of the &lt;del&gt;fundamental-mode&lt;/del&gt; keybindings intact and remaps and binds only a handful of commands. Note in particular the binding of =TAB= to &lt;del&gt;vertico-insert&lt;/del&gt; and the bindings of &lt;del&gt;vertico-exit/exit-input&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;beginning-of-buffer&lt;/del&gt;, &lt;del&gt;minibuffer-beginning-of-buffer&lt;/del&gt; -&amp;gt; &lt;del&gt;vertico-first&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;end-of-buffer&lt;/del&gt; -&amp;gt; &lt;del&gt;vertico-last&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;scroll-down-command&lt;/del&gt; -&amp;gt; &lt;del&gt;vertico-scroll-down&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;scroll-up-command&lt;/del&gt; -&amp;gt; &lt;del&gt;vertico-scroll-up&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;next-line&lt;/del&gt;, &lt;del&gt;next-line-or-history-element&lt;/del&gt; -&amp;gt; &lt;del&gt;vertico-next&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;previous-line&lt;/del&gt;, &lt;del&gt;previous-line-or-history-element&lt;/del&gt; -&amp;gt; &lt;del&gt;vertico-previous&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;forward-paragraph&lt;/del&gt; -&amp;gt; &lt;del&gt;vertico-next-group&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;backward-paragraph&lt;/del&gt; -&amp;gt; &lt;del&gt;vertico-previous-group&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;exit-minibuffer&lt;/del&gt; -&amp;gt; &lt;del&gt;vertico-exit&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;kill-ring-save&lt;/del&gt; -&amp;gt; &lt;del&gt;vertico-save&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;=M-RET= -&amp;gt; &lt;del&gt;vertico-exit-input&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;=TAB= -&amp;gt; &lt;del&gt;vertico-insert&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Vertico is available from [[http://elpa.gnu.org/packages/vertico.html][GNU ELPA]]. You can install it directly via &lt;del&gt;package-install&lt;/del&gt;. After installation, you can activate the global minor mode with =M-x vertico-mode=. In order to configure Vertico and other packages in your init.el, you may want to take advantage of &lt;del&gt;use-package&lt;/del&gt;. Here is an example configuration:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Enable vertico (use-package vertico :init (vertico-mode)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; Different scroll margin&#xA;;; (setq vertico-scroll-margin 0)&#xA;&#xA;;; Show more candidates&#xA;;; (setq vertico-count 20)&#xA;&#xA;;; Grow and shrink the Vertico minibuffer&#xA;;; (setq vertico-resize t)&#xA;&#xA;;; Optionally enable cycling for `vertico-next&#39; and `vertico-previous&#39;.&#xA;;; (setq vertico-cycle t)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;;; Persist history over Emacs restarts. Vertico sorts by history position. (use-package savehist :init (savehist-mode))&lt;/p&gt; &#xA;&lt;p&gt;;; A few more useful configurations... (use-package emacs :init ;; Add prompt indicator to &lt;code&gt;completing-read-multiple&#39;. ;; We display [CRM&amp;lt;separator&amp;gt;], e.g., [CRM,] if the separator is a comma. (defun crm-indicator (args) (cons (format &#34;[CRM%s] %s&#34; (replace-regexp-in-string &#34;\\&lt;/code&gt;\[.&lt;em&gt;?]\&lt;/em&gt;\|\[.&lt;em&gt;?]\&lt;/em&gt;\&#39;&#34; &#34;&#34; crm-separator) (car args)) (cdr args))) (advice-add #&#39;completing-read-multiple :filter-args #&#39;crm-indicator)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; Do not allow the cursor in the minibuffer prompt&#xA;(setq minibuffer-prompt-properties&#xA;      &#39;(read-only t cursor-intangible t face minibuffer-prompt))&#xA;(add-hook &#39;minibuffer-setup-hook #&#39;cursor-intangible-mode)&#xA;&#xA;;; Emacs 28: Hide commands in M-x which do not work in the current mode.&#xA;;; Vertico commands are hidden in normal buffers.&#xA;;; (setq read-extended-command-predicate&#xA;;;       #&#39;command-completion-default-include-p)&#xA;&#xA;;; Enable recursive minibuffers&#xA;(setq enable-recursive-minibuffers t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;I recommend to give Orderless completion a try, which is different from the prefix TAB completion used by the basic default completion system or in shells.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Optionally use the `orderless&#39; completion style. (use-package orderless :init ;; Configure a custom style dispatcher (see the Consult wiki) ;; (setq orderless-style-dispatchers &#39;(+orderless-dispatch) ;; orderless-component-separator #&#39;orderless-escapable-split-on-space) (setq completion-styles &#39;(orderless basic) completion-category-defaults nil completion-category-overrides &#39;((file (styles partial-completion))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =basic= completion style is specified as fallback in addition to =orderless= in order to ensure that completion commands which rely on dynamic completion tables, e.g., &lt;del&gt;completion-table-dynamic&lt;/del&gt; or &lt;del&gt;completion-table-in-turn&lt;/del&gt;, work correctly. See =+orderless-dispatch= in the [[https://github.com/minad/consult/wiki][Consult wiki]] for an advanced Orderless style dispatcher. Additionally enable =partial-completion= for file path expansion. =partial-completion= is important for file wildcard support. Multiple files can be opened at once with =find-file= if you enter a wildcard. You may also give the =initials= completion style a try.&lt;/p&gt; &#xA;&lt;p&gt;See also the [[https://github.com/minad/vertico/wiki][Vertico Wiki]] for additional configuration tips. For more general documentation read the chapter about completion in the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html][Emacs manual]]. If you want to create your own completion commands, you can find documentation about completion in the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion.html][Elisp manual]].&lt;/p&gt; &#xA;&lt;p&gt;** Completion styles and TAB completion&lt;/p&gt; &#xA;&lt;p&gt;The bindings of the &lt;del&gt;minibuffer-local-completion-map&lt;/del&gt; are not available in Vertico by default. This means that TAB works differently from what you may expect from the default Emacs completion system.&lt;/p&gt; &#xA;&lt;p&gt;If you prefer to have the default completion commands a key press away you can add new bindings or even replace the Vertico bindings. Then the default completion commands behave as usual. For example you can use =M-TAB= to cycle between candidates if you have set &lt;del&gt;completion-cycle-threshold&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (define-key vertico-map &#34;?&#34; #&#39;minibuffer-completion-help) (define-key vertico-map (kbd &#34;M-RET&#34;) #&#39;minibuffer-force-complete-and-exit) (define-key vertico-map (kbd &#34;M-TAB&#34;) #&#39;minibuffer-complete) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The &lt;del&gt;orderless&lt;/del&gt; completion style does not support completion of a common prefix substring, as you may be familiar with from shells or the basic default completion system. The reason is that the Orderless input string is usually not a prefix. In order to support completing prefixes you may want to combine &lt;del&gt;orderless&lt;/del&gt; with &lt;del&gt;substring&lt;/del&gt; in your =completion-styles= configuration.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq completion-styles &#39;(substring orderless basic)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Alternatively you can experiment with the built-in completion-styles, e.g., adding =partial-completion= or =flex=. The =partial-completion= style is important to add if you want to open multiple files at once with &lt;del&gt;find-file&lt;/del&gt; using wildcards. In order to open multiple files at once, you have to move to the prompt and then press =RET=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq completion-styles &#39;(basic substring partial-completion flex)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Because Vertico is fully compatible with Emacs default completion system, further customization of completion behavior can be achieved by setting the designated Emacs variables. For example, one may wish to disable case-sensitivity for file and buffer matching when built-in completion styles are used instead of &lt;del&gt;orderless&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq read-file-name-completion-ignore-case t read-buffer-completion-ignore-case t completion-ignore-case t) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Completion-at-point and completion-in-region&lt;/p&gt; &#xA;&lt;p&gt;The =completion-at-point= command is usually bound to =M-TAB= or =TAB=. In case you want to use Vertico for completion-at-point/completion-in-region, you can use the function &lt;del&gt;consult-completion-in-region&lt;/del&gt; provided by the Consult package.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Use &lt;code&gt;consult-completion-in-region&#39; if Vertico is enabled. ;; Otherwise use the default &lt;/code&gt;completion--in-region&#39; function. (setq completion-in-region-function (lambda (&amp;amp;rest args) (apply (if vertico-mode #&#39;consult-completion-in-region #&#39;completion--in-region) args))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =completion-in-region-function= setting also affects TAB completion in the minibuffer when =M-:= (&lt;del&gt;eval-expression&lt;/del&gt;) is used.&lt;/p&gt; &#xA;&lt;p&gt;You may also want to look into my [[https://github.com/minad/corfu][Corfu]] package, which provides a minimal completion system for =completion-in-region= in a child frame popup. Corfu is also a narrowly focused package and developed in the same spirit as Vertico.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Extensions :properties: :custom_id: extensions &lt;span&gt;🔚&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We maintain small extension packages to Vertico in this repository in the subdirectory [[https://github.com/minad/vertico/tree/main/extensions][extensions/]]. The extensions are installed together with Vertico if you pull the package from ELPA. The extensions are inactive by default and can be enabled manually if desired. Furthermore it is possible to install all of the files separately, both &lt;del&gt;vertico.el&lt;/del&gt; and the &lt;del&gt;vertico-*.el&lt;/del&gt; extensions. Currently the following extensions come with the Vertico ELPA package:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-buffer.el][vertico-buffer]]: =vertico-buffer-mode= to display Vertico in a separate buffer.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-directory.el][vertico-directory]]: Commands for Ido-like directory navigation.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-flat.el][vertico-flat]]: =vertico-flat-mode= to enable a flat, horizontal display.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-grid.el][vertico-grid]]: =vertico-grid-mode= to enable a grid display.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-indexed.el][vertico-indexed]]: =vertico-indexed-mode= to select indexed candidates with prefix arguments.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-mouse.el][vertico-mouse]]: =vertico-mouse-mode= to support for scrolling and candidate selection.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-multiform.el][vertico-multiform]]: Configure Vertico modes per command or completion category.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-quick.el][vertico-quick]]: Commands to select using Avy-style quick keys.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-repeat.el][vertico-repeat]]: The command =vertico-repeat= repeats the last completion session.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-reverse.el][vertico-reverse]]: =vertico-reverse-mode= to reverse the display.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico/blob/main/extensions/vertico-unobtrusive.el][vertico-unobtrusive]]: =vertico-unobtrusive-mode= displays only the topmost candidate.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the Commentary of those files for configuration details. With these extensions it is possible to adapt Vertico such that it matches your preference or behaves similar to other familiar UIs. For example, the combination =vertico-flat= plus =vertico-directory= resembles Ido in look and feel. For an interface similar to Helm, the extension =vertico-buffer= allows you to configure freely where the completion buffer opens, instead of growing the minibuffer. Furthermore =vertico-buffer= will adjust the number of displayed candidates according to the buffer height.&lt;/p&gt; &#xA;&lt;p&gt;Configuration example for =vertico-directory=:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Configure directory extension. (use-package vertico-directory :after vertico :ensure nil ;; More convenient directory navigation commands :bind (:map vertico-map (&#34;RET&#34; . vertico-directory-enter) (&#34;DEL&#34; . vertico-directory-delete-char) (&#34;M-DEL&#34; . vertico-directory-delete-word)) ;; Tidy shadowed file names :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Configure Vertico per command or completion category&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/minad/vertico/blob/screenshots/vertico-ripgrep.png?raw=true]]&lt;/p&gt; &#xA;&lt;p&gt;Vertico offers the =vertico-multiform-mode= which allows you to configure Vertico per command or per completion category. The =vertico-buffer-mode= enables a Helm-like buffer display, which takes more space but also displays more candidates. This verbose display mode is useful for commands like &lt;del&gt;consult-imenu&lt;/del&gt; or &lt;del&gt;consult-outline&lt;/del&gt; since the buffer display allows you to get a better overview over the entire current buffer. But for other commands you want to keep using the default Vertico display. &lt;del&gt;vertico-multiform-mode&lt;/del&gt; solves this configuration problem!&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Enable vertico-multiform (vertico-multiform-mode)&lt;/p&gt; &#xA;&lt;p&gt;;; Configure the display per command. ;; Use a buffer with indices for imenu ;; and a flat (Ido-like) menu for M-x. (setq vertico-multiform-commands &#39;((consult-imenu buffer indexed) (execute-extended-command unobtrusive)))&lt;/p&gt; &#xA;&lt;p&gt;;; Configure the display per completion category. ;; Use the grid display for files and a buffer ;; for the consult-grep commands. (setq vertico-multiform-categories &#39;((file grid) (consult-grep buffer))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Temporary toggling between the different display modes is possible. Bind the following commands:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (define-key vertico-map &#34;\M-V&#34; #&#39;vertico-multiform-vertical) (define-key vertico-map &#34;\M-G&#34; #&#39;vertico-multiform-grid) (define-key vertico-map &#34;\M-F&#34; #&#39;vertico-multiform-flat) (define-key vertico-map &#34;\M-R&#34; #&#39;vertico-multiform-reverse) (define-key vertico-map &#34;\M-U&#34; #&#39;vertico-multiform-unobtrusive) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can use your own functions or even lambdas to configure the completion behavior per command or per completion category. The function must have the calling convention of a mode, i.e., it takes a single argument, which is either 1 to turn on the mode and -1 to turn off the mode.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Configure &lt;code&gt;consult-outline&#39; as a scaled down TOC in a separate buffer (setq vertico-multiform-commands &lt;/code&gt;((consult-outline buffer ,(lambda (_) (text-scale-set -1))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Furthermore you can tune buffer-local settings per command or category.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Change the default sorting function. ;; See &lt;code&gt;vertico-sort-function&#39; and &lt;/code&gt;vertico-sort-override-function&#39;. (setq vertico-multiform-commands &#39;((describe-symbol (vertico-sort-function . vertico-sort-alpha))))&lt;/p&gt; &#xA;&lt;p&gt;(setq vertico-multiform-categories &#39;((symbol (vertico-sort-function . vertico-sort-alpha)) (file (vertico-sort-function . sort-directories-first))))&lt;/p&gt; &#xA;&lt;p&gt;;; Sort directories before files (defun sort-directories-first (files) (setq files (vertico-sort-history-length-alpha files)) (nconc (seq-filter (lambda (x) (string-suffix-p &#34;/&#34; x)) files) (seq-remove (lambda (x) (string-suffix-p &#34;/&#34; x)) files))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Combining these features allows us to fine-tune the completion display even more by adjusting the &lt;del&gt;vertico-buffer-display-action&lt;/del&gt;. We can for example reuse the current window for commands of the &lt;del&gt;consult-grep&lt;/del&gt; category (&lt;del&gt;consult-grep&lt;/del&gt;, &lt;del&gt;consult-git-grep&lt;/del&gt; and &lt;del&gt;consult-ripgrep&lt;/del&gt;). Note that this configuration is incompatible with Consult preview, since the previewed buffer is usually shown in exactly this window. Nevertheless this snippet demonstrates the flexibility of the configuration system.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Configure the buffer display and the buffer display action (setq vertico-multiform-categories &#39;((consult-grep buffer (vertico-buffer-display-action . (display-buffer-same-window)))))&lt;/p&gt; &#xA;&lt;p&gt;;; Disable preview for consult-grep commands (consult-customize consult-ripgrep consult-git-grep consult-grep :preview-key nil) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;As another example, the following code uses &lt;del&gt;vertico-flat&lt;/del&gt; and &lt;del&gt;vertico-cycle&lt;/del&gt; to emulate &lt;del&gt;(ido-mode &#39;buffer)&lt;/del&gt;, i.e., Ido when it is enabled only for completion of buffer names. &lt;del&gt;vertico-cycle&lt;/del&gt; set to &lt;del&gt;t&lt;/del&gt; is necessary here to prevent completion candidates from disappearing when they scroll off-screen to the left.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq vertico-multiform-categories &#39;((buffer flat (vertico-cycle . t)))) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Complementary packages :properties: :custom_id: complementary-packages &lt;span&gt;🔚&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Vertico integrates well with complementary packages, which enrich the completion UI. These packages are fully supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/minad/marginalia][Marginalia]]: Rich annotations in the minibuffer&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/consult][Consult]]: Useful search and navigation commands&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/oantolin/embark][Embark]]: Minibuffer actions and context menu&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/oantolin/orderless][Orderless]]: Advanced completion style&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In order to get accustomed with the package ecosystem, I recommend the following quick start approach:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Start with plain Emacs (&lt;del&gt;emacs -Q&lt;/del&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Install and enable Vertico to get incremental minibuffer completion.&lt;/li&gt; &#xA; &lt;li&gt;Install Orderless and/or configure the built-in completion styles for more flexible minibuffer filtering.&lt;/li&gt; &#xA; &lt;li&gt;Install Marginalia if you like rich minibuffer annotations.&lt;/li&gt; &#xA; &lt;li&gt;Install Embark and add two keybindings for &lt;del&gt;embark-dwim&lt;/del&gt; and &lt;del&gt;embark-act&lt;/del&gt;. I am using the mnemonic keybindings =M-.= and =C-.= since these commands allow you to act on the object at point or in the minibuffer.&lt;/li&gt; &#xA; &lt;li&gt;Install Consult if you want additional featureful completion commands, e.g., the buffer switcher &lt;del&gt;consult-buffer&lt;/del&gt; with preview or the line-based search &lt;del&gt;consult-line&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Install Embark-Consult and Wgrep for export from =consult-line= to =occur-mode= buffers and from =consult-grep= to editable =grep-mode= buffers.&lt;/li&gt; &#xA; &lt;li&gt;Fine tune Vertico with [[#extensions][extensions]].&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The ecosystem is modular. You don&#39;t have to use all of these components. Use only the ones you like and the ones which fit well into your setup. The steps 1. to 4. introduce no new commands over plain Emacs. Step 5. introduces the new commands &lt;del&gt;embark-act&lt;/del&gt; and &lt;del&gt;embark-dwim&lt;/del&gt;. In step 6. you get the Consult commands, some offer new functionality not present in Emacs already (e.g., &lt;del&gt;consult-line&lt;/del&gt;) and some are substitutes (e.g., &lt;del&gt;consult-buffer&lt;/del&gt; for &lt;del&gt;switch-to-buffer&lt;/del&gt;).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Child frames and Popups&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;An often requested feature is the ability to display the completions in a child frame popup. Personally I am critical of using child frames for minibuffer completion. From my experience it introduces more problems than it solves. Most importantly child frames hide the content of the underlying buffer. Furthermore child frames do not play well together with changing windows and entering recursive minibuffer sessions. On top, child frames can feel slow and sometimes flicker. A better alternative is the &lt;del&gt;vertico-buffer&lt;/del&gt; display which can even be configured individually per command using &lt;del&gt;vertico-multiform&lt;/del&gt;. On the plus side of child frames, the completion display appears at the center of the screen, where your eyes are focused. Please give the following packages a try and judge for yourself.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/muffinmad/emacs-mini-frame][mini-frame]]: Display the entire minibuffer in a child frame.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/mini-popup][mini-popup]]: Slightly simpler alternative to mini-frame.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/tumashu/vertico-posframe][vertico-posframe]]: Display only the Vertico minibuffer in a child frame using the posframe library.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alternatives&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are many alternative completion UIs, each UI with its own advantages and disadvantages.&lt;/p&gt; &#xA;&lt;p&gt;Vertico aims to be 100% compliant with all Emacs commands and achieves that with a minimal code base, relying purely on &lt;del&gt;completing-read&lt;/del&gt; while avoiding to invent its own APIs. Inventing a custom API as Helm or Ivy is explicitly avoided in order to increase flexibility and package reuse. Due to its small code base and reuse of the Emacs built-in facilities, bugs and compatibility issues are less likely to occur in comparison to completion UIs or full completion systems, which reimplement a lot of functionality.&lt;/p&gt; &#xA;&lt;p&gt;Since Vertico only provides the UI, you may want to combine it with some of the complementary packages, to give a full-featured completion experience similar to Helm or Ivy. Overall the packages in the spirit of Vertico have a different style than Helm or Ivy. The idea is to have smaller independent components, which one can add and understand step by step. Each component focuses on its niche and tries to be as non-intrusive as possible. Vertico targets users interested in crafting their Emacs precisely to their liking - completion plays an integral part in how the users interacts with Emacs.&lt;/p&gt; &#xA;&lt;p&gt;There are other interactive completion UIs, which follow a similar philosophy:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://git.sr.ht/~protesilaos/mct][Mct]]: Minibuffer and Completions in Tandem. Mct reuses the default &lt;del&gt;&lt;em&gt;Completions&lt;/em&gt;&lt;/del&gt; buffer and enhances it with automatic updates and additional keybindings, to select a candidate and move between minibuffer and completions buffer. Since Mct uses a fully functional buffer you can reuse all your familiar buffer commands inside the completions buffer. The main distinction to Vertico&#39;s approach is that &lt;del&gt;&lt;em&gt;Completions&lt;/em&gt;&lt;/del&gt; buffer displays all matching candidates. This has the advantage that you can interact freely with the candidates and jump around with Isearch or Avy. On the other hand it necessarily causes a slowdown in comparison to Vertico, which only displays a subset of candidates. Mct supports completion in region via its &lt;del&gt;mct-region-mode&lt;/del&gt;. Note that Mct development is currently [[https://protesilaos.com/codelog/2022-04-14-emacs-discontinue-mct/][discontinued]] due to recent changes of the default completion UI on the Emacs master branch.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/oantolin/icomplete-vertical][Icomplete-vertical]]: This package enhances the Emacs builtin Icomplete with a vertical display. In contrast to Vertico, Icomplete rotates the candidates such that the current candidate always appears at the top. From my perspective, candidate rotation feels a bit less intuitive than the UI of Vertico or Selectrum. Note that Emacs 28 offers a built-in &lt;del&gt;icomplete-vertical-mode&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/radian-software/selectrum][Selectrum]]: Selectrum is the predecessor of Vertico, since it directly inspired Vertico. Selectrum has a similar UI and interaction model as Vertico. Vertico offers additional features and is more flexible than Selectrum thanks to its [[#extensions][extensions]]. Unfortunately Selectrum is not fully compatible with every Emacs completion command and dynamic completion tables ([[https://github.com/radian-software/selectrum/issues/481][selectrum#481]]), since it uses its own filtering infrastructure, which deviates from the standard Emacs completion facilities. The filtering infrastructure also leads to a larger and more complex code base. Selectrum is likely getting deprecated in favor of Vertico ([[https://github.com/minad/vertico/issues/237][vertico#237]], [[https://github.com/radian-software/selectrum/issues/598][selectrum#598)]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Resources&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to learn more about Vertico and minibuffer completion, check out the following resources:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/doomemacs/doomemacs/tree/master/modules/completion/vertico][Doom Emacs Vertico Module]]: Vertico is Doom&#39;s default completion system.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/SystemCrafters/crafted-emacs/blob/master/modules/crafted-completion.el][Crafted Emacs Completion Module]]: Vertico and Corfu are used for completion.&lt;/li&gt; &#xA; &lt;li&gt;[[https://git.sr.ht/~protesilaos/dotfiles/tree/master/item/emacs/.emacs.d/][Prot&#39;s Emacs configuration]]: Vertico and Corfu are used for completion.&lt;/li&gt; &#xA; &lt;li&gt;[[https://www.youtube.com/watch?v=fnE0lXoe7Y0][Emacs Completion Explained]] (2022-07-19) by Andrew Tropin.&lt;/li&gt; &#xA; &lt;li&gt;[[https://www.youtube.com/watch?v=w9hHMDyF9V4][Emacs Minibuffer Completions]] (2022-02-12) by Greg Yut.&lt;/li&gt; &#xA; &lt;li&gt;[[https://www.youtube.com/watch?v=hPwDbx--Waw][Vertico Extensions for Emacs]] (2022-01-08) by Karthik Chikmagalur.&lt;/li&gt; &#xA; &lt;li&gt;[[https://youtu.be/5ffb2at2d7w][Using Emacs Episode 80 - Vertico, Marginalia, Consult and Embark]] (2021-10-26) by Mike Zamansky.&lt;/li&gt; &#xA; &lt;li&gt;[[https://www.youtube.com/watch?v=UtqE-lR2HCA][System Crafters Live! - Replacing Ivy and Counsel with Vertico and Consult]] (2021-05-21) by David Wilson.&lt;/li&gt; &#xA; &lt;li&gt;[[https://www.youtube.com/watch?v=J0OaRy85MOo][Streamline Your Emacs Completions with Vertico]] (2021-05-17) by David Wilson.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since this package is part of [[http://elpa.gnu.org/packages/vertico.html][GNU ELPA]] contributions require a copyright assignment to the FSF.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Problematic completion commands&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Vertico is robust in most scenarios. However some completion commands make certain assumptions about the completion styles and the completion UI. Some of these assumptions may not hold in Vertico or other UIs and require minor workarounds.&lt;/p&gt; &#xA;&lt;p&gt;** &lt;del&gt;org-refile&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;org-refile&lt;/del&gt; uses &lt;del&gt;org-olpath-completing-read&lt;/del&gt; to complete the outline path in steps, when &lt;del&gt;org-refile-use-outline-path&lt;/del&gt; is non-nil.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately the implementation of this Org completion table assumes that the &lt;del&gt;basic&lt;/del&gt; completion style is used. The table is incompatible with completion styles like &lt;del&gt;substring&lt;/del&gt;, &lt;del&gt;flex&lt;/del&gt; or &lt;del&gt;orderless&lt;/del&gt;. In order to fix the issue at the root, the completion table should make use of completion boundaries similar to the built-in file completion table. In your user configuration you can prioritize &lt;del&gt;basic&lt;/del&gt; before &lt;del&gt;orderless&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Alternative 1: Use the basic completion style (setq org-refile-use-outline-path &#39;file org-outline-path-complete-in-steps t) (advice-add #&#39;org-olpath-completing-read :around (lambda (&amp;amp;rest args) (minibuffer-with-setup-hook (lambda () (setq-local completion-styles &#39;(basic))) (apply args)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Alternatively you may want to disable the outline path completion in steps. The completion on the full path can be quicker since the input string matches directly against substrings of the full path, which is useful with Orderless. However the list of possible completions becomes much more cluttered.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Alternative 2: Complete full paths (setq org-refile-use-outline-path &#39;file org-outline-path-complete-in-steps nil) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** &lt;del&gt;org-agenda-filter&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Similar to &lt;del&gt;org-refile&lt;/del&gt;, the &lt;del&gt;org-agenda-filter&lt;/del&gt; completion function (&lt;del&gt;org-agenda-filter-completion-function&lt;/del&gt;) does not make use of completion boundaries. Unfortunately =TAB= completion (&lt;del&gt;minibuffer-complete&lt;/del&gt;) does not work for this reason. This affects Vertico and also the Emacs default completion system. For example if you enter &lt;del&gt;+tag&amp;lt;0 TAB&lt;/del&gt; the input is replaced with &lt;del&gt;0:10&lt;/del&gt; which is not correct. With preserved completion boundaries, the expected result would be &lt;del&gt;+tag&amp;lt;0:10&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;** &lt;del&gt;tmm-menubar&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;The text menu bar works well with Vertico but always shows a =&lt;em&gt;Completions&lt;/em&gt;= buffer, which is unwanted if you use the Vertico UI. This completion buffer can be disabled with an advice. If you disabled the standard GUI menu bar and prefer the Vertico interface you may also overwrite the default F10 keybinding.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (global-set-key [f10] #&#39;tmm-menubar) (advice-add #&#39;tmm-add-prompt :after #&#39;minibuffer-hide-completions) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** &lt;del&gt;ffap-menu&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;The command &lt;del&gt;ffap-menu&lt;/del&gt; shows the =&lt;em&gt;Completions&lt;/em&gt;= buffer by default like &lt;del&gt;tmm-menubar&lt;/del&gt;, which is unnecessary with Vertico. This completion buffer can be disabled as follows.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (advice-add #&#39;ffap-menu-ask :around (lambda (&amp;amp;rest args) (cl-letf (((symbol-function #&#39;minibuffer-completion-help) #&#39;ignore)) (apply args)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** &lt;del&gt;completion-table-dynamic&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Dynamic completion tables (&lt;del&gt;completion-table-dynamic&lt;/del&gt;, &lt;del&gt;completion-table-in-turn&lt;/del&gt;, etc.) should work well with Vertico. However the requirement is that the =basic= completion style is enabled. The =basic= style performs prefix filtering by passing the input to the completion table (or the dynamic completion table function). The =basic= completion style must not necessarily be configured with highest priority, it can also come after other completion styles like =orderless=, =substring= or =flex=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq completion-styles &#39;(basic)) ;; (setq completion-styles &#39;(orderless basic)) (completing-read &#34;Dynamic: &#34; (completion-table-dynamic (lambda (str) (list (concat str &#34;1&#34;) (concat str &#34;2&#34;) (concat str &#34;3&#34;))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Submitting the empty string&lt;/p&gt; &#xA;&lt;p&gt;The commands &lt;del&gt;multi-occur&lt;/del&gt;, &lt;del&gt;auto-insert&lt;/del&gt;, &lt;del&gt;bbdb-create&lt;/del&gt; read multiple arguments from the minibuffer with &lt;del&gt;completing-read&lt;/del&gt;, one at a time, until you submit an empty string. You should type =M-RET= (&lt;del&gt;vertico-exit-input&lt;/del&gt;) to finish the loop. Directly pressing =RET= (&lt;del&gt;vertico-exit&lt;/del&gt;) does not work since the first candidate is preselected.&lt;/p&gt; &#xA;&lt;p&gt;The underlying issue is that &lt;del&gt;completing-read&lt;/del&gt; always allows you to exit with the empty string, which is called the /null completion/, even if the &lt;del&gt;REQUIRE-MATCH&lt;/del&gt; argument is non-nil. Try the following two calls to &lt;del&gt;completing-read&lt;/del&gt; with =C-x C-e=:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (completing-read &#34;Select: &#34; &#39;(&#34;first&#34; &#34;second&#34; &#34;third&#34;) nil &#39;require-match) (completing-read &#34;Select: &#34; &#39;(&#34;first&#34; &#34;second&#34; &#34;third&#34;) nil &#39;require-match nil nil &#34;&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In both cases the empty string can be submitted. In the first case no explicit default value is specified and Vertico preselects the &lt;em&gt;first&lt;/em&gt; candidate. In order to exit with the empty string, press =M-RET=. In the second case the explicit default value &#34;&#34; is specified and Vertico preselects the prompt, such that exiting with the empty string is possible by pressing =RET= only.&lt;/p&gt; &#xA;&lt;p&gt;** Tramp hostname completion&lt;/p&gt; &#xA;&lt;p&gt;In combination with Orderless, hostnames are not made available for completion after entering =/ssh:=. In order to avoid this problem, the =basic= completion style should be specified for the file completion category, such that =basic= is tried before =orderless=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq completion-styles &#39;(orderless basic) completion-category-overrides &#39;((file (styles basic partial-completion)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;For users who are familiar with the =completion-style= machinery: You may also define a custom completion style which sets in only for remote files!&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun basic-remote-try-completion (string table pred point) (and (vertico--remote-p string) (completion-basic-try-completion string table pred point))) (defun basic-remote-all-completions (string table pred point) (and (vertico--remote-p string) (completion-basic-all-completions string table pred point))) (add-to-list &#39;completion-styles-alist &#39;(basic-remote basic-remote-try-completion basic-remote-all-completions nil)) (setq completion-styles &#39;(orderless basic) completion-category-overrides &#39;((file (styles basic-remote partial-completion)))) #+end_src&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>minad/corfu</title>
    <updated>2022-07-31T02:10:25Z</updated>
    <id>tag:github.com,2022-07-31:/minad/corfu</id>
    <link href="https://github.com/minad/corfu" rel="alternate"></link>
    <summary type="html">&lt;p&gt;🏝️ corfu.el - Completion Overlay Region FUnction&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: corfu.el - Completion Overlay Region FUnction #+author: Daniel Mendler #+language: en #+export_file_name: corfu.texi #+texinfo_dir_category: Emacs misc features #+texinfo_dir_title: Corfu: (corfu). #+texinfo_dir_desc: Completion Overlay Region FUnction&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img alt=&#34;GNU Emacs&#34; src=&#34;https://github.com/minad/corfu/raw/screenshots/emacs.svg?raw=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/packages/corfu.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/corfu.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/devel/corfu.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/corfu.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Corfu enhances completion at point with a small completion popup. The current candidates are shown in a popup below or above the point. Corfu is the minimalistic &lt;del&gt;completion-in-region&lt;/del&gt; counterpart of the [[https://github.com/minad/vertico][Vertico]] minibuffer UI.&lt;/p&gt; &#xA;&lt;p&gt;Corfu is a small package, which relies on the Emacs completion facilities and concentrates on providing a polished completion UI. Completions are either provided by commands like &lt;del&gt;dabbrev-completion&lt;/del&gt; or by pluggable backends (&lt;del&gt;completion-at-point-functions&lt;/del&gt;, Capfs). Most programming language major modes implement a Capf. Furthermore the language server packages, [[https://github.com/joaotavora/eglot][Eglot]] and [[https://github.com/emacs-lsp/lsp-mode][Lsp-mode]], use Capfs which talk to the LSP server to retrieve the completions. Corfu does not include its own completion backends. The Emacs built-in Capfs and the Capfs provided by other programming language packages are usually sufficient. A few additional Capfs and completion utilities are provided by the [[https://github.com/minad/cape][Cape]] package.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;: Corfu uses child frames to show the popup and falls back to the default setting of the &lt;del&gt;completion-in-region-function&lt;/del&gt; on non-graphical displays. If you want to use Corfu in the terminal, install the package [[https://codeberg.org/akib/emacs-corfu-terminal][corfu-terminal]], which provides an alternative overlay-based display.&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;img src=&#34;https://github.com/minad/corfu/raw/screenshots/light.png?raw=true&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;img src=&#34;https://github.com/minad/corfu/raw/screenshots/dark.png?raw=true&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+toc: headlines 8&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Timer-based auto-completions (/off/ by default, set &lt;del&gt;corfu-auto&lt;/del&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Popup display with scrollbar indicator and arrow key navigation.&lt;/li&gt; &#xA; &lt;li&gt;The popup can be summoned explicitly by pressing =TAB= at any time.&lt;/li&gt; &#xA; &lt;li&gt;The current candidate is inserted with =TAB= and selected with =RET=.&lt;/li&gt; &#xA; &lt;li&gt;Candidates sorting by prefix, string length and alphabetically.&lt;/li&gt; &#xA; &lt;li&gt;The selected candidate is previewed (configurable via &lt;del&gt;corfu-preview-current&lt;/del&gt;).&lt;/li&gt; &#xA; &lt;li&gt;The selected candidate automatically committed on further input by default. (configurable via &lt;del&gt;corfu-preview-current&lt;/del&gt;).&lt;/li&gt; &#xA; &lt;li&gt;The [[https://github.com/oantolin/orderless][Orderless]] completion style is supported. The filter string can contain arbitrary characters, after inserting a space via =M-SPC= (configurable via &lt;del&gt;corfu-quit-at-boundary&lt;/del&gt; and &lt;del&gt;corfu-separator&lt;/del&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Deferred completion style highlighting for performance.&lt;/li&gt; &#xA; &lt;li&gt;Support for candidate annotations and documentation in the echo area.&lt;/li&gt; &#xA; &lt;li&gt;Deprecated candidates are crossed out in the display.&lt;/li&gt; &#xA; &lt;li&gt;Icons can be provided by an external package via margin formatter functions.&lt;/li&gt; &#xA; &lt;li&gt;Extensions: Quick keys, Index keys, Sorting by history, Candidate documentation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation and Configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Corfu is available from [[http://elpa.gnu.org/packages/corfu.html][GNU ELPA]], such that it can be installed directly via &lt;del&gt;package-install&lt;/del&gt;. After installation, the global minor mode can be enabled with =M-x global-corfu-mode=. In order to configure Corfu and other packages in your init.el, you may want to use &lt;del&gt;use-package&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Corfu is highly flexible and customizable via &lt;del&gt;corfu-*&lt;/del&gt; customization variables, such that you can adapt it precisely to your requirements. However in order to quickly try out the Corfu completion package, it should be sufficient to activate &lt;del&gt;global-corfu-mode&lt;/del&gt;. You can experiment with manual completion for example in an Elisp buffer or in an Eshell or Shell buffer. For auto completion, set &lt;del&gt;corfu-auto=t&lt;/del&gt; before turning on &lt;del&gt;global-corfu-mode&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example configuration:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (use-package corfu ;; Optional customizations ;; :custom ;; (corfu-cycle t) ;; Enable cycling for `corfu-next/previous&#39; ;; (corfu-auto t) ;; Enable auto completion ;; (corfu-separator ?\s) ;; Orderless field separator ;; (corfu-quit-at-boundary nil) ;; Never quit at completion boundary ;; (corfu-quit-no-match nil) ;; Never quit, even if there is no match ;; (corfu-preview-current nil) ;; Disable current candidate preview ;; (corfu-preselect-first nil) ;; Disable candidate preselection ;; (corfu-on-exact-match nil) ;; Configure handling of exact matches ;; (corfu-echo-documentation nil) ;; Disable documentation in the echo area ;; (corfu-scroll-margin 5) ;; Use scroll margin&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; Enable Corfu only for certain modes.&#xA;;; :hook ((prog-mode . corfu-mode)&#xA;;;        (shell-mode . corfu-mode)&#xA;;;        (eshell-mode . corfu-mode))&#xA;&#xA;;; Recommended: Enable Corfu globally.&#xA;;; This is recommended since Dabbrev can be used globally (M-/).&#xA;;; See also `corfu-excluded-modes&#39;.&#xA;:init&#xA;(global-corfu-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;;; A few more useful configurations... (use-package emacs :init ;; TAB cycle if there are only few candidates (setq completion-cycle-threshold 3)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; Emacs 28: Hide commands in M-x which do not apply to the current mode.&#xA;;; Corfu commands are hidden, since they are not supposed to be used via M-x.&#xA;;; (setq read-extended-command-predicate&#xA;;;       #&#39;command-completion-default-include-p)&#xA;&#xA;;; Enable indentation+completion using the TAB key.&#xA;;; `completion-at-point&#39; is often bound to M-TAB.&#xA;(setq tab-always-indent &#39;complete))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Dabbrev completion is based on =completion-in-region= and can be used with Corfu. You may want to swap the =dabbrev-completion= with the =dabbrev-expand= key for easier access, if you prefer completion. Also take a look at the =cape-dabbrev= completion at point function provided by my [[https://github.com/minad/cape][Cape]] package.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Use Dabbrev with Corfu! (use-package dabbrev ;; Swap M-/ and C-M-/ :bind ((&#34;M-/&#34; . dabbrev-completion) (&#34;C-M-/&#34; . dabbrev-expand)) ;; Other useful Dabbrev configurations. :custom (dabbrev-ignored-buffer-regexps &#39;(&#34;\.\(?:pdf\|jpe?g\|png\)\&#39;&#34;))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you start to configure the package more deeply, I recommend to give the Orderless completion style a try for filtering. Orderless completion is different from the familiar prefix TAB completion. Corfu can be used with the default completion styles. The use of Orderless is not a necessity.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Optionally use the `orderless&#39; completion style. (use-package orderless :init ;; Configure a custom style dispatcher (see the Consult wiki) ;; (setq orderless-style-dispatchers &#39;(+orderless-dispatch) ;; orderless-component-separator #&#39;orderless-escapable-split-on-space) (setq completion-styles &#39;(orderless basic) completion-category-defaults nil completion-category-overrides &#39;((file (styles . (partial-completion)))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =basic= completion style is specified as fallback in addition to =orderless= in order to ensure that completion commands which rely on dynamic completion tables, e.g., &lt;del&gt;completion-table-dynamic&lt;/del&gt; or &lt;del&gt;completion-table-in-turn&lt;/del&gt;, work correctly. See =+orderless-dispatch= in the [[https://github.com/minad/consult/wiki][Consult wiki]] for an advanced Orderless style dispatcher. Additionally enable =partial-completion= for file path expansion. =partial-completion= is important for file wildcard support. Multiple files can be opened at once with =find-file= if you enter a wildcard. You may also give the =initials= completion style a try.&lt;/p&gt; &#xA;&lt;p&gt;See also the [[https://github.com/minad/corfu/wiki][Corfu Wiki]] and the [[https://github.com/minad/cape][Cape manual]] for additional Capf configuration tips. The Lsp-mode configuration is documented in the wiki. For more general documentation read the chapter about completion in the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html][Emacs manual]]. If you want to create your own Capfs, you can find documentation about completion in the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion.html][Elisp manual]].&lt;/p&gt; &#xA;&lt;p&gt;** Auto completion&lt;/p&gt; &#xA;&lt;p&gt;Auto completion is disabled by default, but can be enabled by setting &lt;del&gt;corfu-auto=t&lt;/del&gt;. Furthermore you may want to configure Corfu to quit completion eagerly, such that the completion popup stays out of your way when it appeared unexpectedly.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Enable auto completion and configure quitting (setq corfu-auto t corfu-quit-no-match &#39;separator) ;; or t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;I recommend to experiment a bit with the various settings and key bindings to find a configuration which works for you. There is no one size fits all solution. Some people like auto completion, some like manual completion, some want to cycle with TAB and some with the arrow keys.&lt;/p&gt; &#xA;&lt;p&gt;In case you like aggressive auto completion settings, where the completion popup appears immediately, I recommend to use a cheap completion style like =basic=, which performs prefix filtering. In this case Corfu completion should still be very fast in buffers with efficient completion backends. You can try the following settings in an Elisp buffer or the Emacs scratch buffer.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Aggressive completion, cheap prefix filtering. (setq-local corfu-auto t corfu-auto-delay 0 corfu-auto-prefix 0 completion-styles &#39;(basic)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you want to combine fast prefix filtering and Orderless filtering you can still do that by defining a custom Orderless completion style via =orderless-define-completion-style=. We use a custom style dispatcher, which enables prefix filtering for input shorter than 4 characters. Note that such a setup is quite advanced. Please refer to the Orderless documentation and source code for further details.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun orderless-fast-dispatch (word index total) (and (= index 0) (= total 1) (length&amp;lt; word 4) `(orderless-regexp . ,(concat &#34;^&#34; (regexp-quote word)))))&lt;/p&gt; &#xA;&lt;p&gt;(orderless-define-completion-style orderless-fast (orderless-dispatch &#39;(orderless-fast-dispatch)) (orderless-matching-styles &#39;(orderless-literal orderless-regexp)))&lt;/p&gt; &#xA;&lt;p&gt;(setq-local corfu-auto t corfu-auto-delay 0 corfu-auto-prefix 0 completion-styles &#39;(orderless-fast)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Completing in the minibuffer&lt;/p&gt; &#xA;&lt;p&gt;Corfu can be used for completion in the minibuffer, since it relies on child frames to display the candidates. By default, &lt;del&gt;global-corfu-mode&lt;/del&gt; does not activate &lt;del&gt;corfu-mode&lt;/del&gt; in the minibuffer, to avoid interference with specialised minibuffer completion UIs like Vertico or Mct. However you may still want to enable Corfu completion for commands like &lt;del&gt;M-:&lt;/del&gt; (&lt;del&gt;eval-expression&lt;/del&gt;) or &lt;del&gt;M-!&lt;/del&gt; (&lt;del&gt;shell-command&lt;/del&gt;), which read from the minibuffer. Activate &lt;del&gt;corfu-mode&lt;/del&gt; only if &lt;del&gt;completion-at-point&lt;/del&gt; is bound in the minibuffer-local keymap to achieve this effect.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun corfu-enable-in-minibuffer () &#34;Enable Corfu in the minibuffer if `completion-at-point&#39; is bound.&#34; (when (where-is-internal #&#39;completion-at-point (list (current-local-map))) ;; (setq-local corfu-auto nil) Enable/disable auto completion (corfu-mode 1))) (add-hook &#39;minibuffer-setup-hook #&#39;corfu-enable-in-minibuffer) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can also enable Corfu more generally for every minibuffer, as long as no other completion UI is active. If you use Mct or Vertico as your main minibuffer completion UI, the following snippet should yield the desired result.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun corfu-enable-always-in-minibuffer () &#34;Enable Corfu in the minibuffer if Vertico/Mct are not active.&#34; (unless (or (bound-and-true-p mct--active) (bound-and-true-p vertico--input)) ;; (setq-local corfu-auto nil) Enable/disable auto completion (corfu-mode 1))) (add-hook &#39;minibuffer-setup-hook #&#39;corfu-enable-always-in-minibuffer 1) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Completing in the Eshell or Shell&lt;/p&gt; &#xA;&lt;p&gt;When completing in the Eshell I recommend conservative local settings without auto completion, such that the completion behavior is similar to widely used shells like Bash, Zsh or Fish.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (add-hook &#39;eshell-mode-hook (lambda () (setq-local corfu-auto nil) (corfu-mode))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;When pressing =RET= while the Corfu popup is visible, the &lt;del&gt;corfu-insert&lt;/del&gt; command will be invoked. This command does inserts the currently selected candidate, but it does not send the prompt input to Eshell or the comint process. Therefore you often have to press =RET= twice which feels like an unnecessary double confirmation. Fortunately it is easy to improve this! In my configuration I define the advice &lt;del&gt;corfu-send-shell&lt;/del&gt; which sends the candidate after insertion.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun corfu-send-shell (&amp;amp;rest _) &#34;Send completion candidate when inside comint/eshell.&#34; (cond ((and (derived-mode-p &#39;eshell-mode) (fboundp &#39;eshell-send-input)) (eshell-send-input)) ((and (derived-mode-p &#39;comint-mode) (fboundp &#39;comint-send-input)) (comint-send-input))))&lt;/p&gt; &#xA;&lt;p&gt;(advice-add #&#39;corfu-insert :after #&#39;corfu-send-shell) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Shell completion uses the flexible &lt;del&gt;Pcomplete&lt;/del&gt; mechanism internally, which allows you to program the completions per shell command. If you want to know more, look into this [[https://www.masteringemacs.org/article/pcomplete-context-sensitive-completion-emacs][blog post]], which shows how to configure Pcomplete for git commands. I recommend the [[https://github.com/JonWaltman/pcmpl-args.el][pcmpl-args]] package which extends Pcomplete with completion support and helpful annotation support for more commands. Similar to the Fish shell, pcmpl-args uses man page parsing and --help output parsing to dynamically generate completions. This package brings Eshell completion to another level!&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately Pcomplete has a few technical issues, which we can work around with the [[https://github.com/minad/cape][Cape]] library (Completion at point extensions). Cape provides wrappers, which sanitize the Pcomplete function. Ideally the bugs in Pcomplete should be fixed upstream. &lt;em&gt;For now these two advices are strongly recommended to achieve a sane Eshell experience.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Silence the pcomplete capf, no errors or messages! (advice-add &#39;pcomplete-completions-at-point :around #&#39;cape-wrap-silent)&lt;/p&gt; &#xA;&lt;p&gt;;; Ensure that pcomplete does not write to the buffer ;; and behaves as a pure `completion-at-point-function&#39;. (advice-add &#39;pcomplete-completions-at-point :around #&#39;cape-wrap-purify) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Orderless completion&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/oantolin/orderless][Orderless]] is an advanced completion style that supports multi-component search filters separated by a configurable character (space, by default). Normally, entering characters like space which lie outside the completion region boundaries (words, typically) causes Corfu to quit. This behavior is helpful with auto-completion, which may pop-up when not desired, e.g. on entering a new variable name. Just keep typing and Corfu will get out of the way.&lt;/p&gt; &#xA;&lt;p&gt;But orderless search terms can contain arbitrary characters; they are also interpreted as regular expressions. To use orderless, set &lt;del&gt;corfu-separator&lt;/del&gt; (a space, by default) to the primary character of your orderless component separator.&lt;/p&gt; &#xA;&lt;p&gt;Then, when a new orderless component is desired, use =M-SPC= (&lt;del&gt;corfu-insert-separator&lt;/del&gt;) to enter the /first/ component separator in the input, and arbitrary orderless search terms and new separators can be entered thereafter.&lt;/p&gt; &#xA;&lt;p&gt;To treat the entire input as Orderless input, you can set the customization option &lt;del&gt;corfu-quit-at-boundary=t&lt;/del&gt;. This disables the predicate which checks if the current completion boundary has been left. In contrast, if you /always/ want to quit at the boundary, simply set &lt;del&gt;corfu-quit-at-boundary=nil&lt;/del&gt;. By default &lt;del&gt;corfu-quit-at-boundary&lt;/del&gt; is set to &lt;del&gt;separator&lt;/del&gt; which quits at completion boundaries as long as no separator has been inserted with &lt;del&gt;corfu-insert-separator&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Finally, there exists the user option &lt;del&gt;corfu-quit-no-match&lt;/del&gt; which is set to =separator= by default. With this setting Corfu stays alive as soon as you start advanced filtering with a &lt;del&gt;corfu-separator&lt;/del&gt; even if there are no matches, for example due to a typo. As long as no separator character has been inserted with &lt;del&gt;corfu-insert-separator&lt;/del&gt;, Corfu will still quit if there are no matches. This ensures that the Corfu popup goes away quickly if completion is not possible.&lt;/p&gt; &#xA;&lt;p&gt;In the following we show two configurations, one which works best with auto completion and one which may work better with manual completion if you prefer to always use =SPC= to separate the Orderless components.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Auto completion example (use-package corfu :custom (corfu-auto t) ;; Enable auto completion ;; (corfu-separator ?_) ;; Set to orderless separator, if not using space :bind ;; Another key binding can be used, such as S-SPC. ;; (:map corfu-map (&#34;M-SPC&#34; . corfu-insert-separator)) :init (global-corfu-mode))&lt;/p&gt; &#xA;&lt;p&gt;;; Manual completion example (use-package corfu :custom ;; (corfu-separator ?_) ;; Set to orderless separator, if not using space :bind ;; Configure SPC for separator insertion (:map corfu-map (&#34;SPC&#34; . corfu-insert-separator)) :init (global-corfu-mode)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** TAB-and-Go completion&lt;/p&gt; &#xA;&lt;p&gt;You may be interested in configuring Corfu in TAB-and-Go style. Pressing TAB moves to the next candidate and further input will then commit the selection. Note that further input will not expand snippets or templates, which may not be desired but which leads overall to a more predictable behavior. In order to force snippet expansion, confirm a candidate explicitly with &lt;del&gt;RET&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (use-package corfu ;; TAB-and-Go customizations :custom (corfu-cycle t) ;; Enable cycling for `corfu-next/previous&#39; (corfu-preselect-first nil) ;; Disable candidate preselection&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; Use TAB for cycling, default is `corfu-complete&#39;.&#xA;:bind&#xA;(:map corfu-map&#xA;      (&#34;TAB&#34; . corfu-next)&#xA;      ([tab] . corfu-next)&#xA;      (&#34;S-TAB&#34; . corfu-previous)&#xA;      ([backtab] . corfu-previous))&#xA;&#xA;:init&#xA;(global-corfu-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Transfer completion to the minibuffer&lt;/p&gt; &#xA;&lt;p&gt;Sometimes it is useful to transfer the Corfu completion session to the minibuffer, since the minibuffer offers richer interaction features. In particular, [[https://github.com/oantolin/embark][Embark]] is available in the minibuffer, such that you can act on the candidates or export/collect the candidates to a separate buffer. Hopefully we can also add Corfu-support to Embark in the future, such that at least export/collect is possible directly from Corfu. But in my opinion having the ability to transfer the Corfu completion to the minibuffer is an even better feature, since further completion can be performed there.&lt;/p&gt; &#xA;&lt;p&gt;The command &lt;del&gt;corfu-move-to-minibuffer&lt;/del&gt; is defined here in terms of &lt;del&gt;consult-completion-in-region&lt;/del&gt;, which uses the minibuffer completion UI via &lt;del&gt;completing-read&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun corfu-move-to-minibuffer () (interactive) (let ((completion-extra-properties corfu--extra) completion-cycle-threshold completion-cycling) (apply #&#39;consult-completion-in-region completion-in-region--data))) (define-key corfu-map &#34;\M-m&#34; #&#39;corfu-move-to-minibuffer) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Key bindings&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Corfu uses a transient keymap &lt;del&gt;corfu-map&lt;/del&gt; which is active while the popup is shown. The keymap defines the following remappings and bindings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;beginning-of-buffer&lt;/del&gt; -&amp;gt; &lt;del&gt;corfu-first&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;end-of-buffer&lt;/del&gt; -&amp;gt; &lt;del&gt;corfu-last&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;scroll-down-command&lt;/del&gt; -&amp;gt; &lt;del&gt;corfu-scroll-down&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;scroll-up-command&lt;/del&gt; -&amp;gt; &lt;del&gt;corfu-scroll-up&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;next-line&lt;/del&gt;, =down=, =M-n= -&amp;gt; &lt;del&gt;corfu-next&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;previous-line&lt;/del&gt;, =up=, =M-p= -&amp;gt; &lt;del&gt;corfu-previous&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;completion-at-point&lt;/del&gt;, =TAB= -&amp;gt; &lt;del&gt;corfu-complete&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;=RET= -&amp;gt; &lt;del&gt;corfu-insert&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;=M-g= -&amp;gt; &lt;del&gt;corfu-info-location&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;=M-h= -&amp;gt; &lt;del&gt;corfu-info-documentation&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;=M-SPC= -&amp;gt; &lt;del&gt;corfu-insert-separator&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;=C-g= -&amp;gt; &lt;del&gt;corfu-quit&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;keyboard-escape-quit&lt;/del&gt; -&amp;gt; &lt;del&gt;corfu-reset&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Extensions :properties: :custom_id: extensions &lt;span&gt;🔚&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We maintain small extension packages to Corfu in this repository in the subdirectory [[https://github.com/minad/corfu/tree/main/extensions][extensions/]]. The extensions are installed together with Corfu if you pull the package from ELPA. The extensions are inactive by default and can be enabled manually if desired. Furthermore it is possible to install all of the files separately, both &lt;del&gt;corfu.el&lt;/del&gt; and the &lt;del&gt;corfu-*.el&lt;/del&gt; extensions. Currently the following extensions come with the Corfu ELPA package:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/minad/corfu/blob/main/extensions/corfu-history.el][corfu-history]]: =corfu-history-mode= to remember selected candidates and to improve sorting.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/corfu/blob/main/extensions/corfu-indexed.el][corfu-indexed]]: =corfu-indexed-mode= to select indexed candidates with prefix arguments.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/corfu/blob/main/extensions/corfu-info.el][corfu-info]]: Actions to access the candidate location and documentation.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/corfu/blob/main/extensions/corfu-quick.el][corfu-quick]]: Commands to select using Avy-style quick keys.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the Commentary of those files for configuration details.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Complementary packages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Corfu works well together with all packages providing code completion via the &lt;del&gt;completion-at-point-functions&lt;/del&gt;. Many modes and packages already provide a Capf out of the box. Nevertheless you may want to look into complementary packages to enhance your setup.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://codeberg.org/akib/emacs-corfu-terminal][corfu-terminal]]: The corfu-terminal package provides an overlay-based display for Corfu, such that you can use Corfu in terminal Emacs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://github.com/galeo/corfu-doc][corfu-doc]]: The corfu-doc package displays the candidate documentation in a popup next to the Corfu popup, similar to =company-quickhelp=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://github.com/oantolin/orderless][Orderless]]: Corfu supports completion styles, including the advanced [[https://github.com/oantolin/orderless][Orderless]] completion style, where the filtering expressions are separated by spaces or another character (see &lt;del&gt;corfu-separator&lt;/del&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://github.com/minad/cape][Cape]]: Additional Capf backends and =completion-in-region= commands are provided by the [[https://github.com/minad/cape][Cape]] package. Among others, the package supplies a file path and a Dabbrev completion backend. Cape provides the &lt;del&gt;cape-company-to-capf&lt;/del&gt; adapter to reuse Company backends in Corfu. Furthermore the function &lt;del&gt;cape-super-capf&lt;/del&gt; can merge multiple Capfs, such that the candidates of multiple Capfs are displayed together at the same time.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://github.com/jdtsmith/kind-icon][kind-icon]]: Icons are supported by Corfu via an external package. For example the [[https://github.com/jdtsmith/kind-icon][kind-icon]] package provides beautifully styled SVG icons based on monochromatic icon sets like material design.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://github.com/JonWaltman/pcmpl-args.el][pcmpl-args]]: Extend the Eshell/Shell Pcomplete mechanism with support for many more commands. Similar to the Fish shell, Pcomplete uses man page parsing to dynamically retrieve the completions and helpful annotations. This package brings Eshell completions to another level!&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://github.com/minad/tempel][Tempel]]: Tiny template/snippet package with templates in Lisp syntax, which can be used in conjunction with Corfu.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://github.com/minad/vertico][Vertico]]: You may also want to look into my [[https://github.com/minad/vertico][Vertico]] package. Vertico is the minibuffer completion counterpart of Corfu.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alternatives&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://github.com/company-mode/company-mode][Company]]: Company is a widely used and mature completion package, which implements a similar interaction model and popup UI as Corfu. While Corfu relies exclusively on the standard Emacs completion API (Capfs), Company defines its own API for the backends. Company includes its completion backends, which are incompatible with the Emacs completion infrastructure. As a result of this design, Company is a more complex package than Corfu. Company by default uses overlays for the popup in contrast to the child frames used by Corfu. Overall both packages work well, but Company integrates less tightly with Emacs. The &lt;del&gt;completion-styles&lt;/del&gt; support is more limited and the &lt;del&gt;completion-at-point&lt;/del&gt; command and the &lt;del&gt;completion-in-region&lt;/del&gt; function do not invoke Company.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://git.sr.ht/~protesilaos/mct][Mct]]: Protesilaos&#39; Minibuffer Confines Transcended package supports both minibuffer completion and completion in region. It reuses the default completion UI for this purpose and installs a timer which live updates the completion buffer. The main advantage of Mct is that you work with a regular Emacs buffer instead of with a popup. You can take advantage of the usual Emacs commands to navigate in the completions buffer. On top, Mct enhances the movement such that you can quickly switch between the completions buffer and the minibuffer or the region which is being completed. Mct does not support timer-based auto completion, but the integration into Emacs is naturally tight. Note that Mct development is currently [[https://protesilaos.com/codelog/2022-04-14-emacs-discontinue-mct/][discontinued]] due to recent changes of the default completion UI on the Emacs master branch.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://github.com/minad/consult][consult-completion-in-region]]: The Consult package provides the function &lt;del&gt;consult-completion-in-region&lt;/del&gt; which can be set as &lt;del&gt;completion-in-region-function&lt;/del&gt; such that it handles &lt;del&gt;completion-at-point&lt;/del&gt;. The function works by transferring the in-buffer completion to the minibuffer. In the minibuffer, the minibuffer completion UI, for example [[https://github.com/minad/vertico][Vertico]] takes over. If you prefer to perform all your completions in the minibuffer &lt;del&gt;consult-completion-in-region&lt;/del&gt; is your best option.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since this package is part of [[http://elpa.gnu.org/packages/corfu.html][GNU ELPA]] contributions require a copyright assignment to the FSF.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>astahlman/ob-async</title>
    <updated>2022-07-31T02:10:25Z</updated>
    <id>tag:github.com,2022-07-31:/astahlman/ob-async</id>
    <link href="https://github.com/astahlman/ob-async" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Asynchronous src_block execution for org-babel&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/astahlman/ob-async&#34;&gt;&lt;img src=&#34;https://travis-ci.org/astahlman/ob-async.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/ob-async&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/ob-async-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/ob-async&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/ob-async-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ob-async&lt;/code&gt; enables asynchronous execution of org-babel src blocks, like this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/astahlman/ob-async/master/readme-demo.gif&#34; alt=&#34;Demo of async sh execution&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ob-async&lt;/code&gt; isn&#39;t tied to src blocks in a specific org-babel language. Simply add the keyword &lt;code&gt;:async&lt;/code&gt; to the header-args of any org-babel src block and invoke &lt;code&gt;ob-async-org-babel-execute-src-block&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ob-async&lt;/code&gt; is available in MELPA. If you&#39;d rather install from source, make sure &lt;code&gt;ob-async.el&lt;/code&gt; is on your &lt;code&gt;load-path&lt;/code&gt;, like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(add-to-list &#39;load-path &#34;$PATH_TO_OB_ASYNC_ROOT_DIR&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Require the package and &lt;code&gt;ob-async&lt;/code&gt; will handle any source block which includes &lt;code&gt;:async&lt;/code&gt; in its header-args.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;ob-async)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ob-async&lt;/code&gt; should work with no additional setup for most languages. However, there are a few known edge-cases which require extra configuration.&lt;/p&gt; &#xA;&lt;h3&gt;ob-async-no-async-languages-alist&lt;/h3&gt; &#xA;&lt;p&gt;Some org-babel languages (e.g., &lt;code&gt;ob-python&lt;/code&gt;) define their own &lt;code&gt;:async&lt;/code&gt; keyword that conflicts with &lt;code&gt;ob-async&lt;/code&gt;. &lt;code&gt;ob-async&lt;/code&gt; will ignore any languages in this blacklist, even if the &lt;code&gt;:async&lt;/code&gt; keywords is present. Note that the &lt;code&gt;-alist&lt;/code&gt; suffix is misleading; this variable actually represents a plain list and will be renamed in a future release.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setq ob-async-no-async-languages-alist &#39;(&#34;ipython&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For additional context, see &lt;a href=&#34;https://github.com/astahlman/ob-async/pull/35&#34;&gt;https://github.com/astahlman/ob-async/pull/35&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;ob-async-pre-execute-src-block-hook&lt;/h3&gt; &#xA;&lt;p&gt;Some org-babel languages require additional user configuration. For example, &lt;code&gt;ob-julia&lt;/code&gt; requires &lt;code&gt;inferior-julia-program-name&lt;/code&gt; to be defined. Normally you would define such variables in your &lt;code&gt;init.el&lt;/code&gt;, but src block execution occurs in an Emacs subprocess which does not evaluate &lt;code&gt;init.el&lt;/code&gt; on startup. Instead, you can place initialization logic in &lt;code&gt;ob-async-pre-execute-src-block-hook&lt;/code&gt;, which runs before execution of every src block.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(add-hook &#39;ob-async-pre-execute-src-block-hook&#xA;        &#39;(lambda ()&#xA;           (setq inferior-julia-program-name &#34;/usr/local/bin/julia&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For additional context, see &lt;a href=&#34;https://github.com/astahlman/ob-async/issues/37&#34;&gt;https://github.com/astahlman/ob-async/issues/37&lt;/a&gt; and &lt;a href=&#34;https://github.com/jwiegley/emacs-async/pull/73&#34;&gt;https://github.com/jwiegley/emacs-async/pull/73&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cask/cask&#34;&gt;Cask&lt;/a&gt; manages dependencies and runs tests. Once Cask is installed, you can &lt;code&gt;make test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;First, go through the troubleshooting checklist, &lt;code&gt;troubleshooting.org&lt;/code&gt;. It&#39;s an org-mode file in this repository that&#39;s designed to diagnose issues with ob-async. If that doesn&#39;t solve your problem, include a copy of the entire file (which will include your &lt;code&gt;#+RESULTS&lt;/code&gt; blocks) in a Github issue.&lt;/p&gt;</summary>
  </entry>
</feed>