<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-03T02:07:52Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>minad/org-modern</title>
    <updated>2022-06-03T02:07:52Z</updated>
    <id>tag:github.com,2022-06-03:/minad/org-modern</id>
    <link href="https://github.com/minad/org-modern" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ¦„ Modern Org Style&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: Modern Org Style #+author: Daniel Mendler #+language: en&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img alt=&#34;GNU Emacs&#34; src=&#34;https://github.com/minad/corfu/raw/screenshots/emacs.svg?raw=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/packages/org-modern.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/org-modern.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/devel/org-modern.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/org-modern.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/org-modern&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/org-modern-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://stable.melpa.org/#/org-modern&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/org-modern-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Introduction&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This package implements a &#34;modern&#34; style for your Org buffers using font locking and text properties. The package styles headlines, keywords, tables and source blocks. The styling is configurable, you can enable, disable or modify the style of each syntax element individually via the =org-modern= customization group.&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/minad/org-modern/blob/screenshots/example.gif?raw=true]]&lt;/p&gt; &#xA;&lt;p&gt;The screenshots shows [[file:example.org][example.org]] with =org-modern-mode= turned on and off. The elegant theme featured in the screenshot is [[https://protesilaos.com/emacs/modus-themes][modus-operandi]].&lt;/p&gt; &#xA;&lt;p&gt;This package is still early in its development, so expect bugs and issues in particular due to unfortunate interactions of the =variable-pitch= and =fixed-pitch= fonts. You should ensure that your fonts combine harmonically and have approximately the same height. =org-modern-mode= tries to adjust the tag label display based on the value of =line-spacing=. This looks best if =line-spacing= has a value between 0.1 and 0.4 in the Org buffer. Note that =org-indent-mode= interferes with some of the style elements applied by =org-modern-mode=, e.g., the block brackets in the fringe.&lt;/p&gt; &#xA;&lt;p&gt;Bug reports, improvement or style proposals are welcome! Maybe some more Org elements deserve styling or alternative stylings should be offered?&lt;/p&gt; &#xA;&lt;p&gt;The tag style of =org-modern= is a poor Emacsien&#39;s ripoff from Nicholas Rougier&#39;s beautiful [[https://github.com/rougier/svg-tag-mode][svg-tag-mode]]. In contrast to =svg-tag-mode=, this package avoids images and uses cheap and fast Emacs box text properties. By only styling the text via text properties, the styled text, e.g., dates or tags stay editable and are easy to interact with.&lt;/p&gt; &#xA;&lt;p&gt;On the downside, this restricts our flexibility and may lead to font-dependent issues. We do our best, but for example there is no way we can get round corners. Combining =org-modern-mode= with =svg-tag-mode= is possible. You can use SVG tags and use the table and block styling from =org-modern=. If you are interested in further tweaks, Emacs comes with the builtin =prettify-symbols-mode= which can be used for individual styling of custom keywords.&lt;/p&gt; &#xA;&lt;p&gt;Another popular alternative is [[https://github.com/integral-dw/org-superstar-mode][org-superstar]], which has a more restricted feature set and mainly adjusts headlines and lists. =org-superstar= relies on character composition, while =org-modern= uses text properties, which are considered more future-proof.&lt;/p&gt; &#xA;&lt;p&gt;The package is available on GNU ELPA and MELPA. You can install the package with =package-install=. Then =org-modern= can be enabled manually in an Org buffer by invoking =M-x org-modern-mode=. In order to enable =org-modern= for all your Org buffers, add =org-modern-mode= to the Org mode hooks.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Option 1: Per buffer (add-hook &#39;org-mode-hook #&#39;org-modern-mode) (add-hook &#39;org-agenda-finalize-hook #&#39;org-modern-agenda)&lt;/p&gt; &#xA;&lt;p&gt;;; Option 2: Globally (global-org-modern-mode) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Try the following minimal setup in =emacs -Q= to emulate the looks of the screenshot above.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Minimal UI (package-initialize) (menu-bar-mode -1) (tool-bar-mode -1) (scroll-bar-mode -1) (modus-themes-load-operandi)&lt;/p&gt; &#xA;&lt;p&gt;;; Choose some fonts ;; (set-face-attribute &#39;default nil :family &#34;Iosevka&#34;) ;; (set-face-attribute &#39;variable-pitch nil :family &#34;Iosevka Aile&#34;) ;; (set-face-attribute &#39;org-modern-symbol nil :family &#34;Iosevka&#34;)&lt;/p&gt; &#xA;&lt;p&gt;;; Add frame borders and window dividers (modify-all-frames-parameters &#39;((right-divider-width . 40) (internal-border-width . 40))) (dolist (face &#39;(window-divider window-divider-first-pixel window-divider-last-pixel)) (face-spec-reset-face face) (set-face-foreground face (face-attribute &#39;default :background))) (set-face-background &#39;fringe (face-attribute &#39;default :background))&lt;/p&gt; &#xA;&lt;p&gt;(setq ;; Edit settings org-auto-align-tags nil org-tags-column 0 org-catch-invisible-edits &#39;show-and-error org-special-ctrl-a/e t org-insert-heading-respect-content t&lt;/p&gt; &#xA;&lt;p&gt;;; Org styling, hide markup etc. org-hide-emphasis-markers t org-pretty-entities t org-ellipsis &#34;â€¦&#34;&lt;/p&gt; &#xA;&lt;p&gt;;; Agenda styling org-agenda-block-separator ?â”€ org-agenda-time-grid &#39;((daily today require-timed) (800 1000 1200 1400 1600 1800 2000) &#34; â”„â”„â”„â”„â”„ &#34; &#34;â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„&#34;) org-agenda-current-time-string &#34;â­  now â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&#34;)&lt;/p&gt; &#xA;&lt;p&gt;(global-org-modern-mode) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since this package is part of [[http://elpa.gnu.org/packages/org-modern.html][GNU ELPA]] contributions require a copyright assignment to the FSF.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jwiegley/use-package</title>
    <updated>2022-06-03T02:07:52Z</updated>
    <id>tag:github.com,2022-06-03:/jwiegley/use-package</id>
    <link href="https://github.com/jwiegley/use-package" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A use-package declaration for simplifying your .emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;code&gt;use-package&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/use-package/Lobby?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/use-package/Lobby.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/use-package/Lobby&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/jwiegley/use-package&#34;&gt;&lt;img src=&#34;https://travis-ci.org/jwiegley/use-package.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.milkbox.net/#/use-package&#34;&gt;&lt;img src=&#34;http://melpa.milkbox.net/packages/use-package-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/use-package&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/use-package-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;use-package&lt;/code&gt; macro allows you to isolate package configuration in your &lt;code&gt;.emacs&lt;/code&gt; file in a way that is both performance-oriented and, well, tidy. I created it because I have over 80 packages that I use in Emacs, and things were getting difficult to manage. Yet with this utility my total load time is around 2 seconds, with no loss of functionality!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;use-package&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; a package manager! Although &lt;code&gt;use-package&lt;/code&gt; does have the useful capability to interface with package managers (see &lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#package-installation&#34;&gt;below&lt;/a&gt;), its primary purpose is for the configuration and loading of packages.&lt;/p&gt; &#xA;&lt;p&gt;Notes for users upgrading to 2.x are located &lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#upgrading-to-2x&#34;&gt;at the bottom&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#installing-use-package&#34;&gt;Installing use-package&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#getting-started&#34;&gt;Getting started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#key-binding&#34;&gt;Key-binding&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#binding-to-keymaps&#34;&gt;Binding to keymaps&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#binding-within-local-keymaps&#34;&gt;Binding within local keymaps&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#modes-and-interpreters&#34;&gt;Modes and interpreters&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#magic-handlers&#34;&gt;Magic handlers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#hooks&#34;&gt;Hooks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#package-customization&#34;&gt;Package customization&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#customizing-variables&#34;&gt;Customizing variables&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#customizing-faces&#34;&gt;Customizing faces&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#notes-about-lazy-loading&#34;&gt;Notes about lazy loading&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#information-about-package-loads&#34;&gt;Information about package loads&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#conditional-loading&#34;&gt;Conditional loading&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#conditional-loading-before-preface&#34;&gt;Conditional loading before :preface&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#loading-packages-in-sequence&#34;&gt;Loading packages in a sequence&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#prevent-loading-if-dependencies-are-missing&#34;&gt;Prevent loading if dependencies are missing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#byte-compiling-your-emacs&#34;&gt;Byte compiling your .emacs&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#prevent-a-package-from-loading-at-compile-time&#34;&gt;Prevent a package from loading at compile-time&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#extending-the-load-path&#34;&gt;Extending the load-path&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#catching-errors-during-use-package-expansion&#34;&gt;Catching errors during use-package expansion&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#diminishing-and-delighting-minor-modes&#34;&gt;Diminishing and delighting minor modes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#package-installation&#34;&gt;Package installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#usage-with-other-package-managers&#34;&gt;Usage with other package managers&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#gathering-statistics&#34;&gt;Gathering Statistics&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#keyword-extensions&#34;&gt;Keyword Extensions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#use-package-ensure-system-package&#34;&gt;use-package-ensure-system-package&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#use-package-chords&#34;&gt;use-package-chords&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#how-to-create-an-extension&#34;&gt;How to create an extension&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#first-step-add-the-keyword&#34;&gt;First step: Add the keyword&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#second-step-create-a-normalizer&#34;&gt;Second step: Create a normalizer&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#third-step-create-a-handler&#34;&gt;Third step: Create a handler&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#fourth-step-test-it-out&#34;&gt;Fourth step: Test it out&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#some-timing-results&#34;&gt;Some timing results&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#upgrading-to-2x&#34;&gt;Upgrading to 2.x&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#semantics-of-init-is-now-consistent&#34;&gt;Semantics of :init is now consistent&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#idle-has-been-removed&#34;&gt;:idle has been removed&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#defer-now-accepts-an-optional-numeric-argument&#34;&gt;:defer now accepts an optional numeric argument&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#add-preface-occurring-before-everything-except-disabled&#34;&gt;Add :preface, occuring before everything except :disabled&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#add-functions-for-declaring-functions-to-the-byte-compiler&#34;&gt;Add :functions, for declaring functions to the byte-compiler&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#use-packageel-is-no-longer-needed-at-runtime&#34;&gt;use-package.el is no longer needed at runtime&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installing use-package&lt;/h2&gt; &#xA;&lt;p&gt;Either clone from this GitHub repository or install from &lt;a href=&#34;http://melpa.milkbox.net/&#34;&gt;MELPA&lt;/a&gt; (recommended).&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Here is the simplest &lt;code&gt;use-package&lt;/code&gt; declaration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; This is only needed once, near the top of the file&#xA;(eval-when-compile&#xA;  ;; Following line is not needed if use-package.el is in ~/.emacs.d&#xA;  (add-to-list &#39;load-path &#34;&amp;lt;path where use-package is installed&amp;gt;&#34;)&#xA;  (require &#39;use-package))&#xA;&#xA;(use-package foo)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This loads in the package &lt;code&gt;foo&lt;/code&gt;, but only if &lt;code&gt;foo&lt;/code&gt; is available on your system. If not, a warning is logged to the &lt;code&gt;*Messages*&lt;/code&gt; buffer.&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;:init&lt;/code&gt; keyword to execute code before a package is loaded. It accepts one or more forms, up to the next keyword:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package foo&#xA;  :init&#xA;  (setq foo-variable t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, &lt;code&gt;:config&lt;/code&gt; can be used to execute code after a package is loaded. In cases where loading is done lazily (see more about autoloading below), this execution is deferred until after the autoload occurs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package foo&#xA;  :init&#xA;  (setq foo-variable t)&#xA;  :config&#xA;  (foo-mode 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you might expect, you can use &lt;code&gt;:init&lt;/code&gt; and &lt;code&gt;:config&lt;/code&gt; together:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package color-moccur&#xA;  :commands (isearch-moccur isearch-all)&#xA;  :bind ((&#34;M-s O&#34; . moccur)&#xA;         :map isearch-mode-map&#xA;         (&#34;M-o&#34; . isearch-moccur)&#xA;         (&#34;M-O&#34; . isearch-moccur-all))&#xA;  :init&#xA;  (setq isearch-lazy-highlight t)&#xA;  :config&#xA;  (use-package moccur-edit))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, I want to autoload the commands &lt;code&gt;isearch-moccur&lt;/code&gt; and &lt;code&gt;isearch-all&lt;/code&gt; from &lt;code&gt;color-moccur.el&lt;/code&gt;, and bind keys both at the global level and within the &lt;code&gt;isearch-mode-map&lt;/code&gt; (see next section). When the package is actually loaded (by using one of these commands), &lt;code&gt;moccur-edit&lt;/code&gt; is also loaded, to allow editing of the &lt;code&gt;moccur&lt;/code&gt; buffer.&lt;/p&gt; &#xA;&lt;h2&gt;Key-binding&lt;/h2&gt; &#xA;&lt;p&gt;Another common thing to do when loading a module is to bind a key to primary commands within that module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :bind (&#34;C-.&#34; . ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This does two things: first, it creates an autoload for the &lt;code&gt;ace-jump-mode&lt;/code&gt; command and defers loading of &lt;code&gt;ace-jump-mode&lt;/code&gt; until you actually use it. Second, it binds the key &lt;code&gt;C-.&lt;/code&gt; to that command. After loading, you can use &lt;code&gt;M-x describe-personal-keybindings&lt;/code&gt; to see all such keybindings you&#39;ve set throughout your &lt;code&gt;.emacs&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;A more literal way to do the exact same thing is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :commands ace-jump-mode&#xA;  :init&#xA;  (bind-key &#34;C-.&#34; &#39;ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you use the &lt;code&gt;:commands&lt;/code&gt; keyword, it creates autoloads for those commands and defers loading of the module until they are used. Since the &lt;code&gt;:init&lt;/code&gt; form is always run -- even if &lt;code&gt;ace-jump-mode&lt;/code&gt; might not be on your system -- remember to restrict &lt;code&gt;:init&lt;/code&gt; code to only what would succeed either way.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;:bind&lt;/code&gt; keyword takes either a cons or a list of conses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package hi-lock&#xA;  :bind ((&#34;M-o l&#34; . highlight-lines-matching-regexp)&#xA;         (&#34;M-o r&#34; . highlight-regexp)&#xA;         (&#34;M-o w&#34; . highlight-phrase)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;:commands&lt;/code&gt; keyword likewise takes either a symbol or a list of symbols.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: inside strings, special keys like &lt;code&gt;tab&lt;/code&gt; or &lt;code&gt;F1&lt;/code&gt;-&lt;code&gt;Fn&lt;/code&gt; have to be written inside angle brackets, e.g. &lt;code&gt;&#34;C-&amp;lt;up&amp;gt;&#34;&lt;/code&gt;. Standalone special keys (and some combinations) can be written in square brackets, e.g. &lt;code&gt;[tab]&lt;/code&gt; instead of &lt;code&gt;&#34;&amp;lt;tab&amp;gt;&#34;&lt;/code&gt;. The syntax for the keybindings is similar to the &#34;kbd&#34; syntax: see &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html&#34;&gt;https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package helm&#xA;  :bind ((&#34;M-x&#34; . helm-M-x)&#xA;         (&#34;M-&amp;lt;f5&amp;gt;&#34; . helm-find-files)&#xA;         ([f10] . helm-buffers-list)&#xA;         ([S-f10] . helm-recentf)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Furthermore, &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/elisp/Remapping-Commands.html&#34;&gt;remapping commands&lt;/a&gt; with &lt;code&gt;:bind&lt;/code&gt; and &lt;code&gt;bind-key&lt;/code&gt; works as expected, because when the binding is a vector, it is passed straight to &lt;code&gt;define-key&lt;/code&gt;. So the following example will rebind &lt;code&gt;M-q&lt;/code&gt; (originally &lt;code&gt;fill-paragraph&lt;/code&gt;) to &lt;code&gt;unfill-toggle&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package unfill&#xA;  :bind ([remap fill-paragraph] . unfill-toggle))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Binding to keymaps&lt;/h3&gt; &#xA;&lt;p&gt;Normally &lt;code&gt;:bind&lt;/code&gt; expects that commands are functions that will be autoloaded from the given package. However, this does not work if one of those commands is actually a keymap, since keymaps are not functions, and cannot be autoloaded using Emacs&#39; &lt;code&gt;autoload&lt;/code&gt; mechanism.&lt;/p&gt; &#xA;&lt;p&gt;To handle this case, &lt;code&gt;use-package&lt;/code&gt; offers a special, limited variant of &lt;code&gt;:bind&lt;/code&gt; called &lt;code&gt;:bind-keymap&lt;/code&gt;. The only difference is that the &#34;commands&#34; bound to by &lt;code&gt;:bind-keymap&lt;/code&gt; must be keymaps defined in the package, rather than command functions. This is handled behind the scenes by generating custom code that loads the package containing the keymap, and then re-executes your keypress after the first load, to reinterpret that keypress as a prefix key.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package projectile&#xA;  :bind-keymap&#xA;  (&#34;C-c p&#34; . projectile-command-map))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Binding within local keymaps&lt;/h3&gt; &#xA;&lt;p&gt;Slightly different from binding a key to a keymap, is binding a key &lt;em&gt;within&lt;/em&gt; a local keymap that only exists after the package is loaded. &lt;code&gt;use-package&lt;/code&gt; supports this with a &lt;code&gt;:map&lt;/code&gt; modifier, taking the local keymap to bind to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package helm&#xA;  :bind (:map helm-command-map&#xA;         (&#34;C-c h&#34; . helm-execute-persistent-action)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The effect of this statement is to wait until &lt;code&gt;helm&lt;/code&gt; has loaded, and then to bind the key &lt;code&gt;C-c h&lt;/code&gt; to &lt;code&gt;helm-execute-persistent-action&lt;/code&gt; within Helm&#39;s local keymap, &lt;code&gt;helm-mode-map&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Multiple uses of &lt;code&gt;:map&lt;/code&gt; may be specified. Any binding occurring before the first use of &lt;code&gt;:map&lt;/code&gt; are applied to the global keymap:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package term&#xA;  :bind ((&#34;C-c t&#34; . term)&#xA;         :map term-mode-map&#xA;         (&#34;M-p&#34; . term-send-up)&#xA;         (&#34;M-n&#34; . term-send-down)&#xA;         :map term-raw-map&#xA;         (&#34;M-o&#34; . other-window)&#xA;         (&#34;M-p&#34; . term-send-up)&#xA;         (&#34;M-n&#34; . term-send-down)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Modes and interpreters&lt;/h2&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:bind&lt;/code&gt;, you can use &lt;code&gt;:mode&lt;/code&gt; and &lt;code&gt;:interpreter&lt;/code&gt; to establish a deferred binding within the &lt;code&gt;auto-mode-alist&lt;/code&gt; and &lt;code&gt;interpreter-mode-alist&lt;/code&gt; variables. The specifier to either keyword can be a cons cell, a list of cons cells, or a string or regexp:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ruby-mode&#xA;  :mode &#34;\\.rb\\&#39;&#34;&#xA;  :interpreter &#34;ruby&#34;)&#xA;&#xA;;; The package is &#34;python&#34; but the mode is &#34;python-mode&#34;:&#xA;(use-package python&#xA;  :mode (&#34;\\.py\\&#39;&#34; . python-mode)&#xA;  :interpreter (&#34;python&#34; . python-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you aren&#39;t using &lt;code&gt;:commands&lt;/code&gt;, &lt;code&gt;:bind&lt;/code&gt;, &lt;code&gt;:bind*&lt;/code&gt;, &lt;code&gt;:bind-keymap&lt;/code&gt;, &lt;code&gt;:bind-keymap*&lt;/code&gt;, &lt;code&gt;:mode&lt;/code&gt;, &lt;code&gt;:interpreter&lt;/code&gt;, or &lt;code&gt;:hook&lt;/code&gt; (all of which imply &lt;code&gt;:defer&lt;/code&gt;; see the docstring for &lt;code&gt;use-package&lt;/code&gt; for a brief description of each), you can still defer loading with the &lt;code&gt;:defer&lt;/code&gt; keyword:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :defer t&#xA;  :init&#xA;  (autoload &#39;ace-jump-mode &#34;ace-jump-mode&#34; nil t)&#xA;  (bind-key &#34;C-.&#34; &#39;ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This does exactly the same thing as the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :bind (&#34;C-.&#34; . ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Magic handlers&lt;/h2&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:mode&lt;/code&gt; and &lt;code&gt;:interpreter&lt;/code&gt;, you can also use &lt;code&gt;:magic&lt;/code&gt; and &lt;code&gt;:magic-fallback&lt;/code&gt; to cause certain function to be run if the beginning of a file matches a given regular expression. The difference between the two is that &lt;code&gt;:magic-fallback&lt;/code&gt; has a lower priority than &lt;code&gt;:mode&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package pdf-tools&#xA;  :load-path &#34;site-lisp/pdf-tools/lisp&#34;&#xA;  :magic (&#34;%PDF&#34; . pdf-view-mode)&#xA;  :config&#xA;  (pdf-tools-install :no-query))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This registers an autoloaded command for &lt;code&gt;pdf-view-mode&lt;/code&gt;, defers loading of &lt;code&gt;pdf-tools&lt;/code&gt;, and runs &lt;code&gt;pdf-view-mode&lt;/code&gt; if the beginning of a buffer matches the string &lt;code&gt;&#34;%PDF&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Hooks&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;:hook&lt;/code&gt; keyword allows adding functions onto package hooks. Thus, all of the following are equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :hook prog-mode)&#xA;&#xA;(use-package ace-jump-mode&#xA;  :hook (prog-mode . ace-jump-mode))&#xA;&#xA;(use-package ace-jump-mode&#xA;  :commands ace-jump-mode&#xA;  :init&#xA;  (add-hook &#39;prog-mode-hook #&#39;ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And likewise, when multiple hooks should be applied, the following are also equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :hook (prog-mode text-mode))&#xA;&#xA;(use-package ace-jump-mode&#xA;  :hook ((prog-mode text-mode) . ace-jump-mode))&#xA;&#xA;(use-package ace-jump-mode&#xA;  :hook ((prog-mode . ace-jump-mode)&#xA;         (text-mode . ace-jump-mode)))&#xA;&#xA;(use-package ace-jump-mode&#xA;  :commands ace-jump-mode&#xA;  :init&#xA;  (add-hook &#39;prog-mode-hook #&#39;ace-jump-mode)&#xA;  (add-hook &#39;text-mode-hook #&#39;ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using &lt;code&gt;:hook&lt;/code&gt; omit the &#34;-hook&#34; suffix if you specify the hook explicitly, as this is appended by default. For example the following code will not work as it attempts to add to the &lt;code&gt;prog-mode-hook-hook&lt;/code&gt; which does not exist:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; DOES NOT WORK&#xA;(use-package ace-jump-mode&#xA;  :hook (prog-mode-hook . ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you do not like this behaviour, set &lt;code&gt;use-package-hook-name-suffix&lt;/code&gt; to nil. By default the value of this variable is &#34;-hook&#34;.&lt;/p&gt; &#xA;&lt;p&gt;The use of &lt;code&gt;:hook&lt;/code&gt;, as with &lt;code&gt;:bind&lt;/code&gt;, &lt;code&gt;:mode&lt;/code&gt;, &lt;code&gt;:interpreter&lt;/code&gt;, etc., causes the functions being hooked to implicitly be read as &lt;code&gt;:commands&lt;/code&gt; (meaning they will establish interactive &lt;code&gt;autoload&lt;/code&gt; definitions for that module, if not already defined as functions), and so &lt;code&gt;:defer t&lt;/code&gt; is also implied by &lt;code&gt;:hook&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Package customization&lt;/h2&gt; &#xA;&lt;h3&gt;Customizing variables.&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:custom&lt;/code&gt; keyword allows customization of package custom variables.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package comint&#xA;  :custom&#xA;  (comint-buffer-maximum-size 20000 &#34;Increase comint buffer size.&#34;)&#xA;  (comint-prompt-read-only t &#34;Make the prompt read only.&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The documentation string is not mandatory.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: these are only for people who wish to keep customizations with their accompanying use-package declarations. Functionally, the only benefit over using &lt;code&gt;setq&lt;/code&gt; in a &lt;code&gt;:config&lt;/code&gt; block is that customizations might execute code when values are assigned.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The customized values are &lt;strong&gt;not&lt;/strong&gt; saved in the Emacs &lt;code&gt;custom-file&lt;/code&gt;. Thus you should either use the &lt;code&gt;:custom&lt;/code&gt; option &lt;strong&gt;or&lt;/strong&gt; you should use &lt;code&gt;M-x customize-option&lt;/code&gt; which will save customized values in the Emacs &lt;code&gt;custom-file&lt;/code&gt;. Do not use both.&lt;/p&gt; &#xA;&lt;h3&gt;Customizing faces&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:custom-face&lt;/code&gt; keyword allows customization of package custom faces.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package eruby-mode&#xA;  :custom-face&#xA;  (eruby-standard-face ((t (:slant italic)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Notes about lazy loading&lt;/h2&gt; &#xA;&lt;p&gt;In almost all cases you don&#39;t need to manually specify &lt;code&gt;:defer t&lt;/code&gt;. This is implied whenever &lt;code&gt;:bind&lt;/code&gt; or &lt;code&gt;:mode&lt;/code&gt; or &lt;code&gt;:interpreter&lt;/code&gt; is used. Typically, you only need to specify &lt;code&gt;:defer&lt;/code&gt; if you know for a fact that some other package will do something to cause your package to load at the appropriate time, and thus you would like to defer loading even though use-package isn&#39;t creating any autoloads for you.&lt;/p&gt; &#xA;&lt;p&gt;You can override package deferral with the &lt;code&gt;:demand&lt;/code&gt; keyword. Thus, even if you use &lt;code&gt;:bind&lt;/code&gt;, using &lt;code&gt;:demand&lt;/code&gt; will force loading to occur immediately and not establish an autoload for the bound key.&lt;/p&gt; &#xA;&lt;h2&gt;Information about package loads&lt;/h2&gt; &#xA;&lt;p&gt;When a package is loaded, and if you have &lt;code&gt;use-package-verbose&lt;/code&gt; set to &lt;code&gt;t&lt;/code&gt;, or if the package takes longer than 0.1s to load, you will see a message to indicate this loading activity in the &lt;code&gt;*Messages*&lt;/code&gt; buffer. The same will happen for configuration, or &lt;code&gt;:config&lt;/code&gt; blocks that take longer than 0.1s to execute. In general, you should keep &lt;code&gt;:init&lt;/code&gt; forms as simple and quick as possible, and put as much as you can get away with into the &lt;code&gt;:config&lt;/code&gt; block. This way, deferred loading can help your Emacs to start as quickly as possible.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, if an error occurs while initializing or configuring a package, this will not stop your Emacs from loading. Rather, the error will be captured by &lt;code&gt;use-package&lt;/code&gt;, and reported to a special &lt;code&gt;*Warnings*&lt;/code&gt; popup buffer, so that you can debug the situation in an otherwise functional Emacs.&lt;/p&gt; &#xA;&lt;h2&gt;Conditional loading&lt;/h2&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;:if&lt;/code&gt; keyword to predicate the loading and initialization of modules.&lt;/p&gt; &#xA;&lt;p&gt;For example, I only want &lt;code&gt;edit-server&lt;/code&gt; running for my main, graphical Emacs, not for other Emacsen I may start at the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package edit-server&#xA;  :if window-system&#xA;  :init&#xA;  (add-hook &#39;after-init-hook &#39;server-start t)&#xA;  (add-hook &#39;after-init-hook &#39;edit-server-start t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In another example, we can load things conditional on the operating system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package exec-path-from-shell&#xA;  :if (memq window-system &#39;(mac ns))&#xA;  :ensure t&#xA;  :config&#xA;  (exec-path-from-shell-initialize))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;:disabled&lt;/code&gt; keyword can turn off a module you&#39;re having difficulties with, or stop loading something you&#39;re not using at the present time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ess-site&#xA;  :disabled&#xA;  :commands R)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When byte-compiling your &lt;code&gt;.emacs&lt;/code&gt; file, disabled declarations are omitted from the output entirely, to accelerate startup times.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;:when&lt;/code&gt; is provided as an alias for &lt;code&gt;:if&lt;/code&gt;, and &lt;code&gt;:unless foo&lt;/code&gt; means the same thing as &lt;code&gt;:if (not foo)&lt;/code&gt;. For example, the following will also stop &lt;code&gt;:ensure&lt;/code&gt; from happening on Mac systems:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(when (memq window-system &#39;(mac ns))&#xA;  (use-package exec-path-from-shell&#xA;    :ensure t&#xA;    :config&#xA;    (exec-path-from-shell-initialize)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Conditional loading before :preface&lt;/h3&gt; &#xA;&lt;p&gt;If you need to conditionalize a use-package form so that the condition occurs before even the &lt;code&gt;:preface&lt;/code&gt; is executed, simply use &lt;code&gt;when&lt;/code&gt; around the use-package form itself:&lt;/p&gt; &#xA;&lt;h3&gt;Loading packages in sequence&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes it only makes sense to configure a package after another has been loaded, because certain variables or functions are not in scope until that time. This can achieved using an &lt;code&gt;:after&lt;/code&gt; keyword that allows a fairly rich description of the exact conditions when loading should occur. Here is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package hydra&#xA;  :load-path &#34;site-lisp/hydra&#34;)&#xA;&#xA;(use-package ivy&#xA;  :load-path &#34;site-lisp/swiper&#34;)&#xA;&#xA;(use-package ivy-hydra&#xA;  :after (ivy hydra))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, because all of these packages are demand-loaded in the order they occur, the use of &lt;code&gt;:after&lt;/code&gt; is not strictly necessary. By using it, however, the above code becomes order-independent, without an implicit depedence on the nature of your init file.&lt;/p&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;:after (foo bar)&lt;/code&gt; is the same as &lt;code&gt;:after (:all foo bar)&lt;/code&gt;, meaning that loading of the given package will not happen until both &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; have been loaded. Here are some of the other possibilities:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;:after (foo bar)&#xA;:after (:all foo bar)&#xA;:after (:any foo bar)&#xA;:after (:all (:any foo bar) (:any baz quux))&#xA;:after (:any (:all foo bar) (:all baz quux))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you nest selectors, such as &lt;code&gt;(:any (:all foo bar) (:all baz quux))&lt;/code&gt;, it means that the package will be loaded when either both &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; have been loaded, or both &lt;code&gt;baz&lt;/code&gt; and &lt;code&gt;quux&lt;/code&gt; have been loaded.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: pay attention if you set &lt;code&gt;use-package-always-defer&lt;/code&gt; to t, and also use the &lt;code&gt;:after&lt;/code&gt; keyword, as you will need to specify how the declared package is to be loaded: e.g., by some &lt;code&gt;:bind&lt;/code&gt;. If you&#39;re not using one of the mechanisms that registers autoloads, such as &lt;code&gt;:bind&lt;/code&gt; or &lt;code&gt;:hook&lt;/code&gt;, and your package manager does not provide autoloads, it&#39;s possible that without adding &lt;code&gt;:demand t&lt;/code&gt; to those declarations, your package will never be loaded.&lt;/p&gt; &#xA;&lt;h3&gt;Prevent loading if dependencies are missing&lt;/h3&gt; &#xA;&lt;p&gt;While the &lt;code&gt;:after&lt;/code&gt; keyword delays loading until the dependencies are loaded, the somewhat simpler &lt;code&gt;:requires&lt;/code&gt; keyword simply never loads the package if the dependencies are not available at the time the &lt;code&gt;use-package&lt;/code&gt; declaration is encountered. By &#34;available&#34; in this context it means that &lt;code&gt;foo&lt;/code&gt; is available if &lt;code&gt;(featurep &#39;foo)&lt;/code&gt; evaluates to a non-nil value. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package abbrev&#xA;  :requires foo)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is the same as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package abbrev&#xA;  :if (featurep &#39;foo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As a convenience, a list of such packages may be specified:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package abbrev&#xA;  :requires (foo bar baz))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more complex logic, such as that supported by &lt;code&gt;:after&lt;/code&gt;, simply use &lt;code&gt;:if&lt;/code&gt; and the appropriate Lisp expression.&lt;/p&gt; &#xA;&lt;h2&gt;Byte-compiling your .emacs&lt;/h2&gt; &#xA;&lt;p&gt;Another feature of &lt;code&gt;use-package&lt;/code&gt; is that it always loads every file that it can when &lt;code&gt;.emacs&lt;/code&gt; is being byte-compiled. This helps to silence spurious warnings about unknown variables and functions.&lt;/p&gt; &#xA;&lt;p&gt;However, there are times when this is just not enough. For those times, use the &lt;code&gt;:defines&lt;/code&gt; and &lt;code&gt;:functions&lt;/code&gt; keywords to introduce dummy variable and function declarations solely for the sake of the byte-compiler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package texinfo&#xA;  :defines texinfo-section-list&#xA;  :commands texinfo-mode&#xA;  :init&#xA;  (add-to-list &#39;auto-mode-alist &#39;(&#34;\\.texi$&#34; . texinfo-mode)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to silence a missing function warning, you can use &lt;code&gt;:functions&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ruby-mode&#xA;  :mode &#34;\\.rb\\&#39;&#34;&#xA;  :interpreter &#34;ruby&#34;&#xA;  :functions inf-ruby-keys&#xA;  :config&#xA;  (defun my-ruby-mode-hook ()&#xA;    (require &#39;inf-ruby)&#xA;    (inf-ruby-keys))&#xA;&#xA;  (add-hook &#39;ruby-mode-hook &#39;my-ruby-mode-hook))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Prevent a package from loading at compile-time&lt;/h3&gt; &#xA;&lt;p&gt;Normally, &lt;code&gt;use-package&lt;/code&gt; will load each package at compile time before compiling the configuration, to ensure that any necessary symbols are in scope to satisfy the byte-compiler. At times this can cause problems, since a package may have special loading requirements, and all that you want to use &lt;code&gt;use-package&lt;/code&gt; for is to add a configuration to the &lt;code&gt;eval-after-load&lt;/code&gt; hook. In such cases, use the &lt;code&gt;:no-require&lt;/code&gt; keyword:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package foo&#xA;  :no-require t&#xA;  :config&#xA;  (message &#34;This is evaluated when `foo&#39; is loaded&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Extending the load-path&lt;/h2&gt; &#xA;&lt;p&gt;If your package needs a directory added to the &lt;code&gt;load-path&lt;/code&gt; in order to load, use &lt;code&gt;:load-path&lt;/code&gt;. This takes a symbol, a function, a string or a list of strings. If the path is relative, it is expanded within &lt;code&gt;user-emacs-directory&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ess-site&#xA;  :load-path &#34;site-lisp/ess/lisp/&#34;&#xA;  :commands R)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: when using a symbol or a function to provide a dynamically generated list of paths, you must inform the byte-compiler of this definition so the value is available at byte-compilation time. This is done by using the special form &lt;code&gt;eval-and-compile&lt;/code&gt; (as opposed to &lt;code&gt;eval-when-compile&lt;/code&gt;). Further, this value is fixed at whatever was determined during compilation, to avoid looking up the same information again on each startup:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(eval-and-compile&#xA;  (defun ess-site-load-path ()&#xA;    (shell-command &#34;find ~ -path ess/lisp&#34;)))&#xA;&#xA;(use-package ess-site&#xA;  :load-path (lambda () (list (ess-site-load-path)))&#xA;  :commands R)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Catching errors during use-package expansion&lt;/h2&gt; &#xA;&lt;p&gt;By default, if &lt;code&gt;use-package-expand-minimally&lt;/code&gt; is nil (the default), use-package will attempts to catch and report errors that occur during expansion of use-package declarations in your init file. Setting &lt;code&gt;use-package-expand-minimally&lt;/code&gt; to t completely disables this checking.&lt;/p&gt; &#xA;&lt;p&gt;This behavior may be overridden locally using the &lt;code&gt;:catch&lt;/code&gt; keyword. If &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;, it enables or disables catching errors at load time. It can also be a function taking two arguments: the keyword being processed at the time the error was encountered, and the error object (as generated by &lt;code&gt;condition-case&lt;/code&gt;). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package example&#xA;  ;; Note that errors are never trapped in the preface, since doing so would&#xA;  ;; hide definitions from the byte-compiler.&#xA;  :preface (message &#34;I&#39;m here at byte-compile and load time.&#34;)&#xA;  :init (message &#34;I&#39;m always here at startup&#34;)&#xA;  :config&#xA;  (message &#34;I&#39;m always here after the package is loaded&#34;)&#xA;  (error &#34;oops&#34;)&#xA;  ;; Don&#39;t try to (require &#39;example), this is just an example!&#xA;  :no-require t&#xA;  :catch (lambda (keyword err)&#xA;           (message (error-message-string err))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Evaluating the above form will print these messages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Iâ€™m here at byte-compile and load time.&#xA;Iâ€™m always here at startup&#xA;Configuring package example...&#xA;Iâ€™m always here after the package is loaded&#xA;oops&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Diminishing and delighting minor modes&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;use-package&lt;/code&gt; also provides built-in support for the diminish and delight utilities -- if you have them installed. Their purpose is to remove or change minor mode strings in your mode-line.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/myrjola/diminish.el&#34;&gt;diminish&lt;/a&gt; is invoked with the &lt;code&gt;:diminish&lt;/code&gt; keyword, which is passed either a minor mode symbol, a cons of the symbol and its replacement string, or just a replacement string, in which case the minor mode symbol is guessed to be the package name with &#34;-mode&#34; appended at the end:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package abbrev&#xA;  :diminish abbrev-mode&#xA;  :config&#xA;  (if (file-exists-p abbrev-file-name)&#xA;      (quietly-read-abbrev-file)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://elpa.gnu.org/packages/delight.html&#34;&gt;delight&lt;/a&gt; is invoked with the &lt;code&gt;:delight&lt;/code&gt; keyword, which is passed a minor mode symbol, a replacement string or quoted &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Data.html&#34;&gt;mode-line data&lt;/a&gt; (in which case the minor mode symbol is guessed to be the package name with &#34;-mode&#34; appended at the end), both of these, or several lists of both. If no arguments are provided, the default mode name is hidden completely.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; Don&#39;t show anything for rainbow-mode.&#xA;(use-package rainbow-mode&#xA;  :delight)&#xA;&#xA;;; Don&#39;t show anything for auto-revert-mode, which doesn&#39;t match&#xA;;; its package name.&#xA;(use-package autorevert&#xA;  :delight auto-revert-mode)&#xA;&#xA;;; Remove the mode name for projectile-mode, but show the project name.&#xA;(use-package projectile&#xA;  :delight &#39;(:eval (concat &#34; &#34; (projectile-project-name))))&#xA;&#xA;;; Completely hide visual-line-mode and change auto-fill-mode to &#34; AF&#34;.&#xA;(use-package emacs&#xA;  :delight&#xA;  (auto-fill-function &#34; AF&#34;)&#xA;  (visual-line-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Package installation&lt;/h2&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;use-package&lt;/code&gt; to load packages from ELPA with &lt;code&gt;package.el&lt;/code&gt;. This is particularly useful if you share your &lt;code&gt;.emacs&lt;/code&gt; among several machines; the relevant packages are downloaded automatically once declared in your &lt;code&gt;.emacs&lt;/code&gt;. The &lt;code&gt;:ensure&lt;/code&gt; keyword causes the package(s) to be installed automatically if not already present on your system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package magit&#xA;  :ensure t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to install a different package from the one named by &lt;code&gt;use-package&lt;/code&gt;, you can specify it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package tex&#xA;  :ensure auctex)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable &lt;code&gt;use-package-always-ensure&lt;/code&gt; if you wish this behavior to be global for all packages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;use-package-ensure)&#xA;(setq use-package-always-ensure t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;:ensure&lt;/code&gt; will install a package if it is not already installed, but it does not keep it up-to-date. If you want to keep your packages updated automatically, one option is to use &lt;a href=&#34;https://github.com/rranelli/auto-package-update.el&#34;&gt;auto-package-update&lt;/a&gt;, like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package auto-package-update&#xA;  :config&#xA;  (setq auto-package-update-delete-old-versions t)&#xA;  (setq auto-package-update-hide-results t)&#xA;  (auto-package-update-maybe))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lastly, when running on Emacs 24.4 or later, use-package can pin a package to a specific archive, allowing you to mix and match packages from different archives. The primary use-case for this is preferring packages from the &lt;code&gt;melpa-stable&lt;/code&gt; and &lt;code&gt;gnu&lt;/code&gt; archives, but using specific packages from &lt;code&gt;melpa&lt;/code&gt; when you need to track newer versions than what is available in the &lt;code&gt;stable&lt;/code&gt; archives is also a valid use-case.&lt;/p&gt; &#xA;&lt;p&gt;By default &lt;code&gt;package.el&lt;/code&gt; prefers &lt;code&gt;melpa&lt;/code&gt; over &lt;code&gt;melpa-stable&lt;/code&gt; due to the versioning &lt;code&gt;(&amp;gt; evil-20141208.623 evil-1.0.9)&lt;/code&gt;, so even if you are tracking only a single package from &lt;code&gt;melpa&lt;/code&gt;, you will need to tag all the non-&lt;code&gt;melpa&lt;/code&gt; packages with the appropriate archive. If this really annoys you, then you can set &lt;code&gt;use-package-always-pin&lt;/code&gt; to set a default.&lt;/p&gt; &#xA;&lt;p&gt;If you want to manually keep a package updated and ignore upstream updates, you can pin it to &lt;code&gt;manual&lt;/code&gt;, which as long as there is no repository by that name, will Just Work(tm).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;use-package&lt;/code&gt; throws an error if you try to pin a package to an archive that has not been configured using &lt;code&gt;package-archives&lt;/code&gt; (apart from the magic &lt;code&gt;manual&lt;/code&gt; archive mentioned above):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Archive &#39;foo&#39; requested for package &#39;bar&#39; is not available.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package company&#xA;  :ensure t&#xA;  :pin melpa-stable)&#xA;&#xA;(use-package evil&#xA;  :ensure t)&#xA;  ;; no :pin needed, as package.el will choose the version in melpa&#xA;&#xA;(use-package adaptive-wrap&#xA;  :ensure t&#xA;  ;; as this package is available only in the gnu archive, this is&#xA;  ;; technically not needed, but it helps to highlight where it&#xA;  ;; comes from&#xA;  :pin gnu)&#xA;&#xA;(use-package org&#xA;  :ensure t&#xA;  ;; ignore org-mode from upstream and use a manually installed version&#xA;  :pin manual)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: the &lt;code&gt;:pin&lt;/code&gt; argument has no effect on emacs versions &amp;lt; 24.4.&lt;/p&gt; &#xA;&lt;h3&gt;Usage with other package managers&lt;/h3&gt; &#xA;&lt;p&gt;By overriding &lt;code&gt;use-package-ensure-function&lt;/code&gt; and/or &lt;code&gt;use-package-pre-ensure-function&lt;/code&gt;, other package managers can override &lt;code&gt;:ensure&lt;/code&gt; to use them instead of &lt;code&gt;package.el&lt;/code&gt;. At the present time, the only package manager that does this is &lt;a href=&#34;https://github.com/raxod502/straight.el&#34;&gt;&lt;code&gt;straight.el&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Gathering Statistics&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;d like to see how many packages you&#39;ve loaded, what stage of initialization they&#39;ve reached, and how much aggregate time they&#39;ve spent (roughly), you can enable &lt;code&gt;use-package-compute-statistics&lt;/code&gt; after loading &lt;code&gt;use-package&lt;/code&gt; but before any &lt;code&gt;use-package&lt;/code&gt; forms, and then run the command &lt;code&gt;M-x use-package-report&lt;/code&gt; to see the results. The buffer displayed is a tabulated list. You can use &lt;code&gt;S&lt;/code&gt; in a column to sort the rows based on it.&lt;/p&gt; &#xA;&lt;h2&gt;Keyword Extensions&lt;/h2&gt; &#xA;&lt;p&gt;Starting with version 2.0, &lt;code&gt;use-package&lt;/code&gt; is based on an extensible framework that makes it easy for package authors to add new keywords, or modify the behavior of existing keywords.&lt;/p&gt; &#xA;&lt;p&gt;Some keyword extensions are now included in the &lt;code&gt;use-package&lt;/code&gt; distribution and can be optionally installed.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;(use-package-ensure-system-package)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:ensure-system-package&lt;/code&gt; keyword allows you to ensure system binaries exist alongside your package declarations.&lt;/p&gt; &#xA;&lt;p&gt;First, you will want to make sure &lt;code&gt;exec-path&lt;/code&gt; is cognisant of all binary package names that you would like to ensure are installed. &lt;a href=&#34;https://github.com/purcell/exec-path-from-shell&#34;&gt;&lt;code&gt;exec-path-from-shell&lt;/code&gt;&lt;/a&gt; is often a good way to do this.&lt;/p&gt; &#xA;&lt;p&gt;To enable the extension after you&#39;ve loaded &lt;code&gt;use-package&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package use-package-ensure-system-package&#xA;  :ensure t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hereâ€™s an example of usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package rg&#xA;  :ensure-system-package rg)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will expect a global binary package to exist called &lt;code&gt;rg&lt;/code&gt;. If it does not, it will use your system package manager (using the package &lt;a href=&#34;https://gitlab.com/jabranham/system-packages&#34;&gt;&lt;code&gt;system-packages&lt;/code&gt;&lt;/a&gt;) to attempt an install of a binary by the same name asynchronously. For example, for most &lt;code&gt;macOS&lt;/code&gt; users this would call: &lt;code&gt;brew install rg&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If the package is named differently than the binary, you can use a cons in the form of &lt;code&gt;(binary . package-name)&lt;/code&gt;, i.e.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package rg&#xA;  :ensure-system-package&#xA;  (rg . ripgrep))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the previous &lt;code&gt;macOS&lt;/code&gt; example, this would call: &lt;code&gt;brew install ripgrep&lt;/code&gt; if &lt;code&gt;rg&lt;/code&gt; was not found.&lt;/p&gt; &#xA;&lt;p&gt;What if you want to customize the install command further?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package tern&#xA;  :ensure-system-package (tern . &#34;npm i -g tern&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;:ensure-system-package&lt;/code&gt; can also take a cons where its &lt;code&gt;cdr&lt;/code&gt; is a string that will get called by &lt;code&gt;(async-shell-command)&lt;/code&gt; to install if it isnâ€™t found.&lt;/p&gt; &#xA;&lt;p&gt;You may also pass in a list of cons-es:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package ruby-mode&#xA;  :ensure-system-package&#xA;  ((rubocop     . &#34;gem install rubocop&#34;)&#xA;   (ruby-lint   . &#34;gem install ruby-lint&#34;)&#xA;   (ripper-tags . &#34;gem install ripper-tags&#34;)&#xA;   (pry         . &#34;gem install pry&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, in case the package dependency does not provide a global executable, you can ensure packages exist by checking the presence of a file path by providing a string like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package dash-at-point&#xA;  :if (eq system-type &#39;darwin)&#xA;  :ensure-system-package&#xA;  (&#34;/Applications/Dash.app&#34; . &#34;brew cask install dash&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;:ensure-system-package&lt;/code&gt; will use &lt;code&gt;system-packages-install&lt;/code&gt; to install system packages, except where a custom command has been specified, in which case it will be executed verbatim by &lt;code&gt;async-shell-command&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Configuration variables &lt;code&gt;system-packages-package-manager&lt;/code&gt; and &lt;code&gt;system-packages-use-sudo&lt;/code&gt; will be honoured, but not for custom commands. Custom commands should include the call to sudo in the command if needed.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;(use-package-chords)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:chords&lt;/code&gt; keyword allows you to define &lt;a href=&#34;http://www.emacswiki.org/emacs/key-chord.el&#34;&gt;&lt;code&gt;key-chord&lt;/code&gt;&lt;/a&gt; bindings for &lt;code&gt;use-package&lt;/code&gt; declarations in the same manner as the &lt;code&gt;:bind&lt;/code&gt; keyword.&lt;/p&gt; &#xA;&lt;p&gt;To enable the extension:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package use-package-chords&#xA;  :ensure t&#xA;  :config (key-chord-mode 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can define your chord bindings in the same manner as &lt;code&gt;:bind&lt;/code&gt; using a cons or a list of conses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :chords ((&#34;jj&#34; . ace-jump-char-mode)&#xA;           (&#34;jk&#34; . ace-jump-word-mode)&#xA;           (&#34;jl&#34; . ace-jump-line-mode)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to create an extension&lt;/h3&gt; &#xA;&lt;h4&gt;First step: Add the keyword&lt;/h4&gt; &#xA;&lt;p&gt;The first step is to add your keyword at the right place in &lt;code&gt;use-package-keywords&lt;/code&gt;. This list determines the order in which things will happen in the expanded code. You should never change this order, but it gives you a framework within which to decide when your keyword should fire.&lt;/p&gt; &#xA;&lt;h4&gt;Second step: Create a normalizer&lt;/h4&gt; &#xA;&lt;p&gt;Define a normalizer for your keyword by defining a function named after the keyword, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun use-package-normalize/:pin (name-symbol keyword args)&#xA;  (use-package-only-one (symbol-name keyword) args&#xA;    (lambda (label arg)&#xA;      (cond&#xA;       ((stringp arg) arg)&#xA;       ((symbolp arg) (symbol-name arg))&#xA;       (t&#xA;        (use-package-error&#xA;         &#34;:pin wants an archive name (a string)&#34;))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The job of the normalizer is take a list of arguments (possibly nil), and turn it into the single argument (which could still be a list) that should appear in the final property list used by &lt;code&gt;use-package&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Third step: Create a handler&lt;/h4&gt; &#xA;&lt;p&gt;Once you have a normalizer, you must create a handler for the keyword:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun use-package-handler/:pin (name-symbol keyword archive-name rest state)&#xA;  (let ((body (use-package-process-keywords name-symbol rest state)))&#xA;    ;; This happens at macro expansion time, not when the expanded code is&#xA;    ;; compiled or evaluated.&#xA;    (if (null archive-name)&#xA;        body&#xA;      (use-package-pin-package name-symbol archive-name)&#xA;      (use-package-concat&#xA;       body&#xA;       `((push &#39;(,name-symbol . ,archive-name)&#xA;               package-pinned-packages))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Handlers can affect the handling of keywords in two ways. First, it can modify the &lt;code&gt;state&lt;/code&gt; plist before recursively processing the remaining keywords, to influence keywords that pay attention to the state (one example is the state keyword &lt;code&gt;:deferred&lt;/code&gt;, not to be confused with the &lt;code&gt;use-package&lt;/code&gt; keyword &lt;code&gt;:defer&lt;/code&gt;). Then, once the remaining keywords have been handled and their resulting forms returned, the handler may manipulate, extend, or just ignore those forms.&lt;/p&gt; &#xA;&lt;p&gt;The task of each handler is to return a &lt;em&gt;list of forms&lt;/em&gt; representing code to be inserted. It does not need to be a &lt;code&gt;progn&lt;/code&gt; list, as this is handled automatically in other places. Thus it is very common to see the idiom of using &lt;code&gt;use-package-concat&lt;/code&gt; to add new functionality before or after a code body, so that only the minimum code necessary is emitted as the result of a &lt;code&gt;use-package&lt;/code&gt; expansion.&lt;/p&gt; &#xA;&lt;h4&gt;Fourth step: Test it out&lt;/h4&gt; &#xA;&lt;p&gt;After the keyword has been inserted into &lt;code&gt;use-package-keywords&lt;/code&gt;, and a normalizer and a handler defined, you can now test it by seeing how usages of the keyword will expand. For this, use &lt;code&gt;M-x pp-macroexpand-last-sexp&lt;/code&gt; with the cursor set immediately after the &lt;code&gt;(use-package ...)&lt;/code&gt; expression.&lt;/p&gt; &#xA;&lt;h2&gt;Some timing results&lt;/h2&gt; &#xA;&lt;p&gt;On my Retina iMac, the &#34;Mac port&#34; variant of Emacs 24.4 loads in 0.57s, with around 218 packages configured (nearly all of them lazy-loaded). However, I experience no loss of functionality, just a bit of latency when I&#39;m first starting to use Emacs (due to the autoloading). Since I also use idle-loading for many packages, perceived latency is typically reduced overall.&lt;/p&gt; &#xA;&lt;p&gt;On Linux, the same configuration loads in 0.32s.&lt;/p&gt; &#xA;&lt;p&gt;If I don&#39;t use Emacs graphically, I can test the absolute minimum times. This is done by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;time emacs -l init.elc -batch --eval &#39;(message &#34;Hello, world!&#34;)&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On the Mac I see an average of 0.36s for the same configuration, and on Linux 0.26s.&lt;/p&gt; &#xA;&lt;h1&gt;Upgrading to 2.x&lt;/h1&gt; &#xA;&lt;h2&gt;Semantics of :init is now consistent&lt;/h2&gt; &#xA;&lt;p&gt;The meaning of &lt;code&gt;:init&lt;/code&gt; has been changed: It now &lt;em&gt;always&lt;/em&gt; happens before package load, whether &lt;code&gt;:config&lt;/code&gt; has been deferred or not. This means that some uses of &lt;code&gt;:init&lt;/code&gt; in your configuration may need to be changed to &lt;code&gt;:config&lt;/code&gt; (in the non-deferred case). For the deferred case, the behavior is unchanged from before.&lt;/p&gt; &#xA;&lt;p&gt;Also, because &lt;code&gt;:init&lt;/code&gt; and &lt;code&gt;:config&lt;/code&gt; now mean &#34;before&#34; and &#34;after&#34;, the &lt;code&gt;:pre-&lt;/code&gt; and &lt;code&gt;:post-&lt;/code&gt; keywords are gone, as they should no longer be necessary.&lt;/p&gt; &#xA;&lt;p&gt;Lastly, an effort has been made to make your Emacs start even in the presence of use-package configuration failures. So after this change, be sure to check your &lt;code&gt;*Messages*&lt;/code&gt; buffer. Most likely, you will have several instances where you are using &lt;code&gt;:init&lt;/code&gt;, but should be using &lt;code&gt;:config&lt;/code&gt; (this was the case for me in a number of places).&lt;/p&gt; &#xA;&lt;h2&gt;:idle has been removed&lt;/h2&gt; &#xA;&lt;p&gt;I am removing this feature for now because it can result in a nasty inconsistency. Consider the following definition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package vkill&#xA;  :commands vkill&#xA;  :idle (some-important-configuration-here)&#xA;  :bind (&#34;C-x L&#34; . vkill-and-helm-occur)&#xA;  :init&#xA;  (defun vkill-and-helm-occur ()&#xA;    (interactive)&#xA;    (vkill)&#xA;    (call-interactively #&#39;helm-occur))&#xA;&#xA;  :config&#xA;  (setq vkill-show-all-processes t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If I load my Emacs and wait until the idle timer fires, then this is the sequence of events:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:init :idle &amp;lt;load&amp;gt; :config&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But if I load Emacs and immediately type C-x L without waiting for the idle timer to fire, this is the sequence of events:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:init &amp;lt;load&amp;gt; :config :idle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s possible that the user could use &lt;code&gt;featurep&lt;/code&gt; in their idle to test for this case, but that&#39;s a subtlety I&#39;d rather avoid.&lt;/p&gt; &#xA;&lt;h2&gt;:defer now accepts an optional numeric argument&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;:defer [N]&lt;/code&gt; causes the package to be loaded -- if it has not already been -- after &lt;code&gt;N&lt;/code&gt; seconds of idle time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package back-button&#xA;  :commands (back-button-mode)&#xA;  :defer 2&#xA;  :init&#xA;  (setq back-button-show-toolbar-buttons nil)&#xA;  :config&#xA;  (back-button-mode 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Add :preface, occurring before everything except :disabled&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;:preface&lt;/code&gt; can be used to establish function and variable definitions that will 1) make the byte-compiler happy (it won&#39;t complain about functions whose definitions are unknown because you have them within a guard block), and 2) allow you to define code that can be used in an &lt;code&gt;:if&lt;/code&gt; test.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: whatever is specified within &lt;code&gt;:preface&lt;/code&gt; is evaluated both at load time and at byte-compilation time, in order to ensure that definitions are seen by both the Lisp evaluator and the byte-compiler, so you should avoid having any side-effects in your preface, and restrict it merely to symbol declarations and definitions.&lt;/p&gt; &#xA;&lt;h2&gt;Add :functions, for declaring functions to the byte-compiler&lt;/h2&gt; &#xA;&lt;p&gt;What &lt;code&gt;:defines&lt;/code&gt; does for variables, &lt;code&gt;:functions&lt;/code&gt; does for functions.&lt;/p&gt; &#xA;&lt;h2&gt;use-package.el is no longer needed at runtime&lt;/h2&gt; &#xA;&lt;p&gt;This means you should put the following at the top of your Emacs, to further reduce load time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(eval-when-compile&#xA;  (require &#39;use-package))&#xA;(require &#39;diminish)                ;; if you use :diminish&#xA;(require &#39;bind-key)                ;; if you use any :bind variant&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>bbatsov/projectile</title>
    <updated>2022-06-03T02:07:52Z</updated>
    <id>tag:github.com,2022-06-03:/bbatsov/projectile</id>
    <link href="https://github.com/bbatsov/projectile" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Project Interaction Library for Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Projectile&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bbatsov/projectile/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/bbatsov/projectile/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/projectile&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/projectile-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/projectile&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/projectile-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.nongnu.org/nongnu/projectile.html&#34;&gt;&lt;img src=&#34;https://elpa.nongnu.org/nongnu/projectile.svg?sanitize=true&#34; alt=&#34;NonGNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?sanitize=true&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Synopsis&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Projectile&lt;/strong&gt; is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a project level without introducing external dependencies (when feasible). For instance - finding project files has a portable implementation written in pure Emacs Lisp without the use of GNU &lt;code&gt;find&lt;/code&gt; (but for performance sake an indexing mechanism backed by external commands exists as well).&lt;/p&gt; &#xA;&lt;p&gt;Projectile tries to be practical - portability is great, but if some external tools could speed up some task substantially and the tools are available, Projectile will leverage them.&lt;/p&gt; &#xA;&lt;p&gt;This library provides easy project management and navigation. The concept of a project is pretty basic - just a folder containing some special file (e.g. a VCS marker or a project descriptor file like &lt;code&gt;pom.xml&lt;/code&gt; or &lt;code&gt;Gemfile&lt;/code&gt;). Projectile will auto-detect pretty much every popular project type out of the box and you can easily extend it with additional project types.&lt;/p&gt; &#xA;&lt;p&gt;Here are some of Projectile&#39;s features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;jump to a file in project&lt;/li&gt; &#xA; &lt;li&gt;jump to a project buffer&lt;/li&gt; &#xA; &lt;li&gt;jump to a test in project&lt;/li&gt; &#xA; &lt;li&gt;toggle between files with same names but different extensions (e.g. &lt;code&gt;.h&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;.c/.cpp&lt;/code&gt;, &lt;code&gt;Gemfile&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;Gemfile.lock&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;toggle between code and its test (e.g. &lt;code&gt;main.service.js&lt;/code&gt; &amp;lt;-&amp;gt; &lt;code&gt;main.service.spec.js&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;jump to recently visited files in the project&lt;/li&gt; &#xA; &lt;li&gt;switch between projects you have worked on&lt;/li&gt; &#xA; &lt;li&gt;kill (close) all project buffers&lt;/li&gt; &#xA; &lt;li&gt;replace in project&lt;/li&gt; &#xA; &lt;li&gt;grep (search) in project&lt;/li&gt; &#xA; &lt;li&gt;run shell commands in a project (e.g. &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;lein&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;support for multiple minibuffer completion/selection libraries (&lt;code&gt;ido&lt;/code&gt;, &lt;code&gt;ivy&lt;/code&gt;, &lt;code&gt;helm&lt;/code&gt; and the default completion system)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.patreon.com/bbatsov&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/patreon-donate-orange.svg?sanitize=true&#34; alt=&#34;Patreon&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;amp;hosted_button_id=GRQKNBM6P8VRQ&#34;&gt;&lt;img src=&#34;https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif&#34; alt=&#34;Paypal&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve been developing Projectile for a decade now (since 2011). While it&#39;s a fun project to work on, it still requires a lot of time and energy to maintain.&lt;/p&gt; &#xA;&lt;p&gt;You can support my work on Projectile via &lt;a href=&#34;https://www.paypal.me/bbatsov&#34;&gt;PayPal&lt;/a&gt;, &lt;a href=&#34;https://www.patreon.com/bbatsov&#34;&gt;Patreon&lt;/a&gt; and &lt;a href=&#34;https://github.com/sponsors/bbatsov&#34;&gt;GitHub Sponsors&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Projectile in Action&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a glimpse of Projectile in action (using &lt;code&gt;ivy&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bbatsov/projectile/master/doc/modules/ROOT/assets/images/projectile-demo.gif&#34; alt=&#34;Projectile Demo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In this short demo you can see:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;finding files in a project&lt;/li&gt; &#xA; &lt;li&gt;switching between implementation and test&lt;/li&gt; &#xA; &lt;li&gt;switching between projects&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;The instructions that follow are meant to get you from zero to a running Projectile setup in a minute. Visit the &lt;a href=&#34;https://docs.projectile.mx&#34;&gt;online documentation&lt;/a&gt; for (way) more details.&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;package.el&lt;/code&gt; is the built-in package manager in Emacs.&lt;/p&gt; &#xA;&lt;p&gt;Projectile is available on all major &lt;code&gt;package.el&lt;/code&gt; community maintained repos - &lt;a href=&#34;https://elpa.nongnu.org&#34;&gt;NonGNU ELPA&lt;/a&gt;, &lt;a href=&#34;http://stable.melpa.org&#34;&gt;MELPA Stable&lt;/a&gt; and &lt;a href=&#34;http://melpa.org&#34;&gt;MELPA&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can install Projectile with the following command:&lt;/p&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x&lt;/kbd&gt; &lt;code&gt;package-install&lt;/code&gt; &lt;kbd&gt;[RET]&lt;/kbd&gt; &lt;code&gt;projectile&lt;/code&gt; &lt;kbd&gt;[RET]&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, users of Debian 9 or later or Ubuntu 16.04 or later may simply &lt;code&gt;apt-get install elpa-projectile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Finally add this to your Emacs config:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(projectile-mode +1)&#xA;;; Recommended keymap prefix on macOS&#xA;(define-key projectile-mode-map (kbd &#34;s-p&#34;) &#39;projectile-command-map)&#xA;;; Recommended keymap prefix on Windows/Linux&#xA;(define-key projectile-mode-map (kbd &#34;C-c p&#34;) &#39;projectile-command-map)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Those keymap prefixes are just a suggestion. Feel free to put there whatever works best for you.&lt;/p&gt; &#xA;&lt;h3&gt;Basic Usage&lt;/h3&gt; &#xA;&lt;p&gt;Enable &lt;code&gt;projectile-mode&lt;/code&gt;, open a file in one of your projects and type a command such as &lt;kbd&gt;C-c p f&lt;/kbd&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://docs.projectile.mx&#34;&gt;online documentation&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Some operations like search (grep) depend (presently) on external utilities such as &lt;code&gt;find&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Commands depending on external utilities might misbehave on the &lt;code&gt;fish&lt;/code&gt; shell.&lt;/li&gt; &#xA; &lt;li&gt;Using Projectile over TRAMP might be slow in certain cases.&lt;/li&gt; &#xA; &lt;li&gt;Some commands might misbehave on complex project setups (e.g. a git project with submodules).&lt;/li&gt; &#xA; &lt;li&gt;Projectile was mostly tested on Unix OS-es (e.g. GNU/Linux and macOS), so some functionality might not work well on Windows.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Known issues&lt;/h2&gt; &#xA;&lt;p&gt;Check out the project&#39;s &lt;a href=&#34;https://github.com/bbatsov/projectile/issues?sort=created&amp;amp;direction=desc&amp;amp;state=open&#34;&gt;issue list&lt;/a&gt; a list of unresolved issues. By the way - feel free to fix any of them and send me a pull request. :-)&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a &lt;a href=&#34;https://github.com/bbatsov/projectile/contributors&#34;&gt;list&lt;/a&gt; of all the people who have contributed to the development of Projectile (a.k.a. Projectile&#39;s Hall of Fame).&lt;/p&gt; &#xA;&lt;p&gt;Joining this esteemed group of people is only a commit away!&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;A fairly extensive changelog is available &lt;a href=&#34;https://raw.githubusercontent.com/bbatsov/projectile/master/CHANGELOG.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright Â© 2011-2021 Bozhidar Batsov and &lt;a href=&#34;https://github.com/bbatsov/projectile/contributors&#34;&gt;contributors&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Distributed under the GNU General Public License, version 3&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>myrjola/diminish.el</title>
    <updated>2022-06-03T02:07:52Z</updated>
    <id>tag:github.com,2022-06-03:/myrjola/diminish.el</id>
    <link href="https://github.com/myrjola/diminish.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Diminished modes are minor modes with no modeline display&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://elpa.gnu.org/packages/diminish.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/packages/diminish.svg?sanitize=true&#34; alt=&#34;GNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.gnu.org/devel/diminish.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/devel/diminish.svg?sanitize=true&#34; alt=&#34;GNU-devel ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/diminish&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/diminish-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/diminish&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/diminish-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;diminish.el&lt;/h1&gt; &#xA;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;When we diminish a mode, we are saying we want it to continue doing its work for us, but we no longer want to be reminded of it. It becomes a night worker, like a janitor; it becomes an invisible man; it remains a component, perhaps an important one, sometimes an indispensable one, of the mechanism that maintains the day-people&#39;s world, but its place in their thoughts is diminished, usually to nothing. As we grow old we diminish more and more such thoughts, such people, usually to nothing. -- Will Mengarini&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This package implements hiding or abbreviation of the mode line displays (lighters) of minor-modes.&lt;/p&gt; &#xA;&lt;h1&gt;Quick start&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;diminish)&#xA;&#xA;(diminish &#39;rainbow-mode)                                       ; Hide lighter from mode-line&#xA;(diminish &#39;rainbow-mode &#34; Rbow&#34;)                               ; Replace rainbow-mode lighter with &#34; Rbow&#34;&#xA;(diminish &#39;rainbow-mode &#39;rainbow-mode-lighter)                 ; Use raingow-mode-lighter variable value&#xA;(diminish &#39;rainbow-mode &#39;(&#34; &#34; &#34;R-&#34; &#34;bow&#34;))                     ; Replace rainbow-mode lighter with &#34; R-bow&#34;&#xA;(diminish &#39;rainbow-mode &#39;((&#34; &#34; &#34;R&#34;) &#34;/&#34; &#34;bow&#34;))                ; Replace rainbow-mode lighter with &#34; R/bow&#34;&#xA;(diminish &#39;rainbow-mode &#39;(:eval (format &#34; Rbow/%s&#34; (+ 2 3))))  ; Replace rainbow-mode lighter with &#34; Rbow/5&#34;&#xA;(diminish &#39;rainbow-mode                                        ; Replace rainbow-mode lighter with greened &#34; Rbow&#34;&#xA;  &#39;(:propertize &#34; Rbow&#34; face &#39;(:foreground &#34;green&#34;)))&#xA;(diminish &#39;rainbow-mode                                        ; If rainbow-mode-mode-linep is non-nil &#34; Rbow/t&#34;&#xA;  &#39;(rainbow-mode-mode-linep &#34; Rbow/t&#34; &#34; Rbow/nil&#34;))&#xA;(diminish &#39;rainbow-mode &#39;(3 &#34; Rbow&#34; &#34;/&#34; &#34;s&#34;))                  ; Replace rainbow-mode lighter with &#34; Rb&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Ref: &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Data.html&#34;&gt;Emacs manual - The Data Structure of the Mode Line&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;John Wiegley&#39;s &lt;a href=&#34;https://github.com/jwiegley/use-package#diminishing-and-delighting-minor-modes&#34;&gt;use-package&lt;/a&gt; macro also has support for diminish.el.&lt;/p&gt; &#xA;&lt;h1&gt;Copyright Assignment&lt;/h1&gt; &#xA;&lt;p&gt;Diminish is subject to the same &lt;a href=&#34;https://www.fsf.org/licensing/contributor-faq&#34;&gt;copyright assignment&lt;/a&gt; policy as GNU Emacs.&lt;/p&gt; &#xA;&lt;p&gt;Any &lt;a href=&#34;https://www.gnu.org/prep/maintain/html_node/Legally-Significant.html#Legally-Significant&#34;&gt;legally significant&lt;/a&gt; contributions can only be merged after the author has completed their paperwork. Please ask for the request form, and we&#39;ll send it to you.&lt;/p&gt; &#xA;&lt;h1&gt;Acknowledgments&lt;/h1&gt; &#xA;&lt;p&gt;diminish.el was created by Will Mengarini on 19th of February 1998 and is now maintained by &lt;a href=&#34;https://github.com/myrjola&#34;&gt;Martin YrjÃ¶lÃ¤&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacs-typescript/typescript.el</title>
    <updated>2022-06-03T02:07:52Z</updated>
    <id>tag:github.com,2022-06-03:/emacs-typescript/typescript.el</id>
    <link href="https://github.com/emacs-typescript/typescript.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;TypeScript-support for Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;typescript.el&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/emacs-typescript/typescript.el/workflows/Build%20&amp;amp;%20Test/badge.svg?sanitize=true&#34; alt=&#34;Build &amp;amp; Test&#34;&gt; &lt;a href=&#34;https://melpa.org/#/typescript-mode&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/typescript-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/typescript-mode&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/typescript-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;typescript.el&lt;/code&gt; is a major-mode for editing &lt;a href=&#34;http://www.typescriptlang.org/&#34;&gt;Typescript&lt;/a&gt;-files in &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;GNU Emacs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;typescript.el&lt;/code&gt; is a self-contained, lightweight and minimalist major-mode focused on providing basic font-lock/syntax-highlighting and indentation for Typescript syntax, without any external dependencies.&lt;/p&gt; &#xA;&lt;p&gt;Output from &lt;code&gt;tsc&lt;/code&gt; and &lt;code&gt;tslint&lt;/code&gt; is also handled seamlessly through &lt;code&gt;compilation-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;typescript.el&lt;/code&gt; can be installed from source directly using your favourite approach or framework, or from MELPA and MELPA Stable as a package.&lt;/p&gt; &#xA;&lt;p&gt;To install typescript.el simply type &lt;code&gt;M-x package-install&amp;lt;RET&amp;gt;typescript-mode&amp;lt;RET&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Customization&lt;/h1&gt; &#xA;&lt;p&gt;To customize &lt;code&gt;typescript.el&lt;/code&gt; just type the following: &lt;code&gt;M-x customize-group&amp;lt;RET&amp;gt;typescript&amp;lt;RET&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can add any other customization you like to &lt;code&gt;typescript-mode-hook&lt;/code&gt; in your &lt;code&gt;init.el&lt;/code&gt; file. &lt;code&gt;typescript.el&lt;/code&gt; also handles &lt;code&gt;prog-mode-hook&lt;/code&gt; on versions of Emacs which supports it.&lt;/p&gt; &#xA;&lt;h1&gt;Support for Compilation Mode&lt;/h1&gt; &#xA;&lt;p&gt;This mode automatically adds support for &lt;code&gt;compilation-mode&lt;/code&gt; so that if you run &lt;code&gt;M-x compile&amp;lt;ret&amp;gt;tsc&amp;lt;ret&amp;gt;&lt;/code&gt; the error messages are correctly parsed.&lt;/p&gt; &#xA;&lt;p&gt;However, the error messages produced by &lt;code&gt;tsc&lt;/code&gt; when its &lt;code&gt;pretty&lt;/code&gt; flag is turned on include ANSI color escapes, which by default &lt;code&gt;compilation-mode&lt;/code&gt; does not interpret. In order to get the escapes parsed, you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;ansi-color)&#xA;(defun colorize-compilation-buffer ()&#xA;  (ansi-color-apply-on-region compilation-filter-start (point-max)))&#xA;(add-hook &#39;compilation-filter-hook &#39;colorize-compilation-buffer)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, if you prefer, you can configure &lt;code&gt;tsc&lt;/code&gt; with the &lt;code&gt;pretty&lt;/code&gt; flag set to &lt;code&gt;false&lt;/code&gt;: &lt;code&gt;tsc --pretty false&lt;/code&gt;. However, doing this does more than just turning off the colors. It also causes &lt;code&gt;tsc&lt;/code&gt; to produce less elaborate error messages.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;To run the tests you can run &lt;code&gt;make test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you prefer, you may run the tests via the provided &lt;code&gt;Dockerfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t typescript-mode .&#xA;docker run --rm -v $(pwd):/typescript-mode typescript-mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Other Typescript-packages of interest&lt;/h1&gt; &#xA;&lt;p&gt;While &lt;code&gt;typescript.el&lt;/code&gt; may &lt;em&gt;not&lt;/em&gt; provide a full kitchen-sink, the good news is that there&#39;s other packages which do!&lt;/p&gt; &#xA;&lt;p&gt;More advanced features can be provided by using these additional packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/emacs-lsp/lsp-mode&#34;&gt;lsp-mode&lt;/a&gt; - A standards-based code-completion and refactoring backend, based on the &lt;a href=&#34;https://langserver.org/&#34;&gt;Language Server Protocol (LSP)&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/ananthakumaran/tide/&#34;&gt;tide&lt;/a&gt; - TypeScript Interactive Development Environment for Emacs&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/josteink/ts-comint&#34;&gt;ts-comint&lt;/a&gt; - a Typescript REPL in Emacs.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Initializing these with &lt;code&gt;typescript.el&lt;/code&gt; will then become a matter of creating your own &lt;code&gt;typescript-mode-hook&lt;/code&gt; in your &lt;code&gt;init.el&lt;/code&gt; file.&lt;/p&gt;</summary>
  </entry>
</feed>