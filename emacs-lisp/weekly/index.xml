<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-01-19T01:38:56Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jdtsmith/ultra-scroll</title>
    <updated>2025-01-19T01:38:56Z</updated>
    <id>tag:github.com,2025-01-19:/jdtsmith/ultra-scroll</id>
    <link href="https://github.com/jdtsmith/ultra-scroll" rel="alternate"></link>
    <summary type="html">&lt;p&gt;scroll Emacs like lightning&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ultra-scroll: scroll emacs like lightning ‚ö°üñ±Ô∏è‚ö°&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;ultra-scroll&lt;/code&gt;[^1] is a smooth-scrolling package for emacs, with native support for standard builds as well as &lt;a href=&#34;https://bitbucket.org/mituharu/emacs-mac&#34;&gt;emacs-mac&lt;/a&gt;. It provides highly optimized, pixel-precise smooth scrolling which can readily keep up with the &lt;em&gt;very&lt;/em&gt; high event rates of modern track-pads and high-precision wheel mice.&lt;/p&gt; &#xA;&lt;p&gt;You move your fingers, the page responds, &lt;em&gt;instantly&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github-production-user-asset-6210df.s3.amazonaws.com/93749/290018933-ed5cf414-eab5-4ba8-b077-30cac0c5ace0.mov&#34;&gt;https://github-production-user-asset-6210df.s3.amazonaws.com/93749/290018933-ed5cf414-eab5-4ba8-b077-30cac0c5ace0.mov&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Importantly, &lt;code&gt;ultra-scroll&lt;/code&gt; can cleanly &lt;em&gt;scroll right across&lt;/em&gt; tall images and other jumbo lines ‚Äì a perennial problem with scrolling packages to date. As a bonus, it enables relatively smooth scrolling even with dumb third party mice on some systems.&lt;/p&gt; &#xA;&lt;p&gt;Note, the &lt;code&gt;previous-buffer&lt;/code&gt; animation above is from two-finger track-pad swiping, and is an &lt;code&gt;emacs-mac&lt;/code&gt; exclusive.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] &lt;strong&gt;Do you need this?&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;If you don&#39;t scroll with a high-speed device (modern mouse or track-pad), no. If you do, but aren&#39;t sure, here&#39;s a good test to try:&lt;/p&gt; &#xA; &lt;p&gt;Open a heavy emacs buffer full screen on your largest monitor. While scrolling smoothly such that lines would move across your window&#39;s full height in about 5 seconds, &lt;em&gt;can you easily read the text you see&lt;/em&gt;, without stopping, in both directions? Now, try this exercise again with your browser ‚Äì I bet it&#39;s &lt;em&gt;very&lt;/em&gt; readable there. Shouldn&#39;t emacs be like this?&lt;/p&gt; &#xA; &lt;p&gt;If you scroll buffers with tall images visible, this is also a good reason to give &lt;code&gt;ultra-scroll&lt;/code&gt; a try.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Release Information&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/jdtsmith/ultra-scroll/main/NEWS.org&#34;&gt;NEWS&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ultra-scroll&lt;/code&gt; should work across all systems that provide pixel-level scrolling information for your input hardware. If you don&#39;t think &lt;code&gt;ultra-scroll&lt;/code&gt; is working for you, run &lt;code&gt;M-x ultra-scroll-check&lt;/code&gt;, and follow the directions. If it reports:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Normal pixel scroll data&lt;/strong&gt;: you are good to go, everything is working.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;No real pixel scroll data&lt;/strong&gt;: your system and hardware are delivering pixel scrolling data, but they &lt;em&gt;never change&lt;/em&gt;. This is equivalent to line-by-line scrolling. &lt;code&gt;ultra-scroll&lt;/code&gt; will work fine for you, but &lt;em&gt;without&lt;/em&gt; any smooth scrolling. You can use it for the improved large image scrolling behavior, or see below for another option.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;em&gt;error&lt;/em&gt; &lt;strong&gt;Malformed wheel event&lt;/strong&gt;: your system does not deliver &lt;em&gt;any&lt;/em&gt; pixel-level scroll data. Either upgrade your hardware/system to a known working config (see &lt;a href=&#34;https://raw.githubusercontent.com/jdtsmith/issues/18&#34;&gt;this issue&lt;/a&gt; for user experiences), or see below.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For systems which do &lt;em&gt;not&lt;/em&gt; provide normal pixel scroll data, you can try the built-in &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt; with &lt;code&gt;pixel-scroll-precision-interpolate-mice&lt;/code&gt; (which &#34;creates&#34; events by interpolation) instead.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] &lt;strong&gt;Your Help Needed!&lt;/strong&gt; While &lt;code&gt;ultra-scroll&lt;/code&gt; works out of the box for most people, it&#39;s impossible to test all combinations of systems and hardware, so please take a moment to &lt;a href=&#34;https://raw.githubusercontent.com/jdtsmith/issues/18&#34;&gt;report your smooth-scrolling experiences&lt;/a&gt; for the benefit of others.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Not yet in a package archive. For Emacs 29.1 and later, use &lt;code&gt;package-vc-install&lt;/code&gt;. In the &lt;code&gt;*scratch*&lt;/code&gt; buffer, enter&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;(package-vc-install &#39;(ultra-scroll :vc-backend Git :url  &#34;https://github.com/jdtsmith/ultra-scroll&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;move to the final paren, and &lt;code&gt;C-x C-e&lt;/code&gt;. Installation is then simple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;(use-package ultra-scroll&#xA;  ;:load-path &#34;~/code/emacs/ultra-scroll&#34; ; if you git clone&#39;d instead of package-vc-install&#xA;  :init&#xA;  (setq scroll-conservatively 101 ; important!&#xA;        scroll-margin 0) &#xA;  :config&#xA;  (ultra-scroll-mode 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Just start scrolling :).&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP] For best performance, use a build with native-compilation (see &lt;a href=&#34;https://raw.githubusercontent.com/jdtsmith/ultra-scroll/main/#Speed&#34;&gt;Speed&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;There is little to no configuration.&lt;/p&gt; &#xA;&lt;h3&gt;Altering dumb mice behavior on emacs-mac&lt;/h3&gt; &#xA;&lt;p&gt;If desired for use with dumb mice on &lt;code&gt;emacs-mac&lt;/code&gt;, the variable &lt;code&gt;ultra-scroll-mac-multiplier&lt;/code&gt; can be set to a number smaller or larger than &lt;code&gt;1.0&lt;/code&gt; to decrease/increase mouse-wheel scrolling speed. Note that many fancier wheeled mice have drivers that &lt;em&gt;simulate&lt;/em&gt; track-pads, so this variable will have no effect on them. For these, and for track-pads generally, scrolling speed should be configured in system settings.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] Only certain systems provide real variable pixel scroll offset data (&lt;code&gt;PIXEL-DELTA&lt;/code&gt;) for older/wheeled (&#34;dumb&#34;) mice. Use &lt;code&gt;M-x ultra-scroll-check&lt;/code&gt; to see if yours does. If not, it&#39;s recommended to upgrade hardware, or stick with &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Mitigating garbage collection pauses&lt;/h3&gt; &#xA;&lt;p&gt;To reduce the likelihood of garbage collection during scroll, which can introduce slight pauses, the value of &lt;code&gt;gc-cons-percentage&lt;/code&gt; is temporarily increased, and reset during idle time. The defaults should work well for most situations, but if necessary, can be configured using &lt;code&gt;ultra-scroll-gc-percentage&lt;/code&gt; and &lt;code&gt;ultra-scroll-gc-idle-time&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Hiding cursor and disabling other modes during scroll&lt;/h3&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;ultra-scroll&lt;/code&gt; hides the cursor (and a &lt;code&gt;hl-line&lt;/code&gt; if active) once it reaches the window edge, to prevent &#34;bouncing cursor&#34; behavior. This can be disabled, or the time delay to restore the cursor set, with &lt;code&gt;ultra-scroll-hide-cursor&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In addition to the cursor, it is sometimes useful to temporarily disable other modes during the scroll. The special hook variable &lt;code&gt;ultra-scroll-hide-functions&lt;/code&gt; can be used for this, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-commonlisp&#34;&gt;(add-hook &#39;ultra-scroll-hide-functions &#39;hl-line-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the hook contains &lt;code&gt;hl-line-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;pixel-scroll-precision&lt;/code&gt; comparison and interoperability&lt;/h2&gt; &#xA;&lt;p&gt;Emacs has a built-in smooth scrolling system called &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt;. In fact, by design, &lt;code&gt;ultra-scroll&lt;/code&gt; &lt;em&gt;activates&lt;/em&gt; the builtin &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt;, remapping its scrolling function with its own. The latter also has the capability of &lt;em&gt;faking&lt;/em&gt; smooth scrolling using interpolation. It can do this for non-mouse movements, like &lt;code&gt;scroll-up/down-command&lt;/code&gt; (usually on &lt;code&gt;PgUp&lt;/code&gt; / &lt;code&gt;PgDown&lt;/code&gt;). To use these additional capabilities, simply set the relevant variables, like &lt;code&gt;pixel-scroll-precision-interpolate-page&lt;/code&gt;, and they should &#34;just work&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;ultra-scroll&lt;/code&gt; disables &lt;code&gt;pixel-scroll-precision-use-momentum&lt;/code&gt;, since it may not handle tall image scrolling well. Some systems (MacOS) get momentum scrolling &#34;for free&#34; from the OS, independent of this setting. If you experiment with re-enabling &lt;code&gt;pixel-scroll-precision-use-momentum&lt;/code&gt; on other systems like Linux, please open an issue to report your findings.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!WARNING] &lt;code&gt;ultra-scroll&lt;/code&gt; activates &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt; by side effect. If you are experimenting with both modes during a single session, always disable &lt;code&gt;ultra-scroll-mode&lt;/code&gt; first and then re-enable &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;A comparison between ultra-scroll and pixel-scroll-precision&lt;/h3&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://raw.githubusercontent.com/jdtsmith/ultra-scroll/main/#how-does-this-compare-to-the-built-in-smooth-scrolling&#34;&gt;this question&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports smooth scrolling even on systems which do &lt;em&gt;not&lt;/em&gt; provide pixel scroll data, using interpolation (see &lt;code&gt;pixel-scroll-precision-interpolate-mice&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Can simulate a &#34;momentum&#34; scrolling phase on systems which do not provide this capability (see &lt;code&gt;pixel-scroll-precision-use-momentum&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Has occasional issues scrolling tall images.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;ultra-scroll&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fully supports &lt;em&gt;only&lt;/em&gt; those system and hardware combos that deliver &lt;em&gt;real&lt;/em&gt; pixel scroll data (see &lt;a href=&#34;https://raw.githubusercontent.com/jdtsmith/ultra-scroll/main/#Compatibility&#34;&gt;Compatibility&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Provides &#34;momentum&#34; scrolling only on systems which provide this themselves.&lt;/li&gt; &#xA; &lt;li&gt;Is somewhat faster (see &lt;a href=&#34;https://raw.githubusercontent.com/jdtsmith/ultra-scroll/main/#Speed&#34;&gt;Speed&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Handles tall image scrolling without issue.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Related packages and functionality&lt;/h2&gt; &#xA;&lt;p&gt;emacs-mac&#39;s own builtin &lt;code&gt;mac-mwheel-scroll&lt;/code&gt;&lt;br&gt; This venerable code was introduced with &lt;a href=&#34;https://bitbucket.org/mituharu/emacs-mac/&#34;&gt;emacs-mac&lt;/a&gt; more than a decade ago, and was the first to provide smooth scrolling in emacs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt;&lt;br&gt; A fast pixel scrolling by Po Lu, built in to Emacs as of v29.1 (see &lt;code&gt;pixel-scroll.el&lt;/code&gt;). Does not support &lt;code&gt;emacs-mac&lt;/code&gt;. &lt;code&gt;ultra-scroll&lt;/code&gt; was initially based on its design, but many design elements have changed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;pixel-scroll-mode&lt;/code&gt;&lt;br&gt; A simpler line-by-line pixel scrolling mode, also found in the file &lt;code&gt;pixel-scroll.el&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/io12/good-scroll.el&#34;&gt;good-scroll&lt;/a&gt;&lt;br&gt; An update to &lt;code&gt;pixel-scroll-mode&lt;/code&gt; with variable speed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zk-phi/sublimity&#34;&gt;sublimity&lt;/a&gt;&lt;br&gt; Includes smooth scrolling based on sublime editor.&lt;/p&gt; &#xA;&lt;h2&gt;Questions&lt;/h2&gt; &#xA;&lt;h3&gt;What was the motivation behind this?&lt;/h3&gt; &#xA;&lt;p&gt;Picture it: a fast new laptop and 5K monitor with a large heavy-duty, full-screen buffer in &lt;code&gt;python-ts-mode&lt;/code&gt;. Scrolling line-by-line with a decent mouse is mostly OK, but smooth pixel scrolling with the track-pad is just‚Ä¶ &lt;em&gt;painful&lt;/em&gt;. Repeated attempts to rationalize this fail, especially because it&#39;s notably worse in one direction than the other. Scrolling Emacs feels like moving through (light) molasses. &lt;em&gt;No bueno&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Checking into it, the smooth scroll event callback takes 15-20ms scrolling in one direction, and 3‚Äì5x longer in the other. This performance is perfectly fine for normal mice which deliver a few scrolling events a second. &lt;em&gt;But track-pad and fancy mouse scroll events are arriving every 10ms, or less&lt;/em&gt;! The code just couldn&#39;t keep up. Hence: molasses.&lt;/p&gt; &#xA;&lt;p&gt;I also wanted to be able to scroll through image-rich documents without worrying about jumpy/loopy scrolling behavior. And my extra dumb mouse didn&#39;t work well either: small scrolls did nothing: you&#39;d have scroll pretty aggressively to get any movement at all.&lt;/p&gt; &#xA;&lt;p&gt;How hard could it be to fix this? And the adventure began‚Ä¶&lt;/p&gt; &#xA;&lt;h3&gt;Why was this initially for emacs-mac only?&lt;/h3&gt; &#xA;&lt;p&gt;This packaged used to be called &lt;code&gt;ultra-scroll-mac&lt;/code&gt;. The &lt;code&gt;emacs-mac&lt;/code&gt; port of emacs exposes pixel-level scrolling event stream of Mac track-pads (and other fancy mice) in a distinct way, which is not supported by &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt;. And unfortunately the default smooth-scrolling library included in &lt;code&gt;emacs-mac&lt;/code&gt; is quite low performance (see above).&lt;/p&gt; &#xA;&lt;h3&gt;How does this compare to the built-in smooth scrolling?&lt;/h3&gt; &#xA;&lt;p&gt;On the &lt;code&gt;emacs-mac&lt;/code&gt; build, there is no comparison, because &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt; doesn&#39;t work there. On other builds, they are fairly comparable. Compared to &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt;, &lt;code&gt;ultra-scroll&lt;/code&gt; obviously works with &lt;code&gt;emacs-mac&lt;/code&gt;, but is also even &lt;a href=&#34;https://raw.githubusercontent.com/jdtsmith/ultra-scroll/main/#Speed&#34;&gt;faster&lt;/a&gt;, and can cleanly scroll past images taller than the window.&lt;/p&gt; &#xA;&lt;p&gt;In addition to fast scrolling, the built-in &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt; (new in Emacs v29.1) can simulate a &lt;em&gt;feature-complete track-pad driver&lt;/em&gt; in elisp for older mice which do not supply pixel scroll information. This comes complete with elisp-based scroll interpolation, a timer-based &lt;em&gt;momentum&lt;/em&gt; phase, etc.&lt;/p&gt; &#xA;&lt;h3&gt;Why are there so many smooth scrolling modes? Why is this so hard? It&#39;s just &lt;em&gt;scrolling&lt;/em&gt;‚Ä¶&lt;/h3&gt; &#xA;&lt;p&gt;Emacs was designed long before mice were common, not to mention modern high-resolution track-pads and mice which send rapid micro-updates (&#34;move up one pixel!&#34;) 60-120 times per second. Unlike other programs, Emacs &lt;em&gt;insists&lt;/em&gt; on keeping the cursor (point) visible at all times. Deep in its re-display code, Emacs tracks where point is, and works diligently to ensure it never falls outside the visible window. It does this not by moving point (that&#39;s the user&#39;s job), but by moving the &lt;em&gt;window&lt;/em&gt; (visible range of lines) surrounding point.&lt;/p&gt; &#xA;&lt;p&gt;Once you are used to this behavior, it&#39;s actually pretty nice for navigating with &lt;code&gt;C-n&lt;/code&gt; / &lt;code&gt;C-p&lt;/code&gt; and friends. But for smooth scrolling with a track-pad or mouse, it is &lt;em&gt;very problematic&lt;/em&gt; ‚Äì nothing screams &#34;janky scrolling&#34; like the window lurching back or forth half a page during a scroll. Or worse: getting caught in an endless loop of scroll-in-one-direction/jump-back-in-the-other.&lt;/p&gt; &#xA;&lt;p&gt;So what should be done? The elisp info manual (&lt;code&gt;Textual Scrolling&lt;/code&gt; / &lt;code&gt;set-window-start&lt;/code&gt;) helpfully mentions:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚Ä¶for reliable results Lisp programs that call this function should always move point to be inside the window whose display starts at POSITION.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Which is all well and good, but &lt;em&gt;where&lt;/em&gt; do you find such a point, in advance, safely &lt;em&gt;inside the window&lt;/em&gt;? Often this isn&#39;t terribly hard, but there is one common case where this admonition falls comically flat: scrolling past an image or other content which is &lt;em&gt;taller than the window&lt;/em&gt; ‚Äì what I call &lt;strong&gt;jumbo lines&lt;/strong&gt;. Where can I place point &lt;em&gt;inside the window&lt;/em&gt; when a jumbo line occupies the entire window height?&lt;/p&gt; &#xA;&lt;p&gt;As a result of these types of difficulties, pixel scrolling codes and packages are often quite involved, with much of the logic boiling down to a stalwart and increasingly heroic pile of interwoven attempts to &lt;em&gt;keep the damn point on screen&lt;/em&gt; and prevent juddering and looping as you scroll.&lt;/p&gt; &#xA;&lt;h3&gt;What should I know about developing scrolling modes for Emacs?&lt;/h3&gt; &#xA;&lt;p&gt;For posterity, some things I discovered in my own mostly-victorious battle against unwanted re-centering during smooth scroll, including across jumbo lines:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;scroll-conservatively=101&lt;/code&gt; is very helpful, since with this Emacs will &#34;scroll just enough text to bring point into view, even if you move far away&#34;. It does not defeat re-centering, but makes it‚Ä¶ more manageable.&lt;/li&gt; &#xA; &lt;li&gt;You cannot let-bind &lt;code&gt;scroll-conservatively&lt;/code&gt; for effect, as it comes into play only on re-display (after your event handler returns).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scroll-margin&amp;gt;0&lt;/code&gt; is a no-no. This setting always moves point at least that many lines from the window boundaries, which, unless you can reliably place point there during the scroll (even in the presence of jumbo lines; see below), will cause loop-back. See #3.&lt;/li&gt; &#xA; &lt;li&gt;Virtual Scroll: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;vscroll&lt;/code&gt; ‚Äì a virtual rendered scrolling window hiding &lt;em&gt;below&lt;/em&gt; the current window ‚Äì is key to smooth scrolling, and altering &lt;code&gt;vscroll&lt;/code&gt; to move the view-port is incredibly fast.&lt;/li&gt; &#xA;   &lt;li&gt;There is plenty of &lt;code&gt;vscroll&lt;/code&gt; room available, including the entirety of any tall lines (as for displayed images) in view.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;vscroll&lt;/code&gt; can sometimes place the point off the visible window (I know, sacrilege), but more often triggers re-centering.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Scrolling asymmetry: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Sadly &lt;code&gt;vscroll&lt;/code&gt; is purely &lt;em&gt;one-sided&lt;/em&gt;: you can only access a &lt;code&gt;vscroll&lt;/code&gt; area &lt;em&gt;beneath&lt;/em&gt; the current window view; &lt;em&gt;there is no negative &lt;code&gt;vscroll&lt;/code&gt;&lt;/em&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Unlike &lt;code&gt;window-start&lt;/code&gt;, &lt;code&gt;window-end&lt;/code&gt; does not get updated promptly between re-displays and cannot always be trusted. Computing it is expensive, so should be avoided during re-display.&lt;/li&gt; &#xA;   &lt;li&gt;For these two reasons, smooth scrolling up and scrolling down are &lt;em&gt;not symmetric&lt;/em&gt; with each other, and will likely never be. You need different approaches for each.&lt;/li&gt; &#xA;   &lt;li&gt;If the two approaches for scrolling up and down perform quite differently, the user will definitely feel this difference.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;For avoiding re-centering, naive movement doesn&#39;t work well. You need to learn the basic layout of lines on the window &lt;em&gt;before re-display&lt;/em&gt; has occurred.&lt;/li&gt; &#xA; &lt;li&gt;The &#34;usable window height&#34; deducts any header and the old-fashioned tab-bar, but &lt;em&gt;not&lt;/em&gt; the tab-bar-mode bar.&lt;/li&gt; &#xA; &lt;li&gt;Jumbo lines (lines taller than the window&#39;s height): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Scrolling towards buffer end: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;When scrolling with jumbo lines towards the buffer&#39;s end (with &lt;code&gt;vscroll&lt;/code&gt;), simply keep &lt;em&gt;point on the jumbo line&lt;/em&gt; until it fully disappears from view. As a special case, Emacs will not re-center when this happens.&lt;/li&gt; &#xA;     &lt;li&gt;This is &lt;em&gt;not&lt;/em&gt; true for lines that are shorter than the usable window height. In this case, you must &lt;em&gt;avoid&lt;/em&gt; placing point on any line which falls partially out of view.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Scrolling towards buffer start: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;When scrolling up past jumbo lines towards the buffer&#39;s start using &lt;code&gt;set-window-start&lt;/code&gt; (lines of content move down), you must keep point on the jumbo, but &lt;em&gt;only until it clears the top of the window area&lt;/em&gt; (even by one pixel).&lt;/li&gt; &#xA;     &lt;li&gt;After this, you must move the point to the line above it (and had better insist that &lt;code&gt;scroll-conservatively&amp;gt;0&lt;/code&gt; to prevent re-centering).&lt;/li&gt; &#xA;     &lt;li&gt;In some cases (depending on truncation/visual-line-mode/etc.), this movement must occur from a position beyond the first full height object (which may not be at the line&#39;s start). E.g. one before the visual line end.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pos-visible-in-window&lt;/code&gt; doesn&#39;t always give correct results near the window boundaries. Better to use the first line at the window&#39;s top or directly identify the final line (both via &lt;code&gt;pos-at-x-y&lt;/code&gt;) and adjust from there.&lt;/li&gt; &#xA; &lt;li&gt;Display bugs &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;There are &lt;a href=&#34;https://debbugs.gnu.org/cgi/bugreport.cgi?bug=67533&#34;&gt;display&lt;/a&gt; &lt;a href=&#34;https://debbugs.gnu.org/cgi/bugreport.cgi?bug=67604&#34;&gt;bugs&lt;/a&gt; with inline images that cause them to misreport pixel measurements and positions sometimes.&lt;/li&gt; &#xA;   &lt;li&gt;These lead to slightly staccato scrolling in such buffers and &lt;code&gt;height=0&lt;/code&gt; gets erroneously reported, so can&#39;t be used to find beginning of buffer. Best to guard against these.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Update:&lt;/strong&gt; Two display bugs have been fixed in master as of Dec, 2023, so scrolling with lots of inline images will soon be even smoother. &lt;a href=&#34;https://debbugs.gnu.org/cgi/bugreport.cgi?bug=67604&#34;&gt;One bug&lt;/a&gt; related to motion skipping visual-wrapped lines with images at line start remains.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;So all in all, it&#39;s quite complicated to get something that works as you&#39;d hope. The cutting room floor is littered with literally dozens of almost-but-not-quite-working versions of &lt;code&gt;ultra-scroll&lt;/code&gt;. I&#39;m sure there are many more corner cases, but the current design gets most things right in my usage.&lt;/p&gt; &#xA;&lt;h2&gt;Speed&lt;/h2&gt; &#xA;&lt;p&gt;I often wonder how many people who claim &#34;emacs is laggy&#34; form that impression from scrolling. Scrolling at 60-120Hz or faster with modern mice and track-pads puts a lot of stress on systems, and is often the first place lag appears. So &lt;code&gt;ultra-scroll&lt;/code&gt; is fast &lt;em&gt;by design&lt;/em&gt;. I made some observations about its speed using &lt;code&gt;ELP&lt;/code&gt; to measure the average call duration of individual scroll functions (&lt;code&gt;ultra-scroll-up/down&lt;/code&gt;) with various buffer and window sizes[^2].&lt;/p&gt; &#xA;&lt;h3&gt;Take-aways&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Very large window sizes and buffers with &#34;extra&#34; processing going on, like treesitter, LSP modes, elaborate font-locking, tons of overlays, etc. can slow down scrolling.&lt;/li&gt; &#xA; &lt;li&gt;If the scroll command does its work in &amp;lt;10ms, you do not notice it. You can definitely start feeling it when scroll commands take more than 15ms.&lt;/li&gt; &#xA; &lt;li&gt;The underlying scroll primitives need to leave some overhead in time, so that all the other emacs commands that occur when new content is brought into view (font-lock) can run without causing scroll lag, for all your different modes. &lt;strong&gt;Faster is better&lt;/strong&gt;: 3ms or less in a light buffer would be &lt;em&gt;ideal&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Building &lt;code&gt;--with-native-comp&lt;/code&gt; is &lt;em&gt;essential&lt;/em&gt; for ultra-smooth scrolling. It increases the speed of each individual scroll commands by &lt;strong&gt;&amp;gt;3x&lt;/strong&gt;, which is important since these commands are called so frequently.&lt;/li&gt; &#xA; &lt;li&gt;On the same build (NS, v29.4, with native-comp), &lt;code&gt;ultra-scroll&lt;/code&gt; is about &lt;strong&gt;40% faster&lt;/strong&gt; than &lt;code&gt;pixel-scroll-precision-mode&lt;/code&gt;. Except on slower machines, or in very heavy buffers and/or on large window sizes where your performance is right on the edge, this shouldn&#39;t be too noticeable.&lt;/li&gt; &#xA; &lt;li&gt;On the same system (an M2 mac), &lt;code&gt;ultra-scroll&lt;/code&gt; on &lt;code&gt;emacs-mac&lt;/code&gt; is 10-15% faster than on NS builds like &lt;code&gt;emacs-plus&lt;/code&gt;. Very likely not noticeable.&lt;/li&gt; &#xA; &lt;li&gt;The mode-line gets updated &lt;em&gt;very often&lt;/em&gt; during smooth scrolls (and in general), and poorly written fancy modeline add-ons are a common source of slow-down. Good modeline modes will &lt;em&gt;rate-limit&lt;/em&gt; their updates behind timers and/or cache results in local/global variables. If your scrolling (or any other aspect of Emacs) &#34;lags&#34;, try &lt;code&gt;(setq mode-line-format &#34;NADA&#34;)&lt;/code&gt; and see if that solves it. If so, suspect your fancy modeline.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;[^1]: Formerly &lt;code&gt;ultra-scroll-mac&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[^2]: To try this yourself, &lt;code&gt;M-x elp-instrument-function&lt;/code&gt; on both &lt;code&gt;ultra-scroll-up/down&lt;/code&gt;, scroll around (both directions) in a big buffer with a large window, then &lt;code&gt;M-x elp-results&lt;/code&gt;. The last column gives average time in seconds. Less than 0.003s (i.e. 3ms) is ideal, 8ms is still perfectly usable, 15ms you&#39;ll feel a bit, 50ms will be very frustrating. &lt;code&gt;scroll-down&lt;/code&gt; is always faster than &lt;code&gt;scroll-up&lt;/code&gt; due to an asymmetry in Emacs&#39; &lt;code&gt;vscroll&lt;/code&gt; buffer.&lt;/p&gt;</summary>
  </entry>
</feed>