<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-25T01:56:05Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>emacs-tree-sitter/tree-sitter-langs</title>
    <updated>2023-06-25T01:56:05Z</updated>
    <id>tag:github.com,2023-06-25:/emacs-tree-sitter/tree-sitter-langs</id>
    <link href="https://github.com/emacs-tree-sitter/tree-sitter-langs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Language bundle for Emacs&#39;s tree-sitter package&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Tree-sitter Language Bundle for Emacs&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_HTML &lt;a href=&#34;https://github.com/emacs-tree-sitter/tree-sitter-langs/actions/workflows/main.yml&#34;&gt; &lt;img src=&#34;https://github.com/emacs-tree-sitter/tree-sitter-langs/actions/workflows/main.yml/badge.svg?sanitize=true&#34; alt=&#34;GitHub Actions&#34; style=&#34;max-width: 100%;&#34;&gt; &lt;/a&gt; #+END_HTML&lt;/p&gt; &#xA;&lt;p&gt;This is a convenient language bundle for the Emacs package [[https://github.com/emacs-tree-sitter/elisp-tree-sitter][tree-sitter]]. It serves as an interim distribution mechanism, until &lt;del&gt;tree-sitter&lt;/del&gt; is widespread enough for language-specific major modes to incorporate its functionalities.&lt;/p&gt; &#xA;&lt;p&gt;For each supported language, this package provides:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Pre-compiled grammar binaries for 3 major platforms: macOS, Linux and Windows, on x86_64. In the future, &lt;del&gt;tree-sitter-langs&lt;/del&gt; may provide tooling for major modes to do this on their own.&lt;/li&gt; &#xA; &lt;li&gt;An optional &lt;del&gt;highlights.scm&lt;/del&gt; file that provides highlighting patterns. This is mainly intended for major modes that are not aware of &lt;del&gt;tree-sitter&lt;/del&gt;. A language major mode that wants to use &lt;del&gt;tree-sitter&lt;/del&gt; for syntax highlighting should instead provide the query patterns on its own, using the mechanisms defined by [[https://emacs-tree-sitter.github.io/syntax-highlighting/interface-for-modes/][tree-sitter-hl]].&lt;/li&gt; &#xA; &lt;li&gt;Optional query patterns for other minor modes that provide high-level functionalities on top of &lt;del&gt;tree-sitter&lt;/del&gt;, such as code folding, evil text objects... As with highlighting patterns, major modes that are directly aware of &lt;del&gt;tree-sitter&lt;/del&gt; should provide the query patterns on their own.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;** Highlighting Queries&lt;/p&gt; &#xA;&lt;h1&gt;&lt;em&gt;Note&lt;/em&gt;: Highlighting styles are a mattter of taste.&lt;/h1&gt; &#xA;&lt;p&gt;Highlighting query patterns for a language are in the file &lt;del&gt;queries/&#xA;  &lt;lang&gt;&#xA;   /highlights.scm&#xA;  &lt;/lang&gt;&lt;/del&gt;. Most of them are &lt;em&gt;intentionally different&lt;/em&gt; from those from upstream repositories, which are more geared towards /GitHub&#39;s use cases/. We try to be more consistent with /Emacs&#39;s existing conventions/. (For some languages, this is WIP, so their patterns may look similar to upstream&#39;s.)&lt;/p&gt; &#xA;&lt;p&gt;In general, try to follow what the docstrings of &lt;del&gt;tree-sitter-hl-face:&lt;/del&gt; faces say. Most importantly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Definitions and uses should be differentiated: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;@function&lt;/del&gt; vs. &lt;del&gt;@function.call&lt;/del&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;@method&lt;/del&gt; vs. &lt;del&gt;@method.call&lt;/del&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;@type.parameter&lt;/del&gt; vs. &lt;del&gt;@type.argument&lt;/del&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;@variable&lt;/del&gt; and &lt;del&gt;@variable.parameter&lt;/del&gt; should be applied only to declarations/definitions/bindings/mutations (/writes/), not usage (/reads/).&lt;/li&gt; &#xA; &lt;li&gt;Special faces should have high priority (placed earlier in the pattern list): &lt;del&gt;@function.macro&lt;/del&gt;, &lt;del&gt;@type.builtin&lt;/del&gt;, &lt;del&gt;@variable.special&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Patterns whose internals may be highlighted should have low priority (placed towards the end). Example: strings with interpolation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Mode-specific highlighting Some languages are associated with multiple major modes. Mode-specific highlighting patterns are provided by the files &lt;del&gt;queries/&#xA;  &lt;lang&gt;&#xA;   /highlights.&#xA;   &lt;major-mode&gt;&#xA;    .scm&#xA;   &lt;/major-mode&gt;&#xA;  &lt;/lang&gt;&lt;/del&gt;. These are combined with the base highlighting patterns in &lt;del&gt;queries/&#xA;  &lt;lang&gt;&#xA;   /highlights.scm&#xA;  &lt;/lang&gt;&lt;/del&gt;, but have higher precedence.&lt;/p&gt; &#xA;&lt;p&gt;** Building Grammars from Source Note: If you also plan to work on [[https://github.com/emacs-tree-sitter/elisp-tree-sitter#building-grammars-from-source][elisp-tree-sitter]], it might be more convenient to work with this repository as a submodule.&lt;/p&gt; &#xA;&lt;p&gt;*** Tools and dependencies&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install [[https://emacs-eask.github.io/][eask]].&lt;/li&gt; &#xA; &lt;li&gt;Install ELisp dependencies: #+begin_src bash eask install-deps #+end_src&lt;/li&gt; &#xA; &lt;li&gt;Install NodeJS. It is needed to generate the grammar code from the JavaScript DSL. The recommended tool to manage NodeJS is [[https://volta.sh/][volta]].&lt;/li&gt; &#xA; &lt;li&gt;Install [[https://tree-sitter.github.io/tree-sitter/creating-parsers#installation][tree-sitter CLI tool]]. (Its binary can also be downloaded directly from [[https://github.com/tree-sitter/tree-sitter/releases][GitHub]].) &lt;em&gt;Note: versions 0.20+ cannot be used, as they introduce [[https://github.com/tree-sitter/tree-sitter/pull/1157][a breaking change]] in binary storage location&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Building grammars To build a specific language&#39;s grammar, run &lt;del&gt;script/compile&lt;/del&gt;. (See the list of registered languages in [[./repos][repos/]].) For example: #+begin_src bash script/compile rust #+end_src&lt;/p&gt; &#xA;&lt;p&gt;To build all registered languages, and creating the bundle: #+begin_src bash script/compile all #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Adding a new grammar&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Register a new submodule. For example: #+begin_src bash # git submodule add -b &#xA;  &lt;branch&gt;&#xA;    -- &#xA;   &lt;git-url&gt;&#xA;     repos/&#xA;    &lt;lang&gt;&#xA;      git submodule add -b master -- &#xA;     &lt;a href=&#34;https://github.com/tree-sitter/tree-sitter-rust&#34;&gt;https://github.com/tree-sitter/tree-sitter-rust&lt;/a&gt; repos/rust #+end_src&#xA;    &lt;/lang&gt;&#xA;   &lt;/git-url&gt;&#xA;  &lt;/branch&gt;&lt;/li&gt; &#xA; &lt;li&gt;Modify its settings in [[.gitmodules][.gitmodules]]: #+begin_src conf update = none ignore = dirty #+end_src&lt;/li&gt; &#xA; &lt;li&gt;Try building and testing it. For example: #+begin_src bash script/compile rust script/test rust #+end_src&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>emacs-tree-sitter/ts-fold</title>
    <updated>2023-06-25T01:56:05Z</updated>
    <id>tag:github.com,2023-06-25:/emacs-tree-sitter/ts-fold</id>
    <link href="https://github.com/emacs-tree-sitter/ts-fold" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Code-folding using tree-sitter&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-GPL%20v3-blue.svg?sanitize=true&#34; alt=&#34;License: GPL v3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://jcs-emacs.github.io/jcs-elpa/#/ts-fold&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jcs-emacs/badges/master/elpa/v/ts-fold.svg?sanitize=true&#34; alt=&#34;JCS-ELPA&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;ts-fold&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code-folding using tree-sitter&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/emacs-tree-sitter/ts-fold/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/emacs-tree-sitter/ts-fold/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ts-fold&lt;/code&gt; builds on top of &lt;a href=&#34;https://github.com/emacs-tree-sitter/elisp-tree-sitter&#34;&gt;elisp-tree-sitter&lt;/a&gt; to provide code folding based on the tree-sitter syntax tree.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/etc/screenshot.png&#34; width=&#34;80%&#34; height=&#34;80%&#34;&gt; &lt;/p&gt; &#xA;&lt;!-- Markdown is not able to render links with unicode so after refreshing the toc, select it and:&#xA;    `M-x replace-regexp #[^-a-zA-Z] &lt;ret&gt; # &lt;ret&gt;` --&gt; &#xA;&lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-refresh-toc --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-installation&#34;&gt;üíæ Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-method-1-with-straightel-and-use-package&#34;&gt;üîç Method 1. with &lt;code&gt;straight.el&lt;/code&gt; and &lt;code&gt;use-package&lt;/code&gt;:&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-method-2-manual&#34;&gt;üîç Method 2. Manual&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-usage&#34;&gt;üñ• Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-commands&#34;&gt;üìá Commands&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-supported-languages&#34;&gt;üî® Supported languages&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-customization&#34;&gt;üìù Customization&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-folding-on-new-nodes&#34;&gt;‚ö™ Folding on new nodes&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-example&#34;&gt;‚ùî Example&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-offset&#34;&gt;‚Üî Offset&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-writing-new-fold-functions&#34;&gt;üîç Writing new fold functions&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-plugins&#34;&gt;üîå Plugins&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-indicators-mode&#34;&gt;‚öñÔ∏è Indicators Mode&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-installation-1&#34;&gt;üíæ Installation&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-usage-1&#34;&gt;üñ• Usage&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-summary&#34;&gt;üìù Summary&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-usage-2&#34;&gt;üñ• Usage&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-customization-1&#34;&gt;üìù Customization&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-line-comment-folding&#34;&gt;üå´Ô∏è Line-Comment folding&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-usage-3&#34;&gt;üñ• Usage&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-contribute&#34;&gt;üî∞ Contribute&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-how-to-add-a-folding-parser&#34;&gt;‚ùì How to add a folding parser?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-where-can-i-look-for-tree-sitter-node&#34;&gt;üîç Where can I look for tree-sitter node?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-how-to-create-a-summary-parser&#34;&gt;‚ùì How to create a summary parser?&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;h2&gt;üíæ Installation&lt;/h2&gt; &#xA;&lt;h3&gt;üîç Method 1. with &lt;code&gt;straight.el&lt;/code&gt; and &lt;code&gt;use-package&lt;/code&gt;:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ts-fold&#xA;  :straight (ts-fold :type git :host github :repo &#34;emacs-tree-sitter/ts-fold&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üîç Method 2. Manual&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/emacs-tree-sitter/ts-fold /path/to/lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then in Emacs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-to-list &#39;load-path &#34;/path/to/lib&#34;)&#xA;(require &#39;ts-fold)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ts-fold&#xA;  :load-path &#34;/path/to/lib&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üñ• Usage&lt;/h2&gt; &#xA;&lt;h3&gt;üìá Commands&lt;/h3&gt; &#xA;&lt;p&gt;The following are the functions provided by &lt;code&gt;ts-fold-mode&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Commands for enabling &lt;code&gt;ts-fold&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Commands&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ts-fold-mode&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;enable &lt;code&gt;ts-fold-mode&lt;/code&gt; in the current buffer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;global-ts-fold-mode&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;enable &lt;code&gt;ts-fold-mode&lt;/code&gt; whenever tree-sitter is turned on and the major mode is supported by ts-fold.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ts-fold-indicators-mode&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;enable ts-fold with indicators in the current buffer. See &lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-indicators-mode&#34;&gt;plugins section&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;global-ts-fold-indicators-mode&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;enable ts-fold with indicators globally. See &lt;a href=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/#-indicators-mode&#34;&gt;plugins section&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ts-fold-line-comment-mode&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;enable line comment folding.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Commands for using &lt;code&gt;ts-fold&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Commands&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ts-fold-close&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;fold the current syntax node.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ts-fold-open&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;open the outermost fold of the current syntax node. Keep the sub-folds close.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ts-fold-open-recursively&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;open all folds inside the current syntax node.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ts-fold-close-all&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;close all foldable syntax nodes in the current buffer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ts-fold-open-all&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;open all folded syntax nodes in the current buffer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ts-fold-toggle&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;toggle the syntax node at `point&#39;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;If evil mode is loaded, then these commands are also added to the evil folding list.&lt;/p&gt; &#xA;&lt;h3&gt;üî® Supported languages&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ö†Ô∏è Please sort these two lists alphabetically!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;These languages are fairly complete:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bash&lt;/li&gt; &#xA; &lt;li&gt;C / C++ / C# / CSS&lt;/li&gt; &#xA; &lt;li&gt;Elixir&lt;/li&gt; &#xA; &lt;li&gt;Go&lt;/li&gt; &#xA; &lt;li&gt;HTML&lt;/li&gt; &#xA; &lt;li&gt;Java / JavaScript / JSX / JSON / Julia&lt;/li&gt; &#xA; &lt;li&gt;Lua&lt;/li&gt; &#xA; &lt;li&gt;Nix&lt;/li&gt; &#xA; &lt;li&gt;PHP / Python&lt;/li&gt; &#xA; &lt;li&gt;R / Ruby / Rust&lt;/li&gt; &#xA; &lt;li&gt;Scala / Swift&lt;/li&gt; &#xA; &lt;li&gt;TypeScript / TSX&lt;/li&gt; &#xA; &lt;li&gt;YAML&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These languages are in development:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Agda&lt;/li&gt; &#xA; &lt;li&gt;Elm&lt;/li&gt; &#xA; &lt;li&gt;Emacs Lisp&lt;/li&gt; &#xA; &lt;li&gt;OCaml&lt;/li&gt; &#xA; &lt;li&gt;XML (upstream)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üìù Customization&lt;/h2&gt; &#xA;&lt;p&gt;Although ts-fold aims to have good folding out of the box for all supported definitions, people will indubitably have their own preferences or desired functionality. The following section outlines how to add your own folding definitions and folding functions to make ts-fold work for you. If there are any improvements you find for existing or new languages, please do raise a PR so that others may benefit from better folding in the future!&lt;/p&gt; &#xA;&lt;h3&gt;‚ö™ Folding on new nodes&lt;/h3&gt; &#xA;&lt;p&gt;Ts-fold defines all its folding definitions in the variable &lt;code&gt;ts-fold-range-alist&lt;/code&gt; which is an alist with the key of the alist being the mode and the value being another alist of fold definitions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; Example of ts-fold-range-alist&#39;s structure&#xA;&#39;((c-mode     . c-folding-definitions) ;; &amp;lt;language&amp;gt;-folding-definitions is structured as shown below&#xA;  (css-mode   . css-folding-definitions)&#xA;  (go-mode    . go-folding-definitions)&#xA;  (scala-mode . scala-folding-definitions)&#xA;  ...)&#xA;&#xA;;; Examle of a folding definition alist&#xA;(setq css-folding-definitions&#xA;    (block   . ts-fold-range-seq)&#xA;    (comment . ts-fold-range-c-like-comment))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So you can select whatever node that you want to fold on it.&lt;/p&gt; &#xA;&lt;p&gt;To find what node you&#39;ll want to fold closed, refer to the &lt;a href=&#34;https://emacs-tree-sitter.github.io/getting-started/#view-the-syntax-tree&#34;&gt;tree-sitter documentation&lt;/a&gt; about viewing nodes. &lt;code&gt;tree-sitter-debug&lt;/code&gt; and &lt;code&gt;tree-sitter-query-builder&lt;/code&gt; are both very useful for this.&lt;/p&gt; &#xA;&lt;p&gt;For the folding functions, ts-fold provides some default&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ts-fold-range-seq&lt;/code&gt; - Folds from the start of the node to the end of the node leaving a buffer of one character on each side. Usually used for code blocks that have bracketing delimiters.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int main() { // &amp;lt;-- start of tree-sitter block node&#xA;    printf(&#34;Hello, World\n&#34;);&#xA;    return 0;&#xA;} // &amp;lt;-- end of tree-sitter block node&#xA;&#xA;// |&#xA;// | &#39;(block . ts-fold-range-seq)&#xA;// V&#xA;&#xA;int main() {...} // Folded node&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ts-fold-range-markers&lt;/code&gt; - Folds the node starting from a giving delimiter character. Useful if tree-sitter&#39;s node definition doesn&#39;t align with the start of the desired folding section.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; This folding function requires a lambda (or an externally defined function wrapper) so that the delimiter can be specified. You usually don&#39;t need to worry about the &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; variables, so just pass them through.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Dog interface {&#xA;    Bark() (string, error)&#xA;    Beg() (bool, error)&#xA;}&#xA;&#xA;/* | Note: The tree-sitter node starts at the word interface, not at the &#39;{&#39;.&#xA; * | &#39;(interface_type . (lambda (node offset)&#xA; * |                      (ts-fold-range-markers node offset &#34;{&#34; &#34;}&#34;)))&#xA; * V&#xA; */&#xA;&#xA;type Dog interface {...}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ts-fold-range-block-comment&lt;/code&gt; - Folds multi-line comments that are of the form &lt;code&gt;/*...*/&lt;/code&gt;. Should show a summary if the commentary plugin is turned on.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*&#xA; * The main function that gets run after program is compiled&#xA; * Doesn&#39;t take any parameters&#xA; */&#xA;int main() {&#xA;    printf(&#34;Hello, World\n&#34;);&#xA;    return 0;&#xA;}&#xA;&#xA;// |&#xA;// | &#39;(comment . ts-fold-range-block-comment)&#xA;// V&#xA;&#xA;/* &amp;lt;S&amp;gt; The main function that gets run after program is compiled */&#xA;int main() {&#xA;    printf(&#34;Hello, World\n&#34;);&#xA;    return 0;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ts-fold-range-line-comment&lt;/code&gt; - For languages that have one line comment blocks with the comment delimiter starting each line. Condenses all the comment nodes into a single fold.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This folding function requires a lambda (or an externally defined function wrapper) so that the delimiter can be specified. You usually don&#39;t need to worry about the &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; variables, so just pass them through.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# show the long form of ls&#xA;# and also display hidden files&#xA;alias ll=&#39;ls -lah&#39;&#xA;&#xA;# |&#xA;# | (comment (lambda (node offset) (ts-fold-range-line-comment node offset &#34;#&#34;))))&#xA;# V&#xA;&#xA;# show the long form of ls...&#xA;alias ll=&#39;ls -lah&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ts-fold-range-c-like-comment&lt;/code&gt; - A shortcut for the large number of languages that have the c style comment structures &lt;code&gt;/*...*/&lt;/code&gt; and &lt;code&gt;// ...&lt;/code&gt;. Smartly picks the correct folding style for the comment on the line.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*&#xA; * The main function that gets run after program is compiled&#xA; * Doesn&#39;t take any parameters&#xA; */&#xA;int main() {&#xA;    // print hello world&#xA;    // and a new line&#xA;    printf(&#34;Hello, World\n&#34;);&#xA;    return 0;&#xA;}&#xA;&#xA;// |&#xA;// | &#39;(comment . ts-fold-range-c-like-comment)&#xA;// V&#xA;&#xA;/* &amp;lt;S&amp;gt; The main function that gets run after program is compiled */&#xA;int main() {&#xA;    // &amp;lt;S&amp;gt; print hello world&#xA;    printf(&#34;Hello, World\n&#34;);&#xA;    return 0;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Now that you know what kinds of folds are easily available in ts-fold, you can go ahead and add new fold definitions to &lt;code&gt;ts-fold-range-alist&lt;/code&gt; and be good to go!&lt;/p&gt; &#xA;&lt;h4&gt;‚ùî Example&lt;/h4&gt; &#xA;&lt;p&gt;Let&#39;s look at a quick example of adding a new folding definition. Let&#39;s say you want to add folding to &lt;code&gt;go-mode&lt;/code&gt;&#39;s &lt;code&gt;field_declaration_list&lt;/code&gt;. The folding definition that is needed will be &lt;code&gt;&#39;(field_declaration_list . ts-fold-range-seq)&lt;/code&gt;. To add this to the &lt;code&gt;ts-fold-range-alist&lt;/code&gt;, you can do something like the following.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(push &#39;(field_declaration_list . ts-fold-range-seq) (alist-get &#39;go-mode ts-fold-range-alist))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now the new fold definition should be usable by ts-fold!&lt;/p&gt; &#xA;&lt;h4&gt;‚Üî Offset&lt;/h4&gt; &#xA;&lt;p&gt;With the functions listed above you&#39;ll be able to define most folding behavior that you&#39;ll want for most languages. However, sometimes you&#39;ll have a language where the delimiter is a word instead of a single character bracket and you want to offset your fold by a certain amount to accommodate it. That&#39;s where offsets come in. When adding a fold definition to a a language&#39;s fold alist, you can either provide the folding function directly as you&#39;ve seen so far:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;&#39;(block . ts-fold-range-seq)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can provide the folding function with an offset:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;&#39;(block . (ts-fold-range-seq 1 -3))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When a range is provided, it provides extra room on the ends of a fold. The way this works is most easily shown using an example. Lets say we want to write a fold for bash&#39;s &lt;code&gt;for...do...done&lt;/code&gt; construct to look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;for i in 1 2 3 4 5&#xA;do&#xA;   echo &#34;Welcome $i times&#34;&#xA;done&#xA;&#xA;# |&#xA;# | &#39;(do_group . &amp;lt;some folding function&amp;gt;)&#xA;# V&#xA;&#xA;for i in 1 2 3 4 5&#xA;do...done&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;do...done&lt;/code&gt; block is represented in tree-sitter as the node named &lt;code&gt;do_group&lt;/code&gt;. However, if we just use &lt;code&gt;&#39;(do_group . ts-fold-range-seq)&lt;/code&gt;, then we&#39;ll get results like the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;for i in 1 2 3 4 5&#xA;d...e&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which is hard to read. Instead, we can use the definition &lt;code&gt;&#39;(do_group . (ts-fold-range-seq 1 -3))&lt;/code&gt; to offset the fold a bit to get our desired result!&lt;/p&gt; &#xA;&lt;h3&gt;üîç Writing new fold functions&lt;/h3&gt; &#xA;&lt;p&gt;If the built in functions don&#39;t fit your needs, you can write your own fold parser! Folding functions take two parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;node&lt;/code&gt; - the targeted tree-sitter node; in this example, &lt;code&gt;block&lt;/code&gt; will be the targeting node.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;offset&lt;/code&gt; - (optional) a cons of two integers. This is handy when you have a similar rule with little of positioning adjustment.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Then the function needs to return a position range for the fold overlay in the form &lt;code&gt;&#39;(start-of-fold . end-of-fold)&lt;/code&gt;. If &lt;code&gt;nil&lt;/code&gt; is returned instead of a range, then no fold is created. This can be useful if you want to add extra conditional logic onto your fold.&lt;/p&gt; &#xA;&lt;p&gt;As an example of a folding function, take a look at the definition of the basic &lt;code&gt;ts-fold-range-seq&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun ts-fold-range-seq (node offset)&#xA;  &#34;...&#34;&#xA;  (let ((beg (1+ (tsc-node-start-position node)))  ; node beginning position&#xA;        (end (1- (tsc-node-end-position node))))   ; node end position&#xA;    (ts-fold--cons-add (cons beg end) offset)))    ; return fold range&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üîå Plugins&lt;/h2&gt; &#xA;&lt;p&gt;ts-fold comes with a couple of useful little additions that can be used or turned off as desired.&lt;/p&gt; &#xA;&lt;h3&gt;‚öñ Indicators Mode&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/etc/indicators.png&#34; width=&#34;40%&#34; height=&#34;480%&amp;quot;/&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;This plugin adds interactive visual markers in the gutter that show where folds can be made. They can be clicked on to fold or unfold given nodes.&lt;/p&gt; &#xA;&lt;h4&gt;üíæ Installation&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;ts-fold-indicator-mode&lt;/code&gt; is loaded when &lt;code&gt;ts-fold-mode&lt;/code&gt; is and the functionality should be auto-loaded in, however if that&#39;s not working then you may want to explicitly declare the package in in your config.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;use-package&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ts-fold-indicators&#xA;:straight (ts-fold-indicators :type git :host github :repo &#34;emacs-tree-sitter/ts-fold&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-to-list &#39;load-path &#34;/path/to/lib&#34;)&#xA;(require ts-fold)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;or&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ts-fold-indicators&#xA;   :load-path &#34;/path/to/lib&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;üñ• Usage&lt;/h4&gt; &#xA;&lt;p&gt;You can then enable this manually by doing either of the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x ts-fold-indicators-mode&#xA;&#xA;M-x global-ts-fold-indicators-mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that turning on &lt;code&gt;ts-fold-indicators-mode&lt;/code&gt; automatically turns on &lt;code&gt;ts-fold-mode&lt;/code&gt; as well. Though, turning off &lt;code&gt;ts-fold-indicators-mode&lt;/code&gt; does not turn off &lt;code&gt;ts-fold-mode&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;To enable this automatically whenever &lt;code&gt;tree-sitter-mode&lt;/code&gt; is enabled, use the global indicator mode:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-ts-fold-indicators-mode 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Else, a hook can be added to tree-sitter directly.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-hook &#39;tree-sitter-after-on-hook #&#39;ts-fold-indicators-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To switch to left/right fringe: (Default is &lt;code&gt;left-fringe&lt;/code&gt;)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq ts-fold-indicators-fringe &#39;right-fringe)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To lower/higher the fringe overlay&#39;s priority: (Default is &lt;code&gt;30&lt;/code&gt;)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq ts-fold-indicators-priority 30)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To apply different faces depending on some conditions: (Default is &lt;code&gt;nil&lt;/code&gt;)&lt;/p&gt; &lt;p&gt;For example, to coordinate &lt;a href=&#34;https://github.com/emacs-vs/line-reminder&#34;&gt;line-reminder&lt;/a&gt; with this plugin.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;&#xA;(setq ts-fold-indicators-face-function&#xA;      (lambda (pos &amp;amp;rest _)&#xA;        ;; Return the face of it&#39;s function.&#xA;        (line-reminder--get-face (line-number-at-pos pos t))))&#xA;&#xA;(advice-add &#39;line-reminder-transfer-to-saved-lines :after&#xA;            ;; Refresh indicators for package `ts-fold&#39;.&#xA;            #&#39;ts-fold-indicators-refresh)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;üìù Summary&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/etc/summary.gif&#34; width=&#34;80%&#34; height=&#34;80%&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;This plugin automatically extracts summary from the comment/document string, so you can have a nice way to peek at what&#39;s inside the fold range.&lt;/p&gt; &#xA;&lt;h4&gt;üñ• Usage&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If you don&#39;t want this to happen, do: (Default is &lt;code&gt;t&lt;/code&gt;)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq ts-fold-summary-show nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Summary are truncated by length: (Default is &lt;code&gt;60&lt;/code&gt;)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq ts-fold-summary-max-length 60)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The exceeding string are replace by: (Default is &lt;code&gt;&#34;...&#34;&lt;/code&gt;)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq ts-fold-summary-exceeded-string &#34;...&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To change summary format: (Default is &lt;code&gt;&#34; &amp;lt;S&amp;gt; %s &#34;&lt;/code&gt;)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq ts-fold-summary-format &#34; &amp;lt;S&amp;gt; %s &#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;üìù Customization&lt;/h4&gt; &#xA;&lt;p&gt;Just like with fold definitions, you can create your own summary definitions. Summary definitions are defined in &lt;code&gt;ts-fold-summary-parsers-alist&lt;/code&gt; and has one summary function per major mode &lt;code&gt;&#39;(java-mode . fold-summary-function)&lt;/code&gt;. The summary function takes in the doc string which is all the text from a doc node and then returns a string to be displayed in its stead. Unlike with the folding functions, there aren&#39;t a set of general summary functions to fall back on. However, there are lots of examples and helper functions present in &lt;code&gt;ts-fold-summary.el&lt;/code&gt;. Let&#39;s look at one example here.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(defun ts-fold-summary-javadoc (doc-str)&#xA;  &#34;Extract summary from DOC-STR in Javadoc.&#34;&#xA;  (ts-fold-summary--generic doc-str &#34;*&#34;)) ;; strip the &#39;*&#39; and returns the first line&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As can be seen &lt;code&gt;ts-fold-summary--generic&lt;/code&gt; is a very helpful function since it removes the provided delimiter and returns the first line. often this will be enough.&lt;/p&gt; &#xA;&lt;h3&gt;üå´ Line-Comment folding&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/emacs-tree-sitter/ts-fold/master/etc/line-comment.gif&#34; width=&#34;80%&#34; height=&#34;80%&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;This plugin makes line comment into foldable range.&lt;/p&gt; &#xA;&lt;h4&gt;üñ• Usage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x ts-fold-line-comment-mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üî∞ Contribute&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://makeapullrequest.com&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/PRs-welcome-brightgreen.svg?sanitize=true&#34; alt=&#34;PRs Welcome&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bbatsov/emacs-lisp-style-guide&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/elisp-style%20guide-purple&#34; alt=&#34;Elisp styleguide&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.paypal.me/jcs090218&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/paypal-donate-1?logo=paypal&amp;amp;color=blue&#34; alt=&#34;Donate on paypal&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.patreon.com/jcs090218&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/patreon-become%20a%20patron-orange.svg?logo=patreon&#34; alt=&#34;Become a patron&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Enable &lt;code&gt;tree-sitter-mode&lt;/code&gt; first, then &lt;code&gt;tree-sitter-query-builder&lt;/code&gt; is useful to test out queries that determine what syntax nodes should be foldable and how to fold them. &lt;a href=&#34;https://ubolonton.github.io/emacs-tree-sitter/syntax-highlighting/queries/&#34;&gt;emacs-tree-sitter&lt;/a&gt; has an excellent documentation on how to write &lt;code&gt;tree-sitter&lt;/code&gt; queries.&lt;/p&gt; &#xA;&lt;h3&gt;‚ùì How to add a folding parser?&lt;/h3&gt; &#xA;&lt;p&gt;When adding a new folding parser, add the folding definition function to &lt;code&gt;ts-fold.el&lt;/code&gt; itself near where the other range functions live and then add the parser to &lt;code&gt;ts-fold-parsers.el&lt;/code&gt; file. Finally, if you are adding support for a new language, remember to add it to the &lt;code&gt;ts-fold-range-alist&lt;/code&gt; variable.&lt;/p&gt; &#xA;&lt;p&gt;When creating a new parser, name it &lt;code&gt;ts-fold-parsers-&amp;lt;language&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When creating a new folding function, name it &lt;code&gt;ts-fold-range-&amp;lt;language&amp;gt;-&amp;lt;feature&amp;gt;&lt;/code&gt; or something similar.&lt;/p&gt; &#xA;&lt;h4&gt;üîç Where can I look for tree-sitter node?&lt;/h4&gt; &#xA;&lt;p&gt;Here are some techniques for finding your desired nodes in tree-sitter.&lt;/p&gt; &#xA;&lt;p&gt;To look for the correct node you have three options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;look at the &lt;code&gt;tree-sitter-[lang]/grammar.js&lt;/code&gt; implementation. In the above example, &lt;code&gt;block&lt;/code&gt; node is defined in the &lt;a href=&#34;https://github.com/tree-sitter/tree-sitter-c-sharp&#34;&gt;tree-sitter-c-sharp&lt;/a&gt;&#39;s &lt;code&gt;grammar.js&lt;/code&gt; file&lt;/li&gt; &#xA; &lt;li&gt;open a file of your language choice in emacs and &lt;code&gt;M-x tree-sitter-debug-mode&lt;/code&gt;. This will display the whole s-expr representing your file&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(message &#34;%S&#34; (tsc-node-to-sexp))&lt;/code&gt; in your function to display what your function is seeing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ö†Ô∏è Warning&lt;/p&gt; &#xA; &lt;p&gt;Make sure you look into the correct repository. Repositories are managed under &lt;a href=&#34;https://github.com/emacs-tree-sitter/tree-sitter-langs&#34;&gt;tree-sitter-langs&lt;/a&gt;&#39;s using git submodule. Some tree-sitter module aren&#39;t using the latest version!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;‚ùì How to create a summary parser?&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ts-fold-summary.el&lt;/code&gt; module is used to extract and display a short description from the comment/docstring.&lt;/p&gt; &#xA;&lt;p&gt;To create a summary parser, you just have to create a function that could extract comment syntax correctly then register this function to &lt;code&gt;ts-fold-summary-parsers-alist&lt;/code&gt; defined in &lt;code&gt;ts-fold-summary.el&lt;/code&gt;. The display and shortening will be handled by the module itself.&lt;/p&gt; &#xA;&lt;p&gt;Functions should be named with the prefix &lt;code&gt;ts-fold-summary-&lt;/code&gt; followed by &lt;code&gt;style name&lt;/code&gt;. For example, to create a summary parser for Javadoc style, then it should be named &lt;code&gt;ts-fold-summary-javadoc&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kiwanami/emacs-deferred</title>
    <updated>2023-06-25T01:56:05Z</updated>
    <id>tag:github.com,2023-06-25:/kiwanami/emacs-deferred</id>
    <link href="https://github.com/kiwanami/emacs-deferred" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple asynchronous functions for emacs lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;deferred.el&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/kiwanami/emacs-deferred&#34;&gt;&lt;img src=&#34;https://travis-ci.org/kiwanami/emacs-deferred.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/r/kiwanami/emacs-deferred&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/kiwanami/emacs-deferred/badge.svg?sanitize=true&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/deferred&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/deferred-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/deferred&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/deferred-badge.svg?sanitize=true&#34; alt=&#34;MELPA stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/kiwanami/emacs-deferred/tags&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/tag/kiwanami/emacs-deferred.svg?sanitize=true&#34; alt=&#34;Tag Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.html&#34;&gt;&lt;img src=&#34;http://img.shields.io/:license-gpl3-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;deferred.el&lt;/code&gt; provides facilities to manage asynchronous tasks.&lt;/p&gt; &#xA;&lt;p&gt;The API and implementations were translated from &lt;a href=&#34;https://github.com/cho45/jsdeferred&#34; title=&#34;JSDeferred&#34;&gt;JSDeferred&lt;/a&gt; (by cho45) and &lt;a href=&#34;http://mochikit.com/doc/html/MochiKit/Async.html&#34; title=&#34;Mochikit.Async&#34;&gt;Mochikit.Async&lt;/a&gt; (by Bob Ippolito) in JavaScript.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;(note the README for &lt;code&gt;concurrent&lt;/code&gt; is &lt;a href=&#34;https://raw.githubusercontent.com/kiwanami/emacs-deferred/master/README-concurrent.markdown&#34;&gt;here in the same repo&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install deferred.el from &lt;a href=&#34;http://melpa.org&#34;&gt;MELPA&lt;/a&gt; by package.el.&lt;/p&gt; &#xA;&lt;h2&gt;Sample codes&lt;/h2&gt; &#xA;&lt;p&gt;You can find following sample codes in &lt;code&gt;deferred-sample.el&lt;/code&gt;. Executing &lt;code&gt;eval-last-sexp&lt;/code&gt; (C-x C-e), you can try those codes.&lt;/p&gt; &#xA;&lt;h3&gt;Basic usage&lt;/h3&gt; &#xA;&lt;p&gt;This is a basic deferred chain. This code puts some outputs into message buffer, and then require a number from minibuffer.&lt;/p&gt; &#xA;&lt;p&gt;Chain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(deferred:$&#xA;  (deferred:next&#xA;    (lambda () (message &#34;deferred start&#34;)))&#xA;  (deferred:nextc it&#xA;    (lambda ()&#xA;      (message &#34;chain 1&#34;)&#xA;      1))&#xA;  (deferred:nextc it&#xA;    (lambda (x)&#xA;      (message &#34;chain 2 : %s&#34; x)))&#xA;  (deferred:nextc it&#xA;    (lambda ()&#xA;      (read-minibuffer &#34;Input a number: &#34;)))&#xA;  (deferred:nextc it&#xA;    (lambda (x)&#xA;      (message &#34;Got the number : %i&#34; x)))&#xA;  (deferred:error it&#xA;    (lambda (err)&#xA;      (message &#34;Wrong input : %s&#34; err))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This s-exp returns immediately.&lt;/li&gt; &#xA; &lt;li&gt;Asynchronous tasks start subsequently.&lt;/li&gt; &#xA; &lt;li&gt;The macro &lt;code&gt;deferred:$&lt;/code&gt; chains deferred objects.&lt;/li&gt; &#xA; &lt;li&gt;The anaphoric variable &lt;code&gt;it&lt;/code&gt; holds a deferred object in the previous line.&lt;/li&gt; &#xA; &lt;li&gt;The next deferred task receives the value that is returned by the previous deferred one.&lt;/li&gt; &#xA; &lt;li&gt;Inputting a wrong value, such as alphabets, this s-exp raises an error. The error is caught by the errorback function defined by &lt;code&gt;deferred:error&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Timer&lt;/h3&gt; &#xA;&lt;p&gt;After evaluating this s-exp and waiting for 1 second, a message is shown in the minibuffer.&lt;/p&gt; &#xA;&lt;p&gt;Timer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(deferred:$&#xA;  (deferred:wait 1000) ; 1000msec&#xA;  (deferred:nextc it&#xA;    (lambda (x)&#xA;      (message &#34;Timer sample! : %s msec&#34; x))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The next deferred task subsequent to deferred:wait receives the actual elapse time in millisecond.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Commands and Sub-process&lt;/h3&gt; &#xA;&lt;p&gt;This s-exp inserts the result that is performed by the command &lt;code&gt;ls -la&lt;/code&gt;. (This s-exp may not run in windows. Try &lt;code&gt;dir&lt;/code&gt; command.)&lt;/p&gt; &#xA;&lt;p&gt;Command process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(deferred:$&#xA;  (deferred:process &#34;ls&#34; &#34;-la&#34;)&#xA;  (deferred:nextc it&#xA;    (lambda (x) (insert x))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This s-exp hardly blocks Emacs because of asynchronous mechanisms.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;HTTP GET : Text&lt;/h3&gt; &#xA;&lt;p&gt;This s-exp inserts a text from &lt;a href=&#34;http://www.gnu.org&#34;&gt;http://www.gnu.org&lt;/a&gt; asynchronously. (You can clear the result with undo command.)&lt;/p&gt; &#xA;&lt;p&gt;HTTP GET:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(require &#39;url)&#xA;&#xA;(deferred:$&#xA;  (deferred:url-retrieve &#34;http://www.gnu.org&#34;)&#xA;  (deferred:nextc it&#xA;    (lambda (buf)&#xA;      (insert  (with-current-buffer buf (buffer-string)))&#xA;      (kill-buffer buf))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;HTTP Get : Image&lt;/h3&gt; &#xA;&lt;p&gt;This s-exp inserts an image from google asynchronously.&lt;/p&gt; &#xA;&lt;p&gt;Get an image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(deferred:$&#xA;  (deferred:url-retrieve &#34;http://www.google.co.jp/intl/en_com/images/srpr/logo1w.png&#34;)&#xA;  (deferred:nextc it&#xA;    (lambda (buf)&#xA;      (insert-image&#xA;       (create-image&#xA;        (let ((data (with-current-buffer buf (buffer-string))))&#xA;          (substring data (+ (string-match &#34;\n\n&#34; data) 2)))&#xA;        &#39;png t))&#xA;      (kill-buffer buf))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parallel&lt;/h3&gt; &#xA;&lt;p&gt;This s-exp retrieves two images from google concurrently and wait for the both results. Then, the file sizes of the images are inserted the current buffer.&lt;/p&gt; &#xA;&lt;p&gt;Parallel deferred:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(deferred:$&#xA;  (deferred:parallel&#xA;    (lambda ()&#xA;      (deferred:url-retrieve &#34;http://www.google.co.jp/intl/en_com/images/srpr/logo1w.png&#34;))&#xA;    (lambda ()&#xA;      (deferred:url-retrieve &#34;http://www.google.co.jp/images/srpr/nav_logo14.png&#34;)))&#xA;  (deferred:nextc it&#xA;    (lambda (buffers)&#xA;      (cl-loop for i in buffers&#xA;               do&#xA;               (insert&#xA;                (format&#xA;                 &#34;size: %s\n&#34;&#xA;                 (with-current-buffer i (length (buffer-string)))))&#xA;               (kill-buffer i)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The function &lt;code&gt;deferred:parallel&lt;/code&gt; runs asynchronous tasks concurrently.&lt;/li&gt; &#xA; &lt;li&gt;The function wait for all results, regardless normal or abnormal. Then, the subsequent tasks are executed.&lt;/li&gt; &#xA; &lt;li&gt;The next task receives a list of the results.&lt;/li&gt; &#xA; &lt;li&gt;The order of the results is corresponding to one of the argument.&lt;/li&gt; &#xA; &lt;li&gt;Giving an alist of tasks as the argument, the results alist is returned.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Deferred Combination : try-catch-finally&lt;/h3&gt; &#xA;&lt;p&gt;This s-exp executes following tasks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Getting an image by wget command,&lt;/li&gt; &#xA; &lt;li&gt;Resizing the image by convert command in ImageMagick,&lt;/li&gt; &#xA; &lt;li&gt;Insert the re-sized image into the current buffer. You can construct the control structure of deferred tasks, like try-catch-finally in Java.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Get an image by wget and resize by ImageMagick:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(deferred:$&#xA;&#xA;  ;; try&#xA;  (deferred:$&#xA;    (deferred:process &#34;wget&#34; &#34;-O&#34; &#34;a.jpg&#34; &#34;http://www.gnu.org/software/emacs/tour/images/splash.png&#34;)&#xA;    (deferred:nextc it&#xA;      (lambda () (deferred:process &#34;convert&#34; &#34;a.jpg&#34; &#34;-resize&#34; &#34;100x100&#34; &#34;jpg:b.jpg&#34;)))&#xA;    (deferred:nextc it&#xA;      (lambda ()&#xA;        (clear-image-cache)&#xA;        (insert-image (create-image (expand-file-name &#34;b.jpg&#34;) &#39;jpeg nil)))))&#xA;&#xA;  ;; catch&#xA;  (deferred:error it ;&#xA;    (lambda (err)&#xA;      (insert &#34;Can not get a image! : &#34; err)))&#xA;&#xA;  ;; finally&#xA;  (deferred:nextc it&#xA;    (lambda ()&#xA;      (deferred:parallel&#xA;        (lambda () (delete-file &#34;a.jpg&#34;))&#xA;        (lambda () (delete-file &#34;b.jpg&#34;)))))&#xA;  (deferred:nextc it&#xA;    (lambda (x) (message &#34;&amp;gt;&amp;gt; %s&#34; x))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In this case, the deferred tasks are statically connected.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here is an another sample code for try-catch-finally blocks. This is simpler than above code because of the &lt;code&gt;deferred:try&#39; macro. (Note: They bring the same results practically, but are not perfectly identical. The &lt;/code&gt;finally` task may not be called because of asynchrony.)&lt;/p&gt; &#xA;&lt;p&gt;Try-catch-finally:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(deferred:$&#xA;  (deferred:try&#xA;    (deferred:$&#xA;      (deferred:process &#34;wget&#34; &#34;-O&#34; &#34;a.jpg&#34; &#34;http://www.gnu.org/software/emacs/tour/images/splash.png&#34;)&#xA;      (deferred:nextc it&#xA;        (lambda () (deferred:process &#34;convert&#34; &#34;a.jpg&#34; &#34;-resize&#34; &#34;100x100&#34; &#34;jpg:b.jpg&#34;)))&#xA;      (deferred:nextc it&#xA;        (lambda ()&#xA;          (clear-image-cache)&#xA;          (insert-image (create-image (expand-file-name &#34;b.jpg&#34;) `jpeg nil)))))&#xA;    :catch&#xA;    (lambda (err) (insert &#34;Can not get a image! : &#34; err))&#xA;    :finally&#xA;    (lambda ()&#xA;      (delete-file &#34;a.jpg&#34;)&#xA;      (delete-file &#34;b.jpg&#34;)))&#xA;  (deferred:nextc it&#xA;    (lambda (x) (message &#34;&amp;gt;&amp;gt; %s&#34; x))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Timeout&lt;/h3&gt; &#xA;&lt;p&gt;Although a long time command is executed (3 second sleeping), the task is rejected by timeout for 1 second.&lt;/p&gt; &#xA;&lt;p&gt;The function &lt;code&gt;deferred:earlier&lt;/code&gt; also runs asynchronous tasks concurrently, however, the next deferred task receives the first result. The other results and tasks will be rejected (canceled or ignored).&lt;/p&gt; &#xA;&lt;p&gt;Timeout Process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(deferred:$&#xA;  (deferred:earlier&#xA;    (deferred:process &#34;sh&#34; &#34;-c&#34; &#34;sleep 3 | echo &#39;hello!&#39;&#34;)&#xA;    (deferred:$&#xA;      (deferred:wait 1000) ; timeout msec&#xA;      (deferred:nextc it (lambda () &#34;canceled!&#34;))))&#xA;  (deferred:nextc it&#xA;    (lambda (x) (insert x))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Changing longer timeout for &lt;code&gt;deferred:wait&lt;/code&gt;, the next task receives a result of the command.&lt;/li&gt; &#xA; &lt;li&gt;When a task finishes abnormally, the task is ignored. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;When all tasks finishes abnormally, the next task receives nil.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The functions &lt;code&gt;deferred:parallel&lt;/code&gt; and &lt;code&gt;deferred:earlier&lt;/code&gt; may be corresponding to &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;, respectively.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here is an another sample code for timeout, employing &lt;code&gt;deferred:timeout&lt;/code&gt; macro.&lt;/p&gt; &#xA;&lt;p&gt;Timeout macro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(deferred:$&#xA;  (deferred:timeout&#xA;    1000 &#34;canceled!&#34;&#xA;    (deferred:process &#34;sh&#34; &#34;-c&#34; &#34;sleep 3 | echo &#39;hello!&#39;&#34;))&#xA;  (deferred:nextc it&#xA;    (lambda (x) (insert x))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the &lt;code&gt;deferred:timeout&lt;/code&gt; and &lt;code&gt;deferred:earlier&lt;/code&gt; just rejects the task result and does not stop the running task chains. Please see the document for &lt;code&gt;deferred:cancel&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Loop and Animation&lt;/h3&gt; &#xA;&lt;p&gt;This s-exp plays an animation at the cursor position for few seconds. Then, you can move cursor freely, because the animation does not block Emacs.&lt;/p&gt; &#xA;&lt;p&gt;Returning a deferred object in the deferred tasks, the returned task is executed before the next deferred one that is statically connected on the source code. (In this case, the interrupt task is dynamically connected.)&lt;/p&gt; &#xA;&lt;p&gt;Employing a recursive structure of deferred tasks, you can construct a deferred loop. It may seem the multi-thread in Emacs Lisp.&lt;/p&gt; &#xA;&lt;p&gt;Loop and animation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let ((count 0) (anm &#34;-/|\\-&#34;)&#xA;      (end 50) (pos (point))&#xA;      (wait-time 50))&#xA;  (deferred:$&#xA;    (deferred:next&#xA;      (lambda (x) (message &#34;Animation started.&#34;)))&#xA;&#xA;    (deferred:nextc it&#xA;      (deferred:lambda (x)&#xA;        (save-excursion&#xA;          (when (&amp;lt; 0 count)&#xA;            (goto-char pos) (delete-char 1))&#xA;          (insert (char-to-string&#xA;                   (aref anm (% count (length anm))))))&#xA;        (if (&amp;gt; end (cl-incf count)) ; return nil to stop this loop&#xA;            (deferred:nextc (deferred:wait wait-time) self)))) ; return the deferred&#xA;&#xA;    (deferred:nextc it&#xA;      (lambda (x)&#xA;        (save-excursion&#xA;          (goto-char pos) (delete-char 1))&#xA;        (message &#34;Animation finished.&#34;)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;deferred:lambda&lt;/code&gt; is an anaphoric macro in which &lt;code&gt;self&lt;/code&gt; refers itself. It is convenient to construct a recursive structure.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Wrapping asynchronous function&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s say you have an asynchronous function which takes a callback. For example, dbus.el, xml-rpc.el and websocket.el has such kind of asynchronous APIs. To use such libraries with deferred.el, you can make an unregistered deferred object using &lt;code&gt;deferred:new&lt;/code&gt; and then start the deferred callback queue using &lt;code&gt;deferred:callback-post&lt;/code&gt; in the callback given to the asynchronous function. If the asynchronous function supports &#34;errorback&#34;, you can use &lt;code&gt;deferred:errorback-post&lt;/code&gt; to pass the error information to the following callback queue.&lt;/p&gt; &#xA;&lt;p&gt;In the following example, &lt;code&gt;run-at-time&lt;/code&gt; is used as an example for the asynchronous function. Deferred.el already has &lt;code&gt;deferred:wait&lt;/code&gt; for this purpose so that you don&#39;t need the following code if you want to use &lt;code&gt;run-at-time&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(deferred:$&#xA;  (deferred:next&#xA;    (lambda ()&#xA;      (message &#34;1&#34;)&#xA;      1))&#xA;  (deferred:nextc it&#xA;    (lambda (x)&#xA;      (let ((d (deferred:new #&#39;identity)))&#xA;        (run-at-time 0 nil (lambda (x)&#xA;                             ;; Start the following callback queue now.&#xA;                             (deferred:callback-post d x))&#xA;                     x)&#xA;        ;; Return the unregistered (not yet started) callback&#xA;        ;; queue, so that the following queue will wait until it&#xA;        ;; is started.&#xA;        d)))&#xA;  ;; You can connect deferred callback queues&#xA;  (deferred:nextc it&#xA;    (lambda (x)&#xA;      (message &#34;%s&#34; (1+ x)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;h3&gt;Functions&lt;/h3&gt; &#xA;&lt;h4&gt;Basic functions&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:next (callback)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;callback: a function with zero or one argument&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return a deferred object that wrap the given callback function. Then, put the deferred object into the execution queue to run asynchronously. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Namely, run the given function asynchronously.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:nextc (d callback)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;d: a deferred object&lt;/li&gt; &#xA;     &lt;li&gt;callback: a function with zero or one argument&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return a deferred object that wrap the given callback function. Then, connect the created deferred object with the given deferred object. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Namely, add the given function to the previous deferred object.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:error (d errorback)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;d: a deferred object&lt;/li&gt; &#xA;     &lt;li&gt;errorback: a function with zero or one argument&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return a deferred object that wrap the given function as errorback. Then, connect the created deferred object with the given deferred object. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Namely, the given function catches the error occurred in the previous task.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;If this function does not throw an error, the subsequent callback functions are executed.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:cancel (d)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;d: a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;the given deferred object (invalidated)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Invalidate the given deferred object.&lt;/li&gt; &#xA;   &lt;li&gt;Because this function modifies the deferred object, one can not used the given deferred instance again.&lt;/li&gt; &#xA;   &lt;li&gt;This function just cancels the given deferred instance, not the whole deferred chain. In the current deferred implementation, a message of cancellation can not propagate to chained deferred objects because the chain is built by the singly linked list. If the deferred chains may be canceled on your code, you should care the side-effect tasks.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:watch (d callback)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;d: deferred object&lt;/li&gt; &#xA;     &lt;li&gt;callback: a function with zero or one argument&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Create a deferred object with watch task and connect it to the given deferred object.&lt;/li&gt; &#xA;   &lt;li&gt;The watch task CALLBACK can not affect deferred chains with return values.&lt;/li&gt; &#xA;   &lt;li&gt;This function is used in following purposes, simulation of try-finally block in asynchronous tasks, monitoring of progress of deferred tasks.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:wait (msec)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;msec: a number (millisecond)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return a deferred object that will be called after the specified millisecond.&lt;/li&gt; &#xA;   &lt;li&gt;The subsequent deferred task receives the actual elapse time in millisecond.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:$&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments / more than one deferred forms&lt;/li&gt; &#xA;   &lt;li&gt;Return / the last deferred object&lt;/li&gt; &#xA;   &lt;li&gt;An anaphoric macro chains deferred objects. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;The anaphoric variable &lt;code&gt;it&lt;/code&gt; holds a deferred object in the previous line.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Utility functions&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:loop (number-or-list callback)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;number-or-list: an integer or a list&lt;/li&gt; &#xA;     &lt;li&gt;callback: a function with zero or one argument&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return a deferred object that iterates the function for the specified times. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;The function receives the count number that begins zero.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;If a list is given, not a number, the function visits each elements in the list like &lt;code&gt;mapc&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:parallel (list-or-alist)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;list-or-alist:&lt;/li&gt; &#xA;     &lt;li&gt;more than one deferred objects or a list of functions&lt;/li&gt; &#xA;     &lt;li&gt;an alist consist of cons cells with a symbol and a deferred object or a function&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return a deferred object that executes given functions in parallel and wait for all callback values.&lt;/li&gt; &#xA;   &lt;li&gt;The subsequent deferred task receives a list of the results. The order of the results is corresponding to one of the argument.&lt;/li&gt; &#xA;   &lt;li&gt;Giving an alist of tasks as the argument, the results alist is returned.&lt;/li&gt; &#xA;   &lt;li&gt;If the parallel task throws an error, the error object is passed as a result.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:earlier (list-or-alist)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;list-or-alist:&lt;/li&gt; &#xA;     &lt;li&gt;more than one deferred objects or a list of functions&lt;/li&gt; &#xA;     &lt;li&gt;an alist consist of cons cells with a symbol and a deferred object or a function&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return a deferred object that executes given functions in parallel and wait for the first callback value. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;The other tasks are rejected. (See the document for &lt;code&gt;deferred:cancel&lt;/code&gt;)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Giving an alist of tasks as the argument, a cons cell is returned as a result.&lt;/li&gt; &#xA;   &lt;li&gt;When a task finishes abnormally, the task is ignored. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;When all tasks finishes abnormally, the next task receives nil. That is, no errorback function is called.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Wrapper functions&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:call (function args...)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;function: a function&lt;/li&gt; &#xA;     &lt;li&gt;args: arguments (variable length)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;a wrapper of the function &lt;code&gt;funcall&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:apply (function args)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;function: a function&lt;/li&gt; &#xA;     &lt;li&gt;args: a list of arguments&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;a wrapper of the function &lt;code&gt;apply&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:process (command args...) / deferred:process-shell (command args...)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;command: command to execute&lt;/li&gt; &#xA;     &lt;li&gt;args: command arguments (variable length)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Execute a command asynchronously. These functions are wrappers of &lt;code&gt;start-process&lt;/code&gt; and &lt;code&gt;start-process-shell-command&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;The subsequent deferred task receives the stdout and stderr from the command as a string.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:process-buffer (command args...) / deferred:process-shell-buffer (command args...)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;command: command to execute&lt;/li&gt; &#xA;     &lt;li&gt;args: command arguments (variable length)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Execute a command asynchronously. These functions are wrappers of &lt;code&gt;start-process&lt;/code&gt; and &lt;code&gt;start-process-shell-command&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;The subsequent deferred task receives the stdout and stderr from the command as a buffer. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;The following tasks are responsible to kill the buffer.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:wait-idle (msec)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;msec: a number (millisecond)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return a deferred object that will be called when Emacs has been idle for the specified millisecond.&lt;/li&gt; &#xA;   &lt;li&gt;The subsequent deferred task receives the elapse time in millisecond.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:url-retrieve (url [cbargs])&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;url: URL to get&lt;/li&gt; &#xA;     &lt;li&gt;cbargs: callback argument (optional)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;A wrapper function of &lt;code&gt;url-retrieve&lt;/code&gt; in the &lt;code&gt;url&lt;/code&gt; package.&lt;/li&gt; &#xA;   &lt;li&gt;The subsequent deferred task receives the content as a buffer. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;The following tasks are responsible to kill the buffer.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[experimental] deferred:url-get (url [params])&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;url: URL to get&lt;/li&gt; &#xA;     &lt;li&gt;params: alist of parameters&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[experimental] deferred:url-post (url [params])&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;url: URL to get&lt;/li&gt; &#xA;     &lt;li&gt;params: alist of parameters&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Primitive functions&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:new ([callback])&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;callback: a function with zero or one argument (optional)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Create a deferred object&lt;/li&gt; &#xA;   &lt;li&gt;The created deferred object is never called until someone call the function &lt;code&gt;deferred:callback&lt;/code&gt; or &lt;code&gt;deferred:errorback&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Using this object, a deferred chain can pause to wait for other events. (See the source for &lt;code&gt;deferred:wait&lt;/code&gt;.)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:succeed ([value])&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;value: a value (optional)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Create a deferred object that has been called the callback function.&lt;/li&gt; &#xA;   &lt;li&gt;When a deferred task is connected, the subsequent task will be executed immediately (synchronously).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:fail ([error])&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;error: an error value (optional)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Create a deferred object that has been called the errorback function.&lt;/li&gt; &#xA;   &lt;li&gt;When a deferred task is connected, the subsequent task will be executed immediately (synchronously).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:callback (d [value])&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;d: a deferred object&lt;/li&gt; &#xA;     &lt;li&gt;value: a value (optional)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object or a result value&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Start executing the deferred tasks. The first task is executed synchronously.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:callback-post (d [value])&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;d: a deferred object&lt;/li&gt; &#xA;     &lt;li&gt;value: a value (optional)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object or a result value&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Start executing the deferred tasks. The first task is executed asynchronously.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:errorback (d [error])&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;d: a deferred object&lt;/li&gt; &#xA;     &lt;li&gt;error: an error value (optional)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object or a result value&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Start executing the deferred tasks from errorback. The first task is executed synchronously.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:errorback-post (d [error])&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;d: a deferred object&lt;/li&gt; &#xA;     &lt;li&gt;error: an error value (optional)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object or a result value&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Start executing the deferred tasks from errorback. The first task is executed asynchronously.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Utility Macros&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:try (d &amp;amp;key catch finally)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;d: deferred object&lt;/li&gt; &#xA;     &lt;li&gt;catch: [keyword argument] A function that is called when an error is occurred during tasks &lt;code&gt;d&lt;/code&gt;. (This function is expanded as an argument of &lt;code&gt;deferred:error&lt;/code&gt;.)&lt;/li&gt; &#xA;     &lt;li&gt;finally: [keyword argument] A function that is called when tasks &lt;code&gt;d&lt;/code&gt; finishes whether in success or failure. (This function is expanded as an argument of deferred:watch.)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Try-catch-finally macro. This macro simulates the try-catch-finally block asynchronously.&lt;/li&gt; &#xA;   &lt;li&gt;Because of asynchrony, this macro does not ensure that the &lt;code&gt;finally&lt;/code&gt; task should be called.&lt;/li&gt; &#xA;   &lt;li&gt;This macro is implemented by &lt;code&gt;deferred:error&lt;/code&gt; and &lt;code&gt;deferred:watch&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:timeout (msec timeout-form d)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;msec: a number&lt;/li&gt; &#xA;     &lt;li&gt;timeout-form: sexp-form&lt;/li&gt; &#xA;     &lt;li&gt;d: a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Time out macro on a deferred task &lt;code&gt;d&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;If the deferred task &lt;code&gt;d&lt;/code&gt; does not complete within &lt;code&gt;timeout-msec&lt;/code&gt;, this macro rejects the deferred task and return the &lt;code&gt;timeout-form&lt;/code&gt;. (See the document for &lt;code&gt;deferred:cancel&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;This macro is implemented by &lt;code&gt;deferred:earlier&lt;/code&gt; and &lt;code&gt;deferred:wait&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;deferred:process...&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;deferred:processc (d command args...)&lt;/li&gt; &#xA;   &lt;li&gt;deferred:process-bufferc (d command args...)&lt;/li&gt; &#xA;   &lt;li&gt;deferred:process-shellc (d command args...)&lt;/li&gt; &#xA;   &lt;li&gt;deferred:process-shell-bufferc (d command args...)&lt;/li&gt; &#xA;   &lt;li&gt;Arguments &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;d: a deferred object&lt;/li&gt; &#xA;     &lt;li&gt;command: command to execute&lt;/li&gt; &#xA;     &lt;li&gt;args: command arguments (variable length)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a deferred object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;This macro wraps the deferred:process function in deferred:nextc and connect the given deferred task.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Execution and Connection&lt;/h3&gt; &#xA;&lt;h4&gt;Firing&lt;/h4&gt; &#xA;&lt;p&gt;Some deferred functions can fire a deferred chain implicitly. Following functions register a deferred object with the execution queue to run asynchronously.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;next&lt;/li&gt; &#xA; &lt;li&gt;wait&lt;/li&gt; &#xA; &lt;li&gt;loop&lt;/li&gt; &#xA; &lt;li&gt;parallel&lt;/li&gt; &#xA; &lt;li&gt;earlier&lt;/li&gt; &#xA; &lt;li&gt;call, apply&lt;/li&gt; &#xA; &lt;li&gt;process&lt;/li&gt; &#xA; &lt;li&gt;url-retrieve, url-get, url-post&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The deferred tasks those are created by &lt;code&gt;deferred:new&lt;/code&gt; are never called. Using this object, a deferred chain can pause to wait for other events. (See the source for &lt;code&gt;deferred:wait&lt;/code&gt;.)&lt;/p&gt; &#xA;&lt;p&gt;One can fire the chain before connecting. That is, deferred objects wait for connecting the subsequent task holding the result value. The functions &lt;code&gt;deferred:succeed&lt;/code&gt; and &lt;code&gt;deferred:fail&lt;/code&gt; create those waiting objects.&lt;/p&gt; &#xA;&lt;h4&gt;Static connection&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;static connection (statically connected)&lt;/code&gt; is a connection between deferred tasks on the source code. This is a basic usage for the deferred chain.&lt;/p&gt; &#xA;&lt;p&gt;The static connection is almost equivalent to ordinary callback notation as an argument in the function declarations. The deferred notation is easy to read and write better than the callback one, because the sequence of asynchronous tasks can be written by the deferred notation straightforward.&lt;/p&gt; &#xA;&lt;h4&gt;Dynamic Connection&lt;/h4&gt; &#xA;&lt;p&gt;Returning a deferred object in the deferred tasks, the returned task is executed before the next deferred one that is statically connected on the source code. This is the &lt;code&gt;dynamic connection (dynamically connected)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Employing a recursive structure of deferred tasks, you can construct higher level control structures, such as loop.&lt;/p&gt; &#xA;&lt;h2&gt;Discussion&lt;/h2&gt; &#xA;&lt;p&gt;Some discussions of writing deferred codes.&lt;/p&gt; &#xA;&lt;h3&gt;Using lexical scope&lt;/h3&gt; &#xA;&lt;p&gt;Using the lexical scope macro, such as &lt;code&gt;let&lt;/code&gt;, the deferred tasks defined by lambdas can access local variables.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;let&lt;/code&gt; Ex.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let ((a (point)))&#xA;  (deferred:$&#xA;    (deferred:wait 1000)&#xA;    (deferred:nextc it&#xA;      (lambda (x)&#xA;        (goto-char a)&#xA;        (insert &#34;here!&#34;)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you write a code of deferred tasks without lexical scope macros, you should be careful with the scopes of each variables.&lt;/p&gt; &#xA;&lt;h3&gt;Excursion (Current status)&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;excursion&lt;/code&gt; functions those hold the current status with the s-exp form, such as &lt;code&gt;save-execursion&lt;/code&gt; or &lt;code&gt;with-current-buffer&lt;/code&gt;, are not valid in the deferred tasks, because of execution asynchronously.&lt;/p&gt; &#xA;&lt;p&gt;Wrong Ex.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(with-current-buffer (get-buffer &#34;*Message*&#34;)&#xA;  (deferred:$&#xA;    (deferred:wait 1000)&#xA;    (deferred:nextc it&#xA;      (lambda (x)&#xA;        (insert &#34;Time: %s &#34; x) ; `insert` may not be in the *Message* buffer!&#xA;      ))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, using lexical scope macros to access the buffer variable, you can change the buffer in the deferred task.&lt;/p&gt; &#xA;&lt;p&gt;Corrected:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let ((buf (get-buffer &#34;*Message*&#34;)))&#xA;  (deferred:$&#xA;    (deferred:wait 1000)&#xA;    (deferred:nextc it&#xA;      (lambda (x)&#xA;        (with-current-buffer buf ; Set buffer in the asynchronous task.&#xA;          (insert &#34;Time: %s &#34; x))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Be aware of return values&lt;/h3&gt; &#xA;&lt;p&gt;However the dynamic connection is a powerful feature, sometimes it causes bugs of the wrong execution order, because of returning not intended deferred objects.&lt;/p&gt; &#xA;&lt;p&gt;Then, you should watch the return values of the deferred tasks not to cause an unexpected dynamic connection.&lt;/p&gt; &#xA;&lt;h3&gt;Debugging&lt;/h3&gt; &#xA;&lt;p&gt;The debugging of asynchronous tasks is difficult. Of course, you can use debugger for deferred tasks, but asynchronous tasks cause some troubles, such as interruptions of your debugging and timing gap of simultaneous deferred tasks. Therefore, logging is a safe debugging to observe the tasks correctly, for example, using the &lt;code&gt;message&lt;/code&gt; function and making custom application log buffer.&lt;/p&gt; &#xA;&lt;p&gt;If deferred tasks fall into an infinite loop unexpectedly (but Emacs may not freeze), calling the command &lt;code&gt;deferred:clear-queue&lt;/code&gt;, you can stop the deferred tasks immediately.&lt;/p&gt; &#xA;&lt;p&gt;If the errors occurred in deferred tasks are caught by no errorback functions, finally the deferred framework catches it and reports to the message buffer. Because the implementation of the framework uses a &lt;code&gt;condition-case&lt;/code&gt; form, the debugger can not catch the signals normally. If you want to debug the errors in the deferred tasks with the debug-on-error mechanism, set the variable &lt;code&gt;deferred:debug-on-signal&lt;/code&gt; non-nil.&lt;/p&gt; &#xA;&lt;p&gt;Wrapping a deferred task in the function &lt;code&gt;deferred:sync!&lt;/code&gt;, you can wait for the result of the task synchronously. However, the wrapper function should be used for test or debug purpose, because the synchronous waiting is not exact.&lt;/p&gt; &#xA;&lt;h3&gt;Using macros&lt;/h3&gt; &#xA;&lt;p&gt;Writing deferred tasks with &lt;code&gt;deferred.el&lt;/code&gt;, you may write a lot of &lt;code&gt;deferred:nextc&lt;/code&gt; and &lt;code&gt;lambda&lt;/code&gt; to define tasks. Defining a macro, you may write codes shortly. The test code &lt;code&gt;test-deferred.el&lt;/code&gt; uses many macros to shorten test codes.&lt;/p&gt; &#xA;&lt;p&gt;On the other hand, using macros to hide &lt;code&gt;lambda&lt;/code&gt;, it is difficult to realize when the deferred codes are evaluated. That is why &lt;code&gt;deferred.el&lt;/code&gt; does not provide lot of convenient macros. If you use macros, be careful evaluation timing of deferred forms.&lt;/p&gt; &#xA;&lt;h3&gt;Introduction for deferred&lt;/h3&gt; &#xA;&lt;p&gt;Following documents are good introduction to deferred.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://cho45.stfuawsc.com/jsdeferred/doc/intro.en.html&#34; title=&#34;Introduction to JSDeferred&#34;&gt;Introduction to JSDeferred&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://cho45.stfuawsc.com/jsdeferred/&#34; title=&#34;JSDeferred site&#34;&gt;JSDeferred site&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;(C) 2010-2016 SAKURAI Masashi All rights reserved. m.sakurai at kiwanami.net&lt;/p&gt;</summary>
  </entry>
</feed>