<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-03-30T01:46:27Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ahyatt/llm</title>
    <updated>2025-03-30T01:46:27Z</updated>
    <id>tag:github.com,2025-03-30:/ahyatt/llm</id>
    <link href="https://github.com/ahyatt/llm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A package abstracting llm capabilities for emacs.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: llm package for emacs&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Introduction This library provides an interface for interacting with Large Language Models (LLMs). It allows elisp code to use LLMs while also giving end-users the choice to select their preferred LLM. This is particularly beneficial when working with LLMs since various high-quality models exist, some of which have paid API access, while others are locally installed and free but offer medium quality. Applications using LLMs can utilize this library to ensure compatibility regardless of whether the user has a local LLM or is paying for API access.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This library abstracts several kinds of features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Chat functionality: the ability to query the LLM and get a response, and continue to take turns writing to the LLM and receiving responses. The library supports both synchronous, asynchronous, and streaming responses.&lt;/li&gt; &#xA; &lt;li&gt;Chat with image and other kinda of media inputs are also supported, so that the user can input images and discuss them with the LLM.&lt;/li&gt; &#xA; &lt;li&gt;Tool use is supported, for having the LLM call elisp functions that it chooses, with arguments it provides.&lt;/li&gt; &#xA; &lt;li&gt;Embeddings: Send text and receive a vector that encodes the semantic meaning of the underlying text. Can be used in a search system to find similar passages.&lt;/li&gt; &#xA; &lt;li&gt;Prompt construction: Create a prompt to give to an LLM from one more sources of data.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Certain functionalities might not be available in some LLMs. Any such unsupported functionality will raise a &lt;del&gt;&#39;not-implemented&lt;/del&gt; signal, or it may fail in some other way. Clients are recommended to check =llm-capabilities= when trying to do something beyond basic text chat.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Setting up providers Users of an application that uses this package should not need to install it themselves. The llm package should be installed as a dependency when you install the package that uses it. However, you do need to require the llm module and set up the provider you will be using. Typically, applications will have a variable you can set. For example, let&#39;s say there&#39;s a package called &#34;llm-refactoring&#34;, which has a variable &lt;del&gt;llm-refactoring-provider&lt;/del&gt;. You would set it up like so:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (use-package llm-refactoring :init (require &#39;llm-openai) (setq llm-refactoring-provider (make-llm-openai :key my-openai-key)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Here &lt;del&gt;my-openai-key&lt;/del&gt; would be a variable you set up before with your OpenAI key. Or, just substitute the key itself as a string. It&#39;s important to remember never to check your key into a public repository such as GitHub, because your key must be kept private. Anyone with your key can use the API, and you will be charged.&lt;/p&gt; &#xA;&lt;p&gt;You can also use a function as a key, so you can store your key in a secure place and retrieve it via a function. For example, you could add a line to =~/.authinfo.gpg=:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example machine llm.openai password &#xA; &lt;key&gt;&#xA;   #+end_example&#xA; &lt;/key&gt;&lt;/p&gt; &#xA;&lt;p&gt;And then set up your provider like: #+begin_src emacs-lisp (setq llm-refactoring-provider (make-llm-openai :key (plist-get (car (auth-source-search :host &#34;llm.openai&#34;)) :secret))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;All of the providers (except for =llm-fake=), can also take default parameters that will be used if they are not specified in the prompt. These are the same parameters as appear in the prompt, but prefixed with =default-chat-=. So, for example, if you find that you like Ollama to be less creative than the default, you can create your provider like:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (make-llm-ollama :embedding-model &#34;mistral:latest&#34; :chat-model &#34;mistral:latest&#34; :default-chat-temperature 0.1) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;For embedding users. if you store the embeddings, you &lt;em&gt;must&lt;/em&gt; set the embedding model. Even though there&#39;s no way for the llm package to tell whether you are storing it, if the default model changes, you may find yourself storing incompatible embeddings. ** Open AI You can set up with &lt;del&gt;make-llm-openai&lt;/del&gt;, with the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;:key&lt;/del&gt;, the Open AI key that you get when you sign up to use Open AI&#39;s APIs. Remember to keep this private. This is non-optional.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:chat-model&lt;/del&gt;: A model name from the [[https://platform.openai.com/docs/models/gpt-4][list of Open AI&#39;s model names.]] Keep in mind some of these are not available to everyone. This is optional, and will default to a reasonable model.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:embedding-model&lt;/del&gt;: A model name from [[https://platform.openai.com/docs/guides/embeddings/embedding-models][list of Open AI&#39;s embedding model names.]] This is optional, and will default to a reasonable model. ** Open AI Compatible There are many Open AI compatible APIs and proxies of Open AI. You can set up one with &lt;del&gt;make-llm-openai-compatible&lt;/del&gt;, with the following parameter:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;del&gt;:url&lt;/del&gt;, the URL of leading up to the command (&#34;embeddings&#34; or &#34;chat/completions&#34;). So, for example, &#34;&lt;a href=&#34;https://api.openai.com/v1/&#34;&gt;https://api.openai.com/v1/&lt;/a&gt;&#34; is the URL to use Open AI (although if you wanted to do that, just use &lt;del&gt;make-llm-openai&lt;/del&gt; instead).&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:chat-model&lt;/del&gt;: The chat model that is supported by the provider. Some providers don&#39;t need a model to be set, but still require it in the API, so we default to &#34;unset&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:embedding-model&lt;/del&gt;: An embedding model name that is supported by the provider. This is also defaulted to &#34;unset&#34;. ** Azure&#39;s Open AI Microsoft Azure has an Open AI integration, although it doesn&#39;t support everything Open AI does, such as tool use. You can set it up with &lt;del&gt;make-llm-azure&lt;/del&gt;, with the following parameter:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;:url&lt;/del&gt;, the endpoint URL, such as &#34;&lt;a href=&#34;https://docs-test-001.openai.azure.com/&#34;&gt;https://docs-test-001.openai.azure.com/&lt;/a&gt;&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:key&lt;/del&gt;, the Azure key for Azure OpenAI service.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:chat-model&lt;/del&gt;, the chat model, which must be deployed in Azure.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;embedding-model&lt;/del&gt;, the embedding model which must be deployed in Azure. ** GitHub Models GitHub now has its own platform for interacting with AI models. For a list of models check the [[https://github.com/marketplace/models][marketplace]]. You can set it up with &lt;del&gt;make-llm-github&lt;/del&gt;, with the following parameters:&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:key&lt;/del&gt;, a GitHub token or an Azure AI production key.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:chat-model&lt;/del&gt;, the chat model, which can be any of the ones you have access for (currently o1 is restricted).&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:embedding-model&lt;/del&gt;, the embedding model, which can be better found [[https://github.com/marketplace?type=models&amp;amp;task=Embeddings][through a filter]]a. ** Gemini (not via Google Cloud) This is Google&#39;s AI model. You can get an API key via their [[https://makersuite.google.com/app/apikey][page on Google AI Studio]]. Set this up with &lt;del&gt;make-llm-gemini&lt;/del&gt;, with the following parameters:&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:key&lt;/del&gt;, the Google AI key that you get from Google AI Studio.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:chat-model&lt;/del&gt;, the model name, from the [[https://ai.google.dev/models][list]] of models. This is optional and will default to the text Gemini model.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:embedding-model&lt;/del&gt;: the model name, currently must be &#34;embedding-001&#34;. This is optional and will default to &#34;embedding-001&#34;. ** Vertex (Gemini via Google Cloud) This is mostly for those who want to use Google Cloud specifically, most users should use Gemini instead, which is easier to set up.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can set up with &lt;del&gt;make-llm-vertex&lt;/del&gt;, with the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;:project&lt;/del&gt;: Your project number from Google Cloud that has Vertex API enabled.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:chat-model&lt;/del&gt;: A model name from the [[https://cloud.google.com/vertex-ai/docs/generative-ai/chat/chat-prompts#supported_model][list of Vertex&#39;s model names.]] This is optional, and will default to a reasonable model.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:embedding-model&lt;/del&gt;: A model name from the [[https://cloud.google.com/vertex-ai/docs/generative-ai/embeddings/get-text-embeddings#supported_models][list of Vertex&#39;s embedding model names.]] This is optional, and will default to a reasonable model.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition to the provider, which you may want multiple of (for example, to charge against different projects), there are customizable variables:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-vertex-gcloud-binary&lt;/del&gt;: The binary to use for generating the API key.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-vertex-gcloud-region&lt;/del&gt;: The gcloud region to use. It&#39;s good to set this to a region near where you are for best latency. Defaults to &#34;us-central1&#34;.&lt;/p&gt; &lt;p&gt;If you haven&#39;t already, you must run the following command before using this: #+begin_src sh gcloud beta services identity create --service=aiplatform.googleapis.com --project=PROJECT_ID #+end_src ** Claude [[https://docs.anthropic.com/claude/docs/intro-to-claude][Claude]] is Anthropic&#39;s large language model. It does not support embeddings. You can set it up with the following parameters:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=:key=: The API key you get from [[https://console.anthropic.com/settings/keys][Claude&#39;s settings page]]. This is required. =:chat-model=: One of the [[https://docs.anthropic.com/claude/docs/models-overview][Claude models]]. Defaults to &#34;claude-3-opus-20240229&#34;, the most powerful model. ** Ollama [[https://ollama.ai/][Ollama]] is a way to run large language models locally. There are [[https://ollama.ai/library][many different models]] you can use with it, and some of them [[https://ollama.com/search?c=tools][support tool use]]. You set it up with the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;:scheme&lt;/del&gt;: The scheme (http/https) for the connection to ollama. This default to &#34;http&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:host&lt;/del&gt;: The host that ollama is run on. This is optional and will default to localhost.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:port&lt;/del&gt;: The port that ollama is run on. This is optional and will default to the default ollama port.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:chat-model&lt;/del&gt;: The model name to use for chat. This is not optional for chat use, since there is no default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:embedding-model&lt;/del&gt;: The model name to use for embeddings. Only [[https://ollama.com/search?q=&amp;amp;c=embedding][some models]] can be used for embeddings. This is not optional for embedding use, since there is no default. ** Deepseek [[https://deepseek.com][Deepseek]] is a company offers both reasoning and chat high-quality models. This provider connects to their server. It is also possible to run their model locally as a free model via Ollama. To use the service, you can set it up with the following parameters:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=:key=: The API Key you get from DeepSeek [[https://platform.deepseek.com/api_keys][API key page]]. This is required. =:chat-model=: One of the models from their [[https://api-docs.deepseek.com/quick_start/pricing][model list.]] ** GPT4All [[https://gpt4all.io/index.html][GPT4All]] is a way to run large language models locally. To use it with =llm= package, you must click &#34;Enable API Server&#34; in the settings. It does not offer embeddings or streaming functionality, though, so Ollama might be a better fit for users who are not already set up with local models. You can set it up with the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;:host&lt;/del&gt;: The host that GPT4All is run on. This is optional and will default to localhost.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:port&lt;/del&gt;: The port that GPT4All is run on. This is optional and will default to the default ollama port.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:chat-model&lt;/del&gt;: The model name to use for chat. This is not optional for chat use, since there is no default. ** llama.cpp [[https://github.com/ggerganov/llama.cpp][llama.cpp]] is a way to run large language models locally. To use it with the =llm= package, you need to start the server (with the &#34;--embedding&#34; flag if you plan on using embeddings). The server must be started with a model, so it is not possible to switch models until the server is restarted to use the new model. As such, model is not a parameter to the provider, since the model choice is already set once the server starts.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There is a deprecated provider, however it is no longer needed. Instead, llama cpp is Open AI compatible, so the Open AI Compatible provider should work. ** Fake This is a client that makes no call, but it just there for testing and debugging. Mostly this is of use to programmatic clients of the llm package, but end users can also use it to understand what will be sent to the LLMs. It has the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;:output-to-buffer&lt;/del&gt;: if non-nil, the buffer or buffer name to append the request sent to the LLM to.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:chat-action-func&lt;/del&gt;: a function that will be called to provide a string or symbol and message cons which are used to raise an error.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:embedding-action-func&lt;/del&gt;: a function that will be called to provide a vector or symbol and message cons which are used to raise an error.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Models When picking a chat or embedding model, anything can be used, as long as the service thinks it is valid. However, models vary on context size and capabilities. The =llm-prompt= module, and any client, can depend on the context size of the model via &lt;del&gt;llm-chat-token-limit&lt;/del&gt;. Similarly, some models have different capabilities, exposed in &lt;del&gt;llm-capabilities&lt;/del&gt;. The =llm-models= module defines a list of popular models, but this isn&#39;t a comprehensive list. If you want to add a model, it is fairly easy to do, for example here is adding the Mistral model (which is already included, though):&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (require &#39;llm-models) (llm-models-add :name &#34;Mistral&#34; :symbol &#39;mistral :capabilities &#39;(generation tool-use free-software) :context-length 8192 :regex &#34;mistral&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =:regex= needs to uniquely identify the model passed in from a provider&#39;s chat or embedding model.&lt;/p&gt; &#xA;&lt;p&gt;Once this is done, the model will be recognized to have the given context length and capabilities.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=llm= and the use of non-free LLMs The =llm= package is part of GNU Emacs by being part of GNU ELPA. Unfortunately, the most popular LLMs in use are non-free, which is not what GNU software should be promoting by inclusion. On the other hand, by use of the =llm= package, the user can make sure that any client that codes against it will work with free models that come along. It&#39;s likely that sophisticated free LLMs will, emerge, although it&#39;s unclear right now what free software means with respect to LLMs. Because of this tradeoff, we have decided to warn the user when using non-free LLMs (which is every LLM supported right now except the fake one). You can turn this off the same way you turn off any other warning, by clicking on the left arrow next to the warning when it comes up. Alternatively, you can set &lt;del&gt;llm-warn-on-nonfree&lt;/del&gt; to &lt;del&gt;nil&lt;/del&gt;. This can be set via customization as well.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To build upon the example from before: #+begin_src emacs-lisp (use-package llm-refactoring :init (require &#39;llm-openai) (setq llm-refactoring-provider (make-llm-openai :key my-openai-key) llm-warn-on-nonfree nil) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Programmatic use Client applications should require the =llm= package, and code against it. Most functions are generic, and take a struct representing a provider as the first argument. The client code, or the user themselves can then require the specific module, such as =llm-openai=, and create a provider with a function such as &lt;del&gt;(make-llm-openai :key user-api-key)&lt;/del&gt;. The client application will use this provider to call all the generic functions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For all callbacks, the callback will be executed in the buffer the function was first called from. If the buffer has been killed, it will be executed in a temporary buffer instead. ** Main functions&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-chat provider prompt multi-output&lt;/del&gt;: With user-chosen &lt;del&gt;provider&lt;/del&gt; , and a &lt;del&gt;llm-chat-prompt&lt;/del&gt; structure (created by &lt;del&gt;llm-make-chat-prompt&lt;/del&gt;), send that prompt to the LLM and wait for the string output.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-chat-async provider prompt response-callback error-callback multi-output&lt;/del&gt;: Same as &lt;del&gt;llm-chat&lt;/del&gt;, but executes in the background. Takes a &lt;del&gt;response-callback&lt;/del&gt; which will be called with the text response. The &lt;del&gt;error-callback&lt;/del&gt; will be called in case of error, with the error symbol and an error message.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-chat-streaming provider prompt partial-callback response-callback error-callback multi-output&lt;/del&gt;: Similar to &lt;del&gt;llm-chat-async&lt;/del&gt;, but request a streaming response. As the response is built up, &lt;del&gt;partial-callback&lt;/del&gt; is called with the all the text retrieved up to the current point. Finally, &lt;del&gt;reponse-callback&lt;/del&gt; is called with the complete text.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-embedding provider string&lt;/del&gt;: With the user-chosen &lt;del&gt;provider&lt;/del&gt;, send a string and get an embedding, which is a large vector of floating point values. The embedding represents the semantic meaning of the string, and the vector can be compared against other vectors, where smaller distances between the vectors represent greater semantic similarity.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-embedding-async provider string vector-callback error-callback&lt;/del&gt;: Same as &lt;del&gt;llm-embedding&lt;/del&gt; but this is processed asynchronously. &lt;del&gt;vector-callback&lt;/del&gt; is called with the vector embedding, and, in case of error, &lt;del&gt;error-callback&lt;/del&gt; is called with the same arguments as in &lt;del&gt;llm-chat-async&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-batch-embedding provider strings&lt;/del&gt;: same as &lt;del&gt;llm-embedding&lt;/del&gt;, but takes in a list of strings, and returns a list of vectors whose order corresponds to the ordering of the strings.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-batch-embedding-async provider strings vectors-callback error-callback&lt;/del&gt;: same as &lt;del&gt;llm-embedding-async&lt;/del&gt;, but takes in a list of strings, and returns a list of vectors whose order corresponds to the ordering of the strings.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-count-tokens provider string&lt;/del&gt;: Count how many tokens are in &lt;del&gt;string&lt;/del&gt;. This may vary by &lt;del&gt;provider&lt;/del&gt;, because some provideres implement an API for this, but typically is always about the same. This gives an estimate if the provider has no API support.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-cancel-request request&lt;/del&gt; Cancels the given request, if possible. The &lt;del&gt;request&lt;/del&gt; object is the return value of async and streaming functions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-name provider&lt;/del&gt;. Provides a short name of the model or provider, suitable for showing to users.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-models provider&lt;/del&gt;. Return a list of all the available model names for the provider. This could be either embedding or chat models. You can use &lt;del&gt;llm-models-match&lt;/del&gt; to filter on models that have a certain capability (as long as they are in &lt;del&gt;llm-models&lt;/del&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;llm-chat-token-limit&lt;/del&gt;. Gets the token limit for the chat model. This isn&#39;t possible for some backends like =llama.cpp=, in which the model isn&#39;t selected or known by this library.&lt;/p&gt; &lt;p&gt;And the following helper functions:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;llm-make-chat-prompt text &amp;amp;keys context examples tools temperature max-tokens response-format non-standard-params&lt;/del&gt;: This is how you make prompts. &lt;del&gt;text&lt;/del&gt; can be a string (the user input to the llm chatbot), or a list representing a series of back-and-forth exchanges, of odd number, with the last element of the list representing the user&#39;s latest input. This supports inputting context (also commonly called a system prompt, although it isn&#39;t guaranteed to replace the actual system prompt), examples, and other important elements, all detailed in the docstring for this function. &lt;del&gt;response-format&lt;/del&gt; can be &lt;del&gt;&#39;json&lt;/del&gt;, to force JSON output, or a JSON schema (see below) but the prompt also needs to mention and ideally go into detail about what kind of JSON response is desired. Providers with the &lt;del&gt;json-response&lt;/del&gt; capability support JSON output, and it will be ignored if unsupported. The &lt;del&gt;non-standard-params&lt;/del&gt; let you specify other options that might vary per-provider, and for this, the correctness is up to the client.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;llm-chat-prompt-to-text prompt&lt;/del&gt;: From a prompt, return a string representation. This is not usually suitable for passing to LLMs, but for debugging purposes.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;llm-chat-streaming-to-point provider prompt buffer point finish-callback&lt;/del&gt;: Same basic arguments as &lt;del&gt;llm-chat-streaming&lt;/del&gt;, but will stream to &lt;del&gt;point&lt;/del&gt; in &lt;del&gt;buffer&lt;/del&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;llm-chat-prompt-append-response prompt response role&lt;/del&gt;: Append a new response (from the user, usually) to the prompt. The &lt;del&gt;role&lt;/del&gt; is optional, and defaults to &lt;del&gt;&#39;user&lt;/del&gt;. *** Return and multi-output The default return value is text except for when tools are called, in which case it is a record of the return values of the tools called.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Models can potentially return many types of information, though, so the &lt;del&gt;multi-output&lt;/del&gt; option was added to the &lt;del&gt;llm-chat&lt;/del&gt; calls so that the single return value can instead be a plist that represents the various possible values. In the case of &lt;del&gt;llm-chat&lt;/del&gt;, this plist is returned, in &lt;del&gt;llm-chat-async&lt;/del&gt;, it is passed to the success function. In &lt;del&gt;llm-chat-streaming&lt;/del&gt;, it is passed to the success function, and each partial update will be a plist, with no guarantee that the same keys will always be present.&lt;/p&gt; &#xA;&lt;p&gt;The possible plist keys are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;:text&lt;/del&gt; , for the main textual output.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:reasoning&lt;/del&gt;, for reasoning output, when the model separates it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:tool-uses&lt;/del&gt;, the tools that the llm identified to be called, as a list of plists, with &lt;del&gt;:name&lt;/del&gt; and &lt;del&gt;:args&lt;/del&gt; values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:tool-results&lt;/del&gt;, the results of calling the tools. *** JSON schema By using the &lt;del&gt;response-format&lt;/del&gt; argument to &lt;del&gt;llm-make-chat-prompt&lt;/del&gt;, you can ask the LLM to return items according to a specified JSON schema, based on the [[https://json-schema.org][JSON Schema Spec]]. Not everything is supported, but the most commonly used parts are. To specify the JSON schema, we use a plist-based approach. JSON objects are defined with &lt;del&gt;(:type object :properties (:&#xA;   &lt;var1&gt; &#xA;    &lt;schema1&gt;&#xA;      :&#xA;     &lt;var2&gt; &#xA;      &lt;schema2&gt;&#xA;        ... :&#xA;       &lt;varn&gt; &#xA;        &lt;scheman&gt;&#xA;         ) :required (&#xA;         &lt;req var1&gt;&#xA;           ... &#xA;          &lt;req varn&gt;&#xA;           ))&#xA;          &lt;/req&gt;&#xA;         &lt;/req&gt;&#xA;        &lt;/scheman&gt;&#xA;       &lt;/varn&gt;&#xA;      &lt;/schema2&gt;&#xA;     &lt;/var2&gt;&#xA;    &lt;/schema1&gt;&#xA;   &lt;/var1&gt;&lt;/del&gt;. Arrays are defined with &lt;del&gt;(:type array :items &#xA;   &lt;schema&gt;&#xA;    )&#xA;   &lt;/schema&gt;&lt;/del&gt;. Enums are defined with &lt;del&gt;(:enum [&#xA;   &lt;val1&gt; &#xA;    &lt;val2&gt; &#xA;     &lt;val3&gt;&#xA;      ])&#xA;     &lt;/val3&gt;&#xA;    &lt;/val2&gt;&#xA;   &lt;/val1&gt;&lt;/del&gt;. You can also request integers, strings, and other types defined by the JSON Schema Spec, by just having &lt;del&gt;(:type &#xA;   &lt;type&gt;&#xA;    )&#xA;   &lt;/type&gt;&lt;/del&gt;. Typically, LLMs often require the top-level schema object to be an object, and often that all properties on the top-level object must be required.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some examples: #+begin_src emacs-lisp (llm-chat my-provider (llm-make-chat-prompt &#34;How many countries are there? Return the result as JSON.&#34; :response-format &#39;(:type object :properties (:num (:type &#34;integer&#34;)) :required [&#34;num&#34;]))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : {&#34;num&#34;:195}&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (llm-chat my-provider (llm-make-chat-prompt &#34;Which editor is hard to quit? Return the result as JSON.&#34; :response-format &#39;(:type object :properties (:editor (:enum [&#34;emacs&#34; &#34;vi&#34; &#34;vscode&#34;]) :authors (:type &#34;array&#34; :items (:type &#34;string&#34;))) :required [&#34;editor&#34; &#34;authors&#34;]))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: : {&#34;editor&#34;:&#34;vi&#34;,&#34;authors&#34;:[&#34;Bram Moolenaar&#34;,&#34;Bill Joy&#34;]}&lt;/p&gt; &#xA;&lt;p&gt;** Logging Interactions with the =llm= package can be logged by setting &lt;del&gt;llm-log&lt;/del&gt; to a non-nil value. This should be done only when developing. The log can be found in the =&lt;em&gt;llm log&lt;/em&gt;= buffer. ** How to handle conversations Conversations can take place by repeatedly calling &lt;del&gt;llm-chat&lt;/del&gt; and its variants. The prompt should be constructed with &lt;del&gt;llm-make-chat-prompt&lt;/del&gt;. For a conversation, the entire prompt must be kept as a variable, because the &lt;del&gt;llm-chat-prompt-interactions&lt;/del&gt; slot will be getting changed by the chat functions to store the conversation. For some providers, this will store the history directly in &lt;del&gt;llm-chat-prompt-interactions&lt;/del&gt;, but other LLMs have an opaque conversation history. For that reason, the correct way to handle a conversation is to repeatedly call &lt;del&gt;llm-chat&lt;/del&gt; or variants with the same prompt structure, kept in a variable, and after each time, add the new user text with &lt;del&gt;llm-chat-prompt-append-response&lt;/del&gt;. The following is an example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defvar-local llm-chat-streaming-prompt nil) (defun start-or-continue-conversation (text) &#34;Called when the user has input TEXT as the next input.&#34; (if llm-chat-streaming-prompt (llm-chat-prompt-append-response llm-chat-streaming-prompt text) (setq llm-chat-streaming-prompt (llm-make-chat-prompt text)) (llm-chat-streaming-to-point provider llm-chat-streaming-prompt (current-buffer) (point-max) (lambda ())))) #+end_src ** Caution about &lt;del&gt;llm-chat-prompt-interactions&lt;/del&gt; The interactions in a prompt may be modified by conversation or by the conversion of the context and examples to what the LLM understands. Different providers require different things from the interactions. Some can handle system prompts, some cannot. Some require alternating user and assistant chat interactions, others can handle anything. It&#39;s important that clients keep to behaviors that work on all providers. Do not attempt to read or manipulate &lt;del&gt;llm-chat-prompt-interactions&lt;/del&gt; after initially setting it up for the first time, because you are likely to make changes that only work for some providers. Similarly, don&#39;t directly create a prompt with &lt;del&gt;make-llm-chat-prompt&lt;/del&gt;, because it is easy to create something that wouldn&#39;t work for all providers. ** Tool use &lt;em&gt;Note: tool use is currently beta quality. If you want to use tool use, please watch the =llm= [[https://github.com/ahyatt/llm/discussions][discussions]] for any announcements about changes.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Tool use is a way to give the LLM a list of functions it can call, and have it call the functions for you. The standard interaction has the following steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The client sends the LLM a prompt with tools it can use.&lt;/li&gt; &#xA; &lt;li&gt;The LLM may return which tools to use, and with what arguments, or text as normal.&lt;/li&gt; &#xA; &lt;li&gt;If the LLM has decided to use one or more tools, those tool&#39;s functions should be called, and their results sent back to the LLM. This could be the final step depending on if any follow-on is needed.&lt;/li&gt; &#xA; &lt;li&gt;The LLM will return with a text response based on the initial prompt and the results of the tool use.&lt;/li&gt; &#xA; &lt;li&gt;The client can now can continue the conversation.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This basic structure is useful because it can guarantee a well-structured output (if the LLM does decide to use the tool). &lt;em&gt;Not every LLM can handle tool use, and those that do not will ignore the tools entirely&lt;/em&gt;. The function =llm-capabilities= will return a list with =tool-use= in it if the LLM supports tool use. Because not all providers support tool use when streaming, =streaming-tool-use= indicates the ability to use tool uses in &lt;del&gt;llm-chat-streaming&lt;/del&gt;. Right now only Gemini, Vertex, Claude, and Open AI support tool use. However, even for LLMs that handle tool use, there is sometimes a difference in the capabilities. Right now, it is possible to write tools that succeed in Open AI but cause errors in Gemini, because Gemini does not appear to handle tools that have types that contain other types. So client programs are advised for right now to keep function to simple types.&lt;/p&gt; &#xA;&lt;p&gt;The way to call functions is to attach a list of functions to the =tools= slot in the prompt. This is a list of =llm-tool= structs, which is a tool that is an elisp function, with a name, a description, and a list of arguments. The docstrings give an explanation of the format. An example is:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (llm-chat-async my-llm-provider (llm-make-chat-prompt &#34;What is the capital of France?&#34; :tools (list (llm-make-tool :function (lambda (callback result) ;; In this example function the assumption is that the ;; callback will be called after processing the result is ;; complete. (notify-user-of-capital result callback)) :name &#34;capital_of_country&#34; :description &#34;Get the capital of a country.&#34; :args &#39;((:name &#34;country&#34; :description &#34;The country whose capital to look up.&#34; :type string)) :async t))) #&#39;identity ;; No need to process the result in this example. (lambda (_ err) (error &#34;Error on getting capital: %s&#34; err))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Note that tools have the same arguments and structure as the tool definitions in [[https://github.com/karthink/gptel][GTPel]].&lt;/p&gt; &#xA;&lt;p&gt;The various chat APIs will execute the functions defined in =tools= slot with the arguments supplied by the LLM. The chat functions will, Instead of returning (or passing to a callback) a string, instead a list will be returned of tool names and return values. This is not technically an alist because the same tool might be used several times, so the =car= can be equivalent.&lt;/p&gt; &#xA;&lt;p&gt;After the tool is called, the client could use the result, but if you want to proceed with the conversation, or get a textual response that accompany the function you should just send the prompt back with no modifications. This is because the LLM gives the tool use to perform, and then expects to get back the results of that tool use. The results were already executed at the end of the call which returned the tools used, which also stores the result of that execution in the prompt. This is why it should be sent back without further modifications.&lt;/p&gt; &#xA;&lt;p&gt;Be aware that there is no gaurantee that the tool will be called correctly. While the LLMs mostly get this right, they are trained on Javascript functions, so imitating Javascript names is recommended. So, &#34;write_email&#34; is a better name for a function than &#34;write-email&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Examples can be found in =llm-tester=. There is also a function call to generate function calls from existing elisp functions in =utilities/elisp-to-tool.el=. ** Media input &lt;em&gt;Note: media input functionality is currently alpha quality. If you want to use it, please watch the =llm= [[https://github.com/ahyatt/llm/discussions][discussions]] for any announcements about changes.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Media can be used in =llm-chat= and related functions. To use media, you can use =llm-multipart= in =llm-make-chat-prompt=, and pass it an Emacs image or an =llm-media= object for other kinds of media. Besides images, some models support video and audio. Not all providers or models support these, with images being the most frequently supported media type, and video and audio more rare. ** Advanced prompt creation The =llm-prompt= module provides helper functions to create prompts that can incorporate data from your application. In particular, this should be very useful for application that need a lot of context.&lt;/p&gt; &#xA;&lt;p&gt;A prompt defined with =llm-prompt= is a template, with placeholders that the module will fill in. Here&#39;s an example of a prompt definition, from the [[https://github.com/ahyatt/ekg][ekg]] package:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (llm-defprompt ekg-llm-fill-prompt &#34;The user has written a note, and would like you to append to it, to make it more useful. This is important: only output your additions, and do not repeat anything in the user&#39;s note. Write as a third party adding information to a note, so do not use the first person.&lt;/p&gt; &#xA;&lt;p&gt;First, I&#39;ll give you information about the note, then similar other notes that user has written, in JSON. Finally, I&#39;ll give you instructions. The user&#39;s note will be your input, all the rest, including this, is just context for it. The notes given are to be used as background material, which can be referenced in your answer.&lt;/p&gt; &#xA;&lt;p&gt;The user&#39;s note uses tags: {{tags}}. The notes with the same tags, listed here in reverse date order: {{tag-notes:10}}&lt;/p&gt; &#xA;&lt;p&gt;These are similar notes in general, which may have duplicates from the ones above: {{similar-notes:1}}&lt;/p&gt; &#xA;&lt;p&gt;This ends the section on useful notes as a background for the note in question.&lt;/p&gt; &#xA;&lt;p&gt;Your instructions on what content to add to the note:&lt;/p&gt; &#xA;&lt;p&gt;{{instructions}} &#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;When this is filled, it is done in the context of a provider, which has a known context size (via &lt;del&gt;llm-chat-token-limit&lt;/del&gt;). Care is taken to not overfill the context, which is checked as it is filled via &lt;del&gt;llm-count-tokens&lt;/del&gt;. We usually want to not fill the whole context, but instead leave room for the chat and subsequent terms. The variable &lt;del&gt;llm-prompt-default-max-pct&lt;/del&gt; controls how much of the context window we want to fill. The way we estimate the number of tokens used is quick but inaccurate, so limiting to less than the maximum context size is useful for guarding against a miscount leading to an error calling the LLM due to too many tokens. If you want to have a hard limit as well that doesn&#39;t depend on the context window size, you can use &lt;del&gt;llm-prompt-default-max-tokens&lt;/del&gt;. We will use the minimum of either value.&lt;/p&gt; &#xA;&lt;p&gt;Variables are enclosed in double curly braces, like this: ={{instructions}}=. They can just be the variable, or they can also denote a number of tickets, like so: ={{tag-notes:10}}=. Tickets should be thought of like lottery tickets, where the prize is a single round of context filling for the variable. So the variable =tag-notes= gets 10 tickets for a drawing. Anything else where tickets are unspecified (unless it is just a single variable, which will be explained below) will get a number of tickets equal to the total number of specified tickets. So if you have two variables, one with 1 ticket, one with 10 tickets, one will be filled 10 times more than the other. If you have two variables, one with 1 ticket, one unspecified, the unspecified one will get 1 ticket, so each will have an even change to get filled. If no variable has tickets specified, each will get an equal chance. If you have one variable, it could have any number of tickets, but the result would be the same, since it would win every round. This algorithm is the contribution of David Petrou.&lt;/p&gt; &#xA;&lt;p&gt;The above is true of variables that are to be filled with a sequence of possible values. A lot of LLM context filling is like this. In the above example, ={{similar-notes}}= is a retrieval based on a similarity score. It will continue to fill items from most similar to least similar, which is going to return almost everything the ekg app stores. We want to retrieve only as needed. Because of this, the =llm-prompt= module takes in /generators/ to supply each variable. However, a plain list is also acceptable, as is a single value. Any single value will not enter into the ticket system, but rather be prefilled before any tickets are used.&lt;/p&gt; &#xA;&lt;p&gt;Values supplied in either the list or generators can be the values themselves, or conses. If a cons, the variable to fill is the =car= of the cons, and the =cdr= is the place to fill the new value, =front= or =back=. The =front= is the default: new values will be appended to the end. =back= will add new values to the start of the filled text for the variable instead.&lt;/p&gt; &#xA;&lt;p&gt;So, to illustrate with this example, here&#39;s how the prompt will be filled:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;First, the ={{tags}}= and ={{instructions}}= will be filled first. This will happen regardless before we check the context size, so the module assumes that these will be small and not blow up the context.&lt;/li&gt; &#xA; &lt;li&gt;Check the context size we want to use (&lt;del&gt;llm-prompt-default-max-pct&lt;/del&gt; multiplied by &lt;del&gt;llm-chat-token-limit&lt;/del&gt;) and exit if exceeded.&lt;/li&gt; &#xA; &lt;li&gt;Run a lottery with all tickets and choose one of the remaining variables to fill.&lt;/li&gt; &#xA; &lt;li&gt;If the variable won&#39;t make the text too large, fill the variable with one entry retrieved from a supplied generator, otherwise ignore. These are values are not conses, so values will be appended to the end of the generated text for each variable (so a new variable generated for tags will append after other generated tags but before the subsequent &#34;and&#34; in the text.&lt;/li&gt; &#xA; &lt;li&gt;Goto 2&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The prompt can be filled two ways, one using predefined prompt template (&lt;del&gt;llm-defprompt&lt;/del&gt; and &lt;del&gt;llm-prompt-fill&lt;/del&gt;), the other using a prompt template that is passed in (&lt;del&gt;llm-prompt-fill-text&lt;/del&gt;).&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (llm-defprompt my-prompt &#34;My name is {{name}} and I&#39;m here&#39;s to say {{messages}}&#34;)&lt;/p&gt; &#xA;&lt;p&gt;(llm-prompt-fill &#39;my-prompt my-llm-provider :name &#34;Pat&#34; :messages #&#39;my-message-retriever)&lt;/p&gt; &#xA;&lt;p&gt;(iter-defun my-message-retriever () &#34;Return the messages I like to say.&#34; (my-message-reset-messages) (while (my-has-next-message) (iter-yield (my-get-next-message)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can just fill it directly: #+begin_src emacs-lisp (llm-prompt-fill-text &#34;Hi, I&#39;m {{name}} and I&#39;m here to say {{messages}}&#34; :name &#34;John&#34; :messages #&#39;my-message-retriever) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;As you can see in the examples, the variable values are passed in with matching keys.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions If you are interested in creating a provider, please send a pull request, or open a bug. This library is part of GNU ELPA, so any major provider that we include in this module needs to be written by someone with FSF papers. However, you can always write a module and put it on a different package archive, such as MELPA.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>