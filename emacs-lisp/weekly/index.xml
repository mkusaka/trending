<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-04T01:43:13Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>schalkwijk/emacs-config</title>
    <updated>2022-09-04T01:43:13Z</updated>
    <id>tag:github.com,2022-09-04:/schalkwijk/emacs-config</id>
    <link href="https://github.com/schalkwijk/emacs-config" rel="alternate"></link>
    <summary type="html">&lt;p&gt;My humble emacs setup.&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>clojure-emacs/clojure-mode</title>
    <updated>2022-09-04T01:43:13Z</updated>
    <id>tag:github.com,2022-09-04:/clojure-emacs/clojure-mode</id>
    <link href="https://github.com/clojure-emacs/clojure-mode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs support for the Clojure(Script) programming language&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/clojure-emacs/clojure-mode&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/clojure-emacs/clojure-mode.svg?style=svg&#34; alt=&#34;circleci&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/clojure-mode&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/clojure-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/clojure-mode&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/clojure-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.nongnu.org/nongnu/clojure-mode.html&#34;&gt;&lt;img src=&#34;https://elpa.nongnu.org/nongnu/clojure-mode.svg?sanitize=true&#34; alt=&#34;NonGNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.com/invite/nFPpynQPME&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/chat-on%20discord-7289da.svg?sanitize=true&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://www.gnu.org/copyleft/gpl.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?sanitize=true&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Clojure Mode&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt; is an Emacs major mode that provides font-lock (syntax highlighting), indentation, navigation and refactoring support for the &lt;a href=&#34;http://clojure.org&#34;&gt;Clojure(Script) programming language&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;This documentation tracks the &lt;code&gt;master&lt;/code&gt; branch of &lt;code&gt;clojure-mode&lt;/code&gt;. Some of the features and settings discussed here might not be available in older releases (including the current stable release). Please, consult the relevant git tag (e.g. 5.15.1) if you need documentation for a specific &lt;code&gt;clojure-mode&lt;/code&gt; release.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Available on the major &lt;code&gt;package.el&lt;/code&gt; community maintained repos - &lt;a href=&#34;http://stable.melpa.org&#34;&gt;MELPA Stable&lt;/a&gt; and &lt;a href=&#34;http://melpa.org&#34;&gt;MELPA&lt;/a&gt; repos.&lt;/p&gt; &#xA;&lt;p&gt;MELPA Stable is the recommended repo as it has the latest stable version. MELPA has a development snapshot for users who don&#39;t mind (infrequent) breakage but don&#39;t want to run from a git checkout.&lt;/p&gt; &#xA;&lt;p&gt;You can install &lt;code&gt;clojure-mode&lt;/code&gt; using the following command:&lt;/p&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x&lt;/kbd&gt; &lt;code&gt;package-install&lt;/code&gt; &lt;kbd&gt;[RET]&lt;/kbd&gt; &lt;code&gt;clojure-mode&lt;/code&gt; &lt;kbd&gt;[RET]&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;p&gt;or if you&#39;d rather keep it in your dotfiles:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(unless (package-installed-p &#39;clojure-mode)&#xA;  (package-install &#39;clojure-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the installation doesn&#39;t work try refreshing the package list:&lt;/p&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x&lt;/kbd&gt; &lt;code&gt;package-refresh-contents&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Bundled major modes&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;clojure-mode&lt;/code&gt; package actually bundles together several major modes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;clojure-mode&lt;/code&gt; is a major mode for editing Clojure code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clojurescript-mode&lt;/code&gt; is a major mode for editing ClojureScript code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clojurec-mode&lt;/code&gt; is a major mode for editing &lt;code&gt;.cljc&lt;/code&gt; source files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All the major modes derive from &lt;code&gt;clojure-mode&lt;/code&gt; and provide more or less the same functionality. Differences can be found mostly in the font-locking - e.g. ClojureScript has some built-in constructs that are not present in Clojure.&lt;/p&gt; &#xA;&lt;p&gt;The proper major mode is selected automatically based on the extension of the file you&#39;re editing.&lt;/p&gt; &#xA;&lt;p&gt;Having separate major modes gives you the flexibility to attach different hooks to them and to alter their behavior individually (e.g. add extra font-locking just to &lt;code&gt;clojurescript-mode&lt;/code&gt;) .&lt;/p&gt; &#xA;&lt;p&gt;Note that all modes derive from &lt;code&gt;clojure-mode&lt;/code&gt;, so things you add to &lt;code&gt;clojure-mode-hook&lt;/code&gt; and &lt;code&gt;clojure-mode-map&lt;/code&gt; will affect all the derived modes as well.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;In the spirit of Emacs, pretty much everything you can think of in &lt;code&gt;clojure-mode&lt;/code&gt; is configurable.&lt;/p&gt; &#xA;&lt;p&gt;To see a list of available configuration options do &lt;code&gt;M-x customize-group RET clojure&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Indentation options&lt;/h3&gt; &#xA;&lt;p&gt;The default indentation rules in &lt;code&gt;clojure-mode&lt;/code&gt; are derived from the &lt;a href=&#34;https://guide.clojure.style&#34;&gt;community Clojure Style Guide&lt;/a&gt;. Please, refer to the guide for the general Clojure indentation rules.&lt;/p&gt; &#xA;&lt;h4&gt;Indentation of docstrings&lt;/h4&gt; &#xA;&lt;p&gt;By default multi-line docstrings are indented with 2 spaces, as this is a somewhat common standard in the Clojure community. You can however adjust this by modifying &lt;code&gt;clojure-docstring-fill-prefix-width&lt;/code&gt;. Set it to 0 if you don&#39;t want multi-line docstrings to be indented at all (which is pretty common in most lisps).&lt;/p&gt; &#xA;&lt;h4&gt;Indentation of function forms&lt;/h4&gt; &#xA;&lt;p&gt;The indentation of function forms is configured by the variable &lt;code&gt;clojure-indent-style&lt;/code&gt;. It takes three possible values:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;always-align&lt;/code&gt; (the default)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(some-function&#xA; 10&#xA; 1&#xA; 2)&#xA;(some-function 10&#xA;               1&#xA;               2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;always-indent&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(some-function&#xA;  10&#xA;  1&#xA;  2)&#xA;(some-function 10&#xA;  1&#xA;  2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;align-arguments&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(some-function&#xA;  10&#xA;  1&#xA;  2)&#xA;(some-function 10&#xA;               1&#xA;               2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Prior to clojure-mode 5.10, the configuration options for &lt;code&gt;clojure-indent-style&lt;/code&gt; used to be keywords, but now they are symbols. Keywords will still be supported at least until clojure-mode 6.&lt;/p&gt; &#xA;&lt;h4&gt;Indentation of macro forms&lt;/h4&gt; &#xA;&lt;p&gt;The indentation of special forms and macros with bodies is controlled via &lt;code&gt;put-clojure-indent&lt;/code&gt;, &lt;code&gt;define-clojure-indent&lt;/code&gt; and &lt;code&gt;clojure-backtracking-indent&lt;/code&gt;. Nearly all special forms and built-in macros with bodies have special indentation settings in &lt;code&gt;clojure-mode&lt;/code&gt;. You can add/alter the indentation settings in your personal config. Let&#39;s assume you want to indent &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(-&amp;gt;&amp;gt; something&#xA;  ala&#xA;  bala&#xA;  portokala)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can do so by putting the following in your config:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(put-clojure-indent &#39;-&amp;gt; 1)&#xA;(put-clojure-indent &#39;-&amp;gt;&amp;gt; 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means that the body of the &lt;code&gt;-&amp;gt;/-&amp;gt;&amp;gt;&lt;/code&gt; is after the first argument.&lt;/p&gt; &#xA;&lt;p&gt;A more compact way to do the same thing is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(define-clojure-indent&#xA;  (-&amp;gt; 1)&#xA;  (-&amp;gt;&amp;gt; 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To indent something like a definition (&lt;code&gt;defn&lt;/code&gt;) you can do something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(put-clojure-indent &#39;&amp;gt;defn :defn)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify different indentation settings for symbols prefixed with some ns (or ns alias):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(put-clojure-indent &#39;do 0)&#xA;(put-clojure-indent &#39;my-ns/do 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The bodies of certain more complicated macros and special forms (e.g. &lt;code&gt;letfn&lt;/code&gt;, &lt;code&gt;deftype&lt;/code&gt;, &lt;code&gt;extend-protocol&lt;/code&gt;, etc) are indented using a contextual backtracking indentation method, require more sophisticated indent specifications. Here are a few examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(define-clojure-indent&#xA;  (implement &#39;(1 (1)))&#xA;  (letfn     &#39;(1 ((:defn)) nil))&#xA;  (proxy     &#39;(2 nil nil (1)))&#xA;  (reify     &#39;(:defn (1)))&#xA;  (deftype   &#39;(2 nil nil (1)))&#xA;  (defrecord &#39;(2 nil nil (1)))&#xA;  (specify   &#39;(1 (1)))&#xA;  (specify   &#39;(1 (1))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These follow the same rules as the &lt;code&gt;:style/indent&lt;/code&gt; metadata specified by &lt;a href=&#34;https://github.com/clojure-emacs/cider-nrepl&#34;&gt;cider-nrepl&lt;/a&gt;. For instructions on how to write these specifications, see &lt;a href=&#34;https://docs.cider.mx/cider/indent_spec.html&#34;&gt;this document&lt;/a&gt;. The only difference is that you&#39;re allowed to use lists instead of vectors.&lt;/p&gt; &#xA;&lt;p&gt;The indentation of &lt;a href=&#34;https://docs.cider.mx/cider/indent_spec.html#special-arguments&#34;&gt;special arguments&lt;/a&gt; is controlled by &lt;code&gt;clojure-special-arg-indent-factor&lt;/code&gt;, which by default indents special arguments a further &lt;code&gt;lisp-body-indent&lt;/code&gt; when compared to ordinary arguments.&lt;/p&gt; &#xA;&lt;p&gt;An example of the default formatting is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defrecord MyRecord&#xA;    [my-field])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;defrecord&lt;/code&gt; has two special arguments, followed by the form&#39;s body - namely the record&#39;s name and its fields vector.&lt;/p&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;clojure-special-arg-indent-factor&lt;/code&gt; to 1, results in:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defrecord MyRecord&#xA;  [my-field])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Indentation of Comments&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt; differentiates between comments like &lt;code&gt;;&lt;/code&gt;, &lt;code&gt;;;&lt;/code&gt;, etc. By default &lt;code&gt;clojure-mode&lt;/code&gt; treats &lt;code&gt;;&lt;/code&gt; as inline comments and &lt;em&gt;always&lt;/em&gt; indents those. You can change this behaviour like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(add-hook &#39;clojure-mode-hook (lambda () (setq-local comment-column 0)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You might also want to change &lt;code&gt;comment-add&lt;/code&gt; to 0 in that way, so that Emacs comment functions (e.g. &lt;code&gt;comment-region&lt;/code&gt;) would use &lt;code&gt;;&lt;/code&gt; by default instead of &lt;code&gt;;;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Check out &lt;a href=&#34;https://guide.clojure.style/#comments&#34;&gt;this section&lt;/a&gt; of the Clojure style guide to understand better the semantics of the different comment levels and why &lt;code&gt;clojure-mode&lt;/code&gt; treats them differently by default.&lt;/p&gt; &#xA;&lt;h3&gt;Vertical alignment&lt;/h3&gt; &#xA;&lt;p&gt;You can vertically align sexps with &lt;code&gt;C-c SPC&lt;/code&gt;. For instance, typing this combo on the following form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(def my-map&#xA;  {:a-key 1&#xA;   :other-key 2})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Leads to the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(def my-map&#xA;  {:a-key     1&#xA;   :other-key 2})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can also be done automatically (as part of indentation) by turning on &lt;code&gt;clojure-align-forms-automatically&lt;/code&gt;. This way it will happen whenever you select some code and hit &lt;code&gt;TAB&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Font-locking&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt; features static font-locking (syntax highlighting) that you can extend yourself if needed. As typical for Emacs, it&#39;s based on regular expressions. You can find the default font-locking rules in &lt;code&gt;clojure-font-lock-keywords&lt;/code&gt;. Here&#39;s how you can add font-locking for built-in Clojure functions and vars:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(defvar clojure-built-in-vars&#xA;  &#39;(;; clojure.core&#xA;    &#34;accessor&#34; &#34;aclone&#34;&#xA;    &#34;agent&#34; &#34;agent-errors&#34; &#34;aget&#34; &#34;alength&#34; &#34;alias&#34;&#xA;    &#34;all-ns&#34; &#34;alter&#34; &#34;alter-meta!&#34; &#34;alter-var-root&#34; &#34;amap&#34;&#xA;    ;; omitted for brevity&#xA;    ))&#xA;&#xA;(defvar clojure-built-in-dynamic-vars&#xA;  &#39;(;; clojure.test&#xA;    &#34;*initial-report-counters*&#34; &#34;*load-tests*&#34; &#34;*report-counters*&#34;&#xA;    &#34;*stack-trace-depth*&#34; &#34;*test-out*&#34; &#34;*testing-contexts*&#34; &#34;*testing-vars*&#34;&#xA;    ;; clojure.xml&#xA;    &#34;*current*&#34; &#34;*sb*&#34; &#34;*stack*&#34; &#34;*state*&#34;&#xA;    ))&#xA;&#xA;(font-lock-add-keywords &#39;clojure-mode&#xA;                        `((,(concat &#34;(\\(?:\.*/\\)?&#34;&#xA;                                    (regexp-opt clojure-built-in-vars t)&#xA;                                    &#34;\\&amp;gt;&#34;)&#xA;                           1 font-lock-builtin-face)))&#xA;&#xA;(font-lock-add-keywords &#39;clojure-mode&#xA;                        `((,(concat &#34;\\&amp;lt;&#34;&#xA;                                    (regexp-opt clojure-built-in-dynamic-vars t)&#xA;                                    &#34;\\&amp;gt;&#34;)&#xA;                           0 font-lock-builtin-face)))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The package &lt;code&gt;clojure-mode-extra-font-locking&lt;/code&gt; provides such additional font-locking for Clojure built-ins.&lt;/p&gt; &#xA;&lt;p&gt;As you might imagine one problem with this font-locking approach is that because it&#39;s based on regular expressions you&#39;ll get some false positives here and there (there&#39;s no namespace information, and no way for &lt;code&gt;clojure-mode&lt;/code&gt; to know what var a symbol resolves to). That&#39;s why &lt;code&gt;clojure-mode&lt;/code&gt;&#39;s font-locking defaults are conservative and minimalistic.&lt;/p&gt; &#xA;&lt;p&gt;Precise font-locking requires additional data that can obtained from a running REPL (that&#39;s how CIDER&#39;s &lt;a href=&#34;https://docs.cider.mx/cider/config/syntax_highlighting.html&#34;&gt;dynamic font-locking&lt;/a&gt; works) or from static code analysis.&lt;/p&gt; &#xA;&lt;p&gt;When it comes to non built-in definitions, &lt;code&gt;clojure-mode&lt;/code&gt; needs to be manually instructed how to handle the docstrings and highlighting. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(put &#39;&amp;gt;defn &#39;clojure-doc-string-elt 2)&#xA;&#xA;(font-lock-add-keywords &#39;clojure-mode&#xA;                        `((,(concat &#34;(\\(?:&#34; clojure--sym-regexp &#34;/\\)?&#34;&#xA;                                    &#34;\\(&amp;gt;defn\\)\\&amp;gt;&#34;)&#xA;                           1 font-lock-keyword-face)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;clojure-doc-string-elt&lt;/code&gt; attribute is processed by the function &lt;code&gt;clojure-font-lock-syntactic-face-function&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Refactoring support&lt;/h2&gt; &#xA;&lt;p&gt;The available refactorings were originally created and maintained by the &lt;code&gt;clj-refactor.el&lt;/code&gt; team. The ones implemented in Elisp only are gradually migrated to &lt;code&gt;clojure-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Threading macros related features&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-thread&lt;/code&gt;: Thread another form into the surrounding thread. Both &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; variants are supported.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-thread.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-unwind&lt;/code&gt;: Unwind a threaded expression. Supports both &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-unwind.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-thread-first-all&lt;/code&gt;: Introduce the thread first macro (&lt;code&gt;-&amp;gt;&lt;/code&gt;) and rewrite the entire form. With a prefix argument do not thread the last form.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-thread-first-all.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-thread-last-all&lt;/code&gt;: Introduce the thread last macro and rewrite the entire form. With a prefix argument do not thread the last form.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-thread-last-all.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-unwind-all&lt;/code&gt;: Fully unwind a threaded expression removing the threading macro.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-unwind-all.gif&#34;&gt; &#xA;&lt;h3&gt;Cycling things&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-cycle-privacy&lt;/code&gt;: Cycle privacy of &lt;code&gt;def&lt;/code&gt;s or &lt;code&gt;defn&lt;/code&gt;s. Use metadata explicitly with setting &lt;code&gt;clojure-use-metadata-for-privacy&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; for &lt;code&gt;defn&lt;/code&gt;s too.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-cycle-privacy.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-cycle-not&lt;/code&gt;: Add or remove a &lt;code&gt;not&lt;/code&gt; form around the current form.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-cycle-not.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-cycle-when&lt;/code&gt;: Find the closest &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;when-not&lt;/code&gt; up the syntax tree and toggle it.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-cycle-when.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-cycle-if&lt;/code&gt;: Find the closest &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;if-not&lt;/code&gt; up the syntax tree and toggle it. Also transpose the &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;then&lt;/code&gt; branches, keeping the semantics the same as before.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-cycle-if.gif&#34;&gt; &#xA;&lt;h3&gt;Convert collection&lt;/h3&gt; &#xA;&lt;p&gt;Convert any given collection at point to list, quoted list, map, vector or set.&lt;/p&gt; &#xA;&lt;h3&gt;Let expression&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-introduce-let&lt;/code&gt;: Introduce a new &lt;code&gt;let&lt;/code&gt; form. Put the current form into its binding form with a name provided by the user as a bound name. If called with a numeric prefix put the let form Nth level up in the form hierarchy.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-introduce-let.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-move-to-let&lt;/code&gt;: Move the current form to the closest &lt;code&gt;let&lt;/code&gt;&#39;s binding form. Replace all occurrences of the form in the body of the let.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-move-to-let.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-let-forward-slurp-sexp&lt;/code&gt;: Slurp the next form after the &lt;code&gt;let&lt;/code&gt; into the &lt;code&gt;let&lt;/code&gt;. Replace all occurrences of the bound forms in the form added to the &lt;code&gt;let&lt;/code&gt; form. If called with a prefix argument slurp the next n forms.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-let-forward-slurp-sexp.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-let-backward-slurp-sexp&lt;/code&gt;: Slurp the form before the &lt;code&gt;let&lt;/code&gt; into the &lt;code&gt;let&lt;/code&gt;. Replace all occurrences of the bound forms in the form added to the &lt;code&gt;let&lt;/code&gt; form. If called with a prefix argument slurp the previous n forms.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-let-backward-slurp-sexp.gif&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;paredit-convolute-sexp&lt;/code&gt; is advised to replace occurrences of bound forms with their bound names when convolute is used on a let form.&lt;/p&gt; &#xA;&lt;h3&gt;Rename ns alias&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-rename-ns-alias&lt;/code&gt;: Rename an alias inside a namespace declaration, and all of its usages in the buffer&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-rename-ns-alias.gif&#34;&gt; &#xA;&lt;p&gt;If there is an active selected region, only rename usages of aliases within the region, without affecting the namespace declaration.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-rename-ns-alias-region.gif&#34;&gt; &#xA;&lt;h3&gt;Add arity to a function&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-add-arity&lt;/code&gt;: Add a new arity to an existing single-arity or multi-arity function.&lt;/p&gt; &#xA;&lt;img width=&#34;512&#34; src=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/doc/clojure-add-arity.gif&#34;&gt; &#xA;&lt;h2&gt;Related packages&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode/raw/master/clojure-mode-extra-font-locking.el&#34;&gt;clojure-mode-extra-font-locking&lt;/a&gt; provides additional font-locking for built-in methods and macros. The font-locking is pretty imprecise, because it doesn&#39;t take namespaces into account and it won&#39;t font-lock a function at all possible positions in a sexp, but if you don&#39;t mind its imperfections you can easily enable it:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(require &#39;clojure-mode-extra-font-locking)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The code in &lt;code&gt;clojure-mode-font-locking&lt;/code&gt; used to be bundled with &lt;code&gt;clojure-mode&lt;/code&gt; before version 3.0.&lt;/p&gt; &#xA;&lt;p&gt;You can also use the code in this package as a basis for extending the font-locking further (e.g. functions/macros from more namespaces). Generally you should avoid adding special font-locking for things that don&#39;t have fairly unique names, as this will result in plenty of incorrect font-locking. CIDER users should avoid this package, as CIDER does its own dynamic font-locking, which is namespace-aware and doesn&#39;t produce almost any false positives.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/clojure-emacs/clj-refactor.el&#34;&gt;clj-refactor&lt;/a&gt; provides refactoring support.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Enabling &lt;code&gt;CamelCase&lt;/code&gt; support for editing commands(like &lt;code&gt;forward-word&lt;/code&gt;, &lt;code&gt;backward-word&lt;/code&gt;, etc) in &lt;code&gt;clojure-mode&lt;/code&gt; is quite useful since we often have to deal with Java class and method names. The built-in Emacs minor mode &lt;code&gt;subword-mode&lt;/code&gt; provides such functionality:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-hook &#39;clojure-mode-hook #&#39;subword-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The use of &lt;a href=&#34;http://mumble.net/~campbell/emacs/paredit.html&#34;&gt;paredit&lt;/a&gt; when editing Clojure (or any other Lisp) code is highly recommended. It helps ensure the structure of your forms is not compromised and offers a number of operations that work on code structure at a higher level than just characters and words. To enable it for Clojure buffers:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-hook &#39;clojure-mode-hook #&#39;paredit-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Fuco1/smartparens&#34;&gt;smartparens&lt;/a&gt; is an excellent (newer) alternative to paredit. Many Clojure hackers have adopted it recently and you might want to give it a try as well. To enable &lt;code&gt;smartparens&lt;/code&gt; use the following code:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-hook &#39;clojure-mode-hook #&#39;smartparens-strict-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Fanael/rainbow-delimiters&#34;&gt;RainbowDelimiters&lt;/a&gt; is a minor mode which highlights parentheses, brackets, and braces according to their depth. Each successive level is highlighted in a different color. This makes it easy to spot matching delimiters, orient yourself in the code, and tell which statements are at a given depth. Assuming you&#39;ve already installed &lt;code&gt;RainbowDelimiters&lt;/code&gt; you can enable it like this:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-hook &#39;clojure-mode-hook #&#39;rainbow-delimiters-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Malabarba/aggressive-indent-mode&#34;&gt;aggressive-indent-mode&lt;/a&gt; automatically adjust the indentation of your code, while you&#39;re writing it. Using it together with &lt;code&gt;clojure-mode&lt;/code&gt; is highly recommended. Provided you&#39;ve already installed &lt;code&gt;aggressive-indent-mode&lt;/code&gt; you can enable it like this:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-hook &#39;clojure-mode-hook #&#39;aggressive-indent-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;REPL Interaction&lt;/h2&gt; &#xA;&lt;p&gt;One of the fundamental aspects of Lisps in general, and Clojure in particular, is the notion of interactive programming - building your programs by continuously changing the state of the running Lisp program (as opposed to doing something more traditional like making a change and re-running the program afterwards to see the changes in action). To get the most of clojure-mode you&#39;ll have to combine it with some tool which will allow you to interact with your Clojure program (a.k.a. process/REPL).&lt;/p&gt; &#xA;&lt;p&gt;A number of options exist for connecting to a running Clojure process and evaluating code interactively.&lt;/p&gt; &#xA;&lt;h3&gt;Basic REPL&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/clojure-emacs/inf-clojure&#34;&gt;inf-clojure&lt;/a&gt; provides basic interaction with a Clojure REPL process. It&#39;s very similar in nature and supported functionality to &lt;code&gt;inferior-lisp-mode&lt;/code&gt; for Common Lisp.&lt;/p&gt; &#xA;&lt;h3&gt;CIDER&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;CIDER&lt;/a&gt; is a powerful Clojure interactive development environment, similar to SLIME for Common Lisp.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re into Clojure and Emacs you should definitely check it out.&lt;/p&gt; &#xA;&lt;h2&gt;Tutorials&lt;/h2&gt; &#xA;&lt;p&gt;Tutorials, targeting Emacs beginners, are available at &lt;a href=&#34;http://clojure-doc.org/articles/tutorials/emacs/&#34;&gt;clojure-doc.org&lt;/a&gt; and &lt;a href=&#34;http://www.braveclojure.com/basic-emacs/&#34;&gt;Clojure for the Brave and the True&lt;/a&gt;. Keep in mind, however, that they might be out-of-date.&lt;/p&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt; is a capable tool, but it&#39;s certainly not perfect. This section lists a couple of general design problems/limitations that might affect your experience negatively.&lt;/p&gt; &#xA;&lt;h3&gt;General Issues&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt; derives a lot of functionality directly from &lt;code&gt;lisp-mode&lt;/code&gt; (an Emacs major mode for Common Lisp), which simplified the initial implementation, but also made it harder to implement certain functionality. Down the road it&#39;d be nice to fully decouple &lt;code&gt;clojure-mode&lt;/code&gt; from &lt;code&gt;lisp-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode/issues/270&#34;&gt;this ticket&lt;/a&gt; for a bit more details.&lt;/p&gt; &#xA;&lt;h3&gt;Indentation Performance&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;clojure-mode&lt;/code&gt;&#39;s indentation engine is a bit slow. You can speed things up significantly by disabling &lt;code&gt;clojure-use-backtracking-indent&lt;/code&gt;, but this will break the indentation of complex forms like &lt;code&gt;deftype&lt;/code&gt;, &lt;code&gt;defprotocol&lt;/code&gt;, &lt;code&gt;reify&lt;/code&gt;, &lt;code&gt;letfn&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;We should look into ways to optimize the performance of the backtracking indentation logic. See &lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode/issues/606&#34;&gt;this ticket&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Font-locking Implementation&lt;/h3&gt; &#xA;&lt;p&gt;As mentioned &lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode#font-locking&#34;&gt;above&lt;/a&gt;, the font-locking is implemented in terms of regular expressions which makes it both slow and inaccurate.&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;An extensive changelog is available &lt;a href=&#34;https://raw.githubusercontent.com/clojure-emacs/clojure-mode/master/CHANGELOG.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright Â© 2007-2022 Jeffrey Chu, Lennart Staflin, Phil Hagelberg, Bozhidar Batsov, Artur Malabarba, Magnar Sveen and &lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode/contributors&#34;&gt;contributors&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Distributed under the GNU General Public License; type &lt;kbd&gt;C-h C-c&lt;/kbd&gt; to view it.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>fxbois/web-mode</title>
    <updated>2022-09-04T01:43:13Z</updated>
    <id>tag:github.com,2022-09-04:/fxbois/web-mode</id>
    <link href="https://github.com/fxbois/web-mode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;web template editing mode for emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;web-mode.el&lt;/h1&gt; &#xA;&lt;p&gt;web-mode.el is an emacs major mode for editing &lt;strong&gt;web templates&lt;/strong&gt; aka HTML files embedding parts (CSS/JavaScript) and blocks (pre rendered by client/server side engines).&lt;/p&gt; &#xA;&lt;p&gt;web-mode.el is compatible with many template engines: PHP, JSP, ASP, Django, Twig, Jinja, Mustache, ERB, FreeMarker, Velocity, Cheetah, Smarty, CTemplate, Mustache, Blade, ErlyDTL, Go Template, Dust.js, Google Closure (soy), React/JSX, Angularjs, ejs, Nunjucks, etc.&lt;/p&gt; &#xA;&lt;p&gt;More infos on &lt;a href=&#34;https://web-mode.org/&#34;&gt;https://web-mode.org/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://web-mode.org/web-mode.png?v=5&#34; alt=&#34;ScreenShot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.paypal.me/fxbois&#34;&gt;&lt;img src=&#34;https://web-mode.org/images/PayPal.svg?sanitize=true&#34; alt=&#34;paypal.me&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://melpa.org/#/web-mode&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/web-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://stable.melpa.org/#/web-mode&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/web-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>