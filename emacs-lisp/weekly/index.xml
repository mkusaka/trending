<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-23T01:53:55Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>volrath/treepy.el</title>
    <updated>2023-07-23T01:53:55Z</updated>
    <id>tag:github.com,2023-07-23:/volrath/treepy.el</id>
    <link href="https://github.com/volrath/treepy.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Generic tree traversing tools for Emacs Lisp&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/treepy.png&#34; align=&#34;right&#34;&gt; &#xA;&lt;h1&gt;treepy.el (&lt;em&gt;ˈtriːpi&lt;/em&gt;)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://melpa.org/#/treepy&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/treepy-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Emacs-25-8e44bd.svg?sanitize=true&#34; alt=&#34;Emacs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/volrath/treepy.el&#34;&gt;&lt;img src=&#34;https://travis-ci.org/volrath/treepy.el.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A set of generic functions for traversing tree-like data structures recursively and/or iteratively, ported from &lt;a href=&#34;https://clojure.github.io/clojure/clojure.walk-api.html&#34;&gt;&lt;code&gt;clojure.walk&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://clojure.github.io/clojure/clojure.zip-api.html&#34;&gt;&lt;code&gt;clojure.zip&lt;/code&gt;&lt;/a&gt; respectively.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#available-functions&#34;&gt;Available Functions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#walker&#34;&gt;Walker&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#zipper&#34;&gt;Zipper&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#main-differences-with-clojure-libraries&#34;&gt;Main differences with Clojure libraries&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#clojure.walk&#34;&gt;clojure.walk&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#clojure.zip&#34;&gt;clojure.zip&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#prior-art&#34;&gt;Prior Art&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;treepy&lt;/em&gt; supports &lt;code&gt;Emacs 25.1+&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is available in MELPA, which is the recommended way to install it and keep it up to date.&lt;/p&gt; &#xA;&lt;p&gt;To install it, you may do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x package-install RET treepy RET&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the installation doesn&#39;t work, consider refreshing the package list: &lt;code&gt;M-x package-refresh-contents [RET]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For a manual installation, just place &lt;code&gt;treepy.el&lt;/code&gt; in your &lt;code&gt;load-path&lt;/code&gt; and &lt;code&gt;(require &#39;treepy)&lt;/code&gt;. Then you&#39;ll have all the &lt;code&gt;treepy-*&lt;/code&gt; functions available.&lt;/p&gt; &#xA;&lt;h2&gt;Available functions&lt;/h2&gt; &#xA;&lt;h3&gt;Walker&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-walk&lt;/code&gt; inner outer form&lt;/p&gt; &lt;p&gt;Traverses FORM, an arbitrary data structure. INNER and OUTER are functions. Applies INNER to each element of FORM, building up a data structure of the same type, then applies OUTER to the result. Recognizes cons, lists, alists, vectors and hash tables.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-postwalk&lt;/code&gt; f form&lt;/p&gt; &lt;p&gt;Performs a depth-first, post-order traversal of F applied to FORM. Calls F on each sub-form, uses F&#39;s return value in place of the original. Recognizes cons, lists, alists, vectors and hash tables.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-prewalk&lt;/code&gt; f form&lt;/p&gt; &lt;p&gt;Like &lt;code&gt;treepy-postwalk&lt;/code&gt;, Performs function F on FORM but does pre-order traversal.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-prewalk-demo&lt;/code&gt; form&lt;/p&gt; &lt;p&gt;Demonstrates the behavior of &lt;code&gt;treepy-prewalk&lt;/code&gt; for FORM. Returns a list of each form as it is walked.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-postwalk-demo&lt;/code&gt; form&lt;/p&gt; &lt;p&gt;Demonstrates the behavior of &lt;code&gt;treepy-postwalk&lt;/code&gt; for FORM. Returns a list of each form as it is walked.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-postwalk-replace&lt;/code&gt; smap form &amp;amp;optional testfn&lt;/p&gt; &lt;p&gt;Recursively transforms FORM by replacing keys in SMAP with their values. Does replacement at the root of the tree first. The optional TESTFN is passed to &lt;code&gt;map-contains-key&lt;/code&gt; as the testing equality function.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-postwalk-replace&lt;/code&gt; smap form &amp;amp;optional testfn&lt;/p&gt; &lt;p&gt;Recursively transforms FORM by replacing keys in SMAP with their values. Does replacement at the leaves of the tree first. The optional TESTFN is passed to &lt;code&gt;map-contains-key&lt;/code&gt; as the testing equality function.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Zipper&lt;/h3&gt; &#xA;&lt;h4&gt;Construction&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-zipper&lt;/code&gt; branchp children make-node root&lt;/p&gt; &lt;p&gt;Creates a new zipper structure.&lt;/p&gt; &lt;p&gt;BRANCHP is a function that, given a node, returns t if it can have children, even if it currently doesn&#39;t.&lt;/p&gt; &lt;p&gt;CHILDREN is a function that, given a branch node, returns a seq of its children.&lt;/p&gt; &lt;p&gt;MAKE-NODE is a function that, given an existing node and a seq of children, returns a new branch node with the supplied children.&lt;/p&gt; &lt;p&gt;ROOT is the root node.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-list-zip&lt;/code&gt; root&lt;/p&gt; &lt;p&gt;Returns a zipper for nested lists, given a ROOT list.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-vector-zip&lt;/code&gt; root&lt;/p&gt; &lt;p&gt;Returns a zipper for nested vectors, given a ROOT vector.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Context / Path&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-node&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the node at LOC.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-branch-p&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns &lt;code&gt;t&lt;/code&gt; if the node at LOC is a branch. &lt;code&gt;nil&lt;/code&gt; otherwise.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-children&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns a children list of the node at LOC, which must be a branch.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-make-node&lt;/code&gt; loc node children&lt;/p&gt; &lt;p&gt;Returns a new branch node, given an existing LOC, NODE and new CHILDREN. The LOC is only used to supply the constructor.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-path&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns a list of nodes leading to the given LOC.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-lefts&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns a list of the left siblings of this LOC.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-rights&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns a list of the right siblings of this LOC.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Navigation&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-down&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the leftmost child of the node at this LOC, or &lt;code&gt;nil&lt;/code&gt; if no children.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-up&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the parent of the node at this LOC, or &lt;code&gt;nil&lt;/code&gt; if at the top.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-root&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Zips from LOC all the way up and return the root node, reflecting any changes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-right&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the right sibling of the node at this LOC, or &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-rightmost&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the rightmost sibling of the node at this LOC, or self.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-left&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the left sibling of the node at this LOC, or &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-leftmost&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the leftmost sibling of the node at this LOC, or self.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-leftmost-descendant&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the leftmost descendant of the given LOC. (ie, down repeatedly).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Modification&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-insert-left&lt;/code&gt; loc item&lt;/p&gt; &lt;p&gt;Inserts ITEM as the left sibling of this LOC&#39;S node, without moving.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-insert-right&lt;/code&gt; loc item&lt;/p&gt; &lt;p&gt;Inserts ITEM as the right sibling of this LOC&#39;s node, without moving.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-replace&lt;/code&gt; loc node&lt;/p&gt; &lt;p&gt;Replaces the node in this LOC with the given NODE, without moving.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-edit&lt;/code&gt; loc f &amp;amp;rest args&lt;/p&gt; &lt;p&gt;Replaces the node at this LOC with the value of &lt;code&gt;(F node ARGS)&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-insert-child&lt;/code&gt; loc item&lt;/p&gt; &lt;p&gt;Inserts ITEM as the leftmost child of this LOC&#39;s node, without moving.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-append-child&lt;/code&gt; loc item&lt;/p&gt; &lt;p&gt;Inserts ITEM as the rightmost child of this LOC&#39;S node, without moving.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-remove&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Removes the node at LOC. Returns the loc that would have preceded it in a depth-first walk.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Enumeration&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-next&lt;/code&gt; loc &amp;amp;optional order&lt;/p&gt; &lt;p&gt;Moves to the next LOC in the hierarchy, depth-first, using ORDER if given. Possible values for ORDER are &lt;code&gt;:preorder&lt;/code&gt; and &lt;code&gt;:postorder&lt;/code&gt;, defaults to the former. When reaching the end, returns a distinguished loc detectable via &lt;code&gt;treepy-end-p&lt;/code&gt;. If already at the end, stays there.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-next&lt;/code&gt; loc &amp;amp;optional order&lt;/p&gt; &lt;p&gt;Moves to the previous LOC in the hierarchy, depth-first, using ORDER if given. Possible values for ORDER are &lt;code&gt;:preorder&lt;/code&gt; and &lt;code&gt;:postorder&lt;/code&gt;, defaults to the former.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-end-p&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns &lt;code&gt;t&lt;/code&gt; if LOC represents the end of a depth-first walk, &lt;code&gt;nil&lt;/code&gt; otherwise.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Main differences with clojure libraries&lt;/h2&gt; &#xA;&lt;p&gt;Even though one of &lt;em&gt;treepy&#39;s&lt;/em&gt; goals is to provide an API that&#39;s as close as possible to &lt;a href=&#34;https://clojure.github.io/clojure/clojure.walk-api.html&#34;&gt;&lt;code&gt;clojure.walk&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://clojure.github.io/clojure/clojure.zip-api.html&#34;&gt;&lt;code&gt;clojure.zip&lt;/code&gt;&lt;/a&gt;, there are some subtle (and not so subtle) differences derived from elisp/clojure distinct data structures, levels of abstraction, and code conventions.&lt;/p&gt; &#xA;&lt;p&gt;The most notorious difference is the name of the functions. For every function in Clojure world, there&#39;s a &lt;em&gt;treepy&lt;/em&gt; counterpart that&#39;s prefixed with &lt;code&gt;treepy-&lt;/code&gt;. So:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;clojure.walk/walk&lt;/code&gt; -&amp;gt; &lt;code&gt;treepy-walk&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clojure.zip/zipper&lt;/code&gt; -&amp;gt; &lt;code&gt;treepy-zipper&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;... and so on.&lt;/p&gt; &#xA;&lt;h3&gt;clojure.walk&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-walk&lt;/code&gt; (and all its derivatives) works on lists, vectors, alists and hash-tables only.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Instead of printing to stdout, &lt;code&gt;treepy-prewalk-demo&lt;/code&gt; and &lt;code&gt;treepy-postwalk-demo&lt;/code&gt; return a list of the sub forms as they get walked.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;treepy&lt;/em&gt; doesn&#39;t provide implementations for &lt;code&gt;keywordize-keys&lt;/code&gt;, &lt;code&gt;stringify-keys&lt;/code&gt; and &lt;code&gt;macroexpand-all&lt;/code&gt;. There&#39;s already a &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/elisp/Expansion.html&#34;&gt;&lt;code&gt;macroexpand-all&lt;/code&gt; implementation built in&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-prewalk-replace&lt;/code&gt; and &lt;code&gt;treepy-postwalk-replace&lt;/code&gt; are based on the (Emacs 25) built in &lt;a href=&#34;https://github.com/emacs-mirror/emacs/raw/master/lisp/emacs-lisp/map.el#L262&#34;&gt;&lt;code&gt;map-contains-key&lt;/code&gt;&lt;/a&gt; function. Both functions take an optional a &lt;em&gt;testfn&lt;/em&gt; third parameter to be used by &lt;code&gt;map-contains-key&lt;/code&gt;. Defaults to &lt;code&gt;equal&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;clojure.zip&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;In order to follow elisp conventions, &lt;em&gt;treepy&lt;/em&gt; has a couple of other small renamings:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;clojure.zip/branch?&lt;/code&gt; -&amp;gt; &lt;code&gt;treepy-branch-p&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;clojure.zip/end?&lt;/code&gt; -&amp;gt; &lt;code&gt;treepy-end-p&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There&#39;s is no exact equivalent to &lt;code&gt;clojure.zip/seq-zip&lt;/code&gt; in &lt;em&gt;treepy&lt;/em&gt;, a &lt;code&gt;treepy-list-zip&lt;/code&gt; is provided instead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;treepy&lt;/em&gt; provides a way to traverse a tree in postorder while using the enumeration functions &lt;code&gt;treepy-next&lt;/code&gt; and &lt;code&gt;treepy-prev&lt;/code&gt;. This is done by having an extra optional parameter &lt;em&gt;order&lt;/em&gt; that can be passed to both functions:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;(treepy-next loc)  ;; =&amp;gt; next node in preorder, as in clojure.zip/next.&#xA;(treepy-next loc :preorder)  ;; =&amp;gt; also next node in preorder.&#xA;(treepy-next loc :postorder)  ;; =&amp;gt; next node in postorder.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There&#39;s a new function in &lt;em&gt;treepy&lt;/em&gt; to get the leftmost descendant of a node/loc. Unsurprisingly, it&#39;s called &lt;code&gt;treepy-leftmost-descendant&lt;/code&gt;. This function is particularly useful when trying to traverse a tree in post order, since unlike preorder trasversal, the root is NOT the first element you want walk/visit. You might want to call &lt;code&gt;(treepy-leftmost-descendant root)&lt;/code&gt; before starting to walk the nodes with &lt;code&gt;treepy-next&lt;/code&gt; in postorder.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following are some &lt;em&gt;treepy&lt;/em&gt;&#39;s implementation differences that you might not need to bother with if you just wanna use the library.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;treepy&#39;s &lt;em&gt;loc&lt;/em&gt; data structure:&lt;/strong&gt; When you create a Clojure &#34;zipper&#34; with &lt;code&gt;clojure.zip/zipper&lt;/code&gt;, you have to provide three helper functions (&lt;code&gt;branch?&lt;/code&gt;, &lt;code&gt;children&lt;/code&gt;, and &lt;code&gt;make-node&lt;/code&gt;) and a &lt;code&gt;root&lt;/code&gt; form. &lt;code&gt;clojure.zip/zipper&lt;/code&gt; will then return a tuple vector that represents a &#34;&lt;em&gt;loc&lt;/em&gt;action&#34;. The three helper functions are stored as clojure&#39;s &lt;a href=&#34;https://clojure.org/reference/metadata&#34;&gt;metadata&lt;/a&gt; into the returned &lt;em&gt;loc&lt;/em&gt;. Since there&#39;s no equivalent to metadata in Elisp, &lt;em&gt;treepy&lt;/em&gt; directly associates the three helper functions into an alist that&#39;s returned with the rest of the &lt;em&gt;loc&lt;/em&gt; information. The resulting structure of a &lt;em&gt;treepy&lt;/em&gt; &lt;code&gt;loc&lt;/code&gt; is the following:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;((&amp;lt;current node&amp;gt; . &amp;lt;path alist&amp;gt;) . ((:branch-p . #&#39;provided-branch-fn)&#xA;                                    (:children . #&#39;provided-children-fn)&#xA;                                    (:make-node . #&#39;provided-make-node-fn)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;path alist&amp;gt;&lt;/code&gt; is an alist containing the same keys and values as &lt;code&gt;clojure.zip&lt;/code&gt;&#39;s path map. Only difference is that &lt;em&gt;treepy&lt;/em&gt; uses lists instead of vectors to handle the &lt;code&gt;left&lt;/code&gt; siblings and &lt;code&gt;pnodes&lt;/code&gt; parent nodes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Prior Art&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/xiongtx/zipper.el&#34;&gt;xiongtx/zipper.el&lt;/a&gt;: Non-generic, EIEIO, zipper implementation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/danielfm/cl-zipper&#34;&gt;danielfm/cl-zipper&lt;/a&gt;: Common Lisp zipper implementation.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;LICENSE&lt;/h2&gt; &#xA;&lt;p&gt;© 2017 Daniel Barreto&lt;/p&gt; &#xA;&lt;p&gt;Distributed under the terms of the GNU GENERAL PUBLIC LICENSE, version 3.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>syl20bnr/nose.el</title>
    <updated>2023-07-23T01:53:55Z</updated>
    <id>tag:github.com,2023-07-23:/syl20bnr/nose.el</id>
    <link href="https://github.com/syl20bnr/nose.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This gives a bunch of functions that handle running nosetests on a particular buffer or part of a buffer. Fork from https://bitbucket.org/durin42/nosemacs/overview&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;nose.el&lt;/h1&gt; &#xA;&lt;p&gt;This gives a bunch of functions that handle running nosetests on a particular buffer or part of a buffer.&lt;/p&gt; &#xA;&lt;p&gt;This is a fork from the &lt;a href=&#34;https://bitbucket.org/durin42/nosemacs/overview&#34;&gt;bitbucket repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s different ?&lt;/h2&gt; &#xA;&lt;p&gt;This fork:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;brings Windows compatibility.&lt;/li&gt; &#xA; &lt;li&gt;calls python with an inline script to launch nose.&lt;/li&gt; &#xA; &lt;li&gt;can launch test suites (require to install the nose fixes via &lt;code&gt;easy_install nose-fixes&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;is compatible with virtualenv&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;You&#39;ll need to add the directory containing &lt;code&gt;nose.el&lt;/code&gt; to your &lt;code&gt;load-path&lt;/code&gt;, and then&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;nose)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;By default, the root of a project is found by looking for any of the files &lt;code&gt;setup.cfg&lt;/code&gt;, &lt;code&gt;.hg&lt;/code&gt;, &lt;code&gt;.git&lt;/code&gt; and &lt;code&gt;.projectile&lt;/code&gt;. You can add files to check for to the file list:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(add-to-list &#39;nose-project-root-files &#34;something&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or you can change the project root test to detect in some other way whether a directory is the project root:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setq nose-project-root-test (lambda (dirname) (equal dirname &#34;foo&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want dots as output, rather than the verbose output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defvar nose-use-verbose nil) ; default is t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Probably also want some key bindings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(add-hook &#39;python-mode-hook&#xA;          (lambda ()&#xA;            (local-set-key &#34;\C-ca&#34; &#39;nosetests-all)&#xA;            (local-set-key &#34;\C-cm&#34; &#39;nosetests-module)&#xA;            (local-set-key &#34;\C-cs&#34; &#39;nosetests-suite)&#xA;            (local-set-key &#34;\C-c.&#34; &#39;nosetests-one)&#xA;            (local-set-key &#34;\C-cpa&#34; &#39;nosetests-pdb-all)&#xA;            (local-set-key &#34;\C-cpm&#34; &#39;nosetests-pdb-module)&#xA;            (local-set-key &#34;\C-cps&#34; &#39;nosetests-pdb-suite)&#xA;            (local-set-key &#34;\C-cp.&#34; &#39;nosetests-pdb-one)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;p&gt;To be able to launch a test suite, your suite must define a function with the name &lt;code&gt;load_tests&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For instance (typical example to make &lt;code&gt;PyDev&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;nose.el&lt;/code&gt; happy):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import unittest&#xA;&#xA;ALL_TESTS = unittest.TestSuite([my_suites_go_here]) &#xA;&#xA;def load_tests(loader=None, tests=None, pattern=None):&#xA;    return ALL_TESTS&#xA;&#xA;if __name__ == &#39;__main__&#39;:&#xA;    unittest.TextTestRunner(verbosity=2).run(ALL_TESTS)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;To the original authors of nose.el: &lt;code&gt;Jason Pellerin&lt;/code&gt; and &lt;code&gt;Augie Fackler&lt;/code&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>stormogulen/.emacs</title>
    <updated>2023-07-23T01:53:55Z</updated>
    <id>tag:github.com,2023-07-23:/stormogulen/.emacs</id>
    <link href="https://github.com/stormogulen/.emacs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs Configuration&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;Personal Emacs Configuration Using Cask, Pallet and MELPA&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>