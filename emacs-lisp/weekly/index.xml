<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-12T01:39:28Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>meedstrom/org-node</title>
    <updated>2024-05-12T01:39:28Z</updated>
    <id>tag:github.com,2024-05-12:/meedstrom/org-node</id>
    <link href="https://github.com/meedstrom/org-node" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;org-node ** News [2024-05-07]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It was unclear how to ensure that org-id knows about all IDs, so new variable: =org-node-extra-id-dirs=!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** News [2024-05-03]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=org-node-reset= is now async!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** News [2024-05-01]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It turns out that =org-node-reset= took dozens of seconds on some people&#39;s configs. I /think/ it&#39;s fixed now.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** News [2024-04-30]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We no longer depend on a =BACKLINKS= property! It is still a great way to show backlinks, so it remains as an option.&lt;/li&gt; &#xA; &lt;li&gt;Renamed =CACHED_BACKLINKS= to just =BACKLINKS=. One =M-x org-node-backlink-fix-all= will take care of the rename, or you can remove them all with =M-x org-node-backlink-regret=.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Breaking API change&lt;/em&gt; -- nodes are objects now, not plists! The software can&#39;t give you a deprecation notice, because plists fail silently (that&#39;s why the change). See updated examples for =org-node-filter-fn= etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** What&#39;s all this&lt;/p&gt; &#xA;&lt;p&gt;I found org-roam too slow, so I made [[https://github.com/meedstrom/quickroam][quickroam]]. And that idea spun off into this package, a standalone thing. I hope it&#39;s also easier to learn.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;If you were using org-roam&lt;/em&gt;, there is nothing to migrate. You can use both packages. It&#39;s exactly the same on-disk format: &#34;notes&#34; are identified by their org-id.&lt;/p&gt; &lt;p&gt;Thanks to shims, you can even &lt;em&gt;skip syncing the org-roam DB&lt;/em&gt; but still use its features, like the rich backlinks buffer and org-roam-capture!&lt;/p&gt; &lt;p&gt;In pursuit of being &#34;just org-id&#34;, this package has no equivalent setting to =org-roam-directory= -- it just looks up =org-id-locations=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;If you were not using org-roam&lt;/em&gt;, maybe think of it as a limited, focused [[https://github.com/alphapapa/org-ql][org-ql]]. If you were the sort of person to prefer ID-links over file links or any other type of link, you&#39;re in the right place! Now you can truly rely on IDs, and forget about filenames and hierarchies and directory structures -- as long as you&#39;ve assigned an ID to something, you can find it later.&lt;/p&gt; &lt;p&gt;And you can still keep doing hierarchies and structures, where that brings you joy, unlike systems that mandate limitations like &#34;one note per file&#34;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** What&#39;s a &#34;node&#34;?&lt;/p&gt; &#xA;&lt;p&gt;My life can be divided into two periods &#34;&lt;em&gt;before org-roam&lt;/em&gt;&#34; and &#34;&lt;em&gt;after org-roam&lt;/em&gt;&#34;. I crossed a kind of gap once I got a good way to link between my notes. It&#39;s odd to remember when I just relied on browsing hierarchies of subtrees -- what a strange way to do things!&lt;/p&gt; &#xA;&lt;p&gt;At the core, all the &#34;notetaking packages&#34; (orgrr/zk/deft/org-roam/denote/...) try to help you with this: make it easy to link between notes.&lt;/p&gt; &#xA;&lt;p&gt;Right off the bat, that imposes two requirements: a method to search for notes, since you can&#39;t link to something you can&#39;t search for, and a decision about exactly what kinds of things should turn up as search hits.&lt;/p&gt; &#xA;&lt;p&gt;Just searching for Org files is too coarse, and just searching for any subtree anywhere brings in too much clutter.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s what org-roam invented. It turns out that if you limit the search hits to just those files and subtrees you&#39;ve deigned to assign an org-id -- which roughly maps to everything you&#39;ve ever thought it was worth linking to -- it filters out the noise excellently.&lt;/p&gt; &#xA;&lt;p&gt;Once a subtree has an ID you can link to, it&#39;s a &#34;node&#34; because it has joined the wider graph, the network of linked nodes. I wish the English language had more distinct sounds for the words &#34;node&#34; and &#34;note&#34;, but to clarify, I&#39;ll say &#34;ID-node&#34; when the distinction matters.&lt;/p&gt; &#xA;&lt;p&gt;** Feature matrix&lt;/p&gt; &#xA;&lt;p&gt;For your pleasure, here&#39;s a comparison of three similar notetaking systems: all permitting org-id as first-class citizen and not locking you into an &#34;one-note-per-file&#34; concept.&lt;/p&gt; &#xA;&lt;p&gt;| | org-roam | org-node | [[https://github.com/toshism/org-super-links][org-super-links]] | |------------------------------------+-------------+--------------------+----------------------| | Backlinks | yes | yes | yes | | Node search and insert | yes | yes | no (suggests org-ql) | | Node aliases | yes | yes | not applicable | | Rich backlinks buffer | yes | yes (org-roam&#39;s) | no | | Reflinks | yes | yes (as backlinks) | no | | Ref search | yes | yes (as aliases) | no | | Extract subtree to new file | yes | yes | no | | Can configure rich completions | yes | yes | not applicable | | org-roam-capture integration | yes | yes | no | | org-capture integration | no | yes | no | | Backlinks in same window | no | yes | yes | | Avoid scanning :BACKLINKS: drawers | no | yes | yes | | Node exclusion | yes | limited | not applicable | | Support =roam:= links | yes | no | no | | Warn about dead links | no | no | no | |------------------------------------+-------------+--------------------+----------------------| | Some query-able cache | =org-roam-db= | =org-nodes= | no | | Asynchronous caching | no | yes | yes (very async ;) | | Time to re-cache my 2000 files | 2m 48s | 0m 02s | not applicable |&lt;/p&gt; &#xA;&lt;p&gt;This isn&#39;t a totally fair comparison; org-roam has an advantage in the details, see Appendix II. With org-node I&#39;ve made what I would&#39;ve liked to hack on, so it&#39;s more simplistic in many aspects.&lt;/p&gt; &#xA;&lt;p&gt;** Setup&lt;/p&gt; &#xA;&lt;p&gt;Add an init snippet like this (assuming [[https://github.com/radian-software/straight.el][straight.el]]):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (use-package org-node :straight (org-node :type git :host github :repo &#34;meedstrom/org-node&#34;) :hook (org-mode . org-node-cache-mode)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Quick start&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re new to these concepts, fear not. The main things for day-to-day operation are two commands: &#34;find&#34; and &#34;insert-link&#34;.&lt;/p&gt; &#xA;&lt;h1&gt;(OK if you love [[https://github.com/meedstrom/org-node?tab=readme-ov-file#org-capture][org-capture]], you might end up using that a lot too, but you know who you are.)&lt;/h1&gt; &#xA;&lt;p&gt;Pick some good keys and try them out, and you can come back to this README later---or never.&lt;/p&gt; &#xA;&lt;p&gt;The keys I use:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (global-set-key (kbd &#34;&#xA; &lt;f2&gt;&#xA;   f&#34;) #&#39;org-node-find) (global-set-key (kbd &#34;&#xA;  &lt;f2&gt;&#xA;    i&#34;) #&#39;org-node-insert-link) #+end_src&#xA;  &lt;/f2&gt;&#xA; &lt;/f2&gt;&lt;/p&gt; &#xA;&lt;p&gt;(I like F2, but if you don&#39;t, maybe M-s?)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (global-set-key (kbd &#34;M-s f&#34;) #&#39;org-node-find) (global-set-key (kbd &#34;M-s i&#34;) #&#39;org-node-insert-link) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;To browse config options, type =M-x customize-group RET org-node RET=.&lt;/p&gt; &#xA;&lt;p&gt;Final tip for the newbie: there&#39;s no separate command for node creation! You just use the commands above, and type the name of a node that doesn&#39;t exist.&lt;/p&gt; &#xA;&lt;p&gt;*** Use Org-roam at the same time?&lt;/p&gt; &#xA;&lt;p&gt;These user options help you feel at home using both packages side-by-side:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (setq org-node-creation-fn #&#39;org-node-new-by-roam-capture) (setq org-node-slug-fn #&#39;org-node-slugify-like-roam) (setq org-node-creation-hook nil) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Also, either run =M-x org-roam-id-update-id-locations=, or add your =org-roam-directory= to the following variable. It shouldn&#39;t be necessary, but upstream org-id has no real convenient setting for this...&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (setq org-node-extra-id-dirs &#39;(...)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;ve been struggling with slow saving of big files in the past, consider these org-roam settings:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (setq org-roam-db-update-on-save nil) ;; don&#39;t update DB on save, not needed (setq org-roam-link-auto-replace nil) ;; don&#39;t look for &#34;roam:&#34; links on save #+end_src&lt;/p&gt; &#xA;&lt;p&gt;With that done, try out the commands mentioned in [[https://github.com/meedstrom/org-node?tab=readme-ov-file#quick-start][Quick start]]. There&#39;s more under [[https://github.com/meedstrom/org-node?tab=readme-ov-file#toolbox][Toolbox]]. Enjoy!&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m guessing you also want the [[https://github.com/meedstrom/org-node?tab=readme-ov-file#backlink-solution-1-org-roam-buffer][org-roam-buffer]]. See next section.&lt;/p&gt; &#xA;&lt;p&gt;** Backlink solution 1: org-roam-buffer&lt;/p&gt; &#xA;&lt;p&gt;Want to keep using =M-x org-roam-buffer-toggle=?&lt;/p&gt; &#xA;&lt;p&gt;**** &lt;em&gt;Option 1A.&lt;/em&gt; Keep letting org-roam update its own DB.&lt;/p&gt; &#xA;&lt;p&gt;If you didn&#39;t have laggy saves, this is fine. In other words, keep =org-roam-db-update-on-save= at t.&lt;/p&gt; &#xA;&lt;p&gt;**** &lt;em&gt;Option 1B&lt;/em&gt;. Tell org-node to write to the org-roam DB.&lt;/p&gt; &#xA;&lt;p&gt;The following hook keeps the database synced.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (add-hook &#39;org-node-cache-rescan-file-hook #&#39;org-node-feed-file-to-roam-db) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;For a full reset, equivalent to =C-u M-x org-roam-db-sync=, you can type =M-x org-node-feed-roam-db=. It&#39;s still slow, but interestingly, all the slowness comes from EmacSQL or SQLite. If someone figures out how to optimize that, please let me know!&lt;/p&gt; &#xA;&lt;p&gt;**** &lt;em&gt;Option 1C&lt;/em&gt;. Cut out the DB altogether.&lt;/p&gt; &#xA;&lt;p&gt;Do some hax:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (advice-add &#39;org-roam-backlinks-get :override #&#39;org-node--fabricate-roam-backlinks) (advice-add &#39;org-roam-reflinks-get :override #&#39;org-node--fabricate-roam-reflinks) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Backlink solution 2: inside the file I love these solutions because I rarely have the screen space to display a backlink buffer.&lt;/p&gt; &#xA;&lt;p&gt;**** &lt;em&gt;Option 2A&lt;/em&gt;. Let org-node add a =:BACKLINKS:= property to all nodes.&lt;/p&gt; &#xA;&lt;p&gt;For a first-time run, type =M-x org-node-backlink-fix-all=. (Don&#39;t worry, if you change your mind, you can undo with =M-x org-node-backlink-regret=.)&lt;/p&gt; &#xA;&lt;p&gt;Then start using the minor mode =org-node-backlink-mode=, which keeps these properties updated. Init snippet:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (add-hook &#39;org-mode-hook #&#39;org-node-backlink-mode) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;**** &lt;em&gt;Option 2B.&lt;/em&gt; Let [[https://github.com/toshism/org-super-links][org-super-links]] manage a =:BACKLINKS:...:END:= drawer.&lt;/p&gt; &#xA;&lt;p&gt;I /think/ the following should work. Totally untested, let me know!&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (add-hook &#39;org-node-insert-link-hook #&#39;org-node-convert-link-to-super) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Misc *** Org-capture&lt;/p&gt; &#xA;&lt;p&gt;You may have heard that org-roam has its own set of capture templates: the =org-roam-capture-templates=.&lt;/p&gt; &#xA;&lt;p&gt;It can make sense, for people who fully understand the magic of capture templates. I didn&#39;t, so I was not confident using a second-order abstraction over an already leaky abstraction.&lt;/p&gt; &#xA;&lt;p&gt;So can we reproduce the functionality on top of vanilla org-capture? That&#39;d be less scary. The answer is yes!&lt;/p&gt; &#xA;&lt;p&gt;Here are some example capture templates. The secret sauce is =(function org-node-capture-target)=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (setq org-capture-templates &#39;((&#34;n&#34; &#34;ID node&#34;) (&#34;nc&#34; &#34;Capture to ID node (maybe creating it)&#34; plain (function org-node-capture-target) nil :empty-lines-after 1)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    (&#34;nv&#34; &#34;Visit ID node (maybe creating it)&#34;&#xA;     plain (function org-node-capture-target) nil&#xA;     :jump-to-captured t&#xA;     :immediate-finish t)&#xA;&#xA;    ;; Sometimes useful with `org-node-insert-link&#39; to make a stub&#xA;    (&#34;ni&#34; &#34;Instantly create ID node without content &amp;amp; without visiting&#34;&#xA;     plain (function org-node-capture-target) nil&#xA;     :immediate-finish t)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;And if you want the commands =org-node-find= &amp;amp; =org-node-insert-link= to likewise outsource to org-capture when creating new nodes:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (setq org-node-creation-fn #&#39;org-capture) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Managing org-id-locations&lt;/p&gt; &#xA;&lt;p&gt;I find unsatisfactory the config options in org-id (see [[https://github.com/meedstrom/org-node?tab=readme-ov-file#appendix-iii-taking-ownership-of-org-id][Appendix III]]), so org-node has an additional way to feed data to org-id, so we won&#39;t run into &#34;ID not found&#34; situations.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (setq org-node-extra-id-dirs &#39;(&#34;/home/kept/notes&#34; &#34;/home/kept/project1/&#34; &#34;/home/kept/project2/&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Rich completions&lt;/p&gt; &#xA;&lt;p&gt;How to see the headings&#39; full outline paths while searching for nodes:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp ;; Prepend completions with the heading&#39;s outline path (setq org-node-format-candidate-fn (lambda (node title) (if-let ((olp (org-node-get-olp node))) (concat (string-join olp &#34; &amp;gt; &#34;) &#34; &amp;gt; &#34; title) title))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;When tinkering with this expression, test the result by evalling the form and doing a =M-x org-node-reset=.&lt;/p&gt; &#xA;&lt;p&gt;Another variant, that greys out the ancestor headings, and includes the file title (I like this one):&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (setopt org-node-format-candidate-fn (lambda (node title) (if (org-node-get-is-subtree node) (let ((ancestors (cons (org-node-get-file-title-or-basename node) (org-node-get-olp node))) (result nil)) (dolist (anc ancestors) (push (propertize anc &#39;face &#39;shadow) result) (push &#34; &amp;gt; &#34; result)) (push title result) (string-join (nreverse result))) title))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Limitations: excluding notes The =org-node-filter-fn= works well for ignoring TODO items that happen to have an ID, and ignoring org-drill items and that sort of thing, but beyond that, it has limited utility because unlike org-roam, &lt;em&gt;child ID nodes of an excluded node are not excluded!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;So let&#39;s say you have a big archive file, fulla IDs, and you want to exclude all of it. Putting a =:ROAM_EXCLUDE: t= at the top won&#39;t do it. As it stands, what I&#39;d suggest is unfortunately, look at the file name.&lt;/p&gt; &#xA;&lt;p&gt;The point of org-id is to avoid dependence on filenames, but it&#39;s often pragmatic to let up on purism just a bit :-) It works well for me to filter out any file or directory that happens to contain &#34;archive&#34; in the name:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (setq org-node-filter-fn (lambda (node) (not (or (org-node-get-todo node) ;; Ignore headings with todo state (member &#34;drill&#34; (org-node-get-tags node)) (assoc &#34;ROAM_EXCLUDE&#34; (org-node-get-properties node)) (string-search &#34;archive&#34; (org-node-get-file-path node)))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Toolbox&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=org-node-find= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A counterpart to =org-roam-node-find=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=org-node-insert-link= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A counterpart to =org-roam-node-insert=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=org-node-insert-transclusion=&lt;/li&gt; &#xA; &lt;li&gt;=org-node-insert-transclusion-as-subtree=&lt;/li&gt; &#xA; &lt;li&gt;=org-node-extract-subtree= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A bizarro counterpart to =org-roam-extract-subtree=. Export a subtree at point into a file-level node, leave a link in the source, and make the new node the current buffer.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=org-node-nodeify-entry= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;(Trivial) Give an ID to the subtree at point (and run org-node-creation-hook)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=org-node-insert-heading= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;(Trivial) Insert a new heading with an ID (and run org-node-creation-hook)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=org-node-random= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Visit a random node&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=org-node-rewrite-links-ask= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Look for link descriptions that got out of sync with the current node title, then prompt at each link to update it&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=org-node-rename-file-by-title= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Auto-rename the file based on the current =#+title=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=org-node-rename-asset-and-rewrite-links= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Interactively rename an asset such as an image file and try to update all Org links to them. Requires [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]]. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;NOTE: For now, it only looks for links inside the root directory that it prompts you for, and sub and sub-subdirectories and so on -- but won&#39;t find a link in a completely different place. Like if you have stuff under /stuff linking to stuff in /home, those links won&#39;t be updated.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=org-node-backlink-fix-all= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Add =BACKLINKS= property to every node everywhere that should have one&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=org-node-backlink-regret= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;In case you regret using this package -- remove all =BACKLINKS=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Appendix I: Rosetta stone&lt;/p&gt; &#xA;&lt;p&gt;API comparison between org-roam and org-node.&lt;/p&gt; &#xA;&lt;p&gt;| Action | org-roam | org-node | |-----------------------------------------+------------------------------------+-----------------------------------------------------------------------------------------| | Get ID at point | =(org-roam-id-at-point)= | =(org-entry-get nil &#34;ID&#34; t)= | | Get node at point | =(org-roam-node-at-point)= | =(org-node-at-point)= | | Get list of files | =(org-roam-list-files)= | =(org-node-files)= | | Prompt user to pick a node | =(org-roam-node-read)= | =(org-node-read)= | | Get backlink objects | =(org-roam-backlinks-get NODE)= | =(gethash (org-node id NODE) org-node--links-table)= | | Get reflink objects | =(org-roam-reflinks-get NODE)= | =(gethash (org-node id NODE) org-node--reflinks-table)= | | Get title | =(org-roam-node-title NODE)= | =(org-node-get-title NODE)= | | Get title of file where NODE is | =(org-roam-node-file-title NODE)= | =(org-node-get-file-title NODE)= | | Get title /or/ name of file where NODE is | | =(org-node-get-file-title-or-basename NODE)= | | Get ID | =(org-roam-node-id NODE)= | =(org-node-get-id NODE)= | | Get filename | =(org-roam-node-file NODE)= | =(org-node-get-file-path NODE)= | | Get tags | =(org-roam-node-tags NODE)= | =(org-node-get-tags NODE)=, no inherited tags | | Get outline level | =(org-roam-node-level NODE)= | =(org-node-get-level NODE)= | | Get char position | =(org-roam-node-point NODE)= | =(org-node-get-pos NODE)= | | Get properties | =(org-roam-node-properties NODE)= | =(org-node-get-properties NODE)=, no inherited properties | | Get subtree TODO state | =(org-roam-node-todo NODE)= | =(org-node-get-todo NODE)=, only that match global =org-todo-keywords= | | Get subtree SCHEDULED | =(org-roam-node-scheduled NODE)= | =(org-node-get-scheduled NODE)= | | Get subtree DEADLINE | =(org-roam-node-deadline NODE)= | =(org-node-get-deadline NODE)= | | Get outline-path | =(org-roam-node-olp NODE)= | =(org-node-get-olp NODE)= | | Get =ROAM_REFS= | =(org-roam-node-refs NODE)= | =(org-node-get-refs NODE)= | | Get =ROAM_ALIASES= | =(org-roam-node-aliases NODE)= | =(org-node-get-aliases NODE)= | | Get =ROAM_EXCLUDE= | | =(assoc &#34;ROAM_EXCLUDE&#34; (org-node-get-properties NODE))=, doesn&#39;t inherit parent excludes! | | Get whether this is a subtree | =(zerop (org-roam-node-level NODE))= | =(org-node-get-is-subtree NODE)= | | Get subtree heading sans TODO | =(org-roam-node-title NODE)= | =(org-node--visit-get-true-heading NODE)= | | Get subtree priority | =(org-roam-node-priority NODE)= | | | Ensure fresh data | =(org-roam-db-sync)= | =(org-node-cache-ensure)= |&lt;/p&gt; &#xA;&lt;p&gt;** Appendix II: Pros of org-roam&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;It is the most general toolkit. Take a function like =org-roam-id-at-point=. Why does it exist, when you could use =(org-id-get nil nil nil t)=? Well, the org-roam version ignores those ancestor headings that have an ID but have been marked not to count as &#34;Roam nodes&#34;, so it travels further up the tree until it finds one that is indeed &#34;a Roam node&#34;.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This brings good to some users. Complexity is not the enemy. It&#39;s just a bit of a YAML vs TOML situation. Or lsp-mode vs eglot. I prefer to try to be &#34;closer to the metal&#34;, use vanilla =org-capture= instead of =org-roam-capture=, look up vanilla =org-id-locations= instead of =org-roam-directory= etc. Not have so many wrappers.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Take the variable =org-roam-mode-sections=. Under any ordinary Emacs Lisp package, this would just be a list of functions. But in fact, you can add to it a cons cell of a function plus the arguments to pass to it. I like programmability, but this is ... oriented towards people who aren&#39;t programmers, I think.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;It does make the org-roam source code a slower read. You scratch your head and ask &#34;Why is it made that way?&#34; Then you see, and you say &#34;Ah, but /I/ don&#39;t need that!&#34; Well, maybe someone does.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Take the variable =org-roam-node-display-templates=. At least, others may consider this a pro, but for my tastes no. I try to let people customize with little lambdas and provide examples of how they&#39;d get some result or other. This instead has the dream UI where you can just set the variable to a string &#34;${olp} ${tags} ${title}&#34; or some such and be done with it. Problem is it&#39;s a new mini-DSL (domain-specific language), and when you learn it you miss out on an elisp lesson. Convenient for beginners but also /keeps/ them beginners.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;** Appendix III: Taking ownership of org-id&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say most of your Org files sit in a folder =/home/kept/notes/= but some others are outside, scattered here and there, plus you&#39;d like to try not depending on the handy =org-roam-update-org-id-locations=.&lt;/p&gt; &#xA;&lt;p&gt;The challenges with org-id:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The classic way to tell it where to look for IDs is adding the directories to =org-agenda-files=. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Unfortunately with thousands of files, this slows down the agenda something extreme. Not an option.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;An alternative way is to populate =org-id-extra-files= or =org-agenda-text-search-extra-files=. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;See snippet A below, but unfortunately with thousands of files this slows down =M-x customize-group= for org-id or org-agenda something extreme.&lt;/li&gt; &#xA;   &lt;li&gt;Sounds like org-id could use a patch... I&#39;ll email someone about it...eventually&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;To sidestep the small problem with #2, you could trust in org-id to keep itself updated, because it does that every time your Emacs creates or searches for an ID. You regenerate org-id-locations /once/ (or well, once every time you wipe .emacs.d). See snippets B or C.&lt;/li&gt; &#xA; &lt;li&gt;org-id complains about duplicate IDs because it&#39;s also looking in e.g. the versioned backups generated by Logseq &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;So, you need some sort of exclusion ruleset. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;For an elisp-only way, see snippets A or B.&lt;/li&gt; &#xA;     &lt;li&gt;A /natural/ way is to obey =.ignore= or =.gitignore=, if you already keep such files. I&#39;ve found no elisp gitignore parser, but see snippet C for a way to use ripgrep&#39;s builtin parser.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Why org-roam didn&#39;t give you this problem? It has actually been suppressing org-id errors!&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;If your Emacs quits unexpectedly, it can &lt;em&gt;forget many ID locations!&lt;/em&gt; To ensure it remembers, either use a hook like : (add-hook &#39;after-save-hook : (defun my-save-id-soon () : (run-with-idle-timer 10 t #&#39;org-id-locations-save))) or enable =eager-state-preempt-kill-emacs-hook-mode= from [[https://github.com/meedstrom/eager-state][eager-state]].&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Snippet A #+begin_src elisp ;; Populate `org-id-extra-files&#39; (dolist (file (mapcan (lambda (dir) (directory-files-recursively dir &#34;\.org$&#34;)) &#39;(;; Example values &#34;/home/kept/notes/&#34; &#34;/home/kept/project1/&#34; &#34;/home/kept/project2/&#34;))) (or (string-search &#34;/logseq/bak/&#34; file) (string-search &#34;/logseq/version-files/&#34; file) (push file org-id-extra-files)))&lt;/p&gt; &#xA;&lt;p&gt;;; Then either run M-x org-id-update-id-locations or restart Emacs. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Snippet B #+begin_src elisp ;; Populate org-id without setting &lt;code&gt;org-id-extra-files&#39;. Only do it if ;; &lt;/code&gt;org-id-locations&#39; is gone. (when (or (and (not (file-exists-p org-id-locations-file)) (null org-id-locations)) (if (null org-id-locations) (org-id-locations-load) (if (listp org-id-locations) (null org-id-locations) (hash-table-empty-p org-id-locations)))) (org-id-update-id-locations (seq-remove (lambda (file) (or (string-search &#34;/logseq/bak/&#34; file) (string-search &#34;/logseq/version-files/&#34; file))) (mapcan (lambda (dir) (directory-files-recursively dir &#34;\.org$&#34;)) &#39;(;; Example values &#34;/home/kept/roam/&#34; &#34;/home/kept/project1/&#34; &#34;/home/kept/project2/&#34;)))) (org-id-locations-save)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Snippet C #+begin_src elisp ;; Populate org-id without setting &lt;code&gt;org-id-extra-files&#39;. Only do it if ;; &lt;/code&gt;org-id-locations&#39; is gone. (when (or (and (not (file-exists-p org-id-locations-file)) (null org-id-locations)) (if (null org-id-locations) (org-id-locations-load) (if (listp org-id-locations) (null org-id-locations) (hash-table-empty-p org-id-locations)))) (dolist (default-directory &#39;(;; Example values &#34;/home/kept/notes/&#34; &#34;/home/kept/project1/&#34; &#34;/home/kept/project2/&#34;)) ;; Borrow ripgrep&#39;s ability to obey .ignore/.gitignore (org-id-update-id-locations (split-string (shell-command-to-string &#34;rg -ilt org :ID:&#34;) &#34;\n&#34; t)) (org-id-locations-save))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Bonus snippet: full reset&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp ;; FOR TESTING: wipe all records ;; You ONLY need to wipe if it won&#39;t shut up about duplicates! (progn (delete-file org-id-locations-file) (setq org-id-locations nil) (setq org-id--locations-checksum nil) (setq org-agenda-text-search-extra-files nil) (setq org-id-files nil) (setq org-id-extra-files nil)) #+end_src&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacs-straight/let-alist</title>
    <updated>2024-05-12T01:39:28Z</updated>
    <id>tag:github.com,2024-05-12:/emacs-straight/let-alist</id>
    <link href="https://github.com/emacs-straight/let-alist" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mirror of the let-alist package from GNU ELPA, current as of 2024-05-12&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>akermu/emacs-libvterm</title>
    <updated>2024-05-12T01:39:28Z</updated>
    <id>tag:github.com,2024-05-12:/akermu/emacs-libvterm</id>
    <link href="https://github.com/akermu/emacs-libvterm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs libvterm integration&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://melpa.org/#/vterm&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/vterm-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;p&gt;Emacs-libvterm (&lt;em&gt;vterm&lt;/em&gt;) is fully-fledged terminal emulator inside GNU Emacs based on &lt;a href=&#34;https://github.com/neovim/libvterm&#34;&gt;libvterm&lt;/a&gt;, a C library. As a result of using compiled code (instead of elisp), emacs-libvterm is fully capable, fast, and it can seamlessly handle large outputs.&lt;/p&gt; &#xA;&lt;h2&gt;Warning&lt;/h2&gt; &#xA;&lt;p&gt;This package is in active development and, while being stable enough to be used as a daily-driver, it is currently in &lt;strong&gt;alpha&lt;/strong&gt; stage. This means that occasionally the public interface will change (for example names of options or functions). A list of recent breaking changes is in &lt;a href=&#34;https://raw.githubusercontent.com/akermu/emacs-libvterm/master/#breaking-changes&#34;&gt;appendix&lt;/a&gt;. Moreover, emacs-libvterm deals directly with some low-level operations, hence, bugs can lead to segmentation faults and crashes. If that happens, please &lt;a href=&#34;https://github.com/akermu/emacs-libvterm/issues/new&#34;&gt;report the problem&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Given that eshell, shell, and (ansi-)term are Emacs built-in, why should I use vterm?&lt;/h2&gt; &#xA;&lt;p&gt;The short answer is: unparalleled performance and compatibility with standard command-line tools.&lt;/p&gt; &#xA;&lt;p&gt;For the long answer, let us discuss the differences between &lt;code&gt;eshell&lt;/code&gt;, &lt;code&gt;shell&lt;/code&gt;, &lt;code&gt;term&lt;/code&gt; and &lt;code&gt;vterm&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;eshell&lt;/code&gt;: it is a shell completely implemented in Emacs Lisp. It is well-integrated in Emacs and it runs on Windows. It does not support command line tools that require terminal manipulation capabilities (e.g., &lt;code&gt;ncdu&lt;/code&gt;, &lt;code&gt;nmtui&lt;/code&gt;, ...).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;shell&lt;/code&gt;: it interfaces with a standard shell (e.g., &lt;code&gt;bash&lt;/code&gt;). It reads an input from Emacs, sends it to the shell, and reports back the output from the shell. As such, like &lt;code&gt;eshell&lt;/code&gt;, it does not support interactive commands, especially those that directly handle how the output should be displayed (e.g., &lt;code&gt;htop&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;term&lt;/code&gt;: it is a terminal emulator written in elisp. &lt;code&gt;term&lt;/code&gt; runs a shell (similarly to other terminal emulators like Gnome Terminal) and programs can directly manipulate the output using escape codes. Hence, many interactive applications (like the one aforementioned) work with &lt;code&gt;term&lt;/code&gt;. However, &lt;code&gt;term&lt;/code&gt; and &lt;code&gt;ansi-term&lt;/code&gt; do not implement all the escapes codes needed, so some programs do not work properly. Moreover, &lt;code&gt;term&lt;/code&gt; has inferior performance compared to standalone terminals, especially with large bursts of output.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;vterm&lt;/code&gt;: like &lt;code&gt;term&lt;/code&gt; it is a terminal emulator. Unlike &lt;code&gt;term&lt;/code&gt;, the core of &lt;code&gt;vterm&lt;/code&gt; is an external library written in C, &lt;code&gt;libvterm&lt;/code&gt;. For this reason, &lt;code&gt;vterm&lt;/code&gt; outperforms &lt;code&gt;term&lt;/code&gt; and has a nearly universal compatibility with terminal applications.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Vterm is not for you if you are using Windows, or if you cannot set up Emacs with support for modules. Otherwise, you should try vterm, as it provides a superior terminal experience in Emacs.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;vterm&lt;/code&gt; is like using Gnome Terminal inside Emacs: Vterm is fully-featured and fast, but is not as well integrated in Emacs as &lt;code&gt;eshell&lt;/code&gt; (yet), so some of the editing keybinding you are used to using may not work. For example, &lt;code&gt;evil-mode&lt;/code&gt; is currently not supported (though, users can enable VI emulation in their shells). This is because keys are sent directly to the shell. We are constantly working to improve this.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;Before installing emacs-libvterm, you need to make sure you have installed&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;GNU Emacs (&amp;gt;= 25.1) with &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/elisp/Dynamic-Modules.html&#34;&gt;module support&lt;/a&gt;. You can check that, by verifying that &lt;code&gt;module-file-suffix&lt;/code&gt; is not &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;cmake (&amp;gt;= 3.11)&lt;/li&gt; &#xA; &lt;li&gt;libtool-bin (related issues: &lt;a href=&#34;https://github.com/akermu/emacs-libvterm/issues/66&#34;&gt;#66&lt;/a&gt; &lt;a href=&#34;https://github.com/akermu/emacs-libvterm/issues/85#issuecomment-491845136&#34;&gt;#85&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;OPTIONAL: &lt;a href=&#34;https://github.com/Sbozzolo/libvterm-mirror.git&#34;&gt;libvterm&lt;/a&gt; (&amp;gt;= 0.2). This library can be found in the official repositories of most distributions (e.g., Arch, Debian, Fedora, Gentoo, openSUSE, Ubuntu). Typical names are &lt;code&gt;libvterm&lt;/code&gt; (Arch, Fedora, Gentoo, openSUSE), or &lt;code&gt;libvterm-dev&lt;/code&gt; (Debian, Ubuntu). If not available, &lt;code&gt;libvterm&lt;/code&gt; will be downloaded during the compilation process. Some distributions (e.g. Ubuntu &amp;lt; 20.04, Debian &amp;lt; 11) have versions of &lt;code&gt;libvterm&lt;/code&gt; that are too old. If you find compilation errors related to &lt;code&gt;VTERM_COLOR&lt;/code&gt;, you should not use your system libvterm. See &lt;a href=&#34;https://raw.githubusercontent.com/akermu/emacs-libvterm/master/#frequently-asked-questions-and-problems&#34;&gt;FAQ&lt;/a&gt; for more details.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;From MELPA&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;vterm&lt;/code&gt; is available on &lt;a href=&#34;https://melpa.org/&#34;&gt;MELPA&lt;/a&gt;, and it can be installed as a normal package. If the requirements are satisfied (mainly, Emacs was built with support for modules), &lt;code&gt;vterm&lt;/code&gt; will compile the module the first time it is run. This is the recommended way to install &lt;code&gt;vterm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;vterm&lt;/code&gt; can be install from MELPA with &lt;code&gt;use-package&lt;/code&gt; by adding the following lines to your &lt;code&gt;init.el&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package vterm&#xA;    :ensure t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To take full advantage of the capabilities of &lt;code&gt;vterm&lt;/code&gt;, you should configure your shell too. Read about this in the section &lt;a href=&#34;https://raw.githubusercontent.com/akermu/emacs-libvterm/master/#shell-side-configuration&#34;&gt;shell-side configuration&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Manual installation&lt;/h2&gt; &#xA;&lt;p&gt;Clone the repository:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/akermu/emacs-libvterm.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, vterm will try to find if libvterm is installed. If it is not found, emacs-libvterm will download the latest version available of libvterm (from &lt;a href=&#34;https://github.com/neovim/libvterm&#34;&gt;here&lt;/a&gt;), compile it, and use it. If you always want to use the vendored version as opposed to the one on you system, set &lt;code&gt;USE_SYSTEM_LIBVTERM&lt;/code&gt; to &lt;code&gt;no&lt;/code&gt;. To do this, change &lt;code&gt;cmake ..&lt;/code&gt; with &lt;code&gt;cmake -DUSE_SYSTEM_LIBVTERM=no ..&lt;/code&gt; in the following instructions.&lt;/p&gt; &#xA;&lt;p&gt;Build the module with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd emacs-libvterm&#xA;mkdir -p build&#xA;cd build&#xA;cmake ..&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And add this to your &lt;code&gt;init.el&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-to-list &#39;load-path &#34;path/to/emacs-libvterm&#34;)&#xA;(require &#39;vterm)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, with &lt;code&gt;use-package&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package vterm&#xA;  :load-path  &#34;path/to/emacs-libvterm/&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;vterm and Ubuntu&lt;/h2&gt; &#xA;&lt;h3&gt;20.04&lt;/h3&gt; &#xA;&lt;p&gt;Using &lt;code&gt;vterm&lt;/code&gt; on Ubuntu requires additional steps. The latest LTS version (20.04) ships without CMake installed and Emacs27 is not yet available from Ubuntu&#39;s package repository.&lt;/p&gt; &#xA;&lt;p&gt;The basic steps for getting vterm to work on Ubuntu 20.04 are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ensure Emacs27 is installed&lt;/li&gt; &#xA; &lt;li&gt;Install cmake, libtool, and libtool-bin&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are a few options for installing Emacs27 on Ubuntu 20.04:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compile Emacs27 from source&lt;/li&gt; &#xA; &lt;li&gt;Install Emacs27 from Snap&lt;/li&gt; &#xA; &lt;li&gt;Install Emacs27 from Kevin Kelley&#39;s PPA&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In any case, if you have an older Emacs version you will need to purge it before proceeding:&lt;/p&gt; &#xA;&lt;h4&gt;Purge Emacs&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt --purge remove emacs&#xA;sudo apt autoremove&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Installing Emacs27 from Kevin Kelley PPA&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo add-apt-repository ppa:kelleyk/emacs&#xA;sudo apt install emacs27&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;If you get an error about emacs27_common during the install process:&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Errors were encountered while processing:&#xA; /tmp/apt-dpkg-install-RVK8CA/064-emacs27-common_27.1~1.git86d8d76aa3-kk2+20.04_all.deb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt --purge remove emacs-common&#xA;sudo apt --fix-broken install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Installing Emacs27 from Snap&lt;/h4&gt; &#xA;&lt;p&gt;I hesitate to include SNAP here, because I ran into a number of GTK Theme parsing errors, and Fontconfig errors when I tested it, and reverted to installing from Kevin Kelley&#39;s PPA. YMMV&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo snap install emacs --classic&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Install CMake and Libtool&lt;/h4&gt; &#xA;&lt;p&gt;In Ubuntu 20.04 CMake (v3.16.3-1ubuntu1) and Libtool can be installed with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt install cmake&#xA;sudo apt install libtool&#xA;sudo apt install libtool-bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;18.04&lt;/h3&gt; &#xA;&lt;p&gt;Using &lt;code&gt;vterm&lt;/code&gt; on Ubuntu 18.04 requires additional steps. 18.04 ships with a version of CMake that is too old for &lt;code&gt;vterm&lt;/code&gt; and GNU Emacs is not compiled with support for dynamical module loading.&lt;/p&gt; &#xA;&lt;p&gt;It is possible to install GNU Emacs with module support from Kevin Kelley&#39;s PPA. The binary in Ubuntu Emacs Lisp PPA is currently broken and leads to segmentation faults (see &lt;a href=&#34;https://github.com/akermu/emacs-libvterm/issues/185#issuecomment-562237077&#34;&gt;#185&lt;/a&gt;). In case Emacs is already on the system, you need to purge it before proceeding with the following commands.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo add-apt-repository ppa:kelleyk/emacs&#xA;sudo apt update&#xA;sudo apt-get install emacs26&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A way to install a recent version of CMake (&amp;gt;= 3.11) is with linuxbrew.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install cmake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In some cases, &lt;code&gt;/bin/sh&lt;/code&gt; needs to be relinked to &lt;code&gt;/bin/bash&lt;/code&gt; for the compilation to work (see, &lt;a href=&#34;https://github.com/akermu/emacs-libvterm/issues/216#issuecomment-575934593&#34;&gt;#216&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Pull requests to improve support for Ubuntu are welcome (e.g., simplifying the installation).&lt;/p&gt; &#xA;&lt;p&gt;Some releases of Ubuntu (e.g., 18.04) ship with a old version of libvterm that can lead to compilation errors. If you have this problem, see the &lt;a href=&#34;https://raw.githubusercontent.com/akermu/emacs-libvterm/master/#frequently-asked-questions-and-problems&#34;&gt;FAQ&lt;/a&gt; for a solution.&lt;/p&gt; &#xA;&lt;h2&gt;GNU Guix&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;vterm&lt;/code&gt; and its dependencies are available in GNU Guix as &lt;a href=&#34;https://guix.gnu.org/packages/emacs-vterm-0-1.7d7381f/&#34;&gt;emacs-vterm&lt;/a&gt;. The package can be installed with &lt;code&gt;guix package -i emacs-vterm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Shell-side configuration&lt;/h2&gt; &#xA;&lt;p&gt;Some of the most useful features in &lt;code&gt;vterm&lt;/code&gt; (e.g., &lt;a href=&#34;https://raw.githubusercontent.com/akermu/emacs-libvterm/master/#directory-tracking-and-prompt-tracking&#34;&gt;directory-tracking and prompt-tracking&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/akermu/emacs-libvterm/master/#message-passing&#34;&gt;message passing&lt;/a&gt;) require shell-side configurations. The main goal of these additional functions is to enable the shell to send information to &lt;code&gt;vterm&lt;/code&gt; via properly escaped sequences. A function that helps in this task, &lt;code&gt;vterm_printf&lt;/code&gt;, is defined below. This function is widely used throughout this readme.&lt;/p&gt; &#xA;&lt;p&gt;For &lt;code&gt;bash&lt;/code&gt; or &lt;code&gt;zsh&lt;/code&gt;, put this in your &lt;code&gt;.zshrc&lt;/code&gt; or &lt;code&gt;.bashrc&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vterm_printf() {&#xA;    if [ -n &#34;$TMUX&#34; ] &amp;amp;&amp;amp; ([ &#34;${TERM%%-*}&#34; = &#34;tmux&#34; ] || [ &#34;${TERM%%-*}&#34; = &#34;screen&#34; ]); then&#xA;        # Tell tmux to pass the escape sequences through&#xA;        printf &#34;\ePtmux;\e\e]%s\007\e\\&#34; &#34;$1&#34;&#xA;    elif [ &#34;${TERM%%-*}&#34; = &#34;screen&#34; ]; then&#xA;        # GNU screen (screen, screen-256color, screen-256color-bce)&#xA;        printf &#34;\eP\e]%s\007\e\\&#34; &#34;$1&#34;&#xA;    else&#xA;        printf &#34;\e]%s\e\\&#34; &#34;$1&#34;&#xA;    fi&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This works also for &lt;code&gt;dash&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For &lt;code&gt;fish&lt;/code&gt; put this in your &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fish&#34;&gt;function vterm_printf;&#xA;    if begin; [  -n &#34;$TMUX&#34; ]  ; and  string match -q -r &#34;screen|tmux&#34; &#34;$TERM&#34;; end&#xA;        # tell tmux to pass the escape sequences through&#xA;        printf &#34;\ePtmux;\e\e]%s\007\e\\&#34; &#34;$argv&#34;&#xA;    else if string match -q -- &#34;screen*&#34; &#34;$TERM&#34;&#xA;        # GNU screen (screen, screen-256color, screen-256color-bce)&#xA;        printf &#34;\eP\e]%s\007\e\\&#34; &#34;$argv&#34;&#xA;    else&#xA;        printf &#34;\e]%s\e\\&#34; &#34;$argv&#34;&#xA;    end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Debugging and testing&lt;/h1&gt; &#xA;&lt;p&gt;If you have successfully built the module, you can test it by executing the following command in the &lt;code&gt;build&lt;/code&gt; directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Open a terminal in the current window.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-other-window&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Open a terminal in another window.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-copy-mode&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;When you enable &lt;code&gt;vterm-copy-mode&lt;/code&gt;, the terminal buffer behaves like a normal &lt;code&gt;read-only&lt;/code&gt; text buffer: you can search, copy text, etc. The default keybinding to toggle &lt;code&gt;vterm-copy-mode&lt;/code&gt; is &lt;code&gt;C-c C-t&lt;/code&gt;. When a region is selected, it is possible to copy the text and leave &lt;code&gt;vterm-copy-mode&lt;/code&gt; with the enter key.&lt;/p&gt; &#xA;&lt;p&gt;If no region is selected when the enter key is pressed it will copy the current line from start to end. If &lt;code&gt;vterm-copy-exclude-prompt&lt;/code&gt; is true it will skip the prompt and not include it in the copy.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-clear-scrollback&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;vterm-clear-scrollback&lt;/code&gt; does exactly what the name suggests: it clears the current buffer from the data that it is not currently visible. &lt;code&gt;vterm-clear-scrollback&lt;/code&gt; is bound to &lt;code&gt;C-c C-l&lt;/code&gt;. This function is typically used with the &lt;code&gt;clear&lt;/code&gt; function provided by the shell to clear both screen and scrollback. In order to achieve this behavior, you need to add a new shell alias.&lt;/p&gt; &#xA;&lt;p&gt;For &lt;code&gt;zsh&lt;/code&gt;, put this in your &lt;code&gt;.zshrc&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;if [[ &#34;$INSIDE_EMACS&#34; = &#39;vterm&#39; ]]; then&#xA;    alias clear=&#39;vterm_printf &#34;51;Evterm-clear-scrollback&#34;;tput clear&#39;&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;bash&lt;/code&gt;, put this in your &lt;code&gt;.bashrc&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;if [[ &#34;$INSIDE_EMACS&#34; = &#39;vterm&#39; ]]; then&#xA;    function clear() {&#xA;        vterm_printf &#34;51;Evterm-clear-scrollback&#34;;&#xA;        tput clear;&#xA;    }&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;fish&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fish&#34;&gt;if [ &#34;$INSIDE_EMACS&#34; = &#39;vterm&#39; ]&#xA;    function clear&#xA;        vterm_printf &#34;51;Evterm-clear-scrollback&#34;;&#xA;        tput clear;&#xA;    end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These aliases take advantage of the fact that &lt;code&gt;vterm&lt;/code&gt; can execute &lt;code&gt;elisp&lt;/code&gt; commands, as explained below.&lt;/p&gt; &#xA;&lt;p&gt;If it possible to automatically clear the scrollback when the screen is cleared by setting the variable &lt;code&gt;vterm-clear-scrollback-when-clearing&lt;/code&gt;: When &lt;code&gt;vterm-clear-scrollback-when-clearing&lt;/code&gt; is non nil, &lt;code&gt;C-l&lt;/code&gt; clears both the screen and the scrollback. When is nil, &lt;code&gt;C-l&lt;/code&gt; only clears the screen. The opposite behavior can be achieved by using the universal prefix (i.e., calling &lt;code&gt;C-u C-l&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h1&gt;Customization&lt;/h1&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-shell&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Shell to run in a new vterm. It defaults to &lt;code&gt;$SHELL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-environment&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;to add more environment variables there is the custom vterm-environment which has a similar format than the internal Emacs variable process-environment. You can check the documentation with C-h v process-environment for more details.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-term-environment-variable&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Value for the &lt;code&gt;TERM&lt;/code&gt; environment variable. It defaults to &lt;code&gt;xterm-256color&lt;/code&gt;. If &lt;a href=&#34;https://github.com/dieggsy/eterm-256color&#34;&gt;eterm-256color&lt;/a&gt; is installed, setting &lt;code&gt;vterm-term-environment-variable&lt;/code&gt; to &lt;code&gt;eterm-color&lt;/code&gt; improves the rendering of colors in some systems.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-kill-buffer-on-exit&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;If set to &lt;code&gt;t&lt;/code&gt;, buffers are killed when the associated process is terminated (for example, by logging out the shell). Keeping buffers around it is useful if you need to copy or manipulate the content.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-module-cmake-args&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Compilation flags and arguments to be given to CMake when compiling the module. This string is directly passed to CMake, so it uses the same syntax. At the moment, it main use is for compiling vterm using the system libvterm instead of the one downloaded from GitHub. You can find all the arguments and flags available with &lt;code&gt;cmake -LA&lt;/code&gt; in the build directory.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-copy-exclude-prompt&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Controls whether or not to exclude the prompt when copying a line in &lt;code&gt;vterm-copy-mode&lt;/code&gt;. Using the universal prefix before calling &lt;code&gt;vterm-copy-mode-done&lt;/code&gt; will invert the value for that call, allowing you to temporarily override the setting. When a prompt is not found, the whole line is copied.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-use-vterm-prompt-detection-method&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The variable &lt;code&gt;vterm-use-vterm-prompt-detection-method&lt;/code&gt; determines whether to use the vterm prompt tracking, if false it use the regexp in &lt;code&gt;vterm-copy-prompt-regexp&lt;/code&gt; to search for the prompt.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-enable-manipulate-selection-data-by-osc52&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Vterm support copy text to Emacs kill ring and system clipboard by using OSC 52. See &lt;a href=&#34;https://invisible-island.net/xterm/ctlseqs/ctlseqs.html&#34;&gt;https://invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt; for more info about OSC 52. For example: send &#39;blabla&#39; to kill ring: printf &#34;\033]52;c;$(printf &#34;%s&#34; &#34;blabla&#34; | base64)\a&#34;&lt;/p&gt; &#xA;&lt;p&gt;tmux can share its copy buffer to terminals by supporting osc52(like iterm2 xterm), you can enable this feature for tmux by : set -g set-clipboard on #osc 52 copy paste share with iterm set -ga terminal-overrides &#39;,xterm*:XT:Ms=\E]52;%p1%s;%p2%s\007&#39; set -ga terminal-overrides &#39;,screen*:XT:Ms=\E]52;%p1%s;%p2%s\007&#39;&lt;/p&gt; &#xA;&lt;p&gt;The clipboard querying/clearing functionality offered by OSC 52 is not implemented here, And for security reason, this feature is disabled by default.&#34;&lt;/p&gt; &#xA;&lt;p&gt;This feature need the new way of handling strings with a struct &lt;code&gt;VTermStringFragment&lt;/code&gt; in libvterm. You&#39;d better compile emacs-libvterm with &lt;code&gt;cmake -DUSE_SYSTEM_LIBVTERM=no ..&lt;/code&gt;. If you don&#39;t do that, when the content you want to copied is too long, it would be truncated by bug of libvterm.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-buffer-name-string&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;When &lt;code&gt;vterm-buffer-name-string&lt;/code&gt; is not nil, vterm renames automatically its own buffers with &lt;code&gt;vterm-buffer-name-string&lt;/code&gt;. This string can contain the character &lt;code&gt;%s&lt;/code&gt;, which is substituted with the &lt;em&gt;title&lt;/em&gt; (as defined by the shell, see below). A possible value for &lt;code&gt;vterm-buffer-name-string&lt;/code&gt; is &lt;code&gt;vterm %s&lt;/code&gt;, according to which all the vterm buffers will be named &#34;vterm TITLE&#34;.&lt;/p&gt; &#xA;&lt;p&gt;This requires some shell-side configuration to print the title. For example to set the name &#34;HOSTNAME:PWD&#34;, use can you the following:&lt;/p&gt; &#xA;&lt;p&gt;For &lt;code&gt;zsh&lt;/code&gt;,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;autoload -U add-zsh-hook&#xA;add-zsh-hook -Uz chpwd (){ print -Pn &#34;\e]2;%m:%2~\a&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;bash&lt;/code&gt;,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PROMPT_COMMAND=&#34;${PROMPT_COMMAND:+$PROMPT_COMMAND; }&#34;&#39;echo -ne &#34;\033]0;${HOSTNAME}:${PWD}\007&#34;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;fish&lt;/code&gt;,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fish&#34;&gt;function fish_title&#xA;    hostname&#xA;    echo &#34;:&#34;&#xA;    prompt_pwd&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://tldp.org/HOWTO/Xterm-Title-4.html&#34;&gt;zsh and bash&lt;/a&gt; and &lt;a href=&#34;https://fishshell.com/docs/current/#programmable-title&#34;&gt;fish documentations&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-always-compile-module&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Vterm needs &lt;code&gt;vterm-module&lt;/code&gt; to work. This can be compiled externally, or &lt;code&gt;vterm&lt;/code&gt; will ask the user whether to build the module when &lt;code&gt;vterm&lt;/code&gt; is first called. To avoid this question and always compile the module, set &lt;code&gt;vterm-always-compile-module&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;vterm-copy-mode-remove-fake-newlines&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;When not-nil fake newlines are removed on entering copy mode. vterm inserts fake-newlines purely for rendering. When using &lt;code&gt;vterm-copy-mode&lt;/code&gt; these are in conflict with many emacs functions like isearch-forward. if this varialbe is not-nil the fake-newlines are removed on entering copy-mode and re-inserted on leaving copy mode. Also truncate-lines is set to t on entering copy-mode and set to nil on leaving.&lt;/p&gt; &#xA;&lt;h2&gt;Keybindings&lt;/h2&gt; &#xA;&lt;p&gt;If you want a key to be sent to the terminal, bind it to &lt;code&gt;vterm--self-insert&lt;/code&gt;, or remove it from &lt;code&gt;vterm-mode-map&lt;/code&gt;. By default, &lt;code&gt;vterm.el&lt;/code&gt; binds most of the &lt;code&gt;C-&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;M-&amp;lt;char&amp;gt;&lt;/code&gt; keys, &lt;code&gt;&amp;lt;f1&amp;gt;&lt;/code&gt; through &lt;code&gt;&amp;lt;f12&amp;gt;&lt;/code&gt; and some special keys like &lt;code&gt;&amp;lt;backspace&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;return&amp;gt;&lt;/code&gt;. Sending a keyboard interrupt is bound to &lt;code&gt;C-c C-c&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to send a keypress that is already recognized by Emacs, such as &lt;code&gt;C-g&lt;/code&gt;, use the interactive function &lt;code&gt;vterm-send-next-key&lt;/code&gt;. This can be bound to a key in the &lt;code&gt;vterm-mode-map&lt;/code&gt; like &lt;code&gt;C-q&lt;/code&gt;, in which case pressing &lt;code&gt;C-q C-g&lt;/code&gt; will send a &lt;code&gt;C-g&lt;/code&gt; key to the terminal, and so on for other modified keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(define-key vterm-mode-map (kbd &#34;C-q&#34;) #&#39;vterm-send-next-key)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can be useful for controlling an application running in the terminal, such as Emacs or Nano.&lt;/p&gt; &#xA;&lt;h2&gt;Fonts&lt;/h2&gt; &#xA;&lt;p&gt;You can change the font (the &lt;em&gt;face&lt;/em&gt;) used in a vterm with the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-hook &#39;vterm-mode-hook&#xA;          (lambda ()&#xA;            (set (make-local-variable &#39;buffer-face-mode-face) &#39;fixed-pitch)&#xA;                 (buffer-face-mode t)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where instead of &lt;code&gt;&#39;fixed-pitch&lt;/code&gt; you specify the face you want to use. The example reported here can be used to force vterm to use a mono-spaced font (the &lt;code&gt;fixed-pitch&lt;/code&gt; face). This is useful when your default font in Emacs is a proportional font.&lt;/p&gt; &#xA;&lt;p&gt;In addition to that, you can disable some text properties (bold, underline, reverse video) setting the relative option to &lt;code&gt;t&lt;/code&gt; (&lt;code&gt;vterm-disable-bold&lt;/code&gt;, &lt;code&gt;vterm-disable-underline&lt;/code&gt;, or &lt;code&gt;vterm-disable-inverse-video&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;You can use another font for vterm buffer&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-hook &#39;vterm-mode-hook&#xA;          (lambda ()&#xA;               (set (make-local-variable &#39;buffer-face-mode-face) &#39;(:family &#34;IosevkaTerm Nerd Font&#34;))&#xA;               (buffer-face-mode t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Blink cursor&lt;/h2&gt; &#xA;&lt;p&gt;When &lt;code&gt;vterm-ignore-blink-cursor&lt;/code&gt; is &lt;code&gt;t&lt;/code&gt;, vterm will ignore request from application to turn on or off cursor blink.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;nil&lt;/code&gt;, cursor in any window may begin to blink or not blink because &lt;code&gt;blink-cursor-mode&lt;/code&gt; is a global minor mode in Emacs, you can use &lt;code&gt;M-x blink-cursor-mode&lt;/code&gt; to toggle.&lt;/p&gt; &#xA;&lt;h2&gt;Colors&lt;/h2&gt; &#xA;&lt;p&gt;Customize the following faces to your liking. It is possible to specify different colors for foreground and background via the &lt;code&gt;:foreground&lt;/code&gt; and &lt;code&gt;:background&lt;/code&gt; attributes.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;vterm-color-black&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-red&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-green&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-yellow&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-blue&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-magenta&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-cyan&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-white&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-bright-black&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-bright-red&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-bright-green&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-bright-yellow&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-bright-blue&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-bright-magenta&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-bright-cyan&lt;/li&gt; &#xA; &lt;li&gt;vterm-color-bright-white&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Directory tracking and Prompt tracking&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;vterm&lt;/code&gt; supports &lt;em&gt;directory tracking&lt;/em&gt;. If this feature is enabled, the default directory in Emacs and the current working directory in &lt;code&gt;vterm&lt;/code&gt; are synced. As a result, interactive functions that ask for a path or a file (e.g., &lt;code&gt;dired&lt;/code&gt; or &lt;code&gt;find-file&lt;/code&gt;) will do so starting from the current location.&lt;/p&gt; &#xA;&lt;p&gt;And &lt;code&gt;vterm&lt;/code&gt; supports &lt;em&gt;prompt tracking&lt;/em&gt;. If this feature is enabled, Emacs knows where the prompt ends, you needn&#39;t customize &lt;code&gt;term-prompt-regexp&lt;/code&gt; any more. Then you can use &lt;code&gt;vterm-next-prompt&lt;/code&gt; and &lt;code&gt;vterm-previous-prompt&lt;/code&gt; moving to end of next/previous prompt. The default keybinding is &lt;code&gt;C-c C-n&lt;/code&gt; and &lt;code&gt;C-c C-p&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;And &lt;code&gt;vterm-beginning-of-line&lt;/code&gt; would move the point to the first character after the shell prompt on this line. If the point is already there, move to the beginning of the line. The default keybinding is &lt;code&gt;C-a&lt;/code&gt; in &lt;code&gt;vterm-copy-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;And &lt;code&gt;vterm--at-prompt-p&lt;/code&gt; would check whether the cursor is at the point just after the shell prompt.&lt;/p&gt; &#xA;&lt;p&gt;Directory tracking and Prompt tracking requires some configuration, as the shell has to be instructed to share the relevant information with Emacs. The following pieces of code assume that you have the function &lt;code&gt;vterm_printf&lt;/code&gt; as defined in section &lt;a href=&#34;https://raw.githubusercontent.com/akermu/emacs-libvterm/master/#shell-side-configuration&#34;&gt;shell-side configuration&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For &lt;code&gt;zsh&lt;/code&gt;, put this at the end of your &lt;code&gt;.zshrc&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;vterm_prompt_end() {&#xA;    vterm_printf &#34;51;A$(whoami)@$(hostname):$(pwd)&#34;&#xA;}&#xA;setopt PROMPT_SUBST&#xA;PROMPT=$PROMPT&#39;%{$(vterm_prompt_end)%}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;bash&lt;/code&gt;, put this at the end of your &lt;code&gt;.bashrc&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;vterm_prompt_end(){&#xA;    vterm_printf &#34;51;A$(whoami)@$(hostname):$(pwd)&#34;&#xA;}&#xA;PS1=$PS1&#39;\[$(vterm_prompt_end)\]&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;fish&lt;/code&gt;, put this in your &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fish&#34;&gt;function vterm_prompt_end;&#xA;    vterm_printf &#39;51;A&#39;(whoami)&#39;@&#39;(hostname)&#39;:&#39;(pwd)&#xA;end&#xA;functions --copy fish_prompt vterm_old_fish_prompt&#xA;function fish_prompt --description &#39;Write out the prompt; do not replace this. Instead, put this at end of your file.&#39;&#xA;    # Remove the trailing newline from the original prompt. This is done&#xA;    # using the string builtin from fish, but to make sure any escape codes&#xA;    # are correctly interpreted, use %b for printf.&#xA;    printf &#34;%b&#34; (string join &#34;\n&#34; (vterm_old_fish_prompt))&#xA;    vterm_prompt_end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we are using the function &lt;code&gt;vterm_printf&lt;/code&gt; that we have discussed above, so make sure that this function is defined in your configuration file.&lt;/p&gt; &#xA;&lt;p&gt;Directory tracking works on remote servers too. In case the hostname of your remote machine does not match the actual hostname needed to connect to that server, change &lt;code&gt;$(hostname)&lt;/code&gt; with the correct one. For example, if the correct hostname is &lt;code&gt;foo&lt;/code&gt; and the username is &lt;code&gt;bar&lt;/code&gt;, you should have something like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;HOSTNAME=foo&#xA;USER=baz&#xA;vterm_printf &#34;51;A$USER@$HOSTNAME:$(pwd)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Message passing&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;vterm&lt;/code&gt; can read and execute commands. At the moment, a command is passed by providing a specific escape sequence. For example, to evaluate&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(message &#34;Hello!&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;printf &#34;\e]51;Emessage \&#34;Hello\!\&#34;\e\\&#34;&#xA;# or&#xA;vterm_printf &#34;51;Emessage \&#34;Hello\!\&#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The commands that are understood are defined in the setting &lt;code&gt;vterm-eval-cmds&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As &lt;code&gt;split-string-and-unquote&lt;/code&gt; is used the parse the passed string, double quotes and backslashes need to be escaped via backslash. A convenient shell function to automate the substitution is&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;bash&lt;/code&gt; or &lt;code&gt;zsh&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vterm_cmd() {&#xA;    local vterm_elisp&#xA;    vterm_elisp=&#34;&#34;&#xA;    while [ $# -gt 0 ]; do&#xA;        vterm_elisp=&#34;$vterm_elisp&#34;&#34;$(printf &#39;&#34;%s&#34; &#39; &#34;$(printf &#34;%s&#34; &#34;$1&#34; | sed -e &#39;s|\\|\\\\|g&#39; -e &#39;s|&#34;|\\&#34;|g&#39;)&#34;)&#34;&#xA;        shift&#xA;    done&#xA;    vterm_printf &#34;51;E$vterm_elisp&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;fish&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fish&#34;&gt;function vterm_cmd --description &#39;Run an Emacs command among the ones been defined in vterm-eval-cmds.&#39;&#xA;    set -l vterm_elisp ()&#xA;    for arg in $argv&#xA;        set -a vterm_elisp (printf &#39;&#34;%s&#34; &#39; (string replace -a -r &#39;([\\\\&#34;])&#39; &#39;\\\\\\\\$1&#39; $arg))&#xA;    end&#xA;    vterm_printf &#39;51;E&#39;(string join &#39;&#39; $vterm_elisp)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can write shell functions to call the ones defined in &lt;code&gt;vterm-eval-cmds&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find_file() {&#xA;    vterm_cmd find-file &#34;$(realpath &#34;${@:-.}&#34;)&#34;&#xA;}&#xA;&#xA;say() {&#xA;    vterm_cmd message &#34;%s&#34; &#34;$*&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or for &lt;code&gt;fish&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fish&#34;&gt;function find_file&#xA;    set -q argv[1]; or set argv[1] &#34;.&#34;&#xA;    vterm_cmd find-file (realpath &#34;$argv&#34;)&#xA;end&#xA;&#xA;function say&#xA;    vterm_cmd message &#34;%s&#34; &#34;$argv&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This newly defined &lt;code&gt;find_file&lt;/code&gt; function can now be used inside &lt;code&gt;vterm&lt;/code&gt; as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find_file name_of_file_in_local_directory&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you call &lt;code&gt;find_file&lt;/code&gt; without specifying any file (you just execute &lt;code&gt;find_file&lt;/code&gt; in your shell), &lt;code&gt;dired&lt;/code&gt; will open with the current directory.&lt;/p&gt; &#xA;&lt;p&gt;As an example, say you like having files opened below the current window. You could add the command to do it on the lisp side like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(push (list &#34;find-file-below&#34;&#xA;            (lambda (path)&#xA;              (if-let* ((buf (find-file-noselect path))&#xA;                        (window (display-buffer-below-selected buf nil)))&#xA;                  (select-window window)&#xA;                (message &#34;Failed to open file: %s&#34; path))))&#xA;      vterm-eval-cmds)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then add the command in your &lt;code&gt;.bashrc&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;open_file_below() {&#xA;    vterm_cmd find-file-below &#34;$(realpath &#34;${@:-.}&#34;)&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can open any file from inside your shell.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;open_file_below ~/Documents&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Shell-side configuration files&lt;/h2&gt; &#xA;&lt;p&gt;The configurations described in earlier sections are combined in &lt;a href=&#34;https://raw.githubusercontent.com/akermu/emacs-libvterm/master/etc/&#34;&gt;&lt;code&gt;etc/&lt;/code&gt;&lt;/a&gt;. These can be appended to or loaded into your user configuration file. Alternatively, they can be installed system-wide, for example in &lt;code&gt;/etc/bash/bashrc.d/&lt;/code&gt;, &lt;code&gt;/etc/profile.d/&lt;/code&gt; (for &lt;code&gt;zsh&lt;/code&gt;), or &lt;code&gt;/etc/fish/conf.d/&lt;/code&gt; for &lt;code&gt;fish&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When using vterm Emacs sets the environment variable INSIDE_EMACS in the subshell to ‘vterm’. Usually the programs check this variable to determine whether they are running inside Emacs.&lt;/p&gt; &#xA;&lt;p&gt;Vterm also sets an extra variable EMACS_VTERM_PATH to the place where the vterm library is installed. This is very useful because when vterm is installed from melpa the Shell-side configuration files are in the EMACS_VTERM_PATH inside the /etc sub-directory. After a package update, the directory name changes, so, a code like this in your bashrc could be enough to load always the latest version of the file from the right location without coping any file manually.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;if [[ &#34;$INSIDE_EMACS&#34; = &#39;vterm&#39; ]] \&#xA;    &amp;amp;&amp;amp; [[ -n ${EMACS_VTERM_PATH} ]] \&#xA;    &amp;amp;&amp;amp; [[ -f ${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh ]]; then&#xA;&#x9;source ${EMACS_VTERM_PATH}/etc/emacs-vterm-bash.sh&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Frequently Asked Questions and Problems&lt;/h2&gt; &#xA;&lt;h3&gt;How can I increase the size of the scrollback?&lt;/h3&gt; &#xA;&lt;p&gt;By default, the scrollback can contain up to 1000 lines per each vterm buffer. You can increase this up to 100000 by changing the variable &lt;code&gt;vterm-max-scrollback&lt;/code&gt;. If you want to increase it further, you have to edit the file &lt;code&gt;vterm-module.h&lt;/code&gt;, change the variable &lt;code&gt;SB_MAX&lt;/code&gt;, and set the new value for &lt;code&gt;vterm-max-scrollback&lt;/code&gt;. The potential maximum memory consumption of vterm buffers increases with &lt;code&gt;vterm-max-scrollback&lt;/code&gt;, so setting &lt;code&gt;SB_MAX&lt;/code&gt; to extreme values may lead to system instabilities and crashes.&lt;/p&gt; &#xA;&lt;h3&gt;How can I automatically close vterm buffers when the process is terminated?&lt;/h3&gt; &#xA;&lt;p&gt;There is an option for that: set &lt;code&gt;vterm-kill-buffer-on-exit&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;The package does not compile, I have errors related to &lt;code&gt;VTERM_COLOR&lt;/code&gt;.&lt;/h3&gt; &#xA;&lt;p&gt;The version of &lt;code&gt;libvterm&lt;/code&gt; installed on your system is too old. You should let &lt;code&gt;emacs-libvterm&lt;/code&gt; download &lt;code&gt;libvterm&lt;/code&gt; for you. You can either uninstall your libvterm, or instruct Emacs to ignore the system libvterm. If you are compiling from Emacs, you can do this by setting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq vterm-module-cmake-args &#34;-DUSE_SYSTEM_LIBVTERM=no&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and compile again. If you are compiling with CMake, use the flag &lt;code&gt;-DUSE_SYSTEM_LIBVTERM=no&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;&amp;lt;C-backspace&amp;gt;&lt;/code&gt; doesn&#39;t kill previous word.&lt;/h3&gt; &#xA;&lt;p&gt;This can be fixed by rebinding the key to what &lt;code&gt;C-w&lt;/code&gt; does:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(define-key vterm-mode-map (kbd &#34;&amp;lt;C-backspace&amp;gt;&#34;)&#xA;    (lambda () (interactive) (vterm-send-key (kbd &#34;C-w&#34;))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;counsel-yank-pop&lt;/code&gt; doesn&#39;t work.&lt;/h3&gt; &#xA;&lt;p&gt;Add this piece of code to your configuration file to make &lt;code&gt;counsel&lt;/code&gt; use the correct function to yank in vterm buffers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun vterm-counsel-yank-pop-action (orig-fun &amp;amp;rest args)&#xA;  (if (equal major-mode &#39;vterm-mode)&#xA;      (let ((inhibit-read-only t)&#xA;            (yank-undo-function (lambda (_start _end) (vterm-undo))))&#xA;        (cl-letf (((symbol-function &#39;insert-for-yank)&#xA;               (lambda (str) (vterm-send-string str t))))&#xA;            (apply orig-fun args)))&#xA;    (apply orig-fun args)))&#xA;&#xA;(advice-add &#39;counsel-yank-pop-action :around #&#39;vterm-counsel-yank-pop-action)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How can I get the local directory without shell-side configuration?&lt;/h3&gt; &#xA;&lt;p&gt;We recommend that you set up shell-side configuration for reliable directory tracking. If you cannot do it, a possible workaround is the following.&lt;/p&gt; &#xA;&lt;p&gt;On most GNU/Linux systems, you can read current directory from &lt;code&gt;/proc&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun vterm-directory-sync ()&#xA;  &#34;Synchronize current working directory.&#34;&#xA;  (interactive)&#xA;  (when vterm--process&#xA;    (let* ((pid (process-id vterm--process))&#xA;           (dir (file-truename (format &#34;/proc/%d/cwd/&#34; pid))))&#xA;      (setq default-directory dir))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A possible application of this function is in combination with &lt;code&gt;find-file&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(advice-add #&#39;find-file :before #&#39;vterm-directory-sync)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method does not work on remote machines.&lt;/p&gt; &#xA;&lt;h3&gt;How can I get the directory tracking in a more understandable way?&lt;/h3&gt; &#xA;&lt;p&gt;If you looked at the recommended way to set-up directory tracking, you will have noticed that it requires printing obscure code like &lt;code&gt;\e]2;%m:%2~\a&lt;/code&gt; (unless you are using &lt;code&gt;fish&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;There is another way to achieve this behavior. Define a shell function, on a local host you can simply use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vterm_set_directory() {&#xA;    vterm_cmd update-pwd &#34;$PWD/&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On a remote one, use instead&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vterm_set_directory() {&#xA;    vterm_cmd update-pwd &#34;/-:&#34;&#34;$USER&#34;&#34;@&#34;&#34;$HOSTNAME&#34;&#34;:&#34;&#34;$PWD/&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, for &lt;code&gt;zsh&lt;/code&gt;, add this function to the &lt;code&gt;chpwd&lt;/code&gt; hook:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;autoload -U add-zsh-hook&#xA;add-zsh-hook -Uz chpwd (){ vterm_set_directory }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;bash&lt;/code&gt;, append it to the prompt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PROMPT_COMMAND=&#34;${PROMPT_COMMAND:+$PROMPT_COMMAND; }vterm_set_directory&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, add &lt;code&gt;update-pwd&lt;/code&gt; to the list of commands that Emacs is allowed to execute from vterm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-to-list &#39;vterm-eval-cmds &#39;(&#34;update-pwd&#34; (lambda (path) (setq default-directory path))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;When evil-mode is enabled, the cursor moves back in normal state, and this messes directory tracking&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;evil-collection&lt;/code&gt; provides a solution for this problem. If you do not want to use &lt;code&gt;evil-collection&lt;/code&gt;, you can add the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun evil-collection-vterm-escape-stay ()&#xA;&#34;Go back to normal state but don&#39;t move&#xA;cursor backwards. Moving cursor backwards is the default vim behavior but it is&#xA;not appropriate in some cases like terminals.&#34;&#xA;(setq-local evil-move-cursor-back nil))&#xA;&#xA;(add-hook &#39;vterm-mode-hook #&#39;evil-collection-vterm-escape-stay)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Related packages&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jixiuf/vterm-toggle&#34;&gt;vterm-toggle&lt;/a&gt;: Toggles between a vterm and the current buffer&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/suonlight/multi-libvterm&#34;&gt;multi-libvterm&lt;/a&gt;: Multiterm for emacs-libvterm&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Appendix&lt;/h2&gt; &#xA;&lt;h3&gt;Breaking changes&lt;/h3&gt; &#xA;&lt;p&gt;Obsolete variables will be removed in version 0.1.&lt;/p&gt; &#xA;&lt;h4&gt;August 2022&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;vterm-send-C-[a-z]&lt;/code&gt; &lt;code&gt;vterm-send-M-[a-z]&lt;/code&gt; &lt;code&gt;vterm-define-key&lt;/code&gt; &lt;code&gt;vterm-send-{up/down/left/right/prior/next/meta-dot/meta-comma/ctrl-slash}&lt;/code&gt; were obsolete, please use &lt;code&gt;vterm-send&lt;/code&gt; or &lt;code&gt;vterm-send-key&lt;/code&gt; or &lt;code&gt;vterm--self-insert&lt;/code&gt; instead.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;October 2020&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;vterm-disable-bold-font&lt;/code&gt; was renamed to &lt;code&gt;vterm-disable-bold&lt;/code&gt; to uniform it with the other similar options.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;July 2020&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;vterm-use-vterm-prompt&lt;/code&gt; was renamed to &lt;code&gt;vterm-use-vterm-prompt-detection-method&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;vterm-kill-buffer-on-exit&lt;/code&gt; is set to &lt;code&gt;t&lt;/code&gt; by default.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;April 2020&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;vterm-clear-scrollback&lt;/code&gt; was renamed to &lt;code&gt;vterm-clear-scrollback-when-clearning&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;vterm-set-title-functions&lt;/code&gt; was removed. In its place, there is a new custom option &lt;code&gt;vterm-buffer-name-string&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/akermu/emacs-libvterm/master/vterm-buffer-name-string&#34;&gt;vterm-buffer-name-string&lt;/a&gt; for documentation.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>