<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-14T01:54:46Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jart/emacs-copilot</title>
    <updated>2024-01-14T01:54:46Z</updated>
    <id>tag:github.com,2024-01-14:/jart/emacs-copilot</id>
    <link href="https://github.com/jart/emacs-copilot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Large language model code completion for Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Emacs Copilot&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jart/emacs-copilot/assets/49262/1a79d4e4-9622-452e-9944-950c6f21d67f&#34;&gt;https://github.com/jart/emacs-copilot/assets/49262/1a79d4e4-9622-452e-9944-950c6f21d67f&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;copilot-complete&lt;/code&gt; function demonstrates that ~100 lines of LISP is all it takes for Emacs to do that thing Github Copilot and VSCode are famous for doing except superior w.r.t. both quality and freedom&lt;/p&gt; &#xA;&lt;p&gt;Emacs Copilot helps you do pair programming with a local-running LLM that generates code completions within Emacs buffers. The LLM is run as a sub-command that remembers your local editing history on a file by file basis. Tokens stream into your buffer without delay as gen&#39;d and you can hit &lt;code&gt;C-g&lt;/code&gt; to interrupt your LLM at any time. History and memory can also be deleted from the LLM&#39;s context when deleting code from your Emacs buffer that matches up verbatim. Copilot is language agnostic and your programming language is determed by file extension&lt;/p&gt; &#xA;&lt;p&gt;One really good LLM right now is WizardCoder 34b since it scores the same as GPT-4 on HumanEval. You need a computer like a Mac Studio M2 Ultra in order to use it. If you have a mere Macbook Pro, then try the Q3 version. If you have a modest PC then you could consider downloading the WizardCoder-Python-13b llamafile since it&#39;s almost as good, and will even go acceptably fast on CPU-only systems having at least AVX2 and 2200 MT/s RAM. If you&#39;re even more strapped for compute and use things like Raspberry Pi, then give Phi-2 a spin&lt;/p&gt; &#xA;&lt;p&gt;To get started, try writing yourself the first line of a function. For example, you might open up a file in your editor named &lt;code&gt;hello.c&lt;/code&gt; and then type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool is_prime(int x) {&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then place your caret at the end of the line, and press &lt;code&gt;C-c C-k&lt;/code&gt; to hand over control to your LLM, which should generate the rest of the function implementation for you. Things are also tuned so the LLM is likely to stop as soon as a function is made. Explanations and other kind of ELI5 commentary is avoided too.&lt;/p&gt; &#xA;&lt;p&gt;Later on, if you were to write something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main() {&#xA;  for (int i = 0; i &amp;lt; 100;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And ask your LLM to complete that, then your LLM will likely recall that you two wrote an is_prime() function earlier, even though it&#39;s only considering those two lines in the current instruction. You&#39;ll most likely then see it decide to generate code to print the primes&lt;/p&gt; &#xA;&lt;h2&gt;Reference Implementation&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;ve downloaded your LLM (see below) then all you really need is to copy and paste this code into an Emacs buffer and run &lt;code&gt;M-x eval-buffer&lt;/code&gt;. You&#39;ll want to tune the code to your own personal taste. That&#39;s why it&#39;s being presented in full as a succinct code example here.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun copilot-complete ()&#xA;  (interactive)&#xA;  (let* ((spot (point))&#xA;         (inhibit-quit t)&#xA;         (curfile (buffer-file-name))&#xA;         (cash (concat curfile &#34;.cache&#34;))&#xA;         (hist (concat curfile &#34;.prompt&#34;))&#xA;         (lang (file-name-extension curfile))&#xA;&#xA;         ;; extract current line, to left of caret&#xA;         ;; and the previous line, to give the llm&#xA;         (code (save-excursion&#xA;                 (dotimes (i 2)&#xA;                   (when (&amp;gt; (line-number-at-pos) 1)&#xA;                     (previous-line)))&#xA;                 (beginning-of-line)&#xA;                 (buffer-substring-no-properties (point) spot)))&#xA;&#xA;         ;; create new prompt for this interaction&#xA;         (system &#34;\&#xA;You are an Emacs code generator. \&#xA;Writing comments is forbidden. \&#xA;Writing test code is forbidden. \&#xA;Writing English explanations is forbidden. &#34;)&#xA;         (prompt (format&#xA;                  &#34;[INST]%sGenerate %s code to complete:[/INST]\n```%s\n%s&#34;&#xA;                  (if (file-exists-p cash) &#34;&#34; system) lang lang code)))&#xA;&#xA;    ;; iterate text deleted within editor then purge it from prompt&#xA;    (when kill-ring&#xA;      (save-current-buffer&#xA;        (find-file hist)&#xA;        (dotimes (i 10)&#xA;          (let ((substring (current-kill i t)))&#xA;            (when (and substring (string-match-p &#34;\n.*\n&#34; substring))&#xA;              (goto-char (point-min))&#xA;              (while (search-forward substring nil t)&#xA;                (delete-region (- (point) (length substring)) (point))))))&#xA;        (save-buffer 0)&#xA;        (kill-buffer (current-buffer))))&#xA;&#xA;    ;; append prompt for current interaction to the big old prompt&#xA;    (write-region prompt nil hist &#39;append &#39;silent)&#xA;&#xA;    ;; run llamafile streaming stdout into buffer catching ctrl-g&#xA;    (with-local-quit&#xA;      (call-process &#34;wizardcoder-python-34b-v1.0.Q5_K_M.llamafile&#34;&#xA;                    nil (list (current-buffer) nil) t&#xA;                    &#34;--prompt-cache&#34; cash&#xA;                    &#34;--prompt-cache-all&#34;&#xA;                    &#34;--silent-prompt&#34;&#xA;                    &#34;--temp&#34; &#34;0&#34;&#xA;                    &#34;-c&#34; &#34;1024&#34;&#xA;                    &#34;-ngl&#34; &#34;35&#34;&#xA;                    &#34;-r&#34; &#34;```&#34;&#xA;                    &#34;-r&#34; &#34;\n}&#34;&#xA;                    &#34;-f&#34; hist))&#xA;&#xA;    ;; get rid of most markdown syntax&#xA;    (let ((end (point)))&#xA;      (save-excursion&#xA;        (goto-char spot)&#xA;        (while (search-forward &#34;\\_&#34; end t)&#xA;          (backward-char)&#xA;          (delete-backward-char 1 nil)&#xA;          (setq end (- end 1)))&#xA;        (goto-char spot)&#xA;        (while (search-forward &#34;```&#34; end t)&#xA;          (delete-backward-char 3 nil)&#xA;          (setq end (- end 3))))&#xA;&#xA;      ;; append generated code to prompt&#xA;      (write-region spot end hist &#39;append &#39;silent))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Emacs Download Link&lt;/h2&gt; &#xA;&lt;p&gt;If you don&#39;t have Emacs installed, or you use a platform like Windows where it&#39;s normally difficult to obtain, then here&#39;s a single-file build of Emacs that (like llamafile) is directly runnable and needn&#39;t be installed.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cosmo.zip/pub/cosmos/bin/emacs&#34;&gt;https://cosmo.zip/pub/cosmos/bin/emacs&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/jart/emacs-copilot/main/#gotchas&#34;&gt;Gotchas&lt;/a&gt; below if you have trouble running it. See also the &lt;a href=&#34;https://raw.githubusercontent.com/jart/emacs-copilot/main/#supported-oses-and-cpus&#34;&gt;Supported OSes and CPUs&lt;/a&gt; list too.&lt;/p&gt; &#xA;&lt;h2&gt;LLM Download Links&lt;/h2&gt; &#xA;&lt;p&gt;Here are some LLMs that are known to work reasonably well with Emacs Copilot, that are freely available to download online. They&#39;re all good, but the biggest one is the best one. Choose the size that&#39;s appropriate for your hardware.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Model&lt;/th&gt; &#xA;   &lt;th&gt;Size&lt;/th&gt; &#xA;   &lt;th&gt;License&lt;/th&gt; &#xA;   &lt;th&gt;&lt;a href=&#34;https://github.com/mozilla-Ocho/llamafile&#34;&gt;llamafile&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;WizardCoder-Python-34b (Q5)&lt;/td&gt; &#xA;   &lt;td&gt;23.9 GB&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://ai.meta.com/resources/models-and-libraries/llama-downloads/&#34;&gt;LLaMA 2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/jartine/WizardCoder-Python-34B-V1.0-llamafile/resolve/main/wizardcoder-python-34b-v1.0.Q5_K_M.llamafile?download=true&#34;&gt;wizardcoder-python-34b-v1.0.Q5_K_M.llamafile&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;WizardCoder-Python-34b (Q3)&lt;/td&gt; &#xA;   &lt;td&gt;16.3 GB&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://ai.meta.com/resources/models-and-libraries/llama-downloads/&#34;&gt;LLaMA 2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/jartine/WizardCoder-Python-34B-V1.0-llamafile/resolve/main/wizardcoder-python-34b-v1.0.Q3_K_M.llamafile?download=true&#34;&gt;wizardcoder-python-34b-v1.0.Q3_K_M.llamafile&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;WizardCoder-Python-13b&lt;/td&gt; &#xA;   &lt;td&gt;7.33 GB&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://ai.meta.com/resources/models-and-libraries/llama-downloads/&#34;&gt;LLaMA 2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/jartine/wizardcoder-13b-python/resolve/main/wizardcoder-python-13b.llamafile?download=true&#34;&gt;wizardcoder-python-13b.llamafile&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Phi-2&lt;/td&gt; &#xA;   &lt;td&gt;2.09 GB&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/microsoft/phi-2/resolve/main/LICENSE&#34;&gt;microsoft-research-license&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/jartine/phi-2-llamafile/resolve/main/phi-2.Q5_K_M.llamafile?download=true&#34;&gt;phi-2.Q5_K_M.llamafile&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Be sure to &lt;code&gt;chmod +x&lt;/code&gt; your llamafile executable after you download it. Then consider placing it on the system path. If you have any trouble running the llamafile, then see the &lt;a href=&#34;https://raw.githubusercontent.com/jart/emacs-copilot/main/#gotchas&#34;&gt;Gotchas&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;Cache files&lt;/h2&gt; &#xA;&lt;p&gt;If you decide to switch models, then be sure to delete all the &lt;code&gt;FILE.cache&lt;/code&gt; files that got generated on your local filesystem.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find . -name \*.cache | xargs rm -f&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also tune the Emacs LISP code above to just not use prompt caching at all, by removing those flags. That might have a negative impact on code completion latency though. On Apple Metal GPU, which has extremely fast prompt loading, the slowdown might be ~1 second, but for systems that need CPU inference it could be significantly higher.&lt;/p&gt; &#xA;&lt;h2&gt;Gotchas&lt;/h2&gt; &#xA;&lt;p&gt;On macOS with Apple Silicon you need to have Xcode installed for llamafile to be able to bootstrap itself.&lt;/p&gt; &#xA;&lt;p&gt;If you use zsh and have trouble running llamafile, try saying &lt;code&gt;sh -c ./llamafile&lt;/code&gt;. This is due to a bug that was fixed in zsh 5.9+. The same is the case for Python &lt;code&gt;subprocess&lt;/code&gt;, old versions of Fish, etc.&lt;/p&gt; &#xA;&lt;p&gt;On some Linux systems, you might get errors relating to &lt;code&gt;run-detectors&lt;/code&gt; or WINE. This is due to &lt;code&gt;binfmt_misc&lt;/code&gt; registrations. You can fix that by adding an additional registration for the APE file format llamafile uses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo wget -O /usr/bin/ape https://cosmo.zip/pub/cosmos/bin/ape-$(uname -m).elf&#xA;sudo chmod +x /usr/bin/ape&#xA;sudo sh -c &#34;echo &#39;:APE:M::MZqFpD::/usr/bin/ape:&#39; &amp;gt;/proc/sys/fs/binfmt_misc/register&#34;&#xA;sudo sh -c &#34;echo &#39;:APE-jart:M::jartsr::/usr/bin/ape:&#39; &amp;gt;/proc/sys/fs/binfmt_misc/register&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As mentioned above, on Windows you may need to rename your llamafile by adding &lt;code&gt;.exe&lt;/code&gt; to the filename.&lt;/p&gt; &#xA;&lt;p&gt;Also as mentioned above, Windows also has a maximum file size limit of 4GB for executables. The LLaVA server executable above is just 30MB shy of that limit, so it&#39;ll work on Windows, but with larger models like WizardCoder 13B, you need to store the weights in a separate file. An example is provided above; see &#34;Using llamafile with external weights.&#34;&lt;/p&gt; &#xA;&lt;p&gt;On WSL, it&#39;s recommended that the WIN32 interop feature be disabled:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo sh -c &#34;echo -1 &amp;gt; /proc/sys/fs/binfmt_misc/WSLInterop&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On any platform, if your llamafile process is immediately killed, check if you have CrowdStrike and then ask to be whitelisted.&lt;/p&gt; &#xA;&lt;h2&gt;Supported OSes and CPUs&lt;/h2&gt; &#xA;&lt;p&gt;llamafile supports the following operating systems, which require a minimum stock install:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux 2.6.18+ (ARM64 or AMD64) i.e. any distro RHEL5 or newer&lt;/li&gt; &#xA; &lt;li&gt;Darwin (macOS) 23.1.0+ [1] (ARM64 or AMD64, with GPU only supported on ARM64)&lt;/li&gt; &#xA; &lt;li&gt;Windows 8+ (AMD64)&lt;/li&gt; &#xA; &lt;li&gt;FreeBSD 13+ (AMD64, GPU should work in theory)&lt;/li&gt; &#xA; &lt;li&gt;NetBSD 9.2+ (AMD64, GPU should work in theory)&lt;/li&gt; &#xA; &lt;li&gt;OpenBSD 7+ (AMD64, no GPU support)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;llamafile supports the following CPUs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;AMD64 microprocessors must have SSSE3. Otherwise llamafile will print an error and refuse to run. This means that if you have an Intel CPU, it needs to be Intel Core or newer (circa 2006+), and if you have an AMD CPU, then it needs to be Bulldozer or newer (circa 2011+). If you have a newer CPU with AVX, or better yet AVX2, then llamafile will utilize your chipset features to go faster. There is no support for AVX512+ runtime dispatching yet.&lt;/li&gt; &#xA; &lt;li&gt;ARM64 microprocessors must have ARMv8a+. This means everything from Apple Silicon to 64-bit Raspberry Pis will work, provided your weights fit into memory.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[1] Darwin kernel versions 15.6+ &lt;em&gt;should&lt;/em&gt; be supported, but we currently have no way of testing that.&lt;/p&gt; &#xA;&lt;h2&gt;A note about models&lt;/h2&gt; &#xA;&lt;p&gt;The example llamafiles provided above should not be interpreted as endorsements or recommendations of specific models, licenses, or data sets on the part of Mozilla.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>alezost/bui.el</title>
    <updated>2024-01-14T01:54:46Z</updated>
    <id>tag:github.com,2024-01-14:/alezost/bui.el</id>
    <link href="https://github.com/alezost/bui.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Buffer interface library for Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;[[http://www.gnu.org/licenses/gpl-3.0.txt][file:https://img.shields.io/badge/license-GPL_3-orange.svg]] [[http://melpa.org/#/bui][file:http://melpa.org/packages/bui-badge.svg]] [[http://stable.melpa.org/#/bui][file:http://stable.melpa.org/packages/bui-badge.svg]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;About&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=BUI= (=Buffer User Interface=) is an Emacs library that can be used to make user interfaces to display some kind of entries (like packages, buffers, functions, etc.).&lt;/p&gt; &#xA;&lt;p&gt;The intention of BUI is to be a high-level library which is convenient to be used both by:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;package makers&lt;/em&gt;, as there is no need to bother about implementing routine details and usual features (like buffer history, filtering displayed entries, etc.);&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;users&lt;/em&gt;, as it provides familiar and intuitive interfaces with usual keys (for moving by lines, marking, sorting, switching between buttons); and what is also important, the defined interfaces are highly configurable through various generated variables. A summary of available key bindings can be displayed by pressing =h=.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;BUI provides means to display entries in 2 types of buffers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;=list=: it is based on =tabulated-list-mode=, thus it looks similar to a list of Emacs packages (=M-x list-packages=);&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=info=: it can be used to display more verbose info, like various buttons, text and other stuff related to the displayed entry (or entries).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In short, you define how a =list= / =info= interface looks like (using =bui-define-interface= macro), and then you can make some user commands that will display entries (using =bui-get-display-entries= and similar functions).&lt;/p&gt; &#xA;&lt;p&gt;For example, you can make a =list= interface to display buffers (similar to what =M-x list-buffers= do), like this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (require &#39;bui)&lt;/p&gt; &#xA;&lt;p&gt;(defun buffers-buffer-&amp;gt;entry (buffer) (with-current-buffer buffer `((id . ,buffer) (name . ,(buffer-name)) (mode . ,major-mode) (size . ,(buffer-size)) (file-name . ,buffer-file-name))))&lt;/p&gt; &#xA;&lt;p&gt;(defun buffers-get-entries () (mapcar &#39;buffers-buffer-&amp;gt;entry (buffer-list)))&lt;/p&gt; &#xA;&lt;p&gt;(bui-define-interface buffers list :buffer-name &#34;&lt;em&gt;Buffers&lt;/em&gt;&#34; :get-entries-function &#39;buffers-get-entries :format &#39;((name nil 30 t) (mode nil 25 t) (size nil 8 bui-list-sort-numerically-2 :right-align t) (file-name bui-list-get-file-name 30 t)) :sort-key &#39;(name))&lt;/p&gt; &#xA;&lt;p&gt;(defun buffers () &#34;Display a list of buffers.&#34; (interactive) (bui-get-display-entries &#39;buffers &#39;list)) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This is a simplified example just to demonstrate how =bui.el= can be used. For full example see [[file:examples/buffers.el]]. You can see how it looks like on the following screenshot. =M-x buffers= displays a list of buffers, then 2 buffers are marked (with =m= key) and &#34;described&#34; in =info= buffer (with =i= key).&lt;/p&gt; &#xA;&lt;p&gt;[[http://i.imgur.com/3dlBu2Y.png]]&lt;/p&gt; &#xA;&lt;p&gt;=bui-define-interface= macro takes the following arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;ENTRY-TYPE: an arbitrary symbol to denote the entry type.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;BUFFER-TYPE: =list= or =info= symbol.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Keyword arguments: used to define various interface parameters and to set default values of user variables (like titles, buffer name, etc.). The main keywords that should be specified are:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;=:get-entries-function=: this function should return a list of entries to display. Each entry is a usual association list with one required =id= key (it is used to fill =tabulated-list-entries= variable).&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;=:format=: it specifies how the data is displayed; see docstrings of the generated =ENTRY-TYPE-BUFFER-TYPE-format= variables for details (in the current example: =buffers-list-format= and =buffers-info-format=).&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For real-world examples you may look at [[https://github.com/alezost/aurel][aurel]] or [[https://github.com/alezost/guix.el][guix]] packages.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Malabarba/spinner.el</title>
    <updated>2024-01-14T01:54:46Z</updated>
    <id>tag:github.com,2024-01-14:/Malabarba/spinner.el</id>
    <link href="https://github.com/Malabarba/spinner.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs mode-line spinner for operations in progress&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: spinner.el&lt;/p&gt; &#xA;&lt;p&gt;Add spinners and progress-bars to the mode-line for ongoing operations.&lt;/p&gt; &#xA;&lt;p&gt;[[file:some-spinners.gif]]&lt;/p&gt; &#xA;&lt;p&gt;[[file:all-spinners.gif]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;First of all, don’t forget to add &lt;del&gt;(spinner &#34;VERSION&#34;)&lt;/del&gt; to your package’s dependencies.&lt;/p&gt; &#xA;&lt;p&gt;** Major-modes&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Just call &lt;del&gt;(spinner-start)&lt;/del&gt; and a spinner will be added to the mode-line.&lt;/li&gt; &#xA; &lt;li&gt;Call &lt;del&gt;(spinner-stop)&lt;/del&gt; on the same buffer when you want to remove it.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The default spinner is a line drawing that rotates. You can pass an argument to &lt;del&gt;spinner-start&lt;/del&gt; to specify which spinner you want. All possibilities are listed in the &lt;del&gt;spinner-types&lt;/del&gt; variable, but here are a few examples for you to try:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;(spinner-start &#39;vertical-breathing 10)&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;(spinner-start &#39;minibox)&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;(spinner-start &#39;moon)&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;(spinner-start &#39;triangle)&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can also define your own as a vector of strings (see the examples in &lt;del&gt;spinner-types&lt;/del&gt;).&lt;/p&gt; &#xA;&lt;p&gt;** Minor-modes Minor-modes can create a spinner with &lt;del&gt;spinner-create&lt;/del&gt; and then add it to their mode-line lighter. They can then start the spinner by setting a variable and calling &lt;del&gt;spinner-start-timer&lt;/del&gt;. Finally, they can stop the spinner (and the timer) by just setting the same variable to nil.&lt;/p&gt; &#xA;&lt;p&gt;Here’s an example for a minor-mode named &lt;del&gt;foo&lt;/del&gt;. Assuming that &lt;del&gt;foo--lighter&lt;/del&gt; is used as the mode-line lighter, the following code will add an &lt;em&gt;inactive&lt;/em&gt; global spinner to the mode-line. #+begin_src emacs-lisp (defvar foo--spinner (spinner-create &#39;rotating-line)) (defconst foo--lighter &#39;(&#34; foo&#34; (:eval (spinner-print foo--spinner)))) #+end_src&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;To activate the spinner, just call &lt;del&gt;(spinner-start foo--spinner)&lt;/del&gt;. It will show up on the mode-line and start animating.&lt;/li&gt; &#xA; &lt;li&gt;To get rid of it, call &lt;del&gt;(spinner-stop foo--spinner)&lt;/del&gt;. It will then disappear again.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Some minor-modes will need spinners to be buffer-local. To achieve that, just make the &lt;del&gt;foo--spinner&lt;/del&gt; variable buffer-local and use the third argument of the &lt;del&gt;spinner-create&lt;/del&gt; function. The snippet below is an example.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defvar-local foo--spinner nil) (defconst foo--lighter &#39;(&#34; foo&#34; (:eval (spinner-print foo--spinner)))) (defun foo--start-spinner () &#34;Create and start a spinner on this buffer.&#34; (unless foo--spinner (setq foo--spinner (spinner-create &#39;moon t))) (spinner-start foo--spinner)) #+end_src&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;To activate the spinner, just call &lt;del&gt;(foo--start-spinner)&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To get rid of it, call &lt;del&gt;(spinner-stop foo--spinner)&lt;/del&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This will use the &lt;del&gt;moon&lt;/del&gt; spinner, but you can use any of the names defined in the &lt;del&gt;spinner-types&lt;/del&gt; variable or even define your own.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Extra options&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both &lt;del&gt;spinner-start&lt;/del&gt; and &lt;del&gt;spinner-create&lt;/del&gt; take extra options to configure the spinner, these are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;FPS&lt;/del&gt;: The number of frames to display per second. Defaults to &lt;del&gt;spinner-frames-per-second&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;DELAY&lt;/del&gt;: After starting a spinner, it still won’t be displayed for this many seconds.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>