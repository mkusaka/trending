<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-26T01:52:19Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>karthink/gptel</title>
    <updated>2023-03-26T01:52:19Z</updated>
    <id>tag:github.com,2023-03-26:/karthink/gptel</id>
    <link href="https://github.com/karthink/gptel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A no-frills ChatGPT client for Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: GPTel: A simple ChatGPT client for Emacs&lt;/p&gt; &#xA;&lt;p&gt;[[https://melpa.org/#/gptel][file:https://melpa.org/packages/gptel-badge.svg]]&lt;/p&gt; &#xA;&lt;p&gt;GPTel is a simple, no-frills ChatGPT client for Emacs.&lt;/p&gt; &#xA;&lt;p&gt;[[file:img/gptel.png]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Requires an [[https://platform.openai.com/account/api-keys][OpenAI API key]].&lt;/li&gt; &#xA; &lt;li&gt;No external dependencies, only Emacs. Also, it&#39;s async.&lt;/li&gt; &#xA; &lt;li&gt;Interact with ChatGPT from any buffer in Emacs.&lt;/li&gt; &#xA; &lt;li&gt;ChatGPT&#39;s responses are in Markdown or Org markup (configurable).&lt;/li&gt; &#xA; &lt;li&gt;Supports conversations (not just one-off queries) and multiple independent sessions.&lt;/li&gt; &#xA; &lt;li&gt;You can go back and edit your previous prompts, or even ChatGPT&#39;s previous responses when continuing a conversation. These will be fed back to ChatGPT.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Installation&lt;/p&gt; &#xA;&lt;p&gt;GPTel is on MELPA. Install it with =M-x package-install‚èé= =gptel=.&lt;/p&gt; &#xA;&lt;p&gt;(Optional: Install =markdown-mode=.)&lt;/p&gt; &#xA;&lt;p&gt;*** Straight #+begin_src emacs-lisp (straight-use-package &#39;gptel) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Installing the =markdown-mode= package is optional.&lt;/p&gt; &#xA;&lt;p&gt;*** Manual Clone this repository and load this file: #+begin_src emacs-lisp (add-to-list &#39;load-path &#34;/path/to/gptel/&#34;) (require &#39;gptel) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Installing the =markdown-mode= package is optional.&lt;/p&gt; &#xA;&lt;p&gt;** Usage&lt;/p&gt; &#xA;&lt;p&gt;Procure an [[https://platform.openai.com/account/api-keys][OpenAI API key]].&lt;/p&gt; &#xA;&lt;p&gt;Optional: Set =gptel-api-key= to the key or to a function that returns the key (more secure).&lt;/p&gt; &#xA;&lt;p&gt;*** In a dedicated chat buffer:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Run =M-x gptel= to start or switch to the ChatGPT buffer. It will ask you for the key if you skipped the previous step. Run it with a prefix-arg (=C-u M-x gptel=) to start a new session.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In the gptel buffer, send your prompt with =M-x gptel-send=, bound to =C-c RET=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Set chat parameters (GPT model, directives etc) for the session by calling =gptel-send= with a prefix argument (=C-u C-c RET=):&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;[[https://user-images.githubusercontent.com/8607532/224946059-9b918810-ab8b-46a6-b917-549d50c908f2.png]]&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s it. You can go back and edit previous prompts and responses if you want.&lt;/p&gt; &#xA;&lt;p&gt;The default mode is =markdown-mode= if available, else =text-mode=. You can set =gptel-default-mode= to =org-mode= if desired.&lt;/p&gt; &#xA;&lt;p&gt;*** In any buffer:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Select a region of text and call =M-x gptel-send=. The response will be inserted below your region.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can select both the original prompt and the response and call =M-x gptel-send= again to continue the conversation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Call =M-x gptel-send= with a prefix argument to set chat parameters (GPT model, directives etc) for this buffer, or to start a dedicated session from the selected region:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;[[https://user-images.githubusercontent.com/8607532/224949877-08c44cb4-7bff-4ffc-963a-16fef7a4271f.png]]&lt;/p&gt; &#xA;&lt;p&gt;** Why another ChatGPT client?&lt;/p&gt; &#xA;&lt;p&gt;Existing Emacs clients don&#39;t /reliably/ let me use it the simple way I can in the browser. They will get better, but I wanted something for now.&lt;/p&gt; &#xA;&lt;p&gt;Also, AI-assisted work is a new way to use Emacs. It&#39;s not yet clear what the best Emacs interface to tools like it is.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Should it be part of CAPF (=completions-at-point-functions=)?&lt;/li&gt; &#xA; &lt;li&gt;A dispatch menu from anywhere that can act on selected regions?&lt;/li&gt; &#xA; &lt;li&gt;A comint/shell-style REPL?&lt;/li&gt; &#xA; &lt;li&gt;One-off queries in the minibuffer (like =shell-command=)?&lt;/li&gt; &#xA; &lt;li&gt;A refactoring tool in code buffers?&lt;/li&gt; &#xA; &lt;li&gt;An =org-babel= interface?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Maybe all of these, I don&#39;t know yet. As a start, I wanted to replicate the web browser usage pattern so I can build from there -- and don&#39;t need to switch to the browser every time. The code is fairly simple right now.&lt;/p&gt; &#xA;&lt;p&gt;** Will you add feature X?&lt;/p&gt; &#xA;&lt;p&gt;Maybe, I&#39;d like to experiment a bit first.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>minad/cape</title>
    <updated>2023-03-26T01:52:19Z</updated>
    <id>tag:github.com,2023-03-26:/minad/cape</id>
    <link href="https://github.com/minad/cape" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ü¶∏cape.el - Completion At Point Extensions&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: cape.el - Let your completions fly! #+author: Daniel Mendler #+language: en #+export_file_name: cape.texi #+texinfo_dir_category: Emacs misc features #+texinfo_dir_title: Cape: (cape). #+texinfo_dir_desc: Completion At Point Extensions&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img alt=&#34;GNU Emacs&#34; src=&#34;https://github.com/minad/corfu/raw/screenshots/emacs.svg?raw=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://elpa.gnu.org/packages/cape.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/cape.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://elpa.gnu.org/devel/cape.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/cape.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/cape&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/cape-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://stable.melpa.org/#/cape&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/cape-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Cape provides Completion At Point Extensions which can be used in combination with the [[https://github.com/minad/corfu][Corfu]] completion UI or the default completion UI. The completion backends used by &lt;del&gt;completion-at-point&lt;/del&gt; are so called &lt;del&gt;completion-at-point-functions&lt;/del&gt; (Capfs). In principle, the Capfs provided by Cape can also be used by [[https://github.com/company-mode/company-mode][Company]].&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;img src=&#34;https://github.com/minad/cape/raw/logo/cape.png?raw=true&#34; align=&#34;right&#34; width=&#34;30%&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can register the &lt;del&gt;cape-*&lt;/del&gt; functions in the &lt;del&gt;completion-at-point-functions&lt;/del&gt; list. This makes the backends available for completion, which is usually invoked by pressing &lt;del&gt;TAB&lt;/del&gt; or &lt;del&gt;M-TAB&lt;/del&gt;. The functions can also be invoked interactively to trigger the respective completion at point. You can bind them directly to a key in your user configuration. Notable commands/Capfs are &lt;del&gt;cape-line&lt;/del&gt; for completion of a line from the current buffer and &lt;del&gt;cape-file&lt;/del&gt; for completion of a file name. The command &lt;del&gt;cape-symbol&lt;/del&gt; is particularly useful for documentation of Elisp packages or configurations, since it completes Elisp symbols anywhere.&lt;/p&gt; &#xA;&lt;p&gt;Cape has the super power to transform Company backends into Capfs and merge multiple Capfs into a Super-Capf! These transformers allow you to still take advantage of Company backends even if you are not using Company as frontend.&lt;/p&gt; &#xA;&lt;p&gt;#+toc: headlines 8&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Available Capfs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-dabbrev&lt;/del&gt;: Complete word from current buffers (see also &lt;del&gt;dabbrev-capf&lt;/del&gt; on Emacs 29)&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-file&lt;/del&gt;: Complete file name&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-history&lt;/del&gt;: Complete from Eshell, Comint or minibuffer history&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-keyword&lt;/del&gt;: Complete programming language keyword&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-symbol&lt;/del&gt;: Complete Elisp symbol&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-abbrev&lt;/del&gt;: Complete abbreviation (&lt;del&gt;add-global-abbrev&lt;/del&gt;, &lt;del&gt;add-mode-abbrev&lt;/del&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-ispell&lt;/del&gt;: Complete word from Ispell dictionary&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-dict&lt;/del&gt;: Complete word from dictionary file&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-line&lt;/del&gt;: Complete entire line from current buffer&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-tex&lt;/del&gt;: Complete unicode char from TeX command, e.g. &lt;del&gt;\hbar&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-sgml&lt;/del&gt;: Complete unicode char from Sgml entity, e.g., &lt;del&gt;&amp;amp;alpha&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-rfc1345&lt;/del&gt;: Complete unicode char using RFC 1345 mnemonics.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Cape is available on GNU ELPA and MELPA. You can install the package with &lt;del&gt;package-install&lt;/del&gt;. In the long term some of the Capfs provided by this package could be upstreamed into Emacs itself.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Enable Corfu completion UI ;; See the Corfu README for more configuration tips. (use-package corfu :init (global-corfu-mode))&lt;/p&gt; &#xA;&lt;p&gt;;; Add extensions (use-package cape ;; Bind dedicated completion commands ;; Alternative prefix keys: C-c p, M-p, M-+, ... :bind ((&#34;C-c p p&#34; . completion-at-point) ;; capf (&#34;C-c p t&#34; . complete-tag) ;; etags (&#34;C-c p d&#34; . cape-dabbrev) ;; or dabbrev-completion (&#34;C-c p h&#34; . cape-history) (&#34;C-c p f&#34; . cape-file) (&#34;C-c p k&#34; . cape-keyword) (&#34;C-c p s&#34; . cape-symbol) (&#34;C-c p a&#34; . cape-abbrev) (&#34;C-c p i&#34; . cape-ispell) (&#34;C-c p l&#34; . cape-line) (&#34;C-c p w&#34; . cape-dict) (&#34;C-c p \&#34; . cape-tex) (&#34;C-c p _&#34; . cape-tex) (&#34;C-c p ^&#34; . cape-tex) (&#34;C-c p &amp;amp;&#34; . cape-sgml) (&#34;C-c p r&#34; . cape-rfc1345)) :init ;; Add &lt;code&gt;completion-at-point-functions&#39;, used by &lt;/code&gt;completion-at-point&#39;. (add-to-list &#39;completion-at-point-functions #&#39;cape-dabbrev) (add-to-list &#39;completion-at-point-functions #&#39;cape-file) ;;(add-to-list &#39;completion-at-point-functions #&#39;cape-history) ;;(add-to-list &#39;completion-at-point-functions #&#39;cape-keyword) ;;(add-to-list &#39;completion-at-point-functions #&#39;cape-tex) ;;(add-to-list &#39;completion-at-point-functions #&#39;cape-sgml) ;;(add-to-list &#39;completion-at-point-functions #&#39;cape-rfc1345) ;;(add-to-list &#39;completion-at-point-functions #&#39;cape-abbrev) ;;(add-to-list &#39;completion-at-point-functions #&#39;cape-ispell) ;;(add-to-list &#39;completion-at-point-functions #&#39;cape-dict) ;;(add-to-list &#39;completion-at-point-functions #&#39;cape-symbol) ;;(add-to-list &#39;completion-at-point-functions #&#39;cape-line) ) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CAPF adapters and transformers ** Company adapter&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;/Wrap your Company backend in a Cape and turn it into a Capf!/&lt;/p&gt; &#xA;&lt;p&gt;Cape provides the adapter &lt;del&gt;cape-company-to-capf&lt;/del&gt; for Company backends. The adapter transforms Company backends to Capfs which are understood by the built-in Emacs completion mechanism. The function is approximately the inverse of the &lt;del&gt;company-capf&lt;/del&gt; backend from Company. The adapter can be used as follows:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Use Company backends as Capfs. (setq-local completion-at-point-functions (mapcar #&#39;cape-company-to-capf (list #&#39;company-files #&#39;company-ispell #&#39;company-dabbrev))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Note that the adapter does not require Company to be installed or enabled. Backends implementing the Company specification do not necessarily have to depend on Company, however in practice most backends do. The following shows a small example completion backend, which can be used with both &lt;del&gt;completion-at-point&lt;/del&gt; (Corfu, default completion) and Company.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defvar emojis &#39;((&#34;:-D&#34; . &#34;üòÄ&#34;) (&#34;;-)&#34; . &#34;üòâ&#34;) (&#34;:-/&#34; . &#34;üòï&#34;) (&#34;:-(&#34; . &#34;üôÅ&#34;) (&#34;:-*&#34; . &#34;üòô&#34;)))&lt;/p&gt; &#xA;&lt;p&gt;(defun emoji-backend (action &amp;amp;optional arg &amp;amp;rest _) (pcase action (&#39;prefix (and (memq (char-before) &#39;(?: ?;)) (cons (string (char-before)) t))) (&#39;candidates (all-completions arg emojis)) (&#39;annotation (concat &#34; &#34; (cdr (assoc arg emojis)))) (&#39;post-completion (let ((str (buffer-substring (- (point) 3) (point)))) (delete-region (- (point) 3) (point)) (insert (cdr (assoc str emojis)))))))&lt;/p&gt; &#xA;&lt;p&gt;;; Register emoji backend with `completion-at-point&#39; (setq completion-at-point-functions (list (cape-company-to-capf #&#39;emoji-backend)))&lt;/p&gt; &#xA;&lt;p&gt;;; Register emoji backend with Company. (setq company-backends &#39;(emoji-backend)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;It is possible to merge/group multiple Company backends and use them as a single Capf using the &lt;del&gt;company--multi-backend-adapter&lt;/del&gt; function from Company. The adapter transforms multiple Company backends into a single Company backend, which can then be used as a Capf via &lt;del&gt;cape-company-to-capf&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (require &#39;company) ;; Use the company-dabbrev and company-elisp backends together. (setq completion-at-point-functions (list (cape-company-to-capf (apply-partially #&#39;company--multi-backend-adapter &#39;(company-dabbrev company-elisp))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Super-Capf - Merging multiple Capfs&lt;/p&gt; &#xA;&lt;p&gt;/Throw multiple Capfs under the Cape and get a Super-Capf!/&lt;/p&gt; &#xA;&lt;p&gt;Cape supports merging multiple Capfs using the function &lt;del&gt;cape-super-capf&lt;/del&gt;. &lt;em&gt;This feature is EXPERIMENTAL and should only be used in special scenarios. Don&#39;t use cape-super-capf if you are not 100% sure that you need it! If you decide to use the function, you are on UNSUPPORTED TERRITORY.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;del&gt;cape-super-capf&lt;/del&gt; is not needed if you want to use multiple Capfs which are tried one by one, e.g., it is perfectly possible to use &lt;del&gt;cape-file&lt;/del&gt; together with the Lsp-mode Capf or other programming mode Capfs by adding &lt;del&gt;cape-file&lt;/del&gt; to the &lt;del&gt;completion-at-point-functions&lt;/del&gt; list. The file completion will be available in comments and string literals. &lt;del&gt;cape-super-capf&lt;/del&gt; is only needed if you want to combine multiple Capfs, such that the candidates from multiple sources appear /together/ in the completion list at the same time.&lt;/p&gt; &#xA;&lt;p&gt;Completion table merging works only for tables which are sufficiently well-behaved and tables which do not define completion boundaries. &lt;del&gt;cape-super-capf&lt;/del&gt; has the same restrictions as &lt;del&gt;completion-table-merge&lt;/del&gt; and &lt;del&gt;completion-table-in-turn&lt;/del&gt;. As a simple rule of thumb, &lt;del&gt;cape-super-capf&lt;/del&gt; works only well for static completion functions like &lt;del&gt;cape-dabbrev&lt;/del&gt;, &lt;del&gt;cape-keyword&lt;/del&gt;, &lt;del&gt;cape-ispell&lt;/del&gt;, etc., but not for complex multi-step completions like &lt;del&gt;cape-file&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Merge the dabbrev, dict and keyword capfs, display candidates together. (setq-local completion-at-point-functions (list (cape-super-capf #&#39;cape-dabbrev #&#39;cape-dict #&#39;cape-keyword)))&lt;/p&gt; &#xA;&lt;p&gt;;; Alternative: Define named Capf instead of using the anonymous Capf directly (defalias &#39;cape-dabbrev+dict+keyword (cape-super-capf #&#39;cape-dabbrev #&#39;cape-dict #&#39;cape-keyword)) (setq-local completion-at-point-functions (list #&#39;cape-dabbrev+dict+keyword)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;See also the aforementioned &lt;del&gt;company--multi-backend-adapter&lt;/del&gt; from Company, which allows you to merge multiple Company backends.&lt;/p&gt; &#xA;&lt;p&gt;** Capf-Buster - Cache busting&lt;/p&gt; &#xA;&lt;p&gt;/The Capf-Buster ensures that you always get a fresh set of candidates!/&lt;/p&gt; &#xA;&lt;p&gt;If a Capf caches the candidates for too long we can use a cache busting Capf-transformer. For example the Capf merging function &lt;del&gt;cape-super-capf&lt;/del&gt; creates a Capf, which caches the candidates for the whole lifetime of the Capf. Therefore you may want to combine a merged Capf with a cache buster under some circumstances. It is noteworthy that the &lt;del&gt;company-capf&lt;/del&gt; backend from Company refreshes the completion table frequently. With the &lt;del&gt;cape-capf-buster&lt;/del&gt; we can achieve a similarly refreshing strategy.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq-local completion-at-point-functions (list (cape-capf-buster #&#39;some-caching-capf))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Capf transformers&lt;/p&gt; &#xA;&lt;p&gt;Cape provides a set of additional Capf transformation functions, which are mostly meant to used by experts to fine tune the Capf behavior and Capf interaction. These can either be used as advices (=cape-wrap-&lt;em&gt;)= or to create a new Capf from an existing Capf (=cape-capf-&lt;/em&gt;=). You can bind the Capfs created by the Capf transformers with =defalias= to a function symbol.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-interactive-capf&lt;/del&gt;, &lt;del&gt;cape-interactive&lt;/del&gt;: Create a Capf which can be called interactively.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-accept-all&lt;/del&gt;, &lt;del&gt;cape-capf-accept-all&lt;/del&gt;: Create a Capf which accepts every input as valid.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-silent&lt;/del&gt;, &lt;del&gt;cape-capf-silent&lt;/del&gt;: Wrap a chatty Capf and silence it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-purify&lt;/del&gt;, &lt;del&gt;cape-capf-purify&lt;/del&gt;: Purify a broken Capf and ensure that it does not modify the buffer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-nonexclusive&lt;/del&gt;, &lt;del&gt;cape-capf-nonexclusive:&lt;/del&gt; Mark Capf as non-exclusive.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-noninterruptible&lt;/del&gt;, &lt;del&gt;cape-capf-noninterruptible:&lt;/del&gt; Protect a Capf which does not like to be interrupted.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-case-fold&lt;/del&gt;, &lt;del&gt;cape-capf-case-fold&lt;/del&gt;: Create a Capf which is case insensitive.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-properties&lt;/del&gt;, &lt;del&gt;cape-capf-properties&lt;/del&gt;: Add completion properties to a Capf.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-predicate&lt;/del&gt;, &lt;del&gt;cape-capf-predicate&lt;/del&gt;: Add candidate predicate to a Capf.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-prefix-length&lt;/del&gt;, &lt;del&gt;cape-capf-prefix-length&lt;/del&gt;: Enforce a minimal prefix length.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-inside-comment&lt;/del&gt;, &lt;del&gt;cape-capf-inside-comment&lt;/del&gt;: Ensure that Capf triggers only inside comment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;cape-wrap-inside-string&lt;/del&gt;, &lt;del&gt;cape-capf-inside-string&lt;/del&gt;: Ensure that Capf triggers only inside a string literal.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In the following we show a few example configurations, which have come up on the [[https://github.com/minad/cape/issues][Cape]] or [[https://github.com/minad/corfu/issues][Corfu issue tracker]] or the [[https://github.com/minad/corfu/wiki][Corfu wiki.]] I use some of these tweaks in my personal configuration.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Example 1: Sanitize the `pcomplete-completions-at-point&#39; Capf. The Capf has ;; undesired side effects on Emacs 28 and earlier. These advices are not needed ;; on Emacs 29 and newer. (when (&amp;lt; emacs-major-version 29) (advice-add &#39;pcomplete-completions-at-point :around #&#39;cape-wrap-silent) (advice-add &#39;pcomplete-completions-at-point :around #&#39;cape-wrap-purify))&lt;/p&gt; &#xA;&lt;p&gt;;; Example 2: Configure a Capf with a specific auto completion prefix length (setq-local completion-at-point-functions (list (cape-capf-prefix-length #&#39;cape-dabbrev 2)))&lt;/p&gt; &#xA;&lt;p&gt;;; Example 3: Named Capf (defalias &#39;cape-dabbrev-min-2 (cape-capf-prefix-length #&#39;cape-dabbrev 2)) (setq-local completion-at-point-functions (list #&#39;cape-dabbrev-min-2))&lt;/p&gt; &#xA;&lt;p&gt;;; Example 4: Define a defensive Dabbrev Capf, which accepts all inputs. If you ;; use Corfu and &lt;code&gt;corfu-auto=t&#39;, the first candidate won&#39;t be auto selected even ;; if &lt;/code&gt;corfu-preselect=first&#39;. You can use this instead of `cape-dabbrev&#39;. (defun my-cape-dabbrev-accept-all () (cape-wrap-accept-all #&#39;cape-dabbrev)) (add-to-list &#39;completion-at-point-functions #&#39;my-cape-dabbrev-accept-all)&lt;/p&gt; &#xA;&lt;p&gt;;; Example 5: Define interactive Capf which can be bound to a key. Here we wrap ;; the `elisp-completion-at-point&#39; such that we can complete Elisp code ;; explicitly in arbitrary buffers. (keymap-global-set &#34;C-c p e&#34; (cape-interactive-capf #&#39;elisp-completion-at-point))&lt;/p&gt; &#xA;&lt;p&gt;;; Example 6: Ignore :keywords in Elisp completion. (defun ignore-elisp-keywords (sym) (not (keywordp sym))) (setq-local completion-at-point-functions (list (cape-capf-predicate #&#39;elisp-completion-at-point #&#39;ignore-elisp-keywords))) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since this package is part of [[https://elpa.gnu.org/packages/cape.html][GNU ELPA]] contributions require a copyright assignment to the FSF.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tarsius/minions</title>
    <updated>2023-03-26T01:52:19Z</updated>
    <id>tag:github.com,2023-03-26:/tarsius/minions</id>
    <link href="https://github.com/tarsius/minions" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A minor-mode menu for the mode line&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;A minor-mode menu for the mode line&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This package implements a nested menu that gives access to all known minor modes (i.e., those listed in &lt;del&gt;minor-mode-list&lt;/del&gt;). It can be used to toggle local and global minor modes, to access mode-specific menus, and to display information about modes.&lt;/p&gt; &#xA;&lt;p&gt;This menu is intended as a replacement for the incomplete, yet quite space consuming, list of enabled minor modes that is displayed in the mode line by default. To use the menu like this, enable Minions mode.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively the menu can be bound globally, for example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (global-set-key [S-down-mouse-3] &#39;minions-minor-modes-menu) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;To list a mode even though the defining library has not been loaded yet, you must add it to &lt;del&gt;minor-mode-list&lt;/del&gt; yourself. Additionally it must be autoloaded. For example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (when (autoloadp (symbol-function &#39;glasses-mode)) (cl-pushnew &#39;glasses-mode minor-mode-list)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Compatibility information can be found [[https://github.com/tarsius/minions/wiki][here]].&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;br&gt;&lt;br&gt; #+html: &lt;a href=&#34;https://github.com/tarsius/minions/actions/workflows/compile.yml&#34;&gt;&lt;img alt=&#34;Compile&#34; src=&#34;https://github.com/tarsius/minions/actions/workflows/compile.yml/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://stable.melpa.org/#/minions&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/minions-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/minions&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/minions-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>