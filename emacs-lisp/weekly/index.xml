<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-03T02:09:05Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jwiegley/use-package</title>
    <updated>2022-07-03T02:09:05Z</updated>
    <id>tag:github.com,2022-07-03:/jwiegley/use-package</id>
    <link href="https://github.com/jwiegley/use-package" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A use-package declaration for simplifying your .emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;code&gt;use-package&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/use-package/Lobby?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/use-package/Lobby.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/use-package/Lobby&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/jwiegley/use-package&#34;&gt;&lt;img src=&#34;https://travis-ci.org/jwiegley/use-package.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.milkbox.net/#/use-package&#34;&gt;&lt;img src=&#34;http://melpa.milkbox.net/packages/use-package-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/use-package&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/use-package-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;use-package&lt;/code&gt; macro allows you to isolate package configuration in your &lt;code&gt;.emacs&lt;/code&gt; file in a way that is both performance-oriented and, well, tidy. I created it because I have over 80 packages that I use in Emacs, and things were getting difficult to manage. Yet with this utility my total load time is around 2 seconds, with no loss of functionality!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;use-package&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; a package manager! Although &lt;code&gt;use-package&lt;/code&gt; does have the useful capability to interface with package managers (see &lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#package-installation&#34;&gt;below&lt;/a&gt;), its primary purpose is for the configuration and loading of packages.&lt;/p&gt; &#xA;&lt;p&gt;Notes for users upgrading to 2.x are located &lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#upgrading-to-2x&#34;&gt;at the bottom&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#installing-use-package&#34;&gt;Installing use-package&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#getting-started&#34;&gt;Getting started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#key-binding&#34;&gt;Key-binding&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#binding-to-keymaps&#34;&gt;Binding to keymaps&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#binding-within-local-keymaps&#34;&gt;Binding within local keymaps&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#modes-and-interpreters&#34;&gt;Modes and interpreters&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#magic-handlers&#34;&gt;Magic handlers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#hooks&#34;&gt;Hooks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#package-customization&#34;&gt;Package customization&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#customizing-variables&#34;&gt;Customizing variables&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#customizing-faces&#34;&gt;Customizing faces&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#notes-about-lazy-loading&#34;&gt;Notes about lazy loading&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#information-about-package-loads&#34;&gt;Information about package loads&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#conditional-loading&#34;&gt;Conditional loading&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#conditional-loading-before-preface&#34;&gt;Conditional loading before :preface&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#loading-packages-in-sequence&#34;&gt;Loading packages in a sequence&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#prevent-loading-if-dependencies-are-missing&#34;&gt;Prevent loading if dependencies are missing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#byte-compiling-your-emacs&#34;&gt;Byte compiling your .emacs&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#prevent-a-package-from-loading-at-compile-time&#34;&gt;Prevent a package from loading at compile-time&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#extending-the-load-path&#34;&gt;Extending the load-path&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#catching-errors-during-use-package-expansion&#34;&gt;Catching errors during use-package expansion&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#diminishing-and-delighting-minor-modes&#34;&gt;Diminishing and delighting minor modes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#package-installation&#34;&gt;Package installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#usage-with-other-package-managers&#34;&gt;Usage with other package managers&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#gathering-statistics&#34;&gt;Gathering Statistics&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#keyword-extensions&#34;&gt;Keyword Extensions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#use-package-ensure-system-package&#34;&gt;use-package-ensure-system-package&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#use-package-chords&#34;&gt;use-package-chords&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#how-to-create-an-extension&#34;&gt;How to create an extension&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#first-step-add-the-keyword&#34;&gt;First step: Add the keyword&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#second-step-create-a-normalizer&#34;&gt;Second step: Create a normalizer&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#third-step-create-a-handler&#34;&gt;Third step: Create a handler&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#fourth-step-test-it-out&#34;&gt;Fourth step: Test it out&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#some-timing-results&#34;&gt;Some timing results&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#upgrading-to-2x&#34;&gt;Upgrading to 2.x&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#semantics-of-init-is-now-consistent&#34;&gt;Semantics of :init is now consistent&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#idle-has-been-removed&#34;&gt;:idle has been removed&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#defer-now-accepts-an-optional-numeric-argument&#34;&gt;:defer now accepts an optional numeric argument&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#add-preface-occurring-before-everything-except-disabled&#34;&gt;Add :preface, occuring before everything except :disabled&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#add-functions-for-declaring-functions-to-the-byte-compiler&#34;&gt;Add :functions, for declaring functions to the byte-compiler&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwiegley/use-package/master/#use-packageel-is-no-longer-needed-at-runtime&#34;&gt;use-package.el is no longer needed at runtime&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installing use-package&lt;/h2&gt; &#xA;&lt;p&gt;Either clone from this GitHub repository or install from &lt;a href=&#34;http://melpa.milkbox.net/&#34;&gt;MELPA&lt;/a&gt; (recommended).&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Here is the simplest &lt;code&gt;use-package&lt;/code&gt; declaration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; This is only needed once, near the top of the file&#xA;(eval-when-compile&#xA;  ;; Following line is not needed if use-package.el is in ~/.emacs.d&#xA;  (add-to-list &#39;load-path &#34;&amp;lt;path where use-package is installed&amp;gt;&#34;)&#xA;  (require &#39;use-package))&#xA;&#xA;(use-package foo)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This loads in the package &lt;code&gt;foo&lt;/code&gt;, but only if &lt;code&gt;foo&lt;/code&gt; is available on your system. If not, a warning is logged to the &lt;code&gt;*Messages*&lt;/code&gt; buffer.&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;:init&lt;/code&gt; keyword to execute code before a package is loaded. It accepts one or more forms, up to the next keyword:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package foo&#xA;  :init&#xA;  (setq foo-variable t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, &lt;code&gt;:config&lt;/code&gt; can be used to execute code after a package is loaded. In cases where loading is done lazily (see more about autoloading below), this execution is deferred until after the autoload occurs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package foo&#xA;  :init&#xA;  (setq foo-variable t)&#xA;  :config&#xA;  (foo-mode 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you might expect, you can use &lt;code&gt;:init&lt;/code&gt; and &lt;code&gt;:config&lt;/code&gt; together:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package color-moccur&#xA;  :commands (isearch-moccur isearch-all)&#xA;  :bind ((&#34;M-s O&#34; . moccur)&#xA;         :map isearch-mode-map&#xA;         (&#34;M-o&#34; . isearch-moccur)&#xA;         (&#34;M-O&#34; . isearch-moccur-all))&#xA;  :init&#xA;  (setq isearch-lazy-highlight t)&#xA;  :config&#xA;  (use-package moccur-edit))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, I want to autoload the commands &lt;code&gt;isearch-moccur&lt;/code&gt; and &lt;code&gt;isearch-all&lt;/code&gt; from &lt;code&gt;color-moccur.el&lt;/code&gt;, and bind keys both at the global level and within the &lt;code&gt;isearch-mode-map&lt;/code&gt; (see next section). When the package is actually loaded (by using one of these commands), &lt;code&gt;moccur-edit&lt;/code&gt; is also loaded, to allow editing of the &lt;code&gt;moccur&lt;/code&gt; buffer.&lt;/p&gt; &#xA;&lt;h2&gt;Key-binding&lt;/h2&gt; &#xA;&lt;p&gt;Another common thing to do when loading a module is to bind a key to primary commands within that module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :bind (&#34;C-.&#34; . ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This does two things: first, it creates an autoload for the &lt;code&gt;ace-jump-mode&lt;/code&gt; command and defers loading of &lt;code&gt;ace-jump-mode&lt;/code&gt; until you actually use it. Second, it binds the key &lt;code&gt;C-.&lt;/code&gt; to that command. After loading, you can use &lt;code&gt;M-x describe-personal-keybindings&lt;/code&gt; to see all such keybindings you&#39;ve set throughout your &lt;code&gt;.emacs&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;A more literal way to do the exact same thing is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :commands ace-jump-mode&#xA;  :init&#xA;  (bind-key &#34;C-.&#34; &#39;ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you use the &lt;code&gt;:commands&lt;/code&gt; keyword, it creates autoloads for those commands and defers loading of the module until they are used. Since the &lt;code&gt;:init&lt;/code&gt; form is always run -- even if &lt;code&gt;ace-jump-mode&lt;/code&gt; might not be on your system -- remember to restrict &lt;code&gt;:init&lt;/code&gt; code to only what would succeed either way.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;:bind&lt;/code&gt; keyword takes either a cons or a list of conses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package hi-lock&#xA;  :bind ((&#34;M-o l&#34; . highlight-lines-matching-regexp)&#xA;         (&#34;M-o r&#34; . highlight-regexp)&#xA;         (&#34;M-o w&#34; . highlight-phrase)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;:commands&lt;/code&gt; keyword likewise takes either a symbol or a list of symbols.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: inside strings, special keys like &lt;code&gt;tab&lt;/code&gt; or &lt;code&gt;F1&lt;/code&gt;-&lt;code&gt;Fn&lt;/code&gt; have to be written inside angle brackets, e.g. &lt;code&gt;&#34;C-&amp;lt;up&amp;gt;&#34;&lt;/code&gt;. Standalone special keys (and some combinations) can be written in square brackets, e.g. &lt;code&gt;[tab]&lt;/code&gt; instead of &lt;code&gt;&#34;&amp;lt;tab&amp;gt;&#34;&lt;/code&gt;. The syntax for the keybindings is similar to the &#34;kbd&#34; syntax: see &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html&#34;&gt;https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package helm&#xA;  :bind ((&#34;M-x&#34; . helm-M-x)&#xA;         (&#34;M-&amp;lt;f5&amp;gt;&#34; . helm-find-files)&#xA;         ([f10] . helm-buffers-list)&#xA;         ([S-f10] . helm-recentf)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Furthermore, &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/elisp/Remapping-Commands.html&#34;&gt;remapping commands&lt;/a&gt; with &lt;code&gt;:bind&lt;/code&gt; and &lt;code&gt;bind-key&lt;/code&gt; works as expected, because when the binding is a vector, it is passed straight to &lt;code&gt;define-key&lt;/code&gt;. So the following example will rebind &lt;code&gt;M-q&lt;/code&gt; (originally &lt;code&gt;fill-paragraph&lt;/code&gt;) to &lt;code&gt;unfill-toggle&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package unfill&#xA;  :bind ([remap fill-paragraph] . unfill-toggle))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Binding to keymaps&lt;/h3&gt; &#xA;&lt;p&gt;Normally &lt;code&gt;:bind&lt;/code&gt; expects that commands are functions that will be autoloaded from the given package. However, this does not work if one of those commands is actually a keymap, since keymaps are not functions, and cannot be autoloaded using Emacs&#39; &lt;code&gt;autoload&lt;/code&gt; mechanism.&lt;/p&gt; &#xA;&lt;p&gt;To handle this case, &lt;code&gt;use-package&lt;/code&gt; offers a special, limited variant of &lt;code&gt;:bind&lt;/code&gt; called &lt;code&gt;:bind-keymap&lt;/code&gt;. The only difference is that the &#34;commands&#34; bound to by &lt;code&gt;:bind-keymap&lt;/code&gt; must be keymaps defined in the package, rather than command functions. This is handled behind the scenes by generating custom code that loads the package containing the keymap, and then re-executes your keypress after the first load, to reinterpret that keypress as a prefix key.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package projectile&#xA;  :bind-keymap&#xA;  (&#34;C-c p&#34; . projectile-command-map))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Binding within local keymaps&lt;/h3&gt; &#xA;&lt;p&gt;Slightly different from binding a key to a keymap, is binding a key &lt;em&gt;within&lt;/em&gt; a local keymap that only exists after the package is loaded. &lt;code&gt;use-package&lt;/code&gt; supports this with a &lt;code&gt;:map&lt;/code&gt; modifier, taking the local keymap to bind to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package helm&#xA;  :bind (:map helm-command-map&#xA;         (&#34;C-c h&#34; . helm-execute-persistent-action)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The effect of this statement is to wait until &lt;code&gt;helm&lt;/code&gt; has loaded, and then to bind the key &lt;code&gt;C-c h&lt;/code&gt; to &lt;code&gt;helm-execute-persistent-action&lt;/code&gt; within Helm&#39;s local keymap, &lt;code&gt;helm-mode-map&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Multiple uses of &lt;code&gt;:map&lt;/code&gt; may be specified. Any binding occurring before the first use of &lt;code&gt;:map&lt;/code&gt; are applied to the global keymap:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package term&#xA;  :bind ((&#34;C-c t&#34; . term)&#xA;         :map term-mode-map&#xA;         (&#34;M-p&#34; . term-send-up)&#xA;         (&#34;M-n&#34; . term-send-down)&#xA;         :map term-raw-map&#xA;         (&#34;M-o&#34; . other-window)&#xA;         (&#34;M-p&#34; . term-send-up)&#xA;         (&#34;M-n&#34; . term-send-down)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Modes and interpreters&lt;/h2&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:bind&lt;/code&gt;, you can use &lt;code&gt;:mode&lt;/code&gt; and &lt;code&gt;:interpreter&lt;/code&gt; to establish a deferred binding within the &lt;code&gt;auto-mode-alist&lt;/code&gt; and &lt;code&gt;interpreter-mode-alist&lt;/code&gt; variables. The specifier to either keyword can be a cons cell, a list of cons cells, or a string or regexp:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ruby-mode&#xA;  :mode &#34;\\.rb\\&#39;&#34;&#xA;  :interpreter &#34;ruby&#34;)&#xA;&#xA;;; The package is &#34;python&#34; but the mode is &#34;python-mode&#34;:&#xA;(use-package python&#xA;  :mode (&#34;\\.py\\&#39;&#34; . python-mode)&#xA;  :interpreter (&#34;python&#34; . python-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you aren&#39;t using &lt;code&gt;:commands&lt;/code&gt;, &lt;code&gt;:bind&lt;/code&gt;, &lt;code&gt;:bind*&lt;/code&gt;, &lt;code&gt;:bind-keymap&lt;/code&gt;, &lt;code&gt;:bind-keymap*&lt;/code&gt;, &lt;code&gt;:mode&lt;/code&gt;, &lt;code&gt;:interpreter&lt;/code&gt;, or &lt;code&gt;:hook&lt;/code&gt; (all of which imply &lt;code&gt;:defer&lt;/code&gt;; see the docstring for &lt;code&gt;use-package&lt;/code&gt; for a brief description of each), you can still defer loading with the &lt;code&gt;:defer&lt;/code&gt; keyword:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :defer t&#xA;  :init&#xA;  (autoload &#39;ace-jump-mode &#34;ace-jump-mode&#34; nil t)&#xA;  (bind-key &#34;C-.&#34; &#39;ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This does exactly the same thing as the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :bind (&#34;C-.&#34; . ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Magic handlers&lt;/h2&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;:mode&lt;/code&gt; and &lt;code&gt;:interpreter&lt;/code&gt;, you can also use &lt;code&gt;:magic&lt;/code&gt; and &lt;code&gt;:magic-fallback&lt;/code&gt; to cause certain function to be run if the beginning of a file matches a given regular expression. The difference between the two is that &lt;code&gt;:magic-fallback&lt;/code&gt; has a lower priority than &lt;code&gt;:mode&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package pdf-tools&#xA;  :load-path &#34;site-lisp/pdf-tools/lisp&#34;&#xA;  :magic (&#34;%PDF&#34; . pdf-view-mode)&#xA;  :config&#xA;  (pdf-tools-install :no-query))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This registers an autoloaded command for &lt;code&gt;pdf-view-mode&lt;/code&gt;, defers loading of &lt;code&gt;pdf-tools&lt;/code&gt;, and runs &lt;code&gt;pdf-view-mode&lt;/code&gt; if the beginning of a buffer matches the string &lt;code&gt;&#34;%PDF&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Hooks&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;:hook&lt;/code&gt; keyword allows adding functions onto package hooks. Thus, all of the following are equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :hook prog-mode)&#xA;&#xA;(use-package ace-jump-mode&#xA;  :hook (prog-mode . ace-jump-mode))&#xA;&#xA;(use-package ace-jump-mode&#xA;  :commands ace-jump-mode&#xA;  :init&#xA;  (add-hook &#39;prog-mode-hook #&#39;ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And likewise, when multiple hooks should be applied, the following are also equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :hook (prog-mode text-mode))&#xA;&#xA;(use-package ace-jump-mode&#xA;  :hook ((prog-mode text-mode) . ace-jump-mode))&#xA;&#xA;(use-package ace-jump-mode&#xA;  :hook ((prog-mode . ace-jump-mode)&#xA;         (text-mode . ace-jump-mode)))&#xA;&#xA;(use-package ace-jump-mode&#xA;  :commands ace-jump-mode&#xA;  :init&#xA;  (add-hook &#39;prog-mode-hook #&#39;ace-jump-mode)&#xA;  (add-hook &#39;text-mode-hook #&#39;ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using &lt;code&gt;:hook&lt;/code&gt; omit the &#34;-hook&#34; suffix if you specify the hook explicitly, as this is appended by default. For example the following code will not work as it attempts to add to the &lt;code&gt;prog-mode-hook-hook&lt;/code&gt; which does not exist:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; DOES NOT WORK&#xA;(use-package ace-jump-mode&#xA;  :hook (prog-mode-hook . ace-jump-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you do not like this behaviour, set &lt;code&gt;use-package-hook-name-suffix&lt;/code&gt; to nil. By default the value of this variable is &#34;-hook&#34;.&lt;/p&gt; &#xA;&lt;p&gt;The use of &lt;code&gt;:hook&lt;/code&gt;, as with &lt;code&gt;:bind&lt;/code&gt;, &lt;code&gt;:mode&lt;/code&gt;, &lt;code&gt;:interpreter&lt;/code&gt;, etc., causes the functions being hooked to implicitly be read as &lt;code&gt;:commands&lt;/code&gt; (meaning they will establish interactive &lt;code&gt;autoload&lt;/code&gt; definitions for that module, if not already defined as functions), and so &lt;code&gt;:defer t&lt;/code&gt; is also implied by &lt;code&gt;:hook&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Package customization&lt;/h2&gt; &#xA;&lt;h3&gt;Customizing variables.&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:custom&lt;/code&gt; keyword allows customization of package custom variables.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package comint&#xA;  :custom&#xA;  (comint-buffer-maximum-size 20000 &#34;Increase comint buffer size.&#34;)&#xA;  (comint-prompt-read-only t &#34;Make the prompt read only.&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The documentation string is not mandatory.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: these are only for people who wish to keep customizations with their accompanying use-package declarations. Functionally, the only benefit over using &lt;code&gt;setq&lt;/code&gt; in a &lt;code&gt;:config&lt;/code&gt; block is that customizations might execute code when values are assigned.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The customized values are &lt;strong&gt;not&lt;/strong&gt; saved in the Emacs &lt;code&gt;custom-file&lt;/code&gt;. Thus you should either use the &lt;code&gt;:custom&lt;/code&gt; option &lt;strong&gt;or&lt;/strong&gt; you should use &lt;code&gt;M-x customize-option&lt;/code&gt; which will save customized values in the Emacs &lt;code&gt;custom-file&lt;/code&gt;. Do not use both.&lt;/p&gt; &#xA;&lt;h3&gt;Customizing faces&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:custom-face&lt;/code&gt; keyword allows customization of package custom faces.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package eruby-mode&#xA;  :custom-face&#xA;  (eruby-standard-face ((t (:slant italic)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Notes about lazy loading&lt;/h2&gt; &#xA;&lt;p&gt;The keywords &lt;code&gt;:commands&lt;/code&gt;, et al, provide &#34;triggers&#34; that cause a package to be loaded when certain events occur. However, if &lt;code&gt;use-package&lt;/code&gt; cannot determine that any trigger has been declared, it will load the package immediately (when Emacs is starting up) unless &lt;code&gt;:defer t&lt;/code&gt; is given. The presence of triggers can be overridden using &lt;code&gt;:demand t&lt;/code&gt; to force immediately loading anyway. For example, &lt;code&gt;:hook&lt;/code&gt; represents a trigger that fires when the specified hook is run.&lt;/p&gt; &#xA;&lt;p&gt;In almost all cases you don&#39;t need to manually specify &lt;code&gt;:defer t&lt;/code&gt;, because this is implied whenever &lt;code&gt;:bind&lt;/code&gt; or &lt;code&gt;:mode&lt;/code&gt; or &lt;code&gt;:interpreter&lt;/code&gt; are used. Typically, you only need to specify &lt;code&gt;:defer&lt;/code&gt; if you know for a fact that some other package will do something to cause your package to load at the appropriate time, and thus you would like to defer loading even though &lt;code&gt;use-package&lt;/code&gt; has not created any autoloads for you.&lt;/p&gt; &#xA;&lt;p&gt;You can override package deferral with the &lt;code&gt;:demand&lt;/code&gt; keyword. Thus, even if you use &lt;code&gt;:bind&lt;/code&gt;, adding &lt;code&gt;:demand&lt;/code&gt; will force loading to occur immediately and not establish an autoload for the bound key.&lt;/p&gt; &#xA;&lt;h2&gt;Information about package loads&lt;/h2&gt; &#xA;&lt;p&gt;When a package is loaded, and if you have &lt;code&gt;use-package-verbose&lt;/code&gt; set to &lt;code&gt;t&lt;/code&gt;, or if the package takes longer than 0.1s to load, you will see a message to indicate this loading activity in the &lt;code&gt;*Messages*&lt;/code&gt; buffer. The same will happen for configuration, or &lt;code&gt;:config&lt;/code&gt; blocks that take longer than 0.1s to execute. In general, you should keep &lt;code&gt;:init&lt;/code&gt; forms as simple and quick as possible, and put as much as you can get away with into the &lt;code&gt;:config&lt;/code&gt; block. This way, deferred loading can help your Emacs to start as quickly as possible.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, if an error occurs while initializing or configuring a package, this will not stop your Emacs from loading. Rather, the error will be captured by &lt;code&gt;use-package&lt;/code&gt;, and reported to a special &lt;code&gt;*Warnings*&lt;/code&gt; popup buffer, so that you can debug the situation in an otherwise functional Emacs.&lt;/p&gt; &#xA;&lt;h2&gt;Conditional loading&lt;/h2&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;:if&lt;/code&gt; keyword to predicate the loading and initialization of modules.&lt;/p&gt; &#xA;&lt;p&gt;For example, I only want &lt;code&gt;edit-server&lt;/code&gt; running for my main, graphical Emacs, not for other Emacsen I may start at the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package edit-server&#xA;  :if window-system&#xA;  :init&#xA;  (add-hook &#39;after-init-hook &#39;server-start t)&#xA;  (add-hook &#39;after-init-hook &#39;edit-server-start t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In another example, we can load things conditional on the operating system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package exec-path-from-shell&#xA;  :if (memq window-system &#39;(mac ns))&#xA;  :ensure t&#xA;  :config&#xA;  (exec-path-from-shell-initialize))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;:disabled&lt;/code&gt; keyword can turn off a module you&#39;re having difficulties with, or stop loading something you&#39;re not using at the present time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ess-site&#xA;  :disabled&#xA;  :commands R)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When byte-compiling your &lt;code&gt;.emacs&lt;/code&gt; file, disabled declarations are omitted from the output entirely, to accelerate startup times.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;:when&lt;/code&gt; is provided as an alias for &lt;code&gt;:if&lt;/code&gt;, and &lt;code&gt;:unless foo&lt;/code&gt; means the same thing as &lt;code&gt;:if (not foo)&lt;/code&gt;. For example, the following will also stop &lt;code&gt;:ensure&lt;/code&gt; from happening on Mac systems:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(when (memq window-system &#39;(mac ns))&#xA;  (use-package exec-path-from-shell&#xA;    :ensure t&#xA;    :config&#xA;    (exec-path-from-shell-initialize)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Conditional loading before :preface&lt;/h3&gt; &#xA;&lt;p&gt;If you need to conditionalize a use-package form so that the condition occurs before even the &lt;code&gt;:preface&lt;/code&gt; is executed, simply use &lt;code&gt;when&lt;/code&gt; around the use-package form itself:&lt;/p&gt; &#xA;&lt;h3&gt;Loading packages in sequence&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes it only makes sense to configure a package after another has been loaded, because certain variables or functions are not in scope until that time. This can achieved using an &lt;code&gt;:after&lt;/code&gt; keyword that allows a fairly rich description of the exact conditions when loading should occur. Here is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package hydra&#xA;  :load-path &#34;site-lisp/hydra&#34;)&#xA;&#xA;(use-package ivy&#xA;  :load-path &#34;site-lisp/swiper&#34;)&#xA;&#xA;(use-package ivy-hydra&#xA;  :after (ivy hydra))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, because all of these packages are demand-loaded in the order they occur, the use of &lt;code&gt;:after&lt;/code&gt; is not strictly necessary. By using it, however, the above code becomes order-independent, without an implicit depedence on the nature of your init file.&lt;/p&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;:after (foo bar)&lt;/code&gt; is the same as &lt;code&gt;:after (:all foo bar)&lt;/code&gt;, meaning that loading of the given package will not happen until both &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; have been loaded. Here are some of the other possibilities:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;:after (foo bar)&#xA;:after (:all foo bar)&#xA;:after (:any foo bar)&#xA;:after (:all (:any foo bar) (:any baz quux))&#xA;:after (:any (:all foo bar) (:all baz quux))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you nest selectors, such as &lt;code&gt;(:any (:all foo bar) (:all baz quux))&lt;/code&gt;, it means that the package will be loaded when either both &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; have been loaded, or both &lt;code&gt;baz&lt;/code&gt; and &lt;code&gt;quux&lt;/code&gt; have been loaded.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: pay attention if you set &lt;code&gt;use-package-always-defer&lt;/code&gt; to t, and also use the &lt;code&gt;:after&lt;/code&gt; keyword, as you will need to specify how the declared package is to be loaded: e.g., by some &lt;code&gt;:bind&lt;/code&gt;. If you&#39;re not using one of the mechanisms that registers autoloads, such as &lt;code&gt;:bind&lt;/code&gt; or &lt;code&gt;:hook&lt;/code&gt;, and your package manager does not provide autoloads, it&#39;s possible that without adding &lt;code&gt;:demand t&lt;/code&gt; to those declarations, your package will never be loaded.&lt;/p&gt; &#xA;&lt;h3&gt;Prevent loading if dependencies are missing&lt;/h3&gt; &#xA;&lt;p&gt;While the &lt;code&gt;:after&lt;/code&gt; keyword delays loading until the dependencies are loaded, the somewhat simpler &lt;code&gt;:requires&lt;/code&gt; keyword simply never loads the package if the dependencies are not available at the time the &lt;code&gt;use-package&lt;/code&gt; declaration is encountered. By &#34;available&#34; in this context it means that &lt;code&gt;foo&lt;/code&gt; is available if &lt;code&gt;(featurep &#39;foo)&lt;/code&gt; evaluates to a non-nil value. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package abbrev&#xA;  :requires foo)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is the same as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package abbrev&#xA;  :if (featurep &#39;foo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As a convenience, a list of such packages may be specified:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package abbrev&#xA;  :requires (foo bar baz))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more complex logic, such as that supported by &lt;code&gt;:after&lt;/code&gt;, simply use &lt;code&gt;:if&lt;/code&gt; and the appropriate Lisp expression.&lt;/p&gt; &#xA;&lt;h2&gt;Byte-compiling your .emacs&lt;/h2&gt; &#xA;&lt;p&gt;Another feature of &lt;code&gt;use-package&lt;/code&gt; is that it always loads every file that it can when &lt;code&gt;.emacs&lt;/code&gt; is being byte-compiled. This helps to silence spurious warnings about unknown variables and functions.&lt;/p&gt; &#xA;&lt;p&gt;However, there are times when this is just not enough. For those times, use the &lt;code&gt;:defines&lt;/code&gt; and &lt;code&gt;:functions&lt;/code&gt; keywords to introduce dummy variable and function declarations solely for the sake of the byte-compiler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package texinfo&#xA;  :defines texinfo-section-list&#xA;  :commands texinfo-mode&#xA;  :init&#xA;  (add-to-list &#39;auto-mode-alist &#39;(&#34;\\.texi$&#34; . texinfo-mode)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to silence a missing function warning, you can use &lt;code&gt;:functions&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ruby-mode&#xA;  :mode &#34;\\.rb\\&#39;&#34;&#xA;  :interpreter &#34;ruby&#34;&#xA;  :functions inf-ruby-keys&#xA;  :config&#xA;  (defun my-ruby-mode-hook ()&#xA;    (require &#39;inf-ruby)&#xA;    (inf-ruby-keys))&#xA;&#xA;  (add-hook &#39;ruby-mode-hook &#39;my-ruby-mode-hook))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Prevent a package from loading at compile-time&lt;/h3&gt; &#xA;&lt;p&gt;Normally, &lt;code&gt;use-package&lt;/code&gt; will load each package at compile time before compiling the configuration, to ensure that any necessary symbols are in scope to satisfy the byte-compiler. At times this can cause problems, since a package may have special loading requirements, and all that you want to use &lt;code&gt;use-package&lt;/code&gt; for is to add a configuration to the &lt;code&gt;eval-after-load&lt;/code&gt; hook. In such cases, use the &lt;code&gt;:no-require&lt;/code&gt; keyword:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package foo&#xA;  :no-require t&#xA;  :config&#xA;  (message &#34;This is evaluated when `foo&#39; is loaded&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Extending the load-path&lt;/h2&gt; &#xA;&lt;p&gt;If your package needs a directory added to the &lt;code&gt;load-path&lt;/code&gt; in order to load, use &lt;code&gt;:load-path&lt;/code&gt;. This takes a symbol, a function, a string or a list of strings. If the path is relative, it is expanded within &lt;code&gt;user-emacs-directory&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ess-site&#xA;  :load-path &#34;site-lisp/ess/lisp/&#34;&#xA;  :commands R)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: when using a symbol or a function to provide a dynamically generated list of paths, you must inform the byte-compiler of this definition so the value is available at byte-compilation time. This is done by using the special form &lt;code&gt;eval-and-compile&lt;/code&gt; (as opposed to &lt;code&gt;eval-when-compile&lt;/code&gt;). Further, this value is fixed at whatever was determined during compilation, to avoid looking up the same information again on each startup:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(eval-and-compile&#xA;  (defun ess-site-load-path ()&#xA;    (shell-command &#34;find ~ -path ess/lisp&#34;)))&#xA;&#xA;(use-package ess-site&#xA;  :load-path (lambda () (list (ess-site-load-path)))&#xA;  :commands R)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Catching errors during use-package expansion&lt;/h2&gt; &#xA;&lt;p&gt;By default, if &lt;code&gt;use-package-expand-minimally&lt;/code&gt; is nil (the default), use-package will attempts to catch and report errors that occur during expansion of use-package declarations in your init file. Setting &lt;code&gt;use-package-expand-minimally&lt;/code&gt; to t completely disables this checking.&lt;/p&gt; &#xA;&lt;p&gt;This behavior may be overridden locally using the &lt;code&gt;:catch&lt;/code&gt; keyword. If &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;, it enables or disables catching errors at load time. It can also be a function taking two arguments: the keyword being processed at the time the error was encountered, and the error object (as generated by &lt;code&gt;condition-case&lt;/code&gt;). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package example&#xA;  ;; Note that errors are never trapped in the preface, since doing so would&#xA;  ;; hide definitions from the byte-compiler.&#xA;  :preface (message &#34;I&#39;m here at byte-compile and load time.&#34;)&#xA;  :init (message &#34;I&#39;m always here at startup&#34;)&#xA;  :config&#xA;  (message &#34;I&#39;m always here after the package is loaded&#34;)&#xA;  (error &#34;oops&#34;)&#xA;  ;; Don&#39;t try to (require &#39;example), this is just an example!&#xA;  :no-require t&#xA;  :catch (lambda (keyword err)&#xA;           (message (error-message-string err))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Evaluating the above form will print these messages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;I’m here at byte-compile and load time.&#xA;I’m always here at startup&#xA;Configuring package example...&#xA;I’m always here after the package is loaded&#xA;oops&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Diminishing and delighting minor modes&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;use-package&lt;/code&gt; also provides built-in support for the diminish and delight utilities -- if you have them installed. Their purpose is to remove or change minor mode strings in your mode-line.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/myrjola/diminish.el&#34;&gt;diminish&lt;/a&gt; is invoked with the &lt;code&gt;:diminish&lt;/code&gt; keyword, which is passed either a minor mode symbol, a cons of the symbol and its replacement string, or just a replacement string, in which case the minor mode symbol is guessed to be the package name with &#34;-mode&#34; appended at the end:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package abbrev&#xA;  :diminish abbrev-mode&#xA;  :config&#xA;  (if (file-exists-p abbrev-file-name)&#xA;      (quietly-read-abbrev-file)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://elpa.gnu.org/packages/delight.html&#34;&gt;delight&lt;/a&gt; is invoked with the &lt;code&gt;:delight&lt;/code&gt; keyword, which is passed a minor mode symbol, a replacement string or quoted &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Data.html&#34;&gt;mode-line data&lt;/a&gt; (in which case the minor mode symbol is guessed to be the package name with &#34;-mode&#34; appended at the end), both of these, or several lists of both. If no arguments are provided, the default mode name is hidden completely.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; Don&#39;t show anything for rainbow-mode.&#xA;(use-package rainbow-mode&#xA;  :delight)&#xA;&#xA;;; Don&#39;t show anything for auto-revert-mode, which doesn&#39;t match&#xA;;; its package name.&#xA;(use-package autorevert&#xA;  :delight auto-revert-mode)&#xA;&#xA;;; Remove the mode name for projectile-mode, but show the project name.&#xA;(use-package projectile&#xA;  :delight &#39;(:eval (concat &#34; &#34; (projectile-project-name))))&#xA;&#xA;;; Completely hide visual-line-mode and change auto-fill-mode to &#34; AF&#34;.&#xA;(use-package emacs&#xA;  :delight&#xA;  (auto-fill-function &#34; AF&#34;)&#xA;  (visual-line-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Package installation&lt;/h2&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;use-package&lt;/code&gt; to load packages from ELPA with &lt;code&gt;package.el&lt;/code&gt;. This is particularly useful if you share your &lt;code&gt;.emacs&lt;/code&gt; among several machines; the relevant packages are downloaded automatically once declared in your &lt;code&gt;.emacs&lt;/code&gt;. The &lt;code&gt;:ensure&lt;/code&gt; keyword causes the package(s) to be installed automatically if not already present on your system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package magit&#xA;  :ensure t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to install a different package from the one named by &lt;code&gt;use-package&lt;/code&gt;, you can specify it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package tex&#xA;  :ensure auctex)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable &lt;code&gt;use-package-always-ensure&lt;/code&gt; if you wish this behavior to be global for all packages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;use-package-ensure)&#xA;(setq use-package-always-ensure t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;:ensure&lt;/code&gt; will install a package if it is not already installed, but it does not keep it up-to-date. If you want to keep your packages updated automatically, one option is to use &lt;a href=&#34;https://github.com/rranelli/auto-package-update.el&#34;&gt;auto-package-update&lt;/a&gt;, like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package auto-package-update&#xA;  :config&#xA;  (setq auto-package-update-delete-old-versions t)&#xA;  (setq auto-package-update-hide-results t)&#xA;  (auto-package-update-maybe))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lastly, when running on Emacs 24.4 or later, use-package can pin a package to a specific archive, allowing you to mix and match packages from different archives. The primary use-case for this is preferring packages from the &lt;code&gt;melpa-stable&lt;/code&gt; and &lt;code&gt;gnu&lt;/code&gt; archives, but using specific packages from &lt;code&gt;melpa&lt;/code&gt; when you need to track newer versions than what is available in the &lt;code&gt;stable&lt;/code&gt; archives is also a valid use-case.&lt;/p&gt; &#xA;&lt;p&gt;By default &lt;code&gt;package.el&lt;/code&gt; prefers &lt;code&gt;melpa&lt;/code&gt; over &lt;code&gt;melpa-stable&lt;/code&gt; due to the versioning &lt;code&gt;(&amp;gt; evil-20141208.623 evil-1.0.9)&lt;/code&gt;, so even if you are tracking only a single package from &lt;code&gt;melpa&lt;/code&gt;, you will need to tag all the non-&lt;code&gt;melpa&lt;/code&gt; packages with the appropriate archive. If this really annoys you, then you can set &lt;code&gt;use-package-always-pin&lt;/code&gt; to set a default.&lt;/p&gt; &#xA;&lt;p&gt;If you want to manually keep a package updated and ignore upstream updates, you can pin it to &lt;code&gt;manual&lt;/code&gt;, which as long as there is no repository by that name, will Just Work(tm).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;use-package&lt;/code&gt; throws an error if you try to pin a package to an archive that has not been configured using &lt;code&gt;package-archives&lt;/code&gt; (apart from the magic &lt;code&gt;manual&lt;/code&gt; archive mentioned above):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Archive &#39;foo&#39; requested for package &#39;bar&#39; is not available.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package company&#xA;  :ensure t&#xA;  :pin melpa-stable)&#xA;&#xA;(use-package evil&#xA;  :ensure t)&#xA;  ;; no :pin needed, as package.el will choose the version in melpa&#xA;&#xA;(use-package adaptive-wrap&#xA;  :ensure t&#xA;  ;; as this package is available only in the gnu archive, this is&#xA;  ;; technically not needed, but it helps to highlight where it&#xA;  ;; comes from&#xA;  :pin gnu)&#xA;&#xA;(use-package org&#xA;  :ensure t&#xA;  ;; ignore org-mode from upstream and use a manually installed version&#xA;  :pin manual)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: the &lt;code&gt;:pin&lt;/code&gt; argument has no effect on emacs versions &amp;lt; 24.4.&lt;/p&gt; &#xA;&lt;h3&gt;Usage with other package managers&lt;/h3&gt; &#xA;&lt;p&gt;By overriding &lt;code&gt;use-package-ensure-function&lt;/code&gt; and/or &lt;code&gt;use-package-pre-ensure-function&lt;/code&gt;, other package managers can override &lt;code&gt;:ensure&lt;/code&gt; to use them instead of &lt;code&gt;package.el&lt;/code&gt;. At the present time, the only package manager that does this is &lt;a href=&#34;https://github.com/raxod502/straight.el&#34;&gt;&lt;code&gt;straight.el&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Gathering Statistics&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;d like to see how many packages you&#39;ve loaded, what stage of initialization they&#39;ve reached, and how much aggregate time they&#39;ve spent (roughly), you can enable &lt;code&gt;use-package-compute-statistics&lt;/code&gt; after loading &lt;code&gt;use-package&lt;/code&gt; but before any &lt;code&gt;use-package&lt;/code&gt; forms, and then run the command &lt;code&gt;M-x use-package-report&lt;/code&gt; to see the results. The buffer displayed is a tabulated list. You can use &lt;code&gt;S&lt;/code&gt; in a column to sort the rows based on it.&lt;/p&gt; &#xA;&lt;h2&gt;Keyword Extensions&lt;/h2&gt; &#xA;&lt;p&gt;Starting with version 2.0, &lt;code&gt;use-package&lt;/code&gt; is based on an extensible framework that makes it easy for package authors to add new keywords, or modify the behavior of existing keywords.&lt;/p&gt; &#xA;&lt;p&gt;Some keyword extensions are now included in the &lt;code&gt;use-package&lt;/code&gt; distribution and can be optionally installed.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;(use-package-ensure-system-package)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:ensure-system-package&lt;/code&gt; keyword allows you to ensure system binaries exist alongside your package declarations.&lt;/p&gt; &#xA;&lt;p&gt;First, you will want to make sure &lt;code&gt;exec-path&lt;/code&gt; is cognisant of all binary package names that you would like to ensure are installed. &lt;a href=&#34;https://github.com/purcell/exec-path-from-shell&#34;&gt;&lt;code&gt;exec-path-from-shell&lt;/code&gt;&lt;/a&gt; is often a good way to do this.&lt;/p&gt; &#xA;&lt;p&gt;To enable the extension after you&#39;ve loaded &lt;code&gt;use-package&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package use-package-ensure-system-package&#xA;  :ensure t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here’s an example of usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package rg&#xA;  :ensure-system-package rg)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will expect a global binary package to exist called &lt;code&gt;rg&lt;/code&gt;. If it does not, it will use your system package manager (using the package &lt;a href=&#34;https://gitlab.com/jabranham/system-packages&#34;&gt;&lt;code&gt;system-packages&lt;/code&gt;&lt;/a&gt;) to attempt an install of a binary by the same name asynchronously. For example, for most &lt;code&gt;macOS&lt;/code&gt; users this would call: &lt;code&gt;brew install rg&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If the package is named differently than the binary, you can use a cons in the form of &lt;code&gt;(binary . package-name)&lt;/code&gt;, i.e.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package rg&#xA;  :ensure-system-package&#xA;  (rg . ripgrep))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the previous &lt;code&gt;macOS&lt;/code&gt; example, this would call: &lt;code&gt;brew install ripgrep&lt;/code&gt; if &lt;code&gt;rg&lt;/code&gt; was not found.&lt;/p&gt; &#xA;&lt;p&gt;What if you want to customize the install command further?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package tern&#xA;  :ensure-system-package (tern . &#34;npm i -g tern&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;:ensure-system-package&lt;/code&gt; can also take a cons where its &lt;code&gt;cdr&lt;/code&gt; is a string that will get called by &lt;code&gt;(async-shell-command)&lt;/code&gt; to install if it isn’t found.&lt;/p&gt; &#xA;&lt;p&gt;You may also pass in a list of cons-es:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package ruby-mode&#xA;  :ensure-system-package&#xA;  ((rubocop     . &#34;gem install rubocop&#34;)&#xA;   (ruby-lint   . &#34;gem install ruby-lint&#34;)&#xA;   (ripper-tags . &#34;gem install ripper-tags&#34;)&#xA;   (pry         . &#34;gem install pry&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, in case the package dependency does not provide a global executable, you can ensure packages exist by checking the presence of a file path by providing a string like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package dash-at-point&#xA;  :if (eq system-type &#39;darwin)&#xA;  :ensure-system-package&#xA;  (&#34;/Applications/Dash.app&#34; . &#34;brew cask install dash&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;:ensure-system-package&lt;/code&gt; will use &lt;code&gt;system-packages-install&lt;/code&gt; to install system packages, except where a custom command has been specified, in which case it will be executed verbatim by &lt;code&gt;async-shell-command&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Configuration variables &lt;code&gt;system-packages-package-manager&lt;/code&gt; and &lt;code&gt;system-packages-use-sudo&lt;/code&gt; will be honoured, but not for custom commands. Custom commands should include the call to sudo in the command if needed.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;(use-package-chords)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:chords&lt;/code&gt; keyword allows you to define &lt;a href=&#34;http://www.emacswiki.org/emacs/key-chord.el&#34;&gt;&lt;code&gt;key-chord&lt;/code&gt;&lt;/a&gt; bindings for &lt;code&gt;use-package&lt;/code&gt; declarations in the same manner as the &lt;code&gt;:bind&lt;/code&gt; keyword.&lt;/p&gt; &#xA;&lt;p&gt;To enable the extension:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package use-package-chords&#xA;  :ensure t&#xA;  :config (key-chord-mode 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can define your chord bindings in the same manner as &lt;code&gt;:bind&lt;/code&gt; using a cons or a list of conses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package ace-jump-mode&#xA;  :chords ((&#34;jj&#34; . ace-jump-char-mode)&#xA;           (&#34;jk&#34; . ace-jump-word-mode)&#xA;           (&#34;jl&#34; . ace-jump-line-mode)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to create an extension&lt;/h3&gt; &#xA;&lt;h4&gt;First step: Add the keyword&lt;/h4&gt; &#xA;&lt;p&gt;The first step is to add your keyword at the right place in &lt;code&gt;use-package-keywords&lt;/code&gt;. This list determines the order in which things will happen in the expanded code. You should never change this order, but it gives you a framework within which to decide when your keyword should fire.&lt;/p&gt; &#xA;&lt;h4&gt;Second step: Create a normalizer&lt;/h4&gt; &#xA;&lt;p&gt;Define a normalizer for your keyword by defining a function named after the keyword, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun use-package-normalize/:pin (name-symbol keyword args)&#xA;  (use-package-only-one (symbol-name keyword) args&#xA;    (lambda (label arg)&#xA;      (cond&#xA;       ((stringp arg) arg)&#xA;       ((symbolp arg) (symbol-name arg))&#xA;       (t&#xA;        (use-package-error&#xA;         &#34;:pin wants an archive name (a string)&#34;))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The job of the normalizer is take a list of arguments (possibly nil), and turn it into the single argument (which could still be a list) that should appear in the final property list used by &lt;code&gt;use-package&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Third step: Create a handler&lt;/h4&gt; &#xA;&lt;p&gt;Once you have a normalizer, you must create a handler for the keyword:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun use-package-handler/:pin (name-symbol keyword archive-name rest state)&#xA;  (let ((body (use-package-process-keywords name-symbol rest state)))&#xA;    ;; This happens at macro expansion time, not when the expanded code is&#xA;    ;; compiled or evaluated.&#xA;    (if (null archive-name)&#xA;        body&#xA;      (use-package-pin-package name-symbol archive-name)&#xA;      (use-package-concat&#xA;       body&#xA;       `((push &#39;(,name-symbol . ,archive-name)&#xA;               package-pinned-packages))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Handlers can affect the handling of keywords in two ways. First, it can modify the &lt;code&gt;state&lt;/code&gt; plist before recursively processing the remaining keywords, to influence keywords that pay attention to the state (one example is the state keyword &lt;code&gt;:deferred&lt;/code&gt;, not to be confused with the &lt;code&gt;use-package&lt;/code&gt; keyword &lt;code&gt;:defer&lt;/code&gt;). Then, once the remaining keywords have been handled and their resulting forms returned, the handler may manipulate, extend, or just ignore those forms.&lt;/p&gt; &#xA;&lt;p&gt;The task of each handler is to return a &lt;em&gt;list of forms&lt;/em&gt; representing code to be inserted. It does not need to be a &lt;code&gt;progn&lt;/code&gt; list, as this is handled automatically in other places. Thus it is very common to see the idiom of using &lt;code&gt;use-package-concat&lt;/code&gt; to add new functionality before or after a code body, so that only the minimum code necessary is emitted as the result of a &lt;code&gt;use-package&lt;/code&gt; expansion.&lt;/p&gt; &#xA;&lt;h4&gt;Fourth step: Test it out&lt;/h4&gt; &#xA;&lt;p&gt;After the keyword has been inserted into &lt;code&gt;use-package-keywords&lt;/code&gt;, and a normalizer and a handler defined, you can now test it by seeing how usages of the keyword will expand. For this, use &lt;code&gt;M-x pp-macroexpand-last-sexp&lt;/code&gt; with the cursor set immediately after the &lt;code&gt;(use-package ...)&lt;/code&gt; expression.&lt;/p&gt; &#xA;&lt;h2&gt;Some timing results&lt;/h2&gt; &#xA;&lt;p&gt;On my Retina iMac, the &#34;Mac port&#34; variant of Emacs 24.4 loads in 0.57s, with around 218 packages configured (nearly all of them lazy-loaded). However, I experience no loss of functionality, just a bit of latency when I&#39;m first starting to use Emacs (due to the autoloading). Since I also use idle-loading for many packages, perceived latency is typically reduced overall.&lt;/p&gt; &#xA;&lt;p&gt;On Linux, the same configuration loads in 0.32s.&lt;/p&gt; &#xA;&lt;p&gt;If I don&#39;t use Emacs graphically, I can test the absolute minimum times. This is done by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;time emacs -l init.elc -batch --eval &#39;(message &#34;Hello, world!&#34;)&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On the Mac I see an average of 0.36s for the same configuration, and on Linux 0.26s.&lt;/p&gt; &#xA;&lt;h1&gt;Upgrading to 2.x&lt;/h1&gt; &#xA;&lt;h2&gt;Semantics of :init is now consistent&lt;/h2&gt; &#xA;&lt;p&gt;The meaning of &lt;code&gt;:init&lt;/code&gt; has been changed: It now &lt;em&gt;always&lt;/em&gt; happens before package load, whether &lt;code&gt;:config&lt;/code&gt; has been deferred or not. This means that some uses of &lt;code&gt;:init&lt;/code&gt; in your configuration may need to be changed to &lt;code&gt;:config&lt;/code&gt; (in the non-deferred case). For the deferred case, the behavior is unchanged from before.&lt;/p&gt; &#xA;&lt;p&gt;Also, because &lt;code&gt;:init&lt;/code&gt; and &lt;code&gt;:config&lt;/code&gt; now mean &#34;before&#34; and &#34;after&#34;, the &lt;code&gt;:pre-&lt;/code&gt; and &lt;code&gt;:post-&lt;/code&gt; keywords are gone, as they should no longer be necessary.&lt;/p&gt; &#xA;&lt;p&gt;Lastly, an effort has been made to make your Emacs start even in the presence of use-package configuration failures. So after this change, be sure to check your &lt;code&gt;*Messages*&lt;/code&gt; buffer. Most likely, you will have several instances where you are using &lt;code&gt;:init&lt;/code&gt;, but should be using &lt;code&gt;:config&lt;/code&gt; (this was the case for me in a number of places).&lt;/p&gt; &#xA;&lt;h2&gt;:idle has been removed&lt;/h2&gt; &#xA;&lt;p&gt;I am removing this feature for now because it can result in a nasty inconsistency. Consider the following definition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package vkill&#xA;  :commands vkill&#xA;  :idle (some-important-configuration-here)&#xA;  :bind (&#34;C-x L&#34; . vkill-and-helm-occur)&#xA;  :init&#xA;  (defun vkill-and-helm-occur ()&#xA;    (interactive)&#xA;    (vkill)&#xA;    (call-interactively #&#39;helm-occur))&#xA;&#xA;  :config&#xA;  (setq vkill-show-all-processes t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If I load my Emacs and wait until the idle timer fires, then this is the sequence of events:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:init :idle &amp;lt;load&amp;gt; :config&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But if I load Emacs and immediately type C-x L without waiting for the idle timer to fire, this is the sequence of events:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:init &amp;lt;load&amp;gt; :config :idle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s possible that the user could use &lt;code&gt;featurep&lt;/code&gt; in their idle to test for this case, but that&#39;s a subtlety I&#39;d rather avoid.&lt;/p&gt; &#xA;&lt;h2&gt;:defer now accepts an optional numeric argument&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;:defer [N]&lt;/code&gt; causes the package to be loaded -- if it has not already been -- after &lt;code&gt;N&lt;/code&gt; seconds of idle time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package back-button&#xA;  :commands (back-button-mode)&#xA;  :defer 2&#xA;  :init&#xA;  (setq back-button-show-toolbar-buttons nil)&#xA;  :config&#xA;  (back-button-mode 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Add :preface, occurring before everything except :disabled&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;:preface&lt;/code&gt; can be used to establish function and variable definitions that will 1) make the byte-compiler happy (it won&#39;t complain about functions whose definitions are unknown because you have them within a guard block), and 2) allow you to define code that can be used in an &lt;code&gt;:if&lt;/code&gt; test.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: whatever is specified within &lt;code&gt;:preface&lt;/code&gt; is evaluated both at load time and at byte-compilation time, in order to ensure that definitions are seen by both the Lisp evaluator and the byte-compiler, so you should avoid having any side-effects in your preface, and restrict it merely to symbol declarations and definitions.&lt;/p&gt; &#xA;&lt;h2&gt;Add :functions, for declaring functions to the byte-compiler&lt;/h2&gt; &#xA;&lt;p&gt;What &lt;code&gt;:defines&lt;/code&gt; does for variables, &lt;code&gt;:functions&lt;/code&gt; does for functions.&lt;/p&gt; &#xA;&lt;h2&gt;use-package.el is no longer needed at runtime&lt;/h2&gt; &#xA;&lt;p&gt;This means you should put the following at the top of your Emacs, to further reduce load time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(eval-when-compile&#xA;  (require &#39;use-package))&#xA;(require &#39;diminish)                ;; if you use :diminish&#xA;(require &#39;bind-key)                ;; if you use any :bind variant&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>alamaison/emacs-cmake-project</title>
    <updated>2022-07-03T02:09:05Z</updated>
    <id>tag:github.com,2022-07-03:/alamaison/emacs-cmake-project</id>
    <link href="https://github.com/alamaison/emacs-cmake-project" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A minor-mode integrating the CMake build process with the Emacs ecosystem.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Emacs CMake project mode&lt;/h1&gt; &#xA;&lt;p&gt;A minor-mode integrating the CMake build process with the Emacs ecosystem.&lt;/p&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;Emacs build tools for C/C++ generally assume a Makefile exists for the project but this isn&#39;t necessarily the case for projects managed by CMake which can generate many different types of project file. Integrates the CMake build process with the existing Emacs tools.&lt;/p&gt; &#xA;&lt;p&gt;This mode is &lt;em&gt;not&lt;/em&gt; for editing the &lt;code&gt;CMakeLists.txt&lt;/code&gt; themselves; that is left to the major-mode &lt;a href=&#34;http://www.cmake.org/CMakeDocs/cmake-mode.el&#34;&gt;&lt;code&gt;cmake-mode&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;p&gt;Copy this file somewhere on your Emacs load path or use &lt;a href=&#34;http://marmalade-repo.org/&#34;&gt;Marmalade&lt;/a&gt; and the package manager to install it.&lt;/p&gt; &#xA;&lt;p&gt;Either auto-load the mode in your init file by adding the line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(autoload &#39;cmake-project-mode &#34;cmake-project&#34; nil t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or simply require the library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;cmake-project)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use &lt;code&gt;M-x cmake-project-mode&lt;/code&gt; in any buffer you wish to use the mode in. Alternatively, start the mode automatically for any C/C++ file whose directory includes a &lt;code&gt;CMakeLists.txt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defun maybe-cmake-project-mode ()&#xA;  (if (or (file-exists-p &#34;CMakeLists.txt&#34;)&#xA;          (file-exists-p (expand-file-name &#34;CMakeLists.txt&#34; (car (project-roots (project-current))))))&#xA;      (cmake-project-mode)))&#xA;&#xA;(add-hook &#39;c-mode-hook &#39;maybe-cmake-project-mode)&#xA;(add-hook &#39;c++-mode-hook &#39;maybe-cmake-project-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;h1&gt;Configuring build tree&lt;/h1&gt; &#xA;&lt;p&gt;Use &lt;code&gt;M-x cmake-project-configure-project&lt;/code&gt; to configure or reconfigure a CMake build tree. The function finds the source automatically based on the current buffer.&lt;/p&gt; &#xA;&lt;h1&gt;The compile command&lt;/h1&gt; &#xA;&lt;p&gt;This mode makes the &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/emacs/Compilation.html&#34;&gt;compile command&lt;/a&gt;, &lt;code&gt;M-x compile&lt;/code&gt;, build the project by default via CMake in a &lt;code&gt;bin&lt;/code&gt; subdirectory of the project source root directory.&lt;/p&gt; &#xA;&lt;h1&gt;Flymake&lt;/h1&gt; &#xA;&lt;p&gt;This mode integrates with &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/flymake/index.html&#34;&gt;Flymake&lt;/a&gt; so that, when &lt;code&gt;flymake-mode&lt;/code&gt; is enabled, the entire project is built whenever the buffer is saved and any errors are higlighted in the buffer. This is different from Flymake&#39;s typical behaviour which builds only the file for the buffer in question. CMake doesn&#39;t provide a way to build one file at a time (or at least we don&#39;t know of a way) so we must build everything.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacs-evil/evil</title>
    <updated>2022-07-03T02:09:05Z</updated>
    <id>tag:github.com,2022-07-03:/emacs-evil/evil</id>
    <link href="https://github.com/emacs-evil/evil" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The extensible vi layer for Emacs.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/emacs-evil/evil/master/doc/logo.png&#34; alt=&#34;An extensible vi layer for Emacs&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/emacs-evil/evil/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/emacs-evil/evil/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/evil&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/evil-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/evil&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/evil-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://elpa.nongnu.org/nongnu/evil.html&#34;&gt;&lt;img src=&#34;http://elpa.nongnu.org/nongnu/evil.svg?sanitize=true&#34; alt=&#34;NonGNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://evil.readthedocs.io/en/latest/?badge=latest&#34;&gt;&lt;img src=&#34;https://readthedocs.org/projects/evil/badge/?version=latest&#34; alt=&#34;Documentation Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-GPL%20v3-blue.svg?sanitize=true&#34; alt=&#34;License: GPL v3&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Evil is an &lt;strong&gt;e&lt;/strong&gt;xtensible &lt;strong&gt;vi&lt;/strong&gt; &lt;strong&gt;l&lt;/strong&gt;ayer for &lt;a href=&#34;http://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt;. It emulates the main features of &lt;a href=&#34;http://www.vim.org/&#34;&gt;Vim&lt;/a&gt;, and provides facilities for writing custom extensions. Also see our page on &lt;a href=&#34;http://emacswiki.org/emacs/Evil&#34;&gt;EmacsWiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://evil.readthedocs.io/en/latest/overview.html#installation-via-package-el&#34;&gt;official documentation&lt;/a&gt; for installation instructions. We recommend using &lt;em&gt;package.el&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As a quickstart, you can add the following code to your Emacs init file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; Set up package.el to work with MELPA&#xA;(require &#39;package)&#xA;(add-to-list &#39;package-archives&#xA;             &#39;(&#34;melpa&#34; . &#34;https://melpa.org/packages/&#34;))&#xA;(package-initialize)&#xA;(package-refresh-contents)&#xA;&#xA;;; Download Evil&#xA;(unless (package-installed-p &#39;evil)&#xA;  (package-install &#39;evil))&#xA;&#xA;;; Enable Evil&#xA;(require &#39;evil)&#xA;(evil-mode 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Evil requires Emacs 24.1 or later.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Evil requires any of the following for &lt;code&gt;C-r&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;undo-redo&lt;/code&gt; from Emacs 28&lt;/li&gt; &#xA;   &lt;li&gt;The &lt;a href=&#34;https://gitlab.com/tsc25/undo-tree&#34;&gt;undo-tree&lt;/a&gt; package (available via GNU ELPA)&lt;/li&gt; &#xA;   &lt;li&gt;The &lt;a href=&#34;https://gitlab.com/ideasman42/emacs-undo-fu&#34;&gt;undo-fu&lt;/a&gt; package (available via MELPA)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For the motions &lt;code&gt;g;&lt;/code&gt; &lt;code&gt;g,&lt;/code&gt; and for the last-change-register &lt;code&gt;.&lt;/code&gt;, Evil requires the &lt;a href=&#34;https://github.com/emacs-evil/goto-chg&#34;&gt;goto-chg.el&lt;/a&gt; package (available via MELPA and NonGNU ELPA), which provides the functions &lt;code&gt;goto-last-change&lt;/code&gt; and &lt;code&gt;goto-last-change-reverse&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For Emacs 24.1 and 24.2 Evil also requires &lt;a href=&#34;https://elpa.gnu.org/packages/cl-lib.html&#34;&gt;cl-lib&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;The latest version of the documentation is readable online &lt;a href=&#34;https://evil.readthedocs.io/en/latest/index.html&#34;&gt;here&lt;/a&gt;. It is also available as &lt;a href=&#34;https://readthedocs.org/projects/evil/downloads/pdf/latest/&#34;&gt;PDF&lt;/a&gt; and as &lt;a href=&#34;https://readthedocs.org/projects/evil/downloads/epub/latest/&#34;&gt;EPUB&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Mailing list&lt;/h1&gt; &#xA;&lt;p&gt;Evil is discussed at the &lt;a href=&#34;http://lists.ourproject.org/cgi-bin/mailman/listinfo/implementations-list&#34;&gt;gmane.emacs.vim-emulation&lt;/a&gt; mailing list.&lt;/p&gt; &#xA;&lt;h1&gt;IRC&lt;/h1&gt; &#xA;&lt;p&gt;Visit us on &lt;code&gt;irc.libera.chat #evil-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Contribution&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/emacs-evil/evil/raw/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for guidelines for issues and pull requests.&lt;/p&gt;</summary>
  </entry>
</feed>