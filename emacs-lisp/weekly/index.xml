<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-16T01:54:09Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>arnested/php-extras</title>
    <updated>2023-07-16T01:54:09Z</updated>
    <id>tag:github.com,2023-07-16:/arnested/php-extras</id>
    <link href="https://github.com/arnested/php-extras" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Extra features for Emacs `php-mode&#39;.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PHP Extras&lt;/h1&gt; &#xA;&lt;p&gt;A small collection of extra features for Emacs &lt;code&gt;php-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Currently includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;php-extras-insert-previous-variable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;php-extras-eldoc-documentation-function&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Auto complete source for PHP functions based on &lt;code&gt;php-extras-eldoc-documentation-function&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Company completion back-end for PHP functions based on &lt;code&gt;php-extras-eldoc-documentation-function&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;code&gt;php-extras-insert-previous-variable&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;When variable names get too long or you have to juggle a lot of nested arrays it gets cumbersome to repeat the same variables over and over again while programming.&lt;/p&gt; &#xA;&lt;p&gt;In example you have the code below and want to debug what value you actually parsed to &lt;code&gt;some_function()&lt;/code&gt;. You have point at &lt;code&gt;^&lt;/code&gt; and now all you have to write is repeat the variable...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;some_function($my_array[&#39;some_level&#39;][0][&#39;another_level&#39;][7]);&#xA;print_r(^);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enter &lt;code&gt;php-extras&lt;/code&gt; and you just hit &lt;kbd&gt;C-c C-$&lt;/kbd&gt; and it will insert the previous variable (including array indexes).&lt;/p&gt; &#xA;&lt;p&gt;If you prefix the command (i.e. &lt;kbd&gt;C-u 3 C-c C-$&lt;/kbd&gt;) it will search back 3 variables and with negative prefix arguments it will search forward.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;php-extras-eldoc-documentation-function&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;eldoc-mode&lt;/code&gt; is a nice minor mode that ships with Emacs. It will display a function tip in the mini buffer showing the function and its arguments for the function at point. That is if you provide a function to look up the function definition.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;php-extras&lt;/code&gt; provides such a function for looking up all the core PHP functions.&lt;/p&gt; &#xA;&lt;p&gt;The function &lt;code&gt;php-extras-generate-eldoc&lt;/code&gt; will download the &lt;a href=&#34;http://doc.php.net/downloads/json/php_manual_en.json&#34;&gt;PHP function list&lt;/a&gt; and extract the function definitions (slow) and store them in a hash table on disk for you.&lt;/p&gt; &#xA;&lt;p&gt;If you install &lt;code&gt;php-extras&lt;/code&gt; as an ELPA package from &lt;a href=&#34;http://marmalade-repo.org/packages/php-extras&#34;&gt;Marmalade&lt;/a&gt; the hash table is already generated for you.&lt;/p&gt; &#xA;&lt;h2&gt;Auto complete source for PHP functions based&lt;/h2&gt; &#xA;&lt;p&gt;The PHP functions extracted for &lt;code&gt;php-extras-eldoc-documentation-function&lt;/code&gt; is also setup as a source for &lt;a href=&#34;http://cx4a.org/software/auto-complete&#34;&gt;auto-complete&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://cx4a.org/software/auto-complete&#34;&gt;auto-complete&lt;/a&gt; already comes with a dictionary of PHP functions and will auto complete on them using the &lt;code&gt;ac-source-dictionary&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The source we provide with &lt;code&gt;php-extras&lt;/code&gt; will hopefully be more up to date.&lt;/p&gt; &#xA;&lt;h2&gt;Company completion back-end for PHP functions based&lt;/h2&gt; &#xA;&lt;p&gt;Users of &lt;a href=&#34;http://company-mode.github.io/&#34;&gt;company-mode&lt;/a&gt; will also get in-buffer completion based on the extracted PHP functions.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;The easiest way to install &lt;code&gt;php-extras&lt;/code&gt; is probably to install it via the ELPA archive at &lt;a href=&#34;http://marmalade-repo.org/packages/php-extras&#34;&gt;Marmalade&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;ELPA (package.el) is part of Emacs 24. For Emacs 23 see &lt;a href=&#34;http://marmalade-repo.org&#34;&gt;Marmalade&lt;/a&gt; for installation instructions.&lt;/p&gt; &#xA;&lt;p&gt;The version number of the ELPA package will have the date appended when the package was build and hence the date the documentation got extracted from &lt;a href=&#34;http://php.net&#34;&gt;php.net&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Manual installation&lt;/h3&gt; &#xA;&lt;p&gt;I really recommend that you install this package via ELPA as described above.&lt;/p&gt; &#xA;&lt;p&gt;If you insist on installing it manually try to follow this recipe:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Place the folder with the files somewhere on your disk.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add this to your &lt;code&gt;.emacs&lt;/code&gt; / &lt;code&gt;.emacs.d/init.el&lt;/code&gt;:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(add-to-list &#39;load-path &#34;/somewhere/on/your/disk/php-extras&#34;)&#xA;(eval-after-load &#39;php-mode&#xA;  (require &#39;php-extras))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Either restart your Emacs or evaluate the &lt;code&gt;add-to-list&lt;/code&gt; expression.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Generate the hash table containing the PHP functions:&lt;/p&gt; &lt;p&gt;&lt;kbd&gt;M-x load-library RET php-extras-gen-eldoc RET&lt;/kbd&gt;&lt;/p&gt; &lt;p&gt;&lt;kbd&gt;M-x php-extras-generate-eldoc RET&lt;/kbd&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development of PHP Extras&lt;/h2&gt; &#xA;&lt;p&gt;PHP Extras is developed at &lt;a href=&#34;https://github.com/arnested/php-extras&#34;&gt;GitHub&lt;/a&gt;. Feature requests, ideas, bug reports, and pull request are more than welcome!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacs-php/php-auto-yasnippets</title>
    <updated>2023-07-16T01:54:09Z</updated>
    <id>tag:github.com,2023-07-16:/emacs-php/php-auto-yasnippets</id>
    <link href="https://github.com/emacs-php/php-auto-yasnippets" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Dynamically Generated YASnippets for PHP Code in GNU Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Automatic YASnippets for PHP in Emacs&lt;/h1&gt; &#xA;&lt;p&gt;The php-auto-yasnippets package for &lt;a href=&#34;http://www.gnu.org/software/emacs/&#34;&gt;GNU Emacs&lt;/a&gt; will automatically create ‘snippets’ for &lt;a href=&#34;http://php.net/&#34;&gt;standard PHP functions&lt;/a&gt;. It defines these snippets using the &lt;a href=&#34;https://github.com/capitaomorte/yasnippet&#34;&gt;YASnippet package&lt;/a&gt;, with optional support for &lt;a href=&#34;https://github.com/auto-complete/auto-complete&#34;&gt;auto-complete&lt;/a&gt;. For example, if you type the PHP function&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;implode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and press &lt;code&gt;C-c C-y&lt;/code&gt; then php-auto-yasnippets will expand that into&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;implode($glue, $pieces)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;with the cursor ready to overwrite &lt;code&gt;$glue&lt;/code&gt; with the string you want to use. Pressing Tab will skip over to &lt;code&gt;$pieces&lt;/code&gt; to do the same. This way you can be sure you not only have the correct number of arguments, but also that you have them in the correct order. PHP comes with a large standard library and functions that sound similar sometimes require arguments in contrasting orders. This package will help you avoid having to remember those corner cases.&lt;/p&gt; &#xA;&lt;p&gt;If a function has any optional parameters then php-auto-yasnippets will wrap them in square braces. This is the same convention the PHP manual uses to indicate optional parameters. For example, php-auto-yasnippets will expand &lt;code&gt;filter_input&lt;/code&gt; into this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;filter_input($type, $variable_name, [$filter], [$options])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you do not need the optional parameters you can delete them by pressing &lt;code&gt;C-d&lt;/code&gt; when you Tab over to them.&lt;/p&gt; &#xA;&lt;p&gt;You can use the prefix command to expand method names. When you use the prefix, u.g. &lt;code&gt;C-u C-c C-y&lt;/code&gt;, the package will ask you for the name of the class which implements that method. This information is necessary in order to generate the correct snippet.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PHP 5.3 or later&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/capitaomorte/yasnippet&#34;&gt;YASnippet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ejmr/php-mode&#34;&gt;php-mode&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To use php-auto-yasnippets you need to do three things. First, place the package in your load-path (&lt;code&gt;C-h v load-path&lt;/code&gt; for help) and load it from your Emacs configuration file by adding:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;php-auto-yasnippets)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Second, make sure the variable &lt;code&gt;php-auto-yasnippet-php-program&lt;/code&gt; points to the program &lt;code&gt;Create-PHP-YASnippet.php&lt;/code&gt;. That PHP program should have come with this package; if you do not have it then you can get it from the &lt;a href=&#34;https://github.com/ejmr/php-auto-yasnippets&#34;&gt;project website&lt;/a&gt;. By default php-auto-yasnippets will search for the PHP program in the same directory as the Elisp code, i.e. the &lt;code&gt;php-auto-yasnippets.el&lt;/code&gt;. If you want to put the PHP program in another place then use &lt;code&gt;setq&lt;/code&gt; in your configuration file to set the variable to the proper path, e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;php-auto-yasnippets)&#xA;(setq php-auto-yasnippet-php-program &#34;~/path/to/Create-PHP-YASnippet.php&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, bind the function &lt;code&gt;yas/create-php-snippet&lt;/code&gt; to a key of your choice. You &lt;em&gt;must&lt;/em&gt; do this because php-auto-yasnippets defines no key-bindings. And since the package requires php-mode, and is most useful when writing PHP code, you may want to use a key-binding that only works when using php-mode. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(define-key php-mode-map (kbd &#34;C-c C-y&#34;) &#39;yas/create-php-snippet)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now if you type the name of a PHP function and press &lt;code&gt;C-c C-y&lt;/code&gt; it will expand into a snippet containing all of the parameters, their names, any default values, et cetera.&lt;/p&gt; &#xA;&lt;h2&gt;auto-complete&lt;/h2&gt; &#xA;&lt;p&gt;With auto-complete support activated, it&#39;s even simpler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;imp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;followed by &lt;code&gt;Tab&lt;/code&gt;, then &lt;code&gt;Return&lt;/code&gt; (to choose the first completion) expands the snippet to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;implode($glue, $pieces)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;First, install and configure &lt;a href=&#34;https://github.com/auto-complete/auto-complete&#34;&gt;auto-complete&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Add&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(payas/ac-setup)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to your php-auto-yasnippets setup, and you should be good to go.&lt;/p&gt; &#xA;&lt;p&gt;Note that auto-completion does not support user-defined functions or classes (it relies on auto-complete&#39;s php-mode dictionary of functions).&lt;/p&gt; &#xA;&lt;h2&gt;Loading User Code&lt;/h2&gt; &#xA;&lt;p&gt;This package can also generate snippets for user-defined functions and methods.&lt;/p&gt; &#xA;&lt;p&gt;You can tell a buffer what files to load for function and class definitions by setting &lt;code&gt;php-auto-yasnippet-required-files&lt;/code&gt; to a list of required paths.&lt;/p&gt; &#xA;&lt;p&gt;If you use &lt;a href=&#34;http://getcomposer.org/&#34;&gt;Composer&lt;/a&gt;, you might put something like this in &lt;code&gt;~/project/.dir-locals.el&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(php-mode . ((php-auto-yasnippet-required-files (list &#34;~/project/vendor/autoload.php&#34;))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can generate snippets for any classes Composer autoloads, in any PHP file in the project.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://glynnforrest.com&#34;&gt;Glynn Forrest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://yasuyk.github.io/&#34;&gt;Yasuyuki Oka&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.sanityinc.com/&#34;&gt;Steve Purcell&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.nateeag.com/&#34;&gt;Nate Eagleson&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/amcorreia&#34;&gt;Alessandro Madruga Correia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bystrano&#34;&gt;Michel Bystranowski&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/MarTango&#34;&gt;Martin Tang&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Miscellaneous&lt;/h2&gt; &#xA;&lt;p&gt;This package uses &lt;a href=&#34;http://semver.org/&#34;&gt;Semantic Versioning&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.gnu.org/copyleft/gpl.html&#34;&gt;GNU General Public License&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2013, 2014, 2015, 2016, 2017 Eric James Michael Ritz&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>nishimaki10/emacs-phpcbf</title>
    <updated>2023-07-16T01:54:09Z</updated>
    <id>tag:github.com,2023-07-16:/nishimaki10/emacs-phpcbf</id>
    <link href="https://github.com/nishimaki10/emacs-phpcbf" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Format PHP code in Emacs using PHP_CodeSniffer&#39;s phpcbf&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;phpcbf.el &lt;a href=&#34;http://melpa.org/#/phpcbf&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/phpcbf-badge.svg?sanitize=true&#34; alt=&#34;melpa badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/phpcbf&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/phpcbf-badge.svg?sanitize=true&#34; alt=&#34;melpa stable badge&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Format PHP code in Emacs using &lt;a href=&#34;https://github.com/squizlabs/PHP_CodeSniffer&#34;&gt;PHP_CodeSniffer&lt;/a&gt;&#39;s phpcbf.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install &lt;code&gt;phpcbf.el&lt;/code&gt; from &lt;a href=&#34;http://melpa.org&#34;&gt;MELPA&lt;/a&gt; with package.el (&lt;code&gt;M-x package-install phpcbf&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;And you can also install it with &lt;a href=&#34;https://github.com/dimitri/el-get&#34;&gt;el-get&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;phpcbf&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;If called interactively, the current buffer is formatted according to &lt;code&gt;phpcbf-standard&lt;/code&gt;. Default standard is &#34;PEAR&#34;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;phpcbf-enable-on-save&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Add this to init file to run phpcbf on the current buffer when saving:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-hook &#39;php-mode-hook &#39;phpcbf-enable-on-save)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sample Configuration&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;phpcbf)&#xA;&#xA;(custom-set-variables&#xA; &#39;(phpcbf-executable &#34;/usr/local/bin/phpcbf&#34;)&#xA; &#39;(phpcbf-standard &#34;PSR2&#34;))&#xA;&#xA;;; Auto format on save.&#xA;(add-hook &#39;php-mode-hook &#39;phpcbf-enable-on-save)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Customize&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;phpcbf-executable&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Location of &lt;code&gt;phpcbf&lt;/code&gt; command (default is called &lt;code&gt;(executable-find &#34;phpcbf&#34;)&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;phpcbf-standard&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The name or path of the coding standard to use (default is &#34;PEAR&#34;).&lt;/p&gt; &#xA;&lt;p&gt;How to check installed standards:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ phpcbf -i&#xA;The installed coding standards are PSR1, PHPCS, Zend, PEAR, PSR2, Squiz and MySource&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And more your custom standards. &lt;a href=&#34;https://github.com/squizlabs/PHP_CodeSniffer/wiki/Coding-Standard-Tutorial&#34;&gt;See here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;See Also&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/squizlabs/PHP_CodeSniffer&#34;&gt;PHP_CodeSniffer&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;PHP_CodeSniffer tokenizes PHP, JavaScript and CSS files and detects violations of a defined set of coding standards.&lt;/p&gt;</summary>
  </entry>
</feed>