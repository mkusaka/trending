<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-25T01:40:04Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>minad/consult</title>
    <updated>2022-12-25T01:40:04Z</updated>
    <id>tag:github.com,2022-12-25:/minad/consult</id>
    <link href="https://github.com/minad/consult" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üîç consult.el - Consulting completing-read&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: consult.el - Consulting completing-read #+author: Daniel Mendler #+language: en #+export_file_name: consult.texi #+texinfo_dir_category: Emacs misc features #+texinfo_dir_title: Consult: (consult). #+texinfo_dir_desc: Useful commands built on completing-read.&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img alt=&#34;GNU Emacs&#34; src=&#34;https://github.com/minad/corfu/raw/screenshots/emacs.svg?raw=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://elpa.gnu.org/packages/consult.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/consult.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://elpa.gnu.org/devel/consult.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/consult.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/consult&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/consult-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://stable.melpa.org/#/consult&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/consult-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Consult provides practical commands based on the Emacs completion function [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][completing-read]]. Completion allows you to quickly select an item from a list of candidates. Consult offers in particular an advanced buffer switching command =consult-buffer= to switch between buffers and recently opened files. Furthermore Consult provides multiple search commands, an asynchronous =consult-grep= and =consult-ripgrep=, and the line-based search command =consult-line=. Some of the Consult commands are enhanced versions of built-in Emacs commands. For example the command =consult-imenu= presents a flat list of the Imenu with [[#live-previews][live preview]], [[#narrowing-and-grouping][grouping and narrowing]]. Please take a look at the [[#available-commands][full list of commands]].&lt;/p&gt; &#xA;&lt;p&gt;Consult is fully compatible with completion systems centered around the standard Emacs =completing-read= API, notably the default completion system, [[https://github.com/minad/vertico][Vertico]], [[https://github.com/protesilaos/mct][Mct]], and [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Icomplete.html][Icomplete]].&lt;/p&gt; &#xA;&lt;p&gt;This package keeps the completion system specifics to a minimum. The ability of the Consult commands to work well with arbitrary completion systems is one of the main advantages of the package. Consult fits well into existing setups and it helps you to create a full completion environment out of small and independent components.&lt;/p&gt; &#xA;&lt;p&gt;You can combine the complementary packages [[https://github.com/minad/marginalia/][Marginalia]], [[https://github.com/oantolin/embark/][Embark]] and [[https://github.com/oantolin/orderless][Orderless]] with Consult. Marginalia enriches the completion display with annotations, e.g., documentation strings or file information. The versatile Embark package provides local actions, comparable to a context menu. These actions operate on the selected candidate in the minibuffer or at point in normal buffers. For example, when selecting from a list of files, Embark offers an action to delete the file. Additionally Embark offers a facility to collect completion candidates in a collect buffer. The section [[#embark-integration][Embark integration]] documents in greater detail how Consult and Embark work together.&lt;/p&gt; &#xA;&lt;p&gt;#+toc: headlines 8&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Screenshots :noexport:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+caption: consult-grep [[https://github.com/minad/consult/blob/screenshots/consult-grep.gif?raw=true]] Fig. 1: Command =consult-git-grep=&lt;/p&gt; &#xA;&lt;p&gt;#+caption: consult-imenu [[https://github.com/minad/consult/blob/screenshots/consult-imenu.png?raw=true]] Fig. 2: Command =consult-imenu=&lt;/p&gt; &#xA;&lt;p&gt;#+caption: consult-line [[https://github.com/minad/consult/blob/screenshots/consult-line.png?raw=true]] Fig. 3: Command =consult-line=&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Available commands :properties: :custom_id: available-commands :description: Navigation, search, editing commands and more &lt;span&gt;üîö&lt;/span&gt; #+cindex: commands&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Most Consult commands follow the meaningful naming scheme =consult-&#xA; &lt;thing&gt;&#xA;  =. Many commands implement a little known but convenient Emacs feature called &#34;future history&#34;, which guesses what input the user wants. At a command prompt type =M-n= and typically Consult will insert the symbol or thing at point into the input.&#xA; &lt;/thing&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;TIP:&lt;/em&gt; If you have [[https://github.com/minad/marginalia][Marginalia]] annotators activated, type =M-x ^consult= to see all Consult commands with their abbreviated description. Alternatively, type =C-h a ^consult= to get an overview of all Consult variables and functions with their descriptions.&lt;/p&gt; &#xA;&lt;p&gt;** Virtual Buffers :properties: :description: Buffers, bookmarks and recent files &lt;span&gt;üîö&lt;/span&gt; #+cindex: virtual buffers&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-buffer #+findex: consult-buffer-other-window #+findex: consult-buffer-other-frame #+findex: consult-project-buffer #+findex: consult-recent-file #+findex: consult-bookmark&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-buffer= (=-other-window=, =-other-frame=): Enhanced version of =switch-to-buffer= with support for virtual buffers. Supports live preview of buffers and narrowing to the virtual buffer types. You can type =f SPC= in order to narrow to recent files. Press =SPC= to show ephemeral buffers. Supported narrowing keys: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;b Buffers&lt;/li&gt; &#xA;   &lt;li&gt;SPC Hidden buffers&lt;/li&gt; &#xA;   &lt;li&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Modified buffers&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;f Files (Requires =recentf-mode=)&lt;/li&gt; &#xA;   &lt;li&gt;r File registers&lt;/li&gt; &#xA;   &lt;li&gt;m Bookmarks&lt;/li&gt; &#xA;   &lt;li&gt;p Project&lt;/li&gt; &#xA;   &lt;li&gt;Custom [[#multiple-sources][other sources]] configured in =consult-buffer-sources=.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;=consult-project-buffer=: Variant of =consult-buffer= restricted to buffers and recent files of the current project. You can add custom sources to =consult-project-buffer-sources=. The command may prompt you for a project if you invoke it from outside a project.&lt;/li&gt; &#xA; &lt;li&gt;=consult-bookmark=: Select or create bookmark. To select bookmarks you might use the =consult-buffer= as an alternative, which can include a bookmark virtual buffer source. Note that =consult-bookmark= supports preview of bookmarks and narrowing.&lt;/li&gt; &#xA; &lt;li&gt;=consult-recent-file=: Select from recent files with preview. You might prefer the powerful =consult-buffer= instead, which can include recent files as a virtual buffer source. The =recentf-mode= enables tracking of recent files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Editing :properties: :description: Commands useful for editing &lt;span&gt;üîö&lt;/span&gt; #+cindex: editing&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-yank-pop #+findex: consult-yank-from-kill-ring #+findex: consult-yank-replace #+findex: consult-kmacro&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-yank-from-kill-ring=: Enhanced version of =yank= to select an item from the =kill-ring=. The selected text previewed as overlay in the buffer.&lt;/li&gt; &#xA; &lt;li&gt;=consult-yank-pop=: Enhanced version of =yank-pop= with DWIM-behavior, which either replaces the last =yank= by cycling through the =kill-ring=, or if there has not been a last =yank= consults the =kill-ring=. The selected text previewed as overlay in the buffer.&lt;/li&gt; &#xA; &lt;li&gt;=consult-yank-replace=: Like =consult-yank-pop=, but always replaces the last =yank= with an item from the =kill-ring=.&lt;/li&gt; &#xA; &lt;li&gt;=consult-kmacro=: Select macro from the macro ring and execute it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Register :properties: :description: Searching through registers and fast access &lt;span&gt;üîö&lt;/span&gt; #+cindex: register&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-register #+findex: consult-register-load #+findex: consult-register-store #+findex: consult-register-format #+findex: consult-register-window&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-register=: Select from list of registers. The command supports narrowing to register types and preview of marker positions. This command is useful to search the register contents. For quick access use the commands =consult-register-load=, =consult-register-store= or the built-in Emacs register commands.&lt;/li&gt; &#xA; &lt;li&gt;=consult-register-format=: Set =register-preview-function= to this function for an enhanced register formatting. See the [[#use-package-example][example configuration]].&lt;/li&gt; &#xA; &lt;li&gt;=consult-register-window=: Replace =register-preview= with this function for a better register window. See the [[#use-package-example][example configuration]].&lt;/li&gt; &#xA; &lt;li&gt;=consult-register-load=: Utility command to quickly load a register. The command either jumps to the register value or inserts it.&lt;/li&gt; &#xA; &lt;li&gt;=consult-register-store=: Improved UI to store registers depending on the current context with an action menu. With an active region, store/append/prepend the contents, optionally deleting the region when a prefix argument is given. With a numeric prefix argument, store/add the number. Otherwise store point, frameset, window or kmacro. Usage examples: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;=M-&#39; x=: If no region is active, store point in register =x=. If a region is active, store the region in register =x=.&lt;/li&gt; &#xA;   &lt;li&gt;=M-&#39; M-w x=: Store window configuration in register =x=.&lt;/li&gt; &#xA;   &lt;li&gt;=C-u 100 M-&#39; x=: Store number in register =x=.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Navigation :properties: :description: Mark rings, outlines and imenu &lt;span&gt;üîö&lt;/span&gt; #+cindex: navigation&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-goto-line #+findex: consult-mark #+findex: consult-global-mark #+findex: consult-outline #+findex: consult-imenu #+findex: consult-imenu-multi&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-goto-line=: Jump to line number enhanced with live preview. This is a drop-in replacement for =goto-line=.&lt;/li&gt; &#xA; &lt;li&gt;=consult-mark=: Jump to a marker in the =mark-ring=. Supports live preview and recursive editing.&lt;/li&gt; &#xA; &lt;li&gt;=consult-global-mark=: Jump to a marker in the =global-mark-ring=. Supports live preview and recursive editing.&lt;/li&gt; &#xA; &lt;li&gt;=consult-outline=: Jump to a heading of the outline. Supports narrowing to a heading level, live preview and recursive editing.&lt;/li&gt; &#xA; &lt;li&gt;=consult-imenu=: Jump to imenu item in the current buffer. Supports live preview, recursive editing and narrowing.&lt;/li&gt; &#xA; &lt;li&gt;=consult-imenu-multi=: Jump to imenu item in project buffers, with the same major mode as the current buffer. Supports live preview, recursive editing and narrowing. This feature has been inspired by [[https://github.com/vspinu/imenu-anywhere][imenu-anywhere]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Search :properties: :description: Line search, grep and file search &lt;span&gt;üîö&lt;/span&gt; #+cindex: search&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-line #+findex: consult-line-multi #+findex: consult-keep-lines #+findex: consult-focus-lines&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-line=: Enter search string and select from matching lines. Supports live preview and recursive editing. The symbol at point and the recent Isearch string are added to the &#34;future history&#34; and can be accessed by pressing =M-n=. When =consult-line= is bound to the =isearch-mode-map= and is invoked during a running Isearch, it will use the current Isearch string.&lt;/li&gt; &#xA; &lt;li&gt;=consult-line-multi=: Search dynamically across multiple buffers. By default search across project buffers. If invoked with a prefix argument search across all buffers. The candidates are computed on demand based on the input. The command behaves like =consult-grep=, but operates on buffers instead of files.&lt;/li&gt; &#xA; &lt;li&gt;=consult-keep-lines=: Replacement for =keep/flush-lines= which uses the current completion style for filtering the buffer. The function updates the buffer while typing. In particular =consult-keep-lines= can narrow down an exported Embark collect buffer further, relying on the same completion filtering as &lt;del&gt;completing-read&lt;/del&gt;. If the input begins with the negation operator, i.e., &lt;del&gt;! SPC&lt;/del&gt;, the filter matches the complement. If a region is active, the region restricts the filtering.&lt;/li&gt; &#xA; &lt;li&gt;=consult-focus-lines=: Temporarily hide lines by filtering them using the current completion style. Call with =C-u= prefix argument in order to show the hidden lines again. If the input begins with the negation operator, i.e., &lt;del&gt;! SPC&lt;/del&gt;, the filter matches the complement. In contrast to =consult-keep-lines= this function does not edit the buffer. If a region is active, the region restricts the filtering.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Grep and Find :properties: :description: Searching through the filesystem &lt;span&gt;üîö&lt;/span&gt; #+cindex: grep #+cindex: find #+cindex: locate&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-grep #+findex: consult-ripgrep #+findex: consult-git-grep #+findex: consult-find #+findex: consult-locate&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-grep=, =consult-ripgrep=, =consult-git-grep=: Search for regular expression in files. Consult invokes Grep asynchronously, while you enter the search term. After at least =consult-async-min-input= characters, the search gets started. Consult splits the input string into two parts, if the first character is a punctuation character, like =#=. For example =#regexps#filter-string=, is split at the second =#=. The string =regexps= is passed to Grep. Note that Consult transforms Emacs regular expressions to expressions understand by the search program. Always use Emacs regular expressions at the prompt. If you enter multiple regular expressions separated by space only lines matching all regular expressions are shown. In order to match space literally, escape the space with a backslash. The =filter-string= is passed to the /fast/ Emacs filtering to further narrow down the list of matches. This is particularly useful if you are using an advanced completion style like orderless. =consult-grep= supports preview. If the =consult-project-function= returns non-nil, =consult-grep= searches the current project directory. Otherwise the =default-directory= is searched. If =consult-grep= is invoked with prefix argument =C-u M-s g=, you can specify the directory manually.&lt;/li&gt; &#xA; &lt;li&gt;=consult-find=, =consult-locate=: Find file by matching the path against a regexp. Like for =consult-grep=, either the project root or the current directory is the root directory for the search. The input string is treated similarly to =consult-grep=, where the first part is passed to find, and the second part is used for Emacs filtering.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Compilation :properties: :description: Jumping to references and compilation errors &lt;span&gt;üîö&lt;/span&gt; #+cindex: compilation errors&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-compile-error #+findex: consult-flymake #+findex: consult-xref&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-compile-error=: Jump to a compilation error. Supports live preview narrowing and recursive editing.&lt;/li&gt; &#xA; &lt;li&gt;=consult-flymake=: Jump to flymake diagnostic. Supports live preview and recursive editing. The command supports narrowing. Press =e SPC=, =w SPC=, =n SPC= to only show errors, warnings and notes respectively.&lt;/li&gt; &#xA; &lt;li&gt;=consult-xref=: Integration with xref. This function can be set as =xref-show-xrefs-function= and =xref-show-definitions-function=.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Histories :properties: :description: Navigating histories &lt;span&gt;üîö&lt;/span&gt; #+cindex: history&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-complex-command #+findex: consult-history #+findex: consult-isearch-history&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-complex-command=: Select a command from the =command-history=. This command is a =completing-read= version of =repeat-complex-command= and is also a replacement for the =command-history= command from chistory.el.&lt;/li&gt; &#xA; &lt;li&gt;=consult-history=: Insert a string from the current buffer history, for example the Eshell or Comint history. You can also invoke this command from the minibuffer. In that case =consult-history= uses the history stored in the =minibuffer-history-variable=. If you prefer =completion-at-point=, take a look at =cape-history= from the [[https://github.com/minad/cape][Cape]] package.&lt;/li&gt; &#xA; &lt;li&gt;=consult-isearch-history=: During an Isearch session, this command picks a search string from history and continues the search with the newly selected string. Outside of Isearch, the command allows you to pick a string from the history and starts a new Isearch. =consult-isearch-history= acts as a drop-in replacement for =isearch-edit-string=.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Modes :properties: :description: Toggling minor modes and executing commands &lt;span&gt;üîö&lt;/span&gt; #+cindex: minor mode #+cindex: major mode&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-minor-mode-menu #+findex: consult-mode-command&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-minor-mode-menu=: Enable/disable minor mode. Supports narrowing to on/off/local/global modes by pressing =i/o/l/g SPC= respectively.&lt;/li&gt; &#xA; &lt;li&gt;=consult-mode-command=: Run a command from the currently active minor or major modes. Supports narrowing to local-minor/global-minor/major mode via the keys =l/g/m=.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Org Mode :properties: :description: Org-specific commands &lt;span&gt;üîö&lt;/span&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-org-heading #+findex: consult-org-agenda&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-org-heading=: Similar to =consult-outline=, for Org buffers. Supports narrowing by heading level, priority and TODO state, as well as live preview and recursive editing.&lt;/li&gt; &#xA; &lt;li&gt;=consult-org-agenda=: Jump to an agenda heading. Supports narrowing by heading level, priority and TODO state, as well as live preview and recursive editing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Miscellaneous :properties: :description: Various other useful commands &lt;span&gt;üîö&lt;/span&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+findex: consult-completion-in-region #+findex: consult-theme #+findex: consult-man #+findex: consult-preview-at-point #+findex: consult-preview-at-point-mode&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-man=: Find Unix man page, via Unix =apropos= or =man -k=. =consult-man= opens the selected man page using the Emacs =man= command.&lt;/li&gt; &#xA; &lt;li&gt;=consult-theme=: Select a theme and disable all currently enabled themes. Supports live preview of the theme while scrolling through the candidates.&lt;/li&gt; &#xA; &lt;li&gt;=consult-preview-at-point= and =consult-preview-at-point-mode=: Command and minor mode which previews the candidate at point in the =&lt;em&gt;Completions&lt;/em&gt;= buffer. This mode is relevant if you use [[https://git.sr.ht/~protesilaos/mct][Mct]] or the default =&lt;em&gt;Completions&lt;/em&gt;= UI.&lt;/li&gt; &#xA; &lt;li&gt;=consult-completion-in-region=: In case you don&#39;t use [[https://github.com/minad/corfu][Corfu]] as your in-buffer completion UI, this function can be set as =completion-in-region-function=. Then your minibuffer completion UI (e.g., Vertico or Icomplete) will be used for =completion-at-point=. If you use Mct, you can give =mct-region-mode= a try. #+begin_src emacs-lisp ;; Use &lt;code&gt;consult-completion-in-region&#39; if Vertico is enabled. ;; Otherwise use the default &lt;/code&gt;completion--in-region&#39; function. (setq completion-in-region-function (lambda (&amp;amp;rest args) (apply (if vertico-mode #&#39;consult-completion-in-region #&#39;completion--in-region) args))) #+end_src Instead of =consult-completion-in-region=, you may prefer to see the completions directly in the buffer as a small popup. In that case, I recommend either the [[https://github.com/minad/corfu][Corfu]] or the [[https://github.com/company-mode/company-mode][Company]] package. There is a technical limitation of =consult-completion-in-region= in combination with Lsp-mode or Eglot. The Lsp server relies on the input at point, in order to generate refined candidate strings. Since the completion is transferred from the original buffer to the minibuffer, the server does not receive the updated input. LSP completion works with Corfu or Company though, which perform the completion directly in the original buffer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Special features :properties: :description: Enhancements over built-in `completing-read&#39; &lt;span&gt;üîö&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Consult enhances =completing-read= with live previews of candidates, additional narrowing capabilities to candidate groups and asynchronously generated candidate lists. The internal =consult--read= function, which is used by most Consult commands, is a thin wrapper around =completing-read= and provides the special functionality. In order to support multiple candidate sources there exists the high-level function =consult--multi=. The architecture of Consult allows it to work with different completion systems in the backend, while still offering advanced features.&lt;/p&gt; &#xA;&lt;p&gt;** Live previews :properties: :description: Preview the currently selected candidate :custom_id: live-previews &lt;span&gt;üîö&lt;/span&gt; #+cindex: preview&lt;/p&gt; &#xA;&lt;p&gt;Some Consult commands support live previews. For example when you scroll through the items of =consult-line=, the buffer will scroll to the corresponding position. It is possible to jump back and forth between the minibuffer and the buffer to perform recursive editing while the search is ongoing.&lt;/p&gt; &#xA;&lt;p&gt;Consult enables previews by default. You can disable them by adjusting the =consult-preview-key= variable. Furthermore it is possible to specify keybindings which trigger the preview manually as shown in the [[#use-package-example][example configuration]]. The default setting of =consult-preview-key= is =any= which means that Consult triggers the preview /immediately/ on any key press when the selected candidate changes. You can configure each command individually with its own =:preview-key=. The following settings are possible:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automatic and immediate =&#39;any=&lt;/li&gt; &#xA; &lt;li&gt;Automatic and delayed =(list :debounce 0.5 &#39;any)=&lt;/li&gt; &#xA; &lt;li&gt;Manual and immediate =(kbd &#34;M-.&#34;)=&lt;/li&gt; &#xA; &lt;li&gt;Manual and delayed =(list :debounce 0.5 (kbd &#34;M-.&#34;))=&lt;/li&gt; &#xA; &lt;li&gt;Disabled =nil=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A safe recommendation is to leave automatic immediate previews enabled in general and disable the automatic preview only for commands where the preview may be expensive due to file loading. Internally, Consult uses the value of =this-command= to determine the =:preview-key= customized. This means that if you wrap a =consult-*= command within your own function or command, you will also need to add the name of /your custom command/ to the =consult-customize= call in order for it to be considered.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (consult-customize consult-ripgrep consult-git-grep consult-grep consult-bookmark consult-recent-file consult-xref consult--source-bookmark consult--source-file-register consult--source-recent-file consult--source-project-recent-file ;; my/command-wrapping-consult ;; disable auto previews inside my command :preview-key &#39;(:debounce 0.4 any) ;; Option 1: Delay preview ;; :preview-key (kbd &#34;M-.&#34;)) ;; Option 2: Manual preview #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In this case one may wonder what the difference is between using an Embark action on the current candidate in comparison to a manually triggered preview. The main difference is that the files opened by manual preview are closed again after the completion session. Furthermore during preview some functionality is disabled to improve the performance, see for example the customization variables =consult-preview-allowed-hooks= and =consult-preview-variables=. Files larger than =consult-preview-raw-size= are previewed literally without syntax highlighting and without changing the major mode. Delaying the preview is also useful for =consult-theme=, since the theme preview is slow. The delay results in a smoother UI experience.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Preview on any key press, but delay 0.5s (consult-customize consult-theme :preview-key &#39;(:debounce 0.5 any)) ;; Preview immediately on M-., on up/down after 0.5s, on any other key after 1s (consult-customize consult-theme :preview-key (list (kbd &#34;M-.&#34;) :debounce 0.5 (kbd &#34;&#xA; &lt;up&gt;&#xA;  &#34;) (kbd &#34;&#xA;  &lt;down&gt;&#xA;   &#34;) :debounce 1 &#39;any)) #+end_src&#xA;  &lt;/down&gt;&#xA; &lt;/up&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Narrowing and grouping :properties: :description: Restricting the completion to a candidate group :custom_id: narrowing-and-grouping &lt;span&gt;üîö&lt;/span&gt; #+cindex: narrowing&lt;/p&gt; &#xA;&lt;p&gt;Consult has special support for candidate groups. If the completion UI supports the grouping functionality, the UI separates the groups with thin lines and shows group titles. Grouping is useful if the list of candidates consists of candidates of multiple types or candidates from [[#multiple-sources][multiple sources]], like the =consult-buffer= command, which shows both buffers and recently opened files. Note that you can disable the group titles by setting the =:group= property of the corresponding command to nil using the =consult-customize= macro.&lt;/p&gt; &#xA;&lt;p&gt;By entering a narrowing prefix or by pressing a narrowing key it is possible to restrict the completion candidates to a certain candidate group. When you use the =consult-buffer= command, you can enter the prefix =b SPC= to restrict list of candidates to buffers only. If you press =DEL= afterwards, the full candidate list will be shown again. Furthermore a narrowing prefix key and a widening key can be configured which can be pressed to achieve the same effect, see the configuration variables =consult-narrow-key= and =consult-widen-key=.&lt;/p&gt; &#xA;&lt;p&gt;After pressing =consult-narrow-key=, the possible narrowing keys can be shown by pressing =C-h=. When pressing =C-h= after some prefix key, the =prefix-help-command= is invoked, which shows the keybinding help window by default. As a more compact alternative, there is the =consult-narrow-help= command which can be bound to a key, for example =?= or =C-h= in the =consult-narrow-map=, as shown in the [[#use-package-example][example configuration]]. If [[https://github.com/justbur/emacs-which-key][which-key]] is installed, the narrowing keys are automatically shown in the which-key window after pressing the =consult-narrow-key=.&lt;/p&gt; &#xA;&lt;p&gt;** Asynchronous search :properties: :description: Filtering asynchronously generated candidate lists &lt;span&gt;üîö&lt;/span&gt; #+cindex: asynchronous search&lt;/p&gt; &#xA;&lt;p&gt;Consult has support for asynchronous generation of candidate lists. This feature is used for search commands like =consult-grep=, where the list of matches is generated dynamically while the user is typing a regular expression. The grep process is executed in the background. When modifying the regular expression, the background process is terminated and a new process is started with the modified regular expression.&lt;/p&gt; &#xA;&lt;p&gt;The matches, which have been found, can then be narrowed using the installed Emacs completion-style. This can be powerful if you are using for example the =orderless= completion style.&lt;/p&gt; &#xA;&lt;p&gt;This two-level filtering is possible by splitting the input string. Part of the input string is treated as input to grep and part of the input is used for filtering. There are multiple splitting styles available, configured in &lt;del&gt;consult-async-split-styles-alist&lt;/del&gt;: =nil=, =comma=, =semicolon= and =perl=. The default splitting style is configured with the variable &lt;del&gt;consult-async-split-style&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With the =comma= and =semicolon= splitting styles, the first word before the comma or semicolon is passed to grep, the remaining string is used for filtering. The =nil= splitting style does not perform any splitting, the whole input is passed to grep.&lt;/p&gt; &#xA;&lt;p&gt;The =perl= splitting style splits the input string at a punctuation character, using a similar syntax as Perl regular expressions.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=#defun=: Search for &#34;defun&#34; using grep.&lt;/li&gt; &#xA; &lt;li&gt;=#consult embark=: Search for both &#34;consult&#34; and &#34;embark&#34; using grep in any order.&lt;/li&gt; &#xA; &lt;li&gt;=#first.*second=: Search for &#34;first&#34; followed by &#34;second&#34; using grep.&lt;/li&gt; &#xA; &lt;li&gt;=#(consult|embark)=: Search for &#34;consult&#34; or &#34;embark&#34; using grep. Note the usage of Emacs-style regular expressions.&lt;/li&gt; &#xA; &lt;li&gt;=#defun#consult=: Search for &#34;defun&#34; using grep, filter with the word &#34;consult&#34;.&lt;/li&gt; &#xA; &lt;li&gt;=/defun/consult=: It is also possible to use other punctuation characters.&lt;/li&gt; &#xA; &lt;li&gt;=#to#=: Force searching for &#34;to&#34; using grep, since the grep pattern must be longer than =consult-async-min-input= characters by default.&lt;/li&gt; &#xA; &lt;li&gt;=#defun -- --invert-match#=: Pass argument =--invert-match= to grep.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Asynchronous processes like =find= and =grep= create an error log buffer =_&lt;em&gt;consult-async&lt;/em&gt;= (note the leading space), which is useful for troubleshooting. The prompt has a small indicator showing the process status:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=:= the usual prompt colon, before input is provided.&lt;/li&gt; &#xA; &lt;li&gt;=*= with warning face, the process is running.&lt;/li&gt; &#xA; &lt;li&gt;=:= with success face, success, process exited with an error code of zero.&lt;/li&gt; &#xA; &lt;li&gt;=!= with error face, failure, process exited with a nonzero error code.&lt;/li&gt; &#xA; &lt;li&gt;=;= with error face, interrupted, for example if more input is provided.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Multiple sources :properties: :description: Combining candidates from different sources :custom_id: multiple-sources &lt;span&gt;üîö&lt;/span&gt; #+cindex: multiple sources&lt;/p&gt; &#xA;&lt;p&gt;Multiple synchronous candidate sources can be combined. This feature is used by the =consult-buffer= command to present buffer-like candidates in a single menu for quick access. By default =consult-buffer= includes buffers, bookmarks, recent files and project-specific buffers and files. It is possible to configure the list of sources via the =consult-buffer-sources= variable. Arbitrary custom sources can be defined.&lt;/p&gt; &#xA;&lt;p&gt;As an example, the bookmark source is defined as follows:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defvar consult--source-bookmark `(:name &#34;Bookmark&#34; :narrow ?m :category bookmark :face consult-bookmark :history bookmark-history :items ,#&#39;bookmark-all-names :action ,#&#39;consult--bookmark-action)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Required source fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=:category= Completion category.&lt;/li&gt; &#xA; &lt;li&gt;=:items= List of strings to select from or function returning list of strings. A list of cons cells is not supported.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Optional source fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=:name= Name of the source, used for narrowing, group titles and annotations.&lt;/li&gt; &#xA; &lt;li&gt;=:narrow= Narrowing character or =(character . string)= pair.&lt;/li&gt; &#xA; &lt;li&gt;=:preview-key= Preview key or keys which trigger preview.&lt;/li&gt; &#xA; &lt;li&gt;=:enabled= Function which must return t if the source is enabled.&lt;/li&gt; &#xA; &lt;li&gt;=:hidden= When t candidates of this source are hidden by default.&lt;/li&gt; &#xA; &lt;li&gt;=:face= Face used for highlighting the candidates.&lt;/li&gt; &#xA; &lt;li&gt;=:annotate= Annotation function called for each candidate, returns string.&lt;/li&gt; &#xA; &lt;li&gt;=:history= Name of history variable to add selected candidate.&lt;/li&gt; &#xA; &lt;li&gt;=:default= Must be t if the first item of the source is the default value.&lt;/li&gt; &#xA; &lt;li&gt;=:action= Function called with the selected candidate.&lt;/li&gt; &#xA; &lt;li&gt;=:new= Function called with new candidate name, only if =:require-match= is nil.&lt;/li&gt; &#xA; &lt;li&gt;=:state= State constructor for the source, must return the state function.&lt;/li&gt; &#xA; &lt;li&gt;Other source fields can be added specifically to the use case.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The =:state= and =:action= fields of the sources deserve a longer explanation. The =:action= function takes a single argument and is only called after selection with the selected candidate, if the selection has not been aborted. This functionality is provided for convenience and easy definition of sources. The =:state= field is more general. The =:state= function is a constructor function without arguments, which can perform some setup necessary for the preview. It must return a closure which takes an ACTION and a CANDIDATE argument. See the docstring of =consult--with-preview= for more details about the ACTION argument.&lt;/p&gt; &#xA;&lt;p&gt;By default, =consult-buffer= previews buffers, bookmarks and files. Loading recent files or bookmarks can result in expensive operations. However it is possible to configure a manual preview as follows.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (consult-customize consult--source-bookmark consult--source-file-register consult--source-recent-file consult--source-project-recent-file :preview-key (kbd &#34;M-.&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Sources can be added directly to the =consult-buffer-source= list for convenience. For example views/perspectives can be added to the list of virtual buffers from a library like [[https://github.com/minad/bookmark-view/][bookmark-view]].&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Configure new bookmark-view source (add-to-list &#39;consult-buffer-sources (list :name &#34;View&#34; :narrow ?v :category &#39;bookmark :face &#39;font-lock-keyword-face :history &#39;bookmark-view-history :action #&#39;consult--bookmark-action :items #&#39;bookmark-view-names) &#39;append)&lt;/p&gt; &#xA;&lt;p&gt;;; Modify bookmark source, such that views are hidden (setq consult--source-bookmark (plist-put consult--source-bookmark :items (lambda () (bookmark-maybe-load-default-file) (mapcar #&#39;car (seq-remove (lambda (x) (eq #&#39;bookmark-view-handler (alist-get &#39;handler (cdr x)))) bookmark-alist))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Another useful source lists all Org buffers and lets you create new ones. One can create similar sources for other major modes, e.g., for Eshell.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defvar org-source (list :name &#34;Org Buffer&#34; :category &#39;buffer :narrow ?o :face &#39;consult-buffer :history &#39;buffer-name-history :state #&#39;consult--buffer-state :new (lambda (name) (with-current-buffer (get-buffer-create name) (insert &#34;#+title: &#34; name &#34;\n\n&#34;) (org-mode) (consult--buffer-action (current-buffer)))) :items (lambda () (mapcar #&#39;buffer-name (seq-filter (lambda (x) (eq (buffer-local-value &#39;major-mode x) &#39;org-mode)) (buffer-list))))))&lt;/p&gt; &#xA;&lt;p&gt;(add-to-list &#39;consult-buffer-sources &#39;org-source &#39;append) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;For more details, see the documentation of =consult-buffer= and of the internal =consult--multi= API. The =consult--multi= function can be used to create new multi-source commands, but is part of the internal API as of now, since some details may still change.&lt;/p&gt; &#xA;&lt;p&gt;** Embark integration :properties: :description: Actions, Grep/Occur-buffer export :custom_id: embark-integration &lt;span&gt;üîö&lt;/span&gt; #+cindex: embark&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;: Install the =embark-consult= package from MELPA, which provides Consult-specific Embark actions and the Occur buffer export.&lt;/p&gt; &#xA;&lt;p&gt;Embark is a versatile package which offers context dependent actions, comparable to a context menu. See the [[https://github.com/oantolin/embark][Embark manual]] for an extensive description of its capabilities.&lt;/p&gt; &#xA;&lt;p&gt;Actions are commands which can operate on the currently selected candidate (or target in Embark terminology). When completing files, for example the =delete-file= command is offered. With Embark you can execute arbitrary commands on the currently selected candidate via =M-x=.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore Embark provides the =embark-collect= command, which collects candidates and presents them in an Embark collect buffer, where further actions can be applied to them. A related feature is the =embark-export= command, which exports candidate lists to a buffer of a special type. For example in the case of file completion, a Dired buffer is opened.&lt;/p&gt; &#xA;&lt;p&gt;In the context of Consult, particularly exciting is the possibility to export the matching lines from =consult-line=, =consult-outline=, =consult-mark= and =consult-global-mark=. The matching lines are exported to an Occur buffer where they can be edited via the =occur-edit-mode= (press key =e=). Similarly, Embark supports exporting the matches found by =consult-grep=, =consult-ripgrep= and =consult-git-grep= to a Grep buffer, where the matches across files can be edited, if the [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]] package is installed. These three workflows are symmetric.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-line= -&amp;gt; =embark-export= to =occur-mode= buffer -&amp;gt; =occur-edit-mode= for editing of matches in buffer.&lt;/li&gt; &#xA; &lt;li&gt;=consult-grep= -&amp;gt; =embark-export= to =grep-mode= buffer -&amp;gt; =wgrep= for editing of all matches.&lt;/li&gt; &#xA; &lt;li&gt;=consult-find= -&amp;gt; =embark-export= to =dired-mode= buffer -&amp;gt; =wdired-change-to-wdired-mode= for editing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configuration :properties: :description: Example configuration and customization variables &lt;span&gt;üîö&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Consult can be installed from [[https://elpa.gnu.org/packages/consult.html][ELPA]] or [[https://melpa.org/#/consult][MELPA]] via the Emacs built-in package manager. Alternatively it can be directly installed from the development repository via other non-standard package managers.&lt;/p&gt; &#xA;&lt;p&gt;There is the [[https://github.com/minad/consult/wiki][Consult wiki]], where additional configuration examples can be contributed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;IMPORTANT:&lt;/em&gt; It is strongly recommended that you enable [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html][lexical binding]] in your configuration. Consult relies on lambdas and lexical closures. For this reason many Consult-related snippets require lexical binding.&lt;/p&gt; &#xA;&lt;p&gt;** Use-package example :properties: :description: Configuration example based on use-package :custom_id: use-package-example &lt;span&gt;üîö&lt;/span&gt; #+cindex: use-package&lt;/p&gt; &#xA;&lt;p&gt;The Consult package only provides commands and does not add any keybindings or modes. Therefore the package is non-intrusive but requires a little setup effort. In order to use the Consult commands, it is advised to add keybindings for commands which are accessed often. Rarely used commands can be invoked via =M-x=. Feel free to only bind the commands you consider useful to your workflow. The configuration shown here relies on the =use-package= macro, which is a convenient tool to manage package configurations.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE:&lt;/em&gt; There is the [[https://github.com/minad/consult/wiki][Consult wiki]], where you can contribute additional configuration examples.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Example configuration for Consult (use-package consult ;; Replace bindings. Lazily loaded due by `use-package&#39;. :bind (;; C-c bindings (mode-specific-map) (&#34;C-c h&#34; . consult-history) (&#34;C-c m&#34; . consult-mode-command) (&#34;C-c k&#34; . consult-kmacro) ;; C-x bindings (ctl-x-map) (&#34;C-x M-:&#34; . consult-complex-command) ;; orig. repeat-complex-command (&#34;C-x b&#34; . consult-buffer) ;; orig. switch-to-buffer (&#34;C-x 4 b&#34; . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window (&#34;C-x 5 b&#34; . consult-buffer-other-frame) ;; orig. switch-to-buffer-other-frame (&#34;C-x r b&#34; . consult-bookmark) ;; orig. bookmark-jump (&#34;C-x p b&#34; . consult-project-buffer) ;; orig. project-switch-to-buffer ;; Custom M-# bindings for fast register access (&#34;M-#&#34; . consult-register-load) (&#34;M-&#39;&#34; . consult-register-store) ;; orig. abbrev-prefix-mark (unrelated) (&#34;C-M-#&#34; . consult-register) ;; Other custom bindings (&#34;M-y&#34; . consult-yank-pop) ;; orig. yank-pop ;; M-g bindings (goto-map) (&#34;M-g e&#34; . consult-compile-error) (&#34;M-g f&#34; . consult-flymake) ;; Alternative: consult-flycheck (&#34;M-g g&#34; . consult-goto-line) ;; orig. goto-line (&#34;M-g M-g&#34; . consult-goto-line) ;; orig. goto-line (&#34;M-g o&#34; . consult-outline) ;; Alternative: consult-org-heading (&#34;M-g m&#34; . consult-mark) (&#34;M-g k&#34; . consult-global-mark) (&#34;M-g i&#34; . consult-imenu) (&#34;M-g I&#34; . consult-imenu-multi) ;; M-s bindings (search-map) (&#34;M-s d&#34; . consult-find) (&#34;M-s D&#34; . consult-locate) (&#34;M-s g&#34; . consult-grep) (&#34;M-s G&#34; . consult-git-grep) (&#34;M-s r&#34; . consult-ripgrep) (&#34;M-s l&#34; . consult-line) (&#34;M-s L&#34; . consult-line-multi) (&#34;M-s k&#34; . consult-keep-lines) (&#34;M-s u&#34; . consult-focus-lines) ;; Isearch integration (&#34;M-s e&#34; . consult-isearch-history) :map isearch-mode-map (&#34;M-e&#34; . consult-isearch-history) ;; orig. isearch-edit-string (&#34;M-s e&#34; . consult-isearch-history) ;; orig. isearch-edit-string (&#34;M-s l&#34; . consult-line) ;; needed by consult-line to detect isearch (&#34;M-s L&#34; . consult-line-multi) ;; needed by consult-line to detect isearch ;; Minibuffer history :map minibuffer-local-map (&#34;M-s&#34; . consult-history) ;; orig. next-matching-history-element (&#34;M-r&#34; . consult-history)) ;; orig. previous-matching-history-element&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; Enable automatic preview at point in the *Completions* buffer. This is&#xA;;; relevant when you use the default completion UI.&#xA;:hook (completion-list-mode . consult-preview-at-point-mode)&#xA;&#xA;;; The :init configuration is always executed (Not lazy)&#xA;:init&#xA;&#xA;;; Optionally configure the register formatting. This improves the register&#xA;;; preview for `consult-register&#39;, `consult-register-load&#39;,&#xA;;; `consult-register-store&#39; and the Emacs built-ins.&#xA;(setq register-preview-delay 0.5&#xA;      register-preview-function #&#39;consult-register-format)&#xA;&#xA;;; Optionally tweak the register preview window.&#xA;;; This adds thin lines, sorting and hides the mode line of the window.&#xA;(advice-add #&#39;register-preview :override #&#39;consult-register-window)&#xA;&#xA;;; Use Consult to select xref locations with preview&#xA;(setq xref-show-xrefs-function #&#39;consult-xref&#xA;      xref-show-definitions-function #&#39;consult-xref)&#xA;&#xA;;; Configure other variables and modes in the :config section,&#xA;;; after lazily loading the package.&#xA;:config&#xA;&#xA;;; Optionally configure preview. The default value&#xA;;; is &#39;any, such that any key triggers the preview.&#xA;;; (setq consult-preview-key &#39;any)&#xA;;; (setq consult-preview-key (kbd &#34;M-.&#34;))&#xA;;; (setq consult-preview-key (list (kbd &#34;&amp;lt;S-down&amp;gt;&#34;) (kbd &#34;&amp;lt;S-up&amp;gt;&#34;)))&#xA;;; For some commands and buffer sources it is useful to configure the&#xA;;; :preview-key on a per-command basis using the `consult-customize&#39; macro.&#xA;(consult-customize&#xA; consult-theme :preview-key &#39;(:debounce 0.2 any)&#xA; consult-ripgrep consult-git-grep consult-grep&#xA; consult-bookmark consult-recent-file consult-xref&#xA; consult--source-bookmark consult--source-file-register&#xA; consult--source-recent-file consult--source-project-recent-file&#xA; ;; :preview-key (kbd &#34;M-.&#34;)&#xA; :preview-key &#39;(:debounce 0.4 any))&#xA;&#xA;;; Optionally configure the narrowing key.&#xA;;; Both &amp;lt; and C-+ work reasonably well.&#xA;(setq consult-narrow-key &#34;&amp;lt;&#34;) ;; (kbd &#34;C-+&#34;)&#xA;&#xA;;; Optionally make narrowing help available in the minibuffer.&#xA;;; You may want to use `embark-prefix-help-command&#39; or which-key instead.&#xA;;; (define-key consult-narrow-map (vconcat consult-narrow-key &#34;?&#34;) #&#39;consult-narrow-help)&#xA;&#xA;;; By default `consult-project-function&#39; uses `project-root&#39; from project.el.&#xA;;; Optionally configure a different project root function.&#xA;;; There are multiple reasonable alternatives to chose from.&#xA;;;;; 1. project.el (the default)&#xA;;; (setq consult-project-function #&#39;consult--default-project--function)&#xA;;;;; 2. projectile.el (projectile-project-root)&#xA;;; (autoload &#39;projectile-project-root &#34;projectile&#34;)&#xA;;; (setq consult-project-function (lambda (_) (projectile-project-root)))&#xA;;;;; 3. vc.el (vc-root-dir)&#xA;;; (setq consult-project-function (lambda (_) (vc-root-dir)))&#xA;;;;; 4. locate-dominating-file&#xA;;; (setq consult-project-function (lambda (_) (locate-dominating-file &#34;.&#34; &#34;.git&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Custom variables :properties: :description: Short description of all customization settings &lt;span&gt;üîö&lt;/span&gt; #+cindex: customization&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;TIP:&lt;/em&gt; If you have [[https://github.com/minad/marginalia][Marginalia]] installed, type =M-x customize-variable RET ^consult= to see all Consult-specific customizable variables with their current values and abbreviated description. Alternatively, type =C-h a ^consult= to get an overview of all Consult variables and functions with their descriptions.&lt;/p&gt; &#xA;&lt;p&gt;| Variable | Description | |----------------------------------+-------------------------------------------------------| | consult-after-jump-hook | Functions to call after jumping to a location | | consult-async-input-debounce | Input debounce for asynchronous commands | | consult-async-input-throttle | Input throttle for asynchronous commands | | consult-async-min-input | Minimum numbers of letters needed for async process | | consult-async-refresh-delay | Refresh delay for asynchronous commands | | consult-async-split-style | Splitting style used for async commands | | consult-async-split-styles-alist | Available splitting styles used for async commands | | consult-bookmark-narrow | Narrowing configuration for =consult-bookmark= | | consult-buffer-filter | Filter for =consult-buffer= | | consult-buffer-sources | List of virtual buffer sources | | consult-find-args | Command line arguments for find | | consult-fontify-max-size | Buffers larger than this limit are not fontified | | consult-fontify-preserve | Preserve fontification for line-based commands. | | consult-git-grep-args | Command line arguments for git-grep | | consult-goto-line-numbers | Show line numbers for =consult-goto-line= | | consult-grep-max-columns | Maximal number of columns of the matching lines | | consult-grep-args | Command line arguments for grep | | consult-imenu-config | Mode-specific configuration for =consult-imenu= | | consult-line-numbers-widen | Show absolute line numbers when narrowing is active. | | consult-line-start-from-top | Start the =consult-line= search from the top | | consult-locate-args | Command line arguments for locate | | consult-man-args | Command line arguments for man | | consult-mode-command-filter | Filter for =consult-mode-command= | | consult-mode-histories | Mode-specific history variables | | consult-narrow-key | Narrowing prefix key during completion | | consult-point-placement | Placement of the point when jumping to matches | | consult-preview-key | Keys which triggers preview | | consult-preview-allowed-hooks | List of =find-file= hooks to enable during preview | | consult-preview-excluded-files | Regexps matched against file names during preview | | consult-preview-max-count | Maximum number of files to keep open during preview | | consult-preview-max-size | Files larger than this size are not previewed | | consult-preview-raw-size | Files larger than this size are previewed in raw form | | consult-preview-variables | Alist of variables to bind during preview | | consult-project-buffer-sources | List of virtual project buffer sources | | consult-project-function | Function which returns current project root | | consult-register-prefix | Prefix string for register keys during completion | | consult-ripgrep-args | Command line arguments for ripgrep | | consult-themes | List of themes to be presented for selection | | consult-widen-key | Widening key during completion | | consult-yank-rotate | Rotate kill ring |&lt;/p&gt; &#xA;&lt;p&gt;** Fine-tuning of individual commands :properties: :alt_title: Fine-tuning :description: Fine-grained configuration for special requirements &lt;span&gt;üîö&lt;/span&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE:&lt;/em&gt; Consult supports fine-grained customization of individual commands. This configuration feature exists for experienced users with special requirements. There is the [[https://github.com/minad/consult/wiki][Consult wiki]], where we collect further configuration examples.&lt;/p&gt; &#xA;&lt;p&gt;Commands and buffer sources allow flexible, individual customization by using the =consult-customize= macro. You can override any option passed to the internal =consult--read= API. The [[https://github.com/minad/consult/wiki][Consult wiki]] already contains a numerous useful configuration examples. Note that since =consult--read= is part of the internal API, options could be removed, replaced or renamed in future versions of the package.&lt;/p&gt; &#xA;&lt;p&gt;Useful options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=:prompt= set the prompt string&lt;/li&gt; &#xA; &lt;li&gt;=:preview-key= set the preview key, default is =consult-preview-key=&lt;/li&gt; &#xA; &lt;li&gt;=:initial= set the initial input&lt;/li&gt; &#xA; &lt;li&gt;=:default= set the default value&lt;/li&gt; &#xA; &lt;li&gt;=:history= set the history variable symbol&lt;/li&gt; &#xA; &lt;li&gt;=:add-history= add items to the future history, for example symbol at point&lt;/li&gt; &#xA; &lt;li&gt;=:sort= enable or disable sorting&lt;/li&gt; &#xA; &lt;li&gt;=:group= set to nil to disable candidate grouping and titles.&lt;/li&gt; &#xA; &lt;li&gt;=:inherit-input-method= set to non-nil to inherit the input method.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (consult-customize ;; Disable preview for &lt;code&gt;consult-theme&#39; completely. consult-theme :preview-key nil ;; Set preview for &lt;/code&gt;consult-buffer&#39; to key &lt;code&gt;M-.&#39; consult-buffer :preview-key (kbd &#34;M-.&#34;) ;; For &lt;/code&gt;consult-line&#39; change the prompt and specify multiple preview ;; keybindings. Note that you should bind &#xA; &lt;s-up&gt;&#xA;   and &#xA;  &lt;s-down&gt;&#xA;    in the ;; &#xA;   &lt;code&gt;minibuffer-local-completion-map&#39; or &lt;/code&gt;vertico-map&#39; to the commands which ;; select the previous or next candidate. consult-line :prompt &#34;Search: &#34; :preview-key (list (kbd &#34;&#xA;   &lt;s-down&gt;&#xA;    &#34;) (kbd &#34;&#xA;    &lt;s-up&gt;&#xA;     &#34;))) #+end_src&#xA;    &lt;/s-up&gt;&#xA;   &lt;/s-down&gt;&#xA;  &lt;/s-down&gt;&#xA; &lt;/s-up&gt;&lt;/p&gt; &#xA;&lt;p&gt;The configuration values are evaluated at runtime, just before the completion session is started. Therefore you can use for example =thing-at-point= to adjust the initial input or the future history.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (consult-customize consult-line :add-history (seq-some #&#39;thing-at-point &#39;(region symbol)))&lt;/p&gt; &#xA;&lt;p&gt;(defalias &#39;consult-line-thing-at-point &#39;consult-line)&lt;/p&gt; &#xA;&lt;p&gt;(consult-customize consult-line-thing-at-point :initial (thing-at-point &#39;symbol)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Generally it is possible to modify commands for your individual needs by the following techniques:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use =consult-customize= in order to change the command or source settings.&lt;/li&gt; &#xA; &lt;li&gt;Create your own wrapper function which passes modified arguments to the Consult functions.&lt;/li&gt; &#xA; &lt;li&gt;Create your own buffer [[#multiple-sources][multi sources]] for =consult-buffer=.&lt;/li&gt; &#xA; &lt;li&gt;Create advices to modify some internal behavior.&lt;/li&gt; &#xA; &lt;li&gt;Write or propose a patch.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Recommended packages :properties: :description: Related packages recommended for installation &lt;span&gt;üîö&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I use and recommend this combination of packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;consult: This package&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/vertico][vertico]]: Fast and minimal vertical completion system&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/marginalia][marginalia]]: Annotations for the completion candidates&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/oantolin/embark][embark and embark-consult]]: Action commands, which can act on the completion candidates&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/oantolin/orderless][orderless]]: Completion style which offers flexible candidate filtering&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There exist many other fine completion UIs beside Vertico, which are supported by Consult. Give them a try and find out which interaction model fits best for you.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The builtin completion UI, which pops up the =&lt;em&gt;Completions&lt;/em&gt;= buffer.&lt;/li&gt; &#xA; &lt;li&gt;The builtin =icomplete-vertical-mode= in Emacs 28.&lt;/li&gt; &#xA; &lt;li&gt;[[https://git.sr.ht/~protesilaos/mct][mct by Protesilaos Stavrou]]: Minibuffer and Completions in Tandem, which builds on the default completion UI (development currently [[https://protesilaos.com/codelog/2022-04-14-emacs-discontinue-mct/][discontinued]]).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that all packages are independent and can be exchanged with alternative components, since there exist no hard dependencies. Furthermore it is possible to get started with only default completion and Consult and add more components later to the mix. For example you can omit Marginalia if you don&#39;t need annotations. I highly recommend the Embark package, but in order to familiarize yourself with the other components, you can first start without it - or you could use with Embark right away and add the other components later on.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Auxiliary packages :properties: :description: Integrations with the wider ecosystem &lt;span&gt;üîö&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can integrate Consult with special programs or with other packages in the wider Emacs ecosystem. You may want to install some of theses packages depending on your preferences and requirements.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/yadex205/consult-ag][consult-ag]]: Support for the [[https://github.com/ggreer/the_silver_searcher][Silver Searcher]] in the style of =consult-grep=.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mohkale/consult-company][consult-company]]: Completion at point using the [[https://github.com/company-mode/company-mode][Company]] backends.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/youngker/consult-codesearch.el][consult-codesearch]]: Integration with [[https://github.com/google/codesearch][Code Search]].&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/karthink/consult-dir][consult-dir]]: Directory jumper using Consult multi sources.&lt;/li&gt; &#xA; &lt;li&gt;[[https://codeberg.org/ravi/consult-dash][consult-dash]]: Consult interface to [[https://github.com/dash-docs-el/dash-docs][Dash documentation]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mohkale/consult-eglot][consult-eglot]]: Integration with Eglot (LSP client).&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/consult-flycheck][consult-flycheck]]: Additional Flycheck integration.&lt;/li&gt; &#xA; &lt;li&gt;[[https://gitlab.com/OlMon/consult-flyspell][consult-flyspell]]: Additional Flyspell integration.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/ghosty141/consult-git-log-grep][consult-git-log-grep]]: Consult interface to git log.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/Nyoho/consult-hatena-bookmark][consult-hatena-bookmark]]: Access Hatena bookmarks.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/rcj/consult-ls-git][consult-ls-git]]: List files from git via Consult.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/gagbo/consult-lsp][consult-lsp]]: Integration with Lsp-mode (LSP client).&lt;/li&gt; &#xA; &lt;li&gt;[[https://codeberg.org/jao/consult-notmuch][consult-notmuch]]: Access the [[https://notmuchmail.org/][Notmuch]] email system using Consult.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mclear-tools/consult-notes][consult-notes]]: Searching notes with Consult.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/jgru/consult-org-roam][consult-org-roam]]: Integration with [[https://github.com/org-roam/org-roam][Org-roam]].&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/Qkessler/consult-project-extra/][consult-project-extra]]: Additional project.el extras and buffer sources.&lt;/li&gt; &#xA; &lt;li&gt;[[https://gitlab.com/OlMon/consult-projectile/][consult-projectile]]: Additional [[https://github.com/bbatsov/projectile][Projectile]] integration and buffer sources.&lt;/li&gt; &#xA; &lt;li&gt;[[https://codeberg.org/jao/consult-recoll][consult-recoll]]: Access the [[https://www.lesbonscomptes.com/recoll/][Recoll]] desktop full-text search using Consult.&lt;/li&gt; &#xA; &lt;li&gt;[[https://codeberg.org/jao/espotify][consult-spotify]]: Access the Spotify API and control your local music player.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mohkale/consult-yasnippet][consult-yasnippet]]: Integration with Yasnippet.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/affe][affe]]: Asynchronous Fuzzy Finder for Emacs based on Consult.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Not directly related to Consult, but maybe still of interest are the following packages. These packages should work well with Consult, follow a similar spirit or offer functionality based on &lt;del&gt;completing-read&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/minad/corfu][corfu]]: Completion systems for =completion-at-point= using small popups (Alternative to [[https://github.com/company-mode/company-mode][Company]]).&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/cape][cape]]: Completion At Point Extensions, which can be used with =consult-completion-in-region= and [[https://github.com/minad/corfu][Corfu]].&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/minad/bookmark-view][bookmark-view]]: Store window configuration as bookmarks, possible integration with =consult-buffer=.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/bdarcus/citar][citar]]: Versatile package for citation insertion and bibliography management.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/astoff/devdocs.el][devdocs]]: Emacs viewer for [[https://devdocs.io/][DevDocs]] with a convenient completion interface.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/d12frosted/flyspell-correct][flyspell-correct]]: Apply spelling corrections by selecting via =completing-read=.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]]: Editing of grep buffers, use together with =consult-grep= via =embark-export=.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/iyefrat/all-the-icons-completion][all-the-icons-completion]]: Icons for the completion UI.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bug reports :properties: :description: How to create reproducible bug reports &lt;span&gt;üîö&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you find a bug or suspect that there is a problem with Consult, please carry out the following steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;em&gt;Update all the relevant packages to the newest version&lt;/em&gt;. This includes Consult, Vertico or other completion UIs, Marginalia, Embark and Orderless.&lt;/li&gt; &#xA; &lt;li&gt;Either use the default completion UI or ensure that exactly one of =vertico-mode=, =mct-mode=, or =icomplete-mode= is enabled. The unsupported modes =ivy-mode=, =helm-mode= and =ido-ubiquitous-mode= must be disabled.&lt;/li&gt; &#xA; &lt;li&gt;Ensure that the =completion-styles= variable is properly configured. Try to set =completion-styles= to a list including =substring= or =orderless=.&lt;/li&gt; &#xA; &lt;li&gt;Try to reproduce the issue by starting a bare bone Emacs instance with =emacs -Q= on the command line. Execute the following minimal code snippets in the scratch buffer. This way we can exclude side effects due to configuration settings. If other packages are relevant to reproduce the issue, include them in the minimal configuration snippet.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Minimal setup with Vertico for =emacs -Q=: #+begin_src emacs-lisp (package-initialize) (require &#39;consult) (require &#39;vertico) (vertico-mode) (setq completion-styles &#39;(substring basic)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Minimal setup with the default completion system for =emacs -Q=: #+begin_src emacs-lisp (package-initialize) (require &#39;consult) (setq completion-styles &#39;(substring basic)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Please provide the necessary important information with your bug report:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The minimal configuration snippet used to reproduce the issue.&lt;/li&gt; &#xA; &lt;li&gt;Your completion UI (Default completion, Vertico, Mct or Icomplete).&lt;/li&gt; &#xA; &lt;li&gt;A stack trace in case the bug triggers an exception.&lt;/li&gt; &#xA; &lt;li&gt;Your Emacs version, since bugs may be fixed or introduced in newer versions.&lt;/li&gt; &#xA; &lt;li&gt;Your operating system, since Emacs behavior varies between Linux, Mac and Windows.&lt;/li&gt; &#xA; &lt;li&gt;The package manager, e.g., straight.el or package.el, used to install the Emacs packages, in order to exclude update issues. Did you install Consult as part of the Doom or Spacemacs Emacs distributions?&lt;/li&gt; &#xA; &lt;li&gt;Do you use Evil or other packages which apply deep changes? Consult does not provide Evil integration out of the box, but there is some support in [[https://github.com/emacs-evil/evil-collection][evil-collection]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When evaluating Consult-related code snippets you should enable [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html][lexical binding]]. Consult often relies on lambdas and lexical closures.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions :properties: :description: Feature requests and pull requests &lt;span&gt;üîö&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Consult is a community effort, please participate in the discussions. Contributions are welcome, but you may want to discuss potential contributions first. Since this package is part of [[https://elpa.gnu.org/packages/consult.html][GNU ELPA]] contributions require a copyright assignment to the FSF.&lt;/p&gt; &#xA;&lt;p&gt;If you have a proposal, take a look at the [[https://github.com/consult/issues][Consult issue tracker]] and the [[https://github.com/minad/consult/issues/6][Consult wishlist]]. There have been many prior feature discussions. Please search through the issue tracker, maybe your issue or feature request has already been discussed. You can contribute to the [[https://github.com/minad/consult/wiki][Consult wiki]], in case you want to share small configuration or command snippets.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Acknowledgments :properties: :description: Contributors and Sources of Inspiration &lt;span&gt;üîö&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This package took inspiration from [[https://github.com/abo-abo/swiper#counsel][Counsel]] by Oleh Krehel. Some of the Consult commands originated in the Counsel package or the wiki of the Selectrum package. This package exists only thanks to the help of these great contributors and thanks to the feedback of many users. Thank you!&lt;/p&gt; &#xA;&lt;p&gt;Code contributions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/oantolin/][Omar Antol√≠n Camarena]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/s-kostyaev/][Sergey Kostyaev]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/okamsn/][Earl Hyatt]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/clemera/][Clemens Radermacher]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/tomfitzhenry/][Tom Fitzhenry]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/jakanakaevangeli][jakanakaevangeli]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://hg.serna.eu][I√±igo Serna]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/aspiers/][Adam Spiers]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/omar-polo][Omar Polo]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/astoff][Augusto Stoffel]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/noctuid][Fox Kiester]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/tecosaur][Tecosaur]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mohamed-abdelnour][Mohamed Abdelnour]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/thisirs][Sylvain Rousseau]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/jdtsmith][J.D. Smith]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mohkale][Mohsin Kaleem]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/jyp][Jean-Philippe Bernardy]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/aagon][Aymeric Agon-Rambosson]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/geolessel][Geoffrey Lessel]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/piotrkwiecinski][Piotr Kwiecinski]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Advice and useful discussions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/clemera/][Clemens Radermacher]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/oantolin/][Omar Antol√≠n Camarena]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://protesilaos.com][Protesilaos Stavrou]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/purcell/][Steve Purcell]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/alphapapa/][Adam Porter]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/manuel-uberti/][Manuel Uberti]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/tomfitzhenry/][Tom Fitzhenry]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/hmelman/][Howard Melman]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/monnier/][Stefan Monnier]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/dgutov/][Dmitry Gutov]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/iyefrat][Itai Y. Efrat]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/bdarcus][Bruce d&#39;Arcus]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/jdtsmith][J.D. Smith]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/Qkessler][Enrique Kessler Mart√≠nez]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/raxod502][Radon Rosborough]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Authors of supplementary =consult-*= packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://codeberg.org/jao/][Jose A Ortega Ruiz]] ([[https://codeberg.org/jao/consult-notmuch][consult-notmuch]], [[https://codeberg.org/jao/consult-recoll][consult-recoll]], [[https://codeberg.org/jao/espotify][consult-spotify]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/gagbo/][Gerry Agbobada]] ([[https://github.com/gagbo/consult-lsp][consult-lsp]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/karthink][Karthik Chikmagalur]] ([[https://github.com/karthink/consult-dir][consult-dir]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mohkale][Mohsin Kaleem]] ([[https://github.com/mohkale/consult-company][consult-company]], [[https://github.com/mohkale/consult-eglot][consult-eglot]], [[https://github.com/mohkale/consult-yasnippet][consult-yasnippet]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://gitlab.com/OlMon][Marco Paw≈Çowski]] ([[https://gitlab.com/OlMon/consult-flyspell][consult-flyspell]], [[https://gitlab.com/OlMon/consult-projectile][consult-projectile]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/Qkessler][Enrique Kessler Mart√≠nez]] ([[https://github.com/Qkessler/consult-project-extra][consult-project-extra]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/jgru][Jan Gru]] ([[https://github.com/jgru/consult-org-roam][consult-org-roam]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/yadex205][Kanon Kakuno]] ([[https://github.com/yadex205/consult-ag][consult-ag]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/rcj][Robin Joy]] ([[https://github.com/rcj/consult-ls-git][consult-ls-git]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://codeberg.org/ravi][Ravi R Kiran]] [[https://codeberg.org/ravi/consult-dash][(consult-dash]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/mclearc][Colin McLear]] ([[https://github.com/mclear-tools/consult-notes][consult-notes]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/Nyoho][Yukinori Kitadai]] ([[https://github.com/Nyoho/consult-hatena-bookmark][consult-hatena-bookmark]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/ghosty141][ghosty141]] ([[https://github.com/ghosty141/consult-git-log-grep][consult-git-log-grep]])&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/youngker][YoungJoo Lee]] ([[https://github.com/youngker/consult-codesearch.el][consult-codesearch]])&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+html: &amp;lt;!--&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Indices :properties: :description: Indices of concepts and functions &lt;span&gt;üîö&lt;/span&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Function index :properties: :description: List of all Consult commands :index: fn &lt;span&gt;üîö&lt;/span&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Concept index :properties: :description: List of all Consult-specific concepts :index: cp &lt;span&gt;üîö&lt;/span&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+html: --&amp;gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mickeynp/combobulate</title>
    <updated>2022-12-25T01:40:04Z</updated>
    <id>tag:github.com,2022-12-25:/mickeynp/combobulate</id>
    <link href="https://github.com/mickeynp/combobulate" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Structured Editing and Navigation in Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;==================================================== Structured Navigation and Editing with Combobulate&lt;/h1&gt; &#xA;&lt;p&gt;.. image:: docs/combobulate-navigate.svg&lt;/p&gt; &#xA;&lt;h1&gt;What is Combobulate?&lt;/h1&gt; &#xA;&lt;p&gt;.. note:: Combobulate is &lt;strong&gt;alpha software&lt;/strong&gt; with all the caveats that follows from that. Your author uses it daily however, though breaking changes are likely.&lt;/p&gt; &#xA;&lt;p&gt;Combobulate is an Emacs package that provides a standardized framework for manipulating and navigating your source code using tree sitter&#39;s concrete syntax tree. Combobulate is language agnostic and should work with little modification almost all languages supported by tree sitter itself.&lt;/p&gt; &#xA;&lt;h2&gt;Benefits&lt;/h2&gt; &#xA;&lt;p&gt;Combobulate is new and it does not have as many features yet as it&#39;s likely to get over time. It is designed to help you navigate and edit your code faster than the tools offered by your major mode (or some Language Server features).&lt;/p&gt; &#xA;&lt;p&gt;To start with, Combobulate improves navigation like letting you navigate in or out of syntactic structures that your language may use. In some that might be functions, try/except, while/for blocks and classes like in Python; in others, it might be React-style JSX and Javascript or Typescript. Because Combobulate has a perfect understanding of your code it&#39;s able to faultlessly navigate to things most other major modes would struggle with, like arrow functions in Javascript.&lt;/p&gt; &#xA;&lt;p&gt;Combobulate also co-operates with third-party packages you may already use: Combobulate can activate multiple cursors and place them on every dictionary, list, or tuple element in Python, or against every attribute in JSX. Extending this to other parts of a language is easy.&lt;/p&gt; &#xA;&lt;p&gt;Because it offers a unified framework for all programming languages, Combobulate is designed to be easy to extend or modify. Open &lt;code&gt;combobulate-&amp;lt;language&amp;gt;.el&lt;/code&gt; to see the language-specific features it offers. The Python example is a good place to start.&lt;/p&gt; &#xA;&lt;p&gt;You can use Avy to quick jump to important parts of you code, like function definitions. You can also drag elements up or down to re-arrange them.&lt;/p&gt; &#xA;&lt;p&gt;In addition to this, Combobulate ships with a basic hierarchical aid that shows you where you&#39;re navigating if you use its navigation features.&lt;/p&gt; &#xA;&lt;h2&gt;Philosophy&lt;/h2&gt; &#xA;&lt;p&gt;.. image:: docs/combobulate-navigate-jsx.svg&lt;/p&gt; &#xA;&lt;p&gt;Your author feels that Emacs comes with excellent tools for navigating and editing code as it is. Combobulate is philosophically aligned with Emacs&#39;s idea that editing and moving by &#34;balanced expressions&#34; (&lt;code&gt;mark-sexp&lt;/code&gt;, &lt;code&gt;forward-sexp&lt;/code&gt;, &lt;code&gt;kill-sexp&lt;/code&gt;, &lt;code&gt;up/downward-list&lt;/code&gt;, etc.) is a useful way to think of text.&lt;/p&gt; &#xA;&lt;p&gt;Before the advent of tree sitter doing so was hard in languages that did not lend themselves to this easily like LISP does. Combobulate aims to take that germ of an idea and the ideas of &lt;code&gt;ParEdit &amp;lt;https://www.emacswiki.org/emacs/ParEdit&amp;gt;&lt;/code&gt;__ and make it work as consistently and transparently across languages as possible.&lt;/p&gt; &#xA;&lt;h1&gt;How do I install Combobulate?&lt;/h1&gt; &#xA;&lt;p&gt;To start using it, install this package::&lt;/p&gt; &#xA;&lt;p&gt;(use-package combobulate ;; Ensure &lt;code&gt;combobulate-mode&lt;/code&gt; is activated when you launch a mode it supports :hook ((python-mode . combobulate-mode) (js-mode . combobulate-mode) (typescript-mode . combobulate-mode)) :load-path &#34;path-to-this-package&#34;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Because combobulate is alpha software it has hard dependencies on &lt;code&gt;avy&lt;/code&gt;, &lt;code&gt;multiple-cursors&lt;/code&gt; and &lt;code&gt;hydra&lt;/code&gt;. This will change over time as the package matures. If you wish to help fix that, please submit PRs.&lt;/p&gt; &#xA;&lt;h1&gt;How do I use it?&lt;/h1&gt; &#xA;&lt;p&gt;.. image:: docs/combobulate-avy-jump.svg&lt;/p&gt; &#xA;&lt;p&gt;To start, you can type &lt;code&gt;C-c o o&lt;/code&gt; to open the Hydra menu (or &lt;code&gt;M-x combobulate-menu/body&lt;/code&gt;) with a selection of the commands available to you. I recommend you review the key bindings in &lt;code&gt;combobulate-mode&lt;/code&gt; also.&lt;/p&gt; &#xA;&lt;p&gt;By default Combobulate also binds to the following keys in its minor mode:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;C-M-u&lt;/code&gt; and &lt;code&gt;C-M-d&lt;/code&gt; intelligent navigation in and out of parentheses (as it normally does) but it also stops at useful navigable nodes &lt;code&gt;C-M-n&lt;/code&gt; and &lt;code&gt;C-M-p&lt;/code&gt; moves to/from navigable siblings.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;M-k&lt;/code&gt; kills the navigable node point is in. You can use this to collectively kill larger and larger blocks of code. &lt;code&gt;M-h&lt;/code&gt; marks the navigable node point is on. Like the kill function (or the &lt;em&gt;expand region&lt;/em&gt; package) it grows the mark and point with each repeated invocation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;C-c o j&lt;/code&gt; activates avy and lets you jump to navigable parts of your code. &lt;code&gt;C-c o o&lt;/code&gt; opens the Hydra menu &lt;code&gt;C-c o t&lt;/code&gt; is a prefix map of mode-specific transformations. Currently only used in Javascript and Typescript modes to vanish/wrap JSX elements.&lt;/p&gt; &#xA;&lt;h1&gt;Languages Supported&lt;/h1&gt; &#xA;&lt;p&gt;The following languages are supported out of the box by Combobulate:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Python&lt;/li&gt; &#xA; &lt;li&gt;Typescript + React&lt;/li&gt; &#xA; &lt;li&gt;Javascript + React&lt;/li&gt; &#xA; &lt;li&gt;HTML&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;but&lt;/em&gt;, it&#39;s super easy to add support for new languages. Open &lt;code&gt;combobulate-python.el&lt;/code&gt; for an example of how to do it.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>radian-software/apheleia</title>
    <updated>2022-12-25T01:40:04Z</updated>
    <id>tag:github.com,2022-12-25:/radian-software/apheleia</id>
    <link href="https://github.com/radian-software/apheleia" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üå∑ Run code formatter on buffer contents without moving point, using RCS patches and dynamic programming.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Apheleia&lt;/h1&gt; &#xA;&lt;p&gt;Good code is automatically formatted by tools like &lt;a href=&#34;https://github.com/python/black&#34;&gt;Black&lt;/a&gt; or &lt;a href=&#34;https://prettier.io/&#34;&gt;Prettier&lt;/a&gt; so that you and your team spend less time on formatting and more time on building features. It&#39;s best if your editor can run code formatters each time you save a file, so that you don&#39;t have to look at badly formatted code or get surprised when things change just before you commit. However, running a code formatter on save suffers from the following two problems:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;It takes some time (e.g. around 200ms for Black on an empty file), which makes the editor feel less responsive.&lt;/li&gt; &#xA; &lt;li&gt;It invariably moves your cursor (point) somewhere unexpected if the changes made by the code formatter are too close to point&#39;s position.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Apheleia is an &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt; package which solves both of these problems comprehensively for all languages, allowing you to say goodbye to language-specific packages such as &lt;a href=&#34;https://github.com/proofit404/blacken&#34;&gt;Blacken&lt;/a&gt; and &lt;a href=&#34;https://github.com/prettier/prettier-emacs&#34;&gt;prettier-js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The approach is as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run code formatters on &lt;code&gt;after-save-hook&lt;/code&gt;, rather than &lt;code&gt;before-save-hook&lt;/code&gt;, and do so asynchronously. Once the formatter has finished running, check if the buffer has been modified since it started; only apply the changes if not.&lt;/li&gt; &#xA; &lt;li&gt;After running the code formatter, generate an &lt;a href=&#34;https://tools.ietf.org/doc/tcllib/html/rcs.html#section4&#34;&gt;RCS patch&lt;/a&gt; showing the changes and then apply it to the buffer. This prevents changes elsewhere in the buffer from moving point. If a patch region happens to include point, then use a &lt;a href=&#34;https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm&#34;&gt;dynamic programming algorithm for string alignment&lt;/a&gt; to determine where point should be moved so that it remains in the same place relative to its surroundings. Finally, if the vertical position of point relative to the window has changed, adjust the scroll position to maintain maximum visual continuity. (This includes iterating through all windows displaying the buffer, if there are more than one.) The dynamic programming algorithm runs in quadratic time, which is why it is only applied if necessary and to a single patch region.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Apheleia is available on &lt;a href=&#34;https://melpa.org/&#34;&gt;MELPA&lt;/a&gt;. It is easiest to install it using &lt;a href=&#34;https://github.com/raxod502/straight.el&#34;&gt;&lt;code&gt;straight.el&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(straight-use-package &#39;apheleia)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, you may install using any other package manager if you prefer.&lt;/p&gt; &#xA;&lt;h2&gt;User guide&lt;/h2&gt; &#xA;&lt;p&gt;To your init-file, add the following form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(apheleia-global-mode +1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The autoloading has been configured so that this will &lt;em&gt;not&lt;/em&gt; cause Apheleia to be loaded until you save a file.&lt;/p&gt; &#xA;&lt;p&gt;By default, Apheleia is configured to format with &lt;a href=&#34;https://github.com/python/black&#34;&gt;Black&lt;/a&gt;, &lt;a href=&#34;https://prettier.io/&#34;&gt;Prettier&lt;/a&gt;, and &lt;a href=&#34;https://golang.org/cmd/gofmt/&#34;&gt;Gofmt&lt;/a&gt; on save in all relevant major modes. To configure this, you can adjust the values of the following variables:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-formatters&lt;/code&gt;: Alist mapping names of formatters (symbols like &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;prettier&lt;/code&gt;) to commands used to run those formatters (such as &lt;code&gt;(&#34;black&#34; &#34;-&#34;)&lt;/code&gt; and &lt;code&gt;(npx &#34;prettier&#34; input)&lt;/code&gt;). See the docstring for more information. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can manipulate this alist using standard Emacs functions. For example, to add some command-line options to Black, you could use:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setf (alist-get &#39;black apheleia-formatters)&#xA;      &#39;(&#34;black&#34; &#34;--option&#34; &#34;...&#34; &#34;-&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;There are a list of symbols that are interpreted by apheleia specially when formatting a command (example: &lt;code&gt;npx&lt;/code&gt;). Any non-string entries in a formatter that doesn&#39;t equal one of these symbols is evaluated and replaced in place. This can be used to pass certain flags to the formatter process depending on the state of the current buffer. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(push &#39;(shfmt . (&#34;beautysh&#34;&#xA;                 &#34;-filename&#34; filepath&#xA;                 (when-let ((indent (bound-and-true-p sh-basic-offset)))&#xA;                   (list &#34;--indent-size&#34; (number-to-string indent)))&#xA;                 (when indent-tabs-mode &#34;--tab&#34;)&#xA;                 &#34;-&#34;))&#xA;      apheleia-formatters)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This adds an entry to &lt;code&gt;apheleia-formatters&lt;/code&gt; for the &lt;code&gt;beautysh&lt;/code&gt; formatter. The evaluated entries makes it so that the &lt;code&gt;--tab&lt;/code&gt; flag is only passed to &lt;code&gt;beautysh&lt;/code&gt; when the value of &lt;code&gt;indent-tabs-mode&lt;/code&gt; is true. Similarly the indent-size flag is passed the exact value of the &lt;code&gt;sh-basic-offset&lt;/code&gt; variable only when it is bound. Observe that one of these evaluations returns a list of flags whereas the other returns a single string. These are substituted into the command as you&#39;d expect.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can also use Apheleia to format buffers that have no underlying files. In this case the value of &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;filepath&lt;/code&gt; will be the name of the current buffer with any special characters for the file-system (such as &lt;code&gt;*&lt;/code&gt; on windows) being stripped out.&lt;/p&gt; &lt;p&gt;This is also how the extension for any temporary files apheleia might create will be determined. If you&#39;re using a formatter that determines the file-type from the extension you should name such buffers such that their suffixed with the extension. For example a buffer called &lt;code&gt;*foo-bar.c*&lt;/code&gt; that has no associated file will have an implicit file-name of &lt;code&gt;foo-bar.c&lt;/code&gt; and any temporary files will be suffixed with a &lt;code&gt;.c&lt;/code&gt; extension.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can implement formatters as arbitrary Elisp functions which operate directly on a buffer, without needing to invoke an external command. This can be useful to integrate with e.g. language servers. See the docstring for more information on the expected interface for Elisp formatters.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-mode-alist&lt;/code&gt;: Alist mapping major modes and filename regexps to names of formatters to use in those modes and files. See the docstring for more information. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can use this variable to configure multiple formatters for the same buffer by setting the &lt;code&gt;cdr&lt;/code&gt; of an entry to a list of formatters to run instead of a single formatter. For example you may want to run &lt;code&gt;isort&lt;/code&gt; and &lt;code&gt;black&lt;/code&gt; one after the other.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setf (alist-get &#39;isort apheleia-formatters)&#xA;      &#39;(&#34;isort&#34; &#34;--stdout&#34; &#34;-&#34;))&#xA;(setf (alist-get &#39;python-mode apheleia-mode-alist)&#xA;      &#39;(isort black))&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This will make apheleia run &lt;code&gt;isort&lt;/code&gt; on the current buffer and then &lt;code&gt;black&lt;/code&gt; on the result of &lt;code&gt;isort&lt;/code&gt; and then use the final output to format the current buffer.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: At the moment there&#39;s no smart or configurable error handling in place. This means if one of the configured formatters fail (for example if &lt;code&gt;isort&lt;/code&gt; isn&#39;t installed) then apheleia just doesn&#39;t format the buffer at all, even if &lt;code&gt;black&lt;/code&gt; is installed.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; If a formatter uses &lt;code&gt;file&lt;/code&gt; (rather than &lt;code&gt;filepath&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt; or none of these keywords), it can&#39;t be chained after another formatter, because &lt;code&gt;file&lt;/code&gt; implies that the formatter must read from the &lt;em&gt;original&lt;/em&gt; file, not an intermediate temporary file. For this reason it&#39;s suggested to avoid the use of &lt;code&gt;file&lt;/code&gt; in general.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-formatter&lt;/code&gt;: Optional buffer-local variable specifying the formatter to use in this buffer. Overrides &lt;code&gt;apheleia-mode-alist&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-inhibit&lt;/code&gt;: Optional buffer-local variable, if set to non-nil then Apheleia does not turn on automatically even if &lt;code&gt;apheleia-global-mode&lt;/code&gt; is on.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can run &lt;code&gt;M-x apheleia-mode&lt;/code&gt; to toggle automatic formatting on save in a single buffer, or &lt;code&gt;M-x apheleia-global-mode&lt;/code&gt; to toggle the default setting for all buffers. Also, even if &lt;code&gt;apheleia-mode&lt;/code&gt; is not enabled, you can run &lt;code&gt;M-x apheleia-format-buffer&lt;/code&gt; to manually invoke the configured formatter for the current buffer. Running with a prefix argument will cause the command to prompt you for which formatter to run.&lt;/p&gt; &#xA;&lt;p&gt;Apheleia does not currently support TRAMP, and is therefore automatically disabled for remote files.&lt;/p&gt; &#xA;&lt;p&gt;If an error occurs while formatting, a message is displayed in the echo area. You can jump to the error by invoking &lt;code&gt;M-x apheleia-goto-error&lt;/code&gt;, or manually switch to the log buffer mentioned in the message.&lt;/p&gt; &#xA;&lt;p&gt;You can configure error reporting using the following user options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-hide-log-buffers&lt;/code&gt;: By default, errors from formatters are put in buffers named like &lt;code&gt;*apheleia-cmdname-log*&lt;/code&gt;. If you customize this user option to non-nil then a space is prepended to the names of these buffers, hiding them by default in &lt;code&gt;switch-to-buffer&lt;/code&gt; (you must type a space to see them).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-log-only-errors&lt;/code&gt;: By default, only failed formatter runs are logged. If you customize this user option to nil then all runs are logged, along with whether or not they succeeded. This could be helpful in debugging.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following user options are also available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-post-format-hook&lt;/code&gt;: Normal hook run after Apheleia formats a buffer. Run if the formatting is successful, even when no changes are made to the buffer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-max-alignment-size&lt;/code&gt;: The maximum number of characters that a diff region can have to be processed using Apheleia&#39;s dynamic programming algorithm for point alignment. This cannot be too big or Emacs will hang noticeably on large reformatting operations, since the DP algorithm is quadratic-time.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-mode-lighter&lt;/code&gt;: &lt;code&gt;apheleia-mode&lt;/code&gt; lighter displayed in the mode-line. If you don&#39;t want to display it, use nil. Otherwise, its value must be a string.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Apheleia exposes some hooks for advanced customization:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;apheleia-formatter-exited-hook&lt;/code&gt;: Abnormal hook which is run after a formatter has completely finished running for a buffer. Not run if the formatting was interrupted and no action was taken. Receives two arguments: the symbol for the formatter that was run (e.g. &lt;code&gt;black&lt;/code&gt;, or it could be a list if multiple formatters were run in a chain), and a boolean for whether there was an error.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;apheleia-inhibit-functions&lt;/code&gt;: List of functions to run before turning on Apheleia automatically from &lt;code&gt;apheleia-global-mode&lt;/code&gt;. If one of these returns non-nil then &lt;code&gt;apheleia-mode&lt;/code&gt; is not enabled in the buffer.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Known issues&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;process aphelieia-whatever no longer connected to pipe; closed it&lt;/code&gt;: This happens on older Emacs versions when formatting a buffer with size greater than 65,536 characters. There is no known workaround besides disabling &lt;code&gt;apheleia-mode&lt;/code&gt; for the affected buffer, or upgrading to a more recent version of Emacs. See &lt;a href=&#34;https://github.com/raxod502/apheleia/issues/20&#34;&gt;#20&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/raxod502/contributor-guide&#34;&gt;the contributor guide for my projects&lt;/a&gt; for general information, and the following sections for Apheleia-specific details.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s also a &lt;a href=&#34;https://github.com/radian-software/apheleia/wiki&#34;&gt;wiki&lt;/a&gt; that could do with additions/clarity. Any improvement suggestions should be submitted as an issue.&lt;/p&gt; &#xA;&lt;h3&gt;Adding a formatter&lt;/h3&gt; &#xA;&lt;p&gt;I have done my best to make it straightforward to add a formatter. You just follow these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install your formatter on your machine so you can test.&lt;/li&gt; &#xA; &lt;li&gt;Create an entry in &lt;code&gt;apheleia-formatters&lt;/code&gt; with how to run it. (See the docstring of this variable for explanation about the available keywords.)&lt;/li&gt; &#xA; &lt;li&gt;Add entries for the relevant major modes in &lt;code&gt;apheleia-mode-alist&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;See if it works for you!&lt;/li&gt; &#xA; &lt;li&gt;Add a file at &lt;code&gt;test/formatters/installers/yourformatter.bash&lt;/code&gt; which explains how to install the formatter on Ubuntu. This will be used by CI.&lt;/li&gt; &#xA; &lt;li&gt;Test with &lt;code&gt;make fmt-build FORMATTERS=yourformatter&lt;/code&gt; to do the installation, then &lt;code&gt;make fmt-docker&lt;/code&gt; to start a shell with the formatter available. Verify it runs in this environment.&lt;/li&gt; &#xA; &lt;li&gt;Add an example input (pre-formatting) and output (post-formatting) file at &lt;code&gt;test/formatters/samplecode/yourformatter/in.whatever&lt;/code&gt; and &lt;code&gt;test/formatters/samplecode/yourformatter/out.whatever&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Verify that the tests are passing, using &lt;code&gt;make fmt-test FORMATTERS=yourformatter&lt;/code&gt; from inside the &lt;code&gt;fmt-docker&lt;/code&gt; shell.&lt;/li&gt; &#xA; &lt;li&gt;Submit a pull request, CI should now be passing!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;I got the idea for using RCS patches to avoid moving point too much from &lt;a href=&#34;https://github.com/prettier/prettier-emacs&#34;&gt;prettier-js&lt;/a&gt;, although that package does not implement the dynamic programming algorithm which Apheleia uses to guarantee stability of point even within a formatted region.&lt;/p&gt; &#xA;&lt;p&gt;Note that despite this inspiration, Apheleia is a clean-room implementation which is free of the copyright terms of prettier-js.&lt;/p&gt;</summary>
  </entry>
</feed>