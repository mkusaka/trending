<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-11T01:41:37Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jorgenschaefer/emacs-buttercup</title>
    <updated>2022-12-11T01:41:37Z</updated>
    <id>tag:github.com,2022-12-11:/jorgenschaefer/emacs-buttercup</id>
    <link href="https://github.com/jorgenschaefer/emacs-buttercup" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Behavior-Driven Emacs Lisp Testing&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Buttercup — Behavior-Driven Emacs Lisp Testing&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jorgenschaefer/emacs-buttercup/actions?query=workflow%3A%22Build+and+test%22+branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/jorgenschaefer/emacs-buttercup/workflows/Build%20and%20test/badge.svg?sanitize=true&#34; alt=&#34;Build and test&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.nongnu.org/nongnu/buttercup.html&#34;&gt;&lt;img src=&#34;https://elpa.nongnu.org/nongnu/buttercup.svg?sanitize=true&#34; alt=&#34;NonGNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/buttercup&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/buttercup-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jorgenschaefer/emacs-buttercup/master/docs/images/buttercup.jpg&#34; alt=&#34;Ranculus repens, photo by sannse&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Buttercup is a behavior-driven development framework for testing Emacs Lisp code. It allows to group related tests so they can share common set-up and tear-down code, and allows the programmer to “spy” on functions to ensure they are called with the right arguments during testing.&lt;/p&gt; &#xA;&lt;p&gt;The framework is heavily inspired by &lt;a href=&#34;https://jasmine.github.io/edge/introduction.html&#34;&gt;Jasmine&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Full article: &lt;a href=&#34;https://raw.githubusercontent.com/jorgenschaefer/emacs-buttercup/master/docs/writing-tests.md&#34;&gt;Writing Tests&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;A simple test looks like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Lisp&#34;&gt;(describe &#34;A suite&#34;&#xA;  (it &#34;contains a spec with an expectation&#34;&#xA;    (expect t :to-be t)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation and Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Full article: &lt;a href=&#34;https://raw.githubusercontent.com/jorgenschaefer/emacs-buttercup/master/docs/running-tests.md&#34;&gt;Running Tests&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can install buttercup from &lt;a href=&#34;https://elpa.nongnu.org/&#34;&gt;NonGNU ELPA&lt;/a&gt; or &lt;a href=&#34;http://stable.melpa.org/&#34;&gt;MELPA Stable&lt;/a&gt;. Add the following to your &lt;code&gt;init.el&lt;/code&gt; or &lt;code&gt;.emacs&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;package)&#xA;;; Available as a default in GNU Emacs from version 28.1&#xA;(add-to-list &#39;package-archives&#xA;             (&#34;nongnu&#34; . &#34;https://elpa.nongnu.org/nongnu/&#34;) t)&#xA;(add-to-list &#39;package-archives&#xA;             &#39;(&#34;melpa-stable&#34; . &#34;http://stable.melpa.org/packages/&#34;) t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This should allow you to &lt;code&gt;M-x package-install RET buttercup RET&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, users of Debian 9 or later or Ubuntu 16.10 or later may simply &lt;code&gt;apt-get install elpa-buttercup&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Now create a file called &lt;code&gt;test-feature.el&lt;/code&gt; with these contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Lisp&#34;&gt;(describe &#34;A suite&#34;&#xA;  (it &#34;contains a spec with an expectation&#34;&#xA;    (expect t :to-be t)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now use buttercup to run this test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ emacs -batch -f package-initialize -L . -f buttercup-run-discover&#xA;Running 1 specs.&#xA;&#xA;A suite&#xA;  contains a spec with an expectation&#xA;&#xA;Ran 1 specs, 0 failed, in 0.0 seconds.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Congratulations, you ran your first test!&lt;/p&gt; &#xA;&lt;h2&gt;Feature List&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Shared set-up and tear-down sections to reduce code repetition and share a common environment among tests.&lt;/li&gt; &#xA; &lt;li&gt;Easy to read and extensible &lt;code&gt;expect&lt;/code&gt; macro to describe expected behavior.&lt;/li&gt; &#xA; &lt;li&gt;Powerful mocking framework, called “spies,” to both cause them to return expected values or throw errors as needed by the test, as well as to ensure functions are called with expected arguments during tests.&lt;/li&gt; &#xA; &lt;li&gt;Built to be run within a Continuous Integration environment, including test runners to discover and execute tests in a directory tree.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Why not ERT?&lt;/h3&gt; &#xA;&lt;p&gt;Emacs comes with a testing framework, &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/ert.html&#34;&gt;ERT&lt;/a&gt;. Buttercup was written to address some shortcomings of that framework.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ERT &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/ert.html#Fixtures-and-Test-Suites&#34;&gt;deliberately leaves it up to the programmer to define set-up and tear-down code&lt;/a&gt;, which requires a lot of boiler-plate code for every set-up function. Buttercup makes this easy and seamless.&lt;/li&gt; &#xA; &lt;li&gt;ERT has no good way of being run in a continuous integration environment. There are &lt;a href=&#34;https://github.com/rejeep/ert-runner.el&#34;&gt;external projects to make this less of a pain&lt;/a&gt; instead. Once all is said and done, you installed six external packages your project does not need just to run your own tests. And that does not include a mocking library.&lt;/li&gt; &#xA; &lt;li&gt;ERT has no way of grouping related tests, requiring every test name to share the same prefix, making names long and hard to read.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Nonetheless, ERT is a great project. It introduced testing to Emacs, and Buttercup learned a lot from its code to record a stack trace for error display. Even though Buttercup tries to be a better testing framework than ERT, we do wish ERT and the ERT maintainers all the best and hope both frameworks can continue to benefit from each other.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>abo-abo/hydra</title>
    <updated>2022-12-11T01:41:37Z</updated>
    <id>tag:github.com,2022-12-11:/abo-abo/hydra</id>
    <link href="https://github.com/abo-abo/hydra" rel="alternate"></link>
    <summary type="html">&lt;p&gt;make Emacs bindings that stick around&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Hydra&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/abo-abo/hydra&#34;&gt;&lt;img src=&#34;https://travis-ci.org/abo-abo/hydra.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.gnu.org/packages/hydra.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/packages/hydra.svg?sanitize=true&#34; alt=&#34;GNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/hydra&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/hydra-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/hydra&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/hydra-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://oremacs.com/download/Hydra.jpg&#34; alt=&#34;hydra&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Description for Poets&lt;/h2&gt; &#xA;&lt;p&gt;Once you summon the Hydra through the prefixed binding (the body + any one head), all heads can be called in succession with only a short extension.&lt;/p&gt; &#xA;&lt;p&gt;The Hydra is vanquished once Hercules, any binding that isn&#39;t the Hydra&#39;s head, arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his original purpose, calling his proper command. This makes the Hydra very seamless, it&#39;s like a minor mode that disables itself auto-magically.&lt;/p&gt; &#xA;&lt;h2&gt;Description for Pragmatics&lt;/h2&gt; &#xA;&lt;p&gt;Imagine that you have bound &lt;kbd&gt;C-c j&lt;/kbd&gt; and &lt;kbd&gt;C-c k&lt;/kbd&gt; in your config. You want to call &lt;kbd&gt;C-c j&lt;/kbd&gt; and &lt;kbd&gt;C-c k&lt;/kbd&gt; in some (arbitrary) sequence. Hydra allows you to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Bind your functions in a way that pressing &lt;kbd&gt;C-c jjkk3j5k&lt;/kbd&gt; is equivalent to pressing &lt;kbd&gt;C-c j C-c j C-c k C-c k M-3 C-c j M-5 C-c k&lt;/kbd&gt;. Any key other than &lt;kbd&gt;j&lt;/kbd&gt; or &lt;kbd&gt;k&lt;/kbd&gt; exits this state.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Assign a custom hint to this group of functions, so that you know immediately after pressing &lt;kbd&gt;C-c&lt;/kbd&gt; that you can follow up with &lt;kbd&gt;j&lt;/kbd&gt; or &lt;kbd&gt;k&lt;/kbd&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to quickly understand the concept, see &lt;a href=&#34;https://www.youtube.com/watch?v=_qZliI1BKzI&#34;&gt;the video demo&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc/generate-toc again --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#sample-hydras&#34;&gt;Sample Hydras&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#the-one-with-the-least-amount-of-code&#34;&gt;The one with the least amount of code&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#the-impressive-looking-one&#34;&gt;The impressive-looking one&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#community-wiki&#34;&gt;Community wiki&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#the-rules-of-hydra-tics&#34;&gt;The Rules of Hydra-tics&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#hydra-awesome&#34;&gt;&lt;code&gt;hydra-awesome&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#awesome-map-and-awesome-binding&#34;&gt;&lt;code&gt;awesome-map&lt;/code&gt; and &lt;code&gt;awesome-binding&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#awesome-plist&#34;&gt;&lt;code&gt;awesome-plist&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#pre-and-post&#34;&gt;&lt;code&gt;:pre&lt;/code&gt; and &lt;code&gt;:post&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#exit&#34;&gt;&lt;code&gt;:exit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#foreign-keys&#34;&gt;&lt;code&gt;:foreign-keys&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#color&#34;&gt;&lt;code&gt;:color&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#timeout&#34;&gt;&lt;code&gt;:timeout&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#hint&#34;&gt;&lt;code&gt;:hint&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#bind&#34;&gt;&lt;code&gt;:bind&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#awesome-docstring&#34;&gt;&lt;code&gt;awesome-docstring&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#awesome-head-1&#34;&gt;&lt;code&gt;awesome-head-1&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#head-binding&#34;&gt;&lt;code&gt;head-binding&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#head-command&#34;&gt;&lt;code&gt;head-command&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#head-hint&#34;&gt;&lt;code&gt;head-hint&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#head-plist&#34;&gt;&lt;code&gt;head-plist&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;h1&gt;Sample Hydras&lt;/h1&gt; &#xA;&lt;h2&gt;The one with the least amount of code&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defhydra hydra-zoom (global-map &#34;&amp;lt;f2&amp;gt;&#34;)&#xA;  &#34;zoom&#34;&#xA;  (&#34;g&#34; text-scale-increase &#34;in&#34;)&#xA;  (&#34;l&#34; text-scale-decrease &#34;out&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this simple code, you can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Start zooming in with &lt;kbd&gt;&amp;lt;f2&amp;gt; g&lt;/kbd&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Continue to zoom in with &lt;kbd&gt;g&lt;/kbd&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Or zoom out with &lt;kbd&gt;l&lt;/kbd&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Zoom in five times at once with &lt;kbd&gt;5g&lt;/kbd&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Stop zooming with &lt;em&gt;any&lt;/em&gt; key that isn&#39;t &lt;kbd&gt;g&lt;/kbd&gt; or &lt;kbd&gt;l&lt;/kbd&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For any Hydra:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;digit-argument&lt;/code&gt; can be called with &lt;kbd&gt;0&lt;/kbd&gt;-&lt;kbd&gt;9&lt;/kbd&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;negative-argument&lt;/code&gt; can be called with &lt;kbd&gt;-&lt;/kbd&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;universal-argument&lt;/code&gt; can be called with &lt;kbd&gt;C-u&lt;/kbd&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;The impressive-looking one&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s the result of pressing &lt;kbd&gt;.&lt;/kbd&gt; in the good-old Buffer menu:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://oremacs.com/download/hydra-buffer-menu.png&#34; alt=&#34;hydra-buffer-menu&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The code is large but very simple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defhydra hydra-buffer-menu (:color pink&#xA;                             :hint nil)&#xA;  &#34;&#xA;^Mark^             ^Unmark^           ^Actions^          ^Search&#xA;^^^^^^^^-----------------------------------------------------------------&#xA;_m_: mark          _u_: unmark        _x_: execute       _R_: re-isearch&#xA;_s_: save          _U_: unmark up     _b_: bury          _I_: isearch&#xA;_d_: delete        ^ ^                _g_: refresh       _O_: multi-occur&#xA;_D_: delete up     ^ ^                _T_: files only: % -28`Buffer-menu-files-only&#xA;_~_: modified&#xA;&#34;&#xA;  (&#34;m&#34; Buffer-menu-mark)&#xA;  (&#34;u&#34; Buffer-menu-unmark)&#xA;  (&#34;U&#34; Buffer-menu-backup-unmark)&#xA;  (&#34;d&#34; Buffer-menu-delete)&#xA;  (&#34;D&#34; Buffer-menu-delete-backwards)&#xA;  (&#34;s&#34; Buffer-menu-save)&#xA;  (&#34;~&#34; Buffer-menu-not-modified)&#xA;  (&#34;x&#34; Buffer-menu-execute)&#xA;  (&#34;b&#34; Buffer-menu-bury)&#xA;  (&#34;g&#34; revert-buffer)&#xA;  (&#34;T&#34; Buffer-menu-toggle-files-only)&#xA;  (&#34;O&#34; Buffer-menu-multi-occur :color blue)&#xA;  (&#34;I&#34; Buffer-menu-isearch-buffers :color blue)&#xA;  (&#34;R&#34; Buffer-menu-isearch-buffers-regexp :color blue)&#xA;  (&#34;c&#34; nil &#34;cancel&#34;)&#xA;  (&#34;v&#34; Buffer-menu-select &#34;select&#34; :color blue)&#xA;  (&#34;o&#34; Buffer-menu-other-window &#34;other-window&#34; :color blue)&#xA;  (&#34;q&#34; quit-window &#34;quit&#34; :color blue))&#xA;&#xA;(define-key Buffer-menu-mode-map &#34;.&#34; &#39;hydra-buffer-menu/body)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Looking at the code, you can see &lt;code&gt;hydra-buffer-menu&lt;/code&gt; as sort of a namespace construct that wraps each function that it&#39;s given in code that shows that hint and makes it easy to call the related functions. One additional function is created and returned as the result of &lt;code&gt;defhydra&lt;/code&gt; - &lt;code&gt;hydra-buffer-menu/body&lt;/code&gt;. This function does nothing except setting up the hint and the keymap, and is usually the entry point to complex hydras.&lt;/p&gt; &#xA;&lt;p&gt;To write your own hydras, you can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Either modify an existing hydra to do what you want to do.&lt;/li&gt; &#xA; &lt;li&gt;Or read &lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/hydra/master/#the-rules-of-hydra-tics&#34;&gt;the rules&lt;/a&gt;, &lt;a href=&#34;https://github.com/abo-abo/hydra/raw/master/hydra-examples.el&#34;&gt;the examples&lt;/a&gt;, the docstrings and comments in the source.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Community wiki&lt;/h1&gt; &#xA;&lt;p&gt;You can find some user created hydras and more documentation in the project&#39;s &lt;a href=&#34;https://github.com/abo-abo/hydra/wiki/&#34;&gt;community wiki&lt;/a&gt;. Feel free to add your own or edit the existing ones.&lt;/p&gt; &#xA;&lt;h1&gt;The Rules of Hydra-tics&lt;/h1&gt; &#xA;&lt;p&gt;Each hydra (take &lt;code&gt;awesome&lt;/code&gt; as a prefix to make it more specific) looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defhydra hydra-awesome (awesome-map awesome-binding awesome-plist)&#xA;  awesome-docstring&#xA;  awesome-head-1&#xA;  awesome-head-2&#xA;  awesome-head-3&#xA;  ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;hydra-awesome&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Each hydra needs a name, and this one is named &lt;code&gt;hydra-awesome&lt;/code&gt;. You can name your hydras as you wish, but I prefer to start each one with &lt;code&gt;hydra-&lt;/code&gt;, because it acts as an additional namespace layer, for example: &lt;code&gt;hydra-zoom&lt;/code&gt;, &lt;code&gt;hydra-helm&lt;/code&gt;, &lt;code&gt;hydra-apropos&lt;/code&gt; etc.&lt;/p&gt; &#xA;&lt;p&gt;If you name your hydra &lt;code&gt;hydra-awesome&lt;/code&gt;, the return result of &lt;code&gt;defhydra&lt;/code&gt; will be &lt;code&gt;hydra-awesome/body&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s what &lt;code&gt;hydra-zoom/body&lt;/code&gt; looks like, if you&#39;re interested:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun hydra-zoom/body ()&#xA;  &#34;Call the body in the \&#34;hydra-zoom\&#34; hydra.&#xA;&#xA;The heads for the associated hydra are:&#xA;&#xA;\&#34;g\&#34;:    `text-scale-increase&#39;,&#xA;\&#34;l\&#34;:    `text-scale-decrease&#39;&#xA;&#xA;The body can be accessed via `hydra-zoom/body&#39;, which is bound to \&#34;&amp;lt;f2&amp;gt;\&#34;.&#34;&#xA;  (interactive)&#xA;  (require &#39;hydra)&#xA;  (hydra-default-pre)&#xA;  (let ((hydra--ignore nil))&#xA;    (hydra-keyboard-quit)&#xA;    (setq hydra-curr-body-fn&#xA;          &#39;hydra-zoom/body))&#xA;  (hydra-show-hint&#xA;   hydra-zoom/hint&#xA;   &#39;hydra-zoom)&#xA;  (hydra-set-transient-map&#xA;   hydra-zoom/keymap&#xA;   (lambda nil&#xA;     (hydra-keyboard-quit)&#xA;     nil)&#xA;   nil)&#xA;  (setq prefix-arg&#xA;        current-prefix-arg))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;awesome-map&lt;/code&gt; and &lt;code&gt;awesome-binding&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This can be any keymap, for instance, &lt;code&gt;global-map&lt;/code&gt; or &lt;code&gt;isearch-mode-map&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For this example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defhydra hydra-zoom (global-map &#34;&amp;lt;f2&amp;gt;&#34;)&#xA;  &#34;zoom&#34;&#xA;  (&#34;g&#34; text-scale-increase &#34;in&#34;)&#xA;  (&#34;l&#34; text-scale-decrease &#34;out&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;awesome-map&lt;/code&gt; is &lt;code&gt;global-map&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;awesome-binding&lt;/code&gt; is &lt;code&gt;&#34;&amp;lt;f2&amp;gt;&#34;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And here&#39;s the relevant generated code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(unless (keymapp (lookup-key global-map (kbd &#34;&amp;lt;f2&amp;gt;&#34;)))&#xA;  (define-key global-map (kbd &#34;&amp;lt;f2&amp;gt;&#34;) nil))&#xA;(define-key global-map [f2 103]&#xA;  (function hydra-zoom/text-scale-increase))&#xA;(define-key global-map [f2 108]&#xA;  (function hydra-zoom/text-scale-decrease))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you see, &lt;code&gt;&#34;&amp;lt;f2&amp;gt;&#34;&lt;/code&gt; is used as a prefix for &lt;kbd&gt;g&lt;/kbd&gt; (char value 103) and &lt;kbd&gt;l&lt;/kbd&gt; (char value 108).&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t want to use a map right now, you can skip it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defhydra hydra-zoom (nil nil)&#xA;  &#34;zoom&#34;&#xA;  (&#34;g&#34; text-scale-increase &#34;in&#34;)&#xA;  (&#34;l&#34; text-scale-decrease &#34;out&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or even simpler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defhydra hydra-zoom ()&#xA;  &#34;zoom&#34;&#xA;  (&#34;g&#34; text-scale-increase &#34;in&#34;)&#xA;  (&#34;l&#34; text-scale-decrease &#34;out&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But then you would have to bind &lt;code&gt;hydra-zoom/text-scale-increase&lt;/code&gt; and &lt;code&gt;hydra-zoom/text-scale-decrease&lt;/code&gt; yourself.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;awesome-plist&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;You can read up on what a plist is in &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/elisp/Property-Lists.html&#34;&gt;the Elisp manual&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;awesome-plist&lt;/code&gt; to modify the behavior of each head in some way. Below is a list of each key.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;:pre&lt;/code&gt; and &lt;code&gt;:post&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can specify code that will be called before each head, and after the body. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defhydra hydra-vi (:pre (set-cursor-color &#34;#40e0d0&#34;)&#xA;                    :post (progn&#xA;                            (set-cursor-color &#34;#ffffff&#34;)&#xA;                            (message&#xA;                             &#34;Thank you, come again.&#34;)))&#xA;  &#34;vi&#34;&#xA;  (&#34;l&#34; forward-char)&#xA;  (&#34;h&#34; backward-char)&#xA;  (&#34;j&#34; next-line)&#xA;  (&#34;k&#34; previous-line)&#xA;  (&#34;q&#34; nil &#34;quit&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Thanks to &lt;code&gt;:pre&lt;/code&gt;, each time any head is called, the cursor color is changed. And when the hydra quits, the cursor color will be made black again with &lt;code&gt;:post&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;:exit&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:exit&lt;/code&gt; key is inherited by every head (they can override it) and influences what will happen after executing head&#39;s command:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:exit nil&lt;/code&gt; (the default) means that the hydra state will continue - you&#39;ll still see the hint and be able to use short bindings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:exit t&lt;/code&gt; means that the hydra state will stop.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;:foreign-keys&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:foreign-keys&lt;/code&gt; key belongs to the body and decides what to do when a key is pressed that doesn&#39;t belong to any head:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:foreign-keys nil&lt;/code&gt; (the default) means that the hydra state will stop and the foreign key will do whatever it was supposed to do if there was no hydra state.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:foreign-keys warn&lt;/code&gt; will not stop the hydra state, but instead will issue a warning without running the foreign key.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:foreign-keys run&lt;/code&gt; will not stop the hydra state, and try to run the foreign key.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;:color&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:color&lt;/code&gt; key is a shortcut. It aggregates &lt;code&gt;:exit&lt;/code&gt; and &lt;code&gt;:foreign-keys&lt;/code&gt; key in the following way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;| color    | toggle                     |&#xA;|----------+----------------------------|&#xA;| red      |                            |&#xA;| blue     | :exit t                    |&#xA;| amaranth | :foreign-keys warn         |&#xA;| teal     | :foreign-keys warn :exit t |&#xA;| pink     | :foreign-keys run          |&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s also a trick to make you instantly aware of the current hydra keys that you&#39;re about to press: the keys will be highlighted with the appropriate color.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;:timeout&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:timeout&lt;/code&gt; key starts a timer for the corresponding amount of seconds that disables the hydra. Calling any head will refresh the timer.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;:hint&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:hint&lt;/code&gt; key will be inherited by each head. Each head is allowed to override it, of course. One value that makes sense is &lt;code&gt;:hint nil&lt;/code&gt;. See below for an explanation of head hint.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;:bind&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;:bind&lt;/code&gt; key provides a lambda to be used to bind each head. This is quite advanced and rarely used, you&#39;re not likely to need it. But if you would like to bind your heads with e.g. &lt;code&gt;bind-key&lt;/code&gt; instead of &lt;code&gt;define-key&lt;/code&gt; you can use this option.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;:bind&lt;/code&gt; key can be overridden by each head. This is useful if you want to have a few heads that are not bound outside the hydra.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;:base-map&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Use this option if you want to override &lt;code&gt;hydra-base-map&lt;/code&gt; for the current hydra.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;awesome-docstring&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This can be a simple string used to build the final hydra hint. However, if you start it with a newline, the key-highlighting and Ruby-style string interpolation becomes enabled, as you can see in &lt;code&gt;hydra-buffer-menu&lt;/code&gt; above.&lt;/p&gt; &#xA;&lt;p&gt;To highlight a key, just wrap it in underscores. Note that the key must belong to one of the heads. The key will be highlighted with the color that is appropriate to the behavior of the key, i.e. if the key will make the hydra exit, the color will be blue.&lt;/p&gt; &#xA;&lt;p&gt;To insert an empty character, use &lt;code&gt;^&lt;/code&gt;. The only use of this is to have your code aligned as nicely as the result.&lt;/p&gt; &#xA;&lt;p&gt;To insert a dynamic Elisp variable, use &lt;code&gt;%&lt;/code&gt;` followed by the variable. Each time the variable changes due to a head, the docstring will be updated. &lt;code&gt;format&lt;/code&gt;-style width specifiers can be used.&lt;/p&gt; &#xA;&lt;p&gt;To insert a dynamic Elisp expression, use e.g. &lt;code&gt;%(length (dired-get-marked-files))&lt;/code&gt;. If a head will change the amount of marked files, for example, it will be appropriately updated.&lt;/p&gt; &#xA;&lt;p&gt;If the result of the Elisp expression is a string and you don&#39;t want to quote it, use this form: &lt;code&gt;%s(shell-command-to-string &#34;du -hs&#34;)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;awesome-head-1&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Each head looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(head-binding head-command head-hint head-plist)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the head &lt;code&gt;(&#34;g&#34; text-scale-increase &#34;in&#34;)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;head-binding&lt;/code&gt; is &lt;code&gt;&#34;g&#34;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;head-command&lt;/code&gt; is &lt;code&gt;text-scale-increase&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;head-hint&lt;/code&gt; is &lt;code&gt;&#34;in&#34;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;head-plist&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;head-binding&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;head-binding&lt;/code&gt; is a string that can be passed to &lt;code&gt;kbd&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;head-command&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;head-command&lt;/code&gt; can be:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;command name, like &lt;code&gt;text-scale-increase&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;a lambda, like&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  (&#34;g&#34; (lambda ()&#xA;         (interactive)&#xA;         (let ((current-prefix-arg 4))&#xA;           (call-interactively #&#39;magit-status)))&#xA;       &#34;git&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;nil, which exits the hydra.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;a single sexp, which will be wrapped in an interactive lambda.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here&#39;s an example of the last option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defhydra hydra-launcher (:color blue)&#xA;   &#34;Launch&#34;&#xA;   (&#34;h&#34; man &#34;man&#34;)&#xA;   (&#34;r&#34; (browse-url &#34;http://www.reddit.com/r/emacs/&#34;) &#34;reddit&#34;)&#xA;   (&#34;w&#34; (browse-url &#34;http://www.emacswiki.org/&#34;) &#34;emacswiki&#34;)&#xA;   (&#34;s&#34; shell &#34;shell&#34;)&#xA;   (&#34;q&#34; nil &#34;cancel&#34;))&#xA;(global-set-key (kbd &#34;C-c r&#34;) &#39;hydra-launcher/body)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;head-hint&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;In case of a large body docstring, you usually don&#39;t want the head hint to show up, since you&#39;ve already documented it in the body docstring. You can set the head hint to &lt;code&gt;nil&lt;/code&gt; to do this.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defhydra hydra-zoom (global-map &#34;&amp;lt;f2&amp;gt;&#34;)&#xA;  &#34;&#xA;Press _g_ to zoom in.&#xA;&#34;&#xA;  (&#34;g&#34; text-scale-increase nil)&#xA;  (&#34;l&#34; text-scale-decrease &#34;out&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;head-plist&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Here&#39;s a list of body keys that can be overridden in each head:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:exit&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:color&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:bind&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:column&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Use &lt;code&gt;:column&lt;/code&gt; feature to have an aligned rectangular docstring without defining it manually. See &lt;a href=&#34;https://github.com/abo-abo/hydra/raw/05871dd6c8af7b2268bd1a10eb9f8a3e423209cd/hydra-examples.el#L337&#34;&gt;hydra-examples.el&lt;/a&gt; for an example code.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>hlissner/emacs-hide-mode-line</title>
    <updated>2022-12-11T01:41:37Z</updated>
    <id>tag:github.com,2022-12-11:/hlissner/emacs-hide-mode-line</id>
    <link href="https://github.com/hlissner/emacs-hide-mode-line" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An Emacs plugin that hides (or masks) the current buffer&#39;s mode-line&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;http://melpa.org/#/hide-mode-line&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/hide-mode-line-badge.svg?style=flat-square&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/hlissner/emacs-hide-mode-line/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-green.svg?style=flat-square&#34; alt=&#34;MIT&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;hide-mode-line&lt;/h1&gt; &#xA;&lt;p&gt;Provides &lt;code&gt;hide-mode-line-mode&lt;/code&gt;. A minor mode that hides (or masks) the mode-line in your current buffer. It can be used to toggle an alternative mode-line, toggle its visibility, or simply disable the mode-line in buffers where it isn&#39;t very useful otherwise.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Extracted from &lt;code&gt;doom-hide-modeline-mode&lt;/code&gt; in &lt;a href=&#34;https://github.com/hlissner/doom-emacs&#34;&gt;Doom Emacs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;hide-mode-line&lt;/code&gt; is available on MELPA.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;M-x package-install hide-mode-line&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;hide-mode-line)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add &lt;code&gt;hide-mode-line-mode&lt;/code&gt; to hooks where you don&#39;t want a mode-line, like the completion-list or org todo/agenda-popup windows, or neotree.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(add-hook &#39;completion-list-mode-hook #&#39;hide-mode-line-mode)&#xA;(add-hook &#39;neotree-mode-hook #&#39;hide-mode-line-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or replace the mode-line in specific windows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(let ((hide-mode-line-format &#39;(&#34;%b&#34;)))&#xA;  (hide-mode-line-mode +1))&#xA;&#xA;(setq-local hide-mode-line-format &#39;(&#34;%b&#34;))&#xA;(hide-mode-line-mode +1)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>