<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-03-02T01:47:02Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>magnars/dash.el</title>
    <updated>2025-03-02T01:47:02Z</updated>
    <id>tag:github.com,2025-03-02:/magnars/dash.el</id>
    <link href="https://github.com/magnars/dash.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A modern list library for Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/magnars/dash.el/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/magnars/dash.el/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.gnu.org/packages/dash.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/packages/dash.svg?sanitize=true&#34; alt=&#34;GNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.gnu.org/devel/dash.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/devel/dash.svg?sanitize=true&#34; alt=&#34;GNU-devel ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/dash&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/dash-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/dash&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/dash-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;&lt;img align=&#34;right&#34; src=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/rainbow-dash.png&#34;&gt; dash.el&lt;/h1&gt; &#xA;&lt;p&gt;A modern list API for Emacs. No &lt;a href=&#34;https://gnu.org/software/emacs/manual/html_node/cl/&#34;&gt;&lt;code&gt;&#39;cl&lt;/code&gt;&lt;/a&gt; required.&lt;/p&gt; &#xA;&lt;p&gt;See the end of the file for license conditions.&lt;/p&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#change-log&#34;&gt;Change log&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#functions&#34;&gt;Functions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#contribute&#34;&gt;Contribute&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#contributors&#34;&gt;Contributors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Change log&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/NEWS.md&#34;&gt;&lt;code&gt;NEWS.md&lt;/code&gt;&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Dash is available on &lt;a href=&#34;https://elpa.gnu.org/&#34;&gt;GNU ELPA&lt;/a&gt;, &lt;a href=&#34;https://elpa.gnu.org/devel/&#34;&gt;GNU-devel ELPA&lt;/a&gt;, and &lt;a href=&#34;https://melpa.org/&#34;&gt;MELPA&lt;/a&gt;, and can be installed with the standard command &lt;code&gt;package-install&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x package-install RET dash RET&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://gnu.org/software/emacs/manual/html_node/emacs/Package-Installation.html&#34;&gt;&lt;code&gt;(info &#34;(emacs) Package Installation&#34;)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can just dump &lt;code&gt;dash.el&lt;/code&gt; in your &lt;code&gt;load-path&lt;/code&gt; somewhere. See &lt;a href=&#34;https://gnu.org/software/emacs/manual/html_node/emacs/Lisp-Libraries.html&#34;&gt;&lt;code&gt;(info &#34;(emacs) Lisp Libraries&#34;)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Using in a package&lt;/h3&gt; &#xA;&lt;p&gt;Add something like this to the library&#39;s headers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; Package-Requires: ((dash &#34;2.19.1&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html&#34;&gt;&lt;code&gt;(info &#34;(elisp) Library Headers&#34;)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Fontification of special variables&lt;/h3&gt; &#xA;&lt;p&gt;Font lock of special Dash variables (&lt;code&gt;it&lt;/code&gt;, &lt;code&gt;acc&lt;/code&gt;, etc.) in Emacs Lisp buffers can optionally be enabled with the autoloaded minor mode &lt;code&gt;dash-fontify-mode&lt;/code&gt;. In older Emacs versions which do not dynamically detect macros, the minor mode also fontifies Dash macro calls.&lt;/p&gt; &#xA;&lt;p&gt;To automatically enable the minor mode in all Emacs Lisp buffers, just call its autoloaded global counterpart &lt;code&gt;global-dash-fontify-mode&lt;/code&gt;, either interactively or from your &lt;code&gt;user-init-file&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(global-dash-fontify-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Info symbol lookup&lt;/h3&gt; &#xA;&lt;p&gt;While editing Elisp files, you can use &lt;code&gt;C-h S&lt;/code&gt; (&lt;code&gt;info-lookup-symbol&lt;/code&gt;) to look up Elisp symbols in the relevant Info manuals (see &lt;a href=&#34;https://gnu.org/software/emacs/manual/html_node/emacs/Info-Lookup.html&#34;&gt;&lt;code&gt;(emacs) Info Lookup&lt;/code&gt;&lt;/a&gt;). To enable the same for Dash symbols, use the command &lt;code&gt;dash-register-info-lookup&lt;/code&gt;. It can be called directly when needed, or automatically from your &lt;code&gt;user-init-file&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(with-eval-after-load &#39;info-look&#xA;  (dash-register-info-lookup))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Functions&lt;/h2&gt; &#xA;&lt;p&gt;All functions and constructs in the library use a dash (&lt;code&gt;-&lt;/code&gt;) prefix.&lt;/p&gt; &#xA;&lt;p&gt;The library also provides anaphoric macro versions of functions where that makes sense. The names of these macros are prefixed with two dashes (&lt;code&gt;--&lt;/code&gt;) instead of one.&lt;/p&gt; &#xA;&lt;p&gt;While &lt;code&gt;-map&lt;/code&gt; applies a function to each element of a list, its anaphoric counterpart &lt;code&gt;--map&lt;/code&gt; evaluates a form with the local variable &lt;code&gt;it&lt;/code&gt; temporarily bound to the current list element instead. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-map (lambda (n) (* n n)) &#39;(1 2 3 4)) ; Normal version.&#xA;(--map (* it it) &#39;(1 2 3 4))           ; Anaphoric version.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The normal version can of course also be written as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(defun my-square (n)&#xA;  &#34;Return N multiplied by itself.&#34;&#xA;  (* n n))&#xA;&#xA;(-map #&#39;my-square &#39;(1 2 3 4))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This demonstrates the utility of both versions.&lt;/p&gt; &#xA;&lt;h3&gt;Maps&lt;/h3&gt; &#xA;&lt;p&gt;Functions in this category take a transforming function, which is then applied sequentially to each or selected elements of the input list. The results are collected in order and returned as a new list.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-fn-list&#34;&gt;&lt;code&gt;-map&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-when-pred-rep-list&#34;&gt;&lt;code&gt;-map-when&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred rep list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-first-pred-rep-list&#34;&gt;&lt;code&gt;-map-first&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred rep list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-last-pred-rep-list&#34;&gt;&lt;code&gt;-map-last&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred rep list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-indexed-fn-list&#34;&gt;&lt;code&gt;-map-indexed&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-annotate-fn-list&#34;&gt;&lt;code&gt;-annotate&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-splice-pred-fun-list&#34;&gt;&lt;code&gt;-splice&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred fun list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-splice-list-pred-new-list-list&#34;&gt;&lt;code&gt;-splice-list&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred new-list list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-mapcat-fn-list&#34;&gt;&lt;code&gt;-mapcat&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-copy-list&#34;&gt;&lt;code&gt;-copy&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Sublist selection&lt;/h3&gt; &#xA;&lt;p&gt;Functions returning a sublist of the original list.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-filter-pred-list&#34;&gt;&lt;code&gt;-filter&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-pred-list&#34;&gt;&lt;code&gt;-remove&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-first-pred-list&#34;&gt;&lt;code&gt;-remove-first&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-last-pred-list&#34;&gt;&lt;code&gt;-remove-last&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-item-item-list&#34;&gt;&lt;code&gt;-remove-item&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(item list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-non-nil-list&#34;&gt;&lt;code&gt;-non-nil&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-slice-list-from-optional-to-step&#34;&gt;&lt;code&gt;-slice&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list from &amp;amp;optional to step)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-take-n-list&#34;&gt;&lt;code&gt;-take&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-take-last-n-list&#34;&gt;&lt;code&gt;-take-last&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-drop-n-list&#34;&gt;&lt;code&gt;-drop&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-drop-last-n-list&#34;&gt;&lt;code&gt;-drop-last&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-take-while-pred-list&#34;&gt;&lt;code&gt;-take-while&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-drop-while-pred-list&#34;&gt;&lt;code&gt;-drop-while&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-select-by-indices-indices-list&#34;&gt;&lt;code&gt;-select-by-indices&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(indices list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-select-columns-columns-table&#34;&gt;&lt;code&gt;-select-columns&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(columns table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-select-column-column-table&#34;&gt;&lt;code&gt;-select-column&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(column table)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;List to list&lt;/h3&gt; &#xA;&lt;p&gt;Functions returning a modified copy of the input list.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-keep-fn-list&#34;&gt;&lt;code&gt;-keep&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-concat-rest-sequences&#34;&gt;&lt;code&gt;-concat&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest sequences)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-flatten-l&#34;&gt;&lt;code&gt;-flatten&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(l)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-flatten-n-num-list&#34;&gt;&lt;code&gt;-flatten-n&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(num list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-replace-old-new-list&#34;&gt;&lt;code&gt;-replace&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(old new list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-replace-first-old-new-list&#34;&gt;&lt;code&gt;-replace-first&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(old new list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-replace-last-old-new-list&#34;&gt;&lt;code&gt;-replace-last&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(old new list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-insert-at-n-x-list&#34;&gt;&lt;code&gt;-insert-at&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n x list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-replace-at-n-x-list&#34;&gt;&lt;code&gt;-replace-at&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n x list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-update-at-n-func-list&#34;&gt;&lt;code&gt;-update-at&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n func list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-at-n-list&#34;&gt;&lt;code&gt;-remove-at&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-at-indices-indices-list&#34;&gt;&lt;code&gt;-remove-at-indices&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(indices list)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Reductions&lt;/h3&gt; &#xA;&lt;p&gt;Functions reducing lists to a single value (which may also be a list).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-from-fn-init-list&#34;&gt;&lt;code&gt;-reduce-from&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn init list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-from-fn-init-list&#34;&gt;&lt;code&gt;-reduce-r-from&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn init list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-fn-list&#34;&gt;&lt;code&gt;-reduce&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-fn-list&#34;&gt;&lt;code&gt;-reduce-r&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-from-fn-init-list&#34;&gt;&lt;code&gt;-reductions-from&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn init list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-r-from-fn-init-list&#34;&gt;&lt;code&gt;-reductions-r-from&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn init list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-fn-list&#34;&gt;&lt;code&gt;-reductions&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-r-fn-list&#34;&gt;&lt;code&gt;-reductions-r&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-count-pred-list&#34;&gt;&lt;code&gt;-count&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-sum-list&#34;&gt;&lt;code&gt;-sum&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-running-sum-list&#34;&gt;&lt;code&gt;-running-sum&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-product-list&#34;&gt;&lt;code&gt;-product&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-running-product-list&#34;&gt;&lt;code&gt;-running-product&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-inits-list&#34;&gt;&lt;code&gt;-inits&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tails-list&#34;&gt;&lt;code&gt;-tails&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-common-prefix-rest-lists&#34;&gt;&lt;code&gt;-common-prefix&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-common-suffix-rest-lists&#34;&gt;&lt;code&gt;-common-suffix&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-min-list&#34;&gt;&lt;code&gt;-min&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-min-by-comparator-list&#34;&gt;&lt;code&gt;-min-by&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(comparator list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-max-list&#34;&gt;&lt;code&gt;-max&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-max-by-comparator-list&#34;&gt;&lt;code&gt;-max-by&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(comparator list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-frequencies-list&#34;&gt;&lt;code&gt;-frequencies&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Unfolding&lt;/h3&gt; &#xA;&lt;p&gt;Operations dual to reductions, building lists from a seed value rather than consuming a list to produce a single value.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-iterate-fun-init-n&#34;&gt;&lt;code&gt;-iterate&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fun init n)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-unfold-fun-seed&#34;&gt;&lt;code&gt;-unfold&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fun seed)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-repeat-n-x&#34;&gt;&lt;code&gt;-repeat&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n x)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-cycle-list&#34;&gt;&lt;code&gt;-cycle&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Predicates&lt;/h3&gt; &#xA;&lt;p&gt;Reductions of one or more lists to a boolean value.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-some-pred-list&#34;&gt;&lt;code&gt;-some&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-every-pred-list&#34;&gt;&lt;code&gt;-every&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-any-pred-list&#34;&gt;&lt;code&gt;-any?&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-all-pred-list&#34;&gt;&lt;code&gt;-all?&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-none-pred-list&#34;&gt;&lt;code&gt;-none?&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-only-some-pred-list&#34;&gt;&lt;code&gt;-only-some?&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-contains-list-element&#34;&gt;&lt;code&gt;-contains?&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list element)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-is-prefix-prefix-list&#34;&gt;&lt;code&gt;-is-prefix?&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(prefix list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-is-suffix-suffix-list&#34;&gt;&lt;code&gt;-is-suffix?&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(suffix list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-is-infix-infix-list&#34;&gt;&lt;code&gt;-is-infix?&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(infix list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-cons-pair-obj&#34;&gt;&lt;code&gt;-cons-pair?&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(obj)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Partitioning&lt;/h3&gt; &#xA;&lt;p&gt;Functions partitioning the input list into a list of lists.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-split-at-n-list&#34;&gt;&lt;code&gt;-split-at&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-split-with-pred-list&#34;&gt;&lt;code&gt;-split-with&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-split-on-item-list&#34;&gt;&lt;code&gt;-split-on&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(item list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-split-when-fn-list&#34;&gt;&lt;code&gt;-split-when&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-separate-pred-list&#34;&gt;&lt;code&gt;-separate&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-n-list&#34;&gt;&lt;code&gt;-partition&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-all-n-list&#34;&gt;&lt;code&gt;-partition-all&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-in-steps-n-step-list&#34;&gt;&lt;code&gt;-partition-in-steps&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n step list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-all-in-steps-n-step-list&#34;&gt;&lt;code&gt;-partition-all-in-steps&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n step list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-by-fn-list&#34;&gt;&lt;code&gt;-partition-by&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-by-header-fn-list&#34;&gt;&lt;code&gt;-partition-by-header&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-after-pred-pred-list&#34;&gt;&lt;code&gt;-partition-after-pred&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-before-pred-pred-list&#34;&gt;&lt;code&gt;-partition-before-pred&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-before-item-item-list&#34;&gt;&lt;code&gt;-partition-before-item&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(item list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-after-item-item-list&#34;&gt;&lt;code&gt;-partition-after-item&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(item list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-group-by-fn-list&#34;&gt;&lt;code&gt;-group-by&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Indexing&lt;/h3&gt; &#xA;&lt;p&gt;Functions retrieving or sorting based on list indices and related predicates.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-elem-index-elem-list&#34;&gt;&lt;code&gt;-elem-index&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(elem list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-elem-indices-elem-list&#34;&gt;&lt;code&gt;-elem-indices&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(elem list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-find-index-pred-list&#34;&gt;&lt;code&gt;-find-index&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-find-last-index-pred-list&#34;&gt;&lt;code&gt;-find-last-index&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-find-indices-pred-list&#34;&gt;&lt;code&gt;-find-indices&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-grade-up-comparator-list&#34;&gt;&lt;code&gt;-grade-up&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(comparator list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-grade-down-comparator-list&#34;&gt;&lt;code&gt;-grade-down&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(comparator list)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Set operations&lt;/h3&gt; &#xA;&lt;p&gt;Operations pretending lists are sets.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-union-list1-list2&#34;&gt;&lt;code&gt;-union&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list1 list2)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-difference-list1-list2&#34;&gt;&lt;code&gt;-difference&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list1 list2)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-intersection-list1-list2&#34;&gt;&lt;code&gt;-intersection&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list1 list2)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-powerset-list&#34;&gt;&lt;code&gt;-powerset&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-permutations-list&#34;&gt;&lt;code&gt;-permutations&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-distinct-list&#34;&gt;&lt;code&gt;-distinct&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-same-items-list1-list2&#34;&gt;&lt;code&gt;-same-items?&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list1 list2)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Other list operations&lt;/h3&gt; &#xA;&lt;p&gt;Other list functions not fit to be classified elsewhere.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-rotate-n-list&#34;&gt;&lt;code&gt;-rotate&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-cons-rest-args&#34;&gt;&lt;code&gt;-cons*&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest args)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-snoc-list-elem-rest-elements&#34;&gt;&lt;code&gt;-snoc&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list elem &amp;amp;rest elements)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-interpose-sep-list&#34;&gt;&lt;code&gt;-interpose&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(sep list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-interleave-rest-lists&#34;&gt;&lt;code&gt;-interleave&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-iota-count-optional-start-step&#34;&gt;&lt;code&gt;-iota&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(count &amp;amp;optional start step)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-with-fn-list1-list2&#34;&gt;&lt;code&gt;-zip-with&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list1 list2)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-pair-list1-list2&#34;&gt;&lt;code&gt;-zip-pair&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list1 list2)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-lists-rest-lists&#34;&gt;&lt;code&gt;-zip-lists&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-lists-fill-fill-value-rest-lists&#34;&gt;&lt;code&gt;-zip-lists-fill&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fill-value &amp;amp;rest lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-rest-lists&#34;&gt;&lt;code&gt;-zip&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-fill-fill-value-rest-lists&#34;&gt;&lt;code&gt;-zip-fill&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fill-value &amp;amp;rest lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-unzip-lists-lists&#34;&gt;&lt;code&gt;-unzip-lists&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-unzip-lists&#34;&gt;&lt;code&gt;-unzip&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-pad-fill-value-rest-lists&#34;&gt;&lt;code&gt;-pad&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fill-value &amp;amp;rest lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-table-fn-rest-lists&#34;&gt;&lt;code&gt;-table&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn &amp;amp;rest lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-table-flat-fn-rest-lists&#34;&gt;&lt;code&gt;-table-flat&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn &amp;amp;rest lists)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-first-pred-list&#34;&gt;&lt;code&gt;-first&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-last-pred-list&#34;&gt;&lt;code&gt;-last&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-first-item-list&#34;&gt;&lt;code&gt;-first-item&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-second-item-list&#34;&gt;&lt;code&gt;-second-item&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-third-item-list&#34;&gt;&lt;code&gt;-third-item&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-fourth-item-list&#34;&gt;&lt;code&gt;-fourth-item&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-fifth-item-list&#34;&gt;&lt;code&gt;-fifth-item&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-last-item-list&#34;&gt;&lt;code&gt;-last-item&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-butlast-list&#34;&gt;&lt;code&gt;-butlast&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-sort-comparator-list&#34;&gt;&lt;code&gt;-sort&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(comparator list)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-list-arg&#34;&gt;&lt;code&gt;-list&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(arg)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-fix-fn-list&#34;&gt;&lt;code&gt;-fix&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn list)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Tree operations&lt;/h3&gt; &#xA;&lt;p&gt;Functions pretending lists are trees.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-seq-branch-children-tree&#34;&gt;&lt;code&gt;-tree-seq&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(branch children tree)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-map-fn-tree&#34;&gt;&lt;code&gt;-tree-map&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn tree)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-map-nodes-pred-fun-tree&#34;&gt;&lt;code&gt;-tree-map-nodes&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred fun tree)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-reduce-fn-tree&#34;&gt;&lt;code&gt;-tree-reduce&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn tree)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-reduce-from-fn-init-value-tree&#34;&gt;&lt;code&gt;-tree-reduce-from&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn init-value tree)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-mapreduce-fn-folder-tree&#34;&gt;&lt;code&gt;-tree-mapreduce&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn folder tree)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-mapreduce-from-fn-folder-init-value-tree&#34;&gt;&lt;code&gt;-tree-mapreduce-from&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn folder init-value tree)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-clone-list&#34;&gt;&lt;code&gt;-clone&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Threading macros&lt;/h3&gt; &#xA;&lt;p&gt;Macros that conditionally combine sequential forms for brevity or readability.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#--x-optional-form-rest-more&#34;&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(x &amp;amp;optional form &amp;amp;rest more)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#--x-optional-form-rest-more&#34;&gt;&lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(x &amp;amp;optional form &amp;amp;rest more)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#---x-rest-forms&#34;&gt;&lt;code&gt;--&amp;gt;&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(x &amp;amp;rest forms)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-as--value-variable-rest-forms&#34;&gt;&lt;code&gt;-as-&amp;gt;&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(value variable &amp;amp;rest forms)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-some--x-optional-form-rest-more&#34;&gt;&lt;code&gt;-some-&amp;gt;&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(x &amp;amp;optional form &amp;amp;rest more)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-some--x-optional-form-rest-more&#34;&gt;&lt;code&gt;-some-&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(x &amp;amp;optional form &amp;amp;rest more)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-some---expr-rest-forms&#34;&gt;&lt;code&gt;-some--&amp;gt;&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(expr &amp;amp;rest forms)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-doto-init-rest-forms&#34;&gt;&lt;code&gt;-doto&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(init &amp;amp;rest forms)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Binding&lt;/h3&gt; &#xA;&lt;p&gt;Macros that combine &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;let*&lt;/code&gt; with destructuring and flow control.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-when-let-var-val-rest-body&#34;&gt;&lt;code&gt;-when-let&lt;/code&gt;&lt;/a&gt; &lt;code&gt;((var val) &amp;amp;rest body)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-when-let-vars-vals-rest-body&#34;&gt;&lt;code&gt;-when-let*&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(vars-vals &amp;amp;rest body)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-if-let-var-val-then-rest-else&#34;&gt;&lt;code&gt;-if-let&lt;/code&gt;&lt;/a&gt; &lt;code&gt;((var val) then &amp;amp;rest else)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-if-let-vars-vals-then-rest-else&#34;&gt;&lt;code&gt;-if-let*&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(vars-vals then &amp;amp;rest else)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-let-varlist-rest-body&#34;&gt;&lt;code&gt;-let&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(varlist &amp;amp;rest body)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-let-varlist-rest-body&#34;&gt;&lt;code&gt;-let*&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(varlist &amp;amp;rest body)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-lambda-match-form-rest-body&#34;&gt;&lt;code&gt;-lambda&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(match-form &amp;amp;rest body)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-setq-match-form-val&#34;&gt;&lt;code&gt;-setq&lt;/code&gt;&lt;/a&gt; &lt;code&gt;([match-form val] ...)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Side effects&lt;/h3&gt; &#xA;&lt;p&gt;Functions iterating over lists for side effect only.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-each-list-fn&#34;&gt;&lt;code&gt;-each&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list fn)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-each-while-list-pred-fn&#34;&gt;&lt;code&gt;-each-while&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list pred fn)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-each-indexed-list-fn&#34;&gt;&lt;code&gt;-each-indexed&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list fn)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-each-r-list-fn&#34;&gt;&lt;code&gt;-each-r&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list fn)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-each-r-while-list-pred-fn&#34;&gt;&lt;code&gt;-each-r-while&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list pred fn)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-dotimes-num-fn&#34;&gt;&lt;code&gt;-dotimes&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(num fn)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Destructive operations&lt;/h3&gt; &#xA;&lt;p&gt;Macros that modify variables holding lists.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#cons-car-cdr&#34;&gt;&lt;code&gt;!cons&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(car cdr)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#cdr-list&#34;&gt;&lt;code&gt;!cdr&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(list)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Function combinators&lt;/h3&gt; &#xA;&lt;p&gt;Functions that manipulate and compose other functions.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partial-fun-rest-args&#34;&gt;&lt;code&gt;-partial&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fun &amp;amp;rest args)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-rpartial-fn-rest-args&#34;&gt;&lt;code&gt;-rpartial&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn &amp;amp;rest args)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-juxt-rest-fns&#34;&gt;&lt;code&gt;-juxt&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest fns)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-compose-rest-fns&#34;&gt;&lt;code&gt;-compose&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest fns)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-applify-fn&#34;&gt;&lt;code&gt;-applify&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-on-op-trans&#34;&gt;&lt;code&gt;-on&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(op trans)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-flip-fn&#34;&gt;&lt;code&gt;-flip&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-rotate-args-n-fn&#34;&gt;&lt;code&gt;-rotate-args&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(n fn)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-const-c&#34;&gt;&lt;code&gt;-const&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(c)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-cut-rest-params&#34;&gt;&lt;code&gt;-cut&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest params)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-not-pred&#34;&gt;&lt;code&gt;-not&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(pred)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-orfn-rest-preds&#34;&gt;&lt;code&gt;-orfn&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest preds)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-andfn-rest-preds&#34;&gt;&lt;code&gt;-andfn&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest preds)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-iteratefn-fn-n&#34;&gt;&lt;code&gt;-iteratefn&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn n)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-fixfn-fn-optional-equal-test-halt-test&#34;&gt;&lt;code&gt;-fixfn&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(fn &amp;amp;optional equal-test halt-test)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-prodfn-rest-fns&#34;&gt;&lt;code&gt;-prodfn&lt;/code&gt;&lt;/a&gt; &lt;code&gt;(&amp;amp;rest fns)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Maps&lt;/h2&gt; &#xA;&lt;p&gt;Functions in this category take a transforming function, which is then applied sequentially to each or selected elements of the input list. The results are collected in order and returned as a new list.&lt;/p&gt; &#xA;&lt;h4&gt;-map &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Apply &lt;code&gt;fn&lt;/code&gt; to each item in &lt;code&gt;list&lt;/code&gt; and return the list of results.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--map&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-map (lambda (num) (* num num)) &#39;(1 2 3 4)) ;; =&amp;gt; (1 4 9 16)&#xA;(-map #&#39;1+ &#39;(1 2 3 4)) ;; =&amp;gt; (2 3 4 5)&#xA;(--map (* it it) &#39;(1 2 3 4)) ;; =&amp;gt; (1 4 9 16)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-map-when &lt;code&gt;(pred rep list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Use &lt;code&gt;pred&lt;/code&gt; to conditionally apply &lt;code&gt;rep&lt;/code&gt; to each item in &lt;code&gt;list&lt;/code&gt;. Return a copy of &lt;code&gt;list&lt;/code&gt; where the items for which &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; are unchanged, and the rest are mapped through the &lt;code&gt;rep&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-replace-where&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-update-at-n-func-list&#34;&gt;&lt;code&gt;-update-at&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-map-when &#39;even? &#39;square &#39;(1 2 3 4)) ;; =&amp;gt; (1 4 3 16)&#xA;(--map-when (&amp;gt; it 2) (* it it) &#39;(1 2 3 4)) ;; =&amp;gt; (1 2 9 16)&#xA;(--map-when (= it 2) 17 &#39;(1 2 3 4)) ;; =&amp;gt; (1 17 3 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-map-first &lt;code&gt;(pred rep list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Use &lt;code&gt;pred&lt;/code&gt; to determine the first item in &lt;code&gt;list&lt;/code&gt; to call &lt;code&gt;rep&lt;/code&gt; on. Return a copy of &lt;code&gt;list&lt;/code&gt; where the first item for which &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt; is replaced with the result of calling &lt;code&gt;rep&lt;/code&gt; on that item.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-when-pred-rep-list&#34;&gt;&lt;code&gt;-map-when&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-replace-first-old-new-list&#34;&gt;&lt;code&gt;-replace-first&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-map-first &#39;even? &#39;square &#39;(1 2 3 4)) ;; =&amp;gt; (1 4 3 4)&#xA;(--map-first (&amp;gt; it 2) (* it it) &#39;(1 2 3 4)) ;; =&amp;gt; (1 2 9 4)&#xA;(--map-first (= it 2) 17 &#39;(1 2 3 2)) ;; =&amp;gt; (1 17 3 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-map-last &lt;code&gt;(pred rep list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Use &lt;code&gt;pred&lt;/code&gt; to determine the last item in &lt;code&gt;list&lt;/code&gt; to call &lt;code&gt;rep&lt;/code&gt; on. Return a copy of &lt;code&gt;list&lt;/code&gt; where the last item for which &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt; is replaced with the result of calling &lt;code&gt;rep&lt;/code&gt; on that item.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-when-pred-rep-list&#34;&gt;&lt;code&gt;-map-when&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-replace-last-old-new-list&#34;&gt;&lt;code&gt;-replace-last&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-map-last &#39;even? &#39;square &#39;(1 2 3 4)) ;; =&amp;gt; (1 2 3 16)&#xA;(--map-last (&amp;gt; it 2) (* it it) &#39;(1 2 3 4)) ;; =&amp;gt; (1 2 3 16)&#xA;(--map-last (= it 2) 17 &#39;(1 2 3 2)) ;; =&amp;gt; (1 2 3 17)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-map-indexed &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Apply &lt;code&gt;fn&lt;/code&gt; to each index and item in &lt;code&gt;list&lt;/code&gt; and return the list of results. This is like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-fn-list&#34;&gt;&lt;code&gt;-map&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;fn&lt;/code&gt; takes two arguments: the index of the current element within &lt;code&gt;list&lt;/code&gt;, and the element itself.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--map-indexed&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For a side-effecting variant, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-each-indexed-list-fn&#34;&gt;&lt;code&gt;-each-indexed&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-map-indexed (lambda (index item) (- item index)) &#39;(1 2 3 4)) ;; =&amp;gt; (1 1 1 1)&#xA;(--map-indexed (- it it-index) &#39;(1 2 3 4)) ;; =&amp;gt; (1 1 1 1)&#xA;(-map-indexed #&#39;* &#39;(1 2 3 4)) ;; =&amp;gt; (0 2 6 12)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-annotate &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Pair each item in &lt;code&gt;list&lt;/code&gt; with the result of passing it to &lt;code&gt;fn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Return an alist of (&lt;code&gt;result&lt;/code&gt; . &lt;code&gt;item&lt;/code&gt;), where each &lt;code&gt;item&lt;/code&gt; is the corresponding element of &lt;code&gt;list&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt; is the value obtained by calling &lt;code&gt;fn&lt;/code&gt; on &lt;code&gt;item&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--annotate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-annotate #&#39;1+ &#39;(1 2 3)) ;; =&amp;gt; ((2 . 1) (3 . 2) (4 . 3))&#xA;(-annotate #&#39;length &#39;((f o o) (bar baz))) ;; =&amp;gt; ((3 f o o) (2 bar baz))&#xA;(--annotate (&amp;gt; it 1) &#39;(0 1 2 3)) ;; =&amp;gt; ((nil . 0) (nil . 1) (t . 2) (t . 3))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-splice &lt;code&gt;(pred fun list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Splice lists generated by &lt;code&gt;fun&lt;/code&gt; in place of items satisfying &lt;code&gt;pred&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Call &lt;code&gt;pred&lt;/code&gt; on each element of &lt;code&gt;list&lt;/code&gt;. Whenever the result of &lt;code&gt;pred&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, leave that &lt;code&gt;it&lt;/code&gt; as-is. Otherwise, call &lt;code&gt;fun&lt;/code&gt; on the same &lt;code&gt;it&lt;/code&gt; that satisfied &lt;code&gt;pred&lt;/code&gt;. The result should be a (possibly empty) list of items to splice in place of &lt;code&gt;it&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This can be useful as an alternative to the &lt;code&gt;,@&lt;/code&gt; construct in a ``&#39; structure, in case you need to splice several lists at marked positions (for example with keywords).&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--splice&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-splice-list-pred-new-list-list&#34;&gt;&lt;code&gt;-splice-list&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-insert-at-n-x-list&#34;&gt;&lt;code&gt;-insert-at&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-splice #&#39;numberp (lambda (n) (list n n)) &#39;(a 1 b 2)) ;; =&amp;gt; (a 1 1 b 2 2)&#xA;(--splice t (list it it) &#39;(1 2 3 4)) ;; =&amp;gt; (1 1 2 2 3 3 4 4)&#xA;(--splice (eq it :magic) &#39;((magical) (code)) &#39;((foo) :magic (bar))) ;; =&amp;gt; ((foo) (magical) (code) (bar))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-splice-list &lt;code&gt;(pred new-list list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Splice &lt;code&gt;new-list&lt;/code&gt; in place of elements matching &lt;code&gt;pred&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-splice-pred-fun-list&#34;&gt;&lt;code&gt;-splice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-insert-at-n-x-list&#34;&gt;&lt;code&gt;-insert-at&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-splice-list &#39;keywordp &#39;(a b c) &#39;(1 :foo 2)) ;; =&amp;gt; (1 a b c 2)&#xA;(-splice-list &#39;keywordp nil &#39;(1 :foo 2)) ;; =&amp;gt; (1 2)&#xA;(--splice-list (keywordp it) &#39;(a b c) &#39;(1 :foo 2)) ;; =&amp;gt; (1 a b c 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-mapcat &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the concatenation of the result of mapping &lt;code&gt;fn&lt;/code&gt; over &lt;code&gt;list&lt;/code&gt;. Thus function &lt;code&gt;fn&lt;/code&gt; should return a list.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-mapcat &#39;list &#39;(1 2 3)) ;; =&amp;gt; (1 2 3)&#xA;(-mapcat (lambda (item) (list 0 item)) &#39;(1 2 3)) ;; =&amp;gt; (0 1 0 2 0 3)&#xA;(--mapcat (list 0 it) &#39;(1 2 3)) ;; =&amp;gt; (0 1 0 2 0 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-copy &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Create a shallow copy of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-copy &#39;(1 2 3)) ;; =&amp;gt; (1 2 3)&#xA;(let ((a &#39;(1 2 3))) (eq a (-copy a))) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sublist selection&lt;/h2&gt; &#xA;&lt;p&gt;Functions returning a sublist of the original list.&lt;/p&gt; &#xA;&lt;h4&gt;-filter &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list of the items in &lt;code&gt;list&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-select&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--filter&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For similar operations, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-keep-fn-list&#34;&gt;&lt;code&gt;-keep&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-pred-list&#34;&gt;&lt;code&gt;-remove&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-filter (lambda (num) (= 0 (% num 2))) &#39;(1 2 3 4)) ;; =&amp;gt; (2 4)&#xA;(-filter #&#39;natnump &#39;(-2 -1 0 1 2)) ;; =&amp;gt; (0 1 2)&#xA;(--filter (= 0 (% it 2)) &#39;(1 2 3 4)) ;; =&amp;gt; (2 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-remove &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list of the items in &lt;code&gt;list&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-reject&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--remove&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For similar operations, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-keep-fn-list&#34;&gt;&lt;code&gt;-keep&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-filter-pred-list&#34;&gt;&lt;code&gt;-filter&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-remove (lambda (num) (= 0 (% num 2))) &#39;(1 2 3 4)) ;; =&amp;gt; (1 3)&#xA;(-remove #&#39;natnump &#39;(-2 -1 0 1 2)) ;; =&amp;gt; (-2 -1)&#xA;(--remove (= 0 (% it 2)) &#39;(1 2 3 4)) ;; =&amp;gt; (1 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-remove-first &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Remove the first item from &lt;code&gt;list&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;. This is a non-destructive operation, but only the front of &lt;code&gt;list&lt;/code&gt; leading up to the removed item is a copy; the rest is &lt;code&gt;list&lt;/code&gt;&#39;s original tail. If no item is removed, then the result is a complete copy.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-reject-first&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--remove-first&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-first-pred-rep-list&#34;&gt;&lt;code&gt;-map-first&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-item-item-list&#34;&gt;&lt;code&gt;-remove-item&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-last-pred-list&#34;&gt;&lt;code&gt;-remove-last&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-remove-first #&#39;natnump &#39;(-2 -1 0 1 2)) ;; =&amp;gt; (-2 -1 1 2)&#xA;(-remove-first #&#39;stringp &#39;(1 2 &#34;first&#34; &#34;second&#34;)) ;; =&amp;gt; (1 2 &#34;second&#34;)&#xA;(--remove-first (&amp;gt; it 3) &#39;(1 2 3 4 5 6)) ;; =&amp;gt; (1 2 3 5 6)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-remove-last &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Remove the last item from &lt;code&gt;list&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;. The result is a copy of &lt;code&gt;list&lt;/code&gt; regardless of whether an element is removed.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-reject-last&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--remove-last&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-last-pred-rep-list&#34;&gt;&lt;code&gt;-map-last&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-item-item-list&#34;&gt;&lt;code&gt;-remove-item&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-first-pred-list&#34;&gt;&lt;code&gt;-remove-first&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-remove-last #&#39;natnump &#39;(1 3 5 4 7 8 10 -11)) ;; =&amp;gt; (1 3 5 4 7 8 -11)&#xA;(-remove-last #&#39;stringp &#39;(1 2 &#34;last&#34; &#34;second&#34;)) ;; =&amp;gt; (1 2 &#34;last&#34;)&#xA;(--remove-last (&amp;gt; it 3) &#39;(1 2 3 4 5 6 7 8 9 10)) ;; =&amp;gt; (1 2 3 4 5 6 7 8 9)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-remove-item &lt;code&gt;(item list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a copy of &lt;code&gt;list&lt;/code&gt; with all occurrences of &lt;code&gt;item&lt;/code&gt; removed. The comparison is done with &lt;code&gt;equal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-remove-item 3 &#39;(1 2 3 2 3 4 5 3)) ;; =&amp;gt; (1 2 2 4 5)&#xA;(-remove-item &#39;foo &#39;(foo bar baz foo)) ;; =&amp;gt; (bar baz)&#xA;(-remove-item &#34;bob&#34; &#39;(&#34;alice&#34; &#34;bob&#34; &#34;eve&#34; &#34;bob&#34;)) ;; =&amp;gt; (&#34;alice&#34; &#34;eve&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-non-nil &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a copy of &lt;code&gt;list&lt;/code&gt; with all &lt;code&gt;nil&lt;/code&gt; items removed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-non-nil &#39;(nil 1 nil 2 nil nil 3 4 nil 5 nil)) ;; =&amp;gt; (1 2 3 4 5)&#xA;(-non-nil &#39;((nil))) ;; =&amp;gt; ((nil))&#xA;(-non-nil ()) ;; =&amp;gt; ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-slice &lt;code&gt;(list from &amp;amp;optional to step)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return copy of &lt;code&gt;list&lt;/code&gt;, starting from index &lt;code&gt;from&lt;/code&gt; to index &lt;code&gt;to&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; may be negative. These values are then interpreted modulo the length of the list.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;step&lt;/code&gt; is a number, only each &lt;code&gt;step&lt;/code&gt;th item in the resulting section is returned. Defaults to 1.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-slice &#39;(1 2 3 4 5) 1) ;; =&amp;gt; (2 3 4 5)&#xA;(-slice &#39;(1 2 3 4 5) 0 3) ;; =&amp;gt; (1 2 3)&#xA;(-slice &#39;(1 2 3 4 5 6 7 8 9) 1 -1 2) ;; =&amp;gt; (2 4 6 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-take &lt;code&gt;(n list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a copy of the first &lt;code&gt;n&lt;/code&gt; items in &lt;code&gt;list&lt;/code&gt;. Return a copy of &lt;code&gt;list&lt;/code&gt; if it contains &lt;code&gt;n&lt;/code&gt; items or fewer. Return &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; is zero or less.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-take-last-n-list&#34;&gt;&lt;code&gt;-take-last&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-take 3 &#39;(1 2 3 4 5)) ;; =&amp;gt; (1 2 3)&#xA;(-take 17 &#39;(1 2 3 4 5)) ;; =&amp;gt; (1 2 3 4 5)&#xA;(-take 0 &#39;(1 2 3 4 5)) ;; =&amp;gt; ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-take-last &lt;code&gt;(n list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a copy of the last &lt;code&gt;n&lt;/code&gt; items of &lt;code&gt;list&lt;/code&gt; in order. Return a copy of &lt;code&gt;list&lt;/code&gt; if it contains &lt;code&gt;n&lt;/code&gt; items or fewer. Return &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; is zero or less.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-take-n-list&#34;&gt;&lt;code&gt;-take&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-take-last 3 &#39;(1 2 3 4 5)) ;; =&amp;gt; (3 4 5)&#xA;(-take-last 17 &#39;(1 2 3 4 5)) ;; =&amp;gt; (1 2 3 4 5)&#xA;(-take-last 1 &#39;(1 2 3 4 5)) ;; =&amp;gt; (5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-drop &lt;code&gt;(n list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the tail (not a copy) of &lt;code&gt;list&lt;/code&gt; without the first &lt;code&gt;n&lt;/code&gt; items. Return &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; contains &lt;code&gt;n&lt;/code&gt; items or fewer. Return &lt;code&gt;list&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; is zero or less.&lt;/p&gt; &#xA;&lt;p&gt;For another variant, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-drop-last-n-list&#34;&gt;&lt;code&gt;-drop-last&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-drop 3 &#39;(1 2 3 4 5)) ;; =&amp;gt; (4 5)&#xA;(-drop 17 &#39;(1 2 3 4 5)) ;; =&amp;gt; ()&#xA;(-drop 0 &#39;(1 2 3 4 5)) ;; =&amp;gt; (1 2 3 4 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-drop-last &lt;code&gt;(n list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a copy of &lt;code&gt;list&lt;/code&gt; without its last &lt;code&gt;n&lt;/code&gt; items. Return a copy of &lt;code&gt;list&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; is zero or less. Return &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; contains &lt;code&gt;n&lt;/code&gt; items or fewer.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-drop-n-list&#34;&gt;&lt;code&gt;-drop&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-drop-last 3 &#39;(1 2 3 4 5)) ;; =&amp;gt; (1 2)&#xA;(-drop-last 17 &#39;(1 2 3 4 5)) ;; =&amp;gt; ()&#xA;(-drop-last 0 &#39;(1 2 3 4 5)) ;; =&amp;gt; (1 2 3 4 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-take-while &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Take successive items from &lt;code&gt;list&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;. &lt;code&gt;pred&lt;/code&gt; is a function of one argument. Return a new list of the successive elements from the start of &lt;code&gt;list&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--take-while&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For another variant, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-drop-while-pred-list&#34;&gt;&lt;code&gt;-drop-while&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-take-while #&#39;even? &#39;(1 2 3 4)) ;; =&amp;gt; ()&#xA;(-take-while #&#39;even? &#39;(2 4 5 6)) ;; =&amp;gt; (2 4)&#xA;(--take-while (&amp;lt; it 4) &#39;(1 2 3 4 3 2 1)) ;; =&amp;gt; (1 2 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-drop-while &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Drop successive items from &lt;code&gt;list&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;. &lt;code&gt;pred&lt;/code&gt; is a function of one argument. Return the tail (not a copy) of &lt;code&gt;list&lt;/code&gt; starting from its first element for which &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--drop-while&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For another variant, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-take-while-pred-list&#34;&gt;&lt;code&gt;-take-while&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-drop-while #&#39;even? &#39;(1 2 3 4)) ;; =&amp;gt; (1 2 3 4)&#xA;(-drop-while #&#39;even? &#39;(2 4 5 6)) ;; =&amp;gt; (5 6)&#xA;(--drop-while (&amp;lt; it 4) &#39;(1 2 3 4 3 2 1)) ;; =&amp;gt; (4 3 2 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-select-by-indices &lt;code&gt;(indices list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list whose elements are elements from &lt;code&gt;list&lt;/code&gt; selected as &lt;code&gt;(nth i list)&lt;/code&gt; for all i from &lt;code&gt;indices&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-select-by-indices &#39;(4 10 2 3 6) &#39;(&#34;v&#34; &#34;e&#34; &#34;l&#34; &#34;o&#34; &#34;c&#34; &#34;i&#34; &#34;r&#34; &#34;a&#34; &#34;p&#34; &#34;t&#34; &#34;o&#34; &#34;r&#34;)) ;; =&amp;gt; (&#34;c&#34; &#34;o&#34; &#34;l&#34; &#34;o&#34; &#34;r&#34;)&#xA;(-select-by-indices &#39;(2 1 0) &#39;(&#34;a&#34; &#34;b&#34; &#34;c&#34;)) ;; =&amp;gt; (&#34;c&#34; &#34;b&#34; &#34;a&#34;)&#xA;(-select-by-indices &#39;(0 1 2 0 1 3 3 1) &#39;(&#34;f&#34; &#34;a&#34; &#34;r&#34; &#34;l&#34;)) ;; =&amp;gt; (&#34;f&#34; &#34;a&#34; &#34;r&#34; &#34;f&#34; &#34;a&#34; &#34;l&#34; &#34;l&#34; &#34;a&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-select-columns &lt;code&gt;(columns table)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Select &lt;code&gt;columns&lt;/code&gt; from &lt;code&gt;table&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;table&lt;/code&gt; is a list of lists where each element represents one row. It is assumed each row has the same length.&lt;/p&gt; &#xA;&lt;p&gt;Each row is transformed such that only the specified &lt;code&gt;columns&lt;/code&gt; are selected.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-select-column-column-table&#34;&gt;&lt;code&gt;-select-column&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-select-by-indices-indices-list&#34;&gt;&lt;code&gt;-select-by-indices&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-select-columns &#39;(0 2) &#39;((1 2 3) (a b c) (:a :b :c))) ;; =&amp;gt; ((1 3) (a c) (:a :c))&#xA;(-select-columns &#39;(1) &#39;((1 2 3) (a b c) (:a :b :c))) ;; =&amp;gt; ((2) (b) (:b))&#xA;(-select-columns nil &#39;((1 2 3) (a b c) (:a :b :c))) ;; =&amp;gt; (nil nil nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-select-column &lt;code&gt;(column table)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Select &lt;code&gt;column&lt;/code&gt; from &lt;code&gt;table&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;table&lt;/code&gt; is a list of lists where each element represents one row. It is assumed each row has the same length.&lt;/p&gt; &#xA;&lt;p&gt;The single selected column is returned as a list.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-select-columns-columns-table&#34;&gt;&lt;code&gt;-select-columns&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-select-by-indices-indices-list&#34;&gt;&lt;code&gt;-select-by-indices&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-select-column 1 &#39;((1 2 3) (a b c) (:a :b :c))) ;; =&amp;gt; (2 b :b)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;List to list&lt;/h2&gt; &#xA;&lt;p&gt;Functions returning a modified copy of the input list.&lt;/p&gt; &#xA;&lt;h4&gt;-keep &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list of the non-&lt;code&gt;nil&lt;/code&gt; results of applying &lt;code&gt;fn&lt;/code&gt; to each item in &lt;code&gt;list&lt;/code&gt;. Like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-filter-pred-list&#34;&gt;&lt;code&gt;-filter&lt;/code&gt;&lt;/a&gt;, but returns the non-&lt;code&gt;nil&lt;/code&gt; results of &lt;code&gt;fn&lt;/code&gt; instead of the corresponding elements of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Its anaphoric counterpart is &lt;code&gt;--keep&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-keep #&#39;cdr &#39;((1 2 3) (4 5) (6))) ;; =&amp;gt; ((2 3) (5))&#xA;(-keep (lambda (n) (and (&amp;gt; n 3) (* 10 n))) &#39;(1 2 3 4 5 6)) ;; =&amp;gt; (40 50 60)&#xA;(--keep (and (&amp;gt; it 3) (* 10 it)) &#39;(1 2 3 4 5 6)) ;; =&amp;gt; (40 50 60)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-concat &lt;code&gt;(&amp;amp;rest sequences)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Concatenate all the arguments and make the result a list. The result is a list whose elements are the elements of all the arguments. Each argument may be a list, vector or string.&lt;/p&gt; &#xA;&lt;p&gt;All arguments except the last argument are copied. The last argument is just used as the tail of the new list.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-concat &#39;(1)) ;; =&amp;gt; (1)&#xA;(-concat &#39;(1) &#39;(2)) ;; =&amp;gt; (1 2)&#xA;(-concat &#39;(1) &#39;(2 3) &#39;(4)) ;; =&amp;gt; (1 2 3 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-flatten &lt;code&gt;(l)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Take a nested list &lt;code&gt;l&lt;/code&gt; and return its contents as a single, flat list.&lt;/p&gt; &#xA;&lt;p&gt;Note that because &lt;code&gt;nil&lt;/code&gt; represents a list of zero elements (an empty list), any mention of &lt;code&gt;nil&lt;/code&gt; in &lt;code&gt;l&lt;/code&gt; will disappear after flattening. If you need to preserve nils, consider &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-flatten-n-num-list&#34;&gt;&lt;code&gt;-flatten-n&lt;/code&gt;&lt;/a&gt; or map them to some unique symbol and then map them back.&lt;/p&gt; &#xA;&lt;p&gt;Conses of two atoms are considered &#34;terminals&#34;, that is, they aren&#39;t flattened further.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-flatten-n-num-list&#34;&gt;&lt;code&gt;-flatten-n&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-flatten &#39;((1))) ;; =&amp;gt; (1)&#xA;(-flatten &#39;((1 (2 3) (((4 (5))))))) ;; =&amp;gt; (1 2 3 4 5)&#xA;(-flatten &#39;(1 2 (3 . 4))) ;; =&amp;gt; (1 2 (3 . 4))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-flatten-n &lt;code&gt;(num list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Flatten &lt;code&gt;num&lt;/code&gt; levels of a nested &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-flatten-l&#34;&gt;&lt;code&gt;-flatten&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-flatten-n 1 &#39;((1 2) ((3 4) ((5 6))))) ;; =&amp;gt; (1 2 (3 4) ((5 6)))&#xA;(-flatten-n 2 &#39;((1 2) ((3 4) ((5 6))))) ;; =&amp;gt; (1 2 3 4 (5 6))&#xA;(-flatten-n 3 &#39;((1 2) ((3 4) ((5 6))))) ;; =&amp;gt; (1 2 3 4 5 6)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-replace &lt;code&gt;(old new list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Replace all &lt;code&gt;old&lt;/code&gt; items in &lt;code&gt;list&lt;/code&gt; with &lt;code&gt;new&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Elements are compared using &lt;code&gt;equal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-replace-at-n-x-list&#34;&gt;&lt;code&gt;-replace-at&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-replace 1 &#34;1&#34; &#39;(1 2 3 4 3 2 1)) ;; =&amp;gt; (&#34;1&#34; 2 3 4 3 2 &#34;1&#34;)&#xA;(-replace &#34;foo&#34; &#34;bar&#34; &#39;(&#34;a&#34; &#34;nice&#34; &#34;foo&#34; &#34;sentence&#34; &#34;about&#34; &#34;foo&#34;)) ;; =&amp;gt; (&#34;a&#34; &#34;nice&#34; &#34;bar&#34; &#34;sentence&#34; &#34;about&#34; &#34;bar&#34;)&#xA;(-replace 1 2 nil) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-replace-first &lt;code&gt;(old new list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Replace the first occurrence of &lt;code&gt;old&lt;/code&gt; with &lt;code&gt;new&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Elements are compared using &lt;code&gt;equal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-first-pred-rep-list&#34;&gt;&lt;code&gt;-map-first&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-replace-first 1 &#34;1&#34; &#39;(1 2 3 4 3 2 1)) ;; =&amp;gt; (&#34;1&#34; 2 3 4 3 2 1)&#xA;(-replace-first &#34;foo&#34; &#34;bar&#34; &#39;(&#34;a&#34; &#34;nice&#34; &#34;foo&#34; &#34;sentence&#34; &#34;about&#34; &#34;foo&#34;)) ;; =&amp;gt; (&#34;a&#34; &#34;nice&#34; &#34;bar&#34; &#34;sentence&#34; &#34;about&#34; &#34;foo&#34;)&#xA;(-replace-first 1 2 nil) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-replace-last &lt;code&gt;(old new list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Replace the last occurrence of &lt;code&gt;old&lt;/code&gt; with &lt;code&gt;new&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Elements are compared using &lt;code&gt;equal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-last-pred-rep-list&#34;&gt;&lt;code&gt;-map-last&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-replace-last 1 &#34;1&#34; &#39;(1 2 3 4 3 2 1)) ;; =&amp;gt; (1 2 3 4 3 2 &#34;1&#34;)&#xA;(-replace-last &#34;foo&#34; &#34;bar&#34; &#39;(&#34;a&#34; &#34;nice&#34; &#34;foo&#34; &#34;sentence&#34; &#34;about&#34; &#34;foo&#34;)) ;; =&amp;gt; (&#34;a&#34; &#34;nice&#34; &#34;foo&#34; &#34;sentence&#34; &#34;about&#34; &#34;bar&#34;)&#xA;(-replace-last 1 2 nil) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-insert-at &lt;code&gt;(n x list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list with &lt;code&gt;x&lt;/code&gt; inserted into &lt;code&gt;list&lt;/code&gt; at position &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-splice-pred-fun-list&#34;&gt;&lt;code&gt;-splice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-splice-list-pred-new-list-list&#34;&gt;&lt;code&gt;-splice-list&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-insert-at 1 &#39;x &#39;(a b c)) ;; =&amp;gt; (a x b c)&#xA;(-insert-at 12 &#39;x &#39;(a b c)) ;; =&amp;gt; (a b c x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-replace-at &lt;code&gt;(n x list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list with element at &lt;code&gt;n&lt;/code&gt;th position in &lt;code&gt;list&lt;/code&gt; replaced with &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-replace-old-new-list&#34;&gt;&lt;code&gt;-replace&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-replace-at 0 9 &#39;(0 1 2 3 4 5)) ;; =&amp;gt; (9 1 2 3 4 5)&#xA;(-replace-at 1 9 &#39;(0 1 2 3 4 5)) ;; =&amp;gt; (0 9 2 3 4 5)&#xA;(-replace-at 4 9 &#39;(0 1 2 3 4 5)) ;; =&amp;gt; (0 1 2 3 9 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-update-at &lt;code&gt;(n func list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Use &lt;code&gt;func&lt;/code&gt; to update the &lt;code&gt;n&lt;/code&gt;th element of &lt;code&gt;list&lt;/code&gt;. Return a copy of &lt;code&gt;list&lt;/code&gt; where the &lt;code&gt;n&lt;/code&gt;th element is replaced with the result of calling &lt;code&gt;func&lt;/code&gt; on it.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-when-pred-rep-list&#34;&gt;&lt;code&gt;-map-when&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-update-at 0 (lambda (x) (+ x 9)) &#39;(0 1 2 3 4 5)) ;; =&amp;gt; (9 1 2 3 4 5)&#xA;(-update-at 1 (lambda (x) (+ x 8)) &#39;(0 1 2 3 4 5)) ;; =&amp;gt; (0 9 2 3 4 5)&#xA;(--update-at 2 (length it) &#39;(&#34;foo&#34; &#34;bar&#34; &#34;baz&#34; &#34;quux&#34;)) ;; =&amp;gt; (&#34;foo&#34; &#34;bar&#34; 3 &#34;quux&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-remove-at &lt;code&gt;(n list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return &lt;code&gt;list&lt;/code&gt; with its element at index &lt;code&gt;n&lt;/code&gt; removed. That is, remove any element selected as (nth &lt;code&gt;n&lt;/code&gt; &lt;code&gt;list&lt;/code&gt;) from &lt;code&gt;list&lt;/code&gt; and return the result.&lt;/p&gt; &#xA;&lt;p&gt;This is a non-destructive operation: parts of &lt;code&gt;list&lt;/code&gt; (but not necessarily all of it) are copied as needed to avoid destructively modifying it.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-at-indices-indices-list&#34;&gt;&lt;code&gt;-remove-at-indices&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-pred-list&#34;&gt;&lt;code&gt;-remove&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-remove-at 0 &#39;(a b c)) ;; =&amp;gt; (b c)&#xA;(-remove-at 1 &#39;(a b c)) ;; =&amp;gt; (a c)&#xA;(-remove-at 2 &#39;(a b c)) ;; =&amp;gt; (a b)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-remove-at-indices &lt;code&gt;(indices list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return &lt;code&gt;list&lt;/code&gt; with its elements at &lt;code&gt;indices&lt;/code&gt; removed. That is, for each index &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;indices&lt;/code&gt;, remove any element selected as (nth &lt;code&gt;i&lt;/code&gt; &lt;code&gt;list&lt;/code&gt;) from &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is a non-destructive operation: parts of &lt;code&gt;list&lt;/code&gt; (but not necessarily all of it) are copied as needed to avoid destructively modifying it.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-at-n-list&#34;&gt;&lt;code&gt;-remove-at&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-remove-pred-list&#34;&gt;&lt;code&gt;-remove&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-remove-at-indices &#39;(0) &#39;(a b c d e)) ;; =&amp;gt; (b c d e)&#xA;(-remove-at-indices &#39;(1 3) &#39;(a b c d e)) ;; =&amp;gt; (a c e)&#xA;(-remove-at-indices &#39;(4 0 2) &#39;(a b c d e)) ;; =&amp;gt; (b d)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Reductions&lt;/h2&gt; &#xA;&lt;p&gt;Functions reducing lists to a single value (which may also be a list).&lt;/p&gt; &#xA;&lt;h4&gt;-reduce-from &lt;code&gt;(fn init list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Reduce the function &lt;code&gt;fn&lt;/code&gt; across &lt;code&gt;list&lt;/code&gt;, starting with &lt;code&gt;init&lt;/code&gt;. Return the result of applying &lt;code&gt;fn&lt;/code&gt; to &lt;code&gt;init&lt;/code&gt; and the first element of &lt;code&gt;list&lt;/code&gt;, then applying &lt;code&gt;fn&lt;/code&gt; to that result and the second element, etc. If &lt;code&gt;list&lt;/code&gt; is empty, return &lt;code&gt;init&lt;/code&gt; without calling &lt;code&gt;fn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--reduce-from&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For other folds, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-fn-list&#34;&gt;&lt;code&gt;-reduce&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-fn-list&#34;&gt;&lt;code&gt;-reduce-r&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-reduce-from #&#39;- 10 &#39;(1 2 3)) ;; =&amp;gt; 4&#xA;(-reduce-from #&#39;list 10 &#39;(1 2 3)) ;; =&amp;gt; (((10 1) 2) 3)&#xA;(--reduce-from (concat acc &#34; &#34; it) &#34;START&#34; &#39;(&#34;a&#34; &#34;b&#34; &#34;c&#34;)) ;; =&amp;gt; &#34;START a b c&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-reduce-r-from &lt;code&gt;(fn init list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Reduce the function &lt;code&gt;fn&lt;/code&gt; across &lt;code&gt;list&lt;/code&gt; in reverse, starting with &lt;code&gt;init&lt;/code&gt;. Return the result of applying &lt;code&gt;fn&lt;/code&gt; to the last element of &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;init&lt;/code&gt;, then applying &lt;code&gt;fn&lt;/code&gt; to the second-to-last element and the previous result of &lt;code&gt;fn&lt;/code&gt;, etc. That is, the first argument of &lt;code&gt;fn&lt;/code&gt; is the current element, and its second argument the accumulated value. If &lt;code&gt;list&lt;/code&gt; is empty, return &lt;code&gt;init&lt;/code&gt; without calling &lt;code&gt;fn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function is like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-from-fn-init-list&#34;&gt;&lt;code&gt;-reduce-from&lt;/code&gt;&lt;/a&gt; but the operation associates from the right rather than left. In other words, it starts from the end of &lt;code&gt;list&lt;/code&gt; and flips the arguments to &lt;code&gt;fn&lt;/code&gt;. Conceptually, it is like replacing the conses in &lt;code&gt;list&lt;/code&gt; with applications of &lt;code&gt;fn&lt;/code&gt;, and its last link with &lt;code&gt;init&lt;/code&gt;, and evaluating the resulting expression.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--reduce-r-from&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For other folds, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-fn-list&#34;&gt;&lt;code&gt;-reduce-r&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-fn-list&#34;&gt;&lt;code&gt;-reduce&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-reduce-r-from #&#39;- 10 &#39;(1 2 3)) ;; =&amp;gt; -8&#xA;(-reduce-r-from #&#39;list 10 &#39;(1 2 3)) ;; =&amp;gt; (1 (2 (3 10)))&#xA;(--reduce-r-from (concat it &#34; &#34; acc) &#34;END&#34; &#39;(&#34;a&#34; &#34;b&#34; &#34;c&#34;)) ;; =&amp;gt; &#34;a b c END&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-reduce &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Reduce the function &lt;code&gt;fn&lt;/code&gt; across &lt;code&gt;list&lt;/code&gt;. Return the result of applying &lt;code&gt;fn&lt;/code&gt; to the first two elements of &lt;code&gt;list&lt;/code&gt;, then applying &lt;code&gt;fn&lt;/code&gt; to that result and the third element, etc. If &lt;code&gt;list&lt;/code&gt; contains a single element, return it without calling &lt;code&gt;fn&lt;/code&gt;. If &lt;code&gt;list&lt;/code&gt; is empty, return the result of calling &lt;code&gt;fn&lt;/code&gt; with no arguments.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--reduce&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For other folds, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-from-fn-init-list&#34;&gt;&lt;code&gt;-reduce-from&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-fn-list&#34;&gt;&lt;code&gt;-reduce-r&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-reduce #&#39;- &#39;(1 2 3 4)) ;; =&amp;gt; -8&#xA;(-reduce #&#39;list &#39;(1 2 3 4)) ;; =&amp;gt; (((1 2) 3) 4)&#xA;(--reduce (format &#34;%s-%d&#34; acc it) &#39;(1 2 3)) ;; =&amp;gt; &#34;1-2-3&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-reduce-r &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Reduce the function &lt;code&gt;fn&lt;/code&gt; across &lt;code&gt;list&lt;/code&gt; in reverse. Return the result of applying &lt;code&gt;fn&lt;/code&gt; to the last two elements of &lt;code&gt;list&lt;/code&gt;, then applying &lt;code&gt;fn&lt;/code&gt; to the third-to-last element and the previous result of &lt;code&gt;fn&lt;/code&gt;, etc. That is, the first argument of &lt;code&gt;fn&lt;/code&gt; is the current element, and its second argument the accumulated value. If &lt;code&gt;list&lt;/code&gt; contains a single element, return it without calling &lt;code&gt;fn&lt;/code&gt;. If &lt;code&gt;list&lt;/code&gt; is empty, return the result of calling &lt;code&gt;fn&lt;/code&gt; with no arguments.&lt;/p&gt; &#xA;&lt;p&gt;This function is like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-fn-list&#34;&gt;&lt;code&gt;-reduce&lt;/code&gt;&lt;/a&gt; but the operation associates from the right rather than left. In other words, it starts from the end of &lt;code&gt;list&lt;/code&gt; and flips the arguments to &lt;code&gt;fn&lt;/code&gt;. Conceptually, it is like replacing the conses in &lt;code&gt;list&lt;/code&gt; with applications of &lt;code&gt;fn&lt;/code&gt;, ignoring its last link, and evaluating the resulting expression.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--reduce-r&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For other folds, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-from-fn-init-list&#34;&gt;&lt;code&gt;-reduce-r-from&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-fn-list&#34;&gt;&lt;code&gt;-reduce&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-reduce-r #&#39;- &#39;(1 2 3 4)) ;; =&amp;gt; -2&#xA;(-reduce-r #&#39;list &#39;(1 2 3 4)) ;; =&amp;gt; (1 (2 (3 4)))&#xA;(--reduce-r (format &#34;%s-%d&#34; acc it) &#39;(1 2 3)) ;; =&amp;gt; &#34;3-2-1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-reductions-from &lt;code&gt;(fn init list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list of &lt;code&gt;fn&lt;/code&gt;&#39;s intermediate reductions across &lt;code&gt;list&lt;/code&gt;. That is, a list of the intermediate values of the accumulator when &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-from-fn-init-list&#34;&gt;&lt;code&gt;-reduce-from&lt;/code&gt;&lt;/a&gt; (which see) is called with the same arguments.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--reductions-from&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For other folds, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-fn-list&#34;&gt;&lt;code&gt;-reductions&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-r-fn-list&#34;&gt;&lt;code&gt;-reductions-r&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-reductions-from #&#39;max 0 &#39;(2 1 4 3)) ;; =&amp;gt; (0 2 2 4 4)&#xA;(-reductions-from #&#39;* 1 &#39;(1 2 3 4)) ;; =&amp;gt; (1 1 2 6 24)&#xA;(--reductions-from (format &#34;(FN %s %d)&#34; acc it) &#34;INIT&#34; &#39;(1 2 3)) ;; =&amp;gt; (&#34;INIT&#34; &#34;(FN INIT 1)&#34; &#34;(FN (FN INIT 1) 2)&#34; &#34;(FN (FN (FN INIT 1) 2) 3)&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-reductions-r-from &lt;code&gt;(fn init list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list of &lt;code&gt;fn&lt;/code&gt;&#39;s intermediate reductions across reversed &lt;code&gt;list&lt;/code&gt;. That is, a list of the intermediate values of the accumulator when &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-from-fn-init-list&#34;&gt;&lt;code&gt;-reduce-r-from&lt;/code&gt;&lt;/a&gt; (which see) is called with the same arguments.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--reductions-r-from&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For other folds, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-fn-list&#34;&gt;&lt;code&gt;-reductions&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-r-fn-list&#34;&gt;&lt;code&gt;-reductions-r&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-reductions-r-from #&#39;max 0 &#39;(2 1 4 3)) ;; =&amp;gt; (4 4 4 3 0)&#xA;(-reductions-r-from #&#39;* 1 &#39;(1 2 3 4)) ;; =&amp;gt; (24 24 12 4 1)&#xA;(--reductions-r-from (format &#34;(FN %d %s)&#34; it acc) &#34;INIT&#34; &#39;(1 2 3)) ;; =&amp;gt; (&#34;(FN 1 (FN 2 (FN 3 INIT)))&#34; &#34;(FN 2 (FN 3 INIT))&#34; &#34;(FN 3 INIT)&#34; &#34;INIT&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-reductions &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list of &lt;code&gt;fn&lt;/code&gt;&#39;s intermediate reductions across &lt;code&gt;list&lt;/code&gt;. That is, a list of the intermediate values of the accumulator when &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-fn-list&#34;&gt;&lt;code&gt;-reduce&lt;/code&gt;&lt;/a&gt; (which see) is called with the same arguments.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--reductions&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For other folds, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-fn-list&#34;&gt;&lt;code&gt;-reductions&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-r-fn-list&#34;&gt;&lt;code&gt;-reductions-r&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-reductions #&#39;+ &#39;(1 2 3 4)) ;; =&amp;gt; (1 3 6 10)&#xA;(-reductions #&#39;* &#39;(1 2 3 4)) ;; =&amp;gt; (1 2 6 24)&#xA;(--reductions (format &#34;(FN %s %d)&#34; acc it) &#39;(1 2 3)) ;; =&amp;gt; (1 &#34;(FN 1 2)&#34; &#34;(FN (FN 1 2) 3)&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-reductions-r &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list of &lt;code&gt;fn&lt;/code&gt;&#39;s intermediate reductions across reversed &lt;code&gt;list&lt;/code&gt;. That is, a list of the intermediate values of the accumulator when &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-fn-list&#34;&gt;&lt;code&gt;-reduce-r&lt;/code&gt;&lt;/a&gt; (which see) is called with the same arguments.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--reductions-r&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For other folds, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-r-from-fn-init-list&#34;&gt;&lt;code&gt;-reductions-r-from&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reductions-fn-list&#34;&gt;&lt;code&gt;-reductions&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-reductions-r #&#39;+ &#39;(1 2 3 4)) ;; =&amp;gt; (10 9 7 4)&#xA;(-reductions-r #&#39;* &#39;(1 2 3 4)) ;; =&amp;gt; (24 24 12 4)&#xA;(--reductions-r (format &#34;(FN %d %s)&#34; it acc) &#39;(1 2 3)) ;; =&amp;gt; (&#34;(FN 1 (FN 2 3))&#34; &#34;(FN 2 3)&#34; 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-count &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Counts the number of items in &lt;code&gt;list&lt;/code&gt; where (&lt;code&gt;pred&lt;/code&gt; item) is non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-count &#39;even? &#39;(1 2 3 4 5)) ;; =&amp;gt; 2&#xA;(--count (&amp;lt; it 4) &#39;(1 2 3 4)) ;; =&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-sum &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the sum of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-sum ()) ;; =&amp;gt; 0&#xA;(-sum &#39;(1)) ;; =&amp;gt; 1&#xA;(-sum &#39;(1 2 3 4)) ;; =&amp;gt; 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-running-sum &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list with running sums of items in &lt;code&gt;list&lt;/code&gt;. &lt;code&gt;list&lt;/code&gt; must be non-empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-running-sum &#39;(1 2 3 4)) ;; =&amp;gt; (1 3 6 10)&#xA;(-running-sum &#39;(1)) ;; =&amp;gt; (1)&#xA;(-running-sum ()) ;; Wrong type argument: consp, nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-product &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the product of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-product ()) ;; =&amp;gt; 1&#xA;(-product &#39;(1)) ;; =&amp;gt; 1&#xA;(-product &#39;(1 2 3 4)) ;; =&amp;gt; 24&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-running-product &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list with running products of items in &lt;code&gt;list&lt;/code&gt;. &lt;code&gt;list&lt;/code&gt; must be non-empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-running-product &#39;(1 2 3 4)) ;; =&amp;gt; (1 2 6 24)&#xA;(-running-product &#39;(1)) ;; =&amp;gt; (1)&#xA;(-running-product ()) ;; Wrong type argument: consp, nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-inits &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return all prefixes of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-inits &#39;(1 2 3 4)) ;; =&amp;gt; (nil (1) (1 2) (1 2 3) (1 2 3 4))&#xA;(-inits nil) ;; =&amp;gt; (nil)&#xA;(-inits &#39;(1)) ;; =&amp;gt; (nil (1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-tails &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return all suffixes of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-tails &#39;(1 2 3 4)) ;; =&amp;gt; ((1 2 3 4) (2 3 4) (3 4) (4) nil)&#xA;(-tails nil) ;; =&amp;gt; (nil)&#xA;(-tails &#39;(1)) ;; =&amp;gt; ((1) nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-common-prefix &lt;code&gt;(&amp;amp;rest lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the longest common prefix of &lt;code&gt;lists&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-common-prefix &#39;(1)) ;; =&amp;gt; (1)&#xA;(-common-prefix &#39;(1 2) &#39;(3 4) &#39;(1 2)) ;; =&amp;gt; ()&#xA;(-common-prefix &#39;(1 2) &#39;(1 2 3) &#39;(1 2 3 4)) ;; =&amp;gt; (1 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-common-suffix &lt;code&gt;(&amp;amp;rest lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the longest common suffix of &lt;code&gt;lists&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-common-suffix &#39;(1)) ;; =&amp;gt; (1)&#xA;(-common-suffix &#39;(1 2) &#39;(3 4) &#39;(1 2)) ;; =&amp;gt; ()&#xA;(-common-suffix &#39;(1 2 3 4) &#39;(2 3 4) &#39;(3 4)) ;; =&amp;gt; (3 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-min &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the smallest value from &lt;code&gt;list&lt;/code&gt; of numbers or markers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-min &#39;(0)) ;; =&amp;gt; 0&#xA;(-min &#39;(3 2 1)) ;; =&amp;gt; 1&#xA;(-min &#39;(1 2 3)) ;; =&amp;gt; 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-min-by &lt;code&gt;(comparator list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Take a comparison function &lt;code&gt;comparator&lt;/code&gt; and a &lt;code&gt;list&lt;/code&gt; and return the least element of the list by the comparison function.&lt;/p&gt; &#xA;&lt;p&gt;See also combinator &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-on-op-trans&#34;&gt;&lt;code&gt;-on&lt;/code&gt;&lt;/a&gt; which can transform the values before comparing them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-min-by &#39;&amp;gt; &#39;(4 3 6 1)) ;; =&amp;gt; 1&#xA;(--min-by (&amp;gt; (car it) (car other)) &#39;((1 2 3) (2) (3 2))) ;; =&amp;gt; (1 2 3)&#xA;(--min-by (&amp;gt; (length it) (length other)) &#39;((1 2 3) (2) (3 2))) ;; =&amp;gt; (2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-max &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the largest value from &lt;code&gt;list&lt;/code&gt; of numbers or markers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-max &#39;(0)) ;; =&amp;gt; 0&#xA;(-max &#39;(3 2 1)) ;; =&amp;gt; 3&#xA;(-max &#39;(1 2 3)) ;; =&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-max-by &lt;code&gt;(comparator list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Take a comparison function &lt;code&gt;comparator&lt;/code&gt; and a &lt;code&gt;list&lt;/code&gt; and return the greatest element of the list by the comparison function.&lt;/p&gt; &#xA;&lt;p&gt;See also combinator &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-on-op-trans&#34;&gt;&lt;code&gt;-on&lt;/code&gt;&lt;/a&gt; which can transform the values before comparing them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-max-by &#39;&amp;gt; &#39;(4 3 6 1)) ;; =&amp;gt; 6&#xA;(--max-by (&amp;gt; (car it) (car other)) &#39;((1 2 3) (2) (3 2))) ;; =&amp;gt; (3 2)&#xA;(--max-by (&amp;gt; (length it) (length other)) &#39;((1 2 3) (2) (3 2))) ;; =&amp;gt; (1 2 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-frequencies &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Count the occurrences of each distinct element of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Return an alist of (&lt;code&gt;element&lt;/code&gt; . &lt;code&gt;n&lt;/code&gt;), where each &lt;code&gt;element&lt;/code&gt; occurs &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The test for equality is done with &lt;code&gt;equal&lt;/code&gt;, or with &lt;code&gt;-compare-fn&lt;/code&gt; if that is non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-count-pred-list&#34;&gt;&lt;code&gt;-count&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-group-by-fn-list&#34;&gt;&lt;code&gt;-group-by&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-frequencies ()) ;; =&amp;gt; ()&#xA;(-frequencies &#39;(1 2 3 1 2 1)) ;; =&amp;gt; ((1 . 3) (2 . 2) (3 . 1))&#xA;(let ((-compare-fn #&#39;string=)) (-frequencies &#39;(a &#34;a&#34;))) ;; =&amp;gt; ((a . 2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Unfolding&lt;/h2&gt; &#xA;&lt;p&gt;Operations dual to reductions, building lists from a seed value rather than consuming a list to produce a single value.&lt;/p&gt; &#xA;&lt;h4&gt;-iterate &lt;code&gt;(fun init n)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list of iterated applications of &lt;code&gt;fun&lt;/code&gt; to &lt;code&gt;init&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This means a list of the form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(`init` (`fun` `init`) (`fun` (`fun` `init`)) ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;n&lt;/code&gt; is the length of the returned list.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-iterate #&#39;1+ 1 10) ;; =&amp;gt; (1 2 3 4 5 6 7 8 9 10)&#xA;(-iterate (lambda (x) (+ x x)) 2 5) ;; =&amp;gt; (2 4 8 16 32)&#xA;(--iterate (* it it) 2 5) ;; =&amp;gt; (2 4 16 256 65536)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-unfold &lt;code&gt;(fun seed)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Build a list from &lt;code&gt;seed&lt;/code&gt; using &lt;code&gt;fun&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is &#34;dual&#34; operation to &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-fn-list&#34;&gt;&lt;code&gt;-reduce-r&lt;/code&gt;&lt;/a&gt;: while -reduce-r consumes a list to produce a single value, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-unfold-fun-seed&#34;&gt;&lt;code&gt;-unfold&lt;/code&gt;&lt;/a&gt; takes a seed value and builds a (potentially infinite!) list.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;fun&lt;/code&gt; should return &lt;code&gt;nil&lt;/code&gt; to stop the generating process, or a cons (&lt;code&gt;a&lt;/code&gt; . &lt;code&gt;b&lt;/code&gt;), where &lt;code&gt;a&lt;/code&gt; will be prepended to the result and &lt;code&gt;b&lt;/code&gt; is the new seed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-unfold (lambda (x) (unless (= x 0) (cons x (1- x)))) 10) ;; =&amp;gt; (10 9 8 7 6 5 4 3 2 1)&#xA;(--unfold (when it (cons it (cdr it))) &#39;(1 2 3 4)) ;; =&amp;gt; ((1 2 3 4) (2 3 4) (3 4) (4))&#xA;(--unfold (when it (cons it (butlast it))) &#39;(1 2 3 4)) ;; =&amp;gt; ((1 2 3 4) (1 2 3) (1 2) (1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-repeat &lt;code&gt;(n x)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list of length &lt;code&gt;n&lt;/code&gt; with each element being &lt;code&gt;x&lt;/code&gt;. Return &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; is less than 1.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-repeat 3 :a) ;; =&amp;gt; (:a :a :a)&#xA;(-repeat 1 :a) ;; =&amp;gt; (:a)&#xA;(-repeat 0 :a) ;; =&amp;gt; ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-cycle &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return an infinite circular copy of &lt;code&gt;list&lt;/code&gt;. The returned list cycles through the elements of &lt;code&gt;list&lt;/code&gt; and repeats from the beginning.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-take 5 (-cycle &#39;(1 2 3))) ;; =&amp;gt; (1 2 3 1 2)&#xA;(-take 7 (-cycle &#39;(1 &#34;and&#34; 3))) ;; =&amp;gt; (1 &#34;and&#34; 3 1 &#34;and&#34; 3 1)&#xA;(-zip-lists (-cycle &#39;(3)) &#39;(1 2)) ;; =&amp;gt; ((3 1) (3 2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Predicates&lt;/h2&gt; &#xA;&lt;p&gt;Reductions of one or more lists to a boolean value.&lt;/p&gt; &#xA;&lt;h4&gt;-some &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return (&lt;code&gt;pred&lt;/code&gt; x) for the first &lt;code&gt;list&lt;/code&gt; item where (&lt;code&gt;pred&lt;/code&gt; x) is non-&lt;code&gt;nil&lt;/code&gt;, else &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-any&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--some&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-some #&#39;stringp &#39;(1 &#34;2&#34; 3)) ;; =&amp;gt; t&#xA;(--some (string-match-p &#34;x&#34; it) &#39;(&#34;foo&#34; &#34;axe&#34; &#34;xor&#34;)) ;; =&amp;gt; 1&#xA;(--some (= it-index 3) &#39;(0 1 2)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-every &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return non-&lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt; for all items in &lt;code&gt;list&lt;/code&gt;. If so, return the last such result of &lt;code&gt;pred&lt;/code&gt;. Otherwise, once an item is reached for which &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, return &lt;code&gt;nil&lt;/code&gt; without calling &lt;code&gt;pred&lt;/code&gt; on any further &lt;code&gt;list&lt;/code&gt; elements.&lt;/p&gt; &#xA;&lt;p&gt;This function is like &lt;code&gt;-every-p&lt;/code&gt;, but on success returns the last non-&lt;code&gt;nil&lt;/code&gt; result of &lt;code&gt;pred&lt;/code&gt; instead of just &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--every&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-every #&#39;numberp &#39;(1 2 3)) ;; =&amp;gt; t&#xA;(--every (string-match-p &#34;x&#34; it) &#39;(&#34;axe&#34; &#34;xor&#34;)) ;; =&amp;gt; 0&#xA;(--every (= it it-index) &#39;(0 1 3)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-any? &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return &lt;code&gt;t&lt;/code&gt; if (&lt;code&gt;pred&lt;/code&gt; &lt;code&gt;x&lt;/code&gt;) is non-&lt;code&gt;nil&lt;/code&gt; for any &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, else &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-any-p&lt;/code&gt;, &lt;code&gt;-some?&lt;/code&gt;, &lt;code&gt;-some-p&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-any? #&#39;numberp &#39;(nil 0 t)) ;; =&amp;gt; t&#xA;(-any? #&#39;numberp &#39;(nil t t)) ;; =&amp;gt; nil&#xA;(-any? #&#39;null &#39;(1 3 5)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-all? &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return &lt;code&gt;t&lt;/code&gt; if (&lt;code&gt;pred&lt;/code&gt; &lt;code&gt;x&lt;/code&gt;) is non-&lt;code&gt;nil&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, else &lt;code&gt;nil&lt;/code&gt;. In the latter case, stop after the first &lt;code&gt;x&lt;/code&gt; for which (&lt;code&gt;pred&lt;/code&gt; &lt;code&gt;x&lt;/code&gt;) is &lt;code&gt;nil&lt;/code&gt;, without calling &lt;code&gt;pred&lt;/code&gt; on any subsequent elements of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The similar function &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-every-pred-list&#34;&gt;&lt;code&gt;-every&lt;/code&gt;&lt;/a&gt; is more widely useful, since it returns the last non-&lt;code&gt;nil&lt;/code&gt; result of &lt;code&gt;pred&lt;/code&gt; instead of just &lt;code&gt;t&lt;/code&gt; on success.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-all-p&lt;/code&gt;, &lt;code&gt;-every-p&lt;/code&gt;, &lt;code&gt;-every?&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--all?&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-all? #&#39;numberp &#39;(1 2 3)) ;; =&amp;gt; t&#xA;(-all? #&#39;numberp &#39;(2 t 6)) ;; =&amp;gt; nil&#xA;(--all? (= 0 (% it 2)) &#39;(2 4 6)) ;; =&amp;gt; t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-none? &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return &lt;code&gt;t&lt;/code&gt; if (&lt;code&gt;pred&lt;/code&gt; &lt;code&gt;x&lt;/code&gt;) is &lt;code&gt;nil&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, else &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-none-p&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-none? &#39;even? &#39;(1 2 3)) ;; =&amp;gt; nil&#xA;(-none? &#39;even? &#39;(1 3 5)) ;; =&amp;gt; t&#xA;(--none? (= 0 (% it 2)) &#39;(1 2 3)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-only-some? &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return &lt;code&gt;t&lt;/code&gt; if different &lt;code&gt;list&lt;/code&gt; items both satisfy and do not satisfy &lt;code&gt;pred&lt;/code&gt;. That is, if &lt;code&gt;pred&lt;/code&gt; returns both &lt;code&gt;nil&lt;/code&gt; for at least one item, and non-&lt;code&gt;nil&lt;/code&gt; for at least one other item in &lt;code&gt;list&lt;/code&gt;. Return &lt;code&gt;nil&lt;/code&gt; if all items satisfy the predicate or none of them do.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-only-some-p&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-only-some? &#39;even? &#39;(1 2 3)) ;; =&amp;gt; t&#xA;(-only-some? &#39;even? &#39;(1 3 5)) ;; =&amp;gt; nil&#xA;(-only-some? &#39;even? &#39;(2 4 6)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-contains? &lt;code&gt;(list element)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return non-&lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; contains &lt;code&gt;element&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The test for equality is done with &lt;code&gt;equal&lt;/code&gt;, or with &lt;code&gt;-compare-fn&lt;/code&gt; if that is non-&lt;code&gt;nil&lt;/code&gt;. As with &lt;code&gt;member&lt;/code&gt;, the return value is actually the tail of &lt;code&gt;list&lt;/code&gt; whose car is &lt;code&gt;element&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-contains-p&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-contains? &#39;(1 2 3) 1) ;; =&amp;gt; (1 2 3)&#xA;(-contains? &#39;(1 2 3) 2) ;; =&amp;gt; (2 3)&#xA;(-contains? &#39;(1 2 3) 4) ;; =&amp;gt; ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-is-prefix? &lt;code&gt;(prefix list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return non-&lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;prefix&lt;/code&gt; is a prefix of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-is-prefix-p&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-is-prefix? &#39;(1 2 3) &#39;(1 2 3 4 5)) ;; =&amp;gt; t&#xA;(-is-prefix? &#39;(1 2 3 4 5) &#39;(1 2 3)) ;; =&amp;gt; nil&#xA;(-is-prefix? &#39;(1 3) &#39;(1 2 3 4 5)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-is-suffix? &lt;code&gt;(suffix list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return non-&lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;suffix&lt;/code&gt; is a suffix of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-is-suffix-p&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-is-suffix? &#39;(3 4 5) &#39;(1 2 3 4 5)) ;; =&amp;gt; t&#xA;(-is-suffix? &#39;(1 2 3 4 5) &#39;(3 4 5)) ;; =&amp;gt; nil&#xA;(-is-suffix? &#39;(3 5) &#39;(1 2 3 4 5)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-is-infix? &lt;code&gt;(infix list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return non-&lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;infix&lt;/code&gt; is infix of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This operation runs in O(n^2) time&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-is-infix-p&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-is-infix? &#39;(1 2 3) &#39;(1 2 3 4 5)) ;; =&amp;gt; t&#xA;(-is-infix? &#39;(2 3 4) &#39;(1 2 3 4 5)) ;; =&amp;gt; t&#xA;(-is-infix? &#39;(3 4 5) &#39;(1 2 3 4 5)) ;; =&amp;gt; t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-cons-pair? &lt;code&gt;(obj)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return non-&lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is a true cons pair. That is, a cons (&lt;code&gt;a&lt;/code&gt; . &lt;code&gt;b&lt;/code&gt;) where &lt;code&gt;b&lt;/code&gt; is not a list.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-cons-pair-p&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-cons-pair? &#39;(1 . 2)) ;; =&amp;gt; t&#xA;(-cons-pair? &#39;(1 2)) ;; =&amp;gt; nil&#xA;(-cons-pair? &#39;(1)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Partitioning&lt;/h2&gt; &#xA;&lt;p&gt;Functions partitioning the input list into a list of lists.&lt;/p&gt; &#xA;&lt;h4&gt;-split-at &lt;code&gt;(n list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Split &lt;code&gt;list&lt;/code&gt; into two sublists after the &lt;code&gt;n&lt;/code&gt;th element. The result is a list of two elements (&lt;code&gt;take&lt;/code&gt; &lt;code&gt;drop&lt;/code&gt;) where &lt;code&gt;take&lt;/code&gt; is a new list of the first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;list&lt;/code&gt;, and &lt;code&gt;drop&lt;/code&gt; is the remaining elements of &lt;code&gt;list&lt;/code&gt; (not a copy). &lt;code&gt;take&lt;/code&gt; and &lt;code&gt;drop&lt;/code&gt; are like the results of &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-take-n-list&#34;&gt;&lt;code&gt;-take&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-drop-n-list&#34;&gt;&lt;code&gt;-drop&lt;/code&gt;&lt;/a&gt;, respectively, but the split is done in a single list traversal.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-split-at 3 &#39;(1 2 3 4 5)) ;; =&amp;gt; ((1 2 3) (4 5))&#xA;(-split-at 17 &#39;(1 2 3 4 5)) ;; =&amp;gt; ((1 2 3 4 5) nil)&#xA;(-split-at 0 &#39;(1 2 3 4 5)) ;; =&amp;gt; (nil (1 2 3 4 5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-split-with &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Split &lt;code&gt;list&lt;/code&gt; into a prefix satisfying &lt;code&gt;pred&lt;/code&gt;, and the rest. The first sublist is the prefix of &lt;code&gt;list&lt;/code&gt; with successive elements satisfying &lt;code&gt;pred&lt;/code&gt;, and the second sublist is the remaining elements that do not. The result is like performing&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;((-take-while `pred` `list`) (-drop-while `pred` `list`))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but in no more than a single pass through &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-split-with &#39;even? &#39;(1 2 3 4)) ;; =&amp;gt; (nil (1 2 3 4))&#xA;(-split-with &#39;even? &#39;(2 4 5 6)) ;; =&amp;gt; ((2 4) (5 6))&#xA;(--split-with (&amp;lt; it 4) &#39;(1 2 3 4 3 2 1)) ;; =&amp;gt; ((1 2 3) (4 3 2 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-split-on &lt;code&gt;(item list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Split the &lt;code&gt;list&lt;/code&gt; each time &lt;code&gt;item&lt;/code&gt; is found.&lt;/p&gt; &#xA;&lt;p&gt;Unlike &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-by-fn-list&#34;&gt;&lt;code&gt;-partition-by&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;item&lt;/code&gt; is discarded from the results. Empty lists are also removed from the result.&lt;/p&gt; &#xA;&lt;p&gt;Comparison is done by &lt;code&gt;equal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-split-when-fn-list&#34;&gt;&lt;code&gt;-split-when&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-split-on &#39;| &#39;(Nil | Leaf a | Node [Tree a])) ;; =&amp;gt; ((Nil) (Leaf a) (Node [Tree a]))&#xA;(-split-on :endgroup &#39;(&#34;a&#34; &#34;b&#34; :endgroup &#34;c&#34; :endgroup &#34;d&#34; &#34;e&#34;)) ;; =&amp;gt; ((&#34;a&#34; &#34;b&#34;) (&#34;c&#34;) (&#34;d&#34; &#34;e&#34;))&#xA;(-split-on :endgroup &#39;(&#34;a&#34; &#34;b&#34; :endgroup :endgroup &#34;d&#34; &#34;e&#34;)) ;; =&amp;gt; ((&#34;a&#34; &#34;b&#34;) (&#34;d&#34; &#34;e&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-split-when &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Split the &lt;code&gt;list&lt;/code&gt; on each element where &lt;code&gt;fn&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unlike &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-by-fn-list&#34;&gt;&lt;code&gt;-partition-by&lt;/code&gt;&lt;/a&gt;, the &#34;matched&#34; element is discarded from the results. Empty lists are also removed from the result.&lt;/p&gt; &#xA;&lt;p&gt;This function can be thought of as a generalization of &lt;code&gt;split-string&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-split-when &#39;even? &#39;(1 2 3 4 5 6)) ;; =&amp;gt; ((1) (3) (5))&#xA;(-split-when &#39;even? &#39;(1 2 3 4 6 8 9)) ;; =&amp;gt; ((1) (3) (9))&#xA;(--split-when (memq it &#39;(&amp;amp;optional &amp;amp;rest)) &#39;(a b &amp;amp;optional c d &amp;amp;rest args)) ;; =&amp;gt; ((a b) (c d) (args))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-separate &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Split &lt;code&gt;list&lt;/code&gt; into two sublists based on whether items satisfy &lt;code&gt;pred&lt;/code&gt;. The result is like performing&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;((-filter `pred` `list`) (-remove `pred` `list`))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but in a single pass through &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-separate (lambda (num) (= 0 (% num 2))) &#39;(1 2 3 4 5 6 7)) ;; =&amp;gt; ((2 4 6) (1 3 5 7))&#xA;(--separate (&amp;lt; it 5) &#39;(3 7 5 9 3 2 1 4 6)) ;; =&amp;gt; ((3 3 2 1 4) (7 5 9 6))&#xA;(-separate &#39;cdr &#39;((1 2) (1) (1 2 3) (4))) ;; =&amp;gt; (((1 2) (1 2 3)) ((1) (4)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-partition &lt;code&gt;(n list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list with the items in &lt;code&gt;list&lt;/code&gt; grouped into &lt;code&gt;n&lt;/code&gt;-sized sublists. If there are not enough items to make the last group &lt;code&gt;n&lt;/code&gt;-sized, those items are discarded.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-partition 2 &#39;(1 2 3 4 5 6)) ;; =&amp;gt; ((1 2) (3 4) (5 6))&#xA;(-partition 2 &#39;(1 2 3 4 5 6 7)) ;; =&amp;gt; ((1 2) (3 4) (5 6))&#xA;(-partition 3 &#39;(1 2 3 4 5 6 7)) ;; =&amp;gt; ((1 2 3) (4 5 6))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-partition-all &lt;code&gt;(n list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list with the items in &lt;code&gt;list&lt;/code&gt; grouped into &lt;code&gt;n&lt;/code&gt;-sized sublists. The last group may contain less than &lt;code&gt;n&lt;/code&gt; items.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-partition-all 2 &#39;(1 2 3 4 5 6)) ;; =&amp;gt; ((1 2) (3 4) (5 6))&#xA;(-partition-all 2 &#39;(1 2 3 4 5 6 7)) ;; =&amp;gt; ((1 2) (3 4) (5 6) (7))&#xA;(-partition-all 3 &#39;(1 2 3 4 5 6 7)) ;; =&amp;gt; ((1 2 3) (4 5 6) (7))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-partition-in-steps &lt;code&gt;(n step list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Partition &lt;code&gt;list&lt;/code&gt; into sublists of length &lt;code&gt;n&lt;/code&gt; that are &lt;code&gt;step&lt;/code&gt; items apart. Like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partition-all-in-steps-n-step-list&#34;&gt;&lt;code&gt;-partition-all-in-steps&lt;/code&gt;&lt;/a&gt;, but if there are not enough items to make the last group &lt;code&gt;n&lt;/code&gt;-sized, those items are discarded.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-partition-in-steps 2 1 &#39;(1 2 3 4)) ;; =&amp;gt; ((1 2) (2 3) (3 4))&#xA;(-partition-in-steps 3 2 &#39;(1 2 3 4)) ;; =&amp;gt; ((1 2 3))&#xA;(-partition-in-steps 3 2 &#39;(1 2 3 4 5)) ;; =&amp;gt; ((1 2 3) (3 4 5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-partition-all-in-steps &lt;code&gt;(n step list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Partition &lt;code&gt;list&lt;/code&gt; into sublists of length &lt;code&gt;n&lt;/code&gt; that are &lt;code&gt;step&lt;/code&gt; items apart. Adjacent groups may overlap if &lt;code&gt;n&lt;/code&gt; exceeds the &lt;code&gt;step&lt;/code&gt; stride. Trailing groups may contain less than &lt;code&gt;n&lt;/code&gt; items.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-partition-all-in-steps 2 1 &#39;(1 2 3 4)) ;; =&amp;gt; ((1 2) (2 3) (3 4) (4))&#xA;(-partition-all-in-steps 3 2 &#39;(1 2 3 4)) ;; =&amp;gt; ((1 2 3) (3 4))&#xA;(-partition-all-in-steps 3 2 &#39;(1 2 3 4 5)) ;; =&amp;gt; ((1 2 3) (3 4 5) (5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-partition-by &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Apply &lt;code&gt;fn&lt;/code&gt; to each item in &lt;code&gt;list&lt;/code&gt;, splitting it each time &lt;code&gt;fn&lt;/code&gt; returns a new value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-partition-by &#39;even? ()) ;; =&amp;gt; ()&#xA;(-partition-by &#39;even? &#39;(1 1 2 2 2 3 4 6 8)) ;; =&amp;gt; ((1 1) (2 2 2) (3) (4 6 8))&#xA;(--partition-by (&amp;lt; it 3) &#39;(1 2 3 4 3 2 1)) ;; =&amp;gt; ((1 2) (3 4 3) (2 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-partition-by-header &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Apply &lt;code&gt;fn&lt;/code&gt; to the first item in &lt;code&gt;list&lt;/code&gt;. That is the header value. Apply &lt;code&gt;fn&lt;/code&gt; to each item in &lt;code&gt;list&lt;/code&gt;, splitting it each time &lt;code&gt;fn&lt;/code&gt; returns the header value, but only after seeing at least one other value (the body).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(--partition-by-header (= it 1) &#39;(1 2 3 1 2 1 2 3 4)) ;; =&amp;gt; ((1 2 3) (1 2) (1 2 3 4))&#xA;(--partition-by-header (&amp;gt; it 0) &#39;(1 2 0 1 0 1 2 3 0)) ;; =&amp;gt; ((1 2 0) (1 0) (1 2 3 0))&#xA;(-partition-by-header &#39;even? &#39;(2 1 1 1 4 1 3 5 6 6 1)) ;; =&amp;gt; ((2 1 1 1) (4 1 3 5) (6 6 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-partition-after-pred &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Partition &lt;code&gt;list&lt;/code&gt; after each element for which &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--partition-after-pred&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-partition-after-pred #&#39;booleanp ()) ;; =&amp;gt; ()&#xA;(-partition-after-pred #&#39;booleanp &#39;(t t)) ;; =&amp;gt; ((t) (t))&#xA;(-partition-after-pred #&#39;booleanp &#39;(0 0 t t 0 t)) ;; =&amp;gt; ((0 0 t) (t) (0 t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-partition-before-pred &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Partition directly before each time &lt;code&gt;pred&lt;/code&gt; is true on an element of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-partition-before-pred #&#39;booleanp ()) ;; =&amp;gt; ()&#xA;(-partition-before-pred #&#39;booleanp &#39;(0 t)) ;; =&amp;gt; ((0) (t))&#xA;(-partition-before-pred #&#39;booleanp &#39;(0 0 t 0 t t)) ;; =&amp;gt; ((0 0) (t 0) (t) (t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-partition-before-item &lt;code&gt;(item list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Partition directly before each time &lt;code&gt;item&lt;/code&gt; appears in &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-partition-before-item 3 ()) ;; =&amp;gt; ()&#xA;(-partition-before-item 3 &#39;(1)) ;; =&amp;gt; ((1))&#xA;(-partition-before-item 3 &#39;(3)) ;; =&amp;gt; ((3))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-partition-after-item &lt;code&gt;(item list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Partition directly after each time &lt;code&gt;item&lt;/code&gt; appears in &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-partition-after-item 3 ()) ;; =&amp;gt; ()&#xA;(-partition-after-item 3 &#39;(1)) ;; =&amp;gt; ((1))&#xA;(-partition-after-item 3 &#39;(3)) ;; =&amp;gt; ((3))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-group-by &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Separate &lt;code&gt;list&lt;/code&gt; into an alist whose keys are &lt;code&gt;fn&lt;/code&gt; applied to the elements of &lt;code&gt;list&lt;/code&gt;. Keys are compared by &lt;code&gt;equal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-group-by &#39;even? ()) ;; =&amp;gt; ()&#xA;(-group-by &#39;even? &#39;(1 1 2 2 2 3 4 6 8)) ;; =&amp;gt; ((nil 1 1 3) (t 2 2 2 4 6 8))&#xA;(--group-by (car (split-string it &#34;/&#34;)) &#39;(&#34;a/b&#34; &#34;c/d&#34; &#34;a/e&#34;)) ;; =&amp;gt; ((&#34;a&#34; &#34;a/b&#34; &#34;a/e&#34;) (&#34;c&#34; &#34;c/d&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Indexing&lt;/h2&gt; &#xA;&lt;p&gt;Functions retrieving or sorting based on list indices and related predicates.&lt;/p&gt; &#xA;&lt;h4&gt;-elem-index &lt;code&gt;(elem list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the first index of &lt;code&gt;elem&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;. That is, the index within &lt;code&gt;list&lt;/code&gt; of the first element that is &lt;code&gt;equal&lt;/code&gt; to &lt;code&gt;elem&lt;/code&gt;. Return &lt;code&gt;nil&lt;/code&gt; if there is no such element.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-find-index-pred-list&#34;&gt;&lt;code&gt;-find-index&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-elem-index 2 &#39;(6 7 8 3 4)) ;; =&amp;gt; nil&#xA;(-elem-index &#34;bar&#34; &#39;(&#34;foo&#34; &#34;bar&#34; &#34;baz&#34;)) ;; =&amp;gt; 1&#xA;(-elem-index &#39;(1 2) &#39;((3) (5 6) (1 2) nil)) ;; =&amp;gt; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-elem-indices &lt;code&gt;(elem list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the list of indices at which &lt;code&gt;elem&lt;/code&gt; appears in &lt;code&gt;list&lt;/code&gt;. That is, the indices of all elements of &lt;code&gt;list&lt;/code&gt; &lt;code&gt;equal&lt;/code&gt; to &lt;code&gt;elem&lt;/code&gt;, in the same ascending order as they appear in &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-elem-indices 2 &#39;(6 7 8 3 4 1)) ;; =&amp;gt; ()&#xA;(-elem-indices &#34;bar&#34; &#39;(&#34;foo&#34; &#34;bar&#34; &#34;baz&#34;)) ;; =&amp;gt; (1)&#xA;(-elem-indices &#39;(1 2) &#39;((3) (1 2) (5 6) (1 2) nil)) ;; =&amp;gt; (1 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-find-index &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the index of the first item satisfying &lt;code&gt;pred&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;. Return &lt;code&gt;nil&lt;/code&gt; if no such item is found.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;pred&lt;/code&gt; is called with one argument, the current list element, until it returns non-&lt;code&gt;nil&lt;/code&gt;, at which point the search terminates.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--find-index&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-first-pred-list&#34;&gt;&lt;code&gt;-first&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-find-last-index-pred-list&#34;&gt;&lt;code&gt;-find-last-index&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-find-index #&#39;numberp &#39;(a b c)) ;; =&amp;gt; nil&#xA;(-find-index #&#39;natnump &#39;(1 0 -1)) ;; =&amp;gt; 0&#xA;(--find-index (&amp;gt; it 5) &#39;(2 4 1 6 3 3 5 8)) ;; =&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-find-last-index &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the index of the last item satisfying &lt;code&gt;pred&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;. Return &lt;code&gt;nil&lt;/code&gt; if no such item is found.&lt;/p&gt; &#xA;&lt;p&gt;Predicate &lt;code&gt;pred&lt;/code&gt; is called with one argument each time, namely the current list element.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--find-last-index&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-last-pred-list&#34;&gt;&lt;code&gt;-last&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-find-index-pred-list&#34;&gt;&lt;code&gt;-find-index&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-find-last-index #&#39;numberp &#39;(a b c)) ;; =&amp;gt; nil&#xA;(--find-last-index (&amp;gt; it 5) &#39;(2 7 1 6 3 8 5 2)) ;; =&amp;gt; 5&#xA;(-find-last-index (-partial #&#39;string&amp;lt; &#39;a) &#39;(c b a)) ;; =&amp;gt; 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-find-indices &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the list of indices in &lt;code&gt;list&lt;/code&gt; satisfying &lt;code&gt;pred&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Each element of &lt;code&gt;list&lt;/code&gt; in turn is passed to &lt;code&gt;pred&lt;/code&gt;. If the result is non-&lt;code&gt;nil&lt;/code&gt;, the index of that element in &lt;code&gt;list&lt;/code&gt; is included in the result. The returned indices are in ascending order, i.e., in the same order as they appear in &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--find-indices&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-find-index-pred-list&#34;&gt;&lt;code&gt;-find-index&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-elem-indices-elem-list&#34;&gt;&lt;code&gt;-elem-indices&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-find-indices #&#39;numberp &#39;(a b c)) ;; =&amp;gt; ()&#xA;(-find-indices #&#39;numberp &#39;(8 1 d 2 b c a 3)) ;; =&amp;gt; (0 1 3 7)&#xA;(--find-indices (&amp;gt; it 5) &#39;(2 4 1 6 3 3 5 8)) ;; =&amp;gt; (3 7)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-grade-up &lt;code&gt;(comparator list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Grade elements of &lt;code&gt;list&lt;/code&gt; using &lt;code&gt;comparator&lt;/code&gt; relation. This yields a permutation vector such that applying this permutation to &lt;code&gt;list&lt;/code&gt; sorts it in ascending order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-grade-up #&#39;&amp;lt; &#39;(3 1 4 2 1 3 3)) ;; =&amp;gt; (1 4 3 0 5 6 2)&#xA;(let ((l &#39;(3 1 4 2 1 3 3))) (-select-by-indices (-grade-up #&#39;&amp;lt; l) l)) ;; =&amp;gt; (1 1 2 3 3 3 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-grade-down &lt;code&gt;(comparator list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Grade elements of &lt;code&gt;list&lt;/code&gt; using &lt;code&gt;comparator&lt;/code&gt; relation. This yields a permutation vector such that applying this permutation to &lt;code&gt;list&lt;/code&gt; sorts it in descending order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-grade-down #&#39;&amp;lt; &#39;(3 1 4 2 1 3 3)) ;; =&amp;gt; (2 0 5 6 3 1 4)&#xA;(let ((l &#39;(3 1 4 2 1 3 3))) (-select-by-indices (-grade-down #&#39;&amp;lt; l) l)) ;; =&amp;gt; (4 3 3 3 2 1 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Set operations&lt;/h2&gt; &#xA;&lt;p&gt;Operations pretending lists are sets.&lt;/p&gt; &#xA;&lt;h4&gt;-union &lt;code&gt;(list1 list2)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list of distinct elements appearing in either &lt;code&gt;list1&lt;/code&gt; or &lt;code&gt;list2&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The test for equality is done with &lt;code&gt;equal&lt;/code&gt;, or with &lt;code&gt;-compare-fn&lt;/code&gt; if that is non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-union &#39;(1 2 3) &#39;(3 4 5)) ;; =&amp;gt; (1 2 3 4 5)&#xA;(-union &#39;(1 2 2 4) ()) ;; =&amp;gt; (1 2 4)&#xA;(-union &#39;(1 1 2 2) &#39;(4 4 3 2 1)) ;; =&amp;gt; (1 2 4 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-difference &lt;code&gt;(list1 list2)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list with the distinct members of &lt;code&gt;list1&lt;/code&gt; that are not in &lt;code&gt;list2&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The test for equality is done with &lt;code&gt;equal&lt;/code&gt;, or with &lt;code&gt;-compare-fn&lt;/code&gt; if that is non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-difference () ()) ;; =&amp;gt; ()&#xA;(-difference &#39;(1 2 3) &#39;(4 5 6)) ;; =&amp;gt; (1 2 3)&#xA;(-difference &#39;(1 2 3 4) &#39;(3 4 5 6)) ;; =&amp;gt; (1 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-intersection &lt;code&gt;(list1 list2)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list of distinct elements appearing in both &lt;code&gt;list1&lt;/code&gt; and &lt;code&gt;list2&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The test for equality is done with &lt;code&gt;equal&lt;/code&gt;, or with &lt;code&gt;-compare-fn&lt;/code&gt; if that is non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-intersection () ()) ;; =&amp;gt; ()&#xA;(-intersection &#39;(1 2 3) &#39;(4 5 6)) ;; =&amp;gt; ()&#xA;(-intersection &#39;(1 2 2 3) &#39;(4 3 3 2)) ;; =&amp;gt; (2 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-powerset &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the power set of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-powerset ()) ;; =&amp;gt; (nil)&#xA;(-powerset &#39;(x y)) ;; =&amp;gt; ((x y) (x) (y) nil)&#xA;(-powerset &#39;(x y z)) ;; =&amp;gt; ((x y z) (x y) (x z) (x) (y z) (y) (z) nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-permutations &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the distinct permutations of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Duplicate elements of &lt;code&gt;list&lt;/code&gt; are determined by &lt;code&gt;equal&lt;/code&gt;, or by &lt;code&gt;-compare-fn&lt;/code&gt; if that is non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-permutations ()) ;; =&amp;gt; (nil)&#xA;(-permutations &#39;(a a b)) ;; =&amp;gt; ((a a b) (a b a) (b a a))&#xA;(-permutations &#39;(a b c)) ;; =&amp;gt; ((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-distinct &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a copy of &lt;code&gt;list&lt;/code&gt; with all duplicate elements removed.&lt;/p&gt; &#xA;&lt;p&gt;The test for equality is done with &lt;code&gt;equal&lt;/code&gt;, or with &lt;code&gt;-compare-fn&lt;/code&gt; if that is non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-uniq&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-distinct ()) ;; =&amp;gt; ()&#xA;(-distinct &#39;(1 1 2 3 3)) ;; =&amp;gt; (1 2 3)&#xA;(-distinct &#39;(t t t)) ;; =&amp;gt; (t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-same-items? &lt;code&gt;(list1 list2)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return non-&lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;list1&lt;/code&gt; and &lt;code&gt;list2&lt;/code&gt; have the same distinct elements.&lt;/p&gt; &#xA;&lt;p&gt;The order of the elements in the lists does not matter. The lists may be of different lengths, i.e., contain duplicate elements. The test for equality is done with &lt;code&gt;equal&lt;/code&gt;, or with &lt;code&gt;-compare-fn&lt;/code&gt; if that is non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-same-items-p&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-same-items? &#39;(1 2 3) &#39;(1 2 3)) ;; =&amp;gt; t&#xA;(-same-items? &#39;(1 1 2 3) &#39;(3 3 2 1)) ;; =&amp;gt; t&#xA;(-same-items? &#39;(1 2 3) &#39;(1 2 3 4)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Other list operations&lt;/h2&gt; &#xA;&lt;p&gt;Other list functions not fit to be classified elsewhere.&lt;/p&gt; &#xA;&lt;h4&gt;-rotate &lt;code&gt;(n list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Rotate &lt;code&gt;list&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; places to the right (left if &lt;code&gt;n&lt;/code&gt; is negative). The time complexity is O(n).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-rotate 3 &#39;(1 2 3 4 5 6 7)) ;; =&amp;gt; (5 6 7 1 2 3 4)&#xA;(-rotate -3 &#39;(1 2 3 4 5 6 7)) ;; =&amp;gt; (4 5 6 7 1 2 3)&#xA;(-rotate 16 &#39;(1 2 3 4 5 6 7)) ;; =&amp;gt; (6 7 1 2 3 4 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-cons* &lt;code&gt;(&amp;amp;rest args)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Make a new list from the elements of &lt;code&gt;args&lt;/code&gt;. The last 2 elements of &lt;code&gt;args&lt;/code&gt; are used as the final cons of the result, so if the final element of &lt;code&gt;args&lt;/code&gt; is not a list, the result is a dotted list. With no &lt;code&gt;args&lt;/code&gt;, return &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-cons* 1 2) ;; =&amp;gt; (1 . 2)&#xA;(-cons* 1 2 3) ;; =&amp;gt; (1 2 . 3)&#xA;(-cons* 1) ;; =&amp;gt; 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-snoc &lt;code&gt;(list elem &amp;amp;rest elements)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Append &lt;code&gt;elem&lt;/code&gt; to the end of the list.&lt;/p&gt; &#xA;&lt;p&gt;This is like &lt;code&gt;cons&lt;/code&gt;, but operates on the end of list.&lt;/p&gt; &#xA;&lt;p&gt;If any &lt;code&gt;elements&lt;/code&gt; are given, append them to the list as well.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-snoc &#39;(1 2 3) 4) ;; =&amp;gt; (1 2 3 4)&#xA;(-snoc &#39;(1 2 3) 4 5 6) ;; =&amp;gt; (1 2 3 4 5 6)&#xA;(-snoc &#39;(1 2 3) &#39;(4 5 6)) ;; =&amp;gt; (1 2 3 (4 5 6))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-interpose &lt;code&gt;(sep list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list of all elements in &lt;code&gt;list&lt;/code&gt; separated by &lt;code&gt;sep&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-interpose &#34;-&#34; ()) ;; =&amp;gt; ()&#xA;(-interpose &#34;-&#34; &#39;(&#34;a&#34;)) ;; =&amp;gt; (&#34;a&#34;)&#xA;(-interpose &#34;-&#34; &#39;(&#34;a&#34; &#34;b&#34; &#34;c&#34;)) ;; =&amp;gt; (&#34;a&#34; &#34;-&#34; &#34;b&#34; &#34;-&#34; &#34;c&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-interleave &lt;code&gt;(&amp;amp;rest lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a new list of the first item in each list, then the second etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-interleave &#39;(1 2) &#39;(&#34;a&#34; &#34;b&#34;)) ;; =&amp;gt; (1 &#34;a&#34; 2 &#34;b&#34;)&#xA;(-interleave &#39;(1 2) &#39;(&#34;a&#34; &#34;b&#34;) &#39;(&#34;A&#34; &#34;B&#34;)) ;; =&amp;gt; (1 &#34;a&#34; &#34;A&#34; 2 &#34;b&#34; &#34;B&#34;)&#xA;(-interleave &#39;(1 2 3) &#39;(&#34;a&#34; &#34;b&#34;)) ;; =&amp;gt; (1 &#34;a&#34; 2 &#34;b&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-iota &lt;code&gt;(count &amp;amp;optional start step)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list containing &lt;code&gt;count&lt;/code&gt; numbers. Starts from &lt;code&gt;start&lt;/code&gt; and adds &lt;code&gt;step&lt;/code&gt; each time. The default &lt;code&gt;start&lt;/code&gt; is zero, the default &lt;code&gt;step&lt;/code&gt; is 1. This function takes its name from the corresponding primitive in the &lt;code&gt;apl&lt;/code&gt; language.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-iota 6) ;; =&amp;gt; (0 1 2 3 4 5)&#xA;(-iota 4 2.5 -2) ;; =&amp;gt; (2.5 0.5 -1.5 -3.5)&#xA;(-iota -1) ;; Wrong type argument: natnump, -1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-zip-with &lt;code&gt;(fn list1 list2)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Zip &lt;code&gt;list1&lt;/code&gt; and &lt;code&gt;list2&lt;/code&gt; into a new list using the function &lt;code&gt;fn&lt;/code&gt;. That is, apply &lt;code&gt;fn&lt;/code&gt; pairwise taking as first argument the next element of &lt;code&gt;list1&lt;/code&gt; and as second argument the next element of &lt;code&gt;list2&lt;/code&gt; at the corresponding position. The result is as long as the shorter list.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--zip-with&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For other zips, see also &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-lists-rest-lists&#34;&gt;&lt;code&gt;-zip-lists&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-fill-fill-value-rest-lists&#34;&gt;&lt;code&gt;-zip-fill&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-zip-with #&#39;+ &#39;(1 2 3 4) &#39;(5 6 7)) ;; =&amp;gt; (6 8 10)&#xA;(-zip-with #&#39;cons &#39;(1 2 3) &#39;(4 5 6 7)) ;; =&amp;gt; ((1 . 4) (2 . 5) (3 . 6))&#xA;(--zip-with (format &#34;%s &amp;amp; %s&#34; it other) &#39;(Batman Jekyll) &#39;(Robin Hyde)) ;; =&amp;gt; (&#34;Batman &amp;amp; Robin&#34; &#34;Jekyll &amp;amp; Hyde&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-zip-pair &lt;code&gt;(list1 list2)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Zip &lt;code&gt;list1&lt;/code&gt; and &lt;code&gt;list2&lt;/code&gt; together.&lt;/p&gt; &#xA;&lt;p&gt;Make a pair with the head of each list, followed by a pair with the second element of each list, and so on. The number of pairs returned is equal to the length of the shorter input list.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-lists-rest-lists&#34;&gt;&lt;code&gt;-zip-lists&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-zip-pair &#39;(1 2 3 4) &#39;(5 6 7)) ;; =&amp;gt; ((1 . 5) (2 . 6) (3 . 7))&#xA;(-zip-pair &#39;(1 2 3) &#39;(4 5 6)) ;; =&amp;gt; ((1 . 4) (2 . 5) (3 . 6))&#xA;(-zip-pair &#39;(1 2) &#39;(3)) ;; =&amp;gt; ((1 . 3))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-zip-lists &lt;code&gt;(&amp;amp;rest lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Zip &lt;code&gt;lists&lt;/code&gt; together.&lt;/p&gt; &#xA;&lt;p&gt;Group the head of each list, followed by the second element of each list, and so on. The number of returned groupings is equal to the length of the shortest input list, and the length of each grouping is equal to the number of input &lt;code&gt;lists&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The return value is always a list of proper lists, in contrast to &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-rest-lists&#34;&gt;&lt;code&gt;-zip&lt;/code&gt;&lt;/a&gt; which returns a list of dotted pairs when only two input &lt;code&gt;lists&lt;/code&gt; are provided.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-pair-list1-list2&#34;&gt;&lt;code&gt;-zip-pair&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-zip-lists &#39;(1 2 3) &#39;(4 5 6)) ;; =&amp;gt; ((1 4) (2 5) (3 6))&#xA;(-zip-lists &#39;(1 2 3) &#39;(4 5 6 7)) ;; =&amp;gt; ((1 4) (2 5) (3 6))&#xA;(-zip-lists &#39;(1 2) &#39;(3 4 5) &#39;(6)) ;; =&amp;gt; ((1 3 6))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-zip-lists-fill &lt;code&gt;(fill-value &amp;amp;rest lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Zip &lt;code&gt;lists&lt;/code&gt; together, padding shorter lists with &lt;code&gt;fill-value&lt;/code&gt;. This is like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-lists-rest-lists&#34;&gt;&lt;code&gt;-zip-lists&lt;/code&gt;&lt;/a&gt; (which see), except it retains all elements at positions beyond the end of the shortest list. The number of returned groupings is equal to the length of the longest input list, and the length of each grouping is equal to the number of input &lt;code&gt;lists&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-zip-lists-fill 0 &#39;(1 2) &#39;(3 4 5) &#39;(6)) ;; =&amp;gt; ((1 3 6) (2 4 0) (0 5 0))&#xA;(-zip-lists-fill 0 &#39;(1 2) &#39;(3 4) &#39;(5 6)) ;; =&amp;gt; ((1 3 5) (2 4 6))&#xA;(-zip-lists-fill 0 &#39;(1 2 3) nil) ;; =&amp;gt; ((1 0) (2 0) (3 0))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-zip &lt;code&gt;(&amp;amp;rest lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Zip &lt;code&gt;lists&lt;/code&gt; together.&lt;/p&gt; &#xA;&lt;p&gt;Group the head of each list, followed by the second element of each list, and so on. The number of returned groupings is equal to the length of the shortest input list, and the number of items in each grouping is equal to the number of input &lt;code&gt;lists&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If only two &lt;code&gt;lists&lt;/code&gt; are provided as arguments, return the groupings as a list of dotted pairs. Otherwise, return the groupings as a list of proper lists.&lt;/p&gt; &#xA;&lt;p&gt;Since the return value changes form depending on the number of arguments, it is generally recommended to use &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-lists-rest-lists&#34;&gt;&lt;code&gt;-zip-lists&lt;/code&gt;&lt;/a&gt; instead, or &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-pair-list1-list2&#34;&gt;&lt;code&gt;-zip-pair&lt;/code&gt;&lt;/a&gt; if a list of dotted pairs is desired.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-unzip-lists&#34;&gt;&lt;code&gt;-unzip&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-zip &#39;(1 2 3 4) &#39;(5 6 7) &#39;(8 9)) ;; =&amp;gt; ((1 5 8) (2 6 9))&#xA;(-zip &#39;(1 2 3) &#39;(4 5 6) &#39;(7 8 9)) ;; =&amp;gt; ((1 4 7) (2 5 8) (3 6 9))&#xA;(-zip &#39;(1 2 3)) ;; =&amp;gt; ((1) (2) (3))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-zip-fill &lt;code&gt;(fill-value &amp;amp;rest lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Zip &lt;code&gt;lists&lt;/code&gt; together, padding shorter lists with &lt;code&gt;fill-value&lt;/code&gt;. This is like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-rest-lists&#34;&gt;&lt;code&gt;-zip&lt;/code&gt;&lt;/a&gt; (which see), except it retains all elements at positions beyond the end of the shortest list. The number of returned groupings is equal to the length of the longest input list, and the length of each grouping is equal to the number of input &lt;code&gt;lists&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Since the return value changes form depending on the number of arguments, it is generally recommended to use &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-lists-fill-fill-value-rest-lists&#34;&gt;&lt;code&gt;-zip-lists-fill&lt;/code&gt;&lt;/a&gt; instead, unless a list of dotted pairs is explicitly desired.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-zip-fill 0 &#39;(1 2 3) &#39;(4 5)) ;; =&amp;gt; ((1 . 4) (2 . 5) (3 . 0))&#xA;(-zip-fill 0 () &#39;(1 2 3)) ;; =&amp;gt; ((0 . 1) (0 . 2) (0 . 3))&#xA;(-zip-fill 0 &#39;(1 2) &#39;(3 4) &#39;(5 6)) ;; =&amp;gt; ((1 3 5) (2 4 6))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-unzip-lists &lt;code&gt;(lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Unzip &lt;code&gt;lists&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This works just like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-lists-rest-lists&#34;&gt;&lt;code&gt;-zip-lists&lt;/code&gt;&lt;/a&gt; (which see), but takes a list of lists instead of a variable number of arguments, such that&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(-unzip-lists (-zip-lists `args`...))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is identity (given that the lists comprising &lt;code&gt;args&lt;/code&gt; are of the same length).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-unzip-lists (-zip-lists &#39;(1 2) &#39;(3 4) &#39;(5 6))) ;; =&amp;gt; ((1 2) (3 4) (5 6))&#xA;(-unzip-lists &#39;((1 2 3) (4 5) (6 7) (8 9))) ;; =&amp;gt; ((1 4 6 8) (2 5 7 9))&#xA;(-unzip-lists &#39;((1 2 3) (4 5 6))) ;; =&amp;gt; ((1 4) (2 5) (3 6))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-unzip &lt;code&gt;(lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Unzip &lt;code&gt;lists&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This works just like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-rest-lists&#34;&gt;&lt;code&gt;-zip&lt;/code&gt;&lt;/a&gt; (which see), but takes a list of lists instead of a variable number of arguments, such that&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(-unzip (-zip `l1` `l2` `l3` ...))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is identity (given that the lists are of the same length, and that &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-zip-rest-lists&#34;&gt;&lt;code&gt;-zip&lt;/code&gt;&lt;/a&gt; is not called with two arguments, because of the caveat described in its docstring).&lt;/p&gt; &#xA;&lt;p&gt;Note in particular that calling &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-unzip-lists&#34;&gt;&lt;code&gt;-unzip&lt;/code&gt;&lt;/a&gt; on a list of two lists will return a list of dotted pairs.&lt;/p&gt; &#xA;&lt;p&gt;Since the return value changes form depending on the number of &lt;code&gt;lists&lt;/code&gt;, it is generally recommended to use &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-unzip-lists-lists&#34;&gt;&lt;code&gt;-unzip-lists&lt;/code&gt;&lt;/a&gt; instead.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-unzip (-zip &#39;(1 2) &#39;(3 4) &#39;(5 6))) ;; =&amp;gt; ((1 . 2) (3 . 4) (5 . 6))&#xA;(-unzip &#39;((1 2 3) (4 5 6))) ;; =&amp;gt; ((1 . 4) (2 . 5) (3 . 6))&#xA;(-unzip &#39;((1 2 3) (4 5) (6 7) (8 9))) ;; =&amp;gt; ((1 4 6 8) (2 5 7 9))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-pad &lt;code&gt;(fill-value &amp;amp;rest lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Pad each of &lt;code&gt;lists&lt;/code&gt; with &lt;code&gt;fill-value&lt;/code&gt; until they all have equal lengths.&lt;/p&gt; &#xA;&lt;p&gt;Ensure all &lt;code&gt;lists&lt;/code&gt; are as long as the longest one by repeatedly appending &lt;code&gt;fill-value&lt;/code&gt; to the shorter lists, and return the resulting &lt;code&gt;lists&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-pad 0 ()) ;; =&amp;gt; (nil)&#xA;(-pad 0 &#39;(1 2) &#39;(3 4)) ;; =&amp;gt; ((1 2) (3 4))&#xA;(-pad 0 &#39;(1 2) &#39;(3 4 5 6) &#39;(7 8 9)) ;; =&amp;gt; ((1 2 0 0) (3 4 5 6) (7 8 9 0))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-table &lt;code&gt;(fn &amp;amp;rest lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Compute outer product of &lt;code&gt;lists&lt;/code&gt; using function &lt;code&gt;fn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The function &lt;code&gt;fn&lt;/code&gt; should have the same arity as the number of supplied lists.&lt;/p&gt; &#xA;&lt;p&gt;The outer product is computed by applying fn to all possible combinations created by taking one element from each list in order. The dimension of the result is (length lists).&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-table-flat-fn-rest-lists&#34;&gt;&lt;code&gt;-table-flat&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-table &#39;* &#39;(1 2 3) &#39;(1 2 3)) ;; =&amp;gt; ((1 2 3) (2 4 6) (3 6 9))&#xA;(-table (lambda (a b) (-sum (-zip-with &#39;* a b))) &#39;((1 2) (3 4)) &#39;((1 3) (2 4))) ;; =&amp;gt; ((7 15) (10 22))&#xA;(apply &#39;-table &#39;list (-repeat 3 &#39;(1 2))) ;; =&amp;gt; ((((1 1 1) (2 1 1)) ((1 2 1) (2 2 1))) (((1 1 2) (2 1 2)) ((1 2 2) (2 2 2))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-table-flat &lt;code&gt;(fn &amp;amp;rest lists)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Compute flat outer product of &lt;code&gt;lists&lt;/code&gt; using function &lt;code&gt;fn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The function &lt;code&gt;fn&lt;/code&gt; should have the same arity as the number of supplied lists.&lt;/p&gt; &#xA;&lt;p&gt;The outer product is computed by applying fn to all possible combinations created by taking one element from each list in order. The results are flattened, ignoring the tensor structure of the result. This is equivalent to calling:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(-flatten-n (1- (length lists)) (apply &#39;-table fn lists))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but the implementation here is much more efficient.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-flatten-n-num-list&#34;&gt;&lt;code&gt;-flatten-n&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-table-fn-rest-lists&#34;&gt;&lt;code&gt;-table&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-table-flat &#39;list &#39;(1 2 3) &#39;(a b c)) ;; =&amp;gt; ((1 a) (2 a) (3 a) (1 b) (2 b) (3 b) (1 c) (2 c) (3 c))&#xA;(-table-flat &#39;* &#39;(1 2 3) &#39;(1 2 3)) ;; =&amp;gt; (1 2 3 2 4 6 3 6 9)&#xA;(apply &#39;-table-flat &#39;list (-repeat 3 &#39;(1 2))) ;; =&amp;gt; ((1 1 1) (2 1 1) (1 2 1) (2 2 1) (1 1 2) (2 1 2) (1 2 2) (2 2 2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-first &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the first item in &lt;code&gt;list&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;. Return &lt;code&gt;nil&lt;/code&gt; if no such element is found.&lt;/p&gt; &#xA;&lt;p&gt;To get the first item in the list no questions asked, use &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-first-item-list&#34;&gt;&lt;code&gt;-first-item&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;-find&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--first&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-first #&#39;natnump &#39;(-1 0 1)) ;; =&amp;gt; 0&#xA;(-first #&#39;null &#39;(1 2 3)) ;; =&amp;gt; nil&#xA;(--first (&amp;gt; it 2) &#39;(1 2 3)) ;; =&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-last &lt;code&gt;(pred list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the last x in &lt;code&gt;list&lt;/code&gt; where (&lt;code&gt;pred&lt;/code&gt; x) is non-&lt;code&gt;nil&lt;/code&gt;, else &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-last &#39;even? &#39;(1 2 3 4 5 6 3 3 3)) ;; =&amp;gt; 6&#xA;(-last &#39;even? &#39;(1 3 7 5 9)) ;; =&amp;gt; nil&#xA;(--last (&amp;gt; (length it) 3) &#39;(&#34;a&#34; &#34;looong&#34; &#34;word&#34; &#34;and&#34; &#34;short&#34; &#34;one&#34;)) ;; =&amp;gt; &#34;short&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-first-item &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the first item of &lt;code&gt;list&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; on an empty list.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-second-item-list&#34;&gt;&lt;code&gt;-second-item&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-last-item-list&#34;&gt;&lt;code&gt;-last-item&lt;/code&gt;&lt;/a&gt;, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-first-item ()) ;; =&amp;gt; ()&#xA;(-first-item &#39;(1 2 3 4 5)) ;; =&amp;gt; 1&#xA;(let ((list (list 1 2 3))) (setf (-first-item list) 5) list) ;; =&amp;gt; (5 2 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-second-item &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the second item of &lt;code&gt;list&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; is too short.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-first-item-list&#34;&gt;&lt;code&gt;-first-item&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-third-item-list&#34;&gt;&lt;code&gt;-third-item&lt;/code&gt;&lt;/a&gt;, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-second-item ()) ;; =&amp;gt; ()&#xA;(-second-item &#39;(1 2 3 4 5)) ;; =&amp;gt; 2&#xA;(let ((list (list 1 2))) (setf (-second-item list) 5) list) ;; =&amp;gt; (1 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-third-item &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the third item of &lt;code&gt;list&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; is too short.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-second-item-list&#34;&gt;&lt;code&gt;-second-item&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-fourth-item-list&#34;&gt;&lt;code&gt;-fourth-item&lt;/code&gt;&lt;/a&gt;, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-third-item ()) ;; =&amp;gt; ()&#xA;(-third-item &#39;(1 2)) ;; =&amp;gt; ()&#xA;(-third-item &#39;(1 2 3 4 5)) ;; =&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-fourth-item &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the fourth item of &lt;code&gt;list&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; is too short.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-third-item-list&#34;&gt;&lt;code&gt;-third-item&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-fifth-item-list&#34;&gt;&lt;code&gt;-fifth-item&lt;/code&gt;&lt;/a&gt;, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-fourth-item ()) ;; =&amp;gt; ()&#xA;(-fourth-item &#39;(1 2 3)) ;; =&amp;gt; ()&#xA;(-fourth-item &#39;(1 2 3 4 5)) ;; =&amp;gt; 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-fifth-item &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the fifth item of &lt;code&gt;list&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; is too short.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-fourth-item-list&#34;&gt;&lt;code&gt;-fourth-item&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-last-item-list&#34;&gt;&lt;code&gt;-last-item&lt;/code&gt;&lt;/a&gt;, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-fifth-item ()) ;; =&amp;gt; ()&#xA;(-fifth-item &#39;(1 2 3 4)) ;; =&amp;gt; ()&#xA;(-fifth-item &#39;(1 2 3 4 5)) ;; =&amp;gt; 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-last-item &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the last item of &lt;code&gt;list&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; on an empty list.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-first-item-list&#34;&gt;&lt;code&gt;-first-item&lt;/code&gt;&lt;/a&gt;, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-last-item ()) ;; =&amp;gt; ()&#xA;(-last-item &#39;(1 2 3 4 5)) ;; =&amp;gt; 5&#xA;(let ((list (list 1 2 3))) (setf (-last-item list) 5) list) ;; =&amp;gt; (1 2 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-butlast &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a list of all items in list except for the last.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-butlast &#39;(1 2 3)) ;; =&amp;gt; (1 2)&#xA;(-butlast &#39;(1 2)) ;; =&amp;gt; (1)&#xA;(-butlast &#39;(1)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-sort &lt;code&gt;(comparator list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Sort &lt;code&gt;list&lt;/code&gt;, stably, comparing elements using &lt;code&gt;comparator&lt;/code&gt;. Return the sorted list. &lt;code&gt;list&lt;/code&gt; is &lt;code&gt;not&lt;/code&gt; modified by side effects. &lt;code&gt;comparator&lt;/code&gt; is called with two elements of &lt;code&gt;list&lt;/code&gt;, and should return non-&lt;code&gt;nil&lt;/code&gt; if the first element should sort before the second.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-sort #&#39;&amp;lt; &#39;(3 1 2)) ;; =&amp;gt; (1 2 3)&#xA;(-sort #&#39;&amp;gt; &#39;(3 1 2)) ;; =&amp;gt; (3 2 1)&#xA;(--sort (&amp;lt; it other) &#39;(3 1 2)) ;; =&amp;gt; (1 2 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-list &lt;code&gt;(arg)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Ensure &lt;code&gt;arg&lt;/code&gt; is a list. If &lt;code&gt;arg&lt;/code&gt; is already a list, return it as is (not a copy). Otherwise, return a new list with &lt;code&gt;arg&lt;/code&gt; as its only element.&lt;/p&gt; &#xA;&lt;p&gt;Another supported calling convention is (-list &amp;amp;rest &lt;code&gt;args&lt;/code&gt;). In this case, if &lt;code&gt;arg&lt;/code&gt; is not a list, a new list with all of &lt;code&gt;args&lt;/code&gt; as elements is returned. This use is supported for backward compatibility and is otherwise deprecated.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-list 1) ;; =&amp;gt; (1)&#xA;(-list ()) ;; =&amp;gt; ()&#xA;(-list &#39;(1 2 3)) ;; =&amp;gt; (1 2 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-fix &lt;code&gt;(fn list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Compute the (least) fixpoint of &lt;code&gt;fn&lt;/code&gt; with initial input &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;fn&lt;/code&gt; is called at least once, results are compared with &lt;code&gt;equal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-fix (lambda (l) (-non-nil (--mapcat (-split-at (/ (length it) 2) it) l))) &#39;((1 2 3))) ;; =&amp;gt; ((1) (2) (3))&#xA;(let ((l &#39;((starwars scifi) (jedi starwars warrior)))) (--fix (-uniq (--mapcat (cons it (cdr (assq it l))) it)) &#39;(jedi book))) ;; =&amp;gt; (jedi starwars warrior scifi book)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tree operations&lt;/h2&gt; &#xA;&lt;p&gt;Functions pretending lists are trees.&lt;/p&gt; &#xA;&lt;h4&gt;-tree-seq &lt;code&gt;(branch children tree)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a sequence of the nodes in &lt;code&gt;tree&lt;/code&gt;, in depth-first search order.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;branch&lt;/code&gt; is a predicate of one argument that returns non-&lt;code&gt;nil&lt;/code&gt; if the passed argument is a branch, that is, a node that can have children.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;children&lt;/code&gt; is a function of one argument that returns the children of the passed branch node.&lt;/p&gt; &#xA;&lt;p&gt;Non-branch nodes are simply copied.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-tree-seq &#39;listp &#39;identity &#39;(1 (2 3) 4 (5 (6 7)))) ;; =&amp;gt; ((1 (2 3) 4 (5 (6 7))) 1 (2 3) 2 3 4 (5 (6 7)) 5 (6 7) 6 7)&#xA;(-tree-seq &#39;listp &#39;reverse &#39;(1 (2 3) 4 (5 (6 7)))) ;; =&amp;gt; ((1 (2 3) 4 (5 (6 7))) (5 (6 7)) (6 7) 7 6 5 4 (2 3) 3 2 1)&#xA;(--tree-seq (vectorp it) (append it nil) [1 [2 3] 4 [5 [6 7]]]) ;; =&amp;gt; ([1 [2 3] 4 [5 [6 7]]] 1 [2 3] 2 3 4 [5 [6 7]] 5 [6 7] 6 7)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-tree-map &lt;code&gt;(fn tree)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Apply &lt;code&gt;fn&lt;/code&gt; to each element of &lt;code&gt;tree&lt;/code&gt; while preserving the tree structure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-tree-map &#39;1+ &#39;(1 (2 3) (4 (5 6) 7))) ;; =&amp;gt; (2 (3 4) (5 (6 7) 8))&#xA;(-tree-map &#39;(lambda (x) (cons x (expt 2 x))) &#39;(1 (2 3) 4)) ;; =&amp;gt; ((1 . 2) ((2 . 4) (3 . 8)) (4 . 16))&#xA;(--tree-map (length it) &#39;(&#34;&amp;lt;body&amp;gt;&#34; (&#34;&amp;lt;p&amp;gt;&#34; &#34;text&#34; &#34;&amp;lt;/p&amp;gt;&#34;) &#34;&amp;lt;/body&amp;gt;&#34;)) ;; =&amp;gt; (6 (3 4 4) 7)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-tree-map-nodes &lt;code&gt;(pred fun tree)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Call &lt;code&gt;fun&lt;/code&gt; on each node of &lt;code&gt;tree&lt;/code&gt; that satisfies &lt;code&gt;pred&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, continue descending down this node. If &lt;code&gt;pred&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;, apply &lt;code&gt;fun&lt;/code&gt; to this node and do not descend further.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-tree-map-nodes &#39;vectorp (lambda (x) (-sum (append x nil))) &#39;(1 [2 3] 4 (5 [6 7] 8))) ;; =&amp;gt; (1 5 4 (5 13 8))&#xA;(-tree-map-nodes &#39;keywordp (lambda (x) (symbol-name x)) &#39;(1 :foo 4 ((5 6 :bar) :baz 8))) ;; =&amp;gt; (1 &#34;:foo&#34; 4 ((5 6 &#34;:bar&#34;) &#34;:baz&#34; 8))&#xA;(--tree-map-nodes (eq (car-safe it) &#39;add-mode) (-concat it (list :mode &#39;emacs-lisp-mode)) &#39;(with-mode emacs-lisp-mode (foo bar) (add-mode a b) (baz (add-mode c d)))) ;; =&amp;gt; (with-mode emacs-lisp-mode (foo bar) (add-mode a b :mode emacs-lisp-mode) (baz (add-mode c d :mode emacs-lisp-mode)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-tree-reduce &lt;code&gt;(fn tree)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Use &lt;code&gt;fn&lt;/code&gt; to reduce elements of list &lt;code&gt;tree&lt;/code&gt;. If elements of &lt;code&gt;tree&lt;/code&gt; are lists themselves, apply the reduction recursively.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;fn&lt;/code&gt; is first applied to first element of the list and second element, then on this result and third element from the list etc.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-fn-list&#34;&gt;&lt;code&gt;-reduce-r&lt;/code&gt;&lt;/a&gt; for how exactly are lists of zero or one element handled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-tree-reduce &#39;+ &#39;(1 (2 3) (4 5))) ;; =&amp;gt; 15&#xA;(-tree-reduce &#39;concat &#39;(&#34;strings&#34; (&#34; on&#34; &#34; various&#34;) ((&#34; levels&#34;)))) ;; =&amp;gt; &#34;strings on various levels&#34;&#xA;(--tree-reduce (cond ((stringp it) (concat it &#34; &#34; acc)) (t (let ((sn (symbol-name it))) (concat &#34;&amp;lt;&#34; sn &#34;&amp;gt;&#34; acc &#34;&amp;lt;/&#34; sn &#34;&amp;gt;&#34;)))) &#39;(body (p &#34;some words&#34;) (div &#34;more&#34; (b &#34;bold&#34;) &#34;words&#34;))) ;; =&amp;gt; &#34;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;some words&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;more &amp;lt;b&amp;gt;bold&amp;lt;/b&amp;gt; words&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-tree-reduce-from &lt;code&gt;(fn init-value tree)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Use &lt;code&gt;fn&lt;/code&gt; to reduce elements of list &lt;code&gt;tree&lt;/code&gt;. If elements of &lt;code&gt;tree&lt;/code&gt; are lists themselves, apply the reduction recursively.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;fn&lt;/code&gt; is first applied to &lt;code&gt;init-value&lt;/code&gt; and first element of the list, then on this result and second element from the list etc.&lt;/p&gt; &#xA;&lt;p&gt;The initial value is ignored on cons pairs as they always contain two elements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-tree-reduce-from &#39;+ 1 &#39;(1 (1 1) ((1)))) ;; =&amp;gt; 8&#xA;(--tree-reduce-from (-concat acc (list it)) nil &#39;(1 (2 3 (4 5)) (6 7))) ;; =&amp;gt; ((7 6) ((5 4) 3 2) 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-tree-mapreduce &lt;code&gt;(fn folder tree)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Apply &lt;code&gt;fn&lt;/code&gt; to each element of &lt;code&gt;tree&lt;/code&gt;, and make a list of the results. If elements of &lt;code&gt;tree&lt;/code&gt; are lists themselves, apply &lt;code&gt;fn&lt;/code&gt; recursively to elements of these nested lists.&lt;/p&gt; &#xA;&lt;p&gt;Then reduce the resulting lists using &lt;code&gt;folder&lt;/code&gt; and initial value &lt;code&gt;init-value&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-from-fn-init-list&#34;&gt;&lt;code&gt;-reduce-r-from&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is the same as calling &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-reduce-fn-tree&#34;&gt;&lt;code&gt;-tree-reduce&lt;/code&gt;&lt;/a&gt; after &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-map-fn-tree&#34;&gt;&lt;code&gt;-tree-map&lt;/code&gt;&lt;/a&gt; but is twice as fast as it only traverse the structure once.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-tree-mapreduce &#39;list &#39;append &#39;(1 (2 (3 4) (5 6)) (7 (8 9)))) ;; =&amp;gt; (1 2 3 4 5 6 7 8 9)&#xA;(--tree-mapreduce 1 (+ it acc) &#39;(1 (2 (4 9) (2 1)) (7 (4 3)))) ;; =&amp;gt; 9&#xA;(--tree-mapreduce 0 (max acc (1+ it)) &#39;(1 (2 (4 9) (2 1)) (7 (4 3)))) ;; =&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-tree-mapreduce-from &lt;code&gt;(fn folder init-value tree)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Apply &lt;code&gt;fn&lt;/code&gt; to each element of &lt;code&gt;tree&lt;/code&gt;, and make a list of the results. If elements of &lt;code&gt;tree&lt;/code&gt; are lists themselves, apply &lt;code&gt;fn&lt;/code&gt; recursively to elements of these nested lists.&lt;/p&gt; &#xA;&lt;p&gt;Then reduce the resulting lists using &lt;code&gt;folder&lt;/code&gt; and initial value &lt;code&gt;init-value&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-reduce-r-from-fn-init-list&#34;&gt;&lt;code&gt;-reduce-r-from&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is the same as calling &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-reduce-from-fn-init-value-tree&#34;&gt;&lt;code&gt;-tree-reduce-from&lt;/code&gt;&lt;/a&gt; after &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-tree-map-fn-tree&#34;&gt;&lt;code&gt;-tree-map&lt;/code&gt;&lt;/a&gt; but is twice as fast as it only traverse the structure once.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-tree-mapreduce-from &#39;identity &#39;* 1 &#39;(1 (2 (3 4) (5 6)) (7 (8 9)))) ;; =&amp;gt; 362880&#xA;(--tree-mapreduce-from (+ it it) (cons it acc) nil &#39;(1 (2 (4 9) (2 1)) (7 (4 3)))) ;; =&amp;gt; (2 (4 (8 18) (4 2)) (14 (8 6)))&#xA;(concat &#34;{&#34; (--tree-mapreduce-from (cond ((-cons-pair? it) (concat (symbol-name (car it)) &#34; -&amp;gt; &#34; (symbol-name (cdr it)))) (t (concat (symbol-name it) &#34; : {&#34;))) (concat it (unless (or (equal acc &#34;}&#34;) (equal (substring it (1- (length it))) &#34;{&#34;)) &#34;, &#34;) acc) &#34;}&#34; &#39;((elisp-mode (foo (bar . booze)) (baz . qux)) (c-mode (foo . bla) (bum . bam))))) ;; =&amp;gt; &#34;{elisp-mode : {foo : {bar -&amp;gt; booze}, baz -&amp;gt; qux}, c-mode : {foo -&amp;gt; bla, bum -&amp;gt; bam}}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-clone &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Create a deep copy of &lt;code&gt;list&lt;/code&gt;. The new list has the same elements and structure but all cons are replaced with new ones. This is useful when you need to clone a structure such as plist or alist.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let* ((a (list (list 1))) (b (-clone a))) (setcar (car a) 2) b) ;; =&amp;gt; ((1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Threading macros&lt;/h2&gt; &#xA;&lt;p&gt;Macros that conditionally combine sequential forms for brevity or readability.&lt;/p&gt; &#xA;&lt;h4&gt;-&amp;gt; &lt;code&gt;(x &amp;amp;optional form &amp;amp;rest more)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Thread the expr through the forms. Insert &lt;code&gt;x&lt;/code&gt; as the second item in the first form, making a list of it if it is not a list already. If there are more forms, insert the first form as the second item in second form, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-&amp;gt; &#39;(2 3 5)) ;; =&amp;gt; (2 3 5)&#xA;(-&amp;gt; &#39;(2 3 5) (append &#39;(8 13))) ;; =&amp;gt; (2 3 5 8 13)&#xA;(-&amp;gt; &#39;(2 3 5) (append &#39;(8 13)) (-slice 1 -1)) ;; =&amp;gt; (3 5 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-&amp;gt;&amp;gt; &lt;code&gt;(x &amp;amp;optional form &amp;amp;rest more)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Thread the expr through the forms. Insert &lt;code&gt;x&lt;/code&gt; as the last item in the first form, making a list of it if it is not a list already. If there are more forms, insert the first form as the last item in second form, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-&amp;gt;&amp;gt; &#39;(1 2 3) (-map &#39;square)) ;; =&amp;gt; (1 4 9)&#xA;(-&amp;gt;&amp;gt; &#39;(1 2 3) (-map &#39;square) (-remove &#39;even?)) ;; =&amp;gt; (1 9)&#xA;(-&amp;gt;&amp;gt; &#39;(1 2 3) (-map &#39;square) (-reduce &#39;+)) ;; =&amp;gt; 14&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;--&amp;gt; &lt;code&gt;(x &amp;amp;rest forms)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Starting with the value of &lt;code&gt;x&lt;/code&gt;, thread each expression through &lt;code&gt;forms&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Insert &lt;code&gt;x&lt;/code&gt; at the position signified by the symbol &lt;code&gt;it&lt;/code&gt; in the first form. If there are more forms, insert the first form at the position signified by &lt;code&gt;it&lt;/code&gt; in the second form, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(--&amp;gt; &#34;def&#34; (concat &#34;abc&#34; it &#34;ghi&#34;)) ;; =&amp;gt; &#34;abcdefghi&#34;&#xA;(--&amp;gt; &#34;def&#34; (concat &#34;abc&#34; it &#34;ghi&#34;) (upcase it)) ;; =&amp;gt; &#34;ABCDEFGHI&#34;&#xA;(--&amp;gt; &#34;def&#34; (concat &#34;abc&#34; it &#34;ghi&#34;) upcase) ;; =&amp;gt; &#34;ABCDEFGHI&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-as-&amp;gt; &lt;code&gt;(value variable &amp;amp;rest forms)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Starting with &lt;code&gt;value&lt;/code&gt;, thread &lt;code&gt;variable&lt;/code&gt; through &lt;code&gt;forms&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the first form, bind &lt;code&gt;variable&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. In the second form, bind &lt;code&gt;variable&lt;/code&gt; to the result of the first form, and so forth.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-as-&amp;gt; 3 my-var (1+ my-var) (list my-var) (mapcar (lambda (ele) (* 2 ele)) my-var)) ;; =&amp;gt; (8)&#xA;(-as-&amp;gt; 3 my-var 1+) ;; =&amp;gt; 4&#xA;(-as-&amp;gt; 3 my-var) ;; =&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-some-&amp;gt; &lt;code&gt;(x &amp;amp;optional form &amp;amp;rest more)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;When expr is non-&lt;code&gt;nil&lt;/code&gt;, thread it through the first form (via &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#--x-optional-form-rest-more&#34;&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/a&gt;), and when that result is non-&lt;code&gt;nil&lt;/code&gt;, through the next form, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-some-&amp;gt; &#39;(2 3 5)) ;; =&amp;gt; (2 3 5)&#xA;(-some-&amp;gt; 5 square) ;; =&amp;gt; 25&#xA;(-some-&amp;gt; 5 even? square) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-some-&amp;gt;&amp;gt; &lt;code&gt;(x &amp;amp;optional form &amp;amp;rest more)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;When expr is non-&lt;code&gt;nil&lt;/code&gt;, thread it through the first form (via &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#--x-optional-form-rest-more&#34;&gt;&lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;), and when that result is non-&lt;code&gt;nil&lt;/code&gt;, through the next form, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-some-&amp;gt;&amp;gt; &#39;(1 2 3) (-map &#39;square)) ;; =&amp;gt; (1 4 9)&#xA;(-some-&amp;gt;&amp;gt; &#39;(1 3 5) (-last &#39;even?) (+ 100)) ;; =&amp;gt; nil&#xA;(-some-&amp;gt;&amp;gt; &#39;(2 4 6) (-last &#39;even?) (+ 100)) ;; =&amp;gt; 106&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-some--&amp;gt; &lt;code&gt;(expr &amp;amp;rest forms)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Thread &lt;code&gt;expr&lt;/code&gt; through &lt;code&gt;forms&lt;/code&gt; via &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#---x-rest-forms&#34;&gt;&lt;code&gt;--&amp;gt;&lt;/code&gt;&lt;/a&gt;, while the result is non-&lt;code&gt;nil&lt;/code&gt;. When &lt;code&gt;expr&lt;/code&gt; evaluates to non-&lt;code&gt;nil&lt;/code&gt;, thread the result through the first of &lt;code&gt;forms&lt;/code&gt;, and when that result is non-&lt;code&gt;nil&lt;/code&gt;, thread it through the next form, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-some--&amp;gt; &#34;def&#34; (concat &#34;abc&#34; it &#34;ghi&#34;)) ;; =&amp;gt; &#34;abcdefghi&#34;&#xA;(-some--&amp;gt; nil (concat &#34;abc&#34; it &#34;ghi&#34;)) ;; =&amp;gt; nil&#xA;(-some--&amp;gt; &#39;(0 1) (-remove #&#39;natnump it) (append it it) (-map #&#39;1+ it)) ;; =&amp;gt; ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-doto &lt;code&gt;(init &amp;amp;rest forms)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Evaluate &lt;code&gt;init&lt;/code&gt; and pass it as argument to &lt;code&gt;forms&lt;/code&gt; with &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#--x-optional-form-rest-more&#34;&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;result&lt;/code&gt; of evaluating &lt;code&gt;init&lt;/code&gt; is threaded through each of &lt;code&gt;forms&lt;/code&gt; individually using &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#--x-optional-form-rest-more&#34;&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/a&gt;, which see. The return value is &lt;code&gt;result&lt;/code&gt;, which &lt;code&gt;forms&lt;/code&gt; may have modified by side effect.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-doto (list 1 2 3) pop pop) ;; =&amp;gt; (3)&#xA;(-doto (cons 1 2) (setcar 3) (setcdr 4)) ;; =&amp;gt; (3 . 4)&#xA;(gethash &#39;k (--doto (make-hash-table) (puthash &#39;k &#39;v it))) ;; =&amp;gt; v&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Binding&lt;/h2&gt; &#xA;&lt;p&gt;Macros that combine &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;let*&lt;/code&gt; with destructuring and flow control.&lt;/p&gt; &#xA;&lt;h4&gt;-when-let &lt;code&gt;((var val) &amp;amp;rest body)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;If &lt;code&gt;val&lt;/code&gt; evaluates to non-&lt;code&gt;nil&lt;/code&gt;, bind it to &lt;code&gt;var&lt;/code&gt; and execute body.&lt;/p&gt; &#xA;&lt;p&gt;Note: binding is done according to &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-let-varlist-rest-body&#34;&gt;&lt;code&gt;-let&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-when-let (match-index (string-match &#34;d&#34; &#34;abcd&#34;)) (+ match-index 2)) ;; =&amp;gt; 5&#xA;(-when-let ((&amp;amp;plist :foo foo) (list :foo &#34;foo&#34;)) foo) ;; =&amp;gt; &#34;foo&#34;&#xA;(-when-let ((&amp;amp;plist :foo foo) (list :bar &#34;bar&#34;)) foo) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-when-let* &lt;code&gt;(vars-vals &amp;amp;rest body)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;If all &lt;code&gt;vals&lt;/code&gt; evaluate to true, bind them to their corresponding &lt;code&gt;vars&lt;/code&gt; and execute body. &lt;code&gt;vars-vals&lt;/code&gt; should be a list of (&lt;code&gt;var&lt;/code&gt; &lt;code&gt;val&lt;/code&gt;) pairs.&lt;/p&gt; &#xA;&lt;p&gt;Note: binding is done according to &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-let-varlist-rest-body&#34;&gt;&lt;code&gt;-let*&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;vals&lt;/code&gt; are evaluated sequentially, and evaluation stops after the first &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;val&lt;/code&gt; is encountered.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-when-let* ((x 5) (y 3) (z (+ y 4))) (+ x y z)) ;; =&amp;gt; 15&#xA;(-when-let* ((x 5) (y nil) (z 7)) (+ x y z)) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-if-let &lt;code&gt;((var val) then &amp;amp;rest else)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;If &lt;code&gt;val&lt;/code&gt; evaluates to non-&lt;code&gt;nil&lt;/code&gt;, bind it to &lt;code&gt;var&lt;/code&gt; and do &lt;code&gt;then&lt;/code&gt;, otherwise do &lt;code&gt;else&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note: binding is done according to &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-let-varlist-rest-body&#34;&gt;&lt;code&gt;-let&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-if-let (match-index (string-match &#34;d&#34; &#34;abc&#34;)) (+ match-index 3) 7) ;; =&amp;gt; 7&#xA;(--if-let (even? 4) it nil) ;; =&amp;gt; t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-if-let* &lt;code&gt;(vars-vals then &amp;amp;rest else)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;If all &lt;code&gt;vals&lt;/code&gt; evaluate to true, bind them to their corresponding &lt;code&gt;vars&lt;/code&gt; and do &lt;code&gt;then&lt;/code&gt;, otherwise do &lt;code&gt;else&lt;/code&gt;. &lt;code&gt;vars-vals&lt;/code&gt; should be a list of (&lt;code&gt;var&lt;/code&gt; &lt;code&gt;val&lt;/code&gt;) pairs.&lt;/p&gt; &#xA;&lt;p&gt;Note: binding is done according to &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-let-varlist-rest-body&#34;&gt;&lt;code&gt;-let*&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;vals&lt;/code&gt; are evaluated sequentially, and evaluation stops after the first &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;val&lt;/code&gt; is encountered.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-if-let* ((x 5) (y 3) (z 7)) (+ x y z) &#34;foo&#34;) ;; =&amp;gt; 15&#xA;(-if-let* ((x 5) (y nil) (z 7)) (+ x y z) &#34;foo&#34;) ;; =&amp;gt; &#34;foo&#34;&#xA;(-if-let* (((_ _ x) &#39;(nil nil 7))) x) ;; =&amp;gt; 7&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-let &lt;code&gt;(varlist &amp;amp;rest body)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Bind variables according to &lt;code&gt;varlist&lt;/code&gt; then eval &lt;code&gt;body&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;varlist&lt;/code&gt; is a list of lists of the form (&lt;code&gt;pattern&lt;/code&gt; &lt;code&gt;source&lt;/code&gt;). Each &lt;code&gt;pattern&lt;/code&gt; is matched against the &lt;code&gt;source&lt;/code&gt; &#34;structurally&#34;. &lt;code&gt;source&lt;/code&gt; is only evaluated once for each &lt;code&gt;pattern&lt;/code&gt;. Each &lt;code&gt;pattern&lt;/code&gt; is matched recursively, and can therefore contain sub-patterns which are matched against corresponding sub-expressions of &lt;code&gt;source&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;All the SOURCEs are evalled before any symbols are bound (i.e. &#34;in parallel&#34;).&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;varlist&lt;/code&gt; only contains one (&lt;code&gt;pattern&lt;/code&gt; &lt;code&gt;source&lt;/code&gt;) element, you can optionally specify it using a vector and discarding the outer-most parens. Thus&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(-let ((`pattern` `source`)) ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;becomes&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(-let [`pattern` `source`] ...).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-let-varlist-rest-body&#34;&gt;&lt;code&gt;-let&lt;/code&gt;&lt;/a&gt; uses a convention of not binding places (symbols) starting with _ whenever it&#39;s possible. You can use this to skip over entries you don&#39;t care about. However, this is not &lt;em&gt;always&lt;/em&gt; possible (as a result of implementation) and these symbols might get bound to undefined values.&lt;/p&gt; &#xA;&lt;p&gt;Following is the overview of supported patterns. Remember that patterns can be matched recursively, so every a, b, aK in the following can be a matching construct and not necessarily a symbol/variable.&lt;/p&gt; &#xA;&lt;p&gt;Symbol:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a - bind the `source` to `a`.  This is just like regular `let`.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Conses and lists:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(a) - bind `car` of cons/list to `a`&#xA;&#xA;(a . b) - bind car of cons to `a` and `cdr` to `b`&#xA;&#xA;(a b) - bind car of list to `a` and `cadr` to `b`&#xA;&#xA;(a1 a2 a3 ...) - bind 0th car of list to `a1`, 1st to `a2`, 2nd to `a3`...&#xA;&#xA;(a1 a2 a3 ... aN . rest) - as above, but bind the `n`th cdr to `rest`.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Vectors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[a] - bind 0th element of a non-list sequence to `a` (works with&#xA;      vectors, strings, bit arrays...)&#xA;&#xA;[a1 a2 a3 ...] - bind 0th element of non-list sequence to `a0`, 1st to&#xA;                 `a1`, 2nd to `a2`, ...&#xA;                 If the `pattern` is shorter than `source`, the values at&#xA;                 places not in `pattern` are ignored.&#xA;                 If the `pattern` is longer than `source`, an `error` is&#xA;                 thrown.&#xA;&#xA;[a1 a2 a3 ... &amp;amp;rest rest] - as above, but bind the rest of&#xA;                            the sequence to `rest`.  This is&#xA;                            conceptually the same as improper list&#xA;                            matching (a1 a2 ... aN . rest)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Key/value stores:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(&amp;amp;plist key0 a0 ... keyN aN) - bind value mapped by keyK in the&#xA;                               `source` plist to aK.  If the&#xA;                               value is not found, aK is `nil`.&#xA;                               Uses `plist-get` to fetch values.&#xA;&#xA;(&amp;amp;alist key0 a0 ... keyN aN) - bind value mapped by keyK in the&#xA;                               `source` alist to aK.  If the&#xA;                               value is not found, aK is `nil`.&#xA;                               Uses `assoc` to fetch values.&#xA;&#xA;(&amp;amp;hash key0 a0 ... keyN aN) - bind value mapped by keyK in the&#xA;                              `source` hash table to aK.  If the&#xA;                              value is not found, aK is `nil`.&#xA;                              Uses `gethash` to fetch values.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Further, special keyword &amp;amp;keys supports &#34;inline&#34; matching of plist-like key-value pairs, similarly to &amp;amp;keys keyword of &lt;code&gt;cl-defun&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(a1 a2 ... aN &amp;amp;keys key1 b1 ... keyN bK)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This binds &lt;code&gt;n&lt;/code&gt; values from the list to a1 ... aN, then interprets the cdr as a plist (see key/value matching above).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;a&lt;/code&gt; shorthand notation for kv-destructuring exists which allows the patterns be optionally left out and derived from the key name in the following fashion:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a key :foo is converted into &lt;code&gt;foo&lt;/code&gt; pattern,&lt;/li&gt; &#xA; &lt;li&gt;a key &#39;bar is converted into &lt;code&gt;bar&lt;/code&gt; pattern,&lt;/li&gt; &#xA; &lt;li&gt;a key &#34;baz&#34; is converted into &lt;code&gt;baz&lt;/code&gt; pattern.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That is, the entire value under the key is bound to the derived variable without any further destructuring.&lt;/p&gt; &#xA;&lt;p&gt;This is possible only when the form following the key is not a valid pattern (i.e. not a symbol, a cons cell or a vector). Otherwise the matching proceeds as usual and in case of an invalid spec fails with an error.&lt;/p&gt; &#xA;&lt;p&gt;Thus the patterns are normalized as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; ;; derive all the missing patterns&#xA; (&amp;amp;plist :foo &#39;bar &#34;baz&#34;) =&amp;gt; (&amp;amp;plist :foo foo &#39;bar bar &#34;baz&#34; baz)&#xA;&#xA; ;; we can specify some but not others&#xA; (&amp;amp;plist :foo &#39;bar explicit-bar) =&amp;gt; (&amp;amp;plist :foo foo &#39;bar explicit-bar)&#xA;&#xA; ;; nothing happens, we store :foo in x&#xA; (&amp;amp;plist :foo x) =&amp;gt; (&amp;amp;plist :foo x)&#xA;&#xA; ;; nothing happens, we match recursively&#xA; (&amp;amp;plist :foo (a b c)) =&amp;gt; (&amp;amp;plist :foo (a b c))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can name the source using the syntax &lt;code&gt;symbol&lt;/code&gt; &amp;amp;as &lt;code&gt;pattern&lt;/code&gt;. This syntax works with lists (proper or improper), vectors and all types of maps.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(list &amp;amp;as a b c) (list 1 2 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;binds &lt;code&gt;a&lt;/code&gt; to 1, &lt;code&gt;b&lt;/code&gt; to 2, &lt;code&gt;c&lt;/code&gt; to 3 and &lt;code&gt;list&lt;/code&gt; to (1 2 3).&lt;/p&gt; &#xA;&lt;p&gt;Similarly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(bounds &amp;amp;as beg . end) (cons 1 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;binds &lt;code&gt;beg&lt;/code&gt; to 1, &lt;code&gt;end&lt;/code&gt; to 2 and &lt;code&gt;bounds&lt;/code&gt; to (1 . 2).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(items &amp;amp;as first . rest) (list 1 2 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;binds &lt;code&gt;first&lt;/code&gt; to 1, &lt;code&gt;rest&lt;/code&gt; to (2 3) and &lt;code&gt;items&lt;/code&gt; to (1 2 3)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[vect &amp;amp;as _ b c] [1 2 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;binds &lt;code&gt;b&lt;/code&gt; to 2, &lt;code&gt;c&lt;/code&gt; to 3 and &lt;code&gt;vect&lt;/code&gt; to [1 2 3] (_ avoids binding as usual).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(plist &amp;amp;as &amp;amp;plist :b b) (list :a 1 :b 2 :c 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;binds &lt;code&gt;b&lt;/code&gt; to 2 and &lt;code&gt;plist&lt;/code&gt; to (:a 1 :b 2 :c 3). Same for &amp;amp;alist and &amp;amp;hash.&lt;/p&gt; &#xA;&lt;p&gt;This is especially useful when we want to capture the result of a computation and destructure at the same time. Consider the form (function-returning-complex-structure) returning a list of two vectors with two items each. We want to capture this entire result and pass it to another computation, but at the same time we want to get the second item from each vector. We can achieve it with pattern&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(result &amp;amp;as [_ a] [_ b]) (function-returning-complex-structure)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: Clojure programmers may know this feature as the &#34;:as binding&#34;. The difference is that we put the &amp;amp;as at the front because we need to support improper list binding.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-let (([a (b c) d] [1 (2 3) 4])) (list a b c d)) ;; =&amp;gt; (1 2 3 4)&#xA;(-let [(a b c . d) (list 1 2 3 4 5 6)] (list a b c d)) ;; =&amp;gt; (1 2 3 (4 5 6))&#xA;(-let [(&amp;amp;plist :foo foo :bar bar) (list :baz 3 :foo 1 :qux 4 :bar 2)] (list foo bar)) ;; =&amp;gt; (1 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-let* &lt;code&gt;(varlist &amp;amp;rest body)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Bind variables according to &lt;code&gt;varlist&lt;/code&gt; then eval &lt;code&gt;body&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;varlist&lt;/code&gt; is a list of lists of the form (&lt;code&gt;pattern&lt;/code&gt; &lt;code&gt;source&lt;/code&gt;). Each &lt;code&gt;pattern&lt;/code&gt; is matched against the &lt;code&gt;source&lt;/code&gt; structurally. &lt;code&gt;source&lt;/code&gt; is only evaluated once for each &lt;code&gt;pattern&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Each &lt;code&gt;source&lt;/code&gt; can refer to the symbols already bound by this &lt;code&gt;varlist&lt;/code&gt;. This is useful if you want to destructure &lt;code&gt;source&lt;/code&gt; recursively but also want to name the intermediate structures.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-let-varlist-rest-body&#34;&gt;&lt;code&gt;-let&lt;/code&gt;&lt;/a&gt; for the list of all possible patterns.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-let* (((a . b) (cons 1 2)) ((c . d) (cons 3 4))) (list a b c d)) ;; =&amp;gt; (1 2 3 4)&#xA;(-let* (((a . b) (cons 1 (cons 2 3))) ((c . d) b)) (list a b c d)) ;; =&amp;gt; (1 (2 . 3) 2 3)&#xA;(-let* (((&amp;amp;alist &#34;foo&#34; foo &#34;bar&#34; bar) (list (cons &#34;foo&#34; 1) (cons &#34;bar&#34; (list &#39;a &#39;b &#39;c)))) ((a b c) bar)) (list foo a b c bar)) ;; =&amp;gt; (1 a b c (a b c))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-lambda &lt;code&gt;(match-form &amp;amp;rest body)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a lambda which destructures its input as &lt;code&gt;match-form&lt;/code&gt; and executes &lt;code&gt;body&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that you have to enclose the &lt;code&gt;match-form&lt;/code&gt; in a pair of parens, such that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(-lambda (x) body)&#xA;(-lambda (x y ...) body)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;has the usual semantics of &lt;code&gt;lambda&lt;/code&gt;. Furthermore, these get translated into normal &lt;code&gt;lambda&lt;/code&gt;, so there is no performance penalty.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-let-varlist-rest-body&#34;&gt;&lt;code&gt;-let&lt;/code&gt;&lt;/a&gt; for a description of the destructuring mechanism.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-map (-lambda ((x y)) (+ x y)) &#39;((1 2) (3 4) (5 6))) ;; =&amp;gt; (3 7 11)&#xA;(-map (-lambda ([x y]) (+ x y)) &#39;([1 2] [3 4] [5 6])) ;; =&amp;gt; (3 7 11)&#xA;(funcall (-lambda ((_ . a) (_ . b)) (-concat a b)) &#39;(1 2 3) &#39;(4 5 6)) ;; =&amp;gt; (2 3 5 6)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-setq &lt;code&gt;([match-form val] ...)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Bind each &lt;code&gt;match-form&lt;/code&gt; to the value of its &lt;code&gt;val&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;match-form&lt;/code&gt; destructuring is done according to the rules of &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-let-varlist-rest-body&#34;&gt;&lt;code&gt;-let&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This macro allows you to bind multiple variables by destructuring the value, so for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(-setq (a b) x&#xA;       (&amp;amp;plist :c c) plist)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;expands roughly speaking to the following code&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setq a (car x)&#xA;      b (cadr x)&#xA;      c (plist-get plist :c))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Care is taken to only evaluate each &lt;code&gt;val&lt;/code&gt; once so that in case of multiple assignments it does not cause unexpected side effects.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let (a) (-setq a 1) a) ;; =&amp;gt; 1&#xA;(let (a b) (-setq (a b) (list 1 2)) (list a b)) ;; =&amp;gt; (1 2)&#xA;(let (c) (-setq (&amp;amp;plist :c c) (list :c &#34;c&#34;)) c) ;; =&amp;gt; &#34;c&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Side effects&lt;/h2&gt; &#xA;&lt;p&gt;Functions iterating over lists for side effect only.&lt;/p&gt; &#xA;&lt;h4&gt;-each &lt;code&gt;(list fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Call &lt;code&gt;fn&lt;/code&gt; on each element of &lt;code&gt;list&lt;/code&gt;. Return &lt;code&gt;nil&lt;/code&gt;; this function is intended for side effects.&lt;/p&gt; &#xA;&lt;p&gt;Its anaphoric counterpart is &lt;code&gt;--each&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For access to the current element&#39;s index in &lt;code&gt;list&lt;/code&gt;, see &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-each-indexed-list-fn&#34;&gt;&lt;code&gt;-each-indexed&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let (l) (-each &#39;(1 2 3) (lambda (x) (push x l))) l) ;; =&amp;gt; (3 2 1)&#xA;(let (l) (--each &#39;(1 2 3) (push it l)) l) ;; =&amp;gt; (3 2 1)&#xA;(-each &#39;(1 2 3) #&#39;identity) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-each-while &lt;code&gt;(list pred fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Call &lt;code&gt;fn&lt;/code&gt; on each &lt;code&gt;item&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, while (&lt;code&gt;pred&lt;/code&gt; &lt;code&gt;item&lt;/code&gt;) is non-&lt;code&gt;nil&lt;/code&gt;. Once an &lt;code&gt;item&lt;/code&gt; is reached for which &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; is no longer called. Return &lt;code&gt;nil&lt;/code&gt;; this function is intended for side effects.&lt;/p&gt; &#xA;&lt;p&gt;Its anaphoric counterpart is &lt;code&gt;--each-while&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let (l) (-each-while &#39;(2 4 5 6) #&#39;even? (lambda (x) (push x l))) l) ;; =&amp;gt; (4 2)&#xA;(let (l) (--each-while &#39;(1 2 3 4) (&amp;lt; it 3) (push it l)) l) ;; =&amp;gt; (2 1)&#xA;(let ((s 0)) (--each-while &#39;(1 3 4 5) (&amp;lt; it 5) (setq s (+ s it))) s) ;; =&amp;gt; 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-each-indexed &lt;code&gt;(list fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Call &lt;code&gt;fn&lt;/code&gt; on each index and element of &lt;code&gt;list&lt;/code&gt;. For each &lt;code&gt;item&lt;/code&gt; at &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, call (funcall &lt;code&gt;fn&lt;/code&gt; &lt;code&gt;index&lt;/code&gt; &lt;code&gt;item&lt;/code&gt;). Return &lt;code&gt;nil&lt;/code&gt;; this function is intended for side effects.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-map-indexed-fn-list&#34;&gt;&lt;code&gt;-map-indexed&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let (l) (-each-indexed &#39;(a b c) (lambda (i x) (push (list x i) l))) l) ;; =&amp;gt; ((c 2) (b 1) (a 0))&#xA;(let (l) (--each-indexed &#39;(a b c) (push (list it it-index) l)) l) ;; =&amp;gt; ((c 2) (b 1) (a 0))&#xA;(let (l) (--each-indexed () (push it l)) l) ;; =&amp;gt; ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-each-r &lt;code&gt;(list fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Call &lt;code&gt;fn&lt;/code&gt; on each element of &lt;code&gt;list&lt;/code&gt; in reversed order. Return &lt;code&gt;nil&lt;/code&gt;; this function is intended for side effects.&lt;/p&gt; &#xA;&lt;p&gt;Its anaphoric counterpart is &lt;code&gt;--each-r&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let (l) (-each-r &#39;(1 2 3) (lambda (x) (push x l))) l) ;; =&amp;gt; (1 2 3)&#xA;(let (l) (--each-r &#39;(1 2 3) (push it l)) l) ;; =&amp;gt; (1 2 3)&#xA;(-each-r &#39;(1 2 3) #&#39;identity) ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-each-r-while &lt;code&gt;(list pred fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Call &lt;code&gt;fn&lt;/code&gt; on each &lt;code&gt;item&lt;/code&gt; in reversed &lt;code&gt;list&lt;/code&gt;, while (&lt;code&gt;pred&lt;/code&gt; &lt;code&gt;item&lt;/code&gt;) is non-&lt;code&gt;nil&lt;/code&gt;. Once an &lt;code&gt;item&lt;/code&gt; is reached for which &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; is no longer called. Return &lt;code&gt;nil&lt;/code&gt;; this function is intended for side effects.&lt;/p&gt; &#xA;&lt;p&gt;Its anaphoric counterpart is &lt;code&gt;--each-r-while&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let (l) (-each-r-while &#39;(2 4 5 6) #&#39;even? (lambda (x) (push x l))) l) ;; =&amp;gt; (6)&#xA;(let (l) (--each-r-while &#39;(1 2 3 4) (&amp;gt;= it 3) (push it l)) l) ;; =&amp;gt; (3 4)&#xA;(let ((s 0)) (--each-r-while &#39;(1 2 3 5) (&amp;gt; it 1) (setq s (+ s it))) s) ;; =&amp;gt; 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-dotimes &lt;code&gt;(num fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Call &lt;code&gt;fn&lt;/code&gt; &lt;code&gt;num&lt;/code&gt; times, presumably for side effects. &lt;code&gt;fn&lt;/code&gt; is called with a single argument on successive integers running from 0, inclusive, to &lt;code&gt;num&lt;/code&gt;, exclusive. &lt;code&gt;fn&lt;/code&gt; is not called if &lt;code&gt;num&lt;/code&gt; is less than 1.&lt;/p&gt; &#xA;&lt;p&gt;This function&#39;s anaphoric counterpart is &lt;code&gt;--dotimes&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let (s) (-dotimes 3 (lambda (n) (push n s))) s) ;; =&amp;gt; (2 1 0)&#xA;(let (s) (-dotimes 0 (lambda (n) (push n s))) s) ;; =&amp;gt; ()&#xA;(let (s) (--dotimes 5 (push it s)) s) ;; =&amp;gt; (4 3 2 1 0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Destructive operations&lt;/h2&gt; &#xA;&lt;p&gt;Macros that modify variables holding lists.&lt;/p&gt; &#xA;&lt;h4&gt;!cons &lt;code&gt;(car cdr)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Destructive: Set &lt;code&gt;cdr&lt;/code&gt; to the cons of &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let (l) (!cons 5 l) l) ;; =&amp;gt; (5)&#xA;(let ((l &#39;(3))) (!cons 5 l) l) ;; =&amp;gt; (5 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;!cdr &lt;code&gt;(list)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Destructive: Set &lt;code&gt;list&lt;/code&gt; to the cdr of &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(let ((l &#39;(3))) (!cdr l) l) ;; =&amp;gt; ()&#xA;(let ((l &#39;(3 5))) (!cdr l) l) ;; =&amp;gt; (5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Function combinators&lt;/h2&gt; &#xA;&lt;p&gt;Functions that manipulate and compose other functions.&lt;/p&gt; &#xA;&lt;h4&gt;-partial &lt;code&gt;(fun &amp;amp;rest args)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function that is a partial application of &lt;code&gt;fun&lt;/code&gt; to &lt;code&gt;args&lt;/code&gt;. &lt;code&gt;args&lt;/code&gt; is a list of the first &lt;code&gt;n&lt;/code&gt; arguments to pass to &lt;code&gt;fun&lt;/code&gt;. The result is a new function which does the same as &lt;code&gt;fun&lt;/code&gt;, except that the first &lt;code&gt;n&lt;/code&gt; arguments are fixed at the values with which this function was called.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-partial #&#39;+ 5)) ;; =&amp;gt; 5&#xA;(funcall (-partial #&#39;- 5) 3) ;; =&amp;gt; 2&#xA;(funcall (-partial #&#39;+ 5 2) 3) ;; =&amp;gt; 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-rpartial &lt;code&gt;(fn &amp;amp;rest args)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function that is a partial application of &lt;code&gt;fn&lt;/code&gt; to &lt;code&gt;args&lt;/code&gt;. &lt;code&gt;args&lt;/code&gt; is a list of the last &lt;code&gt;n&lt;/code&gt; arguments to pass to &lt;code&gt;fn&lt;/code&gt;. The result is a new function which does the same as &lt;code&gt;fn&lt;/code&gt;, except that the last &lt;code&gt;n&lt;/code&gt; arguments are fixed at the values with which this function was called. This is like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-partial-fun-rest-args&#34;&gt;&lt;code&gt;-partial&lt;/code&gt;&lt;/a&gt;, except the arguments are fixed starting from the right rather than the left.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-rpartial #&#39;- 5)) ;; =&amp;gt; -5&#xA;(funcall (-rpartial #&#39;- 5) 8) ;; =&amp;gt; 3&#xA;(funcall (-rpartial #&#39;- 5 2) 10) ;; =&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-juxt &lt;code&gt;(&amp;amp;rest fns)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function that is the juxtaposition of &lt;code&gt;fns&lt;/code&gt;. The returned function takes a variable number of &lt;code&gt;args&lt;/code&gt;, applies each of &lt;code&gt;fns&lt;/code&gt; in turn to &lt;code&gt;args&lt;/code&gt;, and returns the list of results.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-juxt) 1 2) ;; =&amp;gt; ()&#xA;(funcall (-juxt #&#39;+ #&#39;- #&#39;* #&#39;/) 7 5) ;; =&amp;gt; (12 2 35 1)&#xA;(mapcar (-juxt #&#39;number-to-string #&#39;1+) &#39;(1 2)) ;; =&amp;gt; ((&#34;1&#34; 2) (&#34;2&#34; 3))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-compose &lt;code&gt;(&amp;amp;rest fns)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Compose &lt;code&gt;fns&lt;/code&gt; into a single composite function. Return a function that takes a variable number of &lt;code&gt;args&lt;/code&gt;, applies the last function in &lt;code&gt;fns&lt;/code&gt; to &lt;code&gt;args&lt;/code&gt;, and returns the result of calling each remaining function on the result of the previous function, right-to-left. If no &lt;code&gt;fns&lt;/code&gt; are given, return a variadic &lt;code&gt;identity&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-compose #&#39;- #&#39;1+ #&#39;+) 1 2 3) ;; =&amp;gt; -7&#xA;(funcall (-compose #&#39;identity #&#39;1+) 3) ;; =&amp;gt; 4&#xA;(mapcar (-compose #&#39;not #&#39;stringp) &#39;(nil &#34;&#34;)) ;; =&amp;gt; (t nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-applify &lt;code&gt;(fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function that applies &lt;code&gt;fn&lt;/code&gt; to a single list of args. This changes the arity of &lt;code&gt;fn&lt;/code&gt; from taking &lt;code&gt;n&lt;/code&gt; distinct arguments to taking 1 argument which is a list of &lt;code&gt;n&lt;/code&gt; arguments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-applify #&#39;+) nil) ;; =&amp;gt; 0&#xA;(mapcar (-applify #&#39;+) &#39;((1 1 1) (1 2 3) (5 5 5))) ;; =&amp;gt; (3 6 15)&#xA;(funcall (-applify #&#39;&amp;lt;) &#39;(3 6)) ;; =&amp;gt; t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-on &lt;code&gt;(op trans)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function that calls &lt;code&gt;trans&lt;/code&gt; on each arg and &lt;code&gt;op&lt;/code&gt; on the results. The returned function takes a variable number of arguments, calls the function &lt;code&gt;trans&lt;/code&gt; on each one in turn, and then passes those results as the list of arguments to &lt;code&gt;op&lt;/code&gt;, in the same order.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following pairs of expressions are morally equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(funcall (-on #&#39;+ #&#39;1+) 1 2 3) = (+ (1+ 1) (1+ 2) (1+ 3))&#xA;(funcall (-on #&#39;+ #&#39;1+))       = (+)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-sort (-on #&#39;&amp;lt; #&#39;length) &#39;((1 2 3) (1) (1 2))) ;; =&amp;gt; ((1) (1 2) (1 2 3))&#xA;(funcall (-on #&#39;min #&#39;string-to-number) &#34;22&#34; &#34;2&#34; &#34;1&#34; &#34;12&#34;) ;; =&amp;gt; 1&#xA;(-min-by (-on #&#39;&amp;gt; #&#39;length) &#39;((1 2 3) (4) (1 2))) ;; =&amp;gt; (4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-flip &lt;code&gt;(fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function that calls &lt;code&gt;fn&lt;/code&gt; with its arguments reversed. The returned function takes the same number of arguments as &lt;code&gt;fn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following two expressions are morally equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(funcall (-flip #&#39;-) 1 2) = (- 2 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-rotate-args-n-fn&#34;&gt;&lt;code&gt;-rotate-args&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-sort (-flip #&#39;&amp;lt;) &#39;(4 3 6 1)) ;; =&amp;gt; (6 4 3 1)&#xA;(funcall (-flip #&#39;-) 3 2 1 10) ;; =&amp;gt; 4&#xA;(funcall (-flip #&#39;1+) 1) ;; =&amp;gt; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-rotate-args &lt;code&gt;(n fn)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function that calls &lt;code&gt;fn&lt;/code&gt; with args rotated &lt;code&gt;n&lt;/code&gt; places to the right. The returned function takes the same number of arguments as &lt;code&gt;fn&lt;/code&gt;, rotates the list of arguments &lt;code&gt;n&lt;/code&gt; places to the right (left if &lt;code&gt;n&lt;/code&gt; is negative) just like &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-rotate-n-list&#34;&gt;&lt;code&gt;-rotate&lt;/code&gt;&lt;/a&gt;, and applies &lt;code&gt;fn&lt;/code&gt; to the result.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-flip-fn&#34;&gt;&lt;code&gt;-flip&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-rotate-args -1 #&#39;list) 1 2 3 4) ;; =&amp;gt; (2 3 4 1)&#xA;(funcall (-rotate-args 1 #&#39;-) 1 10 100) ;; =&amp;gt; 89&#xA;(funcall (-rotate-args 2 #&#39;list) 3 4 5 1 2) ;; =&amp;gt; (1 2 3 4 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-const &lt;code&gt;(c)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function that returns &lt;code&gt;c&lt;/code&gt; ignoring any additional arguments.&lt;/p&gt; &#xA;&lt;p&gt;In types: a -&amp;gt; b -&amp;gt; a&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-const 2) 1 3 &#34;foo&#34;) ;; =&amp;gt; 2&#xA;(mapcar (-const 1) &#39;(&#34;a&#34; &#34;b&#34; &#34;c&#34; &#34;d&#34;)) ;; =&amp;gt; (1 1 1 1)&#xA;(-sum (mapcar (-const 1) &#39;(&#34;a&#34; &#34;b&#34; &#34;c&#34; &#34;d&#34;))) ;; =&amp;gt; 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-cut &lt;code&gt;(&amp;amp;rest params)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Take n-ary function and n arguments and specialize some of them. Arguments denoted by &amp;lt;&amp;gt; will be left unspecialized.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;code&gt;srfi-26&lt;/code&gt; for detailed description.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-cut list 1 &amp;lt;&amp;gt; 3 &amp;lt;&amp;gt; 5) 2 4) ;; =&amp;gt; (1 2 3 4 5)&#xA;(-map (-cut funcall &amp;lt;&amp;gt; 5) `(1+ 1- ,(lambda (x) (/ 1.0 x)))) ;; =&amp;gt; (6 4 0.2)&#xA;(-map (-cut &amp;lt;&amp;gt; 1 2 3) &#39;(list vector string)) ;; =&amp;gt; ((1 2 3) [1 2 3] &#34;\1\2\3&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-not &lt;code&gt;(pred)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a predicate that negates the result of &lt;code&gt;pred&lt;/code&gt;. The returned predicate passes its arguments to &lt;code&gt;pred&lt;/code&gt;. If &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, the result is non-&lt;code&gt;nil&lt;/code&gt;; otherwise the result is &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-andfn-rest-preds&#34;&gt;&lt;code&gt;-andfn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-orfn-rest-preds&#34;&gt;&lt;code&gt;-orfn&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-not #&#39;numberp) &#34;5&#34;) ;; =&amp;gt; t&#xA;(-sort (-not #&#39;&amp;lt;) &#39;(5 2 1 0 6)) ;; =&amp;gt; (6 5 2 1 0)&#xA;(-filter (-not (-partial #&#39;&amp;lt; 4)) &#39;(1 2 3 4 5 6 7 8)) ;; =&amp;gt; (1 2 3 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-orfn &lt;code&gt;(&amp;amp;rest preds)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a predicate that returns the first non-&lt;code&gt;nil&lt;/code&gt; result of &lt;code&gt;preds&lt;/code&gt;. The returned predicate takes a variable number of arguments, passes them to each predicate in &lt;code&gt;preds&lt;/code&gt; in turn until one of them returns non-&lt;code&gt;nil&lt;/code&gt;, and returns that non-&lt;code&gt;nil&lt;/code&gt; result without calling the remaining &lt;code&gt;preds&lt;/code&gt;. If all &lt;code&gt;preds&lt;/code&gt; return &lt;code&gt;nil&lt;/code&gt;, or if no &lt;code&gt;preds&lt;/code&gt; are given, the returned predicate returns &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-andfn-rest-preds&#34;&gt;&lt;code&gt;-andfn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-not-pred&#34;&gt;&lt;code&gt;-not&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-filter (-orfn #&#39;natnump #&#39;booleanp) &#39;(1 nil &#34;a&#34; -4 b c t)) ;; =&amp;gt; (1 nil t)&#xA;(funcall (-orfn #&#39;symbolp (-cut string-match-p &#34;x&#34; &amp;lt;&amp;gt;)) &#34;axe&#34;) ;; =&amp;gt; 1&#xA;(funcall (-orfn #&#39;= #&#39;+) 1 1) ;; =&amp;gt; t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-andfn &lt;code&gt;(&amp;amp;rest preds)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a predicate that returns non-&lt;code&gt;nil&lt;/code&gt; if all &lt;code&gt;preds&lt;/code&gt; do so. The returned predicate &lt;code&gt;p&lt;/code&gt; takes a variable number of arguments and passes them to each predicate in &lt;code&gt;preds&lt;/code&gt; in turn. If any one of &lt;code&gt;preds&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; also returns &lt;code&gt;nil&lt;/code&gt; without calling the remaining &lt;code&gt;preds&lt;/code&gt;. If all &lt;code&gt;preds&lt;/code&gt; return non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; returns the last such value. If no &lt;code&gt;preds&lt;/code&gt; are given, &lt;code&gt;p&lt;/code&gt; always returns non-&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-orfn-rest-preds&#34;&gt;&lt;code&gt;-orfn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-not-pred&#34;&gt;&lt;code&gt;-not&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(-filter (-andfn #&#39;numberp (-cut &amp;lt; &amp;lt;&amp;gt; 5)) &#39;(a 1 b 6 c 2)) ;; =&amp;gt; (1 2)&#xA;(mapcar (-andfn #&#39;numberp #&#39;1+) &#39;(a 1 b 6)) ;; =&amp;gt; (nil 2 nil 7)&#xA;(funcall (-andfn #&#39;= #&#39;+) 1 1) ;; =&amp;gt; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-iteratefn &lt;code&gt;(fn n)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function &lt;code&gt;fn&lt;/code&gt; composed &lt;code&gt;n&lt;/code&gt; times with itself.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;fn&lt;/code&gt; is a unary function. If you need to use a function of higher arity, use &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#-applify-fn&#34;&gt;&lt;code&gt;-applify&lt;/code&gt;&lt;/a&gt; first to turn it into a unary function.&lt;/p&gt; &#xA;&lt;p&gt;With n = 0, this acts as identity function.&lt;/p&gt; &#xA;&lt;p&gt;In types: (a -&amp;gt; a) -&amp;gt; Int -&amp;gt; a -&amp;gt; a.&lt;/p&gt; &#xA;&lt;p&gt;This function satisfies the following law:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(funcall (-iteratefn fn n) init) = (-last-item (-iterate fn init (1+ n))).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-iteratefn (lambda (x) (* x x)) 3) 2) ;; =&amp;gt; 256&#xA;(funcall (-iteratefn &#39;1+ 3) 1) ;; =&amp;gt; 4&#xA;(funcall (-iteratefn &#39;cdr 3) &#39;(1 2 3 4 5)) ;; =&amp;gt; (4 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-fixfn &lt;code&gt;(fn &amp;amp;optional equal-test halt-test)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function that computes the (least) fixpoint of &lt;code&gt;fn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;fn&lt;/code&gt; must be a unary function. The returned lambda takes a single argument, &lt;code&gt;x&lt;/code&gt;, the initial value for the fixpoint iteration. The iteration halts when either of the following conditions is satisfied:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Iteration converges to the fixpoint, with equality being tested using &lt;code&gt;equal-test&lt;/code&gt;. If &lt;code&gt;equal-test&lt;/code&gt; is not specified, &lt;code&gt;equal&lt;/code&gt; is used. For functions over the floating point numbers, it may be necessary to provide an appropriate approximate comparison test.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;halt-test&lt;/code&gt; returns a non-&lt;code&gt;nil&lt;/code&gt; value. &lt;code&gt;halt-test&lt;/code&gt; defaults to a simple counter that returns &lt;code&gt;t&lt;/code&gt; after &lt;code&gt;-fixfn-max-iterations&lt;/code&gt;, to guard against infinite iteration. Otherwise, &lt;code&gt;halt-test&lt;/code&gt; must be a function that accepts a single argument, the current value of &lt;code&gt;x&lt;/code&gt;, and returns non-&lt;code&gt;nil&lt;/code&gt; as long as iteration should continue. In this way, a more sophisticated convergence test may be supplied by the caller.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The return value of the lambda is either the fixpoint or, if iteration halted before converging, a cons with car &lt;code&gt;halted&lt;/code&gt; and cdr the final output from &lt;code&gt;halt-test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In types: (a -&amp;gt; a) -&amp;gt; a -&amp;gt; a.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-fixfn #&#39;cos #&#39;approx=) 0.7) ;; ~&amp;gt; 0.7390851332151607&#xA;(funcall (-fixfn (lambda (x) (expt (+ x 10) 0.25))) 2.0) ;; =&amp;gt; 1.8555845286409378&#xA;(funcall (-fixfn #&#39;sin #&#39;approx=) 0.1) ;; =&amp;gt; (halted . t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;-prodfn &lt;code&gt;(&amp;amp;rest fns)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return a function that applies each of &lt;code&gt;fns&lt;/code&gt; to each of a list of arguments.&lt;/p&gt; &#xA;&lt;p&gt;Takes a list of &lt;code&gt;n&lt;/code&gt; functions and returns a function that takes a list of length &lt;code&gt;n&lt;/code&gt;, applying &lt;code&gt;i&lt;/code&gt;th function to &lt;code&gt;i&lt;/code&gt;th element of the input list. Returns a list of length &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In types (for &lt;code&gt;n&lt;/code&gt;=2): ((a -&amp;gt; b), (c -&amp;gt; d)) -&amp;gt; (a, c) -&amp;gt; (b, d)&lt;/p&gt; &#xA;&lt;p&gt;This function satisfies the following laws:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  (-compose (-prodfn f g ...)&#xA;            (-prodfn f&#39; g&#39; ...))&#xA;= (-prodfn (-compose f f&#39;)&#xA;           (-compose g g&#39;)&#xA;           ...)&#xA;&#xA;  (-prodfn f g ...)&#xA;= (-juxt (-compose f (-partial #&#39;nth 0))&#xA;         (-compose g (-partial #&#39;nth 1))&#xA;         ...)&#xA;&#xA;  (-compose (-prodfn f g ...)&#xA;            (-juxt f&#39; g&#39; ...))&#xA;= (-juxt (-compose f f&#39;)&#xA;         (-compose g g&#39;)&#xA;         ...)&#xA;&#xA;  (-compose (-partial #&#39;nth n)&#xA;            (-prod f1 f2 ...))&#xA;= (-compose fn (-partial #&#39;nth n))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(funcall (-prodfn #&#39;1+ #&#39;1- #&#39;number-to-string) &#39;(1 2 3)) ;; =&amp;gt; (2 1 &#34;3&#34;)&#xA;(-map (-prodfn #&#39;1- #&#39;1+) &#39;((1 2) (3 4) (5 6))) ;; =&amp;gt; ((0 3) (2 5) (4 7))&#xA;(apply #&#39;+ (funcall (-prodfn #&#39;length #&#39;string-to-number) &#39;((t) &#34;5&#34;))) ;; =&amp;gt; 6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Yes, please do. Pure functions in the list manipulation realm only, please. There&#39;s a suite of examples/tests in &lt;code&gt;dev/examples.el&lt;/code&gt;, so remember to add tests for your additions, or I might break them later.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll find the repo at:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;https://github.com/magnars/dash.el&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the tests with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Regenerate the docs with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make docs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I highly recommend that you install these as a pre-commit hook, so that the tests are always running and the docs are always in sync:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cp dev/pre-commit.sh .git/hooks/pre-commit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Oh, and don&#39;t edit &lt;code&gt;README.md&lt;/code&gt; or &lt;code&gt;dash.texi&lt;/code&gt; directly; they are auto-generated. Change &lt;code&gt;readme-template.md&lt;/code&gt; or &lt;code&gt;dash-template.texi&lt;/code&gt; instead, respectively.&lt;/p&gt; &#xA;&lt;p&gt;To ensure that &lt;code&gt;dash.el&lt;/code&gt; can be distributed with GNU ELPA or Emacs, we require that all contributors assign copyright to the Free Software Foundation. For more on this, see &lt;a href=&#34;https://gnu.org/software/emacs/manual/html_node/emacs/Copyright-Assignment.html&#34;&gt;&lt;code&gt;(info &#34;(emacs) Copyright Assignment&#34;)&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Fuco1&#34;&gt;Matus Goljer&lt;/a&gt; contributed lots of features and functions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tkf&#34;&gt;Takafumi Arakaki&lt;/a&gt; contributed &lt;code&gt;-group-by&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tali713&#34;&gt;tali713&lt;/a&gt; is the author of &lt;code&gt;-applify&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vemv&#34;&gt;Vctor M. Valenzuela&lt;/a&gt; contributed &lt;code&gt;-repeat&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nicferrier&#34;&gt;Nic Ferrier&lt;/a&gt; contributed &lt;code&gt;-cons*&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Wilfred&#34;&gt;Wilfred Hughes&lt;/a&gt; contributed &lt;code&gt;-slice&lt;/code&gt;, &lt;code&gt;-first-item&lt;/code&gt;, and &lt;code&gt;-last-item&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shosti&#34;&gt;Emanuel Evans&lt;/a&gt; contributed &lt;code&gt;-if-let&lt;/code&gt;, &lt;code&gt;-when-let&lt;/code&gt;, and &lt;code&gt;-insert-at&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rejeep&#34;&gt;Johan Andersson&lt;/a&gt; contributed &lt;code&gt;-sum&lt;/code&gt;, &lt;code&gt;-product&lt;/code&gt;, and &lt;code&gt;-same-items?&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kurisuwhyte&#34;&gt;Christina Whyte&lt;/a&gt; contributed &lt;code&gt;-compose&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/steventlamb&#34;&gt;Steve Lamb&lt;/a&gt; contributed &lt;code&gt;-cycle&lt;/code&gt;, &lt;code&gt;-pad&lt;/code&gt;, &lt;code&gt;-annotate&lt;/code&gt;, &lt;code&gt;-zip-fill&lt;/code&gt;, and a variadic version of &lt;code&gt;-zip&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fbergroth&#34;&gt;Fredrik Bergroth&lt;/a&gt; made the &lt;code&gt;-if-let&lt;/code&gt; family use &lt;code&gt;-let&lt;/code&gt; destructuring and improved the script for generating documentation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/holomorph&#34;&gt;Mark Oteiza&lt;/a&gt; contributed &lt;code&gt;-iota&lt;/code&gt; and the script to create an Info manual.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wasamasa&#34;&gt;Vasilij Schneidermann&lt;/a&gt; contributed &lt;code&gt;-some&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/occidens&#34;&gt;William West&lt;/a&gt; made &lt;code&gt;-fixfn&lt;/code&gt; more robust at handling floats.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/camsaul&#34;&gt;Cam Saul&lt;/a&gt; contributed &lt;code&gt;-some-&amp;gt;&lt;/code&gt;, &lt;code&gt;-some-&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;-some--&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/basil-conto&#34;&gt;Basil L. Contovounesios&lt;/a&gt; contributed &lt;code&gt;-common-prefix&lt;/code&gt;, &lt;code&gt;-common-suffix&lt;/code&gt;, and various other improvements.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/doublep&#34;&gt;Paul Pogonyshev&lt;/a&gt; contributed &lt;code&gt;-each-r&lt;/code&gt; and &lt;code&gt;-each-r-while&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Thanks!&lt;/p&gt; &#xA;&lt;p&gt;New contributors are very welcome. See the &lt;a href=&#34;https://raw.githubusercontent.com/magnars/dash.el/master/#contribute&#34;&gt;&lt;code&gt;Contribute&lt;/code&gt;&lt;/a&gt; section above.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (C) 2012-2024 Free Software Foundation, Inc.&lt;/p&gt; &#xA;&lt;p&gt;Author: Magnar Sveen &lt;a href=&#34;mailto:magnars@gmail.com&#34;&gt;magnars@gmail.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;You should have received a copy of the GNU General Public License along with this program. If not, see &lt;a href=&#34;https://www.gnu.org/licenses/&#34;&gt;https://www.gnu.org/licenses/&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>