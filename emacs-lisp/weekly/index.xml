<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-22T01:51:05Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>atilaneves/cmake-ide</title>
    <updated>2023-10-22T01:51:05Z</updated>
    <id>tag:github.com,2023-10-22:/atilaneves/cmake-ide</id>
    <link href="https://github.com/atilaneves/cmake-ide" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Use Emacs as a C/C++ IDE&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;cmake-ide&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/atilaneves/cmake-ide&#34;&gt;&lt;img src=&#34;https://travis-ci.org/atilaneves/cmake-ide.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/atilaneves/cmake-ide?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/atilaneves/cmake-ide/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/cmake-ide&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/cmake-ide-badge.svg?sanitize=true&#34; alt=&#34;Melpa Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;CppCon 2015 Lightning talk on cmake-ide:&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=5FQwQ0QWBTU&#34; title=&#34;Emacs as a C++ IDE&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/5FQwQ0QWBTU/0.jpg&#34; alt=&#34;CppCon 2015 Lightning talk on cmake-ide&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;cmake-ide&lt;/code&gt; is a package to enable IDE-like features on Emacs for &lt;a href=&#34;http://www.cmake.org/&#34;&gt;CMake&lt;/a&gt; projects. It also supports non-CMake projects as long as a &lt;a href=&#34;http://clang.llvm.org/docs/JSONCompilationDatabase.html&#34;&gt;compilation database&lt;/a&gt; is generated out-of-band.This includes autocompletion and on-the-fly syntax checking in Emacs for CMake projects with minimal configuration. It uses other packages to do its heavy lifting, in a combination of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Andersbakken/rtags&#34;&gt;rtags&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/flycheck/flycheck&#34;&gt;flycheck&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/brianjcj/auto-complete-clang&#34;&gt;auto-complete-clang&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/company-mode/company-mode/raw/master/company-clang.el&#34;&gt;company-clang&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Sarcasm/irony-mode&#34;&gt;irony&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;cmake-ide&lt;/code&gt; will set variables and call functions for the installed dependent packages.&lt;/p&gt; &#xA;&lt;p&gt;It works by running CMake in Emacs in order to obtain the necessary compiler flags to pass to the other tools. Since all the dependencies are specified in the CMake scripts, there is no need to maintain a parallel dependency tracking system for Emacs. Just ask CMake.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sets variables for &lt;code&gt;auto-complete-clang&lt;/code&gt;, &lt;code&gt;flycheck&lt;/code&gt; and others for a CMake project automagically. Hardly any configuration necessary.&lt;/li&gt; &#xA; &lt;li&gt;Automatically reruns CMake when a file is saved. Great when using CMake file globs to pick up newly created files, but needs &lt;code&gt;cmake-ide-build-dir&lt;/code&gt; to be set.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cmake-ide-delete-file&lt;/code&gt; allows you to have the same convenience when deleting files. I can&#39;t figure out a better way to do this. Obviously simply deleting the file means having to run CMake again manually for it to register the change in the list of files to be compiled.&lt;/li&gt; &#xA; &lt;li&gt;If &lt;code&gt;cmake-ide-build-dir&lt;/code&gt; is set, it is considered to be the build directory to run CMake in. Additionally, this will cause &lt;code&gt;cmake-ide-compile&lt;/code&gt; to compile the project there. It automatically detects Ninja and Make builds and sets the compile command accordingly. The command to use can be customised by setting the &lt;code&gt;cmake-compile-command&lt;/code&gt; variable.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cmake-ide&lt;/code&gt; can make usage of &lt;a href=&#34;https://github.com/Andersbakken/rtags&#34;&gt;rtags&lt;/a&gt; for finding definitions, also using clang. If &lt;code&gt;(require &#39;rtags)&lt;/code&gt; is called before &lt;code&gt;cmake-ide-setup&lt;/code&gt;, it will automatically start the rtags server (&lt;code&gt;rdm&lt;/code&gt;) and call &lt;code&gt;rc -J&lt;/code&gt; to index the project files for 0-config &#34;jump to definition&#34; and everything else rtags offers. This only works if both &lt;code&gt;rdm&lt;/code&gt; and &lt;code&gt;rc&lt;/code&gt; and in the system path or if &lt;code&gt;cmake-ide-rdm-executable&lt;/code&gt; and &lt;code&gt;cmake-ide-rc-executable&lt;/code&gt; are customized correctly.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build Pool Directories and Persistent Naming of Automatic Build Directories&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;cmake-ide&lt;/code&gt; can automatically create build directories for you -- either in the system&#39;s tmp-directory or under &lt;code&gt;cmake-ide-build-pool-dir&lt;/code&gt; (if set). By default, all automatically created build directories (no matter where created) will have temporary and unique names, that will change with each new session and are thus not reusable. You can, however, by setting &lt;code&gt;cmake-ide-build-pool-use-persistent-naming&lt;/code&gt; use a reproducible naming scheme that is based on the project&#39;s path and will not change as long as the project&#39;s path is the same. This way, you can reuse the build directory.&lt;/p&gt; &#xA;&lt;p&gt;By using both &lt;code&gt;cmake-ide-build-pool-dir&lt;/code&gt; and &lt;code&gt;cmake-ide-build-pool-use-persistent-naming&lt;/code&gt;, you can fully do away with the need to configure a build directory per project with directory local variables (for example).&lt;/p&gt; &#xA;&lt;h2&gt;Non-CMake projects&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;code&gt;.dir-locals.el&lt;/code&gt; to set the &lt;code&gt;cmake-ide-project-dir&lt;/code&gt; and &lt;code&gt;cmake-ide-build-dir&lt;/code&gt; variables (use absolute paths).&lt;/p&gt; &#xA;&lt;p&gt;.dir-locals.el: ((nil . ((cmake-ide-build-dir . &#34;/path/to/build/dir&#34;) (cmake-ide-project-dir . &#34;/path/to/project/dir&#34;))))&lt;/p&gt; &#xA;&lt;p&gt;If a file called &lt;code&gt;compile_commands.json&lt;/code&gt; exists in &lt;code&gt;cmake-ide-build-dir&lt;/code&gt;, it will work just as well as for CMake projects. Bear (&lt;a href=&#34;https://github.com/rizsotto/Bear&#34;&gt;https://github.com/rizsotto/Bear&lt;/a&gt;) can be used to generate a compile_commands.json from a make command.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install from &lt;a href=&#34;https://melpa.org&#34;&gt;MELPA&lt;/a&gt; or &lt;a href=&#34;https://stable.melpa.org/&#34;&gt;MELPA Stable&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x package-install RET cmake-ide.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Add this to your &lt;code&gt;.emacs&lt;/code&gt; / &lt;code&gt;init.el&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;rtags) ;; optional, must have rtags installed&#xA;(cmake-ide-setup)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;cmake-ide-flags-c&lt;/code&gt; or &lt;code&gt;cmake-ide-flags-c++&lt;/code&gt; are set, they will be added to &lt;code&gt;ac-clang-flags&lt;/code&gt; and &lt;code&gt;company-clang-arguments&lt;/code&gt;. These variables should be set. Particularly, they should contain the system include paths (e.g. &lt;code&gt;&#39;(&#34;-I/usr/include/c++/4.9.1&#34; &#34;...&#34;)&lt;/code&gt;. For a system with gcc, you can get this information by running &lt;code&gt;gcc -v -xc++ /dev/null -fsyntax-only&lt;/code&gt; (it&#39;s the same prerequisite for &lt;code&gt;auto-complete-clang&lt;/code&gt; to work, since that&#39;s how clang itself works).&lt;/p&gt; &#xA;&lt;p&gt;And... that&#39;s it. It works by calling cmake and parsing the resulting JSON file with compiler flags. Set &lt;code&gt;cmake-ide-build-dir&lt;/code&gt; to where your project is being built and you won&#39;t have to call CMake manually again (except for the first time to specify options). Best done with &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html&#34;&gt;directory local variables&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Related Projects:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/redguardtoo/cpputils-cmake&#34;&gt;cpputils-cmake&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>atgreen/emacs</title>
    <updated>2023-10-22T01:51:05Z</updated>
    <id>tag:github.com,2023-10-22:/atgreen/emacs</id>
    <link href="https://github.com/atgreen/emacs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;My emacs config&lt;/p&gt;&lt;hr&gt;&lt;p&gt;;; ========================================================================= ;; Anthony Green&#39;s GNU Emacs configuration file. ;; ;; Copyright (C) 2009 Anthony Green &lt;a href=&#34;mailto:green@moxielogic.com&#34;&gt;green@moxielogic.com&lt;/a&gt; ;; ;; This file is free software: you can redistribute it and/or modify ;; it under the terms of the GNU General Public License as published ;; by the Free Software Foundation, either version 3 of the License, ;; or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;;; This file is distributed in the hope that it will be useful, but ;; WITHOUT ANY WARRANTY; without even the implied warranty of ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU ;; General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;;; You should have received a copy of the GNU General Public License ;; along with this file. If not, see &lt;a href=&#34;http://www.gnu.org/licenses/&#34;&gt;http://www.gnu.org/licenses/&lt;/a&gt;. ;; =========================================================================&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>smellsblue/my-emacs-env</title>
    <updated>2023-10-22T01:51:05Z</updated>
    <id>tag:github.com,2023-10-22:/smellsblue/my-emacs-env</id>
    <link href="https://github.com/smellsblue/my-emacs-env" rel="alternate"></link>
    <summary type="html">&lt;p&gt;My Emacs environment&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Remote Load&lt;/h1&gt; &#xA;&lt;p&gt;To load this environment remotely, simply execute the following from within emacs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(let* ((url &#34;https://raw.github.com/smellsblue/my-emacs-env/master/remote-load.el&#34;)&#xA;       (remote-buffer (url-retrieve-synchronously url)))&#xA;  (switch-to-buffer remote-buffer)&#xA;  (goto-char (point-min))&#xA;  (re-search-forward &#34;^$&#34; nil &#39;move)&#xA;  (delete-region (point-min) (1+ (point)))&#xA;  (eval-buffer)&#xA;  (kill-buffer remote-buffer))&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>