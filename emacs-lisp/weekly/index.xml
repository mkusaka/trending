<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-09T01:54:10Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tumashu/posframe</title>
    <updated>2023-07-09T01:54:10Z</updated>
    <id>tag:github.com,2023-07-09:/tumashu/posframe</id>
    <link href="https://github.com/tumashu/posframe" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Pop a posframe (just a child-frame) at point, posframe is a **GNU ELPA** package!&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Created 2021-06-01 Tue 10:41&lt;/h1&gt; &#xA;&lt;p&gt;#+TITLE: Pop a posframe (just a frame) at point #+AUTHOR: Feng Shu&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;http://elpa.gnu.org/packages/posframe.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/posframe.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/devel/posframe.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/posframe.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/posframe&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/posframe-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;What is posframe? Posframe can pop up a frame at point, this &lt;em&gt;posframe&lt;/em&gt; is a child-frame connected to its root window&#39;s buffer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The main advantages are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;It is fast enough for daily usage :-)&lt;/li&gt; &#xA; &lt;li&gt;It works well with CJK languages.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;NOTE:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;For MacOS users, posframe needs Emacs version &amp;gt;= 26.0.91&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;GNOME users with GTK3 builds need Emacs 27 or later. See variable `posframe-gtk-resize-child-frames&#39; which auto-detects this configuration.&lt;/p&gt; &lt;p&gt;More details:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;[[https://git.savannah.gnu.org/cgit/emacs.git/commit/?h=emacs-27&amp;amp;id=c49d379f17bcb0ce82604def2eaa04bda00bd5ec][Fix some problems with moving and resizing child frames]]&lt;/li&gt; &#xA;   &lt;li&gt;[[https://lists.gnu.org/archive/html/emacs-devel/2020-01/msg00343.html][Emacs&#39;s set-frame-size can not work well with gnome-shell?]]&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;[[file:./snapshots/posframe-1.png]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_example (require &#39;posframe) #+end_example&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Create a posframe&lt;/p&gt; &#xA;&lt;p&gt;*** Simple way #+begin_example (when (posframe-workable-p) (posframe-show &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34; :string &#34;This is a test&#34; :position (point))) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;*** Advanced way #+begin_example (defvar my-posframe-buffer &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;)&lt;/p&gt; &#xA;&lt;p&gt;(with-current-buffer (get-buffer-create my-posframe-buffer) (erase-buffer) (insert &#34;Hello world&#34;))&lt;/p&gt; &#xA;&lt;p&gt;(when (posframe-workable-p) (posframe-show my-posframe-buffer :position (point))) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;*** Arguments&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example C-h f posframe-show #+end_example&lt;/p&gt; &#xA;&lt;p&gt;** Hide a posframe #+begin_example (posframe-hide &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;** Hide all posframes #+begin_example M-x posframe-hide-all #+end_example&lt;/p&gt; &#xA;&lt;p&gt;** Delete a posframe&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Delete posframe and its buffer #+begin_example (posframe-delete &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;) #+end_example&lt;/li&gt; &#xA; &lt;li&gt;Only delete the frame #+begin_example (posframe-delete-frame &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;) #+end_example ** Delete all posframes #+begin_example M-x posframe-delete-all #+end_example&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note: this command will delete all posframe buffers. You probably shouldn&#39;t use it if you are sharing a buffer between posframe and other packages.&lt;/p&gt; &#xA;&lt;p&gt;** posframe-arghandler&lt;/p&gt; &#xA;&lt;p&gt;posframe-arghandler feature has been removed from posframe-1.1, user can use advice feature instead.&lt;/p&gt; &#xA;&lt;p&gt;** Mouse banish Default setting will work well in most case, but for EXWM user, suggest use the below config.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq posframe-mouse-banish-function #&#39;posframe-mouse-banish-simple) #+end_src&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>abo-abo/avy</title>
    <updated>2023-07-09T01:54:10Z</updated>
    <id>tag:github.com,2023-07-09:/abo-abo/avy</id>
    <link href="https://github.com/abo-abo/avy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Jump to things in Emacs tree-style&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://elpa.gnu.org/packages/avy.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/packages/avy.svg?sanitize=true&#34; alt=&#34;GNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/avy&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/avy-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/avy&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/avy-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;avy&lt;/code&gt; is a GNU Emacs package for jumping to visible text using a char-based decision tree. See also &lt;a href=&#34;https://github.com/winterTTr/ace-jump-mode&#34;&gt;ace-jump-mode&lt;/a&gt; and &lt;a href=&#34;https://github.com/Lokaltog/vim-easymotion&#34;&gt;vim-easymotion&lt;/a&gt; - &lt;code&gt;avy&lt;/code&gt; uses the same idea.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/abo-abo/avy/images/avy-avatar-1.png&#34; alt=&#34;logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Command overview&lt;/h2&gt; &#xA;&lt;p&gt;You can bind some of these useful commands in your config.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-char&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input one char, jump to it with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;C-:&#34;) &#39;avy-goto-char)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After &lt;kbd&gt;C-: b&lt;/kbd&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/nloyola/avy/images/avy-goto-char.png&#34; alt=&#34;avy-goto-char&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-char-2&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input two consecutive chars, jump to the first one with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The advantage over the previous one is less candidates for the tree search. And it&#39;s not too inconvenient to enter two consecutive chars instead of one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;C-&#39;&#34;) &#39;avy-goto-char-2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After &lt;kbd&gt;C-&#39; bu&lt;/kbd&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://oremacs.com/download/avi-goto-char-2.png&#34; alt=&#34;avy-goto-char-2&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-char-timer&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input an arbitrary amount of consecutive chars, jump to the first one with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This is a more flexible version of &lt;code&gt;avy-goto-char-2&lt;/code&gt;. First part works similarly to &lt;code&gt;isearch&lt;/code&gt;: you type a query and it&#39;s highlighted dynamically on the screen. When you stop typing for &lt;code&gt;avy-timeout-seconds&lt;/code&gt; (0.5s by default), you&#39;ll be able to select one of the candidates with &lt;code&gt;avy&lt;/code&gt;. As you&#39;re inputting characters, you can use &lt;code&gt;C-h&lt;/code&gt; (backspace) or &lt;code&gt;DEL&lt;/code&gt; (delete) to forget the last typed character and &lt;code&gt;RET&lt;/code&gt; to end the input sequence immediately and select a candidate.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-line&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input zero chars, jump to a line start with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;M-g f&#34;) &#39;avy-goto-line)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After &lt;kbd&gt;M-g f&lt;/kbd&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://oremacs.com/download/avi-goto-line.png&#34; alt=&#34;avy-goto-line&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can actually replace the &lt;kbd&gt;M-g g&lt;/kbd&gt; binding of &lt;code&gt;goto-line&lt;/code&gt;, since if you enter a digit for &lt;code&gt;avy-goto-line&lt;/code&gt;, it will switch to &lt;code&gt;goto-line&lt;/code&gt; with that digit already entered.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-word-1&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input one char at word start, jump to a word start with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;M-g w&#34;) &#39;avy-goto-word-1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After &lt;kbd&gt;M-g wb&lt;/kbd&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://oremacs.com/download/avi-goto-word-1.png&#34; alt=&#34;avy-goto-word-1&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-word-0&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input zero chars, jump to a word start with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Compared to &lt;code&gt;avy-goto-word-1&lt;/code&gt;, there are a lot more candidates. But at a least there&#39;s not need to input the initial char.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;M-g e&#34;) &#39;avy-goto-word-0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After &lt;kbd&gt;M-g e&lt;/kbd&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://oremacs.com/download/avi-goto-word-0.png&#34; alt=&#34;avy-goto-word-0&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Org-mode commands&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;avy-org-goto-heading-timer&lt;/code&gt;: Type part of an Org heading. When you stop typing, if only one heading on the screen matches, it will be jumped to; if more than one matches, you can jump to a heading with Avy. This is like &lt;code&gt;avy-goto-char-timer&lt;/code&gt; but for Org headings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;avy-org-refile-as-child&lt;/code&gt;: With point in an entry you want to refile, run this command, select a heading with Avy, and the entry will be refiled as its first child heading. This makes it quick and easy to refile to headings that are visible on-screen, even to other windows or buffers.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Other commands&lt;/h3&gt; &#xA;&lt;p&gt;There are some more commands which you can explore yourself by looking at the code.&lt;/p&gt; &#xA;&lt;h3&gt;Bindings&lt;/h3&gt; &#xA;&lt;p&gt;You add this to your config to bind some stuff:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(avy-setup-default)&#xA;(global-set-key (kbd &#34;C-c C-j&#34;) &#39;avy-resume)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It will bind, for example, &lt;code&gt;avy-isearch&lt;/code&gt; to &lt;kbd&gt;C-&#39;&lt;/kbd&gt; in &lt;code&gt;isearch-mode-map&lt;/code&gt;, so that you can select one of the currently visible &lt;code&gt;isearch&lt;/code&gt; candidates using &lt;code&gt;avy&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Customization&lt;/h3&gt; &#xA;&lt;p&gt;See the comprehensive custom variable list on &lt;a href=&#34;https://github.com/abo-abo/avy/wiki/defcustom&#34;&gt;the defcustom wiki page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See how to write your own avy commands on &lt;a href=&#34;https://github.com/abo-abo/avy/wiki/custom-commands&#34;&gt;the custom-commands wiki page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;h3&gt;Copyright Assignment&lt;/h3&gt; &#xA;&lt;p&gt;Avy is subject to the same &lt;a href=&#34;http://www.gnu.org/prep/maintain/html_node/Copyright-Papers.html&#34;&gt;copyright assignment&lt;/a&gt; policy as Emacs itself, org-mode, CEDET and other packages in &lt;a href=&#34;http://elpa.gnu.org/packages/&#34;&gt;GNU ELPA&lt;/a&gt;. Any &lt;a href=&#34;http://www.gnu.org/prep/maintain/html_node/Legally-Significant.html#Legally-Significant&#34;&gt;legally significant&lt;/a&gt; contributions can only be accepted after the author has completed their paperwork. Please see &lt;a href=&#34;http://git.savannah.gnu.org/cgit/gnulib.git/tree/doc/Copyright/request-assign.future&#34;&gt;the request form&lt;/a&gt; if you want to proceed.&lt;/p&gt; &#xA;&lt;p&gt;The copyright assignment isn&#39;t a big deal, it just says that the copyright for your submitted changes to Emacs belongs to the FSF. This assignment works for all projects related to Emacs. To obtain it, you need to send one email, then send one letter (if you live in the US, it&#39;s digital), and wait for some time (in my case, I had to wait for one month).&lt;/p&gt; &#xA;&lt;h3&gt;Style&lt;/h3&gt; &#xA;&lt;p&gt;The basic code style guide is to use &lt;code&gt;(setq indent-tabs-mode nil)&lt;/code&gt;. It is provided for you in &lt;a href=&#34;https://github.com/abo-abo/avy/raw/master/.dir-locals.el&#34;&gt;.dir-locals.el&lt;/a&gt;, please obey it.&lt;/p&gt; &#xA;&lt;p&gt;Before submitting the change, run &lt;code&gt;make compile&lt;/code&gt; and &lt;code&gt;make test&lt;/code&gt; to make sure that it doesn&#39;t introduce new compile warnings or test failures. Also run &lt;code&gt;make checkdoc&lt;/code&gt; to see that your changes obey the documentation guidelines.&lt;/p&gt; &#xA;&lt;p&gt;Use your own judgment for the commit messages, I recommend a verbose style using &lt;code&gt;magit-commit-add-log&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>rejeep/f.el</title>
    <updated>2023-07-09T01:54:10Z</updated>
    <id>tag:github.com,2023-07-09:/rejeep/f.el</id>
    <link href="https://github.com/rejeep/f.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Modern API for working with files and directories in Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;-&lt;em&gt;- mode: org -&lt;/em&gt;-&lt;/h1&gt; &#xA;&lt;p&gt;#+title: f.el&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/rejeep/f.el/actions/workflows/workflow.yml][file:https://github.com/rejeep/f.el/actions/workflows/workflow.yml/badge.svg]] [[https://coveralls.io/r/rejeep/f.el][file:https://img.shields.io/coveralls/rejeep/f.el.svg]] [[https://melpa.org/#/f][file:https://melpa.org/packages/f-badge.svg]] [[https://stable.melpa.org/#/f][file:https://stable.melpa.org/packages/f-badge.svg]]&lt;/p&gt; &#xA;&lt;p&gt;Much inspired by [[https://github.com/magnars][@magnars]]s excellent [[https://github.com/magnars/s.el][s.el]] and [[https://github.com/magnars/dash.el][dash.el]], [[https://github.com/rejeep/f.el][f.el]] is a modern API for working with files and directories in Emacs.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation :noexport: It’s available on [[https://melpa.org/#/f][Melpa]] and [[https://stable.melpa.org/#/f][Melpa Stable]]. #+begin_src text M-x package-install f #+end_src&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Or you can just dump &lt;del&gt;f.el&lt;/del&gt; in your load path somewhere.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Table of Contents :TOC_3_gh:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#contributing][Contributing]]&lt;/li&gt; &#xA; &lt;li&gt;[[#documentation-and-examples][Documentation and examples]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#paths][Paths]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-join][f-join]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-split][f-split]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-expand][f-expand]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-filename][f-filename]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-dirname][f-dirname]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-common-parent][f-common-parent]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-ext][f-ext]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-no-ext][f-no-ext]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-swap-ext][f-swap-ext]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-base][f-base]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-relative][f-relative]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-short][f-short]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-long][f-long]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-canonical][f-canonical]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-slash][f-slash]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-full][f-full]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-uniquify][f-uniquify]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-uniquify-alist][f-uniquify-alist]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#io][I/O]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-read-bytes][f-read-bytes]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-write-bytes][f-write-bytes]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-append-bytes][f-append-bytes]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-read-text][f-read-text]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-write-text][f-write-text]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-append-text][f-append-text]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#destructive][Destructive]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-mkdir][f-mkdir]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-mkdir-full-path][f-mkdir-full-path]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-delete][f-delete]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-symlink][f-symlink]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-move][f-move]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-copy][f-copy]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-copy-contents][f-copy-contents]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-touch][f-touch]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#predicates][Predicates]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-exists-p][f-exists-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-directory-p][f-directory-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-file-p][f-file-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-symlink-p][f-symlink-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-readable-p][f-readable-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-writable-p][f-writable-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-executable-p][f-executable-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-absolute-p][f-absolute-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-relative-p][f-relative-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-root-p][f-root-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-ext-p][f-ext-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-same-p][f-same-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-parent-of-p][f-parent-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-child-of-p][f-child-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-ancestor-of-p][f-ancestor-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-descendant-of-p][f-descendant-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-hidden-p][f-hidden-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-empty-p][f-empty-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-newer-p][f-newer-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-older-p][f-older-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-same-time-p][f-same-time-p]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#stats][Stats]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-size][f-size]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-depth][f-depth]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-change-time][f-change-time]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-modification-time][f-modification-time]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-access-time][f-access-time]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#misc][Misc]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-this-file][f-this-file]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-path-separator][f-path-separator]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-glob][f-glob]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-entries][f-entries]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-directories][f-directories]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-files][f-files]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-root][f-root]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-traverse-upwards][f-traverse-upwards]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-with-sandbox][f-with-sandbox]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#example][Example]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#using-standard-emacs-builtin-functions][Using standard Emacs builtin functions]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#using-fel][Using f.el]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Contributing Check [[file:./CONTRIBUTING.org]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Documentation and examples ** Paths *** f-join #+begin_example (f-join &amp;amp;rest args)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Join ARGS to a single path.&lt;/p&gt; &#xA;&lt;p&gt;Be aware if one of the arguments is an absolute path, ‘f-join’ will discard all the preceeding arguments and make this absolute path the new root of the generated path. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-join &#34;path&#34;) ;; =&amp;gt; &#34;path&#34; (f-join &#34;path&#34; &#34;to&#34;) ;; =&amp;gt; &#34;path/to&#34; (f-join &#34;/&#34; &#34;path&#34; &#34;to&#34; &#34;heaven&#34;) ;; =&amp;gt; &#34;/path/to/heaven&#34; (f-join &#34;path&#34; &#34;/to&#34; &#34;file&#34;) ;; =&amp;gt; &#34;/to/file&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-split #+begin_example (f-split path)&lt;/p&gt; &#xA;&lt;p&gt;Split PATH and return list containing parts. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-split &#34;path&#34;) ;; =&amp;gt; &#39;(&#34;path&#34;) (f-split &#34;path/to&#34;) ;; =&amp;gt; &#39;(&#34;path&#34; &#34;to&#34;) (f-split &#34;/path/to/heaven&#34;) ;; =&amp;gt; &#39;(&#34;/&#34; &#34;path&#34; &#34;to&#34; &#34;heaven&#34;) (f-split &#34;&lt;del&gt;/back/to/earth&#34;) ;; =&amp;gt; &#39;(&#34;&lt;/del&gt;&#34; &#34;back&#34; &#34;to&#34; &#34;earth&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-expand #+begin_example (f-expand path &amp;amp;optional dir)&lt;/p&gt; &#xA;&lt;p&gt;Expand PATH relative to DIR (or ‘default-directory’). PATH and DIR can be either a directory names or directory file names. Return a directory name if PATH is a directory name, and a directory file name otherwise. File name handlers are ignored. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-expand &#34;name&#34;) ;; =&amp;gt; &#34;/default/directory/name&#34; (f-expand &#34;name&#34; &#34;other/directory&#34;) ;; =&amp;gt; &#34;other/directory/name&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-filename #+begin_example (f-filename path)&lt;/p&gt; &#xA;&lt;p&gt;Return the name of PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-filename &#34;path/to/file.ext&#34;) ;; =&amp;gt; &#34;file.ext&#34; (f-filename &#34;path/to/directory&#34;) ;; =&amp;gt; &#34;directory&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-dirname #+begin_example (f-dirname path)&lt;/p&gt; &#xA;&lt;p&gt;Return the parent directory to PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-parent&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-dirname &#34;path/to/file.ext&#34;) ;; =&amp;gt; &#34;path/to&#34; (f-dirname &#34;path/to/directory&#34;) ;; =&amp;gt; &#34;path/to&#34; (f-dirname &#34;/&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-common-parent #+begin_example (f-common-parent paths)&lt;/p&gt; &#xA;&lt;p&gt;Return the deepest common parent directory of PATHS. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-common-parent &#39;(&#34;foo/bar/baz&#34; &#34;foo/bar/qux&#34; &#34;foo/bar/mux&#34;)) ;; =&amp;gt; &#34;foo/bar/&#34; (f-common-parent &#39;(&#34;/foo/bar/baz&#34; &#34;/foo/bar/qux&#34; &#34;/foo/bax/mux&#34;)) ;; =&amp;gt; &#34;/foo/&#34; (f-common-parent &#39;(&#34;foo/bar/baz&#34; &#34;quack/bar/qux&#34; &#34;lack/bar/mux&#34;)) ;; =&amp;gt; &#34;&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-ext #+begin_example (f-ext path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-name-extension&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-ext &#34;path/to/file&#34;) ;; =&amp;gt; nil (f-ext &#34;path/to/file.txt&#34;) ;; =&amp;gt; txt (f-ext &#34;path/to/file.txt.org&#34;) ;; =&amp;gt; org #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-no-ext #+begin_example (f-no-ext path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-name-sans-extension&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-no-ext &#34;path/to/file&#34;) ;; =&amp;gt; path/to/file (f-no-ext &#34;path/to/file.txt&#34;) ;; =&amp;gt; path/to/file (f-no-ext &#34;path/to/file.txt.org&#34;) ;; =&amp;gt; path/to/file.txt #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-swap-ext #+begin_example (f-swap-ext path ext)&lt;/p&gt; &#xA;&lt;p&gt;Return PATH but with EXT as the new extension. EXT must not be nil or empty. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-swap-ext &#34;path/to/file.ext&#34; &#34;org&#34;) ;; =&amp;gt; &#34;path/to/file.org&#34; (f-swap-ext &#34;path/to/file.ext&#34; &#34;&#34;) ;; =&amp;gt; error #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-base #+begin_example (f-base path)&lt;/p&gt; &#xA;&lt;p&gt;Return the name of PATH, excluding the extension of file. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-base &#34;path/to/file.ext&#34;) ;; =&amp;gt; &#34;file&#34; (f-base &#34;path/to/directory&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-relative #+begin_example (f-relative path &amp;amp;optional dir)&lt;/p&gt; &#xA;&lt;p&gt;Convert FILENAME to be relative to DIRECTORY (default: ‘default-directory’). This function returns a relative file name that is equivalent to FILENAME when used with that default directory as the default. If FILENAME is a relative file name, it will be interpreted as existing in ‘default-directory’. If FILENAME and DIRECTORY lie on different machines or on different drives on a DOS/Windows machine, it returns FILENAME in expanded form.&lt;/p&gt; &#xA;&lt;p&gt;(fn FILENAME &amp;amp;optional DIRECTORY) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-relative &#34;/some/path/relative/to/my/file.txt&#34; &#34;/some/path/&#34;) ;; =&amp;gt; relative/to/my/file.txt (f-relative &#34;/default/directory/my/file.txt&#34;) ;; =&amp;gt; my/file.txt #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-short #+begin_example (f-short path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;abbreviate-file-name&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-abbrev&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-short &#34;/Users/foo/Code/bar&#34;) ;; =&amp;gt; ~/Code/bar (f-short &#34;/path/to/Code/bar&#34;) ;; =&amp;gt; /path/to/Code/bar #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-long #+begin_example (f-long path)&lt;/p&gt; &#xA;&lt;p&gt;Return long version of PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-long &#34;~/Code/bar&#34;) ;; =&amp;gt; /Users/foo/Code/bar (f-long &#34;/path/to/Code/bar&#34;) ;; =&amp;gt; /path/to/Code/bar #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-canonical #+begin_example (f-canonical path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-truename&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-canonical &#34;/path/to/real/file&#34;) ;; =&amp;gt; /path/to/real/file (f-canonical &#34;/link/to/file&#34;) ;; =&amp;gt; /path/to/real/file #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-slash #+begin_example (f-slash path)&lt;/p&gt; &#xA;&lt;p&gt;Append slash to PATH unless one already.&lt;/p&gt; &#xA;&lt;p&gt;Some functions, such as ‘call-process’ requires there to be an ending slash. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-slash &#34;/path/to/file&#34;) ;; =&amp;gt; /path/to/file (f-slash &#34;/path/to/dir&#34;) ;; =&amp;gt; /path/to/dir/ (f-slash &#34;/path/to/dir/&#34;) ;; =&amp;gt; /path/to/dir/ #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-full #+begin_example (f-full path)&lt;/p&gt; &#xA;&lt;p&gt;Return absolute path to PATH, with ending slash. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-full &#34;&lt;del&gt;/path/to/file&#34;) ;; =&amp;gt; /home/foo/path/to/file (f-full &#34;&lt;/del&gt;/path/to/dir&#34;) ;; =&amp;gt; /home/foo/path/to/dir/ (f-full &#34;~/path/to/dir/&#34;) ;; =&amp;gt; /home/foo/path/to/dir/ #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-uniquify #+begin_example (f-uniquify paths)&lt;/p&gt; &#xA;&lt;p&gt;Return unique suffixes of FILES.&lt;/p&gt; &#xA;&lt;p&gt;This function expects no duplicate paths. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;(&#34;bar&#34; &#34;baz&#34; &#34;quux&#34;) (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;(&#34;foo/bar&#34; &#34;www/bar&#34; &#34;quux&#34;) (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/www/bar/quux&#34;)) ;; =&amp;gt; &#39;(&#34;foo/bar&#34; &#34;www/bar&#34; &#34;quux&#34;) (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/home/www/bar&#34; &#34;/home/www/baz&#34; &#34;/var/foo&#34; &#34;/opt/foo/www/baz&#34;)) ;; =&amp;gt; &#39;(&#34;foo/bar&#34; &#34;www/bar&#34; &#34;foo/baz&#34; &#34;home/www/baz&#34; &#34;foo/www/baz&#34; &#34;foo&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-uniquify-alist #+begin_example (f-uniquify-alist paths)&lt;/p&gt; &#xA;&lt;p&gt;Return alist mapping FILES to unique suffixes of FILES.&lt;/p&gt; &#xA;&lt;p&gt;This function expects no duplicate paths. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;bar&#34;) (&#34;/foo/baz&#34; . &#34;baz&#34;) (&#34;/foo/quux&#34; . &#34;quux&#34;)) (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;foo/bar&#34;) (&#34;/www/bar&#34; . &#34;www/bar&#34;) (&#34;/foo/quux&#34; . &#34;quux&#34;)) (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/www/bar/quux&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;foo/bar&#34;) (&#34;/www/bar&#34; . &#34;www/bar&#34;) (&#34;/www/bar/quux&#34; . &#34;quux&#34;)) (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/home/www/bar&#34; &#34;/home/www/baz&#34; &#34;/var/foo&#34; &#34;/opt/foo/www/baz&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;foo/bar&#34;) (&#34;/home/www/bar&#34; . &#34;www/bar&#34;) (&#34;/foo/baz&#34; . &#34;foo/baz&#34;) (&#34;/home/www/baz&#34; . &#34;home/www/baz&#34;) (&#34;/opt/foo/www/baz&#34; . &#34;foo/www/baz&#34;) (&#34;/var/foo&#34; . &#34;foo&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** I/O *** f-read-bytes #+begin_example (f-read-bytes path)&lt;/p&gt; &#xA;&lt;p&gt;Read binary data from PATH.&lt;/p&gt; &#xA;&lt;p&gt;Return the binary data as unibyte string. The optional second and third arguments BEG and END specify what portion of the file to read. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-read-bytes &#34;path/to/binary/data&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-write-bytes #+begin_example (f-write-bytes data path)&lt;/p&gt; &#xA;&lt;p&gt;Write binary DATA to PATH.&lt;/p&gt; &#xA;&lt;p&gt;DATA is a unibyte string. PATH is a file name to write to. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-write-bytes (unibyte-string 72 101 108 108 111 32 119 111 114 108 100) &#34;path/to/binary/data&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-append-bytes #+begin_example (f-append-bytes text coding path)&lt;/p&gt; &#xA;&lt;p&gt;Append binary DATA to PATH.&lt;/p&gt; &#xA;&lt;p&gt;If PATH does not exist, it is created. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-append-bytes &#34;path/to/file&#34; (unibyte-string 72 101 108 108 111 32 119 111 114 108 100)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-read-text #+begin_example (f-read-text path &amp;amp;optional coding)&lt;/p&gt; &#xA;&lt;p&gt;Read text with PATH, using CODING.&lt;/p&gt; &#xA;&lt;p&gt;CODING defaults to ‘utf-8’.&lt;/p&gt; &#xA;&lt;p&gt;Return the decoded text as multibyte string. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-read&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-read-text &#34;path/to/file.txt&#34; &#39;utf-8) (f-read &#34;path/to/file.txt&#34; &#39;utf-8) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-write-text #+begin_example (f-write-text text coding path)&lt;/p&gt; &#xA;&lt;p&gt;Write TEXT with CODING to PATH.&lt;/p&gt; &#xA;&lt;p&gt;TEXT is a multibyte string. CODING is a coding system to encode TEXT with. PATH is a file name to write to. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-write&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-write-text &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) (f-write &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-append-text #+begin_example (f-append-text text coding path)&lt;/p&gt; &#xA;&lt;p&gt;Append TEXT with CODING to PATH.&lt;/p&gt; &#xA;&lt;p&gt;If PATH does not exist, it is created. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-append&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-append-text &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) (f-append &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Destructive *** f-mkdir #+begin_example (f-mkdir &amp;amp;rest dirs)&lt;/p&gt; &#xA;&lt;p&gt;Create directories DIRS.&lt;/p&gt; &#xA;&lt;p&gt;DIRS should be a successive list of directories forming together a full path. The easiest way to call this function with a fully formed path is using ‘f-split’ alongside it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(apply #&#39;f-mkdir (f-split &#34;path/to/file&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Although it works sometimes, it is not recommended to use fully formed paths in the function. In this case, it is recommended to use ‘f-mkdir-full-path’ instead. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-mkdir &#34;dir&#34;) ;; creates /default/directory/dir (f-mkdir &#34;other&#34; &#34;dir&#34;) ;; creates /default/directory/other/dir (f-mkdir &#34;/&#34; &#34;some&#34; &#34;path&#34;) ;; creates /some/path (f-mkdir &#34;~&#34; &#34;yet&#34; &#34;another&#34; &#34;dir&#34;) ;; creates ~/yet/another/dir #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-mkdir-full-path #+begin_example (f-mkdir-full-path dir)&lt;/p&gt; &#xA;&lt;p&gt;Create DIR from a full path.&lt;/p&gt; &#xA;&lt;p&gt;This function is similar to ‘f-mkdir’ except it can accept a full path instead of requiring several successive directory names. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-mkdir-full-path &#34;dir&#34;) ;; creates /default/directory/dir (f-mkdir-full-path &#34;other/dir&#34;) ;; creates /default/directory/other/dir (f-mkdir-full-path &#34;/some/path&#34;) ;; creates /some/path (f-mkdir-full-path &#34;~/yet/another/dir&#34;) ;; creates ~/yet/another/dir #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-delete #+begin_example (f-delete path &amp;amp;optional force)&lt;/p&gt; &#xA;&lt;p&gt;Delete PATH, which can be file or directory.&lt;/p&gt; &#xA;&lt;p&gt;If FORCE is t, a directory will be deleted recursively. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-delete &#34;dir&#34;) (f-delete &#34;other/dir&#34; t) (f-delete &#34;path/to/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-symlink #+begin_example (f-symlink source path)&lt;/p&gt; &#xA;&lt;p&gt;Create a symlink to SOURCE from PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-symlink &#34;path/to/source&#34; &#34;path/to/link&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-move #+begin_example (f-move from to)&lt;/p&gt; &#xA;&lt;p&gt;Move or rename FROM to TO. If TO is a directory name, move FROM into TO. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-move &#34;path/to/file.txt&#34; &#34;new-file.txt&#34;) (f-move &#34;path/to/file.txt&#34; &#34;other/path&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-copy #+begin_example (f-copy from to)&lt;/p&gt; &#xA;&lt;p&gt;Copy file or directory FROM to TO. If FROM names a directory and TO is a directory name, copy FROM into TO as a subdirectory. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-copy &#34;path/to/file.txt&#34; &#34;new-file.txt&#34;) (f-copy &#34;path/to/dir&#34; &#34;other/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-copy-contents #+begin_example (f-copy-contents from to)&lt;/p&gt; &#xA;&lt;p&gt;Copy contents in directory FROM, to directory TO. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-copy-contents &#34;path/to/dir&#34; &#34;path/to/other/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-touch #+begin_example (f-touch path)&lt;/p&gt; &#xA;&lt;p&gt;Update PATH last modification date or create if it does not exist. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-touch &#34;path/to/existing/file.txt&#34;) (f-touch &#34;path/to/non/existing/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Predicates *** f-exists-p #+begin_example (f-exists-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-exists-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-exists?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-exists-p &#34;path/to/file.txt&#34;) (f-exists-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-directory-p #+begin_example (f-directory-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-directory-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Aliases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;f-directory?&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-dir-p&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-dir?&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-directory-p &#34;path/to/file.txt&#34;) ;; =&amp;gt; nil (f-directory-p &#34;path/to/dir&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-file-p #+begin_example (f-file-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-regular-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-file?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-file-p &#34;path/to/file.txt&#34;) ;; =&amp;gt; t (f-file-p &#34;path/to/dir&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-symlink-p #+begin_example (f-symlink-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is symlink, false otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-symlink?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-symlink-p &#34;path/to/file.txt&#34;) ;; =&amp;gt; nil (f-symlink-p &#34;path/to/dir&#34;) ;; =&amp;gt; nil (f-symlink-p &#34;path/to/link&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-readable-p #+begin_example (f-readable-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-readable-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-readable?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-readable-p &#34;path/to/file.txt&#34;) (f-readable-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-writable-p #+begin_example (f-writable-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-writable-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-writable?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-writable-p &#34;path/to/file.txt&#34;) (f-writable-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-executable-p #+begin_example (f-executable-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-executable-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-executable?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-executable-p &#34;path/to/file.txt&#34;) (f-executable-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-absolute-p #+begin_example (f-absolute-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-name-absolute-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-absolute?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-absolute-p &#34;path/to/dir&#34;) ;; =&amp;gt; nil (f-absolute-p &#34;/full/path/to/dir&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-relative-p #+begin_example (f-relative-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is relative, false otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-relative?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-relative-p &#34;path/to/dir&#34;) ;; =&amp;gt; t (f-relative-p &#34;/full/path/to/dir&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-root-p #+begin_example (f-root-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is root directory, false otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-root?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-root-p &#34;/&#34;) ;; =&amp;gt; t (f-root-p &#34;/not/root&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-ext-p #+begin_example (f-ext-p path ext)&lt;/p&gt; &#xA;&lt;p&gt;Return t if extension of PATH is EXT, false otherwise.&lt;/p&gt; &#xA;&lt;p&gt;If EXT is nil or omitted, return t if PATH has any extension, false otherwise.&lt;/p&gt; &#xA;&lt;p&gt;The extension, in a file name, is the part that follows the last ’.’, excluding version numbers and backup suffixes. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-ext?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-ext-p &#34;path/to/file.el&#34; &#34;el&#34;) ;; =&amp;gt; t (f-ext-p &#34;path/to/file.el&#34; &#34;txt&#34;) ;; =&amp;gt; nil (f-ext-p &#34;path/to/file.el&#34;) ;; =&amp;gt; t (f-ext-p &#34;path/to/file&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-same-p #+begin_example (f-same-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A and PATH-B are references to same file. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Aliases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;f-same?&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-equal-p&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-equal?&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-same-p &#34;foo.txt&#34; &#34;foo.txt&#34;) ;; =&amp;gt; t (f-same-p &#34;/path/to/foo.txt&#34; &#34;/path/to/bar.txt&#34;) ;; =&amp;gt; nil (f-same-p &#34;foo/bar/../baz&#34; &#34;foo/baz&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-parent-of-p #+begin_example (f-parent-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is parent of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-parent-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-parent-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; t (f-parent-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil (f-parent-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-child-of-p #+begin_example (f-child-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is child of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-child-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-child-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; nil (f-child-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; t (f-child-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-ancestor-of-p #+begin_example (f-ancestor-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is ancestor of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-ancestor-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-ancestor-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; t (f-ancestor-of-p &#34;/path&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; t (f-ancestor-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil (f-ancestor-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-descendant-of-p #+begin_example (f-descendant-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is desendant of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-descendant-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-descendant-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; t (f-descendant-of-p &#34;/path/to/dir&#34; &#34;/path&#34;) ;; =&amp;gt; t (f-descendant-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; nil (f-descendant-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-hidden-p #+begin_example (f-hidden-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is hidden, nil otherwise.&lt;/p&gt; &#xA;&lt;p&gt;BEHAVIOR controls when a path should be considered as hidden depending on its value. Beware, if PATH begins with &#34;./&#34;, the current dir &#34;.&#34; will not be considered as hidden.&lt;/p&gt; &#xA;&lt;p&gt;When BEHAVIOR is nil, it will only check if the path begins with a dot, as in .a/b/c, and return t if there is one. This is the old behavior of f.el left as default for backward-compatibility purposes.&lt;/p&gt; &#xA;&lt;p&gt;When BEHAVIOR is ANY, return t if any of the elements of PATH is hidden, nil otherwise.&lt;/p&gt; &#xA;&lt;p&gt;When BEHAVIOR is LAST, return t only if the last element of PATH is hidden, nil otherwise.&lt;/p&gt; &#xA;&lt;p&gt;TODO: Hidden directories and files on Windows are marked differently than on *NIX systems. This should be properly implemented. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-hidden?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-hidden-p &#34;path/to/foo&#34;) ;; =&amp;gt; nil (f-hidden-p &#34;.path/to/foo&#34;) ;; =&amp;gt; t (f-hidden-p &#34;path/.to/foo&#34;) ;; =&amp;gt; nil (f-hidden-p &#34;path/to/.foo&#34;) ;; =&amp;gt; nil (f-hidden-p &#34;.path/to/foo&#34; &#39;any) ;; =&amp;gt; t (f-hidden-p &#34;path/.to/foo&#34; &#39;any) ;; =&amp;gt; t (f-hidden-p &#34;path/to/.foo&#34; &#39;any) ;; =&amp;gt; t (f-hidden-p &#34;.path/to/foo&#34; &#39;last) ;; =&amp;gt; nil (f-hidden-p &#34;path/.to/foo&#34; &#39;last) ;; =&amp;gt; nil (f-hidden-p &#34;path/to/.foo&#34; &#39;last) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-empty-p #+begin_example (f-empty-p path)&lt;/p&gt; &#xA;&lt;p&gt;If PATH is a file, return t if the file in PATH is empty, nil otherwise. If PATH is directory, return t if directory has no files, nil otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-empty?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-empty-p &#34;/path/to/empty-file&#34;) ;; =&amp;gt; t (f-empty-p &#34;/path/to/file-with-contents&#34;) ;; =&amp;gt; nil (f-empty-p &#34;/path/to/empty-dir/&#34;) ;; =&amp;gt; t (f-empty-p &#34;/path/to/dir-with-contents/&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-newer-p #+begin_example (f-newer-p file other &amp;amp;optional method)&lt;/p&gt; &#xA;&lt;p&gt;Compare if FILE is newer than OTHER.&lt;/p&gt; &#xA;&lt;p&gt;For more info on METHOD, see ‘f--date-compare’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-newer?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-newer-p &#34;newer.txt&#34; &#34;older.txt&#34;) ;; t (f-newer-p &#34;older.txt&#34;&#34;newer.txt&#34; ) ;; nil (f-newer-p &#34;same1.txt&#34; &#34;same2.txt&#34;) ;; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-older-p #+begin_example (f-older-p file other &amp;amp;optional method)&lt;/p&gt; &#xA;&lt;p&gt;Compare if FILE is older than OTHER.&lt;/p&gt; &#xA;&lt;p&gt;For more info on METHOD, see ‘f--date-compare’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-older?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-older-p &#34;older.txt&#34; &#34;newer.txt&#34;) ;; t (f-older-p &#34;newer.txt&#34;&#34;older.txt&#34; ) ;; nil (f-older-p &#34;same1.txt&#34; &#34;same2.txt&#34;) ;; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-same-time-p #+begin_example (f-same-time-p file other &amp;amp;optional method)&lt;/p&gt; &#xA;&lt;p&gt;Check if FILE and OTHER share the same access or modification time.&lt;/p&gt; &#xA;&lt;p&gt;For more info on METHOD, see ‘f--date-compare’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-same-time?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-same-time-p &#34;same1.txt&#34; &#34;same2.txt&#34;) ;; t (f-same-time-p &#34;newer.txt&#34; &#34;older.txt&#34;) ;; nil (f-same-time-p &#34;older.txt&#34; &#34;newer.txt&#34;) ;; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Stats *** f-size #+begin_example (f-size path)&lt;/p&gt; &#xA;&lt;p&gt;Return size of PATH.&lt;/p&gt; &#xA;&lt;p&gt;If PATH is a file, return size of that file. If PATH is directory, return sum of all files in PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-size &#34;path/to/file.txt&#34;) (f-size &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-depth #+begin_example (f-depth path)&lt;/p&gt; &#xA;&lt;p&gt;Return the depth of PATH.&lt;/p&gt; &#xA;&lt;p&gt;At first, PATH is expanded with ‘f-expand’. Then the full path is used to detect the depth. ’/’ will be zero depth, ’/usr’ will be one depth. And so on. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-depth &#34;/&#34;) ;; 0 (f-depth &#34;/var/&#34;) ;; 1 (f-depth &#34;/usr/local/bin&#34;) ;; 3 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-change-time #+begin_example (f-change-time path &amp;amp;optional timestamp-p)&lt;/p&gt; &#xA;&lt;p&gt;Return the last status change time of PATH.&lt;/p&gt; &#xA;&lt;p&gt;The status change time (ctime) of PATH in the same format as ‘current-time’. For details on TIMESTAMP-P and the format of the returned value, see ‘f--get-time’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-change-time &#34;path/to/file.txt&#34;) ;; (25517 48756 26337 111000) (f-change-time &#34;path/to/dir&#34;) ;; (25517 57887 344657 210000) (f-change-time &#34;path/to/file.txt&#34; t) ;; (1672330868026337111 . 1000000000) (f-change-time &#34;path/to/dir&#34; t) ;; (1672339999344657210 . 1000000000) (f-change-time &#34;path/to/file.txt&#34;&#39;seconds) ;; 1672330868 (f-change-time &#34;path/to/dir&#34;&#39;seconds) ;; 1672339999 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-modification-time #+begin_example (f-modification-time path &amp;amp;optional timestamp-p)&lt;/p&gt; &#xA;&lt;p&gt;Return the last modification time of PATH. The modification time (mtime) of PATH in the same format as ‘current-time’. For details on TIMESTAMP-P and the format of the returned value, see ‘f--get-time’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-modification-time &#34;path/to/file.txt&#34;) ;; (25517 48756 26337 111000) (f-modification-time &#34;path/to/dir&#34;) ;; (25517 57887 344657 210000) (f-modification-time &#34;path/to/file.txt&#34; t) ;; (1672330868026337111 . 1000000000) (f-modification-time &#34;path/to/dir&#34; t) ;; (1672339999344657210 . 1000000000) (f-modification-time &#34;path/to/file.txt&#34; &#39;seconds) ;; 1672330868 (f-modification-time &#34;path/to/dir&#34; &#39;seconds) ;; 1672339999 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-access-time #+begin_example (f-access-time path &amp;amp;optional timestamp-p)&lt;/p&gt; &#xA;&lt;p&gt;Return the last access time of PATH. The access time (atime) of PATH is in the same format as ‘current-time’. For details on TIMESTAMP-P and the format of the returned value, see ‘f--get-time’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-access-time &#34;path/to/file.txt&#34;) ;; (25517 48756 26337 111000) (f-access-time &#34;path/to/dir&#34;) ;; (25517 57887 344657 210000) (f-access-time &#34;path/to/file.txt&#34; t) ;; (1672330868026337111 . 1000000000) (f-access-time &#34;path/to/dir&#34; t) ;; (1672339999344657210 . 1000000000) (f-access-time &#34;path/to/file.txt&#34; &#39;seconds) ;; 1672330868 (f-access-time &#34;path/to/dir&#34; &#39;seconds) ;; 1672339999 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Misc *** f-this-file #+begin_example (f-this-file)&lt;/p&gt; &#xA;&lt;p&gt;Return path to this file. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-this-file) ;; =&amp;gt; /path/to/this/file #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-path-separator #+begin_example (f-path-separator)&lt;/p&gt; &#xA;&lt;p&gt;Return path separator. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-path-separator) ;; =&amp;gt; / #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-glob #+begin_example (f-glob pattern &amp;amp;optional path)&lt;/p&gt; &#xA;&lt;p&gt;Find PATTERN in PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-glob &#34;path/to/&lt;em&gt;.el&#34;) (f-glob &#34;&lt;/em&gt;.el&#34; &#34;path/to&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-entries #+begin_example (f-entries path &amp;amp;optional fn recursive)&lt;/p&gt; &#xA;&lt;p&gt;Find all files and directories in PATH.&lt;/p&gt; &#xA;&lt;p&gt;FN - called for each found file and directory. If FN returns a thruthy value, file or directory will be included. RECURSIVE - Search for files and directories recursive. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-entries &#34;path/to/dir&#34;) (f-entries &#34;path/to/dir&#34; (lambda (file) (s-matches? &#34;test&#34; file))) (f-entries &#34;path/to/dir&#34; nil t) (f--entries &#34;path/to/dir&#34; (s-matches? &#34;test&#34; it)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-directories #+begin_example (f-directories path &amp;amp;optional fn recursive)&lt;/p&gt; &#xA;&lt;p&gt;Find all directories in PATH. See ‘f-entries’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-directories &#34;path/to/dir&#34;) (f-directories &#34;path/to/dir&#34; (lambda (dir) (equal (f-filename dir) &#34;test&#34;))) (f-directories &#34;path/to/dir&#34; nil t) (f--directories &#34;path/to/dir&#34; (equal (f-filename it) &#34;test&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-files #+begin_example (f-files path &amp;amp;optional fn recursive)&lt;/p&gt; &#xA;&lt;p&gt;Find all files in PATH. See ‘f-entries’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-files &#34;path/to/dir&#34;) (f-files &#34;path/to/dir&#34; (lambda (file) (equal (f-ext file) &#34;el&#34;))) (f-files &#34;path/to/dir&#34; nil t) (f--files &#34;path/to/dir&#34; (equal (f-ext it) &#34;el&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-root #+begin_example (f-root)&lt;/p&gt; &#xA;&lt;p&gt;Return absolute root. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-root) ;; =&amp;gt; &#34;/&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-traverse-upwards #+begin_example (f-traverse-upwards fn &amp;amp;optional path)&lt;/p&gt; &#xA;&lt;p&gt;Traverse up as long as FN return nil, starting at PATH.&lt;/p&gt; &#xA;&lt;p&gt;If FN returns a non-nil value, the path sent as argument to FN is returned. If no function callback return a non-nil value, nil is returned. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-traverse-upwards (lambda (path) (f-exists? (f-expand &#34;.git&#34; path))) start-path)&lt;/p&gt; &#xA;&lt;p&gt;(f--traverse-upwards (f-exists? (f-expand &#34;.git&#34; it)) start-path) ;; same as above #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-with-sandbox #+begin_example (f-with-sandbox path-or-paths &amp;amp;rest body)&lt;/p&gt; &#xA;&lt;p&gt;Only allow PATH-OR-PATHS and descendants to be modified in BODY. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-with-sandbox foo-path (f-touch (f-expand &#34;foo&#34; foo-path))) (f-with-sandbox (list foo-path bar-path) (f-touch (f-expand &#34;foo&#34; foo-path)) (f-touch (f-expand &#34;bar&#34; bar-path))) (f-with-sandbox foo-path (f-touch (f-expand &#34;bar&#34; bar-path))) ;; &#34;Destructive operation outside sandbox&#34; #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here&#39;s an example of a function that finds the Git project root.&lt;/p&gt; &#xA;&lt;p&gt;** Using standard Emacs builtin functions #+begin_src emacs-lisp (defun find-git-root (&amp;amp;optional dir) (unless dir (setq dir (expand-file-name (file-name-directory (buffer-file-name))))) (let ((parent (expand-file-name &#34;..&#34; dir))) (unless (equal parent dir) (if (file-exists-p (expand-file-name &#34;.git&#34; dir)) dir (find-git-root parent))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Using f.el #+begin_src emacs-lisp (defun find-git-root (&amp;amp;optional dir) (interactive) (unless dir (setq dir (f-dirname (buffer-file-name)))) (let ((parent (f-parent dir))) (unless (f-root? parent) (if (f-exists? (f-expand &#34;.git&#34; dir)) dir (find-git-root parent))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Now, try writing it even simpler yourself. Hint, check out &lt;del&gt;f-traverse-upwards&lt;/del&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>