<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-21T03:27:16Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>libjack/dotfiles</title>
    <updated>2024-04-21T03:27:16Z</updated>
    <id>tag:github.com,2024-04-21:/libjack/dotfiles</id>
    <link href="https://github.com/libjack/dotfiles" rel="alternate"></link>
    <summary type="html">&lt;p&gt;manage my dotfiles&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;dotfiles&lt;/h1&gt; &#xA;&lt;p&gt;manage my dotfiles&lt;/p&gt; &#xA;&lt;h2&gt;vim setup&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl -Sso ~/.vim/bundle/vim-pathogen/autoload/pathogen.vim https://raw.github.com/tpope/vim-pathogen/master/autoload/pathogen.vim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;prepend to vimrc:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;execute pathogen#infect()&#xA;runtime bundle/vim-pathogen/autoload/pathogen.vim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pathogen lets all other plugins startup from within bundle directory also provides :Helptags to take care of docs&lt;/p&gt; &#xA;&lt;p&gt;other plugins loaded:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;git clone &lt;a href=&#34;https://github.com/Lokaltog/vim-powerline.git&#34;&gt;https://github.com/Lokaltog/vim-powerline.git&lt;/a&gt; bundle/vim-powerline OR&lt;/li&gt; &#xA; &lt;li&gt;git clone &lt;a href=&#34;https://github.com/bling/vim-airline&#34;&gt;https://github.com/bling/vim-airline&lt;/a&gt; bundle/vim-airline&lt;/li&gt; &#xA; &lt;li&gt;git clone &lt;a href=&#34;https://github.com/ctrlpvim/ctrlp.vim&#34;&gt;https://github.com/ctrlpvim/ctrlp.vim&lt;/a&gt; bundle/ctrlp.vim&lt;/li&gt; &#xA; &lt;li&gt;git clone &lt;a href=&#34;https://github.com/scrooloose/nerdtree.git&#34;&gt;https://github.com/scrooloose/nerdtree.git&lt;/a&gt; bundle/nerdtree&lt;/li&gt; &#xA; &lt;li&gt;git clone &lt;a href=&#34;https://github.com/scrooloose/nerdcommenter.git&#34;&gt;https://github.com/scrooloose/nerdcommenter.git&lt;/a&gt; bundle/nerdcommenter&lt;/li&gt; &#xA; &lt;li&gt;git clone &lt;a href=&#34;https://github.com/ntpeters/vim-better-whitespace.git&#34;&gt;https://github.com/ntpeters/vim-better-whitespace.git&lt;/a&gt; bundle/vim-better-whitespace&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>zkry/yaml.el</title>
    <updated>2024-04-21T03:27:16Z</updated>
    <id>tag:github.com,2024-04-21:/zkry/yaml.el</id>
    <link href="https://github.com/zkry/yaml.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;YAML parser in Elisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;yaml.el&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://melpa.org/#/yaml&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/yaml-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;yaml.el is a YAML parser written in Emacs List without any external dependencies. It provides an interface similar to the Emacs JSON parsing utility. The functions provided are as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(yaml-parse-string string &amp;amp;rest args)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following keyword args are accepted:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:object-type&lt;/code&gt; specifies the Lisp data structure to store parsed objects data in. It takes the following symbols: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;hash-table&lt;/code&gt; (default)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;alist&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;plist&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:object-key-type&lt;/code&gt; specifies how map keys should be handled. It takes the following symbols: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;string&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;symbol&lt;/code&gt; (default) Use symbols as keys. If &lt;code&gt;:object-type&lt;/code&gt; is &lt;code&gt;plist&lt;/code&gt;, this becomes the same as &lt;code&gt;keyword&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;keyword&lt;/code&gt; Always use keywords as keys.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:sequence-type&lt;/code&gt; specifies the Lisp data structure to store the parsed sequences in. It takes the following symbols: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;array&lt;/code&gt; (default)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;list&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:null-object&lt;/code&gt; specifies the lisp object to use for nulls. Defaults to the symbol &lt;code&gt;:null&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:false-object&lt;/code&gt; specifies the lisp object to use for false. Defaults to the symbol &lt;code&gt;:false&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(yaml-encode object)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function &lt;code&gt;yaml-encode&lt;/code&gt; will encode a Lisp object to a YAML string.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Until this is published to MELPA you will need to use the code from this repo directly. You can put yaml.el in you load path directly or use a tool like use-package or straight.el.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;yaml)&#xA;&#xA;(yaml-parse-string &#34;&#xA;recipe:&#xA;  ingredients:&#xA;  - milk&#xA;  - eggs&#xA;  - oil&#xA;  - flour&#xA;  duration: 10&#xA;  steps: null&#34; :object-type &#39;alist&#xA;               :sequence-type &#39;array&#xA;               :null-object :empty)&#xA;&#xA;;; =&amp;gt; ((&#34;recipe&#34; (&#34;ingredients&#34; . [&#34;milk&#34; &#34;eggs&#34; &#34;oil&#34; &#34;flour&#34;]) (&#34;duration&#34; . 10) (&#34;steps&#34; . :empty)))&#xA;&#xA;(yaml-parse-string &#34;&#xA;translations:&#xA;  one: бір&#xA;  two: екі&#xA;  three: үш&#34;)&#xA;&#xA;;; =&amp;gt; #s(hash-table ... data (&#34;translations&#34; #s(hash-table ...)))&#xA;&#xA;&#xA;(yaml-encode &#39;(&#34;omitted&#34; ((count . 3) (value . 10) (items (&#34;ruby&#34; &#34;diamond&#34;))) &#34;omitted&#34;))&#xA;&#xA;;; =&amp;gt; &#34;&#xA;- omitted&#xA;- count: 3&#xA;  value: 10&#xA;  items:&#xA;    ruby: [diamond]&#xA;- omitted&#34;&#xA;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;p&gt;Since this is implemented in Emacs Lisp performance is probably not the best. An alternative implementation using libyaml exists and can be found &lt;a href=&#34;https://github.com/syohex/emacs-libyaml&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have a very deeply nested YAML file and your &lt;code&gt;max-lisp-eval-depth&lt;/code&gt; variable is set too low, these is a chance that you might hit the maximum Lisp eval depth limit. In the future I may work on changing the parsing algorithm to avoid this problem but in the meantime you can bump up the &lt;code&gt;max-lisp-eval-depth&lt;/code&gt; variable in your config.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;You can run the tests by executing&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ~/path/to/git-repo/yaml.el&#xA;$ emacs -batch -l ert -l yaml.el -l yaml-tests.el -f ert-run-tests-batch-and-exit&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>