<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-15T01:45:00Z</updated>
  <subtitle>Weekly Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ibnHatab/env-at-picon</title>
    <updated>2023-10-15T01:45:00Z</updated>
    <id>tag:github.com,2023-10-15:/ibnHatab/env-at-picon</id>
    <link href="https://github.com/ibnHatab/env-at-picon" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Development environment on Linux&lt;/p&gt;&lt;hr&gt;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Requirements: ipython bash-completion&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Link or copy following files to the $HOME bin/ - some common scripts apps/ - toolchain and emacs configs .bash_profile - toolchain defs .bashrc .bash_aliases .emacs - emacs config .erlang - erlang config .inputrc - ? .vimrc - vim config for trace reading :ic and :mounse&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You can adapt this command to do the job for you: for i in &lt;code&gt;find env/ -maxdepth 1 | sed -e &#39;1d&#39; | grep -v .git&lt;/code&gt;; do ln -sf $i; done&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Get Erlang test tools&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;mkdir libs; cd libs git clone gitolite@caprica:femto/femto_test git config --global http.proxy $http_proxy rebar get-deps rebar compile&lt;/p&gt; &#xA;&lt;p&gt;cd deps; git clone &lt;a href=&#34;https://github.com/stesla/distel.git&#34;&gt;https://github.com/stesla/distel.git&lt;/a&gt; cd distel; mkdir ebin; make erl&lt;/p&gt; &#xA;&lt;p&gt;edit .erlabg&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jwiegley/emacs-async</title>
    <updated>2023-10-15T01:45:00Z</updated>
    <id>tag:github.com,2023-10-15:/jwiegley/emacs-async</id>
    <link href="https://github.com/jwiegley/emacs-async" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple library for asynchronous processing in Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?sanitize=true&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.gnu.org/packages/async.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/packages/async.svg?sanitize=true&#34; alt=&#34;GNU ELPA&#34; title=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/async&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/async-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34; title=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/async&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/async-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34; title=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;emacs-async&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;async.el&lt;/code&gt; is a module for doing asynchronous processing in Emacs. Some async applications are provided as well with this package:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dired-async&lt;/li&gt; &#xA; &lt;li&gt;smtp-mail-async&lt;/li&gt; &#xA; &lt;li&gt;async-bytecomp&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Install&lt;/h1&gt; &#xA;&lt;p&gt;You can install emacs-async package from MELPA using package.el.&lt;/p&gt; &#xA;&lt;p&gt;You can also install from sources, in this case you should install using make and make install to ensure emacs-async is installed in a standard load-path destination where other packages can find it easily when compiling.&lt;/p&gt; &#xA;&lt;h2&gt;Install dired-async&lt;/h2&gt; &#xA;&lt;p&gt;Add to your &lt;code&gt;.emacs.el&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(autoload &#39;dired-async-mode &#34;dired-async.el&#34; nil t)&#xA;(dired-async-mode 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will allow you to run asynchronously the dired commands for copying, renaming and symlinking. If you are a &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;helm&lt;/a&gt; user, this will allow you to copy, rename etc... asynchronously from &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;helm&lt;/a&gt;. Note that with &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;helm&lt;/a&gt; you can disable this by running the copy, rename etc... commands with a prefix argument.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t want to make dired/helm asynchronous disable it with &lt;code&gt;dired-async-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Debian and Ubuntu&lt;/h3&gt; &#xA;&lt;p&gt;Users of Debian 9 or later or Ubuntu 16.04 or later may simply &lt;code&gt;apt-get install elpa-async&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Authentication and user interaction&lt;/h2&gt; &#xA;&lt;p&gt;Some authentications require user interaction, for example answering to a prompt, entering a passwords etc. Your async implementation should avoid any such user interaction, to avoid being stuck with a prompt you will not be able to answer to in the child emacs. For all what is remote (mails, tramp etc...) you have to let emacs manage your identification with &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/auth.html&#34;&gt;auth-sources&lt;/a&gt;, so that you do not have to enter a password.&lt;/p&gt; &#xA;&lt;p&gt;Basically all you need is something like this in your init file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(use-package auth-source&#xA;  :no-require t&#xA;  :config (setq auth-sources &#39;(&#34;~/.authinfo.gpg&#34; &#34;~/.netrc&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And a &#34;~/.authinfo.gpg&#34; file containing entries such as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;default port sudo login root password xxxxxxxx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;machine xxxxx port xxx login xxx password xxxxxxx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;for more specific hosts (smtp, mails etc...)&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/auth.html&#34;&gt;auth-sources manual&lt;/a&gt; for more infos.&lt;/p&gt; &#xA;&lt;p&gt;However, when choosing the destination with completion (e.g. helm) and you have no &#34;.authinfo&#34; file or just no entry for this host, tramp will prompt for password and offer you to save it, if you answer &#39;yes&#39; you will be able to achieve you async operation as the child Emacs will use this just created &#34;.authinfo&#34; file, if you say &#39;no&#39;, your dired-async process will hang forever because child emacs is waiting for password.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: For all your async implementations in emacs-26+ versions that handle remote files (tramp), you will have to let-bind &lt;code&gt;async-quiet-switch&lt;/code&gt; to &lt;code&gt;-q&lt;/code&gt; to workaround a tramp bug that prevent &lt;code&gt;emacs -Q&lt;/code&gt; to use &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/auth.html&#34;&gt;auth-sources&lt;/a&gt; mechanism.&lt;/p&gt; &#xA;&lt;h2&gt;Enable asynchronous compilation of your (M)elpa packages&lt;/h2&gt; &#xA;&lt;p&gt;By default emacs package.el compile packages in its running emacs session. This is not a problem when installing a new package (which is not actually loaded in current emacs) but it may create errors and bad compilation when upgrading a package (old version of package is already loaded and running in current emacs). You can remedy to this by allowing async to compile your packages asynchronously, (helm and magit actually do this by default, so if you are using these packages they will compile asynchronously) to do this, add to your init file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(async-bytecomp-package-mode 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can control which packages will compile async with &lt;code&gt;async-bytecomp-allowed-packages&lt;/code&gt;. Set it to &lt;code&gt;&#39;(all)&lt;/code&gt; to be sure you will compile all packages asynchronously.&lt;/p&gt; &#xA;&lt;h2&gt;Send mails asynchronously with smtp mail async&lt;/h2&gt; &#xA;&lt;p&gt;To enable this feature, ensure smtp-mail-async.el is loaded and use&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;(setq message-send-mail-function &#39;async-smtpmail-send-it)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;WARNINGS:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;When using recent emacs (25+) the network security manager maybe called interactively in child emacs and make &lt;code&gt;async-smtpmail-send-it&lt;/code&gt; fail, so be sure to send email once synchronously before using &lt;code&gt;async-smtpmail-send-it&lt;/code&gt; as your &lt;code&gt;message-send-mail-function&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You may loose your sent mail if your network is down, so ensure to queue your mails if so. you can do this automatically, see &lt;a href=&#34;https://github.com/jwiegley/emacs-async/issues/64&#34;&gt;issue #64&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Async usage&lt;/h1&gt; &#xA;&lt;p&gt;The interface is intended to be very easy to use:&lt;/p&gt; &#xA;&lt;h2&gt;async-start&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-start START-FUNC FINISH-FUNC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Execute START-FUNC (often a lambda) in a subordinate Emacs process. When done, the return value is passed to FINISH-FUNC. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-start&#xA;   ;; What to do in the child process&#xA;   (lambda ()&#xA;     (message &#34;This is a test&#34;)&#xA;     (sleep-for 3)&#xA;     222)&#xA;&#xA;   ;; What to do when it finishes&#xA;   (lambda (result)&#xA;     (message &#34;Async process done, result should be 222: %s&#34; result)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If FINISH-FUNC is &lt;code&gt;nil&lt;/code&gt; or missing, a future is returned that can be inspected using &lt;code&gt;async-get&lt;/code&gt;, blocking until the value is ready. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(let ((proc (async-start&#xA;               ;; What to do in the child process&#xA;               (lambda ()&#xA;                 (message &#34;This is a test&#34;)&#xA;                 (sleep-for 3)&#xA;                 222))))&#xA;&#xA;    (message &#34;I&#39;m going to do some work here&#34;) ;; ....&#xA;&#xA;    (message &#34;Waiting on async process, result should be 222: %s&#34;&#xA;             (async-get proc)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t want to use a callback, and you don&#39;t care about any return value from the child process, pass the &lt;code&gt;&#39;ignore&lt;/code&gt; symbol as the second argument (if you don&#39;t, and never call &lt;code&gt;async-get&lt;/code&gt;, it will leave &lt;code&gt;*emacs*&lt;/code&gt; process buffers hanging around):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-start&#xA; (lambda ()&#xA;   (delete-file &#34;a remote file on a slow link&#34; nil))&#xA; &#39;ignore)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: Even when FINISH-FUNC is present, a future is still returned except that it yields no value (since the value is passed to FINISH-FUNC). Calling &lt;code&gt;async-get&lt;/code&gt; on such a future always returns &lt;code&gt;nil&lt;/code&gt;. It can still be useful, however, as an argument to &lt;code&gt;async-ready&lt;/code&gt; or &lt;code&gt;async-wait&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;async-start-process&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-start-process NAME PROGRAM FINISH-FUNC &amp;amp;rest PROGRAM-ARGS&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Start the executable PROGRAM asynchronously. See &lt;code&gt;async-start&lt;/code&gt;. PROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the process object when done. If FINISH-FUNC is &lt;code&gt;nil&lt;/code&gt;, the future object will return the process object when the program is finished. Set DEFAULT-DIRECTORY to change PROGRAM&#39;s current working directory.&lt;/p&gt; &#xA;&lt;h2&gt;async-get&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-get FUTURE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Get the value from an asynchronously called function when it is ready. FUTURE is returned by &lt;code&gt;async-start&lt;/code&gt; or &lt;code&gt;async-start-process&lt;/code&gt; when its FINISH-FUNC is &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;async-ready&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-ready FUTURE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Query a FUTURE to see if its function&#39;s value is ready -- i.e., if no blocking would result from a call to &lt;code&gt;async-get&lt;/code&gt; on that FUTURE.&lt;/p&gt; &#xA;&lt;h2&gt;async-wait&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-wait FUTURE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Wait for FUTURE to become ready.&lt;/p&gt; &#xA;&lt;h2&gt;async-inject-variables&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-inject-variables INCLUDE-REGEXP &amp;amp;optional PREDICATE EXCLUDE-REGEXP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Return a &lt;code&gt;setq&lt;/code&gt; form that replicates part of the calling environment. It sets the value for every variable matching INCLUDE-REGEXP and also PREDICATE. It will not perform injection for any variable matching EXCLUDE-REGEXP (if present). It is intended to be used as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-start&#xA;   `(lambda ()&#xA;      (require &#39;smtpmail)&#xA;      (with-temp-buffer&#xA;        (insert ,(buffer-substring-no-properties (point-min) (point-max)))&#xA;        ;; Pass in the variable environment for smtpmail&#xA;        ,(async-inject-variables &#34;\\`\\(smtpmail\\|\\(user-\\)?mail\\)-&#34;)&#xA;        (smtpmail-send-it)))&#xA;   &#39;ignore)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;async-let&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-let BINDINGS &amp;amp;rest FORMS&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Allow to establish let bindings asynchronously. Each value of binding can refer to the symbols already bound in BINDINGS (like &lt;code&gt;let*&lt;/code&gt;). FORMS are executed once BINDINGS have been evaluated, but without blocking emacs.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-let ((x &#34;hello&#34;)&#xA;            (y &#34;world&#34;))&#xA;  (message &#34;%s %s&#34; x y))&#xA;  &#xA;(async-let ((x (* 5 2))&#xA;            (y (+ x 4))&#xA;            (z (+ x y)))&#xA;  (message &#34;%d + %d = %d&#34; x y z))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that if you bind something to nil and set it afterward in body, the evaluation of this binding will NOT be asynchronous, but will happen in you current emacs, blocking it if the evaluation of this value is sufficiently important, e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-let ((x &#34;hello&#34;)&#xA;            (y &#34;world&#34;)&#xA;            z)&#xA;  (setq z (+ 1 2)) ;; Huge calculation of Z will block emacs.&#xA;  (message &#34;%s %s %d&#34; x y z))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;IOW if the calculation of Z is huge and you want it asynchronous evaluate it in BINDINGS but not in FORMS.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacs-straight/jsonrpc</title>
    <updated>2023-10-15T01:45:00Z</updated>
    <id>tag:github.com,2023-10-15:/emacs-straight/jsonrpc</id>
    <link href="https://github.com/emacs-straight/jsonrpc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mirror of the jsonrpc package from GNU ELPA, current as of 2023-10-15&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>