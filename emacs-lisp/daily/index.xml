<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-04T01:36:32Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>positron-solutions/user-keys</title>
    <updated>2023-06-04T01:36:32Z</updated>
    <id>tag:github.com,2023-06-04:/positron-solutions/user-keys</id>
    <link href="https://github.com/positron-solutions/user-keys" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The keyboard belongs to the user&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: User-Keys #+AUTHOR: Psionik K #+PROPERTY: header-args :results silent&lt;/p&gt; &#xA;&lt;p&gt;#+HTML: &lt;img width=&#34;400&#34; src=&#34;https://github.com/positron-solutions/user-keys/assets/73710933/1d684941-0baf-42ad-b053-e0024c0812ce&#34; alt=&#34;Sequences consisting of C-c and a letter are the only sequences reserved for users.  (An error).&#34;&gt; #+HTML: &lt;br&gt; #+HTML: &lt;a href=&#34;https://melpa.org/#/user-keys&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/user-keys-badge.svg?sanitize=true&#34; alt=&#34;melpa package&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/user-keys&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/user-keys-badge.svg?sanitize=true&#34; alt=&#34;melpa stable package&#34;&gt;&lt;/a&gt; #+HTML: &lt;a href=&#34;https://github.com/positron-solutions/user-keys/actions/?workflow=CI&#34;&gt;&lt;img src=&#34;https://github.com/positron-solutions/user-keys/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI workflow status&#34;&gt;&lt;/a&gt; #+HTML: &lt;a href=&#34;https://github.com/positron-solutions/user-keys/actions/?workflow=Developer+Certificate+of+Origin&#34;&gt;&lt;img src=&#34;https://github.com/positron-solutions/user-keys/actions/workflows/dco.yml/badge.svg?sanitize=true&#34; alt=&#34;DCO Check&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Remove legacy keymap spam&lt;/li&gt; &#xA; &lt;li&gt;Move keys that express ideas, such as =C-n=, coherently across multiple modes&lt;/li&gt; &#xA; &lt;li&gt;See the current state of your preferred top-level sequences&lt;/li&gt; &#xA; &lt;li&gt;Introspect modal key bindings, for both package development &amp;amp; configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install User-Keys&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src elisp :eval never&lt;/p&gt; &#xA;&lt;p&gt;(use-package user-keys) ; vanilla&lt;/p&gt; &#xA;&lt;p&gt;;; using elpaca&#39;s with explicit recipe (use-package user-keys :elpaca (user-keys :host github :repo &#34;positron-solutions/user-keys&#34;))&lt;/p&gt; &#xA;&lt;p&gt;;; straight with explicit recipe (use-package user-keys :straight (user-keys :type git :host github :repo &#34;positron-solutions/user-keys&#34;))&lt;/p&gt; &#xA;&lt;p&gt;;; or use manual load-path &amp;amp; require, you brave yak shaver&lt;/p&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Use User-Keys&lt;/p&gt; &lt;p&gt;#+begin_src elisp :eval never&lt;/p&gt; &lt;p&gt;;; Show the state of your preferred sequences in the current major ;; mode. Use this to find out which sequences you might want to bind ;; next. (user-keys-report-preferred)&lt;/p&gt; &lt;p&gt;;; See a report of all &#34;stupid&#34; bindings and the maps that bind them. (user-keys-report-stupid)&lt;/p&gt; &lt;p&gt;;; Check for shadows for a common sequence so you can move all of it&#39;s bindings ;; around at once. (user-keys-report-shadows)&lt;/p&gt; &lt;p&gt;;; Open the output buffer and use the transient interface (user-keys-start)&lt;/p&gt; &lt;p&gt;#+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Contents :PROPERTIES: :TOC: :include siblings :ignore this :END: :CONTENTS:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#other-packages][Other Packages]]&lt;/li&gt; &#xA; &lt;li&gt;[[#motivation][Motivation]]&lt;/li&gt; &#xA; &lt;li&gt;[[#long-term-goal][Long-Term Goal]]&lt;/li&gt; &#xA; &lt;li&gt;[[#correctly-communicating-about-commands-and-sequences][Correctly Communicating About Commands and Sequences]]&lt;/li&gt; &#xA; &lt;li&gt;[[#the-c-c-convention-is-terrible][The C-c Convention is Terrible]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#please-package-authors][Please, Package Authors]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#what-we-should-do][What We Should Do]]&lt;/li&gt; &#xA; &lt;li&gt;[[#contributing][Contributing]]&lt;/li&gt; &#xA; &lt;li&gt;[[#acknowledgments][Acknowledgments]] :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Other Packages&lt;/p&gt; &lt;p&gt;Absolutely check out the newer modal packages such as [[https://github.com/meow-edit/meow][Meow]]. They don&#39;t have a lot of pre-configured bindings, and this opens up room to do crazy things.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Completions frameworks alleviate the need for complex bindings because it&#39;s just faster to complete the command name&lt;/li&gt; &#xA;   &lt;li&gt;Transient bindings (transient package) are a good way to present context specific bindings such as for applications like magit&lt;/li&gt; &#xA;   &lt;li&gt;Helpful presents bindings in a much better format when looking at keymap variables&lt;/li&gt; &#xA;   &lt;li&gt;Which-key is definitely more useful after cleaning out some bindings&lt;/li&gt; &#xA;   &lt;li&gt;Tree sitter is making more and more editing commands able to use the structure of text you are working on&lt;/li&gt; &#xA;   &lt;li&gt;General provides lots of support for defining bindings more succinctly and differentiating user-defined bindings&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Not all of these packages have a clear best choice, so be sure to research Emacs awesome and Reddit etc before adopting a recommendation here.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Motivation&lt;/p&gt; &lt;p&gt;There are too many bindings. Everywhere. It gets in the way of progress. It gets in the way of use. We need tools to take back control and move forward.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;em&gt;Empower users to modify &amp;amp; develop new schemes&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Built-in ways to look at bindings are not appropriate for designing new bindings schemes or looking at bindings systematically. There&#39;s not a good built-in way to see sets of bindings across multiple maps or the state of map activation across different buffers, information that is essential for designing and developing bindings schemes (such as new modal schemes).&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;em&gt;Give the keyboard back to the user&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Having so many bindings in the way or being surprised by shadows from major &amp;amp; minor modes leads to user intimidation and &lt;em&gt;calcification of things that were not intended to become standards.&lt;/em&gt; Whether you start with Evil or defaults, the mass proliferation of bad bindings gets in the way and adds risk and complexity to any attempt to go your own way. This package is developed with the belief that the keyboard belongs to the user, and that extra effort should be made to get out of the way.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;em&gt;Manage Ad-hoc conventions&lt;/em&gt;&lt;/p&gt; &lt;p&gt;There is no configuration option for certain conventions, such as =C-n= usually selecting the next item in a list. Because these conventions exist but are not first class, changing the binding for an idea found in multiple keymaps usually requires modifying each keymap. By viewing all shadows in all maps at once, the user can modify and maintain their own conventions with more awareness and ease.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;em&gt;Support Tree Sitter Migration&lt;/em&gt;&lt;/p&gt; &lt;p&gt;The timing of development was partly motivated by tree-sitter adoption. Because of tree-sitter, editing commands that are aware of syntax boundaries will become common. &lt;em&gt;The old keymaps based on heuristic editing commands will need to evolve.&lt;/em&gt; We need tools that make it easy to open up space and move old conventions.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Long-Term Goal&lt;/p&gt; &lt;p&gt;It is possible that this package may become similar to a no-littering, but for key bindings. Maybe it should be the Magit of key bindings. Maybe it will become an editing interface for a new set of modal bindings. A lot depends on user demand. Be sure to [[https://github.com/sponsors/positron-solutions][support]] the project and help steer the direction.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Correctly Communicating About Commands and Sequences&lt;/p&gt; &lt;p&gt;We need to fix something culturally. Other users might say things such as, &#34;The C-x C-f command.&#34; &lt;em&gt;This is wrong.&lt;/em&gt; There is no &#34;C-x C-f&#34; command. There is a &#34;C-x f&#34; &lt;em&gt;key sequence&lt;/em&gt; that is &lt;em&gt;bound&lt;/em&gt;, by default, to the &lt;em&gt;command&lt;/em&gt; =find-file=. This is a &lt;em&gt;binding&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;Why you should always prefer command names when communicating:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Command names point to source code and can be used as fuel for hacking new commands.&lt;/li&gt; &#xA;   &lt;li&gt;Command names are named using frequent concepts from the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Glossary.html][glossary]]&lt;/li&gt; &#xA;   &lt;li&gt;Command names do not change when users rebind keys. You can communicate about commands no matter what bindings system another user has.&lt;/li&gt; &#xA;   &lt;li&gt;Command names tell users more about what package they came from.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Unfortunately there seems to be no mechanism to find out what a key /was/ bound to in the default settings. We can all use commands. We cannot all know what a binding means.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Command names make you and other users more successful. Communicate by saying command names, not key sequences.&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The C-c Convention is Terrible&lt;/p&gt; &lt;p&gt;The [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Binding-Conventions.html][elisp manual]] states that only the &lt;del&gt;C-c&lt;/del&gt; prefix /and only with a single letter/ should be respected by all major and minor modes. This means the user is expected to bind all of their preferred global commands behind just one &lt;em&gt;prefix&lt;/em&gt; sequence.&lt;/p&gt; &lt;p&gt;#+begin_quote&lt;/p&gt; &lt;p&gt;Donâ€™t define C-c letter as a key in Lisp programs. Sequences consisting of C-c and a letter (either upper or lower case; ASCII or non-ASCII) are reserved for users; &lt;em&gt;they are the only sequences reserved for users&lt;/em&gt;, so do not block them.&lt;/p&gt; &lt;p&gt;#+end_quote&lt;/p&gt; &lt;p&gt;Meanwhile countless packages add bindings to high-value short key sequences just because the package author felt like it or because they wanted to shadow an ad-hoc convention without knowing if the user reconfigured it.&lt;/p&gt; &lt;p&gt;Being forced to sort through massive lists of bindings with many ad-hoc conventions leads to user intimidation and a calcification of things that never should have been allowed to become standards.&lt;/p&gt; &lt;p&gt;=C-c= was never a good idea. It is the kind of choice that occurred after far too much spam was protected by being legacy, a legacy that emerged from mixed contributions and exhausting bike shed mailing list threads that reach conclusions like a [[https://en.wikipedia.org/wiki/Ouija][ouija]] board.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Please, Package Authors&lt;/p&gt; &#xA;&lt;p&gt;Commands do not deserve bindings. They are not entitled to them. At the very most, a package author should provide a keymap and then tell the user how to bind that to a prefix. We have absolutely amazing command discovery these days. The user doesn&#39;t need your bindings. Publish a list of commands in your package usage documentation. Put them into a context-specific application interface like transient. Avoid bad key sequences and ad-hoc conventions unless it&#39;s the purpose of your package to shadow the defaults.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;What We Should Do&lt;/p&gt; &lt;p&gt;In addition to innovation in modal bindings that seek to sidestep the entire problem altogether...&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;em&gt;Reserve short sequences for the user&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Meta and control keys, especially on the home row, should be considered sacred real-estate only available to the user. Opening up space will lower the friction for change, speeding up evolution, eventually leading us to discover new things we actually want to bind.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;em&gt;Lean on M-x&lt;/em&gt;&lt;/p&gt; &lt;p&gt;In the modern era of awesome M-x completions, there&#39;s almost no use to bind functions beyond a certain level of rarity. It only makes sense to have short sequences bound when no M-x sequences are actually very long.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;em&gt;RISC, stateful commands with composition&lt;/em&gt;&lt;/p&gt; &lt;p&gt;In the global bindings, we should try to do more with a smaller set of commands, similar to a RISC style of compressing the possible input values but increasing the meaning of strings of values, which can be composed more easily than long sequences.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;em&gt;Use modal interfaces for context-specific commands&lt;/em&gt;&lt;/p&gt; &lt;p&gt;For bindings that are very context-specific, they should be moved into more transient-like interfaces. If you won&#39;t use a command often, it doesn&#39;t make sense to try to use it from memory or to use it non-modally.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;em&gt;Remove crufty applications from Emacs&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Many bindings and the applications that they are tied to should just be removed from Emacs altogether and treated as independent packages on the GNU ELPA. This will lower the weight of the manual and other deep integrations, making more room to grow.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;em&gt;Put legacy choices into a package&lt;/em&gt;&lt;/p&gt; &lt;p&gt;It needs to be easier to remove default bindings without disrupting legacy users, and that means using a compat package like every other platform out there. Users who want modern Emacs don&#39;t need to care. Users who rely on the old ways should be served by a compat package, not by carrying forward the same old legacy defaults forever.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Contributing&lt;/p&gt; &lt;p&gt;[[./CONTRIBUTING.org][CONTRIBUTING]] contains instructions on using this repository&#39;s functionality. A DCO and GPL3 license are included with this project.&lt;/p&gt; &lt;p&gt;Check the hacking [[./NOTES.org][NOTES]] document for some help getting started hacking on keymaps and bindings. The keymap data structures themselves are a little bit unwieldy.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Github Sponsors is configured.&lt;/em&gt; If you want features &amp;amp; support, organize an international coalition of backers and each donate a comfortable amount, while delegating the authority to pick priorities to those who either demonstrate competence or are willing to pay for what they want.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Acknowledgments&lt;/p&gt; &lt;p&gt;Thanks to [[https://github.com/tarsius][Tarsius]] for publishing the keymap-utils package to MELPA. Some of the built-in functions for exploring keymaps in Emacs were not immediately appropriate for implementing all of the ideas in user-keys. =keymap-map-keys= seemed to provide a buffet of data types and structures. =kmu-map-keymap= was very helpful.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Local Variables:&lt;/h1&gt; &#xA;&lt;h1&gt;before-save-hook: (lambda () (when (require &#39;org-make-toc nil t) (org-make-toc)))&lt;/h1&gt; &#xA;&lt;h1&gt;org-make-toc-link-type-fn: org-make-toc--link-entry-github&lt;/h1&gt; &#xA;&lt;h1&gt;End:&lt;/h1&gt;</summary>
  </entry>
</feed>