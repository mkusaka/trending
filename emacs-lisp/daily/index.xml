<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-24T02:15:45Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>weiyongqing123/.emacs.d</title>
    <updated>2023-11-24T02:15:45Z</updated>
    <id>tag:github.com,2023-11-24:/weiyongqing123/.emacs.d</id>
    <link href="https://github.com/weiyongqing123/.emacs.d" rel="alternate"></link>
    <summary type="html">&lt;p&gt;my emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;.emacs.d&lt;/h1&gt; &#xA;&lt;p&gt;my emacs&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>astoff/drepl</title>
    <updated>2023-11-24T02:15:45Z</updated>
    <id>tag:github.com,2023-11-24:/astoff/drepl</id>
    <link href="https://github.com/astoff/drepl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;REPL protocol for the dumb terminal&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: dREPL&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;/p&gt;&#xA;&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;http://elpa.gnu.org/packages/drepl.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/drepl.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;dREPL is a collection of fully featured language shells for Emacs. At the moment it supports the following interpreters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Python:&lt;/em&gt; requires [[https://pypi.org/project/ipython/][IPython]].&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Lua:&lt;/em&gt; requires [[https://luarocks.org/modules/hoelzro/luarepl][luarepl]] and [[https://luarocks.org/modules/dhkolf/dkjson][dkjson]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following features are available, subject to variations across different REPLs (IPython supports all of them):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Completion, including annotations and also on continuation lines&lt;/li&gt; &#xA; &lt;li&gt;Multi-line input editing&lt;/li&gt; &#xA; &lt;li&gt;Eldoc integration&lt;/li&gt; &#xA; &lt;li&gt;Normal pty interaction during code evaluation (e.g. debuggers)&lt;/li&gt; &#xA; &lt;li&gt;Graphics support via [[https://github.com/astoff/comint-mime][comint-mime]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In fancier terms, dREPL can be described as a REPL protocol for the dumb terminal. One Elisp library defines the user interface and the client code; support for a new programming language requires only writing some backend code in the target language, plus a tiny bit of glue code in Elisp. If the target language provides a good embeddable REPL library, then the backend implementation is also reasonably straightforward.&lt;/p&gt; &#xA;&lt;p&gt;** Usage&lt;/p&gt; &#xA;&lt;p&gt;To start a REPL, use one of the =M-x drepl-*= commands (making sure first that you have the target language dependencies installed, as described above). The rest should look familiar.&lt;/p&gt; &#xA;&lt;p&gt;It is also possible to interact with a REPL from another buffer, say to evaluate a region of text. The relevant commands are the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=drepl-associate=: By default, dREPL tries to guess which REPL is the right one for any given buffer; an error is raised if there is no good guess. In this case, you can manually create an association with this command.&lt;/li&gt; &#xA; &lt;li&gt;=drepl-pop-to-repl=: Go to the REPL associated (implicitly or explicitly) to the current buffer.&lt;/li&gt; &#xA; &lt;li&gt;=drepl-eval=: Evaluate a string read from the minibuffer.&lt;/li&gt; &#xA; &lt;li&gt;=drepl-eval-region= and =drepl-eval-buffer=: Evaluate text of the current buffer.&lt;/li&gt; &#xA; &lt;li&gt;=drepl-restart=: Restart the interpreter. In IPython this is a soft reset; use a prefix argument to kill and start again the interpreter.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Documentation on a symbol in the REPL buffer, if available, can be accessed with =eldoc-doc-buffer=.&lt;/p&gt; &#xA;&lt;p&gt;** Protocol&lt;/p&gt; &#xA;&lt;p&gt;This package extends Comint and so the communication between Emacs and the interpreter happens through a pseudoterminal. The conundrum is how to multiplex control messages and regular IO.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;From the subprocess to Emacs, control messages travel in JSON objects inside an OSC escape sequence (code 5161).&lt;/li&gt; &#xA; &lt;li&gt;From Emacs to the subprocess, control messages are passed as lines of the form =ESC = &#xA;  &lt;json object&gt;&#xA;    LF=. If the subprocess communicates over a PTY and the encoded message is too long to fit a line (this is an OS-dependent limit), then the message payload is split into fragments. All fragments except the last are transmitted as =ESC + &#xA;   &lt;json fragment&gt;&#xA;     LF=.&#xA;   &lt;/json&gt;&#xA;  &lt;/json&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;At any given point in time, the subprocess expects either a framed messages like this or regular IO. Emacs keeps track of the state of the subprocess through =status= notifications as described below.&lt;/p&gt; &#xA;&lt;p&gt;There are three types of message: /requests/, to which a /response/ is expected, and /notifications/, to which no response is expected. A message contains the following fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=op=: The operation name. It must be present in every notification and request but is absent in response messages.&lt;/li&gt; &#xA; &lt;li&gt;=id=: A unique number which should be present in every request and repeated in the response message. It is absent in notification messages.&lt;/li&gt; &#xA; &lt;li&gt;Further fields are parameters specific to each type of request, notification or response.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following operations are defined:&lt;/p&gt; &#xA;&lt;p&gt;*** =status= (interpreter notification) The interpreter indicates whether or not it is ready to receive a framed operation message.&lt;/p&gt; &#xA;&lt;p&gt;Parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=status=: Either =ready= (subprocess is expecting a framed message) or =busy= (IO, if it occurs, should not be framed).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: Some changes in the tracked state happen implicitly. Most importantly, when an editor request is sent, tracked state changes to =busy=.&lt;/p&gt; &#xA;&lt;p&gt;*** =eval= (editor request) Evaluate some code, blocking until the computation is complete.&lt;/p&gt; &#xA;&lt;p&gt;Parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=code=: The code to be evaluated&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Result: The response contains no data (that is, it includes only the original request id). The REPL should evaluate the code and print the result.&lt;/p&gt; &#xA;&lt;p&gt;*** =complete= (editor request)&lt;/p&gt; &#xA;&lt;p&gt;Get completions at point.&lt;/p&gt; &#xA;&lt;p&gt;Parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=code=: A code snippet containing the completion point.&lt;/li&gt; &#xA; &lt;li&gt;=offset=: The offset (zero-based) from start of =code= to the point of completion.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Response:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=candidates= (optional): A list of objects, each containing the following attributes. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;=text=: The completed text, including the existing prefix.&lt;/li&gt; &#xA;   &lt;li&gt;=annot=: Annotation text to be displayed next to the candidate in the completion UI.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** =checkinput= (editor request)&lt;/p&gt; &#xA;&lt;p&gt;Check if a continuation line is needed.&lt;/p&gt; &#xA;&lt;p&gt;Parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=code= (string): A code snippet.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Result:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=status=: One of =complete= (the code is valid), =incomplete= (the code is syntactically invalid, but may become so by adding more text) or =invalid= (there is a syntax error in the existing portion of code).&lt;/li&gt; &#xA; &lt;li&gt;=indent= (optional): If present, this is the expected indentation of a continuation line, as a string.&lt;/li&gt; &#xA; &lt;li&gt;=prompt=: The prompt of a continuation line.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** =describe= (editor request)&lt;/p&gt; &#xA;&lt;p&gt;Obtain information on the symbol at point.&lt;/p&gt; &#xA;&lt;p&gt;Parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=code=: A code snippet.&lt;/li&gt; &#xA; &lt;li&gt;=offset=: An offset (zero-based) from start of =code= containing the symbol of interest.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Result: The response may be empty (no information on the symbol) or as follows.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=name=: The symbol name.&lt;/li&gt; &#xA; &lt;li&gt;=type= (optional): The symbol type or function signature.&lt;/li&gt; &#xA; &lt;li&gt;=text= (optional): Free-form documentation on the symbol.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** =setoptions= (editor request)&lt;/p&gt; &#xA;&lt;p&gt;Set configuration options. The parameters are arbitrary and interpreter-specific. The interpreter must send an empty response.&lt;/p&gt; &#xA;&lt;p&gt;*** =getoptions= (interpreter notification)&lt;/p&gt; &#xA;&lt;p&gt;Indicates that the editor should send a =setoptions= request. Typically emitted when the interpreter is initialized but before printing the first prompt. Implicitly changes the tracked interpreter state to =ready=.&lt;/p&gt; &#xA;&lt;p&gt;** Why&lt;/p&gt; &#xA;&lt;p&gt;This package is intended to do what the good old Comint does, but polishing some rough edges. For example, completion in Comint is spotty and one is able to edit only the last line of a multi-line input.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>danking/eim-py</title>
    <updated>2023-11-24T02:15:45Z</updated>
    <id>tag:github.com,2023-11-24:/danking/eim-py</id>
    <link href="https://github.com/danking/eim-py" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An Emacs Input Method extension for smart pinyin&lt;/p&gt;&lt;hr&gt;&lt;p&gt;I found this at the EmacsWiki page on writing Chinese [1].&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s the work of Ye Wenbin (叶文彬), who has an Emacs wiki page [2].&lt;/p&gt; &#xA;&lt;p&gt;The package is described in detail, in Chinese, on another EmacsWiki page, EimForChinese [3]. Wenbin references some files from his personal home page [4] under tsinghua.edu.cn. Unfortunately, his personal home page is no longer present.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, I&#39;m not sure where I got the tar ball any more. There is, however, a repository [5] on github that seems to have a similar codebase.&lt;/p&gt; &#xA;&lt;p&gt;Feel free to contact me at &lt;a href=&#34;mailto:danking@ccs.neu.edu&#34;&gt;danking@ccs.neu.edu&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[1] &lt;a href=&#34;http://www.emacswiki.org/emacs-zh/WritingChinese&#34;&gt;http://www.emacswiki.org/emacs-zh/WritingChinese&lt;/a&gt; [2] &lt;a href=&#34;http://www.emacswiki.org/emacs-zh/Ye_Wenbin&#34;&gt;http://www.emacswiki.org/emacs-zh/Ye_Wenbin&lt;/a&gt; [3] &lt;a href=&#34;http://www.emacswiki.org/emacs-zh/EimForChinese&#34;&gt;http://www.emacswiki.org/emacs-zh/EimForChinese&lt;/a&gt; [4] &lt;a href=&#34;http://learn.tsinghua.edu.cn:8080/2005211356/emacs/Eim.html&#34;&gt;http://learn.tsinghua.edu.cn:8080/2005211356/emacs/Eim.html&lt;/a&gt; [5] &lt;a href=&#34;https://github.com/viogus/eim&#34;&gt;https://github.com/viogus/eim&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>