<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-31T01:34:03Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nschum/fringe-helper.el</title>
    <updated>2022-08-31T01:34:03Z</updated>
    <id>tag:github.com,2022-08-31:/nschum/fringe-helper.el</id>
    <link href="https://github.com/nschum/fringe-helper.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs: helper functions for fringe bitmaps&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;fringe-helper&lt;/h1&gt; &#xA;&lt;p&gt;helper functions for Emacs fringe bitmaps&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/nschum/fringe-helper.el&#34;&gt;&lt;img src=&#34;https://travis-ci.org/nschum/fringe-helper.el.png?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;fringe-helper contains helper functions for fringe bitmaps.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;fringe-helper-define&lt;/code&gt; allows you to to define fringe bitmaps using a visual string replesentation. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(fringe-helper-define &#39;test-bitmap &#39;(top repeat)&#xA;  &#34;XX......&#34;&#xA;  &#34;..XX....&#34;&#xA;  &#34;....XX..&#34;&#xA;  &#34;......XX&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also generate arguments for &lt;code&gt;define-fringe-bitmap&lt;/code&gt; yourself, by using &lt;code&gt;fringe-helper-convert&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;fringe-helper also provides a few stock bitmaps. They are loaded on demand by &lt;code&gt;fringe-lib-load&lt;/code&gt; and adapt to the current fringe size to a certain extend.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;fringe-helper-insert&lt;/code&gt; inserts a fringe bitmap at point and&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fringe-helper-insert-region&lt;/code&gt; inserts a fringe bitmap along a region.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fringe-helper-remove&lt;/code&gt; removes both kinds.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here&#39;s an example for enhancing &lt;code&gt;flymake-mode&lt;/code&gt; with fringe bitmaps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;fringe-helper)&#xA;(require &#39;flymake)&#xA;&#xA;(defvar flymake-fringe-overlays nil)&#xA;(make-variable-buffer-local &#39;flymake-fringe-overlays)&#xA;&#xA;(defadvice flymake-make-overlay (after add-to-fringe first&#xA;                                 (beg end tooltip-text face mouse-face)&#xA;                                 activate compile)&#xA;  (push (fringe-helper-insert-region&#xA;         beg end&#xA;         (fringe-lib-load (if (eq face &#39;flymake-errline)&#xA;                              fringe-lib-exclamation-mark&#xA;                            fringe-lib-question-mark))&#xA;         &#39;left-fringe &#39;font-lock-warning-face)&#xA;        flymake-fringe-overlays))&#xA;&#xA;(defadvice flymake-delete-own-overlays (after remove-from-fringe activate&#xA;                                        compile)&#xA;  (mapc &#39;fringe-helper-remove flymake-fringe-overlays)&#xA;  (setq flymake-fringe-overlays nil))&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>jjl/elisp</title>
    <updated>2022-08-31T01:34:03Z</updated>
    <id>tag:github.com,2022-08-31:/jjl/elisp</id>
    <link href="https://github.com/jjl/elisp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;My elisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;elisp&lt;/h1&gt; &#xA;&lt;h2&gt;What is it?&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s my emacs configuration. Well, some of it.&lt;/p&gt; &#xA;&lt;h2&gt;How is it structured?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;em&gt;vendor&lt;/em&gt; dir is where libraries I use belong in their upstream versions. Most will be git submodules.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;em&gt;site&lt;/em&gt; dir is where libraries I&#39;ve written reside. There may not be any for a while&lt;/li&gt; &#xA; &lt;li&gt;The &lt;em&gt;cust&lt;/em&gt; dir is where my configurations go. Feel free to base yours on it or ignore it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Fundamentals&lt;/h2&gt; &#xA;&lt;p&gt;I treat emacs as a text editor. I rarely use other features of it and I don&#39;t anticipate reading my mail in it, IRCing from it or browsing the web in it. I have other tools for that. If you want that, jrockway has his elisp repository (which I couldn&#39;t get to grips with properly) on github and you should check that out.&lt;/p&gt; &#xA;&lt;h2&gt;Warning&lt;/h2&gt; &#xA;&lt;p&gt;This is for personal use. I don&#39;t guarantee anything will be usable by other people, but I&#39;ll try to.&lt;/p&gt; &#xA;&lt;h2&gt;How do I use it?&lt;/h2&gt; &#xA;&lt;p&gt;If you understand the warning, you can append this line to your ~/.emacs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(load &#34;~/code/elisp/elisp.el&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This assumes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You&#39;ve checked out this repo as ~/code/elisp&lt;/li&gt; &#xA; &lt;li&gt;You have installed Cask: &lt;a href=&#34;http://cask.github.io/&#34;&gt;http://cask.github.io/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Do not merely symlink ~/.emacs to the elisp.el file. It won&#39;t work properly&lt;/p&gt; &#xA;&lt;h2&gt;What language modes do you include?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clojure (clojure-mode)&lt;/li&gt; &#xA; &lt;li&gt;Coffeescript (coffee-mode)&lt;/li&gt; &#xA; &lt;li&gt;CSS (css-mode)&lt;/li&gt; &#xA; &lt;li&gt;Haskell (haskell-mode)&lt;/li&gt; &#xA; &lt;li&gt;Javascript (js2-mode)&lt;/li&gt; &#xA; &lt;li&gt;LESS CSS (less-css-mode)&lt;/li&gt; &#xA; &lt;li&gt;Markdown (markdown-mode)&lt;/li&gt; &#xA; &lt;li&gt;Perl (cperl-mode)&lt;/li&gt; &#xA; &lt;li&gt;PHP (php-mode)&lt;/li&gt; &#xA; &lt;li&gt;Scala (scala-mode)&lt;/li&gt; &#xA; &lt;li&gt;SCSS (from Sass) (scss-mode)&lt;/li&gt; &#xA; &lt;li&gt;TT/Template Toolkit (tt-mode)&lt;/li&gt; &#xA; &lt;li&gt;YAML&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What other modes do you include?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;magit, for controlling a git repo&lt;/li&gt; &#xA; &lt;li&gt;web-mode, which is a poor way of doing code embedded in html. I use this for php and javascript sometimes. I have a view to replacing this with some mmm-mode magic in the future&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What might be included in future?&lt;/h2&gt; &#xA;&lt;p&gt;TODO.md contains a list of things I&#39;m planning to add&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>alphapapa/ts.el</title>
    <updated>2022-08-31T01:34:03Z</updated>
    <id>tag:github.com,2022-08-31:/alphapapa/ts.el</id>
    <link href="https://github.com/alphapapa/ts.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs timestamp and date-time library&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: ts.el #+PROPERTY: LOGGING nil&lt;/p&gt; &#xA;&lt;p&gt;[[https://melpa.org/#/ts][file:https://melpa.org/packages/ts-badge.svg]] [[https://stable.melpa.org/#/ts][file:https://stable.melpa.org/packages/ts-badge.svg]]&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;ts&lt;/del&gt; is a date and time library for Emacs. It aims to be more convenient than patterns like &lt;del&gt;(string-to-number (format-time-string &#34;%Y&#34;))&lt;/del&gt; by providing easy accessors, like &lt;del&gt;(ts-year (ts-now))&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To improve performance (significantly), formatted date parts are computed lazily rather than when a timestamp object is instantiated, and the computed parts are then cached for later access without recomputing. Behind the scenes, this avoids unnecessary &lt;del&gt;(string-to-number (format-time-string...&lt;/del&gt; calls, which are surprisingly expensive.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contents :PROPERTIES: :TOC: :include siblings :ignore this :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#examples][Examples]]&lt;/li&gt; &#xA; &lt;li&gt;[[#usage][Usage]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#accessors][Accessors]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#adjustors][Adjustors]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#comparators][Comparators]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#duration][Duration]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#formatting][Formatting]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#parsing][Parsing]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#misc][Misc.]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#tips][Tips]]&lt;/li&gt; &#xA; &lt;li&gt;[[#changelog][Changelog]] :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Examples&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Get parts of the current date:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp ;; When the current date is 2018-12-08 23:09:14 -0600: (ts-year (ts-now)) ;=&amp;gt; 2018 (ts-month (ts-now)) ;=&amp;gt; 12 (ts-day (ts-now)) ;=&amp;gt; 8 (ts-hour (ts-now)) ;=&amp;gt; 23 (ts-minute (ts-now)) ;=&amp;gt; 9 (ts-second (ts-now)) ;=&amp;gt; 14 (ts-tz-offset (ts-now)) ;=&amp;gt; &#34;-0600&#34;&lt;/p&gt; &#xA;&lt;p&gt;(ts-dow (ts-now)) ;=&amp;gt; 6 (ts-day-abbr (ts-now)) ;=&amp;gt; &#34;Sat&#34; (ts-day-name (ts-now)) ;=&amp;gt; &#34;Saturday&#34;&lt;/p&gt; &#xA;&lt;p&gt;(ts-month-abbr (ts-now)) ;=&amp;gt; &#34;Dec&#34; (ts-month-name (ts-now)) ;=&amp;gt; &#34;December&#34;&lt;/p&gt; &#xA;&lt;p&gt;(ts-tz-abbr (ts-now)) ;=&amp;gt; &#34;CST&#34; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Increment the current date:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp ;; By 10 years: (list :now (ts-format) :future (ts-format (ts-adjust &#39;year 10 (ts-now)))) ;;=&amp;gt; ( :now &#34;2018-12-15 22:00:34 -0600&#34; ;; :future &#34;2028-12-15 22:00:34 -0600&#34;)&lt;/p&gt; &#xA;&lt;p&gt;;; By 10 years, 2 months, 3 days, 5 hours, and 4 seconds: (list :now (ts-format) :future (ts-format (ts-adjust &#39;year 10 &#39;month 2 &#39;day 3 &#39;hour 5 &#39;second 4 (ts-now)))) ;;=&amp;gt; ( :now &#34;2018-12-15 22:02:31 -0600&#34; ;; :future &#34;2029-02-19 03:02:35 -0600&#34;) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;What day of the week was 2 days ago?&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (ts-day-name (ts-dec &#39;day 2 (ts-now))) ;=&amp;gt; &#34;Thursday&#34;&lt;/p&gt; &#xA;&lt;p&gt;;; Or, with threading macros: (thread-last (ts-now) (ts-dec &#39;day 2) ts-day-name) ;=&amp;gt; &#34;Thursday&#34; (-&amp;gt;&amp;gt; (ts-now) (ts-dec &#39;day 2) ts-day-name) ;=&amp;gt; &#34;Thursday&#34; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Get timestamp for this time last week:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (ts-unix (ts-adjust &#39;day -7 (ts-now))) ;;=&amp;gt; 1543728398.0&lt;/p&gt; &#xA;&lt;p&gt;;; To confirm that the difference really is 7 days: (/ (- (ts-unix (ts-now)) (ts-unix (ts-adjust &#39;day -7 (ts-now)))) 86400) ;;=&amp;gt; 7.000000567521762&lt;/p&gt; &#xA;&lt;p&gt;;; Or human-friendly as a list: (ts-human-duration (ts-difference (ts-now) (ts-dec &#39;day 7 (ts-now)))) ;;=&amp;gt; (:years 0 :days 7 :hours 0 :minutes 0 :seconds 0)&lt;/p&gt; &#xA;&lt;p&gt;;; Or as a string: (ts-human-format-duration (ts-difference (ts-now) (ts-dec &#39;day 7 (ts-now)))) ;;=&amp;gt; &#34;7 days&#34;&lt;/p&gt; &#xA;&lt;p&gt;;; Or confirm by formatting: (list :now (ts-format) :last-week (ts-format (ts-dec &#39;day 7 (ts-now)))) ;;=&amp;gt; ( :now &#34;2018-12-08 23:31:37 -0600&#34; ;; :last-week &#34;2018-12-01 23:31:37 -0600&#34;) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Some accessors have aliases similar to &lt;del&gt;format-time-string&lt;/del&gt; constructors:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (ts-hour (ts-now)) ;=&amp;gt; 0 (ts-H (ts-now)) ;=&amp;gt; 0&lt;/p&gt; &#xA;&lt;p&gt;(ts-minute (ts-now)) ;=&amp;gt; 56 (ts-min (ts-now)) ;=&amp;gt; 56 (ts-M (ts-now)) ;=&amp;gt; 56&lt;/p&gt; &#xA;&lt;p&gt;(ts-second (ts-now)) ;=&amp;gt; 38 (ts-sec (ts-now)) ;=&amp;gt; 38 (ts-S (ts-now)) ;=&amp;gt; 38&lt;/p&gt; &#xA;&lt;p&gt;(ts-year (ts-now)) ;=&amp;gt; 2018 (ts-Y (ts-now)) ;=&amp;gt; 2018&lt;/p&gt; &#xA;&lt;p&gt;(ts-month (ts-now)) ;=&amp;gt; 12 (ts-m (ts-now)) ;=&amp;gt; 12&lt;/p&gt; &#xA;&lt;p&gt;(ts-day (ts-now)) ;=&amp;gt; 9 (ts-d (ts-now)) ;=&amp;gt; 9 #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Parse a string into a timestamp object and reformat it:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (ts-format (ts-parse &#34;sat dec 8 2018 12:12:12&#34;)) ;=&amp;gt; &#34;2018-12-08 12:12:12 -0600&#34;&lt;/p&gt; &#xA;&lt;p&gt;;; With a threading macro: (-&amp;gt;&amp;gt; &#34;sat dec 8 2018 12:12:12&#34; ts-parse ts-format) ;;=&amp;gt; &#34;2018-12-08 12:12:12 -0600&#34; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Format the difference between two timestamps:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (ts-human-format-duration (ts-difference (ts-now) (ts-adjust &#39;day -400 &#39;hour -2 &#39;minute -1 &#39;second -5 (ts-now)))) ;; =&amp;gt; &#34;1 years, 35 days, 2 hours, 1 minutes, 5 seconds&#34;&lt;/p&gt; &#xA;&lt;p&gt;;; Abbreviated: (ts-human-format-duration (ts-difference (ts-now) (ts-adjust &#39;day -400 &#39;hour -2 &#39;minute -1 &#39;second -5 (ts-now))) &#39;abbr) ;; =&amp;gt; &#34;1y35d2h1m5s&#34; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Parse an Org timestamp element directly from &lt;del&gt;org-element-context&lt;/del&gt; and find the difference between it and now:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (with-temp-buffer (org-mode) (save-excursion (insert &#34;&amp;lt;2015-09-24 Thu .+1d&amp;gt;&#34;)) (ts-human-format-duration (ts-difference (ts-now) (ts-parse-org-element (org-element-context))))) ;;=&amp;gt; &#34;3 years, 308 days, 2 hours, 24 minutes, 21 seconds&#34; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Parse an Org timestamp string (which has a repeater) and format the year and month:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp ;; Note the use of &lt;code&gt;format&#39; rather than &lt;/code&gt;concat&#39;, because `ts-year&#39; ;; returns the year as a number rather than a string.&lt;/p&gt; &#xA;&lt;p&gt;(let* ((ts (ts-parse-org &#34;&amp;lt;2015-09-24 Thu .+1d&amp;gt;&#34;))) (format &#34;%s, %s&#34; (ts-month-name ts) (ts-year ts))) ;;=&amp;gt; &#34;September, 2015&#34;&lt;/p&gt; &#xA;&lt;p&gt;;; Or, using dash.el:&lt;/p&gt; &#xA;&lt;p&gt;(--&amp;gt; (ts-parse-org &#34;&amp;lt;2015-09-24 Thu .+1d&amp;gt;&#34;) (format &#34;%s, %s&#34; (ts-month-name it) (ts-year it))) ;;=&amp;gt; &#34;September, 2015&#34;&lt;/p&gt; &#xA;&lt;p&gt;;; Or, if you remember the format specifiers:&lt;/p&gt; &#xA;&lt;p&gt;(ts-format &#34;%B, %Y&#34; (ts-parse-org &#34;&amp;lt;2015-09-24 Thu .+1d&amp;gt;&#34;)) ;;=&amp;gt; &#34;September, 2015&#34; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;How long ago was this date in 1970?&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (let* ((now (ts-now)) (then (ts-apply :year 1970 now))) (list (ts-format then) (ts-human-format-duration (ts-difference now then)))) ;;=&amp;gt; (&#34;1970-08-04 07:07:10 -0500&#34; ;; &#34;49 years, 12 days&#34;) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;How long ago did the epoch begin?&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (ts-human-format-duration (ts-diff (ts-now) (make-ts :unix 0))) ;;=&amp;gt; &#34;49 years, 227 days, 12 hours, 12 minutes, 30 seconds&#34; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;In which of the last 100 years was Christmas on a Saturday?&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (let ((ts (ts-parse &#34;2019-12-25&#34;)) (limit (- (ts-year (ts-now)) 100))) (cl-loop while (&amp;gt;= (ts-year ts) limit) when (string= &#34;Saturday&#34; (ts-day-name ts)) collect (ts-year ts) do (ts-decf (ts-year ts)))) ;;=&amp;gt; (2010 2004 1999 1993 1982 1976 1971 1965 1954 1948 1943 1937 1926 1920) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;For a more interesting example, does a timestamp fall within the previous calendar week?&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp ;; First, define a function to return the range of the previous calendar week.&lt;/p&gt; &#xA;&lt;p&gt;(defun last-week-range () &#34;Return timestamps (BEG . END) spanning the previous calendar week.&#34; (let* (;; Bind &lt;code&gt;now&#39; to the current timestamp to ensure all calculations ;; begin from the same timestamp. (In the unlikely event that ;; the execution of this code spanned from one day into the next, ;; that would cause a wrong result.) (now (ts-now)) ;; We start by calculating the offsets for the beginning and ;; ending timestamps using the current day of the week. Note ;; that the &lt;/code&gt;ts-dow&#39; slot uses the &#34;%w&#34; format specifier, which ;; counts from Sunday to Saturday as a number from 0 to 6. (adjust-beg-day (- (+ 7 (ts-dow now)))) (adjust-end-day (- (- 7 (- 6 (ts-dow now))))) ;; Make beginning/end timestamps based on &lt;code&gt;now&#39;, with adjusted ;; day and hour/minute/second values. These functions return ;; new timestamps, so &lt;/code&gt;now&#39; is unchanged. (beg (thread-last now ;; &lt;code&gt;ts-adjust&#39; makes relative adjustments to timestamps. (ts-adjust &#39;day adjust-beg-day) ;; &lt;/code&gt;ts-apply&#39; applies absolute values to timestamps. (ts-apply :hour 0 :minute 0 :second 0))) (end (thread-last now (ts-adjust &#39;day adjust-end-day) (ts-apply :hour 23 :minute 59 :second 59)))) (cons beg end)))&lt;/p&gt; &#xA;&lt;p&gt;(-let* (;; Bind the default format string for `ts-format&#39;, so the ;; results are easy to understand. (ts-default-format &#34;%a, %Y-%m-%d %H:%M:%S %z&#34;) ;; Get the timestamp for 3 days before now. (check-ts (ts-adjust &#39;day -3 (ts-now))) ;; Get the range for the previous week from the function we defined. ((beg . end) (last-week-range))) (list :last-week-beg (ts-format beg) :check-ts (ts-format check-ts) :last-week-end (ts-format end) :in-range-p (ts-in beg end check-ts))) ;;=&amp;gt; (:last-week-beg &#34;Sun, 2019-08-04 00:00:00 -0500&#34; ;; :check-ts &#34;Fri, 2019-08-09 10:00:34 -0500&#34; ;; :last-week-end &#34;Sat, 2019-08-10 23:59:59 -0500&#34; ;; :in-range-p t) #+END_SRC&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Accessors&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-B (STRUCT)&lt;/del&gt; :: Access slot &#34;month-name&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-H (STRUCT)&lt;/del&gt; :: Access slot &#34;hour&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-M (STRUCT)&lt;/del&gt; :: Access slot &#34;minute&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-S (STRUCT)&lt;/del&gt; :: Access slot &#34;second&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-Y (STRUCT)&lt;/del&gt; :: Access slot &#34;year&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-b (STRUCT)&lt;/del&gt; :: Access slot &#34;month-abbr&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-d (STRUCT)&lt;/del&gt; :: Access slot &#34;day&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-day (STRUCT)&lt;/del&gt; :: Access slot &#34;day&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-day-abbr (STRUCT)&lt;/del&gt; :: Access slot &#34;day-abbr&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-day-name (STRUCT)&lt;/del&gt; :: Access slot &#34;day-name&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-day-of-month-num (STRUCT)&lt;/del&gt; :: Access slot &#34;day&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-day-of-week-abbr (STRUCT)&lt;/del&gt; :: Access slot &#34;day-abbr&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-day-of-week-name (STRUCT)&lt;/del&gt; :: Access slot &#34;day-name&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-day-of-week-num (STRUCT)&lt;/del&gt; :: Access slot &#34;dow&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-day-of-year (STRUCT)&lt;/del&gt; :: Access slot &#34;doy&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-dom (STRUCT)&lt;/del&gt; :: Access slot &#34;day&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-dow (STRUCT)&lt;/del&gt; :: Access slot &#34;dow&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-doy (STRUCT)&lt;/del&gt; :: Access slot &#34;doy&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-hour (STRUCT)&lt;/del&gt; :: Access slot &#34;hour&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-internal (STRUCT)&lt;/del&gt; :: Access slot &#34;internal&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;. Slot represents an Emacs-internal time value (e.g. as returned by &lt;del&gt;current-time&lt;/del&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-m (STRUCT)&lt;/del&gt; :: Access slot &#34;month&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-min (STRUCT)&lt;/del&gt; :: Access slot &#34;minute&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-minute (STRUCT)&lt;/del&gt; :: Access slot &#34;minute&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-month (STRUCT)&lt;/del&gt; :: Access slot &#34;month&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-month-abbr (STRUCT)&lt;/del&gt; :: Access slot &#34;month-abbr&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-month-name (STRUCT)&lt;/del&gt; :: Access slot &#34;month-name&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-month-num (STRUCT)&lt;/del&gt; :: Access slot &#34;month&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-moy (STRUCT)&lt;/del&gt; :: Access slot &#34;month&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-sec (STRUCT)&lt;/del&gt; :: Access slot &#34;second&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-second (STRUCT)&lt;/del&gt; :: Access slot &#34;second&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-tz-abbr (STRUCT)&lt;/del&gt; :: Access slot &#34;tz-abbr&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-tz-offset (STRUCT)&lt;/del&gt; :: Access slot &#34;tz-offset&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-unix (STRUCT)&lt;/del&gt; :: Access slot &#34;unix&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-week (STRUCT)&lt;/del&gt; :: Access slot &#34;woy&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-week-of-year (STRUCT)&lt;/del&gt; :: Access slot &#34;woy&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-woy (STRUCT)&lt;/del&gt; :: Access slot &#34;woy&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-year (STRUCT)&lt;/del&gt; :: Access slot &#34;year&#34; of &lt;del&gt;ts&lt;/del&gt; struct &lt;del&gt;STRUCT&lt;/del&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Adjustors&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-apply (&amp;amp;rest SLOTS TS)&lt;/del&gt; :: Return new timestamp based on &lt;del&gt;TS&lt;/del&gt; with new slot values. Fill timestamp slots, overwrite given slot values, and return new timestamp with Unix timestamp value derived from new slot values. &lt;del&gt;SLOTS&lt;/del&gt; is a list of alternating key-value pairs like that passed to &lt;del&gt;make-ts&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-adjust (&amp;amp;rest ADJUSTMENTS)&lt;/del&gt; :: Return new timestamp having applied &lt;del&gt;ADJUSTMENTS&lt;/del&gt; to &lt;del&gt;TS&lt;/del&gt;. &lt;del&gt;ADJUSTMENTS&lt;/del&gt; should be a series of alternating &lt;del&gt;SLOTS&lt;/del&gt; and &lt;del&gt;VALUES&lt;/del&gt; by which to adjust them. For example, this form returns a new timestamp that is 47 hours into the future:&lt;/p&gt; &lt;p&gt;&lt;del&gt;(ts-adjust ’hour -1 ’day +2 (ts-now))&lt;/del&gt;&lt;/p&gt; &lt;p&gt;Since the timestamp argument is last, it’s suitable for use in a threading macro.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-dec (SLOT VALUE TS)&lt;/del&gt; :: Return a new timestamp based on &lt;del&gt;TS&lt;/del&gt; with its &lt;del&gt;SLOT&lt;/del&gt; decremented by &lt;del&gt;VALUE&lt;/del&gt;. &lt;del&gt;SLOT&lt;/del&gt; should be specified as a plain symbol, not a keyword.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-inc (SLOT VALUE TS)&lt;/del&gt; :: Return a new timestamp based on &lt;del&gt;TS&lt;/del&gt; with its &lt;del&gt;SLOT&lt;/del&gt; incremented by &lt;del&gt;VALUE&lt;/del&gt;. &lt;del&gt;SLOT&lt;/del&gt; should be specified as a plain symbol, not a keyword.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-update (TS)&lt;/del&gt; :: Return timestamp &lt;del&gt;TS&lt;/del&gt; after updating its Unix timestamp from its other slots. Non-destructive. To be used after setting slots with, e.g. &lt;del&gt;ts-fill&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Destructive&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-adjustf (TS &amp;amp;rest ADJUSTMENTS)&lt;/del&gt; :: Return timestamp &lt;del&gt;TS&lt;/del&gt; having applied &lt;del&gt;ADJUSTMENTS&lt;/del&gt;. This function is destructive, as it calls &lt;del&gt;setf&lt;/del&gt; on &lt;del&gt;TS&lt;/del&gt;.&lt;/p&gt; &lt;p&gt;&lt;del&gt;ADJUSTMENTS&lt;/del&gt; should be a series of alternating &lt;del&gt;SLOTS&lt;/del&gt; and &lt;del&gt;VALUES&lt;/del&gt; by which to adjust them. For example, this form adjusts a timestamp to 47 hours into the future:&lt;/p&gt; &lt;p&gt;&lt;del&gt;(let ((ts (ts-now))) (ts-adjustf ts ’hour -1 ’day +2))&lt;/del&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-decf (PLACE &amp;amp;optional (VALUE 1))&lt;/del&gt; :: Decrement timestamp &lt;del&gt;PLACE&lt;/del&gt; by &lt;del&gt;VALUE&lt;/del&gt; (default 1), update its Unix timestamp, and return the new value of &lt;del&gt;PLACE&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-incf (PLACE &amp;amp;optional (VALUE 1))&lt;/del&gt; :: Increment timestamp &lt;del&gt;PLACE&lt;/del&gt; by &lt;del&gt;VALUE&lt;/del&gt; (default 1), update its Unix timestamp, and return the new value of &lt;del&gt;PLACE&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Comparators&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-in (BEG END TS)&lt;/del&gt; :: Return non-nil if &lt;del&gt;TS&lt;/del&gt; is within range &lt;del&gt;BEG&lt;/del&gt; to &lt;del&gt;END&lt;/del&gt;, inclusive. All arguments should be &lt;del&gt;ts&lt;/del&gt; structs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts&amp;lt; (A B)&lt;/del&gt; :: Return non-nil if timestamp &lt;del&gt;A&lt;/del&gt; is less than timestamp &lt;del&gt;B&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts&amp;lt;= (A B)&lt;/del&gt; :: Return non-nil if timestamp &lt;del&gt;A&lt;/del&gt; is &amp;lt;= timestamp &lt;del&gt;B&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts= (A B)&lt;/del&gt; :: Return non-nil if timestamp &lt;del&gt;A&lt;/del&gt; is the same as timestamp &lt;del&gt;B&lt;/del&gt;. Compares only the timestamps’ &lt;del&gt;unix&lt;/del&gt; slots. Note that a timestamp’s Unix slot is a float and may differ by less than one second, causing them to be unequal even if all of the formatted parts of the timestamp are the same.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts&amp;gt; (A B)&lt;/del&gt; :: Return non-nil if timestamp &lt;del&gt;A&lt;/del&gt; is greater than timestamp &lt;del&gt;B&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts&amp;gt;= (A B)&lt;/del&gt; :: Return non-nil if timestamp &lt;del&gt;A&lt;/del&gt; is &amp;gt;= timestamp &lt;del&gt;B&lt;/del&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Duration&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-human-duration (SECONDS)&lt;/del&gt; :: Return plist describing duration &lt;del&gt;SECONDS&lt;/del&gt; in years, days, hours, minutes, and seconds. This is a simple calculation that does not account for leap years, leap seconds, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-human-format-duration (SECONDS &amp;amp;optional ABBREVIATE)&lt;/del&gt; :: Return human-formatted string describing duration &lt;del&gt;SECONDS&lt;/del&gt;. If &lt;del&gt;SECONDS&lt;/del&gt; is less than 1, returns &lt;del&gt;&#34;0 seconds&#34;&lt;/del&gt;. If &lt;del&gt;ABBREVIATE&lt;/del&gt; is non-nil, return a shorter version, without spaces. This is a simple calculation that does not account for leap years, leap seconds, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Formatting&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-format (&amp;amp;optional TS-OR-FORMAT-STRING TS)&lt;/del&gt; :: Format timestamp with &lt;del&gt;format-time-string&lt;/del&gt;. If &lt;del&gt;TS-OR-FORMAT-STRING&lt;/del&gt; is a timestamp or nil, use the value of &lt;del&gt;ts-default-format&lt;/del&gt;. If both &lt;del&gt;TS-OR-FORMAT-STRING&lt;/del&gt; and &lt;del&gt;TS&lt;/del&gt; are nil, use the current time.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Parsing&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-parse (STRING)&lt;/del&gt; :: Return new &lt;del&gt;ts&lt;/del&gt; struct, parsing &lt;del&gt;STRING&lt;/del&gt; with &lt;del&gt;parse-time-string&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-parse-fill (FILL STRING)&lt;/del&gt; :: Return new &lt;del&gt;ts&lt;/del&gt; struct, parsing &lt;del&gt;STRING&lt;/del&gt; with &lt;del&gt;parse-time-string&lt;/del&gt;. Empty hour/minute/second values are filled according to &lt;del&gt;FILL&lt;/del&gt;: if &lt;del&gt;begin&lt;/del&gt;, with 0; if &lt;del&gt;end&lt;/del&gt;, hour is filled with 23 and minute/second with 59; if nil, an error may be signaled when time values are empty. Note that when &lt;del&gt;FILL&lt;/del&gt; is &lt;del&gt;end&lt;/del&gt;, a time value like &#34;12:12&#34; is filled to &#34;12:12:00&#34;, not &#34;12:12:59&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-parse-org (ORG-TS-STRING)&lt;/del&gt; :: Return timestamp object for Org timestamp string &lt;del&gt;ORG-TS-STRING&lt;/del&gt;. Note that function &lt;del&gt;org-parse-time-string&lt;/del&gt; is called, which should be loaded before calling this function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-parse-org-fill (FILL ORG-TS-STRING)&lt;/del&gt; :: Return timestamp object for Org timestamp string &lt;del&gt;ORG-TS-STRING&lt;/del&gt;. Note that function &lt;del&gt;org-parse-time-string&lt;/del&gt; is called, which should be loaded before calling this function. Hour/minute/second values are filled according to &lt;del&gt;FILL&lt;/del&gt;: if &lt;del&gt;begin&lt;/del&gt;, with 0; if &lt;del&gt;end&lt;/del&gt;, hour is filled with 23 and minute/second with 59. Note that &lt;del&gt;org-parse-time-string&lt;/del&gt; does not support timestamps that contain seconds.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-parse-org-element (ELEMENT)&lt;/del&gt; :: Return timestamp object for Org timestamp element &lt;del&gt;ELEMENT&lt;/del&gt;. Element should be like one parsed by &lt;del&gt;org-element&lt;/del&gt;, the first element of which is &lt;del&gt;timestamp&lt;/del&gt;. Assumes timestamp is not a range.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Misc.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;copy-ts (TS)&lt;/del&gt; :: Return copy of timestamp struct &lt;del&gt;TS&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-difference (A B)&lt;/del&gt; :: Return difference in seconds between timestamps &lt;del&gt;A&lt;/del&gt; and &lt;del&gt;B&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-diff&lt;/del&gt; :: Alias for &lt;del&gt;ts-difference&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-fill (TS &amp;amp;optional ZONE)&lt;/del&gt; :: Return &lt;del&gt;TS&lt;/del&gt; having filled all slots from its Unix timestamp. This is non-destructive. &lt;del&gt;ZONE&lt;/del&gt; is passed to &lt;del&gt;format-time-string&lt;/del&gt;, which see.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-now&lt;/del&gt; :: Return &lt;del&gt;ts&lt;/del&gt; struct set to now.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-p (STRUCT)&lt;/del&gt; ::&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-reset (TS)&lt;/del&gt; :: Return &lt;del&gt;TS&lt;/del&gt; with all slots cleared except &lt;del&gt;unix&lt;/del&gt;. Non-destructive. The same as:&lt;/p&gt; &lt;p&gt;&lt;del&gt;(make-ts :unix (ts-unix ts))&lt;/del&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;ts-defstruct (&amp;amp;rest ARGS)&lt;/del&gt; :: Like &lt;del&gt;cl-defstruct&lt;/del&gt;, but with additional slot options.&lt;/p&gt; &lt;p&gt;Additional slot options and values:&lt;/p&gt; &lt;p&gt;&lt;del&gt;:accessor-init&lt;/del&gt;: a sexp that initializes the slot in the accessor if the slot is nil. The symbol &lt;del&gt;struct&lt;/del&gt; will be bound to the current struct. The accessor is defined after the struct is fully defined, so it may refer to the struct definition (e.g. by using the &lt;del&gt;cl-struct&lt;/del&gt; &lt;del&gt;pcase&lt;/del&gt; macro).&lt;/p&gt; &lt;p&gt;&lt;del&gt;:aliases&lt;/del&gt;: &lt;del&gt;A&lt;/del&gt; list of symbols which will be aliased to the slot accessor, prepended with the struct name (e.g. a struct &lt;del&gt;ts&lt;/del&gt; with slot &lt;del&gt;year&lt;/del&gt; and alias &lt;del&gt;y&lt;/del&gt; would create an alias &lt;del&gt;ts-y&lt;/del&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tips :PROPERTIES: :TOC: :depth 0 :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &lt;del&gt;ts-human-format-duration&lt;/del&gt; vs. &lt;del&gt;format-seconds&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Emacs has a built-in function, &lt;del&gt;format-seconds&lt;/del&gt;, that produces output similar to that of &lt;del&gt;ts-human-format-duration&lt;/del&gt;. Its output is also controllable with a format string. However, if the output of &lt;del&gt;ts-human-format-duration&lt;/del&gt; is sufficient, it performs much better than &lt;del&gt;format-seconds&lt;/del&gt;. This simple benchmark, run 100,000 times, shows that it runs much faster and generates less garbage:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (bench-multi-lexical :times 100000 :forms ((&#34;ts-human-format-duration&#34; (ts-human-format-duration 15780.910933971405 t)) (&#34;format-seconds&#34; (format-seconds &#34;%yy%dd%hh%mm%ss%z&#34; 15780.910933971405)))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: | Form | x faster than next | Total runtime | # of GCs | Total GC runtime | |--------------------------+--------------------+---------------+----------+------------------| | ts-human-format-duration | 5.82 | 0.832945 | 3 | 0.574929 | | format-seconds | slowest | 4.848253 | 17 | 3.288799 |&lt;/p&gt; &#xA;&lt;p&gt;(See the [[https://github.com/alphapapa/emacs-package-dev-handbook][Emacs Package Developer&#39;s Handbook]] for the &lt;del&gt;bench-multi-lexical&lt;/del&gt; macro.)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Changelog :PROPERTIES: :TOC: :depth 0 :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** 0.3&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Added&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Function &lt;del&gt;ts-fill&lt;/del&gt; accepts a &lt;del&gt;ZONE&lt;/del&gt; argument, like that passed to &lt;del&gt;format-time-string&lt;/del&gt;, which see.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** 0.2.1&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Fixed&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;ts-human-format-duration&lt;/del&gt; returned an empty string for durations less than 1 second (now returns &lt;del&gt;&#34;0 seconds&#34;&lt;/del&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** 0.2&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Added&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Functions &lt;del&gt;ts-parse-fill&lt;/del&gt; and &lt;del&gt;ts-parse-org-fill&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Function &lt;del&gt;ts-in&lt;/del&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Changed&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Function &lt;del&gt;ts-now&lt;/del&gt; is no longer inlined. This allows it to be changed at runtime with, e.g. &lt;del&gt;cl-letf&lt;/del&gt;, which is helpful in testing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Fixed&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Save match data in =ts-fill=. (Function =split-string=, which is called in it, modifies the match data.)&lt;/li&gt; &#xA; &lt;li&gt;Save match data in =ts-parse-org=. (Function =org-parse-time-string=, which is called in it, modifies the match data.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Documentation&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Improve description and commentary.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** 0.1&lt;/p&gt; &#xA;&lt;p&gt;First tagged release. Published to MELPA.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;License :PROPERTIES: :TOC: :ignore this :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;GPLv3&lt;/p&gt; &#xA;&lt;h1&gt;Local Variables:&lt;/h1&gt; &#xA;&lt;h1&gt;eval: (require &#39;org-make-toc)&lt;/h1&gt; &#xA;&lt;h1&gt;before-save-hook: org-make-toc&lt;/h1&gt; &#xA;&lt;h1&gt;org-export-with-properties: ()&lt;/h1&gt; &#xA;&lt;h1&gt;org-export-with-title: t&lt;/h1&gt; &#xA;&lt;h1&gt;End:&lt;/h1&gt;</summary>
  </entry>
</feed>