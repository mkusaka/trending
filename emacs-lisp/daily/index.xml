<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-30T01:34:44Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>foxfriday/evil-ts</title>
    <updated>2023-03-30T01:34:44Z</updated>
    <id>tag:github.com,2023-03-30:/foxfriday/evil-ts</id>
    <link href="https://github.com/foxfriday/evil-ts" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Actions for Emacs evil-mode using the new built-in tree sitter library.&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;Evil Ts Mode&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This package provides some basic additional actions for &lt;del&gt;evil-mode&lt;/del&gt; using the new built-in tree sitter library. The package only works with Emacs 29 or greater. To activate, just run &lt;del&gt;M-x evil-ts-mode&lt;/del&gt;. This was so easy to do, that it hardly merits a package. But perhaps it will be useful to someone.&lt;/p&gt; &#xA;&lt;p&gt;In visual mode, you can select a &lt;del&gt;if/try/etc statement&lt;/del&gt; with &lt;del&gt;s&lt;/del&gt;. So when you are inside an if statement, the sequence &lt;del&gt;vas&lt;/del&gt; will select it. Similarly, &lt;del&gt;f&lt;/del&gt; selects a function and &lt;del&gt;c&lt;/del&gt; selects a class. On these cases, there is no difference between inner and outer text objects.&lt;/p&gt; &#xA;&lt;p&gt;In normal state, you can move to the beginning or the end of a class with &lt;del&gt;[c&lt;/del&gt; and &lt;del&gt;]c&lt;/del&gt;. Similarly, &lt;del&gt;[f&lt;/del&gt; and &lt;del&gt;]f&lt;/del&gt; moves you to the start or end of a function. And &lt;del&gt;[w&lt;/del&gt; moves you to the start of a sentence, and &lt;del&gt;]w&lt;/del&gt; to the end (these last two bindings are not great, but &lt;del&gt;]s&lt;/del&gt; is usually taken for navigating spelling errors). I created this package for my own personal use, so the default bindings may not be what you want. Of course, you can change that. The mode map is &lt;del&gt;evil-ts-mode-map&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Adding new objects is simple. Open &lt;del&gt;treesit-explore-mode&lt;/del&gt; and find the node of interest. The following example, shows how to add a text object for try or if statements and map it to &lt;del&gt;i&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes (require rx)&lt;/p&gt; &#xA;&lt;p&gt;(evil-define-text-object my-if-or-try (count &amp;amp;optional beg end type) (evil-ts-select-obj (rx (or &#34;if&#34; &#34;for&#34; &#34;with&#34; &#34;try&#34;) &#34;_statement&#34;)))&lt;/p&gt; &#xA;&lt;p&gt;(keymap-set evil-inner-text-objects-map &#34;i&#34; &#39;my-if-or-try) (keymap-set evil-outer-text-objects-map &#34;i&#34; &#39;my-if-or-try) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Installation&lt;/p&gt; &#xA;&lt;p&gt;With straight:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (straight-use-package &#39;(evil-ts :type git :host github :repo &#34;foxfriday/evil-ts&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can also use the new &lt;del&gt;vc-install&lt;/del&gt; functions. This is what I do:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :tangle yes (defun extra-github-install (repo dest &amp;amp;optional branch) &#34;Clone BRANCH of REPO in DEST and install.&#34; (let* ((remote (concat &#34;&lt;a href=&#34;https://github.com/&#34;&gt;https://github.com/&lt;/a&gt;&#34; repo &#34;.git&#34;)) (name (nth 1 (string-split repo &#34;/&#34;))) (pkg (intern name)) (local (file-name-concat (expand-file-name dest) name)) (branch (if branch branch &#34;main&#34;))) (unless (file-directory-p local) (vc-clone remote &#39;Git local branch)) (unless (package-installed-p pkg) (package-vc-install-from-checkout local name))))&lt;/p&gt; &#xA;&lt;p&gt;(extra-github-install &#34;foxfriday/evil-ts&#34; &#34;~/Repos/emacs&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Troubleshooting&lt;/p&gt; &#xA;&lt;p&gt;Make sure that you installed the tree sitter modules, and that your Emacs build includes native support for tree sitter. The easiest way to install the modules is to use [[https://github.com/casouri/tree-sitter-module][these]] scripts. You may also want to activate the built-in tree sitter modes, though that&#39;s not strictly necessary. You do need to let &lt;del&gt;treesit&lt;/del&gt; know the location of the modules. All that can be done by adding the following in your &lt;del&gt;init.el&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ; required. Assumes that the modules are in your emacs directory, inside ; the subdirectory &#39;ts&#39;. (setq treesit-extra-load-path (list (concat user-emacs-directory &#34;ts/&#34;))) ; optional, use tree sitter modes. (setq major-mode-remap-alist &#39;((c++-mode . c++-ts-mode) (c-mode . c-ts-mode) (c-or-c++-mode . c-or-c++-ts-mode) (conf-toml-mode . toml-ts-mode) (csharp-mode . csharp-ts-mode) (css-mode . css-ts-mode) (java-mode . java-ts-mode) (js-json-mode . json-ts-mode) (python-mode . python-ts-mode) (ruby-mode . ruby-ts-mode) (sh-mode . bash-ts-mode))) ; tree-sitter only modes (add-to-list &#39;auto-mode-alist &#39;(&#34;CMakeLists\&#39;&#34; . cmake-ts-mode)) (add-to-list &#39;auto-mode-alist &#39;(&#34;Dockerfile\&#39;&#34; . dockerfile-ts-mode)) (add-to-list &#39;auto-mode-alist &#39;(&#34;\.go\&#39;&#34; . go-ts-mode)) (add-to-list &#39;auto-mode-alist &#39;(&#34;/go\.mod\&#39;&#34; . go-mod-ts-mode)) (add-to-list &#39;auto-mode-alist &#39;(&#34;\.rs\&#39;&#34; . rust-ts-mode)) (add-to-list &#39;auto-mode-alist &#39;(&#34;\.tsx\&#39;&#34; . tsx-ts-mode)) (add-to-list &#39;auto-mode-alist &#39;(&#34;\.ts\&#39;&#34; . typescript-ts-mode)) (add-to-list &#39;auto-mode-alist &#39;(&#34;\.y[a]?ml\&#39;&#34; . yaml-ts-mode)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Similar Packages&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/meain/evil-textobj-tree-sitter][Evil-textobj-tree-sitter]] provides similar functionality without the &#34;Emacs 29 or greater&#34; requirement, and it is available on Melpa. Evil-ts works with the built in treesit package so it needs Emacs 29.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>skeeto/elisp-latch</title>
    <updated>2023-03-30T01:34:44Z</updated>
    <id>tag:github.com,2023-03-30:/skeeto/elisp-latch</id>
    <link href="https://github.com/skeeto/elisp-latch" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Promises and latches for Emacs Lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Promises and Latches for Emacs Lisp&lt;/h1&gt; &#xA;&lt;p&gt;This package (ab)uses &lt;code&gt;accept-process-output&lt;/code&gt; and processes to provide asynchronous blocking, allowing other functions to run before the current execution context completes. All blocking will freeze the Emacs display, but timers and I/O will continue to run. Use with caution.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Promises have &lt;code&gt;deliver&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;;; Make promise&#xA;(defvar p (make-promise))&#xA;&#xA;;; Deliver a value to the promise in 5 seconds.&#xA;(run-at-time 5 nil #&#39;deliver p &#34;Hello, world&#34;)&#xA;&#xA;;; Retrieve the value from the promise. This blocks until a value is&#xA;;; delivered. The timer can still deliver a value when this is&#xA;;; blocked, but Emacs&#39; display will freeze.&#xA;(retrieve p)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Latches have &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;notify&lt;/code&gt;, which can optionally pass a value.&lt;/p&gt; &#xA;&lt;p&gt;This example turns an asynchronous function into a synchronous one. The function &lt;code&gt;skewer-eval&lt;/code&gt; takes a string containing JavaScript and a callback, &lt;code&gt;eval&lt;/code&gt;s the string in a browser, and gives the evaluation result to the callback. Say we&#39;d rather return the value directly,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(defun skewer-eval-synchronously (js-code)&#xA;  (lexical-let ((latch (make-one-time-latch)))&#xA;    (skewer-eval js-code (apply-partially #&#39;notify latch))&#xA;    (wait latch)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Garbage Collection&lt;/h2&gt; &#xA;&lt;p&gt;Latches use processes underneath and are not properly garbage collected. Use the &lt;code&gt;destroy&lt;/code&gt; method to destroy them when done using them, or use a one-time-latch which will destroy itself automatically. Use &lt;code&gt;destroy-all-latches&lt;/code&gt; when you&#39;re debugging/experimenting and made a mess of things.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>skeeto/ant-project-mode</title>
    <updated>2023-03-30T01:34:44Z</updated>
    <id>tag:github.com,2023-03-30:/skeeto/ant-project-mode</id>
    <link href="https://github.com/skeeto/ant-project-mode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs minor mode supporting Apache Ant projects&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ant-project-mode (minor mode)&lt;/h1&gt; &#xA;&lt;p&gt;This package provides the minor mode &lt;code&gt;ant-project-mode&lt;/code&gt; for use with java-mode and build.xml files. To install put this directory in your load-path.&lt;/p&gt; &#xA;&lt;p&gt;See the header comment in ant-project-mode.el for recommended usage.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Provides bindings for invoking Ant with various standard targets, a function for opening entire Ant-based projects at once, and YASnippet snippets.&lt;/p&gt;</summary>
  </entry>
</feed>