<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-02T01:40:50Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Alexander-Miller/pfuture</title>
    <updated>2022-08-02T01:40:50Z</updated>
    <id>tag:github.com,2022-08-02:/Alexander-Miller/pfuture</id>
    <link href="https://github.com/Alexander-Miller/pfuture" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;-&lt;em&gt;- fill-column: 100; eval: (auto-fill-mode t) -&lt;/em&gt;-&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Content :TOC:noexport:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#pfuture][Pfuture]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#what-it-is][What it is]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#practical-examples][Practical examples]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#with-a-future-object][With a Future object]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#with-a-callback][With a Callback]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#about-asyncel][About async.el]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pfuture ** What it is&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;pfuture.el offers a set of simple functions wrapping Emacs&#39; existing process creation capabilities. It allows to conveniently deal with external processes in an asynchronous manner without having to worry about stdout buffers and filter- &amp;amp; sentinel-functions.&lt;/p&gt; &#xA;&lt;p&gt;The following examples practically demonstrate its capabilities. Detailed and formal documentation can be found in each function&#39;s eldoc.&lt;/p&gt; &#xA;&lt;p&gt;** Practical examples&lt;/p&gt; &#xA;&lt;p&gt;Pfuture has 2 entry points.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;pfuture-new&lt;/del&gt; creates a &lt;del&gt;future&lt;/del&gt; object that can be stored, passed around to other functions and awaited to completion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;pfuture-callback&lt;/del&gt; allows starting an external process in a fire-and-forget fashion, alongside callbacks to execute when the process succeeds or fails, with full access to its output.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** With a Future object&lt;/p&gt; &#xA;&lt;p&gt;We can use pfuture to start an artficially long-running process (simulated with a sleep of 3 seconds) twice and wait until both futures complete. Despite sleeping twice only 3 seconds will have passed since the processes run in parallel.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (let ((start (float-time)) (future1 (pfuture-new &#34;sleep&#34; &#34;3&#34;)) (future2 (pfuture-new &#34;sleep&#34; &#34;3&#34;)) (future3 (pfuture-new &#34;echo&#34; &#34;All futures have finished after %s seconds.&#34;))) (pfuture-await future1 :timeout 4 :just-this-one nil) (pfuture-await future2 :timeout 4 :just-this-one nil) (pfuture-await future3 :timeout 4 :just-this-one nil) (message (pfuture-result future3) (round (- (float-time) start)))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Stdout and stderr in future objects are separate:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (let ((future (pfuture-new &#34;ls&#34; &#34;nonexsitent_file&#34;))) (pfuture-await-to-finish future) (message &#34;Future stdout: [%s]&#34; (string-trim (pfuture-result future))) (message &#34;Future stderr: [%s]&#34; (string-trim (pfuture-stderr future)))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Calls to &lt;del&gt;pfuture-await&lt;/del&gt; (and especially &lt;del&gt;pfuture-await-to-finish&lt;/del&gt;) are blocking, so it is important to set an appropriate timeout (default is 1 second) or to be really sure that the process is going to terminate.&lt;/p&gt; &#xA;&lt;p&gt;*** With a Callback&lt;/p&gt; &#xA;&lt;p&gt;Here we start another process and instead of keeping the future around and eventually awaiting it we can simply define what steps to take once the process has completed, depending on whether it failed or not.&lt;/p&gt; &#xA;&lt;p&gt;(Note that &lt;del&gt;pfuture-callback&lt;/del&gt; requires lexical scope)&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (defun showcase-error-callback (process status output) (message &#34;Pfuture Error!&#34;) (message &#34;Process: %s&#34; process) (message &#34;Status: %s&#34; status) (message &#34;Output: %s&#34; output))&lt;/p&gt; &#xA;&lt;p&gt;(let ((debug-callback (lambda (pfuture-process status _pfuture-buffer) (message &#34;Pfuture Debug: Process [%s] changed sttaus to [%s]&#34; pfuture-process status)))) (pfuture-callback [&#34;ls&#34; &#34;-alh&#34; &#34;.&#34;] :directory &#34;~/Documents/git/pfuture&#34; :name &#34;Pfuture Example&#34; :on-success (message &#34;Pfuture Finish:\n%s&#34; (pfuture-callback-output)) :on-error #&#39;showcase-error-callback :on-status-change debug-callback)) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;** About async.el&lt;/p&gt; &#xA;&lt;p&gt;You might be inclined to compare both packages since they both, at first glance, handle asynchronous processes, but in truth they have very little in common outside of their general asynchronous nature.&lt;/p&gt; &#xA;&lt;p&gt;Async.el allows you to start and handle an asynchronous Emacs instance, running Elisp code. Pfuture lets you start any external command like &lt;del&gt;git&lt;/del&gt; or &lt;del&gt;ls&lt;/del&gt; (as its mostly a wrapper around &lt;del&gt;make-process&lt;/del&gt;), and then read its output. So while the two packages may appear similar at first there is really nothing to compare.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacs-straight/let-alist</title>
    <updated>2022-08-02T01:40:50Z</updated>
    <id>tag:github.com,2022-08-02:/emacs-straight/let-alist</id>
    <link href="https://github.com/emacs-straight/let-alist" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mirror of the let-alist package from GNU ELPA, current as of 2022-08-02&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>Wilfred/ht.el</title>
    <updated>2022-08-02T01:40:50Z</updated>
    <id>tag:github.com,2022-08-02:/Wilfred/ht.el</id>
    <link href="https://github.com/Wilfred/ht.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The missing hash table library for Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ht.el&lt;/h1&gt; &#xA;&lt;p&gt;The missing hash table library for Emacs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://melpa.org/#/ht&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/ht-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/ht&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/ht-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/Wilfred/ht.el&#34;&gt;&lt;img src=&#34;https://travis-ci.org/Wilfred/ht.el.png?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-generate-toc again --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#htel&#34;&gt;ht.el&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#functions&#34;&gt;Functions&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#return-a-hash-table&#34;&gt;Return a hash table&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#accessing-the-hash-table&#34;&gt;Accessing the hash table&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#mutating-the-hash-table&#34;&gt;Mutating the hash table&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#iterating-over-the-hash-table&#34;&gt;Iterating over the hash table&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#predicates&#34;&gt;Predicates&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#converting-from-a-hash-table&#34;&gt;Converting from a hash table&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#converting-to-a-hash-table&#34;&gt;Converting to a hash table&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#macros&#34;&gt;Macros&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#returning-a-hash-table&#34;&gt;Returning a hash table&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#iterating-over-the-hash-table-anaphoric&#34;&gt;Iterating over the hash table (anaphoric)&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#why&#34;&gt;Why?&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#similar-libraries&#34;&gt;Similar libraries&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#changelog&#34;&gt;Changelog&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#running-tests&#34;&gt;Running tests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/#whats-an-alistplist&#34;&gt;What&#39;s an alist/plist?&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;h2&gt;Functions&lt;/h2&gt; &#xA;&lt;h3&gt;Return a hash table&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-create&lt;/code&gt; &lt;code&gt;(test?)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-merge&lt;/code&gt; &lt;code&gt;(&amp;amp;rest tables)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-copy&lt;/code&gt; &lt;code&gt;(table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-select&lt;/code&gt; &lt;code&gt;(function table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-reject&lt;/code&gt; &lt;code&gt;(function table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-select-keys&lt;/code&gt; &lt;code&gt;(table keys)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Accessing the hash table&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-get&lt;/code&gt; &lt;code&gt;(table key default?)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-get*&lt;/code&gt; &lt;code&gt;(table &amp;amp;rest keys)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-keys&lt;/code&gt; &lt;code&gt;(table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-values&lt;/code&gt; &lt;code&gt;(table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-items&lt;/code&gt; &lt;code&gt;(table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-find&lt;/code&gt; &lt;code&gt;(function table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-size&lt;/code&gt; &lt;code&gt;(table)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Mutating the hash table&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-set!&lt;/code&gt; &lt;code&gt;(table key value)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-update!&lt;/code&gt; &lt;code&gt;(table table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-remove!&lt;/code&gt; &lt;code&gt;(table key)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-clear!&lt;/code&gt; &lt;code&gt;(table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-reject!&lt;/code&gt; &lt;code&gt;(function table)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Iterating over the hash table&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-map&lt;/code&gt; &lt;code&gt;(function table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-each&lt;/code&gt; &lt;code&gt;(function table)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Predicates&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ht?&lt;/code&gt; &lt;code&gt;(table-or-object)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-contains?&lt;/code&gt; &lt;code&gt;(table key)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-equal?&lt;/code&gt; &lt;code&gt;(table1 table2)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-empty?&lt;/code&gt; &lt;code&gt;(table)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Converting from a hash table&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-&amp;gt;alist&lt;/code&gt; &lt;code&gt;(table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-&amp;gt;plist&lt;/code&gt; &lt;code&gt;(table)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Converting to a hash table&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ht&amp;lt;-alist&lt;/code&gt; &lt;code&gt;(alist test?)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht&amp;lt;-plist&lt;/code&gt; &lt;code&gt;(plist test?)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Macros&lt;/h2&gt; &#xA;&lt;h3&gt;Returning a hash table&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ht&lt;/code&gt; &lt;code&gt;(&amp;amp;rest pairs)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Iterating over the hash table (anaphoric)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-amap&lt;/code&gt; &lt;code&gt;(form table)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ht-aeach&lt;/code&gt; &lt;code&gt;(form table)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Creating a hash table and accessing it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;ht)&#xA;&#xA;(defun say-hello (name)&#xA;  (let ((greetings (ht (&#34;Bob&#34; &#34;Hey bob!&#34;)&#xA;                       (&#34;Chris&#34; &#34;Hi Chris!&#34;))))&#xA;    (ht-get greetings name &#34;Hello stranger!&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This could be alternatively written as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;ht)&#xA;&#xA;(defun say-hello (name)&#xA;  (let ((greetings (ht-create)))&#xA;    (ht-set! greetings &#34;Bob&#34; &#34;Hey Bob!&#34;)&#xA;    (ht-set! greetings &#34;Chris&#34; &#34;Hi Chris!&#34;)&#xA;    (ht-get greetings name &#34;Hello stranger!&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Accessing nested hash tables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(let ((alphabets (ht (&#34;Greek&#34; (ht (1 (ht (&#39;letter &#34;α&#34;)&#xA;                                         (&#39;name &#34;alpha&#34;)))&#xA;                                  (2 (ht (&#39;letter &#34;β&#34;)&#xA;                                         (&#39;name &#34;beta&#34;)))))&#xA;                     (&#34;English&#34; (ht (1 (ht (&#39;letter &#34;a&#34;)&#xA;                                           (&#39;name &#34;A&#34;)))&#xA;                                    (2 (ht (&#39;letter &#34;b&#34;)&#xA;                                           (&#39;name &#34;B&#34;))))))))&#xA;  (ht-get* alphabets &#34;Greek&#34; 1 &#39;letter))  ; =&amp;gt; &#34;α&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ht-get&lt;/code&gt; and &lt;code&gt;ht-get*&lt;/code&gt; have gv-setters and so will work with &lt;code&gt;setf&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(let ((table (ht-create)))&#xA;  (ht-set! table 1 &#34;A&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is equivalent to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(let ((table (ht-create)))&#xA;  (setf (ht-get table 1) &#34;A&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(let ((table (ht (1 (ht (2 (ht (3 &#34;three&#34;))))))))&#xA;  (ht-set! (ht-get (ht-get table 1) 2) 3 :three))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is equivalent to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(let ((table (ht (1 (ht (2 (ht (3 &#34;three&#34;))))))))&#xA;  (setf (ht-get* table 1 2 3) :three))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;Libraries like &lt;a href=&#34;https://github.com/magnars/s.el&#34;&gt;s.el&lt;/a&gt; (strings) and &lt;a href=&#34;https://github.com/magnars/dash.el&#34;&gt;dash.el&lt;/a&gt; (lists) have shown how much nicer Emacs lisp programming can be with good libraries. ht.el aims to similarly simplify working with hash tables.&lt;/p&gt; &#xA;&lt;p&gt;Common operations with hash tables (e.g. enumerate the keys) are too difficult in Emacs lisp.&lt;/p&gt; &#xA;&lt;p&gt;ht.el offers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A consistent naming scheme (contrast &lt;code&gt;make-hash-table&lt;/code&gt; with &lt;code&gt;puthash&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;A more natural argument ordering&lt;/li&gt; &#xA; &lt;li&gt;Mutation functions always return &lt;code&gt;nil&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;A more comprehensive range of hash table operations, including a conventional map (&lt;code&gt;ht-map&lt;/code&gt; returns a list, elisp&#39;s &lt;code&gt;maphash&lt;/code&gt; returns nil).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Similar libraries&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nicferrier/emacs-kv&#34;&gt;kv.el&lt;/a&gt; (focuses more on alists)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.emacswiki.org/emacs/mon-hash-utils.el&#34;&gt;mon-hash-utils&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;ht.el is available on &lt;a href=&#34;https://melpa.org/&#34;&gt;MELPA&lt;/a&gt; (recommended) and &lt;a href=&#34;http://marmalade-repo.org/&#34;&gt;Marmalade&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Add MELPA to your .emacs.d/init.el:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;package)&#xA;(add-to-list &#39;package-archives &#39;(&#34;melpa&#34; . &#34;https://melpa.org/packages/&#34;) t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then run &lt;code&gt;M-x package-install &amp;lt;RET&amp;gt; ht &amp;lt;RET&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;ht.el uses semantic versioning, so an incompatible API change will result in the major version increasing. See &lt;a href=&#34;https://raw.githubusercontent.com/Wilfred/ht.el/master/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt; for a history of all changes.&lt;/p&gt; &#xA;&lt;h2&gt;Running tests&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;M-x ht-run-tests&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s an alist/plist?&lt;/h2&gt; &#xA;&lt;p&gt;An alist is an association list, which is a list of pairs. It looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;((key1 . value1)&#xA; (key2 . value2)&#xA; (key3 . value3))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An alist can also look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;((key1 . value1)&#xA; (key2 . value2)&#xA; (key1 . oldvalue))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A plist is a property list, which is a flat list with an even number of items. It looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(key1 value1&#xA; key2 value2&#xA; key3 value3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both of these are slow. ht.el provides &lt;code&gt;ht&amp;lt;-alist&lt;/code&gt; and &lt;code&gt;ht&amp;lt;-plist&lt;/code&gt; to help you convert to hash tables. If you need to work with an alist or plist, use the functions &lt;code&gt;ht-&amp;gt;alist&lt;/code&gt; and &lt;code&gt;ht-&amp;gt;plist&lt;/code&gt; to convert an hash table to those formats.&lt;/p&gt;</summary>
  </entry>
</feed>