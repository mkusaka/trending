<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-20T01:33:44Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>CeleritasCelery/rune</title>
    <updated>2023-01-20T01:33:44Z</updated>
    <id>tag:github.com,2023-01-20:/CeleritasCelery/rune</id>
    <link href="https://github.com/CeleritasCelery/rune" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rust VM for Emacs&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;Rune &lt;em&gt;R&lt;/em&gt; ust &lt;em&gt;UN&lt;/em&gt; der &lt;em&gt;E&lt;/em&gt; macs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This project is an experimental Emacs lisp interpreter written in rust. The project is still at a very early phase and explores using Rust as an host language. See the [[file:design.org][design doc]] for more details. ** Status The current goal of this project is to eventually bootstrap all elisp builtin elisp files. This includes things like buffers, regex, file io, etc. The project currently features a elisp interpreter and bytecode VM to enable bootstrap.&lt;/p&gt; &#xA;&lt;p&gt;Development on this project is driven by trying to add new elisp files and seeing where things break. Most of the time, it is just missing builtin functions, but occasionally new functionality needs to be added.&lt;/p&gt; &#xA;&lt;p&gt;** Running The easiest way to run the interpreter is with &lt;del&gt;cargo run&lt;/del&gt;. Running with the load argument (&lt;del&gt;cargo run -- --load&lt;/del&gt;) will load the bootstrapped elisp and then exit. Running with the repl argument (&lt;del&gt;cargo run -- --repl&lt;/del&gt;) will open an elisp repl. Running with both arguments (&lt;del&gt;cargo run -- --load --repl&lt;/del&gt;) will load the elisp and then open the repl. Running with no arguments is equivalent to &lt;del&gt;cargo run -- --load&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;** Exploring this repo This project contains one library of derived macros in &lt;del&gt;fn_macros/&lt;/del&gt;. This defines the &lt;del&gt;defun&lt;/del&gt; proc macro for defining builtin functions. The rest of the code is contained in &lt;del&gt;src/&lt;/del&gt;. The modules are described below.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[file:src/core/object/][objects]] :: The basic objects used in the interpreter. These are modeled after Emacs objects using tagged pointers with inline fixnums. Conversion between different primitives and object types are also found here.&lt;/li&gt; &#xA; &lt;li&gt;[[file:src/reader.rs][reader]] :: The emacs lisp reader that translates a string to a cons cell. Due to the simple nature of lisp syntax, the reader is hand rolled and does not rely on any parsing libraries.&lt;/li&gt; &#xA; &lt;li&gt;[[file:src/core/env.rs][env]] :: The global obarray. Currently function bindings are global and immutable and value bindings are thread-local and mutable. When the ability is added to share data between threads, this will enable new threads to safely run functions without the need to copy them.&lt;/li&gt; &#xA; &lt;li&gt;[[file:src/core/gc.rs][gc]] :: Contains the allocator and garbage collector. All code for rooting and managing objects live here as well.&lt;/li&gt; &#xA; &lt;li&gt;[[src/bytecode.rs][bytecode]] :: The bytecode VM. This uses the same opcodes as Emacs and uses the bytecomp.el to compile.&lt;/li&gt; &#xA; &lt;li&gt;[[file:src/interpreter.rs][interpreter]] :: The basic elisp interpreter. This is used only to bootstrap the elisp byte-compiler.&lt;/li&gt; &#xA; &lt;li&gt;[[file:src/fns.rs][fns]], [[file:src/data.rs][data]], [[file:src/alloc.rs][alloc]] :: These modules contain definitions of builtin in functions. Some of these are just stubbed out until the functionality is actually needed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Contributing This project is moved forward by trying to load new elisp files and seeing what breaks. The best way to do that is with &lt;del&gt;cargo run&lt;/del&gt;, which will load the currently bootstrapped files. The bootstrapped files are located in [[file:src/main.rs][main.rs]] as part of the &lt;del&gt;load&lt;/del&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Usually what is needed is to implement more primitive functions. This is done with the [[file:fn_macros/lib.rs][defun]] macro. For example if we wanted to implement the &lt;del&gt;substring&lt;/del&gt; function, we would first look at the lisp signature.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (substring STRING &amp;amp;optional FROM TO) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Then we would translate the types to their rust equivalent. If the correct type is not known we can use &lt;del&gt;Object&lt;/del&gt;. In this example we would write our Rust signature as follows: #+begin_src rust #[defun] fn substring(string: &amp;amp;str, from: Option&#xA; &lt;i64&gt;&#xA;  , to: Option&#xA;  &lt;i64&gt;&#xA;   ) -&amp;gt; String {...} #+end_src&#xA;  &lt;/i64&gt;&#xA; &lt;/i64&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you run with &lt;del&gt;cargo run -- --load --repo&lt;/del&gt; that will load the current bootstrapped files and then open the REPL. From there you can run &lt;del&gt;(load &#34;/path/to/elisp/file.el&#34;)&lt;/del&gt; to try loading a new file. Files that are not bootstrapped are not yet included in this repo, but are part of [[https://github.com/emacs-mirror/emacs][Emacs]]. Once the file is bootstrapped it can be added to the [[file:lisp/][lisp directory]].&lt;/p&gt; &#xA;&lt;p&gt;** Blog posts&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://coredumped.dev/2021/10/21/building-an-emacs-lisp-vm-in-rust/][tagged pointers in Rust]] :: My initial approach to creating tagged pointers in rust. It serves as in intro to this project.&lt;/li&gt; &#xA; &lt;li&gt;[[https://coredumped.dev/2022/04/11/implementing-a-safe-garbage-collector-in-rust/][implementing a safe garbage collector]] :: An overview of the garbage collector used in this project and how Rust enables safe GC abstractions.&lt;/li&gt; &#xA; &lt;li&gt;[[https://coredumped.dev/2022/05/19/a-vision-of-a-multi-threaded-emacs/][A vision of a multi-threaded Emacs]] :: Some ideas about how to add multi-threading to the existing language. ** Further exploration&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/remacs/remacs][Remacs]] :: The original rust and Emacs project. Remacs took the approach of enabling interop between Emacs C core and rust, enabling them to replace parts of Emacs piecemeal. The project is currently unmaintained, but is a big inspiration for rune.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/emacs-ng/emacs-ng][emacs-ng]] :: The spiritual successor to remacs. This project integrates the Deno runtime into emacs, allowing you to write extensions in elisp or javascript. Which sounds cool if you happen to be a web developer. It really shows the power of integrating Emacs with a more mature ecosystem (which is part of the promise of rust).&lt;/li&gt; &#xA; &lt;li&gt;[[http://craftinginterpreters.com/][crafting interpreters]] :: This was a big inspiration for this project, and it probably one of the best introductions to programming language implementations.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>milkypostman/powerline</title>
    <updated>2023-01-20T01:33:44Z</updated>
    <id>tag:github.com,2023-01-20:/milkypostman/powerline</id>
    <link href="https://github.com/milkypostman/powerline" rel="alternate"></link>
    <summary type="html">&lt;p&gt;emacs powerline&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;powerline&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; This project is in maintenance mode and not currently being developed or maintained. Pull requests will be reviewed and accepted but may not get an immediate response. Sorry for the inconvenience.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Emacs version of the Vim powerline.&lt;/p&gt; &#xA;&lt;p&gt;This is a proposed version 2.0 of the original &lt;a href=&#34;http://www.emacswiki.org/emacs/PowerLine&#34;&gt;Emacs Powerline&lt;/a&gt; which is a fork of &lt;a href=&#34;https://github.com/Lokaltog/vim-powerline&#34;&gt;vim-powerline&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This version has utf-8 support enabled. The &lt;code&gt;utf-8&lt;/code&gt; separators will display a unicode character properly under mintty for example - as long as you have &lt;a href=&#34;https://github.com/Lokaltog/powerline-fonts&#34;&gt;patched fonts&lt;/a&gt; installed.&lt;/p&gt; &#xA;&lt;p&gt;By default, any terminal mode emacs will use the &lt;code&gt;utf-8&lt;/code&gt; separators.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;powerline)&#xA;(powerline-default-theme)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The second line customizes &lt;code&gt;mode-line-format&lt;/code&gt; according to the default theme.&lt;/p&gt; &#xA;&lt;p&gt;There are five builtin themes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;powerline-default-theme&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;powerline-center-theme&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;powerline-center-evil-theme&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;powerline-vim-theme&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;powerline-nano-theme&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can revert back to the original value of &lt;code&gt;mode-line-format&lt;/code&gt; that was being used when powerline was loaded using &lt;code&gt;powerline-revert&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Faces&lt;/h2&gt; &#xA;&lt;p&gt;The faces that powerline uses for the builtin themes are &lt;code&gt;powerline-active1&lt;/code&gt; and &lt;code&gt;powerline-active2&lt;/code&gt; for the active modeline, and &lt;code&gt;powerline-inactive1&lt;/code&gt; ande &lt;code&gt;powerline-inactive2&lt;/code&gt; for the inactive modelines. If you create your own theme, you can add as many faces as you want and pass those faces to the corresponding &lt;code&gt;powerline-*&lt;/code&gt; functions when creating your &lt;code&gt;mode-line-format&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Custom Themes&lt;/h2&gt; &#xA;&lt;p&gt;Please look over the &lt;code&gt;powerline-default-theme&lt;/code&gt; and &lt;code&gt;powerline-center-theme&lt;/code&gt; in &lt;a href=&#34;https://github.com/milkypostman/powerline/raw/master/powerline-themes.el&#34;&gt;&lt;code&gt;powerline-themes.el&lt;/code&gt;&lt;/a&gt; for examples of themes that involve different justifications of modeline text.&lt;/p&gt; &#xA;&lt;p&gt;You can write your own powerline theme by simply setting your own &lt;code&gt;mode-line-format&lt;/code&gt; to be an evaluation (&lt;code&gt;:eval&lt;/code&gt;) of the powerline functions. Notice in &lt;code&gt;powerline-default-theme&lt;/code&gt; the &lt;code&gt;let*&lt;/code&gt; defines two lists: &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; which are exactly the lists that define what goes on the left and right sides of the modeline. The &lt;code&gt;powerline-center-theme&lt;/code&gt; demonstrates how to &lt;em&gt;center&lt;/em&gt; justify part of the modeline and defines an additional &lt;code&gt;center&lt;/code&gt; list which is exactly the modeline components to be displayed in the middle section.&lt;/p&gt; &#xA;&lt;p&gt;In &lt;em&gt;most&lt;/em&gt; circumstances you should only need to modify the builtin themes unless you are trying to do a particularly unique layout.&lt;/p&gt; &#xA;&lt;h3&gt;Explanation&lt;/h3&gt; &#xA;&lt;p&gt;This theme does some tricks to improve performance and get all the text justified properly. First, it sets &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; to a list of powerline sections. You can easily re-utilize builtin modeline formatting by adding it as a raw powerline section. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(powerline-raw mode-line-mule-info nil &#39;l)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would add the formatting defined in &lt;code&gt;mode-line-mule-info&lt;/code&gt; to the modeline as it appears in the default modeline.&lt;/p&gt; &#xA;&lt;p&gt;The last line of this is what actually puts it all together, by concatonating the &lt;code&gt;lhs&lt;/code&gt;, some &#34;fill&#34; space, and &lt;code&gt;rhs&lt;/code&gt;. This &lt;em&gt;must&lt;/em&gt; be done to ensure that the padding in between the left and right sections properly fills the modeline.&lt;/p&gt; &#xA;&lt;h2&gt;Improvements from this rewrite:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cleaner code.&lt;/li&gt; &#xA; &lt;li&gt;Try to simply be a &lt;em&gt;library&lt;/em&gt; that provides functions for generating a mode-line&lt;/li&gt; &#xA; &lt;li&gt;Make right-aligned text actually be flush against the right side.&lt;/li&gt; &#xA; &lt;li&gt;Separators are designed to dynamically size their height based on the font settings.&lt;/li&gt; &#xA; &lt;li&gt;Separators spread their width to the nearest character width. (This is required to make right-aligned text actually be right-aligned)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Implementing New Separators&lt;/h2&gt; &#xA;&lt;p&gt;The function should return an XPM image created using the &lt;code&gt;create-image&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;There is a function called &lt;code&gt;memoize&lt;/code&gt; that will help make calling the function multiple times with the same parameters be much quicker by caching the return value.&lt;/p&gt; &#xA;&lt;p&gt;Each divider should have the signature: &lt;code&gt;(face1 face2 &amp;amp;optional height)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;face1&lt;/code&gt; : the left-hand face&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;face2&lt;/code&gt; : the right-hand face&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;height&lt;/code&gt; : specifies the height of the XPM, most of time this is &lt;code&gt;(font-char-height)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Separators should consider the &lt;code&gt;height&lt;/code&gt; when they are created so that the mode-line can change sizes based on the font height.&lt;/p&gt;</summary>
  </entry>
</feed>