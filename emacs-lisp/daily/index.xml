<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-23T01:28:01Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>alphapapa/org-protocol-capture-html</title>
    <updated>2023-08-23T01:28:01Z</updated>
    <id>tag:github.com,2023-08-23:/alphapapa/org-protocol-capture-html</id>
    <link href="https://github.com/alphapapa/org-protocol-capture-html" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Capture HTML from the browser selection into Emacs as org-mode content&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+PROPERTY: LOGGING nil&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;org-protocol-capture-html :noexport:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;org-protocol is awesome, but browsers do a pretty poor job of turning a page&#39;s HTML content into plain-text. However, Pandoc supports converting /from/ HTML /to/ org-mode, so we can use it to turn HTML into Org-mode content! It can even turn HTML tables into Org tables!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Screenshot :noexport:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here&#39;s an example of what you get in Emacs from capturing [[http://kitchingroup.cheme.cmu.edu/blog/2014/07/17/Pandoc-does-org-mode-now/][this page]]:&lt;/p&gt; &#xA;&lt;p&gt;[[screenshot.png]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contents :TOC:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#requirements][Requirements]]&lt;/li&gt; &#xA; &lt;li&gt;[[#installation][Installation]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#emacs][Emacs]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#bookmarklets][Bookmarklets]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#shell-script][Shell script]]&lt;/li&gt; &#xA; &lt;li&gt;[[#usage][Usage]]&lt;/li&gt; &#xA; &lt;li&gt;[[#changelog][Changelog]]&lt;/li&gt; &#xA; &lt;li&gt;[[#credits][Credits]]&lt;/li&gt; &#xA; &lt;li&gt;[[#appendix][Appendix]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#org-protocol-instructions][org-protocol Instructions]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#selection-grabbing-function][Selection-grabbing function]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#to-do][To-Do]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Requirements&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;[[http://orgmode.org/worg/org-contrib/org-protocol.html][org-protocol]]&lt;/em&gt;: This is what connects org-mode to the &#34;outside world&#34; using a MIME protocol handler. The instructions on the org-protocol page are a bit out of date, so you might want to try [[#org-protocol-instructions][these instructions]] instead.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/magnars/s.el][s.el]]&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Pandoc&lt;/em&gt;: Version 1.8 or later is required.&lt;/li&gt; &#xA; &lt;li&gt;The shell script uses =curl= to download URLs (if you use it in that mode).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation ** Emacs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Put =org-protocol-capture-html.el= in your =load-path= and add to your init file:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (require &#39;org-protocol-capture-html) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;*** org-capture Template&lt;/p&gt; &#xA;&lt;p&gt;You need a suitable =org-capture= template. I recommend this one. Whatever you choose, the default selection key is =w=, so if you want to use a different key, you&#39;ll need to modify the script and the bookmarklets.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (&#34;w&#34; &#34;Web site&#34; entry (file &#34;&#34;) &#34;* %a :website:\n\n%U %?\n\n%:initial&#34;) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;** Bookmarklets&lt;/p&gt; &#xA;&lt;p&gt;Now you need to make a bookmarklet in your browser(s) of choice. You can select text in the page when you capture and it will be copied into the template, or you can just capture the page title and URL. A [[#selection-grabbing-function][selection-grabbing function]] is used to capture the selection.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; The =w= in the URL in these bookmarklets chooses the corresponding capture template. You can leave it out if you want to be prompted for the template, or change it to another letter for a different template key.&lt;/p&gt; &#xA;&lt;p&gt;*** Firefox&lt;/p&gt; &#xA;&lt;p&gt;This bookmarklet captures what is currently selected in the browser. Or if nothing is selected, it just captures the page&#39;s URL and title.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC js javascript:location.href = &#39;org-protocol://capture-html?template=w&amp;amp;url=&#39; + encodeURIComponent(location.href) + &#39;&amp;amp;title=&#39; + encodeURIComponent(document.title || &#34;[untitled page]&#34;) + &#39;&amp;amp;body=&#39; + encodeURIComponent(function () {var html = &#34;&#34;; if (typeof document.getSelection != &#34;undefined&#34;) {var sel = document.getSelection(); if (sel.rangeCount) {var container = document.createElement(&#34;div&#34;); for (var i = 0, len = sel.rangeCount; i &amp;lt; len; ++i) {container.appendChild(sel.getRangeAt(i).cloneContents());} html = container.innerHTML;}} else if (typeof document.selection != &#34;undefined&#34;) {if (document.selection.type == &#34;Text&#34;) {html = document.selection.createRange().htmlText;}} var relToAbs = function (href) {var a = document.createElement(&#34;a&#34;); a.href = href; var abs = a.protocol + &#34;//&#34; + a.host + a.pathname + a.search + a.hash; a.remove(); return abs;}; var elementTypes = [[&#39;a&#39;, &#39;href&#39;], [&#39;img&#39;, &#39;src&#39;]]; var div = document.createElement(&#39;div&#39;); div.innerHTML = html; elementTypes.map(function(elementType) {var elements = div.getElementsByTagName(elementType[0]); for (var i = 0; i &amp;lt; elements.length; i++) {elements[i].setAttribute(elementType[1], relToAbs(elements[i].getAttribute(elementType[1])));}}); return div.innerHTML;}()); #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This one uses =eww=&#39;s built-in readability-scoring function in Emacs 25.1 and up to capture the article or main content of the page.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC js javascript:location.href = &#39;org-protocol://capture-eww-readable?template=w&amp;amp;url=&#39; + encodeURIComponent(location.href) + &#39;&amp;amp;title=&#39; + encodeURIComponent(document.title || &#34;[untitled page]&#34;); #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; When you click on one of these bookmarklets for the first time, Firefox will ask what program to use to handle the =org-protocol= protocol. You can simply choose the default program that appears (=org-protocol=).&lt;/p&gt; &#xA;&lt;p&gt;*** Pentadactyl&lt;/p&gt; &#xA;&lt;p&gt;If you use [[http://5digits.org/pentadactyl/][Pentadactyl]], you can use the Firefox &lt;em&gt;bookmarklets&lt;/em&gt; above, or you can put these &lt;em&gt;commands&lt;/em&gt; in your =.pentadactylrc=:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC js map -modes=n,v ch -javascript content.location.href = &#39;org-protocol://capture-html?template=w&amp;amp;url=&#39; + encodeURIComponent(content.location.href) + &#39;&amp;amp;title=&#39; + encodeURIComponent(content.document.title || &#34;[untitled page]&#34;) + &#39;&amp;amp;body=&#39; + encodeURIComponent(function () {var html = &#34;&#34;; if (typeof content.document.getSelection != &#34;undefined&#34;) {var sel = content.document.getSelection(); if (sel.rangeCount) {var container = document.createElement(&#34;div&#34;); for (var i = 0, len = sel.rangeCount; i &amp;lt; len; ++i) {container.appendChild(sel.getRangeAt(i).cloneContents());} html = container.innerHTML;}} else if (typeof document.selection != &#34;undefined&#34;) {if (document.selection.type == &#34;Text&#34;) {html = document.selection.createRange().htmlText;}} var relToAbs = function (href) {var a = content.document.createElement(&#34;a&#34;); a.href = href; var abs = a.protocol + &#34;//&#34; + a.host + a.pathname + a.search + a.hash; a.remove(); return abs;}; var elementTypes = [[&#39;a&#39;, &#39;href&#39;], [&#39;img&#39;, &#39;src&#39;]]; var div = content.document.createElement(&#39;div&#39;); div.innerHTML = html; elementTypes.map(function(elementType) {var elements = div.getElementsByTagName(elementType[0]); for (var i = 0; i &amp;lt; elements.length; i++) {elements[i].setAttribute(elementType[1], relToAbs(elements[i].getAttribute(elementType[1])));}}); return div.innerHTML;}())&lt;/p&gt; &#xA;&lt;p&gt;map -modes=n,v ce -javascript location.href=&#39;org-protocol://capture-eww-readable?template=w&amp;amp;url=&#39;+encodeURIComponent(content.location.href)+&#39;&amp;amp;title=&#39;+encodeURIComponent(content.document.title || &#34;[untitled page]&#34;) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; The JavaScript objects are slightly different for running as Pentadactyl commands since it has its own chrome.&lt;/p&gt; &#xA;&lt;p&gt;*** Chrome&lt;/p&gt; &#xA;&lt;p&gt;These bookmarklets work in Chrome:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC js javascript:location.href = &#39;org-protocol:///capture-html?template=w&amp;amp;url=&#39; + encodeURIComponent(location.href) + &#39;&amp;amp;title=&#39; + encodeURIComponent(document.title || &#34;[untitled page]&#34;) + &#39;&amp;amp;body=&#39; + encodeURIComponent(function () {var html = &#34;&#34;; if (typeof window.getSelection != &#34;undefined&#34;) {var sel = window.getSelection(); if (sel.rangeCount) {var container = document.createElement(&#34;div&#34;); for (var i = 0, len = sel.rangeCount; i &amp;lt; len; ++i) {container.appendChild(sel.getRangeAt(i).cloneContents());} html = container.innerHTML;}} else if (typeof document.selection != &#34;undefined&#34;) {if (document.selection.type == &#34;Text&#34;) {html = document.selection.createRange().htmlText;}} var relToAbs = function (href) {var a = document.createElement(&#34;a&#34;); a.href = href; var abs = a.protocol + &#34;//&#34; + a.host + a.pathname + a.search + a.hash; a.remove(); return abs;}; var elementTypes = [[&#39;a&#39;, &#39;href&#39;], [&#39;img&#39;, &#39;src&#39;]]; var div = document.createElement(&#39;div&#39;); div.innerHTML = html; elementTypes.map(function(elementType) {var elements = div.getElementsByTagName(elementType[0]); for (var i = 0; i &amp;lt; elements.length; i++) {elements[i].setAttribute(elementType[1], relToAbs(elements[i].getAttribute(elementType[1])));}}); return div.innerHTML;}());&lt;/p&gt; &#xA;&lt;p&gt;javascript:location.href = &#39;org-protocol:///capture-eww-readable?template=w&amp;amp;url=&#39; + encodeURIComponent(location.href) + &#39;&amp;amp;title=&#39; + encodeURIComponent(document.title || &#34;[untitled page]&#34;);&lt;/p&gt; &#xA;&lt;p&gt;#+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; The first sets of slashes are tripled compared to the Firefox bookmarklets. When testing with Chrome, I found that =xdg-open= was collapsing the double-slashes into single-slashes, which breaks =org-protocol=. I&#39;m not sure why that doesn&#39;t seem to be necessary for Firefox. If you have any trouble with this, you might try removing the extra slashes.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Shell script&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The [[org-protocol-capture-html.sh][shell script]] is handy for piping any HTML (or plain-text) content to Org through the shell, or downloading and capturing any URL directly (without a browser), but it&#39;s not required. It requires =getopt=, part of the =util-linux= package which should be standard on most Linux distros. On OS X you may need to install =getopt= or =util-linux= from MacPorts or Homebrew, etc.&lt;/p&gt; &#xA;&lt;p&gt;You can use it like this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE org-protocol-capture-html.sh [OPTIONS] [HTML] cat html | org-protocol-capture-html.sh [OPTIONS]&lt;/p&gt; &#xA;&lt;p&gt;Send HTML to Emacs through org-protocol, passing it through Pandoc to convert HTML to Org-mode. HTML may be passed as an argument or through STDIN. If only URL is given, it will be downloaded and its contents used.&lt;/p&gt; &#xA;&lt;p&gt;Options: -h, --heading HEADING Heading -r, --readability Capture web page article with eww-readable -t, --template TEMPLATE org-capture template key (default: w) -u, --url URL URL&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--debug  Print debug info&#xA;--help   I need somebody!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+END_EXAMPLE&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After installing the bookmarklets, you can select some text on a web page with your mouse, open the bookmarklet with the browser, and Emacs should pop up an Org capture buffer. You can also do it without selecting text first, if you just want to capture a link to the page.&lt;/p&gt; &#xA;&lt;p&gt;You can also pass data through the shell script, for example:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC sh dmesg | grep -i sata | org-protocol-capture-html.sh --heading &#34;dmesg SATA messages&#34; --template i&lt;/p&gt; &#xA;&lt;p&gt;org-protocol-capture-html.sh --readability --url &#34;&lt;a href=&#34;https://lwn.net/Articles/615220/&#34;&gt;https://lwn.net/Articles/615220/&lt;/a&gt;&#34;&lt;/p&gt; &#xA;&lt;p&gt;org-protocol-capture-html.sh -h &#34;TODO Feed the cat!&#34; -t i &#34;He gets grouchy if I forget!&#34; #+END_SRC&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Changelog :noexport_1:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2019-05-12&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Python 2-3 compatibility fixes in =org-protocol-capture-html.sh=. ([[https://github.com/alphapapa/org-protocol-capture-html/pull/31][#31]]. Thanks to [[https://github.com/samspills][Sam Pillsworth]].)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2017-04-17&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use [[https://github.com/magnars/s.el][s.el]].&lt;/li&gt; &#xA; &lt;li&gt;Handle empty titles from =dom=.&lt;/li&gt; &#xA; &lt;li&gt;Skip HTTP headers more reliably in the =eww-readable= support.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2017-04-15&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Switch from old-style =org-protocol= links to the new-style ones used in Org 9. &lt;em&gt;Note&lt;/em&gt;: This requires updating existing bookmarklets to use the new-style links. See the examples in the usage instructions. Users who are unable to upgrade to Org 9 should use the previous version of this package.&lt;/li&gt; &#xA; &lt;li&gt;Remove =python-readability= support and just use =eww-readable=. =eww-readable= seems to work so well that it seems unnecessary to bother with external tools. Of course, this does require Emacs 25.1, so users on Emacs 24 may wish to use the previous version.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2017-04-11&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add =org-protocol-capture-eww-readable=. For Emacs 25.1 and up, this uses =eww=&#39;s built-in readability-style function instead of calling external Python scripts.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2016-10-23 Sun&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add =org-protocol-capture-html-demote-times= variable, which controls how many times headings in captured pages are demoted. This is handy if you use a sub-heading in your capture template, so you can make all the headings in captured pages lower than the lowest-level heading in your capture template.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2016-10-05 Wed&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Check Pandoc&#39;s no-wrap option lazily (upon first capture), and if Pandoc takes too long for some reason, try again next time a capture is run.&lt;/li&gt; &#xA; &lt;li&gt;If Pandoc does take too long, kill the buffer and process without prompting.&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;del&gt;sleep-for&lt;/del&gt; instead of &lt;del&gt;sit-for&lt;/del&gt; to work around any potential issues with whatever &#34;input&#34; may interrupt &lt;del&gt;sit-for&lt;/del&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Hopefully this puts issue #12 to rest for good. Thanks to [[https://github.com/jguenther][@jguenther]] for his help fixing and reporting bugs.&lt;/p&gt; &#xA;&lt;p&gt;** &amp;lt;2016-10-03 Mon&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Handle pages without titles in bookmarklet examples. If a page lacks an HTML title, the string passed to =org-protocol= would have nothing where the title should go, and this would cause the capture to fail. Now the bookmarklets will use =[untitled page]= instead of an empty string. (No Elisp code changed, only the examples in the readme.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2016-10-01 Sat&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use a temp buffer for the Pandoc test, thanks to [[https://github.com/jguenther][@jguenther]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2016-09-29 Thu&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix issue #12 (i.e. /really/ fix the =--no-wrap= deprecation), thanks to [[https://github.com/jguenther][@jguenther]].&lt;/li&gt; &#xA; &lt;li&gt;Require =cl= and use =cl-incf= instead of =incf=.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2016-09-23 Fri&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix for Pandoc versions =&amp;gt;== 1.16, which deprecates =--no-wrap= in favor of =--wrap=none=.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2016-04-03 Sun&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add support for [[https://github.com/buriy/python-readability][python-readability]].&lt;/li&gt; &#xA; &lt;li&gt;Improve instructions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** &amp;lt;2016-03-23 Wed&amp;gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add URL downloading to the shell script. Now you can run =org-protocol-capture-html.sh -u &lt;a href=&#34;http://example.com=&#34;&gt;http://example.com=&lt;/a&gt; and it will download and capture the page.&lt;/li&gt; &#xA; &lt;li&gt;Add =org-capture= template to the readme. This will make it much easier for new users.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Credits&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Thanks to [[https://github.com/jguenther][@jguenther]] for helping to fix issue #12.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to [[https://github.com/xuchunyang][@xuchunyang]] for finding and fixing #17 and #19.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Appendix&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** org-protocol Instructions&lt;/p&gt; &#xA;&lt;p&gt;*** 1. Add protocol handler&lt;/p&gt; &#xA;&lt;p&gt;Create the file =~/.local/share/applications/org-protocol.desktop= containing:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC conf [Desktop Entry] Name=org-protocol Exec=emacsclient %u Type=Application Terminal=false Categories=System; MimeType=x-scheme-handler/org-protocol; #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Each line&#39;s key must be capitalized exactly as displayed, or it will be an invalid =.desktop= file.&lt;/p&gt; &#xA;&lt;p&gt;Then update =~/.local/share/applications/mimeinfo.cache= by running:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;On KDE: =kbuildsycoca4=&lt;/li&gt; &#xA; &lt;li&gt;On GNOME: =update-desktop-database ~/.local/share/applications/=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** 2. Configure Emacs&lt;/p&gt; &#xA;&lt;p&gt;**** Init file&lt;/p&gt; &#xA;&lt;p&gt;Add to your Emacs init file:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (server-start) (require &#39;org-protocol) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;**** Capture template&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll probably want to add a capture template something like this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (&#34;w&#34; &#34;Web site&#34; entry (file+olp &#34;~/org/inbox.org&#34; &#34;Web&#34;) &#34;* %c :website:\n%U %?%:initial&#34;) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Using =%:initial= instead of =%i= seems to handle multi-line content better.&lt;/p&gt; &#xA;&lt;p&gt;This will result in a capture like this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC org&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[http://orgmode.org/worg/org-contrib/org-protocol.html][org-protocol.el – Intercept calls from emacsclient to trigger custom actions]] :website: [2015-09-29 Tue 11:09] About org-protocol.el org-protocol.el is based on code and ideas from org-annotation-helper.el and org-browser-url.el. #+END_SRC&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** 3. Configure Firefox&lt;/p&gt; &#xA;&lt;p&gt;On some versions of Firefox, it may be necessary to add this setting. You may skip this step and come back to it if you get an error saying that Firefox doesn&#39;t know how to handle =org-protocol= links.&lt;/p&gt; &#xA;&lt;p&gt;Open =about:config= and create a new =boolean= value named =network.protocol-handler.expose.org-protocol= and set it to =true=.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; If you do skip this step, and you do encounter the error, Firefox may replace all open tabs in the window with the error message, making it difficult or impossible to recover those tabs. It&#39;s best to use a new window with a throwaway tab to test this setup until you know it&#39;s working.&lt;/p&gt; &#xA;&lt;p&gt;** Selection-grabbing function&lt;/p&gt; &#xA;&lt;p&gt;This function gets the HTML from the browser&#39;s selection. It&#39;s from [[http://stackoverflow.com/a/6668159/712624][this answer]] on StackOverflow.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC js function () { var html = &#34;&#34;;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  if (typeof content.document.getSelection != &#34;undefined&#34;) {&#xA;      var sel = content.document.getSelection();&#xA;      if (sel.rangeCount) {&#xA;          var container = document.createElement(&#34;div&#34;);&#xA;          for (var i = 0, len = sel.rangeCount; i &amp;lt; len; ++i) {&#xA;              container.appendChild(sel.getRangeAt(i).cloneContents());&#xA;          }&#xA;          html = container.innerHTML;&#xA;      }&#xA;  } else if (typeof document.selection != &#34;undefined&#34;) {&#xA;      if (document.selection.type == &#34;Text&#34;) {&#xA;          html = document.selection.createRange().htmlText;&#xA;      }&#xA;  }&#xA;&#xA;  var relToAbs = function (href) {&#xA;      var a = content.document.createElement(&#34;a&#34;);&#xA;      a.href = href;&#xA;      var abs = a.protocol + &#34;//&#34; + a.host + a.pathname + a.search + a.hash;&#xA;      a.remove();&#xA;      return abs;&#xA;  };&#xA;  var elementTypes = [&#xA;      [&#39;a&#39;, &#39;href&#39;],&#xA;      [&#39;img&#39;, &#39;src&#39;]&#xA;  ];&#xA;&#xA;  var div = content.document.createElement(&#39;div&#39;);&#xA;  div.innerHTML = html;&#xA;&#xA;  elementTypes.map(function(elementType) {&#xA;      var elements = div.getElementsByTagName(elementType[0]);&#xA;      for (var i = 0; i &amp;lt; elements.length; i++) {&#xA;          elements[i].setAttribute(elementType[1], relToAbs(elements[i].getAttribute(elementType[1])));&#xA;      }&#xA;  });&#xA;  return div.innerHTML;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;} #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a one-line version of it, better for pasting into bookmarklets and such:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC js function () {var html = &#34;&#34;; if (typeof content.document.getSelection != &#34;undefined&#34;) {var sel = content.document.getSelection(); if (sel.rangeCount) {var container = document.createElement(&#34;div&#34;); for (var i = 0, len = sel.rangeCount; i &amp;lt; len; ++i) {container.appendChild(sel.getRangeAt(i).cloneContents());} html = container.innerHTML;}} else if (typeof document.selection != &#34;undefined&#34;) {if (document.selection.type == &#34;Text&#34;) {html = document.selection.createRange().htmlText;}} var relToAbs = function (href) {var a = content.document.createElement(&#34;a&#34;); a.href = href; var abs = a.protocol + &#34;//&#34; + a.host + a.pathname + a.search + a.hash; a.remove(); return abs;}; var elementTypes = [[&#39;a&#39;, &#39;href&#39;], [&#39;img&#39;, &#39;src&#39;]]; var div = content.document.createElement(&#39;div&#39;); div.innerHTML = html; elementTypes.map(function(elementType) {var elements = div.getElementsByTagName(elementType[0]); for (var i = 0; i &amp;lt; elements.length; i++) {elements[i].setAttribute(elementType[1], relToAbs(elements[i].getAttribute(elementType[1])));}}); return div.innerHTML;} #+END_SRC&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To-Do :noexport_1:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** TODO Add link to Mac OS X article&lt;/p&gt; &#xA;&lt;p&gt;[[https://blog.aaronbieber.com/2016/11/24/org-capture-from-anywhere-on-your-mac.html][This article]] would be helpful for Mac users in setting up org-protocol.&lt;/p&gt; &#xA;&lt;p&gt;** TODO File-based capturing&lt;/p&gt; &#xA;&lt;p&gt;Pentadactyl has the =:write= command, which can write a page&#39;s HTML to a file, or to a command, like =:write !org-protocol-capture-html.sh=. This should make it easy to implement file-based capturing, which would pass HTML through a temp file rather than as an argument, and this would work around the argument-length limit that we occasionally run into.&lt;/p&gt; &#xA;&lt;p&gt;All that should be necessary is to:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add a new sub-protocol =capture-file= that receives a path to a file instead of a URL to a page. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;It should probably delete the file after finishing the capture, to avoid leaving temp files laying around, so it should protect against deleting random files. Probably the best way to do this would be to define a directory and a prefix, and any files not in that directory and not having that prefix should not be deleted.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Add a options to =org-protocol-capture-html.sh= to capture with files. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This should have two methods: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Pass the path to an existing file, which will then be passed to Emacs.&lt;/li&gt; &#xA;     &lt;li&gt;Pass content via =STDIN=, write it to a tempfile, and pass the tempfile&#39;s path to Emacs. The tempfile should go in the directory and have the prefix so that Emacs knows it&#39;s safe to delete that file.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Document how to integrate this with Pentadactyl. It should be very simple, like =:write !org-protocol-capture-html --tempfile=. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This would, by default, pass the entire content of the page. It would be good to also be able to capture only the selection, and to be able to use Readability on the result. Here&#39;s an example from the Pentadactyl manual that seems to show using JavaScript to fill arguments to the command:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE txt :com! search-selection,ss -bang -nargs=? -complete search \ -js commands.execute((bang ? open : tabopen ) \ + args + + buffer.currentWord) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    However, I don&#39;t see how this would allow writing different content to =STDIN=, only arguments.  So this might not be possible without modifying Pentadactyl and/or using a separate Firefox extension.  [[file:~/src/dactyl/common/modules/buffer.jsm::commands.add(%5B&#34;sav%5Beas%5D&#34;,%20&#34;w%5Brite%5D&#34;%5D,][Here]] is the source for the =:write= command, and [[file:~/Temp/src/dactyl/common/modules/storage.jsm::write:%20function%20write(buf,%20mode,%20perms,%20encoding)%20{][here]] for the underlying JS function.  And you can see [[file:~/src/dactyl/common/modules/io.jsm::%5B&#34;exec&#34;,%20&#34;&amp;gt;&#34;%20%2B%20shellEscape(stdout.path),%20&#34;2&amp;gt;&amp;amp;1&#34;,%20&#34;&amp;lt;&#34;%20%2B%20shellEscape(stdin.path),][here]] how it uses temp files to pass =STDIN= to commands.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Handle long chunks of HTML&lt;/p&gt; &#xA;&lt;p&gt;If you try to capture too long a chunk of HTML, it will fail with &#34;argument list too long errors&#34; from =emacsclient=. To work around this will require capturing via STDIN instead of arguments. Since org-protocol is based on using URLs, this will probably require using a shell script and a new Emacs function, and perhaps another MIME protocol-handler. Even then, it might still run into problems, because the data is passed to the shell script as an argument in the protocol-handler. Working around that would probably require a non-protocol-handler-based method using a browser extension to send the HTML directly via STDIN. Might be possible with Pentadactyl instead of making an entirely new browser extension. Also, maybe the [[https://addons.mozilla.org/en-US/firefox/addon/org-mode-capture/][Org-mode Capture]] Firefox extension could be extended (...) to do this.&lt;/p&gt; &#xA;&lt;p&gt;However, most of the time, this is not a problem.&lt;/p&gt; &#xA;&lt;p&gt;** Package for MELPA&lt;/p&gt; &#xA;&lt;p&gt;This would be nice.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>LefterisJP/malinka</title>
    <updated>2023-08-23T01:28:01Z</updated>
    <id>tag:github.com,2023-08-23:/LefterisJP/malinka</id>
    <link href="https://github.com/LefterisJP/malinka" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A C/C++ project configuration package for Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+DESCRIPTION: A C/C++ project configuration package for Emacs #+OPTIONS: H:2&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Information Malinka is a project management Emacs package for C/C++&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It acts as a glue between different C/C++ packages to provide them with the right data for a project. All the data are organized and can be configured on a per project basis. The packages that malinka can work with are:&lt;/p&gt; &#xA;&lt;p&gt;** Rtags Rtags help the user jump around the code easily and provide integration with many clang utilities like Clang fixits. The main functionality that malinka provides is to properly populate and communicate the compiler commands to the rtags daemons depending on the project you are working on.&lt;/p&gt; &#xA;&lt;p&gt;If you have not installed rtags yet, visit their [[https://github.com/Andersbakken/rtags][github page]] and read more information about how you can acquire and use rtags. Alternatively if you used [[https://github.com/dimitri/el-get][el-get]] to get malinka rtags should have been downloaded and built as a dependency&lt;/p&gt; &#xA;&lt;p&gt;** Flycheck Optionally and if you also have [[https://github.com/flycheck/flycheck][flycheck]] with the clang syntax-checker activated, malinka will communicate to flycheck&#39;s clang syntax checker the appropriate =cpp-defines= and =include-paths= so that flycheck can do its syntax checking.&lt;/p&gt; &#xA;&lt;p&gt;** Projectile If you are using [[https://github.com/bbatsov/projectile][projectile]] then malinka can provide projectile with the compile and test commands to build and test your project respectively. Projectile also helps with the detection of root directory for projects.&lt;/p&gt; &#xA;&lt;p&gt;** Irony If you are using [[https://github.com/Sarcasm/irony-mode][irony mode]] malinka can then provide the json compilation database for your project that will be indexed by the irony server&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example Setup :PROPERTIES: :CUSTOM_ID: example_setup :END: Working with malinka requires that you define your project somewhere in your emacs file using =(malinka-define-project)=.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (require &#39;malinka)&lt;/p&gt; &#xA;&lt;p&gt;(add-hook &#39;c-mode-common-hook &#39;malinka-mode)&lt;/p&gt; &#xA;&lt;p&gt;(malinka-define-project :name &#34;ethereum&#34; :root-directory &#34;/home/lefteris/ew/cpp-ethereum&#34; :build-directory &#34;/home/lefteris/ew/cpp-ethereum/build&#34; :configure-cmd &#34;cmake .. -DCMAKE_BUILD_TYPE=Debug -DHEADLESS=1&#34; :compile-cmd &#34;make -j4&#34; :test-cmd &#34;./test/testeth&#34;) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;In the above example we can see malinka&#39;s initialization and a sample definition of a project. You need to hook =malinka-mode= to c/c++ mode so that all malinka functionality can operate only on the loading of those type of buffers.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s look now at the arguments of a project&#39;s definition one by one.&lt;/p&gt; &#xA;&lt;p&gt;** name This is the name of the project. This is how malinka will refer to your project everywhere. Must be unique. ** root-directory This is the root directory of the project.&lt;/p&gt; &#xA;&lt;p&gt;** build-directory This is the directory where the =build-cmd= and =compile-cmd= will be executed in.&lt;/p&gt; &#xA;&lt;p&gt;** configure-cmd This is the command to configure the project for malinka. This is what malinka will use to create the json compilation database. There are 2 different ways to achieve this and depends on the type of build system you use to build your project. *** cmake &amp;gt; 2.85 If malinka detects you are using cmake with version greater than 2.85 then it will use cmake to create the compilation database in the build directory. *** all others For all other cases, simple makefiles, scons, waf e.t.c. you have to provide the build command here making sure that it will provide visible compile output. You can simply add the =--dry-run= option in most build systems as this command should be used just to create the compilation database. The output will be parsed by malinka and the compilation database will be created. ** compile-db-cmd This command instructs malinka in what way to generate the compilation database. =compile-db-cmd= takes precedence over configure-cmd. When =configure-cmd= is not enough to generate a correct compilation database, you should use =compile-db-cmd=. One example is when using ninja or bear to generate a compilation database. You should provide a command that could always generate a compilation database correctly. For example, you may add =bear make -B= to make sure it always generate a compilation database whenever current project has been already built. ** compile-cmd This is the command to compile the whole project. This is what will be given to projectile&#39;s =projectile-compile-project= to compile your project with your chosen keybinding. Default is: =C-c p c= ** test-cmd This is the command to test the project. This is what will be given to projectile&#39;s =projectile-test-project= to test your project with your chosen keybinding. Default is: =C-c p P=. It is an optional project attribute. ** run-cmd This is the command to run the executable or anything else generated by the project. It is bound to =projectile-run-command= and the default keybinding is =C-c p u=. This is an optional project attribute.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage As shown in the [[#example_setup][example setup]] section the basic configuration that needs to exist in order to use malinka is to define your projects using =(malinka-define-project)= Following that the way to interact with the defined projects is via the following interactive API:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;=(malinka-project-configure name given-root-dir)=&lt;/p&gt; &lt;p&gt;You will be prompted with a list of the known projects and you will have to select the one you need to configure. Basically this command will create the compilation database for your project and feed the data to the packages you use. Depending on project size this may take quite a bit of time.&lt;/p&gt; &lt;p&gt;The given-root-dir is optional and will only be asked if you failed to provide one in the project definition.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=(malinka-project-select name given-root-dir)=&lt;/p&gt; &lt;p&gt;You will be prompted with a list of the known projects and you will have to select the one you need to select. Basically this command will search for the compilation database in the selected project, read it and feed the data to the packages you are using.&lt;/p&gt; &lt;p&gt;The given-root-dir is optional and will only be asked if you failed to provide one in the project definition.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Operation Malinka will attempt to feed data to all the C/C++ relevant packages that it can detect while a buffer of a malinka project is currently visited. ** Idle Check If &lt;code&gt;malinka-enable-idle-project-check&#39; is non-nil then at the specified interval of &lt;/code&gt;malinka-idle-project-check-seconds&#39; the visited buffer&#39;s file will be checked against all the known malinka projects.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If it is found to be under a project&#39;s root then that project is considered the current project and is selected by malinka. Selection basically means feeding the appropriate data to each of the other C/C++ packages.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Customization As a user you have ample customization choices when using malinka. These are:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-completion-system&lt;/em&gt;: As a user you have a choice of the completion system to choose when selecting a defined project. As inspired by [[https://github.com/flycheck/flycheck][flycheck]]&#39;s customization there are currently two choices offered:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;[[http://www.emacswiki.org/emacs/InteractivelyDoThings][IDO]]: the built-in completion system with fuzzy searching. Powerful though it is, one can really improve it by using [[https://github.com/lewang/flx][flx-ido]].&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;[[http://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][Completing Read]]: The very simple and not fancy emacs built-in completion system. Is the default.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-ignored-directories&lt;/em&gt;: A list of directories to ignore for file searching&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-supported-compilers&lt;/em&gt;: A list of compiler executable names that are recognized and supported by malinka.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-supported-file-types&lt;/em&gt;: File extensions that malinka will treat as related source and header files.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-supported-header-types&lt;/em&gt;: File extensions that malinka will treat as related header files.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-idle-project-check-seconds&lt;/em&gt;: The idle time in seconds to wait until we perform a project idle [[Idle Check][check]]. Can be nil or 0 to disable idle project checks.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-mode-line&lt;/em&gt;: The string to show on the modeline when malinka minor mode is active&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-print-info?&lt;/em&gt;: If true malinka will be printing some info messages of the actions it takes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-print-warning?&lt;/em&gt;: If true malinka will be printing warning messages in case things go wrong but can be taken care of&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-print-debug?&lt;/em&gt;: If true malinka will be printing a lot of DEBUG messages. Only useful for debugging&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;malinka-print-xdebug?&lt;/em&gt;: If true malinka will be printing extreme DEBUG messages. Only useful for debugging. Warning: This WILL spam the &lt;em&gt;Messages&lt;/em&gt; buffer&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Issues If you have problems, bugs or feature requests feel free to open an issue in [[https://github.com/LefterisJP/malinka/issues][github]] and I will take a look at it when I find the time.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Common Issues&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Can&#39;t index file&lt;/em&gt;&lt;/p&gt; &lt;p&gt;To get a view of the connection between Emacs and the rtags daemon you can always check the =&lt;em&gt;rdm&lt;/em&gt;= buffer. There you can see after a &lt;del&gt;M-x malinka-project-configure&lt;/del&gt; if the files are indexed properly.&lt;/p&gt; &lt;p&gt;If for some reason a file can&#39;t be indexed and in the =&lt;em&gt;rdm&lt;/em&gt;= buffer you get something like below: #+BEGIN_SRC sh Failed to make location from [filename:line:column] #+END_SRC Then I would suggest removing the rtags cache kept under =~/.rtags= by default and then redoing a &lt;del&gt;M-x malinka-project-configure&lt;/del&gt;. Also killing the =rdm= daemon is a good idea.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions All contributions are welcome. If you would like to help you can open a pull request with your suggested contribution. ** Running tests #+begin_src sh :tangle yes cask make compile make lint make test #+end_src ** Styling The malinka code is written in elisp and for styling we use the &lt;a href=&#34;https://www.emacswiki.org/emacs/ElispFormat&#34;&gt;elisp-formatter&lt;/a&gt; tool. If you make any contributions please make sure they adhere to the elisp style rules by also running it on your Pull Request.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>