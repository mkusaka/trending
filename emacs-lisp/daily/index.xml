<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-05T01:39:17Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>alphapapa/burly.el</title>
    <updated>2022-07-05T01:39:17Z</updated>
    <id>tag:github.com,2022-07-05:/alphapapa/burly.el</id>
    <link href="https://github.com/alphapapa/burly.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Save and restore frames and windows with their buffers in Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Burly.el&lt;/p&gt; &#xA;&lt;p&gt;#+PROPERTY: LOGGING nil&lt;/p&gt; &#xA;&lt;h1&gt;Note: This readme works with the org-make-toc &lt;a href=&#34;https://github.com/alphapapa/org-make-toc&#34;&gt;https://github.com/alphapapa/org-make-toc&lt;/a&gt; package, which automatically updates the table of contents.&lt;/h1&gt; &#xA;&lt;h1&gt;[[https://melpa.org/#/package-name][file:https://melpa.org/packages/burly-badge.svg]] [[https://stable.melpa.org/#/package-name][file:https://stable.melpa.org/packages/burly-badge.svg]]&lt;/h1&gt; &#xA;&lt;p&gt;#+HTML: &lt;img src=&#34;https://raw.githubusercontent.com/alphapapa/burly.el/master/images/beaver.png&#34; align=&#34;right&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This package provides tools to save and restore frame and window configurations in Emacs, including buffers that may not be live anymore. In this way, it&#39;s like a lightweight &#34;workspace&#34; manager, allowing you to easily restore one or more frames, including their windows, the windows&#39; layout, and their buffers.&lt;/p&gt; &#xA;&lt;p&gt;Internally it uses Emacs&#39;s bookmarks system to restore buffers to their previous contents and location. This provides power and extensibility, since many major modes already integrate with Emacs&#39;s bookmarks system. However, in case a mode&#39;s bookmarking function isn&#39;t satisfactory, Burly allows the user to customize buffer-restoring functions for specific modes.&lt;/p&gt; &#xA;&lt;p&gt;For Org mode, Burly provides such custom functions so that narrowed and indirect Org buffers are properly restored, and headings are located by outline path in case they&#39;ve moved since a bookmark was made (the [[https://github.com/alphapapa/org-bookmark-heading][org-bookmark-heading]] package also provides this through the Emacs bookmark system, but users may not have it installed, and the functionality is too useful to not include here by default).&lt;/p&gt; &#xA;&lt;p&gt;Internally, buffers and frame/window configurations are also encoded as URLs, and users may also save and open those URLs instead of using Emacs bookmarks. (The name &#34;Burly&#34; comes from &#34;buffer URL.&#34;) For example, a URL to the =Installation/Quelpa= heading in this file, as I&#39;m writing it, looks like this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE emacs+burly+file:///home/me/src/emacs/burly.el/README.org?pos=2651&amp;amp;outline-path=%28%22Installation%22%20%22Quelpa%22%29&amp;amp;relative-pos=308 #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;In terms of built-in features, Burly may be seen as integrating or leveraging the built-in libraries =bookmark.el=, =window.el=, and =frameset.el=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contents :noexport: :PROPERTIES: :TOC: :include siblings :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#installation][Installation]]&lt;/li&gt; &#xA; &lt;li&gt;[[#usage][Usage]]&lt;/li&gt; &#xA; &lt;li&gt;[[#changelog][Changelog]]&lt;/li&gt; &#xA; &lt;li&gt;[[#development][Development]]&lt;/li&gt; &#xA; &lt;li&gt;[[#credits][Credits]]&lt;/li&gt; &#xA; &lt;li&gt;[[#license][License]] :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation :PROPERTIES: :TOC: :depth 0 :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** MELPA&lt;/p&gt; &#xA;&lt;p&gt;If you installed from MELPA, you&#39;re done. Just run one of the commands below.&lt;/p&gt; &#xA;&lt;p&gt;** Quelpa&lt;/p&gt; &#xA;&lt;p&gt;The easiest way is to install with [[https://github.com/quelpa/quelpa-use-package][quelpa-use-package]], like this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (use-package burly :quelpa (burly :fetcher github :repo &#34;alphapapa/burly.el&#34;)) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;** Manual&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install version 2.1 or later of the =map= library from GNU ELPA.&lt;/li&gt; &#xA; &lt;li&gt;Copy =burly.el= into a directory in your =load-path=, then &lt;del&gt;(require &#39;burly)&lt;/del&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage :PROPERTIES: :TOC: :depth 0 :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Bookmark commands&lt;/p&gt; &#xA;&lt;p&gt;Most users will probably use Burly by bookmarking frame and window configurations and accessing them with these commands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=burly-bookmark-frames=: Bookmark the current frames and their window configurations.&lt;/li&gt; &#xA; &lt;li&gt;=burly-bookmark-windows=: Bookmark the current frame&#39;s window configuration.&lt;/li&gt; &#xA; &lt;li&gt;=burly-open-bookmark=: Select and open a Burly bookmark.&lt;/li&gt; &#xA; &lt;li&gt;=burly-open-last-bookmark=: Open the last-opened Burly bookmark. Helpful for, e.g. quickly restoring an overview while working on a project.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that bookmarks created by Burly are regular Emacs bookmarks, so they can be managed by Emacs&#39;s built-in bookmark commands, e.g. =list-bookmarks=, =bookmark-delete=, etc.&lt;/p&gt; &#xA;&lt;p&gt;** URL commands&lt;/p&gt; &#xA;&lt;p&gt;These commands work on URL strings. While most users probably won&#39;t use these, they may be useful for building custom tooling.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=burly-open-url=: Open a Burly URL (at point, or prompt for one), displaying the buffer(s) in the current window or frame.&lt;/li&gt; &#xA; &lt;li&gt;=burly-kill-buffer-url=: Copy BUFFER&#39;s URL to the kill ring.&lt;/li&gt; &#xA; &lt;li&gt;=burly-kill-frames-url=: Copy the current frameset&#39;s URL to the kill ring.&lt;/li&gt; &#xA; &lt;li&gt;=burly-kill-windows-url=: Copy the current frame&#39;s window configuration URL to the kill ring.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Tab bar&lt;/p&gt; &#xA;&lt;p&gt;Burly supports Emacs&#39;s &lt;del&gt;tab-bar-mode&lt;/del&gt; with &lt;del&gt;burly-tabs-mode&lt;/del&gt;. When active, Burly bookmarks are opened in new tabs, and the tabs are named according to the bookmarks. Reopening a Burly bookmark uses the designated tab, if it already exists, and tabs may be reset to their bookmarked state with the command &lt;del&gt;burly-reset-tab&lt;/del&gt; (which you might bind to =C-x t R=).&lt;/p&gt; &#xA;&lt;p&gt;** Tips&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can customize settings in the =burly= group.&lt;/li&gt; &#xA; &lt;li&gt;An Info manual is included with this package.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Changelog :PROPERTIES: :TOC: :depth 0 :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** 0.3-pre&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Added&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Command &lt;del&gt;burly-tabs-mode&lt;/del&gt;, which integrates Burly with &lt;del&gt;tab-bar-mode&lt;/del&gt;. When active, Burly bookmarks are opened in new tabs, and the tabs are named according to the bookmark.&lt;/li&gt; &#xA; &lt;li&gt;Command &lt;del&gt;burly-reset-tab&lt;/del&gt;, which resets a tab to the state of the bookmark which opened it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Changed&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Emacs version 28.1 or later is required.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Fixed&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Buffers that can&#39;t be restored by name no longer cause an error which aborts restoration of the rest of the bookmark&#39;s buffers. ** 0.2&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Added&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bookmark commands use &lt;del&gt;completing-read&lt;/del&gt; and offer existing Burly bookmark names, making it easier to update bookmarks. (Thanks to [[https://github.com/Kungsgeten][Erik Sjöstrand]].)&lt;/li&gt; &#xA; &lt;li&gt;Command =burly-open-last-bookmark=.&lt;/li&gt; &#xA; &lt;li&gt;Option =burly-set-window-persistent-parameters=, which synchronizes =window-persistent-parameters= with =burly-window-persistent-parameters=, ensuring that built-in Emacs commands like =window-toggle-side-windows= persist parameters that are persisted with Burly.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Changed&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Option =burly-window-persistent-parameters=&#39;s default value includes more window parameters, like header/mode line, side, slot, etc, making it easier to restore an overview of a project or &#34;workspace.&#34;&lt;/li&gt; &#xA; &lt;li&gt;Emacs version 27.1 or later is required.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Fixed&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Narrow Org buffers to correct heading (at the top of the buffer rather than at point).&lt;/li&gt; &#xA; &lt;li&gt;Buffers whose names have multibyte characters. (Fixes [[https://github.com/alphapapa/burly.el/issues/43][#43]]. Thanks to [[https://github.com/ilupin][Liu Hui]] for reporting.)&lt;/li&gt; &#xA; &lt;li&gt;Bind &lt;del&gt;print-level&lt;/del&gt; to nil where &lt;del&gt;prin1-to-string&lt;/del&gt; is used (in case the value is non-nil in a user&#39;s config, which would cause truncated values).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** 0.1&lt;/p&gt; &#xA;&lt;p&gt;Initial release.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Development&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Bug reports, feature requests, suggestions — /oh my/!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Credits&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Thanks to [[https://github.com/clemera][Clemens Radermacher]] and [[https://github.com/rswgnu][Robert Weiner]] for their suggestions.&lt;/li&gt; &#xA; &lt;li&gt;Thanks to [[https://github.com/tpeacock19][Trey Peacock]] for extensive feedback on pre-release versions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;License&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;GPLv3&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;COMMENT Export setup :noexport: :PROPERTIES: :TOC: :ignore (this descendants) :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Copied from org-super-agenda&#39;s readme, in which much was borrowed from Org&#39;s =org-manual.org=.&lt;/h1&gt; &#xA;&lt;p&gt;#+OPTIONS: broken-links:t *:t&lt;/p&gt; &#xA;&lt;p&gt;** Info export options&lt;/p&gt; &#xA;&lt;p&gt;#+TEXINFO_DIR_CATEGORY: Emacs #+TEXINFO_DIR_TITLE: Burly: (burly) #+TEXINFO_DIR_DESC: Save and restore window configurations and their buffers&lt;/p&gt; &#xA;&lt;h1&gt;NOTE: We could use these, but that causes a pointless error, &#34;org-compile-file: File &#34;..README.info&#34; wasn&#39;t produced...&#34;, so we just rename the files in the after-save-hook instead.&lt;/h1&gt; &#xA;&lt;h1&gt;#+TEXINFO_FILENAME: burly.info&lt;/h1&gt; &#xA;&lt;h1&gt;#+EXPORT_FILE_NAME: burly.texi&lt;/h1&gt; &#xA;&lt;p&gt;** File-local variables&lt;/p&gt; &#xA;&lt;h1&gt;NOTE: Setting org-comment-string buffer-locally is a nasty hack to work around GitHub&#39;s org-ruby&#39;s HTML rendering, which does not respect noexport tags. The only way to hide this tree from its output is to use the COMMENT keyword, but that prevents Org from processing the export options declared in it. So since these file-local variables don&#39;t affect org-ruby, wet set org-comment-string to an unused keyword, which prevents Org from deleting this tree from the export buffer, which allows it to find the export options in it. And since org-export does respect the noexport tag, the tree is excluded from the info page.&lt;/h1&gt; &#xA;&lt;h1&gt;Local Variables:&lt;/h1&gt; &#xA;&lt;h1&gt;before-save-hook: org-make-toc&lt;/h1&gt; &#xA;&lt;h1&gt;after-save-hook: (lambda nil (when (and (require &#39;ox-texinfo nil t) (org-texinfo-export-to-info)) (delete-file &#34;README.texi&#34;) (rename-file &#34;README.info&#34; &#34;burly.info&#34; t)))&lt;/h1&gt; &#xA;&lt;h1&gt;org-export-initial-scope: buffer&lt;/h1&gt; &#xA;&lt;h1&gt;org-export-with-properties: ()&lt;/h1&gt; &#xA;&lt;h1&gt;org-export-with-title: t&lt;/h1&gt; &#xA;&lt;h1&gt;org-comment-string: &#34;NOTCOMMENT&#34;&lt;/h1&gt; &#xA;&lt;h1&gt;End:&lt;/h1&gt;</summary>
  </entry>
  <entry>
    <title>jwiegley/emacs-async</title>
    <updated>2022-07-05T01:39:17Z</updated>
    <id>tag:github.com,2022-07-05:/jwiegley/emacs-async</id>
    <link href="https://github.com/jwiegley/emacs-async" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple library for asynchronous processing in Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?sanitize=true&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://elpa.gnu.org/packages/async.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/packages/async.svg?sanitize=true&#34; alt=&#34;GNU ELPA&#34; title=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/async&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/async-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34; title=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/async&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/async-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34; title=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;emacs-async&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;async.el&lt;/code&gt; is a module for doing asynchronous processing in Emacs. Some async applications are provided as well with this package:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dired-async&lt;/li&gt; &#xA; &lt;li&gt;smtp-mail-async&lt;/li&gt; &#xA; &lt;li&gt;async-bytecomp&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Install&lt;/h1&gt; &#xA;&lt;p&gt;You can install emacs-async package from MELPA using package.el.&lt;/p&gt; &#xA;&lt;p&gt;You can also install from sources, in this case you should install using make and make install to ensure emacs-async is installed in a standard load-path destination where other packages can find it easily when compiling.&lt;/p&gt; &#xA;&lt;h2&gt;Install dired-async&lt;/h2&gt; &#xA;&lt;p&gt;Add to your &lt;code&gt;.emacs.el&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(autoload &#39;dired-async-mode &#34;dired-async.el&#34; nil t)&#xA;(dired-async-mode 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will allow you to run asynchronously the dired commands for copying, renaming and symlinking. If you are a &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;helm&lt;/a&gt; user, this will allow you to copy, rename etc... asynchronously from &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;helm&lt;/a&gt;. Note that with &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;helm&lt;/a&gt; you can disable this by running the copy, rename etc... commands with a prefix argument.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t want to make dired/helm asynchronous disable it with &lt;code&gt;dired-async-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Debian and Ubuntu&lt;/h3&gt; &#xA;&lt;p&gt;Users of Debian 9 or later or Ubuntu 16.04 or later may simply &lt;code&gt;apt-get install elpa-async&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Authentication and user interaction&lt;/h2&gt; &#xA;&lt;p&gt;Some authentications require user interaction, for example answering to a prompt, entering a passwords etc. Your async implementation should avoid any such user interaction, to avoid being stuck with a prompt you will not be able to answer to in the child emacs. For all what is remote (mails, tramp etc...) you have to let emacs manage your identification with &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/auth.html&#34;&gt;auth-sources&lt;/a&gt;, so that you do not have to enter a password.&lt;/p&gt; &#xA;&lt;p&gt;Basically all you need is something like this in your init file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(use-package auth-source&#xA;  :no-require t&#xA;  :config (setq auth-sources &#39;(&#34;~/.authinfo.gpg&#34; &#34;~/.netrc&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And a &#34;~/.authinfo.gpg&#34; file containing entries such as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;default port sudo login root password xxxxxxxx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;machine xxxxx port xxx login xxx password xxxxxxx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;for more specific hosts (smtp, mails etc...)&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/auth.html&#34;&gt;auth-sources manual&lt;/a&gt; for more infos.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: For all your async implementations in emacs-26+ versions that handle remote files (tramp), you will have to let-bind &lt;code&gt;async-quiet-switch&lt;/code&gt; to &lt;code&gt;-q&lt;/code&gt; to workaround a tramp bug that prevent &lt;code&gt;emacs -Q&lt;/code&gt; to use &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/auth.html&#34;&gt;auth-sources&lt;/a&gt; mechanism.&lt;/p&gt; &#xA;&lt;h2&gt;Enable asynchronous compilation of your (M)elpa packages&lt;/h2&gt; &#xA;&lt;p&gt;By default emacs package.el compile packages in its running emacs session. This is not a problem when installing a new package (which is not actually loaded in current emacs) but it may create errors and bad compilation when upgrading a package (old version of package is already loaded and running in current emacs). You can remedy to this by allowing async to compile your packages asynchronously, (helm and magit actually do this by default, so if you are using these packages they will compile asynchronously) to do this, add to your init file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(async-bytecomp-package-mode 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can control which packages will compile async with &lt;code&gt;async-bytecomp-allowed-packages&lt;/code&gt;. Set it to &lt;code&gt;&#39;(all)&lt;/code&gt; to be sure you will compile all packages asynchronously.&lt;/p&gt; &#xA;&lt;h2&gt;Send mails asynchronously with smtp mail async&lt;/h2&gt; &#xA;&lt;p&gt;To enable this feature, ensure smtp-mail-async.el is loaded and use&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;(setq message-send-mail-function &#39;async-smtpmail-send-it)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;WARNINGS:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;When using recent emacs (25+) the network security manager maybe called interactively in child emacs and make &lt;code&gt;async-smtpmail-send-it&lt;/code&gt; fail, so be sure to send email once synchronously before using &lt;code&gt;async-smtpmail-send-it&lt;/code&gt; as your &lt;code&gt;message-send-mail-function&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You may loose your sent mail if your network is down, so ensure to queue your mails if so. you can do this automatically, see &lt;a href=&#34;https://github.com/jwiegley/emacs-async/issues/64&#34;&gt;issue #64&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Async usage&lt;/h1&gt; &#xA;&lt;p&gt;The interface is intended to be very easy to use:&lt;/p&gt; &#xA;&lt;h2&gt;async-start&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-start START-FUNC FINISH-FUNC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Execute START-FUNC (often a lambda) in a subordinate Emacs process. When done, the return value is passed to FINISH-FUNC. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-start&#xA;   ;; What to do in the child process&#xA;   (lambda ()&#xA;     (message &#34;This is a test&#34;)&#xA;     (sleep-for 3)&#xA;     222)&#xA;&#xA;   ;; What to do when it finishes&#xA;   (lambda (result)&#xA;     (message &#34;Async process done, result should be 222: %s&#34; result)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If FINISH-FUNC is &lt;code&gt;nil&lt;/code&gt; or missing, a future is returned that can be inspected using &lt;code&gt;async-get&lt;/code&gt;, blocking until the value is ready. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(let ((proc (async-start&#xA;               ;; What to do in the child process&#xA;               (lambda ()&#xA;                 (message &#34;This is a test&#34;)&#xA;                 (sleep-for 3)&#xA;                 222))))&#xA;&#xA;    (message &#34;I&#39;m going to do some work here&#34;) ;; ....&#xA;&#xA;    (message &#34;Waiting on async process, result should be 222: %s&#34;&#xA;             (async-get proc)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t want to use a callback, and you don&#39;t care about any return value from the child process, pass the &lt;code&gt;&#39;ignore&lt;/code&gt; symbol as the second argument (if you don&#39;t, and never call &lt;code&gt;async-get&lt;/code&gt;, it will leave &lt;code&gt;*emacs*&lt;/code&gt; process buffers hanging around):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-start&#xA; (lambda ()&#xA;   (delete-file &#34;a remote file on a slow link&#34; nil))&#xA; &#39;ignore)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: Even when FINISH-FUNC is present, a future is still returned except that it yields no value (since the value is passed to FINISH-FUNC). Calling &lt;code&gt;async-get&lt;/code&gt; on such a future always returns &lt;code&gt;nil&lt;/code&gt;. It can still be useful, however, as an argument to &lt;code&gt;async-ready&lt;/code&gt; or &lt;code&gt;async-wait&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;async-start-process&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-start-process NAME PROGRAM FINISH-FUNC &amp;amp;rest PROGRAM-ARGS&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Start the executable PROGRAM asynchronously. See &lt;code&gt;async-start&lt;/code&gt;. PROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the process object when done. If FINISH-FUNC is &lt;code&gt;nil&lt;/code&gt;, the future object will return the process object when the program is finished. Set DEFAULT-DIRECTORY to change PROGRAM&#39;s current working directory.&lt;/p&gt; &#xA;&lt;h2&gt;async-get&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-get FUTURE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Get the value from an asynchronously called function when it is ready. FUTURE is returned by &lt;code&gt;async-start&lt;/code&gt; or &lt;code&gt;async-start-process&lt;/code&gt; when its FINISH-FUNC is &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;async-ready&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-ready FUTURE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Query a FUTURE to see if its function&#39;s value is ready -- i.e., if no blocking would result from a call to &lt;code&gt;async-get&lt;/code&gt; on that FUTURE.&lt;/p&gt; &#xA;&lt;h2&gt;async-wait&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-wait FUTURE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Wait for FUTURE to become ready.&lt;/p&gt; &#xA;&lt;h2&gt;async-inject-variables&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-inject-variables INCLUDE-REGEXP &amp;amp;optional PREDICATE EXCLUDE-REGEXP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Return a &lt;code&gt;setq&lt;/code&gt; form that replicates part of the calling environment. It sets the value for every variable matching INCLUDE-REGEXP and also PREDICATE. It will not perform injection for any variable matching EXCLUDE-REGEXP (if present). It is intended to be used as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-start&#xA;   `(lambda ()&#xA;      (require &#39;smtpmail)&#xA;      (with-temp-buffer&#xA;        (insert ,(buffer-substring-no-properties (point-min) (point-max)))&#xA;        ;; Pass in the variable environment for smtpmail&#xA;        ,(async-inject-variables &#34;\\`\\(smtpmail\\|\\(user-\\)?mail\\)-&#34;)&#xA;        (smtpmail-send-it)))&#xA;   &#39;ignore)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;async-let&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-let BINDINGS &amp;amp;rest FORMS&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Allow to establish let bindings asynchronously. Each value of binding can refer to the symbols already bound in BINDINGS (like &lt;code&gt;let*&lt;/code&gt;). FORMS are executed once BINDINGS have been evaluated, but without blocking emacs.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-let ((x &#34;hello&#34;)&#xA;            (y &#34;world&#34;))&#xA;  (message &#34;%s %s&#34; x y))&#xA;  &#xA;(async-let ((x (* 5 2))&#xA;            (y (+ x 4))&#xA;            (z (+ x y)))&#xA;  (message &#34;%d + %d = %d&#34; x y z))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that if you bind something to nil and set it afterward in body, the evaluation of this binding will NOT be asynchronous, but will happen in you current emacs, blocking it if the evaluation of this value is sufficiently important, e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(async-let ((x &#34;hello&#34;)&#xA;            (y &#34;world&#34;)&#xA;            z)&#xA;  (setq z (+ 1 2)) ;; Huge calculation of Z will block emacs.&#xA;  (message &#34;%s %s %d&#34; x y z))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;IOW if the calculation of Z is huge and you want it asynchronous evaluate it in BINDINGS but not in FORMS.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>abo-abo/avy</title>
    <updated>2022-07-05T01:39:17Z</updated>
    <id>tag:github.com,2022-07-05:/abo-abo/avy</id>
    <link href="https://github.com/abo-abo/avy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Jump to things in Emacs tree-style&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://elpa.gnu.org/packages/avy.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/packages/avy.svg?sanitize=true&#34; alt=&#34;GNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/avy&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/avy-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/avy&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/avy-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;avy&lt;/code&gt; is a GNU Emacs package for jumping to visible text using a char-based decision tree. See also &lt;a href=&#34;https://github.com/winterTTr/ace-jump-mode&#34;&gt;ace-jump-mode&lt;/a&gt; and &lt;a href=&#34;https://github.com/Lokaltog/vim-easymotion&#34;&gt;vim-easymotion&lt;/a&gt; - &lt;code&gt;avy&lt;/code&gt; uses the same idea.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/abo-abo/avy/images/avy-avatar-1.png&#34; alt=&#34;logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Command overview&lt;/h2&gt; &#xA;&lt;p&gt;You can bind some of these useful commands in your config.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-char&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input one char, jump to it with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;C-:&#34;) &#39;avy-goto-char)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After &lt;kbd&gt;C-: b&lt;/kbd&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/nloyola/avy/images/avy-goto-char.png&#34; alt=&#34;avy-goto-char&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-char-2&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input two consecutive chars, jump to the first one with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The advantage over the previous one is less candidates for the tree search. And it&#39;s not too inconvenient to enter two consecutive chars instead of one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;C-&#39;&#34;) &#39;avy-goto-char-2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After &lt;kbd&gt;C-&#39; bu&lt;/kbd&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://oremacs.com/download/avi-goto-char-2.png&#34; alt=&#34;avy-goto-char-2&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-char-timer&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input an arbitrary amount of consecutive chars, jump to the first one with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This is a more flexible version of &lt;code&gt;avy-goto-char-2&lt;/code&gt;. First part works similarly to &lt;code&gt;isearch&lt;/code&gt;: you type a query and it&#39;s highlighted dynamically on the screen. When you stop typing for &lt;code&gt;avy-timeout-seconds&lt;/code&gt; (0.5s by default), you&#39;ll be able to select one of the candidates with &lt;code&gt;avy&lt;/code&gt;. As you&#39;re inputting characters, you can use &lt;code&gt;C-h&lt;/code&gt; (backspace) or &lt;code&gt;DEL&lt;/code&gt; (delete) to forget the last typed character and &lt;code&gt;RET&lt;/code&gt; to end the input sequence immediately and select a candidate.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-line&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input zero chars, jump to a line start with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;M-g f&#34;) &#39;avy-goto-line)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After &lt;kbd&gt;M-g f&lt;/kbd&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://oremacs.com/download/avi-goto-line.png&#34; alt=&#34;avy-goto-line&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can actually replace the &lt;kbd&gt;M-g g&lt;/kbd&gt; binding of &lt;code&gt;goto-line&lt;/code&gt;, since if you enter a digit for &lt;code&gt;avy-goto-line&lt;/code&gt;, it will switch to &lt;code&gt;goto-line&lt;/code&gt; with that digit already entered.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-word-1&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input one char at word start, jump to a word start with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;M-g w&#34;) &#39;avy-goto-word-1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After &lt;kbd&gt;M-g wb&lt;/kbd&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://oremacs.com/download/avi-goto-word-1.png&#34; alt=&#34;avy-goto-word-1&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;avy-goto-word-0&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Input zero chars, jump to a word start with a tree.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Compared to &lt;code&gt;avy-goto-word-1&lt;/code&gt;, there are a lot more candidates. But at a least there&#39;s not need to input the initial char.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;M-g e&#34;) &#39;avy-goto-word-0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After &lt;kbd&gt;M-g e&lt;/kbd&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://oremacs.com/download/avi-goto-word-0.png&#34; alt=&#34;avy-goto-word-0&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Org-mode commands&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;avy-org-goto-heading-timer&lt;/code&gt;: Type part of an Org heading. When you stop typing, if only one heading on the screen matches, it will be jumped to; if more than one matches, you can jump to a heading with Avy. This is like &lt;code&gt;avy-goto-char-timer&lt;/code&gt; but for Org headings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;avy-org-refile-as-child&lt;/code&gt;: With point in an entry you want to refile, run this command, select a heading with Avy, and the entry will be refiled as its first child heading. This makes it quick and easy to refile to headings that are visible on-screen, even to other windows or buffers.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Other commands&lt;/h3&gt; &#xA;&lt;p&gt;There are some more commands which you can explore yourself by looking at the code.&lt;/p&gt; &#xA;&lt;h3&gt;Bindings&lt;/h3&gt; &#xA;&lt;p&gt;You add this to your config to bind some stuff:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(avy-setup-default)&#xA;(global-set-key (kbd &#34;C-c C-j&#34;) &#39;avy-resume)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It will bind, for example, &lt;code&gt;avy-isearch&lt;/code&gt; to &lt;kbd&gt;C-&#39;&lt;/kbd&gt; in &lt;code&gt;isearch-mode-map&lt;/code&gt;, so that you can select one of the currently visible &lt;code&gt;isearch&lt;/code&gt; candidates using &lt;code&gt;avy&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Customization&lt;/h3&gt; &#xA;&lt;p&gt;See the comprehensive custom variable list on &lt;a href=&#34;https://github.com/abo-abo/avy/wiki/defcustom&#34;&gt;the defcustom wiki page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See how to write your own avy commands on &lt;a href=&#34;https://github.com/abo-abo/avy/wiki/custom-commands&#34;&gt;the custom-commands wiki page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;h3&gt;Copyright Assignment&lt;/h3&gt; &#xA;&lt;p&gt;Avy is subject to the same &lt;a href=&#34;http://www.gnu.org/prep/maintain/html_node/Copyright-Papers.html&#34;&gt;copyright assignment&lt;/a&gt; policy as Emacs itself, org-mode, CEDET and other packages in &lt;a href=&#34;http://elpa.gnu.org/packages/&#34;&gt;GNU ELPA&lt;/a&gt;. Any &lt;a href=&#34;http://www.gnu.org/prep/maintain/html_node/Legally-Significant.html#Legally-Significant&#34;&gt;legally significant&lt;/a&gt; contributions can only be accepted after the author has completed their paperwork. Please see &lt;a href=&#34;http://git.savannah.gnu.org/cgit/gnulib.git/tree/doc/Copyright/request-assign.future&#34;&gt;the request form&lt;/a&gt; if you want to proceed.&lt;/p&gt; &#xA;&lt;p&gt;The copyright assignment isn&#39;t a big deal, it just says that the copyright for your submitted changes to Emacs belongs to the FSF. This assignment works for all projects related to Emacs. To obtain it, you need to send one email, then send one letter (if you live in the US, it&#39;s digital), and wait for some time (in my case, I had to wait for one month).&lt;/p&gt; &#xA;&lt;h3&gt;Style&lt;/h3&gt; &#xA;&lt;p&gt;The basic code style guide is to use &lt;code&gt;(setq indent-tabs-mode nil)&lt;/code&gt;. It is provided for you in &lt;a href=&#34;https://github.com/abo-abo/avy/raw/master/.dir-locals.el&#34;&gt;.dir-locals.el&lt;/a&gt;, please obey it.&lt;/p&gt; &#xA;&lt;p&gt;Before submitting the change, run &lt;code&gt;make compile&lt;/code&gt; and &lt;code&gt;make test&lt;/code&gt; to make sure that it doesn&#39;t introduce new compile warnings or test failures. Also run &lt;code&gt;make checkdoc&lt;/code&gt; to see that your changes obey the documentation guidelines.&lt;/p&gt; &#xA;&lt;p&gt;Use your own judgment for the commit messages, I recommend a verbose style using &lt;code&gt;magit-commit-add-log&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>