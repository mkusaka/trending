<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-27T01:41:00Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dimitri/el-get</title>
    <updated>2022-06-27T01:41:00Z</updated>
    <id>tag:github.com,2022-06-27:/dimitri/el-get</id>
    <link href="https://github.com/dimitri/el-get" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Manage the external elisp bits and pieces upon which you depend!&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/dimitri/el-get/actions&#34;&gt;&lt;img src=&#34;https://github.com/dimitri/el-get/actions/workflows/test.yml/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.github.com/dimitri/el-get/master/logo/el-get.png&#34; alt=&#34;Color El-Get logo&#34;&gt; El-Get allows you to install and manage &lt;code&gt;elisp&lt;/code&gt; code for Emacs. It supports lots of different types of sources and is able to &lt;em&gt;install&lt;/em&gt; them, &lt;em&gt;update&lt;/em&gt; them and &lt;em&gt;remove&lt;/em&gt; them, but more importantly it will &lt;em&gt;init&lt;/em&gt; them for you. That means it will &lt;code&gt;require&lt;/code&gt; the &lt;em&gt;features&lt;/em&gt; you need, &lt;code&gt;load&lt;/code&gt; the necessary files, set the &lt;em&gt;Info&lt;/em&gt; paths so that &lt;code&gt;C-h i&lt;/code&gt; shows the new documentation you now depend on, and finally call your own initialisation code for you to setup the extension. Or call it a package.&lt;/p&gt; &#xA;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/dimitri/el-get?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/dimitri/el-get.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/dimitri/el-get&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are many methods to keep track of your emacs setup. You can manage it all in a private git repository, you can set up &lt;code&gt;git submodules&lt;/code&gt; or directly import external repositories. You can manually retrieve the various packages you wish to track and ensure they are installed on any machine you apply your configuration to.&lt;/p&gt; &#xA;&lt;p&gt;All of these systems require some degree of manual maintenance, especially if you have packages from various types of locations: &lt;a href=&#34;https://github.com&#34;&gt;github&lt;/a&gt;, &lt;a href=&#34;http://emacswiki.org&#34;&gt;emacswiki&lt;/a&gt;, &lt;a href=&#34;http://elpa.gnu.org/&#34;&gt;GNU ELPA&lt;/a&gt; or &lt;a href=&#34;http://marmalade-repo.org/&#34;&gt;Marmalade&lt;/a&gt;, privately hosted pages, &lt;a href=&#34;http://git-scm.com/&#34;&gt;git&lt;/a&gt;, &lt;a href=&#34;http://bazaar.canonical.com/en/&#34;&gt;bzr&lt;/a&gt;, &lt;a href=&#34;http://www.nongnu.org/cvs/&#34;&gt;CVS&lt;/a&gt;, the list goes on.&lt;/p&gt; &#xA;&lt;p&gt;El-Get is designed to simplify this process and allow access to all the various methods of obtaining packages from a single interface. Every package has a recipe that allows you to locate the original source, and that can be updated if the package is moved.&lt;/p&gt; &#xA;&lt;p&gt;Whether you are using one machine or many, El-Get provides you with a simple interface to your list of installed packages, and the tools to keep them up to date.&lt;/p&gt; &#xA;&lt;h1&gt;El-Get, ELPA and package.el&lt;/h1&gt; &#xA;&lt;p&gt;Emacs 24 ships with &lt;code&gt;package.el&lt;/code&gt; which allows for easy installation of Emacs Lisp extensions for Emacs, and supports several servers where to find a list of packaged extension.&lt;/p&gt; &#xA;&lt;p&gt;Rather than ask authors or contributors to clean-up and package existing software, the El-Get approach is to take bits and pieces as they exist today and still empower Emacs users in a way that those random electrons are easy to use.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s why El-Get supports &lt;code&gt;package.el&lt;/code&gt; as one of its &lt;em&gt;methods&lt;/em&gt; to fetch Emacs Lisp Extensions.&lt;/p&gt; &#xA;&lt;p&gt;Technical differences also include the ability for El-Get to run OS commands (such as &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;ginstall-info&lt;/code&gt;) so as to better cope with the diversity found in the wild, allowing for automatic inclusion of &lt;em&gt;Info&lt;/em&gt; pages for packages providing some.&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;el-get-elpa-build-local-recipes&lt;/code&gt; to install extensions provided by ELPA.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;El-Get is easy to install. The only requirements to do so successfully are Emacs (24.3 and above), &lt;code&gt;git&lt;/code&gt; and a connection to the internet that allows you to &lt;code&gt;git clone&lt;/code&gt; repositories.&lt;/p&gt; &#xA;&lt;p&gt;If you do not already have &lt;code&gt;git&lt;/code&gt; on your system, you can install it through your package manager if you are using Linux or by downloading it from the &lt;a href=&#34;http://git-scm.com/&#34;&gt;Git Homepage&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;Installing El-Get depends on a working &lt;code&gt;install-info&lt;/code&gt; command, please make sure you have one in your &lt;code&gt;PATH&lt;/code&gt;. In &lt;code&gt;debian&lt;/code&gt;, it&#39;s available in the &lt;a href=&#34;http://packages.debian.org/squeeze/install-info&#34;&gt;install-info debian package&lt;/a&gt;. The &lt;a href=&#34;http://developer.apple.com/library/mac/#DOCUMENTATION/Darwin/Reference/ManPages/man1/install-info.1.html&#34;&gt;MacOSX install-info&lt;/a&gt; version works fine with El-Get.&lt;/p&gt; &#xA;&lt;p&gt;When using the &lt;em&gt;windows&lt;/em&gt; operating system, take into account that the way Emacs calls external programs is not the same for &lt;em&gt;native builds&lt;/em&gt; and &lt;em&gt;cygwin&lt;/em&gt;, so make sure you don&#39;t mix and match them at least for &lt;code&gt;install-info&lt;/code&gt; (e.g. &lt;em&gt;cygwin&lt;/em&gt; version of &lt;code&gt;install-info&lt;/code&gt; will error out when called by el-get from a &lt;code&gt;windows-nt&lt;/code&gt; Emacs, see &lt;code&gt;system-type&lt;/code&gt;). When using a &lt;em&gt;native build&lt;/em&gt; of Emacs for windows, consider using the &lt;a href=&#34;http://gnuwin32.sourceforge.net/packages.html&#34;&gt;GNU Win 32&lt;/a&gt; distribution of &lt;a href=&#34;http://gnuwin32.sourceforge.net/packages/texinfo.htm&#34;&gt;TexInfo for windows&lt;/a&gt;, which contains the proper &lt;code&gt;install-info&lt;/code&gt; version when you&#39;re not using the &lt;em&gt;cygwin&lt;/em&gt; Emacs binary.&lt;/p&gt; &#xA;&lt;h2&gt;The Lazy Installer&lt;/h2&gt; &#xA;&lt;p&gt;To install El-Get you can use the &lt;em&gt;lazy-installer&lt;/em&gt;. This will not load it on startup or otherwise affect future usage of Emacs. If you wish to ensure that El-Get will be available in future Emacs session please use the code provided in &lt;strong&gt;Basic Setup&lt;/strong&gt;. Using the code below will require an internet connection even if El-Get is already installed, that&#39;s why it&#39;s advised to use it for first time installation, not for embedding into your &lt;code&gt;.emacs&lt;/code&gt; (or your &lt;code&gt;user-init-file&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;; So the idea is that you copy/paste this code into your *scratch* buffer,&#xA;;; hit C-j, and you have a working el-get.&#xA;(url-retrieve&#xA; &#34;https://raw.githubusercontent.com/dimitri/el-get/master/el-get-install.el&#34;&#xA; (lambda (s)&#xA;   (goto-char (point-max))&#xA;   (eval-print-last-sexp)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: if you are using Windows see &lt;a href=&#34;https://github.com/dimitri/el-get/wiki/Installation-on-Windows&#34;&gt;Installation on Windows&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Evaluating this code after copying it into your &lt;code&gt;*scratch*&lt;/code&gt; buffer by typing &lt;code&gt;C-j&lt;/code&gt; or &lt;code&gt;M-x eval-print-last-exp&lt;/code&gt; will retrieve the El-Get installation script. This script will then use &lt;code&gt;git&lt;/code&gt; to clone El-Get and install it to the default location (&lt;code&gt;~/.emacs.d/el-get/el-get&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Replicating a package set on another Emacs installation&lt;/h2&gt; &#xA;&lt;p&gt;In the Emacs whose setup you wish to replicate, type &lt;code&gt;M-x ielm&lt;/code&gt; for an Emacs Lisp prompt, and enter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;`(setq my-packages&#xA;              &#39;,(mapcar #&#39;el-get-as-symbol&#xA;                        (el-get-list-package-names-with-status &#34;installed&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Copy the result into the new Emacs, in which you should already have installed El-Get, and evaluate it, followed by &lt;code&gt;(el-get &#39;sync my-packages)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Setup&lt;/h1&gt; &#xA;&lt;h2&gt;Basic Setup&lt;/h2&gt; &#xA;&lt;p&gt;If you wish to ensure that El-Get is available when you load Emacs you can place the following elisp code in your init file. It will detect if &lt;code&gt;el-get&lt;/code&gt; is already installed and install it if necessary.&lt;/p&gt; &#xA;&lt;p&gt;The addition of &lt;code&gt;(el-get &#39;sync)&lt;/code&gt; in the code blocks below ensures that any currently &lt;em&gt;installed&lt;/em&gt; packages will be initialized and any &lt;em&gt;required&lt;/em&gt; packages will be installed.&lt;/p&gt; &#xA;&lt;p&gt;Calling the &lt;code&gt;el-get&lt;/code&gt; function is covered in details in the full &lt;em&gt;Info&lt;/em&gt; manual.&lt;/p&gt; &#xA;&lt;p&gt;Here is the basic setup to add to your &lt;code&gt;user-init-file&lt;/code&gt; (&lt;code&gt;.emacs&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(add-to-list &#39;load-path &#34;~/.emacs.d/el-get/el-get&#34;)&#xA;&#xA;(unless (require &#39;el-get nil &#39;noerror)&#xA;  (with-current-buffer&#xA;      (url-retrieve-synchronously&#xA;       &#34;https://raw.githubusercontent.com/dimitri/el-get/master/el-get-install.el&#34;)&#xA;    (goto-char (point-max))&#xA;    (eval-print-last-sexp)))&#xA;&#xA;(add-to-list &#39;el-get-recipe-path &#34;~/.emacs.d/el-get-user/recipes&#34;)&#xA;(el-get &#39;sync)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Alternative Basic Setup with Installation via MELPA&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-to-list &#39;load-path &#34;~/.emacs.d/el-get/el-get&#34;)&#xA;&#xA;(unless (require &#39;el-get nil &#39;noerror)&#xA;  (require &#39;package)&#xA;  (add-to-list &#39;package-archives&#xA;               &#39;(&#34;melpa&#34; . &#34;http://melpa.org/packages/&#34;))&#xA;  (package-refresh-contents)&#xA;  (package-initialize)&#xA;  (package-install &#39;el-get)&#xA;  (require &#39;el-get))&#xA;&#xA;(add-to-list &#39;el-get-recipe-path &#34;~/.emacs.d/el-get-user/recipes&#34;)&#xA;(el-get &#39;sync)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Package Setup&lt;/h2&gt; &#xA;&lt;p&gt;The easiest way to setup a given package is to add its initialization code to a file named &lt;code&gt;init-&amp;lt;package&amp;gt;.el&lt;/code&gt; with &lt;code&gt;&amp;lt;package&amp;gt;&lt;/code&gt; replaced with the package name. This file needs to be placed in the directory &lt;code&gt;el-get-user-package-directory&lt;/code&gt; (defaults to &lt;code&gt;nil&lt;/code&gt;, you have to set a value for it, like for example &lt;code&gt;~/.emacs.d/el-get-init-files/&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;El-Get will then load that file at package initialization time. See the full &lt;em&gt;Info&lt;/em&gt; documentation for more details and possibilities.&lt;/p&gt; &#xA;&lt;p&gt;Many &lt;code&gt;init-&lt;/code&gt; packages are already available in El-Get.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;El-Get requires very little interaction with your init file when managing packages. &lt;strong&gt;Basic Usage&lt;/strong&gt; explains how to manage your packages without ever having to touch your init file again (meaning, &lt;em&gt;once El-Get is installed&lt;/em&gt;). &lt;strong&gt;Advanced Usage with Local Recipes&lt;/strong&gt; explains how to write your init file with explicitly specifying packages to install (when sharing the same setup between several machines for example).&lt;/p&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Adding and removing packages&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;M-x el-get-install&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Will prompt for a package name, with completion, then install it. It will only propose packages that are not already &lt;code&gt;installed&lt;/code&gt;. Any package that you have a recipe for is a candidate.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;M-x el-get-remove&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Will prompt for an &lt;code&gt;installed&lt;/code&gt; package name, with completion, then remove it. Depending on the &lt;code&gt;type&lt;/code&gt; of the package, this often means simply deleting the directory where the source package lies. Sometime we have to use external tools instead (e.g. &lt;code&gt;apt-get&lt;/code&gt;). No effort is made to unload the features.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;M-x el-get-reinstall&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;This is just a shortcut for &lt;code&gt;el-get-remove&lt;/code&gt; followed by &lt;code&gt;el-get-install&lt;/code&gt; of the same package. It is primarily useful when a package has changed types, so the normal &lt;code&gt;el-get-update&lt;/code&gt; process will not work correctly.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Keeping up to date&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;M-x el-get-self-update&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Update only one package, &lt;code&gt;el-get&lt;/code&gt; itself.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;M-x el-get-update&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Will prompt for an installed package name, with completion, then update it. This will run the &lt;code&gt;build&lt;/code&gt; commands and &lt;code&gt;init&lt;/code&gt; the package again.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;M-x el-get-update-all&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Will update all packages that have the &lt;code&gt;installed&lt;/code&gt; status in your status file. Before the update you will be prompted for confirmation that you wish to proceed.&lt;/p&gt; &lt;p&gt;Beware that using this function can lead to hours of settings review: more often than not updating a package requires some adjustments to your setup. Updating all of them at once will require reviewing almost all your setup.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;M-x el-get-reload&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Reload the given package files. Happens automatically at update time too.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Viewing available recipes&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;M-x el-get-list-packages&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Opens a buffer listing all known packages (those for which you have a recipe). The listing includes the package name, its status (one of &lt;em&gt;available&lt;/em&gt;, &lt;em&gt;installed&lt;/em&gt;, &lt;em&gt;removed&lt;/em&gt; or &lt;em&gt;required&lt;/em&gt;) and the package description. The description is a free form text and has not been provided for all recipes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;M-x el-get-describe&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Prompt for a package name, with completion, then open an &lt;code&gt;*Help*&lt;/code&gt; window with details about the selected package. Those include current status, website, description, installation method, full recipe, and buttons to easily install, update or remove the package.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;M-x el-get-find-recipe-file&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Will prompt for the name of a package, with completion, then &lt;code&gt;find-file&lt;/code&gt; its &lt;code&gt;recipe&lt;/code&gt; file. If the recipe does not exist, it will create a new recipe file with the appropriate name.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Advanced Usage with Local Recipes&lt;/h2&gt; &#xA;&lt;p&gt;Placing &lt;code&gt;el-get-bundle&lt;/code&gt; macro calls instead of &lt;code&gt;(el-get &#39;sync)&lt;/code&gt; in your init file to explicitly specify which packages should be installed. The macro accepts either a simple package name from defined recipes, a package name with a local recipe definition, a package with initialization code, or everything together.&lt;/p&gt; &#xA;&lt;p&gt;Note that if you leave in the &lt;code&gt;(el-get &#39;sync)&lt;/code&gt; call (which you need to, unless you&#39;ve also made sure to explicitly call &lt;code&gt;el-get-bundle&lt;/code&gt; for all dependency packages), it &lt;em&gt;must&lt;/em&gt; go after any recipe defining &lt;code&gt;el-get-bundle&lt;/code&gt; calls, otherwise el-get won&#39;t know the recipe when it tries to initialize the package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;; Basic setup&#xA;&#xA;(add-to-list &#39;load-path &#34;~/.emacs.d/el-get/el-get&#34;)&#xA;&#xA;(unless (require &#39;el-get nil &#39;noerror)&#xA;  (with-current-buffer&#xA;      (url-retrieve-synchronously&#xA;       &#34;https://raw.githubusercontent.com/dimitri/el-get/master/el-get-install.el&#34;)&#xA;    (goto-char (point-max))&#xA;    (eval-print-last-sexp)))&#xA;&#xA;(add-to-list &#39;el-get-recipe-path &#34;~/.emacs.d/el-get-user/recipes&#34;)&#xA;&#xA;;; Simple package names&#xA;(el-get-bundle yasnippet)&#xA;(el-get-bundle color-moccur)&#xA;&#xA;;; Locally defined recipe&#xA;(el-get-bundle yaicomplete&#xA;  :url &#34;https://github.com/tarao/elisp.git&#34;&#xA;  :features yaicomplete)&#xA;&#xA;;; With initialization code&#xA;(el-get-bundle zenburn-theme&#xA;  :url &#34;https://raw.githubusercontent.com/bbatsov/zenburn-emacs/master/zenburn-theme.el&#34;&#xA;  (load-theme &#39;zenburn t))&#xA;&#xA;;; End of recipes, call `el-get&#39; to make sure all packages (including&#xA;;; dependencies) are setup.&#xA;(el-get &#39;sync)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If a package with a local recipe definition has a recipe file, the definition overrides that in the recipe file.&lt;/p&gt; &#xA;&lt;p&gt;There is some syntactic sugar to specify a package name and a recipe source together.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(el-get-bundle tarao/tab-group-el)&#xA;;; equivalent to&#xA;;; (el-get-bundle tab-group-el :type github :pkgname &#34;tarao/tab-group-el&#34;)&#xA;&#xA;(el-get-bundle gist:4468816:pit&#xA;;; equivalent to&#xA;;; (el-get-bundle pit :type git :url &#34;http://gist.github.com/4468816.git&#34;)&#xA;&#xA;(el-get-bundle elpa:undo-tree)&#xA;;; equivalent to&#xA;;; (el-get-bundle undo-tree :type elpa)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please refer to the &lt;em&gt;Info&lt;/em&gt; documentation provided with El-Get for the complete syntax of &lt;code&gt;el-get-bundle&lt;/code&gt; and recipe definitions.&lt;/p&gt; &#xA;&lt;h1&gt;Conclusion&lt;/h1&gt; &#xA;&lt;p&gt;Enjoy El-get, enjoy Emacs, have fun with Emacs Lisp, and simplify your Emacs Setup &lt;strong&gt;today&lt;/strong&gt;!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>radian-software/prescient.el</title>
    <updated>2022-06-27T01:41:00Z</updated>
    <id>tag:github.com,2022-06-27:/radian-software/prescient.el</id>
    <link href="https://github.com/radian-software/prescient.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;☄️ Simple but effective sorting and filtering for Emacs.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;prescient.el:&lt;/strong&gt; simple but effective sorting and filtering for Emacs.&lt;/p&gt; &#xA;&lt;h2&gt;Summary&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;prescient.el&lt;/code&gt; is a library which sorts and filters lists of candidates, such as appear when you use a package like &lt;a href=&#34;https://github.com/abo-abo/swiper#ivy&#34;&gt;Ivy&lt;/a&gt; or &lt;a href=&#34;https://github.com/company-mode/company-mode&#34;&gt;Company&lt;/a&gt;. Extension packages such as &lt;code&gt;ivy-prescient.el&lt;/code&gt; and &lt;code&gt;company-prescient.el&lt;/code&gt; adapt the library for usage with various frameworks.&lt;/p&gt; &#xA;&lt;p&gt;As compared to other packages which accomplish similar tasks, including &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/ido.html&#34;&gt;IDO&lt;/a&gt;, &lt;a href=&#34;https://github.com/abo-abo/swiper#ivy&#34;&gt;Ivy&lt;/a&gt;, &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;Helm&lt;/a&gt;, &lt;a href=&#34;https://github.com/nonsequitur/smex&#34;&gt;Smex&lt;/a&gt;, &lt;a href=&#34;https://github.com/lewang/flx&#34;&gt;Flx&lt;/a&gt;, &lt;a href=&#34;https://github.com/PythonNut/historian.el&#34;&gt;Historian&lt;/a&gt;, and &lt;a href=&#34;https://github.com/company-mode/company-statistics&#34;&gt;Company-Statistics&lt;/a&gt;, &lt;code&gt;prescient.el&lt;/code&gt; aims to be simpler, more predictable, and faster.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;prescient.el&lt;/code&gt; is available on MELPA as four separate packages (one for the library, and the rest for integrating with other frameworks):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://melpa.org/#/prescient&#34;&gt;&lt;code&gt;prescient&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://melpa.org/#/ivy-prescient&#34;&gt;&lt;code&gt;ivy-prescient&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://melpa.org/#/company-prescient&#34;&gt;&lt;code&gt;company-prescient&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://melpa.org/#/selectrum-prescient&#34;&gt;&lt;code&gt;selectrum-prescient&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The easiest way to install these packages is using &lt;a href=&#34;https://github.com/raxod502/straight.el&#34;&gt;&lt;code&gt;straight.el&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(straight-use-package &#39;prescient)&#xA;(straight-use-package &#39;ivy-prescient)&#xA;(straight-use-package &#39;company-prescient)&#xA;(straight-use-package &#39;selectrum-prescient)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, you may install using any other package manager if you prefer.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To cause &lt;a href=&#34;https://github.com/abo-abo/swiper#ivy&#34;&gt;Ivy&lt;/a&gt; to use &lt;code&gt;prescient.el&lt;/code&gt; sorting and filtering, enable &lt;code&gt;ivy-prescient-mode&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To cause &lt;a href=&#34;https://github.com/company-mode/company-mode&#34;&gt;Company&lt;/a&gt; to use &lt;code&gt;prescient.el&lt;/code&gt; sorting, enable &lt;code&gt;company-prescient-mode&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To cause &lt;a href=&#34;https://github.com/raxod502/selectrum&#34;&gt;Selectrum&lt;/a&gt; to use &lt;code&gt;prescient.el&lt;/code&gt; sorting and filtering, enable &lt;code&gt;selectrum-prescient-mode&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To cause your usage statistics to be saved between Emacs sessions, enable &lt;code&gt;prescient-persist-mode&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please note that &lt;strong&gt;you must load Counsel before &lt;code&gt;ivy-prescient.el&lt;/code&gt;&lt;/strong&gt;. This is because loading Counsel results in a number of changes being made to the user options of Ivy, which &lt;code&gt;ivy-prescient.el&lt;/code&gt; must then undo.&lt;/p&gt; &#xA;&lt;p&gt;The modes handle sorting and filtering by default. See the package specific sections for options to configure this.&lt;/p&gt; &#xA;&lt;h2&gt;Algorithm&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;prescient.el&lt;/code&gt; takes as input a list of candidates, and a query that you type. The query is first split on spaces into subqueries (two consecutive spaces match a literal space). Each subquery filters the candidates because it must match as either a substring of the candidate, a regexp, or an initialism (e.g. &lt;code&gt;ffap&lt;/code&gt; matches &lt;code&gt;find-file-at-point&lt;/code&gt;, and so does &lt;code&gt;fa&lt;/code&gt;). The last few candidates you selected are displayed first, followed by the most frequently selected ones, and then the remaining candidates are sorted by length. If you don&#39;t like the algorithm used for filtering, you can choose a different one by customizing &lt;code&gt;prescient-filter-method&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you would like &lt;code&gt;prescient.el&lt;/code&gt; to forget about a candidate, use the command &lt;code&gt;prescient-forget&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration and other features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prescient-history-length&lt;/code&gt;: The number of recently selected candidates that are remembered and displayed at the top of the list.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prescient-frequency-decay&lt;/code&gt;: &lt;code&gt;prescient.el&lt;/code&gt; keeps a &#34;frequency&#34; for each selected candidate, which is incremented by one each time you select the candidate. To keep things tidy, frequencies are multiplied by this variable&#39;s value each time you select a new candidate, so they decrease over time.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prescient-frequency-threshold&lt;/code&gt;: Once the frequency for an infrequently used command falls below the value of this variable, &lt;code&gt;prescient.el&lt;/code&gt; forgets about it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prescient-save-file&lt;/code&gt;: Where to save statistics that are persisted between Emacs sessions when &lt;code&gt;prescient-persist-mode&lt;/code&gt; is active. The default value follows the conventions of &lt;a href=&#34;https://github.com/emacscollective/no-littering&#34;&gt;&lt;code&gt;no-littering&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prescient-filter-method&lt;/code&gt;: A list of algorithms to use for filtering candidates. The default is &lt;code&gt;literal&lt;/code&gt;, &lt;code&gt;regexp&lt;/code&gt;, and &lt;code&gt;initialism&lt;/code&gt; as described above, but you can also use substring matching, initialism matching, regexp matching, fuzzy matching, prefix matching, anchored matching, literal-prefix matching, or any combination of those. See the docstring for full details.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prescient-filter-alist&lt;/code&gt;: An alist of symbol-function pairs that associate a symbol in &lt;code&gt;prescient-filter-method&lt;/code&gt; with a function that creates a regexp for matching a candidate. You can add to this alist to define your own custom filter methods, and use them by adding the appropriate symbol to &lt;code&gt;prescient-filter-method&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prescient-sort-full-matches-first&lt;/code&gt;: Whether &lt;code&gt;prescient.el&lt;/code&gt; sorts candidates that are fully matched before candidates that are partially matched.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prescient-use-char-folding&lt;/code&gt;: Whether the &lt;code&gt;literal&lt;/code&gt; and &lt;code&gt;literal-prefix&lt;/code&gt; filter methods use character folding.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;prescient-use-case-folding&lt;/code&gt;: Whether filtering methods use case folding (in non-Emacs terms, whether they are not case-sensitive). This can be one of &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, or &lt;code&gt;smart&lt;/code&gt; (the default). If &lt;code&gt;smart&lt;/code&gt;, then case folding is disabled when upper-case characters are sought.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Company-specific&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;company-prescient-sort-length-enable&lt;/code&gt;: By default, the standard &lt;code&gt;prescient.el&lt;/code&gt; sorting algorithm is used for all Company completions when &lt;code&gt;company-prescient-mode&lt;/code&gt; is enabled. However, this algorithm is inappropriate in some situations. In particular, some Company backends return fuzzy-matched candidates with an intelligent sorting pre-applied. In this case, the fallback sorting by length that &lt;code&gt;prescient.el&lt;/code&gt; does will just make a giant mess of things. By customizing this user option to nil for such Company backends (see &lt;a href=&#34;https://github.com/raxod502/radian/raw/06f2a30258deacb719a195221747ce1d528fc2fe/emacs/radian.el#L2513-L2532&#34;&gt;Radian&lt;/a&gt; for an example), you can avoid the problem. Then &lt;code&gt;prescient.el&lt;/code&gt; will helpfully move recently and frequently used candidates to the top of the completions list, but otherwise leave candidate ordering alone.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Ivy-specific&lt;/h3&gt; &#xA;&lt;p&gt;The following user options are specific to using &lt;code&gt;prescient.el&lt;/code&gt; with Ivy:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ivy-prescient-sort-commands&lt;/code&gt;: By default, all commands have their candidates sorted. You can override this behavior by customizing &lt;code&gt;ivy-prescient-sort-commands&lt;/code&gt;. See the docstring.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ivy-prescient-retain-classic-highlighting&lt;/code&gt;: By default, the highlighting behavior of &lt;code&gt;ivy-prescient.el&lt;/code&gt; is slightly different from Ivy&#39;s highlighting for &lt;code&gt;ivy--regex-ignore-order&lt;/code&gt;. You can recover the original behavior by customizing this user option; see the docstring for more details.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ivy-prescient-enable-filtering&lt;/code&gt;: If set to nil, then &lt;code&gt;ivy-prescient.el&lt;/code&gt; does not apply &lt;code&gt;prescient.el&lt;/code&gt; filtering to Ivy. See the Ivy documentation for information on how Ivy filters by default, and how to customize it manually.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ivy-prescient-enable-sorting&lt;/code&gt;: If set to nil, then &lt;code&gt;ivy-prescient.el&lt;/code&gt; does not apply &lt;code&gt;prescient.el&lt;/code&gt; sorting to Ivy. See the Ivy documentation for information on how Ivy sorts by default, and how to customize it manually.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Selectrum-specific&lt;/h3&gt; &#xA;&lt;p&gt;The following user options are specific to using &lt;code&gt;prescient.el&lt;/code&gt; with Selectrum:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;selectrum-prescient-enable-filtering&lt;/code&gt;: If set to nil, then &lt;code&gt;selectrum-prescient.el&lt;/code&gt; does not change filtering of Selectrum. See the Selectrum documentation for information on how Selectrum configures filtering by default, and how to customize it manually.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;selectrum-prescient-enable-sorting&lt;/code&gt;: If set to nil, then &lt;code&gt;selectrum-prescient.el&lt;/code&gt; does not change sorting of Selectrum. See the Selectrum documentation for information on how Selectrum configures sorting by default, and how to customize it manually.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;selectrum-prescient.el&lt;/code&gt; provides special commands (see the table below) to adjust how &lt;code&gt;prescient.el&lt;/code&gt; filters candidates in the current Selectrum buffer.&lt;/p&gt; &#xA;&lt;p&gt;For example, to toggle regexp filtering on or off (perhaps you&#39;re searching for a long/complex candidate), you can press &lt;code&gt;M-s r&lt;/code&gt;. If you wish to use &lt;em&gt;only&lt;/em&gt; regexp filtering, you can use &lt;code&gt;C-u M-s r&lt;/code&gt; to unconditionally turn on regexp filtering and turn off all other methods. This toggling is a buffer-local effect, and does not change the default filter behavior. For that, customize &lt;code&gt;prescient-filter-method&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;These commands are similar in usage to Isearch&#39;s own toggling commands, except that multiple filtering methods can be active at the same time. While &lt;code&gt;selectrum-prescient-mode&lt;/code&gt; is enabled, &lt;code&gt;M-s&lt;/code&gt; is bound to &lt;code&gt;selectrum-prescient-toggle-map&lt;/code&gt; in the Selectrum buffer, and is used as a prefix key to access the commands.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Key&lt;/th&gt; &#xA;   &lt;th&gt;Command&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;M-s a&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;selectrum-prescient-toggle-anchored&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;M-s f&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;selectrum-prescient-toggle-fuzzy&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;M-s i&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;selectrum-prescient-toggle-initialism&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;M-s l&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;selectrum-prescient-toggle-literal&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;M-s p&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;selectrum-prescient-toggle-prefix&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;M-s P&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;selectrum-prescient-toggle-literal-prefix&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;M-s r&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;selectrum-prescient-toggle-regexp&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;M-s &#39;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;selectrum-prescient-toggle-char-fold&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;M-s c&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;selectrum-prescient-toggle-case-fold&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;When defining custom filter methods, you can create new bindings using &lt;code&gt;selectrum-prescient-create-and-bind-toggle-command&lt;/code&gt;, which takes an unquoted filter symbol and a string that can be used by &lt;code&gt;kbd&lt;/code&gt;. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(selectrum-prescient-create-and-bind-toggle-command my-foo &#34;M-f&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will bind a command to toggle the &lt;code&gt;my-foo&lt;/code&gt; filter to &lt;code&gt;M-s M-f&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With &lt;code&gt;selectrum-prescient-enable-filtering&lt;/code&gt; set, the part of each candidate that matches your input is highlighted with the face &lt;code&gt;selectrum-prescient-primary-highlight&lt;/code&gt;. There is also &lt;code&gt;selectrum-prescient-secondary-highlight&lt;/code&gt; for additional highlighting of specific matched parts of the input.&lt;/p&gt; &#xA;&lt;p&gt;The following example shows customizing these faces, I use the &lt;a href=&#34;https://github.com/NicolasPetton/zerodark-theme&#34;&gt;Zerodark&lt;/a&gt; color theme, which includes colors for Ivy, but not for Selectrum. I inspected the theme source code to see what colors were being used for Ivy, and copied them to be used for Selectrum as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;zerodark-theme)&#xA;&#xA;(let ((class &#39;((class color) (min-colors 89))))&#xA;  (custom-theme-set-faces&#xA;   &#39;zerodark&#xA;   `(selectrum-current-candidate&#xA;     ((,class (:background &#34;#48384c&#34;&#xA;                           :weight bold&#xA;                           :foreground &#34;#c678dd&#34;))))&#xA;   `(selectrum-prescient-primary-highlight&#xA;   ((,class (:foreground &#34;#da8548&#34;))))&#xA;   `(selectrum-prescient-secondary-highlight&#xA;   ((,class (:foreground &#34;#98be65&#34;))))))&#xA;&#xA;(enable-theme &#39;zerodark)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributor guide&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/raxod502/contributor-guide&#34;&gt;the contributor guide for my projects&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tumashu/posframe</title>
    <updated>2022-06-27T01:41:00Z</updated>
    <id>tag:github.com,2022-06-27:/tumashu/posframe</id>
    <link href="https://github.com/tumashu/posframe" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Pop a posframe (just a child-frame) at point, posframe is a **GNU ELPA** package!&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Created 2021-06-01 Tue 10:41&lt;/h1&gt; &#xA;&lt;p&gt;#+TITLE: Pop a posframe (just a frame) at point #+AUTHOR: Feng Shu&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;http://elpa.gnu.org/packages/posframe.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/posframe.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/devel/posframe.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/posframe.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/posframe&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/posframe-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;What is posframe? Posframe can pop up a frame at point, this &lt;em&gt;posframe&lt;/em&gt; is a child-frame connected to its root window&#39;s buffer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The main advantages are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;It is fast enough for daily usage :-)&lt;/li&gt; &#xA; &lt;li&gt;It works well with CJK languages.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;NOTE:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;For MacOS users, posframe needs Emacs version &amp;gt;= 26.0.91&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;GNOME users with GTK3 builds need Emacs 27 or later. See variable `posframe-gtk-resize-child-frames&#39; which auto-detects this configuration.&lt;/p&gt; &lt;p&gt;More details:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;[[https://git.savannah.gnu.org/cgit/emacs.git/commit/?h=emacs-27&amp;amp;id=c49d379f17bcb0ce82604def2eaa04bda00bd5ec][Fix some problems with moving and resizing child frames]]&lt;/li&gt; &#xA;   &lt;li&gt;[[https://lists.gnu.org/archive/html/emacs-devel/2020-01/msg00343.html][Emacs&#39;s set-frame-size can not work well with gnome-shell?]]&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;[[file:./snapshots/posframe-1.png]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_example (require &#39;posframe) #+end_example&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Create a posframe&lt;/p&gt; &#xA;&lt;p&gt;*** Simple way #+begin_example (when (posframe-workable-p) (posframe-show &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34; :string &#34;This is a test&#34; :position (point))) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;*** Advanced way #+begin_example (defvar my-posframe-buffer &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;)&lt;/p&gt; &#xA;&lt;p&gt;(with-current-buffer (get-buffer-create my-posframe-buffer) (erase-buffer) (insert &#34;Hello world&#34;))&lt;/p&gt; &#xA;&lt;p&gt;(when (posframe-workable-p) (posframe-show my-posframe-buffer :position (point))) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;*** Arguments&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example C-h f posframe-show #+end_example&lt;/p&gt; &#xA;&lt;p&gt;** Hide a posframe #+begin_example (posframe-hide &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;** Hide all posframes #+begin_example M-x posframe-hide-all #+end_example&lt;/p&gt; &#xA;&lt;p&gt;** Delete a posframe&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Delete posframe and its buffer #+begin_example (posframe-delete &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;) #+end_example&lt;/li&gt; &#xA; &lt;li&gt;Only delete the frame #+begin_example (posframe-delete-frame &#34; &lt;em&gt;my-posframe-buffer&lt;/em&gt;&#34;) #+end_example ** Delete all posframes #+begin_example M-x posframe-delete-all #+end_example&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note: this command will delete all posframe buffers. You probably shouldn&#39;t use it if you are sharing a buffer between posframe and other packages.&lt;/p&gt; &#xA;&lt;p&gt;** posframe-arghandler&lt;/p&gt; &#xA;&lt;p&gt;posframe-arghandler feature has been removed from posframe-1.1, user can use advice feature instead.&lt;/p&gt; &#xA;&lt;p&gt;** Mouse banish Default setting will work well in most case, but for EXWM user, suggest use the below config.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq posframe-mouse-banish-function #&#39;posframe-mouse-banish-simple) #+end_src&lt;/p&gt;</summary>
  </entry>
</feed>