<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-14T01:39:54Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>emacs-typescript/typescript.el</title>
    <updated>2022-07-14T01:39:54Z</updated>
    <id>tag:github.com,2022-07-14:/emacs-typescript/typescript.el</id>
    <link href="https://github.com/emacs-typescript/typescript.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;TypeScript-support for Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;typescript.el&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/emacs-typescript/typescript.el/workflows/Build%20&amp;amp;%20Test/badge.svg?sanitize=true&#34; alt=&#34;Build &amp;amp; Test&#34;&gt; &lt;a href=&#34;https://melpa.org/#/typescript-mode&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/typescript-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/typescript-mode&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/typescript-mode-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;typescript.el&lt;/code&gt; is a major-mode for editing &lt;a href=&#34;http://www.typescriptlang.org/&#34;&gt;Typescript&lt;/a&gt;-files in &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;GNU Emacs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;typescript.el&lt;/code&gt; is a self-contained, lightweight and minimalist major-mode focused on providing basic font-lock/syntax-highlighting and indentation for Typescript syntax, without any external dependencies.&lt;/p&gt; &#xA;&lt;p&gt;Output from &lt;code&gt;tsc&lt;/code&gt; and &lt;code&gt;tslint&lt;/code&gt; is also handled seamlessly through &lt;code&gt;compilation-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;A short note on development HALT&lt;/h2&gt; &#xA;&lt;p&gt;As the both the JavaScript and TypeScript languages have evolved to become ever more complex, so has the Elisp codebase for &lt;code&gt;typescript-mode&lt;/code&gt; trying to correctly handle them.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;&#39;ve been at the point for quite some time where it has become increasingly obvious that the current code-base simply cannot continue growing. It will be slow. It will be complex. It will be buggy. It will be head-ache inducing to wrap our heads around it, and ... I guess we&#39;re already there.&lt;/p&gt; &#xA;&lt;p&gt;Apart from occasional PRs getting merged, the current &lt;code&gt;typescript-mode&lt;/code&gt; code isn&#39;t being developed because almost nobody wants to work code of this complexity.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Essentially all major development of &lt;code&gt;typescript-mode&lt;/code&gt; has come to a halt.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Seeing the forest for trees&lt;/h2&gt; &#xA;&lt;p&gt;Lots of Emacs major-modes are facing the same problem. I&#39;m sure there&#39;s similar issues for other editors too.&lt;/p&gt; &#xA;&lt;p&gt;This means lots of developers are working on solving this problem once and for all, and what they&#39;ve decided on is relying on a standardized set of external parsers using the &lt;a href=&#34;https://tree-sitter.github.io/tree-sitter/&#34;&gt;tree-sitter&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;p&gt;New major modes are being developed as we speak to support TypeScript (and other languages) within Emacs based on Emacs&#39; upcoming native tree-sitter support.&lt;/p&gt; &#xA;&lt;p&gt;The code will be much faster, it will be simpler to work with and everyone should be happy. Well almost. Since tree-sitter support relies on a new major feature being added to core Emacs, it also means that these new major modes won&#39;t be backward compatible with older Emacs-versions.&lt;/p&gt; &#xA;&lt;p&gt;For that reason we are not &lt;em&gt;replacing&lt;/em&gt; this major mode with the new and improved one, but keeping it around to make sure older Emacs-versions does at least have an option for working with Typescript, even though it may not be optimal or track recent changes to the TypeScript-language.&lt;/p&gt; &#xA;&lt;p&gt;But once new Emacs ships with tree-sitter support, you are adviced to upgrade to the newer modes for better TypeScript-support, rather than keeping this old version around.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;typescript.el&lt;/code&gt; can be installed from source directly using your favourite approach or framework, or from MELPA and MELPA Stable as a package.&lt;/p&gt; &#xA;&lt;p&gt;To install typescript.el simply type &lt;code&gt;M-x package-install&amp;lt;RET&amp;gt;typescript-mode&amp;lt;RET&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Customization&lt;/h1&gt; &#xA;&lt;p&gt;To customize &lt;code&gt;typescript.el&lt;/code&gt; just type the following: &lt;code&gt;M-x customize-group&amp;lt;RET&amp;gt;typescript&amp;lt;RET&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can add any other customization you like to &lt;code&gt;typescript-mode-hook&lt;/code&gt; in your &lt;code&gt;init.el&lt;/code&gt; file. &lt;code&gt;typescript.el&lt;/code&gt; also handles &lt;code&gt;prog-mode-hook&lt;/code&gt; on versions of Emacs which supports it.&lt;/p&gt; &#xA;&lt;h1&gt;Support for Compilation Mode&lt;/h1&gt; &#xA;&lt;p&gt;This mode automatically adds support for &lt;code&gt;compilation-mode&lt;/code&gt; so that if you run &lt;code&gt;M-x compile&amp;lt;ret&amp;gt;tsc&amp;lt;ret&amp;gt;&lt;/code&gt; the error messages are correctly parsed.&lt;/p&gt; &#xA;&lt;p&gt;However, the error messages produced by &lt;code&gt;tsc&lt;/code&gt; when its &lt;code&gt;pretty&lt;/code&gt; flag is turned on include ANSI color escapes, which by default &lt;code&gt;compilation-mode&lt;/code&gt; does not interpret. In order to get the escapes parsed, you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;ansi-color)&#xA;(defun colorize-compilation-buffer ()&#xA;  (ansi-color-apply-on-region compilation-filter-start (point-max)))&#xA;(add-hook &#39;compilation-filter-hook &#39;colorize-compilation-buffer)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, if you prefer, you can configure &lt;code&gt;tsc&lt;/code&gt; with the &lt;code&gt;pretty&lt;/code&gt; flag set to &lt;code&gt;false&lt;/code&gt;: &lt;code&gt;tsc --pretty false&lt;/code&gt;. However, doing this does more than just turning off the colors. It also causes &lt;code&gt;tsc&lt;/code&gt; to produce less elaborate error messages.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;To run the tests you can run &lt;code&gt;make test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you prefer, you may run the tests via the provided &lt;code&gt;Dockerfile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t typescript-mode .&#xA;docker run --rm -v $(pwd):/typescript-mode typescript-mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Other Typescript-packages of interest&lt;/h1&gt; &#xA;&lt;p&gt;While &lt;code&gt;typescript.el&lt;/code&gt; may &lt;em&gt;not&lt;/em&gt; provide a full kitchen-sink, the good news is that there&#39;s other packages which do!&lt;/p&gt; &#xA;&lt;p&gt;More advanced features can be provided by using these additional packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/emacs-lsp/lsp-mode&#34;&gt;lsp-mode&lt;/a&gt; - A standards-based code-completion and refactoring backend, based on the &lt;a href=&#34;https://langserver.org/&#34;&gt;Language Server Protocol (LSP)&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/ananthakumaran/tide/&#34;&gt;tide&lt;/a&gt; - TypeScript Interactive Development Environment for Emacs&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/josteink/ts-comint&#34;&gt;ts-comint&lt;/a&gt; - a Typescript REPL in Emacs.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Initializing these with &lt;code&gt;typescript.el&lt;/code&gt; will then become a matter of creating your own &lt;code&gt;typescript-mode-hook&lt;/code&gt; in your &lt;code&gt;init.el&lt;/code&gt; file.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>radian-software/selectrum</title>
    <updated>2022-07-14T01:39:54Z</updated>
    <id>tag:github.com,2022-07-14:/radian-software/selectrum</id>
    <link href="https://github.com/radian-software/selectrum" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ”” Better solution for incremental narrowing in Emacs.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://melpa.org/#/selectrum&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/selectrum-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/selectrum&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/selectrum-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Selectrum&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/radian-software/selectrum/commits/master/CHANGELOG.md.atom&#34;&gt;News feed&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Selectrum is a better solution for incremental narrowing in Emacs, replacing &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;Helm&lt;/a&gt;, &lt;a href=&#34;https://github.com/abo-abo/swiper#ivy&#34;&gt;Ivy&lt;/a&gt;, and &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/ido/index.html&#34;&gt;Ido&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;!-- longlines-start --&gt; &#xA;&lt;!-- toc --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#what-is-it&#34;&gt;What is it?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#alternative-1-prescient&#34;&gt;Alternative 1: Prescient&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#alternative-2-orderless&#34;&gt;Alternative 2: Orderless&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#user-guide&#34;&gt;User guide&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#keybindings&#34;&gt;Keybindings&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#sorting-and-filtering&#34;&gt;Sorting and filtering&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#additional-features&#34;&gt;Additional features&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#customization&#34;&gt;Customization&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#complementary-extensions&#34;&gt;Complementary extensions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#but-what-is-it-doing-to-my-emacs&#34;&gt;But what is it doing to my Emacs??&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#news&#34;&gt;News&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#developer-guide&#34;&gt;Developer guide&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#usage-of-selectrum&#34;&gt;Usage of Selectrum&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#sorting-filtering-and-highlighting&#34;&gt;Sorting, filtering, and highlighting&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#text-properties&#34;&gt;Text properties&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#hooks&#34;&gt;Hooks&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#variables&#34;&gt;Variables&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#contributor-guide&#34;&gt;Contributor guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#caveats&#34;&gt;Caveats&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#selectrum-in-comparison-to-other-completion-systems&#34;&gt;Selectrum in comparison to other completion-systems&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#ido&#34;&gt;Ido&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#helm&#34;&gt;Helm&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#ivy&#34;&gt;Ivy&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#icomplete&#34;&gt;Icomplete&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#vertico&#34;&gt;Vertico&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#icicles&#34;&gt;Icicles&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#snails&#34;&gt;Snails&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#sallet&#34;&gt;Sallet&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#raven&#34;&gt;Raven&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#swiper&#34;&gt;Swiper&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- tocstop --&gt; &#xA;&lt;!-- longlines-stop --&gt; &#xA;&lt;h2&gt;What is it?&lt;/h2&gt; &#xA;&lt;p&gt;Selectrum aims to provide a better completion UI using standard Emacs APIs. In essence it is an interface for selecting items from a list.&lt;/p&gt; &#xA;&lt;p&gt;You can use it to run a command with &lt;code&gt;M-x&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/images/commands.png&#34; alt=&#34;Picking from a&#xA;list of commands&#34; height=&#34;200&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;You can use it to open a file with &lt;code&gt;C-x C-f&lt;/code&gt; (&lt;code&gt;find-file&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/images/files.png&#34; alt=&#34;Navigating the&#xA;filesystem&#34; height=&#34;200&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Even &lt;a href=&#34;https://www.gnu.org/software/tramp/#Quick-Start-Guide&#34;&gt;TRAMP&lt;/a&gt; works great out of the box:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/images/tramp.png&#34; alt=&#34;Using sudo via&#xA;TRAMP&#34; height=&#34;200&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;You can switch buffers:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/images/buffers.png&#34; alt=&#34;Switching to&#xA;another buffer&#34; height=&#34;200&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;And every other command in Emacs is automatically enhanced, without the need for any configuration:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/images/libraries.png&#34; alt=&#34;Finding&#xA;libraries, with load-path shadows&#34; height=&#34;200&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Selectrum is &lt;a href=&#34;https://melpa.org/#/selectrum&#34;&gt;available as a package on MELPA&lt;/a&gt;. The easiest way to install this package is using &lt;a href=&#34;https://github.com/radian-software/straight.el&#34;&gt;&lt;code&gt;straight.el&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(straight-use-package &#39;selectrum)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, you may install using any other package manager if you prefer.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To enable Selectrum, simply add to your init-file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(selectrum-mode +1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now all completion commands will automatically use Selectrum.&lt;/p&gt; &#xA;&lt;p&gt;The focus of Selectrum is on providing an enhanced completion UI and compose with &lt;a href=&#34;https://github.com/radian-software/selectrum#complementary-extensions&#34;&gt;other packages&lt;/a&gt; which stay within the constraints of the standard Emacs API. Because of the modular approach there are several possible package combinations. Many tips and setup help for integration with other packages can be found in our &lt;a href=&#34;https://github.com/radian-software/selectrum/wiki/Additional-Configuration&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The default sorting method of Selectrum is simple and predictable. The candidates are first sorted by their history position, then by length and then alphabetically.&lt;/p&gt; &#xA;&lt;p&gt;The default filtering of Selectrum uses the Emacs &lt;code&gt;completion-styles&lt;/code&gt;. The default setting of the &lt;code&gt;completion-styles&lt;/code&gt; variable is rather &#34;basic&#34; and you may want to adjust this variable for more advanced filtering. See for example the built-in &lt;code&gt;substring&lt;/code&gt; and &lt;code&gt;flex&lt;/code&gt; styles. Instead of using the built-in completion styles we recommended to use additional packages. Here we highlight two possible approaches for more advanced filtering and sorting: 1. Prescient and 2. Orderless.&lt;/p&gt; &#xA;&lt;h5&gt;Alternative 1: Prescient&lt;/h5&gt; &#xA;&lt;p&gt;Filtering and sorting can both be improved by installing the &lt;a href=&#34;https://github.com/radian-software/prescient.el&#34;&gt;&lt;code&gt;selectrum-prescient&lt;/code&gt;&lt;/a&gt; package from MELPA and adding the following to your init-file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;;; to make sorting and filtering more intelligent&#xA;(selectrum-prescient-mode +1)&#xA;&#xA;;; to save your command history on disk, so the sorting gets more&#xA;;; intelligent over time&#xA;(prescient-persist-mode +1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Your candidates are sorted by &lt;a href=&#34;https://en.wikipedia.org/wiki/Frecency&#34;&gt;&lt;em&gt;frecency&lt;/em&gt;&lt;/a&gt; (a combination of &lt;em&gt;frequency&lt;/em&gt; and &lt;em&gt;recency&lt;/em&gt;). Recently used candidates are sorted first, then frequently used candidates. The remaining candidates are sorted by length. This algorithm turns out to do very well in practice while being fast and not very magical.&lt;/li&gt; &#xA; &lt;li&gt;Your input is split on spaces into subqueries, each of which must (by default) match as either a substring, a regexp, or an initialism (e.g. &lt;code&gt;ffap&lt;/code&gt; matches &lt;code&gt;find-file-at-point&lt;/code&gt;). The subqueries can match a candidate in any order, but a candidate must match all subqueries to remain in the list of filtered candidates. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Other matching styles are available in addition to the default three, and custom styles can be added by users.&lt;/li&gt; &#xA;   &lt;li&gt;Filtering features can be toggled on the fly, such as whether to use character/case folding or which matching styles are active.&lt;/li&gt; &#xA;   &lt;li&gt;Optionally, fully matched candidates can be listed before partially matched candidates while keeping the frecency-based sorting.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The parts of each candidate that matched your input are highlighted, with important sections within each part (such as the initials of an initialism) highlighted in a second color.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Alternative 2: Orderless&lt;/h5&gt; &#xA;&lt;p&gt;Another popular choice for filtering is to use the flexible &lt;a href=&#34;https://github.com/oantolin/orderless&#34;&gt;&lt;code&gt;orderless&lt;/code&gt;&lt;/a&gt; completion style.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq completion-styles &#39;(orderless))&#xA;&#xA;;; Persist history over Emacs restarts&#xA;(savehist-mode)&#xA;&#xA;;; Optional performance optimization&#xA;;; by highlighting only the visible candidates.&#xA;(setq orderless-skip-highlighting (lambda () selectrum-is-active))&#xA;(setq selectrum-highlight-candidates-function #&#39;orderless-highlight-matches)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The candidates are sorted using the default sorting method of Selectrum (by &lt;em&gt;recency&lt;/em&gt;). The history is persisted using the Emacs built-in &lt;code&gt;savehist-mode&lt;/code&gt;. Afterwards the candidates are filtered and highlighted using the &lt;code&gt;completion-styles&lt;/code&gt;, in this case &lt;code&gt;orderless&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In some cases you may want to consider to use Prescient on top of Orderless. Prescient can be used to provide &lt;em&gt;frecency&lt;/em&gt;-based sorting (a combination of &lt;em&gt;frequency&lt;/em&gt; and &lt;em&gt;recency&lt;/em&gt;) and history persistence by adding the following.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq selectrum-prescient-enable-filtering nil)&#xA;(selectrum-prescient-mode +1)&#xA;(prescient-persist-mode +1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;User guide&lt;/h2&gt; &#xA;&lt;p&gt;The design philosophy of Selectrum is to be as simple as possible, because selecting an item from a list really doesn&#39;t have to be that complicated, and you don&#39;t have time to learn all the hottest tricks and keybindings for this. What this means is that Selectrum always prioritizes consistency, simplicity, and understandability over making optimal choices for workflow streamlining. The idea is that when things go wrong, you&#39;ll find it easy to understand what happened and how to fix it.&lt;/p&gt; &#xA;&lt;h3&gt;Keybindings&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;To navigate to a candidate:&lt;/em&gt; use the standard motion commands (&lt;code&gt;&amp;lt;up&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;down&amp;gt;&lt;/code&gt;, &lt;code&gt;C-v&lt;/code&gt;, &lt;code&gt;M-v&lt;/code&gt;, &lt;code&gt;M-&amp;lt;&lt;/code&gt;, &lt;code&gt;M-&amp;gt;&lt;/code&gt;). If you prefer, you can use &lt;code&gt;C-p&lt;/code&gt; and &lt;code&gt;C-n&lt;/code&gt; instead of the arrow keys.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;To navigate to a group of candidates&lt;/em&gt;: use &lt;code&gt;M-{&lt;/code&gt; (remapped from &lt;code&gt;backward-paragraph&lt;/code&gt;) and &lt;code&gt;M-}&lt;/code&gt; (remapped from &lt;code&gt;forward-paragraph&lt;/code&gt;) to move to the previous and next group, respectively. You can also use &lt;code&gt;C-M-p&lt;/code&gt; and &lt;code&gt;C-M-n&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;To accept the currently selected candidate:&lt;/em&gt; type &lt;code&gt;RET&lt;/code&gt;/&lt;code&gt;C-m&lt;/code&gt;. (With a prefix argument, accept instead the candidate at that point in the list, counting from one. See &lt;code&gt;selectrum-show-indices&lt;/code&gt;. The value zero means to accept exactly what you&#39;ve typed, as in the next bullet point.) You can also click the left mouse button on a candidate to choose it or use &lt;code&gt;M-m&lt;/code&gt; to select one using &lt;code&gt;selectrum-quick-keys&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;To submit what you&#39;ve typed, even if it&#39;s not a candidate:&lt;/em&gt; you can use &lt;code&gt;&amp;lt;up&amp;gt;&lt;/code&gt; or &lt;code&gt;C-p&lt;/code&gt; to select the user input just like a regular candidate, and type &lt;code&gt;RET&lt;/code&gt; as usual. (Alternatively, you can type &lt;code&gt;C-j&lt;/code&gt; to submit your exact input without selecting it first.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;To abort:&lt;/em&gt; as per usual, type &lt;code&gt;C-g&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;To navigate into the currently selected directory while finding a file:&lt;/em&gt; type &lt;code&gt;TAB&lt;/code&gt;/&lt;code&gt;C-i&lt;/code&gt;. (What this actually does is insert the currently selected candidate into the minibuffer, which for &lt;code&gt;find-file&lt;/code&gt; has the effect of navigating into a directory.) With a positive prefix argument, insert the candidate at that display position (see &lt;code&gt;selectrum-show-indices&lt;/code&gt;). You can also right click on a candidate to insert it into the minibuffer or use &lt;code&gt;M-i&lt;/code&gt; for inserting one using &lt;code&gt;selectrum-quick-keys&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;To copy the current candidate:&lt;/em&gt; type &lt;code&gt;M-w&lt;/code&gt; or what is bound to &lt;code&gt;kill-ring-save&lt;/code&gt;. When there&#39;s an active region in your input, this still copies the active region. The behavior of &lt;code&gt;M-w&lt;/code&gt; is not modified when Transient Mark mode is disabled.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;To select multiple candidates:&lt;/em&gt; separate them with &lt;code&gt;crm-separator&lt;/code&gt; (&lt;code&gt;,&lt;/code&gt; by default). To make this workflow more convenient, you can use &lt;code&gt;TAB&lt;/code&gt; to complete the currently selected candidate before typing &lt;code&gt;crm-separator&lt;/code&gt; (for common values of &lt;code&gt;crm-separator&lt;/code&gt; it will be automatically inserted for you). This feature only works in commands that use &lt;code&gt;completing-read-multiple&lt;/code&gt;, such as &lt;code&gt;describe-face&lt;/code&gt;. (If multiple selection is enabled, it is shown in the minibuffer prompt.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;To change the display style of candidates:&lt;/em&gt; use &lt;code&gt;M-q&lt;/code&gt; which will cycle from the currently used style through the styles in &lt;code&gt;selectrum-display-style-cycle-list&lt;/code&gt;. With the default configuration this command will toggle between the vertical and an &lt;code&gt;icomplete&lt;/code&gt; like horizontal display.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Selectrum respects your custom keybindings, so if you&#39;ve bound &lt;code&gt;next-line&lt;/code&gt; to &lt;code&gt;M-*&lt;/code&gt; for some reason, then pressing &lt;code&gt;M-*&lt;/code&gt; will select the next candidate. If you don&#39;t like the standard Selectrum bindings, you can change them in &lt;code&gt;selectrum-minibuffer-map&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The keybindings listed above are the &lt;em&gt;only&lt;/em&gt; ones changed from standard editing bindings. So, for example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All your standard horizontal motion, selection, insertion, and deletion commands work as usual.&lt;/li&gt; &#xA; &lt;li&gt;To delete your current input, just use &lt;code&gt;C-a C-k&lt;/code&gt; or &lt;code&gt;C-S-backspace&lt;/code&gt; (bound to &lt;code&gt;kill-whole-line&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;To edit by word units use &lt;code&gt;M-DEL&lt;/code&gt; like usual. To go up a directory you can use &lt;code&gt;C-M-DEL&lt;/code&gt; (bound to &lt;code&gt;selectrum-backward-kill-sexp&lt;/code&gt;). Be aware that on some Linux distributions, this binding is used to kill the X server, which can force-quit all programs you opened. Therefore, accidentally killing the X server can cause data corruption and loss of unsaved work. In such cases, you can instead use &lt;code&gt;ESC C-DEL&lt;/code&gt;, which Emacs helpfully binds by default.&lt;/li&gt; &#xA; &lt;li&gt;To navigate to your home directory, you can just use &lt;code&gt;C-a C-k ~/&lt;/code&gt;. Alternatively, like in default completion, you can type &lt;code&gt;~/&lt;/code&gt; after a &lt;code&gt;/&lt;/code&gt; to ignore the preceding input and move to the home directory.&lt;/li&gt; &#xA; &lt;li&gt;Minibuffer history navigation works as usual with &lt;code&gt;M-p&lt;/code&gt; and &lt;code&gt;M-n&lt;/code&gt;. &lt;code&gt;M-r&lt;/code&gt; will invoke an improved version of history search with completion.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Sorting and filtering&lt;/h3&gt; &#xA;&lt;p&gt;The default sorting and filtering in Selectrum is quite simple and predictable. The method is similar to the one employed by Icomplete. Candidates are sorted first by history position (by &lt;em&gt;recency&lt;/em&gt;), then by length and then alphabetically. Afterwards they are filtered and highlighted using the &lt;code&gt;completion-styles&lt;/code&gt;. This default behavior is intended as a lowest common denominator that will definitely work.&lt;/p&gt; &#xA;&lt;p&gt;It is strongly recommended that you customize &lt;code&gt;completion-styles&lt;/code&gt; using Orderless or install Prescient as described before. It is also possible to supply your own sorting, filtering, and highlighting logic if you would like. For that, see the developer guide later in this documentation.&lt;/p&gt; &#xA;&lt;p&gt;Independent of the sorting and filtering method, Selectrum adds two special features on top:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If your input matches one of the candidates exactly, then that candidate is unconditionally sorted first. (So, if you type in &lt;code&gt;find-file&lt;/code&gt;, then &lt;code&gt;ido-find-file&lt;/code&gt; will never be sorted before &lt;code&gt;find-file&lt;/code&gt;, no matter what.) This is intended to reduce frustration in the case that you know what you want and you don&#39;t want Selectrum getting in the way.&lt;/li&gt; &#xA; &lt;li&gt;After that, if the caller of Selectrum specified a default candidate (for example, &lt;code&gt;describe-function&lt;/code&gt; suggests the function near point as a default) then that candidate will be sorted before the rest. This means you can just press &lt;code&gt;RET&lt;/code&gt; immediately to accept the default, like usual.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Case-sensitivity and other filter options should be configured via the used refinement function. The built-in &lt;code&gt;completion-styles&lt;/code&gt; support the &lt;code&gt;completion-ignore-case&lt;/code&gt;, &lt;code&gt;read-file-name-completion-ignore-case&lt;/code&gt; and &lt;code&gt;read-buffer-completion-ignore-case&lt;/code&gt; options.&lt;/p&gt; &#xA;&lt;h3&gt;Additional features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You can repeat the last command that invoked Selectrum, restoring your user input and selected candidate, using &lt;code&gt;selectrum-repeat&lt;/code&gt;. You must bind this command to a key sequence in order to use it, since running &lt;code&gt;selectrum-repeat&lt;/code&gt; from &lt;code&gt;M-x&lt;/code&gt; will dutifully repeat the last command that invoked Selectrum, which was &lt;code&gt;M-x&lt;/code&gt;. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;C-x C-z&#34;) #&#39;selectrum-repeat)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Customization&lt;/h3&gt; &#xA;&lt;p&gt;User options can be configured via &lt;code&gt;M-x customize-group RET selectrum RET&lt;/code&gt;. Faces can be customized via &lt;code&gt;M-x customize-group RET selectrum-faces RET&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Faces:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;selectrum-completion-annotation&lt;/code&gt;: How annotations are shown next to candidates.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;selectrum-completion-docsig&lt;/code&gt;: How function signatures are shown in &lt;code&gt;completion-in-region&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;selectrum-current-candidate&lt;/code&gt;: How the current candidate is highlighted. If you don&#39;t like the color, you can adjust it to taste.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;selectrum-group-title&lt;/code&gt;: How the titles of candidate groups (such as those used by &lt;a href=&#34;https://github.com/minad/consult&#34;&gt;Consult&lt;/a&gt;) are displayed. See the user option &lt;code&gt;selectrum-group-format&lt;/code&gt; for how this face is used.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;selectrum-group-separator&lt;/code&gt;: By default, group titles are surrounded by struck-through blank space. See the user option &lt;code&gt;selectrum-group-format&lt;/code&gt; for how this face is used.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;selectrum-mouse-highlight&lt;/code&gt;: How candidates are shown when the mouse pointer hovers above them.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;selectrum-quick-keys-highlight&lt;/code&gt;: How the keys are shown when using &lt;code&gt;selectrum-quick-select&lt;/code&gt; (&lt;code&gt;M-m&lt;/code&gt;) and &lt;code&gt;selectrum-quick-insert&lt;/code&gt; (&lt;code&gt;M-i&lt;/code&gt;).&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;selectrum-quick-keys-match&lt;/code&gt;: How pressed quick keys are shown when more than one key is needed.&lt;/li&gt; &#xA;   &lt;li&gt;You might also be interested in the face &lt;code&gt;completions-common-part&lt;/code&gt; for &lt;code&gt;completion-in-region&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Window configuration and candidate display:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;By default, 10 candidates at most are shown in the minibuffer at any given time. &lt;code&gt;selectrum-max-window-height&lt;/code&gt; sets the maximum height the window can expand to.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;By default, the window is only as tall as it needs to be to display the candidates, which can be less than the maximum height. &lt;code&gt;selectrum-fix-vertical-window-height&lt;/code&gt; determines whether the window should &lt;em&gt;always&lt;/em&gt; be as tall as the maximum height, even when less space is needed.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;The variable &lt;code&gt;selectrum-num-candidates-displayed&lt;/code&gt; controls how many candidates are displayed in total. The default value &lt;code&gt;auto&lt;/code&gt; will automatically use as many candidates as are possible to display given the space and height settings.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Candidates can be displayed vertically (like Ivy and Helm) or horizontally (like Icomplete). This is determined by &lt;code&gt;selectrum-display-style&lt;/code&gt;. Display styles can be cycled using the command &lt;code&gt;selectrum-cycle-display-style&lt;/code&gt; (&lt;code&gt;M-q&lt;/code&gt;) and the user option &lt;code&gt;selectrum-display-style-cycle-list&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Candidates can also be displayed outside of the minibuffer, such as in another window or frame as determined by the user option &lt;code&gt;selectrum-display-action&lt;/code&gt;. If you want to display the whole minibuffer (including the input line) in a separate frame you can use the &lt;a href=&#34;https://github.com/muffinmad/emacs-mini-frame&#34;&gt;mini-frame&lt;/a&gt; package, see the &lt;a href=&#34;https://github.com/radian-software/selectrum/wiki/Additional-Configuration#display-minibuffer-in-a-child-frame-with-mini-frame&#34;&gt;wiki&lt;/a&gt; for setup instructions.&lt;/p&gt; &lt;p&gt;To run additional code when initializing the candidate buffer, you can use &lt;code&gt;selectrum-display-action-hook&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Selectrum collapses multi-line candidates into a single line. &lt;code&gt;selectrum-multiline-display-settings&lt;/code&gt; controls how this is done.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;selectrum-group-format&lt;/code&gt; controls how candidate-group titles are displayed. This option makes use of the faces &lt;code&gt;selectrum-group-title&lt;/code&gt; and &lt;code&gt;selectrum-group-separator&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Additional info and highlighting:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;By default, the total number of matches are shown before the prompt. &lt;code&gt;selectrum-count-style&lt;/code&gt; controls how the count is displayed, if at all. The value &lt;code&gt;current/matches&lt;/code&gt; can be helpful when &lt;code&gt;selectrum-cycle-movement&lt;/code&gt; is enabled.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can show the indices of displayed candidates by customizing &lt;code&gt;selectrum-show-indices&lt;/code&gt;. If &lt;code&gt;t&lt;/code&gt;, the index shown is the prefix argument that you should pass to &lt;code&gt;selectrum-select-current-candidate&lt;/code&gt; and &lt;code&gt;selectrum-insert-current-candidate&lt;/code&gt; in order to choose that candidate.&lt;/p&gt; &lt;p&gt;To display a custom index (e.g. letters instead of indices, roman numerals, etc.), you can set &lt;code&gt;selectrum-show-indices&lt;/code&gt; to a function that takes in the relative index of a candidate and returns the string you want to display.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;By default, only the displayed text is highlighted, with the highlighting being extended when annotations are used. If you wish to always extend the highlighting, you can set &lt;code&gt;selectrum-extend-current-candidate-highlight&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Note that in Emacs 27 and greater, the face &lt;code&gt;selectrum-current-candidate&lt;/code&gt; must have the &lt;code&gt;:extend&lt;/code&gt; attribute set to &lt;code&gt;t&lt;/code&gt; for this feature to work.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Completion settings:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;By default, Selectrum also handles in-buffer completion via &lt;code&gt;completion-in-region&lt;/code&gt;. To disable this, you can set &lt;code&gt;selectrum-complete-in-buffer&lt;/code&gt; to nil before activating &lt;code&gt;selectrum-mode&lt;/code&gt;. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;You can configure the initial filtering of &lt;code&gt;selectrum-completion-in-region&lt;/code&gt; using &lt;code&gt;selectrum-completion-in-region-styles&lt;/code&gt;.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;The option &lt;code&gt;selectrum-should-sort&lt;/code&gt; controls whether preprocessing functions should sort.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Candidate selection and prompt selection:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Selectrum provides an &lt;code&gt;ivy-avy&lt;/code&gt;-like interface to quickly select a candidate via key annotations using the commands &lt;code&gt;selectrum-quick-select&lt;/code&gt; (&lt;code&gt;M-m&lt;/code&gt;) or &lt;code&gt;selectrum-quick-insert&lt;/code&gt; (&lt;code&gt;M-i&lt;/code&gt;). &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;You can configure these keys in the user option &lt;code&gt;selectrum-quick-keys&lt;/code&gt;.&lt;/li&gt; &#xA;     &lt;li&gt;You can configure the appearance of these key annotations with &lt;code&gt;selectrum-quick-keys-highlight&lt;/code&gt; and &lt;code&gt;selectrum-quick-keys-match&lt;/code&gt; face.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Using the &lt;code&gt;selectrum-files-select-input-dirs&lt;/code&gt; option you can adjust the selection behavior for file completions. When non-nil, the input gets selected whenever it contains a full directory name.&lt;/li&gt; &#xA;   &lt;li&gt;You set &lt;code&gt;selectrum-cycle-movement&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; to wrap around to the other end of the candidate list when moving past the first or last candidate.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Complementary extensions&lt;/h3&gt; &#xA;&lt;p&gt;For a fully fledged setup enabling additional features similar to those you find in &lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;Helm&lt;/a&gt; or &lt;a href=&#34;https://github.com/abo-abo/swiper#ivy&#34;&gt;Ivy&lt;/a&gt;, we recommend the following additional packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Useful commands based on &lt;code&gt;completing-read&lt;/code&gt; are provided by &lt;a href=&#34;https://github.com/minad/consult&#34;&gt;consult&lt;/a&gt;. Consult is designed as the &lt;a href=&#34;https://github.com/abo-abo/swiper#counsel&#34;&gt;counsel&lt;/a&gt; equivalent for Selectrum and Icomplete or more generally any completion system based on &lt;code&gt;completing-read&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For filtering and &lt;em&gt;frecency&lt;/em&gt;-based sorting (a combination of &lt;em&gt;frequency&lt;/em&gt; and &lt;em&gt;recency&lt;/em&gt;) there is &lt;a href=&#34;https://github.com/radian-software/prescient.el&#34;&gt;Prescient&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;As an alternative filtering method, there is &lt;a href=&#34;https://github.com/oantolin/orderless&#34;&gt;orderless&lt;/a&gt;. It supports many different matching styles and integrates with &lt;code&gt;completion-styles&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For minibuffer actions and occur/export features there is &lt;a href=&#34;https://github.com/oantolin/embark/&#34;&gt;embark&lt;/a&gt;. Embark provides features like ivy-actions/ivy-occur in a framework agnostic way.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Helpful minibuffer annotations for &lt;code&gt;M-x&lt;/code&gt;, &lt;code&gt;describe-*&lt;/code&gt; functions and completions in general are provided by &lt;a href=&#34;https://github.com/minad/marginalia&#34;&gt;marginalia&lt;/a&gt;, which is similar to ivy-rich but works with any framework implementing the default API for completion annotations.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can display completions in a child frame using &lt;a href=&#34;https://github.com/muffinmad/emacs-mini-frame&#34;&gt;emacs-mini-frame&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The above packages work well in combination and we are collaborating with each other to ensure an optimal experience while not introducing any hard dependencies. Our common denominator is the standard Emacs API.&lt;/p&gt; &#xA;&lt;p&gt;For other possibly interesting packages, see our &lt;a href=&#34;https://github.com/radian-software/selectrum/wiki/&#34;&gt;wiki&lt;/a&gt; which also contains &lt;a href=&#34;https://github.com/radian-software/selectrum/wiki/Additional-Configuration&#34;&gt;configuration tips&lt;/a&gt; for many of these.&lt;/p&gt; &#xA;&lt;h3&gt;But what is it doing to my Emacs??&lt;/h3&gt; &#xA;&lt;p&gt;By inspecting the source code of &lt;code&gt;selectrum-mode&lt;/code&gt;, you will see that Selectrum operates by setting a number of standard Emacs variables (&lt;code&gt;completing-read-function&lt;/code&gt;, &lt;code&gt;read-file-name-function&lt;/code&gt;, etc.) and installing advice on a number of standard functions (&lt;code&gt;read-library-name&lt;/code&gt;, &lt;code&gt;minibuffer-message&lt;/code&gt;, etc.).&lt;/p&gt; &#xA;&lt;p&gt;If you object to these changes being made magically, you can make them yourself and refrain from enabling &lt;code&gt;selectrum-mode&lt;/code&gt;. However, backwards compatibility is not guaranteed for this usage, so you will need to review the source code of &lt;code&gt;selectrum-mode&lt;/code&gt; after each update of Selectrum.&lt;/p&gt; &#xA;&lt;p&gt;The autoloads of Selectrum are set up so that you can enable &lt;code&gt;selectrum-mode&lt;/code&gt; without actually loading Selectrum. It will only be loaded once you use some of its functionality in an interactive command.&lt;/p&gt; &#xA;&lt;p&gt;If you want to enable &lt;code&gt;selectrum-mode&lt;/code&gt; for everything except a few commands, you can advise those commands to temporarily deactivate &lt;code&gt;selectrum-mode&lt;/code&gt;. For example, below is how one could disable Selectrum for &lt;code&gt;org-set-tags-command&lt;/code&gt;. Note that such advice also affects recursive minibuffers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun exclude-from-selectrum (orig-fun &amp;amp;rest args)&#xA;    (selectrum-mode -1)&#xA;    (apply orig-fun args)&#xA;    (selectrum-mode +1))&#xA;&#xA;(advice-add &#39;org-set-tags-command :around #&#39;exclude-from-selectrum)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;News&lt;/h3&gt; &#xA;&lt;p&gt;We document changes for users in the &lt;a href=&#34;https://github.com/radian-software/selectrum/raw/master/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt;. To keep up with latest changes and features you can subscribe to the &lt;a href=&#34;https://github.com/radian-software/selectrum/commits/master/CHANGELOG.md.atom&#34;&gt;feed&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Developer guide&lt;/h2&gt; &#xA;&lt;p&gt;This section is intended for the authors of packages which integrate with Selectrum, or for end users who wish to customize the sorting and filtering behavior of Selectrum.&lt;/p&gt; &#xA;&lt;h3&gt;Usage of Selectrum&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;In normal usage, there should be no need to use any Selectrum-specific functions. Simply use &lt;code&gt;completing-read&lt;/code&gt; and friends, and Selectrum will automatically enhance the experience if &lt;code&gt;selectrum-mode&lt;/code&gt; is enabled.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Selectrum does expose some completion functions as part of its public API.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-completing-read&lt;/code&gt; (for &lt;code&gt;completing-read-function&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-completing-read-multiple&lt;/code&gt; (to override &lt;code&gt;completing-read-multiple&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-completion-in-region&lt;/code&gt; (for &lt;code&gt;completion-in-region-function&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-read-buffer&lt;/code&gt; (for &lt;code&gt;read-buffer-function&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-read-file-name&lt;/code&gt; (for &lt;code&gt;read-file-name-function&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-read-directory-name&lt;/code&gt; (to override &lt;code&gt;read-directory-name&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-read-library-name&lt;/code&gt; (to override &lt;code&gt;read-library-name&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These functions are used as replacements for the standard completion functions when &lt;code&gt;selectrum-mode&lt;/code&gt; is enabled. If you want to define your own commands using completion, it is recommended to use the standard &lt;code&gt;completing-read&lt;/code&gt; API.&lt;/p&gt; &#xA;&lt;h3&gt;Sorting, filtering, and highlighting&lt;/h3&gt; &#xA;&lt;p&gt;Selectrum exposes a very simple API for sorting, filtering, and highlighting. Each of these three tasks is controlled by a separate user option:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-preprocess-candidates-function&lt;/code&gt; takes the original list of candidates and sorts it (actually, it can do any sort of preprocessing it wants). Usually preprocessing only happens once. Under special circumstances where the candidate set is dynamic, preprocessing happens instead after each input change.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-refine-candidates-function&lt;/code&gt; takes the preprocessed list and filters it using the user&#39;s input. This refinement happens every time the user input is updated.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-highlight-candidates-function&lt;/code&gt; takes a list of the refined candidates that are going to be displayed in the minibuffer, and propertizes them with highlighting.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For exact specifications of these functions, including whether or not the input list may be modified, please see their docstrings. This information is important, because if you make copies of the candidate list unnecessarily, there will be noticeable lag due to the slowness of Emacs&#39; garbage collector.&lt;/p&gt; &#xA;&lt;h3&gt;Text properties&lt;/h3&gt; &#xA;&lt;p&gt;Selectrum allows changing the display of candidates within the constraints of the official API by make use of text properties of completion candidates. However it is preferable to use an annotation function (or affixation which is introduced in Emacs 28), see `(info &#34;(elisp) Programmed Completion&#34;) to make the annotations work with any compliant completion framework. We also have some information about using annotations on the &lt;a href=&#34;https://github.com/radian-software/selectrum/wiki/Tips-for-Creating-Commands#annotating-candidates&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The following text properties can be used, which may be applied to candidates using &lt;code&gt;propertize&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-candidate-display-prefix&lt;/code&gt;: controls how the candidate is displayed in the list shown in the minibuffer. If this property is present, then its value is prepended to the candidate when it is displayed. This is used, for example, to display disambiguating parent directories in &lt;code&gt;read-library-name&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-candidate-display-suffix&lt;/code&gt;: same as the display prefix, but it&#39;s postpended instead of prepended when the candidate is dispalyed. This is used, for example, to display candidate annotations under &lt;code&gt;completion-in-region&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Besides, we have:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-candidate-display-right-margin&lt;/code&gt;: if this property is presented, its value is displayed at the right margin after the candidate. Currently Selectrum doesn&#39;t make use of this property. It can be used to display supplementary information.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that sorting, filtering, and highlighting is done on the standard values of candidates, before any of these text properties are handled.&lt;/p&gt; &#xA;&lt;h3&gt;Hooks&lt;/h3&gt; &#xA;&lt;p&gt;Selectrum provides two hooks for getting information about what candidates were selected. These are intended primarily for packages like &lt;code&gt;prescient.el&lt;/code&gt; which want to record history statistics. The hooks are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-candidate-selected-hook&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-candidate-inserted-hook&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more information, see their docstrings.&lt;/p&gt; &#xA;&lt;h3&gt;Variables&lt;/h3&gt; &#xA;&lt;p&gt;You can use the variable &lt;code&gt;selectrum-is-active&lt;/code&gt; to check if the current minibuffer session is a Selectrum one.&lt;/p&gt; &#xA;&lt;p&gt;To adjust session settings you can set the user option variables locally in &lt;code&gt;minibuffer-with-setup-hook&lt;/code&gt;. Additionally the following variables can be used to adjust session behavior:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;selectrum-move-default-candidate&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more information, see the respective docstrings.&lt;/p&gt; &#xA;&lt;h2&gt;Contributor guide&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/radian-software/contributor-guide&#34;&gt;the contributor guide for my projects&lt;/a&gt;. We have some &lt;a href=&#34;https://github.com/radian-software/selectrum/tree/master/test&#34;&gt;test scripts&lt;/a&gt; for testing minimal default configurations of common package combinations. You can run them using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd test; ./run.sh &amp;lt;package-combo&amp;gt;.el&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Technical points:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;When adding a new state variable, make sure it is declared as a local variable (using &lt;code&gt;defvar-local&lt;/code&gt;) so recursive sessions aren&#39;t affected. By convention we also use &lt;code&gt;setq-local&lt;/code&gt; each time such a state variable is set.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;By default, &lt;code&gt;debug-on-error&lt;/code&gt; doesn&#39;t work for errors that happen on &lt;code&gt;post-command-hook&lt;/code&gt;. You can work around the issue like so:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun force-debug (func &amp;amp;rest args)&#xA;  (condition-case e&#xA;      (apply func args)&#xA;    ((debug error) (signal (car e) (cdr e)))))&#xA;&#xA;(advice-add #&#39;selectrum--minibuffer-post-command-hook :around #&#39;force-debug)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There is no built-in support for alternate actions on minibuffer candidates, but you can add those using &lt;a href=&#34;https://github.com/oantolin/embark/&#34;&gt;embark&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;In Emacs 26 and earlier, the way that messages are displayed while the minibuffer is active is unworkably bad: they block out the entire minibuffer as long as they are displayed, and then mess up redisplay. This issue has been fixed in Emacs 27, and I suggest upgrading. I think the best solution for people running Emacs 26 would be the development of a small third-party package which backports the improvement from Emacs 27. That way all minibuffer-based packages can benefit from the improvement.&lt;/li&gt; &#xA; &lt;li&gt;With certain theme settings face attributes can conflict with selection indication and faces used for match highlighting. This can become apparent when candidates use the &lt;code&gt;:background&lt;/code&gt; property for example when matching org block lines using &lt;code&gt;consult-line&lt;/code&gt;, see &lt;a href=&#34;https://github.com/radian-software/selectrum/issues/425&#34;&gt;#425&lt;/a&gt;. To work around this specific case you can configure the consult option &lt;code&gt;consult-fontify-preserve&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;There are a few standard features which aren&#39;t implemented in Selectrum, yet. We collect those in (&lt;a href=&#34;https://github.com/radian-software/selectrum/issues/481&#34;&gt;#481&lt;/a&gt;), most notable ones are: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;We don&#39;t make use of &lt;code&gt;completion-boundaries&lt;/code&gt; (&lt;a href=&#34;https://github.com/radian-software/selectrum/issues/448&#34;&gt;#448&lt;/a&gt;).&lt;/li&gt; &#xA;   &lt;li&gt;Dynamic table support is incomplete (&lt;a href=&#34;https://github.com/radian-software/selectrum/issues/114&#34;&gt;#114&lt;/a&gt;).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Selectrum in comparison to other completion-systems&lt;/h2&gt; &#xA;&lt;p&gt;This section documents why I decided to write Selectrum instead of using any of the numerous existing solutions in Emacs.&lt;/p&gt; &#xA;&lt;p&gt;I have not used many of these packages extensively. So, if you think I&#39;ve overlooked an important part or I&#39;ve written something mean or unfair, &lt;strong&gt;please&lt;/strong&gt; feel free to contribute a correction.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/radian-software/selectrum/issues/23&#34;&gt;#23&lt;/a&gt; for discussion.&lt;/p&gt; &#xA;&lt;h3&gt;Ido&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/ido/index.html&#34;&gt;Ido&lt;/a&gt; is a package for interactive selection that is included in Emacs by default. It&#39;s a great improvement on the default &lt;code&gt;completing-read&lt;/code&gt; experience. However, I don&#39;t like how it displays candidates in a horizontal instead of a vertical manner. It feels less intuitive to me. Another key issue with Ido is that it hardly supports any commands out of the box (only buffers and files). There is an extension package &lt;a href=&#34;https://github.com/DarwinAwardWinner/ido-completing-read-plus&#34;&gt;ido-completing-read+&lt;/a&gt; which adds support for the &lt;code&gt;completing-read&lt;/code&gt; interface, but I have been told that even this package does not handle all the cases correctly.&lt;/p&gt; &#xA;&lt;p&gt;There is a package &lt;a href=&#34;https://github.com/creichert/ido-vertical-mode.el&#34;&gt;&lt;code&gt;ido-vertical-mode&lt;/code&gt;&lt;/a&gt; which makes Ido display candidates vertically instead of horizontally, but I suspect that the problems with &lt;code&gt;completing-read&lt;/code&gt; non-compliance remain.&lt;/p&gt; &#xA;&lt;h3&gt;Helm&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/emacs-helm/helm&#34;&gt;Helm&lt;/a&gt; is an installable package which provides an alternate vertical interface for candidate selection. It has the advantage of having very many features and a large number of packages which integrate with it. However, the problem with Helm for me is exactly that it has too many features. Upon opening a Helm menu, I am immediately confronted by numerous colors, diagnostics, options, and pieces of help text. It is too complicated for the problem I want solved. Of course, I am sure it is possible to customize Helm so that it is simpler in appearance. But that would take a long time and I would rather use a piece of software which was designed for the use case I have in mind. I also personally prefer using software that I have some hope of understanding, which ideally means that they don&#39;t provide a hugely complex array of features of which I only use one or two.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/radian-software/selectrum/issues/203&#34;&gt;#203&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Ivy&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/abo-abo/swiper#ivy&#34;&gt;Ivy&lt;/a&gt; is a promising alternative to Selectrum. It is described as a minimal alternative to Helm which provides a simpler interface. The problem with Ivy is that its architecture and API have grown organically, and as a result the implementation is complex. Ivy was originally designed to be used as a backend to &lt;a href=&#34;https://github.com/abo-abo/swiper#swiper&#34;&gt;Swiper&lt;/a&gt;, a buffer search package that originally used Helm. When Ivy became a more general-purpose interactive selection package, more and more special cases were added to try to make various commands work properly. As a result, the &lt;code&gt;ivy-read&lt;/code&gt; API is complex with around 20 arguments and multiple special cases for particular values. Numerous functions in Ivy, &lt;a href=&#34;https://github.com/abo-abo/swiper#counsel&#34;&gt;Counsel&lt;/a&gt;, and Swiper have special cases hardcoded into them to detect when they&#39;re being called from specific other functions in the other two packages.&lt;/p&gt; &#xA;&lt;p&gt;The main differences between Selectrum and Ivy are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Selectrum code base is simpler and more concise, since Selectrum provides a more restricted feature set.&lt;/li&gt; &#xA; &lt;li&gt;Selectrum focuses on the standard completion API offered by Emacs and tries to provide the best possible UI for this API. In contrast, Ivy deviates from this API and invents its own API with extra features, sacrificing reuse and composability down the road.&lt;/li&gt; &#xA; &lt;li&gt;The packages centered around the &lt;code&gt;completing-read&lt;/code&gt; API are more composable, interchangable and modular. Since Selectrum does not offer a public completion API, the decoupling of the components is enforced.&lt;/li&gt; &#xA; &lt;li&gt;By focusing on a single API, the components can be tested against different implementations, e.g., Selectrum, Icomplete or default completion, which improves consistency and helps with correctness.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Selectrum does not support features which break the &lt;code&gt;completing-read&lt;/code&gt; API and works with &lt;em&gt;every&lt;/em&gt; Emacs command with essentially no special cases, specifically because it focuses on doing the common case as well as possible.&lt;/p&gt; &#xA;&lt;h3&gt;Icomplete&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/emacs/Icomplete.html&#34;&gt;Icomplete&lt;/a&gt; is the built-in Emacs package for interactive selection. It is basically the same as the standard &lt;code&gt;completing-read&lt;/code&gt; framework, except that the available candidates are displayed in the minibuffer as you type. Unlike Selectrum, the candidates are displayed horizontally (by default). This can be changed by some manual configuration, including customizing &lt;code&gt;icomplete-separator&lt;/code&gt;, although it is clear that this use case is not an intended one for Icomplete. A serious usability problem of Icomplete is that the way you select a candidate from lower down in the list is very unintuitive: you must &#34;rotate&#34; the entire set of candidates, whereupon the previous candidates become invisible since they have wrapped to the bottom of the list.&lt;/p&gt; &#xA;&lt;p&gt;With sufficient configuration, it is likely possible to replicate a subset of the features of Selectrum using Icomplete. However, the documentation of Icomplete is basically nonexistent, and to achieve this configuration one must bend Icomplete rather severely away from the interaction model it is designed for. In other words, the configuration is not an enjoyable process, and the results will never be equivalent in user experience to a package that was designed for the desired interaction model in the first place. Selectrum, on the other hand, offers a well-tuned and snappy vertical completion interface that is robust and works out of the box.&lt;/p&gt; &#xA;&lt;p&gt;There is a package which takes care of some of the manual labor of configuring Icomplete, called &lt;a href=&#34;https://github.com/oantolin/icomplete-vertical&#34;&gt;&lt;code&gt;icomplete-vertical&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is worth noting the new &lt;a href=&#34;https://github.com/emacs-mirror/emacs/commit/213643a890913f10bac710ca8537e8b1125941d6&#34;&gt;Fido mode&lt;/a&gt; which will be included in Emacs 27. It is basically a variation of Icomplete that behaves more like Ido. As such, Fido mode does not offer solutions to the problems outlined in the above sections.&lt;/p&gt; &#xA;&lt;p&gt;On the upside, Icomplete is the most API compliant enhanced completion UI available. Selectrum also covers the most important aspects of the API and strives to achieve full compliance, as well. For the few edge cases left, see the Caveats section.&lt;/p&gt; &#xA;&lt;h3&gt;Vertico&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/minad/vertico&#34;&gt;Vertico&lt;/a&gt; is a new minimalistic completion system based on the Emacs default completion offering a similar UI as Selectrum. It uses a different implementation approach - it extends the default completion system in a similar way as Icomplete and is therefore fully compliant with all features of the &lt;code&gt;completing-read&lt;/code&gt; API. Overall Vertico follows a similar philosophy as Selectrum, relying on default components and &lt;a href=&#34;https://raw.githubusercontent.com/radian-software/selectrum/master/#complementary-extensions&#34;&gt;complementary packages&lt;/a&gt;. Many of the complementary packages, notably Consult, work well with both Selectrum and Vertico. Selectrum offers a flexible UI, e.g., it supports both a horizontal and a vertical display. Furthermore it provides Avy-style quick keys and display actions, to show the completions in a buffer. On the other hand, Vertico additionally supports cycling over candidates and provides more commands for grouping support.&lt;/p&gt; &#xA;&lt;h3&gt;Icicles&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.emacswiki.org/emacs/Icicles&#34;&gt;Icicles&lt;/a&gt; is a package somewhat like Helm, written by &lt;a href=&#34;https://www.emacswiki.org/emacs/DrewAdams&#34;&gt;Drew Adams&lt;/a&gt;. Like other packages by Drew, Icicles is only available for manual download from EmacsWiki. &lt;a href=&#34;https://github.com/melpa/melpa/pull/5008&#34;&gt;It has been removed from MELPA&lt;/a&gt; due to community consensus that this distribution mechanism has unacceptable security risks, but Drew has declined to migrate to any other distribution mechanism.&lt;/p&gt; &#xA;&lt;p&gt;Because of this situation, I have never attempted to use Icicles, and cannot comment on the package on the basis of its features. If you would like to submit a pull request explaining the advantages and/or disadvantages of Icicles versus Selectrum, we would appreciate it.&lt;/p&gt; &#xA;&lt;h3&gt;Snails&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/manateelazycat/snails&#34;&gt;Snails&lt;/a&gt; describes itself as a &#34;modern, easy-to-expand fuzzy-search framework&#34;. From the README, it seems to provide a similar vertical completion interface to Selectrum.&lt;/p&gt; &#xA;&lt;p&gt;One problem with Snails is that, like Ivy, it goes the route of wrapping every possible command with a &#34;backend&#34; rather than using existing Emacs interfaces to handle all possible commands.&lt;/p&gt; &#xA;&lt;h3&gt;Sallet&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Fuco1/sallet&#34;&gt;Sallet&lt;/a&gt; describes itself as &#34;a type of light spherical helmet&#34;, according to the repo description. However, it also appears to be another vertical completion interface. Although I haven&#39;t used Sallet extensively, here are some differences that I can note:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sallet seems to go the route of providing wrappers for all the possible commands, rather than implementing all of them via the existing &lt;code&gt;completing-read&lt;/code&gt; interface. I am skeptical of this for the reasons outlined in the Ivy section.&lt;/li&gt; &#xA; &lt;li&gt;Sallet provides a &#34;rich-text&#34; approach to vertical completion, where you are shown an entire buffer with colors and multiple columns. Personally, I would prefer something more minimal that fits neatly into the minibuffer.&lt;/li&gt; &#xA; &lt;li&gt;There is no user-facing documentation, which suggests to me that the package is unfinished.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Raven&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/chameco/raven&#34;&gt;Raven&lt;/a&gt; is a little-known package for vertical completion. It looks quite similar to Selectrum, and seems pretty usable to me. The main difference is that Selectrum simply has a more fully-rounded set of features (such as candidate highlighting and a full &lt;code&gt;find-file&lt;/code&gt; replacement). I suspect that these features have simply not yet been implemented.&lt;/p&gt; &#xA;&lt;h3&gt;Swiper&lt;/h3&gt; &#xA;&lt;p&gt;As discussed in the section on Ivy, &lt;a href=&#34;https://github.com/abo-abo/swiper#swiper&#34;&gt;Swiper&lt;/a&gt; is a buffer-search package that uses Ivy&#39;s interface and is coupled closely to the Ivy implementation.&lt;/p&gt; &#xA;&lt;p&gt;Does Selectrum attempt to provide a replacement for Swiper in addition to Ivy and Counsel?&lt;/p&gt; &#xA;&lt;p&gt;The answer is no - such functionality will not be part of Selectrum itself, but there are two alternatives available.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/radian-software/ctrlf&#34;&gt;CTRLF&lt;/a&gt; is a from scratch redesigned buffer-search interface. During the design process, I realized that a Selectrum-like interface is not the best way to present buffer search. Instead, I decided on an improved variant of the Isearch interface that takes inspiration from the standard text search interface found in almost every other modern piece of software, such as web browsers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/minad/consult&#34;&gt;Consult&lt;/a&gt;: The Consult package provides the command &lt;code&gt;consult-line&lt;/code&gt; which behaves similarly to Swiper.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>tali713/esxml</title>
    <updated>2022-07-14T01:39:54Z</updated>
    <id>tag:github.com,2022-07-14:/tali713/esxml</id>
    <link href="https://github.com/tali713/esxml" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An elisp library for working with xml, esxml and sxml.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Read Me&lt;/p&gt; &#xA;&lt;p&gt;This library was created to fascilitate quickly building web pages, though it also includes tools for working with parsed xml&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Code Generation with esxml.el This library provides to formats for xml code generation. The primary form is esxml. esxml is the form that is returned by such functions as libxml-parse-xml-region and is used internally by emacs in many xml related libraries.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** A brief example The following is a very simple esxml document, paths are handled directly, via a case statement. While this is not good practice, this is meant to be a very simple example.&lt;/p&gt; &#xA;&lt;p&gt;*** sxml example #+BEGIN_SRC elisp (let ((count 0)) (defun sxml-demo (httpcon) (incf count) (case (intern (elnode-http-pathinfo httpcon)) (/messages (with-current-buffer &#34;&lt;em&gt;Messages&lt;/em&gt;&#34; (sxml-to-xml `(html (body (pre ,(buffer-string)))))))&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    (t (sxml-to-xml&#xA;        `(html&#xA;          (body&#xA;           (h1 &#34;Hello from Emacs!&#34;) (br)&#xA;           &#34;Trying to visit &#34; ,(format &#34;%s&#34; (elnode-http-pathinfo httpcon)) (br)&#xA;           &#34;Visit &#34; (a (@ (href &#34;/messages&#34;)) &#34;messages&#34;) &#34; to see the *Messages* buffer.&#34; (br)&#xA;           &#34;Have been visited &#34; ,(format &#34;%s&#34; count) &#34; times since last started.&#34;)))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+END_SRC&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This outputs the following HTML:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+BEGIN_SRC&lt;/p&gt;   &#xA;&lt;h1&gt;Hello from Emacs!&lt;/h1&gt;&#xA;&lt;br&gt; Trying to visit /anywhere&#xA;&lt;br&gt; Visit &#xA;&lt;a href=&#34;https://raw.githubusercontent.com/tali713/esxml/master/messages&#34;&gt;messages&lt;/a&gt; to see the *Messages* buffer.&#xA;&lt;br&gt; Have been visited 1 times since last started.   #+END_SRC &#xA;&lt;p&gt;*** esxml example #+BEGIN_SRC elisp (let ((count 0)) (defun esxml-demo (httpcon) (incf count) (case (intern (elnode-http-pathinfo httpcon)) (/messages (with-current-buffer &#34;&lt;em&gt;Messages&lt;/em&gt;&#34; (esxml-to-xml `(html () (body () (pre () ,(buffer-string)))))))&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    (t (esxml-to-xml&#xA;        `(html ()&#xA;               (body ()&#xA;                     (h1 () &#34;Hello from Emacs!&#34;)&#xA;                     (br) &#34;Trying to visit &#34; ,(format &#34;%s&#34; (elnode-http-pathinfo httpcon))&#xA;                     (br)  &#34;Visit &#34; (a ((href . &#34;/messages&#34;)) &#34;messages&#34;)  &#34; to see the *Messages* buffer.&#34;&#xA;                     (br) &#34;Have been visited &#34; ,(format &#34;%s&#34; count) &#34; times since last started.&#34;)))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;** Advanced examples *** A standard page generator&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Extracting data from HTML and XML documents with esxml-query.el #+BEGIN_SRC emacs-lisp (require &#39;dom) (require &#39;esxml-query)&lt;/p&gt; &lt;p&gt;(url-retrieve &#34;&lt;a href=&#34;https://schneierfacts.com/&#34;&gt;https://schneierfacts.com/&lt;/a&gt;&#34; (lambda (status &amp;amp;rest args) (let* ((html (libxml-parse-html-region url-http-end-of-headers (point-max))) (fact (esxml-query &#34;p.fact&#34; html))) (message &#34;Did you know: %s&#34; (car (dom-children fact)))))) #+END_SRC&lt;/p&gt; &lt;p&gt;#+BEGIN_SRC emacs-lisp (require &#39;dom) (require &#39;esxml-query)&lt;/p&gt; &lt;p&gt;(url-retrieve &#34;&lt;a href=&#34;https://www.xkcd.com/rss.xml&#34;&gt;https://www.xkcd.com/rss.xml&lt;/a&gt;&#34; (lambda (status &amp;amp;rest args) (goto-char url-http-end-of-headers) (forward-line 1) (let* ((xml (libxml-parse-xml-region (point) (point-max))) (latest (esxml-query &#34;rss&amp;gt;channel&amp;gt;item&#34; xml)) (title (car (dom-children (esxml-query &#34;title&#34; latest)))) (link (car (dom-children (esxml-query &#34;link&#34; latest))))) (message &#34;%S: %s&#34; title link)))) #+END_SRC&lt;/p&gt; &lt;p&gt;See the following packages for more examples:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://gitlab.com/fvdbeek/emacs-pubmed&#34;&gt;https://gitlab.com/fvdbeek/emacs-pubmed&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/balddotcat/posthtml&#34;&gt;https://github.com/balddotcat/posthtml&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://gist.github.com/dustinlacewell/86f2fedc8ebcea22f96a3c5a81a0e0ba&#34;&gt;https://gist.github.com/dustinlacewell/86f2fedc8ebcea22f96a3c5a81a0e0ba&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/alphapapa/org-web-tools&#34;&gt;https://github.com/alphapapa/org-web-tools&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/alphapapa/org-books&#34;&gt;https://github.com/alphapapa/org-books&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/mihaiolteanu/versuri&#34;&gt;https://github.com/mihaiolteanu/versuri&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://depp.brause.cc/nov.el/&#34;&gt;https://depp.brause.cc/nov.el/&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>