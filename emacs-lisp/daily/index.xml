<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-17T01:33:39Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>idlip/d-nix</title>
    <updated>2023-03-17T01:33:39Z</updated>
    <id>tag:github.com,2023-03-17:/idlip/d-nix</id>
    <link href="https://github.com/idlip/d-nix" rel="alternate"></link>
    <summary type="html">&lt;p&gt;‚ùÑÔ∏è Nixyfied Setup with the Power of Org-Mode üëë Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Nix-Org, A Simply Aesthetic, Productive setup with Declaration World! Just do enable=true;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;*** Utilities that are Best! üåü&lt;/h2&gt; &#xA;&lt;p&gt;|-------------------------+-------------------------------------| | Class | Name | |-------------------------+-------------------------------------| | Window Manager | [[https://hyprland.org/][Hyprland]] üå∏ | | Text Editor | [[https://www.gnu.org/software/emacs/][Emacs]] üíÆ | | Gtk Theme | [[https://github.com/Fausto-Korpsvart/Gruvbox-GTK-Theme][Gruvbox]] / [[https://github.com/vinceliuice/Orchis-theme][Orchis]] üé® | | Font | [[https://tosche.net/fonts/comic-code][Comic Code]] / [[https://github.com/dtinth/comic-mono-font][Comic Mono]] / [[https://github.com/tonsky/FiraCode][Fira Code]] | | Pdf Reader | [[https://github.com/ahrm/sioyek][Sioyek]] üìî (ditch zathura) | | Media Player | [[https://mpv.io][MPV!]] üé¨ (its MVP too) | | Image Viewer | [[https://sr.ht/~exec64/imv/][Imv]] üñºÔ∏è | | RSS Reader | [[https://github.com/skeeto/elfeed][Elfeed]] üì∞ (Again, Emacs) | | Music Player | [[https://github.com/ncmpcpp/ncmpcpp][Ncmpcpp]] or [[https://github.com//mingus][Mingus in Emacs]] üé∂ | | Terminal | [[https://codeberg.org/dnkl/foot][Foot]] via footclient ‚öΩ | | Menu/Launcher | [[https://github.com/Cloudef/bemenu][Bemenu]] üöÄ | | Notification | [[https://github.com/dunst/dunst][Dunst]] üõéÔ∏è | | Shell | [[https://zsh.org][Zshell]] with [[https://starship.rs][Starship]] üî∞ | | Status Bar | [[https://github.com/Alexays/Waybar][Waybar]] üç• | | Favourite Color-Schemes | Modus-Vivendi + Gruvbox | |-------------------------+-------------------------------------|&lt;/p&gt; &#xA;&lt;p&gt;#+begin_quote Rest all other stuffs I do in Emacs, tbh I could do everything in Emacs lol. #+end_quote&lt;/p&gt; &#xA;&lt;p&gt;Feel free to open an issue and ask me doubts or about some improvements, you wanna inform! I will be glad. If you really wanna talk/discuss with me, open an issue so I will join on some media (Irc/matrix or telegram)&lt;/p&gt; &#xA;&lt;p&gt;***** Illustration - Unix Way üéÜ&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Desktop Rice&lt;/em&gt;&lt;/p&gt; &lt;p&gt;[[file:assets/desktop-unix.png]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;RSS and Emacs&lt;/em&gt;&lt;/p&gt; &lt;p&gt;[[file:assets/emacs-rss.png]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Org Edit and Pdf Reader&lt;/em&gt;&lt;/p&gt; &lt;p&gt;[[file:assets/org-pdf.png]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Emacs web browser (eww) and Firefox&lt;/p&gt; &lt;p&gt;[[file:assets/firefox-ewweb.png]]&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Organized Nix Flakes? üå≤&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I manage my whole system with single org file. Its easy and pretty handy. You can read that file here &lt;em&gt;‚Ü¨&lt;/em&gt; [[file:d-setup.org][d-setup.org]] , its both self documenting and has all source code blocks.&lt;/p&gt; &#xA;&lt;p&gt;Another key feature in my setup is, every file i tangle is at &lt;em&gt;read-only mode&lt;/em&gt;. So generally we can avoid editing/touching them. Thus, every action has to be made in &lt;em&gt;d-setup.org&lt;/em&gt; only.&lt;/p&gt; &#xA;&lt;h2&gt;Also, I have made files to be &lt;em&gt;symlink&lt;/em&gt;, so i can edit them without requiring to rebuild whole thing!&lt;/h2&gt; &#xA;&lt;p&gt;#+begin_center | &lt;em&gt;Note&lt;/em&gt;: There are &lt;em&gt;#FIXME tags in [[file:d-setup.org][d-setup.org]]&lt;/em&gt; where you should edit it accordingly to your &lt;em&gt;USERNAME&lt;/em&gt; and &lt;em&gt;HOSTNAME&lt;/em&gt;. I have tried to comment few things to make it as a info, you can &lt;em&gt;ask/create issue&lt;/em&gt; regarding this, don&#39;t hold back. &lt;em&gt;I&#39;m waiting for you to ask!&lt;/em&gt; | #+end_center&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;** Welcome to &#39;Will of D&#39; flakes system ‚öîÔ∏è&lt;/p&gt; &#xA;&lt;p&gt;#+begin_quote /you can check out small write-up on my [[file:blogs/linux-journey.org][linux journey]]/ #+end_quote&lt;/p&gt; &#xA;&lt;p&gt;*** Now if you get doubt of, &#34;Should I try NixOS?&#34; ‚ùÑÔ∏è&lt;/p&gt; &#xA;&lt;p&gt;Here is an answer from a non-programmer, who just browses and watches media. Just don&#39;t, if you are looking for small benefit. Don&#39;t! You will regret having hard time to figure out petty things, again forget about error, you cannot even search in web.&lt;/p&gt; &#xA;&lt;p&gt;But, if you have decided, go with it. According to me (non-programmer), these points are good to consider NixOS&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You use Emacs (lol), &lt;em&gt;Emacs&lt;/em&gt; ‚ù§Ô∏è &lt;em&gt;Nix&lt;/em&gt; is Match made in Heaven.&lt;/li&gt; &#xA; &lt;li&gt;You want to declare stuffs and get same output, and forget what all you setup, cause its all declared in config.&lt;/li&gt; &#xA; &lt;li&gt;You want an isolated environments (shell) to do some stuffs without involving whole system.&lt;/li&gt; &#xA; &lt;li&gt;You want to stop troubleshooting and breaking update and are lazy to backup, and want to rollback with ease like with just a reboot.&lt;/li&gt; &#xA; &lt;li&gt;You want to say I use &lt;em&gt;Nixos Btw&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Pack your bags, lets go through our configuration! ‚ú® Before that I believe you are a tinkerer, I have a motto which goes like this&lt;/p&gt; &#xA;&lt;p&gt;#+begin_quote /If you want to understand the whole, Understand its parts/. &lt;em&gt;[[https://www.verywellmind.com/what-is-gestalt-psychology-2795808][Gestalt Psychology]]&lt;/em&gt; #+end_quote&lt;/p&gt; &#xA;&lt;p&gt;I mean, that is how *Nix Philosophy or Linux users are, We understand each utility (grep, sed...) and make precise use of it, You can technically call it Magic of scripting.&lt;/p&gt; &#xA;&lt;p&gt;**** Credits üéñÔ∏è&lt;/p&gt; &#xA;&lt;p&gt;These configs were the inspiration and helped to build this way.&lt;/p&gt; &#xA;&lt;p&gt;I thank them sincerely.&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/Iron-Shark/Technonomicon][Iron Shark]] &lt;em&gt;‚üπ&lt;/em&gt; Made migrating to Single org-file config very easy.&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/sioodmy/dotfiles][Sioodmy]] &lt;em&gt;‚üπ&lt;/em&gt; First config which I understand thoroughly and modified based on this.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;#+begin_center Soon will be more documented....... #+end_center&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Fuco1/emacs-lgr</title>
    <updated>2023-03-17T01:33:39Z</updated>
    <id>tag:github.com,2023-03-17:/Fuco1/emacs-lgr</id>
    <link href="https://github.com/Fuco1/emacs-lgr" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fully featured logging framework for Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lgr&lt;/h1&gt; &#xA;&lt;p&gt;lgr is a logging package for Emacs built on the back of &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/eieio/&#34;&gt;EIEIO&lt;/a&gt; classes. It is designed to be flexible, performant, and extensible.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Hierarchical loggers&lt;/em&gt; like in log4j and python logging. This is useful if you want to be able to configure logging on a per-package basis.&lt;/li&gt; &#xA; &lt;li&gt;An &lt;em&gt;arbitrary number of appenders&lt;/em&gt; for each logger. A single logger can write to the console, a logfile, a database, etc‚Ä¶ .&lt;/li&gt; &#xA; &lt;li&gt;Support for structured logging. As opposed to many other logging packages for Emacs a log event is not just a message with a timestamp, but an object that can contain arbitrary data fields. This is useful for producing machine readable logs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Lazy evaluated&lt;/em&gt; arguments for log messages. If the log event level is above the threshold, arguments won&#39;t be evaluated to save time.&lt;/li&gt; &#xA; &lt;li&gt;Appenders that write logs to a wide range of destinations: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;minibuffer via &lt;code&gt;message&lt;/code&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;standard output with &lt;code&gt;princ&lt;/code&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;plaintext files (with a powerful formatting syntax),&lt;/li&gt; &#xA;   &lt;li&gt;JSON files with arbitrary data fields,&lt;/li&gt; &#xA;   &lt;li&gt;... or your own custom appender.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;How do I log!&lt;/h2&gt; &#xA;&lt;p&gt;To log an &lt;em&gt;event&lt;/em&gt; with lgr, we call &lt;code&gt;(lgr-LEVEL lgr &amp;lt;message&amp;gt;)&lt;/code&gt;. Rest of the arguments to the logging function are interpreted by &lt;code&gt;format&lt;/code&gt; until all the format control sequences are replaced, then the rest is stored as arbitrary event metadata.&lt;/p&gt; &#xA;&lt;p&gt;To get a &lt;code&gt;lgr&lt;/code&gt; logger object, call &lt;code&gt;(lgr-get-logger &#34;logger-name&#34;)&lt;/code&gt;. Logger name is an arbitrary string, but should somehow correspond to your package&#39;s name.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(lgr-fatal lgr &#34;A critical error&#34;)&#xA;;=&amp;gt; [2023-03-11T01:24:49+0000] (fatal) A critical error&#xA;(lgr-error lgr &#34;A less severe error&#34;)&#xA;;=&amp;gt; [2023-03-11T01:24:49+0000] (error) A less severe error&#xA;(lgr-warn lgr &#34;A potentially bad situation&#34;)&#xA;;=&amp;gt; [2023-03-11T01:24:49+0000] (warn) A potentially bad situation&#xA;(lgr-info lgr &#34;iris has %s rows&#34; (nrow iris))&#xA;;=&amp;gt; [2023-03-11T01:24:49+0000] (info) iris has 150 rows&#xA;&#xA;; the following log levels are hidden by default&#xA;(lgr-debug lgr &#34;A debug message&#34;)&#xA;(lgr-trace lgr &#34;A finer grained debug message&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Loggers &lt;strong&gt;should never&lt;/strong&gt; be created manually but only be retrieved using &lt;code&gt;lgr-get-logger&lt;/code&gt;. If a logger with the same name already exists, it will be returned from a cache. The common idiom is to let-bind a logger at the beginning of a function and then use it throughout the function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(defun start-worker (worker-id)&#xA;  (let ((lgr (lgr-get-logger &#34;package.worker&#34;)))&#xA;    (lgr-info lgr &#34;Starting worker %d&#34; worker-id)&#xA;    ...))&#xA;&#xA;(defun main ()&#xA;  (let ((lgr (lgr-get-logger &#34;package&#34;)))&#xA;    (lgr-info lgr &#34;Starting the package main event loop&#34;)&#xA;    (start-worker 1)&#xA;    (start-worker 2)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can of course use multiple loggers in a single function by let-binding multiple calls to &lt;code&gt;lgr-get-logger&lt;/code&gt; (or even use them inline).&lt;/p&gt; &#xA;&lt;h2&gt;Give me 3 minute rundown of configuration&lt;/h2&gt; &#xA;&lt;p&gt;Logging an event by itself wont store it anywhere, for that, the logger must be configured with an appended. A Logger can have several appenders to write to multiple destinations.&lt;/p&gt; &#xA;&lt;p&gt;For example, we can add a file appender to format events as JSONs and save them to file. To do this, we need to configure two settings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;add the JSON layout to the appender so it knows how to format the events before writing them to the file.&lt;/li&gt; &#xA; &lt;li&gt;attach this appender to the logger object &lt;code&gt;lgr&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Configuration is very convenient with the usage of the &lt;code&gt;-&amp;gt;&lt;/code&gt; macro from the &lt;a href=&#34;https://github.com/magnars/dash.el#--x-optional-form-rest-more&#34;&gt;dash.el&lt;/a&gt; package, but can be equally done without.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(-&amp;gt; lgr&#xA;    (lgr-add-appender&#xA;     (-&amp;gt; (lgr-appender-file &#34;json-logs.log&#34;)&#xA;         (lgr-set-layout (lgr-layout-json)))))&#xA;&#xA;;; same code macro-expanded&#xA;(lgr-add-appender&#xA; lgr&#xA; (lgr-set-layout&#xA;  (lgr-appender-file &#34;json-logs.log&#34;)&#xA;  (lgr-layout-json)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;-&amp;gt;&lt;/code&gt; style resembles the method &#34;dot chaining&#34; from traditional OOP languages like Java or C++. To make this possible, we make sure that all the configuration methods always take the instance as the first argument and return itself so they can be chained:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(-&amp;gt; lgr&#xA;    (lgr-add-appender (lgr-appender-princ))&#xA;    (lgr-set-threshold lgr-level-trace)&#xA;    (lgr-set-propagate nil))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Logger hierarchies&lt;/h2&gt; &#xA;&lt;p&gt;Loggers are organized in hierarchies. The loggers are automatically nested by separating the segments of the name with a dot:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(lgr-get-logger &#34;lgr&#34;)&#xA;(lgr-get-logger &#34;lgr.appender&#34;)&#xA;(lgr-get-logger &#34;lgr.layout&#34;)&#xA;&#xA;;; lgr&#xA;;; ‚îú‚îÄ appender&#xA;;; ‚îî‚îÄ layout&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Loggers &lt;em&gt;propagate&lt;/em&gt; events up the hierarchy unless configured not to with &lt;code&gt;lgr-set-propagate&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The most common situation is to configure appenders only on top-level logger and let events bubble up and be processed there. But if an appender is added to some logger lower in the hierarchy, an event can be dispatched twice or more times.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;M-x lgr-loggers-format-to-tree&lt;/code&gt; to visualize the logger hierarchy. The results are displayed in a &lt;code&gt;*lgr loggers*&lt;/code&gt; buffer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;lgr logger hierarchy&#xA;====================&#xA;&#xA;üîá Loggers without appenders&#xA;&#xA;üîá lgr--root [info]&#xA;‚îú‚îÄ elsa [info] &amp;gt; Princ&#xA;‚îÇ  ‚îî‚îÄ lsp&#xA;‚îú‚îÄ üîá lgr&#xA;‚îÇ  ‚îú‚îÄ üîá appender&#xA;‚îÇ  ‚îî‚îÄ üîá layout&#xA;‚îú‚îÄ local &amp;gt; Warnings&#xA;‚îÇ  ‚îú‚îÄ error [error]&#xA;‚îÇ  ‚îî‚îÄ test&#xA;‚îÇ     ‚îú‚îÄ one&#xA;‚îÇ     ‚îî‚îÄ two&#xA;‚îî‚îÄ üîá test [error]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuring thresholds&lt;/h2&gt; &#xA;&lt;p&gt;Loggers and appenders can both be configured independently with thresholds.&lt;/p&gt; &#xA;&lt;p&gt;Currently, six levels are built-in in &lt;code&gt;lgr&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;fatal&lt;/code&gt; =&amp;gt; 100 or constant &lt;code&gt;lgr-level-fatal&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;error&lt;/code&gt; =&amp;gt; 200 or constant &lt;code&gt;lgr-level-error&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;warn&lt;/code&gt; =&amp;gt; 300 or constant &lt;code&gt;lgr-level-warn&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;info&lt;/code&gt; =&amp;gt; 400 or constant &lt;code&gt;lgr-level-info&lt;/code&gt; &lt;strong&gt;[default]&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;debug&lt;/code&gt; =&amp;gt; 500 or constant &lt;code&gt;lgr-level-debug&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;trace&lt;/code&gt; =&amp;gt; 600 or constant &lt;code&gt;lgr-level-trace&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A logger won&#39;t emit an event whose level is higher than the logger threshold.&lt;/p&gt; &#xA;&lt;p&gt;An appender won&#39;t append an event whose level is higher than the appender threshold.&lt;/p&gt; &#xA;&lt;p&gt;This way, we can create interesting setups such as:&lt;/p&gt; &#xA;&lt;p&gt;Configure one logger with two appenders, one for file logging and one sending emails. We configure the file appender to debug threshold and the email appender to error threshold.&lt;/p&gt; &#xA;&lt;p&gt;If the logger itself has an info threshold, only events info and above will be emited. All those will be saved in the file, because the file appender has debug threshold. But only fatal and error events will be sent as emails to an SRE operator.&lt;/p&gt; &#xA;&lt;p&gt;If a logger has no configured threshold, it will look up the logger hierarchy to inherit the threshold of first configured logger. This way, you can selectively increase or decrease the log granularity of parts of the logger hierarchy when debugging specific parts of code.&lt;/p&gt; &#xA;&lt;p&gt;Thresholds are configured with &lt;code&gt;lgr-set-threshold&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(-&amp;gt; (lgr-get-logger &#34;lgr&#34;)&#xA;    (lgr-set-threshold lgr-level-debug))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Event metadata&lt;/h2&gt; &#xA;&lt;p&gt;By passing additional key-value pairs in form of a plist, you can add arbitrary metadata to your events.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(lgr-info lgr &#34;This is a message number %d&#34; 5 :worker-id &#34;west-eu-7&#34; :datacenter &#34;dc1&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Various layouts handle the formatting of metadata differently, you can read in their documentation. For example, JSON layout will serialize it as JSON subobject under a &lt;code&gt;meta&lt;/code&gt; key.&lt;/p&gt; &#xA;&lt;h1&gt;Available Loggers, Appenders and Layouts&lt;/h1&gt; &#xA;&lt;p&gt;lgr comes with many appenders and layouts out of the box. You can read the built-in documentation with &lt;code&gt;C-h f &amp;lt;class-name&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Currently implemented loggers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lgr-logger&lt;/code&gt; - log message as-is&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lgr-logger-format&lt;/code&gt; - interpret message as format string for &lt;code&gt;format&lt;/code&gt;, using remaining arguments as replacement.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;lgr-logger-format&lt;/code&gt; is the default format returned by &lt;code&gt;lgr-get-logger&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Currently implemented appenders:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lgr-appender&lt;/code&gt; - print events using &lt;code&gt;message&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lgr-appender-princ&lt;/code&gt; - print events using &lt;code&gt;princ&lt;/code&gt; (standard output in &lt;code&gt;-batch&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lgr-appender-file&lt;/code&gt; - write events to a file&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lgr-appender-buffer&lt;/code&gt; - write events to a buffer&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lgr-appender-warnings&lt;/code&gt; - use &lt;code&gt;display-warning&lt;/code&gt; to log events&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lgr-appender-journald&lt;/code&gt; - write logs to systemd journal&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Available layouts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lgr-layout-format&lt;/code&gt; - use custom format string template to format events&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lgr-layout-json&lt;/code&gt; - format as JSON string&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;But isn&#39;t it going to slow down my code?&lt;/h1&gt; &#xA;&lt;p&gt;No. &lt;code&gt;lgr&lt;/code&gt; uses macros to implement lazy evaluation of the arguments. If the logger threshold doesn&#39;t exceed the event level, no arguments to the &lt;code&gt;lgr-LEVEL&lt;/code&gt; call are actually evaluated (except the logger itself which needs to be checked).&lt;/p&gt; &#xA;&lt;p&gt;This is why it is not advisable to use &lt;code&gt;lgr-log&lt;/code&gt; directly but instead always use the &lt;code&gt;lgr-LEVEL&lt;/code&gt; macros.&lt;/p&gt; &#xA;&lt;h1&gt;Extending lgr&lt;/h1&gt; &#xA;&lt;p&gt;The main idea of &lt;code&gt;lgr&lt;/code&gt; is to make it easily extensible by adding your own layouts and appenders.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example appender used in &lt;code&gt;lgr&lt;/code&gt;&#39;s own test suite. It simply pushes the events to an internal list.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(defclass lgr-test-appender&#xA;  ;; extend `lgr-appender&#39; class&#xA;  (lgr-appender)&#xA;  ;; add a new slot to store the events&#xA;  ((events :type list :initform nil)))&#xA;&#xA;;; implement the `log-append&#39; method&#xA;(cl-defmethod lgr-append ((appender lgr-test-appender) (event lgr-event))&#xA;  (push event (oref appender events)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is a more interesting example of an appender using &lt;a href=&#34;https://github.com/jwiegley/emacs-async/pull/167&#34;&gt;emacs-async&lt;/a&gt; to send messages from worker processes to the main process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(defclass elsa-worker-appender (lgr-appender) ()&#xA;  &#34;Appender sending messages back to parent process.&#34;)&#xA;&#xA;(cl-defmethod lgr-append ((this elsa-worker-appender) event)&#xA;  (when async-in-child-emacs&#xA;    (async-send&#xA;     :op &#34;echo&#34;&#xA;     :message (lgr-format-event (oref this layout) event)))&#xA;  this)&#xA;&#xA;;; configure the logging in a worker process&#xA;(-&amp;gt; (lgr-get-logger &#34;elsa&#34;)&#xA;    (lgr-reset-appenders)&#xA;    (lgr-add-appender&#xA;     (-&amp;gt; (elsa-worker-appender)&#xA;         (lgr-set-layout (elsa-plain-layout))))&#xA;    (lgr-set-threshold lgr-level-info))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(as seen in &lt;a href=&#34;https://github.com/emacs-elsa/Elsa&#34;&gt;Elsa&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;This example shows the power of &lt;code&gt;lgr&lt;/code&gt;. We can keep the same &lt;code&gt;lgr-info&lt;/code&gt; and &lt;code&gt;lgr-debug&lt;/code&gt; calls everywhere and based on the configuration in either the main process or the worker process different appender will be used to dispatch the messages where they need to go. Therefore, the logging logic, destinations and formatting are separate from the logging &lt;em&gt;calls&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Using lgr in my own package.&lt;/h1&gt; &#xA;&lt;p&gt;Because all the packages loaded in Emacs share the common namespace, there are some basic guidelines for using lgr in your own private or published packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The main logger name should correspond to your package name.&lt;/li&gt; &#xA; &lt;li&gt;All the loggers you use in the package should be nested under your main logger.&lt;/li&gt; &#xA; &lt;li&gt;If your package is used inside Emacs, you should provide some reasonable default configuration, for example in the major-mode function or as a separate function &lt;code&gt;PACKAGE-setup-lgr&lt;/code&gt; that users can call in their init file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That&#39;s it!. This way, &lt;em&gt;consumers&lt;/em&gt; of your package can independently of you as the author increase or decrease or even completely disable logging in your package.&lt;/p&gt; &#xA;&lt;h1&gt;Acknowledgement&lt;/h1&gt; &#xA;&lt;p&gt;This library&#39;s architecture was inspired in great deal by &lt;a href=&#34;https://github.com/s-fleck/lgr&#34;&gt;s-fleck/lgr&lt;/a&gt; package for R language, which in turn is modelled after &lt;a href=&#34;https://docs.python.org/3/library/logging.html&#34;&gt;python logging&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jdtsmith/speedrect</title>
    <updated>2023-03-17T01:33:39Z</updated>
    <id>tag:github.com,2023-03-17:/jdtsmith/speedrect</id>
    <link href="https://github.com/jdtsmith/speedrect" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Quick key bindings and other tools for rectangle-mark-mode&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SpeedRect&lt;/h1&gt; &#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/93749/223541236-cd77d56c-d1d0-40cd-8d69-f6c12dfe3d3a.png&#34; width=&#34;423&#34; align=&#34;right&#34;&gt; &#xA;&lt;p&gt;Quick key bindings and other tools for Emacs&#39; &lt;code&gt;rectangle-mark-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;SpeedRect&lt;/code&gt; is a small Emacs package that provides convenient &#34;modal&#34; key bindings and other tools while in &lt;code&gt;rectangle-mark-mode&lt;/code&gt; (&lt;code&gt;C-x SPC&lt;/code&gt;, by default).&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Single-key &lt;a href=&#34;https://raw.githubusercontent.com/jdtsmith/speedrect/main/#key-listing&#34;&gt;bindings&lt;/a&gt; for all the basic rectangle functions: open, insert string, kill, delete, clear, copy, yank.&lt;/li&gt; &#xA; &lt;li&gt;Exposes useful unbound command to delete whitespace from the rectangle rightwards.&lt;/li&gt; &#xA; &lt;li&gt;Additional command to &lt;em&gt;invert the deletion&lt;/em&gt;, i.e. delete the &lt;em&gt;unmarked columns&lt;/em&gt;, keeping only the marked rectangle on those lines.&lt;/li&gt; &#xA; &lt;li&gt;Ability to restore the last rectangle&#39;s position, which gets auto-saved.&lt;/li&gt; &#xA; &lt;li&gt;Change your mind and start a new rectangle from point.&lt;/li&gt; &#xA; &lt;li&gt;Column shift: slide the marked rectangle position left or right, 1 or 5 columns at a time (or any number of columns, with a numerical prefix).&lt;/li&gt; &#xA; &lt;li&gt;Two-way interaction with Calc: send sums or tables of data into calc, and yank processed matrix data into the buffer from the calc stack.&lt;/li&gt; &#xA; &lt;li&gt;A useful help page (hit &lt;code&gt;?&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Just download, add to path, and arrange to &lt;code&gt;(require &#39;speedrect)&lt;/code&gt;. For users of &lt;code&gt;use-package&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package speedrect&#xA;  :load-path &#34;~/code/emacs/speedrect&#34;) ; or wherever&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, with &lt;code&gt;use-package&lt;/code&gt; and &lt;code&gt;straight&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package speedrect&#xA;  :straight (speedrect :type git :host github :repo &#34;jdtsmith/speedrect&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Start &lt;code&gt;rectangle-mark-mode&lt;/code&gt; as usual (&lt;code&gt;C-x SPC&lt;/code&gt;, by default). Hit &lt;code&gt;?&lt;/code&gt; to summon a help buffer of available key bindings.&lt;/p&gt; &#xA;&lt;h2&gt;Hints&lt;/h2&gt; &#xA;&lt;p&gt;A rectangle is just a &lt;em&gt;region&lt;/em&gt; (point and mark), specially interpreted. While marking rectangles, you can &lt;code&gt;C-x C-x&lt;/code&gt; to switch point and mark to make changes to the top/bottom of the selected region (hit it yet again to switch to the other diagonal).&lt;/p&gt; &#xA;&lt;p&gt;Use calc, it&#39;s super-powerful:&lt;/p&gt; &#xA;&lt;h3&gt;Using Calc&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_mono/calc.html&#34;&gt;Calc&lt;/a&gt; is an ancient and powerful calculator in emacs with many capabilities, including operating on &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/calc/Matrix-Tutorial.html&#34;&gt;matrix data&lt;/a&gt;. In addition to simple sums, &lt;code&gt;SpeedRect&lt;/code&gt; offers powerful two-way communication with calc for sending in and yanking out columns of numerical data:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;It can send columns of numbers to calc as a &lt;em&gt;matrix&lt;/em&gt; (2D array of numbers). Once in calc, you can operate on those numbers using a wide array of operations. Many things &#34;just work&#34; on matrices (e.g. &lt;code&gt;1 +&lt;/code&gt; will add one to all the numbers). Others can easily be mapped over matrix elements (try &lt;code&gt;v M&lt;/code&gt;). You can combine columns, change their order, and much more.&lt;/li&gt; &#xA; &lt;li&gt;Once you have something you&#39;re happy with at the top of calc&#39;s &lt;em&gt;stack&lt;/em&gt; (the entry numbered &lt;code&gt;1:&lt;/code&gt;), you can: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;hit &lt;code&gt;q&lt;/code&gt; to return to your original buffer (where &lt;code&gt;rectangle-mark-mode&lt;/code&gt; will still be active),&lt;/li&gt; &#xA;   &lt;li&gt;adjust the position of your rectangle if needed (&lt;code&gt;S-left/right&lt;/code&gt; is useful for this; a zero-width rectangle is fine), and&lt;/li&gt; &#xA;   &lt;li&gt;hit &lt;code&gt;m&lt;/code&gt; to yank the matrix from calc into the buffer (if it has the right number of rows), replacing the marked rectangle.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You don&#39;t have to be in the same &lt;code&gt;mark-rectangle-mode&lt;/code&gt; session to yank a matrix from calc. As long as the height of your rectangle matches the number of matrix rows, it will just work. So you can start in one buffer, accumulate a matrix, manipulate it, switch to another buffer, and yank it there.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: what you see is what you get in calc. The matrix will be yanked &lt;em&gt;exactly&lt;/em&gt; as it appears. &lt;code&gt;v [&lt;/code&gt; and &lt;code&gt;v ,&lt;/code&gt; will remove the brackets and commas. &lt;code&gt;v &amp;gt;&lt;/code&gt; will right align numbers. While &lt;code&gt;v .&lt;/code&gt; is convenient for shortening long entries, undo it before yanking. &lt;code&gt;d f&lt;/code&gt; will let you set the number of digits after the decimal. And many more options.&lt;/p&gt; &#xA;&lt;h2&gt;Key Listing&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;SpeedRect Rectangle Mark Mode Commands&#xA;============================================================================&#xA;&#xA;Insertion:&#xA;&#xA;  [o] open      fill rectangle with tabs/spaces, moving adjacent text right&#xA;  [t] string    replace rectangle with prompt string&#xA;&#xA;Killing:&#xA;&#xA;  [k] kill      kill and save rectangle for yanking&#xA;  [d] delete    kill rectangle without saving&#xA;  [SPC] del-ws  delete all whitespace, starting from left column&#xA;  [c] clear     clear rectangle area by overwriting with spaces&#xA;  [r] rest      delete the rest of the columns, keeping the marked rectangle&#xA;&#xA;Change Rectangle:&#xA;&#xA;  [n] new       start a new rectangle from this location&#xA;  [l] last      restore the last used rectangle position, if possible&#xA;&#xA;Shift Rectangle (can use numeric prefixes):&#xA;&#xA;  [S-left]      move the rectangle left&#xA;  [S-right]     move the rectangle right&#xA;  [S-up]        move the rectangle up&#xA;  [S-down]      move the rectangle down&#xA;  [M-S-left]    move the rectangle left 5 columns&#xA;  [M-S-right]   move the rectangle right 5 columns&#xA;  [M-S-up]      move the rectangle up 5 columns&#xA;  [M-S-down]    move the rectangle down 5 lines&#xA;&#xA;Copy/Yank:&#xA;&#xA;  [w] copy      copy rectangle for future yanking&#xA;  [y] yank      yank rectangle, inserting at point&#xA;&#xA;Numerical:&#xA;&#xA;  [N] numbers   fill the rectangle with numbers (prefix to set start)&#xA;  [#] grab      grab the rectangle as a matrix in calc&#xA;  [_] across    sum across rows and grab result in calc as a vector&#xA;  [:] down      sum down the columns and grab result in calc&#xA;  [m] yank-mat  yank matrix from top of calc stack, overwriting selected rect&#xA;&#xA;Etc:&#xA;&#xA;  [?] help      view this Help buffer&#xA;  [q] quit      exit rectangle-mark-mode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Related packages&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/zk-phi/phi-rectangle&#34;&gt;phi-rectangle&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;Contributors of ideas from &lt;a href=&#34;https://www.reddit.com/r/emacs/comments/11k9u73/a_tiny_modal_rectanglemarkmode/&#34;&gt;this discussion&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>