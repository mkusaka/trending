<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-21T01:28:39Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>positron-solutions/dslide</title>
    <updated>2024-05-21T01:28:39Z</updated>
    <id>tag:github.com,2024-05-21:/positron-solutions/dslide</id>
    <link href="https://github.com/positron-solutions/dslide" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A presentation framework for Emacs. If Emacs can do it, you can present it. Yes, Org mode too.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: Domain Specific sLIDEs #+author: Positron #+email: &lt;a href=&#34;mailto:contact@positron.solutions&#34;&gt;contact@positron.solutions&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A Presentation Framework&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Present Org documents with babel integration&lt;/li&gt; &#xA; &lt;li&gt;Incorporate &lt;em&gt;anything&lt;/em&gt; Emacs does into a presentation&lt;/li&gt; &#xA; &lt;li&gt;Extensible for org and beyond ** Simple User Interface Fully programmable sequences behind a two-button interface:&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;dslide-deck-forward&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;dslide-deck-backward&lt;/del&gt; ** Present Org Documents ü¶Ñ&lt;/li&gt; &#xA; &lt;li&gt;Document header generated from keywords&lt;/li&gt; &#xA; &lt;li&gt;Breadcrumbs&lt;/li&gt; &#xA; &lt;li&gt;By default, every heading and child heading is a slide&lt;/li&gt; &#xA; &lt;li&gt;Configurable slide behavior using pre-built actions&lt;/li&gt; &#xA; &lt;li&gt;Consume typical org data like inline images with full-frame display ** Fully Programmable ‚ú®&lt;/li&gt; &#xA; &lt;li&gt;Directly script your presentation with Org babel blocks&lt;/li&gt; &#xA; &lt;li&gt;Convenient API for quickly writing reliable custom actions&lt;/li&gt; &#xA; &lt;li&gt;Integration with Elisp programs and arbitrary Emacs buffers&lt;/li&gt; &#xA; &lt;li&gt;Custom class support for extending the framework ** Status üõ†Ô∏è Version 0.3.2 üë∑&lt;/li&gt; &#xA; &lt;li&gt;Stabilizing the API and naming (as in not stable yet)&lt;/li&gt; &#xA; &lt;li&gt;Gathering user feedback &amp;amp; experience&lt;/li&gt; &#xA; &lt;li&gt;Accepting PR&#39;s and issue reports&lt;/li&gt; &#xA; &lt;li&gt;Composed children actions coming soon‚Ñ¢&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The user-facing API will look pretty similar to what is already there today, but if any keys change, I&#39;ll call &lt;del&gt;warn&lt;/del&gt; on the old keys.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Installation This isn&#39;t on a package archive yet. Subscribe to Positron&#39;s [[https://www.youtube.com/@Positron-gv7do][YouTube]] for updates. #+begin_src elisp ;; package-vc (package-vc-install &#39;(dslide :url &#34;&lt;a href=&#34;https://github.com/positron-solutions/dslide.git&#34;&gt;https://github.com/positron-solutions/dslide.git&lt;/a&gt;&#34;))&lt;/p&gt; &lt;p&gt;;; using elpaca&#39;s with explicit recipe (use-package dslide :elpaca (dslide :host github :repo &#34;positron-solutions/dslide&#34;))&lt;/p&gt; &lt;p&gt;;; straight with explicit recipe (use-package dslide :straight (dslide :type git :host github :repo &#34;positron-solutions/dslide&#34;))&lt;/p&gt; &lt;p&gt;;; or use manual load-path &amp;amp; require, you brave yak shaver #+end_src ** Try It Out With just defaults, run &lt;del&gt;dslide-deck-start&lt;/del&gt; on your existing documents. You can load the examples in the [[./test/demo.org]] file to see a showcase of configuration behavior.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The default keymap uses arrow keys. Left and right are &lt;del&gt;dslide-deck-forward&lt;/del&gt; and &lt;del&gt;dslide-deck-backward&lt;/del&gt;. Up is &lt;del&gt;dslide-deck-start&lt;/del&gt; and will show the contents. Down is &lt;del&gt;dslide-deck-stop&lt;/del&gt; and will stop the slide show.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Features ** Contents Navigation Call &lt;del&gt;dslide-contents&lt;/del&gt; to show a contents overview. Calling &lt;del&gt;dslide-deck-forward&lt;/del&gt; and &lt;del&gt;dslide-deck-backward&lt;/del&gt; in the contents can quickly move through headings. Call &lt;del&gt;dslide-deck-start&lt;/del&gt; again to resume the presentation from that point. ** Clean Buffer State The actual display is done in an indirect buffer. Your hooks and customizations for presentation will not pollute your editing buffer. Dirty state will not pile up in your presentation buffer, greatly increasing reliability even if your custom Elisp scripting is sloppy üí©. ** Follow Along If you display the slideshow in one window or frame, you can configure the point to follow the slide in the base buffer, enabling you to see the full markup and even edit the presentation while developing your customizations.&lt;/li&gt; &#xA; &lt;li&gt;Glossary&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Deck&lt;/em&gt;: an object that is used to relate the display and base buffer and is the root of all sequences. It&#39;s another word for &#34;presentation&#34; or PT.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Slide&lt;/em&gt;: an object that interprets an org heading to hydrate its actions&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Action&lt;/em&gt;: an object that responds to &lt;del&gt;dslide-deck-forward&lt;/del&gt; and &lt;del&gt;dslide-deck-backward&lt;/del&gt; calls and implements lifecycle methods to initialize and clean up state&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Step&lt;/em&gt;: a single call to &lt;del&gt;dslide-deck-foward&lt;/del&gt; or &lt;del&gt;dslide-deck-backward&lt;/del&gt;, usually delegated down to &lt;del&gt;dslide-forward&lt;/del&gt; and &lt;del&gt;dslide-backward&lt;/del&gt; methods&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Contents&lt;/em&gt;: use org folding to create a view of folded headings to quickly navigate slides&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Slide Buffer&lt;/em&gt;: the slides are shown in an indirect buffer that is cloned from your org document buffer. The source is called the &lt;em&gt;base buffer&lt;/em&gt;. Check for the =deck: my-presentation.org= buffer name. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Inderect buffer and =slide-buffer= are used interchangeably&lt;/li&gt; &#xA;   &lt;li&gt;Base buffer or =base-buffer= is used pretty exclusively&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configuring Be sure to check =M-x= &lt;del&gt;customize-group&lt;/del&gt; =dslide= to see all declared custom variables. All of the variables are configured to recommended defaults except hooks, which would depend on other packages usually.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Many settings can be configured at:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;global level through customize variables&lt;/li&gt; &#xA; &lt;li&gt;document level through keywords&lt;/li&gt; &#xA; &lt;li&gt;slide level through the property drawer ** Binding You likely want to start the mode via &lt;del&gt;dslide-deck-start&lt;/del&gt;. Once the mode starts, it creates an indirect buffer to display the slides and then calls &lt;del&gt;dslide-deck-start-function&lt;/del&gt; once the mode is active and everything is initialized, so you can customize startup behavior.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All commands begin with &lt;del&gt;dslide-deck&lt;/del&gt; üí° #+begin_src elisp (keymap-set org-mode-map &#34;&#xA; &lt;f5&gt;&#xA;  &#34; #&#39;dslide-deck-start) #+end_src Once the global minor mode, &#xA;  &lt;del&gt;dslide-mode&lt;/del&gt; is active, additional bindings in &#xA;  &lt;del&gt;dslide-mode-map&lt;/del&gt; are active in every buffer so that you can integrate other buffers into your presentation. (Tracking which buffers are part of a presentation is still a topic under consideration üöß) *** Secondary Commands üöß Because you might want to play a video or take a branch in the presentation and then exit that branch, the plan is to overload the &#xA;  &lt;del&gt;dslide-deck-start&lt;/del&gt; binding within presentations to enter / exit these branches. ** Hooks Because slides and actions have a life-cycle and can easily find their own heading, consider making a custom action and setting that action on slides where it&#39;s needed.&#xA; &lt;/f5&gt;&lt;/p&gt; &#xA;&lt;p&gt;Beware of using the normal &lt;del&gt;dslide-mode-hook&lt;/del&gt; üò± because it runs &lt;em&gt;in the base buffer&lt;/em&gt; ‚ö†Ô∏è. If you remap faces or add a bunch of styling, it will be copied to the indirect buffer but then linger in your base buffer. Instead, use &lt;del&gt;dslide-start-hook&lt;/del&gt;. üí°&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;dslide-start-hook&lt;/del&gt; Is run in the indirect buffer after it is set it. This is what you want.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;dslide-stop-hook&lt;/del&gt; is run in the base buffer because the indirect buffer is already dead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;dslide-contents-hook&lt;/del&gt; is run after switching to contents. It runs in the display buffer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;dslide-narrow-hook&lt;/del&gt; is run whenever a &lt;del&gt;dslide-deck-forward&lt;/del&gt; or &lt;del&gt;dslide-deck-backward&lt;/del&gt; changes the narrow state.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;del&gt;dslide-after-last-slide-hook&lt;/del&gt; is run when the user tries to go forward but there are no more slides. You can use this to implement a final feedback before quitting or add &lt;del&gt;dslide-deck-stop&lt;/del&gt; to exit without feedback.&lt;/p&gt; &lt;p&gt;Another option is to use &lt;del&gt;dslide-push-step&lt;/del&gt; to push a callback that will only run when called going forward. #+begin_src elisp (defun my-stop-if-forward () (mc-push-step (lambda (direction) (when (eq direction &#39;forward) ;; Be sure to return t or the hook will run again. (prog1 t (dslide-deck-stop))))))&lt;/p&gt; &lt;p&gt;(setq dslide-after-last-slide-hook #&#39;my-stop-if-forward) #+end_src ** Recommended MC Settings The out-of-the-box experience can be a bit messy due to property drawers, keywords, and babel blocks that you might include. You probably want to hide these elements. [[https://github.com/positron-solutions/master-of-ceremonies][Master of Ceremonies]] contains some flexible hiding that can be updated with each slide and turned on and off only when the slideshow is active. #+begin_src elisp ;; Something like this should work (add-hook &#39;dslide-start-hook mc-hide-markup-mode) (add-hook &#39;dslide-narrow-hook #&#39;mc-hide-refresh) (add-hook &#39;dslide-start-hook mc-hide-cursor-mode) #+end_src üöß I implemented &lt;del&gt;mc&lt;/del&gt;&#39;s hiding with overlays, but I might switch to font-locking. Overlays were easier to clean up, but since switching to using an indirect buffer for the presentation, this is no longer a problem. ** Heading Properties Headings are treated as slides. Slides have actions. Actions are configured in the property drawer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=DSLIDE_SLIDE_ACTION=: Usually narrows to the slide. Lifecycle encloses the section.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=DSLIDE_SECTION_ACTIONS:= Most commonly customized. You can list multiple actions. Each one will step through its forward and backward steps.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=DSLIDE_CHILD_ACTION=: Used to customize if and how child headings become slides&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some actions must be fully enclosed by the lifecycle of a surrounding action, such as narrowing to the headline and section before displaying a contained list item-by-item.&lt;/p&gt; &#xA;&lt;p&gt;üöß Likely in the future, actions will be composable and accept arguments, using Lisp s-expressions. This API should be forward compatible. *** Example Regular Org Mode markup is used to add actions to headings. See more examples in the [[../test]] directory. #+begin_src org ,* Full Screen Images :PROPERTIES: :DSLIDE_ACTIONS: dslide-action-images :END: ,#+attr_html: :width 50% [[./images/emacsen4.jpeg]] [[./images/before-google3.jpeg]] #+end_src *** Action Arguments Many actions understand arguments, allowing tuning of similar behaviors from the same class. Implementing new arguments is relatively easy, just adding a slot and then reacting to the value of that slot.&lt;/p&gt; &#xA;&lt;p&gt;Configuring the slot is done by adding plist-style properties after the class name: #+begin_src org :PROPERTIES: :DSLIDE_SECTION_ACTIONS: dslide-action-item-reveal :inline t :END: #+end_src You can also use &#34;property+&#34; syntax to add to a property, and these accept plist arguments too: #+begin_src org :PROPERTIES: :DSLIDE_SECTION_ACTIONS: dslide-action-babel :DSLIDE_SECTION_ACTIONS+: dslide-action-images :fullscreen t :END: #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Customizing ** Sub-classing The deck and slide class as well as actions can all be sub-classed. Use the existing sub-classes of actions as example code for writing other classes. See the [[info:eieio#Top][eieio#Top]] manual for explanation of OOP in Elisp.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Action&lt;/em&gt;: Creating new action subclasses are an efficient way to perform similar operations on typical kinds of org data.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Slide:&lt;/em&gt; Slides can be configured extensively by changing their actions. However, for more vertical cooperation between slides or cooperation among actions, extended slides could be useful.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Deck&lt;/em&gt;: If the core methods of the deck are insufficient, extension is another option besides advice, hooks, and modifying the source.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you suspect you might need to sub-class the &lt;del&gt;dslide-slide&lt;/del&gt; or &lt;del&gt;dslide-deck&lt;/del&gt;, please file an issue because your use case is probably interesting. *** Custom Action The &lt;del&gt;dslide-section-next&lt;/del&gt; and &lt;del&gt;dslide-section-previous&lt;/del&gt; method documentation are very helpful behavior for quickly writing custom actions. They advance the action&#39;s =:marker= forwards and backwards to the next matching element and return that element so we can do something with it.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;declare a class&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;override a few methods&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;now you too can paint the paragraphs red #+begin_src elisp (defclass dslide-action-red-paragraphs (dslide-action) ((overlays :initform nil)) &#34;Paint the paragraphs red, one by one.&#34;)&lt;/p&gt; &lt;p&gt;;; Default no-op `dslide-init&#39; is sufficient&lt;/p&gt; &lt;p&gt;;; Default implementation of `dslide-end&#39;, which just plays forward to the end, ;; is well-behaved with this class.&lt;/p&gt; &lt;p&gt;;; Remove any remaining overlays when calling final. (cl-defmethod dslide-final :after ((obj dslide-action-red-paragraphs)) (mapc #&#39;delete-overlay (oref obj overlays)))&lt;/p&gt; &lt;p&gt;;; Find the next paragraph and add an overlay if it exists (cl-defmethod dslide-forward ((obj dslide-action-red-paragraphs)) (when-let ((paragraph (dslide-section-next obj &#39;paragraph))) (let* ((beg (org-element-property :begin paragraph)) (end (org-element-property :end paragraph)) (new-overlay (make-overlay beg end))) (overlay-put new-overlay &#39;face &#39;error) (push new-overlay (oref obj overlays)) ;; Return non-nil to indicate progress was made. This also informs the ;; highlight when following the slides in the base buffer. beg)))&lt;/p&gt; &lt;p&gt;(cl-defmethod dslide-backward ((obj dslide-action-red-paragraphs)) (when-let* ((overlay (pop (oref obj overlays)))) (delete-overlay overlay) ;; If there is a preceding overlay, move to its beginning else move to the ;; beginning of the heading. (if-let ((overlay (car (oref obj overlays)))) (prog1 t (dslide-marker obj (overlay-start overlay))) (dslide-marker obj (org-element-property :begin (dslide-heading obj)))))) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Default Classes The default classes and actions can be configured at the document or customize level. Set the =DSLIDE_DECK_CLASS= and =DSLIDE_SLIDE_CLASS= as well as other properties that work at the heading level. The order of precedence (&lt;em&gt;Not fully implemented&lt;/em&gt; üöß):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Property definition of the current heading&lt;/li&gt; &#xA; &lt;li&gt;Property definition in the document&lt;/li&gt; &#xA; &lt;li&gt;Customize variable ** Babel Scripting You can write custom scripts into your presentation as Org Babel blocks. These can be executed with the &lt;del&gt;dslide-action-babel&lt;/del&gt; action. You just need to label your blocks with lifecycle methods if you want to be able to go forwards and backwards. See the &lt;del&gt;dslide-action-babel&lt;/del&gt; class and examples in [[./test/demo.org]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The =#+attr_ms:= affiliated keyword is used to configure which methods will run the block. Block labels that are understood:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;=begin= and =end= are run when the slide is instantiated, going forward and backward respectively. You can have several blocks with these methods, and they will be run from &lt;em&gt;top-to-bottom&lt;/em&gt; always, making it easier to re-use code usually.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=final= is only called when no progress can be made or if the presentation is stopped.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=forward= and =backward= are self-explanatory. Position your =backward= blocks &lt;em&gt;above&lt;/em&gt; any block that they undo&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=both= runs either direction. It will not repeat in place when reversing. Use seperate =forward= and =backward= blocks for that üí° *** Step Callbacks See &lt;del&gt;dslide-push-step&lt;/del&gt; for inserting arbitrary callbacks that can function as steps. Unless your action performs state tracking to decide when to consume &lt;del&gt;dslide-deck-forward&lt;/del&gt; and &lt;del&gt;dslide-deck-backward&lt;/del&gt; itself, a callback may be easier.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Because babel blocks are not actions, using &lt;del&gt;dslide-push-step&lt;/del&gt; may be the only way to optionally add a step callback from a babel block.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Package Pairings This package is focused on creating a linear presentation sequence. For functionality not related to integrations into the &lt;del&gt;dslide-deck-forward&lt;/del&gt; &lt;del&gt;dslide-deck-backward&lt;/del&gt; interface, it is better to maintain separate packages and use hooks and babel scripting. ** Master of Ceremonies The [[https://github.com/positron-solutions/master-of-ceremonies][master-of-ceremonies]] package contains utilities for display &amp;amp; presentation frame setup that are not specific to using DSL IDE.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;hide markup&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;display a region full-screen&lt;/li&gt; &#xA; &lt;li&gt;silence messages during presentation&lt;/li&gt; &#xA; &lt;li&gt;hide the cursor or make it very subtle&lt;/li&gt; &#xA; &lt;li&gt;extract notes and display them in a separate frame ** Open Broadcaster Software Sacha Chua has written an OBS plugin integration helpful for video integration [[https://github.com/sachac/obs-websocket-el][obs-websocket-el]]. ** Orgit &lt;del&gt;orgit&lt;/del&gt; can be used to show commits as links, which open with =dslide-action-links= üöß This is a lie. I was going to support this as a demonstration of a custom action. ** moom.el The [[https://github.com/takaxp/moom#org-mode-org-tree-slide][moom]] package contains some commands for resizing text and repositioning frames. ** Org Modern Bullets and many prettifications of common org markups. The markup that you don&#39;t hide looks better with org modern. ** Org Appear Never worry about turning on pretty links for a presentation. Edit them by just moving the point inside.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Domain Model This is a description of how the pieces of the program &lt;em&gt;must&lt;/em&gt; fit together. For any deep customization or hacking, the section is essential reading. At the least, it will &lt;em&gt;greatly improve your success&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;‚ö†Ô∏è Even if the current implementation differs, trust this domain model and expect the implementation to approach it.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The user interface &lt;del&gt;dslide-deck-forward&lt;/del&gt; and &lt;del&gt;dslide-deck-backward&lt;/del&gt; is a concrete requirement that drives most of the rest of the implementation and feature design.&lt;/li&gt; &#xA; &lt;li&gt;Because Org&#39;s basic structure is about trees, we need to nest sequences of steps to represent a tree of sequences. Not flattening the tree is more flexible and was chosen.&lt;/li&gt; &#xA; &lt;li&gt;The element parser and presentation tends to prefer breadth-first style, working on the section element before the child headings. ** Stateful Sequence Class This class is the heart of providing the common user interface and convenient implementation interface for extending the package. *** Command Pattern The basis of all undo systems is either:&lt;/li&gt; &#xA; &lt;li&gt;implement reverse actions that decide their behavior from the updated state&lt;/li&gt; &#xA; &lt;li&gt;save mementos that allow undoing forward actions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is the [[https://en.wikipedia.org/wiki/Command_pattern][command pattern]]. Navigating the linear sequence of a presentation is very similar to an undo system. Log-backed architectures such as git or event-sourcing can similarly be viewed as navigating to any point in a sequence by applying or rolling back a sequence of changes. *** Setup &amp;amp; Teardown At the boundaries of a sequence of forward and reverse actions, it may be necessary to build up or tear down some state.&lt;/p&gt; &#xA;&lt;p&gt;There are two setup methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;dslide-begin&lt;/del&gt; for setup going forwards&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;dslide-end&lt;/del&gt; for setup going backwards&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additionally, for teardown there is &lt;del&gt;dslide-final&lt;/del&gt; that is always called last, when the action or slide will be garbage collected and wants to clean up overlays etc. *** Indexing Via Point In order to support contents based navigation, we need to be able to play a slide forward up to the current point. This may require instantiating some parent slides and playing them forward to a child. To avoid the need for parents to know about children, the &lt;del&gt;dslide-goto&lt;/del&gt; method was introduced. *** Stateful Sequence Interface The conclusion of the command pattern, setup &amp;amp; teardown, and indexing via point is the &lt;del&gt;dslide-stateful-sequence&lt;/del&gt; class. Anything that implements its interface can be controlled by &lt;del&gt;dslide-deck-forward&lt;/del&gt; and &lt;del&gt;dslide-deck-backward&lt;/del&gt;. The full interface:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;dslide-begin&lt;/del&gt; &amp;amp; &lt;del&gt;dslide-end&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;dslide-final&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;dslide-forward&lt;/del&gt; &amp;amp; &lt;del&gt;dslide-backward&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;dslide-goto&lt;/del&gt; **** Re-Using Implementations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The default implementation of &lt;del&gt;dslide-end&lt;/del&gt; is achieved by just walking forward from &lt;del&gt;dslide-begin&lt;/del&gt;, calling &lt;del&gt;dslide-forward&lt;/del&gt; until it returns =nil=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Implementing &lt;del&gt;dslide-goto&lt;/del&gt; is optional as long as &lt;del&gt;dslide-begin&lt;/del&gt; and &lt;del&gt;dslide-forward&lt;/del&gt; can implement &lt;del&gt;dslide-end&lt;/del&gt; and report their furthest extent of progress accurately.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ideally &lt;del&gt;dslide-deck-forward&lt;/del&gt; &amp;amp; &lt;del&gt;dslide-deck-backward&lt;/del&gt; along with &lt;del&gt;dslide-begin&lt;/del&gt; &amp;amp; &lt;del&gt;dslide-end&lt;/del&gt; form a closed system, but for the convenience of the implementer, it&#39;s fine to use an idempotent &lt;del&gt;dslide-begin&lt;/del&gt; as the &lt;del&gt;dslide-deck-backward&lt;/del&gt; step if granular backward is difficult or not valuable to implement. ** Sequence Composition Navigating a tree involves depth. Descendants may care about what happened in ancestors. Ancestors may care about what descendants leave behind. There may be conventions about what happens when descending into a child or returning from one. *** Telescoping Calls At one time, slides were to be mostly independent and not running at the same time. While this simplified some things, it was limited.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Nesting slide actions might require updating several children concurrently. This was impossible to implement without pulling logic down into the parent slide&#39;s actions. Thus, the implementation calls through parents into children usually. *** Child, Section, and Slide It is extremely natural that a slide action will fill one of three roles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Narrow to the contents its actions work on&lt;/li&gt; &#xA; &lt;li&gt;Perform some steps on the heading&#39;s section&lt;/li&gt; &#xA; &lt;li&gt;Perform steps on the heading&#39;s children, including instantiating slides and calling their methods, which may narrow to them **** Multiple Slide Property Keys The three natural roles for actions are why there are more than one heading property for configuring actions. Each action is easier to implement if they only fill one role. It is easier for the user to configure a slide if they only have to declare one action. By breaking up the slide&#39;s typical actions, we can configure with enough granularity to usually only touch one heading property. The only drawback is that hydration has to do a little bit of extra work. **** Actions are Concurrent (mostly). Each slide is holding onto several actions. The lifetime of the slide action encompasses the section and child. There are some remaining quirks that are likely more to do with badly implemented children üöß *** Trees &amp;amp; Lifetime If something depends on something else existing or having been set up, its lifetime must be fully encompassed by that other thing. Especially since we are going forward &amp;amp; backward, cleanups must happen on both ends of a sequence.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is natural that a parent heading out-lives its child. User can take advantage of this by using the document or higher level headings to store state that needs to be shared by children. The &lt;del&gt;final&lt;/del&gt; calls for those things can call cleanup. *** Slides &amp;amp; Action Lifetime Actions live, for the most part, as long as the slide. Their &lt;del&gt;dslide-begin&lt;/del&gt; method is called at the very beginning. An action that reveals items must hide them before the user first sees them.&lt;/p&gt; &#xA;&lt;p&gt;A consequence of this is that there are usually multiple actions alive at once. Something has to hold onto them. This is the slide.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Since you likely just need something to magically happen, the recommended option is to place a hamburger in the [[https://github.com/sponsors/positron-solutions][hamburger jar]] and file an issue.&lt;/li&gt; &#xA; &lt;li&gt;If you do have time, excellent. Happy to support your PR&#39;s and provide context about the architecture and behavior. ** Work In Progress üöß Open issues and give feedback on feature requests. Contributions welcome. *** Secondary Commands See the section about bindings for context. Video play or other situations where the presentation might branch should be supported by overloading the behavior of &lt;del&gt;dslide-deck-start&lt;/del&gt; *** &lt;del&gt;dslide-goto&lt;/del&gt;, starting from point Since not many actions currently have implemented this very accurately, playing from point is likely not that accurate. Progress updating in the base buffer is also currently only at the slide level of granularity. *** Affiliated Buffers There is no tracking whether a buffer is part of the presentation or not. How would a buffer become one? Should it be implicit? Without any sort of tracking, the consequence is that having a presentation open leaves the minor mode bindings hot. These commands do weird things when run from these situations, especially if running babel scripts, so some kind of first-class buffer affiliation seems necessary. *** Non-Graphic Display For terminals, the line-height based slide-in effect is not supported. *** Sub-Sequence Call &amp;amp; Restore Sequences are often enclosed within other sequences, but there is currently no support for pushing or popping states when entering or exiting sequences. It&#39;s just not clear yet what cooperation might be necessary at sub-sequence boundaries. *** Non-Org Sequences There&#39;s no concrete reason why presentations need to start with Org mode buffers. The deck object could have its org-specific functionality pushed down to an org-mode class. The only requirement is to be able to hydrate some stateful sequences, which may hydrate and call into sub-sequences, meaning anything is pretty trivially possible. *** Heading Filtering This was not implemented yet, but evidently some had been filtering their headlines to only show TODO&#39;s in &lt;del&gt;org-tree-slide&lt;/del&gt;. Perhaps it is convenient to filter some tags and prevent them from being instantiated, especially if they will fail. *** Counting Slides Especially if slides launch sub-sequences, and they do it from Lisp, this is hard. Buffer slides and also slide actions make it somewhat ambiguous. Counting trees or tracking the point might be easier. A &lt;del&gt;children&lt;/del&gt; method for sequences works as long as sequences actually implement it. *** Improper Levels Children with no parents or missing a level are currently not supported and likely cause bad behavior.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Thanks &amp;amp; Acknowledgments This package is a direct descendant of Takaaki ISHIKAWA&#39;s [[https://github.com/takaxp/org-tree-slide][org-tree-slide]] package. Many of the ideas and some of the implementations were either inherited or inspired by ideas from that package. This package would not exist without the inspiration. Thanks to everyone who contributed on org-tree-slide.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>