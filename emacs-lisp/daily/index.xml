<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-10T01:39:15Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>joaotavora/beardbolt</title>
    <updated>2022-08-10T01:39:15Z</updated>
    <id>tag:github.com,2022-08-10:/joaotavora/beardbolt</id>
    <link href="https://github.com/joaotavora/beardbolt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An Emacs alternative to compiler explorer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Beardbolt&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/joaotavora/beardbolt/master/beardbolt.gif&#34; alt=&#34;beardbolt in action&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;An experimental fork-rewrite of &lt;a href=&#34;https://gitlab.com/jgkamat/rmsbolt&#34;&gt;RMSbolt&lt;/a&gt;, itself a supercharged implementation of &lt;a href=&#34;https://github.com/mattgodbolt/compiler-explorer&#34;&gt;godbolt, the compiler-explorer&lt;/a&gt; but for Emacs, instead of a clunky browser.&lt;/p&gt; &#xA;&lt;p&gt;Beardbolt shows assembly output for given source code file, making it easy to see what the compiler is doing.&lt;/p&gt; &#xA;&lt;p&gt;It also highlights which source code corresponds to a given assembly, and vice versa.&lt;/p&gt; &#xA;&lt;h3&gt;Why Beardbolt over RMSbolt&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Doesn&#39;t require file to be saved.&lt;/li&gt; &#xA; &lt;li&gt;3-5x faster on typical files. See &lt;a href=&#34;https://raw.githubusercontent.com/joaotavora/beardbolt/master/#benchmarks&#34;&gt;here for benchmarks&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;ðŸŒˆHas pretty rainbowsðŸŒˆ&lt;/li&gt; &#xA; &lt;li&gt;Has more useful Godbolt features like &#34;execute program&#34; and &#34;preserve/filter library functions&#34; .&lt;/li&gt; &#xA; &lt;li&gt;Simpler code (less than half the LOC, but also less funcional in some regards if we&#39;re honest).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Why RMSbolt over Beardbolt&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports way more languages/compilers. Beardbolt only C, C++ and Rust.&lt;/li&gt; &#xA; &lt;li&gt;Supports more Emacs versions. Beardbolt probably only 28+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /path/to/beardbolt/clone&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(add-to-list &#39;load-path &#34;/path/to/beardbolt/clone&#34;)&#xA;(require &#39;beardbolt)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x beardbolt-starter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Main commands&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-starter&lt;/code&gt;: Lets you start a new experiment in one of the supported languages. Automatically start &lt;code&gt;beardbolt-mode&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-mode&lt;/code&gt;: Starts a minor mode that automatically re-compiles buffer code every few changes to the source code.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-compile&lt;/code&gt;: Manually start a compilation. Bound to &lt;code&gt;C-c C-c&lt;/code&gt; in &lt;code&gt;beardbolt-mode&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Options as local variables&lt;/h3&gt; &#xA;&lt;p&gt;Beardbolt&#39;s behaviour can be tweaked with the follow options. You may set them globally (they&#39;re Emacs customization variables), but it&#39;s probably more useful to write them as file-local variable cookies instead. Beardbolt will pick them up immediately on each run.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-command&lt;/code&gt;: Main compiler command to run. May be something like &lt;code&gt;&#34;gcc -O3&#34;&lt;/code&gt;. Leave unset to have Beardbolt try to guess from some nearby &lt;code&gt;compilation_commands.json&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-disassemble&lt;/code&gt;: Compile, assemble, then disassemble using &lt;code&gt;objdump&lt;/code&gt; and present that input instead of assembly code.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-asm-format&lt;/code&gt;: Choose between &lt;code&gt;intel&lt;/code&gt; and &lt;code&gt;att&lt;/code&gt; formats.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-preserve-directives&lt;/code&gt;: Keep every non-code, non-label asm directive.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-preserve-unused-labels&lt;/code&gt;: Keep unused asm labels.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-preserve-library-functions&lt;/code&gt;: Keep functions with no code related to current file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-demangle&lt;/code&gt;: Demangle any mangled symbols of resulting assembly with &lt;code&gt;c++filt&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;beardbolt-execute&lt;/code&gt;: If non-nil, run the resulting program in the compilation buffer. If a string, run with these arguments. If t runs without arguments.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;benchmarks&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Benchmarks vs RMSbolt&lt;/h3&gt; &#xA;&lt;p&gt;First note that Beardbolt is highly hacky/experimental and may be providing incorrect results, in which case most/all of the following benchmarks/comparisons are probably invalid.&lt;/p&gt; &#xA;&lt;p&gt;Second, a word on what &#34;fast&#34; means: the performance metric to optimize is responsiveness. Both Beardbolt and RMSbolt continuously analyze the program to present a &#34;live&#34; view of its assembly output. The goal is not only to provide this service as quickly as possible, but also to intrude as little as possible in the user&#39;s editing.&lt;/p&gt; &#xA;&lt;p&gt;Both extensions work in a two-step fashion. Beardbolt tries to optimize step 2.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The file is saved and partially compiled by an external program&lt;/p&gt; &lt;p&gt;This happens asynchronously. It might takes several seconds and spin up your CPU, but it does not generally harm the UX inside Emacs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Some Elisp processing takes place on the assembly output&lt;/p&gt; &lt;p&gt;This happens inside Emacs, and it&#39;s generally bad if it takes a long time, because Emacs is single-threaded and has no easily accessible asynchronous mechanisms for this type of work.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;Results&lt;/h4&gt; &#xA;&lt;p&gt;To run the benchmarks, have both RMSbolt and Beardbolt clones side-by-side, then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd /path/to/beardbolt/clone&#xA;$ EMACS=~/Source/Emacs/emacs/src/emacs make benchmark&#xA;/home/capitaomorte/Source/Emacs/emacs/src/emacs -Q -L . --batch -l beardbolt-benchmark starters/slow-to-process.cpp&#xA;RMSbolt timings for slow-to-process.cpp&#xA;  samples: (1.329s 1.316s 1.338s 1.345s 1.341s)&#xA;  average: 1.334s&#xA;Beardbolt timings for slow-to-process.cpp&#xA;  samples: (0.324s 0.338s 0.334s 0.334s 0.342s)&#xA;  average: 0.334s&#xA;/home/capitaomorte/Source/Emacs/emacs/src/emacs -Q -L . --batch -l beardbolt-benchmark starters/vector-emplace-back.cpp&#xA;RMSbolt timings for vector-emplace-back.cpp&#xA;  samples: (0.234s 0.223s 0.223s 0.240s 0.224s)&#xA;  average: 0.229s&#xA;Beardbolt timings for vector-emplace-back.cpp&#xA;  samples: (0.086s 0.074s 0.073s 0.074s 0.089s)&#xA;  average: 0.079s&#xA;/home/capitaomorte/Source/Emacs/emacs/src/emacs -Q -L . --batch -l beardbolt-benchmark starters/unordered-multimap-emplace.cpp&#xA;RMSbolt timings for unordered-multimap-emplace.cpp&#xA;  samples: (0.534s 0.523s 0.524s 0.523s 0.529s)&#xA;  average: 0.527s&#xA;Beardbolt timings for unordered-multimap-emplace.cpp&#xA;  samples: (0.103s 0.123s 0.103s 0.102s 0.118s)&#xA;  average: 0.110s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This ran &lt;code&gt;beardbolt-compile&lt;/code&gt; and &lt;code&gt;rmsbolt-compile&lt;/code&gt; 5 times on small two &lt;a href=&#34;https://cppreference.com&#34;&gt;cppreference.com&lt;/a&gt; examples (&lt;a href=&#34;https://en.cppreference.com/w/cpp/container/vector/emplace_back&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;https://en.cppreference.com/w/cpp/container/unordered_multimap/emplace&#34;&gt;2&lt;/a&gt;) as well as a known &#34;slow&#34; file found in &lt;a href=&#34;https://gitlab.com/jgkamat/rmsbolt/-/issues/9&#34;&gt;RMSbolt&#39;s bug tracker&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To make the benchmark fair(er?) I patched &lt;code&gt;rmsbolt.el&lt;/code&gt; to generate slightly less debug with &lt;code&gt;-g1&lt;/code&gt; instead of &lt;code&gt;-g&lt;/code&gt;, and thus benefit from the same speedup that &lt;code&gt;beardbolt.el&lt;/code&gt; uses.&lt;/p&gt; &#xA;&lt;p&gt;The results were obtained on my Thinkpad T480 running Emacs 29 (without native compilation).&lt;/p&gt;</summary>
  </entry>
</feed>