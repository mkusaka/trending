<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-18T01:42:15Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jorgenschaefer/pyvenv</title>
    <updated>2022-07-18T01:42:15Z</updated>
    <id>tag:github.com,2022-07-18:/jorgenschaefer/pyvenv</id>
    <link href="https://github.com/jorgenschaefer/pyvenv" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Python virtual environment interface for Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;pyvenv.el, Python virtual environment support for Emacs&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://secure.travis-ci.org/jorgenschaefer/pyvenv.png&#34; alt=&#34;Travis-CI Build Status&#34;&gt; &lt;a href=&#34;http://stable.melpa.org/#/pyvenv&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/pyvenv-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is a simple global minor mode which will replicate the changes done by virtualenv activation inside Emacs.&lt;/p&gt; &#xA;&lt;p&gt;The main entry points are &lt;code&gt;pyvenv-activate&lt;/code&gt;, which queries the user for a virtual environment directory to activate, and &lt;code&gt;pyvenv-workon&lt;/code&gt;, which queries for a virtual environment in &lt;code&gt;$WORKON_HOME&lt;/code&gt; (from virtualenvwrapper.sh).&lt;/p&gt; &#xA;&lt;h2&gt;Similar Projects&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/aculich/virtualenv.el&#34;&gt;virtualenv.el&lt;/a&gt; is the original virtualenv implementation for Emacs. I used it for a long time, but didn’t like some of the design decisions.&lt;/p&gt; &#xA;&lt;p&gt;For example, it does not modify &lt;code&gt;process-environment&lt;/code&gt; so does not set a virtual environment for &lt;code&gt;M-x compile&lt;/code&gt; and other external processes. Also, &lt;code&gt;M-x virtualenv-workon&lt;/code&gt; requires a prefix argument to actually change the current virtual environment. And it does not support virtualenvwrapper’s hooks, which I use to set up a working environment.&lt;/p&gt; &#xA;&lt;p&gt;All in all, too much magic for too little gain. So I figured I’d write my own. Still, it’s an excellent package and I’m very grateful to have used it for a long time.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>NinjaTrappeur/my-repo-pins</title>
    <updated>2022-07-18T01:42:15Z</updated>
    <id>tag:github.com,2022-07-18:/NinjaTrappeur/my-repo-pins</id>
    <link href="https://github.com/NinjaTrappeur/my-repo-pins" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs project manager and remote git checkout&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;My Repo Pins &lt;a href=&#34;https://github.com/NinjaTrappeur/my-repo-pins/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/NinjaTrappeur/my-repo-pins/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/my-repo-pins&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/my-repo-pins-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NinjaTrappeur/my-repo-pins/master/doc/assets/logo-white.svg#gh-dark-mode-only&#34; alt=&#34;Project logo&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/NinjaTrappeur/my-repo-pins/master/doc/assets/logo-black.svg#gh-light-mode-only&#34; alt=&#34;Project logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;My Repo Pins - move between projects quickly&lt;/p&gt; &#xA;&lt;p&gt;Open source developers often have to jump between projects, either to read code, or to craft patches. My Repo Pins reduces the friction so that it becomes trivial to do so.&lt;/p&gt; &#xA;&lt;p&gt;The idea of the plugin is based on this idea; if the repository URLs can be translated to a filesystem location, the local disk can be used like a cache. My Repo Pins lazily clones the repo to the filesystem location if needed, and then jumps into the project in one single command. You don&#39;t have to remember where you put the project on the local filesystem because it&#39;s always using the same location. Something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;~/code-root&#xA;├── codeberg.org&#xA;│&amp;nbsp;&amp;nbsp; └── Freeyourgadget&#xA;│&amp;nbsp;&amp;nbsp;     └── Gadgetbridge&#xA;└── github.com&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp; ├── BaseAdresseNationale&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp; │&amp;nbsp;&amp;nbsp; └── fantoir&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp; ├── mpv-player&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp; │&amp;nbsp;&amp;nbsp; └── mpv&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp; └── NinjaTrappeur&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; ├── cinny&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp; └── my-repo-pins&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This Emacs plugin aims to help you navigate this repository tree &lt;strong&gt;and&lt;/strong&gt; clone new repositories at the right place in the tree.&lt;/p&gt; &#xA;&lt;h2&gt;Show me What You&#39;ve Got&lt;/h2&gt; &#xA;&lt;p&gt;As always, a small demo is worth a thousand words!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Jump to a local repository you already cloned:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NinjaTrappeur/my-repo-pins/master/doc/assets/jump-local.webp&#34; alt=&#34;Screen capture showcasing my-repo-pins jumping to a already checked out repository&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Find a repository in a remote forge, clone it, and jump to it:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NinjaTrappeur/my-repo-pins/master/doc/assets/clone-project.webp&#34; alt=&#34;Screen capture showcasing my-repo-pins cloning a git repository from a remote forge before jumping to it&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Alternatively, you can also specify a absolute git URL you want to clone:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NinjaTrappeur/my-repo-pins/master/doc/assets/clone-absolute-url.webp&#34; alt=&#34;Screen capture showcasing my-repo-pins cloning a git repository using a absolute git url before jumping to it&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Via MELPA (recommended)&lt;/h3&gt; &#xA;&lt;p&gt;This package is available on &lt;a href=&#34;https://melpa.org&#34;&gt;MELPA&lt;/a&gt;. After &lt;a href=&#34;https://melpa.org/#/getting-started&#34;&gt;adding MELPA to your &lt;code&gt;packages-archives&lt;/code&gt;&lt;/a&gt;, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x package-install&#xA;my-repo-pins&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Manually&lt;/h3&gt; &#xA;&lt;p&gt;Clone this repository, open the &lt;code&gt;my-repo-pins.el&lt;/code&gt; file, then, install the package using &lt;code&gt;M-x package-install-file&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;The minimal configuration consists in setting the directory in which you want to clone all your git repositories via the &lt;code&gt;my-repo-pins-code-root&lt;/code&gt; variable.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say you&#39;d like to store all your git repositories in the &lt;code&gt;~/code-root&lt;/code&gt; directory. You&#39;ll want to add the following snippet in your Emacs configuration file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;my-repo-pins)&#xA;(setq my-repo-pins-code-root &#34;~/code-root&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then call the &lt;code&gt;M-x my-repo-pins&lt;/code&gt; command to open a project living in your &lt;code&gt;~/code-root&lt;/code&gt; directory &lt;strong&gt;or&lt;/strong&gt; clone a new project in your code root.&lt;/p&gt; &#xA;&lt;p&gt;Binding this command to a global key binding might make things a bit more convenient. I personally like to bind it to &lt;code&gt;M-h&lt;/code&gt;. You can add the following snippet to your Emacs configuration to set up this key binding:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(global-set-key (kbd &#34;M-h&#34;) &#39;my-repo-pins)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Customization&lt;/h2&gt; &#xA;&lt;h3&gt;my-repo-pins-code-root - REQUIRED&lt;/h3&gt; &#xA;&lt;p&gt;Path to the directory containing all your projects. &lt;code&gt;my-repo-pins&lt;/code&gt; organize the git repos you&#39;ll clone in a tree fashion.&lt;/p&gt; &#xA;&lt;p&gt;All the code fetched using &lt;code&gt;my-repo-pins&lt;/code&gt; will end up in this root directory. A tree of subdirectories will be created mirroring the remote clone URL.&lt;/p&gt; &#xA;&lt;p&gt;For instance, after checking out &lt;a href=&#34;https://git.savannah.gnu.org/git/emacs/org-mode.git&#34;&gt;https://git.savannah.gnu.org/git/emacs/org-mode.git&lt;/a&gt;, the source code will live in the my-repo-pins-code-root/git.savannah.gnu.org/git/emacs/org-mode/ local directory&lt;/p&gt; &#xA;&lt;h3&gt;my-repo-pins-max-depth&lt;/h3&gt; &#xA;&lt;p&gt;Maximum search depth starting from the &lt;code&gt;my-repo-pins-code-root&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;Set this variable to nil if you don&#39;t want any limit.&lt;/p&gt; &#xA;&lt;p&gt;This is a performance stop gap. It&#39;ll prevent my repo pins from accidentally walking too deep if it fails to detect a project boundary.&lt;/p&gt; &#xA;&lt;p&gt;By default, this limit is set to 2 to materialize the &lt;code&gt;&amp;lt;forge&amp;gt;/&amp;lt;username&amp;gt;&lt;/code&gt; directories that are supposed to contain the projects.&lt;/p&gt; &#xA;&lt;p&gt;We won&#39;t search further once we reach this limit. A warning message is issued to the &lt;code&gt;*Messages*&lt;/code&gt; buffer to warn the user the limit has been reached.&lt;/p&gt; &#xA;&lt;h3&gt;my-repo-pins-git-bin&lt;/h3&gt; &#xA;&lt;p&gt;Path pointing to the git binary. By default, it&#39;ll look for git in the current &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;my-repo-pins-forge-fetchers&lt;/h3&gt; &#xA;&lt;p&gt;Alist in the form of &lt;code&gt;(&#34;FORGE NAME&#34; . FETCH-FUNCTION)&lt;/code&gt; where &lt;code&gt;FETCH-FUNCTION&lt;/code&gt; is a function in charge of retrieving a potential remote clone URL. More about this function in the &lt;a href=&#34;https://raw.githubusercontent.com/NinjaTrappeur/my-repo-pins/master/#fetchers&#34;&gt;Fetchers&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;Fetchers&lt;/h2&gt; &#xA;&lt;p&gt;When a repository cannot be found in the code root directory, &lt;code&gt;my-repo-pins&lt;/code&gt; will try to download it from different forges. By default, it&#39;ll try to find it on github.com, gitlab.com, git.sr.ht, and codeberg.org.&lt;/p&gt; &#xA;&lt;h3&gt;Re-Using the Default Fetchers for your own Forge Instance&lt;/h3&gt; &#xA;&lt;p&gt;My-repo-pins provides some generic fetchers for Gitlab, Sourcehut, and Gitea.&lt;/p&gt; &#xA;&lt;p&gt;You can re-use these generic fetchers for your own forge instance using the following functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GitLab: &lt;code&gt;my-repo-pins--query-gitlab-owner-repo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;SourceHut: &lt;code&gt;my-repo-pins--query-sourcehut-owner-repo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Gitea: &lt;code&gt;my-repo-pins--query-gitea-owner-repo&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These functions share the same 4 input arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;instance-url&lt;/code&gt;: your instance &lt;a href=&#34;https://fr.wikipedia.org/wiki/Fully_qualified_domain_name&#34;&gt;FQDN&lt;/a&gt;. For instance: &lt;code&gt;gitlab.gnome.org&lt;/code&gt;, &lt;code&gt;git.alternativebit.fr&lt;/code&gt;, …&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;user-name&lt;/code&gt;: the user name for which we want to clone the repository.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;repo-name&lt;/code&gt;: name of the repository we want to clone.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;callback&lt;/code&gt;: function &lt;code&gt;my-repo-pins&lt;/code&gt; will use to clone the repository once we retrieved the various clone URLs. The callback takes an alist as parameter. The alist being of the form of : &lt;code&gt;((ssh . SSH-CHECKOUT-URL) (https . HTTPS-CHECKOUT-URL))&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can re-use these functions by instantiating them for a specific forge, then by appending this instantiation to the &lt;code&gt;my-repo-pins-forge-fetchers&lt;/code&gt; variable in your Emacs configuration.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say you want to retrieve repositories from the Gnome Gitlab instance living at &lt;code&gt;gitlab.gnome.org&lt;/code&gt;. You&#39;ll have to add the following snippet to your Emacs configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setq my-repo-pins-forge-fetchers&#xA;      `((&#34;gitlab.gnome.org&#34; (lambda (owner repo cb)(my-repo-pins--query-gitlab-owner-repo &#34;gitlab.gnome.org&#34; owner repo cb)))&#xA;        ,my-repo-pins-forge-fetchers))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Writing your Forge Fetcher from Scratch&lt;/h3&gt; &#xA;&lt;p&gt;You may also want to support a forge for which &lt;code&gt;my-repo-pins&lt;/code&gt; currently does not provide any generic fetcher. In that case, you&#39;ll have to write a function in the form of:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun your-custom-fetcher (owner repo)&#xA;; (..) the actual implementation&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function needs to accept two input parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;owner&lt;/code&gt;: string containing the name of the owner of the query repository. IE. &lt;code&gt;ninjatrappeur&lt;/code&gt; for the &lt;code&gt;ninjatrappeur/my-repo-pins&lt;/code&gt; query.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;repository&lt;/code&gt;: string containing the name of the query repository. IE. &lt;code&gt;my-repo-pins&lt;/code&gt; for the &lt;code&gt;ninjatrappeur/my-repo-pins&lt;/code&gt; query.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This function will return either &lt;code&gt;nil&lt;/code&gt; in case the query couldn&#39;t be found on the remote forge. An alist containing the SSH and HTTPS clone URLs in the form of:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;&#39;((ssh . SSH-CHECKOUT-URL)&#xA;  (https . HTTPS-CHECKOUT-URL))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Aknowledgements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This plugin is heavily inspired by &lt;a href=&#34;https://github.com/zimbatm/h&#34;&gt;&lt;strong&gt;Zimbatm&#39;s h&lt;/strong&gt;&lt;/a&gt;. Thanks a lot for this amazing tool, it made my life easier for years!&lt;/li&gt; &#xA; &lt;li&gt;Thanks a lot to Wiwi who found the &lt;strong&gt;terrible&lt;/strong&gt; pun we used to name this project.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>vspinu/sesman</title>
    <updated>2022-07-18T01:42:15Z</updated>
    <id>tag:github.com,2022-07-18:/vspinu/sesman</id>
    <link href="https://github.com/vspinu/sesman" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Session manager for Emacs based IDEs.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?sanitize=true&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/sesman&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/sesman-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/sesman&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/sesman-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/vspinu/sesman&#34;&gt;&lt;img src=&#34;https://travis-ci.org/vspinu/sesman.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Generic Session Manager for Emacs&lt;/h2&gt; &#xA;&lt;p&gt;Sesman provides facilities for session management and interactive session association with the current contexts (e.g. project, directory, buffers). While sesman can be used to manage arbitrary &#34;sessions&#34;, it primary targets the Emacs based IDEs (&lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;CIDER&lt;/a&gt;, &lt;a href=&#34;https://ess.r-project.org/&#34;&gt;ESS&lt;/a&gt;, &lt;a href=&#34;https://github.com/jaor/geiser&#34;&gt;Geiser&lt;/a&gt;, &lt;a href=&#34;https://github.com/dgutov/robe&#34;&gt;Robe&lt;/a&gt;, &lt;a href=&#34;https://common-lisp.net/project/slime/&#34;&gt;SLIME&lt;/a&gt; etc.)&lt;/p&gt; &#xA;&lt;p&gt;For Emacs based IDEs, session are commonly composed of one or more physical processes (sub-processes, sockets, websockets etc). For example in the current implementation of &lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;CIDER&lt;/a&gt; a session would be composed of one or more sesman connections (Clojure or ClojureScript). Each &lt;a href=&#34;https://github.com/clojure-emacs/cider&#34;&gt;CIDER&lt;/a&gt; connection consists of user REPL buffer and two sub-processes, one for user eval communication and another for tooling (completion, inspector etc).&lt;/p&gt; &#xA;&lt;h3&gt;Concepts:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;session&#34; is a list of the form &lt;code&gt;(session-name ..other-stuff..)&lt;/code&gt; where &lt;code&gt;..other-stuff..&lt;/code&gt; is system dependent.&lt;/li&gt; &#xA; &lt;li&gt;&#34;system&#34; is generic name used for a tool which uses sesman (e.g. &lt;code&gt;CIDER&lt;/code&gt;, &lt;code&gt;ESS&lt;/code&gt; etc)&lt;/li&gt; &#xA; &lt;li&gt;&#34;contexts&#34; are Emacs objects which describe current context. For example &lt;code&gt;current-buffer&lt;/code&gt;, &lt;code&gt;default-directory&lt;/code&gt; and &lt;code&gt;project-current&lt;/code&gt; are such contexts. Context objects are used to create associations (links) between the current context and sessions. At any given time the user can link (unlink) sessions to (from) contexts. By default there are three types of contexts - buffer, directory and project, but systems can define their own specialized context types..&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sesman is composed of two parts, user interface, available as a sesman map and menu, and system interface consisting of a few generics and API functions.&lt;/p&gt; &#xA;&lt;h3&gt;User Interface&lt;/h3&gt; &#xA;&lt;p&gt;Consists of&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;lifecycle management commands (&lt;code&gt;sesman-start&lt;/code&gt;, &lt;code&gt;sesman-quit&lt;/code&gt; and &lt;code&gt;sesman-restart&lt;/code&gt;), and&lt;/li&gt; &#xA; &lt;li&gt;association management commands (&lt;code&gt;sesman-link-with-buffer&lt;/code&gt;, &lt;code&gt;sesman-link-with-directory&lt;/code&gt;, &lt;code&gt;sesman-link-with-project&lt;/code&gt; and &lt;code&gt;sesman-unlink&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;From the user&#39;s prospective the work-flow is as follow. Start a session, either with &lt;code&gt;sesman-start&lt;/code&gt; (&lt;code&gt;C-c C-s C-s&lt;/code&gt;) or some of the system specific commands (&lt;code&gt;run-xyz&lt;/code&gt;, &lt;code&gt;xyz-jack-in&lt;/code&gt; etc). On startup each session is automatically associated with the least specific context (commonly a project). In the most common case the user has only one session open per project. In such case, no ambiguity arises when a system retrieves the current session. If multiple sessions are associated with the current context the ambiguity is automatically resolved through the system specific relevance mechanism. Usually it is the most recently used session.&lt;/p&gt; &#xA;&lt;p&gt;By default links with projects and directories are many-to-many in the sense that any session can be linked to multiple context and each context can be associated with multiple sessions. Buffers instead are 1-to-many. One buffer can be associated with only one session and a session can be associated with multiple buffers. This behavior is controlled by a custom &lt;code&gt;sesman-single-link-context-types&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;System Interface&lt;/h3&gt; &#xA;&lt;p&gt;Consists of several generics, of which only first three are strictly required:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;sesman-start-session&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sesman-quit-session&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sesman-restart-session&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sesman-session-info&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sesman-context-types&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sesman-more-relevant-p&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sesman also provides [a range of utility functions][system api] functions to manipulate sessions, links and session components. Systems can register entire sessions with &lt;code&gt;sesman-register&lt;/code&gt; or add/remove objects one by one with &lt;code&gt;sesman-add-object&lt;/code&gt;/&lt;code&gt;sesman-remove-object&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Systems should link sesman map into their key-maps (ideally on &lt;code&gt;C-c C-s&lt;/code&gt;) and install sesman menu with &lt;code&gt;sesman-install-menu&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Implementations&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.cider.mx/cider/usage/managing_connections.html&#34;&gt;CIDER implementation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- , which is a good mnemonic and is already used in CIDER and ESS. --&gt;</summary>
  </entry>
</feed>