<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-14T01:41:05Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>alexmurray/evil-vimish-fold</title>
    <updated>2022-08-14T01:41:05Z</updated>
    <id>tag:github.com,2022-08-14:/alexmurray/evil-vimish-fold</id>
    <link href="https://github.com/alexmurray/evil-vimish-fold" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Evil vimish-fold&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?sanitize=true&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/evil-vimish-fold&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/evil-vimish-fold-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/alexmurray/evil-vimish-fold&#34;&gt;&lt;img src=&#34;https://travis-ci.org/alexmurray/evil-vimish-fold.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Integration of &lt;a href=&#34;https://github.com/mrkkrp/vimish-fold&#34;&gt;vimish-fold&lt;/a&gt; with &lt;a href=&#34;https://bitbucket.org/lyro/evil/wiki/Home&#34;&gt;evil&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Adds standard vim keybindings of &lt;kbd&gt;zf&lt;/kbd&gt; and &lt;kbd&gt;zd&lt;/kbd&gt; to create and delete folds (via &lt;code&gt;vimish-fold&lt;/code&gt;) respectively. Also hooks into &lt;code&gt;evil&lt;/code&gt; so the usual vim keybindings for fold toggling (&lt;kbd&gt;za&lt;/kbd&gt;), opening (&lt;kbd&gt;zo&lt;/kbd&gt;), closing (&lt;kbd&gt;zc&lt;/kbd&gt;) etc all work as expected with &lt;code&gt;vimish-fold&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Finally, also supports navigation between folds using &lt;kbd&gt;zj&lt;/kbd&gt; and &lt;kbd&gt;zk&lt;/kbd&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This provides a near-complete vim folding experience in evil for Emacs.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;MELPA&lt;/h3&gt; &#xA;&lt;p&gt;The preferred way to install &lt;code&gt;evil-vimish-fold&lt;/code&gt; is via &lt;a href=&#34;http://melpa.org&#34;&gt;MELPA&lt;/a&gt;. You can just &lt;kbd&gt;M-x package-install RET evil-vimish-fold RET&lt;/kbd&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Manual&lt;/h3&gt; &#xA;&lt;p&gt;If you would like to install the package manually, download or clone it and place within Emacs&#39; &lt;code&gt;load-path&lt;/code&gt;, then you can require it in your init file like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;evil-vimish-fold)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: This will also require the manual installation of &lt;code&gt;evil&lt;/code&gt; and &lt;code&gt;vimish-fold&lt;/code&gt; if you have not done so already.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;You can configure &lt;code&gt;evil-vimish-fold&lt;/code&gt; to run on a per mode basis using hooks or as a global mode activated on specific modes.&lt;/p&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;global-evil-vimish-fold-mode&lt;/code&gt; will enable &lt;code&gt;evil-vimish-fold-mode&lt;/code&gt; in modes derived from those specified in &lt;code&gt;evil-vimish-fold-target-modes&lt;/code&gt;. By default &lt;code&gt;evil-vimish-fold-target-modes&lt;/code&gt; is set to &lt;code&gt;prog-mode&lt;/code&gt; (and thus all modes derived from &lt;code&gt;prog-mode&lt;/code&gt;). This will allow you to avoid having &lt;code&gt;evil-vimish-mode&lt;/code&gt; enabled in modes where its key bindings conflict, e.g., magit.&lt;/p&gt; &#xA;&lt;h3&gt;Vanilla configuration examples&lt;/h3&gt; &#xA;&lt;p&gt;Per mode (no use of global mode):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(add-hook &#39;prog-mode-hook &#39;evil-vimish-fold-mode)&#xA;(add-hook &#39;text-mode-hook &#39;evil-vimish-fold-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Globally for a set of modes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(setq evil-vimish-fold-target-modes &#39;(prog-mode conf-mode text-mode))&#xA;(global-evil-vimish-fold-mode 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;use-package configuration examples&lt;/h3&gt; &#xA;&lt;p&gt;A configuration using mode hooks (no use of global mode):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package vimish-fold&#xA;  :ensure&#xA;  :after evil)&#xA;&#xA;(use-package evil-vimish-fold&#xA;  :ensure&#xA;  :after vimish-fold&#xA;  :hook ((prog-mode conf-mode text-mode) . evil-vimish-fold-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;p&gt;A configuration that sets the lighter, i.e., visual indicator of the mode&#39;s activation in the modeline, sets target modes, then turns on global mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package vimish-fold&#xA;  :ensure&#xA;  :after evil)&#xA;&#xA;(use-package evil-vimish-fold&#xA;  :ensure&#xA;  :after vimish-fold&#xA;  :init&#xA;  (setq evil-vimish-fold-mode-lighter &#34; ⮒&#34;)&#xA;  (setq evil-vimish-fold-target-modes &#39;(prog-mode conf-mode text-mode))&#xA;  :config&#xA;  (global-evil-vimish-fold-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright © 2015 Alex Murray&lt;/p&gt; &#xA;&lt;p&gt;Distributed under GNU GPL, version 3.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>abo-abo/auto-yasnippet</title>
    <updated>2022-08-14T01:41:05Z</updated>
    <id>tag:github.com,2022-08-14:/abo-abo/auto-yasnippet</id>
    <link href="https://github.com/abo-abo/auto-yasnippet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;quickly create disposable yasnippets&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Auto-YASnippet&lt;/h1&gt; &#xA;&lt;p&gt;This is a hybrid of &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/emacs/Basic-Keyboard-Macro.html&#34;&gt;keyboard macros&lt;/a&gt; and &lt;a href=&#34;https://github.com/joaotavora/yasnippet&#34;&gt;yasnippet&lt;/a&gt;. You create the snippet on the go, usually to be used just in the one place. It&#39;s fast, because you&#39;re not leaving the current buffer, and all you do is enter the code you&#39;d enter anyway, just placing &lt;code&gt;~&lt;/code&gt; where you&#39;d like yasnippet fields and mirrors to be.&lt;/p&gt; &#xA;&lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-generate-toc again --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#auto-yasnippet&#34;&gt;Auto-YASnippet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#installation-instructions&#34;&gt;Installation instructions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#a-basic-example&#34;&gt;A basic example&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#inline-text&#34;&gt;Inline text&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#multiple-placeholders&#34;&gt;Multiple placeholders&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#javascript---aya-create-one-line&#34;&gt;JavaScript - &lt;code&gt;aya-create-one-line&lt;/code&gt;:&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#generating-comments&#34;&gt;Generating comments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#mixed-case-templates&#34;&gt;Mixed case templates&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#functions&#34;&gt;Functions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#aya-create&#34;&gt;aya-create&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#aya-expand&#34;&gt;aya-expand&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#aya-open-line&#34;&gt;aya-open-line&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abo-abo/auto-yasnippet/master/#aya-persist-snippet&#34;&gt;aya-persist-snippet&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;h1&gt;Installation instructions&lt;/h1&gt; &#xA;&lt;p&gt;It&#39;s easiest/recommended to install from &lt;a href=&#34;http://melpa.org/&#34;&gt;MELPA&lt;/a&gt;. Here&#39;s a minimal MELPA configuration for your &lt;code&gt;~/.emacs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(package-initialize)&#xA;(add-to-list &#39;package-archives &#39;(&#34;melpa&#34; . &#34;http://melpa.org/packages/&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Afterwards, &lt;kbd&gt;M-x package-install RET auto-yasnippet RET&lt;/kbd&gt; (you might want to &lt;kbd&gt;M-x package-refresh-contents RET&lt;/kbd&gt; beforehand if you haven&#39;t done so recently).&lt;/p&gt; &#xA;&lt;p&gt;You will also want to setup the key bindings. Here&#39;s what I recommend:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(global-set-key (kbd &#34;H-w&#34;) #&#39;aya-create)&#xA;(global-set-key (kbd &#34;H-y&#34;) #&#39;aya-expand)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I also like to bind this, instead of using &lt;kbd&gt;TAB&lt;/kbd&gt; to expand yasnippets:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(global-set-key (kbd &#34;C-o&#34;) #&#39;aya-open-line)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;A basic example&lt;/h2&gt; &#xA;&lt;p&gt;Suppose we want to write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;count_of_red = get_total(&#34;red&#34;);&#xA;count_of_blue = get_total(&#34;blue&#34;);&#xA;count_of_green = get_total(&#34;green&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We write a template, using ~ to represent variables that we want to replace:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;count_of_~red = get_total(&#34;~red&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Call &lt;code&gt;aya-create&lt;/code&gt; with point on this line, and the template is converted to a value we want:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;count_of_red = get_total(&#34;red&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then call &lt;code&gt;aya-expand&lt;/code&gt; and you can &#39;paste&#39; additional instances of the template. Yasnippet is active, so you can tab between placeholders as usual.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;count_of_red = get_total(&#34;red&#34;);&#xA;count_of_ = get_total(&#34;&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Inline text&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;~&lt;/code&gt; replaces the symbol after it. If you want to replace arbitrary text, use Emacs-style backticks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;`red&#39;_total = get_total(&#34;`red&#39;_values&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Multiple placeholders&lt;/h2&gt; &#xA;&lt;p&gt;You can replace multiple values in a template, just like normal yasnippet.&lt;/p&gt; &#xA;&lt;p&gt;In this example, our template has multiple lines, so we need to select the relevant lines before calling &lt;code&gt;aya-create&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;~FooType get~Foo() {&#xA;    // Get the ~foo attribute on this.&#xA;    return this.~foo;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We only fill in three placeholders in this example (the fourth is the same as the third).&lt;/p&gt; &#xA;&lt;h2&gt;JavaScript - &lt;code&gt;aya-create-one-line&lt;/code&gt;:&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;aya-create-one-line&lt;/code&gt; works as a combination of &lt;code&gt;aya-create&lt;/code&gt; and &lt;code&gt;aya-expand&lt;/code&gt; for one-line snippets. It&#39;s invoked by &lt;code&gt;aya-create&lt;/code&gt; in case there&#39;s no &lt;code&gt;aya-marker&lt;/code&gt; (default &lt;code&gt;~&lt;/code&gt;) on the line, but there&#39;s &lt;code&gt;aya-marker-one-line&lt;/code&gt; (default &lt;code&gt;$&lt;/code&gt;). Or you can invoke it on its own.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;field$ = document.getElementById(&#34;&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;call &lt;code&gt;aya-create&lt;/code&gt; and the rest is as before:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;field1 = document.getElementById(&#34;field1&#34;);&#xA;field2 = document.getElementById(&#34;field2&#34;);&#xA;field3 = document.getElementById(&#34;field3&#34;);&#xA;fieldFinal = document.getElementById(&#34;fieldFinal&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Generating comments&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a yasnippet that makes use of &lt;code&gt;aya-tab-position&lt;/code&gt;. You need to call &lt;code&gt;aya-open-line&lt;/code&gt; if you want to use it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# -*- mode: snippet -*-&#xA;# name: short comment&#xA;# key: sc&#xA;# --&#xA;//———$1${1:$(make-string (- 47 aya-tab-position (length yas-text)) ?—)}$0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Comments generated with this will always end in same column position, no matter from which indentation level they were invoked from.&lt;/p&gt; &#xA;&lt;h2&gt;Mixed case templates&lt;/h2&gt; &#xA;&lt;p&gt;You can create mixed case templates setting &lt;code&gt;aya-case-fold&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;. This will result in templates where variables that start with a character of a different case will be treated as the same variable. The case of the first character will be preserved in the resulting snippet.&lt;/p&gt; &#xA;&lt;p&gt;Using the earlier example with a slight twist:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;count_of_~red = get_total(&#34;~Red&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then calling &lt;code&gt;aya-create&lt;/code&gt;, then &lt;code&gt;aya-expand&lt;/code&gt;, and finally typing &lt;code&gt;blue&lt;/code&gt;, the result would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;count_of_blue = get_total(&#34;Blue&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that &lt;code&gt;blue&lt;/code&gt; was placed in both locations with proper casing.&lt;/p&gt; &#xA;&lt;h1&gt;Functions&lt;/h1&gt; &#xA;&lt;h2&gt;aya-create&lt;/h2&gt; &#xA;&lt;p&gt;Removes &#34;~&#34; from current line or region (if mark is active) yielding valid code. The created snippet is recorded into &lt;code&gt;aya-current&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;aya-expand&lt;/h2&gt; &#xA;&lt;p&gt;Expands whatever is currently in &lt;code&gt;aya-current&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;aya-open-line&lt;/h2&gt; &#xA;&lt;p&gt;Generic expansion function. It will either expand or move to the next field depending on the context.&lt;/p&gt; &#xA;&lt;h2&gt;aya-persist-snippet&lt;/h2&gt; &#xA;&lt;p&gt;Save the current auto-snippet to a user snippets folder (this defaults to &lt;code&gt;~/.emacs.d/snippets/&lt;/code&gt;.) The current &lt;code&gt;major-mode&lt;/code&gt; name will be used to determine the snippets sub-directory to store the snippet. For example when working in &lt;code&gt;js2-mode&lt;/code&gt; the snippet will be saved to (by default) &lt;code&gt;~/.emacs.d/snippets/js2-mode/&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You will be prompted for the snippet &lt;strong&gt;name&lt;/strong&gt;. The appropriate file will be opened but not saved, with the point on the &lt;code&gt;key: &lt;/code&gt; parameter of the snippet. If you wish to proceed, fill in the key, save the buffer and call &lt;kbd&gt;C-c C-l&lt;/kbd&gt; (&lt;code&gt;yas-load-snippet-buffer&lt;/code&gt;). Otherwise, simply kill the buffer - there will be no side effects.&lt;/p&gt; &#xA;&lt;p&gt;You can customize &lt;code&gt;aya-persist-snippets-dir&lt;/code&gt; to use a different folder for storing auto-snippets.&lt;/p&gt; &#xA;&lt;p&gt;You will need to run &lt;code&gt;yas/reload-all&lt;/code&gt; before using the new snippet with its &lt;strong&gt;key&lt;/strong&gt; trigger.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>haji-ali/transient-extras</title>
    <updated>2022-08-14T01:41:05Z</updated>
    <id>tag:github.com,2022-08-14:/haji-ali/transient-extras</id>
    <link href="https://github.com/haji-ali/transient-extras" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A transient menu for lp&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: transient-extras - Extensions and application menus based on transient #+author: Al Haji-Ali #+language: en #+export_file_name: transient-extras.texi #+texinfo_dir_category: Emacs misc features #+texinfo_dir_title: transient-extras: (transient-extras). #+texinfo_dir_desc: Extensions and application menus based on transient&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Introduction This package provides a set of extensions to [[https://github.com/magit/transient/][transient]] and interactive menus to common UNIX tools and applications.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;transient-extras-lp #+CAPTION: Printing menu [[file:transient-extras-lp.png]]&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=transient-extras-lp= provides a menu based on [[https://github.com/magit/transient/][transient]] to call the CUPS printing program =lp= on the current buffer or a selected file.&lt;/p&gt; &#xA;&lt;p&gt;=transient-extras-lp= can be enabled for =dired= and [[https://github.com/vedang/pdf-tools/][pdf-tools]] buffers as follows (make sure that =transient-extras.el= is in &lt;del&gt;load-path&lt;/del&gt;)&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (require &#39;transient-extras-lp)&lt;/p&gt; &#xA;&lt;p&gt;(with-eval-after-load &#39;dired (define-key dired-mode-map (kbd &#34;C-c C-p&#34;) #&#39;transient-extras-lp-menu))&lt;/p&gt; &#xA;&lt;p&gt;(with-eval-after-load &#39;pdf-tools (define-key pdf-misc-minor-mode-map (kbd &#34;C-c C-p&#34;) #&#39;transient-extras-lp-menu)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Or simply call =transient-extras-lp-menu= to print the current buffer or the selected files in =dired=. If a buffer has an associated file, the file is printed, otherwise the buffer content is sent to =lp=.&lt;/p&gt; &#xA;&lt;p&gt;** Additional Configuration By pressing =d=, you can input the name of the printer. The command =lpstat -a= is used to get a list of installed and network printers. If you have [[https://github.com/haji-ali/async-completing-read][async-completing-read]] installed then the command will be run asynchronously.&lt;/p&gt;</summary>
  </entry>
</feed>