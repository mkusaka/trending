<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-09T01:33:12Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ahyatt/triples</title>
    <updated>2022-12-09T01:33:12Z</updated>
    <id>tag:github.com,2022-12-09:/ahyatt/triples</id>
    <link href="https://github.com/ahyatt/triples" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An emacs module to manage a generic database of triples: subject, predicate, object data. This can be used for a variety of applications.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Triples&lt;/p&gt; &#xA;&lt;p&gt;The =triples= module is a standard database module designed for use in other emacs modules. It works with either the builtin sqlite in Emacs 29 or the [[https://github.com/magit/emacsql][emacsql]] module, and provides a simple way of storing entities and their associated schema. The triples module is well suited to graph-like applications, where links between entities are important. The module has wrappers for most common operations, but it is anticipated that occasionally client modules would need to make their own sqlite calls. Many different database instances can be handled by the =triples= module. It is expected that clients supply the database connection.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installing This module is available through GNU ELPA, and can be installed as normal. However, most of the time this module is only useful in concert with another module which uses it as a library and will declare it as a dependency, so unless you are planning on developing with it, there is usually no need to install it directly.&lt;/li&gt; &#xA; &lt;li&gt;Maturity This module is very new should be considered alpha quality.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;While it has basic functionality, there are significant parts, such as a querying language, that are missing. Whether anyone needs such parts will determine the priority in which they get built.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Types and Schema =triples= employs a design in which each entity can be a member of many /types/, and each /type/ has multiple /properties/. The properties that a type has is defined by /schema/. Let&#39;s take an example:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; We assume a database called db has already been set up. (triples-add-schema db &#39;person &#39;(name :base/unique t :base/type string) &#39;(age :base/unique t :base/type integer)) (triples-add-schema db &#39;employee &#39;(id :base/unique t :base/type integer) &#39;(manager :base/unique t) &#39;(reportees :base/virtual-reversed employee/manager)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This adds a type called =person=, which can be set on any entity. There&#39;s another type called =employee=, which can also be set, independently of other types. This schema is stored in the database itself, so the database can function properly regardless on what elisp has been loaded. The schema can be redefined multiple times without any issues.&lt;/p&gt; &#xA;&lt;p&gt;The =person= has 2 properties, =name=, and =age=. They are both marked as unique, so they take a single value, not a list. If =:base/unique= was not true, the value would be a list. We also specify what type it is, which can be any elisp type. =employee= is similarly constructed, but has an interesting property, =reportees=, which is a =base/virtual-reversed= property, meaning that it is supplied with values, but rather can get them from the reversed relation of =employee/manager=.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ll explore how these types are used can be used in the section after next.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The triples concept A triple is a unit of data consisting of a /subject/, a /predicate/, an /object/, and, optionally, internal metadata about the unit. The triple can be thought of as a link between the subject and object via the predicate.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s say that, as in the example above, we want to store someone&#39;s name. The triples would be a /subject/ that uniquely identifies the person, a /predicate/ that indicates the link between subject and object is about a name, and the object, which is the name value.&lt;/p&gt; &#xA;&lt;p&gt;The object can become the subject, and this explains how the =base/virtual-reversed= predicate works. If Bob is the manager of Alice, then there could be a triple with Alice as the subject, =manager= as the predicate, and Bob as the object. But we can also find the reversed links, and ask who all are all the people that Bob manages. In this case, Bob is the subject, and Alice is the object. However, we don&#39;t actually need to store this information and try to keep it in sync, we can just get it by querying for when the Bob is the object and =manager= is the predicate.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Setting and retrieving A subject can be set all at once (everything about the subject), or dealt with per-type. For example, the following are equivalent:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (triples-delete-subject db &#34;alice&#34;) (triples-set-type db &#34;alice&#34; &#39;person :name &#34;Alice Aardvark&#34; :age 41) (triples-set-type db &#34;alice&#34; &#39;employee :id 1901 :manager &#34;bob&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (triples-set-subject db &#34;alice&#34; &#39;(person :name &#34;Alice Aardvark&#34; :age 41) &#39;(employee :id 1901 :manager &#34;bob&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In the second, the setting of the entire subject implies deleting everything previously associated with it.&lt;/p&gt; &#xA;&lt;p&gt;Here is how the data is retrieved:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (triples-get-subject db &#34;alice&#34;) #+end_src Which returns, assuming we have &#34;catherine&#34; and &#34;dennis&#34; who have &#34;alice&#34; as their =employee/manager=: #+begin_src emacs-lisp &#39;(:person/name &#34;Alice Aardvark&#34; :person/age 41 :employee/id 1901 :employee/manager &#34;bob&#34; :employee/reportees &#39;(&#34;catherine&#34; &#34;dennis&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Or, #+begin_src emacs-lisp (triples-get-type db &#34;alice&#34; &#39;employee) #+end_src Which returns #+begin_src emacs-lisp &#39;(:manager &#34;bob&#34; :reportees &#39;(&#34;catherine&#34; &#34;dennis&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;There are other useful functions, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=triples-get-types=, which gets all the types a subject has,&lt;/li&gt; &#xA; &lt;li&gt;=triples-delete-subject=, which deletes all data associated with a subject,&lt;/li&gt; &#xA; &lt;li&gt;=triples-with-predicate=, gets all triples that is about a specific property,&lt;/li&gt; &#xA; &lt;li&gt;=triples-with-predicate-object=, get all subjects whose predicate is equal to /object/,&lt;/li&gt; &#xA; &lt;li&gt;=triples-subjects-of-type=, get all subjects which have a particular type.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Predicates, with type and without Sometimes the triples library will require predicates that are without type, and sometimes with type, or &#34;combined predicates&#34;. The rule is that if the type is already specified in the function, it does not need to be respecified. If the type is not specified, it is included in the combined predicate.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When returning data, if data is from just one type, the type is not returned in the returned predicates. If the data is from multiple types, the type is returned as combined predicates.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using direct SQL access Sometimes clients of this library need to do something with the database, and the higher-level triples functionality doesn&#39;t help. If you would like lower-level functionality into handling triples, you can use the same low-level methods that the rest of this library uses. These start with =triples-db-=.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=triples-db-insert=: Add a triple. Uses SQL&#39;s =REPLACE= command, so there can&#39;t be completely duplicate triples (including the property, which often can serve as a disambiguation mechanism).&lt;/li&gt; &#xA; &lt;li&gt;=triples-db-delete=: Delete triples matching the arguments. Empty arguments match everything, so =(triples-db-delete db)= will delete all triples.&lt;/li&gt; &#xA; &lt;li&gt;=triples-db-delete-subject-predicate-prefix=: Delete triples matching subjects and with predicates with a certain prefix. This can&#39;t be done with =triples-db-delete= because that method uses exact matching for all arguments, and this uses prefix matching for the predicate.&lt;/li&gt; &#xA; &lt;li&gt;=triples-db-select-predicate-object-fragment=: Select triples that contain an object partially in which the fragment appears.&lt;/li&gt; &#xA; &lt;li&gt;=triples-db-select=: Select triples matching any of the parts of the triple. Like =triples-db-delete=, empty arguments match everything. You can specify exactly what to return with a selector.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sometimes this still doesn&#39;t cover what you might want to do. In that case, you should write your own direct database access. However, please follow the coding patterns for the functions above in writing it, so that the code works with both Emacs 29&#39;s builtin sqlite, and =emacsql=.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mamapanda/evil-traces</title>
    <updated>2022-12-09T01:33:12Z</updated>
    <id>tag:github.com,2022-12-09:/mamapanda/evil-traces</id>
    <link href="https://github.com/mamapanda/evil-traces" rel="alternate"></link>
    <summary type="html">&lt;p&gt;some evil-ex command previews&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Evil Traces #+AUTHOR: Daniel Phan&lt;/p&gt; &#xA;&lt;p&gt;[[https://melpa.org/#/evil-traces][file:https://melpa.org/packages/evil-traces-badge.svg]] [[https://github.com/mamapanda/evil-traces/actions?query=workflow%3ACI][file:https://github.com/mamapanda/evil-traces/workflows/CI/badge.svg]]&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;evil-traces&lt;/del&gt; is a port of [[https://github.com/markonm/traces.vim][traces.vim]]. It enables visual previews for certain &lt;del&gt;evil-ex&lt;/del&gt; commands.&lt;/p&gt; &#xA;&lt;p&gt;Currently, these commands are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;change&lt;/li&gt; &#xA; &lt;li&gt;copy&lt;/li&gt; &#xA; &lt;li&gt;delete&lt;/li&gt; &#xA; &lt;li&gt;global&lt;/li&gt; &#xA; &lt;li&gt;join&lt;/li&gt; &#xA; &lt;li&gt;move&lt;/li&gt; &#xA; &lt;li&gt;normal&lt;/li&gt; &#xA; &lt;li&gt;shell command&lt;/li&gt; &#xA; &lt;li&gt;sort&lt;/li&gt; &#xA; &lt;li&gt;substitute &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;evil-traces&lt;/del&gt; reuses &lt;del&gt;evil&lt;/del&gt;&#39;s runner function for replacement and match previews&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;vglobal&lt;/li&gt; &#xA; &lt;li&gt;yank&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Basic Example This package can be installed from MELPA with &lt;del&gt;M-x package-install [RET] evil-traces [RET]&lt;/del&gt;. Here&#39;s a basic setup with &lt;del&gt;use-package&lt;/del&gt;:&lt;/p&gt; &lt;p&gt;#+BEGIN_SRC emacs-lisp (use-package evil-traces :config (evil-traces-use-diff-faces) ; if you want to use diff&#39;s faces (evil-traces-mode)) #+END_SRC&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Customization To view all available faces and options, see &lt;del&gt;M-x customize-group [RET] evil-traces [RET]&lt;/del&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Faces &lt;del&gt;evil-traces&lt;/del&gt; uses the following faces:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-default&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-change&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-copy-preview&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-copy-range&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-delete&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-global-match&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-global-range&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-join-indicator&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-join-range&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-move-preview&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-move-range&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-normal&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-shell-command&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-sort&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-substitute-range&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;evil-traces-yank&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default, most faces inherit from &lt;del&gt;evil-traces-default&lt;/del&gt;, which inherits from &lt;del&gt;region&lt;/del&gt;. You may use &lt;del&gt;custom-set-faces&lt;/del&gt; to edit face values:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (custom-set-faces &#39;(evil-traces-join-indicator ((t (:inherit diff-added)))) &#39;(evil-traces-join-range ((t (:inherit diff-changed)))) ;; etc. ) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can set the faces with &lt;del&gt;evil-traces-use-diff-faces&lt;/del&gt; or &lt;del&gt;evil-traces-use-diff-refine-faces&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;** Variables The idle update delay is controlled by &lt;del&gt;evil-traces-idle-delay&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (setq evil-traces-idle-delay 0.05) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Warnings and information can be enabled or disabled through &lt;del&gt;evil-traces-enable-echo&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (setq evil-traces-enable-echo t) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Visual previews can be suspended through &lt;del&gt;evil-traces-suspend-function&lt;/del&gt;. &lt;del&gt;evil-traces-suspend-function&lt;/del&gt; takes no arguments and returns non-nil when previews should not be shown.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (defun my-evil-traces-suspend-p () &#34;Return non-nil if both &lt;code&gt;evil-ex-range&#39; and &lt;/code&gt;evil-ex-argument&#39; are nil.&#34; (and (null evil-ex-range) (null evil-ex-argument)))&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; ;; Only show previews if a range or argument has been typed.&#xA; (setq evil-traces-suspend-function #&#39;my-evil-traces-suspend-p)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;evil-traces-join-indicator&lt;/del&gt; and &lt;del&gt;evil-traces-join-indicator-padding&lt;/del&gt; control the appearance of &lt;del&gt;:join&lt;/del&gt;&#39;s end-of-line indicators.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (setq evil-traces-join-indicator &#34;&amp;lt;&amp;lt;&amp;lt;&#34; evil-traces-join-indicator-padding 2) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;evil-traces-argument-type-alist&lt;/del&gt; determines what argument type each ex command gets mapped to when &lt;del&gt;evil-traces-mode&lt;/del&gt; is on. &lt;del&gt;evil&lt;/del&gt; uses the argument type to determine which highlighting function to use, so this variable can be modified to change highlighting behavior. For example,&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp ;; Enable :change when lispyville-mode is on (add-to-list &#39;evil-traces-argument-type-alist &#39;(lispyville-change . evil-traces-change))&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; ;; You can use :delete&#39;s preview for :move if :move&#39;s annoys you.&#xA; (add-to-list &#39;evil-traces-argument-type-alist &#39;(evil-move . evil-traces-delete))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;If you want to add your own argument type, take a look at &lt;del&gt;evil-traces-deftype&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Sample GIFs &lt;del&gt;:delete&lt;/del&gt;&lt;/p&gt; &lt;p&gt;[[./img/delete.gif]]&lt;/p&gt; &lt;p&gt;&lt;del&gt;:global&lt;/del&gt;&lt;/p&gt; &lt;p&gt;[[./img/global.gif]]&lt;/p&gt; &lt;p&gt;&lt;del&gt;:join&lt;/del&gt;&lt;/p&gt; &lt;p&gt;[[./img/join.gif]]&lt;/p&gt; &lt;p&gt;&lt;del&gt;:move&lt;/del&gt;&lt;/p&gt; &lt;p&gt;[[./img/move.gif]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Inspirations&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[https://github.com/edkolev/evil-goggles][evil-goggles]]&lt;/li&gt; &#xA;   &lt;li&gt;[[https://github.com/markonm/traces.vim][traces.vim]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>AndreySV/dotfiles</title>
    <updated>2022-12-09T01:33:12Z</updated>
    <id>tag:github.com,2022-12-09:/AndreySV/dotfiles</id>
    <link href="https://github.com/AndreySV/dotfiles" rel="alternate"></link>
    <summary type="html">&lt;p&gt;~/.* files ( .vimrc, .bashrc, .bash_profile, .bash_aliases, ... )&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;dotfiles&lt;/h1&gt; &#xA;&lt;p&gt;~/.* files ( .vimrc, .bashrc, .bash_profile, .bash_aliases, ... )&lt;/p&gt;</summary>
  </entry>
</feed>