<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-13T01:40:09Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>progfolio/elpaca</title>
    <updated>2022-08-13T01:40:09Z</updated>
    <id>tag:github.com,2022-08-13:/progfolio/elpaca</id>
    <link href="https://github.com/progfolio/elpaca" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An elisp package manager&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: Elpaca: An Elisp Package Manager #+author: Nicholas Vollmer #+options: exports:both&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;/p&gt;&#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/progfolio/elpaca/master/images/elpaca.svg?sanitize=true&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;/p&gt;&#xA;&lt;p align=&#34;center&#34;&gt; &#34;Chews data, spits packages.&#34;&lt;/p&gt;&#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;Elpaca is an elisp package manager. It allows users to find, install, update, and remove third-party packages for Emacs. It is a replacement for the built-in Emacs package manager, package.el.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation If you&#39;re impatient, take a look at the [[#example-configuration][example configuration]] ** Requirements&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Emacs &amp;gt;= 27.1&lt;/li&gt; &#xA; &lt;li&gt;git (minimum version TBD)&lt;/li&gt; &#xA; &lt;li&gt;Windows users must be able to create symlinks. ** Bootstrap Snippet To install Elpaca, add the following bootstrapping snippet to your init.el. It must come before any calls to other Elpaca functions/macros. This will clone Elpaca into your =user-emacs-directory= under the =elpaca= subdirectory. It then builds and activates Elpaca.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (declare-function elpaca-generate-autoloads &#34;elpaca&#34;) (defvar elpaca-directory (expand-file-name &#34;elpaca/&#34; user-emacs-directory)) (when-let ((elpaca-repo (expand-file-name &#34;repos/elpaca/&#34; elpaca-directory)) (elpaca-build (expand-file-name &#34;builds/elpaca/&#34; elpaca-directory)) (elpaca-target (if (file-exists-p elpaca-build) elpaca-build elpaca-repo)) (elpaca-url &#34;&lt;a href=&#34;https://www.github.com/progfolio/elpaca.git&#34;&gt;https://www.github.com/progfolio/elpaca.git&lt;/a&gt;&#34;) ((add-to-list &#39;load-path elpaca-target)) ((not (file-exists-p elpaca-repo))) (buffer (get-buffer-create &#34;&lt;em&gt;elpaca-bootstrap&lt;/em&gt;&#34;))) (condition-case-unless-debug err (progn (unless (zerop (call-process &#34;git&#34; nil buffer t &#34;clone&#34; elpaca-url elpaca-repo)) (error &#34;%s&#34; (list (with-current-buffer buffer (buffer-string))))) (byte-recompile-directory elpaca-repo 0 &#39;force) (require &#39;elpaca) (elpaca-generate-autoloads &#34;elpaca&#34; elpaca-repo) (kill-buffer buffer)) ((error) (delete-directory elpaca-directory &#39;recursive) (with-current-buffer buffer (goto-char (point-max)) (insert (format &#34;\n%S&#34; err)) (display-buffer buffer))))) (require &#39;elpaca-autoloads) (add-hook &#39;after-init-hook #&#39;elpaca-process-queues) (elpaca (elpaca :host github :repo &#34;progfolio/elpaca&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll also want to disable package.el in your [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][early-init file]], and remove anything related to package.el in your init file. e.g. calls to &lt;del&gt;(package-activate-all)&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (setq package-enable-at-startup nil) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Basic concepts&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The =elpaca-example= macro in the following examples reduces verbosity. It is not part of Elpaca.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t :exports none :results silent (defun elpaca-example-sort-plist (plist) &#34;Return copy of PLIST with :package followed by lexically sorted kew/val pairs.&#34; `(:package ,(plist-get plist :package) ,@(cl-loop for k in (cl-sort (cl-loop for key in plist by #&#39;cddr unless (eq key :package) collect key) #&#39;string&amp;lt; :key #&#39;symbol-name) append (list k (plist-get plist k)))))&lt;/p&gt; &#xA;&lt;p&gt;(defmacro elpaca-example (&amp;amp;rest body) &#34;Execute BODY with a clean elpaca environment.&#34; `(let (elpaca-cache-menu-items elpaca-order-functions elpaca-recipe-functions (elpaca-menu-functions &#39;(elpaca-example-menu))) (elpaca-example-sort-plist ,@body))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Examples will use the following [[#menus][recipe menu]], which offers a &#34;burger&#34; package recipe:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t :results silent (defun elpaca-example-menu (_) &#39;((burger . (:recipe (:buns 2 :lettuce t :tomato t :beef t :cheese t :cook well-done :from elpaca-example-menu))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Recipes :PROPERTIES: :CUSTOM_ID: recipes :END: A recipe provides Elpaca with the metadata necessary to build and install a package. It is a list of the form:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (ITEM . PROPS) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;/ITEM/ is a symbol uniquely identifying the package. /PROPS/ is a plist with any of the following recipe keywords:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;:host | :fetcher :: A symbol or string representing the hosting service of the repository.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github) (example :fetcher gitlab) (example :host &#34;www.example.com&#34;) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;:repo :: A string of the form =USER/REPO=.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github :repo &#34;user/example&#34;) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;:branch :: The repository branch to check out when installing the package.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github :repo &#34;user/example&#34; :branch &#34;main&#34;) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;:tag :: The tag to check out when installing the package.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github :repo &#34;user/example&#34; :tag &#34;v1.0&#34;) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;:ref :: The [[https://git-scm.com/book/en/v2/Git-Internals-Git-References][git ref]] to check out when installing the package.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github :repo &#34;user/example&#34; :ref &#34;a76ca0a&#34;) ;; Check out a specific commit. #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;:depth :: The package repository&#39;s history depth.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (example :depth 1) ;; Shallow clone with history truncated to 1 commit. (example :depth nil) ;; Full repository clone. #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;:remotes :: A list of repository [[https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes][remotes]]. The first element is the default remote when installing the package. If it is a string, it names the default remote. The remaining elements are lists of the form:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (NAME . PROPS) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;/NAME/ is a string used to name the remote. /PROPS/ are recipe keyword/value pairs used to override values previously declared in the recipe.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (example :remotes (&#34;origin&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (example :host github :repo &#34;original/example&#34; :remotes (&#34;origin&#34; (&#34;fork&#34; :host gitlab :repo &#34;user/example-fork.el&#34;))) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;:main :: The name of the main elisp file. When provided this can speed up the process of cloning and loading a package&#39;s dependencies.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (example :main &#34;example.el&#34;) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;:build :: A list of build steps, nil or t. If the list starts with the symbol =:not=. The set difference of =elpaca-default-build-steps= and the remaining elements of the list are used.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (example :build (:not autoloads)) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;:inherit :: When non-nil, inherit /PROPS/ from =elpaca-order-functions= and possibly =elpaca-menu-functions=. For example, without inheritance: #+name: recipe-inheritance-nil #+begin_src emacs-lisp :lexical t :results raw code :exports both (elpaca-example (elpaca-recipe &#39;(burger :inherit nil))) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;returns the recipe as declared:&lt;/p&gt; &#xA;&lt;p&gt;#+results: recipe-inheritance-nil #+begin_src emacs-lisp (:package &#34;burger&#34; :inherit nil) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;With inheritance enabled: #+name: recipe-inheritance-menu #+begin_src emacs-lisp :lexical t :results raw code :exports both (elpaca-example (elpaca-recipe &#39;(burger :inherit t))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;the elpaca-example-menu provides the rest of the &#34;burger&#34; recipe.&lt;/p&gt; &#xA;&lt;p&gt;#+results: recipe-inheritance-menu #+begin_src emacs-lisp (:package &#34;burger&#34; :beef t :buns 2 :cheese t :cook well-done :from elpaca-example-menu :inherit t :lettuce t :tomato t) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Inheritance precedence :PROPERTIES: :CUSTOM_ID: inheritance-precedence :END: The following list shows the order of precedence for inheritance. Each item takes precedence over the items which follow it.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;elpaca-recipe-functions&lt;/li&gt; &#xA; &lt;li&gt;declared recipe&lt;/li&gt; &#xA; &lt;li&gt;elpaca-order-functions&lt;/li&gt; &#xA; &lt;li&gt;elpaca-menu-functions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+name: recipe-inheritance-precedence #+begin_src emacs-lisp :lexical t :results raw code :exports both (elpaca-example (let ((elpaca-recipe-functions (lambda (recipe) &#39;(:from recipe-functions :cheese extra))) (elpaca-order-functions (lambda (order) &#39;(:from order-functions :tomato nil)))) (elpaca-recipe &#39;(burger)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+results: recipe-inheritance-precedence #+begin_src emacs-lisp (:package &#34;burger&#34; :beef t :buns 2 :cheese extra :cook well-done :from recipe-functions :lettuce t :tomato nil) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** elpaca-recipe-functions :PROPERTIES: :CUSTOM_ID: elpaca-recipe-functions :END: The abnormal hook =elpaca-recipe-functions= runs via =run-hook-with-args-until-success= just before installing the package. Each function in the list should accept the current recipe as its sole argument and return either nil or a plist. The first function to return a plist has its return value merged with the current recipe.&lt;/p&gt; &#xA;&lt;p&gt;This is useful if you want to guarantee the values of certain keywords despite allowing recipe inheritance.&lt;/p&gt; &#xA;&lt;p&gt;#+name: recipe-functions-example #+begin_src emacs-lisp :lexical t :exports both :results raw code (elpaca-example (let ((elpaca-recipe-functions &#39;((lambda (recipe) &#34;If a recipe calls for cheese, I always want extra.&#34; (when (plist-get recipe :cheese) (list :cheese &#39;extra)))))) (elpaca-recipe &#39;(burger)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+results: recipe-functions-example #+begin_src emacs-lisp (:package &#34;burger&#34; :beef t :buns 2 :cheese extra :cook well-done :from elpaca-example-menu :lettuce t :tomato t) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Menus :PROPERTIES: :CUSTOM_ID: menus :END: A menu is a function which returns an alist of the form: #+begin_src emacs-lisp :lexical t ((ITEM . DATA)...) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;/ITEM/ is a symbol uniquely identifying a package. /DATA/ is a plist of package metadata. /DATA/ must contain the following keywords:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;:recipe :: A package [[#recipes][recipe.]]&lt;/li&gt; &#xA; &lt;li&gt;:source :: A string naming the menu.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It may also provide additional information about a package. For example, the Elpaca UI utilizes the following keywords when present:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;:url :: The package&#39;s website URL.&lt;/li&gt; &#xA; &lt;li&gt;:description :: A description of the package.&lt;/li&gt; &#xA; &lt;li&gt;:date :: The time of package&#39;s last update.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The function must accept one of the following /REQUEST/ symbols as an argument:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;index :: Return the alist described above&lt;/li&gt; &#xA; &lt;li&gt;update :: update the menu&#39;s alist.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (defun elpaca-menu-minimal (request_) &#34;A minimal menu example. Ignore REQUEST, as this is a static, curated list of packages.&#34; &#39;((example :source &#34;EXAMPLE&#34; :recipe (example :host github :repo &#34;user/example&#34;)) (two :source &#34;EXAMPLE&#34; :recipe (two :host gitlab :repo &#34;user/two&#34;)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Menus allow one to offer Elpaca users curated lists of package recipes. For example, [[https://www.github.com/progfolio/melpulls][melpulls]] implements an Elpaca menu for pending MELPA packages.&lt;/p&gt; &#xA;&lt;p&gt;*** elpaca-menu-functions The =elpaca-menu-functions= variable contains menu functions for the following package sources by default:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://www.github.com/melpa/melpa][MELPA]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://git.savannah.gnu.org/cgit/emacs/org-mode.git/][Org]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://git.sr.ht/~bzg/org-contrib][Org-contrib]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://www.github.com/emacs-straight/gnu-elpa-mirror][GNU ELPA Mirror]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://elpa.nongnu.org][NonGNU ELPA]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Menus are checked in order until one returns the requested menu item or the menu list is exhausted.&lt;/p&gt; &#xA;&lt;p&gt;** Orders :PROPERTIES: :CUSTOM_ID: orders :END:&lt;/p&gt; &#xA;&lt;p&gt;At a minimum, an order is a symbol which represents the name of a [[#menus][menu]] item:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca &#39;example) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;An order may also be a partial or full recipe:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca &#39;(example :host gitlab)) (elpaca &#39;(example :host gitlab :repo &#34;user/example&#34; :inherit nil)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** elpaca-order-functions The abnormal hook =elpaca-order-functions= runs via =run-hook-with-args-until-success= before =elpaca-menu-functions=. Each function in the list should accept the current order as its sole argument and return either nil or a plist. The first function to return a plist has its return value merged with the current order.&lt;/p&gt; &#xA;&lt;p&gt;This is useful for declaring default order properties. For example, the following function disables recipe inheritance by default:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t :results raw code :exports both (elpaca-example (let ((elpaca-order-functions &#39;((lambda (_) &#39;(:inherit nil))))) (elpaca-recipe &#39;burger))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: #+begin_src emacs-lisp (:package &#34;burger&#34; :inherit nil) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Queues :PROPERTIES: :CUSTOM_ID: queues :END: Elpaca installs packages asynchronously. [[#orders][Orders]] are automatically queued in a list. A queue is considered &#34;processed&#34; when all of its orders have either finished or failed.&lt;/p&gt; &#xA;&lt;p&gt;Queues make it possible to ensure a package is installed, activated, and configured prior to other packages. The =elpaca-queue= macro wraps calls to =elpaca=, ensuring those orders are processed in their own queue. This is especially useful when one wants to install a package to use later on in their init file. For example, a package which implements an Elpaca [[#menus][menu]]:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca-queue (elpaca &#39;(melpulls :host github :repo &#34;progfolio/melpulls&#34;)) (add-to-list &#39;elpaca-menu-functions #&#39;melpulls) (elpaca-update-menus #&#39;melpulls)) ;; Implicitly queued into a new queue. (elpaca &#39;menu-item-available-in-melpulls) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installing Packages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;elpaca :: =(order &amp;amp;rest body)= Installs /ORDER/ and executes /BODY/ after processing ORDER&#39;s [[#queues][queue]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;/ORDER/ is an [[#orders][order]] as described above.&lt;/p&gt; &#xA;&lt;p&gt;This macro is for programmatic use in one&#39;s init file. Any of the following will install the &#34;example&#34; package:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca example) ;; recipe looked up in `elpaca-menu-functions&#39;. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca example (message &#34;Messaged after the order&#39;s queue has processed.&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca (example :host github :repo &#34;user/example&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca `(example :host github :repo &#34;user/example&#34; ,@(when (eq system-type &#39;darwin) ;; backqouting supported (list :pre-build ((message &#34;Mac specific pre-build&#34;)))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If /ORDER/ is nil, /BODY/ is still executed after processing the current [[#queues][queue]].&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca &#39;first (message &#34;First configured&#34;)) ;; If this weren&#39;t wrapped in an `elpaca&#39; call, it would be executed FIRST ;; Due to the &#34;first&#34; and &#34;third&#34; package installing asynchronously. (elpaca nil (message &#34;Second&#34;)) (elpaca &#39;third (message &#34;Third configured&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;elpaca-use-package :: =(order &amp;amp;rest body)=&lt;/p&gt; &lt;p&gt;A wrapper for the [[https://github.com/jwiegley/use-package][use-package]] macro. /ORDER/ is the same as above. /BODY/ must conform to use-package&#39;s /ARGS/.&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp :lexical t (elpaca use-package (require &#39;use-package)) ; install use-package (elpaca-use-package (example :host github :repo &#34;user/example&#34;) :config (message &#34;Example configured&#34;)) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Finding, Updating, Removing Packages The =elpaca-manger= command will pop to the Elpaca manager buffer. From this buffer you can search and act on all the packages Elpaca knows about.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following commands are available in the Elpaca manager buffer:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t :exports results table replace (with-temp-buffer (describe-map-tree elpaca-ui-mode-map) (goto-char (point-min)) (let (rows) (while (re-search-forward &#34;elpaca&#34; nil &#39;noerror) (push (split-string (buffer-substring-no-properties (line-beginning-position) (line-end-position)) &#34;\t+&#34;) rows)) (setq rows (mapcar (lambda (it) (append (list (car (split-string (documentation (intern (cadr it))) &#34;\n&#34;))) it)) rows)) (setq rows (cl-sort (mapcar #&#39;nreverse rows) #&#39;string&amp;lt; :key #&#39;cadr)) (push &#39;hline rows) (push (list &#34;Command&#34; &#34;Default Binding&#34; &#34;Description&#34;) rows) rows)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: | Command | Default Binding | Description | |----------------------------+-----------------+-----------------------------------------------------------------| | elpaca-ui-send-input | ! | Send input string to current process. | | elpaca-ui-search-installed | I | Search for &#34;#unique #installed&#34; | | elpaca-ui-search-marked | M | Search for &#34;#unique #marked&#34; | | elpaca-ui-search-orphaned | O | Search for &#34;#unique #orphan&#34; | | elpaca-ui-search-refresh | R | Rerun the current search for BUFFER. | | elpaca-ui-search-tried | T | Search for &#34;#unique #installed !#declared&#34; | | elpaca-ui-unmark | U | Unmark current package. | | elpaca-ui-browse-package | b | Browse current package’s URL via ‘browse-url’. | | elpaca-ui-mark-delete | d | Mark package for delete action. | | elpaca-ui-mark-install | i | Mark package for install action. | | elpaca-log | l | Display ‘elpaca-log-buffer’. | | elpaca-manager | m | Display elpaca’s package management UI. | | elpaca-ui-mark-rebuild | r | Mark package for rebuild action. | | elpaca-ui-search | s | Filter current buffer by QUERY. If QUERY is nil, prompt for it. | | elpaca-status | t | Log most recent events for packages. | | elpaca-ui-mark-update | u | Mark package for update action. | | elpaca-ui-visit-build | v b | Visit builds dir associated with current package. | | elpaca-ui-visit-repo | v r | Visit repo associated with current package. | | elpaca-ui-execute-marks | x | Execute each action in ‘elpaca-ui-marked-packages’. |&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example configuration :PROPERTIES: :CUSTOM_ID: example-configuration :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following is an example init.el using Elpaca:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp :lexical t :tangle ./test/example-init.el :results silent ;;; init-elpaca.el --- ELPACA INIT DEMO -&lt;em&gt;- lexical-binding: t; -&lt;/em&gt;- ;; Bootstrap Elpaca (declare-function elpaca-generate-autoloads &#34;elpaca&#34;) (defvar elpaca-directory (expand-file-name &#34;elpaca/&#34; user-emacs-directory)) (when-let ((elpaca-repo (expand-file-name &#34;repos/elpaca/&#34; elpaca-directory)) (elpaca-build (expand-file-name &#34;builds/elpaca/&#34; elpaca-directory)) (elpaca-target (if (file-exists-p elpaca-build) elpaca-build elpaca-repo)) (elpaca-url &#34;&lt;a href=&#34;https://www.github.com/progfolio/elpaca.git&#34;&gt;https://www.github.com/progfolio/elpaca.git&lt;/a&gt;&#34;) ((add-to-list &#39;load-path elpaca-target)) ((not (file-exists-p elpaca-repo))) (buffer (get-buffer-create &#34;&lt;em&gt;elpaca-bootstrap&lt;/em&gt;&#34;))) (condition-case-unless-debug err (progn (unless (zerop (call-process &#34;git&#34; nil buffer t &#34;clone&#34; elpaca-url elpaca-repo)) (error &#34;%s&#34; (list (with-current-buffer buffer (buffer-string))))) (byte-recompile-directory elpaca-repo 0 &#39;force) (require &#39;elpaca) (elpaca-generate-autoloads &#34;elpaca&#34; elpaca-repo) (kill-buffer buffer)) ((error) (delete-directory elpaca-directory &#39;recursive) (with-current-buffer buffer (goto-char (point-max)) (insert (format &#34;\n%S&#34; err)) (display-buffer buffer))))) (require &#39;elpaca-autoloads) (add-hook &#39;after-init-hook #&#39;elpaca-process-queues) (elpaca (elpaca :host github :repo &#34;progfolio/elpaca&#34;))&lt;/p&gt; &#xA;&lt;p&gt;;; Install use-package (elpaca use-package (require &#39;use-package)) ;; Install evil and configure via `use-package&#39; (elpaca-use-package evil :demand t) ;; Install a package from a user-provided recipe (elpaca (yodel :host github :repo &#34;progfolio/yodel&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;h1&gt;LocalWords: elpaca Elpaca elisp repo minibuffer website init ui UI unmark Unmark plist alist MELPA programmatic&lt;/h1&gt;</summary>
  </entry>
  <entry>
    <title>emacs-lsp/lsp-docker</title>
    <updated>2022-08-13T01:40:09Z</updated>
    <id>tag:github.com,2022-08-13:/emacs-lsp/lsp-docker</id>
    <link href="https://github.com/emacs-lsp/lsp-docker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scripts and configurations to leverage lsp-mode in docker environment&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+ATTR_HTML: align=&#34;center&#34;; margin-right=&#34;auto&#34;; margin-left=&#34;auto&#34; =lsp-mode= uses =lsp-docker= to run language servers using in containers&lt;/p&gt; &#xA;&lt;p&gt;[[./images/logo.png]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Table of Contents :TOC_4_gh:noexport: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#preconfigured-language-servers][Preconfigured language servers]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#usage][Usage]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#emacslsplsp-docker-langservers][emacslsp/lsp-docker-langservers]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#configuration][Configuration]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#how-it-works][How it works]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#emacslsplsp-docker-full][emacslsp/lsp-docker-full]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#flags][Flags]] &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;[[#emacs][Emacs]]&lt;/li&gt; &#xA;       &lt;li&gt;[[#spacemacs][Spacemacs]]&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#custom-language-server-containers][Custom language server containers]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#docker-over-tramp-tbd][Docker over TRAMP (TBD)]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#see-also][See also]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#maintainers][Maintainers]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Preconfigured language servers =emacslsp/lsp-docker-langservers= has the following content:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Language servers: | Language | Language Server | |-----------------------+-----------------------------------| | Bash | [[https://github.com/mads-hartmann/bash-language-server][bash-language-server]] | | C++ | [[https://github.com/MaskRay/ccls][ccls]] | | CSS/LessCSS/SASS/SCSS | [[https://github.com/vscode-langservers/vscode-css-languageserver-bin][css]] | | Dockerfile | [[https://github.com/rcjsuen/dockerfile-language-server-nodejs][dockerfile-language-server-nodejs]] | | Go | [[https://golang.org/x/tools/cmd/gopls][gopls]] | | HTML | [[https://github.com/vscode-langservers/vscode-html-languageserver][html]] | | JavaScript/TypeScript | [[https://github.com/theia-ide/typescript-language-server][typescript-language-server]] | | Python | [[https://github.com/palantir/python-language-server][pyls]] | ** Usage There are two ways of working with containerized language servers:&lt;/li&gt; &#xA; &lt;li&gt;2 containers provided by =lsp-docker=: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#emacslsplsp-docker-langservers][emacslsp/lsp-docker-langservers]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#emacslsplsp-docker-full][emacslsp/lsp-docker-full]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#custom-language-server-containers][Custom language server containers]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** emacslsp/lsp-docker-langservers This container is used by =lsp-docker= to run =Language Servers= for =lsp-mode= over local sources. =You must pull the container before lsp-docker can use it= *** Configuration - Clone the repo #+begin_src bash git clone &lt;a href=&#34;https://github.com/emacs-lsp/lsp-docker&#34;&gt;https://github.com/emacs-lsp/lsp-docker&lt;/a&gt; #+end_src - Pull the container #+begin_src bash docker pull emacslsp/lsp-docker-langservers #+end_src - Add repo to load path and register the docker clients in your =~/.emacs= file #+begin_src elisp ;; Uncomment the next line if you are using this from source ;; (add-to-list &#39;load-path &#34;&#xA; &lt;path-to-lsp-docker-dir&gt;&#xA;  &#34;) (require &#39;lsp-docker)&#xA; &lt;/path-to-lsp-docker-dir&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  (defvar lsp-docker-client-packages&#xA;      &#39;(lsp-css lsp-clients lsp-bash lsp-go lsp-pyls lsp-html lsp-typescript&#xA;        lsp-terraform lsp-clangd))&#xA;&#xA;  (setq lsp-docker-client-configs&#xA;      &#39;((:server-id bash-ls :docker-server-id bashls-docker :server-command &#34;bash-language-server start&#34;)&#xA;        (:server-id clangd :docker-server-id clangd-docker :server-command &#34;clangd&#34;)&#xA;        (:server-id css-ls :docker-server-id cssls-docker :server-command &#34;css-languageserver --stdio&#34;)&#xA;        (:server-id dockerfile-ls :docker-server-id dockerfilels-docker :server-command &#34;docker-langserver --stdio&#34;)&#xA;        (:server-id gopls :docker-server-id gopls-docker :server-command &#34;gopls&#34;)&#xA;        (:server-id html-ls :docker-server-id htmls-docker :server-command &#34;html-languageserver --stdio&#34;)&#xA;        (:server-id pyls :docker-server-id pyls-docker :server-command &#34;pyls&#34;)&#xA;        (:server-id ts-ls :docker-server-id tsls-docker :server-command &#34;typescript-language-server --stdio&#34;)))&#xA;&#xA;  (require &#39;lsp-docker)&#xA;  (lsp-docker-init-clients&#xA;    :path-mappings &#39;((&#34;path-to-projects-you-want-to-use&#34; . &#34;/projects&#34;))&#xA;    :client-packages lsp-docker-client-packages&#xA;    :client-configs lsp-docker-client-configs)&#xA;  #+end_src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** How it works =lsp-mode= starts the image passed as =:docker-image-id= and mounts =:path-mappings= in the container. Then when the process is started =lsp-mode= translates the local paths to =docker= path and vice versa using the =:path-mappings= specified when calling =lsp-docker-init-default-clients=. You may use =lsp-enabled-clients= and =lsp-disabled-clients= to control what language server will be used to run for a particular project(refer to =lsp-mode= FAQ on how to configure .dir-locals).&lt;/p&gt; &#xA;&lt;p&gt;** emacslsp/lsp-docker-full The container =emacslsp/lsp-docker-full= contains: - The above language servers - =Emacs28= compiled with native JSON support for better performance. *** Flags | Flag | Purpose | Default | |-----------------+----------------------------------------+-------------------------------------------------------| | EMACS_D_VOLUME | Emacs folder to use for =/root/.emacs= | Emacs: =$(pwd)/emacs.d= Spacemacs: =$(pwd)/spacemacs= | | PROJECTS_VOLUME | Directory to mount at /Projects | =$(pwd)/demo-projects/= | | TZ | Timezone to user in container | Europe/Minsk | | DOCKER_FLAGS | Any additional docker flags | N/A | **** Emacs - Clone =lsp-docker=. #+begin_src bash git clone &lt;a href=&#34;https://github.com/emacs-lsp/lsp-docker&#34;&gt;https://github.com/emacs-lsp/lsp-docker&lt;/a&gt; cd lsp-docker #+end_src - Run #+begin_src bash bash start-emacs.sh #+end_src **** Spacemacs - Clone =lsp-docker=. #+begin_src bash git clone &lt;a href=&#34;https://github.com/emacs-lsp/lsp-docker&#34;&gt;https://github.com/emacs-lsp/lsp-docker&lt;/a&gt; cd lsp-docker #+end_src - Clone spacemacs repo #+begin_src bash # Clone spacemacs develop git clone -b develop &lt;a href=&#34;https://github.com/syl20bnr/spacemacs&#34;&gt;https://github.com/syl20bnr/spacemacs&lt;/a&gt; spacemacs #+end_src - Run #+begin_src bash EMACS_D_VOLUME=/path/to/spacemacs bash start-spacemacs.sh #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Custom language server containers&lt;br&gt; You can use manually built language containers or images hosting language server(s), just follow a few simple rules (shown below).&lt;/p&gt; &#xA;&lt;p&gt;*** Building a container (or an image): You have 2 constraints: - A language server must be launched in =stdio= mode (other types of communication are yet to be supported) - A docker container (only =container= subtype, see the configuration below) must have your language server as an entrypoint (basically you have to be able to launch it with =docker start -i &amp;lt;container_name&amp;gt;= as it is launched this way with =lsp-docker=)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;When you have sucessfully built a language server, you have to register it with either a configuration file or a =.dir-locals= file.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Registering a language server using a persistent configuration file: A configuration file is a yaml file that is named =.lsp-docker.yml= or =.lsp-docker.yaml= and looks generally like this: #+begin_src yaml lsp: server: type: docker subtype: container # Or image. container subtype means launching an existing container # image subtype means creating a new container each time from a specified image name: not-significant-but-unique-name # Must be unique across all language servers server: server-id-of-the-base-server # Server id of a registered server (by lsp-mode) launch_command: &#34;launch command with arguments&#34; # Launch command of the language server # (selected by a server id specified above) in stdio mode # Note: launch_command is not used with container subtype servers # as a command is embedded in a container itself and serves as an entrypoint mappings: - source: &#34;/your/host/source/path&#34; destination: &#34;/your/local/path/inside/a/container&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Registering a language server using a =.dir-locals= file: Just refer to the source code and general conventions of using =.dir-locals=. The variable you need is =lsp-docker-persistent-default-config=, its content is merged with the =lsp= section from a configuration file (if present).&lt;/p&gt; &#xA;&lt;p&gt;** Docker over TRAMP (TBD) Docker running the language servers and hosting the sources, Emacs running on the desktop machine and connecting to docker instance over TRAMP. ** See also&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/Silex/docker.el][docker]] - package for managing =docker= images/containers. ** Maintainers&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/yyoncho][yyoncho]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/rnikoopour][rnikoopour]]&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>3ogx/editor.config</title>
    <updated>2022-08-13T01:40:09Z</updated>
    <id>tag:github.com,2022-08-13:/3ogx/editor.config</id>
    <link href="https://github.com/3ogx/editor.config" rel="alternate"></link>
    <summary type="html">&lt;p&gt;editor.config&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;editor.config&lt;/h1&gt; &#xA;&lt;p&gt;editor.config&lt;/p&gt;</summary>
  </entry>
</feed>