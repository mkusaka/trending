<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-08T01:30:53Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>emacs-jupyter/jupyter</title>
    <updated>2024-12-08T01:30:53Z</updated>
    <id>tag:github.com,2024-12-08:/emacs-jupyter/jupyter</id>
    <link href="https://github.com/emacs-jupyter/jupyter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An interface to communicate with Jupyter kernels.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;An interface to communicate with Jupyter kernels in Emacs.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_HTML &lt;a href=&#34;https://melpa.org/#/jupyter&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/jupyter-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/emacs-jupyter/jupyter/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/emacs-jupyter/jupyter/actions/workflows/test.yml/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/emacs-jupyter/community?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/emacs-jupyter/community.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+END_HTML&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Table of Contents :TOC:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#what-does-this-package-do][What does this package do?]]&lt;/li&gt; &#xA; &lt;li&gt;[[#how-do-i-install-this-package][How do I install this package?]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#using-melpa][Using MELPA]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#manual-installation][Manual installation]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#building-the-widget-support-experimental][Building the widget support (EXPERIMENTAL)]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#related-packages][Related packages]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#ob-ipython][=ob-ipython=]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#emacs-ipython-notebook-ein][=emacs-ipython-notebook= (=ein=)]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#how-do-i-use-the-built-in-frontends][How do I use the built-in frontends?]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#repl][REPL]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#org-mode-source-blocks][=org-mode= source blocks]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#kernelnotebook-server][Kernel/notebook server]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#customizable-variables-available-for-all-frontends][Customizable variables available for all frontends]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;What does this package do?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Provides REPL and =org-mode= source block frontends to Jupyter kernels.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Kernel interactions integrated with Emacs&#39;s built-in features. For example&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Inspecting a piece of code under =point= will display the information for that symbol in the =&lt;em&gt;Help&lt;/em&gt;= buffer. You can re-visit inspection requests made to the kernel by calling =help-go-back= or =help-go-forward= while in the =&lt;em&gt;Help&lt;/em&gt;= buffer.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Uses the =completion-at-point= interface for code completion.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Kernel requests for user input entered through the minibuffer.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can search through REPL history using =isearch=.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;How do I install this package?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Using MELPA&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE:&lt;/em&gt; This package relies on the =emacs-zmq= package which means your Emacs needs to have been built with module support. See the README of that package for more information.&lt;/p&gt; &#xA;&lt;p&gt;You can install this package with any package manager that allows you to install MELPA packages. For Emacs&#39;s built-in package manager:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Ensure MELPA is in =package-archives=&lt;/p&gt; &lt;p&gt;#+BEGIN_SRC elisp (add-to-list &#39;package-archives &#39;(&#34;melpa&#34; . &#34;&lt;a href=&#34;https://melpa.org/packages/&#34;&gt;https://melpa.org/packages/&lt;/a&gt;&#34;)) #+END_SRC&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ensure the latest versions of MELPA packages are available&lt;/p&gt; &lt;p&gt;=M-x package-refresh-contents RET=&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install Jupyter&lt;/p&gt; &lt;p&gt;=M-x package-install RET jupyter RET=&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;** Manual installation&lt;/p&gt; &#xA;&lt;p&gt;For a manual installation you can add the repository directory to your =load-path= and ensure the following dependencies are installed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;markdown-mode (optional) :: &lt;a href=&#34;https://jblevins.org/projects/markdown-mode/&#34;&gt;https://jblevins.org/projects/markdown-mode/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;company-mode (optional) :: &lt;a href=&#34;http://company-mode.github.io/&#34;&gt;http://company-mode.github.io/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;emacs-websocket :: &lt;a href=&#34;https://github.com/ahyatt/emacs-websocket&#34;&gt;https://github.com/ahyatt/emacs-websocket&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;simple-httpd :: &lt;a href=&#34;https://github.com/skeeto/emacs-web-server&#34;&gt;https://github.com/skeeto/emacs-web-server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;zmq :: &lt;a href=&#34;http://github.com/nnicandro/emacs-zmq&#34;&gt;http://github.com/nnicandro/emacs-zmq&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (add-to-list &#39;load-path &#34;~/path/to/jupyter&#34;) (require &#39;jupyter) #+END_SRC ** Building the widget support (EXPERIMENTAL) :PROPERTIES: :ID: 59559FA3-59AD-453F-93E7-113B43F85493 :END:&lt;/p&gt; &#xA;&lt;p&gt;There is limited support for interacting with Jupyter widgets through an external browser. In this case, Emacs acts as a relay for passing messages between the kernel and the browser.&lt;/p&gt; &#xA;&lt;p&gt;To try it out, install =node= (&lt;a href=&#34;https://nodejs.org/en/&#34;&gt;https://nodejs.org/en/&lt;/a&gt;) then run the following shell command from the top-level directory of this project.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC shell make widgets #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;After, launch Emacs, connect to a kernel (e.g. through a REPL), and run some code that creates a widget.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;How do I run the tests?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You must have [[https://github.com/doublep/eldev][Eldev]] installed to be able to run the tests. Once Eldev is installed, then in the top level directory of this project you can run one of the following from the command line&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell&lt;/p&gt; &#xA;&lt;h1&gt;Run the whole set of tests&lt;/h1&gt; &#xA;&lt;p&gt;make test&lt;/p&gt; &#xA;&lt;h1&gt;Run tests tagged with org&lt;/h1&gt; &#xA;&lt;p&gt;make test TAGS=org&lt;/p&gt; &#xA;&lt;h1&gt;Run tests tagged with org and babel&lt;/h1&gt; &#xA;&lt;p&gt;make test TAGS=org,babel&lt;/p&gt; &#xA;&lt;h1&gt;Run tests whose name match a pattern&lt;/h1&gt; &#xA;&lt;p&gt;make test PATTERN=font-lock #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Related packages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** =ob-ipython=&lt;/p&gt; &#xA;&lt;p&gt;The =org-mode= source block frontend in =emacs-jupyter= is similar to what is offered by [[https://github.com/gregsexton/ob-ipython][ob-ipython]] (and also the [[https://github.com/jkitchin/scimax][scimax]] version).&lt;/p&gt; &#xA;&lt;p&gt;** =emacs-ipython-notebook= (=ein=)&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/millejoh/emacs-ipython-notebook][ein]] is a complete Jupyter notebook interface in Emacs with many powerful features for Python kernels. There is some overlap in the features provided by =emacs-jupyter= and =ein=, but I have never used =ein= so I cannot speak very much about any similarities/differences.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;How do I use the built-in frontends? ** REPL&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=M-x jupyter-run-repl= launches a new local kernel and displays a REPL buffer.&lt;/p&gt; &#xA;&lt;p&gt;=M-x jupyter-connect-repl= connects to an existing kernel using the kernel&#39;s [[https://jupyter-client.readthedocs.io/en/stable/kernels.html#connection-files][connection file]], which is supplied by the user, and displays a REPL buffer.&lt;/p&gt; &#xA;&lt;p&gt;The REPL supports some of the [[https://ipython.readthedocs.io/en/stable/interactive/plotting.html#rich-outputs][rich output]] that a kernel may send to a client, e.g. images, LaTeX, and HTML.&lt;/p&gt; &#xA;&lt;p&gt;*** Rich kernel output&lt;/p&gt; &#xA;&lt;p&gt;Below is a table of the supported output mimetypes and their dependencies. If a dependency is not available for a particular mimetype, a mimetype of lower priority gets displayed instead.&lt;/p&gt; &#xA;&lt;p&gt;For widgets, before attempting to open one, you also need to run the shell command =make widgets= in the top-level directory of this project to build some JavaScript files.&lt;/p&gt; &#xA;&lt;p&gt;| Mimetype | Dependencies | |------------------------------------------+---------------------------| | =application/vnd.jupyter.widget-view+json= | [[https://github.com/ahyatt/emacs-websocket][websocket]], [[https://github.com/skeeto/emacs-web-server][simple-httpd]] | | =text/html= | Emacs built with libxml2 | | =text/markdown= | [[https://jblevins.org/projects/markdown-mode/][markdown-mode]] | | =text/latex= | [[https://orgmode.org/][org-mode]] | | =image/svg+xml= | Emacs built with librsvg2 | | =image/png= | none | | =text/plain= | none | *** Inspection&lt;/p&gt; &#xA;&lt;p&gt;To inspect the code around =point= press =M-i=.&lt;/p&gt; &#xA;&lt;p&gt;*** Completion&lt;/p&gt; &#xA;&lt;p&gt;Completion is implemented through the =completion-at-point= interface and should just work.&lt;/p&gt; &#xA;&lt;p&gt;In addition to completing symbols in the REPL buffer, completion also works in buffers [[id:DA597E05-E9A9-4DCE-BBD7-6D25238638C5][associated]] with a REPL. For =org-mode= users, there is even completion in the =org-mode= buffer when editing the contents of a Jupyter source code block. *** REPL history&lt;/p&gt; &#xA;&lt;p&gt;To navigate the REPL history: =M-n= and =M-p=.&lt;/p&gt; &#xA;&lt;p&gt;To search the REPL history: =C-s= and =C-s C-r=.&lt;/p&gt; &#xA;&lt;p&gt;*** Associating buffers with a REPL (=jupyter-repl-interaction-mode=) :PROPERTIES: :ID: DA597E05-E9A9-4DCE-BBD7-6D25238638C5 :END:&lt;/p&gt; &#xA;&lt;p&gt;=M-x jupyter-repl-associate-buffer= sets the =jupyter-current-client= of the current buffer to an existing REPL client and enables =jupyter-repl-interaction-mode=, allowing you to, for example, send the current line for evaluation by the client&#39;s kernel.&lt;/p&gt; &#xA;&lt;p&gt;When =jupyter-repl-interaction-mode= is enabled, the following keybindings are available&lt;/p&gt; &#xA;&lt;p&gt;| Key binding | Command | |-------------+-------------------------------| | =C-M-x= | =jupyter-eval-defun= | | =M-i= | =jupyter-inspect-at-point= | | =C-c C-b= | =jupyter-eval-buffer= | | =C-c C-c= | =jupyter-eval-line-or-region= | | =C-c C-i= | =jupyter-repl-interrupt-kernel= | | =C-c C-r= | =jupyter-repl-restart-kernel= | | =C-c C-s= | =jupyter-repl-scratch-buffer= | | =C-c C-o= | =jupyter-eval-remove-overlays= | | =C-c M-:= | =jupyter-eval-string= |&lt;/p&gt; &#xA;&lt;p&gt;**** Integration with =emacsclient=&lt;/p&gt; &#xA;&lt;p&gt;If =emacsclient= is set as the =EDITOR= and evaluated code opens a file in a =major-mode= compatible with the client that sent the code, the opened file will automatically be associated with the client and have =jupyter-repl-interaction-mode= enabled.&lt;/p&gt; &#xA;&lt;p&gt;This feature probably wont work correctly when there are multiple competing clients sending requests to their underlying kernels that want to open files or if the underlying kernel takes longer than =jupyter-long-timeout= seconds to open a file.&lt;/p&gt; &#xA;&lt;p&gt;See =jupyter-server-mode-set-client= for more details.&lt;/p&gt; &#xA;&lt;p&gt;*** =jupyter-repl-maximum-size=&lt;/p&gt; &#xA;&lt;p&gt;A variable that determines the maximum number of lines a REPL buffer can have before being truncated.&lt;/p&gt; &#xA;&lt;p&gt;*** =jupyter-repl-allow-RET-when-busy=&lt;/p&gt; &#xA;&lt;p&gt;A variable that determines whether to allow insertion of newlines in a REPL cell when a kernel is busy or not. See the variable documentation for more details.&lt;/p&gt; &#xA;&lt;p&gt;*** =jupyter-repl-echo-eval-p=&lt;/p&gt; &#xA;&lt;p&gt;A variable that determines whether code evaluated with the =jupyter-eval-*= commands gets copied over to a REPL input cell or not. You can set this variable to =t= if you prefer having the history of all evaluated code visible in the REPL.&lt;/p&gt; &#xA;&lt;p&gt;** =org-mode= source blocks&lt;/p&gt; &#xA;&lt;p&gt;To enable support for Jupyter based source code blocks, add =jupyter= to =org-babel-load-languages=. Ensure the =jupyter= entry is added last since loading =ob-jupyter= depends on the value of variables such as =org-src-lang-modes= and =org-babel-tangle-lang-exts=.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (org-babel-do-load-languages &#39;org-babel-load-languages &#39;((emacs-lisp . t) (julia . t) (python . t) (jupyter . t))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;After loading, source code blocks with names like =jupyter-LANG= will be available for use. =LANG= can be any one of the kernel languages found on your system. See =jupyter-available-kernelspecs=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The =:session= parameter is required for all Jupyter based source code blocks.&lt;/p&gt; &lt;p&gt;#+BEGIN_SRC org ,#+BEGIN_SRC jupyter-python :session py x = &#39;foo&#39; y = &#39;bar&#39; x + &#39; &#39; + y ,#+END_SRC #+END_SRC&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;By default, source blocks are executed synchronously. To execute a source block asynchronously set the =:async= parameter to =yes=:&lt;/p&gt; &lt;p&gt;#+BEGIN_SRC org ,#+BEGIN_SRC jupyter-python :session py :async yes x = &#39;foo&#39; y = &#39;bar&#39; x + &#39; &#39; + y ,#+END_SRC #+END_SRC&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To change the kernel, set the =:kernel= parameter.&lt;/p&gt; &lt;p&gt;#+BEGIN_SRC org ,#+BEGIN_SRC jupyter-python :session py :async yes :kernel python2 x = &#39;foo&#39; y = &#39;bar&#39; x + &#39; &#39; + y ,#+END_SRC #+END_SRC&lt;/p&gt; &lt;p&gt;Note, the same session name can be used for different values of =:kernel= since the underlying REPL buffer&#39;s name is based on both =:session= and =:kernel=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Any of the default parameters for a language can be changed by setting =org-babel-default-header-args:jupyter-LANG= to an appropriate value. For example to change the defaults for the =julia= kernel, you can set =org-babel-default-header-args:jupyter-julia= to something like&lt;/p&gt; &lt;p&gt;#+BEGIN_SRC elisp (setq org-babel-default-header-args:jupyter-julia &#39;((:async . &#34;yes&#34;) (:session . &#34;jl&#34;) (:kernel . &#34;julia-1.0&#34;))) #+END_SRC *** Note on the language name provided by a kernelspec&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some kernelspecs use spaces in the name of the kernel language. Those get replaced by dashes in the language name you need to use for the corresponding source blocks, e.g. =Wolfram Language= has the source block language =jupyter-Wolfram-Language=.&lt;/p&gt; &#xA;&lt;p&gt;*** Integration with =ob-async=&lt;/p&gt; &#xA;&lt;p&gt;If you have =ob-async= installed and are getting errors when your source block specifies the =:async= header argument, try putting something like the following in your configuration:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (setq ob-async-no-async-languages-alist &#39;(&#34;jupyter-python&#34; &#34;jupyter-julia&#34;)) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;See [[https://github.com/astahlman/ob-async#ob-async-no-async-languages-alist][ob-async-no-async-languages-alist]] for more details.&lt;/p&gt; &#xA;&lt;p&gt;*** Issues with =ob-ipython=&lt;/p&gt; &#xA;&lt;p&gt;If both =ob-ipython= and this package are installed, you may experience issues such as [[https://github.com/dzop/emacs-jupyter/issues/133#issuecomment-502444999][this one]], causing =Search failed= errors. To avoid such errors, remove =ipython= from =org-babel-do-load-languages= and restart your Emacs.&lt;/p&gt; &#xA;&lt;p&gt;*** Overriding built-in src-block languages&lt;/p&gt; &#xA;&lt;p&gt;Instead of having to specify =jupyter-LANG= as a source block name, you can have =LANG= source blocks use the Jupyter machinery. To do so, place a call to =org-babel-jupyter-override-src-block= somewhere in your config (after the call to =org-babel-do-load-languages=).&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (org-babel-jupyter-override-src-block &#34;python&#34;) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;After calling the above function, all =python= source blocks are effectively aliases of =jupyter-python= source blocks and the variable =org-babel-default-header-args:python= will be set to the value of =org-babel-default-header-args:jupyter-python=.&lt;/p&gt; &#xA;&lt;p&gt;Note, =org-babel-default-header-args:python= will &lt;em&gt;not&lt;/em&gt; be an alias of =org-babel-default-header-args:jupyter-python=, the value of the former is merely set to the value of the latter after calling =org-babel-jupyter-override-src-block=.&lt;/p&gt; &#xA;&lt;p&gt;You can restore the original behavior by calling =org-babel-jupyter-restore-src-block=.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC elisp (org-babel-jupyter-restore-src-block &#34;python&#34;) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;*** Rich kernel output&lt;/p&gt; &#xA;&lt;p&gt;The supported display mimetypes ordered by priority are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;text/org&lt;/li&gt; &#xA; &lt;li&gt;image/svg+xml, image/jpeg, image/png&lt;/li&gt; &#xA; &lt;li&gt;text/html&lt;/li&gt; &#xA; &lt;li&gt;text/markdown&lt;/li&gt; &#xA; &lt;li&gt;text/latex&lt;/li&gt; &#xA; &lt;li&gt;text/plain&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;**** A note on using the =:results= header argument&lt;/p&gt; &#xA;&lt;p&gt;There are some cases where the normal result insertion mechanism may not be wanted. To control result insertion somewhat, use the =:results= header argument:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Insert unwrapped LaTeX :: Normally LaTeX results are wrapped in a =BEGIN_EXPORT= block, in order to insert LaTeX unwrapped, specify =:results raw=.&lt;/li&gt; &#xA; &lt;li&gt;Suppress table creation :: Whenever a result can be converted into an =org-mode= table, e.g. when it look like =[1, 2 , 3]=, it is automatically converted into a table. To suppress this behavior you can specify =:results scalar=.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;**** Fixing the file name of images with the =:file= argument&lt;/p&gt; &#xA;&lt;p&gt;Whenever an image result is returned, a random image file name is generated and the image is written to =org-babel-jupyter-resource-directory=. To specify your own file name for the image, set the =:file= header argument.&lt;/p&gt; &#xA;&lt;p&gt;If no file extension is specified in the provided =:file=, then one will be inferred from the returned output. This can be useful in scenarios where the file resulting from the src-block can have different types depeneding on the code, e.g. if the image type returned can be either =png= or =svg= depending on certain settings, you can specify =:file = output= which will be converted into =output.png= or =output.svg= depending on the MIME type return by the executed src-block.&lt;/p&gt; &#xA;&lt;p&gt;**** Changing the mime-type priority with the =:display= argument&lt;/p&gt; &#xA;&lt;p&gt;The priority of mimetypes used to display results can be overwritten using the =:display= option. If instead of displaying HTML results we&#39;d wish to display plain text, the argument =:display text/plain text/html= would prioritize plain text results over html ones. The following example displays plain text instead of HTML: #+BEGIN_SRC org ,#+BEGIN_SRC jupyter-python :session py :display plain import pandas as pd data = [[1, 2], [3, 4]] pd.DataFrame(data, columns=[&#34;Foo&#34;, &#34;Bar&#34;]) ,#+END_SRC #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;**** Image output without the =:file= header argument&lt;/p&gt; &#xA;&lt;p&gt;For images sent by the kernel, if no =:file= parameter is provided to the code block, a file name is automatically generated based on the image data and the image is written to file in =org-babel-jupyter-resource-directory=. This is great for quickly generating throw-away plots while you are working on your code. Once you are happy with your results you can specify the =:file= parameter to fix the file name. **** =org-babel-jupyter-resource-directory=&lt;/p&gt; &#xA;&lt;p&gt;This variable is similar to =org-preview-latex-image-directory= but solely for any files created when Jupyter code blocks are run, e.g. automatically generated image file names.&lt;/p&gt; &#xA;&lt;p&gt;***** Deletion of generated image files&lt;/p&gt; &#xA;&lt;p&gt;Whenever you run a code block multiple times and replace its results, before the results are replaced, any generated files will be deleted to reduce the clutter in =org-babel-jupyter-resource-directory=. **** Convert rich kernel output with the =:pandoc= header argument&lt;/p&gt; &#xA;&lt;p&gt;By default html, markdown, and latex results are wrapped in a =BEGIN_EXPORT= block. If the header argument =:pandoc t= is set, they are instead converted to org-mode format with [[https://pandoc.org/][pandoc]]. You can control which outputs get converted with the custom variable =jupyter-org-pandoc-convertable=.&lt;/p&gt; &#xA;&lt;p&gt;*** Editing the contents of a code block&lt;/p&gt; &#xA;&lt;p&gt;When editing a Jupyter code block&#39;s contents, i.e. by pressing =C-c &#39;= when at a code block, =jupyter-repl-interaction-mode= is automatically enabled in the edit buffer and the buffer will be associated with the REPL session of the code block (see =jupyter-repl-associate-buffer=).&lt;/p&gt; &#xA;&lt;p&gt;You may also bind the command =org-babel-jupyter-scratch-buffer= to an appropriate key in =org-mode= to display a scratch buffer in the code block&#39;s =major-mode= and connected to the code block&#39;s session. *** Connecting to an existing kernel&lt;/p&gt; &#xA;&lt;p&gt;To connect to an existing kernel, pass the kernel&#39;s connection file as the value of the =:session= parameter. The name of the file must have a =.json= suffix for this to work. **** Remote kernels&lt;/p&gt; &#xA;&lt;p&gt;If the connection file is a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Remote-Files.html][remote file name]], i.e. has a prefix like =/method:host:=, the kernel&#39;s ports are assumed to live on =host=. Before attempting to connect to the kernel, =ssh= tunnels for the connection are created. So if you had a remote kernel on a host named =ec2= whose connection file is =/run/user/1000/jupyter/kernel-julia-0.6.json= on that host, you could specify the =:session= like&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC org ,#+BEGIN_SRC jupyter-julia :session /ssh:ec2:/run/user/1000/jupyter/kernel-julia-0.6.json ... ,#+END_SRC #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Note, the kernel on the remote host needs to have the ZMQ socket ports exposed. This means that starting a kernel using&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC shell jupyter notebook --no-browser #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;currently doesn&#39;t work since the notebook server does not allow communication with a kernel using ZMQ sockets. You will have to use the connection file created from using something like&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC shell jupyter kernel --kernel=python #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;***** Password handling for remote connections Currently there is no password handling, so if your =ssh= connection requires a password I suggest you instead use [[https://www.ssh.com/ssh/keygen/][key-based authentication]]. Or if you are connecting to a server using a =pem= file add something like&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC conf Host ec2 User &#xA; &lt;user&gt;&#xA;   HostName &#xA;  &lt;host&gt;&#xA;    IdentityFile &#xA;   &lt;identity&gt;&#xA;    .pem #+END_SRC&#xA;   &lt;/identity&gt;&#xA;  &lt;/host&gt;&#xA; &lt;/user&gt;&lt;/p&gt; &#xA;&lt;p&gt;to your =~/.ssh/config= file. *** Starting a remote kernel&lt;/p&gt; &#xA;&lt;p&gt;If =:session= is a remote file name that doesn&#39;t end in =.json=, e.g. =/ssh:ec2:jl=, then a kernel on the remote host =/ssh:ec2:= is started using the =jupyter kernel= command on the host. The local part of the session name serves to distinguish different remote sessions on the same host.&lt;/p&gt; &#xA;&lt;p&gt;*** Communicating with kernel (notebook) servers&lt;/p&gt; &#xA;&lt;p&gt;If =:session= is a TRAMP file name like =/jpy:localhost#8888:NAME= it is interpreted as corresponding to a connection to a kernel through a Jupyter notebook server located at =&lt;a href=&#34;http://localhost:8888=&#34;&gt;http://localhost:8888=&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If =NAME= is a kernel ID corresponding to an existing kernel on a server, e.g. =/jpy::161b2318-180c-497a-b4bf-de76176061d9=, then a connection to an existing kernel with the corresponding ID will be made. Otherwise, a new kernel will be launched on the server and =NAME= will be used as an identifier for the session.&lt;/p&gt; &#xA;&lt;p&gt;When a new kernel is launched, =NAME= will also be associated with the kernel&#39;s ID, see =jupyter-server-kernel-names=. This is useful to distinguish Org mode =:session= kernels from other ones in the buffer shown by =jupyter-server-list-kernels=.&lt;/p&gt; &#xA;&lt;p&gt;When connecting to an existing kernel, i.e. when =NAME= is the ID of a kernel, the =:kernel= header argument must match the name of the kernel&#39;s kernelspec.&lt;/p&gt; &#xA;&lt;p&gt;To connect to a kernel behind an =HTTPS= connection, use a TRAMP file name that looks like =/jpys:...= instead.&lt;/p&gt; &#xA;&lt;p&gt;*** Standard output, displayed data, and code block results&lt;/p&gt; &#xA;&lt;p&gt;In contrast to non-Jupyter code blocks, the kernel of Jupyter code block can request extra data, other than stdout or a code block&#39;s result, be displayed (see [[https://jupyter-client.readthedocs.io/en/stable/messaging.html#display-data][display_data messages]]).&lt;/p&gt; &#xA;&lt;p&gt;To account for this, Jupyter code blocks do not go through the normal =org-mode= result insertion mechanism (see =org-babel-insert-result=), instead providing its own result insertion. The downside is that, compared to normal =org-mode= code blocks, only a small subset of the header arguments are supported. The upside is that all forms of results produced by a kernel can be inserted into the buffer similar to a Jupyter notebook.&lt;/p&gt; &#xA;&lt;p&gt;*** =jupyter-org-interaction-mode=&lt;/p&gt; &#xA;&lt;p&gt;A minor mode that enables completion and custom keybindings when =point= is inside a Jupyter code block. This mode is enabled by default in =org-mode= buffers, but only has an effect when =point= is inside a Jupyter code block.&lt;/p&gt; &#xA;&lt;p&gt;**** Custom keybindings inside Jupyter code blocks&lt;/p&gt; &#xA;&lt;p&gt;You can define new keybindings that are enabled when =point= is inside a Jupyter code block by using the function =jupyter-org-define-key=. These bindings are added to =jupyter-org-interaction-mode-map= and are only active when =jupyter-org-interaction-mode= is enabled.&lt;/p&gt; &#xA;&lt;p&gt;By default the following keybindings from =jupyter-repl-interaction-mode= are available when =jupyter-org-interaction-mode= is enabled&lt;/p&gt; &#xA;&lt;p&gt;| Key binding | Command | |-------------+---------------------------------| | =C-M-x= | =jupyter-eval-defun= | | =M-i= | =jupyter-inspect-at-point= | | =C-x C-e= | =jupyter-eval-line-or-region= | | =C-c C-i= | =jupyter-repl-interrupt-kernel= | | =C-c C-r= | =jupyter-repl-restart-kernel= |&lt;/p&gt; &#xA;&lt;p&gt;*** Disable automatic connections to a source block session&lt;/p&gt; &#xA;&lt;p&gt;When typing into the region of a Jupyter source block, under certain conditions, an attempt at connecting to the source block&#39;s session is made if not already connected.&lt;/p&gt; &#xA;&lt;p&gt;This behavior can be suppressed by setting =jupyter-org-auto-connect= to =nil=. In this case, a connection is attempted upon executing a source block, for example.&lt;/p&gt; &#xA;&lt;p&gt;*** Enable client-side queuing of requests&lt;/p&gt; &#xA;&lt;p&gt;If the customizable variable =jupyter-org-queue-requests= is non-nil, then perform client side queuing of source block execute requests. This means that when multiple requests are made, for example by executing a subtree, the requests are queued locally in Emacs instead of sending all the requests immediately to the kernel as would happen when =:async yes= is specified on all the source blocks. It is only when one request finishes that the next is sent. In addition, if any request fails all the queued requests that are meant to come after it are aborted and do not get sent to the kernel.&lt;/p&gt; &#xA;&lt;p&gt;To turn client side queuing on or off you can =M-x jupyter-org-toggle-request-queuing=.&lt;/p&gt; &#xA;&lt;p&gt;** Kernel/notebook server *** Managing live kernels&lt;/p&gt; &#xA;&lt;p&gt;The main entry point for working with a kernel server is the =jupyter-server-list-kernels= command which shows a list of all live kernels from the server URL that you provide when first calling the command. Any subsequent calls to the command will use the same URL as the first call. To change server URLs give a prefix argument, =C-u M-x jupyter-server-list-kernels=. This will then set the current server URL for future calls to the one you provide. See the =jupyter-current-server= command for more details.&lt;/p&gt; &#xA;&lt;p&gt;From the buffer shown by =jupyter-server-list-kernels= you can launch new kernels (=C-RET=), connect a REPL to an existing kernel (=RET=), interrupt a kernel (=C-c TAB=), kill a kernel (=C-c C-d= or =d=), refresh the list of kernels (=g=) etc. See the =jupyter-server-kernel-list-mode= for all the available key bindings.&lt;/p&gt; &#xA;&lt;p&gt;Note, the =default-directory= of the =jupyter-server-kernel-list-mode= buffer will be the root directory of the kernel server (so that =dired-jump= will show a =dired= listing of the directory). See the section on TRAMP integration below.&lt;/p&gt; &#xA;&lt;p&gt;*** Naming kernels&lt;/p&gt; &#xA;&lt;p&gt;From the =jupyter-server-list-kernels= buffer one can also name (or rename) a kernel (=R=) so that it has an identifier other than its ID. Naming a kernel adds the name to the =jupyter-server-kernel-names= global variable in a form suitable for persisting across Emacs sessions. See its documentation for more details about persisting its value.&lt;/p&gt; &#xA;&lt;p&gt;*** TRAMP integration&lt;/p&gt; &#xA;&lt;p&gt;There is also integration with the Jupyter notebook contents API in the form of a TRAMP backend. This means that reading/writing the contents of directories the notebook server has access to can be done using normal Emacs file operations using file names with TRAMP syntax. Two new TRAMP file name methods are defined, =jpy= for HTTP connections and =jpys= for HTTPS connections. So suppose you have a local notebook server at &lt;a href=&#34;http://localhost:8888&#34;&gt;http://localhost:8888&lt;/a&gt;, then to access its directory contents you can type&lt;/p&gt; &#xA;&lt;p&gt;#+begin_example M-x dired RET /jpy:localhost#8888:/ #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Note =localhost= is the default host and =8888= is the default port so =/jpy::= is equivalent to =/jpy:localhost#8888:=. You can change the defaults by modifying the =jpy= or =jpys= methods in the variable =tramp-methods= and =tramp-default-host-alist=.&lt;/p&gt; &#xA;&lt;p&gt;*** =jupyter-api-authentication-method=&lt;/p&gt; &#xA;&lt;p&gt;Authentication method used for new notebook server connections. By default, when connecting to a new notebook server you will be asked if either a password or a token should be used for authentication. If you only use tokens for authentication you can change this variable to avoid being asked on every new connection.&lt;/p&gt; &#xA;&lt;p&gt;** Customizable variables available for all frontends&lt;/p&gt; &#xA;&lt;p&gt;*** =jupyter-eval-use-overlays=&lt;/p&gt; &#xA;&lt;p&gt;When non-nil, display the =text/plain= representation of evaluation results inline using overlays. All other representations are displayed in the usual way. This only works with the =jupyter-eval-*= commands like =jupyter-eval-line-or-region=.&lt;/p&gt; &#xA;&lt;p&gt;You can control the appearance of the overlay, see =jupyter-eval-overlay-prefix= and the =jupyter-eval-overlay= face.&lt;/p&gt; &#xA;&lt;p&gt;To clear all overlays from the buffer, bind =jupyter-eval-remove-overlays= to some key. Its bound to =C-c C-o= when =jupyter-repl-interaction-mode= is enabled. Individual overlays are removed whenever the text in the region that was evaluated is modified.&lt;/p&gt; &#xA;&lt;p&gt;For multi-line overlays you can fold/unfold the overlay by pressing =S-RET= when =point= is inside the region of code that caused the overlay to be created. See =jupyter-eval-overlay-keymap=.&lt;/p&gt; &#xA;&lt;p&gt;*** =jupyter-eval-short-result-max-lines=&lt;/p&gt; &#xA;&lt;p&gt;If the number of lines of an evaluation result is smaller than this variable, the function stored in =jupyter-eval-short-result-display-function= is used to display a result.&lt;/p&gt;</summary>
  </entry>
</feed>