<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-30T01:34:06Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>positron-solutions/transient-showcase</title>
    <updated>2022-12-30T01:34:06Z</updated>
    <id>tag:github.com,2022-12-30:/positron-solutions/transient-showcase</id>
    <link href="https://github.com/positron-solutions/transient-showcase" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Example forms for transient UI&#39;s in Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Transient Showcase #+AUTHOR: Psionik K #+PROPERTY: header-args :results silent :comments no :padline yes :no-expand true&lt;/p&gt; &#xA;&lt;p&gt;Code examples for interactive explanations of [[https://github.com/magit/transient][transient]].&lt;/p&gt; &#xA;&lt;p&gt;This guide assumes you have minimal knowledge of Emacs, some programming experience in elisp and non-lisp languages, and have at least seen [[https://magit.vc/screenshots/][screenshots]] of =magit=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;How to use&lt;/p&gt; &lt;p&gt;There are two ways:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Open this file in Emacs and run examples as literate org.&lt;/li&gt; &#xA;   &lt;li&gt;Install the package to run commands and read their source. Start with the =tsc-showcase= command.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Using as literate org document&lt;/p&gt; &#xA;&lt;p&gt;If you open this file in Emacs, it will switch to Org mode and you can run individual source blocks with =org-babel-execute-src-blk= on the block.&lt;/p&gt; &#xA;&lt;p&gt;** Using as an installable package&lt;/p&gt; &#xA;&lt;p&gt;If you install the package, you can read source for each example with the normal. =describe-function= command. All commands are under =tsc-&lt;em&gt;= prefix. Somewhat useful suffixes are under =tsc-suffix-&lt;/em&gt;= while less useful ones under =tsc--suffix-*=. They will come in handly when you are developing new applications.&lt;/p&gt; &#xA;&lt;p&gt;Installations for straight and elpaca:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; using straight use-package with custom recipe&#xA;(use-package transient-showcase&#xA;  :straight &#39;(transient-showcase&#xA;              :type git :host github :repo &#34;positron-solutions/transient-showcase&#34;))&#xA;&#xA;;; using elpaca (recommended to add a hash for reproducibility)&#xA;(elpaca-use-package&#xA; (transient-showcase :host github&#xA;                     :repo &#34;positron-solutions/transient-showcase&#34;)&#xA; :demand t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt; While this file is also the README for this repository, it&#39;s not intended to be used copy-paste. Many links will only open in Emacs. Some definitions are included by refrence from [[*Preludes][Preludes]]&lt;/p&gt; &#xA;&lt;p&gt;** Packaging :PROPERTIES: :VISIBILITY: folded :END:&lt;/p&gt; &#xA;&lt;p&gt;This file is produced with =org-babel-tangle=. Package header and preludes included in the no-web block below:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :noweb yes :hidden yes :eval never &amp;lt;&#xA; &lt;package-header&gt;&#xA;  &amp;gt; &amp;lt;&#xA;  &lt;wave-prelude&gt;&#xA;   &amp;gt; &amp;lt;&#xA;   &lt;predicates-prelude&gt;&#xA;    &amp;gt; &amp;lt;&#xA;    &lt;show-level-prelude&gt;&#xA;     &amp;gt; &amp;lt;&#xA;     &lt;levels-prelude&gt;&#xA;      &amp;gt; &amp;lt;&#xA;      &lt;print-args-prelude&gt;&#xA;       &amp;gt; #+end_src&#xA;      &lt;/print-args-prelude&gt;&#xA;     &lt;/levels-prelude&gt;&#xA;    &lt;/show-level-prelude&gt;&#xA;   &lt;/predicates-prelude&gt;&#xA;  &lt;/wave-prelude&gt;&#xA; &lt;/package-header&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Running Examples in Org Mode&lt;/p&gt; &#xA;&lt;p&gt;This is a basic transient, using an anonymous lambda interactive command as its only suffix.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(transient-define-prefix tsc-hello ()&#xA;  &#34;Prefix that is minimal and uses an anonymous command suffix.&#34;&#xA;  [(&#34;s&#34; &#34;call suffix&#34;&#xA;    (lambda ()&#xA;      (interactive)&#xA;      (message &#34;Called a suffix&#34;)))])&#xA;&#xA;;; First, use M-x org-babel-execute-src-blk to cause `tsc-hello&#39; to be defined&#xA;;; Second, M-x `eval-last-sexp&#39; with your point at the end of the line below&#xA;;; (tsc-hello)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;After executing the block above, you can =execute-extended-command= (&lt;em&gt;M-x&lt;/em&gt;) and select =tsc-hello= to show this transient. All transient prefixes are also commands that show up in (&lt;em&gt;M-x&lt;/em&gt;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt; If the example above is hard to read, review some [[info:elisp#Top][elisp]] [[*Essential Elisp][syntax]] and typical forms.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contents :noexport: :PROPERTIES: :TOC: :include siblings :depth 2 :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[Terminology][Terminology]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Prefixes and Suffixes][Prefixes and Suffixes]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Nesting Prefixes][Nesting Prefixes]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Infix][Infix]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Summary][Summary]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[Declaring - Equivalent Forms][Declaring - Equivalent Forms]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[The Shorthand form][The Shorthand form]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Keyword Arguments Style][Keyword Arguments Style]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Macro Child Definition Style][Macro Child Definition Style]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Overriding slots in the prefix definition][Overriding slots in the prefix definition]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Quoting Note for Vectors][Quoting Note for Vectors]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[Groups &amp;amp; Layouts][Groups &amp;amp; Layouts]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Descriptions][Descriptions]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Layouts][Layouts]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Manually setting group class][Manually setting group class]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[Nesting &amp;amp; Flow Control][Nesting &amp;amp; Flow Control]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Single versus multiple commands][Single versus multiple commands]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Nesting][Nesting]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Mixing Interactive][Mixing Interactive]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Pre-Commands Explained][Pre-Commands Explained]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[Using &amp;amp; Managing States][Using &amp;amp; Managing States]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[The Magic of Transient][The Magic of Transient]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Infixes][Infixes]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Scope][Scope]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Prefix Value &amp;amp; History][Prefix Value &amp;amp; History]]&lt;/li&gt; &#xA;   &lt;li&gt;[[History Keys][History Keys]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Disabling Set / Save on a Suffix][Disabling Set / Save on a Suffix]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Setting or Saving Every Time a Suffix is Used][Setting or Saving Every Time a Suffix is Used]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Lisp Variables][Lisp Variables]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[Controlling CLI&#39;s][Controlling CLI&#39;s]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Reading arguments within suffixes][Reading arguments within suffixes]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Switches &amp;amp; Arguments Again][Switches &amp;amp; Arguments Again]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Dispatching args into a process][Dispatching args into a process]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[Controlling Visibility][Controlling Visibility]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Visibility Predicates][Visibility Predicates]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Inapt (Temporarily Unavailable)][Inapt (Temporarily Unavailable)]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Levels][Levels]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[Advanced][Advanced]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Dynamically generating layouts][Dynamically generating layouts]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Using prefix scope in children][Using prefix scope in children]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Custom Infix Types][Custom Infix Types]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[Appendixes][Appendixes]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[EIEIO - OOP in Elisp][EIEIO - OOP in Elisp]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Debugging][Debugging]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Layout Hacking][Layout Hacking]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Hooks][Hooks]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Preludes][Preludes]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Essential Elisp][Essential Elisp]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[Further Reading][Further Reading]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Package Header][Package Header]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Package Footer][Package Footer]] :END:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Terminology :PROPERTIES: :TOC: :include descendants :depth 3 :local depth :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Prefixes and Suffixes][Prefixes and Suffixes]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Conceptual similarity to Emacs prefix arguments][Conceptual similarity to Emacs prefix arguments]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Nesting Prefixes][Nesting Prefixes]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Infix][Infix]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Summary][Summary]] :END:&lt;/p&gt; &lt;p&gt;Transient means temporary. Transient gets it&#39;s name from the temporary keymap and the popup UI for displaying that keymap. Emacs has a similar idea built-in with [[elisp:(describe-function &#39;set-transient-map)][set-transient-map]] for a temporary high-precedence keymap.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Prefixes and Suffixes&lt;/p&gt; &#xA;&lt;p&gt;The hello transient user input sequence is:&lt;/p&gt; &#xA;&lt;p&gt;=Prefix -&amp;gt; Suffix=&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;em&gt;prefix&lt;/em&gt; is the command you invoke first, such as =magit-dispatch=&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A &lt;em&gt;suffix&lt;/em&gt; is a command displayed in the transient UI, such as =magit-stage=&lt;/p&gt; &lt;p&gt;#+begin_src elisp :tangle no (magit-dispatch) ; same as pressing &#39;h&#39; in magit-status buffer #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The keymap and UI display is frequently referred to as &#34;a transient&#34;. &#34;Prefix&#34; and &#34;a transient&#34; are almost the same thing. Invoking a prefix will show a transient. They are inseparable ideas.&lt;/p&gt; &#xA;&lt;p&gt;*** Conceptual similarity to Emacs prefix arguments&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*Setting [[https://emacsdocs.org/docs/emacs/Prefix-Keymaps][prefix arguments]] with =universal-argument= (=C-u=) is a distinct,&#xA;separate behavior that is part of Emacs.*&#xA;&#xA;With prefix arguments, you &#34;call&#34; commands with extra arguments, like you&#xA;would a function.&#xA;&#xA;A transient prefix can set some states and its suffix can then use these&#xA;states to tweak its behavior.  The difference is that within the lifecycle&#xA;of a transient UI, and coordinating with transient&#39;s state persistence, you&#xA;can create much more complex input to your commands.  You can use commands&#xA;to construct phrases for other commands.&#xA;&#xA;To see a short example of prefix arguments being used within a transient&#xA;prefix, see [[*Scope][the scope example]].&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Nesting Prefixes&lt;/p&gt; &#xA;&lt;p&gt;A prefix can also be bound as a suffix, enabling /nested/ prefixes. A user input sequence with nested transients might look like:&lt;/p&gt; &#xA;&lt;p&gt;=Prefix -&amp;gt; Sub-Prefix -&amp;gt; Sub-Prefix -&amp;gt; Suffix=&lt;/p&gt; &#xA;&lt;p&gt;For example, in the =magit-dispatch= transient (=?=), =l= for =magit-log= is a nested transient. =b= for =all branches= is the suffix command =magit-log-all-branches=.&lt;/p&gt; &#xA;&lt;p&gt;See [[*Flow Control][Flow Control]] for nested transient examples with both sub-prefixes and suffixes that do no exit.&lt;/p&gt; &#xA;&lt;p&gt;** Infix&lt;/p&gt; &#xA;&lt;p&gt;Some suffixes need to hold state, toggling or storing an argument. Infixes are specialized suffixes to set and hold state. A user input sequence with infixes:&lt;/p&gt; &#xA;&lt;p&gt;=Prefix -&amp;gt; Infix -&amp;gt; Infix -&amp;gt; Suffix=&lt;/p&gt; &#xA;&lt;p&gt;See [[*Basic Infixes][Infix examples]] to get a better idea.&lt;/p&gt; &#xA;&lt;p&gt;** Summary&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Prefixes&lt;/em&gt; display the pop-up UI and bind the keymap.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Suffixes&lt;/em&gt; are commands bound within a prefix&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Infixes&lt;/em&gt; are a specialized suffix for storing and setting state&lt;/li&gt; &#xA; &lt;li&gt;A &lt;em&gt;Suffix&lt;/em&gt; may be yet another &lt;em&gt;Prefix&lt;/em&gt;, in which case the transient is nested&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Declaring - Equivalent Forms :PROPERTIES: :TOC: :include descendants :depth 3 :local depth :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[The Shorthand form][The Shorthand form]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Keyword Arguments Style][Keyword Arguments Style]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Macro Child Definition Style][Macro Child Definition Style]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Overriding slots in the prefix definition][Overriding slots in the prefix definition]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Quoting Note for Vectors][Quoting Note for Vectors]] :END:&lt;/p&gt; &lt;p&gt;You can declare the same behavior 3-4 ways&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Shorthand forms within =transient-define-prefix= macro allow shorthand binding of suffixes &amp;amp; commands or creation of infixes directly within the layout definition.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Macros for suffixes and infix definition streamline defining commands while also defining how they will behave in a layout.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Keyword arguments &lt;del&gt;(:foo val1 :bar val2)&lt;/del&gt; are interpreted by the macros and used to set slots (OOP attributes) on prefix, group, and suffix objects. Similar forms for declaring suffixes can be used to modify them when declaring a layout. Very specific control over layouts also uses these forms.&lt;/p&gt; &lt;p&gt;#+begin_src elisp :tangle no ;; slots &amp;amp; methods that can be set / overridden in children (describe-function transient-child) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Custom classes using EIEIO (basically elisp OOP) can change methods deeper in the implementation than you can reach with slots. =describe-function= is a quick way to look at the methods.&lt;/p&gt; &lt;p&gt;#+begin_src elisp :tangle no ;; slots &amp;amp; methods that can be set / overridden in suffixes (describe-function transient-suffix) #+end_src&lt;/p&gt; &lt;p&gt;See the [[*EIEIO - OOP in Elisp][EIEIO Appendix]] for introduction to exploring EIEIO objects and classes.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** The Shorthand form&lt;/p&gt; &#xA;&lt;p&gt;Binding suffixes with the =(&#34;key&#34; &#34;description&#34; suffix-or-command)= form within a group is extremely common.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle no :var _=wave-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-wave ()&#xA;   &#34;Prefix that waves at the user&#34;&#xA;   [(&#34;w&#34; &#34;wave&#34; tsc-suffix-wave)]) ; tsc-suffix-wave is a simple command from wave-prelude&#xA;&#xA; ;; (tsc-wave)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Both commands and suffixes from =transient-define-suffix= can be used. It&#39;s a good reason to use =private--namespace= style names for suffix actions since these commands don&#39;t usually show up in (&lt;em&gt;M-x&lt;/em&gt;) by default.&lt;/p&gt; &#xA;&lt;p&gt;** Keyword Arguments Style&lt;/p&gt; &#xA;&lt;p&gt;You can customize the slot value (OOP attribute) of the transient, groups, and suffixes by adding extra &lt;del&gt;:foo value&lt;/del&gt; style pairs.&lt;/p&gt; &#xA;&lt;p&gt;Not all behaviors have a shorthand form, so as you use more behaviors, you will see more of the keyword argument style API. Here we use the =:transient= property, set to true, meaning the suffix won&#39;t exit the transient.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle no :var _=levels-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-wave-keyword-args ()&#xA;   &#34;Prefix that waves at the user persistently.&#34;&#xA;   [(&#34;e&#34; &#34;wave eventually &amp;amp; stay&#34; tsc--wave-eventually :transient t)&#xA;    (&#34;s&#34; &#34;wave surely &amp;amp; leave&#34; tsc--wave-surely :transient nil)])&#xA;&#xA; ;; (tsc-wave-keyword-args)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Launch the command, wave several times (note timestamp update) and then exit with (&lt;em&gt;C-g&lt;/em&gt;).&lt;/p&gt; &#xA;&lt;p&gt;** Macro Child Definition Style&lt;/p&gt; &#xA;&lt;p&gt;The =transient-define-suffix= macro can help if you need to bind a command in multiple places and only override some properties for some prefixes. It makes the prefix definition more compact at the expense of a more verbose command.&lt;/p&gt; &#xA;&lt;p&gt;#+name: tsc-wave-suffix-def #+begin_src elisp :tangle transient-showcase.el&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-suffix tsc-suffix-wave-macroed ()&#xA;   &#34;Prefix that waves with macro-defined suffix.&#34;&#xA;   :transient t&#xA;   :key &#34;T&#34;&#xA;   :description &#34;wave from macro definition&#34;&#xA;   (interactive)&#xA;   (message &#34;Waves from a macro definition at: %s&#34; (current-time-string)))&#xA;&#xA; ;; Suffix definition creates a command&#xA; ;; (tsc-suffix-wave-macroed)&#xA; ;; Because that&#39;s where the suffix object is stored&#xA; ;; (get &#39;tsc-suffix-wave-macroed &#39;transient--suffix)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=tsc-wave-suffix-def ;; tsc-suffix-wave-suffix defined above&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-wave-macro-defined ()&#xA;   &#34;Prefix to wave using a macro-defined suffix.&#34;&#xA;   [(tsc-suffix-wave-macroed)]) ; note, information moved from prefix to the suffix.&#xA;&#xA; ;; (tsc-wave-macro-defined)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Overriding slots in the prefix definition&lt;/p&gt; &#xA;&lt;p&gt;Even if you define a property via one of the macros, you can still override that property in the later prefix definition. The example below overrides the =:transient=, =:description=, and =:key= properties of the =tsc-suffix-wave= suffix defined above:&lt;/p&gt; &#xA;&lt;p&gt;#+name: tsc-wave-overridden #+begin_src elisp :tangle transient-showcase.el :var _=tsc-wave-suffix-def&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (defun tsc--wave-override ()&#xA;   &#34;Vanilla command used to override suffix&#39;s commands.&#34;&#xA;   (interactive)&#xA;   (message &#34;This suffix was overridden.  I am what remains.&#34;))&#xA;&#xA; (transient-define-prefix tsc-wave-overridden ()&#xA;   &#34;Prefix that waves with overridden suffix behavior.&#34;&#xA;   [(tsc-suffix-wave-macroed&#xA;     :transient nil&#xA;     :key &#34;O&#34;&#xA;     :description &#34;wave overridingly&#34;&#xA;     :command tsc--wave-override)]) ; we overrode what the suffix even does&#xA;&#xA; ;; (tsc-wave-overridden)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you just list the key and symbol followed by properties, it is also a supported shorthand suffix form:&lt;/p&gt; &#xA;&lt;p&gt;=(&#34;wf&#34; tsc-suffix-wave :description &#34;wave furiously&#34;)=&lt;/p&gt; &#xA;&lt;p&gt;** Quoting Note for Vectors&lt;/p&gt; &#xA;&lt;p&gt;Inside the =[ ...vectors... ]= in =transient-define-prefix=, you don&#39;t need to quote symbols because in the vector, everything is a literal. When you move a shorthand style =:property symbol= out to the =transient-define-suffix= form, which is a list, you might need to quote the symbol as =:property &#39;symbol=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Groups &amp;amp; Layouts :PROPERTIES: :TOC: :include descendants :depth 3 :local depth :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Descriptions][Descriptions]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Dynamic Descriptions][Dynamic Descriptions]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Layouts][Layouts]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Groups one on top of the other][Groups one on top of the other]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Groups side by side][Groups side by side]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Group on top of groups side by side][Group on top of groups side by side]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Empty strings make spaces][Empty strings make spaces]]&lt;/li&gt; &#xA;   &lt;li&gt;[[A Grid][A Grid]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Manually setting group class][Manually setting group class]] :END:&lt;/p&gt; &lt;p&gt;To define a transient, you need at least one group. Groups are vectors, delimited as =[ ...group... ]=.&lt;/p&gt; &lt;p&gt;There is basic layout support and you can use it to collect or differentiate commands.&lt;/p&gt; &lt;p&gt;If you begin a group vector with a string, you get a group heading. Groups also support some [[https://magit.vc/manual/transient/Group-Specifications.html#Group-Specifications][properties]]. The [[elisp:(describe-function transient-group)][group class]] also has a lot of information.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Descriptions&lt;/p&gt; &#xA;&lt;p&gt;Very straightforward. Just make the first element in the vector a string or add a =:description= property, which can be a function.&lt;/p&gt; &#xA;&lt;p&gt;In the prefix definition of suffixes, the second string is a description.&lt;/p&gt; &#xA;&lt;p&gt;The =:description= key is applied last and therefore wins in ambiguous declarations.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-layout-descriptions ()&#xA;   &#34;Prefix with descriptions specified with slots.&#34;&#xA;   [&#34;Let&#39;s Give This Transient a Title\n&#34; ; yes the newline works&#xA;    [&#34;Group One&#34;&#xA;     (&#34;wo&#34; &#34;wave once&#34; tsc-suffix-wave)&#xA;     (&#34;wa&#34; &#34;wave again&#34; tsc-suffix-wave)]&#xA;&#xA;    [&#34;Group Two&#34;&#xA;     (&#34;ws&#34; &#34;wave some&#34; tsc-suffix-wave)&#xA;     (&#34;wb&#34; &#34;wave better&#34; tsc-suffix-wave)]]&#xA;&#xA;   [&#34;Bad title&#34; :description &#34;Group of Groups&#34;&#xA;    [&#34;Group Three&#34;&#xA;     (&#34;k&#34; &#34;bad desc&#34; tsc-suffix-wave :description &#34;key-value wins&#34;)&#xA;     (&#34;n&#34; tsc-suffix-wave :description &#34;no desc necessary&#34;)]&#xA;    [:description &#34;Key Only Def&#34;&#xA;     (&#34;wt&#34; &#34;wave too much&#34; tsc-suffix-wave)&#xA;     (&#34;we&#34; &#34;wave excessively&#34; tsc-suffix-wave)]])&#xA;&#xA; ;; (tsc-layout-descriptions)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Dynamic Descriptions&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; The property list style for dynamic descriptions is the same for both prefixes and suffixes. Add =:description symbol-or-lambda-form= to the group vector or suffix list.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  (transient-define-prefix tsc-layout-dynamic-descriptions ()&#xA;    &#34;Prefix that generate descriptions dynamically when transient is shown.&#34;&#xA;    ;; group using function-name to generate description&#xA;    [:description current-time-string&#xA;     ;; single suffix with dynamic description&#xA;     (&#34;wa&#34; tsc-suffix-wave&#xA;      :description (lambda ()&#xA;                     (format &#34;Wave at %s&#34; (current-time-string))))]&#xA;    ;; group with anonymoous function generating description&#xA;    [:description (lambda ()&#xA;                    (format &#34;Group %s&#34; (org-id-new)))&#xA;                  (&#34;wu&#34; &#34;wave uniquely&#34; tsc-suffix-wave)])&#xA;&#xA; ;; (tsc-layout-dynamic-descriptions)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** TODO Errata :PROPERTIES: :TOC: :ignore this :END:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*Note*, the uuid is generated on every key input.  Layout updates are fun.&#xA;It does not also work when changing descriptions in the layout via hackery.&#xA;Âá∏( ` Ôæõ ¬¥ )Âá∏&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Layouts&lt;/p&gt; &#xA;&lt;p&gt;The default behavior treats groups a little differently depending on how they are nested. For most simple groupings, this is sufficient control.&lt;/p&gt; &#xA;&lt;p&gt;*** Groups one on top of the other&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Use a vector for each row.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-layout-stacked ()&#xA;   &#34;Prefix with layout that stacks groups on top of each other.&#34;&#xA;   [&#34;Top Group&#34; (&#34;wt&#34; &#34;wave top&#34; tsc-suffix-wave)]&#xA;   [&#34;Bottom Group&#34; (&#34;wb&#34; &#34;wave bottom&#34; tsc-suffix-wave)])&#xA;&#xA; ;; (tsc-layout-stacked)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Groups side by side&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Use a vector of vectors for columns.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-layout-columns ()&#xA;   &#34;Prefix with side-by-side layout.&#34;&#xA;   [[&#34;Left Group&#34; (&#34;wl&#34; &#34;wave left&#34; tsc-suffix-wave)]&#xA;    [&#34;Right Group&#34; (&#34;wr&#34; &#34;wave right&#34; tsc-suffix-wave)]])&#xA;&#xA; ;; (tsc-layout-columns)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Group on top of groups side by side&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Vector on top of vector inside a vector.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-layout-stacked-columns ()&#xA;   &#34;Prefix with stacked columns layout.&#34;&#xA;   [&#34;Top Group&#34;&#xA;    (&#34;wt&#34; &#34;wave top&#34; tsc-suffix-wave)]&#xA;&#xA;   [[&#34;Left Group&#34;&#xA;     (&#34;wl&#34; &#34;wave left&#34; tsc-suffix-wave)]&#xA;    [&#34;Right Group&#34;&#xA;     (&#34;wr&#34; &#34;wave right&#34; tsc-suffix-wave)]])&#xA;&#xA; ;; (tsc-layout-stacked-columns)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: Groups can have groups or suffixes, but not both. You can&#39;t mix suffixes alongside groups in the same vector. The resulting transient will error when invoked.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;*** Empty strings make spaces&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Groups that are empty or only space have no effect.  This situation can&#xA;happen with layouts that update dynamically.  See [[*dynamic layouts][dynamic layouts]].&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-layout-spaced-out ()&#xA;   &#34;Prefix lots of spacing for users to space out at.&#34;&#xA;   [&#34;&#34; ; cannot add another empty string because it will mix suffixes with groups&#xA;    [&#34;Left Group&#34;&#xA;     &#34;&#34;&#xA;     (&#34;wl&#34; &#34;wave left&#34; tsc-suffix-wave)&#xA;     (&#34;L&#34; &#34;wave lefter&#34; tsc-suffix-wave)&#xA;     &#34;&#34;&#xA;     (&#34;bl&#34; &#34;wave bottom-left&#34; tsc-suffix-wave)&#xA;     (&#34;z&#34; &#34;zone\n&#34; zone)] ; the newline does pad&#xA;&#xA;    [[]] ; empty vector will do nothing&#xA;&#xA;    [&#34;&#34;] ; vector with just empty line has no effect&#xA;&#xA;    ;; empty group will be ignored&#xA;    ;; (useful for hiding in dynamic layouts)&#xA;    [&#34;Empty Group\n&#34;]&#xA;&#xA;    [&#34;Right Group&#34;&#xA;     &#34;&#34;&#xA;     (&#34;wr&#34; &#34;wave right&#34; tsc-suffix-wave)&#xA;     (&#34;R&#34; &#34;wave righter&#34; tsc-suffix-wave)&#xA;     &#34;&#34;&#xA;     (&#34;br&#34; &#34;wave bottom-right&#34; tsc-suffix-wave)]])&#xA;&#xA; ;; (tsc-layout-spaced-out)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** A Grid&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;So, you put columns into rows that are in columns and stuff like that.  This&#xA;can be achieved with or without explicit column settings.&#xA;&#xA;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude&#xA;&#xA;  (transient-define-prefix tsc-layout-the-grid ()&#xA;    &#34;Prefix with groups in a grid-like arrangement.&#34;&#xA;&#xA;    [:description &#34;The Grid\n&#34; ; must use slot or macro is confused&#xA;     [&#34;Left Column&#34; ; note, no newline&#xA;      (&#34;ltt&#34; &#34;left top top&#34; tsc-suffix-wave)&#xA;      (&#34;ltb&#34; &#34;left top bottom&#34; tsc-suffix-wave)&#xA;      &#34;&#34;&#xA;      (&#34;lbt&#34; &#34;left bottom top&#34; tsc-suffix-wave)&#xA;      (&#34;lbb&#34; &#34;left bottom bottom&#34; tsc-suffix-wave)] ; note, no newline&#xA;&#xA;     [&#34;Right Column\n&#34;&#xA;      (&#34;rtt&#34; &#34;right top top&#34; tsc-suffix-wave)&#xA;      (&#34;rtb&#34; &#34;right top bottom&#34; tsc-suffix-wave)&#xA;      &#34;&#34;&#xA;      (&#34;rbt&#34; &#34;right bottom top&#34; tsc-suffix-wave)&#xA;      (&#34;rbb&#34; &#34;right bottom bottom\n&#34; tsc-suffix-wave)]])&#xA;&#xA;  ;; (tsc-layout-the-grid)&#xA;&#xA;#+end_src&#xA;&#xA;*Note*, only =transient-columns=, not =transient-column= can act as a group&#xA;of groups.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Manually setting group class&lt;/p&gt; &#xA;&lt;p&gt;If you need to override the class that the =transient-define-prefix= macro would normally use.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-layout-explicit-classes ()&#xA;   &#34;Prefix with group class used to explicitly specify layout.&#34;&#xA;   [:class transient-row &#34;Row&#34;&#xA;           (&#34;l&#34; &#34;wave left&#34; tsc-suffix-wave)&#xA;           (&#34;r&#34; &#34;wave right&#34; tsc-suffix-wave)]&#xA;   [:class transient-column &#34;Column&#34;&#xA;           (&#34;t&#34; &#34;wave top&#34; tsc-suffix-wave)&#xA;           (&#34;b&#34; &#34;wave bottom&#34; tsc-suffix-wave)])&#xA;&#xA; ;; (tsc-layout-explicit-classes)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Nesting &amp;amp; Flow Control :PROPERTIES: :TOC: :include descendants :depth 3 :local depth :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Single versus multiple commands][Single versus multiple commands]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Nesting][Nesting]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Binding a Sub-Prefix][Binding a Sub-Prefix]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[Nesting with multiple commands][Nesting with multiple commands]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[Setting up another transient manually][Setting up another transient manually]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Mixing Interactive][Mixing Interactive]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Early return][Early return]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Pre-Commands Explained][Pre-Commands Explained]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Warning!][Warning!]] :END:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Many transients call other transients. This allows you to express similar behaviors as interactive commands that ask you for multiple arguments using the minibuffer.&lt;/p&gt; &lt;p&gt;Transient has more options for retaining some state across several transients, making it easier to compose commands and to retain intermediate states for rapidly achieving series of actions over similar inputs.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Single versus multiple commands&lt;/p&gt; &#xA;&lt;p&gt;Sometimes you want to execute multiple commands without re-opening the transient. It&#39;s the same idea as [[https://github.com/emacsorphanage/god-mode][god mode]] or Evil repeat.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude __=tsc-wave-overridden&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-stay-transient ()&#xA;   &#34;Prefix where some suffixes do not exit.&#34;&#xA;   [&#34;Exit or Not?&#34;&#xA;&#xA;    ;; this suffix will not exit after calling sub-prefix&#xA;    (&#34;we&#34; &#34;wave &amp;amp; exit&#34; tsc-wave-overridden)&#xA;    (&#34;ws&#34; &#34;wave &amp;amp; stay&#34; tsc-wave :transient t)])&#xA;&#xA; ;; (tsc-stay-transient)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;, if =tsc-wave= was used in both exit &amp;amp; stay, the =:transient= slot would be clobbered and we would only get one behavior. Beware of re-using the same object instances in the same layout. Move the =:transient= slot override between the two suffixes to see the change in behavior.&lt;/p&gt; &#xA;&lt;p&gt;** Nesting&lt;/p&gt; &#xA;&lt;p&gt;Nesting is putting transients inside other transients, creating user-input sequences like:&lt;/p&gt; &#xA;&lt;p&gt;=Prefix -&amp;gt; Sub-Prefix -&amp;gt; Suffix=&lt;/p&gt; &#xA;&lt;p&gt;*** Binding a Sub-Prefix&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This is the most simple way to create nesting.&#xA;&#xA;#+name: simple-parent-child&#xA;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude&#xA;&#xA;  (transient-define-prefix tsc--simple-child ()&#xA;    [&#34;Simple Child&#34;&#xA;     (&#34;wc&#34; &#34;wave childishly&#34; tsc-suffix-wave)])&#xA;&#xA;  (transient-define-prefix tsc-simple-parent ()&#xA;    &#34;Prefix that calls a child prefix.&#34;&#xA;    [&#34;Simple Parent&#34;&#xA;     (&#34;w&#34; &#34;wave parentally&#34; tsc-suffix-wave)&#xA;     (&#34;b&#34; &#34;become child&#34; tsc--simple-child)])&#xA;&#xA;  ;; (tsc--simple-child)&#xA;  ;; (tsc-simple-parent)&#xA;&#xA;#+end_src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** Nesting with multiple commands&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; Declaring a nested prefix that &#34;returns&#34; to its parent has a convenient&#xA; shorthand form.&#xA;&#xA;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude __=simple-parent-child&#xA;&#xA;  (transient-define-prefix tsc-simple-parent-with-return ()&#xA;    &#34;Prefix with a child prefix that returns.&#34;&#xA;    [&#34;Parent With Return&#34;&#xA;     (&#34;w&#34; &#34;wave parentally&#34; tsc-suffix-wave)&#xA;     (&#34;b&#34; &#34;become child with return&#34; tsc--simple-child :transient t)])&#xA;&#xA;  ;; Child does not &#34;return&#34; when called independently&#xA;  ;; (tsc--simple-child)&#xA;  ;; (tsc-simple-parent-with-return)&#xA;&#xA;#+end_src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Setting up another transient manually&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;If you call =(transient-setup &#39;transient-command-symbol)=, you will activate&#xA;a replacement transient.&#xA;&#xA;This form is useful if you want a command to /perhaps/ load yet another&#xA;transient in some situation.  You may even just want to load the same&#xA;transient with different context, such as passing in a new [[*Scope][scope]].&#xA;&#xA;#+begin_src elisp :tangle transient-showcase.el :var _=simple-parent-child __=wave-prelude&#xA;&#xA;  (transient-define-suffix tsc-suffix-setup-child ()&#xA;    &#34;A suffix that uses `transient-setup&#39; to manually load another transient.&#34;&#xA;    (interactive)&#xA;    ;; note that it&#39;s usually during the post-command side of calling the&#xA;    ;; command that the actual work to set up the transient will occur.&#xA;    ;; This is an implementation detail because it depends if we are calling&#xA;    ;; `transient-setup&#39; while already transient or not.&#xA;    (transient-setup &#39;tsc--simple-child))&#xA;&#xA;  (transient-define-prefix tsc-parent-with-setup-suffix ()&#xA;    &#34;Prefix with a suffix that calls `transient-setup&#39;.&#34;&#xA;    [&#34;Simple Parent&#34;&#xA;     (&#34;wp&#34; &#34;wave parentally&#34; tsc-suffix-wave :transient t) ; remain transient&#xA;&#xA;     ;; You may need to specify a different pre-command (the :transient) key&#xA;     ;; because we need to clean up this transient or create some conditions&#xA;     ;; to trigger the following transient correctly.  This example will&#xA;     ;; work with `transient--do-replace&#39; or no custom pre-command&#xA;&#xA;     (&#34;bc&#34; &#34;become child&#34; tsc-suffix-setup-child :transient transient--do-replace)])&#xA;&#xA;  ;; (tsc-parent-with-setup-suffix)&#xA;&#xA;#+end_src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** TODO Errata :PROPERTIES: :ID: e6f2ba1b-b67e-4bde-8aaf-d3decba915c4 :TOC: :ignore this :END:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; This example should also work with the =transient--do-recurse= pre-command,&#xA; but the child transient does not return.  There is a difference in the&#xA; behavior that should not depend on if the suffix /is/ the prefix or just sets&#xA; up the prefix.  *Possible bug*.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Mixing Interactive&lt;/p&gt; &#xA;&lt;p&gt;You can mix normal Emacs completion flows with transient UI&#39;s.&lt;/p&gt; &#xA;&lt;p&gt;See [[info:elisp#Interactive Codes][Interactive codes]] are listed in the Elisp manual.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;, this also works when binding existing commands that recieve user input.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-suffix tsc--suffix-interactive-string (user-input)&#xA;   &#34;An interactive suffix that obtains string input from the user.&#34;&#xA;   (interactive &#34;sPlease just tell me what you want!: &#34;)&#xA;   (message &#34;I think you want: %s&#34; user-input))&#xA;&#xA; (transient-define-suffix tsc--suffix-interactive-buffer-name (buffer-name)&#xA;   &#34;An interactive suffix that obtains a buffer name from the user.&#34;&#xA;   (interactive &#34;b&#34;)&#xA;   (message &#34;You selected: %s&#34; buffer-name))&#xA;&#xA; (transient-define-prefix tsc-interactive-basic ()&#xA;   &#34;Prefix with interactive user input.&#34;&#xA;   [&#34;Interactive Command Suffixes&#34;&#xA;    (&#34;s&#34; &#34;enter string&#34; tsc--suffix-interactive-string)&#xA;    (&#34;b&#34; &#34;select buffer&#34; tsc--suffix-interactive-buffer-name)])&#xA;&#xA; ;; (tsc-interactive-basic)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Early return&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Sometimes you can complete your work without asking the user for more input.&#xA;In the custom body for a prefix, if you decline to call =transient-setup=,&#xA;then the command will just exit with no problems.&#xA;&#xA;Below is a nested transient.&#xA;&#xA;- The body form of the nested child can return early without loading a new transient&#xA;- The parent uses =transient--do-recurse= to make it&#39;s child &#34;return&#34; to it&#xA;- The &#34;radiations&#34; command in the child explicitly overrides this, using&#xA;  =transient--do-exit= so that it /does not/ return to the parent&#xA;&#xA;#+begin_src elisp :tangle transient-showcase.el&#xA;&#xA;  (defvar tsc--complex nil &#34;Show complex menu or not.&#34;)&#xA;&#xA;  (transient-define-suffix tsc--toggle-complex ()&#xA;    &#34;Toggle `tsc--complex&#39;.&#34;&#xA;    :transient t&#xA;    :description (lambda () (format &#34;toggle complex: %s&#34; tsc--complex))&#xA;    (interactive)&#xA;    (setf tsc--complex (not tsc--complex))&#xA;    (message (propertize (concat &#34;Complexity set to: &#34;&#xA;                                 (if tsc--complex &#34;true&#34; &#34;false&#34;))&#xA;                         &#39;face &#39;success)))&#xA;&#xA;  (transient-define-prefix tsc-complex-messager ()&#xA;    &#34;Prefix that sends complex messages, unles `tsc--complex&#39; is nil.&#34;&#xA;    [&#34;Send Complex Messages&#34;&#xA;     (&#34;s&#34; &#34;snow people&#34;&#xA;      (lambda () (interactive)&#xA;        (message (propertize &#34;snow people! ‚òÉ&#34; &#39;face &#39;success))))&#xA;     (&#34;k&#34; &#34;kitty cats&#34;&#xA;      (lambda () (interactive)&#xA;        (message (propertize &#34;üêà kitty cats! üêà&#34; &#39;face &#39;success))))&#xA;     (&#34;r&#34; &#34;radiations&#34;&#xA;      (lambda () (interactive)&#xA;        (message (propertize &#34;Oh no! radiation! ‚ò¢&#34; &#39;face &#39;success)))&#xA;      ;; radiation is dangerous!&#xA;      :transient transient--do-exit)]&#xA;&#xA;    (interactive)&#xA;    ;; The command body either sets up the transient or simply returns&#xA;    ;; This is the &#34;early return&#34; we&#39;re talking about.&#xA;    (if tsc--complex&#xA;        (transient-setup &#39;tsc-complex-messager)&#xA;      (message &#34;Simple and boring!&#34;)))&#xA;&#xA;  (transient-define-prefix tsc-simple-messager ()&#xA;    &#34;Prefix that toggles child behavior!&#34;&#xA;    [[&#34;Send Message&#34;&#xA;      ;; using `transient--do-recurse&#39; causes suffixes in tsc-child to perform&#xA;      ;; `transient--do-return&#39; so that we come back to this transient.&#xA;      (&#34;m&#34; &#34;message&#34; tsc-complex-messager :transient transient--do-recurse)]&#xA;     [&#34;Toggle Complexity&#34;&#xA;      (&#34;t&#34; tsc--toggle-complex)]])&#xA;&#xA;  ;; (tsc-simple-messager)&#xA;  ;; does not &#34;return&#34; when called independently&#xA;  ;; (tsc-complex-messager)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Pre-Commands Explained :PROPERTIES: :ID: 0c106a1b-d824-4321-89a5-b1e06b468c63 :END:&lt;/p&gt; &#xA;&lt;p&gt;The value in the =:transient= slot affects what state the body of your command will see and what will happen after your command, during the post-command.&lt;/p&gt; &#xA;&lt;p&gt;The =:transient= slot holds a function called the &#34;pre-command.&#34; Before your suffix body forms run, the pre-command is called and creates the conditions that your suffix may use to, for example, prepare for reading variables that were set on infixes. If the pre-command calls =transient-export= then it will add to history.&lt;/p&gt; &#xA;&lt;p&gt;In =transient-define-prefix= and =transient-define-suffix=, the =t= value is actually translated to =transient--do-call= or =transient--do-recurse= depending on the situation.&lt;/p&gt; &#xA;&lt;p&gt;These functions set up some states so that post-command can figure out if it needs to exit, save values, or enter another transient, and what else to do while entering that new transient.&lt;/p&gt; &#xA;&lt;p&gt;The [[https://magit.vc/manual/transient.html#Transient-State][official long manual]] has some more detail. These examples should prepare you to visualize the forms used in those explanations.&lt;/p&gt; &#xA;&lt;p&gt;*** Warning!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Some of the *trickiest bugs you can introduce* will happen when using the&#xA;following variables and functions at varying points in command lifecycles:&#xA;&#xA;- =transient-current-command=&#xA;- =transient--command=&#xA;- =transient-current-prefix=&#xA;- =transient--prefix=&#xA;- =transient-args=&#xA;&#xA;During the pre-command and post-command, these can change.  When you are&#xA;overriding the pre-command, you may discover things such as the result of&#xA;=transient-args= changing.  Calling =transient-setup= may update things.&#xA;Even if you call =transient-args= on on the specific transient, the results&#xA;change during the lifecycle and depending on the pre-command.&#xA;&#xA;*In particular* it seems like layout predicates should use&#xA;=transient--prefix= while suffix bodies should use&#xA;=transient-current-prefix=.&#xA;&#xA;Not all pre-commands are compatible with all situations and suffixes!&#xA;&#xA;[[Debugging][Debugging]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** TODO Errata :PROPERTIES: :TOC: :ignore this :END:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; There&#39;s definitely some edge cases that are unnecessarily complex for the&#xA; use case.  Think of how life was before =transient--do-recurse=.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using &amp;amp; Managing States :PROPERTIES: :TOC: :include descendants :depth 3 :local depth :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[The Magic of Transient][The Magic of Transient]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Infixes][Infixes]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Basic Infixes][Basic Infixes]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Reading Infix Values][Reading Infix Values]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Scope][Scope]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Prefix Value &amp;amp; History][Prefix Value &amp;amp; History]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[History Keys][History Keys]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Detangling with Initialization, Setting, and Saving][Detangling with Initialization, Setting, and Saving]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Disabling Set / Save on a Suffix][Disabling Set / Save on a Suffix]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Setting or Saving Every Time a Suffix is Used][Setting or Saving Every Time a Suffix is Used]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Sticky infix support][Sticky infix support]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Default Values][Default Values]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Readers][Readers]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Lisp Variables][Lisp Variables]] :END:&lt;/p&gt; &lt;p&gt;There are several ways to create state. The [[*Nesting &amp;amp; Flow Control][flow control]] examples in the previous section mainly covered how to get from one command to the other. This section covers how to save values and then read them later, sometimes from a completely different transient. *Coupled with [[&lt;em&gt;Custom Infix Types][custom infix types]], you can create some seriously rich user expression.&lt;/em&gt;&lt;/p&gt; &lt;p&gt;To spark your imagination, here&#39;s a non-exhaustive list of how to get data into your commands:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Interactive forms&lt;/li&gt; &#xA;   &lt;li&gt;Prefix arguments (=C-u= universal argument)&lt;/li&gt; &#xA;   &lt;li&gt;Setting the scope in =transient-setup=&lt;/li&gt; &#xA;   &lt;li&gt;Obtaining a scope in a custom =transient-init-scope= method&lt;/li&gt; &#xA;   &lt;li&gt;Default values in prefix definition&lt;/li&gt; &#xA;   &lt;li&gt;Saved values of infixes&lt;/li&gt; &#xA;   &lt;li&gt;Saved values in other infixes / prefixs with shared =history-key=&lt;/li&gt; &#xA;   &lt;li&gt;User-set infix values from the current or parent prefix&lt;/li&gt; &#xA;   &lt;li&gt;Ad-hoc values in regular =defvar= and =defcustom= etc&lt;/li&gt; &#xA;   &lt;li&gt;Reading values from another, perhaps distant prefix&lt;/li&gt; &#xA;   &lt;li&gt;Arguments passed into interactive commands to call them as normal elisp functions&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** The Magic of Transient&lt;/p&gt; &#xA;&lt;p&gt;Using all of these mechanisms, you can enable users to rapidly construct complex command sentences, sentences with phrases. You can basically make a user interface as expressive as elisp.&lt;/p&gt; &#xA;&lt;p&gt;A user input sequence like this:&lt;/p&gt; &#xA;&lt;p&gt;=Prefix -&amp;gt; Interactive -&amp;gt; Sub-Prefix -&amp;gt; Infix -&amp;gt; Suffix -&amp;gt; Suffix -&amp;gt; ...=&lt;/p&gt; &#xA;&lt;p&gt;Is basically the same as doing this in elisp:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle no :eval never&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (let ((input (Sub-Prefix (Prefix (Interactive))))&#xA;       (infix (Infix)))&#xA;   (suffix input infix)&#xA;   (suffix input infix))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;With history, you can remember lots of these states. This allows the user to quickly fire off lots of mostly completed partial expressions. They are scoped, so you can keep state over different contexts.&lt;/p&gt; &#xA;&lt;p&gt;This is what is meant by &#34;creating user interfaces as expressive as elisp.&#34;&lt;/p&gt; &#xA;&lt;p&gt;Because interactive forms and transients are both still just consuming linear user input, they ultimately have the same capabilities, but if you /think/ in terms of partially constructed elisp expressions, you can do more than if the user has to enter in contextless commands over and over or write more commands while managing their own state in ad-hoc fashion.&lt;/p&gt; &#xA;&lt;p&gt;Transient&#39;s UI also provides greater awareness to the user of the current state. This makes it easier for the user to achieve the greater complexity that is intended, without remembering the command language you are designing for your application.&lt;/p&gt; &#xA;&lt;p&gt;** Infixes&lt;/p&gt; &#xA;&lt;p&gt;Functions need arguments. Infixes are specialized suffixes with behavior defaults that make sense for setting and storing values for consumption in suffixes. It&#39;s like passing arguments into the suffix. They also have support for persisting state across invocations and Emacs sessions.&lt;/p&gt; &#xA;&lt;p&gt;*** Basic Infixes&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Infix classes built-in all descend from =transient-infix= and can be seen&#xA;clearly in the =eieio-browse=.  View their slots and documentaiton with&#xA;~(describe-class transient-infix)~ etc.  Here you can see what most infixes&#xA;look like and how they behave.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; ;; infix defined with a macro&#xA; (transient-define-argument tsc--exclusive-switches ()&#xA;   &#34;This is a specialized infix for only selecting one of several values.&#34;&#xA;   :class &#39;transient-switches&#xA;   :argument-format &#34;--%s-snowcone&#34;&#xA;   :argument-regexp &#34;\\(--\\(grape\\|orange\\|cherry\\|lime\\)-snowcone\\)&#34;&#xA;   :choices &#39;(&#34;grape&#34; &#34;orange&#34; &#34;cherry&#34; &#34;lime&#34;))&#xA;&#xA; (transient-define-prefix tsc-basic-infixes ()&#xA;   &#34;Prefix that just shows off many typical infix types.&#34;&#xA;   [&#34;Infixes&#34;&#xA;&#xA;    ;; from macro&#xA;    (&#34;-e&#34; &#34;exclusive switches&#34; tsc--exclusive-switches)&#xA;&#xA;    ;; shorthand definitions&#xA;    (&#34;-b&#34; &#34;switch with shortarg&#34; (&#34;-w&#34; &#34;--switch-short&#34;)) ; with :short-arg != :key&#xA;    (&#34;-s&#34; &#34;switch&#34; &#34;--switch&#34;)&#xA;    ( &#34;n&#34; &#34;no dash switch&#34; &#34;still works&#34;)&#xA;    (&#34;-a&#34; &#34;argument&#34; &#34;--argument=&#34; :prompt &#34;Let&#39;s argue because: &#34;)&#xA;&#xA;    ;; a bit of inline EIEIO in our shorthand&#xA;    (&#34;-n&#34; &#34;never empty&#34; &#34;--non-null=&#34; :always-read t  :allow-empty nil&#xA;     :init-value (lambda (obj) (oset obj value &#34;better-than-nothing&#34;)))&#xA;&#xA;    (&#34;-c&#34; &#34;choices&#34; &#34;--choice=&#34; :choices (foo bar baz))]&#xA;&#xA;   [&#34;Show Args&#34;&#xA;    (&#34;s&#34; &#34;show arguments&#34; tsc-suffix-print-args)])&#xA;&#xA; ;; (tsc-basic-infixes)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Reading Infix Values&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Reminder&lt;/em&gt; in the section on [[*Pre-Commands Explained][pre-commands]] the discussion about the =:transient= mentions that the values available in a suffix body depend on whe ther the pre-command called =transient--export= before evaluating the suffix body.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;There are two basic ways to read infixes:&#xA;&#xA;- =(transient-args transient-current-command)= and parse manually&#xA;- =(transient-arg-value &#34;--argument-&#34; (transient-args transient-current-command)=&#xA;- =(transient-suffixes transient-current-command)= and retrieve your fully&#xA;  hydrated suffix&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** TODO The =transient-suffixes= option requires filtering :PROPERTIES: :TOC: :ignore this :END:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; In my opinion the API should make it easer to get raw values from suffixes,&#xA; but this is also a matter of custom infixes needing to serialize values&#xA; correctly so that =transient-arg-value= will &#34;just work&#34;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Scope&lt;/p&gt; &#xA;&lt;p&gt;When you call a function with an argument, you want to know in the body of your function what that argument was. This is the scope. The prefix is initialized with the =:scope= either in it&#39;s own body or a similar form. Suffixes can then read back that scope in their body. The suffix object is given the scope and can use it to alter its own display or behavior. The layout also can interpret the scope while it is initializing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;WARNING&lt;/em&gt; When writing predicates against the scope, you will need to determine whether =transient--prefix= or =transient-current-prefix= is correct when writing prefix-generic suffixes. It is very subtle if you accidentally choose the wrong one and the parent has a nil scope while the child has an entirely different scope. These variables change throughout the lifecycle! Use [[*Watching evaluation in Edebug][edebug]] you must!&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-suffix tsc--read-prefix-scope ()&#xA;   &#34;Read the scope of the prefix.&#34;&#xA;   :transient &#39;transient--do-call&#xA;   (interactive)&#xA;   (let ((scope (oref transient-current-prefix scope)))&#xA;     (message &#34;scope: %s&#34; scope)))&#xA;&#xA; (transient-define-suffix tsc--double-scope-re-enter ()&#xA;   &#34;Re-enter the current prefix with double the scope.&#34;&#xA;   ;; :transient &#39;transient--do-replace ; builds up the stack&#xA;   :transient &#39;transient--do-exit&#xA;   (interactive)&#xA;   (let ((scope (oref transient-current-prefix scope)))&#xA;     (if (numberp scope)&#xA;         (transient-setup transient-current-command nil nil :scope (* scope 2))&#xA;       (message (propertize (format &#34;scope was non-numeric! %s&#34; scope) &#39;face &#39;warning))&#xA;       (transient-setup transient-current-command))))&#xA;&#xA; (transient-define-suffix tsc--update-scope-with-prefix-re-enter (new-scope)&#xA;   &#34;Re-enter the prefix with double the scope.&#34;&#xA;   ;; :transient &#39;transient--do-replace ; builds up the stack&#xA;   :transient &#39;transient--do-exit ; do not build up the stack&#xA;   (interactive &#34;P&#34;)&#xA;   (message &#34;universal arg: %s&#34; new-scope)&#xA;   (transient-setup transient-current-command nil nil :scope new-scope))&#xA;&#xA; (transient-define-prefix tsc-scope (scope)&#xA;   &#34;Prefix demonstrating use of scope.&#34;&#xA;&#xA;   ;; note!  this is a location where we definitely had to use&#xA;   ;; `transient--prefix&#39; or get the transient object from the tsc-scope symbol.&#xA;   ;; `transient-current-prefix&#39; is not correct here!&#xA;   [:description (lambda () (format &#34;Scope: %s&#34; (oref transient--prefix scope)))&#xA;    [(&#34;r&#34; &#34;read scope&#34; tsc--read-prefix-scope)&#xA;     (&#34;d&#34; &#34;double scope&#34; tsc--double-scope-re-enter)&#xA;     (&#34;o&#34; &#34;update scope (use prefix argument)&#34; tsc--update-scope-with-prefix-re-enter)]]&#xA;   (interactive &#34;P&#34;)&#xA;   (transient-setup &#39;tsc-scope nil nil :scope scope))&#xA;&#xA; ;; Setting an interactive argument for `eval-last-sexp&#39; is a little different&#xA; ;; (let ((current-prefix-arg 4)) (call-interactively &#39;tsc-scope))&#xA;&#xA; ;; (tsc-scope)&#xA; ;; Then press &#34;C-u 4 o&#34; to update the scope&#xA; ;; Then d to double&#xA; ;; Then r to read&#xA; ;; ... and so on&#xA; ;; C-g to exit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** TODO Errata with prefix arg (=C-u= universal argument). :PROPERTIES: :TOC: :ignore this :END:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Key binding sequences, such as &#34;wa&#34; instead of single-key prefix bindings&#xA;will unset the prefix argument (the old-school Emacs =C-u= prefix argument,&#xA;not the prefix&#39;s scope or other explicit arguments)&#xA;&#xA;*Possibly a bug in transient.*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Prefix Value &amp;amp; History&lt;/p&gt; &#xA;&lt;p&gt;Briefly, there are three locations for state you need to be aware of for this section:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Each transient&#39;s prefix object has a =:value= that is updated by =transient-set= and =transient-save=&lt;/li&gt; &#xA; &lt;li&gt;The values obtained from =transient-args= are usually quite ephemeral and don&#39;t even persist beyond the body of form of the suffixes you usually read them in&lt;/li&gt; &#xA; &lt;li&gt;=transient-values= contains saved values that are used to rehydrate the prefix =:value= slot when the prefix is created&lt;/li&gt; &#xA; &lt;li&gt;=transient-history= is used to make it faster for the user to flip through previous states (which can have independent histories for infixes and prefixes). These are never used unless calling =transient-history-prev= and =transient-history-next=.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We can get this as a list of strings for any prefix by calling =transient-args= on =transient-current-command= in the suffix&#39;s interactive form. If you know the command you want the value of, you can use it&#39;s symbol instead of =transient-current-command=.&lt;/p&gt; &#xA;&lt;p&gt;This is related to history keys. If you set the arguments and then save them using (=C-x s=) for the command =transient-save=, not only will the transient be updated with the new value, but if you call the child independently, it can still read the value from the suffix.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(transient-define-suffix tsc-suffix-eat-snowcone (args)&#xA;  &#34;Eat the snowcone!&#xA;This command can be called from it&#39;s parent, `tsc-snowcone-eater&#39; or independently.&#34;&#xA;  :transient t&#xA;  ;; you can use the interactive form of a command to obtain a default value&#xA;  ;; from the user etc if the one obtained from the parent is invalid.&#xA;  (interactive (list (transient-args &#39;tsc-snowcone-eater)))&#xA;&#xA;  ;; `transient-arg-value&#39; can (with varying success) pick out individual&#xA;  ;; values from the results of `transient-args&#39;.&#xA;&#xA;  (let ((topping (transient-arg-value &#34;--topping=&#34; args))&#xA;        (flavor (transient-arg-value &#34;--flavor=&#34; args)))&#xA;    (message &#34;I ate a %s flavored snowcone with %s on top!&#34; flavor topping)))&#xA;&#xA;(transient-define-prefix tsc-snowcone-eater ()&#xA;  &#34;Prefix demonstrating set &amp;amp; save infix persistence.&#34;&#xA;&#xA;  ;; This prefix has a default value that tsc-suffix-eat-snowcone can see&#xA;  ;; even before the prefix has been called.&#xA;  :value &#39;(&#34;--topping=fruit&#34; &#34;--flavor=cherry&#34;)&#xA;&#xA;  ;; always-read is used below so that you don&#39;t save nil values to history&#xA;  [&#34;Arguments&#34;&#xA;   (&#34;-t&#34; &#34;topping&#34; &#34;--topping=&#34;&#xA;    :choices (&#34;ice cream&#34; &#34;fruit&#34; &#34;whipped cream&#34; &#34;mochi&#34;)&#xA;    :always-read t)&#xA;   (&#34;-f&#34; &#34;flavor&#34; &#34;--flavor=&#34;&#xA;    :choices (&#34;grape&#34; &#34;orange&#34; &#34;cherry&#34; &#34;lime&#34;)&#xA;    :always-read t)]&#xA;&#xA;  ;; Definitely check out the =C-x= menu&#xA;  [&#34;C-x Menu Behaviors&#34;&#xA;   (&#34;S&#34; &#34;save snowcone settings&#34;&#xA;    (lambda () (interactive) (message &#34;saved!&#34;) (transient-save)) :transient t)&#xA;   (&#34;R&#34; &#34;reset snowcone settings&#34;&#xA;    (lambda () (interactive) (message &#34;reset!&#34;) (transient-reset)) :transient t)]&#xA;&#xA;  [&#34;Actions&#34;&#xA;   (&#34;m&#34; &#34;message arguments&#34; tsc-suffix-print-args)&#xA;   (&#34;e&#34; &#34;eat snowcone&#34; tsc-suffix-eat-snowcone)])&#xA;&#xA;;; First call will use the transient&#39;s default value&#xA;;; M-x tsc-suffix-eat-snowcone or `eval-last-sexp&#39; below&#xA;;; (call-interactively &#39;tsc-suffix-eat-snowcone)&#xA;;; (tsc-snowcone-eater)&#xA;;; Eat some snowcones with different flavors&#xA;;; ...&#xA;;; ...&#xA;;; ...&#xA;;; Now save the value and exit the transient.&#xA;;; When you call the suffix independently, it can still read the saved values!&#xA;;; M-x tsc-suffix-eat-snowcone or `eval-last-sexp&#39; below&#xA;;; (call-interactively &#39;tsc-suffix-eat-snowcone)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s worth bringing up the [[elisp:(describe-variable &#39;transient-show-common-commands)][=transient-show-common-commands=]] variable. &lt;em&gt;You may want to set this when working on the history support for your transients.&lt;/em&gt; Otherwise, just remember the (=C-x=) menu inside transients.&lt;/p&gt; &#xA;&lt;p&gt;** History Keys&lt;/p&gt; &#xA;&lt;p&gt;History lets you &lt;em&gt;set&lt;/em&gt; infixes using prior values. It&#39;s per-prefix, per-suffix usually. Using previous examples like =tsc-snowcone-eater=, you can flip through history using:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=C-x p= for =transient-history-prev=&lt;/li&gt; &#xA; &lt;li&gt;=C-x n= for =transient-history-next=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These bindings are revealed when =transient-show-common-commands= is =t= or when you hit the =C-x= prefix.&lt;/p&gt; &#xA;&lt;p&gt;However, what if you &lt;em&gt;don&#39;t&lt;/em&gt; want a unique history for some infixes or even prefixes?&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt; As a more advanced example, using EIEIO and dynamic layout techniques to modify the slot of =:history-key=, you can also make unique histories for the same prefix/infix by setting that slot value depending on the context you want unique histories for.&lt;/p&gt; &#xA;&lt;p&gt;The following example can demonstrate the behavior with some user effort:&lt;/p&gt; &#xA;&lt;p&gt;#+name: tsc-ping-example #+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(transient-define-prefix tsc-ping ()&#xA;  &#34;Prefix demonstrating history sharing.&#34;&#xA;&#xA;  :history-key &#39;non-unique-name&#xA;&#xA;  [&#34;Ping&#34;&#xA;   (&#34;-g&#34; &#34;game&#34; &#34;--game=&#34;)&#xA;   (&#34;p&#34; &#34;ping the pong&#34; tsc-pong)&#xA;   (&#34;a&#34; &#34;print args&#34; tsc-suffix-print-args :transient nil)])&#xA;&#xA;(transient-define-prefix tsc-pong ()&#xA;  &#34;Prefix demonstrating history sharing.&#34;&#xA;&#xA;  :history-key &#39;non-unique-name&#xA;&#xA;  [&#34;Pong&#34;&#xA;   (&#34;-g&#34; &#34;game&#34; &#34;--game=&#34;)&#xA;   (&#34;p&#34; &#34;pong the ping&#34; tsc-ping)&#xA;   (&#34;a&#34; &#34;print args&#34; tsc-suffix-print-args :transient nil)])&#xA;&#xA;;; (tsc-ping)&#xA;;; Okay here&#39;s where it gets weird&#xA;;; 1.  Set the value of game to something and remember it&#xA;;; 2.  Press a to print the args&#xA;;; 3.  Re-open tsc-ping.&#xA;;; 4.  C-x p to load the previous history, see the old value?&#xA;;; 5.  p to switch to the tsc-pong transient&#xA;;; 6.  C-x p to load the previous history, see the old value from tsc-ping???&#xA;;; 7. Note that tsc-pong uses the same history as tsc-ping!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Detangling with Initialization, Setting, and Saving :PROPERTIES: :ID: 6f6c8eba-1c0e-41c4-b57f-c06ab00f64d1 :END:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Set values show up in the prefix&#39;s =value= slot.&#xA;&#xA;#+begin_src elisp :tangle no :var _=tsc-ping-example&#xA;&#xA;  (oref (plist-get (symbol-plist &#39;tsc-ping) &#39;transient--prefix) value)&#xA;&#xA;#+end_src&#xA;&#xA;The prefix value will get the last value that was *set* using&#xA;=transient-set=.&#xA;&#xA;However, the prefix value shown in =transient-values= is only updated when&#xA;calling =transient-save=.&#xA;&#xA;Saved values show up in =transient-values=.  If you save =tsc-ping=, you can&#xA;see the saved value here:&#xA;&#xA;#+begin_src elisp :tangle no :var _=tsc-ping-example&#xA;&#xA;  (assoc &#39;tsc-ping transient-values)&#xA;&#xA;#+end_src&#xA;&#xA;*These two values may be independent.* They are written at the same time&#xA;when calling =transient-save=.  During prefix initializaton, the =:value= is&#xA;written from =transient-values=.&#xA;&#xA;Play with the =tsc-snowcone-eater= and =tsc-ping= and =tsc-pong= in the =C-x=&#xA;menu while also looking at what gets stored in =transient-values=,&#xA;=transient-history= and the prefix&#39;s slots.&#xA;&#xA;When you re-evaluate the prefix or reload Emacs, you will see the result of&#xA;initialization from =transient-values=.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Disabling Set / Save on a Suffix&lt;/p&gt; &#xA;&lt;p&gt;To disable saving and setting values, causing a prefix to always end up using the default value, set the =:unsavable= slot to =t=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-goldfish ()&#xA;   &#34;A prefix that cannot remember anything.&#34;&#xA;   [&#34;Goldfish&#34;&#xA;    (&#34;-r&#34; &#34;rememeber&#34; &#34;--i-remember=&#34;&#xA;     :unsavable t ; infix isn&#39;t saved&#xA;     :always-read t ; infix always asks for new value&#xA;     ;; overriding the method to provide a starting value&#xA;     :init-value (lambda (obj) (oset obj value &#34;nothing&#34;)))&#xA;    (&#34;a&#34; &#34;print args&#34; tsc-suffix-print-args :transient nil)])&#xA;&#xA; ;; (tsc-goldfish)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Try to update =remember= and then set and save it in the =C-x= menu. Reload it. It will never pay attention to history or setting &amp;amp; saving the transient value.&lt;/p&gt; &#xA;&lt;p&gt;** Setting or Saving Every Time a Suffix is Used&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-suffix tsc-suffix-remember-and-wave ()&#xA;   &#34;Wave, and force the prefix to set it&#39;s saveable infix values.&#34;&#xA;   (interactive)&#xA;&#xA;   ;; (transient-reset) ; forget&#xA;   (transient-set) ; save for this session&#xA;   ;; If you combine reset with set, you get a reset for future sessions only.&#xA;   ;; (transient-save) ; save for this and future sessions&#xA;   ;; (transient-reset-value some-other-prefix-object)&#xA;&#xA;   (message &#34;Waves at user at: %s.  You will never be forgotten.&#34; (current-time-string)))&#xA;&#xA; (transient-define-prefix tsc-elephant ()&#xA;   &#34;A prefix that always remembers its infixes.&#34;&#xA;   [&#34;Elephant&#34;&#xA;    (&#34;-r&#34; &#34;rememeber&#34; &#34;--i-remember=&#34;&#xA;     :always-read t)&#xA;    (&#34;w&#34; &#34;remember and wave&#34; tsc-suffix-remember-and-wave)&#xA;    (&#34;a&#34; &#34;print args (skips remembering)&#34; tsc-suffix-print-args :transient nil)])&#xA;&#xA; ;; (tsc-elephant)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** TODO Sticky infix support&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;There needs to be a slot that causes infixes to always be set on export.&#xA;This would cover cases where the most frequent user input changes just&#xA;rapidly enough that both setting every time and saving are equally&#xA;inconvenient.  Using =transient-set= is kind of brute-ish.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Default Values&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Every transient prefix has a value.  It&#39;s a list.  You can set it to create&#xA;defaults for switches and arguments.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-default-values ()&#xA;   &#34;A prefix with a default value.&#34;&#xA;&#xA;   :value &#39;(&#34;--toggle&#34; &#34;--value=5&#34;)&#xA;&#xA;   [&#34;Arguments&#34;&#xA;    (&#34;t&#34; &#34;toggle&#34; &#34;--toggle&#34;)&#xA;    (&#34;v&#34; &#34;value&#34; &#34;--value=&#34; :prompt &#34;an integer: &#34;)]&#xA;&#xA;   [&#34;Show Args&#34;&#xA;    (&#34;s&#34; &#34;show arguments&#34; tsc-suffix-print-args)])&#xA;&#xA; ;; (tsc-default-values)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;, after setting or saving a value on this transient using the =C-x= menu, the next time the transient is set up, it will have a different value. If you want the default to return, use =transient-reset= in your suffix.&lt;/p&gt; &#xA;&lt;p&gt;*** Readers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Readers are the mechanism to provide completions and to enforce input&#xA;validity of infixes.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-enforcing-inputs ()&#xA;   &#34;A prefix with enforced input type.&#34;&#xA;&#xA;   [&#34;Arguments&#34;&#xA;    (&#34;v&#34; &#34;value&#34; &#34;--value=&#34; :prompt &#34;an integer: &#34; :reader transient-read-number-N+)]&#xA;&#xA;   [&#34;Show Args&#34;&#xA;    (&#34;s&#34; &#34;show arguments&#34; tsc-suffix-print-args)])&#xA;&#xA; ;; (tsc-enforcing-inputs)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Setting the reader can be used to enforce rules of valid input. See [[id:0c3f2271-98e0-4db4-b95b-e31975bcbb5e][Advanced/Custom Infix Types]] for an example of writing a custom reader that validates input and assigning that reader via the class method instead of the =:reader= slot.&lt;/p&gt; &#xA;&lt;p&gt;** Lisp Variables&lt;/p&gt; &#xA;&lt;p&gt;Lisp variables are currently at an experimental support level. They way they work is to report and set the value of a lisp symbol variable. Because they aren&#39;t necessarilly intended to be printed as crude CLI arguments, they &lt;em&gt;DO NOT&lt;/em&gt; appear in =(transient-args &#39;prefix)= but this is fine because you can just use the variable.&lt;/p&gt; &#xA;&lt;p&gt;Customizing this class can be useful when working with objects and functions that exist entirely in elisp.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=wave-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (defvar tsc--position &#39;(0 0) &#34;A transient prefix location.&#34;)&#xA;&#xA;   (transient-define-infix tsc--pos-infix ()&#xA;     &#34;A location, key, or command symbol.&#34;&#xA;     :class &#39;transient-lisp-variable&#xA;     :transient t&#xA;     :prompt &#34;An expression such as (0 0), \&#34;p\&#34;, nil, &#39;tsc--msg-pos: &#34;&#xA;     :variable &#39;tsc--position)&#xA;&#xA;   (transient-define-suffix tsc--msg-pos ()&#xA;     &#34;Message the element at location.&#34;&#xA;     :transient &#39;transient--do-call&#xA;     (interactive)&#xA;     ;; lisp variables are not sent in the usual (transient-args) list.&#xA;     ;; Just read `tsc--position&#39; directly.&#xA;     (let ((suffix (transient-get-suffix transient-current-command tsc--position)))&#xA;       (message &#34;%s&#34; (oref suffix description))))&#xA;&#xA;   (transient-define-prefix tsc-lisp-variable ()&#xA;     &#34;A prefix that updates and uses a lisp variable.&#34;&#xA;     [&#34;Location Printing&#34;&#xA;      [(&#34;p&#34; &#34;position&#34; tsc--pos-infix)]&#xA;      [(&#34;m&#34; &#34;message&#34; tsc--msg-pos)]])&#xA;&#xA;   ;; (tsc-lisp-variable)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Controlling CLI&#39;s :PROPERTIES: :TOC: :include descendants :depth 2 :local depth :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Reading arguments within suffixes][Reading arguments within suffixes]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Switches &amp;amp; Arguments Again][Switches &amp;amp; Arguments Again]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Argument and Infix Macros][Argument and Infix Macros]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Choices][Choices]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Mutually Exclusive Switches][Mutually Exclusive Switches]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Incompatible Switches][Incompatible Switches]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Short Args][Short Args]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Choices from a function][Choices from a function]]&lt;/li&gt; &#xA;   &lt;li&gt;[[multiple instances][multiple instances]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Dispatching args into a process][Dispatching args into a process]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Cleanup Cowsay][Cleanup Cowsay]] :END:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;This section covers more usages of infixes, focused on creating better argument strings for CLI tools.&lt;/p&gt; &lt;p&gt;The section on [[*Flow control &amp;amp; managing state][flow control &amp;amp; managing state]] has more information about controlling elisp applications.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Reading arguments within suffixes&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; these forms are generic for different prefixes, allowing you to mix and match suffixes within prefixes.&lt;/p&gt; &#xA;&lt;p&gt;** Switches &amp;amp; Arguments Again&lt;/p&gt; &#xA;&lt;p&gt;The shorthand forms in =transient-define-prefix= are heavily influenced by the CLI style switches and arguments that transient was built to control. Most shorthand forms look like so:&lt;/p&gt; &#xA;&lt;p&gt;=(&#34;key&#34; &#34;description&#34; &#34;argument&#34;)=&lt;/p&gt; &#xA;&lt;p&gt;The macro will select the infix&#39;s exact class depending on how you write =:argument=. If you write something ending in &lt;del&gt;=&lt;/del&gt; such as &lt;del&gt;--value=&lt;/del&gt; then you get =:class transient-option= but if not, the default is a =:class transient-switch=&lt;/p&gt; &#xA;&lt;p&gt;Use [[elisp:(describe-function transient-option)][=(describe-function transient-option)=]] and [[elisp:(describe-function transient-switch)][=(describe-function transient-option)=]] to see a full document of their slots and methods.&lt;/p&gt; &#xA;&lt;p&gt;If you need an argument with a space instead of the equal sign, use a space and force the infix to be an argument by setting =:class transient-option=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-switches-and-arguments (arg)&#xA;   &#34;A prefix with switch and argument examples.&#34;&#xA;   [[&#34;Arguments&#34;&#xA;     (&#34;-s&#34; &#34;switch&#34; &#34;--switch&#34;)&#xA;     (&#34;-a&#34; &#34;argument&#34; &#34;--argument=&#34;)&#xA;     (&#34;t&#34; &#34;toggle&#34; &#34;--toggle&#34;)&#xA;     (&#34;v&#34; &#34;value&#34; &#34;--value=&#34;)]&#xA;&#xA;    [&#34;More Arguments&#34;&#xA;     (&#34;-f&#34; &#34;argument with forced class&#34; &#34;--forced-class &#34; :class transient-option)&#xA;     (&#34;I&#34; &#34;argument with inline&#34; (&#34;-i&#34; &#34;--inline-shortarg=&#34;))&#xA;     (&#34;S&#34; &#34;inline shortarg switch&#34; (&#34;-n&#34; &#34;--inline-shortarg-switch&#34;))]]&#xA;&#xA;   [&#34;Commands&#34;&#xA;    (&#34;w&#34; &#34;wave some&#34; tsc-wave)&#xA;    (&#34;s&#34; &#34;show arguments&#34; tsc-suffix-print-args)]) ; use to analyze the switch values&#xA;&#xA; ;; (tsc-switches-and-arguments)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Argument and Infix Macros&lt;/p&gt; &#xA;&lt;p&gt;If you need to fine-tune a switch (boolean infix), use =transient-define-infix=. Likewise, use =transient-define-argument= for fine-tuning an argument. The class definitions can be used as a reference while the [[https://magit.vc/manual/transient/Suffix-Slots.html#Slotsc-of-transient_002dinfix][manual]] provides more explanation.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-infix tsc--random-init-infix ()&#xA;   &#34;Switch on and off.&#34;&#xA;   :argument &#34;--switch&#34;&#xA;   :shortarg &#34;-s&#34; ; will be used for :key when key is not set&#xA;   :description &#34;switch&#34;&#xA;   :init-value (lambda (obj)&#xA;                 (oset obj value&#xA;                       (eq 0 (random 2))))) ; write t with 50% probability&#xA;&#xA; (transient-define-prefix tsc-maybe-on ()&#xA;   &#34;A prefix with a randomly intializing switch.&#34;&#xA;   [&#34;Arguments&#34;&#xA;    (tsc--random-init-infix)]&#xA;   [&#34;Show Args&#34;&#xA;    (&#34;s&#34; &#34;show arguments&#34; tsc-suffix-print-args)])&#xA;&#xA; ;; (tsc-maybe-on)&#xA; ;; (tsc-maybe-on)&#xA; ;; ...&#xA; ;; Run the command a few times to see the random initialization of `tsc--random-init-infix&#39;&#xA; ;; It will only take more than ten tries for one in a thousand users.  Good luck.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Choices&lt;/p&gt; &#xA;&lt;p&gt;Choices can be set for an argument. The property API and =transient-define-argument= are equivalent for configuring choices. You can either hardcode or generate choices.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-argument tsc--animals-argument ()&#xA;   &#34;Animal picker.&#34;&#xA;   :argument &#34;--animals=&#34;&#xA;   ; :multi-value t ; multi-value can be set to --animals=fox,otter,kitten etc&#xA;   :class &#39;transient-option&#xA;   :choices &#39;(&#34;fox&#34; &#34;kitten&#34; &#34;peregrine&#34; &#34;otter&#34;))&#xA;&#xA; (transient-define-prefix tsc-animal-choices ()&#xA;   &#34;Prefix demonstrating selecting animals from choices.&#34;&#xA;   [&#34;Arguments&#34;&#xA;    (&#34;-a&#34; &#34;--animals=&#34; tsc--animals-argument)]&#xA;   [&#34;Show Args&#34;&#xA;    (&#34;s&#34; &#34;show arguments&#34; tsc-suffix-print-args)])&#xA;&#xA; ;; (tsc-animal-choices)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;**** Choices shorthand in prefix definition&lt;/p&gt; &#xA;&lt;p&gt;Choices can also be defined in a shorthand form. Use =:class &#39;transient-option= if you need to force a different class to be used.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle no :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-animal-choices-shorthand ()&#xA;   &#34;Prefix demonstrating the shorthand style of defining choices.&#34;&#xA;   [&#34;Arguments&#34;&#xA;    (&#34;-a&#34; &#34;Animal&#34; &#34;--animal=&#34; :choices (&#34;fox&#34; &#34;kitten&#34; &#34;peregrine&#34; &#34;otter&#34;))]&#xA;   [&#34;Show Args&#34;&#xA;    (&#34;s&#34; &#34;show arguments&#34; tsc-suffix-print-args)])&#xA;&#xA; ;; (tsc-animal-choices-shorthand)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Mutually Exclusive Switches&lt;/p&gt; &#xA;&lt;p&gt;An argument with =:class transient-switches= may be used if a set of switches is exclusive. The key will likely /not/ match the short argument. Regex is used to tell the interface that you are entering one of the choices. The selected choice will be inserted into =:argument-format=. The =:argument-regexp= must be able to match any of the valid options.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;The UX on mutually exclusive switches is a bit of a pain to discover. You must repeatedly press =:key= in order to cycle through the options.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-argument tsc--snowcone-flavor ()&#xA;   :description &#34;Flavor of snowcone.&#34;&#xA;   :class &#39;transient-switches&#xA;   :key &#34;f&#34;&#xA;   :argument-format &#34;--%s-snowcone&#34;&#xA;   :argument-regexp &#34;\\(--\\(grape\\|orange\\|cherry\\|lime\\)-snowcone\\)&#34;&#xA;   :choices &#39;(&#34;grape&#34; &#34;orange&#34; &#34;cherry&#34; &#34;lime&#34;))&#xA;&#xA; (transient-define-prefix tsc-exclusive-switches ()&#xA;   &#34;Prefix demonstrating exclusive switches.&#34;&#xA;   :value &#39;(&#34;--orange-snowcone&#34;)&#xA;&#xA;   [&#34;Arguments&#34;&#xA;    (tsc--snowcone-flavor)]&#xA;   [&#34;Show Args&#34;&#xA;    (&#34;s&#34; &#34;show arguments&#34; tsc-suffix-print-args)])&#xA;&#xA; ;; (tsc-exclusive-switches)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Incompatible Switches&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;If you need to prevent arguments in a group from being set simultaneously,&#xA;you can set the prefix property =:incompatible= and a list of the long-style&#xA;argument.&#xA;&#xA;Use a list of lists, where each sublist is the long argument style. Match&#xA;the string completely, including use of ~=~ in both arguments and switches.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-incompatible ()&#xA;   &#34;Prefix demonstrating incompatible switches.&#34;&#xA;   ;; update your transient version if you experience #129 / #155&#xA;   :incompatible &#39;((&#34;--switch&#34; &#34;--value=&#34;)&#xA;                   (&#34;--switch&#34; &#34;--toggle&#34; &#34;--flip&#34;)&#xA;                   (&#34;--argument=&#34; &#34;--value=&#34; &#34;--special-arg=&#34;))&#xA;&#xA;   [&#34;Arguments&#34;&#xA;    (&#34;-s&#34; &#34;switch&#34; &#34;--switch&#34;)&#xA;    (&#34;-t&#34; &#34;toggle&#34; &#34;--toggle&#34;)&#xA;    (&#34;-f&#34; &#34;flip&#34; &#34;--flip&#34;)&#xA;&#xA;    (&#34;-a&#34; &#34;argument&#34; &#34;--argument=&#34;)&#xA;    (&#34;v&#34; &#34;value&#34; &#34;--value=&#34;)&#xA;    (&#34;C-a&#34; &#34;special arg&#34; &#34;--special-arg=&#34;)]&#xA;&#xA;   [&#34;Show Args&#34;&#xA;    (&#34;s&#34; &#34;show arguments&#34; tsc-suffix-print-args)])&#xA;&#xA; ;; (tsc-incompatible)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** TODO Short Args&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*This section is incomplete.  Maybe Magit contains better answers.*&#xA;&#xA;Sometimes the =:shortarg= in a CLI doesn&#39;t exactly match the =&lt;span&gt;üîë&lt;/span&gt;= and&#xA;=:argument=, so it can be specified manually.&#xA;&#xA;The =:shortarg= concept could be used to help use man-pages or only for&#xA;[[https://magit.vc/manual/transient.html#index-transient_002ddetect_002dkey_002dconflicts][transient-detect-key-conflicts]] but it&#39;s not clear what behavior it changes.&#xA;&#xA;Shortarg cannot be used for exclusion excluding other options (prefix&#xA;=:incompatible=) or setting default values (prefix =:value=).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Choices from a function&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;See =transient-infix-read= for actual code.  This method uses the prefix&#39;s&#xA;history and then delecates to =completing-read= or&#xA;=completing-read-multiple=.  The =:choices= key coresponds to the&#xA;=COLLECTION= argument passed to completing reads.&#xA;&#xA;*Note*, using a function for completions can appear to require a daunting&#xA;amount of behavior if you read the manul [[info:elisp#Programmed&#xA;Completion][section on programmed completions]].  If you however just return&#xA;a list of options, even when FLAG is not t, everything seems just fine.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (defun tsc--animal-choices (_complete-me _predicate flag)&#xA;   &#34;Programmed completion for animal choice.&#xA; _COMPLETE-ME: whatever the user has typed so far&#xA; _PREDICATE: function you should use to filter candidates (only nil seen so far)&#xA; FLAG: request for metadata (which can be disrespected)&#34;&#xA;&#xA;   ;; if you want to respect metadata requests, here&#39;s what the form might&#xA;   ;; look like, but no behavior was observed.&#xA;   (if (eq flag &#39;metadata)&#xA;       &#39;(metadata . &#39;((annotation-function . (lambda (c) &#34;an annotation&#34;))))&#xA;&#xA;     ;; when not handling a metadata request from completions, use some&#xA;     ;; logic to generate the choices, possibly based on input or some time&#xA;     ;; / context sensitive process.  FLAG will be `t&#39; when these are reqeusted.&#xA;     (if (eq 0 (random 2))&#xA;         &#39;(&#34;fox&#34; &#34;kitten&#34; &#34;otter&#34;)&#xA;       &#39;(&#34;ant&#34; &#34;peregrine&#34; &#34;zebra&#34;))))&#xA;&#xA; (transient-define-prefix tsc-choices-with-completions ()&#xA;   &#34;Prefix with completions for choices.&#34;&#xA;   [&#34;Arguments&#34;&#xA;    (&#34;-a&#34; &#34;Animal&#34; &#34;--animal=&#34;&#xA;     :always-read t ; don&#39;t allow unsetting, just read a new value&#xA;     :choices tsc--animal-choices)]&#xA;   [&#34;Show Args&#34;&#xA;    (&#34;s&#34; &#34;show arguments&#34; tsc-suffix-print-args)])&#xA;&#xA; ;; (tsc-choices-with-completions)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** TODO multiple instances&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Switches and arguments that can be used multiple times are supported.&#xA;Example needs to be written.  This is useful for CLI wrapping or perhaps&#xA;situations where a command accepts multiple levels of the same setting.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Dispatching args into a process&lt;/p&gt; &#xA;&lt;p&gt;If you want to call a command line application using the arguments, you might need to do a bit of work processing the arguments. The following example uses cowsay.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Cowsay doesn&#39;t actually have a =message== argument, So we end up stripping it from the arguments and re-assembling something =call-process= can use.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Cowsay supports more options, but for the sake of keeping this example small (and to refocus effort on transient itself), the set of all CLI options are not fully supported.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There&#39;s some errata about this example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The predicates don&#39;t update the transient. =(transient--redisplay)= doesn&#39;t do the trick. We could use =transient--do-replace= and =transient-setup=, but that would lose existing state&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The predicate needs to be exists &amp;amp; not empty (but doesn&#39;t matter yet)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defun tsc--quit-cowsay ()&#xA;  &#34;Kill the cowsay buffer and exit.&#34;&#xA;  (interactive)&#xA;  (kill-buffer &#34;*cowsay*&#34;))&#xA;&#xA;(defun tsc--cowsay-buffer-exists-p ()&#xA;  &#34;Visibility predicate.&#34;&#xA;  (not (equal (get-buffer &#34;*cowsay*&#34;) nil)))&#xA;&#xA;(transient-define-suffix tsc--cowsay-clear-buffer (&amp;amp;optional buffer)&#xA;  &#34;Delete the *cowsay* buffer.  Optional BUFFER name.&#34;&#xA;  :transient &#39;transient--do-call&#xA;  :if &#39;tsc--cowsay-buffer-exists-p&#xA;  (interactive) ; todo look at &#34;b&#34; interactive code&#xA;&#xA;  (save-excursion&#xA;    (let ((buffer (or buffer &#34;*cowsay*&#34;)))&#xA;      (set-buffer buffer)&#xA;      (delete-region 1 (+ 1 (buffer-size))))))&#xA;&#xA;(transient-define-suffix tsc--cowsay (&amp;amp;optional args)&#xA;  &#34;Run cowsay.&#34;&#xA;  (interactive (list (transient-args transient-current-command)))&#xA;  (let* ((buffer &#34;*cowsay*&#34;)&#xA;         ;; TODO ugly&#xA;         (cowmsg (if args (transient-arg-value &#34;--message=&#34; args) nil))&#xA;         (cowmsg (if cowmsg (list cowmsg) nil))&#xA;         (args (if args&#xA;                   (seq-filter&#xA;                    (lambda (s) (not (string-prefix-p &#34;--message=&#34; s))) args)&#xA;                 nil))&#xA;         (args (if args&#xA;                   (if cowmsg&#xA;                       (append args cowmsg)&#xA;                     args)&#xA;                 cowmsg)))&#xA;&#xA;    (when (tsc--cowsay-buffer-exists-p)&#xA;      (tsc--cowsay-clear-buffer))&#xA;    (apply #&#39;call-process &#34;cowsay&#34; nil buffer nil args)&#xA;    (switch-to-buffer buffer)))&#xA;&#xA;(transient-define-prefix tsc-cowsay ()&#xA;  &#34;Say things with animals!&#34;&#xA;&#xA;  ; only one kind of eyes is meaningful at a time&#xA;  :incompatible &#39;((&#34;-b&#34; &#34;-g&#34; &#34;-p&#34; &#34;-s&#34; &#34;-t&#34; &#34;-w&#34; &#34;-y&#34;))&#xA;&#xA;  [&#34;Message&#34;&#xA;   (&#34;m&#34; &#34;message&#34; &#34;--message=&#34; :always-read t)] ; always-read, so clear by entering empty string&#xA;  [[&#34;Built-in Eyes&#34;&#xA;    (&#34;b&#34; &#34;borg&#34; &#34;-b&#34;)&#xA;    (&#34;g&#34; &#34;greedy&#34; &#34;-g&#34;)&#xA;    (&#34;p&#34; &#34;paranoid&#34; &#34;-p&#34;)&#xA;    (&#34;s&#34; &#34;stoned&#34; &#34;-s&#34;)&#xA;    (&#34;t&#34; &#34;tired&#34; &#34;-t&#34;)&#xA;    (&#34;w&#34; &#34;wired&#34; &#34;-w&#34;)&#xA;    (&#34;y&#34; &#34;youthful&#34; &#34;-y&#34;)]&#xA;   [&#34;Actions&#34;&#xA;    (&#34;c&#34; &#34;cowsay&#34; tsc--cowsay :transient transient--do-call)&#xA;    &#34;&#34;&#xA;    (&#34;d&#34; &#34;delete buffer&#34; tsc--cowsay-clear-buffer)&#xA;    (&#34;q&#34; &#34;quit&#34; tsc--quit-cowsay)]])&#xA;&#xA;;; (tsc-cowsay)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** TODO Cleanup Cowsay&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Clean up cowsay example.  Check for binary before attempting to run it.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Controlling Visibility :PROPERTIES: :TOC: :include descendants :depth 3 :local depth :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Visibility Predicates][Visibility Predicates]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Inapt (Temporarily Unavailable)][Inapt (Temporarily Unavailable)]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Documentation in manual missing][Documentation in manual missing]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Levels][Levels]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Defining group &amp;amp; suffix levels][Defining group &amp;amp; suffix levels]]&lt;/li&gt; &#xA;   &lt;li&gt;[[Using the Levels UI][Using the Levels UI]] :END:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;At times, you need a prefix to show or hide certain options depending on the context.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Visibility Predicates&lt;/p&gt; &#xA;&lt;p&gt;Simple [[https://magit.vc/manual/transient/Predicate-Slots.html#Predicate-Slots][predicates]] at the group or element level exist to hide parts of the transient when they wouldn&#39;t be useful at all in the situation.&lt;/p&gt; &#xA;&lt;p&gt;#+name: predicates-prelude #+begin_src elisp :hidden yes :tangle no&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (defvar tsc-busy nil &#34;Are we busy?&#34;)&#xA;&#xA; (defun tsc--busy-p () &#34;Are we busy?&#34; tsc-busy)&#xA;&#xA; (transient-define-suffix tsc--toggle-busy ()&#xA;   &#34;Toggle busy.&#34;&#xA;   (interactive)&#xA;   (setf tsc-busy (not tsc-busy))&#xA;   (message (propertize (format &#34;busy: %s&#34; tsc-busy)&#xA;                        &#39;face &#39;success)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Open the following example in buffers with different modes (or change modes manually) to see the different effects of the mode predicates.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=predicates-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-visibility-predicates ()&#xA;   &#34;Prefix with visibility predicates.&#xA; Try opening this prefix in buffers with modes deriving from different&#xA; abstract major modes.&#34;&#xA;   [&#34;Empty Groups Not Displayed&#34;&#xA;    ;; in org mode for example, this group doesn&#39;t appear.&#xA;    (&#34;we&#34; &#34;wave elisp&#34; tsc-suffix-wave :if-mode emacs-lisp-mode)&#xA;    (&#34;wc&#34; &#34;wave in C&#34; tsc-suffix-wave :if-mode cc-mode)]&#xA;&#xA;   [&#34;Lists of Modes&#34;&#xA;    (&#34;wm&#34; &#34;wave multiply&#34; tsc-suffix-wave :if-mode (dired-mode gnus-mode))]&#xA;&#xA;   [[&#34;Function Predicates&#34;&#xA;     ;; note, after toggling, the transient needs to be re-displayed for the&#xA;     ;; predicate to take effect&#xA;     (&#34;b&#34; &#34;toggle busy&#34; tsc--toggle-busy)&#xA;     (&#34;bw&#34; &#34;wave busily&#34; tsc-suffix-wave :if tsc--busy-p)]&#xA;&#xA;    [&#34;Programming Actions&#34;&#xA;     :if-derived prog-mode&#xA;     (&#34;pw&#34; &#34;wave programishly&#34; tsc-suffix-wave)&#xA;     (&#34;pe&#34; &#34;wave in elisp&#34; tsc-suffix-wave :if emacs-lisp-mode)]&#xA;    [&#34;Special Mode Actions&#34;&#xA;     :if-derived special-mode&#xA;     (&#34;sw&#34; &#34;wave specially&#34; tsc-suffix-wave)&#xA;     (&#34;sd&#34; &#34;wave dired&#34; tsc-suffix-wave :if-mode dired-mode)]&#xA;    [&#34;Text Mode Actions&#34;&#xA;     :if-derived text-mode&#xA;     (&#34;tw&#34; &#34;wave textually&#34; tsc-suffix-wave)&#xA;     (&#34;to&#34; &#34;wave org-modeishly&#34; tsc-suffix-wave :if-mode org-mode)]])&#xA;&#xA; ;; (tsc-visibility-predicates)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Inapt (Temporarily Unavailable)&lt;/p&gt; &#xA;&lt;p&gt;&#34;Greyed out&#34; suffixes. Inapt is better if an option is temporarily unavailable due to a state that varies with each invocation of the transient.&lt;/p&gt; &#xA;&lt;p&gt;Inapt predicates work on suffixes, but not on groups (which would have to modify every child).&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;, like visibility predicates, =inapt-*= predicates do not take effect until the transient has it&#39;s layout fully redone. Therefore this example uses a child transient and updates the scope.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :var _=print-args-prelude :var __=levels-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (defun tsc--child-scope-p ()&#xA;   &#34;Return the scope of the current transient.&#xA; When this is called in layouts, it&#39;s the transient being layed out&#34;&#xA;   (let ((scope (oref transient--prefix scope)))&#xA;     (message &#34;The scope is: %s&#34; scope)&#xA;     scope))&#xA;&#xA; ;; the wave suffixes were :transient t as defined, so we need to manually&#xA; ;; override them to the `transient--do-return&#39; value for :transient slot so&#xA; ;; that they return back to the parent.&#xA; (transient-define-prefix tsc--inapt-children ()&#xA;   &#34;Prefix with children using inapt predicates.&#34;&#xA;   [&#34;Inapt Predicates Child&#34;&#xA;    (&#34;s&#34; &#34;switched&#34; tsc--wave-surely&#xA;     :transient transient--do-return&#xA;     :if tsc--child-scope-p)&#xA;    (&#34;u&#34; &#34;unswitched&#34; tsc--wave-normally&#xA;     :transient transient--do-return&#xA;     :if-not tsc--child-scope-p)]&#xA;&#xA;   ;; in the body, we read the value of the parent and set our scope to&#xA;   ;; non-nil if the switch is set&#xA;   (interactive)&#xA;   (let ((scope (transient-arg-value &#34;--switch&#34; (transient-args &#39;tsc-inapt-parent))))&#xA;     (message &#34;scope: %s&#34; scope)&#xA;     (message &#34;type: %s&#34; (type-of scope))&#xA;     (transient-setup &#39;tsc--inapt-children nil nil :scope (if scope t nil))))&#xA;&#xA; (transient-define-prefix tsc-inapt-parent ()&#xA;   &#34;Prefix that configures child with inapt predicates.&#34;&#xA;&#xA;   [(&#34;-s&#34; &#34;switch&#34; &#34;--switch&#34;)&#xA;    (&#34;a&#34; &#34;show arguments&#34; tsc-suffix-print-args)&#xA;    (&#34;c&#34; &#34;launch child prefix&#34; tsc--inapt-children :transient transient--do-recurse)])&#xA;&#xA; ;; (tsc-inapt-parent)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** TODO Documentation in manual missing&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;There is not a single mention of inapt even though it&#39;s fully implemented&#xA;and works.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Levels&lt;/p&gt; &#xA;&lt;p&gt;Levels are another way to control visibility.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;As a developer, you set levels to optionally expose or hide children in a prefix.&lt;/li&gt; &#xA; &lt;li&gt;As a user, you change the prefix&#39;s level and the levels of suffixes to customize what&#39;s visible in the transient.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Lower levels are more visible. Setting the level higher reveals more suffixes.&lt;/em&gt; 1-7 are valid levels.&lt;/p&gt; &#xA;&lt;p&gt;The user can adjust levels within a transient prefix by using (&lt;em&gt;C-x l&lt;/em&gt;) for =transient-set-level=. The default active level is 4, stored in =transient-default-level=. The default level for children is 1, stored in =transient--default-child-level=.&lt;/p&gt; &#xA;&lt;p&gt;Per-suffix and per-group, the user can set the level at which the child will be visible. Each prefix has an active level, remembered per prefix. If the child level is less-than-or-equal to the child level, the child is visible.&lt;/p&gt; &#xA;&lt;p&gt;A hidden group will hide a suffix even if that suffix is at a low enough level. Issue #153 has some addional information about behavior that might get cleaned up.&lt;/p&gt; &#xA;&lt;p&gt;**** Defining group &amp;amp; suffix levels&lt;/p&gt; &#xA;&lt;p&gt;Adding default levels for children is as simple as adding integers at the beginning of each list or vector. If some commands are not likely to be used, instead of making the hard choice to include them or not, you can provide them, but tell the user in your README to set higher levels.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; #+begin_src elisp :tangle transient-showcase.el :var _=levels-prelude :var _=show-level-prelude&#xA;&#xA;   (transient-define-prefix tsc-levels-and-visibility ()&#xA;     &#34;Prefix with visibility levels for hiding rarely used commands.&#34;&#xA;&#xA;     [[&#34;Setting the Current Level&#34;&#xA;       ;; this binding is normally not displayed.  The value of&#xA;       ;; `transient-show-common-commands&#39; controls this by default.&#xA;       (&#34;C-x l&#34; &#34;set level&#34; transient-set-level)&#xA;       (&#34;s&#34; &#34;show level&#34; tsc-suffix-show-level)]&#xA;&#xA;      [2 &#34;Per Group&#34; ; 1 is the default default-child-level&#xA;         (&#34;ws&#34; &#34;wave surely&#34; tsc--wave-surely) ; 1 is the default default-child-level&#xA;         (3&#34;wn&#34; &#34;wave normally&#34; tsc--wave-normally)&#xA;         (5&#34;wb&#34; &#34;wave non-essentially&#34; tsc--wave-non-essentially)]&#xA;&#xA;      [3 &#34;Per Group Somewhat Useful&#34;&#xA;         (&#34;wd&#34; &#34;wave definitely&#34; tsc--wave-definitely)]&#xA;&#xA;      [6 &#34;Groups hide visible children&#34;&#xA;         (1 &#34;wh&#34; &#34;wave hidden&#34; tsc--wave-hidden)]&#xA;&#xA;      [5 &#34;Per Group Rarely Useful&#34;&#xA;         (&#34;we&#34; &#34;wave eventually&#34; tsc--wave-eventually)]])&#xA;&#xA;   ;; (tsc-levels-and-visibility)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;**** Using the Levels UI&lt;/p&gt; &#xA;&lt;p&gt;Press (&lt;em&gt;C-x l&lt;/em&gt;) to open the levels UI for the user. Press (&lt;em&gt;C-x l&lt;/em&gt;) again to change the active level. Press a key such as &#34;we&#34; to change the level for a child. After you cancel level editing with (&lt;em&gt;C-g&lt;/em&gt;), you will see that children have either become visible or invisible depending on the changes you made.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;While a child may be visible according to its own level, if it&#39;s hidden within the group, the user&#39;s level-setting UI for the prefix will contradict what&#39;s actually visible. The UI does not allow setting group levels.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Advanced :PROPERTIES: :TOC: :include descendants :depth 3 :local depth :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Dynamically generating layouts][Dynamically generating layouts]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Correction in manual][Correction in manual]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Using prefix scope in children][Using prefix scope in children]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Obtaining Missing Scope][Obtaining Missing Scope]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[Custom Infix Types][Custom Infix Types]]&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[Reading custom infix values][Reading custom infix values]] :END:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;The previous sections are designed to go breadth-first so that you can get core ideas first. The following examples expand on combinations of several ideas or subclassing &amp;amp; customizing rarely used slots.&lt;/p&gt; &lt;p&gt;Some of these examples are approaching the complexity of just reading [[elisp:(find-library &#34;magit&#34;)][magit source]].&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Dynamically generating layouts&lt;/p&gt; &#xA;&lt;p&gt;While you can cover many cases using predicates, layouts, and visibility, &lt;em&gt;sometimes you really do want to generate a list of commands.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;, beware that you could be creating a lot of suffix objects if the forms you use generate unique symbols. These will pollute command completions over time, so probably don&#39;t do that.&lt;/p&gt; &#xA;&lt;p&gt;[[https://magit.vc/manual/transient.html#index-transient_002dsetup_002dchildren][transient-setup-children]]&lt;/p&gt; &#xA;&lt;p&gt;This is a group method that can be overridden in order to modify or eliminate some children from display. If you need a central place for children to coordinate some behavior, this may work for you.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-generated-child ()&#xA;   &#34;Prefix that uses `setup-children&#39; to generate single child.&#34;&#xA;&#xA;   [&#34;Replace this child&#34;&#xA;    ;; Let&#39;s override the group&#39;s method&#xA;    :setup-children&#xA;    (lambda (_) ; we don&#39;t care about the stupid suffix&#xA;&#xA;      ;; remember to return a list&#xA;      (list (transient-parse-suffix&#xA;             transient--prefix&#xA;             &#39;(&#34;r&#34; &#34;replacement&#34; (lambda ()&#xA;                                   (interactive)&#xA;                                   (message &#34;okay!&#34;))))))&#xA;&#xA;    (&#34;s&#34; &#34;haha stupid suffix&#34; (lambda ()&#xA;                                (interactive)&#xA;                                (message &#34;You should replace me!&#34;)))])&#xA;&#xA; ;; (tsc-generated-child)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;=transient--parse-child= takes the same configuration format as =transient-define-prefix=. You can see the layout format in the [[id:49cb2ea4-66fa-4bc4-ab91-268580e907a5][layout hacking appendix]]. =transient--prarse-group= works almost exactly the same, just for groups.&lt;/p&gt; &#xA;&lt;p&gt;The same thing, but parsing an entire group spec:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle transient-showcase.el&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-prefix tsc-generated-group ()&#xA;   &#34;Prefix that uses `setup-children&#39; to generate a group.&#34;&#xA;&#xA;   [&#34;Replace this child&#34;&#xA;    ;; Let&#39;s override the group&#39;s method&#xA;    :setup-children&#xA;    (lambda (_) ; we don&#39;t care about the stupid suffix&#xA;&#xA;      ;; the result of parsing here will be a group&#xA;      (transient-parse-suffixes&#xA;       transient--prefix&#xA;       [&#34;Group Name&#34; (&#34;r&#34; &#34;replacement&#34; (lambda ()&#xA;                                          (interactive)&#xA;                                          (message &#34;okay!&#34;)))]))&#xA;&#xA;    (&#34;s&#34; &#34;haha stupid suffix&#34; (lambda ()&#xA;                                (interactive)&#xA;                                (message &#34;You should replace me!&#34;)))])&#xA;&#xA; ;; (tsc-generated-group)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you need to define a dynamic group class, override =transient-setup-children=. It will work almost entirely the same as the examples above. Set your group class in the prefix using the =:class= key.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt; you don&#39;t need to be inside of a layout body to hack around with dynamic layouts. Mess around in [[elisp:(ielm))][ielm]].&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp :tangle no :results replace&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient--parse-child &#39;magit-dispatch &#39;(&#34;a&#34; &#34;action&#34; (lambda () (interactive) (message &#34;hey&#34;))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt; you can replace =transient--prefix= with =tsc-generated-group= in the example above. =transient--prefix= is just a variable that happens to hold the prefix during layout.&lt;/p&gt; &#xA;&lt;p&gt;*** TODO Correction in manual&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- These functions do mostly the same job.  Why do we need to specify a&#xA;  prefix for =transient-parse-suffixes=, for scope etc?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Using prefix scope in children&lt;/p&gt; &#xA;&lt;p&gt;Basically you are on your own. Just call =(oref transient--prefix scope)= during layout setup or =(oref transient-current-prefix)= during suffix bodies.&lt;/p&gt; &#xA;&lt;p&gt;*** Obtaining Missing Scope&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Because suffixes are basically also commands (riding in the same symbol&#xA;plist), a suffix can be called independently.  In this case, if its expecting&#xA;to read the scope from the prefix when there is no prefix, it might fail.&#xA;&#xA;Therefore, a method called =transient-init-scope= can be overridden and used&#xA;at the correct point in the lifecycle for the suffix to correct the issue.&#xA;&#xA;*Note*, the behavior is actually quite ad-hoc.  You will read the prefix&#xA;yourself and then decide if you want to use some fallback.&#xA;&#xA;There is a perfectly short example in [[https://github.com/magit/magit/blob/40fb3d20026139ad1c3a3d9069b40d7d61bf8786/lisp/magit-transient.el#L56-L61][Magit source]] for the custom&#xA;=magit--git-variable= subclass of the =transient-variable= infix.&#xA;&#xA;Each infix instance is declared in =transient-define-infix=, potentially with&#xA;a =:scope= slot, possibly holding a function.&#xA;&#xA;If it&#39;s holding a function, that function will be used as a backup during&#xA;initialization in case there is no prefix or it has nothing in its =scope=&#xA;slot.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Custom Infix Types :PROPERTIES: :ID: 0c3f2271-98e0-4db4-b95b-e31975bcbb5e :END:&lt;/p&gt; &#xA;&lt;p&gt;Not everything is a string or boolean. You may want to represent complex objects in your transint infixes. If your objects can be rehydrated from some serialized ID, you may want history support.&lt;/p&gt; &#xA;&lt;p&gt;If you need to set and display a custom type, use the simple OOP techniques of [[*EIEIO][EIEIO]]. Also check the [[info:transient#Suffix Value Methods][suffix value methods]] section of the transient manual.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Essential behaviors for your custom infix:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Defining a reader to set the infix with user input&lt;/li&gt; &#xA; &lt;li&gt;=prompt= slot&#39;s default form, =initform= for asking the user for input&lt;/li&gt; &#xA; &lt;li&gt;=transient-init-value= to rehydrate saved values&lt;/li&gt; &#xA; &lt;li&gt;=transient-infix-value= so that setting &amp;amp; saving persist what you want to rehydrate&lt;/li&gt; &#xA; &lt;li&gt;=transient-format-value= to display a user-meaningful form for your value&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We will also use some layout introspection:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=transient-get-suffix= To get suffix by &lt;em&gt;key&lt;/em&gt;, &lt;em&gt;location&lt;/em&gt;, or &lt;em&gt;command symbol&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Getting a description from raw layout children (not EIEIO objects). See [[id:49cb2ea4-66fa-4bc4-ab91-268580e907a5][Layout Hacking]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+name: custom-infixes #+begin_src elisp :tangle transient-showcase.el :var _=levels-prelude :var __=print-args-prelude&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; ;; The children we will be picking can be of several forms.  The&#xA; ;; transient--layout symbol property of a prefix is a vector of vectors, lists,&#xA; ;; and strings.  It&#39;s not the actual eieio types or we would use&#xA; ;; `transient-format-description&#39; to just ask them for the descriptions.&#xA; (defun tsc--layout-child-desc (layout-child)&#xA;   &#34;Get the description from LAYOUT-CHILD.&#xA; LAYOUT-CHILD is a transient layout vector or list.&#34;&#xA;   (let ((description&#xA;          (cond&#xA;           ((vectorp layout-child) (or (plist-get (aref layout-child 2) :description) &#34;&amp;lt;group, no desc&amp;gt;&#34;)) ; group&#xA;           ((stringp layout-child) layout-child) ; plain-text child&#xA;           ((listp layout-child) (plist-get (elt layout-child 2) :description)) ; suffix&#xA;           (t (message (propertize &#34;You traversed into a child&#39;s list elements!&#34; &#39;face &#39;warning))&#xA;              (format &#34;(child&#39;s interior) element: %s&#34; layout-child)))))&#xA;     (cond&#xA;      ;; The description is sometimes a callable function with no arguments,&#xA;      ;; so let&#39;s call it in that case.  Note, the description may be&#xA;      ;; designed for one point in the transient&#39;s lifecycle but we could&#xA;      ;; call it in a different one, causing its behavior to change.&#xA;      ((functionp description) (apply description))&#xA;      (t description))))&#xA;&#xA; ;; We repeat the read using a lisp expression from `read-from-minibuffer&#39; to get&#xA; ;; the LOC key for `transient-get-suffix&#39; until we get a valid result.  This&#xA; ;; ensures we don&#39;t store an invalid LOC.&#xA; (defun tsc-child-infix--reader (prompt initial-input history)&#xA;   &#34;Read a location and check that it exists within the current transient.&#xA; PROMPT, INITIAL-INPUT, and HISTORY are forwarded to `read-from-minibuffer&#39;.&#34;&#xA;   (let ((command (oref transient--prefix command))&#xA;         (success nil))&#xA;     (while (not success)&#xA;       (let* ((loc (read (read-from-minibuffer prompt initial-input nil nil history)))&#xA;              (child (ignore-errors (transient-get-suffix command loc))))&#xA;         (if child (setq success loc)&#xA;           (message (propertize&#xA;                     (format&#xA;                      &#34;Location could not be found in prefix %s&#34;&#xA;                      command)&#xA;                     &#39;face &#39;error))&#xA;           (sit-for 3))))&#xA;     success))&#xA;&#xA; ;; Inherit from variable abstract class&#xA; (defclass tsc-child-infix (transient-variable)&#xA;   ((value-object :initarg value-object :initform nil)&#xA;    ;; this is a new slot for storing the hydrated value.  we re-use the&#xA;    ;; value infrastructure for storing the serialization-friendly value,&#xA;    ;; which is basically a suffix addres or id.&#xA;&#xA;    (reader :initform #&#39;tsc-child-infix--reader)&#xA;    (prompt :initform &#34;Location, a key \&#34;c\&#34;, suffix-command-symbol like tsc--wave-normally or coordinates like (0 2 0): &#34;)))&#xA;&#xA; ;; We have to define this on non-abstract infix classes.  See&#xA; ;; `transient-init-value&#39; in transient source.  The method on&#xA; ;; `transient-argument&#39; class is the best example for initializing your&#xA; ;; suffix based on the prefix&#39;s value, but it does support a lot of&#xA; ;; behaviors.&#xA; (cl-defmethod transient-init-value ((obj tsc-child-infix))&#xA;   &#34;Set the `value&#39; and `value-object&#39; slots using the prefix&#39;s value.&#34;&#xA;   (let* ((prefix-value (oref transient--prefix value))&#xA;          (key (oref obj command))&#xA;          (value (car (alist-get key prefix-value))) ; car?&#xA;          (value-object (transient-get-suffix (oref transient--prefix command) value)))&#xA;     (oset obj value value)&#xA;     (oset obj value-object value-object)))&#xA;&#xA; (cl-defmethod transient-infix-set ((obj tsc-child-infix) value)&#xA;   &#34;Update `value&#39; slot to VALUE.&#xA; Update `value-object&#39; slot to the value corresponding to VALUE.&#34;&#xA;   (let* ((command (oref transient--prefix command))&#xA;          (child (ignore-errors (transient-get-suffix command value))))&#xA;     (oset obj value-object child)&#xA;     (oset obj value (if child value nil))))&#xA;&#xA; ;; If you are making a suffix that needs history, you need to define this&#xA; ;; method.  You also need this method if your value needs some processing&#xA; ;; or use of an alternate value for later rehydration.  Tell the prefix&#xA; ;; what to store when setting / saving&#xA; (cl-defmethod transient-infix-value ((obj tsc-child-infix))&#xA;   &#34;Return our actual value for rehydration later.&#34;&#xA;&#xA;   ;; this is almost identical to the method defined for `transient-infix&#39;,&#xA;   ;; but don&#39;t forget this if you want history on a suffix for example.&#xA;   (list (oref obj command) (oref obj value)))&#xA;&#xA; ;; Show user&#39;s a useful representation of your ugly value&#xA; (cl-defmethod transient-format-value ((obj tsc-child-infix))&#xA;   &#34;All transient children have some description we can display.&#xA; Show either the child&#39;s description or a default if no child is selected.&#34;&#xA;   (if-let* ((value (and (slot-boundp obj &#39;value) (oref obj value)))&#xA;             (value-object (and (slot-boundp obj &#39;value-object)&#xA;                                (oref obj value-object))))&#xA;       (propertize&#xA;        (format &#34;(%s)&#34; (tsc--layout-child-desc value-object))&#xA;        &#39;face &#39;transient-value)&#xA;     (propertize &#34;¬Ø\_(„ÉÑ)_/¬Ø&#34; &#39;face &#39;transient-inactive-value)))&#xA;&#xA; ;; Now that we have our class defined, we can create an infix the usual&#xA; ;; way, just specifying our class&#xA; (transient-define-infix tsc--inception-child-infix ()&#xA;   :class tsc-child-infix)&#xA;&#xA; ;; All set!  This transient just tests our or new toy.&#xA; (transient-define-prefix tsc-inception ()&#xA;   &#34;Prefix that picks a suffix from its own layout.&#34;&#xA;&#xA;   [[&#34;Pick a suffix&#34;&#xA;     (&#34;-s&#34; &#34;just a switch&#34; &#34;--switch&#34;) ; makes history value structure apparent&#xA;     (&#34;c&#34; &#34;child&#34; tsc--inception-child-infix :class tsc-child-infix)]&#xA;&#xA;    [&#34;Some suffixes&#34;&#xA;     (&#34;s&#34; &#34;wave surely&#34; tsc--wave-surely)&#xA;     (&#34;d&#34; &#34;wave definitely&#34; tsc--wave-definitely)&#xA;     (&#34;e&#34; &#34;wave eventually&#34; tsc--wave-eventually)&#xA;     (&#34;C&#34; &#34;call &amp;amp; exit normally&#34; tsc--wave-normally :transient nil)]&#xA;&#xA;    [&#34;Read variables&#34;&#xA;     (&#34;r&#34; &#34;read args&#34; tsc-suffix-print-args )]])&#xA;&#xA; ;; (tsc-inception)&#xA; ;; Try setting the infix to &#34;e&#34; (yes, include quotes)&#xA; ;; Try: (1 2)&#xA; ;; Try: tsc--wave-normally&#xA; ;; Set the infix and re-open it&#xA; ;; Save the infix, re-evaluate the prefix, and open the prefix again&#xA; ;; Try flipping through history&#xA; ;; Now do think of doing things like this with org ids, magit-sections, buffers etc.&#xA;&#xA;#+end_src&#xA;&#xA;This is a difficult example, but once you understand the pieces, you can&#xA;see some of the magit variables in action like =magit--git-variable= and&#xA;it&#39;s many subclasses.&#xA;&#xA;Revisit the section on [[id:6f6c8eba-1c0e-41c4-b57f-c06ab00f64d1][detangling setting, saving and&#xA;history]].  Watching the values update will make it clear what&#xA;representations are bing stored, where, and when.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Reading custom infix values&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*Note*, however you store and rehydrate will affect how you read, so try to&#xA;make it just work with =transient-read-arg=, unlike this example (TODO).&#xA;&#xA;#+name: custom-infixes&#xA;#+begin_src elisp :tangle transient-showcase.el :var _=custom-infixes&#xA;&#xA;   (transient-define-suffix tsc--inception-update-description ()&#xA;     &#34;Update the description of of the selected child.&#34;&#xA;     (interactive)&#xA;     (let* ((args (transient-args transient-current-command))&#xA;            (description (transient-arg-value &#34;--description=&#34; args))&#xA;            ;; This is the part where we read the other infix&#xA;            (loc (car (cdr (assoc &#39;tsc--inception-child-infix args))))&#xA;            (layout-child (transient-get-suffix &#39;tsc-inception-update loc)))&#xA;       (cond&#xA;        ;; Once again, do different bodies based on what we found at the layout locition.&#xA;        ((or (listp layout-child) ; child&#xA;            (vectorp layout-child) ; group&#xA;            (stringp layout-child)) ; string child&#xA;         (if (stringp layout-child)&#xA;             (transient-replace-suffix &#39;tsc-inception-update loc description) ; plain-text child&#xA;           (plist-put (elt layout-child 2) :description description)))&#xA;        (t (message (propertize (format&#xA;                                 &#34;Don&#39;t know how to modify whatever is at: %s&#34;&#xA;                                 loc) &#39;face &#39;warning))))&#xA;       ;; re-enter the transient manually to display the modified layout&#xA;       (transient-setup transient-current-command)))&#xA;&#xA;  (transient-define-prefix tsc-inception-update ()&#xA;    &#34;Prefix that picks and updates its own suffix.&#34;&#xA;&#xA;    [[&#34;Pick a suffix&#34;&#xA;      (&#34;c&#34; &#34;child&#34; tsc--inception-child-infix)]&#xA;&#xA;     [&#34;Update the description!&#34;&#xA;      (&#34;-d&#34; &#34;description&#34; &#34;--description=&#34;) ; makes history value structure apparent&#xA;      (&#34;u&#34; &#34;update&#34; tsc--inception-update-description :transient transient--do-exit)]&#xA;&#xA;     [&#34;Some suffixes&#34;&#xA;      (&#34;s&#34; &#34;wave surely&#34; tsc--wave-surely)&#xA;      (&#34;d&#34; &#34;wave definitely&#34; tsc--wave-definitely)&#xA;      (&#34;e&#34; &#34;wave eventually&#34; tsc--wave-eventually)&#xA;      (&#34;C&#34; &#34;call &amp;amp; exit normally&#34; tsc--wave-normally :transient nil)]&#xA;&#xA;     [&#34;Read variables&#34;&#xA;      (&#34;r&#34; &#34;read args&#34; tsc-suffix-print-args )]])&#xA;&#xA;  ;; (tsc-inception-update)&#xA;  ;; Pick a suffix,&#xA;  ;; Then set the description&#xA;  ;; Then update the suffix&#39;s you picked with the new description!&#xA;  ;; Using a transient to modify a transient (‚äÉÔΩ°‚Ä¢ÃÅ‚Äø‚Ä¢ÃÄÔΩ°)‚äÉ‚îÅ‚úø‚úø‚úø‚úø‚úø‚úø&#xA;  ;; Try to rename a group, such as (0 0)&#xA;  ;; Rename the very outer group, (0)&#xA;&#xA;#+end_src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** TODO Errata :PROPERTIES: :ID: 2ca7838b-1215-4f8b-985b-8ebac41dd980 :TOC: :ignore this :END:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Modifying the very outer group doesn&#39;t quite work.  It&#39;s probably a&#xA;degenrate layout object, meaning setting a description doesn&#39;t cause it to&#xA;behave like a group with a heading.  Maybe outer groups have a different&#xA;data structure?  *An exercise left to the reader*&#xA;&#xA;The flow control for re-display is slightly fighting the history&#xA;implementation.  It would be better if we could retain values while&#xA;triggering a redraw without even more hacking &amp;amp; state manipulation.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Appendixes :PROPERTIES: :TOC: :include descendants :depth 1 :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** EIEIO - OOP in Elisp&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Emacs lisp ships with eieio, a close cousin to the Common Lisp Object&#xA;System.  It&#39;s OOP.  There are classes &amp;amp; subclasses.  You can inherit into new&#xA;classes and override methods to customize behaviors.&#xA;&#xA;You can use eieio API&#39;s to explore transient objects.  Let&#39;s look at some&#xA;transients you have already:&#xA;&#xA;#+begin_src elisp :tangle no :results replace&#xA;&#xA;  ;; The plist for a prefix command contains a `transient-prefix&#39; object in the&#xA;  ;; `transient--prefix&#39; key and a vector layout in `transient--layout&#39; (symbol-plist&#xA;  (symbol-plist &#39;magit-dispatch)&#xA;&#xA;  ;; getting the values from the symbol plist&#xA;  (plist-get (symbol-plist &#39;magit-dispatch) &#39;transient--prefix)&#xA;&#xA;  (let ((prefix-object (plist-get (symbol-plist &#39;magit-dispatch) &#39;transient--prefix)))&#xA;&#xA;    ;; printing the current slot values for that object&#xA;    (object-write prefix-object)&#xA;&#xA;    ;; ;; Object transient-prefix-20997da&#xA;    ;; (transient-prefix &#34;transient-prefix-20997da&#34;&#xA;    ;;   :command magit-dispatch  :info-manual &#34;(magit)Top&#34;)&#xA;&#xA;    ;; getting the class of an object&#xA;    (eieio-object-class prefix-object) ; transient-prefix&#xA;&#xA;    ;; opening the help documents for the class, which shows all methods and&#xA;    ;; slot forms&#xA;    (describe-function transient-prefix))&#xA;&#xA;#+end_src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Typical OOP&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Like all OOP, the three things you want to do are:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** Override methods&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; =cl-defmethod= and sometimes =cl-call-next-method=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** Override default values&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; Inside the =defclass= form, you can set slots that you don&#39;t like.&#xA; =:initform= is a default value.  =:initarg= configures which argument&#xA; to pick up from the class constructor.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** Read &amp;amp; Update&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; =oref= and =oset=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** Call Methods&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; =(method-name object arguments)=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** Introspection&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; See methods like =slot-boundp= in the EIEIO [[info:eieio#Function Index][eieio method index]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Transient&#39;s defclass&#39;s and their inheritance&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Here&#39;s a list of all of transient&#39;s =defclass= and their ancestry.  This is&#xA;how it is in 2022.&#xA;&#xA;#+begin_src elisp :tangle no :results replace&#xA;&#xA;  (eieio-browse) ; shows all known classes and their ancestry&#xA;&#xA;  ;;     +--transient-child&#xA;  ;;     |    +--transient-group&#xA;  ;;     |    |    +--transient-subgroups&#xA;  ;;     |    |    +--transient-columns&#xA;  ;;     |    |    +--transient-row&#xA;  ;;     |    |    +--transient-column&#xA;  ;;     |    +--transient-suffix&#xA;  ;;     |         +--magit--git-submodule-suffix&#xA;  ;;     |         +--transient-infix&#xA;  ;;     |              +--transient-variable&#xA;  ;;     |              |    +--magit--git-variable&#xA;  ;;     |              |    |    +--magit--git-branch:upstream&#xA;  ;;     |              |    |    +--magit--git-variable:urls&#xA;  ;;     |              |    |    +--magit--git-variable:choices&#xA;  ;;     |              |    |         +--magit--git-variable:boolean&#xA;  ;;     |              |    +--transient-lisp-variable&#xA;  ;;     |              +--transient-argument&#xA;  ;;     |                   +--transient-switches&#xA;  ;;     |                   +--transient-option&#xA;  ;;     |                   |    +--transient-files&#xA;  ;;     |                   +--transient-switch&#xA;  ;;     +--transient-prefix&#xA;  ;;          +--magit-log-prefix&#xA;  ;;          |    +--magit-log-refresh-prefix&#xA;  ;;          +--magit-diff-prefix&#xA;  ;;               +--magit-diff-refresh-prefix&#xA;&#xA;#+end_src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** View Class Methods and Attributes&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Using =describe-function= is extremely handly for viewing the class slots&#xA;and methods.&#xA;&#xA;Classes used in transient that you are likely to want to know the slots for:&#xA;&#xA;[[elisp:(describe-function &#39;transient-prefix)][transient-prefix]]&#xA;[[elisp:(describe-function &#39;transient-suffix)][transient-suffix]]&#xA;[[elisp:(describe-function &#39;transient-infix)][transient-infix]]&#xA;[[elisp:(describe-function &#39;transient-argument)][transient-argument]]&#xA;&#xA;[[https://www.gnu.org/software/emacs/manual/html_mono/eieio.html#Inheritance][The eieio docs]] have a more wordy treatment.  The class system has a lot of&#xA;behavior that can be faster at times to just understand through description.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Debugging&lt;/p&gt; &#xA;&lt;p&gt;There is a lot of support for both print-line and step-through debugging.&lt;/p&gt; &#xA;&lt;p&gt;*** Print debug messages&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Just set =transient--debug= to t.  [[elisp:(setq transient--debug t)][(setq transient-debug t)]]&#xA;&#xA;You will get a lot of logs visible in =*Messages*= via&#xA;[[elisp:(view-echo-message-area)][view-echo-message-area]] the next time you run a transient.&#xA;&#xA;#+begin_src text :eval never&#xA;&#xA;-- setup              (cmd: tsc-layout-rows-explicit, event: &#34;M-x&#34;, exit: nil)&#xA;-- stack-zap          (cmd: tsc-layout-rows-explicit, event: &#34;M-x&#34;, exit: nil)&#xA;-- init-transient     (cmd: tsc-layout-rows-explicit, event: &#34;M-x&#34;, exit: nil)&#xA;     push transient--transient-map&#xA;     push transient--redisplay-map&#xA;-- post-command       (cmd: tsc-layout-rows-explicit, event: &#34;M-x&#34;, exit: nil)&#xA;-- pre-command        (cmd: transient-update, event: &#34;w&#34;, exit: nil)&#xA;     pop  transient--redisplay-map&#xA;-- post-command       (cmd: transient-update, event: &#34;w&#34;, exit: nil)&#xA;     pop  transient--redisplay-map&#xA;     push transient--redisplay-map&#xA;-- pre-command        (cmd: tsc-suffix-wave, event: &#34;w l&#34;, exit: nil)&#xA;-- stack-zap          (cmd: tsc-suffix-wave, event: &#34;w l&#34;, exit: nil)&#xA;-- pre-exit           (cmd: tsc-suffix-wave, event: &#34;w l&#34;, exit: t)&#xA;     pop  transient--transient-map&#xA;     pop  transient--redisplay-map&#xA;Waves at the user at: Sat Nov 12 22:38:20 2022.&#xA;-- post-command       (cmd: tsc-suffix-wave, event: &#34;w l&#34;, exit: t)&#xA;-- post-exit          (cmd: tsc-suffix-wave, event: &#34;w l&#34;, exit: t)&#xA;&#xA;#+end_src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Watching evaluation in Edebug&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*Edebug works with transients.  There is much support in transient to&#xA;facilitate using edebug.*&#xA;&#xA;For watching the flow control around your command, especially helpful for&#xA;debugging behavior around setup, layout, or suffix dispatch, you might want&#xA;to watch your transient in Edebug.&#xA;&#xA;[[https://www.youtube.com/watch?v=odkYXXYOxpo][Edebug]] basic introduction video (10 min).&#xA;&#xA;In short:&#xA;&#xA;- goto your [[elisp:(find-library &#34;transient&#34;)][transient source]]&#xA;- instrument a function you want to watch with =edebug-defun=&#xA;- call the transient / suffix that triggers entry of that function&#xA;- use =SPC= to step forward, =c= to continue, =i= to enter a function call,&#xA;  or =h= for help etc&#xA;&#xA;First watch the debug output to gain an idea of how your code flows with the&#xA;transient code.  Then instrument transient behaviors such as&#xA;=transient--post-exit= and use =i= to =edebug-step-in= to calls of interest.&#xA;&#xA;When you are done, remember to use [[elisp:(edebug-remove-instrumentation)][=edebug-remove-instrumentation=]] so that&#xA;you can go on without every transient you open trying to call the debugger.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**** Debugging Macro Forms&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Because edebug works on defuns while suffixes are defined with macros, you&#xA;may need to macro exand in order to come up with something debuggable.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Layout Hacking :PROPERTIES: :ID: 49cb2ea4-66fa-4bc4-ab91-268580e907a5 :END:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;First you need to explort the layout data structures.&#xA;&#xA;#+begin_src elisp :tangle no :results replace&#xA;&#xA;  ;; Let&#39;s look at the layout&#xA;  (let ((prefix-layout (plist-get (symbol-plist &#39;magit-dispatch) &#39;transient--layout)))&#xA;&#xA;    (type-of prefix-layout) ; cons&#xA;&#xA;    (listp prefix-layout) ; t&#xA;&#xA;    (length prefix-layout) ; 3&#xA;&#xA;    ;; Each group in the list is a vector&#xA;    (vectorp (car prefix-layout)) ; t&#xA;&#xA;    (elt (car prefix-layout) 0) ; first element is a priority&#xA;    (elt (car prefix-layout) 1) ; second is a type name&#xA;    (elt (car prefix-layout) 2) ; contents &amp;amp; attributes&#xA;&#xA;    ;; the attributes are key-value pairs used to create the class&#xA;    ;; instance when the transient is shown.&#xA;&#xA;    ;; the nested contents will be lists of vectors for groups and&#xA;    ;; lists of lists for suffixes.&#xA;&#xA;    )&#xA;&#xA;  ;; A sample layout&#xA;&#xA;  ;; ([1 transient-column nil&#xA;  ;;     ((1 transient-suffix&#xA;  ;;         (:key &#34;i&#34; :description &#34;Ignore&#34; :command magit-gitignore))&#xA;  ;;      (1 transient-suffix&#xA;  ;;         (:key &#34;I&#34; :description &#34;Init&#34; :command magit-init))&#xA;  ;;      (1 transient-suffix&#xA;  ;;         (:key &#34;j&#34; :description &#34;Jump to section&#34; :command magit-status-jump :if-mode magit-status-mode))&#xA;  ;;      (1 transient-suffix&#xA;  ;;         (:key &#34;j&#34; :description &#34;Display status&#34; :command magit-status-quick :if-not-mode magit-status-mode)))])&#xA;&#xA;#+end_src&#xA;&#xA;You might find this helpful when constructing [[*Dynamic Layouts][dynamic layouts]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Hooks&lt;/p&gt; &#xA;&lt;p&gt;Just a reminder, some hooks exist. Use =describe-variable= and complete with =transient hook= for the most recent list of hooks.&lt;/p&gt; &#xA;&lt;p&gt;** Preludes&lt;/p&gt; &#xA;&lt;p&gt;Definitions that are not that interesting on their own but are used in examples.&lt;/p&gt; &#xA;&lt;p&gt;*** tsc-suffix-wave Command&lt;/p&gt; &#xA;&lt;p&gt;#+name: wave-prelude #+begin_src elisp :tangle no&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (defun tsc-suffix-wave ()&#xA;   &#34;Wave at the user.&#34;&#xA;   (interactive)&#xA;   (message &#34;Waves at the user at: %s.&#34; (current-time-string)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** tsc-suffix-show-level&lt;/p&gt; &#xA;&lt;p&gt;#+name: show-level-prelude #+begin_src elisp :tangle no&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-suffix tsc-suffix-show-level ()&#xA;   &#34;Show the current transient&#39;s level.&#34;&#xA;   :transient t&#xA;   (interactive)&#xA;   (message &#34;Current level: %s&#34; (oref transient-current-prefix level)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** tsc--define-waver&lt;/p&gt; &#xA;&lt;p&gt;#+name: levels-prelude #+begin_src elisp :tangle no&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; ;; Because command names are used to store and lookup child levels, we have&#xA; ;; define a macro to generate unqiquely named wavers.  See #153 at&#xA; ;; https://github.com/magit/transient/issues/153&#xA; (defmacro tsc--define-waver (name)&#xA;   &#34;Define a new suffix with NAME tsc--wave-NAME.&#34;&#xA;   `(transient-define-suffix ,(intern (format &#34;tsc--wave-%s&#34; name)) ()&#xA;      ,(format &#34;Wave at the user %s&#34; name)&#xA;      :transient t&#xA;      (interactive)&#xA;      (message (format &#34;Waves at %s&#34; (current-time-string)))))&#xA;&#xA; ;; Each form results in a unique suffix definition.&#xA; (tsc--define-waver &#34;surely&#34;)&#xA; (tsc--define-waver &#34;normally&#34;)&#xA; (tsc--define-waver &#34;non-essentially&#34;)&#xA; (tsc--define-waver &#34;definitely&#34;)&#xA; (tsc--define-waver &#34;eventually&#34;)&#xA; (tsc--define-waver &#34;hidden&#34;)&#xA;&#xA; #+end_src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** tsc-suffix-print-args&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a suffix that reads the transient&#39;s infix values, the prefix&#39;s scope, and any universal argument (=C-u 4= etc).&lt;/p&gt; &#xA;&lt;p&gt;#+name: print-args-prelude #+begin_src elisp :tangle no&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (transient-define-suffix tsc-suffix-print-args (the-prefix-arg)&#xA;   &#34;Report the PREFIX-ARG, prefix&#39;s scope, and infix values.&#34;&#xA;   :transient &#39;transient--do-call&#xA;   (interactive &#34;P&#34;)&#xA;   (let ((args (transient-args (oref transient-current-prefix command)))&#xA;         (scope (oref transient-current-prefix scope)))&#xA;     (message &#34;prefix-arg: %s \nprefix&#39;s scope value: %s \ntransient-args: %s&#34;&#xA;              the-prefix-arg scope args)))&#xA;&#xA; ;; tsc-suffix-print-args command is incidentally created&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Essential Elisp&lt;/p&gt; &#xA;&lt;p&gt;If you were hit in the face with the first example, you need to learn basic Elisp. This is not an Elisp guide. Here&#39;s some starting points:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[info:elisp#Macros][transient-define-prefix]] is a macro that creates a command and attaches a =transient-prefix= object to the command symbol&#39;s plist.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[info:elisp#Lambda][lambda]] is a macro to create an anonymous function&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[info:elisp#Using Interactive][interactive]] is a macro that makes the function compatible with the command interface, the =M-x= or =execute-extended-command= menu&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[[info:elisp#Vector Functions][The brackets]] are just vector syntax.&lt;/p&gt; &lt;p&gt;Besides the other ways to evaluate elisp used in this README, try =ielm=.&lt;/p&gt; &lt;p&gt;Use the built-in elisp manual by calling the command =elisp-index-search=. See shortdocs for functions using =shortdoc-display-groups=.&lt;/p&gt; &lt;p&gt;The EIEIO and CL manuals are independent from the Elisp manual for some reason. EIEIO is pretty short and not used much once you get the hang of it. =info-display-manual=&lt;/p&gt; &lt;p&gt;[[info:cl#Top][Common Lisp manual]] you don&#39;t really need the common lisp manual for working with transient. Don&#39;t be alarmed when you see EIEIO using functions like =cl-call-next-method=&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Further Reading&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;[[info:transient#Top][&lt;em&gt;The Transient Manual&lt;/em&gt;]] ([[https://magit.vc/manual/transient.html][web link]]) contains more detailed explanation of behavior. The examples here should allow you to visualize what is being described. This guide and the manual should be your first and second sources.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;[[elisp:(find-library &#34;transient&#34;)][&lt;em&gt;Transient source&lt;/em&gt;]] ([[https://github.com/magit/transient/blob/master/lisp/transient.el][web link]]) is all in one file. Source code is always more accurate than manual descriptions, even if some behavior implementations are a bit scattered.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;[[elisp:(find-library &#34;magit&#34;)][&lt;em&gt;Magit source&lt;/em&gt;]] ([[https://github.com/magit/magit/search?q=transient][web link]]) contains numerous examples of transient being used in a big, full-feature application. Search the source for &#34;transient&#34; and you will find many prefixes, suffixes, and custom classes. The smallest examples may be harder to find and most combine many behaviors at once.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;#+begin_src elisp :tangle transient-showcase.el :noweb yes :hidden yes :eval never &amp;lt;&#xA;   &lt;package-footer&gt;&#xA;    &amp;gt; #+end_src&#xA;   &lt;/package-footer&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;More Packaging :PROPERTIES: :TOC: :ignore this :END:&lt;/p&gt; &lt;p&gt;The headers and footers for the tangled module.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Package Header&lt;/p&gt; &#xA;&lt;p&gt;#+name: package-header #+begin_src elisp tangle: no :eval never ;;; transient-showcase.el --- transient features &amp;amp; behavior showcase -&lt;em&gt;- lexical-binding: t; -&lt;/em&gt;-&lt;/p&gt; &#xA;&lt;p&gt;;; Copyright (C) 2022 Positron Solutions&lt;/p&gt; &#xA;&lt;p&gt;;; Author: Psionik K &lt;a href=&#34;mailto:73710933+psionic-k@users.noreply.github.com&#34;&gt;73710933+psionic-k@users.noreply.github.com&lt;/a&gt; ;; Keywords: convenience ;; Version: 0.1.0 ;; Package-Requires: ((emacs &#34;28.1&#34;)) ;; Homepage: &lt;a href=&#34;http://github.com/positron-solutions/transient-showcase&#34;&gt;http://github.com/positron-solutions/transient-showcase&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;;;; License notice:&lt;/p&gt; &#xA;&lt;p&gt;;; This program is free software: you can redistribute it and/or modify ;; it under the terms of the GNU General Public License as published by ;; the Free Software Foundation, either version 3 of the License, or ;; (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;;; This program is distributed in the hope that it will be useful, ;; but WITHOUT ANY WARRANTY; without even the implied warranty of ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ;; GNU General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;;; You should have received a copy of the GNU General Public License ;; along with this program. If not, see &lt;a href=&#34;https://www.gnu.org/licenses/&#34;&gt;https://www.gnu.org/licenses/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;;;; Commentary:&lt;/p&gt; &#xA;&lt;p&gt;;; This package is created from the README and serves as a fast way to load ;; all of the examples without tangling the org document. This is appropriate ;; if you just want to quickly browse through the examples and see their ;; source code. ;; ;; M-x tsc-showcase contains most of the prefixes and can be bound for ;; use as a quick reference. Just use transient&#39;s help for each ;; command to see the source. C-h &#xA; &lt;suffix key&gt;&#xA;  . ;;&#xA; &lt;/suffix&gt;&lt;/p&gt; &#xA;&lt;p&gt;;;; Code:&lt;/p&gt; &#xA;&lt;p&gt;(require &#39;transient) (require &#39;org-id)&lt;/p&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Package Footer&lt;/p&gt; &#xA;&lt;p&gt;This block includes the showcase transient.&lt;/p&gt; &#xA;&lt;p&gt;#+name: package-footer #+begin_src elisp :tangle no :eval never&lt;/p&gt; &#xA;&lt;p&gt;(transient-define-prefix tsc-showcase () &#34;A launcher for a currated selection of examples. While most of the prefixes have their :transient slot set to t, it&#39;s not possible to return from all of them, especially if they demonstrate flow control such as replacing or exiting.&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; [[&#34;Layouts&#34;&#xA;   (&#34;ls&#34; &#34;stacked&#34; tsc-layout-stacked :transient t)&#xA;   (&#34;lc&#34; &#34;columns&#34; tsc-layout-columns :transient t)&#xA;   (&#34;lt&#34; &#34;stacked columns&#34; tsc-layout-stacked-columns :transient t)&#xA;   (&#34;lg&#34; &#34;grid&#34; tsc-layout-the-grid :transient t)&#xA;   (&#34;lp&#34; &#34;spaced out&#34; tsc-layout-spaced-out :transient t)&#xA;   (&#34;le&#34; &#34;explicit class&#34; tsc-layout-explicit-classes :transient t)&#xA;   (&#34;ld&#34; &#34;descriptions&#34; tsc-layout-descriptions :transient t)&#xA;   ;; padded description to sc&#xA;   (&#34;lD&#34; &#34;dynamic descriptions        &#34; tsc-layout-dynamic-descriptions :transient t)]&#xA;&#xA;  [&#34;Nesting &amp;amp; Flow Control&#34;&#xA;   (&#34;fs&#34; &#34;stay transient&#34; tsc-stay-transient :transient t)&#xA;   (&#34;fb&#34; &#34;binding sub-prefix&#34; tsc-simple-parent :transient t)&#xA;   (&#34;fr&#34; &#34;sub-prefix with return&#34; tsc-simple-parent-with-return :transient t)&#xA;   (&#34;fm&#34; &#34;manual setup in suffix&#34; tsc-parent-with-setup-suffix :transient t)&#xA;   (&#34;fi&#34; &#34;mixing interactive&#34; tsc-interactive-basic :transient t)&#xA;   (&#34;fe&#34; &#34;early return&#34; tsc-simple-messager :transient t)]]&#xA;&#xA;  [[&#34;Managing State&#34; ; padded right group&#xA;   (&#34;sb&#34; &#34;a bunch of infixes&#34; tsc-basic-infixes :transient t)&#xA;   (&#34;sc&#34; &#34;using scope (accepts prefix)&#34; tsc-scope :transient t)&#xA;   (&#34;sn&#34; &#34;set &amp;amp; save / snowcones&#34; tsc-snowcone-eater :transient t)&#xA;   (&#34;sp&#34; &#34;history key / ping-pong&#34; tsc-ping :transient t)&#xA;   (&#34;sg&#34; &#34;always forget / goldfish&#34; tsc-goldfish :transient t)&#xA;   (&#34;se&#34; &#34;always remember / elephant&#34; tsc-elephant :transient t)&#xA;   (&#34;sd&#34; &#34;default values&#34; tsc-default-values :transient t)&#xA;   (&#34;sf&#34; &#34;enforcing inputs&#34; tsc-enforcing-inputs :transient t)&#xA;   (&#34;sl&#34; &#34;lisp variables&#34; tsc-lisp-variable :transient t)]&#xA;&#xA; [&#34;CLI arguments&#34;&#xA;   (&#34;cb&#34; &#34;basic arguments&#34; tsc-switches-and-arguments :transient t)&#xA;   (&#34;cm&#34; &#34;random-init infix&#34; tsc-maybe-on :transient t)&#xA;   (&#34;cc&#34; &#34;basic choices&#34; tsc-animal-choices :transient t)&#xA;   (&#34;ce&#34; &#34;exclusive switches&#34; tsc-exclusive-switches :transient t)&#xA;   (&#34;ci&#34; &#34;incompatible switches&#34; tsc-incompatible :transient t)&#xA;   (&#34;co&#34; &#34;completions for choices&#34; tsc-choices-with-completions :transient t)&#xA;   (&#34;cc&#34; &#34;cowsay cli wrapper&#34; tsc-cowsay :transient t)]]&#xA;&#xA;  [[&#34;Visibility&#34;&#xA;    ;; padded description to sc&#xA;   (&#34;vp&#34; &#34;predicates                  &#34; tsc-visibility-predicates :transient t)&#xA;   (&#34;vi&#34; &#34;inapt (not suitable)&#34; tsc-inapt-parent :transient t)&#xA;   (&#34;vl&#34; &#34;levels&#34; tsc-levels-and-visibility :transient t)]&#xA;&#xA;  [&#34;Advanced&#34;&#xA;   (&#34;ac&#34; &#34;generated child&#34; tsc-generated-child :transient t)&#xA;   (&#34;ag&#34; &#34;generated group&#34; tsc-generated-group :transient t)&#xA;   (&#34;ai&#34; &#34;custom infixes&#34; tsc-inception :transient t)&#xA;   (&#34;au&#34; &#34;custom infixes &amp;amp; update&#34; tsc-inception-update :transient t)]])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(provide &#39;transient-showcase) ;;; transient-showcase.el ends here&lt;/p&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;h1&gt;Local Variables:&lt;/h1&gt; &#xA;&lt;h1&gt;before-save-hook: (lambda () (when (require &#39;org-make-toc nil t) (org-make-toc)))&lt;/h1&gt; &#xA;&lt;h1&gt;org-export-with-properties: ()&lt;/h1&gt; &#xA;&lt;h1&gt;org-export-with-title: t&lt;/h1&gt; &#xA;&lt;h1&gt;org-make-toc-link-type-fn: org-make-toc--link-entry-org&lt;/h1&gt; &#xA;&lt;h1&gt;End:&lt;/h1&gt;</summary>
  </entry>
</feed>