<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-21T01:43:11Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kiwanami/emacs-epc</title>
    <updated>2022-07-21T01:43:11Z</updated>
    <id>tag:github.com,2022-07-21:/kiwanami/emacs-epc</id>
    <link href="https://github.com/kiwanami/emacs-epc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A RPC stack for Emacs Lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;EPC : The Emacs RPC&lt;/h1&gt; &#xA;&lt;p&gt;This program is an asynchronous RPC stack for Emacs. Using this RPC stack, the Emacs can communicate with the peer process smoothly. Because the protocol employs S-expression encoding and consists of asynchronous communications, the RPC response is fairly good.&lt;/p&gt; &#xA;&lt;p&gt;Current implementations for the EPC are followings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;epcs.el : Emacs Lisp implementation (this project)&lt;/li&gt; &#xA; &lt;li&gt;RPC::EPC::Service : Perl implementation (this project) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You can get this module by CPAN or PPM.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;python-epc : Python implementation &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;http://python-epc.readthedocs.org/en/latest/&#34;&gt;http://python-epc.readthedocs.org/en/latest/&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;ruby-elrpc : Ruby implementation &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You can get &lt;code&gt;elrpc&lt;/code&gt; from rubygems.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/kiwanami/ruby-elrpc&#34;&gt;https://github.com/kiwanami/ruby-elrpc&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;nodejs-elrpc : Node.js implementation &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You can get &lt;code&gt;elrpc&lt;/code&gt; from npm.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/kiwanami/node-elrpc&#34;&gt;https://github.com/kiwanami/node-elrpc&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The current status is beta. This library needs more applications to confirm stability of the API and robustness of the implementation.&lt;/p&gt; &#xA;&lt;h2&gt;Applications&lt;/h2&gt; &#xA;&lt;p&gt;Projects using EPC:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kiwanami/emacs-edbi&#34;&gt;Emacs DBI&lt;/a&gt;: Database GUI and API for Emacs&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tkf/emacs-jedi&#34;&gt;Emacs Jedi&lt;/a&gt;: Python auto-completion for Emacs&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.emacswiki.org/emacs/WebKit&#34;&gt;Emacs Webkit&lt;/a&gt; Full-featured browser in Emacs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Sample Code&lt;/h2&gt; &#xA;&lt;p&gt;Here is a client code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;epc)&#xA;&#xA;(setq epc (epc:start-epc &#34;perl&#34; &#39;(&#34;echo-server.pl&#34;)))&#xA;&#xA;(deferred:$&#xA;  (epc:call-deferred epc &#39;echo &#39;(10))&#xA;  (deferred:nextc it &#xA;    (lambda (x) (message &#34;Return : %S&#34; x))))&#xA;&#xA;(deferred:$&#xA;  (epc:call-deferred epc &#39;add &#39;(10 40))&#xA;  (deferred:nextc it &#xA;    (lambda (x) (message &#34;Return : %S&#34; x))))&#xA;&#xA;;; calling synchronously&#xA;(message &#34;%S&#34; (epc:call-sync epc &#39;echo &#39;(10)))&#xA;&#xA;;; Request peer&#39;s methods&#xA;(message &#34;%S&#34; (epc:sync epc (epc:query-methods-deferred epc)))&#xA;&#xA;(epc:stop-epc epc)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is a server code in perl.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;#!/usr/bin/perl&#xA;&#xA;use RPC::EPC::Service;&#xA;&#xA;sub echo_test {&#xA;    my $methods = {&#xA;    &#xA;        &#39;echo&#39; =&amp;gt; [sub {&#xA;            my $args = shift;&#xA;            return $args;&#xA;        },&#34;args&#34;,&#34;just echo back arguments.&#34;],&#xA;        &#xA;        &#39;add&#39; =&amp;gt; sub {&#xA;            my $args_ref = shift;&#xA;            my ($a,$b) = @$args_ref;&#xA;            return $a + $b;&#xA;        }&#xA;    };&#xA;    my $server = RPC::EPC::Service-&amp;gt;new(0, $methods);&#xA;    $server-&amp;gt;start;&#xA;}&#xA;&#xA;echo_test();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is the equivalent server code in emacs lisp.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;epcs)&#xA;&#xA;(let ((connect-function&#xA;       (lambda (mngr) &#xA;         (epc:define-method mngr &#39;echo (lambda (&amp;amp;rest x) x) &#34;args&#34; &#34;just echo back arguments.&#34;)&#xA;         (epc:define-method mngr &#39;add &#39;+ &#34;args&#34; &#34;add argument numbers.&#34;)&#xA;         )) server-process)&#xA;&#xA;  (setq server-process (epcs:server-start connect-function))&#xA;  (sleep-for 10)&#xA;  (epcs:server-stop server-process))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The elisp server code should be started with some arguments (batch starting and indicating load paths) like the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(setq epc (epc:start-epc &#34;emacs&#34; &#39;(&#34;-L&#34; &#34;..&#34; &#34;-L&#34; &#34;~/.emacs.d/elisp&#34; &#34;-batch&#34; &#34;-l&#34; &#34;deferred&#34; &#34;-l&#34; &#34;concurrent&#34; &#34;-l&#34; &#34;epc&#34; &#34;-l&#34; &#34;epcs&#34; &#34;-l&#34; &#34;echo-server.el&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;Package installation&lt;/h2&gt; &#xA;&lt;p&gt;If you use package.el with MELPA (&lt;a href=&#34;http://melpa.org/&#34;&gt;http://melpa.org/&lt;/a&gt;), you just select the package &lt;code&gt;epc&lt;/code&gt; and install it.&lt;/p&gt; &#xA;&lt;h2&gt;Manual installation&lt;/h2&gt; &#xA;&lt;p&gt;This program depends on following programs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;deferred.el, concurrent.el / &lt;a href=&#34;https://github.com/kiwanami/emacs-deferred&#34;&gt;https://github.com/kiwanami/emacs-deferred&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;ctable.el / &lt;a href=&#34;https://github.com/kiwanami/emacs-ctable&#34;&gt;https://github.com/kiwanami/emacs-ctable&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Place those programs and this one (epc.el) in your load path and add following code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;epc)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;API Document&lt;/h1&gt; &#xA;&lt;p&gt;This section describes the overview of the EPC and how to use API.&lt;/p&gt; &#xA;&lt;h3&gt;API Overview&lt;/h3&gt; &#xA;&lt;p&gt;The EPC uses a peer-to-peer-architecture. After the connection is established, both peers can define remote methods and call the methods at the other side.&lt;/p&gt; &#xA;&lt;p&gt;Let we define the words &lt;em&gt;server&lt;/em&gt; and &lt;em&gt;client&lt;/em&gt;. &lt;em&gt;Server&lt;/em&gt; is a process which opens a TCP port and waiting for the connection. &lt;em&gt;Client&lt;/em&gt; is a process which connects to the &lt;em&gt;server&lt;/em&gt;. In most cases, a &lt;em&gt;client&lt;/em&gt; process starts a &lt;em&gt;server&lt;/em&gt; process. Then, the &lt;em&gt;server&lt;/em&gt; process provides some services to the &lt;em&gt;client&lt;/em&gt; process.&lt;/p&gt; &#xA;&lt;p&gt;This diagram shows the API usage and the relation of processes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kiwanami/emacs-epc/master/img/Overview.png&#34; alt=&#34;API Overview&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Object Serialization&lt;/h3&gt; &#xA;&lt;p&gt;All values which are transferred as arguments and return values between processes, are encoded into the S-expression text format.&lt;/p&gt; &#xA;&lt;p&gt;The EPC uses S-expression as an object serialization format, not JSON. In these days, JSON is widely employed and many environments has some JSON serializers. However, JSON is not the best format for IPC from the point of view of serialization speed. The current Emacs implementation (23.x and 24.x) can read/write JSON format with json.el about 5-10 times slower than S-expression one. Since the Emacs interpreter is often slower than other interpreters or VMs, we should choose a format so that Emacs can deal faster. In addition, S-expression has good expression power as well as JSON does. So, the EPC stack uses S-expression, though we need more work for writing S-expression serializers on the peer side. (In the future, we may use JSON when Emacs can read/write JSON in native library...)&lt;/p&gt; &#xA;&lt;p&gt;Simple list structure and some primitive types can be transferred. Complicated objects, such as buffer objects, can not be serialized. The EPC stack doesn&#39;t provide transparent remote object service, that is ORB.&lt;/p&gt; &#xA;&lt;p&gt;The EPC stack can translate following types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;nil&lt;/li&gt; &#xA; &lt;li&gt;symbol&lt;/li&gt; &#xA; &lt;li&gt;number&lt;/li&gt; &#xA; &lt;li&gt;string&lt;/li&gt; &#xA; &lt;li&gt;list&lt;/li&gt; &#xA; &lt;li&gt;complex object of list and alist.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The elisp function &lt;code&gt;prin1&lt;/code&gt; is employed for the serialization from objects to string.&lt;/p&gt; &#xA;&lt;p&gt;The peer EPC stack decodes the S-expression text and reconstructs appropriate objects in the particular language environment.&lt;/p&gt; &#xA;&lt;p&gt;You may want to translate an &lt;code&gt;alist&lt;/code&gt; as a collection object of key-value pairs transparently, so called &lt;code&gt;Hash&lt;/code&gt;. However, because we can not distinguish between alist and nested list, it is responsible for the programmer to exchange the alist objects and the hash objects.&lt;/p&gt; &#xA;&lt;h3&gt;EPC Manager Object (epc:manager)&lt;/h3&gt; &#xA;&lt;p&gt;The struct &lt;code&gt;epc:manager&lt;/code&gt; defines all information for an EPC activity, such as the connection status, remote methods and sessions. Many API functions needs the instance object as an argument. You, however, doesn&#39;t have to learn the internal slots and detailed implementations.&lt;/p&gt; &#xA;&lt;p&gt;An instance of the struct &lt;code&gt;epc:manager&lt;/code&gt; is created by calling the initialization function &lt;code&gt;epc:start-epc&lt;/code&gt;. You can stop the EPC connection with calling the termination function &lt;code&gt;epc:stop-epc&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Start EPC (epc:start-epc)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;epc:start-epc (server-prog server-args)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Start the epc server program, establish the connection and return an &lt;code&gt;epc:manager&lt;/code&gt; object.&lt;/li&gt; &#xA;   &lt;li&gt;Argument &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;server-prog&lt;/code&gt;: a path string for the server program&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;server-args&lt;/code&gt;: a list of command line arguments&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;This function blocks the evaluation and returns an &lt;code&gt;epc:manager&lt;/code&gt; object.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Error &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;If the server prints out non-numeric value in the first line or does not print out the port number in three seconds, it is regarded as start-up failure.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The established EPC session is registered to the global variable for the connection management interface. (See the Management Interface section.)&lt;/p&gt; &#xA;&lt;h3&gt;Stop EPC (epc:stop-epc)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;epc:stop-epc (mngr)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Disconnect the connection and kill the server process.&lt;/li&gt; &#xA;   &lt;li&gt;If the &lt;code&gt;epc:manager&lt;/code&gt; object has exit hooks, this function executes those clean-up hooks.&lt;/li&gt; &#xA;   &lt;li&gt;Argument &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;an &lt;code&gt;epc:manager&lt;/code&gt; object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Define Remote Method (epc:define-method)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;epc:define-method (mngr method-name task &amp;amp;optional arg-specs docstring)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Define a remote method&lt;/li&gt; &#xA;   &lt;li&gt;Argument &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;mngr&lt;/code&gt;: &lt;code&gt;epc:manager&lt;/code&gt; object&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;method-name&lt;/code&gt;: the method name&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;task&lt;/code&gt;: function symbol or lambda&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;arg-specs&lt;/code&gt;: argument signature for the remote method [optional]&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;docstring&lt;/code&gt;: short description for the remote method [optional]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;an &lt;code&gt;epc:method&lt;/code&gt; object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The documents are referred by the peer process for users to inspect the methods.&lt;/p&gt; &#xA;&lt;h3&gt;Call Remote Method (epc:call-deferred, epc:call-sync)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;epc:call-deferred (mngr method-name args)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Call the remote method asynchronously.&lt;/li&gt; &#xA;   &lt;li&gt;Argument &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;mngr&lt;/code&gt;: &lt;code&gt;epc:manager&lt;/code&gt; object&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;method-name&lt;/code&gt;: the method name to call&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;args&lt;/code&gt;: a list of the arguments&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Deferred object&lt;/li&gt; &#xA;     &lt;li&gt;See the next section for the error handling&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;epc:call-sync (mngr method-name args)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Call the remote method synchronously.&lt;/li&gt; &#xA;   &lt;li&gt;Argument &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;mngr&lt;/code&gt;: &lt;code&gt;epc:manager&lt;/code&gt; object&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;method-name&lt;/code&gt;: the method name to call&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;args&lt;/code&gt;: a list of the arguments&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a result from the remote method&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Error Handling&lt;/h3&gt; &#xA;&lt;p&gt;The remote method calling may raise the error. The error has two types, the peer&#39;s program (&lt;code&gt;application-error&lt;/code&gt;) and the EPC stack (&lt;code&gt;epc-error&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;application-error&lt;/code&gt; is a normal error which is caused by peer&#39;s program, such as &#39;division by zero&#39;, &#39;file not found&#39; and so on. The programmers are responsible to this type errors, recovering error handling or just fixing bugs.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;epc-error&lt;/code&gt; is a communication error which is caused by EPC stack, such as &#39;connection closed&#39;, &#39;method not found&#39;, &#39;serialization error&#39; and so on. This type errors are caused by environment problems, bugs of peer&#39;s program, our side one or the EPC stack.&lt;/p&gt; &#xA;&lt;p&gt;Here is a sample robust code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(deferred:$&#xA;    (epc:call-deferred mngr &#34;a-method&#34; &#39;(1 2))&#xA;    (deferred:next it&#xA;        (lambda (x)&#xA;            ;; Normal return&#xA;            ;; x: result value&#xA;            ))&#xA;    (deferred:error it&#xA;        (lambda (err)&#xA;         (cond&#xA;          ((stringp err)&#xA;            ;; application error&#xA;            ;; err: error message&#xA;           )&#xA;          ((eq &#39;epc-error (car err))&#xA;            ;; epc error&#xA;            ;; err: (cadr err) -&amp;gt; error information&#xA;           )))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the case of synchronous calling, a signal will be thrown immediately.&lt;/p&gt; &#xA;&lt;h3&gt;Utilities&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;epc:live-p (mngr)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If the EPC stack for &lt;code&gt;mngr&lt;/code&gt; is eastablished, this function returns &lt;code&gt;t&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;epc:query-methods-deferred (mngr)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Return a list of &lt;code&gt;epc:method&lt;/code&gt; objects for the peer process.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Define Server&lt;/h3&gt; &#xA;&lt;p&gt;Following functions require the &lt;code&gt;epcs&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;epcs:server-start (connect-function &amp;amp;optional port)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Start EPC manager stack and initialize the manager with connect-function.&lt;/li&gt; &#xA;   &lt;li&gt;Argument &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;connect-function&lt;/code&gt;: a function symbol or lambda with one argument &lt;code&gt;mngr&lt;/code&gt;, in which function the manager should define some remote methods.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;port&lt;/code&gt;: TCP port number. (default: determined by the OS)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Return &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;process object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here is a sample code for the EPC server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;epcs)&#xA;&#xA;(let ((connect-function&#xA;       (lambda (mngr) &#xA;         (epc:define-method mngr &#39;echo (lambda (x) x) &#34;args&#34; &#34;just echo back arguments.&#34;)&#xA;         (epc:define-method mngr &#39;add &#39;+ &#34;args&#34; &#34;add argument numbers.&#34;)&#xA;         )) server-process)&#xA;&#xA;  (setq server-process (epcs:server-start connect-function))&#xA;&#xA;  ;; do something or wait for clients&#xA;&#xA;  (epcs:server-stop server-process))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;epcs:server-stop (process)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Stop EPC manager stack.&lt;/li&gt; &#xA;   &lt;li&gt;Argument &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;process&lt;/code&gt;: process object&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Debug&lt;/h3&gt; &#xA;&lt;p&gt;Because the EPC stack is designed to work asynchronously, sometimes you can not use the debugger for the own programs. Then, logging is useful to analyze the troubles.&lt;/p&gt; &#xA;&lt;p&gt;The EPC has some debug functions for analyzing low level communication.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;epc:debug-out&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If this variable is non-nil, the EPC stack records events and communications into the debug buffer.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;epc:debug-buffer&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;debug buffer name (default: &#39;&lt;em&gt;epc log&lt;/em&gt;&#39;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;epc:log (&amp;amp;rest args)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;logging debug messages&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Management Interface&lt;/h2&gt; &#xA;&lt;p&gt;The EPC has a management interface for the EPC connections. Users can check the current connection status, inspect method specs and terminate the connection.&lt;/p&gt; &#xA;&lt;h3&gt;Current Connections&lt;/h3&gt; &#xA;&lt;p&gt;Executing &lt;code&gt;M-x epc:controller&lt;/code&gt;, you can display the list of current established connections.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kiwanami/emacs-epc/master/img/mm-conns.png&#34; alt=&#34;Current Connections&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This table shows following information:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Column&lt;/th&gt; &#xA;   &lt;th&gt;Note&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Process&lt;/td&gt; &#xA;   &lt;td&gt;Process name&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Proc&lt;/td&gt; &#xA;   &lt;td&gt;Process status (&lt;code&gt;process-status&lt;/code&gt; for the process)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Conn&lt;/td&gt; &#xA;   &lt;td&gt;Connection status (&lt;code&gt;process-status&lt;/code&gt; for the TCP connection)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Title&lt;/td&gt; &#xA;   &lt;td&gt;Connection title which is defined by the EPC user program.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Command&lt;/td&gt; &#xA;   &lt;td&gt;Process command and arguments.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Port&lt;/td&gt; &#xA;   &lt;td&gt;TCP port which is opened by the remote process.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Methods&lt;/td&gt; &#xA;   &lt;td&gt;Number of methods which are defined at the Emacs side.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Live sessions&lt;/td&gt; &#xA;   &lt;td&gt;Number of sessions which are waiting for a return value.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;This management buffer provides following key-bind:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Key&lt;/th&gt; &#xA;   &lt;th&gt;Command&lt;/th&gt; &#xA;   &lt;th&gt;Note&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;g&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;epc:controller-update-command&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Refresh the table.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;R&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;epc:controller-connection-restart-command&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Restart the selected connection.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;D,K&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;epc:controller-connection-kill-command&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Kill the selected process and connection.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;m,RET&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;epc:controller-methods-show-command&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Display a method list of the remote process. (See the next sub-section for details.)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;B&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;epc:controller-connection-buffer-command&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Display the connection buffer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Remote Method List&lt;/h3&gt; &#xA;&lt;p&gt;Displaying a method list, you can inspect the methods which are defined by the remote process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kiwanami/emacs-epc/master/img/mm-methods.png&#34; alt=&#34;Remote Method List&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This table shows following information:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Column&lt;/th&gt; &#xA;   &lt;th&gt;Note&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Method Name&lt;/td&gt; &#xA;   &lt;td&gt;Method name to call.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Arguments&lt;/td&gt; &#xA;   &lt;td&gt;[optional] Argument names.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Document&lt;/td&gt; &#xA;   &lt;td&gt;[optional] Method spec document.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Here, &#39;Arguments&#39; and &#39;Document&#39; columns may be blank, because those are not essential slots.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Key&lt;/th&gt; &#xA;   &lt;th&gt;Command&lt;/th&gt; &#xA;   &lt;th&gt;Note&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;e&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;epc:controller-methods-eval-command&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Evaluate the selected remote method with some arguments.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;q&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bury-buffer&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Bury this buffer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Implementation&lt;/h1&gt; &#xA;&lt;p&gt;This section describes the EPC architecture and the wire-protocol so as to implement the peer stacks.&lt;/p&gt; &#xA;&lt;h2&gt;Protocol Details&lt;/h2&gt; &#xA;&lt;p&gt;The EPC protocol is based on the SWANK protocol.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://bc.tech.coop/blog/081209.html&#34;&gt;Understanding SLIME (Using Emacs and Lisp Cooperatively)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Message Envelope&lt;/h3&gt; &#xA;&lt;p&gt;A message consists of 6 bytes content-length and a subsequent payload content. The payload content is a S-expression string. The S-expression is a cons cell, car is message type symbol and cdr is message body list.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PAYLOAD-LENGTH : 24-bit hex-encoded integer&lt;/li&gt; &#xA; &lt;li&gt;PAYLOAD-CONTENT : S-expression, text, utf-8 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;(MESSAGE-TYPE . MESSAGE-BODY-LIST)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The message type can be chosen from &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;return-error&lt;/code&gt;, &lt;code&gt;epc-error&lt;/code&gt; and &lt;code&gt;methods&lt;/code&gt;. The message body varies according to the message type.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MESSAGE-TYPE : &lt;code&gt;call&lt;/code&gt; | &lt;code&gt;return&lt;/code&gt; | &lt;code&gt;return-error&lt;/code&gt; | &lt;code&gt;epc-error&lt;/code&gt; | &lt;code&gt;methods&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;MESSAGE-BODY-LIST : (Dependent on message types.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Message [call]&lt;/h3&gt; &#xA;&lt;p&gt;This message represents calling a peer&#39;s method.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MESSAGE-BODY-LIST : &lt;code&gt;(UID METHOD-NAME ARGS)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;UID : The session ID, which is an unique ID generated by the caller side.&lt;/li&gt; &#xA;   &lt;li&gt;METHOD-NAME : A symbol for method name.&lt;/li&gt; &#xA;   &lt;li&gt;ARGS : A list of method arguments.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Message [return]&lt;/h3&gt; &#xA;&lt;p&gt;This message represents a return value for normal finish of the method calling.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MESSAGE-BODY-LIST : &lt;code&gt;(UID RETURN-VALUE)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;UID : The session ID to return.&lt;/li&gt; &#xA;   &lt;li&gt;RETURN-VALUE : A return object.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Message [return-error]&lt;/h3&gt; &#xA;&lt;p&gt;This message represents an application error, which is due to the application.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MESSAGE-BODY-LIST : &lt;code&gt;(UID ERROR-MESSAGE)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;UID : The session ID to return.&lt;/li&gt; &#xA;   &lt;li&gt;ERROR-MESSAGE : An error message.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Message [epc-error]&lt;/h3&gt; &#xA;&lt;p&gt;This message represents an EPC error, which is due to the EPC stack.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MESSAGE-BODY-LIST : &lt;code&gt;(UID ERROR-MESSAGE)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;UID : The session ID to return.&lt;/li&gt; &#xA;   &lt;li&gt;ERROR-MESSAGE : An error message.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Message [methods]&lt;/h3&gt; &#xA;&lt;p&gt;This message represents a method query.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MESSAGE-BODY-LIST : &lt;code&gt;(UID)&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;UID : The session ID, which is an unique ID generated by the caller side.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The response message is returned by the &lt;code&gt;return&lt;/code&gt; message.&lt;/p&gt; &#xA;&lt;h2&gt;EPC Internal&lt;/h2&gt; &#xA;&lt;p&gt;The EPC is developed on &lt;code&gt;deferred.el&lt;/code&gt; and &lt;code&gt;concurrent.el&lt;/code&gt;. The library &lt;code&gt;deferred.el&lt;/code&gt; provides primitive an asynchronous framework and &lt;code&gt;concurrent.el&lt;/code&gt; does concurrent programing components.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kiwanami/emacs-deferred/raw/master/README.markdown&#34;&gt;deferred.el document&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kiwanami/emacs-deferred/raw/master/README-concurrent.markdown&#34;&gt;concurrent.el document&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The EPC user should learn asynchronous programing on &lt;code&gt;deferred.el&lt;/code&gt;. The components of &lt;code&gt;concurrent.el&lt;/code&gt; are just internally used at &lt;code&gt;epc.el&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kiwanami/emacs-epc/master/img/epc-stack.png&#34; alt=&#34;EPC Stack&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here is a diagram for the &lt;code&gt;epc.el&lt;/code&gt; architecture, which diagram may be helpful for code reading of &lt;code&gt;epc.el&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kiwanami/emacs-epc/master/img/epc-internal.png&#34; alt=&#34;Internal Architecture&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Other Stacks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;perl EPC document &lt;a href=&#34;http://search.cpan.org/~kiwanami/RPC-EPC-Service-v0.0.7/lib/RPC/EPC/Service.pm&#34;&gt;http://search.cpan.org/~kiwanami/RPC-EPC-Service-v0.0.7/lib/RPC/EPC/Service.pm&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;python EPC document &lt;a href=&#34;http://python-epc.readthedocs.org/en/latest/&#34;&gt;http://python-epc.readthedocs.org/en/latest/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;ruby EPC document &lt;a href=&#34;https://github.com/kiwanami/ruby-elrpc/raw/master/README.md&#34;&gt;https://github.com/kiwanami/ruby-elrpc/blob/master/README.md&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;nodejs EPC document &lt;a href=&#34;https://github.com/kiwanami/node-elrpc/raw/master/readme.md&#34;&gt;https://github.com/kiwanami/node-elrpc/blob/master/readme.md&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;EPC is licensed under GPL v3.&lt;/p&gt; &#xA;&lt;h1&gt;Acknowledgment&lt;/h1&gt; &#xA;&lt;p&gt;I received generous support from @tkf. Thanks!&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;(C) 2012, 2013, 2014, 2015 SAKURAI Masashi. m.sakurai at kiwanami.net&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacsorphanage/ov</title>
    <updated>2022-07-21T01:43:11Z</updated>
    <id>tag:github.com,2022-07-21:/emacsorphanage/ov</id>
    <link href="https://github.com/emacsorphanage/ov" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Overlay library for Emacs Lisp.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ov.el &lt;a href=&#34;https://travis-ci.org/ShingoFukuyama/ov.el&#34;&gt;&lt;img src=&#34;https://travis-ci.org/ShingoFukuyama/ov.el.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/ov&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/ov-badge.svg?sanitize=true&#34; alt=&#34;melpa badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/ov&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/ov-badge.svg?sanitize=true&#34; alt=&#34;melpa stable badge&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Simple way to manipulate overlay for Emacs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ShingoFukuyama/images/master/ov1.gif&#34; alt=&#34;ov.el&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Overlay is capable of manipulating text appearance, cursor behavior, etc. It doesn&#39;t affect font-lock or text-properties.&lt;/p&gt; &#xA;&lt;h2&gt;Command&lt;/h2&gt; &#xA;&lt;p&gt;You can always do &lt;code&gt;M-x ov-clear&lt;/code&gt; to clear all overlays in the current buffer.&lt;/p&gt; &#xA;&lt;h2&gt;Functions&lt;/h2&gt; &#xA;&lt;h3&gt;Make overlay / Set properties&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-beg-end-rest-properties&#34;&gt;ov&lt;/a&gt; &lt;code&gt;(beg end &amp;amp;rest properties)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-make-beg-end&#34;&gt;ov-make&lt;/a&gt; &lt;code&gt;(beg end)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-line-optional-point&#34;&gt;ov-line&lt;/a&gt; &lt;code&gt;(&amp;amp;optional point)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-match-string-optional-beg-end&#34;&gt;ov-match&lt;/a&gt; &lt;code&gt;(string &amp;amp;optional beg end)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-regexp-regexp-optional-beg-end&#34;&gt;ov-regexp&lt;/a&gt; &lt;code&gt;(regexp &amp;amp;optional beg end)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-set-ov-or-ovs-or-regexp-rest-properties&#34;&gt;ov-set&lt;/a&gt; &lt;code&gt;(ov-or-ovs-or-regexp &amp;amp;rest properties)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-insert-any&#34;&gt;ov-insert&lt;/a&gt; &lt;code&gt;(any)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-region&#34;&gt;ov-region&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Clear overlay&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-clear-optional-prop-or-beg-val-or-end-beg-end&#34;&gt;ov-clear&lt;/a&gt; &lt;code&gt;(&amp;amp;optional beg end property value)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-reset-ov-or-ovs-variable&#34;&gt;ov-reset&lt;/a&gt; &lt;code&gt;(ov-or-ovs-variable)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Look up overlay parameters, etc&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-p-ov&#34;&gt;ov-p&lt;/a&gt; &lt;code&gt;(ov)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-beg-ov&#34;&gt;ov-beg&lt;/a&gt; &lt;code&gt;(ov)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-end-ov&#34;&gt;ov-end&lt;/a&gt; &lt;code&gt;(ov)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-length-ov&#34;&gt;ov-length&lt;/a&gt; &lt;code&gt;(ov)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-buf-ov&#34;&gt;ov-buf&lt;/a&gt; &lt;code&gt;(ov)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-val-ov-property&#34;&gt;ov-val&lt;/a&gt; &lt;code&gt;(ov property)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-prop-ov&#34;&gt;ov-prop&lt;/a&gt; &lt;code&gt;(ov)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-spec-ov-or-ovs&#34;&gt;ov-spec&lt;/a&gt; &lt;code&gt;(ov-or-ovs)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Get an existing overlay or overlay list&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-at-optional-point&#34;&gt;ov-at&lt;/a&gt; &lt;code&gt;(&amp;amp;optional point)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-in-prop-or-val-val-or-end-beg-end&#34;&gt;ov-in&lt;/a&gt; &lt;code&gt;(prop-or-beg val-or-end beg end)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-all&#34;&gt;ov-all&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-backwards-optional-point&#34;&gt;ov-backwards&lt;/a&gt; &lt;code&gt;(&amp;amp;optional point)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-forwards-optional-point&#34;&gt;ov-forwards&lt;/a&gt; &lt;code&gt;(&amp;amp;optional point)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Overlay manipulation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-move-ov-beg-end-optional-buffer&#34;&gt;ov-move&lt;/a&gt; &lt;code&gt;(ov beg end &amp;amp;optional buffer)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-next-optional-point-or-prop-prop-or-val-val&#34;&gt;ov-next&lt;/a&gt; &lt;code&gt;(&amp;amp;optional point-or-prop prop-or-point val)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-prev-optional-point-or-prop-prop-or-val-val&#34;&gt;ov-prev&lt;/a&gt; &lt;code&gt;(&amp;amp;optional point-or-prop prop-or-point val)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-goto-next-optional-point-or-prop-prop-or-point-val&#34;&gt;ov-goto-next&lt;/a&gt; &lt;code&gt;(&amp;amp;optional point-or-prop prop-or-point val)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-goto-prev-optional-point-or-prop-prop-or-point-val&#34;&gt;ov-goto-prev&lt;/a&gt; &lt;code&gt;(&amp;amp;optional point-or-prop prop-or-point val)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-keymap-ov-or-ovs-or-id-rest-keybinds&#34;&gt;ov-keymap&lt;/a&gt; &lt;code&gt;(ov-or-ovs-or-id &amp;amp;rest keybinds)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-read-only-ov-or-ovs-optional-insert-in-front-insert-behind&#34;&gt;ov-read-only&lt;/a&gt; &lt;code&gt;(ov-or-ovs &amp;amp;optional insert-in-front insert-behind)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-placeholder-ov-or-ovs&#34;&gt;ov-placeholder&lt;/a&gt; &lt;code&gt;(ov-or-ovs)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-smear-regexp-or-list-optional-match-end-base-color-color-range&#34;&gt;ov-smear&lt;/a&gt; &lt;code&gt;(regexp-or-list &amp;amp;optional match-end base-color color-range)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Make overlay / Set properties&lt;/h2&gt; &#xA;&lt;p&gt;&lt;span&gt;🔗&lt;/span&gt; &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/elisp/Overlay-Properties.html&#34;&gt;Overlay Properties&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;ov &lt;code&gt;(beg end &amp;amp;rest properties)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Make an overlay from &lt;code&gt;beg&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;. If &lt;code&gt;properties&lt;/code&gt; are specified, set them for the created overlay.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(ov 10 40 &#39;face &#39;font-lock-warning-face &#39;intangible t)&#xA;(ov 30 80 &#39;(face font-lock-warning-face intangible t))&#xA;(ov (point-min) (point) &#39;face &#39;(:background &#34;#00ff00&#34; :height 1.5))&#xA;(ov (point-min) (point-max) &#39;(face (:background &#34;#00ff00&#34; :height 1.5)))&#xA;;; Just make an overlay without setting properties&#xA;(setq ov1 (ov 5 15))    ; =&amp;gt; #&amp;lt;overlay from 5 to 15 in *scratch*&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can always do &lt;code&gt;M-x ov-clear&lt;/code&gt; to clear all overlays in the current buffer.&lt;/p&gt; &#xA;&lt;h4&gt;ov-make &lt;code&gt;(beg end)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Just make an overlay from &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay&lt;/code&gt; Alias: &lt;code&gt;ov-create&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-make 10 55))           ; =&amp;gt; #&amp;lt;overlay from 10 to 55 in *scratch*&amp;gt;&#xA;(setq ov2 (ov-make (point-min) 25))  ; =&amp;gt; #&amp;lt;overlay from 1 to 25 in *scratch*&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-line &lt;code&gt;(&amp;amp;optional point)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Make an overlay from the beginning of the line to the beginning of the next line, which include &lt;code&gt;point&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-line))  ; =&amp;gt; #&amp;lt;overlay from 734 to 827 in *scratch*&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-match &lt;code&gt;(string &amp;amp;optional beg end)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Make overlays spanning the regions that match &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are numbers, they specify the bounds of the search.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay list&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-match &#34;setq&#34;))&#xA;(setq ov2 (ov-match &#34;setq&#34; 1 200))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-regexp &lt;code&gt;(regexp &amp;amp;optional beg end)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Make overlays spanning the regions that match &lt;code&gt;regexp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are numbers, they specify the bounds of the search.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay list&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-regexp &#34;setq&#34;))&#xA;(setq ov2 (ov-regexp &#34;setq&#34; 100 550))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-set &lt;code&gt;(ov-or-ovs-or-regexp &amp;amp;rest properties)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set overlay properties and values. &lt;code&gt;ov-or-ovs-or-regexp&lt;/code&gt; can be an overlay, overlays or a regexp.&lt;/p&gt; &#xA;&lt;p&gt;If an overlay or list of overlays, &lt;code&gt;properties&lt;/code&gt; are set for these.&lt;/p&gt; &#xA;&lt;p&gt;If a regexp, first overlays are created on the matching regions (see &lt;code&gt;ov-regexp&lt;/code&gt;), then the properties are set.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use a literal string, use &lt;code&gt;(ov-match &#34;string&#34;)&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay&lt;/code&gt; or &lt;code&gt;overlay list&lt;/code&gt;, depending on &lt;code&gt;ov-or-ovs-or-regexp&lt;/code&gt; Alias: &lt;code&gt;ov-put&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-make 335 700))&#xA;(ov-set ov1 &#39;face &#39;font-lock-warning-face &#39;intangible t)&#xA;&#xA;(setq ov2 (ov-match &#34;set&#34;))&#xA;(ov-set ov2 &#39;(face font-lock-function-name-face intangible t))&#xA;&#xA;(ov-set (ov-regexp &#34;^.ov-&#34;) &#39;display &#34;λλ-&#34; &#39;before-string &#34;(&#34; &#39;line-prefix &#34;&amp;lt;λ&amp;gt;&#34;)&#xA;(ov-set &#34;^;;.+$&#34; &#39;face &#39;warning)&#xA;&#xA;(ov-set (ov-line) &#39;before-string (propertize &#34;&amp;gt;&amp;gt;&amp;gt; &#34; &#39;face &#39;font-lock-warning-face))&#xA;(ov-set (ov-line) `(before-string ,(propertize &#34;&amp;gt;&amp;gt;&amp;gt; &#34; &#39;face &#39;font-lock-warning-face)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-insert &lt;code&gt;any&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Insert &lt;code&gt;any&lt;/code&gt; (string, number, list, etc) covered with an empty overlay.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(ov-set (ov-insert &#34;Overlay1&#34;) &#39;face &#39;menu &#39;intangible t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-region&lt;/h4&gt; &#xA;&lt;p&gt;Make an overlay from a region if region is active.&lt;/p&gt; &#xA;&lt;p&gt;When you make a region, do &lt;code&gt;M-: (ov-set (ov-region) &#39;face &#39;(:box t))&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(ov-set (ov-region) &#39;face &#39;(:box t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Clear overlay&lt;/h2&gt; &#xA;&lt;h4&gt;ov-clear &lt;code&gt;(&amp;amp;optional prop-or-beg val-or-end beg end)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Clear overlays satisfying a condition.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;prop-or-beg&lt;/code&gt; is a symbol, clear overlays with this property set to non-nil.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;val-or-end&lt;/code&gt; is non-nil, the specified property&#39;s value should &lt;code&gt;equal&lt;/code&gt; to this value.&lt;/p&gt; &#xA;&lt;p&gt;If both of these are numbers, clear the overlays between these points.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are numbers, clear the overlays with specified property and value between these points.&lt;/p&gt; &#xA;&lt;p&gt;With no arguments, clear all overlays in the buffer.&lt;/p&gt; &#xA;&lt;p&gt;Arguments pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(ov-clear PROPERTY VALUE BEG END)&#xA;(ov-clear PROPERTY VALUE)&#xA;(ov-clear BEG END)&#xA;(ov-clear PROPERTY)&#xA;(ov-clear)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(ov-clear 100 550 &#39;my-fancy-comment t)&#xA;(ov-clear &#39;face &#39;font-lock-function-name-face)&#xA;(ov-clear 200 1000)&#xA;(ov-clear &#39;face)&#xA;(ov-clear) ;; clear overlays in the whole buffer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-reset &lt;code&gt;(ov-or-ovs-variable)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Clear overlays in &lt;code&gt;ov-or-ovs-variable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ov-or-ovs-variable&lt;/code&gt; should be a symbol whose value is an overlay or a list of overlays.&lt;/p&gt; &#xA;&lt;p&gt;Finally, the variable is set to nil.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-line))&#xA;(ov-set ov1  &#39;invisible t)&#xA;(ov-reset ov1)&#xA;&#xA;(setq ov2 (ov-match &#34;ov-&#34;))&#xA;(ov-set ov2 &#39;(face (:underline t)))&#xA;(ov-reset ov2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Look up overlay parameters, etc&lt;/h2&gt; &#xA;&lt;h4&gt;ov-p &lt;code&gt;(ov)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Check whether &lt;code&gt;ov&lt;/code&gt; is overlay or not.&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;code&gt;ov?&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 99)&#xA;(setq ov2 (ov-make 10 20))&#xA;(setq ov3 ov2)&#xA;(ov-p ov1) ; =&amp;gt; nil&#xA;(ov-p ov2) ; =&amp;gt; t&#xA;(ov-p ov3) ; =&amp;gt; t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-beg &lt;code&gt;(ov)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get the beginning of an overlay.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;point&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-make 200 700))&#xA;(ov-beg ov1) ; =&amp;gt; 200&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-end &lt;code&gt;(ov)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get the end of an overlay.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;point&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-make 200 700))&#xA;(ov-end ov1) ; =&amp;gt; 700&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-length &lt;code&gt;(ov)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the length of the region spanned by &lt;code&gt;overlay&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;number&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-make 200 700))&#xA;(ov-length ov1) ; =&amp;gt; 500&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-buf &lt;code&gt;(ov)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get the buffer object of an overlay.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;buffer object&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-make 200 700))&#xA;(ov-buf ov1)               ; =&amp;gt; #&amp;lt;buffer *scratch*&amp;gt;&#xA;(buffer-name (ov-buf ov1)) ; =&amp;gt; &#34;*scratch*&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-val &lt;code&gt;(ov property)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get the value of &lt;code&gt;property&lt;/code&gt; from an overlay.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;value&lt;/code&gt; of property&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-line))&#xA;(ov-set ov1 &#39;aaa &#34;abc&#34; &#39;bbb 22 &#39;ccc 45)&#xA;(ov-val ov1 &#39;bbb)           ; =&amp;gt; 22&#xA;(ov-val ov1 &#39;aaa)           ; =&amp;gt; &#34;abc&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-prop &lt;code&gt;(ov)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get the properties from an overlay.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;properties list&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-make (point-min) (point-max)))&#xA;(ov-set ov1 &#39;(face (:overline t) mouse-face (:underline t)))&#xA;(ov-prop ov1) ; =&amp;gt; (mouse-face (:underline t) face (:overline t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-spec &lt;code&gt;(ov-or-ovs)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Make a specification list from an overlay or list of overlays.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;list ((beginning end buffer (properties)) (beginning end buffer (properties))...)&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-match &#34;ov-spec&#34;))&#xA;(ov-set ov1 &#39;evaporate t)&#xA;(ov-spec ov1)&#xA;;; =&amp;gt; ((5802 5809 README.md (evaporate t)) (5782 5789 README.md (evaporate t)) ...)&#xA;&#xA;(setq ov2 (ov-line))&#xA;(ov-spec ov2) ; =&amp;gt; ((5879 5921 README.md nil))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Get an existing overlay or overlay list&lt;/h2&gt; &#xA;&lt;h4&gt;ov-at &lt;code&gt;(&amp;amp;optional point)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get an overlay at &lt;code&gt;point&lt;/code&gt;. &lt;code&gt;point&lt;/code&gt; defaults to the current &lt;code&gt;point&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(save-excursion&#xA;  (ov-set (ov-make 20 50) &#39;face &#39;(:box t))&#xA;  (goto-char 30)&#xA;  (ov-at))        ; =&amp;gt; #&amp;lt;overlay from 20 to 50 in *scratch*&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-in &lt;code&gt;(prop-or-val val-or-end beg end)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get overlays satisfying a condition.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;prop-or-beg&lt;/code&gt; is a symbol, get overlays with this property set to non-nil.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;val-or-end&lt;/code&gt; is non-nil, the specified property&#39;s value should &lt;code&gt;equal&lt;/code&gt; to this value.&lt;/p&gt; &#xA;&lt;p&gt;If both of these are numbers, get the overlays between these points.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are numbers, get the overlays with specified property and value between these points.&lt;/p&gt; &#xA;&lt;p&gt;With no arguments, get all overlays in the buffer.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay list&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Arguments pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ov-in PROPERTY VALUE BEG END)&#xA;(ov-in PROPERTY VALUE)&#xA;(ov-in PROPERTY)&#xA;(ov-in BEG END)&#xA;(ov-in)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;;; Get all overlays&#xA;(setq ov1 (ov-in))&#xA;;; Get overlays between 10 and 500&#xA;(setq ov2 (ov-in 10 500))&#xA;;; Get the overlays which has a specific property and its value&#xA;(setq ov3 (ov-in &#39;face &#39;warning))&#xA;;; Get the overlays which has a specific property&#xA;(setq ov4 (ov-in &#39;face))&#xA;;; Get the overlays between 10 and 500, which has a specific property and its value&#xA;(setq ov5 (ov-in &#39;face &#39;worning 10 500))&#xA;;; If &#39;any specified to val-or-end, it matches any value&#xA;(setq ov6 (ov-in &#39;face &#39;any 10 500))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-all&lt;/h4&gt; &#xA;&lt;p&gt;Get all the overlays in the entire buffer.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay list&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-all))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-backwards &lt;code&gt;(&amp;amp;optional point)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get all the overlays from the beginning of the buffer to &lt;code&gt;point&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay list&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-backwards))&#xA;(setq ov2 (ov-backwards 1200))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-forwards &lt;code&gt;(&amp;amp;optional point)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get all the overlays from &lt;code&gt;point&lt;/code&gt; to the end of the buffer.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay list&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-forwards))&#xA;(setq ov2 (ov-forwards 1000))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Overlay manipulation&lt;/h2&gt; &#xA;&lt;h4&gt;ov-move &lt;code&gt;(ov beg end &amp;amp;optional buffer)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Move an existing overlay position to another position.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-line))&#xA;(ov-set ov1 &#39;face &#39;underline)&#xA;(ov-move ov1 (point-at-bol) (point-at-eol))&#xA;;; Move overlay ov1 to another buffer&#xA;(progn&#xA;  (with-current-buffer (get-buffer-create &#34;test&#34;)&#xA;    (insert &#34;aaaaaaaaaaaaaaa&#34;))&#xA;  (ov-move ov1 (point-min) (point-max) (get-buffer &#34;test&#34;))&#xA;  (pop-to-buffer &#34;test&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;!-- #### ov-timeout `(time func func-after)` --&gt; &#xA;&lt;!-- Execute `func-after` after `time` seconds passed since `func` done. --&gt; &#xA;&lt;!-- ```cl --&gt; &#xA;&lt;!-- (ov-timeout 0.5 --&gt; &#xA;&lt;!--   &#39;(ov-set &#34;ov&#34; &#39;(face (:background &#34;#ff0000&#34;) aaa t)) --&gt; &#xA;&lt;!--   &#39;(ov-clear &#39;aaa t)) --&gt; &#xA;&lt;!-- (defun ov-fn1 () --&gt; &#xA;&lt;!--   (ov-set (ov-match &#34;ov&#34;) &#39;(face (:background &#34;#ff9900&#34;) bbb t))) --&gt; &#xA;&lt;!-- (defun ov-fn2 () --&gt; &#xA;&lt;!--   (ov-clear &#39;bbb t)) --&gt; &#xA;&lt;!-- (ov-timeout 1.2 ov-fn1 ov-fn2) --&gt; &#xA;&lt;!-- ``` --&gt; &#xA;&lt;h4&gt;ov-next &lt;code&gt;(&amp;amp;optional point-or-prop prop-or-val val)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get the next overlay satisfying a condition.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;point-or-prop&lt;/code&gt; is a symbol, get the next overlay with this property being non-nil.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;prop-or-val&lt;/code&gt; is non-nil, the property should have this value.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;point-or-prop&lt;/code&gt; is a number, get the next overlay after this point.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;prop-or-val&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; are also specified, get the next overlay after &lt;code&gt;point-or-prop&lt;/code&gt; having property &lt;code&gt;prop-or-val&lt;/code&gt; set to &lt;code&gt;val&lt;/code&gt; (with &lt;code&gt;val&lt;/code&gt; unspecified, only the presence of property is tested).&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Arguments pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ov-next POINT PROPERTY VALUE)&#xA;(ov-next PROPERTY VALUE)&#xA;(ov-next PROPERTY)&#xA;(ov-next)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(ov-set &#34;^..&#34; &#39;(face (:background &#34;#ff9900&#34;) aaa t))&#xA;(ov-set &#34;..$&#34; &#39;(face (:background &#34;#7700ff&#34;) bbb t))&#xA;(ov-next)         ; =&amp;gt; #&amp;lt;overlay from 436 to 438 in *scratch*&amp;gt;&#xA;(goto-char (ov-beg (ov-next nil &#39;aaa)))&#xA;(goto-char (ov-end (ov-next nil &#39;bbb t)))&#xA;&#xA;(ov-next &#39;aaa)&#xA;(ov-next &#39;aaa t)&#xA;(ov-next 300 &#39;aaa)&#xA;(ov-next (point) &#39;aaa t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-prev &lt;code&gt;(&amp;amp;optional point-or-prop prop-or-val val)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Get the previous overlay satisfying a condition.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;point-or-prop&lt;/code&gt; is a symbol, get the previous overlay with this property being non-nil.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;prop-or-val&lt;/code&gt; is non-nil, the property should have this value.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;point-or-prop&lt;/code&gt; is a number, get the previous overlay after this point.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;prop-or-val&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; are also specified, get the previous overlay after &lt;code&gt;point-or-prop&lt;/code&gt; having property &lt;code&gt;prop-or-val&lt;/code&gt; set to &lt;code&gt;val&lt;/code&gt; (with &lt;code&gt;val&lt;/code&gt; unspecified, only the presence of property is tested).&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Arguments pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ov-prev POINT PROPERTY VALUE)&#xA;(ov-prev PROPERTY VALUE)&#xA;(ov-prev PROPERTY)&#xA;(ov-prev)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(ov-set (ov-match &#34;o&#34;) &#39;(face (:box t) my-char o))&#xA;(ov-set (ov-match &#34;t&#34;) &#39;(face (:box t) my-char t))&#xA;(ov-prev)         ; =&amp;gt; #&amp;lt;overlay from 482 to 483 in *scratch*&amp;gt;&#xA;(goto-char (ov-beg (ov-prev (point) &#39;face)))&#xA;(goto-char (ov-end (ov-prev nil &#39;my-char &#39;o)))&#xA;&#xA;(ov-prev &#39;my-char)&#xA;(ov-prev &#39;my-char &#39;o)&#xA;(ov-prev 300 &#39;my-char)&#xA;(ov-prev (point) &#39;my-char &#39;o)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-goto-next &lt;code&gt;(&amp;amp;optional point-or-prop prop-or-point val)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Move cursor to the end of the next overlay. The arguments are the same as for &lt;code&gt;ov-next&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(ov-goto-next)&#xA;(ov-goto-next &#39;face)&#xA;(ov-goto-next &#39;face &#39;warning)&#xA;(ov-goto-next 300 &#39;face &#39;warning)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-goto-prev &lt;code&gt;(&amp;amp;optional point-or-prop prop-or-point val)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Move cursor to the beginning of previous overlay. The arguments are the same as for &lt;code&gt;ov-prev&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(ov-goto-prev)&#xA;(ov-goto-prev &#39;face)&#xA;(ov-goto-prev &#39;face &#39;warning)&#xA;(ov-goto-prev 300 &#39;face &#39;warning)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-keymap &lt;code&gt;(ov-or-ovs-or-id &amp;amp;rest keybinds)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set &lt;code&gt;keybinds&lt;/code&gt; to an overlay or a list of overlays.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;ov-or-ovs-or-id&lt;/code&gt; is a symbol, the &lt;code&gt;keybinds&lt;/code&gt; will be enabled for the entire buffer and the property represented by the symbol to &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The overlay is expanded if new inputs are inserted at the beginning or end of the buffer.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay list&lt;/code&gt; or &lt;code&gt;entire buffer overlay&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-match &#34;ov-&#34;))&#xA;(ov-set ov1 &#39;face &#39;warning &#39;my-ov1 t)&#xA;(ov-keymap ov1&#xA;  &#34;M-n&#34; &#39;(if (ov-goto-next &#39;my-ov1) (backward-char 1))&#xA;  &#34;M-p&#34; &#39;(ov-goto-prev &#39;my-ov1))&#xA;&#xA;(setq ov2 (ov-line))&#xA;(ov-set ov2 &#39;face &#39;(:box t))&#xA;(ov-keymap ov2&#xA;  &#34;RET&#34; &#39;(let ((o (ov-at)))&#xA;           (if (memq :box (ov-val o &#39;face))&#xA;               (ov-set o &#39;face &#39;(:underline t))&#xA;             (ov-set o &#39;face &#39;(:box t)))))&#xA;&#xA;(ov-keymap (ov-insert &#34;{Press [C-t] here}&#34;) &#34;C-t&#34; &#39;describe-text-properties)&#xA;&#xA;;; Enable keybind to the whole buffer&#xA;(ov-keymap &#39;my-ov-test1&#xA;  &#34;M-n&#34; &#39;move-end-of-line&#xA;  &#34;M-p&#34; &#39;move-beginning-of-line)&#xA;(ov-clear &#39;my-ov-test1)&#xA;&#xA;;; Multiple keybinds to a command&#xA;(ov-keymap (ov-insert &#34;HERE&#34;)&#xA; &#39;(&#34;a&#34; &#34;b&#34;) &#39;(message &#34;[a] or [b] is pressed&#34;)&#xA; `(,(kbd &#34;&amp;lt;mouse-1&amp;gt;&#34;) ,(kbd &#34;M-c&#34;) &#34;c&#34;) &#39;(message &#34;Clicked or [M-c] or c is pressed&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-read-only &lt;code&gt;(ov-or-ovs &amp;amp;optional insert-in-front insert-behind)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Implement a read-only like feature for overlay or list of overlays.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;insert-in-front&lt;/code&gt; is non-nil, inserting in front of each overlay is prevented.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;insert-behind&lt;/code&gt; is non-nil, inserting behind of each overlay is prevented.&lt;/p&gt; &#xA;&lt;p&gt;Note that it allows modifications from out of range of a read-only overlay.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay list&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(setq ov1 (ov-match &#34;setq&#34;))&#xA;(ov-read-only ov1)&#xA;&#xA;(ov-read-only (ov-insert &#34;ReadOnly&#34;))&#xA;&#xA;;; Prevent inserting in front and behind of an overlay&#xA;(setq ov2 (ov-regexp &#34;^;;&#34;))&#xA;(ov-read-only ov2 t t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-placeholder&lt;/h4&gt; &#xA;&lt;p&gt;Set a placeholder feature for overlay or list of overlays.&lt;/p&gt; &#xA;&lt;p&gt;Each overlay deletes its string and overlay, when it is modified.&lt;/p&gt; &#xA;&lt;p&gt;Return: &lt;code&gt;overlay list&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(ov-placeholder (ov-match &#34;;; Try to insert or delete chars below&#34;))&#xA;;; Try to insert or delete chars below&#xA;&#xA;(ov-placeholder (ov-insert &#34;[Placeholder]&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ov-smear &lt;code&gt;(regexp-or-list &amp;amp;optional match-end base-color color-range)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Set background color overlays to the current buffer. Each background color is randomly determined based on BASE-COLOR or the default background color.&lt;/p&gt; &#xA;&lt;p&gt;If REGEXP-OR-LIST is regexp Set overlays between matches of a regexp.&lt;/p&gt; &#xA;&lt;p&gt;If REGEXP-OR-LIST is list Set overlays between point pairs in a list.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;;; List&#xA;(ov-smear &#39;((1 . 200) (200 . 450) (600 . 750)))&#xA;&#xA;;; Regexp&#xA;(ov-smear &#34;^;;&#34; nil &#34;#ff0000&#34; 60)&#xA;(ov-smear &#34;\n\n&#34; t) ;; 2 returns and use match-end&#xA;(ov-smear &#34;^#&#34;)     ;; for markdown-mode&#xA;(ov-smear &#34;^\\*&#34;)   ;; for org-mode&#xA;;; for objc-mode&#xA;(ov-smear &#34;^@\\(interface\\|implementation\\|end\\)\\|^#pragma&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ShingoFukuyama/images/master/ov-smear.png&#34; alt=&#34;ov-smear&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Useful examples&lt;/h2&gt; &#xA;&lt;h4&gt;Sticky overlay&lt;/h4&gt; &#xA;&lt;p&gt;Sticky overlays will be inherited by inserting at both sides of each one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(let ((ov-sticky-front t)&#xA;      (ov-sticky-rear t))&#xA;  (ov-set &#34;ov-[^\s]+&#34; &#39;face &#39;warning))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Evaporative overlay&lt;/h4&gt; &#xA;&lt;p&gt;When you modify one of the overlaid text, all their overlays will be evaporated. &lt;code&gt;modification-hooks&lt;/code&gt; requires function to specify 5 arguments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(defun my-ov-evaporate-ov1 (_ov _after _beg _end &amp;amp;optional _length)&#xA;  (let ((inhibit-modification-hooks t))&#xA;    (if _after (ov-clear &#39;ov1))))&#xA;(ov-set &#34;ov-&#34; &#39;face &#39;warning&#xA;              &#39;ov1 t&#xA;              &#39;modification-hooks &#39;(my-ov-evaporate-ov1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Add new features or improve functions is welcome!&lt;/p&gt; &#xA;&lt;h4&gt;Add new functions&lt;/h4&gt; &#xA;&lt;p&gt;It would be helpful if you follow:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;ov-&#34; prefixed function name&lt;/li&gt; &#xA; &lt;li&gt;Simpler function name is preferable. (e.g &#34;beg&#34; &amp;gt; &#34;beginning&#34;, &#34;prop&#34; &amp;gt; &#34;property&#34;)&lt;/li&gt; &#xA; &lt;li&gt;Accept single overlay and multiple overlays in one argument, such as &lt;code&gt;ov-or-ovs&lt;/code&gt; in existing functions&lt;/li&gt; &#xA; &lt;li&gt;Write examples and documents in README.md&lt;/li&gt; &#xA; &lt;li&gt;Write tests in /test/ov-test.el&lt;/li&gt; &#xA; &lt;li&gt;Use spaces as the indent instead of tabs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributor&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Fuco1&#34;&gt;Matus Goljer&lt;/a&gt; contributed to overhaul documents, and a lot of suggestions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Change&lt;/h2&gt; &#xA;&lt;h6&gt;2014/07/02&lt;/h6&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add &lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/ov/master/#ov-smear&#34;&gt;ov-smear&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h6&gt;2014/06/05&lt;/h6&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Change &lt;code&gt;ov-keymap&lt;/code&gt;&#39;s keymapping property from &lt;code&gt;local-map&lt;/code&gt; to &lt;code&gt;keymap&lt;/code&gt;. By doing so, override the buffer local keymap instead of totaly replacing it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h6&gt;2014/06/05&lt;/h6&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Change return value type of &lt;code&gt;ov-set&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;ov-length&lt;/code&gt; by Matus Goljer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;span&gt;🔗&lt;/span&gt; &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/elisp/Overlay-Properties.html&#34;&gt;Overlay Properties&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;span&gt;🔗&lt;/span&gt; &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/elisp/Face-Attributes.html&#34;&gt;Face Attributes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;span&gt;🔗&lt;/span&gt; &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/elisp/Managing-Overlays.html&#34;&gt;Managing Overlays&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;span&gt;🔗&lt;/span&gt; &lt;a href=&#34;http://lists.gnu.org/archive/html/emacs-devel/2002-08/msg00428.html&#34;&gt;comint read-only prompt&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Silex/docker.el</title>
    <updated>2022-07-21T01:43:11Z</updated>
    <id>tag:github.com,2022-07-21:/Silex/docker.el</id>
    <link href="https://github.com/Silex/docker.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Manage docker from Emacs.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;http://melpa.org/#/docker&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/docker-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/docker&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/docker-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/Silex/docker.el/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI status&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;docker.el&lt;/h1&gt; &#xA;&lt;p&gt;Emacs integration for &lt;a href=&#34;https://www.docker.com&#34;&gt;Docker&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;p&gt;Supports docker containers, images, volumes, networks and docker-compose.&lt;/p&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;h3&gt;List images&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Silex/docker.el/master/screenshots/image-ls.png&#34; alt=&#34;Images list&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Image run&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Silex/docker.el/master/screenshots/image-run.png&#34; alt=&#34;Image run&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;The recommended way to install docker.el is through &lt;a href=&#34;https://github.com/milkypostman/melpa&#34;&gt;MELPA&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here is a example &lt;a href=&#34;https://github.com/jwiegley/use-package&#34;&gt;use-package&lt;/a&gt; configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(use-package docker&#xA;  :ensure t&#xA;  :bind (&#34;C-c d&#34; . docker))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;kbd&gt;M-x docker&lt;/kbd&gt;, select a resource then then mark or unmark items using the following keybindings (for more marking possibilities, check out &lt;a href=&#34;https://github.com/politza/tablist&#34;&gt;https://github.com/politza/tablist&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Binding&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;?&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;List actions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;l&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Configure listing&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;m&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Mark item&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;u&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Unmark item&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;t&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Toggle marks&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;U&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Unmark all&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;s&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Sort&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;* r&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Mark items by regexp&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;&amp;lt;&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Shrink column&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;&amp;gt;&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enlarge column&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c C-e&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Export to csv&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Then select an action and follow the instructions.&lt;/p&gt; &#xA;&lt;h2&gt;Supported commands&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;docker container: attach, cp, diff, inspect, kill, logs, pause, rename, restart, rm, start, stop, unpause&lt;/li&gt; &#xA; &lt;li&gt;docker image: inspect, pull, push, rm, run, tag&lt;/li&gt; &#xA; &lt;li&gt;docker network: rm&lt;/li&gt; &#xA; &lt;li&gt;docker volume: rm&lt;/li&gt; &#xA; &lt;li&gt;docker-compose: build, config, create, down, exec, logs, pull, push, remove, restart, run, start, stop, up&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can also enter &lt;code&gt;dired&lt;/code&gt; or open a file inside a container or volume.&lt;/p&gt; &#xA;&lt;h2&gt;Customizations&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://github.com/magit/transient&#34;&gt;transient&lt;/a&gt;, all the transients arguments can be set temporarily or permanently. See &lt;a href=&#34;https://magit.vc/manual/transient/Saving-Values.html#Saving-Values&#34;&gt;https://magit.vc/manual/transient/Saving-Values.html#Saving-Values&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;There are also hidden items (e.g on &lt;code&gt;M-x docker&lt;/code&gt; where you could specify the host or TLS settings), see &lt;a href=&#34;https://magit.vc/manual/transient/Enabling-and-Disabling-Suffixes.html&#34;&gt;https://magit.vc/manual/transient/Enabling-and-Disabling-Suffixes.html&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;Here is a list of other customizations you can set:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Variable&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-command&lt;/td&gt; &#xA;   &lt;td&gt;The docker binary to use&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;docker&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-compose-command&lt;/td&gt; &#xA;   &lt;td&gt;The docker-compose binary to use&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;docker-compose&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-container-columns&lt;/td&gt; &#xA;   &lt;td&gt;Columns definition for containers&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;/bin/sh&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-container-default-sort-key&lt;/td&gt; &#xA;   &lt;td&gt;Sort key for containers&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;(&#34;Image&#34;)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-container-shell-file-name&lt;/td&gt; &#xA;   &lt;td&gt;Shell to use when entering containers&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;/bin/sh&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-image-columns&lt;/td&gt; &#xA;   &lt;td&gt;Columns definition for images&lt;/td&gt; &#xA;   &lt;td&gt;Too complex to show&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-image-default-sort-key&lt;/td&gt; &#xA;   &lt;td&gt;Sort key for images&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;(&#34;Repository&#34;)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-image-run-default-args&lt;/td&gt; &#xA;   &lt;td&gt;Base arguments to use for docker run&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;(&#34;-i&#34; &#34;-t&#34; &#34;--rm&#34;)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-network-columns&lt;/td&gt; &#xA;   &lt;td&gt;Columns definition for networks&lt;/td&gt; &#xA;   &lt;td&gt;Too complex to show&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-network-default-sort-key&lt;/td&gt; &#xA;   &lt;td&gt;Sort key for networks&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;(&#34;Name&#34;)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-pop-to-buffer-action&lt;/td&gt; &#xA;   &lt;td&gt;Action for &lt;code&gt;docker-utils-pop-to-buffer&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-run-as-root&lt;/td&gt; &#xA;   &lt;td&gt;Runs docker as root when enabled&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-run-async-with-buffer-function&lt;/td&gt; &#xA;   &lt;td&gt;Function used to run programs with buffers&lt;/td&gt; &#xA;   &lt;td&gt;Too complex to show&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-show-messages&lt;/td&gt; &#xA;   &lt;td&gt;If non-nil message docker commands&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;t&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-show-status&lt;/td&gt; &#xA;   &lt;td&gt;If non-nil compute status&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;t&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-volume-columns&lt;/td&gt; &#xA;   &lt;td&gt;Columns definition for volumes&lt;/td&gt; &#xA;   &lt;td&gt;Too complex to show&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker-volume-default-sort-key&lt;/td&gt; &#xA;   &lt;td&gt;Sort key for volumes&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;(&#34;Driver&#34;)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Changing the default arguments for &lt;code&gt;docker run&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can match on the repository name for an image to customize the initial infix arguments via &lt;code&gt;docker-image-run-custom-args&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(add-to-list&#xA;   &#39;docker-image-run-custom-args&#xA;   `(&#34;^postgres&#34; (&#34;-e POSTGRES_PASSWORD=postgres&#34; . ,docker-image-run-default-args)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So when &lt;code&gt;docker run&lt;/code&gt; is called on an image whose repository name matches the regular expression &lt;code&gt;^postgres&lt;/code&gt;, the option &lt;code&gt;&#34;-e POSTGRES_PASSWORD=postgres&#34;&lt;/code&gt; will appear as set along with the defaults specified by &lt;code&gt;docker-image-run-default-args&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Vterm support&lt;/h2&gt; &#xA;&lt;p&gt;If &lt;a href=&#34;https://github.com/akermu/emacs-libvterm&#34;&gt;vterm&lt;/a&gt; is installed, it&#39;ll be used for any commands that needs a running buffer (for example &lt;code&gt;docker run&lt;/code&gt;, &lt;code&gt;docker logs&lt;/code&gt;, etc).&lt;/p&gt; &#xA;&lt;h2&gt;Contributions&lt;/h2&gt; &#xA;&lt;p&gt;They are very welcome, either as suggestions or as pull requests by opening tickets on the &lt;a href=&#34;https://github.com/Silex/docker.el/issues&#34;&gt;issue tracker&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>