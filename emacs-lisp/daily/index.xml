<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-25T01:38:52Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>minad/marginalia</title>
    <updated>2022-06-25T01:38:52Z</updated>
    <id>tag:github.com,2022-06-25:/minad/marginalia</id>
    <link href="https://github.com/minad/marginalia" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ“œ marginalia.el - Marginalia in the minibuffer&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: marginalia.el - Marginalia in the minibuffer #+author: Omar AntolÃ­n Camarena, Daniel Mendler #+language: en #+export_file_name: marginalia.texi #+texinfo_dir_category: Emacs misc features #+texinfo_dir_title: Marginalia: (marginalia). #+texinfo_dir_desc: Marginalia in the minibuffer&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img alt=&#34;GNU Emacs&#34; src=&#34;https://github.com/minad/corfu/raw/screenshots/emacs.svg?raw=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/packages/marginalia.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/marginalia.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/devel/marginalia.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/marginalia.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/marginalia&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/marginalia-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://stable.melpa.org/#/marginalia&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/marginalia-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Introduction&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+html: &lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/4/4f/Marginalia_%285095211566%29.jpg&#34; align=&#34;right&#34; width=&#34;30%&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This package provides =marginalia-mode= which adds marginalia to the minibuffer completions. [[https://en.wikipedia.org/wiki/Marginalia][Marginalia]] are marks or annotations placed at the margin of the page of a book or in this case helpful colorful annotations placed at the margin of the minibuffer for your completion candidates. Marginalia can only add annotations to be displayed with the completion candidates. It cannot modify the appearance of the candidates themselves, which are shown as supplied by the original commands.&lt;/p&gt; &#xA;&lt;p&gt;The annotations are added based on the completion category. For example =find-file= reports the =file= category and =M-x= reports the =command= category. You can cycle between more or less detailed annotators or even disable the annotator with command =marginalia-cycle=.&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;img src=&#34;https://github.com/minad/marginalia/raw/screenshots/marginalia-mode.png?raw=true&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is recommended to use Marginalia together with either the [[https://github.com/minad/vertico][Vertico]], [[https://github.com/protesilaos/mct][Mct]], [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Icomplete.html][Icomplete]] or the [[https://github.com/raxod502/selectrum][Selectrum]] completion system. Furthermore Marginalia can be combined with [[https://github.com/oantolin/embark][Embark]] for action support and [[https://github.com/minad/consult][Consult]], which provides many useful commands.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp ;; Enable richer annotations using the Marginalia package (use-package marginalia ;; Either bind &lt;code&gt;marginalia-cycle&lt;/code&gt; globally or only in the minibuffer :bind ((&#34;M-A&#34; . marginalia-cycle) :map minibuffer-local-map (&#34;M-A&#34; . marginalia-cycle))&lt;/p&gt; &#xA;&lt;p&gt;;; The :init configuration is always executed (Not lazy!) :init&lt;/p&gt; &#xA;&lt;p&gt;;; Must be in the :init section of use-package such that the mode gets ;; enabled right away. Note that this forces loading the package. (marginalia-mode)) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Information shown by the annotators&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In general, to learn more about what different annotations mean, a good starting point is to look at &lt;del&gt;marginalia-annotator-registry&lt;/del&gt;, and follow up to the annotation function of the category you are interested in.&lt;/p&gt; &#xA;&lt;p&gt;For example the annotations for elisp symbols include their symbol class - v for variable, f for function, c for command, etc. For more information on what the different classifications mean, see the docstring of &lt;del&gt;marginalia--symbol-class&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Adding custom annotators or classifiers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;IMPORTANT NOTICE FOR PACKAGE AUTHORS&lt;/em&gt;: The intention of the Marginalia package is to give the user means to overwrite completion categories and to add custom annotators for existing commands in their user configuration. Marginalia is a user facing package and is not intended to be used as a library. Therefore Marginalia does not expose library functions as part of its public API. If you add your own completion commands to your package we recommend to specify an =annotation-function= or an =affixation-function=, avoiding the Marginalia dependency this way. The =annotation-function= is documented in the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion.html][Elisp manual]]. There is an exception to our recommendation: If you want to implement annotations for an existing package =hypothetical.el=, which does not have annotations and where annotations cannot be added, then the creation of a =marginalia-hypothetical.el= package is a good idea, since Marginalia provides the facilities to enhance existing commands from the outside. If you have questions feel free to ask on the Marginalia issue tracker!&lt;/p&gt; &#xA;&lt;p&gt;Commands that support minibuffer completion use a completion table of all the available candidates. Candidates are associated with a &lt;em&gt;category&lt;/em&gt; such as =command=, =file=, =face=, or =variable= depending on what the candidates are. Based on the category of the candidates, Marginalia selects an &lt;em&gt;annotator&lt;/em&gt; to generate annotations for display for each candidate.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, not all commands (including Emacs&#39; builtin ones) specify the category of their candidates. To compensate for this shortcoming, Marginalia hooks into the emacs completion framework and runs the &lt;em&gt;classifiers&lt;/em&gt; listed in the variable =marginalia-classifiers=, which use the command&#39;s prompt or other properties of the candidates to specify the completion category.&lt;/p&gt; &#xA;&lt;p&gt;For example, the =marginalia-classify-by-prompt= classifier checks the minibuffer prompt against regexps listed in the =marginalia-prompt-categories= alist to determine a category. The following is already included but would be a way to assign the category =face= to all candidates from commands with prompts that include the word &#34;face&#34;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (add-to-list &#39;marginalia-prompt-categories &#39;(&#34;\&amp;lt;face\&amp;gt;&#34; . face)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =marginalia-classify-by-command-name= classifier uses the alist =marginalia-command-categories= to specify the completion category based on the command name. This is particularily useful if the prompt classifier yields a false positive.&lt;/p&gt; &#xA;&lt;p&gt;Completion categories are also important for [[https://github.com/oantolin/embark][Embark]], which associates actions based on the completion category and benefits from Marginalia&#39;s classifiers.&lt;/p&gt; &#xA;&lt;p&gt;Once the category of the candidates is known, Marginalia looks in the =marginalia-annotator-registry= to find the associated annotator to use. An annotator is a function that takes a completion candidate string as an argument and returns an annotation string to be displayed after the candidate in the minibuffer. More than one annotator can be assigned to each each category, displaying more, less or different information. Use the =marginalia-cycle= command to cycle between the annotations of different annotators defined for the current category.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of a basic face annotator:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun my-face-annotator (cand) (when-let (sym (intern-soft cand)) (concat (propertize &#34; &#34; &#39;display &#39;(space :align-to center)) (propertize &#34;The quick brown fox jumps over the lazy dog&#34; &#39;face sym)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Look at Marginalia&#39;s various annotators for examples of formating annotations. In particular, the helper function =marginalia--fields= can be used to format information into columns.&lt;/p&gt; &#xA;&lt;p&gt;After defining a new annotator, associate it with a category in the annotator registry as follows:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (add-to-list &#39;marginalia-annotator-registry &#39;(face my-face-annotator marginalia-annotate-face builtin none)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This makes the =my-face-annotator= the first of four annotators for the face category. The others are the annotator provided by Marginalia (=marginalia-annotate-face=), the =builtin= annotator as defined by Emacs and the =none= annotator, which disables the annotations. With this setting, after invoking =M-x describe-face RET= you can cycle between all of these annotators using =marginalia-cycle=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Disabling annotators, builtin or lightweight annotators&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Marginalia activates rich annotators by default. Depending on your preference you may want to use the builtin annotators or even no annotators by default and only activate the annotators on demand by invoking &lt;del&gt;marginalia-cycle&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to use the builtin annotators by default, you can use the following command. Replace =builtin= by =none= to disable annotators by default.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun marginalia-use-builtin () (interactive) (mapc (lambda (x) (setcdr x (cons &#39;builtin (remq &#39;builtin (cdr x))))) marginalia-annotator-registry)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If a completion category supports two annotators, you can toggle between those using this command.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun marginalia-toggle () (interactive) (mapc (lambda (x) (setcdr x (append (reverse (remq &#39;none (remq &#39;builtin (cdr x)))) &#39;(builtin none)))) marginalia-annotator-registry)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;After cycling the annotators you may want to automatically save the configuration. This can be achieved using an advice which calls &lt;del&gt;customize-save-variable&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (advice-add #&#39;marginalia-cycle :after (lambda () (let ((inhibit-message t)) (customize-save-variable &#39;marginalia-annotator-registry marginalia-annotator-registry)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In order to disable an annotator permanently, the &lt;del&gt;marginalia-annotator-registry&lt;/del&gt; can be modified. For example if you prefer to never see file annotations, you can delete all file annotators from the registry.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq marginalia-annotator-registry (assq-delete-all &#39;file marginalia-annotator-registry)) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since this package is part of [[http://elpa.gnu.org/packages/marginalia.html][GNU ELPA]] contributions require a copyright assignment to the FSF.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>clojure-emacs/parseclj</title>
    <updated>2022-06-25T01:38:52Z</updated>
    <id>tag:github.com,2022-06-25:/clojure-emacs/parseclj</id>
    <link href="https://github.com/clojure-emacs/parseclj" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Clojure Parser for Emacs Lisp&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/clojure-emacs/parseclj&#34;&gt;&lt;img src=&#34;https://travis-ci.org/clojure-emacs/parseclj.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Clojure parser for Emacs Lisp&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;parseclj&lt;/code&gt; is an Emacs Lisp library for parsing Clojure code and &lt;a href=&#34;https://github.com/edn-format/edn&#34;&gt;EDN data&lt;/a&gt;. It supports several input and output formats, all powered by the same shift-reduce parser function.&lt;/p&gt; &#xA;&lt;p&gt;Take a look at the &lt;a href=&#34;https://raw.githubusercontent.com/clojure-emacs/parseclj/main/DESIGN.md&#34;&gt;design document&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;parseclj&lt;/code&gt; is in &lt;strong&gt;alpha&lt;/strong&gt; state right now, its API might be subject to change.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Available on the major &lt;code&gt;package.el&lt;/code&gt; community maintained repos - &lt;a href=&#34;http://stable.melpa.org&#34;&gt;MELPA Stable&lt;/a&gt; and &lt;a href=&#34;http://melpa.org&#34;&gt;MELPA&lt;/a&gt; repos.&lt;/p&gt; &#xA;&lt;p&gt;MELPA Stable is the recommended repo as it has the latest stable version. MELPA has a development snapshot for users who don&#39;t mind (infrequent) breakage but don&#39;t want to run from a git checkout.&lt;/p&gt; &#xA;&lt;p&gt;You can install &lt;code&gt;parseclj&lt;/code&gt; using the following command:&lt;/p&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x package-install [RET] parseclj [RET]&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;p&gt;or if you&#39;d rather keep it in your dotfiles:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(unless (package-installed-p &#39;parseclj)&#xA;  (package-install &#39;parseclj))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the installation doesn&#39;t work try refreshing the package list:&lt;/p&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x package-refresh-contents&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;parseclj&lt;/code&gt; contains function that return an &lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;AST&lt;/a&gt; that, for example, given as input &lt;code&gt;(1 2 [:a :b :c])&lt;/code&gt;, it looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;((:node-type . :root)&#xA; (:position . 1)&#xA; (:children ((:node-type . :list)&#xA;             (:position . 1)&#xA;             (:children ((:node-type . :number)&#xA;                         (:position . 2)&#xA;                         (:form . &#34;1&#34;)&#xA;                         (:value . 1))&#xA;                        ((:node-type . :number)&#xA;                         (:position . 4)&#xA;                         (:form . &#34;2&#34;)&#xA;                         (:value . 2))&#xA;                        ((:node-type . :vector)&#xA;                         (:position . 6)&#xA;                         (:children ((:node-type . :keyword)&#xA;                                     (:position . 7)&#xA;                                     (:form . &#34;:a&#34;)&#xA;                                     (:value . :a))&#xA;                                    ((:node-type . :keyword)&#xA;                                     (:position . 10)&#xA;                                     (:form . &#34;:b&#34;)&#xA;                                     (:value . :b))&#xA;                                    ((:node-type . :keyword)&#xA;                                     (:position . 13)&#xA;                                     (:form . &#34;:c&#34;)&#xA;                                     (:value . :c))))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to use any of these functions, you first need to require it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;parseclj)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then you will have the following functions at your disposal:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;parseclj-parse-clojure&lt;/code&gt; &amp;amp;rest string-and-options&lt;/p&gt; &lt;p&gt;When no arguments, parses Clojure source code into an AST and returns it. When given a string as a first argument, parses it and returns the corresponding AST.&lt;/p&gt; &lt;p&gt;A list of options can be passed down to the parsing process, particularly:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;:lexical-preservation&lt;/code&gt;: a boolean value to retain whitespace, comments, and discards. Defaults to nil.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;:fail-fast&lt;/code&gt;: a boolean value to raise an error when encountering invalid syntax. Defaults to t.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Examples:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(parseclj-parse-clojure) ;; will parse clojure code in the current buffer and return an AST&#xA;(parseclj-parse-clojure &#34;(1 2 3)&#34;)  ;; =&amp;gt; ((:node-type . :root) ... )&#xA;(parseclj-parse-clojure :lexical-preservation t) ;; will parse clojure code in current buffer preserving whitespaces, comments and discards&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;Note: there&#39;s an open issue to extend this API to &lt;a href=&#34;https://github.com/clojure-emacs/parseclj/issues/13&#34;&gt;parse clojure code within some boundaries of a buffer&lt;/a&gt;. Pull requests are welcome.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;parseclj-unparse-clojure&lt;/code&gt; ast&lt;/p&gt; &lt;p&gt;Transform the given AST into Clojure source code and inserts it into the current buffer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;parseclj-unparse-clojure-to-string&lt;/code&gt; ast&lt;/p&gt; &lt;p&gt;Transfrom the given AST into Clojure source code and returns it as a string.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Â© 2017-2021 Arne Brasseur and contributors.&lt;/p&gt; &#xA;&lt;p&gt;Distributed under the terms of the GNU General Public License 3.0 or later. See &lt;a href=&#34;https://raw.githubusercontent.com/clojure-emacs/parseclj/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cask/shut-up</title>
    <updated>2022-06-25T01:38:52Z</updated>
    <id>tag:github.com,2022-06-25:/cask/shut-up</id>
    <link href="https://github.com/cask/shut-up" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs, shut up would you!&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Shut up!&lt;/h1&gt; &#xA;&lt;p&gt;If you have an Emacs shell script, you most likely don&#39;t want output like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Loading vc-git...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This package does it&#39;s best at shutting Emacs up!&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add &lt;code&gt;shut-up&lt;/code&gt; to your &lt;a href=&#34;https://github.com/cask/cask&#34;&gt;Cask&lt;/a&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(depends-on &#34;shut-up&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;shut-up&lt;/code&gt; macro to silence function calls:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(let (output)&#xA;  (shut-up&#xA;    (message &#34;Foo&#34;)&#xA;    (setq output (shut-up-current-output)))&#xA;  (message &#34;This was the last message: %s&#34; output))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In non-interactive sessions, you can also use &lt;code&gt;shut-up-silence-emacs&lt;/code&gt; to change some global Emacs settings to reduce output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(when noninteractive&#xA;  (shut-up-silence-emacs))&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>