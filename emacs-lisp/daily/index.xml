<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-07T01:39:44Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kanru/uuidgen-el</title>
    <updated>2022-07-07T01:39:44Z</updated>
    <id>tag:github.com,2022-07-07:/kanru/uuidgen-el</id>
    <link href="https://github.com/kanru/uuidgen-el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;UUID generation implemented in elisp.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://melpa.org/#/uuidgen&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/uuidgen-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;uuidgen-el&lt;/h1&gt; &#xA;&lt;p&gt;This is a naive implementation of RFC4122 Universally Unique IDentifier generation in elisp. Currently implemented are UUID v1 v3, v4 and v5 generation. The resolution of the time based UUID is microseconds, which is 10 times of the suggested 100-nanosecond resolution, but should be enough for general usage.&lt;/p&gt; &#xA;&lt;h2&gt;APIs&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Function&lt;/strong&gt; &lt;code&gt;uuidgen-1&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Generate time based UUID string, aka UUIDv1.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Function&lt;/strong&gt; &lt;code&gt;uuidgen-4&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Generate UUID string form random numbers, aka UUIDv4.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Function&lt;/strong&gt; &lt;code&gt;uuidgen-3 (ns name)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Generate name based UUID string using MD5 hash algorithm, aka UUIDv3. NS should be a generated UUID or predefined namespaces, &lt;code&gt;uuidgen-ns-dns&lt;/code&gt;, &lt;code&gt;uuidgen-ns-url&lt;/code&gt;, &lt;code&gt;uuidgen-ns-oid&lt;/code&gt;, &lt;code&gt;uuidgen-ns-x500&lt;/code&gt;. NAME is the node name string.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Function&lt;/strong&gt; &lt;code&gt;uuidgen-5 (ns name)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Generate name based UUID string using SHA-1 hash algorithm, aka UUIDv5. NS should be a generated UUID or predefined namespaces, &lt;code&gt;uuidgen-ns-dns&lt;/code&gt;, &lt;code&gt;uuidgen-ns-url&lt;/code&gt;, &lt;code&gt;uuidgen-ns-oid&lt;/code&gt;, &lt;code&gt;uuidgen-ns-x500&lt;/code&gt;. NAME is the node name string.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Function&lt;/strong&gt; &lt;code&gt;uuidgen-urn (uuid)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Return the string representation of a UUID as a URN.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Function&lt;/strong&gt; &lt;code&gt;uuidgen-cid (&amp;amp;optional uuid)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Return UUID string in CID format that is suitable for COM definition. If UUID is nil will generate UUID-4 automatically. You customize &lt;code&gt;uuidgen-cid-format-string&lt;/code&gt; to change the default format.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt; &lt;code&gt;insert-uuid-cid (uuid)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Insert UUID string in CID format that is suitable for COM definition. If UUID is nil will generate UUIDv4 automatically. You customize &lt;code&gt;uuidgen-cid-format-string&lt;/code&gt; to change the default format.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt; &lt;code&gt;uuidgen (time-based)&lt;/code&gt;&lt;/p&gt; &lt;p&gt;Insert UUIDv4 at point. If TIME-BASED is non-nil, insert UUIDv1 instead.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Wilfred/elisp-refs</title>
    <updated>2022-07-07T01:39:44Z</updated>
    <id>tag:github.com,2022-07-07:/Wilfred/elisp-refs</id>
    <link href="https://github.com/Wilfred/elisp-refs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;semantic code search for emacs lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;elisp-refs&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://coveralls.io/github/Wilfred/elisp-refs?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/Wilfred/elisp-refs/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/elisp-refs&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/elisp-refs-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;elisp-refs is an intelligent code search for Emacs lisp.&lt;/p&gt; &#xA;&lt;p&gt;It can find references to functions, macros or variables. Unlike a dumb text search, elisp-refs actually parses the code, so it&#39;s never confused by comments or variables with the same name as functions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Wilfred/elisp-refs/master/refs_screenshot.png&#34; alt=&#34;screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is particularly useful for finding all the places a function is used, or finding examples of usage.&lt;/p&gt; &#xA;&lt;p&gt;Interested readers may enjoy my blog post: &lt;a href=&#34;http://www.wilfred.me.uk/blog/2016/09/30/searching-a-million-lines-of-lisp/&#34;&gt;Searching A Million Lines Of Lisp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install from MELPA (recommended) or just add elisp-refs to your &lt;code&gt;load-path&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Commands available&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-refs-function&lt;/code&gt; (find function calls)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-refs-macro&lt;/code&gt; (find macro calls)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-refs-variable&lt;/code&gt; (find variable references)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-refs-special&lt;/code&gt; (find special form calls)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-refs-symbol&lt;/code&gt; (find all references to a symbol)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These command search all the files currently loaded in your Emacs instance.&lt;/p&gt; &#xA;&lt;p&gt;If called with a prefix, you can limit search results to specific directories. For example:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;C-u M-x elisp-refs-macro RET pcase RET ~/.emacs.d/elpa/magit-20160927.510 RET&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;will search for uses of &lt;code&gt;pcase&lt;/code&gt; in magit:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Wilfred/elisp-refs/master/refs_filtered.png&#34; alt=&#34;filtering screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Semantic analysis&lt;/h2&gt; &#xA;&lt;p&gt;elisp-refs has &lt;em&gt;street smarts&lt;/em&gt;: given &lt;code&gt;(defun foo (bar) (baz))&lt;/code&gt;, it understands that &lt;code&gt;bar&lt;/code&gt; is a variable and &lt;code&gt;baz&lt;/code&gt; is a function.&lt;/p&gt; &#xA;&lt;p&gt;elisp-refs understands the following forms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;defun&lt;/code&gt; &lt;code&gt;defsubst&lt;/code&gt; &lt;code&gt;defmacro&lt;/code&gt; &lt;code&gt;cl-defun&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lambda&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;let&lt;/code&gt; &lt;code&gt;let*&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;funcall&lt;/code&gt; &lt;code&gt;apply&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;sharp quoted expressions (e.g. &lt;code&gt;#&#39;some-func&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;elisp-refs understands elisp special forms, and a few common macros. However, it &lt;strong&gt;cannot understand arbitrary macros&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Therefore elisp-refs will assume that &lt;code&gt;(other-macro (foo bar))&lt;/code&gt; is a function call to &lt;code&gt;foo&lt;/code&gt;. If this is incorrect, you may wish to use the command &lt;code&gt;elisp-refs-symbol&lt;/code&gt; to find all references to the &lt;code&gt;foo&lt;/code&gt; symbol.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;other-macro&lt;/code&gt; is a common macro, please consider submitting a patch to &lt;code&gt;elisp-refs--function-p&lt;/code&gt; to make elisp-refs smarter.&lt;/p&gt; &#xA;&lt;p&gt;elisp-refs also does not support &lt;strong&gt;indirect calls&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;;; Since we do a simple syntax tree walk, this isn&#39;t treated as a&#xA;;; call to foo.&#xA;(let ((x (symbol-function &#39;foo)))&#xA;  (funcall x))&#xA;&#xA;;; Similarly, indirect function calls are not treated as&#xA;;; function calls.&#xA;(defun call-func (x)&#xA;  (funcall x))&#xA;(call-func &#39;foo)&#xA;&#xA;;; However, if you use sharp quoting, elisp-refs knows it&#39;s a function&#xA;reference!&#xA;(call-func #&#39;foo)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running tests&lt;/h2&gt; &#xA;&lt;p&gt;You can run the tests with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cask install&#xA;$ cask exec ert-runner&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;elisp-refs is CPU-intensive elisp and has been carefully optimised. You can run the benchmark script with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cask install&#xA;$ ./bench.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;New features are carefully measured to ensure performance does not get worse.&lt;/p&gt; &#xA;&lt;p&gt;See elisp-refs-bench.el for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Alternative Projects&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;xref-find-references&lt;/strong&gt;: This command is included in Emacs 25.1, but it&#39;s based on a text search. It is confused by comments and strings, and cannot distinguish between functions and variables.&lt;/p&gt; &#xA;&lt;p&gt;xrefs-find-references is also line oriented, so it does not show the whole sexp that matched your search. Since it requires text files, it doesn&#39;t search built-in .el.gz files.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;TAGS&lt;/strong&gt;: It is possible to record function references in TAGS files. Whilst &lt;a href=&#34;https://github.com/universal-ctags/ctags&#34;&gt;universal-ctags&lt;/a&gt; (formerly known as exuberant-ctags) does provide the ability to find references, it is not supported in its lisp parser.&lt;/p&gt; &#xA;&lt;p&gt;etags, the TAGS implementation shipped with Emacs, cannot find references (to my knowledge).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://elpa.gnu.org/packages/el-search.html&#34;&gt;el-search&lt;/a&gt;&lt;/strong&gt; allows you to search for arbitrary forms in elisp files. It&#39;s slower, but a much more general tool. Its design greatly influenced elisp-refs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/purcell/elisp-slime-nav&#34;&gt;elisp-slime-nav&lt;/a&gt;&lt;/strong&gt; finds definitions, not references. It&#39;s a great complementary tool.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dominikh/go-mode.el</title>
    <updated>2022-07-07T01:39:44Z</updated>
    <id>tag:github.com,2022-07-07:/dominikh/go-mode.el</id>
    <link href="https://github.com/dominikh/go-mode.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs mode for the Go programming language&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This is go-mode, the Emacs mode for editing Go code.&lt;/p&gt; &#xA;&lt;p&gt;It is a complete rewrite of the go-mode that shipped with Go 1.0.3 and before, and was part of Go 1.1 until Go 1.3. Beginning with Go 1.4, editor integration will not be part of the Go distribution anymore, making this repository the canonical place for go-mode.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;p&gt;In addition to normal features, such as fontification and indentation, and close integration with familiar Emacs functionality (for example syntax-based navigation like &lt;code&gt;beginning-of-defun&lt;/code&gt;), go-mode comes with the following extra features to provide an improved experience:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Integration with &lt;code&gt;gofmt&lt;/code&gt; by providing a command of the same name, and &lt;code&gt;gofmt-before-save&lt;/code&gt;, which can be used in a hook to format Go buffers before saving them.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Setting the &lt;code&gt;gofmt-command&lt;/code&gt; variable also allows using &lt;code&gt;goimports&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Setting the &lt;code&gt;gofmt-args&lt;/code&gt; variable with a list of arguments allows using e.g. &lt;code&gt;gofmt -s&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Integration with &lt;code&gt;godoc&lt;/code&gt; via the functions &lt;code&gt;godoc&lt;/code&gt; and &lt;code&gt;godoc-at-point&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Integration with the Playground&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;go-play-buffer&lt;/code&gt; and &lt;code&gt;go-play-region&lt;/code&gt; to send code to the Playground&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;go-download-play&lt;/code&gt; to download a Playground entry into a new buffer&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Managing imports&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A function for jumping to the file&#39;s imports (&lt;code&gt;go-goto-imports&lt;/code&gt; - &lt;code&gt;C-c C-f i&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;A function for adding imports, including tab completion (&lt;code&gt;go-import-add&lt;/code&gt;, bound to &lt;code&gt;C-c C-a&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;A function for removing or commenting unused imports (&lt;code&gt;go-remove-unused-imports&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;It is recommended that you use &lt;code&gt;goimports&lt;/code&gt; or the &lt;code&gt;organize-imports&lt;/code&gt; feature of &lt;code&gt;gopls&lt;/code&gt; to manage adding/removing/organizing imports automatically.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Integration with godef&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;godef-describe&lt;/code&gt; (&lt;code&gt;C-c C-d&lt;/code&gt;) to describe expressions&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;godef-jump&lt;/code&gt; (&lt;code&gt;C-c C-j&lt;/code&gt;) and &lt;code&gt;godef-jump-other-window&lt;/code&gt; (&lt;code&gt;C-x 4 C-c C-j&lt;/code&gt;) to jump to declarations&lt;/li&gt; &#xA;   &lt;li&gt;This requires you to install godef via &lt;code&gt;go install github.com/rogpeppe/godef@latest&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Basic support for imenu (functions and variables)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Built-in support for displaying code coverage as calculated by &lt;code&gt;go test&lt;/code&gt; (&lt;code&gt;go-coverage&lt;/code&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Several functions for jumping to and manipulating the individual parts of function signatures. These functions support anonymous functions, but are smart enough to skip them when required (e.g. when jumping to a method receiver or docstring.)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Jump to the argument list (&lt;code&gt;go-goto-arguments&lt;/code&gt; - &lt;code&gt;C-c C-f a&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the docstring, create it if it does not exist yet (&lt;code&gt;go-goto-docstring&lt;/code&gt; - &lt;code&gt;C-c C-f d&lt;/code&gt;).&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the function keyword (&lt;code&gt;go-goto-function&lt;/code&gt; - &lt;code&gt;C-c C-f f&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the function name (&lt;code&gt;go-goto-function-name&lt;/code&gt; - &lt;code&gt;C-c C-f n&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the return values (&lt;code&gt;go-goto-return-values&lt;/code&gt; - &lt;code&gt;C-c C-f r&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the method receiver, adding a pair of parentheses if no method receiver exists (&lt;code&gt;go-goto-method-receiver&lt;/code&gt; - &lt;code&gt;C-c C-f m&lt;/code&gt;).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;All of these functions accept a prefix argument (&lt;code&gt;C-u&lt;/code&gt;), causing them to skip anonymous functions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;GOPATH detection – the function &lt;code&gt;go-guess-gopath&lt;/code&gt; will guess a suitable value for GOPATH, based on gb or wgo projects, Godeps and src folders for plain GOPATH workspaces. The command &lt;code&gt;go-set-project&lt;/code&gt; uses the return value of &lt;code&gt;go-guess-gopath&lt;/code&gt; to set the GOPATH environment variable.&lt;/p&gt; &lt;p&gt;You can either call &lt;code&gt;go-set-project&lt;/code&gt; manually, or integrate it with Projectile&#39;s project switching hooks, or any other means of switching projects you may employ.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;MELPA&lt;/h2&gt; &#xA;&lt;p&gt;The recommended way of installing go-mode is via &lt;a href=&#34;http://www.emacswiki.org/emacs/ELPA&#34;&gt;ELPA&lt;/a&gt;, the Emacs package manager, and the &lt;a href=&#34;http://emacsredux.com/blog/2014/05/16/melpa-stable/&#34;&gt;MELPA Stable repository&lt;/a&gt;, which provides an up-to-date version of go-mode.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re not familiar with ELPA yet, consider reading &lt;a href=&#34;http://ergoemacs.org/emacs/emacs_package_system.html&#34;&gt;this guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Manual&lt;/h2&gt; &#xA;&lt;p&gt;To install go-mode manually, check out the &lt;code&gt;go-mode.el&lt;/code&gt; repository in a directory of your choice, add it to your load path and configure Emacs to automatically load it when opening a &lt;code&gt;.go&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(add-to-list &#39;load-path &#34;/place/where/you/put/it/&#34;)&#xA;(autoload &#39;go-mode &#34;go-mode&#34; nil t)&#xA;(add-to-list &#39;auto-mode-alist &#39;(&#34;\\.go\\&#39;&#34; . go-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Either evaluate the statements with &lt;code&gt;C-x C-e&lt;/code&gt;, or restart Emacs.&lt;/p&gt; &#xA;&lt;h1&gt;Other extensions&lt;/h1&gt; &#xA;&lt;p&gt;There are several third party extensions that can enhance the Go experience in Emacs.&lt;/p&gt; &#xA;&lt;h2&gt;Gopls integration&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/golang/tools/raw/master/gopls/README.md&#34;&gt;Gopls&lt;/a&gt; is the official language server protocol (lsp) implementation provided by the Go team. It is intended to replace the existing third party tools for code formatting (gofmt), automatic imports (goimports), code navigation (godef/guru), type and function descriptions (godoc/godef), error checking, auto completion (gocode), variable and type renaming (rename), and more. Once gopls is stable the older tools will no longer be supported.&lt;/p&gt; &#xA;&lt;p&gt;Gopls is a supported backend for &lt;a href=&#34;https://github.com/emacs-lsp/lsp-mode&#34;&gt;lsp-mode&lt;/a&gt;. It will be used automatically by lsp-mode if &lt;code&gt;gopls&lt;/code&gt; is found in your PATH. You can install gopls via: &lt;code&gt;go install golang.org/x/tools/gopls@latest&lt;/code&gt;. To enable lsp-mode for go buffers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(add-hook &#39;go-mode-hook &#39;lsp-deferred)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Syntax/error checking&lt;/h2&gt; &#xA;&lt;p&gt;There are two ways of using flymake with Go:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dougm/goflymake&#34;&gt;goflymake&lt;/a&gt;, which internally uses &lt;code&gt;go build&lt;/code&gt; to capture all errors that a regular compilation would also produce&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://marmalade-repo.org/packages/flymake-go&#34;&gt;flymake-go&lt;/a&gt; for a more lightweight solution that only uses &lt;code&gt;gofmt&lt;/code&gt; and as such is only able to catch syntax errors. Unlike goflymake, however, it does not require an additional executable.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Additionally, there is &lt;a href=&#34;https://github.com/flycheck/flycheck&#34;&gt;flycheck&lt;/a&gt;, a modern replacement for flymake, which comes with built-in support for Go. In addition to using &lt;code&gt;go build&lt;/code&gt; or &lt;code&gt;gofmt&lt;/code&gt;, it also has support for &lt;code&gt;go vet&lt;/code&gt;, &lt;code&gt;golint&lt;/code&gt; and &lt;code&gt;errcheck&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Auto completion&lt;/h2&gt; &#xA;&lt;p&gt;For auto completion, take a look at &lt;a href=&#34;https://github.com/nsf/gocode&#34;&gt;gocode&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;eldoc&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/syohex/emacs-go-eldoc&#34;&gt;https://github.com/syohex/emacs-go-eldoc&lt;/a&gt; provides eldoc functionality for go-mode.&lt;/p&gt; &#xA;&lt;h2&gt;Snippets&lt;/h2&gt; &#xA;&lt;p&gt;I maintain a set of YASnippet snippets for go-mode at &lt;a href=&#34;https://github.com/dominikh/yasnippet-go&#34;&gt;https://github.com/dominikh/yasnippet-go&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Integration with errcheck&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dominikh/go-errcheck.el&#34;&gt;https://github.com/dominikh/go-errcheck.el&lt;/a&gt; provides integration with &lt;a href=&#34;https://github.com/kisielk/errcheck&#34;&gt;errcheck&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Stability&lt;/h1&gt; &#xA;&lt;p&gt;go-mode.el has regular, tagged releases and is part of the MELPA Stable repository. These tagged releases are intended to provide a stable experience. APIs added in tagged releases will usually not be removed or changed in future releases.&lt;/p&gt; &#xA;&lt;p&gt;Changes made on the master branch, which is tracked by the normal MELPA repository, however, are under active development. New APIs are experimental and may be changed or removed before the next release. Furthermore, there is a higher chance for bugs.&lt;/p&gt; &#xA;&lt;p&gt;If you want a stable experience, use MELPA Stable. If you want cutting edge features, or &#34;beta-test&#34; future releases, use MELPA or the master branch.&lt;/p&gt;</summary>
  </entry>
</feed>