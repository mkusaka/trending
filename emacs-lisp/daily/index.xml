<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-18T01:37:57Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>abo-abo/ace-window</title>
    <updated>2022-06-18T01:37:57Z</updated>
    <id>tag:github.com,2022-06-18:/abo-abo/ace-window</id>
    <link href="https://github.com/abo-abo/ace-window" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Quickly switch windows in Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ace-window&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://elpa.gnu.org/packages/ace-window.html&#34;&gt;&lt;img src=&#34;https://elpa.gnu.org/packages/ace-window.svg?sanitize=true&#34; alt=&#34;GNU ELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://melpa.org/#/ace-window&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/ace-window-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/ace-window&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/ace-window-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;GNU Emacs package for selecting a window to switch to&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What and why&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;m sure you&#39;re aware of the &lt;code&gt;other-window&lt;/code&gt; command. While it&#39;s great for two windows, it quickly loses its value when there are more windows. You need to call it many times, and since it&#39;s not easily predictable, you have to check each time if you&#39;re in the window that you wanted.&lt;/p&gt; &#xA;&lt;p&gt;Another approach is to use &lt;code&gt;windmove-left&lt;/code&gt;, &lt;code&gt;windmove-up&lt;/code&gt;, etc. These are fast and predictable. Their disadvantage is that they need 4 key bindings. The default ones are shift+arrows, which are hard to reach.&lt;/p&gt; &#xA;&lt;p&gt;This package aims to take the speed and predictability of &lt;code&gt;windmove&lt;/code&gt; and pack it into a single key binding, similar to &lt;code&gt;other-window&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;Just assign &lt;code&gt;ace-window&lt;/code&gt; to a short key binding, as switching windows is a common task. I suggest &lt;kbd&gt;M-o&lt;/kbd&gt;, as it&#39;s short and not bound to anything important in the default Emacs.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;When there are two windows, &lt;code&gt;ace-window&lt;/code&gt; will call &lt;code&gt;other-window&lt;/code&gt; (unless &lt;code&gt;aw-dispatch-always&lt;/code&gt; is set non-nil). If there are more, each window will have the first character of its window label highlighted at the upper left of the window. Pressing that character will either switch to that window or filter to the next character needed to select a specific window. Note that, unlike &lt;code&gt;ace-jump-mode&lt;/code&gt;, the position of point will not be changed, i.e. the same behavior as that of &lt;code&gt;other-window&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A special character defined by &lt;code&gt;aw-make-frame-char&lt;/code&gt; (default = &lt;code&gt;z&lt;/code&gt;) means create a new frame and use its window as the target. The new frame&#39;s location is set relative to the prior selected frame&#39;s location and given by &lt;code&gt;aw-frame-offset&lt;/code&gt;. The new frame&#39;s size is given by &lt;code&gt;aw-frame-size&lt;/code&gt;. See their documentation strings for more information.&lt;/p&gt; &#xA;&lt;p&gt;The windows are ordered top-down, left-to-right. This means that if you remember your window layouts, you can switch windows without even looking at the leading char. For instance, the top left window will always be &lt;code&gt;1&lt;/code&gt; (or &lt;code&gt;a&lt;/code&gt; if you use letters for window characters).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ace-window&lt;/code&gt; works across multiple frames, as you can see from the &lt;a href=&#34;http://oremacs.com/download/ace-window.gif&#34;&gt;in-action gif&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Swap and delete window&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You can swap windows by calling &lt;code&gt;ace-window&lt;/code&gt; with a prefix argument &lt;kbd&gt;C-u&lt;/kbd&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can delete the selected window by calling &lt;code&gt;ace-window&lt;/code&gt; with a double prefix argument, i.e. &lt;kbd&gt;C-u C-u&lt;/kbd&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Change the action midway&lt;/h2&gt; &#xA;&lt;p&gt;You can also start by calling &lt;code&gt;ace-window&lt;/code&gt; and then decide to switch the action to &lt;code&gt;delete&lt;/code&gt; or &lt;code&gt;swap&lt;/code&gt; etc. By default the bindings are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;kbd&gt;x&lt;/kbd&gt; - delete window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;m&lt;/kbd&gt; - swap windows&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;M&lt;/kbd&gt; - move window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;c&lt;/kbd&gt; - copy window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;j&lt;/kbd&gt; - select buffer&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;n&lt;/kbd&gt; - select the previous window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;u&lt;/kbd&gt; - select buffer in the other window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;c&lt;/kbd&gt; - split window fairly, either vertically or horizontally&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;v&lt;/kbd&gt; - split window vertically&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;b&lt;/kbd&gt; - split window horizontally&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;o&lt;/kbd&gt; - maximize current window&lt;/li&gt; &#xA; &lt;li&gt;&lt;kbd&gt;?&lt;/kbd&gt; - show these command bindings&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For proper operation, these keys &lt;em&gt;must not&lt;/em&gt; be in &lt;code&gt;aw-keys&lt;/code&gt;. Additionally, if you want these keys to work with fewer than three windows, you need to have &lt;code&gt;aw-dispatch-always&lt;/code&gt; set to &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Customization&lt;/h2&gt; &#xA;&lt;p&gt;Aside from binding &lt;code&gt;ace-window&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(global-set-key (kbd &#34;M-o&#34;) &#39;ace-window)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;the following customizations are available:&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-keys&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;aw-keys&lt;/code&gt; - the list of initial characters used in window labels:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setq aw-keys &#39;(?a ?s ?d ?f ?g ?h ?j ?k ?l))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;aw-keys&lt;/code&gt; are 0-9 by default, which is reasonable, but in the setup above, the keys are on the home row.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-scope&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The default one is &lt;code&gt;global&lt;/code&gt;, which means that &lt;code&gt;ace-window&lt;/code&gt; will work across frames. If you set this to &lt;code&gt;frame&lt;/code&gt;, &lt;code&gt;ace-window&lt;/code&gt; will offer you only the windows of the current frame.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-background&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;ace-window&lt;/code&gt; temporarily sets a gray background and removes color from available windows in order to make the window-switching characters more visible. This is the behavior inherited from &lt;code&gt;ace-jump-mode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This behavior might not be necessary, as you already know the locations where to look, i.e. the top-left corners of each window. So you can turn off the gray background with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setq aw-background nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-dispatch-always&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When non-nil, &lt;code&gt;ace-window&lt;/code&gt; will issue a &lt;code&gt;read-char&lt;/code&gt; even for one window. This will make &lt;code&gt;ace-window&lt;/code&gt; act differently from &lt;code&gt;other-window&lt;/code&gt; for one or two windows. This is useful to change the action midway and execute an action other than the default &lt;em&gt;jump&lt;/em&gt; action. By default, this is set to &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-dispatch-alist&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This is the list of actions you can trigger from &lt;code&gt;ace-window&lt;/code&gt; other than the &lt;em&gt;jump&lt;/em&gt; default. By default it is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defvar aw-dispatch-alist&#xA;  &#39;((?x aw-delete-window &#34;Delete Window&#34;)&#xA;&#x9;(?m aw-swap-window &#34;Swap Windows&#34;)&#xA;&#x9;(?M aw-move-window &#34;Move Window&#34;)&#xA;&#x9;(?c aw-copy-window &#34;Copy Window&#34;)&#xA;&#x9;(?j aw-switch-buffer-in-window &#34;Select Buffer&#34;)&#xA;&#x9;(?n aw-flip-window)&#xA;&#x9;(?u aw-switch-buffer-other-window &#34;Switch Buffer Other Window&#34;)&#xA;&#x9;(?c aw-split-window-fair &#34;Split Fair Window&#34;)&#xA;&#x9;(?v aw-split-window-vert &#34;Split Vert Window&#34;)&#xA;&#x9;(?b aw-split-window-horz &#34;Split Horz Window&#34;)&#xA;&#x9;(?o delete-other-windows &#34;Delete Other Windows&#34;)&#xA;&#x9;(?? aw-show-dispatch-help))&#xA;  &#34;List of actions for `aw-dispatch-default&#39;.&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using ace-window, if the action character is followed by a string, then &lt;code&gt;ace-window&lt;/code&gt; will be invoked again to select the target window for the action. Otherwise, the current window is selected.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-minibuffer-flag&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When non-nil, also display &lt;code&gt;ace-window-mode&lt;/code&gt; string in the minibuffer when &lt;code&gt;ace-window&lt;/code&gt; is active. This is useful when there are many side-by-side windows and the &lt;code&gt;ace-window-mode&lt;/code&gt; string is cutoff in the minor mode area of the modeline.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-ignored-buffers&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;List of buffers and major-modes to ignore when choosing a window from the window list. Active only when &lt;code&gt;aw-ignore-on&lt;/code&gt; is non-nil. Windows displaying these buffers can still be chosen by typing their specific labels.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-ignore-on&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When t, &lt;code&gt;ace-window&lt;/code&gt; will ignore buffers and major-modes in &lt;code&gt;aw-ignored-buffers&lt;/code&gt;. Use M-0 &lt;code&gt;ace-window&lt;/code&gt; to toggle this value. :type &#39;boolean)&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;aw-ignore-current&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When t, &lt;code&gt;ace-window&lt;/code&gt; will ignore `selected-window&#39;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>joddie/macrostep</title>
    <updated>2022-06-18T01:37:57Z</updated>
    <id>tag:github.com,2022-06-18:/joddie/macrostep</id>
    <link href="https://github.com/joddie/macrostep" rel="alternate"></link>
    <summary type="html">&lt;p&gt;interactive macro-expander for Emacs&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;macrostep: interactive macro-expander&lt;/p&gt; &lt;p&gt;=macrostep= is an Emacs minor mode for interactively stepping through the expansion of macros in Emacs Lisp source code. It lets you see exactly what happens at each step of the expansion process by pretty-printing the expanded forms inline in the source buffer, which is temporarily read-only while macro expansions are visible. You can expand and collapse macro forms one step at a time, and evaluate or instrument the expansions for debugging with Edebug as normal (but see &#34;Bugs and known limitations&#34;, below). Single-stepping through the expansion is particularly useful for debugging macros that expand into another macro form. These can be difficult to debug with Emacs&#39; built-in =macroexpand=, which continues expansion until the top-level form is no longer a macro call.&lt;/p&gt; &lt;p&gt;Both globally-visible macros as defined by =defmacro= and local macros bound by =(cl-)macrolet= or another macro-defining form can be expanded. Within macro expansions, calls to macros and compiler macros are fontified specially: macro forms using =macrostep-macro-face=, and functions with compiler macros using =macrostep-compiler-macro-face=. Uninterned symbols (gensyms) are fontified based on which step in the expansion created them, to distinguish them both from normal symbols and from other gensyms with the same print name.&lt;/p&gt; &lt;p&gt;As of version 0.9, it is also possible to extend =macrostep= to work with other languages with macro systems in addition to Emacs Lisp. An extension for Common Lisp (via SLIME) is in the works; contributions for other languages are welcome. See &#34;Extending macrostep&#34; below for details.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Key-bindings and usage The standard keybindings in =macrostep-mode= are the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- e, =, RET  :: expand the macro form following point one step&#xA;- c, u, DEL  :: collapse the form following point&#xA;- q, C-c C-c :: collapse all expanded forms and exit macrostep-mode&#xA;- n, TAB     :: jump to the next macro form in the expansion&#xA;- p, M-TAB   :: jump to the previous macro form in the expansion&#xA;&#xA;It&#39;s not very useful to enable and disable macrostep-mode&#xA;directly.  Instead, bind =macrostep-expand= to a key in&#xA;=emacs-lisp-mode-map=, for example C-c e:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (define-key emacs-lisp-mode-map (kbd &#34;C-c e&#34;) &#39;macrostep-expand) #+END_SRC&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;You can then enter macrostep-mode and expand a macro form&#xA;completely by typing =C-c e e e ...= as many times as necessary.&#xA;&#xA;Exit macrostep-mode by typing =q= or =C-c C-c=, or by successively&#xA;typing =c= to collapse all surrounding expansions.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;** Customization options Type =M-x customize-group RET macrostep RET= to customize options and faces.&lt;/p&gt; &#xA;&lt;p&gt;To display macro expansions in a separate window, instead of inline in the source buffer, customize =macrostep-expand-in-separate-buffer= to =t=. The default is =nil=. Whichever default behavior is selected, the alternative behavior can be obtained temporarily by giving a prefix argument to =macrostep-expand=.&lt;/p&gt; &#xA;&lt;p&gt;To have =macrostep= ignore compiler macros, customize =macrostep-expand-compiler-macros= to =nil=. The default is =t=.&lt;/p&gt; &#xA;&lt;p&gt;Customize the faces =macrostep-macro-face=, =macrostep-compiler-macro-face=, and =macrostep-gensym-1= through =macrostep-gensym-5= to alter the appearance of macro expansions.&lt;/p&gt; &#xA;&lt;p&gt;** Locally-bound macros As of version 0.9, =macrostep= can expand calls to a locally-bound macro, whether defined by a surrounding =(cl-)macrolet= form, or by another macro-defining macro. In other words, it is possible to expand the inner =local-macro= forms in both the following examples, whether =local-macro= is defined by an enclosing =cl-macrolet= --&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (cl-macrolet ((local-macro (&amp;amp;rest args) `(expansion of ,args))) (local-macro (do-something))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;-- or by a macro which expands into =cl-macrolet=, provided that its definition of macro is evaluated prior to calling =macrostep-expand=:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (defmacro with-local-macro (&amp;amp;rest body) &lt;code&gt;(cl-macrolet ((local-macro (&amp;amp;rest args) &lt;/code&gt;(expansion of ,args))) ,@body))&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (with-local-macro&#xA;     (local-macro (do something (else)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;See the =with-js= macro in Emacs&#39;s =js.el= for a real example of the latter kind of macro.&lt;/p&gt; &#xA;&lt;p&gt;Expansion of locally-bound macros is implemented by instrumenting Emacs Lisp&#39;s macro-expander to capture the environment at point. A similar trick is used to detect macro- and compiler-macro calls within expanded text so that they can be fontified accurately.&lt;/p&gt; &#xA;&lt;p&gt;** Expanding sub-forms By moving point around in the macro expansion using =macrostep-next-macro= and =macrostep-prev-macro= (bound to the =n= and =p= keys), it is possible to expand other macro calls within the expansion before expanding the outermost form. This can sometimes be useful, although it does not correspond to the real order of macro expansion in Emacs Lisp, which proceeds by fully expanding the outer form to a non-macro form before expanding sub-forms.&lt;/p&gt; &#xA;&lt;p&gt;The main reason to expand sub-forms out of order is to help with debugging macros which programmatically expand their arguments in order to rewrite them. Expanding the arguments of such a macro lets you visualise what the macro definition would compute via =macroexpand-all=.&lt;/p&gt; &#xA;&lt;p&gt;** Extending macrostep for other languages Since version 0.9, it is possible to extend macrostep to work with other languages besides Emacs Lisp. In typical Emacs fashion, this is implemented by setting buffer-local variables to different function values. Six buffer-local variables define the language-specific part of the implementation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=macrostep-sexp-bounds-function=&lt;/li&gt; &#xA; &lt;li&gt;=macrostep-sexp-at-point-function=&lt;/li&gt; &#xA; &lt;li&gt;=macrostep-environment-at-point-function=&lt;/li&gt; &#xA; &lt;li&gt;=macrostep-expand-1-function=&lt;/li&gt; &#xA; &lt;li&gt;=macrostep-print-function=&lt;/li&gt; &#xA; &lt;li&gt;=macrostep-macro-form-p-function=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Typically, an implementation for another language would set these variables in a major-mode hook. See the docstrings of each variable for details on how each one is called and what it should return. At a minimum, another language implementation needs to provide =macrostep-sexp-at-point-function=, =macrostep-expand-1-function=, and =macrostep-print-function=. Lisp-like languages may be able to reuse the default =macrostep-sexp-bounds-function= if they provide another implementation of =macrostep-macro-form-p-function=. Languages which do not implement locally-defined macros can set =macrostep-environment-at-point-function= to =ignore=.&lt;/p&gt; &#xA;&lt;p&gt;Note that the core =macrostep= machinery only interprets the return value of =macrostep-sexp-bounds-function=, so implementations for other languages can use any internal representations of code and environments which is convenient. Although the terminology is Lisp-specific, there is no reason that implementations could not be provided for non-Lisp languages with macro systems, provided there is some way of identifying macro calls and calling the compiler / preprocessor to obtain their expansions.&lt;/p&gt; &#xA;&lt;p&gt;** Bugs and known limitations You can evaluate and edebug macro-expanded forms and step through the macro-expanded version, but the form that =eval-defun= and friends read from the buffer won&#39;t have the uninterned symbols of the real macro expansion. This will probably work OK with CL-style gensyms, but may cause problems with =make-symbol= symbols if they have the same print name as another symbol in the expansion. It&#39;s possible that using =print-circle= and =print-gensym= could get around this.&lt;/p&gt; &#xA;&lt;p&gt;Please send other bug reports and feature requests to the author.&lt;/p&gt; &#xA;&lt;p&gt;** Acknowledgements Thanks to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;John Wiegley for fixing a bug with the face definitions under Emacs 24 &amp;amp; for plugging macrostep in his [[http://youtu.be/RvPFZL6NJNQ][EmacsConf presentation]]!&lt;/li&gt; &#xA; &lt;li&gt;George Kettleborough for bug reports, and patches to highlight the expanded region and properly handle backquotes.&lt;/li&gt; &#xA; &lt;li&gt;Nic Ferrier for suggesting support for local definitions within macrolet forms&lt;/li&gt; &#xA; &lt;li&gt;Luís Oliveira for suggesting and implementing SLIME support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=macrostep= was originally inspired by J. V. Toups&#39;s &#39;Deep Emacs Lisp&#39; articles ([[http://dorophone.blogspot.co.uk/2011/04/deep-emacs-part-1.html][part 1]], [[http://dorophone.blogspot.co.uk/2011/04/deep-emacs-lisp-part-2.html][part 2]], [[http://dorophone.blogspot.co.uk/2011/05/monadic-parser-combinators-in-elisp.html][screencast]]).&lt;/p&gt; &#xA;&lt;p&gt;** Changelog&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;v0.9, 2015-10-01: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;separate into Elisp-specific and generic components&lt;/li&gt; &#xA;   &lt;li&gt;highlight and expand compiler macros&lt;/li&gt; &#xA;   &lt;li&gt;improve local macro expansion and macro form identification by instrumenting =macroexpand(-all)=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;v0.8, 2014-05-29: fix a bug with printing the first element of lists&lt;/li&gt; &#xA; &lt;li&gt;v0.7, 2014-05-11: expand locally-defined macros within =(cl-)macrolet= forms&lt;/li&gt; &#xA; &lt;li&gt;v0.6, 2013-05-04: better handling of quote and backquote&lt;/li&gt; &#xA; &lt;li&gt;v0.5, 2013-04-16: highlight region, maintain cleaner buffer state&lt;/li&gt; &#xA; &lt;li&gt;v0.4, 2013-04-07: only enter macrostep-mode on successful macro-expansion&lt;/li&gt; &#xA; &lt;li&gt;v0.3, 2012-10-30: print dotted lists correctly. autoload definitions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+OPTIONS: author:nil email:nil toc:nil timestamp:nil&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ardumont/markdown-toc</title>
    <updated>2022-06-18T01:37:57Z</updated>
    <id>tag:github.com,2022-06-18:/ardumont/markdown-toc</id>
    <link href="https://github.com/ardumont/markdown-toc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Generate a TOC in markdown file&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;markdown-toc&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.com/ardumont/markdown-toc&#34;&gt;&lt;img src=&#34;https://travis-ci.com/ardumont/markdown-toc.png?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/ardumont/markdown-toc?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/ardumont/markdown-toc/badge.svg?branch=master&amp;amp;service=github&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://stable.melpa.org/#/markdown-toc&#34;&gt;&lt;img src=&#34;http://stable.melpa.org/packages/markdown-toc-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://melpa.org/#/markdown-toc&#34;&gt;&lt;img src=&#34;http://melpa.org/packages/markdown-toc-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://archive.softwareheritage.org/browse/origin/?origin_url=https://github.com/ardumont/markdown-toc&#34;&gt;&lt;img src=&#34;https://archive.softwareheritage.org/badge/origin/https://github.com/ardumont/markdown-toc/&#34; alt=&#34;SWH&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-refresh-toc --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#use&#34;&gt;Use&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#create&#34;&gt;Create&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#user-toc-manipulation&#34;&gt;User toc manipulation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#update&#34;&gt;Update&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#create-elsewhere&#34;&gt;Create elsewhere&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#remove&#34;&gt;Remove&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#customize&#34;&gt;Customize&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#minor-mode&#34;&gt;Minor mode&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#install&#34;&gt;Install&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#emacs-package-repository&#34;&gt;emacs package repository&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#setup&#34;&gt;Setup&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#melpa-stable&#34;&gt;melpa stable&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#melpa&#34;&gt;melpa&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#install-1&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#emacs-lisp-file&#34;&gt;emacs-lisp file&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ardumont/markdown-toc/master/#inspiration&#34;&gt;Inspiration&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;p&gt;A simple mode to create TOC in a well-formed markdown file.&lt;/p&gt; &#xA;&lt;p&gt;Note that the TOC is well-formed if the markdown is (cf. #15).&lt;/p&gt; &#xA;&lt;h1&gt;Use&lt;/h1&gt; &#xA;&lt;h2&gt;Create&lt;/h2&gt; &#xA;&lt;p&gt;Inside a markdown file, the first time, place yourself where you want to insert the TOC:&lt;/p&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x markdown-toc-generate-toc&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;p&gt;This will compute the TOC and insert it at current position.&lt;/p&gt; &#xA;&lt;p&gt;You can also execute: &lt;kbd&gt;M-x markdown-toc-generate-or-refresh-toc&lt;/kbd&gt; to either gnerate a TOC when none exists or refresh the currently existing one.&lt;/p&gt; &#xA;&lt;p&gt;Here is one possible output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-refresh-toc --&amp;gt;&#xA;**Table of Contents**&#xA;&#xA;- [Use](#use)&#xA;    - [Create](#create)&#xA;    - [Update](#update)&#xA;    - [Create elsewhere](#create-elsewhere)&#xA;- [Install](#install)&#xA;    - [emacs package repository](#emacs-package-repository)&#xA;        - [Setup](#setup)&#xA;            - [melpa stable](#melpa-stable)&#xA;            - [melpa](#melpa)&#xA;            - [marmalade](#marmalade)&#xA;        - [Install](#install)&#xA;    - [emacs-lisp file](#emacs-lisp-file)&#xA;- [Inspiration](#inspiration)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;User toc manipulation&lt;/h2&gt; &#xA;&lt;p&gt;If the user would want to enhance the generated toc, (s)he could use the following function markdown-toc-user-toc-structure-manipulation-fn:&lt;/p&gt; &#xA;&lt;p&gt;It expects as argument the toc-structure markdown-toc uses to generate the toc. The remaining code expects a similar structure.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;&#39;((0 . &#34;some markdown page title&#34;)&#xA;  (0 . &#34;main title&#34;)&#xA;  (1 . &#34;Sources&#34;)&#xA;  (2 . &#34;Marmalade (recommended)&#34;)&#xA;  (2 . &#34;Melpa-stable&#34;)&#xA;  (2 . &#34;Melpa (~snapshot)&#34;)&#xA;  (1 . &#34;Install&#34;)&#xA;  (2 . &#34;Load org-trello&#34;)&#xA;  (2 . &#34;Alternative&#34;)&#xA;  (3 . &#34;Git&#34;)&#xA;  (3 . &#34;Tar&#34;)&#xA;  (0 . &#34;another title&#34;)&#xA;  (1 . &#34;with&#34;)&#xA;  (1 . &#34;some&#34;)&#xA;  (1 . &#34;heading&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So for example, as asked in #16, one could drop the first element:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(custom-set-variables &#39;(markdown-toc-user-toc-structure-manipulation-fn &#39;cdr))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or drop all h1 titles... or whatever:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;dash)&#xA;(custom-set-variables &#39;(markdown-toc-user-toc-structure-manipulation-fn&#xA;  (lambda (toc-structure)&#xA;  (-filter (lambda (l) (let ((index (car l)))&#xA;                    (&amp;lt;= 1 index)))&#xA;           toc-structure)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Update&lt;/h2&gt; &#xA;&lt;p&gt;To update the existing TOC, simply execute: &lt;kbd&gt;M-x markdown-toc-refresh-toc&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;p&gt;This will update the current TOC.&lt;/p&gt; &#xA;&lt;h2&gt;Create elsewhere&lt;/h2&gt; &#xA;&lt;p&gt;To create another updated TOC elsewhere, execute &lt;kbd&gt;M-x markdown-toc-generate-toc&lt;/kbd&gt; again, this will remove the old TOC and insert the updated one from where you stand.&lt;/p&gt; &#xA;&lt;h2&gt;Remove&lt;/h2&gt; &#xA;&lt;p&gt;To remove a TOC, execute &lt;kbd&gt;M-x markdown-toc-delete-toc&lt;/kbd&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Customize&lt;/h2&gt; &#xA;&lt;p&gt;Currently, you can customize the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;markdown-toc-header-toc-start&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;markdown-toc-header-toc-title&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;markdown-toc-header-toc-end&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;markdown-toc-indentation-space&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Customize them as following format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(custom-set-variables&#xA; &#39;(markdown-toc-header-toc-start &#34;&amp;lt;!-- customized start--&amp;gt;&#34;)&#xA; &#39;(markdown-toc-header-toc-title &#34;**customized title**&#34;)&#xA; &#39;(markdown-toc-header-toc-end &#34;&amp;lt;!-- customized end --&amp;gt;&#34;)&#xA; &#39;(markdown-toc-indentation-space 4))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Minor mode&lt;/h2&gt; &#xA;&lt;p&gt;markdown-toc-mode provides a minor mode with the following default binding:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setq markdown-toc-mode-map&#xA;      (let ((map (make-sparse-keymap)))&#xA;        (define-key map (kbd &#34;C-c m .&#34;) &#39;markdown-toc-follow-link-at-point)&#xA;        (define-key map (kbd &#34;C-c m t&#34;) &#39;markdown-toc-generate-or-refresh-toc)&#xA;        (define-key map (kbd &#34;C-c m d&#34;) &#39;markdown-toc-delete-toc)&#xA;        (define-key map (kbd &#34;C-c m v&#34;) &#39;markdown-toc-version)&#xA;        map))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To (de)activate this in an org file: /M-x markdown-toc-mode/&lt;/p&gt; &#xA;&lt;p&gt;You can also use emacs to setup your own bindings.&lt;/p&gt; &#xA;&lt;h1&gt;Install&lt;/h1&gt; &#xA;&lt;h2&gt;emacs package repository&lt;/h2&gt; &#xA;&lt;p&gt;You need to add melpa or melpa-stable package repository before installing it.&lt;/p&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;h4&gt;melpa stable&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;package)&#xA;(add-to-list &#39;package-archives &#39;(&#34;melpa-stable&#34; .&#xA;                                 &#34;http://melpa-stable.milkbox.net/packages/&#34;))&#xA;(package-initialize)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then hit &lt;kbd&gt;M-x eval-buffer&lt;/kbd&gt; to evaluate the buffer&#39;s contents.&lt;/p&gt; &#xA;&lt;h4&gt;melpa&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;package)&#xA;(add-to-list &#39;package-archives &#39;(&#34;melpa&#34; .&#xA;                                 &#34;http://melpa.milkbox.net/packages/&#34;))&#xA;(package-initialize)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then hit &lt;kbd&gt;M-x eval-buffer&lt;/kbd&gt; to evaluate the buffer&#39;s contents.&lt;/p&gt; &#xA;&lt;h3&gt;Install&lt;/h3&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x package-install RET markdown-toc RET&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;h2&gt;emacs-lisp file&lt;/h2&gt; &#xA;&lt;p&gt;Retrieve the markdown-toc.el &lt;a href=&#34;https://github.com/ardumont/markdown-toc/releases&#34;&gt;https://github.com/ardumont/markdown-toc/releases&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Then hit &lt;kbd&gt;M-x package-install-file RET markdown-toc.el RET&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Inspiration&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/thlorenz/doctoc&#34;&gt;https://github.com/thlorenz/doctoc&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The problem I had with doctoc is the installation process. I do not want to install the node tools just for this.&lt;/p&gt;</summary>
  </entry>
</feed>