<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-07T01:33:06Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dgutov/diff-hl</title>
    <updated>2022-09-07T01:33:06Z</updated>
    <id>tag:github.com,2022-09-07:/dgutov/diff-hl</id>
    <link href="https://github.com/dgutov/diff-hl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs package for highlighting uncommitted changes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;About&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;diff-hl-mode&lt;/code&gt; highlights uncommitted changes on the left side of the window (area also known as the &#34;gutter&#34;), allows you to jump between and revert them selectively.&lt;/p&gt; &#xA;&lt;p&gt;In buffers controlled by Git, you can also stage and unstage the changes.&lt;/p&gt; &#xA;&lt;p&gt;For the usage instructions and the list of commands, see the Commentary section inside the file.&lt;/p&gt; &#xA;&lt;p&gt;Tested with Git, Mercurial, Bazaar and SVN. May work with other VC backends, too.&lt;/p&gt; &#xA;&lt;p&gt;The package also contains auxiliary modes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;diff-hl-dired-mode&lt;/code&gt; provides similar functionality in Dired.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;diff-hl-margin-mode&lt;/code&gt; changes the highlighting function to use the margin instead of the fringe.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;diff-hl-amend-mode&lt;/code&gt; sets the reference revision to the one before recent one. Also, you could use &lt;code&gt;diff-hl-set-reference-rev&lt;/code&gt; to set it to any revision, see its docstring for details.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;diff-hl-flydiff-mode&lt;/code&gt; implements highlighting changes on the fly.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;diff-hl-show-hunk-mouse-mode&lt;/code&gt; makes fringe and margin react to mouse clicks to show the curresponding hunk. That&#39;s the alternative to using &lt;code&gt;diff-hl-show-hunk&lt;/code&gt; and friends.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Put this into your init script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(global-diff-hl-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You must also ensure that VC is enabled (e.g. &lt;code&gt;vc-handled-backends&lt;/code&gt; is not nil).&lt;/p&gt; &#xA;&lt;p&gt;Check out the Commentary section in each file for more detailed usage instructions.&lt;/p&gt; &#xA;&lt;h1&gt;Screenshots&lt;/h1&gt; &#xA;&lt;h2&gt;diff-hl-mode&lt;/h2&gt; &#xA;&lt;p&gt;Top window: a buffer in this minor mode, bottom window: the corresponding diff.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dgutov/diff-hl/master/screenshot.png&#34; alt=&#34;screenie&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;diff-hl-dired-mode&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dgutov/diff-hl/master/screenshot-dired.png&#34; alt=&#34;screenie&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;diff-hl-margin-mode&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dgutov/diff-hl/master/screenshot-margin.png&#34; alt=&#34;screenie&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Requirements&lt;/h1&gt; &#xA;&lt;p&gt;Emacs 25.1+.&lt;/p&gt; &#xA;&lt;h1&gt;Notes&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;By default &lt;code&gt;diff-hl-mode&lt;/code&gt; uses the corresponding VC diff command, so it&#39;s only accurate when the buffer is in saved state. Check out &lt;code&gt;diff-hl-flydiff-mode&lt;/code&gt;, it aims to handle unsaved buffers as well.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To use an &lt;a href=&#34;http://stackoverflow.com/questions/32365271/whats-the-difference-between-git-diff-patience-and-git-diff-histogram&#34;&gt;alternative diff algorithm&lt;/a&gt; with Git, add a corresponding argument to &lt;code&gt;vc-git-diff-switches&lt;/code&gt;, e.g. &lt;code&gt;(setq vc-git-diff-switches &#39;(&#34;--histogram&#34;))&lt;/code&gt;. Using the &lt;code&gt;diff.algorithm&lt;/code&gt; option doesn&#39;t work &lt;a href=&#34;http://article.gmane.org/gmane.comp.version-control.git/294622&#34;&gt;because&lt;/a&gt; &lt;code&gt;vc-git-diff&lt;/code&gt; calls &lt;code&gt;git diff-index&lt;/code&gt;. &lt;code&gt;diff-hl-flydiff-mode&lt;/code&gt; does not support alternative algorithms, because it uses the external &lt;code&gt;diff&lt;/code&gt; program.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;We conflict with other modes when they put indicators on the fringe, such as &lt;a href=&#34;https://github.com/flycheck/flycheck&#34;&gt;Flycheck&lt;/a&gt;. This is rarely a significant problem, since if you&#39;re using such a mode, you&#39;d usually want to fix all errors and warnings before continuing, and then the conflicting indicators go away.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There&#39;s no fringe when Emacs is running in the console, but the navigation and revert commands still work. Consider turning &lt;code&gt;diff-hl-margin-mode&lt;/code&gt; on, to show the indicators in the margin instead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Frame-local and buffer-local values of &lt;code&gt;line-spacing&lt;/code&gt; are not supported.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fringe width up to 16 works best (because we can&#39;t define a bitmap with width above that number).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/syohex/emacs-git-gutter&#34;&gt;emacs-git-gutter&lt;/a&gt; shows indicators in the margin by default, allows you to customize how the indicators look more easily, and has a &#34;stage hunk&#34; command.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Integration&lt;/h1&gt; &#xA;&lt;p&gt;If you&#39;re using some package other than &lt;code&gt;vc&lt;/code&gt; to commit changes, it might not run &lt;code&gt;vc-checkin-hook&lt;/code&gt; after commits. In that case, you&#39;ll need to either add &lt;code&gt;diff-hl-update&lt;/code&gt; to the hook it does run, or advise some function that&#39;s called in the buffer after its state has changed.&lt;/p&gt; &#xA;&lt;h2&gt;psvn&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(advice-add &#39;svn-status-update-modeline :after #&#39;diff-hl-update)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Magit&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re using a version before 2.4.0, it defines &lt;code&gt;magit-revert-buffer-hook&lt;/code&gt; (or &lt;code&gt;magit-not-reverted-hook&lt;/code&gt;), which we use.&lt;/p&gt; &#xA;&lt;p&gt;When using Magit 2.4 or newer, add this to your init script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(add-hook &#39;magit-pre-refresh-hook &#39;diff-hl-magit-pre-refresh)&#xA;(add-hook &#39;magit-post-refresh-hook &#39;diff-hl-magit-post-refresh)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tramp&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;diff-hl&lt;/code&gt; should just work with Tramp. But slow or high latency connections can cause performance problems. If you experience such issues, customize &lt;code&gt;diff-hl-disable-on-remote&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;. This will change the behavior of both &lt;code&gt;turn-on-diff-hl-mode&lt;/code&gt; and &lt;code&gt;global-diff-hl-mode&lt;/code&gt; (whichever you prefer to use).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>SqrtMinusOne/reverso.el</title>
    <updated>2022-09-07T01:33:06Z</updated>
    <id>tag:github.com,2022-09-07:/SqrtMinusOne/reverso.el</id>
    <link href="https://github.com/SqrtMinusOne/reverso.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs client for https://www.reverso.net/: translation, grammar check, context and synonyms search&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: reverso.el&lt;/p&gt; &#xA;&lt;p&gt;Emacs client for the [[https://www.reverso.net/][Reverso]] service. The implemented features are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://www.reverso.net/text-translation][Translation]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://context.reverso.net/translation/][Context]] (AKA bilingual concordances)&lt;/li&gt; &#xA; &lt;li&gt;[[https://www.reverso.net/spell-checker/english-spelling-grammar/][Grammar check]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://synonyms.reverso.net/synonym/][Synonyms search]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation The package isn&#39;t yet available anywhere but in this repository. My preferred way for such cases is [[https://github.com/jwiegley/use-package][use-package]] and [[https://github.com/radian-software/straight.el][straight.el]]:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (use-package reverso :straight (:host github :repo &#34;SqrtMinusOne/reverso.el&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Or clone the repository, and it to =load-path= and =require= the package.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage There&#39;s a single entrypoint for all implemented functions, =M-x reverso=. The entirety of the UI is made with the excellent [[https://github.com/magit/transient/][transient.el]].&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Input handling All the commands handle the input the following way.&lt;/p&gt; &#xA;&lt;p&gt;By default, the input string is empty. If the command was launched with a region selected, use the string of that region. If launched with the prefix argument (=C-u=), use the entire buffer.&lt;/p&gt; &#xA;&lt;p&gt;The results of these commands are displayed in =reverso-result-mode= buffers. If launched in that buffer, the command uses the input string for the buffer. If launched with =C-u=, it uses the output string of that buffer (if available).&lt;/p&gt; &#xA;&lt;p&gt;** Translation Run =M-x reverso t= or =M-x reverso-translate= to invoke the translation transient.&lt;/p&gt; &#xA;&lt;p&gt;[[./img/translation-transient.png]]&lt;/p&gt; &#xA;&lt;p&gt;The &#34;Source language&#34; and &#34;Target language&#34; parameters are self-descriptive; just note that in the general case not every language is compatible with every other language. &#34;Swap languages&#34; tries to swap them.&lt;/p&gt; &#xA;&lt;p&gt;If &#34;Brief translation output&#34; is on, the output buffer will only show the translated version of the string.&lt;/p&gt; &#xA;&lt;p&gt;[[./img/translation-res.png]]&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, the buffer result can include the following sections:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Source text&lt;/em&gt; and &lt;em&gt;Translation&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Corrected text&lt;/em&gt;, if available&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Context results&lt;/em&gt;, if available&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Context results usually appear for short strings, like in the example from the screenshot.&lt;/p&gt; &#xA;&lt;p&gt;** Context Run =M-x reverso c= or =M-x reverso-context= to invoke context search (or [[https://en.wikipedia.org/w/index.php?title=Online_bilingual_concordance&amp;amp;redirect=no][bilingual concordances]], essentially a Rosetta stone generator).&lt;/p&gt; &#xA;&lt;p&gt;The input/output UI looks almost the same as in the translation command.&lt;/p&gt; &#xA;&lt;p&gt;Strange enough though, the direct context search usually yields different results than the &#34;Context results&#34; section of the translation command, so you may want to check out both if you want more data.&lt;/p&gt; &#xA;&lt;p&gt;** Synonyms Run =M-x reverso s= or =M-x reverso-synonyms= to invoke the synonyms search.&lt;/p&gt; &#xA;&lt;p&gt;[[./img/synonyms-transient.png]]&lt;/p&gt; &#xA;&lt;p&gt;[[./img/synonyms-res.png]]&lt;/p&gt; &#xA;&lt;p&gt;The results may be split into sections by parts of speech if that is necessary.&lt;/p&gt; &#xA;&lt;p&gt;The section for each part of speech includes up to three sections:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Synonyms&lt;/li&gt; &#xA; &lt;li&gt;Examples&lt;/li&gt; &#xA; &lt;li&gt;Antonyms&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Grammar check Run =M-x reverso g= or =M-x reverso-grammar= to invoke the grammar check.&lt;/p&gt; &#xA;&lt;p&gt;[[./img/grammar-transient.png]]&lt;/p&gt; &#xA;&lt;p&gt;As of now, only English and French languages are available there.&lt;/p&gt; &#xA;&lt;p&gt;[[./img/grammar-res.png]]&lt;/p&gt; &#xA;&lt;p&gt;The results may include the following sections:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Source text&lt;/em&gt;, where errors are highlighted with =reverso-error-face=&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Corrected text&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Corrections&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Grammar check in buffer It may be handy to apply the grammar check to the current buffer, that is, without using another buffer to display the results. For that purpose, there is =M-x reverso b= or =M-x reverso-grammar-buffer=.&lt;/p&gt; &#xA;&lt;p&gt;[[./img/grammar-buffer-transient.png]]&lt;/p&gt; &#xA;&lt;p&gt;Running =e= there (or =M-x reverso-check-buffer=) uses the current buffer as input and displays any errors in finds with [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Overlays.html][overlays]]. If a region is selected, the check is limited to that region.&lt;/p&gt; &#xA;&lt;p&gt;There are a couple of caveats there. First, the service considers each linebreak as a new line, which is incompatible with [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Filling.html][filling text]], i.e. breaking it into lines of a specified width. The &#34;Remove linebreaks&#34; option (=l=) is a workaround for this.&lt;/p&gt; &#xA;&lt;p&gt;Second, the service usually freaks out with special syntax, for instance, Org Mode links.&lt;/p&gt; &#xA;&lt;p&gt;The third partly follows from the second, because the service usually finds errors in hidden parts of Org links. That is a problem because a completely hidden overlay may be somewhat hard to access. So either skip these errors or run =M-x org-toggle-link-display= in Org files beforehand.&lt;/p&gt; &#xA;&lt;p&gt;Finally (and this concerns all other methods as well), the API usually limits the size of the input. So if the service returns an error, try running the check on a smaller region of the buffer.&lt;/p&gt; &#xA;&lt;p&gt;[[./img/grammar-buffer-res.png]]&lt;/p&gt; &#xA;&lt;p&gt;When the cursor is on an error, the error is shown in the &#34;Information&#34; section.&lt;/p&gt; &#xA;&lt;p&gt;&#34;Fix error&#34; (=f= or =M-x reverso-check-fix-at-point=) opens a completion interface with possible fixes; &#34;Ignore error&#34; (=i= or =M-x reverso-check-ignore-error=) just removes the overlay and jumps to the next error.&lt;/p&gt; &#xA;&lt;p&gt;&#34;Previous error&#34; (=p= or =M-x reverso-check-prev-error=), &#34;Next error&#34; (=n= or =M-x reverso-check-next-error=), &#34;First error&#34; (=P= or =M-x reverso-check-first-error=) and &#34;Last error&#34; (=L= or =M-x reverso-check-last-error=) serve to navigate the error list.&lt;/p&gt; &#xA;&lt;p&gt;&#34;Clear&#34; (=c= or =M-x reverso-clear=) removes error overlays. If a region is selected, remove overlays only in that region; otherwise, remove them from the entire buffer.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Caveats Before we go any further, here are some general caveats to be aware of.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;First, the package is using a reverse-engineered API, so all the obvious consequences apply. Although this service has been used in this way for some time already.&lt;/p&gt; &#xA;&lt;p&gt;Second, the cap on the input size was already mentioned. The obvious workaround is running the command on a region of lesser size.&lt;/p&gt; &#xA;&lt;p&gt;Third, there are reports that Reverso dispatches &lt;em&gt;bans by IP&lt;/em&gt; to particularly zealous users, so watch out for that if you are doing a lot of automated queries. This is also the reason why I didn&#39;t implement running one command on multiple consequential regions.&lt;/p&gt; &#xA;&lt;p&gt;Fourth, be careful with what you send to the service. Don&#39;t accidentally send something confidential (like a password) or anything that can be used against you in some other way. Although the service is [[https://www.reverso.net/privacy.aspx?lang=EN][GDPR-compliant on paper]], there&#39;s no way for us to actually verify that.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Customization Run =M-x customize-group reverso= to see the available parameters. Here are some.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you don&#39;t need all 17 languages, you can set the =reverso-languages= variable to limit the list: #+begin_src emacs-lisp (setq reverso-languages &#39;(english german russian)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If the length of =reverso-languages= is greater than =reverso-language-completing-read-threshold=, switching a language in transient buffers will invoke =completing-read= (i.e. minibuffer completion). Otherwise, switching will just switch to the next one.&lt;/p&gt; &#xA;&lt;p&gt;=reverso-max-display-lines-in-input= controls how many lines can be displayed in the input section of a transient buffer.&lt;/p&gt; &#xA;&lt;p&gt;The available faces:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=reverso-highlight-face=&lt;/li&gt; &#xA; &lt;li&gt;=reverso-error-face=&lt;/li&gt; &#xA; &lt;li&gt;=reverso-heading-face=&lt;/li&gt; &#xA; &lt;li&gt;=reverso-keyword-face=&lt;/li&gt; &#xA; &lt;li&gt;=reverso-definition-face= are inherited from the faces of =transient.el= and =basic-faces= to look nice.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Elisp API In case you want to do something in Emacs Lisp, there are 4 main functions that call the Reverso API:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=reverso--translate=&lt;/li&gt; &#xA; &lt;li&gt;=reverso--get-context=&lt;/li&gt; &#xA; &lt;li&gt;=reverso--get-grammar=&lt;/li&gt; &#xA; &lt;li&gt;=reverso--get-context=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Take a look at docstrings for the output format description.&lt;/p&gt; &#xA;&lt;p&gt;Every function is asynchronous, and the results are returned via a callback.&lt;/p&gt; &#xA;&lt;p&gt;Reverso occasionally changes its list of available languages and the compatibility matrix, so if you change any of these, run =reverso-verify-settings= to check for errors.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alternatives and observations One translation service everyone is familiar with is [[https://translate.google.com/][Google Translate]], so of course, there&#39;s an [[https://github.com/atykhonov/google-translate][Emacs client]] for it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The [[https://github.com/emacs-grammarly][emacs-grammarly]] package series provides the Elisp API for [[https://www.grammarly.com/][Grammarly]] (a grammar checking service) and a bunch of frontends for it. Unlike Reverso, Grammarly has an official API (so you don&#39;t risk getting an IP ban), and the allowed input size is much greater.&lt;/p&gt; &#xA;&lt;p&gt;Moreover, Grammarly is less bothered by Org and Markdown syntax, although it still doesn&#39;t like inline code blocks. Grammarly generally seems to be better at grammar-checking than Reverso, especially when it comes to rephrasing wordy sentences and punctiation. However, Grammarly also gives more false positives.&lt;/p&gt; &#xA;&lt;p&gt;Another notable grammar-checking solution is [[https://languagetool.org/][LanguageTool]], which you can [[https://dev.languagetool.org/http-server][run offline]] and use with [[https://github.com/mhayashi1120/Emacs-langtool][Emacs package]]. This one has the obvious advantage of having no limits on usage and not sending your data to a 3rd party server you can&#39;t control. But it still doesn&#39;t like markup syntaxes.&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/valentjn/ltex-ls][LTeX LS]] is a LanguageTool-based language server, designed specifically to work with markup files like Org, Markdown, LaTeX, and a bunch of others.&lt;/p&gt; &#xA;&lt;p&gt;The [[https://www.npmjs.com/package/reverso-api][reverso-api]] npm package implements the same commands in JavaScript. It also provided invaluable information for creating this package.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacscollective/packed</title>
    <updated>2022-09-07T01:33:06Z</updated>
    <id>tag:github.com,2022-09-07:/emacscollective/packed</id>
    <link href="https://github.com/emacscollective/packed" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs package utilities&lt;/p&gt;&lt;hr&gt;&lt;p&gt;** Package manager agnostic Emacs Lisp package utilities&lt;/p&gt; &#xA;&lt;p&gt;Packed provides some package manager agnostic utilities to work with Emacs Lisp packages. As far as Packed is concerned packages are collections of Emacs Lisp libraries that are stored in a dedicated directory such as a Git repository. And libraries are Emacs Lisp files that provide the correct feature (matching the filename).&lt;/p&gt; &#xA;&lt;p&gt;Where a package manager might depend on metadata, Packed instead uses some heuristics to get the same information — that is slower and might also fail at times but makes it unnecessary to maintain package recipes.&lt;/p&gt;</summary>
  </entry>
</feed>