<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-01T01:33:08Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>positron-solutions/elisp-repo-kit</title>
    <updated>2023-01-01T01:33:08Z</updated>
    <id>tag:github.com,2023-01-01:/positron-solutions/elisp-repo-kit</id>
    <link href="https://github.com/positron-solutions/elisp-repo-kit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs Lisp package for creating an Emacs Lisp Github repo with CI&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Elisp Repo Kit (ERK)&lt;/p&gt; &#xA;&lt;p&gt;#+HTML: &lt;a href=&#34;https://melpa.org/#/erk&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/erk-badge.svg?sanitize=true&#34; alt=&#34;melpa package&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/erk&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/erk-badge.svg?sanitize=true&#34; alt=&#34;melpa stable package&#34;&gt;&lt;/a&gt; #+HTML: &lt;a href=&#34;https://github.com/positron-solutions/elisp-repo-kit/actions/?workflow=CI&#34;&gt;&lt;img src=&#34;https://github.com/positron-solutions/elisp-repo-kit/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI workflow status&#34;&gt;&lt;/a&gt; #+HTML: &lt;a href=&#34;https://github.com/positron-solutions/elisp-repo-kit/actions/?workflow=Developer+Certificate+of+Origin&#34;&gt;&lt;img src=&#34;https://github.com/positron-solutions/elisp-repo-kit/actions/workflows/dco.yml/badge.svg?sanitize=true&#34; alt=&#34;DCO Check&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository is a kit to start a new elisp package repository on GitHub. The package contained has commands to streamline elisp development.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Quickly set up an Emacs Lisp repository on GitHub with:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An [[https://www.youtube.com/watch?v=RQK_DaaX34Q&amp;amp;list=PLEoMzSkcN8oPQtn7FQEF3D7sroZbXuPZ7][elisp]] package&lt;/li&gt; &#xA; &lt;li&gt;CI with [[https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs][GitHub Actions]], configured for Darwin (MacOS) and Linux&lt;/li&gt; &#xA; &lt;li&gt;[[https://nixos.org/#examples][Nix]] environment for obtaining dependencies or reproducibly developing CI locally&lt;/li&gt; &#xA; &lt;li&gt;Licensing, [[https://developercertificate.org/][DCO]], DCO sign-off checks, PR template and [[./CONTRIBUTING.org][CONTRIBUTING]] instructions&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/melpa/melpa][MELPA]] publishing compatible&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;To get started:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Install the package and run =erk-new=, provide a directory, and answer all the questions.&lt;/p&gt; &#xA;&lt;p&gt;** Install ERK&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(use-package erk) ; vanilla&#xA;&#xA;;; using elpaca&#xA;(elpaca-use-package&#xA; (erk :host github&#xA;      :repo &#34;positron-solutions/elisp-repo-kit&#34;))&#xA;&#xA;;; straight without `straight-use-package-by-default&#39;&#xA;(straight-use-package &#39;(erk :type git :host github&#xA;                            :repo &#34;positron-solutions/elisp-repo-kit&#34;))&#xA;&#xA;;; straight with `straight-use-package-by-default&#39; t&#xA;(use-package erk&#xA;  :straight&#xA;  (erk :type git :host github :repo &#34;positron-solutions/elisp-repo-kit&#34;))&#xA;&#xA;;; or use melpa, manual load-path &amp;amp; require, you brave yak shaver&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;=erk-new= will ask for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Root directory you want to clone to&lt;/li&gt; &#xA; &lt;li&gt;Package name&lt;/li&gt; &#xA; &lt;li&gt;Package prefix&lt;/li&gt; &#xA; &lt;li&gt;Author name&lt;/li&gt; &#xA; &lt;li&gt;GitHub user or organization&lt;/li&gt; &#xA; &lt;li&gt;Email address&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The =erk-new= calls =erk-rename-relicense= to rename all of the files, string replace names, and re-license to GPL3. Now just follow the steps in [[#finish-setting-up-your-new-github-repo][finish setting up]] Have fun!&lt;/p&gt; &#xA;&lt;p&gt;*** Manual cloning&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;The standalone command, =erk-clone= will clone without renaming.&#xA;&#xA;This repo is also a [[https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template][template repository]], so you can fork without forking&#xA;(Bruce Lee).&#xA;&#xA;If you create via template or clone manually, it&#39;s presumed you know what&#xA;you&#39;re doing at that point.  Call =erk-rename= on its own to rename&#xA;in these cases.&#xA;&#xA;There are some customize options that cause the renaming to be transitively&#xA;consistent.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Manually Add Just CI&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copy the .github folder and the contributing guide to your package.  Set up&#xA;your secrets for Cachix. Read the CI customization section.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contents :PROPERTIES: :TOC: :include siblings :ignore this :END: :CONTENTS:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#using-erk-for-development][Using ERK for development]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#run-tests][Run tests]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#loading-and-re-loading-your-package][Loading and re-loading your package]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#duplicating-ci-locally][Duplicating CI Locally]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#finish-setting-up-your-new-github-repo][Finish setting up your new GitHub repo]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#optional-steps][Optional Steps]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#overview-of-file-contents-and-structure][Overview of file contents and structure]]&lt;/li&gt; &#xA; &lt;li&gt;[[#customizing-ci][Customizing CI]]&lt;/li&gt; &#xA; &lt;li&gt;[[#licensing-developer-certificate-of-origin][Licensing, Developer Certificate of Origin]]&lt;/li&gt; &#xA; &lt;li&gt;[[#publishing-to-melpa][Publishing to MELPA]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#creating-the-recipe][Creating the recipe]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#testing-package-build][Testing package build]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#testing-stable-package-build][Testing stable package build]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#melpa-lints][MELPA Lints]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#maintaining-nixpkgs-versions][Maintaining nixpkgs versions]]&lt;/li&gt; &#xA; &lt;li&gt;[[#package-scope-and-relation-to-other-work][Package scope and relation to other work]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#dependency-management][Dependency Management]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#discovering-and-running-tests--lints][Discovering and Running Tests &amp;amp; Lints]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#comparisons][Comparisons]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#contributing][Contributing]]&lt;/li&gt; &#xA; &lt;li&gt;[[#footnote-on-fsf-and-emacs-core-licensing][Footnote on FSF and Emacs Core Licensing]]&lt;/li&gt; &#xA; &lt;li&gt;[[#shout-outs][Shout-outs]] :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Using ERK for development&lt;/p&gt; &lt;p&gt;Elisp repo kit contains some convenience functions to reload your package and to discover and run ert tests. These shortcuts just make common cases faster.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Run tests&lt;/p&gt; &#xA;&lt;p&gt;Run =erk-ert-project= within your project. The tests will be discovered, rebuilt &amp;amp; reloaded if necessary, and run. There are a few other commands to augment the [[https://www.gnu.org/software/emacs/manual/html_node/ert/][ert]] package.&lt;/p&gt; &#xA;&lt;p&gt;** Loading and re-loading your package&lt;/p&gt; &#xA;&lt;p&gt;Run =erk-reload-project-package= in one of your project files. The features will be recompiled and reloaded.&lt;/p&gt; &#xA;&lt;p&gt;The =erk-reload-project-tests= is the complementary command for tests.&lt;/p&gt; &#xA;&lt;p&gt;** Duplicating CI Locally&lt;/p&gt; &#xA;&lt;p&gt;The CI configuration is all stored in [[.github/][.github]]. Usually you will want development instructions in your new repository. The [[./CONTRIBUTING.org][CONTRIBUTING]] guide contains instructions to reproduce the CI behavior.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Finish setting up your new GitHub repo&lt;/p&gt; &lt;p&gt;You can copy this checklist to your org agenda files:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;p&gt;Create a repository (from [[#Install erk][install]] instructions)&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;p&gt;Create an empty GitHub repository and check the git remote configuration&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;p&gt;Set up your git commit signing (and verification so that it&#39;s obvious) &lt;em&gt;and&lt;/em&gt; [[#sign-off][sign-off]] so that it will be [[#Footnote-on-FSF-and-Emacs-Core-Licensing][straightforward]] for for FSF to pull in your changes if they later change to DCO instead of copyright assignment.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;p&gt;Sign up for [[https://app.cachix.org/][cachix]] and, create a binary cache with API tokens and public read access&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;p&gt;Add repository secrets necessary for your GitHub actions =CACHIX_AUTH_TOKEN= and =CACHIX_CACHE_NAME= (settings -&amp;gt; secrets -&amp;gt; new repository secret)&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;p&gt;Enable actions and add the following actions to your allowed actions list:&lt;/p&gt; &lt;p&gt;#+begin_src&lt;/p&gt; &lt;p&gt;actions/checkout@v3.2.0, cachix/cachix-action@v12, cachix/install-nix-action@v18, actions/setup-python@v4,&lt;/p&gt; &lt;p&gt;#+end_src&lt;/p&gt; &lt;p&gt;&lt;em&gt;Note&lt;/em&gt;, Python is used to run a DCO check script, nothing more.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;p&gt;Get your package working, pushed, actions run, and CI badges all green&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;p&gt;[[#Publishing-to-melpa][Publish]] to MELPA&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;p&gt;Make a post on [[https://old.reddit.com/r/emacs/][reddit]] and [[https://emacs.ch/][mastodon]] about your new package&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Optional Steps&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Install =org-make-toc= for the automatic TOC generation in this org document to work.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Branch protect and enable check requirements for your default branch (usually master). Merge commits, verified only, and no force push are recommended settings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Enable requiring contributors to sign-off on web-based commits&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; For security of your Cachix secrets and any other secrets you may someday add, require Actions approval for all outside contributors and leave repository permissions at read-only&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Cachix is somewhat optional. It&#39;s free for open-source projects. It&#39;s about as easy to sign up and generate the token as to remove the step from the GitHub actions, so you won&#39;t save much time by avoiding it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;If you opt out of cachix or any other binary cache, you will definitely want to turn off tests for =emacsGit= etc because the build times are about 30min-1hr per run when a fresh Emacs must be built.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Overview of file contents and structure&lt;/p&gt; &lt;p&gt;/After cloning and renaming,/ you will have a file tree like this:&lt;/p&gt; &lt;p&gt;#+begin_src shell&lt;/p&gt; &lt;p&gt;├── .gitignore # ignores for byte compiles, autoloads etc │ ├── README.org # this file ├── CONTRIBUTING.org # typical instructions for development ├── COPYING # a GPL3 license ├── DCO # Developer Certificate of Origin │ ├── .github │ ├── .envrc # direnv integration with &lt;code&gt;nix develop&lt;/code&gt; │ ├── flake.nix # dependencies for this project │ ├── flake.lock # version controlled lock of flake.nix input versions │ ├── run-shim.el # elisp script with test &amp;amp; lint routines │ ├── pull_request_template.md # reminders for PR contributors │ └── workflows │ ├── ci.yml # workflow for lints and tests │ └── dco.yml # workflow to check DCO sign-offs │ ├── lisp │ └── erk.el # the package │ └── test └── erk-test.el # ERT unit tests&lt;/p&gt; &lt;p&gt;#+end_src&lt;/p&gt; &lt;p&gt;You can use either a multi-file or flat layout for lisp. Just name test files &lt;del&gt;something-test.el&lt;/del&gt; and keep all lisp files in root, &lt;del&gt;/lisp&lt;/del&gt; or &lt;del&gt;/test&lt;/del&gt; directories.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Customizing CI&lt;/p&gt; &lt;p&gt;The [[.github/run-shim.el][run-shim.el]] script is just provides a CLI interface for adding commands in the [[.github/workflows/ci.yml][ci.yml]] CI declaration. Each action step just loads the shell, declared in the [[.github/flake.nix][flake.nix]] and then runs the shim in Emacs. The shim consumes the CLI command arguments, so you can parameterize the invocations that way.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If you need extra elisp dependencies during CI, add them to the =epkgs= list in the flake.nix.&lt;/li&gt; &#xA;   &lt;li&gt;If you need extra 3rd party dependencies, add them to =packages= in the call to =mkShell=.&lt;/li&gt; &#xA;   &lt;li&gt;To invoke different elisp operations, add / modify the commands in [[.github/run-shim.el][run-shim.el]].&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;There&#39;s more information in [[CONTRIBUTING.org][CONTRIBUTING]] about running commands locally. You will want this information in your new repository.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Licensing, Developer Certificate of Origin&lt;/p&gt; &lt;p&gt;This template project is distributed with the MIT license. =erk-new= will also run =erk-rename-relicense=, which will automatically switch to the GPL3 license. &lt;em&gt;The MIT license allows re-licensing, and so this change is compatible.&lt;/em&gt; If you accept non-trivial changes to your project, it will be very hard to change to the GPL3 later, so consider this choice.&lt;/p&gt; &lt;p&gt;The new repository will also come with DCO sign-off checking on PR&#39;s. The instructions are in the [[./CONTRIBUTING.org][CONTRIBUTING]] guide. A DCO sign-off policy will give your project a clear attestation of sufficient direct or transitive authority from each contributor to submit changes under the terms of your project&#39;s license. This can only improve your legal protection from incidentally handling copyrighted code.&lt;/p&gt; &lt;p&gt;The DCO choice in this repository is also meant to encourage &amp;amp; push stodgy organizations whose responsibility it was to invent better processes towards lower friction paths to contribute code. If you fail to implement the DCO sign-off scheme, there is less hope that the FSF will someday independently merge changes that accumulate in your package because there will not be a .&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Publishing to MELPA&lt;/p&gt; &lt;p&gt;If you have green CI, you have already passed many requirements of publishing a MELPA package. &lt;em&gt;You still need to build your package and verify your recipe.&lt;/em&gt; You are going to clone melpa in order to make your PR. You can use the clone to verify the recipe.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Creating the recipe&lt;/p&gt; &#xA;&lt;p&gt;Fork MELPA personally (not for organization) and clone it to wherever you keep your upstreams. It&#39;s a good idea to separate upstreams from projects you actively maintain so you can see and delete upstreams when not in use.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; mkdir -p upstream&#xA; cd upstream&#xA; git clone git@github.com:$GITHUB_USER/melpa.git  # replace $GITHUB_USER&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;Install package-build&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (use-package package-build) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;=package-build-create-recipe= will give you something like:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (erk :fetcher github :repo &#34;positron-solutions/elisp-repo-kit&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The following template can be filled in and pull-requested to MELPA to publish. You don&#39;t need to touch &lt;del&gt;:files&lt;/del&gt;. The &lt;del&gt;commit&lt;/del&gt; and &lt;del&gt;branch&lt;/del&gt; are optional depending on how you version / develop / tag your releases.&lt;/p&gt; &#xA;&lt;p&gt;Copy the recipe into =recipes/erk= inside your MELPA clone.&lt;/p&gt; &#xA;&lt;p&gt;** Testing package build&lt;/p&gt; &#xA;&lt;p&gt;Inside the MELPA clone root:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; # Builds the package&#xA; make recipes/erk&#xA; # Test sandbox installation (will affect ~/.emacs.d/elpa  So much for sandbox ¯\_(ツ)_/¯&#xA; EMACS_COMMAND=$(which emacs) make sandbox INSTALL=erk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Testing stable package build&lt;/p&gt; &#xA;&lt;p&gt;You need a tag on your default (usually master) branch of your repo, =positron-solutions/elisp-repo-kit=. Use =git tag -S v0.1.0= and =git push origin v0.1.0=. You can also just create a release in the GitHub interface.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; # Test stable builds against your tags&#xA; STABLE=t make recipes/erk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;** MELPA Lints&lt;/p&gt; &#xA;&lt;p&gt;Lastly, install [[https://github.com/riscy/melpazoid][melpazoid]] and call =melpazoid= on your main feature. It does some additional lints. You may need to install =package-lint= if you don&#39;t have it. It&#39;s not declared in melpazoid&#39;s requirements. Getting the package in Nix is not easy yet since melpazoid is not yet on Melpa.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (straight-use-package&#xA;  &#39;(melpazoid :type git :host github :repo &#34;riscy/melpazoid&#34; :files (&#34;melpazoid/melpazoid.el&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;If everything works, you are ready to make a pull request to MELPA. Push your changes and check all the boxes in the PR template except the one that requires you to read the instructions.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Maintaining nixpkgs versions&lt;/p&gt; &lt;p&gt;Nixpkgs has a new release about every six months. You can check their [[https://github.com/NixOS/nixpkgs/branches][branches]] and [[https://github.com/NixOS/nixpkgs/tags][tags]] to see what&#39;s current. To get updated dependencies from MELPA, it&#39;s necessary to update the emacs-overlay with =nix flake lock --update-input emacs-overlay=. You can also specify revs and branches if you need to roll back. There is a make shortcut: =make flake-update= MacOS tends to get a little less test emphasis, and so =nixpkgs-darwin-&#xA;   &lt;version&gt;&#xA;    = branches exist and are required to pass more Darwin tests before merging. This is more stable if you are on MacOS. =nixpkgs-unstable= or =master= are your other less common options.&#xA;   &lt;/version&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Package scope and relation to other work&lt;/p&gt; &lt;p&gt;There are two functional goals of this repository:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Automate the annoying work necessary to set up a new repository&lt;/li&gt; &#xA;   &lt;li&gt;Streamline common elisp development workflows&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Commands within this package will focus on cleaner integration of the tests and lints with Emacs. There has been a lot of work in this area, but much of it is tangled with dependency management and sandbox creation. Much of it is done in languages other than elisp and focused on non-interactive workflows with no interactive integration on top.&lt;/p&gt; &lt;p&gt;Providing close to out-of-box CI is a big focus. By making it easier to qualify changes from other users, it becomes less burdonsome to maintain software, and by extension, less burdensom to publish and create software. The effect is to drive creation of elisp in a way that can accelerate the flow of elisp into Emacs itself.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Dependency Management&lt;/p&gt; &#xA;&lt;p&gt;This repository uses pure dependency management and then levarages it to provide dependencies for development and CI environments. The resulting user experience is built around CI for reproducibility and interactive testing for development speed.&lt;/p&gt; &#xA;&lt;p&gt;Because most elisp dependencies can be obtained without extensive system dependency management, many tools for testing Emacs packages provide dependency management and loading those dependencies into a fresh Emacs instance. This aligns well with ad-hoc sandboxed local testing. This was fine in the old days of impure dependency management and dirty environments.&lt;/p&gt; &#xA;&lt;p&gt;The [[https://github.com/nix-community/emacs-overlay][Emacs Nix Overlay]] and Emacs support within nixpkgs make it possible to stating and obtaining elisp dependencies in a completely pure way. Non-elisp dependencies are trivially provided form nixpkgs. Nix is extremely reliable at dependency management, and it is no surprise that much complexity is normalized away by just the basic behavior model of Nix. In addition, &lt;em&gt;if your project needs or includes additional binary dependencies or modules&lt;/em&gt;, Nix is an excellent way to provide them to CI and users.&lt;/p&gt; &#xA;&lt;p&gt;** Discovering and Running Tests &amp;amp; Lints&lt;/p&gt; &#xA;&lt;p&gt;During development, the commands provided under the =erk-= prefix make it more convenient to reload your package and test features. You can run the ert tests for a project while working on multiple packages.&lt;/p&gt; &#xA;&lt;p&gt;During CI, this repository uses an elisp shim for discovering and running tests. The commands within the package for convenience during development are not depeneded upon during CI.&lt;/p&gt; &#xA;&lt;p&gt;The CI actions obtain an environment with dependencies using Nix, so this can also be done locally using Nix, meaning re-creating environments is available to the user without leaning on CI.&lt;/p&gt; &#xA;&lt;p&gt;** Comparisons&lt;/p&gt; &#xA;&lt;p&gt;There are many comparisons available to understand the roles of similar tools and how they relate to each other.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/alphapapa/makem.sh#comparisons][makem.sh]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/doublep/eldev#see-also][Eldev]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/emacs-twist/nomake][nomake]] Is another project with Nix work&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[[https://github.com/purcell/nix-emacs-ci][nix-emacs-ci]] capture the work needed to provide a running Emacs to CI. Tools like [[https://github.com/doublep/eldev#continuous-integration][eldev]] and [[https://github.com/alphapapa/makem.sh/blob/master/test.yml][makem.sh]] have support for providing dependencies to that Emacs. The Nix flake [[./flake.nix][in this project]] describes both of these tasks. Makem and Eldev etc document Gihub workflows, but &lt;em&gt;the workflows in this repository are meant to be used out-of-the-box after cloning&lt;/em&gt;, although to be fair, there&#39;s more decisions than actual work.&lt;/p&gt; &#xA;&lt;p&gt;Nix-emacs-ci provides a lot of backwards-compatibility versions of Emacs. The nix-overlay is more forward looking, providing =emacsGit= and sometimes other upstream branches when a big feature like native compilation is in the pipeline. Nix-emacs-ci is also still using legacy Nix, without flakes. Flakes are just nicer and the way Nix is going.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Contributing&lt;/p&gt; &lt;p&gt;For turn-key contribution to the software ecosystem that keeps you moving, see the funding links.&lt;/p&gt; &lt;p&gt;For code-based contribution, first decide if you want to work on this repository or fork it to something entirely different.&lt;/p&gt; &lt;p&gt;The [[./CONTRIBUTING.org][CONTRIBUTING]] guide in this repo contains development instructions, including singing &amp;amp; sign-off configuration. You will usually want this file in your own repositories.&lt;/p&gt; &lt;p&gt;Non-exhaustive list of changes that are very welcome:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;More interactive integrations with high-value elisp development workflows&lt;/li&gt; &#xA;   &lt;li&gt;Running additional or better kinds of tests &amp;amp; lints&lt;/li&gt; &#xA;   &lt;li&gt;Fix bugs&lt;/li&gt; &#xA;   &lt;li&gt;Expose trivial options where a structural choice has limited them unnecessarily&lt;/li&gt; &#xA;   &lt;li&gt;Behave the same, but with a less complicated code&lt;/li&gt; &#xA;   &lt;li&gt;Guix or other pure dependency management support&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Changes will likely be rejected if it is aimed at:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Non-elisp interfaces meant for invocation outside of Emacs or with scripting implemented in a language besides elisp.&lt;/li&gt; &#xA;   &lt;li&gt;Managing dependencies outside of Nix (or other pure dependency management) expressions&lt;/li&gt; &#xA;   &lt;li&gt;CI infrastructure support for non-Actions infrastructure (which cannot be tested in this repo)&lt;/li&gt; &#xA;   &lt;li&gt;Backwards compatibility for Emacs two versions behind next release. Master, current stable release, and release - 1 are the only versions being supported&lt;/li&gt; &#xA;   &lt;li&gt;pre-flake Nix support&lt;/li&gt; &#xA;   &lt;li&gt;Guix support that interferes with Nix support&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Footnote on FSF and Emacs Core Licensing&lt;/p&gt; &lt;p&gt;Free Software Foundation (FSF) frequently requires copyright assignment on all code that goes into Emacs core. Many free software projects formerly requiring copyright assignment have since switched to using a Developer Certificate of Origin. DCO sign-off is a practice accepted by git, GCC, and the [[https://wiki.linuxfoundation.org/dco][Linux Kernel]].&lt;/p&gt; &lt;p&gt;Doing DCO sign-off is not the same as copyright assignment, and serves a slightly different purpose. DCO sign-off is an attestation from the submitter stating that they have sufficient direct or transitive authority make their submission under the terms of the license of the recieving project. Copyright assignment serves a more offensive role in the case of GPL non-compliance, giving FSF alone legal standing. If you don&#39;t care about FSF being able to sue people, the DCO should suffice.&lt;/p&gt; &lt;p&gt;Using the DCO &lt;em&gt;may&lt;/em&gt; make it easier for code in your project to be included in Emacs core later. &lt;em&gt;It is the intent of this choice to steer FSF towards DCO-like solutions in order to accelerate code flow into Emacs.&lt;/em&gt; Regardless of FSF&#39;s ongoing position on use of DCO&#39;s, by requiring DCO sign-off and GPG signature, you can be assured that changes submitted to a code base you control are strongly attested to be covered by the license you chose.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Shout-outs&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[https://github.com/alphapapa][alphapapa]] for being super prolific at everything, including package writing, documentation, and activity on various social platforms&lt;/li&gt; &#xA;   &lt;li&gt;[[https://github.com/adisbladis][adisbladis]] for the Nix overlay that makes the CI and local development so nice&lt;/li&gt; &#xA;   &lt;li&gt;[[https://github.com/NobbZ][NobbZ]] for being all over the Nix &amp;amp; Emacs interwebs&lt;/li&gt; &#xA;   &lt;li&gt;[[https://www.fsf.org/][FSF]] and all contributors to Emacs &amp;amp; packages for the Yak shaving club&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Local Variables:&lt;/h1&gt; &#xA;&lt;h1&gt;before-save-hook: (lambda () (when (require &#39;org-make-toc nil t) (org-make-toc)))&lt;/h1&gt; &#xA;&lt;h1&gt;org-make-toc-link-type-fn: org-make-toc--link-entry-github&lt;/h1&gt; &#xA;&lt;h1&gt;End:&lt;/h1&gt;</summary>
  </entry>
</feed>