<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-08T01:41:41Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rejeep/f.el</title>
    <updated>2022-07-08T01:41:41Z</updated>
    <id>tag:github.com,2022-07-08:/rejeep/f.el</id>
    <link href="https://github.com/rejeep/f.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Modern API for working with files and directories in Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;-&lt;em&gt;- mode: org -&lt;/em&gt;-&lt;/h1&gt; &#xA;&lt;p&gt;#+title: f.el&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/rejeep/f.el/actions/workflows/workflow.yml][file:https://github.com/rejeep/f.el/actions/workflows/workflow.yml/badge.svg]] [[https://coveralls.io/r/rejeep/f.el][file:https://img.shields.io/coveralls/rejeep/f.el.svg]] [[https://melpa.org/#/f][file:https://melpa.org/packages/f-badge.svg]] [[https://stable.melpa.org/#/f][file:https://stable.melpa.org/packages/f-badge.svg]]&lt;/p&gt; &#xA;&lt;p&gt;Much inspired by [[https://github.com/magnars][@magnars]]s excellent [[https://github.com/magnars/s.el][s.el]] and [[https://github.com/magnars/dash.el][dash.el]], [[https://github.com/rejeep/f.el][f.el]] is a modern API for working with files and directories in Emacs.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation :noexport: It’s available on [[https://melpa.org/#/f][Melpa]] and [[https://stable.melpa.org/#/f][Melpa Stable]]. #+begin_src text M-x package-install f #+end_src&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Or you can just dump &lt;del&gt;f.el&lt;/del&gt; in your load path somewhere.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Table of Contents :TOC_3_gh:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#contributing][Contributing]]&lt;/li&gt; &#xA; &lt;li&gt;[[#documentation-and-examples][Documentation and examples]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#paths][Paths]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-join][f-join]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-split][f-split]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-expand][f-expand]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-filename][f-filename]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-dirname][f-dirname]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-common-parent][f-common-parent]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-ext][f-ext]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-no-ext][f-no-ext]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-swap-ext][f-swap-ext]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-base][f-base]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-relative][f-relative]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-short][f-short]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-long][f-long]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-canonical][f-canonical]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-slash][f-slash]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-full][f-full]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-uniquify][f-uniquify]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-uniquify-alist][f-uniquify-alist]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#io][I/O]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-read-bytes][f-read-bytes]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-write-bytes][f-write-bytes]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-append-bytes][f-append-bytes]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-read-text][f-read-text]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-write-text][f-write-text]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-append-text][f-append-text]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#destructive][Destructive]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-mkdir][f-mkdir]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-mkdir-full-path][f-mkdir-full-path]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-delete][f-delete]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-symlink][f-symlink]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-move][f-move]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-copy][f-copy]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-copy-contents][f-copy-contents]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-touch][f-touch]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#predicates][Predicates]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-exists-p][f-exists-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-directory-p][f-directory-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-file-p][f-file-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-symlink-p][f-symlink-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-readable-p][f-readable-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-writable-p][f-writable-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-executable-p][f-executable-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-absolute-p][f-absolute-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-relative-p][f-relative-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-root-p][f-root-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-ext-p][f-ext-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-same-p][f-same-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-parent-of-p][f-parent-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-child-of-p][f-child-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-ancestor-of-p][f-ancestor-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-descendant-of-p][f-descendant-of-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-hidden-p][f-hidden-p]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-empty-p][f-empty-p]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#stats][Stats]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-size][f-size]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-depth][f-depth]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-change-time][f-change-time]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-modification-time][f-modification-time]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-access-time][f-access-time]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#misc][Misc]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#f-this-file][f-this-file]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-path-separator][f-path-separator]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-glob][f-glob]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-entries][f-entries]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-directories][f-directories]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-files][f-files]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-root][f-root]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-traverse-upwards][f-traverse-upwards]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#f-with-sandbox][f-with-sandbox]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#example][Example]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#using-standard-emacs-builtin-functions][Using standard Emacs builtin functions]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#using-fel][Using f.el]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Contributing Check [[file:./CONTRIBUTING.org]]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Documentation and examples ** Paths *** f-join #+begin_example (f-join &amp;amp;rest args)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Join ARGS to a single path.&lt;/p&gt; &#xA;&lt;p&gt;Be aware if one of the arguments is an absolute path, ‘f-join’ will discard all the preceeding arguments and make this absolute path the new root of the generated path. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-join &#34;path&#34;) ;; =&amp;gt; &#34;path&#34; (f-join &#34;path&#34; &#34;to&#34;) ;; =&amp;gt; &#34;path/to&#34; (f-join &#34;/&#34; &#34;path&#34; &#34;to&#34; &#34;heaven&#34;) ;; =&amp;gt; &#34;/path/to/heaven&#34; (f-join &#34;path&#34; &#34;/to&#34; &#34;file&#34;) ;; =&amp;gt; &#34;/to/file&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-split #+begin_example (f-split path)&lt;/p&gt; &#xA;&lt;p&gt;Split PATH and return list containing parts. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-split &#34;path&#34;) ;; =&amp;gt; &#39;(&#34;path&#34;) (f-split &#34;path/to&#34;) ;; =&amp;gt; &#39;(&#34;path&#34; &#34;to&#34;) (f-split &#34;/path/to/heaven&#34;) ;; =&amp;gt; &#39;(&#34;/&#34; &#34;path&#34; &#34;to&#34; &#34;heaven&#34;) (f-split &#34;&lt;del&gt;/back/to/earth&#34;) ;; =&amp;gt; &#39;(&#34;&lt;/del&gt;&#34; &#34;back&#34; &#34;to&#34; &#34;earth&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-expand #+begin_example (f-expand path &amp;amp;optional dir)&lt;/p&gt; &#xA;&lt;p&gt;Expand PATH relative to DIR (or ‘default-directory’). PATH and DIR can be either a directory names or directory file names. Return a directory name if PATH is a directory name, and a directory file name otherwise. File name handlers are ignored. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-expand &#34;name&#34;) ;; =&amp;gt; &#34;/default/directory/name&#34; (f-expand &#34;name&#34; &#34;other/directory&#34;) ;; =&amp;gt; &#34;other/directory/name&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-filename #+begin_example (f-filename path)&lt;/p&gt; &#xA;&lt;p&gt;Return the name of PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-filename &#34;path/to/file.ext&#34;) ;; =&amp;gt; &#34;file.ext&#34; (f-filename &#34;path/to/directory&#34;) ;; =&amp;gt; &#34;directory&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-dirname #+begin_example (f-dirname path)&lt;/p&gt; &#xA;&lt;p&gt;Return the parent directory to PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-parent&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-dirname &#34;path/to/file.ext&#34;) ;; =&amp;gt; &#34;path/to&#34; (f-dirname &#34;path/to/directory&#34;) ;; =&amp;gt; &#34;path/to&#34; (f-dirname &#34;/&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-common-parent #+begin_example (f-common-parent paths)&lt;/p&gt; &#xA;&lt;p&gt;Return the deepest common parent directory of PATHS. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-common-parent &#39;(&#34;foo/bar/baz&#34; &#34;foo/bar/qux&#34; &#34;foo/bar/mux&#34;)) ;; =&amp;gt; &#34;foo/bar/&#34; (f-common-parent &#39;(&#34;/foo/bar/baz&#34; &#34;/foo/bar/qux&#34; &#34;/foo/bax/mux&#34;)) ;; =&amp;gt; &#34;/foo/&#34; (f-common-parent &#39;(&#34;foo/bar/baz&#34; &#34;quack/bar/qux&#34; &#34;lack/bar/mux&#34;)) ;; =&amp;gt; &#34;&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-ext #+begin_example (f-ext path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-name-extension&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-ext &#34;path/to/file&#34;) ;; =&amp;gt; nil (f-ext &#34;path/to/file.txt&#34;) ;; =&amp;gt; txt (f-ext &#34;path/to/file.txt.org&#34;) ;; =&amp;gt; org #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-no-ext #+begin_example (f-no-ext path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-name-sans-extension&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-no-ext &#34;path/to/file&#34;) ;; =&amp;gt; path/to/file (f-no-ext &#34;path/to/file.txt&#34;) ;; =&amp;gt; path/to/file (f-no-ext &#34;path/to/file.txt.org&#34;) ;; =&amp;gt; path/to/file.txt #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-swap-ext #+begin_example (f-swap-ext path ext)&lt;/p&gt; &#xA;&lt;p&gt;Return PATH but with EXT as the new extension. EXT must not be nil or empty. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-swap-ext &#34;path/to/file.ext&#34; &#34;org&#34;) ;; =&amp;gt; &#34;path/to/file.org&#34; (f-swap-ext &#34;path/to/file.ext&#34; &#34;&#34;) ;; =&amp;gt; error #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-base #+begin_example (f-base path)&lt;/p&gt; &#xA;&lt;p&gt;Return the name of PATH, excluding the extension of file. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-base &#34;path/to/file.ext&#34;) ;; =&amp;gt; &#34;file&#34; (f-base &#34;path/to/directory&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-relative #+begin_example (f-relative path &amp;amp;optional dir)&lt;/p&gt; &#xA;&lt;p&gt;Convert FILENAME to be relative to DIRECTORY (default: ‘default-directory’). This function returns a relative file name that is equivalent to FILENAME when used with that default directory as the default. If FILENAME is a relative file name, it will be interpreted as existing in ‘default-directory’. If FILENAME and DIRECTORY lie on different machines or on different drives on a DOS/Windows machine, it returns FILENAME in expanded form.&lt;/p&gt; &#xA;&lt;p&gt;(fn FILENAME &amp;amp;optional DIRECTORY) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-relative &#34;/some/path/relative/to/my/file.txt&#34; &#34;/some/path/&#34;) ;; =&amp;gt; relative/to/my/file.txt (f-relative &#34;/default/directory/my/file.txt&#34;) ;; =&amp;gt; my/file.txt #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-short #+begin_example (f-short path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;abbreviate-file-name&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-abbrev&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-short &#34;/Users/foo/Code/bar&#34;) ;; =&amp;gt; ~/Code/bar (f-short &#34;/path/to/Code/bar&#34;) ;; =&amp;gt; /path/to/Code/bar #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-long #+begin_example (f-long path)&lt;/p&gt; &#xA;&lt;p&gt;Return long version of PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-long &#34;~/Code/bar&#34;) ;; =&amp;gt; /Users/foo/Code/bar (f-long &#34;/path/to/Code/bar&#34;) ;; =&amp;gt; /path/to/Code/bar #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-canonical #+begin_example (f-canonical path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-truename&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-canonical &#34;/path/to/real/file&#34;) ;; =&amp;gt; /path/to/real/file (f-canonical &#34;/link/to/file&#34;) ;; =&amp;gt; /path/to/real/file #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-slash #+begin_example (f-slash path)&lt;/p&gt; &#xA;&lt;p&gt;Append slash to PATH unless one already.&lt;/p&gt; &#xA;&lt;p&gt;Some functions, such as ‘call-process’ requires there to be an ending slash. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-slash &#34;/path/to/file&#34;) ;; =&amp;gt; /path/to/file (f-slash &#34;/path/to/dir&#34;) ;; =&amp;gt; /path/to/dir/ (f-slash &#34;/path/to/dir/&#34;) ;; =&amp;gt; /path/to/dir/ #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-full #+begin_example (f-full path)&lt;/p&gt; &#xA;&lt;p&gt;Return absolute path to PATH, with ending slash. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-full &#34;&lt;del&gt;/path/to/file&#34;) ;; =&amp;gt; /home/foo/path/to/file (f-full &#34;&lt;/del&gt;/path/to/dir&#34;) ;; =&amp;gt; /home/foo/path/to/dir/ (f-full &#34;~/path/to/dir/&#34;) ;; =&amp;gt; /home/foo/path/to/dir/ #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-uniquify #+begin_example (f-uniquify paths)&lt;/p&gt; &#xA;&lt;p&gt;Return unique suffixes of FILES.&lt;/p&gt; &#xA;&lt;p&gt;This function expects no duplicate paths. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;(&#34;bar&#34; &#34;baz&#34; &#34;quux&#34;) (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;(&#34;foo/bar&#34; &#34;www/bar&#34; &#34;quux&#34;) (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/www/bar/quux&#34;)) ;; =&amp;gt; &#39;(&#34;foo/bar&#34; &#34;www/bar&#34; &#34;quux&#34;) (f-uniquify &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/home/www/bar&#34; &#34;/home/www/baz&#34; &#34;/var/foo&#34; &#34;/opt/foo/www/baz&#34;)) ;; =&amp;gt; &#39;(&#34;foo/bar&#34; &#34;www/bar&#34; &#34;foo/baz&#34; &#34;home/www/baz&#34; &#34;foo/www/baz&#34; &#34;foo&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-uniquify-alist #+begin_example (f-uniquify-alist paths)&lt;/p&gt; &#xA;&lt;p&gt;Return alist mapping FILES to unique suffixes of FILES.&lt;/p&gt; &#xA;&lt;p&gt;This function expects no duplicate paths. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;bar&#34;) (&#34;/foo/baz&#34; . &#34;baz&#34;) (&#34;/foo/quux&#34; . &#34;quux&#34;)) (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/foo/quux&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;foo/bar&#34;) (&#34;/www/bar&#34; . &#34;www/bar&#34;) (&#34;/foo/quux&#34; . &#34;quux&#34;)) (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/www/bar&#34; &#34;/www/bar/quux&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;foo/bar&#34;) (&#34;/www/bar&#34; . &#34;www/bar&#34;) (&#34;/www/bar/quux&#34; . &#34;quux&#34;)) (f-uniquify-alist &#39;(&#34;/foo/bar&#34; &#34;/foo/baz&#34; &#34;/home/www/bar&#34; &#34;/home/www/baz&#34; &#34;/var/foo&#34; &#34;/opt/foo/www/baz&#34;)) ;; =&amp;gt; &#39;((&#34;/foo/bar&#34; . &#34;foo/bar&#34;) (&#34;/home/www/bar&#34; . &#34;www/bar&#34;) (&#34;/foo/baz&#34; . &#34;foo/baz&#34;) (&#34;/home/www/baz&#34; . &#34;home/www/baz&#34;) (&#34;/opt/foo/www/baz&#34; . &#34;foo/www/baz&#34;) (&#34;/var/foo&#34; . &#34;foo&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** I/O *** f-read-bytes #+begin_example (f-read-bytes path)&lt;/p&gt; &#xA;&lt;p&gt;Read binary data from PATH.&lt;/p&gt; &#xA;&lt;p&gt;Return the binary data as unibyte string. The optional second and third arguments BEG and END specify what portion of the file to read. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-read-bytes &#34;path/to/binary/data&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-write-bytes #+begin_example (f-write-bytes data path)&lt;/p&gt; &#xA;&lt;p&gt;Write binary DATA to PATH.&lt;/p&gt; &#xA;&lt;p&gt;DATA is a unibyte string. PATH is a file name to write to. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-write-bytes (unibyte-string 72 101 108 108 111 32 119 111 114 108 100) &#34;path/to/binary/data&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-append-bytes #+begin_example (f-append-bytes text coding path)&lt;/p&gt; &#xA;&lt;p&gt;Append binary DATA to PATH.&lt;/p&gt; &#xA;&lt;p&gt;If PATH does not exist, it is created. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-append-bytes &#34;path/to/file&#34; (unibyte-string 72 101 108 108 111 32 119 111 114 108 100)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-read-text #+begin_example (f-read-text path &amp;amp;optional coding)&lt;/p&gt; &#xA;&lt;p&gt;Read text with PATH, using CODING.&lt;/p&gt; &#xA;&lt;p&gt;CODING defaults to ‘utf-8’.&lt;/p&gt; &#xA;&lt;p&gt;Return the decoded text as multibyte string. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-read&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-read-text &#34;path/to/file.txt&#34; &#39;utf-8) (f-read &#34;path/to/file.txt&#34; &#39;utf-8) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-write-text #+begin_example (f-write-text text coding path)&lt;/p&gt; &#xA;&lt;p&gt;Write TEXT with CODING to PATH.&lt;/p&gt; &#xA;&lt;p&gt;TEXT is a multibyte string. CODING is a coding system to encode TEXT with. PATH is a file name to write to. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-write&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-write-text &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) (f-write &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-append-text #+begin_example (f-append-text text coding path)&lt;/p&gt; &#xA;&lt;p&gt;Append TEXT with CODING to PATH.&lt;/p&gt; &#xA;&lt;p&gt;If PATH does not exist, it is created. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-append&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-append-text &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) (f-append &#34;Hello world&#34; &#39;utf-8 &#34;path/to/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Destructive *** f-mkdir #+begin_example (f-mkdir &amp;amp;rest dirs)&lt;/p&gt; &#xA;&lt;p&gt;Create directories DIRS.&lt;/p&gt; &#xA;&lt;p&gt;DIRS should be a successive list of directories forming together a full path. The easiest way to call this function with a fully formed path is using ‘f-split’ alongside it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(apply #’f-mkdir (f-split &#34;path/to/file&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Although it works sometimes, it is not recommended to use fully formed paths in the function. In this case, it is recommended to use ‘f-mkdir-full-path’ instead. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-mkdir &#34;dir&#34;) ;; creates /default/directory/dir (f-mkdir &#34;other&#34; &#34;dir&#34;) ;; creates /default/directory/other/dir (f-mkdir &#34;/&#34; &#34;some&#34; &#34;path&#34;) ;; creates /some/path (f-mkdir &#34;~&#34; &#34;yet&#34; &#34;another&#34; &#34;dir&#34;) ;; creates ~/yet/another/dir #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-mkdir-full-path #+begin_example (f-mkdir-full-path dir)&lt;/p&gt; &#xA;&lt;p&gt;Create DIR from a full path.&lt;/p&gt; &#xA;&lt;p&gt;This function is similar to ‘f-mkdir’ except it can accept a full path instead of requiring several successive directory names. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-mkdir-full-path &#34;dir&#34;) ;; creates /default/directory/dir (f-mkdir-full-path &#34;other/dir&#34;) ;; creates /default/directory/other/dir (f-mkdir-full-path &#34;/some/path&#34;) ;; creates /some/path (f-mkdir-full-path &#34;~/yet/another/dir&#34;) ;; creates ~/yet/another/dir #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-delete #+begin_example (f-delete path &amp;amp;optional force)&lt;/p&gt; &#xA;&lt;p&gt;Delete PATH, which can be file or directory.&lt;/p&gt; &#xA;&lt;p&gt;If FORCE is t, a directory will be deleted recursively. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-delete &#34;dir&#34;) (f-delete &#34;other/dir&#34; t) (f-delete &#34;path/to/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-symlink #+begin_example (f-symlink source path)&lt;/p&gt; &#xA;&lt;p&gt;Create a symlink to SOURCE from PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-symlink &#34;path/to/source&#34; &#34;path/to/link&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-move #+begin_example (f-move from to)&lt;/p&gt; &#xA;&lt;p&gt;Move or rename FROM to TO. If TO is a directory name, move FROM into TO. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-move &#34;path/to/file.txt&#34; &#34;new-file.txt&#34;) (f-move &#34;path/to/file.txt&#34; &#34;other/path&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-copy #+begin_example (f-copy from to)&lt;/p&gt; &#xA;&lt;p&gt;Copy file or directory FROM to TO. If FROM names a directory and TO is a directory name, copy FROM into TO as a subdirectory. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-copy &#34;path/to/file.txt&#34; &#34;new-file.txt&#34;) (f-copy &#34;path/to/dir&#34; &#34;other/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-copy-contents #+begin_example (f-copy-contents from to)&lt;/p&gt; &#xA;&lt;p&gt;Copy contents in directory FROM, to directory TO. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-copy-contents &#34;path/to/dir&#34; &#34;path/to/other/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-touch #+begin_example (f-touch path)&lt;/p&gt; &#xA;&lt;p&gt;Update PATH last modification date or create if it does not exist. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-touch &#34;path/to/existing/file.txt&#34;) (f-touch &#34;path/to/non/existing/file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Predicates *** f-exists-p #+begin_example (f-exists-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-exists-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-exists?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-exists-p &#34;path/to/file.txt&#34;) (f-exists-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-directory-p #+begin_example (f-directory-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-directory-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Aliases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;f-directory?&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-dir-p&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-dir?&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-directory-p &#34;path/to/file.txt&#34;) ;; =&amp;gt; nil (f-directory-p &#34;path/to/dir&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-file-p #+begin_example (f-file-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-regular-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-file?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-file-p &#34;path/to/file.txt&#34;) ;; =&amp;gt; t (f-file-p &#34;path/to/dir&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-symlink-p #+begin_example (f-symlink-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is symlink, false otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-symlink?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-symlink-p &#34;path/to/file.txt&#34;) ;; =&amp;gt; nil (f-symlink-p &#34;path/to/dir&#34;) ;; =&amp;gt; nil (f-symlink-p &#34;path/to/link&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-readable-p #+begin_example (f-readable-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-readable-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-readable?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-readable-p &#34;path/to/file.txt&#34;) (f-readable-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-writable-p #+begin_example (f-writable-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-writable-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-writable?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-writable-p &#34;path/to/file.txt&#34;) (f-writable-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-executable-p #+begin_example (f-executable-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-executable-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-executable?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-executable-p &#34;path/to/file.txt&#34;) (f-executable-p &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-absolute-p #+begin_example (f-absolute-p path) #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias of &lt;del&gt;file-name-absolute-p&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-absolute?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-absolute-p &#34;path/to/dir&#34;) ;; =&amp;gt; nil (f-absolute-p &#34;/full/path/to/dir&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-relative-p #+begin_example (f-relative-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is relative, false otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-relative?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-relative-p &#34;path/to/dir&#34;) ;; =&amp;gt; t (f-relative-p &#34;/full/path/to/dir&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-root-p #+begin_example (f-root-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is root directory, false otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-root?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-root-p &#34;/&#34;) ;; =&amp;gt; t (f-root-p &#34;/not/root&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-ext-p #+begin_example (f-ext-p path ext)&lt;/p&gt; &#xA;&lt;p&gt;Return t if extension of PATH is EXT, false otherwise.&lt;/p&gt; &#xA;&lt;p&gt;If EXT is nil or omitted, return t if PATH has any extension, false otherwise.&lt;/p&gt; &#xA;&lt;p&gt;The extension, in a file name, is the part that follows the last ’.’, excluding version numbers and backup suffixes. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-ext?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-ext-p &#34;path/to/file.el&#34; &#34;el&#34;) ;; =&amp;gt; t (f-ext-p &#34;path/to/file.el&#34; &#34;txt&#34;) ;; =&amp;gt; nil (f-ext-p &#34;path/to/file.el&#34;) ;; =&amp;gt; t (f-ext-p &#34;path/to/file&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-same-p #+begin_example (f-same-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A and PATH-B are references to same file. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Aliases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;f-same?&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-equal-p&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;f-equal?&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-same-p &#34;foo.txt&#34; &#34;foo.txt&#34;) ;; =&amp;gt; t (f-same-p &#34;/path/to/foo.txt&#34; &#34;/path/to/bar.txt&#34;) ;; =&amp;gt; nil (f-same-p &#34;foo/bar/../baz&#34; &#34;foo/baz&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-parent-of-p #+begin_example (f-parent-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is parent of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-parent-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-parent-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; t (f-parent-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil (f-parent-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-child-of-p #+begin_example (f-child-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is child of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-child-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-child-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; nil (f-child-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; t (f-child-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-ancestor-of-p #+begin_example (f-ancestor-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is ancestor of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-ancestor-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-ancestor-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; t (f-ancestor-of-p &#34;/path&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; t (f-ancestor-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil (f-ancestor-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-descendant-of-p #+begin_example (f-descendant-of-p path-a path-b)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH-A is desendant of PATH-B. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-descendant-of?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-descendant-of-p &#34;/path/to/dir&#34; &#34;/path/to&#34;) ;; =&amp;gt; t (f-descendant-of-p &#34;/path/to/dir&#34; &#34;/path&#34;) ;; =&amp;gt; t (f-descendant-of-p &#34;/path/to&#34; &#34;/path/to/dir&#34;) ;; =&amp;gt; nil (f-descendant-of-p &#34;/path/to&#34; &#34;/path/to&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-hidden-p #+begin_example (f-hidden-p path)&lt;/p&gt; &#xA;&lt;p&gt;Return t if PATH is hidden, nil otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-hidden?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-hidden-p &#34;/path/to/foo&#34;) ;; =&amp;gt; nil (f-hidden-p &#34;/path/to/.foo&#34;) ;; =&amp;gt; t #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-empty-p #+begin_example (f-empty-p path)&lt;/p&gt; &#xA;&lt;p&gt;If PATH is a file, return t if the file in PATH is empty, nil otherwise. If PATH is directory, return t if directory has no files, nil otherwise. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;Alias: &lt;del&gt;f-empty?&lt;/del&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-empty-p &#34;/path/to/empty-file&#34;) ;; =&amp;gt; t (f-empty-p &#34;/path/to/file-with-contents&#34;) ;; =&amp;gt; nil (f-empty-p &#34;/path/to/empty-dir/&#34;) ;; =&amp;gt; t (f-empty-p &#34;/path/to/dir-with-contents/&#34;) ;; =&amp;gt; nil #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Stats *** f-size #+begin_example (f-size path)&lt;/p&gt; &#xA;&lt;p&gt;Return size of PATH.&lt;/p&gt; &#xA;&lt;p&gt;If PATH is a file, return size of that file. If PATH is directory, return sum of all files in PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-size &#34;path/to/file.txt&#34;) (f-size &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-depth #+begin_example (f-depth path)&lt;/p&gt; &#xA;&lt;p&gt;Return the depth of PATH.&lt;/p&gt; &#xA;&lt;p&gt;At first, PATH is expanded with ‘f-expand’. Then the full path is used to detect the depth. ’/’ will be zero depth, ’/usr’ will be one depth. And so on. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-depth &#34;/&#34;) ;; 0 (f-depth &#34;/var/&#34;) ;; 1 (f-depth &#34;/usr/local/bin&#34;) ;; 3 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-change-time #+begin_example (f-change-time path)&lt;/p&gt; &#xA;&lt;p&gt;Return the last status change time of PATH.&lt;/p&gt; &#xA;&lt;p&gt;The status change time (ctime) of PATH in the same format as ‘current-time’. See ‘file-attributes’ for technical details. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-change-time &#34;path/to/file.txt&#34;) (f-change-time &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-modification-time #+begin_example (f-modification-time path)&lt;/p&gt; &#xA;&lt;p&gt;Return the last modification time of PATH.&lt;/p&gt; &#xA;&lt;p&gt;The modification time (mtime) of PATH in the same format as ‘current-time’. See ‘file-attributes’ for technical details. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-modification-time &#34;path/to/file.txt&#34;) (f-modification-time &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-access-time #+begin_example (f-access-time path)&lt;/p&gt; &#xA;&lt;p&gt;Return the last access time of PATH.&lt;/p&gt; &#xA;&lt;p&gt;The access time (atime) of PATH is in the same format as ‘current-time’. See ‘file-attributes’ for technical details. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-access-time &#34;path/to/file.txt&#34;) (f-access-time &#34;path/to/dir&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Misc *** f-this-file #+begin_example (f-this-file)&lt;/p&gt; &#xA;&lt;p&gt;Return path to this file. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-this-file) ;; =&amp;gt; /path/to/this/file #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-path-separator #+begin_example (f-path-separator)&lt;/p&gt; &#xA;&lt;p&gt;Return path separator. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-path-separator) ;; =&amp;gt; / #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-glob #+begin_example (f-glob pattern &amp;amp;optional path)&lt;/p&gt; &#xA;&lt;p&gt;Find PATTERN in PATH. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-glob &#34;path/to/&lt;em&gt;.el&#34;) (f-glob &#34;&lt;/em&gt;.el&#34; &#34;path/to&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-entries #+begin_example (f-entries path &amp;amp;optional fn recursive)&lt;/p&gt; &#xA;&lt;p&gt;Find all files and directories in PATH.&lt;/p&gt; &#xA;&lt;p&gt;FN - called for each found file and directory. If FN returns a thruthy value, file or directory will be included. RECURSIVE - Search for files and directories recursive. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-entries &#34;path/to/dir&#34;) (f-entries &#34;path/to/dir&#34; (lambda (file) (s-matches? &#34;test&#34; file))) (f-entries &#34;path/to/dir&#34; nil t) (f--entries &#34;path/to/dir&#34; (s-matches? &#34;test&#34; it)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-directories #+begin_example (f-directories path &amp;amp;optional fn recursive)&lt;/p&gt; &#xA;&lt;p&gt;Find all directories in PATH. See ‘f-entries’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-directories &#34;path/to/dir&#34;) (f-directories &#34;path/to/dir&#34; (lambda (dir) (equal (f-filename dir) &#34;test&#34;))) (f-directories &#34;path/to/dir&#34; nil t) (f--directories &#34;path/to/dir&#34; (equal (f-filename it) &#34;test&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-files #+begin_example (f-files path &amp;amp;optional fn recursive)&lt;/p&gt; &#xA;&lt;p&gt;Find all files in PATH. See ‘f-entries’. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-files &#34;path/to/dir&#34;) (f-files &#34;path/to/dir&#34; (lambda (file) (equal (f-ext file) &#34;el&#34;))) (f-files &#34;path/to/dir&#34; nil t) (f--files &#34;path/to/dir&#34; (equal (f-ext it) &#34;el&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-root #+begin_example (f-root)&lt;/p&gt; &#xA;&lt;p&gt;Return absolute root. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-root) ;; =&amp;gt; &#34;/&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-traverse-upwards #+begin_example (f-traverse-upwards fn &amp;amp;optional path)&lt;/p&gt; &#xA;&lt;p&gt;Traverse up as long as FN return nil, starting at PATH.&lt;/p&gt; &#xA;&lt;p&gt;If FN returns a non-nil value, the path sent as argument to FN is returned. If no function callback return a non-nil value, nil is returned. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-traverse-upwards (lambda (path) (f-exists? (f-expand &#34;.git&#34; path))) start-path)&lt;/p&gt; &#xA;&lt;p&gt;(f--traverse-upwards (f-exists? (f-expand &#34;.git&#34; it)) start-path) ;; same as above #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** f-with-sandbox #+begin_example (f-with-sandbox path-or-paths &amp;amp;rest body)&lt;/p&gt; &#xA;&lt;p&gt;Only allow PATH-OR-PATHS and descendants to be modified in BODY. #+end_example&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (f-with-sandbox foo-path (f-touch (f-expand &#34;foo&#34; foo-path))) (f-with-sandbox (list foo-path bar-path) (f-touch (f-expand &#34;foo&#34; foo-path)) (f-touch (f-expand &#34;bar&#34; bar-path))) (f-with-sandbox foo-path (f-touch (f-expand &#34;bar&#34; bar-path))) ;; &#34;Destructive operation outside sandbox&#34; #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here&#39;s an example of a function that finds the Git project root.&lt;/p&gt; &#xA;&lt;p&gt;** Using standard Emacs builtin functions #+begin_src emacs-lisp (defun find-git-root (&amp;amp;optional dir) (unless dir (setq dir (expand-file-name (file-name-directory (buffer-file-name))))) (let ((parent (expand-file-name &#34;..&#34; dir))) (unless (equal parent dir) (if (file-exists-p (expand-file-name &#34;.git&#34; dir)) dir (find-git-root parent))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Using f.el #+begin_src emacs-lisp (defun find-git-root (&amp;amp;optional dir) (interactive) (unless dir (setq dir (f-dirname (buffer-file-name)))) (let ((parent (f-parent dir))) (unless (f-root? parent) (if (f-exists? (f-expand &#34;.git&#34; dir)) dir (find-git-root parent))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Now, try writing it even simpler yourself. Hint, check out &lt;del&gt;f-traverse-upwards&lt;/del&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>politza/tablist</title>
    <updated>2022-07-08T01:41:41Z</updated>
    <id>tag:github.com,2022-07-08:/politza/tablist</id>
    <link href="https://github.com/politza/tablist" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Extended tabulated-list-mode&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Tablist&lt;/h1&gt; &#xA;&lt;p&gt;This package adds marks and filters to &lt;code&gt;tabulated-list-mode&lt;/code&gt;. It also puts a dired face on tabulated list buffers.&lt;/p&gt; &#xA;&lt;p&gt;It can be used by deriving from &lt;code&gt;tablist-mode&lt;/code&gt;, or with more limited features by enabling &lt;code&gt;tablist-minor-mode&lt;/code&gt; inside a &lt;code&gt;tabulated-list-mode&lt;/code&gt; buffer.&lt;/p&gt; &#xA;&lt;h1&gt;Tablist minor mode&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;keymap&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-mark-forward&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;m&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-unmark-backward&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;DEL&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-do-kill-lines&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;k&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-unmark-all-marks&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;U&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-unmark-forward&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;u&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-toggle-marks&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;t&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-sort&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;s&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-shrink-column&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;&amp;lt;&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-enlarge-column&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;&amp;gt;&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-quit&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;q&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-revert&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;G&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-export-csv&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c C-e&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Marks&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;keymap&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-change-marks&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;* c&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-unmark-all-marks&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;* !&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-mark-items-regexp&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;* r&lt;/kbd&gt; or &lt;kbd&gt;% m&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-mark-items-numeric&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;* n&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-mark-forward&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;* m&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Filters&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;keymap&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-pop-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ p&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-push-regexp-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ r&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-push-equal-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ =&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-push-numeric-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ n&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-negate-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ !&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-toggle-first-filter-logic&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ t&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-display-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ /&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-suspend-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ z&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-push-named-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ a&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-name-current-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ s&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-delete-named-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ D&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-deconstruct-named-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ d&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-edit-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ e&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-clear-filter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;/ C&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Tablist mode&lt;/h1&gt; &#xA;&lt;p&gt;Same bindings as &lt;code&gt;tablist-minor-mode&lt;/code&gt;, plus the following:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;keymap&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-flag-forward&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;d&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-find-entry&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;RET&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-find-entry&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;f&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-do-delete&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;D&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-do-copy&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-do-rename&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;R&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tablist-do-flagged-delete&lt;/td&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;x&lt;/kbd&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
  <entry>
    <title>erikbackman/mindre-theme</title>
    <updated>2022-07-08T01:41:41Z</updated>
    <id>tag:github.com,2022-07-08:/erikbackman/mindre-theme</id>
    <link href="https://github.com/erikbackman/mindre-theme" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Minimal and light theme for Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+html: &lt;img src=&#34;https://raw.githubusercontent.com/erikbackman/mindre-theme/assets/mindre-logo.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img alt=&#34;GNU Emacs&#34; src=&#34;https://github.com/erikbackman/erikbackman/raw/master/emacs.svg?raw=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/mindre-theme&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/mindre-theme-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Introduction When putting down ideas or solving problems on paper we seldom use a lot of colors, so why do we need our editor to look like a christmas tree?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Mindre (which is the Swedish word for &#34;less&#34;) tries to strike a good balance between usability and minimalism by almost being a monochrome theme but with a splash of color.&lt;/p&gt; &#xA;&lt;p&gt;I highly recommend using [[http://jonls.dk/redshift/][Redshift]] or something similar to adjust the color temperature of your screen. Personally I have mine set to 3200K for both day and night (default is 3700K and 5500K respectively).&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;img src=&#34;https://raw.githubusercontent.com/erikbackman/mindre-theme/assets/mindre-screenshot.png&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation *** Using =package.el=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can install =mindre-theme= from [[https://melpa.org][MELPA]] using =package.el=&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src M-x package-refresh-contents M-x package-install RET mindre-theme RET #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Or with =use-package=: #+begin_src emacs-lisp (use-package mindre-theme :ensure :config (load-theme &#39;mindre t)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Directly from this repo&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (use-package mindre-theme :ensure :straight (:host github :repo &#34;erikbackman/mindre-theme&#34;) :config (load-theme &#39;mindre t)) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Customisations #+begin_src emacs-lisp (setq mindre-use-more-bold nil mindre-use-faded-lisp-parens t) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;+Frequently+ asked questions&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;What fonts are used in the logo/screenshots?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Sarasa Mono (It&#39;s basically Iosevka) and CMU Concrete&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Roadmap [0/2]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Palette override.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Higher contrast option.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>