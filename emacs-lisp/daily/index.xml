<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-03T01:33:06Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jdtsmith/ultra-scroll-mac</title>
    <updated>2023-12-03T01:33:06Z</updated>
    <id>tag:github.com,2023-12-03:/jdtsmith/ultra-scroll-mac</id>
    <link href="https://github.com/jdtsmith/ultra-scroll-mac" rel="alternate"></link>
    <summary type="html">&lt;p&gt;scroll emacs-mac like lightning&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: ultra-scroll-mac: scroll emacs-mac like lightning&lt;/p&gt; &#xA;&lt;p&gt;&lt;del&gt;ultra-scroll-mac&lt;/del&gt; is a smooth-scrolling package for [[https://bitbucket.org/mituharu/emacs-mac][emacs-mac]]. It provides highly optimized, pixel-precise smooth scrolling which can readily keep up with the /very/ high event rates of modern trackpads and high-precision wheel mice. You move your fingers, the page responds, instantly.&lt;/p&gt; &#xA;&lt;p&gt;Importantly, it can cleanly /scroll right across/ tall images and other jumbo lines -- a perennial problem with scrolling packages to date. As a bonus, it enables relatively smooth scrolling even with dumb third party mice.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Do you need this?&lt;/em&gt;&lt;br&gt; #+begin_quote Here&#39;s a test to try: open a big heavy-duty emacs buffer, full screen. While scrolling smoothly such that lines move across your window&#39;s height in about 5sec, /can you easily read the content you see/, without stopping? Is the text as clear scrolling down as it is going up? Now, try this exercise again with your browser -- I bet it&#39;s /very/ readable there. Shouldn&#39;t emacs be like this? If you scroll buffers with large images, this is also a good reason to give a try. #+end_quote&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compatibility and Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is only for the [[https://bitbucket.org/mituharu/emacs-mac][emacs-mac]] port. &lt;del&gt;M-x emacs-version&lt;/del&gt; should mention &lt;del&gt;Carbon&lt;/del&gt;, not &lt;del&gt;NS&lt;/del&gt;, and &lt;del&gt;window-system&lt;/del&gt; should be &lt;del&gt;mac&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To install, simply &lt;del&gt;git clone&lt;/del&gt; (or &lt;del&gt;package-vc-install&lt;/del&gt;) and:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (use-package ultra-scroll-mac :if (eq window-system &#39;mac) :load-path &#34;~/code/emacs/ultra-scroll-mac&#34; ; if you git clone&#39;d :init (setq scroll-conservatively 101) ; important for jumbo images :config (ultra-scroll-mac-mode 1)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Usage: just start scrolling :).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There is little to no configuration. If desired for use with dumb mice, the variable &lt;del&gt;ultra-scroll-mac-multiplier&lt;/del&gt; can be set to a number smaller or larger than &lt;del&gt;1.0&lt;/del&gt; to decrease/increase scrolling speed. Note that many fancier mice have drivers that /simulate/ trackpads, so this variable will have no effect on them.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Related packages and functionality&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;emacs-mac&#39;s own builtin &lt;del&gt;mac-mwheel-scroll&lt;/del&gt; :: This venerable code has been providing smooth scrolling on [[https://bitbucket.org/mituharu/emacs-mac/][emacs-mac]] by default for nearly a decade.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;pixel-scroll-precision-mode&lt;/del&gt; :: New, fast pixel scrolling by Po Lu, built in to Emacs as of v29.1 (see =pixel-scroll.el=). &lt;del&gt;ultra-scroll-mac&lt;/del&gt; was initially based on its design, but many elements have changed. The core scrolling functions have been contributed back upstream.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;pixel-scroll-mode&lt;/del&gt; :: A simpler line-by-line pixel scrolling mode, also found in =pixel-scroll.el=.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/io12/good-scroll.el][good-scroll]] :: An update to the simple &lt;del&gt;pixel-scroll-mode&lt;/del&gt; with variable speed.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/zk-phi/sublimity][sublimity]] :: Includes smooth scrolling based on sublime editor.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Questions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** What was the motivation behind this?&lt;/p&gt; &#xA;&lt;p&gt;Picture it: a fast new laptop and 5K monitor with a large heavy-duty, full-screen buffer in &lt;del&gt;python-ts-mode&lt;/del&gt;. Scrolling with a decent mouse is mostly OK, but pixel scrolling with the trackpad is just... /painful/. Repeated attempts to rationalize this fail, especially because it&#39;s notably worse in one direction than the other. Scrolling Emacs feels like moving through (light) molasses. No bueno.&lt;/p&gt; &#xA;&lt;p&gt;Checking into it, the smooth scroll event callback takes 15-20ms scrolling in one direction, and 3--5x longer in the other. Perfectly fine for normal mice which deliver a few scrolling events a second. /But trackpad scroll events are arriving every 15ms or less/! The code just couldn&#39;t keep up. Hence the molasses.&lt;/p&gt; &#xA;&lt;p&gt;I also wanted to be able to peruse image-rich documents without worrying about jumpy/loopy scrolling behavior. And my extra dumb mouse didn&#39;t work well either: small scrolls did nothing: you&#39;d have scroll pretty aggressively to get any movement at all.&lt;/p&gt; &#xA;&lt;p&gt;How hard could it be to fix this? And the adventure began...&lt;/p&gt; &#xA;&lt;p&gt;** Why is this emacs-mac only?&lt;/p&gt; &#xA;&lt;p&gt;Only the emacs-mac port exposes the full pixel-level scrolling event stream of trackpads (and fancy mice). This makes &lt;del&gt;ultra-scroll-mac&lt;/del&gt; much simpler than packages which have to simulate this.&lt;/p&gt; &#xA;&lt;p&gt;** So what should I use for other Emacs builds?&lt;/p&gt; &#xA;&lt;p&gt;I recommend the built-in &lt;del&gt;pixel-scroll-precision-mode&lt;/del&gt;. The core scrolling functions used in &lt;del&gt;ultra-scroll-mac&lt;/del&gt; may be directly useful, and have been contributed upstream for potential inclusion.&lt;/p&gt; &#xA;&lt;p&gt;** How does this compare to the built-in smooth scrolling?&lt;/p&gt; &#xA;&lt;p&gt;In addition to fast scrolling, the built-in &lt;del&gt;pixel-scroll-precision-mode&lt;/del&gt; (new in Emacs v29.1) effectively simulates a /feature-complete trackpad driver/ in elisp, complete with scroll interpolation, a timer-based /momentum/ phase, etc. Since all of this is handled by the OS for emacs-mac, it&#39;s not necessary to include.&lt;/p&gt; &#xA;&lt;p&gt;Compared to the built-in precision scrolling, &lt;del&gt;ultra-scroll-mac&lt;/del&gt; obviously works correctly with emacs-mac, but is also even faster, and can smoothly scroll past tall images.&lt;/p&gt; &#xA;&lt;p&gt;** Why are there so many smooth scrolling modes? Why is this so hard, it&#39;s just /scrolling/?&lt;/p&gt; &#xA;&lt;p&gt;Emacs was designed long before mice were common, not to mention modern high-resolution trackpads which send rapid micro-updates (&#34;move up one pixel!&#34;) more than 60 times per second. Unlike other programs, Emacs insists on keeping the cursor (point) visible at all times. Deep in its redisplay code, Emacs tracks where point is, and works diligently to ensure it never falls outside the visible window. It does this not by moving point (that&#39;s the user&#39;s job), but by moving the /window/ (visible range of lines) surrounding point.&lt;/p&gt; &#xA;&lt;p&gt;Once you are used to this behavior, it&#39;s actually pretty nice for navigating with =C-n= / =C-p= and friends. But for smooth scrolling with a trackpad or mouse, it is /very problematic/ -- nothing screams &#34;janky scrolling&#34; like the window lurching back or forth half a page during a scroll. Or worse: getting caught in an endless loop of scroll-in-one-direction/jump-back-in-the-other.&lt;/p&gt; &#xA;&lt;p&gt;So what should be done? The elisp info manual (&lt;del&gt;Textual Scrolling&lt;/del&gt; / &lt;del&gt;set-window-start&lt;/del&gt;) helpfully mentions:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_quote ...for reliable results Lisp programs that call this function should always move point to be inside the window whose display starts at POSITION. #+end_quote&lt;/p&gt; &#xA;&lt;p&gt;Which is all well and good, but /where/ do you find such a point, in advance, safely /inside the window/? Often this isn&#39;t terribly hard, but there is one common case where this admonition falls comically flat: scrolling past images which are /taller than the window/ -- what I call &lt;em&gt;jumbo lines&lt;/em&gt;. Where can I place point /inside the window/ when a jumbo line occupies the entire window height?&lt;/p&gt; &#xA;&lt;p&gt;As a result of these types of difficulties, pixel scrolling codes and packages are often quite involved, with much of the logic boiling down to a stalwart and increasingly heroic pile of interwoven attempts to /keep the damn point on screen/ and prevent juddering and looping as you scroll.&lt;/p&gt; &#xA;&lt;p&gt;** What should I know about scrolling Emacs if I am developing my own related package?&lt;/p&gt; &#xA;&lt;p&gt;For posterity, some things I discovered in my own mostly-victorious battle against unwanted recentering during smooth scroll, including across jumbo lines:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;scroll-conservatively=101&lt;/del&gt; is very helpful, since with this Emacs will &#34;scroll just enough text to bring point into view, even if you move far away&#34;. It does not defeat recentering, but makes it... more manageable.&lt;/li&gt; &#xA; &lt;li&gt;You cannot let-bind &lt;del&gt;scroll-conservatively&lt;/del&gt; for effect, as it comes into play only on redisplay (after your event handler returns).&lt;/li&gt; &#xA; &lt;li&gt;Virtual Scroll: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;vscroll&lt;/del&gt; -- a virtual rendered scrolling window hiding below the current window -- is key to smooth scrolling, and setting &lt;del&gt;vscroll&lt;/del&gt; is incredibly fast.&lt;/li&gt; &#xA;   &lt;li&gt;There is plenty of &lt;del&gt;vscroll&lt;/del&gt; room available, including the entirety of any tall lines (as for displayed images) in view.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;del&gt;vscroll&lt;/del&gt; can sometimes place the point off the visible window (I know, sacrilege), but more often triggers recentering.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Scrolling asymmetry: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;del&gt;vscroll&lt;/del&gt; is purely one-sided: you can only access a vscroll area /beneath/ the current window view; /there is no negative vscroll/.&lt;/li&gt; &#xA;   &lt;li&gt;Unlike &lt;del&gt;window-start&lt;/del&gt;, &lt;del&gt;window-end&lt;/del&gt; does not get updated promptly between redisplays and cannot always be trusted.&lt;/li&gt; &#xA;   &lt;li&gt;For these two reasons, smooth scrolling up and scrolling down are /not symmetric/ with each other (and will likely never be). You need different approaches for each.&lt;/li&gt; &#xA;   &lt;li&gt;If the two approaches for scrolling up and down perform quite differently, the user will feel this difference.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;For avoiding recentering, naive movement doesn&#39;t work well. You need to learn the basic layout of lines on the window /before redisplay/ has occurred.&lt;/li&gt; &#xA; &lt;li&gt;The &#34;usable window height&#34; deducts any header and the old-fashioned tab-bar, but /not/ the tab-bar-mode bar.&lt;/li&gt; &#xA; &lt;li&gt;Jumbo lines: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Scrolling towards buffer end: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;When scrolling with jumbo lines towards the buffer&#39;s end (with &lt;del&gt;vscroll&lt;/del&gt;), simply keep /point on the jumbo line/ until it disappears from view. As a special case, Emacs will not re-center when this happens.&lt;/li&gt; &#xA;     &lt;li&gt;This is /not/ true for lines that are smaller than the usable window height. In this case, you must avoid placing point on any line which falls partially out of view.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Scrolling towards buffer start: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;When scrolling up past jumbo lines, using &lt;del&gt;set-window-start&lt;/del&gt; (lines of content move down), you must keep point on the jumbo, but /only until it clears the top of the window area/ (even by one pixel).&lt;/li&gt; &#xA;     &lt;li&gt;After this, you must move the point to the line above it (and had better insist that &lt;del&gt;scroll-conservatively&amp;gt;0&lt;/del&gt; to prevent re-centering).&lt;/li&gt; &#xA;     &lt;li&gt;In some cases (depending on truncation/visual-line-mode/etc.), this movement must occur from a position beyond the first full height object (which may not be at the line&#39;s start). E.g. one before the visual line end.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;pos-visible-in-window&lt;/del&gt; doesn&#39;t always work near the window boundaries. Better to use the first line at the window&#39;s top or directly identify the final line (both via &lt;del&gt;pos-at-x-y&lt;/del&gt;) and adjust from there.&lt;/li&gt; &#xA; &lt;li&gt;There are [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=67533][display bugs]] with inline images that cause them to misreport pixel measurements and positions sometimes. Best to guard against these.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;So all in all, incredibly complicated to get something that works. The cutting room floor is littered with literally dozens of almost-but-not-quite-working versions. I&#39;m sure there are many more corner cases, but this gets most things right.&lt;/p&gt;</summary>
  </entry>
</feed>