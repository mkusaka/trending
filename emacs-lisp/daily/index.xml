<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-19T01:39:50Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rougier/elegant-emacs</title>
    <updated>2022-06-19T01:39:50Z</updated>
    <id>tag:github.com,2022-06-19:/rougier/elegant-emacs</id>
    <link href="https://github.com/rougier/elegant-emacs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A very minimal but elegant emacs (I think)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A very minimal but elegant emacs (I think)&lt;/h1&gt; &#xA;&lt;p&gt;The goal is to have a minimal consistent vanilla emacs (i.e. no package) and yet elegant.&lt;br&gt; The defaul font is &lt;a href=&#34;https://fonts.google.com/specimen/Roboto+Mono&#34;&gt;Roboto Mono&lt;/a&gt; and optionally, you&#39;ll also need the &lt;a href=&#34;https://fonts.google.com/specimen/Fira+Code&#34;&gt;Fira Code&lt;/a&gt; font.&lt;/p&gt; &#xA;&lt;p&gt;Elegant Emacs is mostly a prototype or proof of concept. While it is perfectly usable, you might want to have a look a &lt;a href=&#34;https://github.com/rougier/nano-emacs&#34;&gt;GNU Emacs / N Î› N O&lt;/a&gt; which is more mature and maintained.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;: &lt;code&gt;emacs -q -l sanity.el -l elegance.el Splash.org &amp;amp;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-0.png&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-1.png&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-2.png&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-3.png&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-4.png&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-5.png&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-6.png&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-7.png&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-8.png&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-9.png#0&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-10.png#0&#34; width=&#34;45%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/rougier/elegant-emacs/master/screenshots/screenshot-11.png#0&#34; width=&#34;45%&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>alamaison/emacs-cmake-project</title>
    <updated>2022-06-19T01:39:50Z</updated>
    <id>tag:github.com,2022-06-19:/alamaison/emacs-cmake-project</id>
    <link href="https://github.com/alamaison/emacs-cmake-project" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A minor-mode integrating the CMake build process with the Emacs ecosystem.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Emacs CMake project mode&lt;/h1&gt; &#xA;&lt;p&gt;A minor-mode integrating the CMake build process with the Emacs ecosystem.&lt;/p&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;Emacs build tools for C/C++ generally assume a Makefile exists for the project but this isn&#39;t necessarily the case for projects managed by CMake which can generate many different types of project file. Integrates the CMake build process with the existing Emacs tools.&lt;/p&gt; &#xA;&lt;p&gt;This mode is &lt;em&gt;not&lt;/em&gt; for editing the &lt;code&gt;CMakeLists.txt&lt;/code&gt; themselves; that is left to the major-mode &lt;a href=&#34;http://www.cmake.org/CMakeDocs/cmake-mode.el&#34;&gt;&lt;code&gt;cmake-mode&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;p&gt;Copy this file somewhere on your Emacs load path or use &lt;a href=&#34;http://marmalade-repo.org/&#34;&gt;Marmalade&lt;/a&gt; and the package manager to install it.&lt;/p&gt; &#xA;&lt;p&gt;Either auto-load the mode in your init file by adding the line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(autoload &#39;cmake-project-mode &#34;cmake-project&#34; nil t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or simply require the library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;cmake-project)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use &lt;code&gt;M-x cmake-project-mode&lt;/code&gt; in any buffer you wish to use the mode in. Alternatively, start the mode automatically for any C/C++ file whose directory includes a &lt;code&gt;CMakeLists.txt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defun maybe-cmake-project-mode ()&#xA;  (if (or (file-exists-p &#34;CMakeLists.txt&#34;)&#xA;          (file-exists-p (expand-file-name &#34;CMakeLists.txt&#34; (car (project-roots (project-current))))))&#xA;      (cmake-project-mode)))&#xA;&#xA;(add-hook &#39;c-mode-hook &#39;maybe-cmake-project-mode)&#xA;(add-hook &#39;c++-mode-hook &#39;maybe-cmake-project-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;h1&gt;Configuring build tree&lt;/h1&gt; &#xA;&lt;p&gt;Use &lt;code&gt;M-x cmake-project-configure-project&lt;/code&gt; to configure or reconfigure a CMake build tree. The function finds the source automatically based on the current buffer.&lt;/p&gt; &#xA;&lt;h1&gt;The compile command&lt;/h1&gt; &#xA;&lt;p&gt;This mode makes the &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/emacs/Compilation.html&#34;&gt;compile command&lt;/a&gt;, &lt;code&gt;M-x compile&lt;/code&gt;, build the project by default via CMake in a &lt;code&gt;bin&lt;/code&gt; subdirectory of the project source root directory.&lt;/p&gt; &#xA;&lt;h1&gt;Flymake&lt;/h1&gt; &#xA;&lt;p&gt;This mode integrates with &lt;a href=&#34;http://www.gnu.org/software/emacs/manual/html_node/flymake/index.html&#34;&gt;Flymake&lt;/a&gt; so that, when &lt;code&gt;flymake-mode&lt;/code&gt; is enabled, the entire project is built whenever the buffer is saved and any errors are higlighted in the buffer. This is different from Flymake&#39;s typical behaviour which builds only the file for the buffer in question. CMake doesn&#39;t provide a way to build one file at a time (or at least we don&#39;t know of a way) so we must build everything.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>radian-software/apheleia</title>
    <updated>2022-06-19T01:39:50Z</updated>
    <id>tag:github.com,2022-06-19:/radian-software/apheleia</id>
    <link href="https://github.com/radian-software/apheleia" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸŒ· Run code formatter on buffer contents without moving point, using RCS patches and dynamic programming.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Apheleia&lt;/h1&gt; &#xA;&lt;p&gt;Good code is automatically formatted by tools like &lt;a href=&#34;https://github.com/python/black&#34;&gt;Black&lt;/a&gt; or &lt;a href=&#34;https://prettier.io/&#34;&gt;Prettier&lt;/a&gt; so that you and your team spend less time on formatting and more time on building features. It&#39;s best if your editor can run code formatters each time you save a file, so that you don&#39;t have to look at badly formatted code or get surprised when things change just before you commit. However, running a code formatter on save suffers from the following two problems:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;It takes some time (e.g. around 200ms for Black on an empty file), which makes the editor feel less responsive.&lt;/li&gt; &#xA; &lt;li&gt;It invariably moves your cursor (point) somewhere unexpected if the changes made by the code formatter are too close to point&#39;s position.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Apheleia is an &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt; package which solves both of these problems comprehensively for all languages, allowing you to say goodbye to language-specific packages such as &lt;a href=&#34;https://github.com/proofit404/blacken&#34;&gt;Blacken&lt;/a&gt; and &lt;a href=&#34;https://github.com/prettier/prettier-emacs&#34;&gt;prettier-js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The approach is as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run code formatters on &lt;code&gt;after-save-hook&lt;/code&gt;, rather than &lt;code&gt;before-save-hook&lt;/code&gt;, and do so asynchronously. Once the formatter has finished running, check if the buffer has been modified since it started; only apply the changes if not.&lt;/li&gt; &#xA; &lt;li&gt;After running the code formatter, generate an &lt;a href=&#34;https://tools.ietf.org/doc/tcllib/html/rcs.html#section4&#34;&gt;RCS patch&lt;/a&gt; showing the changes and then apply it to the buffer. This prevents changes elsewhere in the buffer from moving point. If a patch region happens to include point, then use a &lt;a href=&#34;https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm&#34;&gt;dynamic programming algorithm for string alignment&lt;/a&gt; to determine where point should be moved so that it remains in the same place relative to its surroundings. Finally, if the vertical position of point relative to the window has changed, adjust the scroll position to maintain maximum visual continuity. (This includes iterating through all windows displaying the buffer, if there are more than one.) The dynamic programming algorithm runs in quadratic time, which is why it is only applied if necessary and to a single patch region.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Apheleia is available on &lt;a href=&#34;https://melpa.org/&#34;&gt;MELPA&lt;/a&gt;. It is easiest to install it using &lt;a href=&#34;https://github.com/raxod502/straight.el&#34;&gt;&lt;code&gt;straight.el&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(straight-use-package &#39;apheleia)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, you may install using any other package manager if you prefer.&lt;/p&gt; &#xA;&lt;h2&gt;User guide&lt;/h2&gt; &#xA;&lt;p&gt;To your init-file, add the following form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(apheleia-global-mode +1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The autoloading has been configured so that this will &lt;em&gt;not&lt;/em&gt; cause Apheleia to be loaded until you save a file.&lt;/p&gt; &#xA;&lt;p&gt;By default, Apheleia is configured to format with &lt;a href=&#34;https://github.com/python/black&#34;&gt;Black&lt;/a&gt;, &lt;a href=&#34;https://prettier.io/&#34;&gt;Prettier&lt;/a&gt;, and &lt;a href=&#34;https://golang.org/cmd/gofmt/&#34;&gt;Gofmt&lt;/a&gt; on save in all relevant major modes. To configure this, you can adjust the values of the following variables:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-formatters&lt;/code&gt;: Alist mapping names of formatters (symbols like &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;prettier&lt;/code&gt;) to commands used to run those formatters (such as &lt;code&gt;(&#34;black&#34; &#34;-&#34;)&lt;/code&gt; and &lt;code&gt;(npx &#34;prettier&#34; input)&lt;/code&gt;). See the docstring for more information. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can manipulate this alist using standard Emacs functions. For example, to add some command-line options to Black, you could use:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setf (alist-get &#39;black apheleia-formatters)&#xA;      &#39;(&#34;black&#34; &#34;--option&#34; &#34;...&#34; &#34;-&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;There are a list of symbols that are interpreted by apheleia specially when formatting a command (example: &lt;code&gt;npx&lt;/code&gt;). Any non-string entries in a formatter that doesn&#39;t equal one of these symbols is evaluated and replaced in place. This can be used to pass certain flags to the formatter process depending on the state of the current buffer. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(push &#39;(shfmt . (&#34;beautysh&#34;&#xA;                 &#34;-filename&#34; filepath&#xA;                 (when-let ((indent (bound-and-true-p sh-basic-offset)))&#xA;                   (list &#34;--indent-size&#34; (number-to-string indent)))&#xA;                 (when indent-tabs-mode &#34;--tab&#34;)&#xA;                 &#34;-&#34;))&#xA;      apheleia-formatters)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This adds an entry to &lt;code&gt;apheleia-formatters&lt;/code&gt; for the &lt;code&gt;beautysh&lt;/code&gt; formatter. The evaluated entries makes it so that the &lt;code&gt;--tab&lt;/code&gt; flag is only passed to &lt;code&gt;beautysh&lt;/code&gt; when the value of &lt;code&gt;indent-tabs-mode&lt;/code&gt; is true. Similarly the indent-size flag is passed the exact value of the &lt;code&gt;sh-basic-offset&lt;/code&gt; variable only when it is bound. Observe that one of these evaluations returns a list of flags whereas the other returns a single string. These are substituted into the command as you&#39;d expect.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can also use Apheleia to format buffers that have no underlying files. In this case the value of &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;filepath&lt;/code&gt; will be the name of the current buffer with any special characters for the file-system (such as &lt;code&gt;*&lt;/code&gt; on windows) being stripped out.&lt;/p&gt; &lt;p&gt;This is also how the extension for any temporary files apheleia might create will be determined. If you&#39;re using a formatter that determines the file-type from the extension you should name such buffers such that their suffixed with the extension. For example a buffer called &lt;code&gt;*foo-bar.c*&lt;/code&gt; that has no associated file will have an implicit file-name of &lt;code&gt;foo-bar.c&lt;/code&gt; and any temporary files will be suffixed with a &lt;code&gt;.c&lt;/code&gt; extension.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can implement formatters as arbitrary Elisp functions which operate directly on a buffer, without needing to invoke an external command. This can be useful to integrate with e.g. language servers. See the docstring for more information on the expected interface for Elisp formatters.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-mode-alist&lt;/code&gt;: Alist mapping major modes and filename regexps to names of formatters to use in those modes and files. See the docstring for more information. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;You can use this variable to configure multiple formatters for the same buffer by setting the &lt;code&gt;cdr&lt;/code&gt; of an entry to a list of formatters to run instead of a single formatter. For example you may want to run &lt;code&gt;isort&lt;/code&gt; and &lt;code&gt;black&lt;/code&gt; one after the other.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(setf (alist-get &#39;isort apheleia-formatters)&#xA;      &#39;(&#34;isort&#34; &#34;--stdout&#34; &#34;-&#34;))&#xA;(setf (alist-get &#39;python-mode apheleia-mode-alist)&#xA;      &#39;(isort black))&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This will make apheleia run &lt;code&gt;isort&lt;/code&gt; on the current buffer and then &lt;code&gt;black&lt;/code&gt; on the result of &lt;code&gt;isort&lt;/code&gt; and then use the final output to format the current buffer.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: At the moment there&#39;s no smart or configurable error handling in place. This means if one of the configured formatters fail (for example if &lt;code&gt;isort&lt;/code&gt; isn&#39;t installed) then apheleia just doesn&#39;t format the buffer at all, even if &lt;code&gt;black&lt;/code&gt; is installed.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; If a formatter uses &lt;code&gt;file&lt;/code&gt; (rather than &lt;code&gt;filepath&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt; or none of these keywords), it can&#39;t be chained after another formatter, because &lt;code&gt;file&lt;/code&gt; implies that the formatter must read from the &lt;em&gt;original&lt;/em&gt; file, not an intermediate temporary file. For this reason it&#39;s suggested to avoid the use of &lt;code&gt;file&lt;/code&gt; in general.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-formatter&lt;/code&gt;: Optional buffer-local variable specifying the formatter to use in this buffer. Overrides &lt;code&gt;apheleia-mode-alist&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can run &lt;code&gt;M-x apheleia-mode&lt;/code&gt; to toggle automatic formatting on save in a single buffer, or &lt;code&gt;M-x apheleia-global-mode&lt;/code&gt; to toggle the default setting for all buffers. Also, even if &lt;code&gt;apheleia-mode&lt;/code&gt; is not enabled, you can run &lt;code&gt;M-x apheleia-format-buffer&lt;/code&gt; to manually invoke the configured formatter for the current buffer. Running with a prefix argument will cause the command to prompt you for which formatter to run.&lt;/p&gt; &#xA;&lt;p&gt;Apheleia does not currently support TRAMP, and is therefore automatically disabled for remote files.&lt;/p&gt; &#xA;&lt;p&gt;If an error occurs while formatting, a message is displayed in the echo area. You can jump to the error by invoking &lt;code&gt;M-x apheleia-goto-error&lt;/code&gt;, or manually switch to the log buffer mentioned in the message.&lt;/p&gt; &#xA;&lt;p&gt;You can configure error reporting using the following user options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-hide-log-buffers&lt;/code&gt;: By default, errors from formatters are put in buffers named like &lt;code&gt;*apheleia-cmdname-log*&lt;/code&gt;. If you customize this user option to non-nil then a space is prepended to the names of these buffers, hiding them by default in &lt;code&gt;switch-to-buffer&lt;/code&gt; (you must type a space to see them).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-log-only-errors&lt;/code&gt;: By default, only failed formatter runs are logged. If you customize this user option to nil then all runs are logged, along with whether or not they succeeded. This could be helpful in debugging.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following user options are also available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-post-format-hook&lt;/code&gt;: Normal hook run after Apheleia formats a buffer. Run if the formatting is successful, even when no changes are made to the buffer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-max-alignment-size&lt;/code&gt;: The maximum number of characters that a diff region can have to be processed using Apheleia&#39;s dynamic programming algorithm for point alignment. This cannot be too big or Emacs will hang noticeably on large reformatting operations, since the DP algorithm is quadratic-time.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Apheleia exposes some hooks for advanced customization:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apheleia-formatter-exited-hook&lt;/code&gt;: Abnormal hook which is run after a formatter has completely finished running for a buffer. Not run if the formatting was interrupted and no action was taken. Receives two arguments: the symbol for the formatter that was run (e.g. &lt;code&gt;black&lt;/code&gt;, or it could be a list if multiple formatters were run in a chain), and a boolean for whether there was an error.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Known issues&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;process aphelieia-whatever no longer connected to pipe; closed it&lt;/code&gt;: This happens on older Emacs versions when formatting a buffer with size greater than 65,536 characters. There is no known workaround besides disabling &lt;code&gt;apheleia-mode&lt;/code&gt; for the affected buffer, or upgrading to a more recent version of Emacs. See &lt;a href=&#34;https://github.com/raxod502/apheleia/issues/20&#34;&gt;#20&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/raxod502/contributor-guide&#34;&gt;the contributor guide for my projects&lt;/a&gt; for general information, and the following sections for Apheleia-specific details.&lt;/p&gt; &#xA;&lt;h3&gt;Adding a formatter&lt;/h3&gt; &#xA;&lt;p&gt;I have done my best to make it straightforward to add a formatter. You just follow these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install your formatter on your machine so you can test.&lt;/li&gt; &#xA; &lt;li&gt;Create an entry in &lt;code&gt;apheleia-formatters&lt;/code&gt; with how to run it. (See the docstring of this variable for explanation about the available keywords.)&lt;/li&gt; &#xA; &lt;li&gt;Add entries for the relevant major modes in &lt;code&gt;apheleia-mode-alist&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;See if it works for you!&lt;/li&gt; &#xA; &lt;li&gt;Add a file at &lt;code&gt;test/formatters/installers/yourformatter.bash&lt;/code&gt; which explains how to install the formatter on Ubuntu. This will be used by CI.&lt;/li&gt; &#xA; &lt;li&gt;Test with &lt;code&gt;make fmt-build FORMATTERS=yourformatter&lt;/code&gt; to do the installation, then &lt;code&gt;make fmt-docker&lt;/code&gt; to start a shell with the formatter available. Verify it runs in this environment.&lt;/li&gt; &#xA; &lt;li&gt;Add an example input (pre-formatting) and output (post-formatting) file at &lt;code&gt;test/formatters/samplecode/yourformatter/in.whatever&lt;/code&gt; and &lt;code&gt;test/formatters/samplecode/yourformatter/out.whatever&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Verify that the tests are passing, using &lt;code&gt;make fmt-test FORMATTERS=yourformatter&lt;/code&gt; from inside the &lt;code&gt;fmt-docker&lt;/code&gt; shell.&lt;/li&gt; &#xA; &lt;li&gt;Submit a pull request, CI should now be passing!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;I got the idea for using RCS patches to avoid moving point too much from &lt;a href=&#34;https://github.com/prettier/prettier-emacs&#34;&gt;prettier-js&lt;/a&gt;, although that package does not implement the dynamic programming algorithm which Apheleia uses to guarantee stability of point even within a formatted region.&lt;/p&gt; &#xA;&lt;p&gt;Note that despite this inspiration, Apheleia is a clean-room implementation which is free of the copyright terms of prettier-js.&lt;/p&gt;</summary>
  </entry>
</feed>