<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-16T01:39:41Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>masui/Again</title>
    <updated>2022-07-16T01:39:41Z</updated>
    <id>tag:github.com,2022-07-16:/masui/Again</id>
    <link href="https://github.com/masui/Again" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacsで操作を再実行するシステム&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;again.el&lt;/h1&gt; &#xA;&lt;p&gt;詳細は&lt;a href=&#34;https://scrapbox.io/masui/Again&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://scrapbox.io/Again&#34;&gt;https://scrapbox.io/Again&lt;/a&gt;を参照&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>emacsorphanage/popwin</title>
    <updated>2022-07-16T01:39:41Z</updated>
    <id>tag:github.com,2022-07-16:/emacsorphanage/popwin</id>
    <link href="https://github.com/emacsorphanage/popwin" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Popup Window Manager for Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://melpa.org/#/popwin&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/popwin-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/popwin&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/popwin-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;popwin.el&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/emacsorphanage/popwin/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/emacsorphanage/popwin/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;popwin is a popup window manager for Emacs which makes you free from the hell of annoying buffers such like &lt;code&gt;*Help*&lt;/code&gt;, &lt;code&gt;*Completions*&lt;/code&gt;, &lt;code&gt;*compilation*&lt;/code&gt;, and etc.&lt;/p&gt; &#xA;&lt;p&gt;Take an example. When you complete file names during &lt;code&gt;find-file&lt;/code&gt;, the (annoying) &lt;code&gt;*Completions*&lt;/code&gt; buffer will appear in a newly splitted window. You might understand the necessity of the window, but you may wonder why the window still remains after completion...&lt;/p&gt; &#xA;&lt;p&gt;popwin resolves there problems. Windows of such temporary buffers will be shown as a popup window, and you can close them smoothly by typing &lt;code&gt;C-g&lt;/code&gt; in anytime.&lt;/p&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Before Popup Window&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;After Popup Window&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/m2ym/popwin-el/master/etc/images/popwin1.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/m2ym/popwin-el/master/etc/images/popwin2.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Melpa&lt;/h3&gt; &#xA;&lt;p&gt;This package is on &lt;a href=&#34;https://github.com/melpa/melpa&#34;&gt;MELPA&lt;/a&gt;, you can install it from there! (recommended)&lt;/p&gt; &#xA;&lt;h3&gt;Manually&lt;/h3&gt; &#xA;&lt;p&gt;Install &lt;code&gt;popwin.el&lt;/code&gt; into your &lt;code&gt;load-path&lt;/code&gt; directory. If you have &lt;code&gt;install-elisp&lt;/code&gt; or &lt;code&gt;auto-install&lt;/code&gt;, you may install &lt;code&gt;popwin.el&lt;/code&gt; like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; install-elisp&#xA;(install-elisp &#34;https://raw.github.com/m2ym/popwin-el/master/popwin.el&#34;)&#xA;;; auto-install&#xA;(auto-install-from-url &#34;https://raw.github.com/m2ym/popwin-el/master/popwin.el&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then add the following code into your &lt;code&gt;.emacs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;popwin)&#xA;(popwin-mode 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;popwin is tested under GNU Emacs 22 or later.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;p&gt;Special buffers, for example &lt;code&gt;*Help*&lt;/code&gt;, specified in &lt;code&gt;popwin:special-display-config&lt;/code&gt; will be shown in a popup window. You can close the popup window by typing &lt;code&gt;C-g&lt;/code&gt; or selecting other windows.&lt;/p&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;*Help*&lt;/code&gt;, &lt;code&gt;*Completions*&lt;/code&gt;, &lt;code&gt;*compilation*&lt;/code&gt;, and &lt;code&gt;*Occur*&lt;/code&gt; buffers will be shown in a popup window. Try &lt;code&gt;M-x find-file&lt;/code&gt; and type &lt;code&gt;TAB TAB&lt;/code&gt;. You may see a popup window at the bottom of the frame.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;File Name Completion&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/m2ym/popwin-el/master/etc/images/popwin-find-file.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Let me show other examples.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;M-x occur&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/m2ym/popwin-el/master/etc/images/popwin-occur.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;M-x compile&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/m2ym/popwin-el/master/etc/images/popwin-compile.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Customization&lt;/h2&gt; &#xA;&lt;p&gt;Please do &lt;code&gt;M-x customize-group RET popwin RET&lt;/code&gt; and &lt;code&gt;M-x customize-variable RET popwin:special-display-config RET&lt;/code&gt;. See the header of &lt;code&gt;popwin.el&lt;/code&gt;, source code, and docstrings for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Default Keymap&lt;/h3&gt; &#xA;&lt;p&gt;popwin provides a default keymap named &lt;code&gt;popwin:keymap&lt;/code&gt;. You can use it like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(global-set-key (kbd &#34;C-z&#34;) popwin:keymap)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Keymap:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;| Key    | Command                               |&#xA;|--------+---------------------------------------|&#xA;| b      | popwin:popup-buffer                   |&#xA;| l      | popwin:popup-last-buffer              |&#xA;| o      | popwin:display-buffer                 |&#xA;| C-b    | popwin:switch-to-last-buffer          |&#xA;| C-p    | popwin:original-pop-to-last-buffer    |&#xA;| C-o    | popwin:original-display-last-buffer   |&#xA;| SPC    | popwin:select-popup-window            |&#xA;| s      | popwin:stick-popup-window             |&#xA;| 0      | popwin:close-popup-window             |&#xA;| f, C-f | popwin:find-file                      |&#xA;| e      | popwin:messages                       |&#xA;| C-u    | popwin:universal-display              |&#xA;| 1      | popwin:one-window                     |&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Special Display Config&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;popwin:special-display-config&lt;/code&gt; is a list of &lt;code&gt;CONFIG&lt;/code&gt;. &lt;code&gt;CONFIG&lt;/code&gt; may be a form of &lt;code&gt;(PATTERN . KEYWORDS)&lt;/code&gt;, where &lt;code&gt;PATTERN&lt;/code&gt; is a pattern of specifying a buffer, and &lt;code&gt;KEYWORDS&lt;/code&gt; is a list of a pair of key and value. &lt;code&gt;PATTERN&lt;/code&gt; is a buffer name, a symbol specifying major-mode, or a predicate function which takes the buffer. If &lt;code&gt;CONFIG&lt;/code&gt; is a string or a symbol, &lt;code&gt;PATTERN&lt;/code&gt; will be &lt;code&gt;CONFIG&lt;/code&gt; and &lt;code&gt;KEYWORDS&lt;/code&gt; will be empty. Available keywords are following:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;:regexp&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;: If the value is non-nil, &lt;code&gt;PATTERN&lt;/code&gt; will be used as regexp to matching buffer.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;: Specify width or height of the popup window. If no size specified, &lt;code&gt;popwin:popup-window-width&lt;/code&gt; or &lt;code&gt;popwin:popup-window-height&lt;/code&gt; will be used. See also position keyword.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;:position&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;: The value must be one of &lt;code&gt;(left top right bottom)&lt;/code&gt;. The popup window will shown at the position of the frame. If no position specified, &lt;code&gt;popwin:popup-window-position&lt;/code&gt; will be used.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;:noselect&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;: If the value is non-nil, the popup window will not be selected when it is shown.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;:dedicated&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;: If the value is non-nil, the popup window will be dedicated to the original popup buffer. In this case, when another buffer is selected in the popup window, the popup window will be closed immedicately and the selected buffer will be shown on the previously selected window.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;:stick&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;: If the value is non-nil, the popup window will be stuck when it is shown.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;:tail&lt;/code&gt; : If the value is non-nil, the popup window will show the last contents.&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; M-x anything&#xA;(setq anything-samewindow nil)&#xA;(push &#39;(&#34;*anything*&#34; :height 20) popwin:special-display-config)&#xA;&#xA;;; M-x dired-jump-other-window&#xA;(push &#39;(dired-mode :position top) popwin:special-display-config)&#xA;&#xA;;; M-!&#xA;(push &#34;*Shell Command Output*&#34; popwin:special-display-config)&#xA;&#xA;;; M-x compile&#xA;(push &#39;(compilation-mode :noselect t) popwin:special-display-config)&#xA;&#xA;;; slime&#xA;(push &#34;*slime-apropos*&#34; popwin:special-display-config)&#xA;(push &#34;*slime-macroexpansion*&#34; popwin:special-display-config)&#xA;(push &#34;*slime-description*&#34; popwin:special-display-config)&#xA;(push &#39;(&#34;*slime-compilation*&#34; :noselect t) popwin:special-display-config)&#xA;(push &#34;*slime-xref*&#34; popwin:special-display-config)&#xA;(push &#39;(sldb-mode :stick t) popwin:special-display-config)&#xA;(push &#39;slime-repl-mode popwin:special-display-config)&#xA;(push &#39;slime-connection-list-mode popwin:special-display-config)&#xA;&#xA;;; vc&#xA;(push &#34;*vc-diff*&#34; popwin:special-display-config)&#xA;(push &#34;*vc-change-log*&#34; popwin:special-display-config)&#xA;&#xA;;; undo-tree&#xA;(push &#39;(&#34; *undo-tree*&#34; :width 0.3 :position right) popwin:special-display-config)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Universal Display Config&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;popwin:universal-display-config&lt;/code&gt; is a special alternative value of &lt;code&gt;popwin:special-display-config&lt;/code&gt;, which will be used when executing a command with &lt;code&gt;M-x popwin:universal-display&lt;/code&gt; prefix. If you want to show a specific buffer in a popup window at the time, for example, you can do it with &lt;code&gt;M-x popwin:universal-display RET C-x 4 C-o BUFNAME RET&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The default value is &lt;code&gt;(t)&lt;/code&gt;, meaning all of buffers with &lt;code&gt;M-x popwin:universal-display&lt;/code&gt; prefix will be shown in a popup window.&lt;/p&gt; &#xA;&lt;h2&gt;Working with Other Extensions&lt;/h2&gt; &#xA;&lt;p&gt;Some extensions needs workaround for working with popwin.&lt;/p&gt; &#xA;&lt;h4&gt;YaTeX&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;misc/popwin-yatex.el&lt;/code&gt; helps you to show YaTeX related buffers in a popup window. Add the following code into &lt;code&gt;.emacs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;popwin-yatex)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may write a configuration like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(push &#39;(&#34;*YaTeX-typesetting*&#34;) popwin:special-display-config)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;w3m&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;misc/popwin-w3m.el&lt;/code&gt; helps you to show specific pages with w3m in a popup window. Add the following code into &lt;code&gt;.emacs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;popwin-w3m)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is recommended to change &lt;code&gt;browse-url-browser-function&lt;/code&gt; to &lt;code&gt;popwin:w3m-browse-url&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setq browse-url-browser-function &#39;popwin:w3m-browse-url)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;popwin:w3m-browse-url&lt;/code&gt; is a function (and a command) displaying w3m buffers in a popup window if the given URL is matched with the rules.&lt;/p&gt; &#xA;&lt;p&gt;The rules are described by &lt;code&gt;popwin:w3m-special-display-config&lt;/code&gt; variable, which has almost same structure of &lt;code&gt;popwin:special-display-config&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The difference is &lt;code&gt;popwin:w3m-special-display-config&lt;/code&gt; takes an URL regular expression instead of a buffer pattern.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you want to show google search pages in a popup window, a configuration could be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(push &#39;(&#34;^http://www\\.google\\.com/.*$&#34;) popwin:w3m-special-display-config)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;term.el&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;misc/popwin-term.el&lt;/code&gt; helps you to show term buffers in a popup window. Add the following code into &lt;code&gt;.emacs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;popwin-term)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then write a configuration like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(push &#39;(term-mode :position :top :height 16 :stick t) popwin:special-display-config)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, you can show a term buffer in a popup window with &lt;code&gt;M-x popwin-term:term&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;browse-kill-ring.el&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;misc/browse-kill-ring.el&lt;/code&gt; helps you to show &lt;code&gt;*Kill Ring*&lt;/code&gt; buffer in a popup window. Add the following code into &lt;code&gt;.emacs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;popwin-browse-kill-ring)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then write a configuration like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(push &#34;*Kill Ring*&#34; popwin:special-display-config)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;M-x browse-kill-ring&lt;/code&gt; now shows &lt;code&gt;*Kill Ring*&lt;/code&gt; buffer in a popup window.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;windows.el&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Do not load &lt;code&gt;windows.el&lt;/code&gt; after loading &lt;code&gt;popwin.el&lt;/code&gt;. Load &lt;code&gt;windows.el&lt;/code&gt; first.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Commands&lt;/h2&gt; &#xA;&lt;h3&gt;Command: &lt;code&gt;popwin:popup-buffer&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Focely show the specified buffer in a popup window. &lt;code&gt;popwin:special-display-config&lt;/code&gt; will be ignored.&lt;/p&gt; &#xA;&lt;h3&gt;Command: &lt;code&gt;popwin:display-buffer&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Show the specified buffer in a popup window if possible, meaning there is at least one matched configuration in &lt;code&gt;popwin:special-display-config&lt;/code&gt;. Otherwise, fallback to &lt;code&gt;display-buffer&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Command: &lt;code&gt;popwin:display-last-buffer&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Show the lastly shown buffer in a popup window.&lt;/p&gt; &#xA;&lt;h3&gt;Command: &lt;code&gt;popwin:pop-to-buffer&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Same as &lt;code&gt;popwin:display-buffer&lt;/code&gt;, but behaves like &lt;code&gt;pop-to-buffer&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Command: &lt;code&gt;popwin:one-window&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Same like &lt;code&gt;C-x 1&lt;/code&gt; except that &lt;code&gt;C-g&lt;/code&gt; restore the original window configuration. This is useful when you see the contents of the popup window in full window temporarily.&lt;/p&gt; &#xA;&lt;h3&gt;Command: &lt;code&gt;popup:find-file&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;find-file&lt;/code&gt; in a popup window.&lt;/p&gt; &#xA;&lt;h3&gt;Command: &lt;code&gt;popwin:messages&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Show &lt;code&gt;*Messages*&lt;/code&gt; buffer in a popup window.&lt;/p&gt; &#xA;&lt;h2&gt;Basic API&lt;/h2&gt; &#xA;&lt;h3&gt;Function: &lt;code&gt;popwin:create-popup-window&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;popwin:create-popup-window &amp;amp;optional size position adjust =&amp;gt; (master-window popup-window)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;popwin:create-popup-window&lt;/code&gt; creates a popup window and return it with a master window. Master window is a window which is splitted when creating the popup window. A resposibility of closing the popup window is on developers.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Copyright (C) 2011-2015 Tomohiro Matsuyama &amp;lt;&lt;a href=&#34;mailto:m2ym.pub@gmail.com&#34;&gt;m2ym.pub@gmail.com&lt;/a&gt;&amp;gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>joddie/pcre2el</title>
    <updated>2022-07-16T01:39:41Z</updated>
    <id>tag:github.com,2022-07-16:/joddie/pcre2el</id>
    <link href="https://github.com/joddie/pcre2el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;convert between PCRE, Emacs and rx regexp syntax&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;pcre2el: convert between PCRE, Emacs and rx regexp syntax&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Overview =pcre2el= or =rxt= (RegeXp Translator or RegeXp Tools) is a utility for working with regular expressions in Emacs, based on a recursive-descent parser for regexp syntax. In addition to converting (a subset of) PCRE syntax into its Emacs equivalent, it can do the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;convert Emacs syntax to PCRE&lt;/li&gt; &#xA; &lt;li&gt;convert either syntax to =rx=, an S-expression based regexp syntax&lt;/li&gt; &#xA; &lt;li&gt;untangle complex regexps by showing the parse tree in =rx= form and highlighting the corresponding chunks of code&lt;/li&gt; &#xA; &lt;li&gt;show the complete list of strings (productions) matching a regexp, provided the list is finite&lt;/li&gt; &#xA; &lt;li&gt;provide live font-locking of regexp syntax (so far only for Elisp buffers -- other modes on the TODO list)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Usage Enable =rxt-mode= or its global equivalent =rxt-global-mode= to get the default key-bindings. There are three sets of commands: commands that take a PCRE regexp, commands which take an Emacs regexp, and commands that try to do the right thing based on the current mode. Currently, this means Emacs syntax in =emacs-lisp-mode= and =lisp-interaction-mode=, and PCRE syntax everywhere else.&lt;/p&gt; &#xA;&lt;p&gt;The default key bindings all begin with =C-c /= and have a mnemonic structure: =C-c / &lt;source&gt; &#xA; &lt;target&gt;&#xA;  =, or just =C-c / &#xA;  &lt;target&gt;&#xA;   = for the &#34;do what I mean&#34; commands. The complete list of key bindings is given here and explained in more detail below:&#xA;  &lt;/target&gt;&#xA; &lt;/target&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&#34;Do-what-I-mean&#34; commands:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;=C-c / /= :: =rxt-explain=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / c= :: =rxt-convert-syntax=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / x= :: =rxt-convert-to-rx=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / ′= :: =rxt-convert-to-strings=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Commands that work on a PCRE regexp:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;=C-c / p e= :: =rxt-pcre-to-elisp=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / %= :: =pcre-query-replace-regexp=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / p x= :: =rxt-pcre-to-rx=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / p s= :: =rxt-pcre-to-sre=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / p ′= :: =rxt-pcre-to-strings=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / p /= :: =rxt-explain-pcre=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Commands that work on an Emacs regexp:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;=C-c / e /= :: =rxt-explain-elisp=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / e p= :: =rxt-elisp-to-pcre=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / e x= :: =rxt-elisp-to-rx=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / e s= :: =rxt-elisp-to-sre=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / e ′= :: =rxt-elisp-to-strings=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / e t= :: =rxt-toggle-elisp-rx=&lt;/li&gt; &#xA;   &lt;li&gt;=C-c / t= :: =rxt-toggle-elisp-rx=&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Interactive input and output When used interactively, the conversion commands can read a regexp either from the current buffer or from the minibuffer. The output is displayed in the minibuffer and copied to the kill-ring.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- When called with a prefix argument (=C-u=), they read a regular&#xA;  expression from the minibuffer literally, without further&#xA;  processing -- meaning there&#39;s no need to double the backslashes if&#xA;  it&#39;s an Emacs regexp.  This is the same way commands like&#xA;  =query-replace-regexp= read input.&#xA;&#xA;- When the region is active, they use they the region contents,&#xA;  again literally (without any translation of string syntax).&#xA;&#xA;- With neither a prefix arg nor an active region, the behavior&#xA;  depends on whether the command expects an Emacs regexp or&#xA;  a PCRE one.&#xA;&#xA;  Commands that take an Emacs regexp behave like =C-x C-e=: they&#xA;  evaluate the sexp before point (which could be simply a string&#xA;  literal) and use its value. This is designed for use in Elisp&#xA;  buffers. As a special case, if point is *inside* a string, it&#39;s&#xA;  first moved to the string end, so in practice they should work&#xA;  as long as point is somewhere within the regexp literal.&#xA;&#xA;  Commands that take a PCRE regexp try to read a Perl-style&#xA;  delimited regex literal *after* point in the current buffer,&#xA;  including its flags. For example, putting point before the =m=&#xA;  in the following example and doing =C-c / p e=&#xA;  (=rxt-pcre-to-elisp=) displays =\(?:bar\|foo\)=, correctly&#xA;  stripping out the whitespace and comment:&#xA;&#xA;  : $x =~ m/  foo   |  (?# comment) bar /x&#xA;&#xA;  The PCRE reader currently only works with =/ ... /= delimiters. It&#xA;  will ignore any preceding =m=, =s=, or =qr= operator, as well as&#xA;  the replacement part of an =s= construction.&#xA;&#xA;  Readers for other PCRE-using languages are on the TODO list.&#xA;&#xA;The translation functions display their result in the minibuffer&#xA;and copy it to the kill ring. When translating something into&#xA;Elisp syntax, you might need to use the result either literally&#xA;(e.g. for interactive input to a command like&#xA;=query-replace-regexp=), or as a string to paste into Lisp code.&#xA;To allow both uses, =rxt-pcre-to-elisp= copies both versions&#xA;successively to the kill-ring. The literal regexp without string&#xA;quoting is the top element of the kill-ring, while the Lisp string&#xA;is the second-from-top. You can paste the literal regexp somewhere&#xA;by doing =C-y=, or the Lisp string by =C-y M-y=.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Syntax conversion commands =rxt-convert-syntax= (=C-c / c=) converts between Emacs and PCRE syntax, depending on the major mode in effect when called. Alternatively, you can specify the conversion direction explicitly by using either =rxt-pcre-to-elisp= (=C-c / p e=) or =rxt-elisp-to-pcre= (=C-c / e p=).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Similarly, =rxt-convert-to-rx= (=C-c / x=) converts either kind of&#xA;syntax to =rx= form, while =rxt-convert-pcre-to-rx= (=C-c / p x=)&#xA;and =rxt-convert-elisp-to-rx= (=C-c / e x=) convert to =rx= from a&#xA;specified source type.&#xA;&#xA;In Elisp buffers, you can use =rxt-toggle-elisp-rx= (=C-c / t= or&#xA;=C-c / e t=) to switch the regexp at point back and forth between&#xA;string and =rx= syntax. Point should either be within an =rx= or&#xA;=rx-to-string= form or a string literal for this to work.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** PCRE mode (experimental) If you want to use emulated PCRE regexp syntax in all Emacs commands, try =pcre-mode=, which uses Emacs&#39;s advice system to make all commands that read regexps using the minibuffer use emulated PCRE syntax. It should also work with Isearch.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This feature is still fairly experimental.  It may fail to work or&#xA;do the wrong thing with certain commands.  Please report bugs.&#xA;&#xA;=pcre-query-replace-regexp= was originally defined to do&#xA;query-replace using emulated PCRE regexps, and is now made&#xA;somewhat obsolete by =pcre-mode=.  It is bound to =C-c / %= by&#xA;default, by analogy with =M-%=.  Put the following in your&#xA;=.emacs= if you want to use PCRE-style query replacement&#xA;everywhere:&#xA;&#xA;: (global-set-key [(meta %)] &#39;pcre-query-replace-regexp)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Explain regexps When syntax-highlighting isn&#39;t enough to untangle some gnarly regexp you find in the wild, try the &#39;explain&#39; commands: =rxt-explain= (=C-c / /=), =rxt-explain-pcre= (=C-c / p=) and =rxt-explain-elisp= (=C-c / e=). These display the original regexp along with its pretty-printed =rx= equivalent in a new buffer. Moving point around either in the original regexp or the =rx= translation highlights corresponding pieces of syntax, which can aid in seeing things like the scope of quantifiers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;I call them &#34;explain&#34; commands because the =rx= form is close to a&#xA;plain syntax tree, and this plus the wordiness of the operators&#xA;usually helps to clarify what is going on.  People who dislike&#xA;Lisp syntax might disagree with this assessment.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Generate all matching strings (productions) Occasionally you come across a regexp which is designed to match a finite set of strings, e.g. a set of keywords, and it would be useful to recover the original set. (In Emacs you can generate such regexps using =regexp-opt=). The commands =rxt-convert-to-strings= (=C-c / ′=), =rxt-pcre-to-strings= (=C-c / p ′=) or =rxt-elisp-to-strings= (=C-c / e ′=) accomplish this by generating all the matching strings (&#34;productions&#34;) of a regexp. (The productions are copied to the kill ring as a Lisp list).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;An example in Lisp code:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;: (regexp-opt &#39;(&#34;cat&#34; &#34;caterpillar&#34; &#34;catatonic&#34;)) : ;; =&amp;gt; &#34;\(?:cat\(?:atonic\|erpillar\)?\)&#34; : (rxt-elisp-to-strings &#34;\(?:cat\(?:atonic\|erpillar\)?\)&#34;) : ;; =&amp;gt; &#39;(&#34;cat&#34; &#34;caterpillar&#34; &#34;catatonic&#34;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;For obvious reasons, these commands only work with regexps that&#xA;don&#39;t include any unbounded quantifiers like =+= or =*=. They also&#xA;can&#39;t enumerate all the characters that match a named character&#xA;class like =[[:alnum:]]=. In either case they will give a (hopefully&#xA;meaningful) error message. Due to the nature of permutations, it&#39;s&#xA;still possible for a finite regexp to generate a huge number of&#xA;productions, which will eat memory and slow down your Emacs. Be&#xA;ready with =C-g= if necessary.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** RE-Builder support The Emacs RE-Builder is a useful visual tool which allows using several different built-in syntaxes via =reb-change-syntax= (=C-c TAB=). It supports Elisp read and literal syntax and =rx=, but it can only convert from the symbolic forms to Elisp, not the other way. This package hacks the RE-Builder to also work with emulated PCRE syntax, and to convert transparently between Elisp, PCRE and rx syntaxes. PCRE mode reads a delimited Perl-like literal of the form =/ ... /=, and it should correctly support using the =x= and =s= flags.&lt;/p&gt; &#xA;&lt;p&gt;*** Use from Lisp&lt;/p&gt; &#xA;&lt;p&gt;Example of using the conversion functions: : (rxt-pcre-to-elisp &#34;(abc|def)\w+\d+&#34;) : ;; =&amp;gt; &#34;\(\(?:abc\|def\)\)[_[:alnum:]]+[[:digit:]]+&#34;&lt;/p&gt; &#xA;&lt;p&gt;All the conversion functions take a single string argument, the regexp to translate:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=rxt-pcre-to-elisp=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-pcre-to-rx=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-pcre-to-sre=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-pcre-to-strings=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-elisp-to-pcre=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-elisp-to-rx=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-elisp-to-sre=&lt;/li&gt; &#xA; &lt;li&gt;=rxt-elisp-to-strings=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Bugs and Limitations *** Limitations on PCRE syntax PCRE has a complicated syntax and semantics, only some of which can be translated into Elisp. The following subset of PCRE should be correctly parsed and converted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- parenthesis grouping =( .. )=, including shy matches =(?: ... )=&#xA;- backreferences (various syntaxes), but only up to 9 per expression    &#xA;- alternation =|=&#xA;- greedy and non-greedy quantifiers =*=, =*?=, =+=, =+?=, =?= and =??=&#xA;  (all of which are the same in Elisp as in PCRE)&#xA;- numerical quantifiers ={M,N}=&#xA;- beginning/end of string =\A=, =\Z=&#xA;- string quoting =\Q .. \E=&#xA;- word boundaries =\b=, =\B= (these are the same in Elisp)&#xA;- single character escapes =\a=, =\c=, =\e=, =\f=, =\n=, =\r=,&#xA;  =\t=, =\x=, and =\octal digits= (but see below about non-ASCII&#xA;  characters)&#xA;- character classes =[...]= including Posix escapes&#xA;- character classes =\d=, =\D=, =\h=, =\H=, =\s=, =\S=, =\v=, =\V=&#xA;  both within character class brackets and outside&#xA;- word and non-word characters =\w= and =\W=&#xA;  (Emacs has the same syntax, but its meaning is different)&#xA;- =s= (single line) and =x= (extended syntax) flags, in regexp&#xA;  literals, or set within the expression via =(?xs-xs)= or =(?xs-xs:&#xA;  .... )= syntax&#xA;- comments =(?# ... )=&#xA;&#xA;Most of the more esoteric PCRE features can&#39;t really be supported&#xA;by simple translation to Elisp regexps. These include the&#xA;different lookaround assertions, conditionals, and the&#xA;&#34;backtracking control verbs&#34; =(* ...)= . OTOH, there are a few&#xA;other syntaxes which are currently unsupported and possibly could be:&#xA;&#xA;- =\L=, =\U=, =\l=, =\u= case modifiers&#xA;- =\g{...}= backreferences&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*** Other limitations&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The order of alternatives and characters in char classes sometimes gets shifted around, which is annoying.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Although the string parser tries to interpret PCRE&#39;s octal and hexadecimal escapes correctly, there are problems with matching 8-bit characters that I don&#39;t use enough to properly understand, e.g.: : (string-match-p (rxt-pcre-to-elisp &#34;\377&#34;) &#34;\377&#34;) =&amp;gt; nil A fix for this would be welcome.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Most of PCRE&#39;s rules for how =^=, =\A=, =$= and =\Z= interact with newlines are not implemented, since they seem less relevant to Emacs&#39;s buffer-oriented rather than line-oriented model. However, the different meanings of the =.= metacharacter &lt;em&gt;are&lt;/em&gt; implemented (it matches newlines with the =/s= flag, but not otherwise).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Not currently namespace clean (both =rxt-= and a couple of =pcre-= functions).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** TODO:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Python-specific extensions to PCRE?&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Language-specific stuff to enable regexp font-locking and explaining in different modes. Each language would need two functions, which could be kept in an alist:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt; &lt;p&gt;A function to read PCRE regexps, taking the string syntax into account. E.g., Python has single-quoted, double-quoted and raw strings, each with different quoting rules. PHP has the kind of belt-and-suspenders solution you would expect: regexps are in strings, /and/ you have to include the =/ ... /= delimiters! Duh.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;A function to copy faces back from the parsed string to the original buffer text. This has to recognize any escape sequences so they can be treated as a single character.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Internal details Internally, =rxt= defines an abstract syntax tree data type for regular expressions, parsers for Elisp and PCRE syntax, and &#34;unparsers&#34; from to PCRE, rx, and SRE syntax. Converting from a parsed syntax tree to Elisp syntax is a two-step process: first convert to =rx= form, then let =rx-to-string= do the heavy lifting. See =rxt-parse-re=, =rxt-adt-&amp;gt;pcre=, =rxt-adt-&amp;gt;rx=, and =rxt-adt-&amp;gt;sre=, and the section beginning &#34;Regexp ADT&#34; in pcre2el.el for details.&lt;/p&gt; &#xA;&lt;p&gt;This code is partially based on Olin Shivers&#39; reference SRE implementation in scsh, although it is simplified in some respects and extended in others. See =scsh/re.scm=, =scsh/spencer.scm= and =scsh/posixstr.scm= in the =scsh= source tree for details. In particular, =pcre2el= steals the idea of an abstract data type for regular expressions and the general structure of the string regexp parser and unparser. The data types for character sets are extended in order to support symbolic translation between character set expressions without assuming a small (Latin1) character set. The string parser is also extended to parse a bigger variety of constructions, including POSIX character classes and various Emacs and Perl regexp assertions. Otherwise, only the bare minimum of scsh&#39;s abstract data type is implemented.&lt;/p&gt; &#xA;&lt;p&gt;** Soapbox Emacs regexps have their annoyances, but it is worth getting used to them. The Emacs assertions for word boundaries, symbol boundaries, and syntax classes depending on the syntax of the mode in effect are especially useful. (PCRE has =\b= for word-boundary, but AFAIK it doesn&#39;t have separate assertions for beginning-of-word and end-of-word). Other things that might be done with huge regexps in other languages can be expressed more understandably in Elisp using combinations of `save-excursion&#39; with the various searches (regexp, literal, skip-syntax-forward, sexp-movement functions, etc.).&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s not much point in using =rxt-pcre-to-elisp= to use PCRE notation in a Lisp program you&#39;re going to maintain, since you still have to double all the backslashes. Better to just use the converted result (or better yet, the =rx= form).&lt;/p&gt; &#xA;&lt;p&gt;** History and acknowledgments This was originally created out of an answer to a stackoverflow question: &lt;a href=&#34;http://stackoverflow.com/questions/9118183/elisp-mechanism-for-converting-pcre-regexps-to-emacs-regexps&#34;&gt;http://stackoverflow.com/questions/9118183/elisp-mechanism-for-converting-pcre-regexps-to-emacs-regexps&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Thanks to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Wes Hardaker (hardaker) for the initial inspiration and subsequent hacking&lt;/li&gt; &#xA; &lt;li&gt;priyadarshan for requesting RX/SRE support&lt;/li&gt; &#xA; &lt;li&gt;Daniel Colascione (dcolascione) for a patch to support Emacs&#39;s explicitly-numbered match groups&lt;/li&gt; &#xA; &lt;li&gt;Aaron Meurer (asmeurer) for requesting Isearch support&lt;/li&gt; &#xA; &lt;li&gt;Philippe Vaucher (silex) for a patch to support =ibuffer-do-replace-regexp= in PCRE mode&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>