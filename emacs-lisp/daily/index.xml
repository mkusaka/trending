<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-21T01:29:31Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jrbeeman/emacs.d</title>
    <updated>2023-12-21T01:29:31Z</updated>
    <id>tag:github.com,2023-12-21:/jrbeeman/emacs.d</id>
    <link href="https://github.com/jrbeeman/emacs.d" rel="alternate"></link>
    <summary type="html">&lt;p&gt;I&#39;m tired of hacking other folks&#39; configs to pieces... my simple .emacs.d&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;A bit of the concept and structure for this config is lifted from the core of emacs-prelude (&lt;a href=&#34;https://github.com/bbatsov/emacs-prelude&#34;&gt;https://github.com/bbatsov/emacs-prelude&lt;/a&gt;) but it&#39;s also dramatically simplified.&lt;/p&gt; &#xA;&lt;p&gt;This is currently built against &lt;a href=&#34;http://emacsformacosx.com/&#34;&gt;Emacs 24 pre-release on OS X&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Current features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Very basic configuration of Emacs environment&lt;/li&gt; &#xA; &lt;li&gt;Zenburn theme&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ejmr/php-mode&#34;&gt;php-mode&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jrbeeman/drupal-mode&#34;&gt;drupal-mode&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/mooz/js2-mode&#34;&gt;js2-mode&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://jblevins.org/projects/markdown-mode/&#34;&gt;markdown-mode&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation / setup&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone this repository&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;git submodule init&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;git submodule update&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>skeeto/at-el</title>
    <updated>2023-12-21T01:29:31Z</updated>
    <id>tag:github.com,2023-12-21:/skeeto/at-el</id>
    <link href="https://github.com/skeeto/at-el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Prototype-based Emacs Lisp object system&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;@, another object system for Emacs Lisp&lt;/h1&gt; &#xA;&lt;p&gt;@ is a library providing a domain-specific language for multiple-inheritance prototype-based objects in Emacs Lisp. The goal is to provide a platform for elegant object-oriented Emacs Lisp.&lt;/p&gt; &#xA;&lt;p&gt;The root object of the @ object system is &lt;code&gt;@&lt;/code&gt;. New objects are created with the &lt;code&gt;@extend&lt;/code&gt; function, by extending existing objects. Given no objects to extend, new objects will implicitly extend &lt;code&gt;@&lt;/code&gt;. Keyword arguments provided to &lt;code&gt;@extend&lt;/code&gt; are assigned as properties on the new object.&lt;/p&gt; &#xA;&lt;p&gt;Properties are looked up using &lt;code&gt;eq&lt;/code&gt;, so stick to keywords, symbols, and integers as property keys. The parent prototypes of an object, used in property lookups, are listed in the &lt;code&gt;:proto&lt;/code&gt; property of the object. This can be modified at any time to change the prototype chain.&lt;/p&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;http://nullprogram.com/blog/2013/04/07/&#34;&gt;Prototype-based Elisp Objects with @&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Prototype Library&lt;/h2&gt; &#xA;&lt;p&gt;Practical example @ prototypes can be found under lib/. When prototypes are stored in global variables following the @ naming convention, as demonstrated in the examples, their methods can be looked up with &lt;code&gt;describe-@&lt;/code&gt; (&lt;kbd&gt;C-h @&lt;/kbd&gt;), similar to &lt;code&gt;describe-function&lt;/code&gt; (&lt;kbd&gt;C-h f&lt;/kbd&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Feature Demonstration&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s a hands-on example of @&#39;s features.&lt;/p&gt; &#xA;&lt;h3&gt;Property Access&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(require &#39;@)&#xA;&#xA;;; Create a rectangle prototype, extending the root object @.&#xA;;; Convention: prefix &#34;class&#34; variable names with @.&#xA;(defvar @rectangle (@extend :width nil :height nil))&#xA;&#xA;;; The @ function is used to access properties of an object, following&#xA;;; the prototype chain breadth-first as necessary. An error is thrown&#xA;;; if the property has not been defined.&#xA;(@ @rectangle :width) ; =&amp;gt; nil&#xA;&#xA;;; The @ function is setf-able. Assignment *always* happens on the&#xA;;; immediate object, never on a parent prototype.&#xA;(setf (@ @rectangle :width) 0)&#xA;(setf (@ @rectangle :height) 0)&#xA;&#xA;;; Define the method :area on @rectangle.&#xA;;; The first argument is this/self. Convention: call it @@.&#xA;(setf (@ @rectangle :area) (lambda (@@) (* (@ @@ :width) (@ @@ :height))))&#xA;&#xA;;; Convenience macro def@ for writing methods. Symbols like @: will be&#xA;;; replaced by lookups on @@. The following is equivalent to the above&#xA;;; definition.&#xA;(def@ @rectangle :area ()&#xA;  (* @:width @:height))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiple Inheritance&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;;; Create a color mix-in prototype&#xA;(defvar @colored (@extend :color (list)))&#xA;&#xA;;; The @: variables are setf-able, too.&#xA;(def@ @colored :mix (color)&#xA;  (push color @:color))&#xA;&#xA;;; Create a colored rectangle from the prototypes.&#xA;(defvar foo (@extend @colored @rectangle :width 10 :height 4))&#xA;&#xA;;; @! is used to call methods. The object itself is passed as the&#xA;;; first argument to the function stored on that prototype&#39;s property.&#xA;(@! foo :area)  ; =&amp;gt; 40&#xA;(@! foo :mix :red)&#xA;(@! foo :mix :blue)&#xA;(@ foo :color)  ; =&amp;gt; (:blue :red)&#xA;&#xA;;; @: variables are turned into method calls when in function position.&#xA;(def@ foo :describe ()&#xA;  (format &#34;{color: %s, area: %d}&#34; @:color (@:area)))&#xA;&#xA;(@! foo :describe)  ; =&amp;gt; &#34;{color: (:blue :red), area: 40}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Constructors and Super Methods&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;;; By convention, constructors are the :init method. The @^:&#xA;;; &#34;variables&#34; are used to access super methods, including :init. Use&#xA;;; this to chain constructors and methods up the prototype chain (like&#xA;;; CLOS&#39;s `call-next-method&#39;).&#xA;(def@ @rectangle :init (width height)&#xA;  (@^:init)&#xA;  (setf @:width width @:height height))&#xA;&#xA;;; The :new method on @ extends @@ with a new object and calls :init&#xA;;; on it with the provided arguments.&#xA;(@! (@! @rectangle :new 13.2 2.1) :area) ; =&amp;gt; 27.72&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dynamic Property Getters and Setters&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;;; If a property is not found in the prototype chain, the :get method&#xA;;; is used to determine the value.&#xA;(let ((obj (@extend)))&#xA;  (def@ obj :get (property)&#xA;    (format &#34;got %s&#34; property))&#xA;  (@ obj :foo))&#xA;; =&amp;gt; &#34;got :foo&#34;&#xA;&#xA;;; The :get method on @, the default getter, produces an error if a&#xA;;; property is unbound. If you would rather unbound properties return&#xA;;; nil mix in @soft-get, which provides an alternate default :get&#xA;;; method.&#xA;(@ (@extend @rectangle @soft-get) :foo) ; =&amp;gt; nil&#xA;&#xA;;; Properties are assigned using the :set method. The :set method on @&#xA;;; does standard property assignment as would be expected. This can be&#xA;;; overridden for custom assignment behavior.&#xA;(let ((foo-only (@extend)))&#xA;  (def@ foo-only :set (property value)&#xA;    (if (string-match-p &#34;^:foo&#34; (prin1-to-string property))&#xA;        (@^:set property value)  ; supermethod&#xA;      (error &#34;Only :foo* properties allowed!&#34;)))&#xA;  (setf (@ foo-only :foo-bar) &#39;a)  ; ok&#xA;  (setf (@ foo-only :bar) &#39;b))     ; ERROR&#xA;&#xA;;; Using this, an @immutable prototype mixin is provided that&#xA;;; disallows all property assignments.&#xA;(setf (@ (@extend @immutable) :foo) &#39;a)  ; ERROR&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The @vector prototype under lib/ shows how these can be useful for providing pseudo-properties.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;;; Built on :set, a @watchable mixin is provided for observing all of&#xA;;; the changes to any object.&#xA;(let ((history ())&#xA;      (obj (@extend @watchable)))&#xA;  (@! obj :watch (lambda (obj prop new) (push (list property new) history)))&#xA;  (setf (@ obj :foo) 0)&#xA;  (setf (@ obj :foo) 1)&#xA;  (setf (@ obj :bar) &#39;a)&#xA;  (setf (@ obj :bar) &#39;b)&#xA;  history)&#xA;; =&amp;gt; ((:bar b) (:bar a) (:foo 1) (:foo 0))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reflection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;;; @is is the classical &#34;instanceof&#34; operator. It works on any type of&#xA;;; object in both positions.&#xA;(@is foo @colored)   ; =&amp;gt; t&#xA;(@is foo @rectangle) ; =&amp;gt; t&#xA;(@is foo foo)        ; =&amp;gt; t&#xA;(@is foo @)          ; =&amp;gt; t&#xA;(@is foo (@extend))  ; =&amp;gt; nil&#xA;(@is [1 2 3] @)      ; =&amp;gt; nil&#xA;&#xA;;; The :is method on @ can also be used for this.&#xA;(@! @colored :is @)    ; =&amp;gt; t&#xA;(@! foo :is @colored)  ; =&amp;gt; t&#xA;&#xA;;; The :keys method on @ can be used to list the keys on an object.&#xA;(@! foo :keys)  ; =&amp;gt; (:proto :width :height :color)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Syntax Highlighting&lt;/h3&gt; &#xA;&lt;p&gt;The library provides syntax highlighting for &#39;def@&#39; and &#39;@:&#39; variables in emacs-lisp-mode, so the above @ uses will look more official in an Emacs buffer.&lt;/p&gt;</summary>
  </entry>
</feed>