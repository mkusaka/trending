<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-26T01:38:54Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>karthink/consult-dir</title>
    <updated>2022-07-26T01:38:54Z</updated>
    <id>tag:github.com,2022-07-26:/karthink/consult-dir</id>
    <link href="https://github.com/karthink/consult-dir" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Insert paths into the minibuffer prompt in Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: consult-dir: insert paths into minibuffer prompts in Emacs&lt;/p&gt; &#xA;&lt;p&gt;:BADGE: [[https://melpa.org/#/consult-dir][file:https://melpa.org/packages/consult-dir-badge.svg]] :END:&lt;/p&gt; &#xA;&lt;p&gt;#+attr_html: :width 800px :align center [[file:media/consult-dir.png]]&lt;/p&gt; &#xA;&lt;p&gt;Consult-dir allows you to easily insert directory paths into the minibuffer prompt in Emacs.&lt;/p&gt; &#xA;&lt;p&gt;When using the minibuffer, you can switch - with completion and filtering provided by your completion setup - to any directory you&#39;ve visited recently, or to a project, a bookmarked directory or even a remote host via tramp. The minibuffer prompt will be replaced with the directory you choose.&lt;/p&gt; &#xA;&lt;h1&gt;You can do this at any time, including when using the minibuffer.&lt;/h1&gt; &#xA;&lt;p&gt;Why would you want to do this?&lt;/p&gt; &#xA;&lt;p&gt;To avoid &#34;navigating&#34; long distances when picking a file or directory in any Emacs command that requires one. Here I use it to select a distant directory when copying a file with dired:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/8607532/128619960-a89b578c-b627-417b-b045-06bcbb178b71.mp4&#34;&gt;https://user-images.githubusercontent.com/8607532/128619960-a89b578c-b627-417b-b045-06bcbb178b71.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/8607532/128617436-63aeafcb-02c5-4ae8-894f-9a1f6c240267.mp4&#34;&gt;https://user-images.githubusercontent.com/8607532/128617436-63aeafcb-02c5-4ae8-894f-9a1f6c240267.mp4&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Think of it like the shell tools [[https://github.com/wting/autojump][autojump]], [[https://github.com/clvv/fasd][fasd]] or z but for Emacs. See the demos section below for many more examples. =consult-dir= works with all Emacs commands that require you to specify file paths, and with [[https://github.com/oantolin/embark][Embark actions]] on files.&lt;/p&gt; &#xA;&lt;p&gt;The directory candidates are collected from user bookmarks, Projectile project roots (if available), project.el project roots (if available) and recentf file locations. The =default-directory= variable is not changed in the process.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contents :TOC_3:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#installation][Installation]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#with-use-package][With =use-package=]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#general-method][General method]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#usage][Usage]]&lt;/li&gt; &#xA; &lt;li&gt;[[#demos][Demos]]&lt;/li&gt; &#xA; &lt;li&gt;[[#configuration][Configuration]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#directory-sources][Directory sources]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#bookmarks][Bookmarks]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#recent-directories][Recent directories]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#project-directories-projectel][Project directories (Project.el)]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#project-directories-projectile][Project directories (Projectile)]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#remote-hosts][Remote hosts]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#docker-hosts][Docker hosts]]&lt;/li&gt; &#xA;     &lt;li&gt;[[#writing-your-own-directory-source][Writing your own directory source]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#default-consult-dir-action][Default =consult-dir= action]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#file-name-shadowing][File name shadowing]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#alternatives][Alternatives]]&lt;/li&gt; &#xA; &lt;li&gt;[[#acknowledgements][Acknowledgements]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation =consult-dir= is on MELPA.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** With =use-package= #+BEGIN_SRC emacs-lisp (use-package consult-dir :ensure t :bind ((&#34;C-x C-d&#34; . consult-dir) :map minibuffer-local-completion-map (&#34;C-x C-d&#34; . consult-dir) (&#34;C-x C-j&#34; . consult-dir-jump-file))) #+END_SRC Replace =minibuffer-local-completion-map= above with&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=vertico-map= if you use Vertico,&lt;/li&gt; &#xA; &lt;li&gt;=selectrum-minibuffer-map= if you use Selectrum.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** General method After adding MELPA to your package archives, #+BEGIN_SRC emacs-lisp (add-to-list &#39;package-archives &#39;(&#34;melpa&#34; . &#34;&lt;a href=&#34;http://melpa.org/packages/&#34;&gt;http://melpa.org/packages/&lt;/a&gt;&#34;)) #+END_SRC you can install it with =M-x package-install consult-dir= and bind =consult-dir= as convenient: #+begin_src emacs-lisp (define-key global-map (kbd &#34;C-x C-d&#34;) #&#39;consult-dir) (define-key minibuffer-local-completion-map (kbd &#34;C-x C-d&#34;) #&#39;consult-dir) #+end_src If you want to use the file-jump functionality, you can bind =consult-dir-jump-file= in the =minibuffer-local-completion-map=. #+BEGIN_SRC emacs-lisp (define-key minibuffer-local-completion-map (kbd &#34;C-x C-j&#34;) #&#39;consult-dir-jump-file) #+END_SRC Replace =minibuffer-local-completion-map= above with&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=vertico-map= if you use Vertico,&lt;/li&gt; &#xA; &lt;li&gt;=selectrum-minibuffer-map= if you use Selectrum.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage Call =consult-dir= when in the minibuffer to choose a directory with completion and insert it into the minibuffer prompt, shadowing or replacing the directory path showing currently. The file name part of the text is retained. This lets the user switch to distant directories very quickly when finding files, for instance.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Call =consult-dir= from a regular buffer to choose a directory with completion and then interactively find a file in that directory. The command run with this directory is configurable via =consult-dir-default-command= and defaults to =find-file=.&lt;/p&gt; &#xA;&lt;p&gt;Call =consult-dir-jump-file= from the minibuffer to asynchronously find a file anywhere under the directory that is currently in the prompt. This can be used with =consult-dir= to quickly switch directories and find files at an arbitrary depth under them. =consult-dir-jump-file= uses =consult-find= under the hood.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Demos Here I show the different directory sources using Consult&#39;s narrowing feature, then use =consult-dir= to easily jump around the filesystem and open files. I also use =consult-dir-jump-file= to quickly drill down a directory when I don&#39;t find the file I&#39;m looking for at the top level:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/8607532/127817864-57ca9ec5-af67-4ee8-9410-4758c8450c4b.mp4&#34;&gt;https://user-images.githubusercontent.com/8607532/127817864-57ca9ec5-af67-4ee8-9410-4758c8450c4b.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/8607532/127790046-309df054-3e89-4e3c-adcf-16ec5028ad80.mp4&#34;&gt;https://user-images.githubusercontent.com/8607532/127790046-309df054-3e89-4e3c-adcf-16ec5028ad80.mp4&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;In this demo I call =consult-grep= with a prefix argument. This requires me to specify a directory to grep inside of, so I use =consult-dir= to specify that directory:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/8607532/127790057-1fa9f81b-2c3f-412d-be36-925773451c71.mp4&#34;&gt;https://user-images.githubusercontent.com/8607532/127790057-1fa9f81b-2c3f-412d-be36-925773451c71.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here I use =consult-dir= to jump to one of my project directories when attaching a file to an email:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/8607532/127790065-39ddc117-5e1a-4580-a009-bc0cebd71ad8.mp4&#34;&gt;https://user-images.githubusercontent.com/8607532/127790065-39ddc117-5e1a-4580-a009-bc0cebd71ad8.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;In this example I combine =consult-dir= with Embark. I use =consult-dir= to specify a directory, then Embark to spawn an eshell there. I then use =consult-dir= again when tab-completing inside eshell to specify a distant directory to copy files from. Finally I use =consult-dir= with Embark to jump to a bookmark in a window-split:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/8607532/127790071-4f98d212-c127-48e1-84cd-01701cd63d64.mp4&#34;&gt;https://user-images.githubusercontent.com/8607532/127790071-4f98d212-c127-48e1-84cd-01701cd63d64.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;(In these demos I am using Vertico as my completion system.)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Configuration =consult-dir= should work out of the box with no configuration needed beyond binding it to a key.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;However, only bookmarked directories and Project.el projects are displayed by default. if you use Projectile or want finer control over the directories that are offered as candidates to jump to, read on.&lt;/p&gt; &#xA;&lt;p&gt;** Directory sources *** Bookmarks Enabled by default. To disable, customize =consult-dir-sources=.&lt;/p&gt; &#xA;&lt;p&gt;*** Recent directories To enable, turn on recentf-mode. (=M-x recentf-mode=). Note that if you don&#39;t already use recentf-mode, the recentf directory cache will start out empty and build up over time as you use Emacs.&lt;/p&gt; &#xA;&lt;p&gt;*** Project directories (Project.el) Enabled by default. To disable, customize =consult-dir-project-list-function= or #+BEGIN_SRC emacs-lisp (setq consult-dir-project-list-function nil) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;*** Project directories (Projectile) To enable, customize =consult-dir-project-list-function= or #+BEGIN_SRC emacs-lisp (setq consult-dir-project-list-function #&#39;consult-dir-projectile-dirs) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;*** Remote hosts Also included are a number of sources for interacting with remote hosts via tramp, principally:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=consult-dir--source-tramp-local= for a set list of local/custom hosts (see =consult-dir-tramp-local-hosts= to customize)&lt;/li&gt; &#xA; &lt;li&gt;=consult-dir--source-tramp-ssh= for a list of parsed hosts from your =~/.ssh/config=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default consult-dir does not display known SSH hosts as a separate directory source. If you wish to enable it, customize =consult-dir-sources= or use the following:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (add-to-list &#39;consult-dir-sources &#39;consult-dir--source-tramp-ssh t) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Docker hosts&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also possible to define a source to switch to Docker containers using consult-dir. Note that this requires the [[https://github.com/emacs-pe/docker-tramp.el][docker-tramp]] package to be installed:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun consult-dir--tramp-docker-hosts () &#34;Get a list of hosts from docker.&#34; (when (require &#39;docker-tramp nil t) (let ((hosts) (docker-tramp-use-names t)) (dolist (cand (docker-tramp--parse-running-containers)) (let ((user (unless (string-empty-p (car cand)) (concat (car cand) &#34;@&#34;))) (host (car (cdr cand)))) (push (concat &#34;/docker:&#34; user host &#34;:/&#34;) hosts))) hosts)))&lt;/p&gt; &#xA;&lt;p&gt;(defvar consult-dir--source-tramp-docker &lt;code&gt;(:name &#34;Docker&#34; :narrow ?d :category file :face consult-file :history file-name-history :items ,#&#39;consult-dir--tramp-docker-hosts) &#34;Docker candiadate source for &lt;/code&gt;consult-dir&#39;.&#34;)&lt;/p&gt; &#xA;&lt;p&gt;;; Adding to the list of consult-dir sources (add-to-list &#39;consult-dir-sources &#39;consult-dir--source-tramp-docker t) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Then amend =consult-dir-sources= as in the above snippet to include the source you defined.&lt;/p&gt; &#xA;&lt;p&gt;*** Writing your own directory source If none of the above include directories you want to jump to, you can write your own source. As a template, here is a source that adds paths provided by the shell tool [[https://github.com/clvv/fasd][Fasd]] to consult-dir:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp ;; A function that returns a list of directories (defun consult-dir--fasd-dirs () &#34;Return list of fasd dirs.&#34; (split-string (shell-command-to-string &#34;fasd -ld&#34;) &#34;\n&#34; t))&lt;/p&gt; &#xA;&lt;p&gt;;; A consult source that calls this function (defvar consult-dir--source-fasd &lt;code&gt;(:name &#34;Fasd dirs&#34; :narrow ?f :category file :face consult-file :history file-name-history :enabled ,(lambda () (executable-find &#34;fasd&#34;)) :items ,#&#39;consult-dir--fasd-dirs) &#34;Fasd directory source for &lt;/code&gt;consult-dir&#39;.&#34;)&lt;/p&gt; &#xA;&lt;p&gt;;; Adding to the list of consult-dir sources (add-to-list &#39;consult-dir-sources &#39;consult-dir--source-fasd t) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;For additional directory sources, check out the [[https://github.com/karthink/consult-dir/wiki#additional-directory-sources][wiki]].&lt;/p&gt; &#xA;&lt;p&gt;** Default =consult-dir= action When called from a regular buffer (/i.e/ not the minibuffer), =consult-dir= defaults to calling =find-file= after you choose a directory. To set it to open the directory in dired instead or to run a custom command, customize =consult-dir-default-command=.&lt;/p&gt; &#xA;&lt;p&gt;** File name shadowing By default, choosing a directory using =consult-dir= when in the minibuffer results in the text already in the prompt being &#34;shadowed&#34; or made inactive, but you can still delete the new text to recover it. You can make the new text replace the old instead by setting =consult-dir-shadow-filenames= to =nil=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alternatives =consult-dir= is akin to shell tools like [[https://github.com/wting/autojump][autojump]] or [[https://github.com/clvv/fasd][fasd]] but for all file/directory contexts in Emacs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=consult-buffer= (part of Consult) already allows you to switch to bookmarks and recentf files, so this might be sufficient for you if you need to visit a proximal set of files quickly. =consult-dir= is different in that it is composable with all Emacs commands that require you to specify a directory and thus works in more contexts.&lt;/p&gt; &#xA;&lt;p&gt;Projectile and the built-in project.el have extensive support for listing and quickly switching projects and running actions on them. =consult-dir= is more of a one-stop shop (&#34;just get me there&#34;) for switching directories as it includes recent directories and bookmarks in the mix, allows jumping to files with =consult-dir-jump-file=, and supports running arbitrary actions on directories using Embark. Of course, it also allows for fast directory selection when using any Emacs command that requires specifying a directory.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Acknowledgements&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/dmendler][Daniel Mendler]] for writing Consult and help with the code&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/oantolin][Omar Antolin Camarena]] for many suggestions on the design of consult-dir&lt;/li&gt; &#xA; &lt;li&gt;[[https://old.reddit.com/r/emacs/comments/p4wk1u/consultdir_switch_directories_in_emacs_at_any_time/h936s3t/][u/harizvi]] for the code to include Fasd directories.&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/elken][Ellis Kenyő]] for the TRAMP directory sources.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Local Variables:&lt;/h1&gt; &#xA;&lt;h1&gt;eval: (when (featurep &#39;toc-org) (toc-org-mode))&lt;/h1&gt; &#xA;&lt;h1&gt;End:&lt;/h1&gt;</summary>
  </entry>
  <entry>
    <title>volrath/treepy.el</title>
    <updated>2022-07-26T01:38:54Z</updated>
    <id>tag:github.com,2022-07-26:/volrath/treepy.el</id>
    <link href="https://github.com/volrath/treepy.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Generic tree traversing tools for Emacs Lisp&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/treepy.png&#34; align=&#34;right&#34;&gt; &#xA;&lt;h1&gt;treepy.el (&lt;em&gt;ˈtriːpi&lt;/em&gt;)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://melpa.org/#/treepy&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/treepy-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Emacs-25-8e44bd.svg?sanitize=true&#34; alt=&#34;Emacs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/volrath/treepy.el&#34;&gt;&lt;img src=&#34;https://travis-ci.org/volrath/treepy.el.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A set of generic functions for traversing tree-like data structures recursively and/or iteratively, ported from &lt;a href=&#34;https://clojure.github.io/clojure/clojure.walk-api.html&#34;&gt;&lt;code&gt;clojure.walk&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://clojure.github.io/clojure/clojure.zip-api.html&#34;&gt;&lt;code&gt;clojure.zip&lt;/code&gt;&lt;/a&gt; respectively.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#available-functions&#34;&gt;Available Functions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#walker&#34;&gt;Walker&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#zipper&#34;&gt;Zipper&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#main-differences-with-clojure-libraries&#34;&gt;Main differences with Clojure libraries&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#clojure.walk&#34;&gt;clojure.walk&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#clojure.zip&#34;&gt;clojure.zip&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/volrath/treepy.el/master/#prior-art&#34;&gt;Prior Art&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;treepy&lt;/em&gt; supports &lt;code&gt;Emacs 25.1+&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is available in MELPA, which is the recommended way to install it and keep it up to date.&lt;/p&gt; &#xA;&lt;p&gt;To install it, you may do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x package-install RET treepy RET&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the installation doesn&#39;t work, consider refreshing the package list: &lt;code&gt;M-x package-refresh-contents [RET]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For a manual installation, just place &lt;code&gt;treepy.el&lt;/code&gt; in your &lt;code&gt;load-path&lt;/code&gt; and &lt;code&gt;(require &#39;treepy)&lt;/code&gt;. Then you&#39;ll have all the &lt;code&gt;treepy-*&lt;/code&gt; functions available.&lt;/p&gt; &#xA;&lt;h2&gt;Available functions&lt;/h2&gt; &#xA;&lt;h3&gt;Walker&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-walk&lt;/code&gt; inner outer form&lt;/p&gt; &lt;p&gt;Traverses FORM, an arbitrary data structure. INNER and OUTER are functions. Applies INNER to each element of FORM, building up a data structure of the same type, then applies OUTER to the result. Recognizes cons, lists, alists, vectors and hash tables.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-postwalk&lt;/code&gt; f form&lt;/p&gt; &lt;p&gt;Performs a depth-first, post-order traversal of F applied to FORM. Calls F on each sub-form, uses F&#39;s return value in place of the original. Recognizes cons, lists, alists, vectors and hash tables.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-prewalk&lt;/code&gt; f form&lt;/p&gt; &lt;p&gt;Like &lt;code&gt;treepy-postwalk&lt;/code&gt;, Performs function F on FORM but does pre-order traversal.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-prewalk-demo&lt;/code&gt; form&lt;/p&gt; &lt;p&gt;Demonstrates the behavior of &lt;code&gt;treepy-prewalk&lt;/code&gt; for FORM. Returns a list of each form as it is walked.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-postwalk-demo&lt;/code&gt; form&lt;/p&gt; &lt;p&gt;Demonstrates the behavior of &lt;code&gt;treepy-postwalk&lt;/code&gt; for FORM. Returns a list of each form as it is walked.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-postwalk-replace&lt;/code&gt; smap form &amp;amp;optional testfn&lt;/p&gt; &lt;p&gt;Recursively transforms FORM by replacing keys in SMAP with their values. Does replacement at the root of the tree first. The optional TESTFN is passed to &lt;code&gt;map-contains-key&lt;/code&gt; as the testing equality function.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-postwalk-replace&lt;/code&gt; smap form &amp;amp;optional testfn&lt;/p&gt; &lt;p&gt;Recursively transforms FORM by replacing keys in SMAP with their values. Does replacement at the leaves of the tree first. The optional TESTFN is passed to &lt;code&gt;map-contains-key&lt;/code&gt; as the testing equality function.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Zipper&lt;/h3&gt; &#xA;&lt;h4&gt;Construction&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-zipper&lt;/code&gt; branchp children make-node root&lt;/p&gt; &lt;p&gt;Creates a new zipper structure.&lt;/p&gt; &lt;p&gt;BRANCHP is a function that, given a node, returns t if it can have children, even if it currently doesn&#39;t.&lt;/p&gt; &lt;p&gt;CHILDREN is a function that, given a branch node, returns a seq of its children.&lt;/p&gt; &lt;p&gt;MAKE-NODE is a function that, given an existing node and a seq of children, returns a new branch node with the supplied children.&lt;/p&gt; &lt;p&gt;ROOT is the root node.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-list-zip&lt;/code&gt; root&lt;/p&gt; &lt;p&gt;Returns a zipper for nested lists, given a ROOT list.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-vector-zip&lt;/code&gt; root&lt;/p&gt; &lt;p&gt;Returns a zipper for nested vectors, given a ROOT vector.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Context / Path&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-node&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the node at LOC.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-branch-p&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns &lt;code&gt;t&lt;/code&gt; if the node at LOC is a branch. &lt;code&gt;nil&lt;/code&gt; otherwise.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-children&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns a children list of the node at LOC, which must be a branch.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-make-node&lt;/code&gt; loc node children&lt;/p&gt; &lt;p&gt;Returns a new branch node, given an existing LOC, NODE and new CHILDREN. The LOC is only used to supply the constructor.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-path&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns a list of nodes leading to the given LOC.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-lefts&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns a list of the left sibilings of this LOC.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-rights&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns a list of the right sibilings of this LOC.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Navigation&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-down&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the leftmost child of the node at this LOC, or &lt;code&gt;nil&lt;/code&gt; if no children.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-up&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the parent of the node at this LOC, or &lt;code&gt;nil&lt;/code&gt; if at the top.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-root&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Zips from LOC all the way up and return the root node, reflecting any changes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-right&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the right sibling of the node at this LOC, or &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-rightmost&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the rightmost sibling of the node at this LOC, or self.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-left&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the left sibling of the node at this LOC, or &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-leftmost&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the loc of the leftmost sibling of the node at this LOC, or self.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-leftmost-descendant&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns the leftmost descendant of the given LOC. (ie, down repeatedly).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Modification&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-insert-left&lt;/code&gt; loc item&lt;/p&gt; &lt;p&gt;Inserts ITEM as the left sibling of this LOC&#39;S node, without moving.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-insert-right&lt;/code&gt; loc item&lt;/p&gt; &lt;p&gt;Inserts ITEM as the right sibling of this LOC&#39;s node, without moving.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-replace&lt;/code&gt; loc node&lt;/p&gt; &lt;p&gt;Replaces the node in this LOC with the given NODE, without moving.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-edit&lt;/code&gt; loc f &amp;amp;rest args&lt;/p&gt; &lt;p&gt;Replaces the node at this LOC with the value of &lt;code&gt;(F node ARGS)&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-insert-child&lt;/code&gt; loc item&lt;/p&gt; &lt;p&gt;Inserts ITEM as the leftmost child of this LOC&#39;s node, without moving.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-append-child&lt;/code&gt; loc item&lt;/p&gt; &lt;p&gt;Inserts ITEM as the rightmost child of this LOC&#39;S node, without moving.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-remove&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Removes the node at LOC. Returns the loc that would have preceded it in a depth-first walk.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Enumeration&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-next&lt;/code&gt; loc &amp;amp;optional order&lt;/p&gt; &lt;p&gt;Moves to the next LOC in the hierarchy, depth-first, using ORDER if given. Possible values for ORDER are &lt;code&gt;:preorder&lt;/code&gt; and &lt;code&gt;:postorder&lt;/code&gt;, defaults to the former. When reaching the end, returns a distinguished loc detectable via &lt;code&gt;treepy-end-p&lt;/code&gt;. If already at the end, stays there.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-next&lt;/code&gt; loc &amp;amp;optional order&lt;/p&gt; &lt;p&gt;Moves to the previous LOC in the hierarchy, depth-first, using ORDER if given. Possible values for ORDER are &lt;code&gt;:preorder&lt;/code&gt; and &lt;code&gt;:postorder&lt;/code&gt;, defaults to the former.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-end-p&lt;/code&gt; loc&lt;/p&gt; &lt;p&gt;Returns &lt;code&gt;t&lt;/code&gt; if LOC represents the end of a depth-first walk, &lt;code&gt;nil&lt;/code&gt; otherwise.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Main differences with clojure libraries&lt;/h2&gt; &#xA;&lt;p&gt;Even though one of &lt;em&gt;treepy&#39;s&lt;/em&gt; goals is to provide an API that&#39;s as close as possible to &lt;a href=&#34;https://clojure.github.io/clojure/clojure.walk-api.html&#34;&gt;&lt;code&gt;clojure.walk&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://clojure.github.io/clojure/clojure.zip-api.html&#34;&gt;&lt;code&gt;clojure.zip&lt;/code&gt;&lt;/a&gt;, there are some subtle (and not so subtle) differences derived from elisp/clojure distinct data structures, levels of abstraction, and code conventions.&lt;/p&gt; &#xA;&lt;p&gt;The most notorious difference is the name of the functions. For every function in Clojure world, there&#39;s a &lt;em&gt;treepy&lt;/em&gt; counterpart that&#39;s prefixed with &lt;code&gt;treepy-&lt;/code&gt;. So:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;clojure.walk/walk&lt;/code&gt; -&amp;gt; &lt;code&gt;treepy-walk&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clojure.zip/zipper&lt;/code&gt; -&amp;gt; &lt;code&gt;treepy-zipper&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;... and so on.&lt;/p&gt; &#xA;&lt;h3&gt;clojure.walk&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-walk&lt;/code&gt; (and all its derivatives) works on lists, vectors, alists and hash-tables only.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Instead of printing to stdout, &lt;code&gt;treepy-prewalk-demo&lt;/code&gt; and &lt;code&gt;treepy-postwalk-demo&lt;/code&gt; return a list of the sub forms as they get walked.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;treepy&lt;/em&gt; doesn&#39;t provide implementations for &lt;code&gt;keywordize-keys&lt;/code&gt;, &lt;code&gt;stringify-keys&lt;/code&gt; and &lt;code&gt;macroexpand-all&lt;/code&gt;. There&#39;s already a &lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/elisp/Expansion.html&#34;&gt;&lt;code&gt;macroexpand-all&lt;/code&gt; implementation built in&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;treepy-prewalk-replace&lt;/code&gt; and &lt;code&gt;treepy-postwalk-replace&lt;/code&gt; are based on the (Emacs 25) built in &lt;a href=&#34;https://github.com/emacs-mirror/emacs/raw/master/lisp/emacs-lisp/map.el#L262&#34;&gt;&lt;code&gt;map-contains-key&lt;/code&gt;&lt;/a&gt; function. Both functions take an optional a &lt;em&gt;testfn&lt;/em&gt; third parameter to be used by &lt;code&gt;map-contains-key&lt;/code&gt;. Defaults to &lt;code&gt;equal&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;clojure.zip&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;In order to follow elisp conventions, &lt;em&gt;treepy&lt;/em&gt; has a couple of other small renamings:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;clojure.zip/branch?&lt;/code&gt; -&amp;gt; &lt;code&gt;treepy-branch-p&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;clojure.zip/end?&lt;/code&gt; -&amp;gt; &lt;code&gt;treepy-end-p&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There&#39;s is no exact equivalent to &lt;code&gt;clojure.zip/seq-zip&lt;/code&gt; in &lt;em&gt;treepy&lt;/em&gt;, a &lt;code&gt;treepy-list-zip&lt;/code&gt; is provided instead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;treepy&lt;/em&gt; provides a way to traverse a tree in postorder while using the enumeration functions &lt;code&gt;treepy-next&lt;/code&gt; and &lt;code&gt;treepy-prev&lt;/code&gt;. This is done by having an extra optional parameter &lt;em&gt;order&lt;/em&gt; that can be passed to both functions:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;(treepy-next loc)  ;; =&amp;gt; next node in preorder, as in clojure.zip/next.&#xA;(treepy-next loc :preorder)  ;; =&amp;gt; also next node in preorder.&#xA;(treepy-next loc :postorder)  ;; =&amp;gt; next node in postorder.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There&#39;s a new function in &lt;em&gt;treepy&lt;/em&gt; to get the leftmost descendant of a node/loc. Unsurprisingly, it&#39;s called &lt;code&gt;treepy-leftmost-descendant&lt;/code&gt;. This function is particularly useful when trying to traverse a tree in post order, since unlike preorder trasversal, the root is NOT the first element you want walk/visit. You might want to call &lt;code&gt;(treepy-leftmost-descendant root)&lt;/code&gt; before starting to walk the nodes with &lt;code&gt;treepy-next&lt;/code&gt; in postorder.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following are some &lt;em&gt;treepy&lt;/em&gt;&#39;s implementation differences that you might not need to bother with if you just wanna use the library.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;treepy&#39;s &lt;em&gt;loc&lt;/em&gt; data structure:&lt;/strong&gt; When you create a Clojure &#34;zipper&#34; with &lt;code&gt;clojure.zip/zipper&lt;/code&gt;, you have to provide three helper functions (&lt;code&gt;branch?&lt;/code&gt;, &lt;code&gt;children&lt;/code&gt;, and &lt;code&gt;make-node&lt;/code&gt;) and a &lt;code&gt;root&lt;/code&gt; form. &lt;code&gt;clojure.zip/zipper&lt;/code&gt; will then return a tuple vector that represents a &#34;&lt;em&gt;loc&lt;/em&gt;action&#34;. The three helper functions are stored as clojure&#39;s &lt;a href=&#34;https://clojure.org/reference/metadata&#34;&gt;metadata&lt;/a&gt; into the returned &lt;em&gt;loc&lt;/em&gt;. Since there&#39;s no equivalent to metadata in Elisp, &lt;em&gt;treepy&lt;/em&gt; directly associates the three helper functions into an alist that&#39;s returned with the rest of the &lt;em&gt;loc&lt;/em&gt; information. The resulting structure of a &lt;em&gt;treepy&lt;/em&gt; &lt;code&gt;loc&lt;/code&gt; is the following:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;((&amp;lt;current node&amp;gt; . &amp;lt;path alist&amp;gt;) . ((:branch-p . #&#39;provided-branch-fn)&#xA;                                    (:children . #&#39;provided-children-fn)&#xA;                                    (:make-node . #&#39;provided-make-node-fn)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;path alist&amp;gt;&lt;/code&gt; is an alist containing the same keys and values as &lt;code&gt;clojure.zip&lt;/code&gt;&#39;s path map. Only difference is that &lt;em&gt;treepy&lt;/em&gt; uses lists instead of vectors to handle the &lt;code&gt;left&lt;/code&gt; sibilings and &lt;code&gt;pnodes&lt;/code&gt; parent nodes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Prior Art&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/xiongtx/zipper.el&#34;&gt;xiongtx/zipper.el&lt;/a&gt;: Non-generic, EIEIO, zipper implementation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/danielfm/cl-zipper&#34;&gt;danielfm/cl-zipper&lt;/a&gt;: Common Lisp zipper implementation.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;LICENSE&lt;/h2&gt; &#xA;&lt;p&gt;© 2017 Daniel Barreto&lt;/p&gt; &#xA;&lt;p&gt;Distributed under the terms of the GNU GENERAL PUBLIC LICENSE, version 3.&lt;/p&gt;</summary>
  </entry>
</feed>