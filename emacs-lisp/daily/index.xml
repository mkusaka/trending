<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-18T01:33:42Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zenmacs/.emacs.d</title>
    <updated>2023-02-18T01:33:42Z</updated>
    <id>tag:github.com,2023-02-18:/zenmacs/.emacs.d</id>
    <link href="https://github.com/zenmacs/.emacs.d" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Zenmacs - an .emacs.d&lt;/h1&gt; &#xA;&lt;h2&gt;Goal&lt;/h2&gt; &#xA;&lt;p&gt;Zenmacs has the goal of providing a lightweight IDE experience (similar to Atom, dissimilar to IntelliJ), with intuitive tools that work perfectly, a holy-grail window layout, clean support for handling/displaying arbitrarily many workspaces/projects/files, and a persistent desire for un-sucking Emacs, disregarding complexity-inducing features and consistently embracing better approaches.&lt;/p&gt; &#xA;&lt;p&gt;Often I&#39;ve gone as far as creating custom systems that subvert the Emacs way, and forking/maintaining projects as needed.&lt;/p&gt; &#xA;&lt;p&gt;The feature set aims to have just the right size: one big enough to provide a satisfactory experience, but small enough to be adoptable (less chances for bugs, lack of documentation or discrepancies in opinions).&lt;/p&gt; &#xA;&lt;p&gt;Worth noting, this is not &#34;some guy&#39;s emacs&#34;. You won&#39;t find here oddities specific to my work, locale, OS environment, opinions, etc. All such stuff is in a separate repo: &lt;code&gt;.emacs.d.overrides&lt;/code&gt;, which contents will vary per-user.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, this isn&#39;t some kind of boilerplate project with an opinionated automagical setup for every programming language under the face of Earth. For genericity, only Clojure, Elisp, and &lt;a href=&#34;https://github.com/emacs-lsp/lsp-mode&#34;&gt;lsp-mode&lt;/a&gt; are core to this project. I set up other major modes like Ruby, JavaScript etc in the mentioned &lt;code&gt;.emacs.d.overrides&lt;/code&gt; directory/repo: as one gets more specific, there&#39;s an increased chance for doing something you disagree with (or don&#39;t care about).&lt;/p&gt; &#xA;&lt;p&gt;Importantly, I&#39;ve developed a lot of Clojure-specific features, which make Zenmacs unique and powerful.&lt;/p&gt; &#xA;&lt;p&gt;You are encouraged to customize anything and everything. If Zenmacs makes it difficult for you - it&#39;s a bug!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Key features&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Keyboard shortcuts are ergonomic (free of typical emacs-isms), and are defined in a &lt;a href=&#34;https://github.com/zenmacs/.emacs.d/raw/master/lib/non-submodules/vemv.shortcuts.global.el&#34;&gt;centralized&lt;/a&gt;, OS-independent, discoverable, reloadable manner.&lt;/li&gt; &#xA; &lt;li&gt;A fixed window layout: there&#39;s always a main-window, a repl-window and a project-explorer-window. You cannot break this layout, which gives a Zenmacs a structured yet lightweight IDE feel. You are still free to split windows, or create new frames. &lt;strong&gt;Note&lt;/strong&gt;: Emacs has special meanings for the terms &lt;em&gt;window&lt;/em&gt; and &lt;em&gt;frame&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;It has rich tabs (representing files, projects, workspaces). This is original work. Buffer (file) navigation is great in general, hiding from you the typical Emacs annoying pseudo-files (buffers).&lt;/li&gt; &#xA; &lt;li&gt;Editor, directory tree and repl are always in sync between them as you switch projects/workspaces.&lt;/li&gt; &#xA; &lt;li&gt;Key things (shortcuts, editor configuration, project setup, etc) can be overriden by design (&lt;code&gt;.emacs.d.overrides&lt;/code&gt; repo).&lt;/li&gt; &#xA; &lt;li&gt;It removes Emacs from its many quirks, noisy feedback and esoteric ways of approaching mundane tasks. Philosophy is to make Emacs behave like a normal editor, similarly to when you open Atom and expect everything to &#39;just work&#39;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Caveats&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Clojure tooling (MELPA packages) is version-frozen using my own forks. Forking is a good way to ensure stability, since those are moving targets. I update once a year or so.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;&#34;But, monolith&#34;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;This setup is somewhat similar to others in that it&#39;s a monolithic conglomerate of functionality - you couldn&#39;t cherry-pick just what you wanted.&lt;/p&gt; &#xA;&lt;p&gt;This has the drawback of being all-or-nothing: either you use all the provided features, or you are left bare-bones and have to build it all yourself (maybe copying some bits).&lt;/p&gt; &#xA;&lt;p&gt;I am aware of this weakness. Be assured, dear reader, that if this project takes off, I will split this setup into many independent packages. Meanwhile such effort would be premature optimization.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Note that you need an Unix-y OS.&lt;/li&gt; &#xA; &lt;li&gt;Watch the video so you know what to expect.&lt;/li&gt; &#xA; &lt;li&gt;Get Emacs (26 or 25). For macOS I recommend &lt;code&gt;brew install railwaycat/emacsmacport/emacs-mac&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Possibly, disable unnecessary OS system shortcuts (example: &lt;code&gt;Control + left&lt;/code&gt; in macOS) which may take precedence over Emacs.&lt;/li&gt; &#xA; &lt;li&gt;Backup and remove &lt;code&gt;~/.emacs.d&lt;/code&gt; if that directory existed already&lt;/li&gt; &#xA; &lt;li&gt;Clone the repo into &lt;code&gt;~&lt;/code&gt;, so Emacs will pick up &lt;code&gt;~/.emacs.d&lt;/code&gt; on startup&lt;/li&gt; &#xA; &lt;li&gt;cd into it, make sure that each git submodule is pulled, typically with &lt;code&gt;git submodule update --init --recursive&lt;/code&gt;. &lt;code&gt;./lib&lt;/code&gt; should have many non-empty directories, and no errors in the fetching process.&lt;/li&gt; &#xA; &lt;li&gt;Install &lt;code&gt;rg&lt;/code&gt; and &lt;code&gt;the_silver_searcher&lt;/code&gt; (for helm-ag), &lt;code&gt;ruby&lt;/code&gt; (for fiplr), &lt;code&gt;tree&lt;/code&gt; (for project-explorer).&lt;/li&gt; &#xA; &lt;li&gt;If you want Ruby code autoformatting to work, make sure the &lt;code&gt;rubocop&lt;/code&gt; gem is installed in each Ruby project. Also a global install will be useful for spare files. If rubocop is not present, nothing bad will happen.&lt;/li&gt; &#xA; &lt;li&gt;Launch Emacs. On the first run, the screen will be frozen for a couple minutes since packages are being installed.&lt;/li&gt; &#xA; &lt;li&gt;Take a look at &lt;code&gt;vemv.shortcuts.global.el&lt;/code&gt;. Learn those shortcuts (which you can override later).&lt;/li&gt; &#xA; &lt;li&gt;Open a Leiningen-based Clojure project: &lt;code&gt;vemv/shortcuts/global/tertiary-o&lt;/code&gt; (typically: &lt;code&gt;Control-o&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Execute the shortcut corresponding to &lt;code&gt;vemv/shortcuts/global/primary-j&lt;/code&gt; (typically: &lt;code&gt;C-j&lt;/code&gt;) so CIDER starts and you can get a Clojure(Script) REPL accordingly.&lt;/li&gt; &#xA; &lt;li&gt;Play around with some paredit or evaluation shortcuts!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Customizing keyboard shortcuts, creating project-specific configuration, etc.&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If it didn&#39;t exist already, Zenmacs creates &lt;code&gt;~/.emacs.d.overrides&lt;/code&gt;, which you should keep version-controlled. No code is ever auto-dumped there - it&#39;s up to you to add project-specific configuration, if desired.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Its structure is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.&#xA;└── lib&#xA;    └── emacs.d.overrides.el       # Global user-specific configuration&#xA;    └── zenmacs.project.foobar.el  # Configuration specific to the project with id `foobar`&#xA;    └── zenmacs.project.bazquux.el # Configuration specific to the project with id `bazquux`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In emacs.d.overrides.el you can:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(provide &#39;emacs.d.overrides)&#xA;&#xA;(setq vemv/shortcuts/global/primary-b nil)                ;; nullify an undesired binding&#xA;(setq vemv/shortcuts/global/primary-r &#39;vemv/duplicate)    ;; customize a binding&#xA;(setq vemv.project.reasonable-file-count?/threshold 1000) ;; customize a global (non-project-specific) config value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And more. You can also define user-specific functions, for arbitrary purposes (creating new functionalities), or also for creating helper functions for DRYing out project configuration (e.g. a set of projects must have the same configuration options).&lt;/p&gt; &#xA;&lt;p&gt;As for the project-specific configuration files: these are great places for the stuff that varies between projects. Different formatting rules, expected directory structures, and so on.&lt;/p&gt; &#xA;&lt;p&gt;Project files are created automatically, based on the value of &lt;code&gt;vemv/available-workspaces&lt;/code&gt;. Creation happens both on Emacs startup, and every time you save &lt;code&gt;emacs.d.overrides.el&lt;/code&gt;. This reduces the friction of creating config files.&lt;/p&gt; &#xA;&lt;p&gt;All Elisp code under &lt;code&gt;emacs.d.overrides/lib&lt;/code&gt; are loaded automatically every time you switch to a different project.&lt;/p&gt;</summary>
  </entry>
</feed>