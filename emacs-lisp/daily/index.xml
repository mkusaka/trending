<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-10T01:34:04Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>upgradingdave/ecukes-completing</title>
    <updated>2022-10-10T01:34:04Z</updated>
    <id>tag:github.com,2022-10-10:/upgradingdave/ecukes-completing</id>
    <link href="https://github.com/upgradingdave/ecukes-completing" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Example of completing not playing nicely with ecukes&lt;/p&gt; &#xA;&lt;p&gt;This uses Carton to manage dependencies, so just run carton to create elpa subdirectory.&lt;/p&gt; &#xA;&lt;p&gt;I added the following to &lt;code&gt;elpa/ecukes-20121008.17007&lt;/code&gt; in order for it to find ansi:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(mapc &#xA; (lambda (new) (add-to-list &#39;load-path new))&#xA; (file-expand-wildcards &#34;elpa/*&#34;))        &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ecukes-test.el&lt;/code&gt; has a few simple functions that prompt the user to choose from a list of available colors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;test/test.sh&lt;/code&gt; runs the ert tests. The test prompst for a color, and if you enter &#34;CadetBlue&#34;, the test passes successfully as expected:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; dparoulek@centurion:~/code/elisp/ecukes-test$ ./test/test.sh &#xA; Running 2 tests (2012-11-19 11:54:12-0500)&#xA; Choose Color: CadetBlue&#xA; You chose: CadetBlue!&#xA;    passed  1/2  et-choose-color&#xA;    passed  2/2  et-sanity-check&#xA;&#xA; Ran 2 tests, 2 results as expected (2012-11-19 11:54:19-0500)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When I try to run either &lt;code&gt;ecukes&lt;/code&gt; or &lt;code&gt;ecukes --graphical&lt;/code&gt;, I get the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; dparoulek@centurion:~/code/elisp/ecukes-test$ ecukes&#xA; Feature: Test Completing using ecukes&#xA;   In order to test functions that use completing method calls&#xA;   As an Ecukes user&#xA;   I want to run this feature successfully&#xA;    &#xA;    &#xA;   Scenario: Choose Color&#xA; You chose: !&#xA;     When I press &#34;M-x et-choose-color&#34;&#xA;     And I press &#34;RET&#34;&#xA;     And I type &#34;CadetBlue&#34;&#xA;     And I press &#34;RET&#34;&#xA;     Then et-curr-color should be &#34;CadetBlue&#34;&#xA;       Assertion failed: (equal et-curr-color color)&#xA; &#xA; 1 scenarios (1 failed, 0 passed)&#xA; 5 steps (1 failed, 0 skipped, 4 passed)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>tonini/overseer.el</title>
    <updated>2022-10-10T01:34:04Z</updated>
    <id>tag:github.com,2022-10-10:/tonini/overseer.el</id>
    <link href="https://github.com/tonini/overseer.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ert-runner Integration Into Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL_3-green.svg?style=flat&#34; alt=&#34;License GPL 3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/tonini/overseer.el&#34;&gt;&lt;img src=&#34;https://travis-ci.org/tonini/overseer.el.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;overseer.el&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Ert-runner Integration Into Emacs&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/rejeep/ert-runner.el&#34;&gt;ert-runner&lt;/a&gt; is a great way to run your ert tests. Overseer integrates this tool into emacs and let&#39;s you using it inside your lovely editor.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tonini/overseer.el/master/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tonini/overseer.el/master/#installation-via-packageel&#34;&gt;ELPA&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tonini/overseer.el/master/#via-el-get&#34;&gt;Via el-get&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tonini/overseer.el/master/#manual&#34;&gt;Manual&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tonini/overseer.el/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tonini/overseer.el/master/#interactive-commands&#34;&gt;Interactive commands&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tonini/overseer.el/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tonini/overseer.el/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Installation via package.el&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;package.el&lt;/code&gt; is the built-in package manager in Emacs.&lt;/p&gt; &#xA;&lt;p&gt;Overseer is available on the three major community maintained repositories - &lt;a href=&#34;https://raw.githubusercontent.com/tonini/overseer.el/master/melpa-stable.milkbox.net&#34;&gt;MELPA STABLE&lt;/a&gt;, &lt;a href=&#34;http://melpa.milkbox.net&#34;&gt;MELPA&lt;/a&gt; and &lt;a href=&#34;https://marmalade-repo.org/&#34;&gt;Marmalade&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can install &lt;code&gt;Overseer&lt;/code&gt; with the following commnad:&lt;/p&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x package-install [RET] overseer [RET]&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;p&gt;or by adding this bit of Emacs Lisp code to your Emacs initialization file (&lt;code&gt;.emacs&lt;/code&gt; or &lt;code&gt;init.el&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(unless (package-installed-p &#39;overseer)&#xA;  (package-install &#39;overseer))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the installation doesn&#39;t work try refreshing the package list:&lt;/p&gt; &#xA;&lt;p&gt;&lt;kbd&gt;M-x package-refresh-contents [RET]&lt;/kbd&gt;&lt;/p&gt; &#xA;&lt;p&gt;Keep in mind that MELPA packages are built automatically from the &lt;code&gt;master&lt;/code&gt; branch, meaning bugs might creep in there from time to time. Never-the-less, installing from MELPA is the recommended way of obtaining Overseer, as the &lt;code&gt;master&lt;/code&gt; branch is normally quite stable and &#34;stable&#34; (tagged) builds are released somewhat infrequently.&lt;/p&gt; &#xA;&lt;p&gt;With the most recent builds of Emacs, you can pin Overseer to always use MELPA Stable by adding this to your Emacs initialization:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-to-list &#39;package-pinned-packages &#39;(overseer . &#34;melpa-stable&#34;) t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Via el-get&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dimitri/el-get&#34;&gt;el-get&lt;/a&gt; is another popular package manager for Emacs. If you&#39;re an el-get user just do &lt;kbd&gt;M-x el-get-install [RET] overseer [RET]&lt;/kbd&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Manual&lt;/h3&gt; &#xA;&lt;p&gt;You can install Overseer manually by placing it on your &lt;code&gt;load-path&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; ing it. Many people favour the folder &lt;code&gt;~/.emacs.d/vendor&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(add-to-list &#39;load-path &#34;~/.emacs.d/vendor/&#34;)&#xA;(require &#39;overseer)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;ert-runner&lt;/code&gt; will always run in the context of the current &lt;code&gt;emacs lisp project&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;overseer-mode&lt;/code&gt; is enabled via &lt;code&gt;emacs-lisp-mode-hook&lt;/code&gt; by default for emacs lisp test files. (&lt;code&gt;*-test.el&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;h3&gt;Interactive Commands&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;overseer-mode&lt;/code&gt; minor mode will be automaticly enable the following keybindings:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Keybinding&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c , a&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs &lt;code&gt;cask exec ert-runner&lt;/code&gt;. &lt;code&gt;overseer-test&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c , t&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs &lt;code&gt;cask exec ert-runner -p &amp;lt;test-at-point&amp;gt;&lt;/code&gt;. &lt;code&gt;overseer-test-run-test&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c , b&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs &lt;code&gt;cask exec ert-runner&lt;/code&gt; with the current buffer file as argument. &lt;code&gt;overseer-test-this-buffer&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c , f&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Open a prompt to run &lt;code&gt;cask exec ert-runner&lt;/code&gt; with a custom file as arguments. &lt;code&gt;overseer-test-file&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c , g&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs &lt;code&gt;cask exec ert-runner -t&lt;/code&gt; with given tags (example: &lt;code&gt;indentation,syntax&lt;/code&gt;). &lt;code&gt;overseer-test-this-buffer&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c , p&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Open a prompt to run &lt;code&gt;cask exec ert-runner&lt;/code&gt; with custom arguments. &lt;code&gt;overseer-test-prompt&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c , h&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs &lt;code&gt;cask exec ert-runner --help&lt;/code&gt;. &lt;code&gt;overseer-help&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c , d&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs &lt;code&gt;cask exec ert-runner --debug&lt;/code&gt;. &lt;code&gt;overseer-help&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c , v&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs &lt;code&gt;cask exec ert-runner --verbose&lt;/code&gt;. &lt;code&gt;overseer-help&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-c , q&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs &lt;code&gt;cask exec ert-runner --quiet&lt;/code&gt;. &lt;code&gt;overseer-help&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are very welcome!&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork overseer.el&lt;/li&gt; &#xA; &lt;li&gt;Create a topic branch - &lt;code&gt;git checkout -b my_branch&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Push to your branch - &lt;code&gt;git push origin my_branch&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Send me a pull-request for your topic branch&lt;/li&gt; &#xA; &lt;li&gt;That&#39;s it!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright Â© 2014-2015 Samuel Tonini and &lt;a href=&#34;https://github.com/tonini/overseer.el/contributors&#34;&gt;contributors&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Distributed under the GNU General Public License, version 3&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Wilfred/elisp-def</title>
    <updated>2022-10-10T01:34:04Z</updated>
    <id>tag:github.com,2022-10-10:/Wilfred/elisp-def</id>
    <link href="https://github.com/Wilfred/elisp-def" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Find Emacs Lisp definitions&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;elisp-def &lt;a href=&#34;http://www.melpa.org/#/elisp-def&#34;&gt;&lt;img src=&#34;http://www.melpa.org/packages/elisp-def-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/Wilfred/elisp-def&#34;&gt;&lt;img src=&#34;https://travis-ci.org/Wilfred/elisp-def.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/Wilfred/elisp-def?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/Wilfred/elisp-def/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Go to the definition of the symbol at point. Supports global definitions, local definitions, and even macro-heavy code!&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Wilfred/elisp-def/master/screenshot.png&#34; alt=&#34;screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;elisp-def&lt;/code&gt; statically analyses your code, and falls back to heuristics where that&#39;s not possible. It should work 99% of the time, so please file bugs if it can&#39;t find definitions for your code.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install from MELPA, then add the following to your Emacs configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(dolist (hook &#39;(emacs-lisp-mode-hook ielm-mode-hook))&#xA;  (add-hook hook #&#39;elisp-def-mode))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Global Definitions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;elisp-def&lt;/code&gt; will find the definition of global functions and global variables at point.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(defun demo/foo ()&#xA;  1)&#xA;&#xA;(defun demo/bar ()&#xA;  ;; M-x eval-buffer, then elisp-def on this:&#xA;  (demo/foo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It will also use edebug information to find function definitions, so it finds definitions more often than xref.&lt;/p&gt; &#xA;&lt;h2&gt;Lisp-2 Awareness&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;elisp-def&lt;/code&gt; understands the difference between symbols and functions and jumps to the correct definition.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;cc-mode)&#xA;&#xA;;; `c-version&#39; is both a variable and a function.&#xA;&#xA;(defun demo/foo ()&#xA;  ;; `elisp-def` will find the function here.&#xA;  (c-version))&#xA;&#xA;(defun demo/foo ()&#xA;  ;; `elisp-def` will find the variable here.&#xA;  (setq c-version t))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Macro Awareness&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;elisp-def&lt;/code&gt; understands macros, so it can accurately detect function references.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;dash)&#xA;&#xA;(defvar demo/foo nil)&#xA;&#xA;(defun demo/foo (x)&#xA;  x)&#xA;&#xA;(defun demo/bar ()&#xA;  (-&amp;gt;&amp;gt; 123&#xA;       ;; `elisp-def&#39; knows that this is a function, even though there are&#xA;       ;; no parens.&#xA;       demo/foo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can also understand macros that define functions or variables.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(define-derived-mode demo/foo-mode fundamental-mode &#34;demo&#34;)&#xA;&#xA;;; `elisp-def&#39; will expand macros to discover where major mode hooks&#xA;;; are defined.&#xA;demo/foo-mode-hook&#xA;&#xA;(cl-defstruct demo/point x y)&#xA;&#xA;;; `elisp-def&#39; can find this function even though the defstruct&#xA;;; call doesn&#39;t contain this symbol name.&#xA;(make-demo/point 1 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Find Libraries&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;elisp-def&lt;/code&gt; will find libraries, displaying the &lt;code&gt;provide&lt;/code&gt; declarations if possible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;;; `elisp-def&#39; will open python.el here.&#xA;(require &#39;python)&#xA;&#xA;;; Unlike `xref-find-definition&#39;, `elisp-def&#39; will not confuse this&#xA;;; library name with the macro named `use-package&#39;.&#xA;(require &#39;use-package)&#xA;&#xA;;; `elisp-def&#39; will even find python.el here, because the macro&#xA;;; expands to a call to `require&#39;.&#xA;(use-package python&#xA;  :config&#xA;  (setq python-indent-guess-indent-offset-verbose nil))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Local Bindings&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;elisp-def&lt;/code&gt; understands local bindings and parameters.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(defun demo/foo (bar)&#xA;  (let ((foo 1))&#xA;    ;; `elisp-def&#39; on the FOO below will move point to the let&#xA;    ;; binding.&#xA;    (setq foo 2)&#xA;    ;; `elisp-def&#39; on the BAR below will move point to the function&#xA;    ;; parameters line.&#xA;    (setq bar 3)))&#xA;&#xA;(defun demo/bar ()&#xA;  (let* ((foo 1)&#xA;         (bar 2)&#xA;         (foo 3)&#xA;         ;; `elisp-def&#39; on the second FOO on the following line will&#xA;         ;; move point to the relevant binding, which is the line&#xA;         ;; immediately above.&#xA;         (foo (+ foo 1))&#xA;         (foo 5))&#xA;    nil))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This even works with macros that introduce bindings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;dash)&#xA;(eval-when-compile&#xA;  (require &#39;cl-lib))&#xA;&#xA;(defun demo/foo (items)&#xA;  (cl-destructuring-bind (first second) items&#xA;    ;; `elisp-def&#39; knowns that FIRST is bound on line above.&#xA;    (message &#34;first is %s&#34; first))&#xA;  (-let [(first . rest) items]&#xA;    ;; `elisp-def&#39; knowns that FIRST is bound on line above.&#xA;    (message &#34;first is %s&#34; first)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Ergonomics&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;elisp-def&lt;/code&gt; allows you to put point on quoted symbols, docstring symbols or backquoted symbols.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(defun demo/foo (x)&#xA;  ;; `elisp-def&#39; on X in the docstring will find the parameter.&#xA;  &#34;Adds one to X and returns it.&#34;&#xA;  (1+ x))&#xA;&#xA;(defun demo/bar ()&#xA;  ;; `elisp-def&#39; can find demo/foo even when point is on the #.&#xA;  (funcall #&#39;demo/foo 1)&#xA;  ;; `elisp-def&#39; on demo/foo below will find the function.&#xA;  ;;&#xA;  ;; See `demo/foo&#39; for more information.&#xA;  nil)&#xA;&#xA;(defun demo/baz (foo)&#xA;  ;; `elisp-def&#39; understands that @ is not part of foo here.&#xA;  `(blah ,@foo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When it finds the symbol, elisp-def will also temporarily highlight it for visibility.&lt;/p&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;elisp-def&lt;/code&gt; is limited in its ability to analyse quoted symbols.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;;; `elisp-def&#39; is able to find these quoted symbols because they&#39;re&#xA;;; only globally bound in one namespace.&#xA;(mapcar &#39;symbol-name &#39;(foo bar baz))&#xA;(add-to-list &#39;auto-mode-alist &#39;(&#34;\\.java\\&#39;&#34; . java-mode))&#xA;&#xA;(require &#39;cc-mode)&#xA;(defun demo/calls-fn (sym)&#xA;  (funcall sym))&#xA;&#xA;;; Since `c-version&#39; is both a function and a variable, and we&#39;re not&#xA;;; using a sharp-quote #&#39;c-version, we have to prompt the user.&#xA;(demo/calls-fn &#39;c-version)&#xA;&#xA;(defun demo/foo (c-version)&#xA;  ;; Here we have no idea whether we&#39;re using `c-version&#39; as a&#xA;  ;; function (e.g. funcall), as a variable (e.g. set) or as a&#xA;  ;; parameter (e.g. eval).&#xA;  (bar &#39;c-version nil))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;elisp-def&lt;/code&gt; cannot find definitions in macros with &lt;code&gt;let*&lt;/code&gt; semantics and duplicated variables.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(require &#39;dash)&#xA;&#xA;(defun demo/foo ()&#xA;  (-let ((x 1)&#xA;         (x 2))&#xA;    ;; `elisp-def&#39; on X below will move to the first X binding, rather&#xA;    ;; than the second.&#xA;    x))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;elisp-def&lt;/code&gt; also cannot handle macros that rewrite forms such that the symbol disappears entirely.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(eval-when-compile (require &#39;cl-lib))&#xA;&#xA;(cl-labels ((foo (x y) (+ x y)))&#xA;  ;; `cl-labels&#39; completely rewrites this body to (--cl-foo-- 1 2), so&#xA;  ;; `elisp-def&#39; can&#39;t find the definition of FOO.&#xA;  (foo 1 2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Thanks/Inspirations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;elisp-slime-nav-find-elisp-thing-at-point&lt;/code&gt; from &lt;a href=&#34;https://github.com/purcell/elisp-slime-nav&#34;&gt;elisp-slime-nav&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;xref-find-definitions&lt;/code&gt; in &lt;code&gt;emacs-lisp-mode&lt;/code&gt; (part of Emacs core)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;semantic-ia-fast-jump&lt;/code&gt; from &lt;code&gt;semantic/ia.el&lt;/code&gt; (included in Emacs)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The fine folks on &lt;code&gt;#emacs&lt;/code&gt; for answering my questions on elisp esoterica, particularly Wasamasa.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/alexander-yakushev/compliment&#34;&gt;compliment&lt;/a&gt; library for Clojure completion has a notion of &lt;a href=&#34;https://github.com/alexander-yakushev/compliment/wiki/Context&#34;&gt;context&lt;/a&gt; which is very similar to how elisp-def extracts and analyses forms.&lt;/p&gt; &#xA;&lt;p&gt;Hacklang has a &lt;a href=&#34;https://github.com/facebook/hhvm/raw/master/hphp/hack/man/hh_client.1#L152-L156&#34;&gt;similar notion of a placeholder&lt;/a&gt; for analysing completions at a point in the code.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;GPLv3+.&lt;/p&gt; &#xA;&lt;p&gt;I am providing code in the repository to you under an open source license. Because this is my personal repository, the license you receive to my code is from me and not my employer.&lt;/p&gt;</summary>
  </entry>
</feed>