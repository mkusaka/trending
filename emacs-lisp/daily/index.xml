<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-17T01:29:52Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sigma/codex</title>
    <updated>2023-09-17T01:29:52Z</updated>
    <id>tag:github.com,2023-09-17:/sigma/codex</id>
    <link href="https://github.com/sigma/codex" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CL-like namespaces for Elisp&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/sigma/codex&#34;&gt;&lt;img src=&#34;https://travis-ci.org/sigma/codex.png?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;WARNING: don&#39;t even think about asking for support :) This is just a POC, and is not meant to be actually used in the current state.&lt;/p&gt; &#xA;&lt;p&gt;That said, I&#39;m more than happy to discuss how we could make it happen (in particular, suggestions and patches welcome)&lt;/p&gt; &#xA;&lt;p&gt;In short, I certainly plan to keep working on it, but this is not even near an alpha release. Consider yourself warned.&lt;/p&gt; &#xA;&lt;p&gt;-- Sigma&lt;/p&gt; &#xA;&lt;h1&gt;Elisp namespaces&lt;/h1&gt; &#xA;&lt;p&gt;This is an attempt at namespacing Elisp symbols.&lt;/p&gt; &#xA;&lt;p&gt;Lack of proper namespaces is a problem in Emacs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;symbols defined for private reasons (implementation details) are exposed just the same way as the official interface of a module.&lt;/li&gt; &#xA; &lt;li&gt;naming conventions tend to generate lengthy symbols that everybody hates&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Judging by the amount of IRC traffic that&#39;s generated in #emacs by people complaining about the lack of namespaces, just implementing them will probably significantly decrease the bandwidth congestion on freenode servers. So... here we go.&lt;/p&gt; &#xA;&lt;p&gt;Contrary to other implementations (like &lt;a href=&#34;https://github.com/skeeto/elisp-fakespace&#34;&gt;https://github.com/skeeto/elisp-fakespace&lt;/a&gt;), we don&#39;t constrain ourselves to the main obarray. We instead try to create the symbols at the right place directly, which basically means in the obarray that&#39;s associated with each codex.&lt;/p&gt; &#xA;&lt;p&gt;The core of the implementation is the &lt;code&gt;in-codex&lt;/code&gt; macro, which rewrites its body&#39;s symbols to point at the right places. In particular, a symbol name of the form &#34;&#xA; &lt;codex&gt;&#xA;  :&#xA;  &lt;symbol&gt;&#xA;   &#34; will be resolved as the symbol &#34;symbol&#34; in codex &#34;codex&#34;, which is &#xA;   &lt;em&gt;not&lt;/em&gt; backward-compatible (and there are quite a few libraries out there that already use such a scheme).&#xA;  &lt;/symbol&gt;&#xA; &lt;/codex&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Why Codex ?&lt;/h1&gt; &#xA;&lt;p&gt;Well, this is modeled after CL packages, but packages are something entirely different in Emacs. I thought of &#34;thesaurus&#34; first, but I can&#39;t be bothered to type this all the time. &#34;lexicon&#34; sounded nice, but this might be confusing with all the lexical binding stuff that&#39;s happening right now. &#34;codex&#34; is short and still refers to a collection of symbols. Plus, I like the name :)&lt;/p&gt; &#xA;&lt;h1&gt;Existing codices&lt;/h1&gt; &#xA;&lt;p&gt;One of the challenges of introducing a proper namespacing mechanism is to decide what to do with all the existing stuff in the global obarray.&lt;/p&gt; &#xA;&lt;p&gt;Right now, the thing that&#39;s done is to generate an &#34;emacs&#34; namespace, that contains every built-in function defined in emacs. That&#39;s certainly not sufficient, but is enough for a small POC.&lt;/p&gt; &#xA;&lt;p&gt;If this is deemed worth, one could plug into &lt;code&gt;after-load-functions&lt;/code&gt;, and parse &lt;code&gt;load-history&lt;/code&gt; to generate codices from existing library, so that they could at least be properly integrated.&lt;/p&gt; &#xA;&lt;h1&gt;Examples explained&lt;/h1&gt; &#xA;&lt;p&gt;For clarity, we&#39;ll use the colon notation to qualify the symbols, but that&#39;s obviously not what one would observe, as the symbol names don&#39;t contain that qualification.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defcodex test&#xA;  (:use emacs)&#xA;  (:export &#34;plop&#34;))&#xA;&#xA;(in-codex test&#xA;  (defun plop () 42))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The defun form will be transformed into:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(emacs:defun test:plop nil 42)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That means, the &lt;code&gt;defun&lt;/code&gt; symbol has been detected as exported by the &#34;emacs&#34; codex, while &lt;code&gt;plop&lt;/code&gt; was (probably) not even existing, so that it ends up in the &#34;test&#34; one.&lt;/p&gt; &#xA;&lt;p&gt;If we didn&#39;t have the &lt;code&gt;(:use emacs)&lt;/code&gt; clause in the codex definition, the expansion would have been&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(test:defun test:plop nil 42)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows to easily overload functions in a codex (note that when proper shadowing is in place, it will actually become useful).&lt;/p&gt; &#xA;&lt;p&gt;Another example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defcodex test2)&#xA;&#xA;(in-codex test2&#xA;  (emacs:defun plop () 7))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This time, no use of emacs codex, so we need to prefix the &lt;code&gt;defun&lt;/code&gt; symbol to refer to it. The defun form is transformed into:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(emacs:defun test:plop nil 7)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defcodex test3&#xA;  (:use test))&#xA;&#xA;(in-codex test3&#xA;  (emacs:+ (plop) (test2:plop)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The addition form becomes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(emacs:+ (test:plop) (test2:plop))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which returns 49 as expected ;)&lt;/p&gt; &#xA;&lt;h1&gt;Gotchas&lt;/h1&gt; &#xA;&lt;p&gt;Implementing that kind of logic using a macro has its own cost. Namely, we work on something that has already gone through the &lt;code&gt;read&lt;/code&gt; phase, meaning that all referenced symbols are interned in the global obarray anyway. That&#39;s unclean.&lt;/p&gt; &#xA;&lt;p&gt;To be clear, that doesn&#39;t mean the symbols in the main obarray have the function or value slots of their codex counterparts. It&#39;s just that they exist, in a (mostly) harmless state.&lt;/p&gt; &#xA;&lt;p&gt;Debugging code that&#39;s using those codices would quickly become a nightmare in the absence of proper edebug integration. In particular, the fact that symbols are not prefixed makes it very difficult to know what symbol we&#39;re talking about.&lt;/p&gt;</summary>
  </entry>
</feed>