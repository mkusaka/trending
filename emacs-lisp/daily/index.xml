<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-17T01:42:44Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>protesilaos/ef-themes</title>
    <updated>2022-08-17T01:42:44Z</updated>
    <id>tag:github.com,2022-08-17:/protesilaos/ef-themes</id>
    <link href="https://github.com/protesilaos/ef-themes" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Colourful and legible themes for GNU Emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ef (εὖ) themes for GNU Emacs&lt;/h1&gt; &#xA;&lt;p&gt;WORK-IN-PROGRESS: screenshots will be available once things stabilise.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;ef-themes&lt;/code&gt; are a collection of light and dark themes for GNU Emacs whose goal is to provide colorful (&#34;pretty&#34;) yet legible options for users who want something with a bit more flair than the &lt;code&gt;modus-themes&lt;/code&gt; (also designed by me).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Package name (GNU ELPA): &lt;code&gt;ef-themes&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Official manual: &lt;a href=&#34;https://protesilaos.com/emacs/ef-themes&#34;&gt;https://protesilaos.com/emacs/ef-themes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Git repo on SourceHut: &lt;a href=&#34;https://git.sr.ht/~protesilaos/ef-themes&#34;&gt;https://git.sr.ht/~protesilaos/ef-themes&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Mirrors: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;GitHub: &lt;a href=&#34;https://github.com/protesilaos/ef-themes&#34;&gt;https://github.com/protesilaos/ef-themes&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;GitLab: &lt;a href=&#34;https://gitlab.com/protesilaos/ef-themes&#34;&gt;https://gitlab.com/protesilaos/ef-themes&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Mailing list: &lt;a href=&#34;https://lists.sr.ht/~protesilaos/ef-themes&#34;&gt;https://lists.sr.ht/~protesilaos/ef-themes&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>abo-abo/org-download</title>
    <updated>2022-08-17T01:42:44Z</updated>
    <id>tag:github.com,2022-08-17:/abo-abo/org-download</id>
    <link href="https://github.com/abo-abo/org-download" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Drag and drop images to Emacs org-mode&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;org-download&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://melpa.org/#/org-download&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/org-download-badge.svg?sanitize=true&#34; alt=&#34;MELPA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/org-download&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/org-download-badge.svg?sanitize=true&#34; alt=&#34;MELPA Stable&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This extension facilitates moving images from point &lt;strong&gt;A&lt;/strong&gt; to point &lt;strong&gt;B&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Point &lt;strong&gt;A&lt;/strong&gt; (&lt;em&gt;the source&lt;/em&gt;) can be:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;An image inside your browser that you can drag to Emacs.&lt;/li&gt; &#xA; &lt;li&gt;An image on your file system that you can drag to Emacs.&lt;/li&gt; &#xA; &lt;li&gt;A local or remote image address in kill-ring. Use the &lt;code&gt;org-download-yank&lt;/code&gt; command for this. Remember that you can use &#34;0 w&#34; in &lt;code&gt;dired&lt;/code&gt; to get an address.&lt;/li&gt; &#xA; &lt;li&gt;A screenshot taken using &lt;code&gt;gnome-screenshot&lt;/code&gt;, &lt;code&gt;scrot&lt;/code&gt;, &lt;code&gt;gm&lt;/code&gt;, &lt;code&gt;xclip&lt;/code&gt; (on Linux), &lt;code&gt;screencapture&lt;/code&gt; (on OS X) or , &lt;code&gt;imagemagick/convert&lt;/code&gt; (on Windows). Use the &lt;code&gt;org-download-screenshot&lt;/code&gt; command for this. Customize the backend with &lt;code&gt;org-download-screenshot-method&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Point &lt;strong&gt;B&lt;/strong&gt; (&lt;em&gt;the target&lt;/em&gt;) is an Emacs &lt;code&gt;org-mode&lt;/code&gt; buffer where the inline link will be inserted. Several customization options will determine where exactly on the file system the file will be stored.&lt;/p&gt; &#xA;&lt;p&gt;They are: &lt;code&gt;org-download-method&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&#39;attach =&amp;gt; use &lt;code&gt;org-mode&lt;/code&gt; attachment machinery&lt;/li&gt; &#xA; &lt;li&gt;&#39;directory =&amp;gt; construct the directory in two stages: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt; &lt;p&gt;first part of the folder name is:&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt; &lt;p&gt;either &#34;.&#34; (current folder)&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;or &lt;code&gt;org-download-image-dir&lt;/code&gt; (if it&#39;s not nil).&lt;/p&gt; &lt;p&gt;&lt;code&gt;org-download-image-dir&lt;/code&gt; becomes buffer-local when set, so each file can customize this value, e.g with:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;    -*- mode: Org; org-download-image-dir: &#34;~/Pictures/foo&#34;; -*-&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;To set it for all files at once, use this:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;    (setq-default org-download-image-dir &#34;~/Pictures/foo&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;second part is:&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;code&gt;org-download-heading-lvl&lt;/code&gt; is nil =&amp;gt; &#34;&#34;&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;code&gt;org-download-heading-lvl&lt;/code&gt; is n =&amp;gt; the name of current heading with level n.&lt;/p&gt; &lt;p&gt;Level count starts with 0, i.e. * is 0, ** is 1, *** is 2 etc. &lt;code&gt;org-download-heading-lvl&lt;/code&gt; becomes buffer-local when set, so each file can customize this value, e.g with:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;    -*- mode: Org; org-download-heading-lvl: nil; -*-&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;code&gt;org-download-timestamp&lt;/code&gt;: optionally add a timestamp to the file name.&lt;/p&gt; &#xA;&lt;p&gt;Customize &lt;code&gt;org-download-backend&lt;/code&gt; to choose between &lt;code&gt;url-retrieve&lt;/code&gt; (the default) or &lt;code&gt;wget&lt;/code&gt; or &lt;code&gt;curl&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Set up&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;org-download)&#xA;&#xA;;; Drag-and-drop to `dired`&#xA;(add-hook &#39;dired-mode-hook &#39;org-download-enable)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Pasting from the clipboard&lt;/h2&gt; &#xA;&lt;p&gt;If you have the image stored in the clipboard, use &lt;code&gt;org-download-clipboard&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>skeeto/emacs-aio</title>
    <updated>2022-08-17T01:42:44Z</updated>
    <id>tag:github.com,2022-08-17:/skeeto/emacs-aio</id>
    <link href="https://github.com/skeeto/emacs-aio" rel="alternate"></link>
    <summary type="html">&lt;p&gt;async/await for Emacs Lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;aio: async/await for Emacs Lisp&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;aio&lt;/code&gt; is to Emacs Lisp as &lt;a href=&#34;https://docs.python.org/3/library/asyncio.html&#34;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; is to Python. This package builds upon Emacs 25 generators to provide functions that pause while they wait on asynchronous events. They do not block any thread while paused.&lt;/p&gt; &#xA;&lt;p&gt;Introduction: &lt;a href=&#34;https://nullprogram.com/blog/2019/03/10/&#34;&gt;An Async / Await Library for Emacs Lisp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Installation is &lt;a href=&#34;https://melpa.org/#/aio&#34;&gt;available through MELPA&lt;/a&gt;. Since it uses the &lt;code&gt;record&lt;/code&gt; built-in, it requires Emacs 26 or later.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;An async function is defined using &lt;code&gt;aio-defun&lt;/code&gt; or &lt;code&gt;aio-lambda&lt;/code&gt;. The body of such functions can use &lt;code&gt;aio-await&lt;/code&gt; to pause the function and wait on a given promise. The function continues with the promise&#39;s resolved value when it&#39;s ready. The package provides a number of functions that return promises, and every async function returns a promise representing its future return value.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(aio-defun foo (url)&#xA;  (aio-await (aio-sleep 3))&#xA;  (message &#34;Done sleeping. Now fetching %s&#34; url)&#xA;  (let* ((result (aio-await (aio-url-retrieve url)))&#xA;         (contents (with-current-buffer (cdr result)&#xA;                     (prog1 (buffer-string)&#xA;                       (kill-buffer)))))&#xA;    (message &#34;Result: %s&#34; contents)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If an uncaught signal terminates an asynchronous function, that signal is captured by its return value promise and propagated into any function that awaits on that function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(aio-defun divide (a b)&#xA;  (aio-await (aio-sleep 1))&#xA;  (/ a b))&#xA;&#xA;(aio-defun divide-safe (a b)&#xA;  (condition-case error&#xA;      (aio-await (divide a b))&#xA;    (arith-error :arith-error)))&#xA;&#xA;(aio-wait-for (divide-safe 1.0 2.0))&#xA;;; =&amp;gt; 0.5&#xA;&#xA;(aio-wait-for (divide-safe 0 0))&#xA;;; =&amp;gt; :arith-error&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To convert a callback-based function into an awaitable, async-friendly function, create a new promise object with &lt;code&gt;aio-promise&lt;/code&gt;, then &lt;code&gt;aio-resolve&lt;/code&gt; that promise in the callback. The helper function, &lt;code&gt;aio-make-callback&lt;/code&gt;, makes this easy.&lt;/p&gt; &#xA;&lt;h2&gt;Utility macros and functions&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(aio-wait-for promise)&#xA;;; Synchronously wait for PROMISE, blocking the current thread.&#xA;&#xA;(aio-cancel promise)&#xA;;; Attempt to cancel PROMISE, returning non-nil if successful.&#xA;&#xA;(aio-with-promise promise &amp;amp;rest body) [macro]&#xA;;; Evaluate BODY and resolve PROMISE with the result.&#xA;&#xA;(aio-with-async &amp;amp;rest body) [macro]&#xA;;; Evaluate BODY asynchronously as if it was inside `aio-lambda&#39;.&#xA;&#xA;(aio-make-callback &amp;amp;key tag once)&#xA;;; Return a new callback function and its first promise.&#xA;&#xA;(aio-chain expr) [macro]&#xA;;; `aio-await&#39; on EXPR and replace place EXPR with the next promise.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;aio-make-callback&lt;/code&gt; function is especially useful for callbacks that are invoked repeatedly, such as process filters and sentinels. The &lt;code&gt;aio-chain&lt;/code&gt; macro works in conjunction.&lt;/p&gt; &#xA;&lt;h2&gt;Awaitable functions&lt;/h2&gt; &#xA;&lt;p&gt;Here are some useful promise-returning — i.e. awaitable — functions defined by this package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(aio-sleep seconds &amp;amp;optional result)&#xA;;; Return a promise that is resolved after SECONDS with RESULT.&#xA;&#xA;(aio-idle seconds &amp;amp;optional result)&#xA;;; Return a promise that is resolved after idle SECONDS with RESULT.&#xA;&#xA;(aio-url-retrieve url &amp;amp;optional silent inhibit-cookies)&#xA;;; Wraps `url-retrieve&#39; in a promise.&#xA;&#xA;(aio-all promises)&#xA;;; Return a promise that resolves when all PROMISES are resolved.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Select API&lt;/h2&gt; &#xA;&lt;p&gt;This package includes a select()-like, level-triggered API for waiting on multiple promises at once. Create a &#34;select&#34; object, add promises to it, and await on it. Resolved and returned promises are automatically removed, and the &#34;select&#34; object can be reused.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(aio-make-select &amp;amp;optional promises)&#xA;;; Create a new `aio-select&#39; object for waiting on multiple promises.&#xA;&#xA;(aio-select-add select promise)&#xA;;; Add PROMISE to the set of promises in SELECT.&#xA;&#xA;(aio-select-remove select promise)&#xA;;; Remove PROMISE form the set of promises in SELECT.&#xA;&#xA;(aio-select-promises select)&#xA;;; Return a list of promises in SELECT.&#xA;&#xA;(aio-select select)&#xA;;; Return a promise that resolves when any promise in SELECT resolves.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, here&#39;s an implementation of sleep sort:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(aio-defun sleep-sort (values)&#xA;  (let* ((promises (mapcar (lambda (v) (aio-sleep v v)) values))&#xA;         (select (aio-make-select promises)))&#xA;    (cl-loop repeat (length promises)&#xA;             for next = (aio-await (aio-select select))&#xA;             collect (aio-await next))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Semaphore API&lt;/h2&gt; &#xA;&lt;p&gt;Semaphores work just as they would as a thread synchronization primitive. There&#39;s an internal counter that cannot drop below zero, and &lt;code&gt;aio-sem-wait&lt;/code&gt; is an awaitable function that may block the asynchronous function until another asynchronous function calls &lt;code&gt;aio-sem-post&lt;/code&gt;. Blocked functions wait in a FIFO queue and are awoken in the same order that they awaited.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(aio-sem init)&#xA;;; Create a new semaphore with initial value INIT.&#xA;&#xA;(aio-sem-post sem)&#xA;;; Increment the value of SEM.&#xA;&#xA;(aio-sem-wait sem)&#xA;;; Decrement the value of SEM.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can be used to create a work queue. For example, here&#39;s a configurable download queue for &lt;code&gt;url-retrieve&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-el&#34;&gt;(defun fetch (url-list max-parallel callback)&#xA;  (let ((sem (aio-sem max-parallel)))&#xA;    (dolist (url url-list)&#xA;      (aio-with-async&#xA;        (aio-await (aio-sem-wait sem))&#xA;        (cl-destructuring-bind (status . buffer)&#xA;            (aio-await (aio-url-retrieve url))&#xA;          (aio-sem-post sem)&#xA;          (funcall callback&#xA;                   (with-current-buffer buffer&#xA;                     (prog1 (buffer-string)&#xA;                       (kill-buffer)))))))))&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>