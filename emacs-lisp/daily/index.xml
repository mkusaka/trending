<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-11T01:33:33Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>manateelazycat/deno-bridge</title>
    <updated>2022-10-11T01:33:33Z</updated>
    <id>tag:github.com,2022-10-11:/manateelazycat/deno-bridge</id>
    <link href="https://github.com/manateelazycat/deno-bridge" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Build bridge between Emacs and Deno, execution of JavaScript and Typescript within Emacs.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/manateelazycat/deno-bridge/master/README.zh-CN.md&#34;&gt;简体中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;br&gt;A free/libre framework that build bridge between Emacs and Deno runtime. &lt;br&gt;Allows execution of JavaScript and Typescript within Emacs. &lt;/p&gt; &#xA;&lt;h2&gt;Vision&lt;/h2&gt; &#xA;&lt;p&gt;With deno-bridge, we can execution of JavaScript and Typescript within Emacs and don&#39;t need change source code of Emacs. It&#39;s bringing TypeScript ecosystem of powerful tools and approaches that Emacs just doesn&#39;t have currently:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;TypeScript offers an extremely flexible typing system, that allows to user to have compile time control of their scripting, with the flexibility of types &#34;getting out of the way&#34; when not needed.&lt;/li&gt; &#xA; &lt;li&gt;Deno uses Google&#39;s v8 JavaScript engine, which features an extremely powerful JIT and world-class garbage collector.&lt;/li&gt; &#xA; &lt;li&gt;Usage of modern Async I/O utilizing Rust&#39;s Tokio library.&lt;/li&gt; &#xA; &lt;li&gt;WebWorker support, meaning that multiple JavaScript engines can be running in parallel within the editor. The only restriction is that only the &#39;main&#39; JS Engine can directly call lisp functions.&lt;/li&gt; &#xA; &lt;li&gt;WebAssembly support, compile your C module as WebAsm and distribute it to the world. Don&#39;t worry about packaging shared libraries or changing module interfaces, everything can be handled and customized by you the user, at the scripting layer. No need to be dependent on native implementation details.&lt;/li&gt; &#xA; &lt;li&gt;Performance, v8&#39;s world-class JIT offers the potential for large performance gains. Async I/O from Deno, WebWorkers, and WebAsm, gives you the tools to make Emacs a smoother and faster experience without having to install additional tools to launch as background processes or worry about shared library versions.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;h4&gt;1. Download deno-bridge&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;git clone --depth=1 -b master https://github.com/manateelazycat/deno-bridge ~/.emacs.d/site-lisp/deno-bridge/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;2. Install Dependences&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/denoland/deno_install&#34;&gt;Deno&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ahyatt/emacs-websocket&#34;&gt;Websocket&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;3. Add to ~/.emacs&lt;/h4&gt; &#xA;&lt;p&gt;From here on, you can add the full path to the deno-bridge installation directory to your Emacs &lt;code&gt;load-path&lt;/code&gt;, then add the following to &lt;code&gt;init.el&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Elisp&#34;&gt;(add-to-list &#39;load-path &#34;~/.emacs.d/site-lisp/deno-bridge/&#34;)&#xA;(require deno-bridge)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;I write a demo to show you how simple write app base on deno-brige:&lt;/p&gt; &#xA;&lt;h4&gt;Elisp (deno-bridge-demo.el)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(require &#39;deno-bridge)&#xA;(setq deno-bridge-demo-ts-path (concat (file-name-directory load-file-name) &#34;deno-bridge-demo.ts&#34;))&#xA;(deno-bridge-start &#34;demo&#34; deno-bridge-demo-ts-path &#34;8686&#34; &#34;8687&#34;)&#xA;(deno-bridge-call &#34;demo&#34; &#34;ping&#34; &#34;Hello from Emacs.&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Start Deno process: &lt;code&gt;(deno-bridge-start &#34;demo&#34; deno-bridge-demo-ts-path &#34;8686&#34; &#34;8687&#34;)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Call TypeScript function from Emacs: &lt;code&gt;(deno-bridge-call &#34;demo&#34; &#34;ping&#34; &#34;Hello from Emacs.&#34;)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Clean Deno process: execute command &lt;code&gt;deno-bridge-exit&lt;/code&gt; and select application name&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;TypeScript (deno-bridge-demo.ts)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import { DenoBridge } from &#34;https://deno.land/x/denobridge@0.0.1/mod.ts&#34;&#xA;&#xA;const bridge = new DenoBridge(Deno.args[0], Deno.args[1], Deno.args[2], messageDispatcher)&#xA;&#xA;async function messageDispatcher(message: string) {&#xA;    const info = JSON.parse(message)&#xA;    if (info[0] == &#34;ping&#34;) {&#xA;        console.log(&#34;Emacs message: &#34;, info[1][0])&#xA;&#xA;        const emacsVar = await bridge.getEmacsVar(&#34;deno-bridge-app-list&#34;)&#xA;        console.log(&#34;Emacs var &#39;deno-bridge-app-list&#39;: &#34;, emacsVar)&#xA;&#xA;        bridge.messageToEmacs(&#34;Hi from TypeScript&#34;)&#xA;&#xA;        bridge.evalInEmacs(&#39;(message \&#34;Eval from TypeScript\&#34;)&#39;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create DenoBridge object to communicate with Emacs&lt;/li&gt; &#xA; &lt;li&gt;Get Emacs variable value: &lt;code&gt;await bridge.getEmacsVar(emacs-var-name)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Show message in Emacs minibuffer: &lt;code&gt;bridge.messageToEmacs(&#34;message&#34;)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Eval Elisp code in TypeScript: &lt;code&gt;bridge.evalInEmacs(&#39;(message \&#34;Eval from TypeScript\&#34;)&#39;)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;That&#39;s all story about deno-bridge.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Project base on deno-bridge&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/P233/emmet2-mode&#34;&gt;emmet2-mode&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributor&lt;/h2&gt; &#xA;&lt;a href=&#34;https://github.com/manateelazycat/deno-bridge/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=manateelazycat/deno-bridge&#34;&gt; &lt;/a&gt;</summary>
  </entry>
  <entry>
    <title>emacsorphanage/quickrun</title>
    <updated>2022-10-11T01:33:33Z</updated>
    <id>tag:github.com,2022-10-11:/emacsorphanage/quickrun</id>
    <link href="https://github.com/emacsorphanage/quickrun" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Run command quickly. This packages is inspired quickrun.vim&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://melpa.org/#/quickrun&#34;&gt;&lt;img src=&#34;https://melpa.org/packages/quickrun-badge.svg?sanitize=true&#34; alt=&#34;melpa badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stable.melpa.org/#/quickrun&#34;&gt;&lt;img src=&#34;https://stable.melpa.org/packages/quickrun-badge.svg?sanitize=true&#34; alt=&#34;melpa stable badge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;quickrun.el&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;quickrun.el&lt;/strong&gt; is Emacs port of &lt;a href=&#34;https://github.com/thinca/vim-quickrun&#34;&gt;quickrun.vim&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/emacsorphanage/quickrun/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/emacsorphanage/quickrun/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;quickrun.el&lt;/code&gt; is a extension to execute editing buffer. &lt;code&gt;quickrun.el&lt;/code&gt; is similar to executable-interpret, but &lt;code&gt;quickrun.el&lt;/code&gt; provides more convenient commands. &lt;code&gt;quickrun.el&lt;/code&gt; execute not only script languages(Perl, Ruby, Python etc), but also compiling languages(C, C++, Go, Java etc) and markup language.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Emacs 24.3 or higher.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install &lt;code&gt;quickrun.el&lt;/code&gt; from &lt;a href=&#34;https://melpa.org/&#34;&gt;MELPA&lt;/a&gt; with package.el.&lt;/p&gt; &#xA;&lt;p&gt;Or install directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd load-path-dir&#xA;$ wget https://raw.githubusercontent.com/syohex/emacs-quickrun/master/quickrun.el&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After Installation add following to your configuration file(~/.emacs.d/init.el, ~/.emacs etc)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;quickrun)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Support Programming Languages&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;quickrun.el&lt;/code&gt; supports following programming languages and markup languages as default. But you can register your own command and apply other languages.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Programming Language(commands used)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;C (&lt;code&gt;gcc&lt;/code&gt; / &lt;code&gt;clang&lt;/code&gt; / &lt;code&gt;Visual C++&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;C++ (&lt;code&gt;g++&lt;/code&gt; / &lt;code&gt;clang++&lt;/code&gt; / &lt;code&gt;Visual C++&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;C# (&lt;code&gt;dotnet&lt;/code&gt; / &lt;code&gt;mono&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Objective-C (gcc -objc)&lt;/li&gt; &#xA; &lt;li&gt;D Language (&lt;code&gt;dmd&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Fortran (&lt;code&gt;gfortran&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Java (&lt;code&gt;javac&lt;/code&gt; / &lt;code&gt;java&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Perl (&lt;code&gt;perl&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Perl6 (&lt;code&gt;perl6&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Ruby (&lt;code&gt;ruby&lt;/code&gt; / &lt;code&gt;mruby&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Python (&lt;code&gt;python&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;PHP (&lt;code&gt;php&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Emacs Lisp (&lt;code&gt;emacs&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Scheme (&lt;code&gt;gosh&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Smalltalk (&lt;code&gt;gst&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Racket (&lt;code&gt;racket&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Common Lisp (&lt;code&gt;clisp&lt;/code&gt; / &lt;code&gt;sbcl&lt;/code&gt; / &lt;code&gt;ccl&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Clojure (&lt;code&gt;jark&lt;/code&gt; / &lt;code&gt;clj-env-dir&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Javascript (&lt;code&gt;node&lt;/code&gt; / &lt;code&gt;v8&lt;/code&gt; / &lt;code&gt;js&lt;/code&gt; / &lt;code&gt;jrunscript&lt;/code&gt; / &lt;code&gt;cscript&lt;/code&gt; / &lt;code&gt;deno&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Coffee Script (&lt;code&gt;coffee&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;JSX (&lt;code&gt;jsx&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Markdown (&lt;code&gt;Markdown.pl&lt;/code&gt; / &lt;code&gt;bluecloth&lt;/code&gt; / &lt;code&gt;kramdown&lt;/code&gt; / &lt;code&gt;pandoc&lt;/code&gt; / &lt;code&gt;redcarpet&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Haskell (&lt;code&gt;runghc&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Go Language (&lt;code&gt;go&lt;/code&gt; / &lt;code&gt;gccgo&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Io (&lt;code&gt;io&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Lua (&lt;code&gt;lua&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Groovy (&lt;code&gt;groovy&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Scala (&lt;code&gt;scala&lt;/code&gt;) &lt;strong&gt;Please use UTF-8 encoding&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;HAML (&lt;code&gt;haml&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;SASS (&lt;code&gt;sass&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;LESS (&lt;code&gt;lessc&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Erlang (&lt;code&gt;escript&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;OCaml (&lt;code&gt;ocamlc&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;F# (&lt;code&gt;fsharpc&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;ShellScript (shebang&#39;s shell)&lt;/li&gt; &#xA; &lt;li&gt;AWK (&lt;code&gt;awk&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Rust (&lt;code&gt;rustc&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Dart (&lt;code&gt;dart&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Elixir (&lt;code&gt;elixir&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;TypeScript (&lt;code&gt;tsc&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Tcl (&lt;code&gt;tclsh&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Swift (&lt;code&gt;swift&lt;/code&gt;, &lt;code&gt;xcrun&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;ATS2 (&lt;code&gt;patscc&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;R (&lt;code&gt;Rscript&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Nim/NimScript (&lt;code&gt;nim&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Julia (&lt;code&gt;julia&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Gnuplot (&lt;code&gt;gnuplot&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Kotlin (&lt;code&gt;kotlin&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Crystal (&lt;code&gt;crystal&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;V (&lt;code&gt;v&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Applescript (&lt;code&gt;osascript&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Assembly Language (&lt;code&gt;nasm&lt;/code&gt;, &lt;code&gt;masm&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See also &lt;code&gt;quickrun--support-languages&lt;/code&gt; global variable.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Execute current buffer. If &lt;code&gt;quickrun.el&lt;/code&gt; does not find command-key, then &lt;code&gt;quickrun.el&lt;/code&gt; asks you command-key(You always input command if you use &lt;code&gt;C-u&lt;/code&gt; prefix key)&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-select&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Like &lt;code&gt;quickrun&lt;/code&gt; command but select the backend before the execution.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-region&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Execute region. (Java is not supported)&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-with-arg&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Execute current buffer with arguments. &lt;code&gt;quickrun.el&lt;/code&gt; asks you command line argument&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-shell&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Execute current buffer in eshell for interactive command such as program which reads input from STDIN.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-compile-only&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Compile current buffer with compile.el framework, not execute. quickrun with &lt;code&gt;C-u C-u&lt;/code&gt; prefix behaves same as quickrun-compile-only.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-compile-only-select&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Like &lt;code&gt;quickrun-compile-only&lt;/code&gt; command but select the backend before the execution.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-replace-region&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Replace region of code with its output.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;quickrun-autorun-mode&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Minor mode which executes &lt;code&gt;quickrun&lt;/code&gt; after saving buffer.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;helm-quickrun&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;M-x quickrun&lt;/code&gt; with helm interface&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;anything-quickrun&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;M-x quickrun&lt;/code&gt; with anything interface&lt;/p&gt; &#xA;&lt;h2&gt;Note&lt;/h2&gt; &#xA;&lt;p&gt;If quickrun returns &lt;code&gt;command not found&lt;/code&gt;, please check &lt;code&gt;(executable-find &#34;THE_COMMAND_NAME&#34;)&lt;/code&gt; [for example &lt;code&gt;(executable-find &#34;gnuplot&#34;)&lt;/code&gt;] . If this returns &lt;code&gt;nil&lt;/code&gt;, I strongly recommend you use &lt;a href=&#34;https://github.com/purcell/exec-path-from-shell&#34;&gt;https://github.com/purcell/exec-path-from-shell&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Send File to STDIN&lt;/h2&gt; &#xA;&lt;p&gt;If &lt;code&gt;executed_file.qrinput&lt;/code&gt;(like &lt;code&gt;foo.c.qrinput&lt;/code&gt;) is existed in directory same as executed buffer file, &lt;code&gt;quickrun.el&lt;/code&gt; sends its content to stdin of executed program. Please set &lt;code&gt;quickrun-input-file-extension&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; If you want to disable this feature.&lt;/p&gt; &#xA;&lt;h2&gt;Customize&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;quickrun-focus-p&lt;/code&gt;(Default: &lt;code&gt;t&lt;/code&gt;)&lt;/h3&gt; &#xA;&lt;p&gt;If this value is &lt;code&gt;nil&lt;/code&gt;, quickrun.el does not move focus to output buffer.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;quickrun-truncate-lines&lt;/code&gt;(Default: &lt;code&gt;t&lt;/code&gt;)&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;truncate-lines&#39; value for &lt;/code&gt;&lt;em&gt;quickrun&lt;/em&gt;` buffer.&lt;/p&gt; &#xA;&lt;h2&gt;User Defined Command&lt;/h2&gt; &#xA;&lt;p&gt;You can add your own command or override existsing command by &lt;code&gt;quickrun-add-command&lt;/code&gt; as below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;; Use this parameter as C++ default&#xA;(quickrun-add-command &#34;c++/c1z&#34;&#xA;  &#39;((:command . &#34;g++&#34;)&#xA;    (:exec    . (&#34;%c -std=c++1z %o -o %e %s&#34;&#xA;&#x9;&#x9; &#34;%e %a&#34;))&#xA;    (:remove  . (&#34;%e&#34;)))&#xA;  :default &#34;c++&#34;)&#xA;&#xA;;; Use this parameter in pod-mode&#xA;(quickrun-add-command &#34;pod&#34;&#xA;  &#39;((:command . &#34;perldoc&#34;)&#xA;    (:exec    . &#34;%c -T -F %s&#34;))&#xA;  :mode &#39;pod-mode)&#xA;&#xA;;; You can override existing command&#xA;(quickrun-add-command &#34;c/gcc&#34;&#xA;  &#39;((:exec . (&#34;%c -std=c++1z %o -o %e %s&#34;&#xA;&#x9;      &#34;%e %a&#34;)))&#xA;  :override t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;First argument of &lt;code&gt;quickrun-add-command&lt;/code&gt; is command key. Second argument of it is command parameter, which is described laster. &lt;code&gt;quickrun-add-command&lt;/code&gt; also takes key parameters, &lt;code&gt;:default&lt;/code&gt;, &lt;code&gt;:mode&lt;/code&gt;, &lt;code&gt;:override&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Argument&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;:default&lt;/code&gt; lang&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Use this command parameter as default in specified language&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;:mode&lt;/code&gt; mode&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;this command parameter in specified mode&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;:override&lt;/code&gt; bool&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Override existing parameter with specified parameter&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Command Parameter&lt;/h3&gt; &#xA;&lt;p&gt;Command alist has following parameters,&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:command&lt;/code&gt;(mandatory parameter)&lt;/h4&gt; &#xA;&lt;p&gt;Command name. &lt;code&gt;%c&lt;/code&gt; is expanded into this value.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:cmdopt&lt;/code&gt;(optional)&lt;/h4&gt; &#xA;&lt;p&gt;Command(&lt;code&gt;:command&lt;/code&gt;) option. &lt;code&gt;%o&lt;/code&gt; is expanded into this value.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:exec&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Executed commands. You can also set command list parameter. If you set list parameter, &lt;code&gt;quickrun.el&lt;/code&gt; executes command list in order.&lt;/p&gt; &#xA;&lt;p&gt;If this parameter is omitted, &lt;code&gt;quickrun.el&lt;/code&gt; use default execute command template &#34;%c %o %s %a&#34;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:timeout&lt;/code&gt;(optional)&lt;/h4&gt; &#xA;&lt;p&gt;Timeout in seconds for the process spawn by the command. This value takes precedence over the &lt;code&gt;quickrun-timeout-seconds&lt;/code&gt; custom variable.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:compile-only&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Command exected by &lt;code&gt;quickrun-compile-only&lt;/code&gt;. This option is used for syntax check or converting another language(e.g. CoffeeScript =&amp;gt; JavaScript).&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;:compile-conf&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Configuration of &lt;code&gt;quickrun-compile-only&lt;/code&gt;. This parameter must be alist.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:remove&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Remove files after executing. If command create some intermediate files, you should set this parameter. :remove value is atom or list.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:outputter&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Please see Outputter section.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:default-directory&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Directory where commands are executed.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:tempfile&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Use temporary file or not. &lt;code&gt;quickrun.el&lt;/code&gt; uses temporary file if you omit this parameter.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: If you set this parameter, you cannot use &lt;code&gt;quickrun-region&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;:description&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Description of this command. This parameter is used in &lt;code&gt;helm-quickrun&lt;/code&gt; or &lt;code&gt;anything-quickrun&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Placeholders&lt;/h3&gt; &#xA;&lt;p&gt;You can use following placeholders in command parameter&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Placeholder&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Expanded&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;%c&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Command&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;%o&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Command line option&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;%s&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Source(absolute path)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;%a&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Script&#39;s arguments&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;%n&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Source without extension(absolute path)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;%N&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Source without extension(nondirectory)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Directory name of Source(absolute path)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;%e&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Source with executable suffix(absolute path)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;%E&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Source with executable suffix(nondirectory)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Source file name(&lt;code&gt;%s&lt;/code&gt;, &lt;code&gt;%n&lt;/code&gt; etc) is not original file name except Java language. Because &lt;code&gt;quickrun.el&lt;/code&gt; copys source file to temporary file firstly.&lt;/p&gt; &#xA;&lt;h2&gt;Change Default Command&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;quickrun-set-default&lt;/code&gt; changes default command in language that is registerd multiple command parameters(like c, c++,Javascript).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(quickrun-set-default &#34;c&#34; &#34;c/clang&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means that quickrun uses &#34;c/clang&#34; for C files.&lt;/p&gt; &#xA;&lt;h2&gt;Timeout Seconds&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;quickrun.el&lt;/code&gt; kills process if program run over 10 seconds as default. This avoids infinite loop program or endless program by some mistakes. You control timeout second to set &lt;code&gt;quickrun-timeout-seconds&lt;/code&gt;. This feature is disabled if &lt;code&gt;quickrun-timeout-seconds&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. The timeout can also be set per command with the &lt;code&gt;:timeout&lt;/code&gt; parameter. (You can also kill process by &lt;code&gt;C-c C-c&lt;/code&gt; in quickrun buffer)&lt;/p&gt; &#xA;&lt;h2&gt;Key bindings in quickrun buffer&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Key&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Command&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;q&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Close quickrun window&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;C-c C-c&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Kill quickrun process&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Buffer Local Variables&lt;/h2&gt; &#xA;&lt;p&gt;Buffer local variables is priority to default parameters.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-option-cmd-alist&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Command alist.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-option-command&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Command key(Expanded to %c)&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-option-cmdkey&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Command key of command parameter.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-option-cmdopt&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Command option(Expanded to %o)&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-option-args&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Program argument(Expanded to %a.)&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-option-shebang&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;If this value is &lt;code&gt;non-nil&lt;/code&gt; and first line of source file is started &#34;#!&#34;, the following string is treated as &#34;:command&#34;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-option-outputter&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Outputter function. See &lt;em&gt;Outputter&lt;/em&gt; section&lt;/p&gt; &#xA;&lt;h3&gt;Example of buffer local variable&lt;/h3&gt; &#xA;&lt;p&gt;Setting C++11.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;vector&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;&#xA;int main (int argc, char *argv[])&#xA;{&#xA;    std::vector &amp;lt;std::string&amp;gt; lst = { &#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34; };&#xA;&#xA;    for (auto x : lst) {&#xA;        std::cout &amp;lt;&amp;lt; &#34;[&#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#34;]&#34; &amp;lt;&amp;lt; std::endl;&#xA;    }&#xA;&#xA;    for (auto i = 1; i &amp;lt; argc; i++) {&#xA;        std::cout &amp;lt;&amp;lt; &#34;[&#34; &amp;lt;&amp;lt; argv[i] &amp;lt;&amp;lt; &#34;]&#34; &amp;lt;&amp;lt; std::endl;&#xA;    }&#xA;&#xA;    return 0;&#xA;}&#xA;&#xA;/*&#xA;  Local Variables:&#xA;  quickrun-option-cmd-alist: ((:command . &#34;g++&#34;)&#xA;                              (:exec    . (&#34;%c -std=c++0x -o %n %s&#34;&#xA;                                           &#34;%n apple orange melon&#34;))&#xA;                              (:remove  . (&#34;%n&#34;)))&#xA;  End:&#xA;*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Hooks&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;code&gt;quickrun-after-run-hook&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Run hooks after execute all commands.&lt;/p&gt; &#xA;&lt;h2&gt;Outputter&lt;/h2&gt; &#xA;&lt;p&gt;Outputter is a function for processing command output. Default outputter is to output to *quickrun* buffer and processing ANSI Color sequence.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;quickrun.el&lt;/code&gt; defines following functions as default.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;buffer:buffername&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Output to buffer. &lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/quickrun/master/sample/sample_outputter_buffer.pl&#34;&gt;outputter &lt;em&gt;buffer&lt;/em&gt; sample&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;file:filename&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Output to file. &lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/quickrun/master/sample/sample_outputter_file.pl&#34;&gt;outputter &lt;em&gt;file&lt;/em&gt; sample&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;variable:varname&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Output to variable. &lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/quickrun/master/sample/sample_outputter_variable.pl&#34;&gt;outputter &lt;em&gt;variable&lt;/em&gt; sample&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;browser&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Output to Web browser(using function &lt;em&gt;browse-url&lt;/em&gt;) &lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/quickrun/master/sample/sample_outputter_browser.pl&#34;&gt;outputter &lt;em&gt;browser&lt;/em&gt; sample&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;message&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Output to *Message* buffer(using function &lt;em&gt;message&lt;/em&gt;) &lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/quickrun/master/sample/sample_outputter_message.pl&#34;&gt;outputter &lt;em&gt;message&lt;/em&gt; sample&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;multi&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Use multiple outputters. &lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/quickrun/master/sample/sample_outputter_multi.pl&#34;&gt;outputter &lt;em&gt;multi&lt;/em&gt; sample&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;null&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;No output. &lt;a href=&#34;https://raw.githubusercontent.com/emacsorphanage/quickrun/master/sample/sample_outputter_null.pl&#34;&gt;outputter &lt;em&gt;null&lt;/em&gt; sample&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Using quickrun as function from other functions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;quickrun&lt;/code&gt; can be used as function from other functions. You can pass configuration by &lt;code&gt;:source&lt;/code&gt; argument. Sample is following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun test-perl ()&#xA;  (interactive)&#xA;  (let* ((cmd &#34;git rev-parse --show-toplevel&#34;)&#xA;         (topdir (with-temp-buffer&#xA;                   (call-process-shell-command cmd nil t nil)&#xA;                   (goto-char (point-min))&#xA;                   (if (re-search-forward &#34;^\\(.+\\)$&#34; nil t)&#xA;                       (match-string 1)))))&#xA;    (quickrun :source `((:command . &#34;prove&#34;)&#xA;                        (:default-directory . ,topdir)&#xA;                        (:exec . (&#34;%c -bv --color %s&#34;))))))&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>