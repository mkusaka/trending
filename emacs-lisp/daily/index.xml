<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-19T01:36:54Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>oantolin/orderless</title>
    <updated>2022-08-19T01:36:54Z</updated>
    <id>tag:github.com,2022-08-19:/oantolin/orderless</id>
    <link href="https://github.com/oantolin/orderless" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs completion style that matches multiple regexps in any order&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Orderless #+OPTIONS: d:nil #+EXPORT_FILE_NAME: orderless.texi #+TEXINFO_DIR_CATEGORY: Emacs misc features #+TEXINFO_DIR_TITLE: Orderless: (orderless). #+TEXINFO_DIR_DESC: Completion style for matching regexps in any order&lt;/p&gt; &#xA;&lt;p&gt;#+html: &lt;a href=&#34;http://elpa.gnu.org/packages/orderless.html&#34;&gt;&lt;img alt=&#34;GNU ELPA&#34; src=&#34;https://elpa.gnu.org/packages/orderless.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;http://elpa.gnu.org/devel/orderless.html&#34;&gt;&lt;img alt=&#34;GNU-devel ELPA&#34; src=&#34;https://elpa.gnu.org/devel/orderless.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://melpa.org/#/orderless&#34;&gt;&lt;img alt=&#34;MELPA&#34; src=&#34;https://melpa.org/packages/orderless-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; #+html: &lt;a href=&#34;https://stable.melpa.org/#/orderless&#34;&gt;&lt;img alt=&#34;MELPA Stable&#34; src=&#34;https://stable.melpa.org/packages/orderless-badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Overview :PROPERTIES: :TOC: :include all :ignore this :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This package provides an =orderless= /completion style/ that divides the pattern into space-separated components, and matches candidates that match all of the components in any order. Each component can match in any one of several ways: literally, as a regexp, as an initialism, in the flex style, or as multiple word prefixes. By default, regexp and literal matches are enabled.&lt;/p&gt; &#xA;&lt;p&gt;A completion style is a back-end for completion and is used from a front-end that provides a completion UI. Any completion style can be used with the default Emacs completion UI (sometimes called minibuffer tab completion), with the built-in Icomplete package (which is similar to the more well-known Ido Mode), the icomplete-vertical variant from Emacs 28 (see the external [[https://github.com/oantolin/icomplete-vertical][icomplete-vertical]] package to get that functionality on earlier versions of Emacs), or with some third party minibuffer completion frameworks such as [[https://gitlab.com/protesilaos/mct][Mct]], [[https://github.com/minad/vertico][Vertico]], or [[https://github.com/raxod502/selectrum][Selectrum]] (in its default configuration).&lt;/p&gt; &#xA;&lt;p&gt;All the completion UIs just mentioned are for minibuffer completion, used when Emacs commands prompt the user in the minibuffer for some input, but there is also completion at point in normal buffers, typically used for identifiers in programming languages. Completion styles can also be used for that purpose by completion at point UIs such as [[https://github.com/minad/corfu][Corfu]], [[https://company-mode.github.io/][Company]] or the function =consult-completion-in-region= from [[https://github.com/minad/consult][Consult]].&lt;/p&gt; &#xA;&lt;p&gt;To use a completion style with any of the above mentioned completion UIs simply add it as an entry in the variables =completion-styles= and =completion-category-overrides= (see their documentation). You may also want to modify the =completion-category-defaults= variable, which serves as a default value for =completion-category-overrides=: if you want to use =orderless= exclusively, set both variables to =nil=.&lt;/p&gt; &#xA;&lt;p&gt;With a bit of effort, it might still be possible to use =orderless= with other completion UIs, even if those UIs don&#39;t support the standard Emacs completion styles. Currently there is support for [[https://github.com/abo-abo/swiper][Ivy]] (see below). Also, while Company does support completion styles directly, pressing =SPC= takes you out of completion, so comfortably using =orderless= with it takes a bit of configuration (see below).&lt;/p&gt; &#xA;&lt;p&gt;If you use ELPA or MELPA, the easiest way to install =orderless= is via =package-install=. If you use =use-package=, you can use:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (use-package orderless :ensure t :custom (completion-styles &#39;(orderless basic)) (completion-category-overrides &#39;((file (styles basic partial-completion))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, put =orderless.el= somewhere on your =load-path=, and use the following configuration:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (require &#39;orderless) (setq completion-styles &#39;(orderless basic) completion-category-overrides &#39;((file (styles basic partial-completion)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =basic= completion style is specified as fallback in addition to =orderless= in order to ensure that completion commands which rely on dynamic completion tables, e.g., &lt;del&gt;completion-table-dynamic&lt;/del&gt; or &lt;del&gt;completion-table-in-turn&lt;/del&gt;, work correctly. Furthermore the =basic= completion style needs to be tried /first/ (not as a fallback) for TRAMP hostname completion to work. In order to achieve that, we add an entry for the =file= completion category in the =completion-category-overrides= variable. In addition, the =partial-completion= style allows you to use wildcards for file completion and partial paths, e.g., &lt;del&gt;/u/s/l&lt;/del&gt; for &lt;del&gt;/usr/share/local&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Bug reports are highly welcome and appreciated!&lt;/p&gt; &#xA;&lt;p&gt;:CONTENTS:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#screenshot][Screenshot]]&lt;/li&gt; &#xA; &lt;li&gt;[[#customization][Customization]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#component-matching-styles][Component matching styles]] &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;[[#style-dispatchers][Style dispatchers]]&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;[[#component-separator-regexp][Component separator regexp]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#faces-for-component-matches][Faces for component matches]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#pattern-compiler][Pattern compiler]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#interactively-changing-the-configuration][Interactively changing the configuration]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#integration-with-other-completion-uis][Integration with other completion UIs]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#ivy][Ivy]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#selectrum][Selectrum]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#company][Company]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#related-packages][Related packages]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#ivy-and-helm][Ivy and Helm]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#prescient][Prescient]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#restricting-to-current-matches-in-icicles-ido-and-ivy][Restricting to current matches: Icicles, Ido and Ivy]] :END:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Screenshot :noexport:&lt;/p&gt; &#xA;&lt;p&gt;This is what it looks like to use =describe-function= (bound by default to =C-h f=) to match =eis ff=. Notice that in this particular case =eis= matched as an initialism, and =ff= matched as a regexp. The completion UI in the screenshot is [[https://github.com/oantolin/icomplete-vertical][icomplete-vertical]] and the theme is Protesilaos Stavrou&#39;s lovely [[https://gitlab.com/protesilaos/modus-themes][modus-operandi]].&lt;/p&gt; &#xA;&lt;p&gt;[[images/describe-function-eis-ff.png]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Customization&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Component matching styles&lt;/p&gt; &#xA;&lt;p&gt;Each component of a pattern can match in any of several matching styles. A matching style is simply a function from strings to strings that maps a component to a regexp to match against, so it is easy to define new matching styles. The predefined ones are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;orderless-regexp :: the component is treated as a regexp that must match somewhere in the candidate.&lt;/p&gt; &lt;p&gt;If the component is not a valid regexp, it is ignored.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;orderless-literal :: the component is treated as a literal string that must occur in the candidate.&lt;/p&gt; &lt;p&gt;This is just =regexp-quote=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;orderless-without-literal&lt;/em&gt; :: the component is a treated as a literal string that must &lt;em&gt;not&lt;/em&gt; occur in the candidate.&lt;/p&gt; &lt;p&gt;Note that nothing is highlighted for this matching style. You probably don&#39;t want to use this style directly in =orderless-matching-styles= but with a style dispatcher instead. There is an example in the section on style dispatchers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;orderless-prefixes :: the component is split at word endings and each piece must match at a word boundary in the candidate, occurring in that order.&lt;/p&gt; &lt;p&gt;This is similar to the built-in =partial-completion= completion-style. For example, =re-re= matches =query-replace-regexp=, =recode-region= and =magit-remote-list-refs=; =f-d.t= matches =final-draft.txt=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;orderless-initialism :: each character of the component should appear as the beginning of a word in the candidate, in order.&lt;/p&gt; &lt;p&gt;This maps =abc= to =&amp;lt;a.&lt;em&gt;&amp;lt;b.&lt;/em&gt;\c=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;orderless-flex :: the characters of the component should appear in that order in the candidate, but not necessarily consecutively.&lt;/p&gt; &lt;p&gt;This maps =abc= to =a.*b.*c=.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The variable =orderless-matching-styles= can be set to a list of the desired matching styles to use. By default it enables the literal and regexp styles.&lt;/p&gt; &#xA;&lt;p&gt;*** Style dispatchers&lt;/p&gt; &#xA;&lt;p&gt;For more fine-grained control on which matching styles to use for each component of the input string, you can customize the variable =orderless-style-dispatchers=.&lt;/p&gt; &#xA;&lt;p&gt;Style dispatchers are functions which take a component, its index in the list of components (starting from 0), and the total number of components, and are used to determine the matching styles used for that specific component, overriding the default matching styles.&lt;/p&gt; &#xA;&lt;p&gt;A style dispatcher can either decline to handle the input string or component, or it can return which matching styles to use. It can also, if desired, additionally return a new string to use in place of the given one. Consult the documentation of =orderless-dispatch= for full details.&lt;/p&gt; &#xA;&lt;p&gt;As an example, say you wanted the following setup:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;you normally want components to match as regexps,&lt;/li&gt; &#xA; &lt;li&gt;except for the first component, which should always match as an initialism ---this is pretty useful for, say, =execute-extended-command= (=M-x=) or =describe-function= (=C-h f=),&lt;/li&gt; &#xA; &lt;li&gt;later components ending in =&lt;del&gt;= should match (the characters other than the final =&lt;/del&gt;=) in the flex style, and&lt;/li&gt; &#xA; &lt;li&gt;later components starting with =!= should indicate the rest of the component is a literal string not contained in the candidate.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can achieve this with the following configuration:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun flex-if-twiddle (pattern _index _total) (when (string-suffix-p &#34;~&#34; pattern) `(orderless-flex . ,(substring pattern 0 -1))))&lt;/p&gt; &#xA;&lt;p&gt;(defun first-initialism (pattern index _total) (if (= index 0) &#39;orderless-initialism))&lt;/p&gt; &#xA;&lt;p&gt;(defun without-if-bang (pattern _index _total) (cond ((equal &#34;!&#34; pattern) &#39;(orderless-literal . &#34;&#34;)) ((string-prefix-p &#34;!&#34; pattern) `(orderless-without-literal . ,(substring pattern 1)))))&lt;/p&gt; &#xA;&lt;p&gt;(setq orderless-matching-styles &#39;(orderless-regexp) orderless-style-dispatchers &#39;(first-initialism flex-if-twiddle without-if-bang)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Component separator regexp&lt;/p&gt; &#xA;&lt;p&gt;The pattern components are space-separated by default: this is controlled by the variable =orderless-component-separator=, which should be set either to a regexp that matches the desired component separator, or to a function that takes a string and returns the list of components. The default value is a regexp matches a non-empty sequence of spaces. It may be useful to add hyphens or slashes (or both), to match symbols or file paths, respectively.&lt;/p&gt; &#xA;&lt;p&gt;Even if you want to split on spaces you might want to be able to escape those spaces or to enclose space in double quotes (as in shell argument parsing). For backslash-escaped spaces set =orderless-component-separator= to the function =orderless-escapable-split-on-space=; for shell-like double-quotable space, set it to the standard Emacs function =split-string-and-unquote=.&lt;/p&gt; &#xA;&lt;p&gt;If you are implementing a command for which you know you want a different separator for the components, bind =orderless-component-separator= in a =let= form.&lt;/p&gt; &#xA;&lt;p&gt;** Defining custom orderless styles&lt;/p&gt; &#xA;&lt;p&gt;Orderless allows the definition of custom completion styles using the &lt;del&gt;orderless-define-completion-style&lt;/del&gt; macro. Any Orderless configuration variable can be adjusted locally for the new style, e.g., &lt;del&gt;orderless-matching-styles&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default Orderless only enables the regexp and literal matching styles. In the following example an &lt;del&gt;orderless+initialism&lt;/del&gt; style is defined, which additionally enables initialism matching. This completion style can then used when matching candidates of the symbol or command completion category.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (orderless-define-completion-style orderless+initialism (orderless-matching-styles &#39;(orderless-initialism orderless-literal orderless-regexp))) (setq completion-category-overrides &#39;((command (styles orderless+initialism)) (symbol (styles orderless+initialism)) (variable (styles orderless+initialism)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Note that in order for the =orderless+initialism= style to kick-in with the above configuration, you&#39;d need to use commands whose metadata indicates that the completion candidates are commands or symbols. In Emacs 28, =execute-extended-command= has metadata indicating you are selecting a command, but earlier versions of Emacs lack this metadata. Activating =marginalia-mode= from the [[https://github.com/minad/marginalia][Marginalia]] package provides this metadata automatically for many built-in commands and is recommended if you use the above example configuration, or other similarly fine-grained control of completion styles according to completion category.&lt;/p&gt; &#xA;&lt;p&gt;** Faces for component matches&lt;/p&gt; &#xA;&lt;p&gt;The portions of a candidate matching each component get highlighted in one of four faces, =orderless-match-face-?= where =?= is a number from 0 to 3. If the pattern has more than four components, the faces get reused cyclically.&lt;/p&gt; &#xA;&lt;p&gt;If your =completion-styles= (or =completion-category-overrides= for some particular category) has more than one entry, remember than Emacs tries each completion style in turn and uses the first one returning matches. You will only see these particular faces when the =orderless= completion is the one that ends up being used, of course.&lt;/p&gt; &#xA;&lt;p&gt;** Pattern compiler&lt;/p&gt; &#xA;&lt;p&gt;The default mechanism for turning an input string into a list of regexps to match against, configured using =orderless-matching-styles=, is probably flexible enough for the vast majority of users. The patterns are compiled by the =orderless-pattern-compiler=. Under special circumstances it may be useful to implement a custom pattern compiler by advising the =orderless-pattern-compiler=.&lt;/p&gt; &#xA;&lt;p&gt;** Interactively changing the configuration&lt;/p&gt; &#xA;&lt;p&gt;You might want to change the separator or the matching style configuration on the fly while matching. There many possible user interfaces for this: you could toggle between two chosen configurations, cycle among several, have a keymap where each key sets a different configurations, have a set of named configurations and be prompted (with completion) for one of them, popup a [[https://github.com/abo-abo/hydra][hydra]] to choose a configuration, etc. Since there are so many possible UIs and which to use is mostly a matter of taste, =orderless= does not provide any such commands. But it&#39;s easy to write your own!&lt;/p&gt; &#xA;&lt;p&gt;For example, say you want to use the keybinding =C-l= to make all components match literally. You could use the following code:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (defun my/match-components-literally () &#34;Components match literally for the rest of the session.&#34; (interactive) (setq-local orderless-matching-styles &#39;(orderless-literal) orderless-style-dispatchers nil))&lt;/p&gt; &#xA;&lt;p&gt;(define-key minibuffer-local-completion-map (kbd &#34;C-l&#34;) #&#39;my/match-components-literally) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Using =setq-local= to assign to the configuration variables ensures the values are only used for that minibuffer completion session.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Integration with other completion UIs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Several excellent completion UIs exist for Emacs in third party packages. They do have a tendency to forsake standard Emacs APIs, so integration with them must be done on a case by case basis.&lt;/p&gt; &#xA;&lt;p&gt;If you manage to use =orderless= with a completion UI not listed here, please file an issue or make a pull request so others can benefit from your effort. The functions =orderless-filter=, =orderless-highlight-matches=, =orderless--highlight= and =orderless--component-regexps= are likely to help with the integration.&lt;/p&gt; &#xA;&lt;p&gt;** Ivy&lt;/p&gt; &#xA;&lt;p&gt;To use =orderless= from Ivy add this to your Ivy configuration:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq ivy-re-builders-alist &#39;((t . orderless-ivy-re-builder))) (add-to-list &#39;ivy-highlight-functions-alist &#39;(orderless-ivy-re-builder . orderless-ivy-highlight)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Selectrum&lt;/p&gt; &#xA;&lt;p&gt;Recent versions of Selectrum default to using whatever completion styles you have configured. If you stick with that default configuration you can use =orderless= just by adding it to =completion-styles=. Alternatively, you can use this configuration:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (setq selectrum-refine-candidates-function #&#39;orderless-filter) (setq selectrum-highlight-candidates-function #&#39;orderless-highlight-matches) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you use the above configuration, only the visible candidates are highlighted, which is a litte more efficient.&lt;/p&gt; &#xA;&lt;p&gt;** Company&lt;/p&gt; &#xA;&lt;p&gt;Company comes with a =company-capf= backend that uses the completion-at-point functions, which in turn use completion styles. This means that the =company-capf= backend will automatically use =orderless=, no configuration necessary!&lt;/p&gt; &#xA;&lt;p&gt;But there are a couple of points of discomfort:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Pressing SPC takes you out of completion, so with the default separator you are limited to one component, which is no fun. To fix this add a separator that is allowed to occur in identifiers, for example, for Emacs Lisp code you could use an ampersand:&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp (setq orderless-component-separator &#34;[ &amp;amp;]&#34;) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The matching portions of candidates aren&#39;t highlighted. That&#39;s because =company-capf= is hard-coded to look for the =completions-common-part= face, and it only use one face, =company-echo-common= to highlight candidates.&lt;/p&gt; &lt;p&gt;So, while you can&#39;t get different faces for different components, you can at least get the matches highlighted in the sole available face with this configuration:&lt;/p&gt; &lt;p&gt;#+begin_src emacs-lisp (defun just-one-face (fn &amp;amp;rest args) (let ((orderless-match-faces [completions-common-part])) (apply fn args)))&lt;/p&gt; &lt;p&gt;(advice-add &#39;company-capf--candidates :around #&#39;just-one-face) #+end_src&lt;/p&gt; &lt;p&gt;(Aren&#39;t dynamically scoped variables and the advice system nifty?)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Related packages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Ivy and Helm&lt;/p&gt; &#xA;&lt;p&gt;The well-known and hugely powerful completion frameworks [[https://github.com/abo-abo/swiper][Ivy]] and [[https://github.com/emacs-helm/helm][Helm]] also provide for matching space-separated component regexps in any order. In Ivy, this is done with the =ivy--regex-ignore-order= matcher. In Helm, it is the default, called &#34;multi pattern matching&#34;.&lt;/p&gt; &#xA;&lt;p&gt;This package is significantly smaller than either of those because it solely defines a completion style, meant to be used with any completion UI supporting completion styles while both of those provide their own completion UI (and many other cool features!).&lt;/p&gt; &#xA;&lt;p&gt;It is worth pointing out that Helm does provide its multi pattern matching as a completion style which could be used with default tab completion, Icomplete, Selectrum or other UIs supporting completion styles! (Ivy does not provide a completion style to my knowledge.) So, for example, Icomplete users could, instead of using this package, install Helm and configure Icomplete to use it as follows:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (require &#39;helm) (setq completion-styles &#39;(helm basic)) (icomplete-mode) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;(Of course, if you install Helm, you might as well use the Helm UI in =helm-mode= rather than Icomplete.)&lt;/p&gt; &#xA;&lt;p&gt;** Prescient&lt;/p&gt; &#xA;&lt;p&gt;The [[https://github.com/raxod502/prescient.el][prescient.el]] library also provides matching of space-separated components in any order and it can be used with either the [[https://github.com/raxod502/selectrum][Selectrum]] or [[https://github.com/abo-abo/swiper][Ivy]] completion UIs (it does not offer a completion-style that could be used with Emacs&#39; default completion UI, Mct, Vertico or with Icomplete). The components can be matched literally, as regexps, as initialisms or in the flex style (called &#34;fuzzy&#34; in prescient). In addition to matching, =prescient.el= also supports sorting of candidates (=orderless= leaves that up to the candidate source and the completion UI).&lt;/p&gt; &#xA;&lt;p&gt;** Restricting to current matches in Icicles, Ido and Ivy&lt;/p&gt; &#xA;&lt;p&gt;An effect equivalent to matching multiple components in any order can be achieved in completion frameworks that provide a way to restrict further matching to the current list of candidates. If you use the keybinding for restriction instead of =SPC= to separate your components, you get out of order matching!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[[https://www.emacswiki.org/emacs/Icicles][Icicles]] calls this /progressive completion/ and uses the =icicle-apropos-complete-and-narrow= command, bound to =S-SPC=, to do it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ido has =ido-restrict-to-matches= and binds it to =C-SPC=.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ivy has =ivy-restrict-to-matches=, bound to =S-SPC=, so you can get the effect of out of order matching without using =ivy--regex-ignore-order=.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>js-emacs/js2-refactor.el</title>
    <updated>2022-08-19T01:36:54Z</updated>
    <id>tag:github.com,2022-08-19:/js-emacs/js2-refactor.el</id>
    <link href="https://github.com/js-emacs/js2-refactor.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A JavaScript refactoring library for emacs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;js2-refactor.el &lt;a href=&#34;https://travis-ci.org/magnars/js2-refactor.el&#34;&gt;&lt;img src=&#34;https://travis-ci.org/magnars/js2-refactor.el.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;A JavaScript refactoring library for emacs.&lt;/p&gt; &#xA;&lt;p&gt;This is a collection of small refactoring functions to further the idea of a JavaScript IDE in Emacs that started with js2-mode.&lt;/p&gt; &#xA;&lt;h2&gt;Change in 0.8.0&lt;/h2&gt; &#xA;&lt;p&gt;Add &lt;code&gt;expand-node-at-point&lt;/code&gt; and &lt;code&gt;contract-node-at-point&lt;/code&gt; function to Expand / Contract bracketed list according to node type at point (array, object, function, call args).&lt;/p&gt; &#xA;&lt;p&gt;Removed previous &lt;code&gt;ea&lt;/code&gt; &lt;code&gt;ca&lt;/code&gt; &lt;code&gt;eo&lt;/code&gt; &lt;code&gt;co&lt;/code&gt; &lt;code&gt;eu&lt;/code&gt; &lt;code&gt;cu&lt;/code&gt; &lt;code&gt;ec&lt;/code&gt; &lt;code&gt;cc&lt;/code&gt; key bindings.&lt;/p&gt; &#xA;&lt;h2&gt;Breaking change in 0.7.0&lt;/h2&gt; &#xA;&lt;p&gt;js2-refactor.el is now a minor mode that has to be enabled, with something like the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(add-hook &#39;js2-mode-hook #&#39;js2-refactor-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Breaking change in 0.6.0&lt;/h2&gt; &#xA;&lt;p&gt;You now choose your own keybinding scheme. If you just want what you had before this change, add this to your init:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(js2r-add-keybindings-with-prefix &#34;C-c C-m&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;strong&gt;Setup keybindings&lt;/strong&gt; below for more.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;I highly recommend installing js2-refactor through elpa.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s available on &lt;a href=&#34;http://melpa.milkbox.net/&#34;&gt;melpa&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;M-x package-install js2-refactor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also install the dependencies on your own, and just dump js2-refactor in your path somewhere:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;js2-mode &lt;a href=&#34;https://github.com/mooz/js2-mode/&#34;&gt;https://github.com/mooz/js2-mode/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;dash &lt;a href=&#34;https://github.com/magnars/dash.el&#34;&gt;https://github.com/magnars/dash.el&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;s &lt;a href=&#34;https://github.com/magnars/s.el&#34;&gt;https://github.com/magnars/s.el&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;multiple-cursors &lt;a href=&#34;https://github.com/magnars/multiple-cursors.el&#34;&gt;https://github.com/magnars/multiple-cursors.el&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;yasnippet &lt;a href=&#34;https://github.com/capitaomorte/yasnippet&#34;&gt;https://github.com/capitaomorte/yasnippet&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I also recommend that you get &lt;a href=&#34;https://github.com/magnars/expand-region.el&#34;&gt;expand-region&lt;/a&gt; to more easily mark vars, method calls and functions for refactorings.&lt;/p&gt; &#xA;&lt;p&gt;Then add this to your emacs settings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require &#39;js2-refactor)&#xA;(add-hook &#39;js2-mode-hook #&#39;js2-refactor-mode)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;js2-refactor does not work in a buffer that has Javascript parse errors. To tell js2-mode to treat hashbangs as comments, which prevents them from causing parse errors, add this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setq js2-skip-preprocessor-directives t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Setup keybindings&lt;/h2&gt; &#xA;&lt;p&gt;All functions in js2-refactor have a two-letter mnemonic shortcut. For instance, extract-function is &lt;code&gt;ef&lt;/code&gt;. You get to choose how those are bound. Here&#39;s how:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(js2r-add-keybindings-with-prefix &#34;C-c C-m&#34;)&#xA;;; eg. extract function with `C-c C-m ef`.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you would rather have a modifier key, instead of a prefix, do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(js2r-add-keybindings-with-modifier &#34;C-s-&#34;)&#xA;;; eg. extract function with `C-s-e C-s-f`.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If neither of these appeal to your sense of keyboard layout aesthetics, feel free to pick and choose your own keybindings with a smattering of:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(define-key js2-refactor-mode-map (kbd &#34;C-c C-e C-f&#34;) &#39;js2r-extract-function)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, for an interactive list of available keybindings the following &lt;a href=&#34;https://gist.github.com/anachronic/7af88c62db136727cd1fed17ee0a662f&#34;&gt;hydra&lt;/a&gt; can be used as a starting point.&lt;/p&gt; &#xA;&lt;h2&gt;Refactorings&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ee&lt;/code&gt; is &lt;code&gt;expand-node-at-point&lt;/code&gt;: Expand bracketed list according to node type at point (array, object, function, call args).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cc&lt;/code&gt; is &lt;code&gt;contract-node-at-point&lt;/code&gt;: Contract bracketed list according to node type at point (array, object, function, call args).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ef&lt;/code&gt; is &lt;code&gt;extract-function&lt;/code&gt;: Extracts the marked expressions out into a new named function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;em&lt;/code&gt; is &lt;code&gt;extract-method&lt;/code&gt;: Extracts the marked expressions out into a new named method in an object literal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tf&lt;/code&gt; is &lt;code&gt;toggle-function-expression-and-declaration&lt;/code&gt;: Toggle between function name() {} and var name = function ();&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ta&lt;/code&gt; is &lt;code&gt;toggle-arrow-function-and-expression&lt;/code&gt;: Toggle between function expression to arrow function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ts&lt;/code&gt; is &lt;code&gt;toggle-function-async&lt;/code&gt;: Toggle between an async and a regular function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ip&lt;/code&gt; is &lt;code&gt;introduce-parameter&lt;/code&gt;: Changes the marked expression to a parameter in a local function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lp&lt;/code&gt; is &lt;code&gt;localize-parameter&lt;/code&gt;: Changes a parameter to a local var in a local function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;wi&lt;/code&gt; is &lt;code&gt;wrap-buffer-in-iife&lt;/code&gt;: Wraps the entire buffer in an immediately invoked function expression&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ig&lt;/code&gt; is &lt;code&gt;inject-global-in-iife&lt;/code&gt;: Creates a shortcut for a marked global by injecting it in the wrapping immediately invoked function expression&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ag&lt;/code&gt; is &lt;code&gt;add-to-globals-annotation&lt;/code&gt;: Creates a &lt;code&gt;/*global */&lt;/code&gt; annotation if it is missing, and adds the var at point to it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ev&lt;/code&gt; is &lt;code&gt;extract-var&lt;/code&gt;: Takes a marked expression and replaces it with a var.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;el&lt;/code&gt; is &lt;code&gt;extract-let&lt;/code&gt;: Similar to &lt;code&gt;extract-var&lt;/code&gt; but uses a &lt;code&gt;let&lt;/code&gt;-statement.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ec&lt;/code&gt; is &lt;code&gt;extract-const&lt;/code&gt;: Similar to &lt;code&gt;extract-var&lt;/code&gt; but uses a &lt;code&gt;const&lt;/code&gt;-statement.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;iv&lt;/code&gt; is &lt;code&gt;inline-var&lt;/code&gt;: Replaces all instances of a variable with its initial value.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;rename-var&lt;/code&gt;: Renames the variable on point and all occurrences in its lexical scope.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;vt&lt;/code&gt; is &lt;code&gt;var-to-this&lt;/code&gt;: Changes local &lt;code&gt;var a&lt;/code&gt; to be &lt;code&gt;this.a&lt;/code&gt; instead.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ao&lt;/code&gt; is &lt;code&gt;arguments-to-object&lt;/code&gt;: Replaces arguments to a function call with an object literal of named arguments.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;3i&lt;/code&gt; is &lt;code&gt;ternary-to-if&lt;/code&gt;: Converts ternary operator to if-statement.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sv&lt;/code&gt; is &lt;code&gt;split-var-declaration&lt;/code&gt;: Splits a &lt;code&gt;var&lt;/code&gt; with multiple vars declared, into several &lt;code&gt;var&lt;/code&gt; statements.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss&lt;/code&gt; is &lt;code&gt;split-string&lt;/code&gt;: Splits a &lt;code&gt;string&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;st&lt;/code&gt; is &lt;code&gt;string-to-template&lt;/code&gt;: Converts a &lt;code&gt;string&lt;/code&gt; into a template string.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;uw&lt;/code&gt; is &lt;code&gt;unwrap&lt;/code&gt;: Replaces the parent statement with the selected region.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lt&lt;/code&gt; is &lt;code&gt;log-this&lt;/code&gt;: Adds a console.log() statement for what is at point (or region). With a prefix argument, use JSON pretty-printing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dt&lt;/code&gt; is &lt;code&gt;debug-this&lt;/code&gt;: Adds a debug() statement for what is at point (or region).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sl&lt;/code&gt; is &lt;code&gt;forward-slurp&lt;/code&gt;: Moves the next statement into current function, if-statement, for-loop or while-loop.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ba&lt;/code&gt; is &lt;code&gt;forward-barf&lt;/code&gt;: Moves the last child out of current function, if-statement, for-loop or while-loop.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;k&lt;/code&gt; is &lt;code&gt;kill&lt;/code&gt;: Kills to the end of the line, but does not cross semantic boundaries.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are also some minor conveniences bundled:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;C-S-down&lt;/code&gt; and &lt;code&gt;C-S-up&lt;/code&gt; moves the current line up or down. If the line is an element in an object or array literal, it makes sure that the commas are still correctly placed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Todo&lt;/h2&gt; &#xA;&lt;p&gt;A list of some wanted improvements for the current refactorings.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;del&gt;expand- and contract-array: should work recursively with nested object literals and nested arrays.&lt;/del&gt; Now the &lt;code&gt;expand-node-at-point&lt;/code&gt; and &lt;code&gt;contract-node-at-point&lt;/code&gt; should work, by moving point into right place.&lt;/li&gt; &#xA; &lt;li&gt;expand- and contract-function: should deal better with nested object literals, array declarations, and statements terminated only by EOLs (without semicolons).&lt;/li&gt; &#xA; &lt;li&gt;wrap-buffer-in-iife: should skip comments and namespace initializations at buffer start.&lt;/li&gt; &#xA; &lt;li&gt;extract-variable: could end with a query-replace of the expression in its scope.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/NicolasPetton&#34;&gt;Nicolas Petton&lt;/a&gt; contributed lots of stuff and is now a co-maintainer of the project.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nbfalcon&#34;&gt;Nikita Bloshchanevich&lt;/a&gt; is now a co-maintainer of the project.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mbriggs&#34;&gt;Matt Briggs&lt;/a&gt; contributed &lt;code&gt;js2r-add-to-globals-annotation&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apchamberlain&#34;&gt;Alex Chamberlain&lt;/a&gt; contributed contracting and expanding arrays and functions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/brianloveswords&#34;&gt;Brian J Brennan&lt;/a&gt; added support for &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; to inline-var.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/futurist&#34;&gt;James Yang&lt;/a&gt; added &lt;code&gt;expand-node-at-point&lt;/code&gt; and &lt;code&gt;contract-node-at-point&lt;/code&gt; functions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/arnemart&#34;&gt;Arne Martin Aurlien&lt;/a&gt; added more support for &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Thanks!&lt;/p&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;This project is still in its infancy, and everything isn&#39;t quite sorted out yet. If you&#39;re eager to contribute, please add an issue here on github and we can discuss your changes a little before diving into the elisp. :-)&lt;/p&gt; &#xA;&lt;p&gt;To fetch the test dependencies, install &lt;a href=&#34;https://github.com/rejeep/cask.el&#34;&gt;cask&lt;/a&gt; if you haven&#39;t already, then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd /path/to/js2-refactor.el&#xA;$ cask&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the tests with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./run-tests.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (C) 2012-2014 Magnar Sveen&lt;/p&gt; &#xA;&lt;p&gt;Copyright (C) 2015-2016 Magnar Sveen and Nicolas Petton&lt;/p&gt; &#xA;&lt;p&gt;Author: Magnar Sveen &lt;a href=&#34;mailto:magnars@gmail.com&#34;&gt;magnars@gmail.com&lt;/a&gt;, Nicolas Petton &lt;a href=&#34;mailto:nicolas@petton.fr&#34;&gt;nicolas@petton.fr&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Keywords: javascript refactorings&lt;/p&gt; &#xA;&lt;p&gt;This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;You should have received a copy of the GNU General Public License along with this program. If not, see &lt;a href=&#34;http://www.gnu.org/licenses/&#34;&gt;http://www.gnu.org/licenses/&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>alezost/bui.el</title>
    <updated>2022-08-19T01:36:54Z</updated>
    <id>tag:github.com,2022-08-19:/alezost/bui.el</id>
    <link href="https://github.com/alezost/bui.el" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Buffer interface library for Emacs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;[[http://www.gnu.org/licenses/gpl-3.0.txt][file:https://img.shields.io/badge/license-GPL_3-orange.svg]] [[http://melpa.org/#/bui][file:http://melpa.org/packages/bui-badge.svg]] [[http://stable.melpa.org/#/bui][file:http://stable.melpa.org/packages/bui-badge.svg]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;About&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=BUI= (=Buffer User Interface=) is an Emacs library that can be used to make user interfaces to display some kind of entries (like packages, buffers, functions, etc.).&lt;/p&gt; &#xA;&lt;p&gt;The intention of BUI is to be a high-level library which is convenient to be used both by:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;package makers&lt;/em&gt;, as there is no need to bother about implementing routine details and usual features (like buffer history, filtering displayed entries, etc.);&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;users&lt;/em&gt;, as it provides familiar and intuitive interfaces with usual keys (for moving by lines, marking, sorting, switching between buttons); and what is also important, the defined interfaces are highly configurable through various generated variables. A summary of available key bindings can be displayed by pressing =h=.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;BUI provides means to display entries in 2 types of buffers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;=list=: it is based on =tabulated-list-mode=, thus it looks similar to a list of Emacs packages (=M-x list-packages=);&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;=info=: it can be used to display more verbose info, like various buttons, text and other stuff related to the displayed entry (or entries).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In short, you define how a =list= / =info= interface looks like (using =bui-define-interface= macro), and then you can make some user commands that will display entries (using =bui-get-display-entries= and similar functions).&lt;/p&gt; &#xA;&lt;p&gt;For example, you can make a =list= interface to display buffers (similar to what =M-x list-buffers= do), like this:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC emacs-lisp (require &#39;bui)&lt;/p&gt; &#xA;&lt;p&gt;(defun buffers-buffer-&amp;gt;entry (buffer) (with-current-buffer buffer `((id . ,buffer) (name . ,(buffer-name)) (mode . ,major-mode) (size . ,(buffer-size)) (file-name . ,buffer-file-name))))&lt;/p&gt; &#xA;&lt;p&gt;(defun buffers-get-entries () (mapcar &#39;buffers-buffer-&amp;gt;entry (buffer-list)))&lt;/p&gt; &#xA;&lt;p&gt;(bui-define-interface buffers list :buffer-name &#34;&lt;em&gt;Buffers&lt;/em&gt;&#34; :get-entries-function &#39;buffers-get-entries :format &#39;((name nil 30 t) (mode nil 25 t) (size nil 8 bui-list-sort-numerically-2 :right-align t) (file-name bui-list-get-file-name 30 t)) :sort-key &#39;(name))&lt;/p&gt; &#xA;&lt;p&gt;(defun buffers () &#34;Display a list of buffers.&#34; (interactive) (bui-get-display-entries &#39;buffers &#39;list)) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This is a simplified example just to demonstrate how =bui.el= can be used. For full example see [[file:examples/buffers.el]]. You can see how it looks like on the following screenshot. =M-x buffers= displays a list of buffers, then 2 buffers are marked (with =m= key) and &#34;described&#34; in =info= buffer (with =i= key).&lt;/p&gt; &#xA;&lt;p&gt;[[http://i.imgur.com/3dlBu2Y.png]]&lt;/p&gt; &#xA;&lt;p&gt;=bui-define-interface= macro takes the following arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;ENTRY-TYPE: an arbitrary symbol to denote the entry type.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;BUFFER-TYPE: =list= or =info= symbol.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Keyword arguments: used to define various interface parameters and to set default values of user variables (like titles, buffer name, etc.). The main keywords that should be specified are:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;=:get-entries-function=: this function should return a list of entries to display. Each entry is a usual association list with one required =id= key (it is used to fill =tabulated-list-entries= variable).&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;=:format=: it specifies how the data is displayed; see docstrings of the generated =ENTRY-TYPE-BUFFER-TYPE-format= variables for details (in the current example: =buffers-list-format= and =buffers-info-format=).&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For real-world examples you may look at [[https://github.com/alezost/aurel][aurel]] or [[https://github.com/alezost/guix.el][guix]] packages.&lt;/p&gt;</summary>
  </entry>
</feed>