<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Emacs Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-28T01:35:28Z</updated>
  <subtitle>Daily Trending of Emacs Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nex3/sass-mode</title>
    <updated>2022-09-28T01:35:28Z</updated>
    <id>tag:github.com,2022-09-28:/nex3/sass-mode</id>
    <link href="https://github.com/nex3/sass-mode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs mode for Sass&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>SWI-Prolog/packages-sweep</title>
    <updated>2022-09-28T01:35:28Z</updated>
    <id>tag:github.com,2022-09-28:/SWI-Prolog/packages-sweep</id>
    <link href="https://github.com/SWI-Prolog/packages-sweep" rel="alternate"></link>
    <summary type="html">&lt;p&gt;GNU-Emacs interface that embeds Prolog as an Emacs module&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: sweep: SWI-Prolog Embedded in Emacs #+author: Eshel Yaron #+email: &lt;a href=&#34;mailto:me@eshelyaron.com&#34;&gt;me@eshelyaron.com&lt;/a&gt; #+language: en #+options: &#39;:t toc:nil author:t email:t num:nil ^:{} #+startup: content indent #+export_file_name: sweep.texi #+texinfo_filename: sweep.info #+texinfo_dir_category: Emacs #+texinfo_dir_title: Sweep: (sweep) #+texinfo_dir_desc: SWI-Prolog Embedded in Emacs #+texinfo_header: @set MAINTAINERSITE @uref{&lt;a href=&#34;https://eshelyaron.com,maintainer&#34;&gt;https://eshelyaron.com,maintainer&lt;/a&gt; webpage} #+texinfo_header: @set MAINTAINER Eshel Yaron #+texinfo_header: @set MAINTAINEREMAIL @email{&lt;a href=&#34;mailto:me@eshelyaron.com&#34;&gt;me@eshelyaron.com&lt;/a&gt;} #+texinfo_header: @set MAINTAINERCONTACT @uref{mailto:&lt;a href=&#34;mailto:me@eshelyaron.com&#34;&gt;me@eshelyaron.com&lt;/a&gt;,contact the maintainer}&lt;/p&gt; &#xA;&lt;p&gt;This manual describes the Emacs package =sweep=, which provides an embedded SWI-Prolog runtime inside of Emacs.&lt;/p&gt; &#xA;&lt;p&gt;#+toc: headlines 8 insert TOC here, with eight headline levels&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Overview :PROPERTIES: :CUSTOM_ID: overview :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=sweep= is an embedding of SWI-Prolog in Emacs. It provides an interface for executing Prolog queries and consuming their results from Emacs Lisp (see [[Querying Prolog]]). =sweep= further builds on top of this interface and on top of the standard Emacs facilities to provide advanced features for developing SWI-Prolog programs in Emacs.&lt;/p&gt; &#xA;&lt;p&gt;** High-level architecture :PROPERTIES: :CUSTOM_ID: high-level-architecture :END:&lt;/p&gt; &#xA;&lt;p&gt;=sweep= uses the C interfaces of both SWI-Prolog and Emacs Lisp to create a dynamically loaded Emacs module that contains the SWI-Prolog runtime. As such, =sweep= has parts written in C, in Prolog and in Emacs Lisp.&lt;/p&gt; &#xA;&lt;p&gt;The different parts of =sweep= are structured as follows:&lt;/p&gt; &#xA;&lt;p&gt;#+CINDEX: sweep-module&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=sweep.c= defines a dynamic Emacs module which is referred to from Elisp as =sweep-module=. This module is linked against the SWI-Prolog runtime library (=libswipl=) and exposes a subset of the SWI-Prolog C interface to Emacs in the form of Elisp functions (see [[Querying Prolog]]). Notably, =sweep-module= is responsible for translating Elisp objects to Prolog terms and vice versa.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+CINDEX: sweep.el&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=sweep.el= defines an Elisp library (named simply =sweep=), which builds on top of =sweep-module= to provide user-facing commands and functionality. It is also responsible for loading and compiling the dynamically loaded =sweep-module=.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+CINDEX: sweep.pl&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=sweep.pl= defines a Prolog module (named, unsurprisingly, =sweep=) which is by default arranged by =sweep.el= to be loaded when the embedded Prolog runtime is initialized. It contains predicates that =sweep.el= invoke through =sweep-module= to facilitate its different commands (see [[Finding Prolog code]]).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation :PROPERTIES: :CUSTOM_ID: installation :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The dynamic Emacs module =sweep-module= and the Prolog helper library =sweep.pl= are included in the latest SWI-Prolog distribution. For instructions on how to build and install SWI-Prolog, see [[https://www.swi-prolog.org/build/]].&lt;/p&gt; &#xA;&lt;p&gt;To start using =sweep= in Emacs:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone the =sweep= repository: #+begin_src sh git clone &lt;a href=&#34;https://git.sr.ht/~eshel/sweep&#34;&gt;https://git.sr.ht/~eshel/sweep&lt;/a&gt; #+end_src&lt;/p&gt; &lt;p&gt;Or:&lt;/p&gt; &lt;p&gt;#+begin_src sh git clone &lt;a href=&#34;https://github.com/SWI-Prolog/packages-sweep&#34;&gt;https://github.com/SWI-Prolog/packages-sweep&lt;/a&gt; sweep #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add =sweep= to Emacs&#39; =load-path=: #+begin_src emacs-lisp (add-to-list &#39;load-path &#34;/path/to/sweep&#34;) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Load =sweep= into Emacs: #+begin_src emacs-lisp (require &#39;sweep) #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Prolog initialization and cleanup :PROPERTIES: :CUSTOM_ID: prolog-init :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-initialize The embedded SWI-Prolog runtime must be initialized before it can start executing queries. In =sweep=, Prolog initialization is done via the C-implemented =sweep-initialize= Elisp function defined in =sweep-module=. =sweep-initialize= takes one or more arguments, which must all be strings, and initializes the embedded Prolog as if it were invoked externally in a command line with the given strings as command line arguments, where the first argument to =sweep-initialize= corresponds to =argv[0]=.&lt;/p&gt; &#xA;&lt;p&gt;#+VINDEX: sweep-init-args By default, =sweep.el= will initialize Prolog automatically when it is loaded into Emacs. The arguments used to initialize Prolog in that case are determined by the value of the user-option =sweep-init-args= which the user is free to extend with e.g.:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (add-to-list &#39;sweep-init-args &#34;--stack-limit=512m&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+VINDEX: sweep-init-on-load To inhibit =sweep= from initializing Prolog on load, set the user-option =sweep-init-on-load= to nil.&lt;/p&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-cleanup The embedded Prolog runtime can be reset using the =sweep-cleanup= function. This function cleans up the Prolog state and resources, afterwards =sweep-initialize= can be called to start Prolog anew.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Querying Prolog :PROPERTIES: :CUSTOM_ID: querying-prolog :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-open-query =sweep= provides the Elisp function =sweep-open-query= for invoking Prolog predicates. The invoked predicate must be of arity two and will be called in mode =p(+In, -Out)= i.e. the predicate should treat the first argument as input and expect a variable for the second argument which should be unified with some output. This restriction is placed in order to facilitate a natural calling convention between Elisp, a functional language, and Prolog, a logical one.&lt;/p&gt; &#xA;&lt;p&gt;The =sweep-open-query= function takes five arguments, the first three are strings which denote:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The name of the Prolog context module from which to execute the query,&lt;/li&gt; &#xA; &lt;li&gt;The name of the module in which the invoked predicate is defined, and&lt;/li&gt; &#xA; &lt;li&gt;The name of the predicate to call.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The fourth argument to =sweep-open-query= is converted into a Prolog term and used as the first argument of the predicate (see [[Conversion of Elisp objects to Prolog terms]]). The fifth argument is an optional &#34;reverse&#34; flag, when this flag is set to non-nil, the order of the arguments is reversed such that the predicate is called in mode =p(-Out, +In)= rather than =p(+In, -Out)=.&lt;/p&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-next-solution The function =sweep-next-solution= can be used to examine the results of a query. If the query succeeded, =sweep-next-solution= returns a cons cell whose =car= is either the symbol =!= when the success was deterministic or =t= otherwise, and the =cdr= is the current value of the second (output) Prolog argument converted to an Elisp object (see [[Conversion of Prolog terms to Elisp objects]]). If the query failed, =sweep-next-solution= returns nil.&lt;/p&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-cut-query #+FINDEX: sweep-close-query =sweep= only executes one Prolog query at a given time, thus queries opened with =sweep-open-query= need to be closed before other queries can be opened. When no more solutions are available for the current query (i.e. after =sweep-next-solution= returned nil), or when otherwise further solutions are not of interest, the query must be closed with either =sweep-cut-query= or =sweep-close-query=. Both of these functions close the current query, but =sweep-close-query= also destroys any Prolog bindings created by the query.&lt;/p&gt; &#xA;&lt;p&gt;** Conversion of Elisp objects to Prolog terms :PROPERTIES: :CUSTOM_ID: elisp-to-prolog :END:&lt;/p&gt; &#xA;&lt;p&gt;=sweep= converts Elisp objects into Prolog terms to allow the Elisp programmers to specify arguments for Prolog predicates invocations (see =sweep-open-query=). Seeing as some Elisp objects, like Elisp compiled functions, wouldn&#39;t be as useful for a passing to Prolog as others, =sweep= only converts Elisp objects of certain types to Prolog, namely we convert /trees of strings and numbers/:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Elisp strings are converted to equivalent Prolog strings.&lt;/li&gt; &#xA; &lt;li&gt;Elisp integers are converted to equivalent Prolog integers.&lt;/li&gt; &#xA; &lt;li&gt;Elisp floats are converted to equivalent Prolog floats.&lt;/li&gt; &#xA; &lt;li&gt;The Elisp nil object is converted to the Prolog empty list =[]=.&lt;/li&gt; &#xA; &lt;li&gt;Elisp cons cells are converted to Prolog lists whose head and tail are the Prolog representations of the =car= and the =cdr= of the cons.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Conversion of Prolog terms to Elisp objects :PROPERTIES: :CUSTOM_ID: prolog-to-elisp :END:&lt;/p&gt; &#xA;&lt;p&gt;=sweep= converts Prolog terms into Elisp object to allow efficient processing of Prolog query results in Elisp (see =sweep-next-solution=).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Prolog strings are converted to equivalent Elisp strings.&lt;/li&gt; &#xA; &lt;li&gt;Prolog integers are converted to equivalent Elisp integers.&lt;/li&gt; &#xA; &lt;li&gt;Prolog floats are converted to equivalent Elisp floats.&lt;/li&gt; &#xA; &lt;li&gt;A Prolog atom =foo= is converted to a cons cell =(atom . &#34;foo&#34;)=.&lt;/li&gt; &#xA; &lt;li&gt;The Prolog empty list =[]= is converted to the Elisp nil object.&lt;/li&gt; &#xA; &lt;li&gt;Prolog lists are converted to Elisp cons cells whose =car= and =cdr= are the representations of the head and the tail of the list.&lt;/li&gt; &#xA; &lt;li&gt;Prolog compounds are converted to list whose first element is the symbol =compound=. The second element is a string denoting the functor name of the compound, and the rest of the elements are the arguments of the compound in their Elisp representation.&lt;/li&gt; &#xA; &lt;li&gt;All other Prolog terms (variables, blobs and dicts) are currently represented in Elisp only by their type: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Prolog variables are converted to the symbol =variable=,&lt;/li&gt; &#xA;   &lt;li&gt;Prolog blobs are converted to the symbol =blob=, and&lt;/li&gt; &#xA;   &lt;li&gt;Prolog dicts are converted to the symbol =dict=.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Example - counting solutions for a Prolog predicate in Elisp :PROPERTIES: :CUSTOM_ID: count-permutations :END:&lt;/p&gt; &#xA;&lt;p&gt;As an example of using the =sweep= interface for executing Prolog queries, we show an invocation of the non-deterministic predicate =lists:permutation/2= from Elisp where we count the number of different permutations of the list =(1 2 3 4 5)=:&lt;/p&gt; &#xA;&lt;p&gt;#+name: count-list-permutations #+begin_src emacs-lisp (sweep-open-query &#34;user&#34; &#34;lists&#34; &#34;permutation&#34; &#39;(1 2 3 4 5)) (let ((num 0) (sol (sweep-next-solution))) (while sol (setq num (1+ num)) (setq sol (sweep-next-solution))) (sweep-close-query) num) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Calling Elisp function inside Prolog queries :PROPERTIES: :CUSTOM_ID: funcall-from-prolog :END:&lt;/p&gt; &#xA;&lt;p&gt;The =sweep-module= defines the foreign Prolog predicates =sweep_funcall/2= and =sweep_funcall/3=, which allow for calling Elisp functions from Prolog code. These predicates may only be called in the context of a Prolog query initiated by =sweep-open-query=, i.e. only in the Prolog thread controlled by Emacs. The first argument to these predicates is a Prolog string holding the name of the Elisp function to call. The last argument to these predicates is unified with the return value of the Elisp function, represented as a Prolog term (see [[Conversion of Elisp objects to Prolog terms]]). The second argument of =sweep_funcall/3= is converted to an Elisp object (see [[Conversion of Prolog terms to Elisp objects]]) and passed as a sole argument to the invoked Elisp function. The =sweep_funcall/2= variant invokes the Elisp function without any arguments.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Editing Prolog code :PROPERTIES: :CUSTOM_ID: editing-prolog-code :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+CINDEX: sweep-mode #+FINDEX: sweep-mode #+VINDEX: sweep-mode =sweep= includes a dedicated major mode for reading and editing Prolog code, called =sweep-mode=. To activate this mode in a buffer, type =M-x sweep-mode=. To instruct Emacs to always open Prolog files in =sweep-mode=, modify the Emacs variable =auto-mode-alist= like so:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (add-to-list &#39;auto-mode-alist &#39;(&#34;\.pl\&#39;&#34; . sweep-mode)) (add-to-list &#39;auto-mode-alist &#39;(&#34;\.plt\&#39;&#34; . sweep-mode)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Indentation :PROPERTIES: :CUSTOM_ID: indentation :END:&lt;/p&gt; &#xA;&lt;p&gt;#+CINDEX: indentation&lt;/p&gt; &#xA;&lt;p&gt;In =sweep-mode= buffers, the appropriate indentation for each line is determined by a bespoke /indentation engine/. The indentation engine analyses the syntactic context of a given line and determines the appropriate indentation to apply based on a set of rules.&lt;/p&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-indent-line The entry point of the indentation engine is the function =sweep-indent-line= which takes no arguments and indents that line at point. =sweep-mode= supports the standard Emacs interface for indentation by arranging for =sweep-indent-line= to be called whenever a line should be indented, notably after pressing =TAB=. For more a full description of the available commands and options that pertain to indentation, see [[info:emacs#Indentation][Indentation in the Emacs manual]].&lt;/p&gt; &#xA;&lt;p&gt;*** Indentation rules :PROPERTIES: :CUSTOM_ID: indentation-rules :END:&lt;/p&gt; &#xA;&lt;p&gt;Lines in =sweep-mode= buffers are indented according to the following rules:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;If the current line starts inside a string or a multi-line comment, do not indent.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If the current line starts with a top term, do not indent.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If the current line starts with a closing parenthesis and the matching opening parenthesis is part of a functor, indent to the column of the opening parenthesis if any arguments appear on the same line as the functor, otherwise indent to the start of the functor.&lt;/p&gt; &lt;p&gt;This rule yields the following layouts:&lt;/p&gt; &lt;p&gt;#+begin_src prolog some_functor( some_arg ).&lt;/p&gt; &lt;p&gt;some_functor( some_arg ). #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;#+VINDEX: sweep-indent-offset 4. If the current line is the first non-comment line of a clause body, indent to the starting column of the head term plus the value of the user option =sweep-indent-offset= (by default, four extra columns).&lt;/p&gt; &#xA;&lt;p&gt;As an example, this rule yields the following layouts when =sweep-indent-offset= is set to the default value of four columns:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src prolog some_functor(arg1, arg2) :- body_term.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; asserta( some_functor(arg1, arg2) :-&#xA;              body_term&#xA;        ).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;If the current line starts with the right hand side operand of an infix operator, indent to the starting column of the first operand in the chain of infix operators of the same precedence.&lt;/p&gt; &lt;p&gt;This rule yields the following layouts:&lt;/p&gt; &lt;p&gt;#+begin_src prolog head :- body1, body2, body3, body4, body5.&lt;/p&gt; &lt;p&gt;A is 1 * 2 ^ 3 * 4 * 5.&lt;/p&gt; &lt;p&gt;A is 1 * 2 + 3 * 4 * 5. #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If the last non-comment line ends with a functor and its opening parenthesis, indent to the starting column of the functor plus =sweep-indent-offset=.&lt;/p&gt; &lt;p&gt;This rule yields the following layout:&lt;/p&gt; &lt;p&gt;#+begin_src prolog some_functor( arg1, ... #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If the last non-comment line ends with a prefix operator, indent to starting column of the operator plus =sweep-indent-offset=.&lt;/p&gt; &lt;p&gt;This rule yields the following layout:&lt;/p&gt; &lt;p&gt;#+begin_src prolog :- multifile predicate/3. #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;** Semantic highlighting :PROPERTIES: :CUSTOM_ID: semantic-highlighting :END:&lt;/p&gt; &#xA;&lt;p&gt;#+CINDEX: fontification =sweep-mode= integrates with the standard Emacs =font-lock= system which is used for highlighting text in buffers (see [[info:emacs#Font Lock][Font Lock in the Emacs manual]]). =sweep-mode= highlights different tokens in Prolog code according to their semantics, determined through static analysis which is performed on demand. When a buffer is first opened in =sweep-mode=, its entire contents are analyzed to collect and cache cross reference data, and the buffer is highlighted accordingly. In contrast, when editing and moving around the buffer, a faster, local analysis is invoked to updated the semantic highlighting in response to changes in the buffer.&lt;/p&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-colourise-buffer At any point in a =sweep-mode= buffer, the command =C-c C-c= (or =M-x sweep-colourise-buffer=) can be used to update the cross reference cache and highlight the buffer accordingly. This may be useful e.g. after defining a new predicate.&lt;/p&gt; &#xA;&lt;p&gt;#+VINDEX: sweep-colourise-buffer-on-idle #+VINDEX: sweep-colourise-buffer-max-size #+VINDEX: sweep-colourise-buffer-min-interval If the user option =sweep-colourise-buffer-on-idle= is set to non-nil (as it is by default), =sweep-mode= also updates semantic highlighting in the buffer whenever Emacs is idle for a reasonable amount of time, unless the buffer is larger than the value of the =sweep-colourise-buffer-max-size= user option ( 100,000 by default). The minimum idle time to wait before automatically updating semantic highlighting can be set via the user option =sweep-colourise-buffer-min-interval=.&lt;/p&gt; &#xA;&lt;p&gt;#+CINDEX: sweep-faces =sweep= defines more than 60 different faces (named sets of properties that determine the appearance of a specific text in Emacs buffers, see also [[info:emacs#Faces][Faces in the Emacs manual]]) to signify the specific semantics of each token in a Prolog code buffer. =sweep= comes with three /styles/:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The =default= style includes faces that mostly inherit from standard Emacs faces commonly used in programming modes.&lt;/li&gt; &#xA; &lt;li&gt;The =light= style mimics the colors used in the SWI-Prolog built-in editor.&lt;/li&gt; &#xA; &lt;li&gt;The =dark= style mimics the colors used in the SWI-Prolog built-in editor in dark mode.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+VINDEX: sweep-faces-style To choose a style, customize the user option =sweep-faces-style= with =M-x customize-option RET sweep-faces-style RET=. The new style will apply to all new =sweep-mode= buffers. To apply the new style to an existing buffer, use =C-x x f= (=font-lock-update=) in that buffer.&lt;/p&gt; &#xA;&lt;p&gt;To view and customize all of the faces defined and used in =sweep=, type =M-x customize-group RET sweep-faces RET=.&lt;/p&gt; &#xA;&lt;p&gt;** Term-based editing and motion commands :PROPERTIES: :CUSTOM_ID: term-based-commands :END:&lt;/p&gt; &#xA;&lt;p&gt;#+CINDEX: sexps Emacs includes many useful features for operating on syntactic units in source code buffer, such as marking, transposing and moving over expressions. By default, these features are geared towards working with Lisp expressions, or &#34;sexps&#34;. =sweep-mode= extends the Emacs&#39; notion of syntactic expressions to accommodate for Prolog terms, which allows the standard sexp-based commands to operate on them seamlessly.&lt;/p&gt; &#xA;&lt;p&gt;#+FINDEX: raise-sexp [[info:emacs#Expressions][Expressions in the Emacs manual]] covers the most important commands that operate on sexps, and by extension on Prolog terms. Another useful command for Prolog programmers is =M-x kill-backward-up-list=, bound by default to =C-M-^= in =sweep-mode= buffers. This command replaces the parent term containing the term at point with the term itself. To illustrate the utility of this command, consider the following clause:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src prolog head :- goal1, setup_call_cleanup(setup, goal2, cleanup). #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Now with point anywhere inside =goal2=, calling =kill-backward-up-list= removes the =setup_call_cleanup/3= term leaving =goal2= to be called directly:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src prolog head :- goal1, goal2. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Definitions and references :PROPERTIES: :CUSTOM_ID: sweep-xref :END:&lt;/p&gt; &#xA;&lt;p&gt;#+CINDEX: xref =sweep-mode= integrates with the Emacs =xref= API to facilitate quick access to predicate definitions and references in Prolog code buffers. This enables the many commands that the =xref= interface provides, like =M-.= for jumping to the definition of the predicate at point. Refer to [[info:emacs#Find Identifiers][Find Identifiers in the Emacs manual]] for an overview of the available commands.&lt;/p&gt; &#xA;&lt;p&gt;#+CINDEX: imenu =sweep-mode= also integrates with Emacs&#39; =imenu=, which provides a simple facility for looking up and jumping to definitions in the current buffer. To jump to a definition in the current buffer, type =M-x imenu= (bound by default to =M-g i= in Emacs version 29). For information about customizing =imenu=, see [[info:emacs#Imenu][Imenu in the Emacs manual]].&lt;/p&gt; &#xA;&lt;p&gt;** Following file specifications :PROPERTIES: :CUSTOM_ID: following-file-specs :END:&lt;/p&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-find-file-at-point File specifications that occur in =sweep-mode= buffers can be followed with =C-c C-o= (or =M-x sweep-find-file-at-point=) whenever point is over a valid file specification. For example, consider a Prolog file buffer with the common directive =use_module/1=:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src prolog :- use_module(library(lists)). #+end_src&lt;/p&gt; &#xA;&lt;p&gt;With point in any position inside =library(lists)=, typing =C-c C-o= will open the =lists.pl= file in the Prolog library.&lt;/p&gt; &#xA;&lt;p&gt;For more information about file specifications in SWI-Prolog, see [[https://www.swi-prolog.org/pldoc/doc_for?object=absolute_file_name/3][absolute_file_name/3]] in the SWI-Prolog manual.&lt;/p&gt; &#xA;&lt;p&gt;** Loading buffers :PROPERTIES: :CUSTOM_ID: loading-buffers :END:&lt;/p&gt; &#xA;&lt;p&gt;#+CINDEX: loading #+FINDEX: sweep-load-buffer The command =M-x sweep-load-buffer= can be used to load the contents of a =sweep-mode= buffer into the embedded SWI-Prolog runtime. After a buffer is loaded, the predicates it defines can be queried from Elisp (see [[Querying Prolog]]) and from the =sweep= top-level (see [[The Prolog top-level]]). In =sweep-mode= buffers, =sweep-load-buffer= is bound by default to =C-c C-l=. By default this command loads the current buffer if its major mode is =sweep-mode=, and prompts for an appropriate buffer otherwise. To choose a different buffer to load while visiting a =sweep-mode= buffer, invoke =sweep-load-buffer= with a prefix argument (=C-u C-c C-l=).&lt;/p&gt; &#xA;&lt;p&gt;More relevant information about loading code in SWI-Prolog can be found in [[https://www.swi-prolog.org/pldoc/man?section=consulting][Loading Prolog source files]] in the SWI-Prolog manual.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Prolog top-level :PROPERTIES: :CUSTOM_ID: prolog-top-level :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+CINDEX: top-level #+FINDEX: sweep-top-level =sweep= provides a classic Prolog top-level interface for interacting with the embedded Prolog runtime. To start the top-level, use =M-x sweep-top-level=. This command opens a buffer called =&lt;em&gt;sweep-top-level&lt;/em&gt;= which hosts the live Prolog top-level.&lt;/p&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-top-level-mode #+VINDEX: sweep-top-level-mode The top-level buffer uses a major mode named =sweep-top-level-mode=. This mode derives from =comint-mode=, which is the common mode used in Emacs REPL interfaces. As a result, the top-level buffer inherits the features present in other =comint-mode= derivatives, most of which are described in [[info:emacs#Shell Mode][the Emacs manual]].&lt;/p&gt; &#xA;&lt;p&gt;** Multiple top-levels :PROPERTIES: :CUSTOM_ID: multiple-top-levels :END:&lt;/p&gt; &#xA;&lt;p&gt;Any number of top-levels can be created and used concurrently, each in its own buffer. If a top-level buffer already exists, =sweep-top-level= will simply open it by default. To create another one or more top-level buffers, run =sweep-top-level= with a prefix argument (i.e. =C-u M-x sweep-top-level-mode=) to choose a different buffer name. Alternatively, run the command =C-x x u= (or =M-x rename-uniquely=) in the buffer called =&lt;em&gt;sweep-top-level&lt;/em&gt;= and then run =M-x sweep-top-level= again. This will change the name of the original top-level buffer to something like =&lt;em&gt;sweep-top-level&lt;/em&gt;&amp;lt;2&amp;gt;= and allow the new top-level to claim the buffer name =&lt;em&gt;sweep-top-level&lt;/em&gt;=.&lt;/p&gt; &#xA;&lt;p&gt;** Top-level history :PROPERTIES: :CUSTOM_ID: top-level-history :END:&lt;/p&gt; &#xA;&lt;p&gt;=sweep-top-level-mode= buffers provide a history of previously user inputs, similarly to other =comint-mode= derivatives such as =shell-mode=. To insert the last input from the history at the prompt, use =M-p= (=comint-previous-input=). For a full description of history related commands, see [[info:emacs#Shell History][Shell History in the Emacs manual]].&lt;/p&gt; &#xA;&lt;p&gt;#+VINDEX: sweep-top-level-min-history-length The =sweep= top-level history only records inputs whose length is at least =sweep-top-level-min-history-length=. This user option is set to 3 by default, and should generally be set to at least 2 to keep the history from being clobbered with single-character inputs, which are common in the top-level interaction, e.g. =;= as used to invoke backtracking.&lt;/p&gt; &#xA;&lt;p&gt;** Completion in the top-level :PROPERTIES: :CUSTOM_ID: completion-in-top-level :END:&lt;/p&gt; &#xA;&lt;p&gt;The =sweep-top-level-mode=, enabled in the =sweep= top-level buffer, integrates with the standard Emacs symbol completion mechanism to provide completion for predicate names. To complete a partial predicate name in the top-level prompt, use =C-M-i= (or =M-&#xA; &lt;tab&gt;&#xA;  =). For more information see [[info:emacs#Symbol Completion][Symbol Completion in the Emacs manual]].&#xA; &lt;/tab&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Finding Prolog code :PROPERTIES: :CUSTOM_ID: finding-prolog-code :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-find-module =sweep= provides the command =M-x sweep-find-module= for selecting and jumping to the source code of a loaded or auto-loadable Prolog module. =sweep= integrates with Emacs&#39; standard completion API to annotate candidate modules in the completion UI with their =PLDoc= description when available.&lt;/p&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-find-predicate Along with =M-x sweep-find-module=, =sweep= provides the command =M-x sweep-find-predicate= jumping to the definition a loaded or auto-loadable Prolog predicate.&lt;/p&gt; &#xA;&lt;p&gt;** Prolog file specification expansion :PROPERTIES: :CUSTOM_ID: file-spec-expansion :END:&lt;/p&gt; &#xA;&lt;p&gt;=sweep= defines a handler for the Emacs function =expand-file-file= that recognizes Prolog file specifications, such as =library(lists)=, and expands them to their corresponding absolute paths. This means that one can use Prolog file specifications with Emacs&#39; standard =find-file= (=C-x C-f=) to locate Prolog resources directly.&lt;/p&gt; &#xA;&lt;p&gt;For example, typing =C-x C-f library(pldoc/doc_man)= will open the source of the =pldoc_man= module from the Prolog library, and likewise =C-x C-f pack(.)= will open the Prolog packages directory.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Quick access to sweep commands :PROPERTIES: :CUSTOM_ID: quick-command-access :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+VINDEX: sweep-prefix-map =sweep= defines a keymap called =sweep-prefix-map= which provides keybinding for several useful =sweep= commands. By default, =sweep-prefix-map= itself is not bound to any key. To bind it globally to a prefix key, e.g. =C-c p=, use:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src emacs-lisp (keymap-global-set &#34;C-c p&#34; sweep-prefix-map) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;As an example, with the above binding the =sweep= top-level can be accessed from anywhere with =C-c p t=, which invokes the command =sweep-top-level=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Examining Prolog messages :PROPERTIES: :CUSTOM_ID: prolog-messages :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+CINDEX: messages #+VINDEX: sweep-messages-buffer-name Messages emitted by the embedded Prolog are redirected by =sweep= to a dedicated Emacs buffer. By default, the =sweep= messages buffer is named =&lt;em&gt;sweep Messages&lt;/em&gt;=. To instruct =sweep= to use another buffer name instead, type =M-x customize-option RET sweep-messages-buffer-name RET= and set the option to a suitable value.&lt;/p&gt; &#xA;&lt;p&gt;The =sweep= messages buffer uses the minor mode =compilation-minor-mode=, which allows for jumping to source locations indicated in errors and warning directly from the corresponding message in the =sweep= messages buffer. For more information about the features enabled by =compilation-minor-mode=, see [[info:emacs#Compilation Mode][Compilation Mode in the Emacs manual]].&lt;/p&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-view-messages =sweep= includes the command =sweep-view-messages= for quickly switching to the =sweep= messages buffer. This command is bound by default in =sweep-prefix-map= to the =e= key (see [[Quick access to sweep commands]]).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Setting Prolog flags :PROPERTIES: :CUSTOM_ID: prolog-flags :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+CINDEX: prolog flags #+FINDEX: sweep-set-prolog-flag The command =M-x sweep-set-prolog-flag= can be used to interactively configure the embedded Prolog execution environment by changing the values of Prolog flags. This command first prompts the user for a Prolog flag to set, with completion candidates annotated with their current values as Prolog flags, and then prompts for a string that will be read as a Prolog term and set as the value of the chosen flag. For more information on Prolog flags in SWI-Prolog see [[https://www.swi-prolog.org/pldoc/man?section=flags][Environment Control in the SWI-Prolog manual]].&lt;/p&gt; &#xA;&lt;p&gt;As an example, the Prolog flag =double_quotes= controls the interpretation of double quotes in Prolog code. By default, =double_quotes= is set to =string=, so e.g. =&#34;foo&#34;= is read as a SWI-Prolog string as we can easily validate in the =sweep= top-level:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src prolog ?- A = &#34;foo&#34;. A = &#34;foo&#34;. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;We can change the interpretation of double quotes to denote lists of character codes, by setting the value the =double_quotes= flag to =codes= with =M-x sweep-set-prolog-flag RET double_quotes RET codes RET=. Evaluating =A = &#34;foo&#34;= again exhibits the different interpretation:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src prolog ?- A = &#34;foo&#34;. A = [102, 111, 111]. #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installing Prolog packages :PROPERTIES: :CUSTOM_ID: prolog-packages :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+FINDEX: sweep-pack-install The command =M-x sweep-pack-install= can be used to install or upgrade a SWI-Prolog =pack=. When selecting a =pack= to install, the completion candidates are annotated with description and the version of each package.&lt;/p&gt; &#xA;&lt;p&gt;#+html: &amp;lt;!--&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Indices :PROPERTIES: :CUSTOM_ID: indices :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Function index :PROPERTIES: :INDEX: fn :CUSTOM_ID: findex :END:&lt;/p&gt; &#xA;&lt;p&gt;** Variable index :PROPERTIES: :INDEX: vr :CUSTOM_ID: vindex :END:&lt;/p&gt; &#xA;&lt;p&gt;** Concept index :PROPERTIES: :INDEX: cp :CUSTOM_ID: cindex :END:&lt;/p&gt; &#xA;&lt;p&gt;#+html: --&amp;gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>janv/dotfiles</title>
    <updated>2022-09-28T01:35:28Z</updated>
    <id>tag:github.com,2022-09-28:/janv/dotfiles</id>
    <link href="https://github.com/janv/dotfiles" rel="alternate"></link>
    <summary type="html">&lt;p&gt;emacs ftw&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Emacs Starter Kit&lt;/h1&gt; &#xA;&lt;p&gt;The Starter Kit should provide a saner set of defaults than you get normally with Emacs. It was originally intended for beginners, but it should provide a reasonable working environment for anyone using Emacs for dynamic languages. It also bundles a number of useful libraries that are not distributed with Emacs for various reasons.&lt;/p&gt; &#xA;&lt;p&gt;The latest version is at &lt;a href=&#34;http://github.com/technomancy/emacs-starter-kit/&#34;&gt;http://github.com/technomancy/emacs-starter-kit/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This version of the Starter Kit acts as a set of config files you drop into your home directory. Version 2 (the v2 branch) is a set of packages you can pull in using package.el instead now that it&#39;s been included in Emacs.&lt;/p&gt; &#xA;&lt;h2&gt;Learning&lt;/h2&gt; &#xA;&lt;p&gt;This won&#39;t teach you Emacs, but it&#39;ll make it easier to get comfortable. To access the tutorial, press control-h followed by t.&lt;/p&gt; &#xA;&lt;p&gt;You may also find the &lt;a href=&#34;http://peepcode.com/products/meet-emacs&#34;&gt;PeepCode Meet Emacs screencast&lt;/a&gt; helpful. The &lt;a href=&#34;http://emacswiki.org&#34;&gt;Emacs Wiki&lt;/a&gt; is also very handy.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install GNU Emacs (at least version 22, 23 is preferred) Use your package manager if you have one. Otherwise Mac users may get &lt;a href=&#34;http://emacsformacosx.com/&#34;&gt;some prebuilt binaries&lt;/a&gt;, and Windows users can get them &lt;a href=&#34;http://ftp.gnu.org/pub/gnu/emacs/windows/emacs-23.1-bin-i386.zip&#34;&gt;from GNU&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Move the directory containing this file to ~/.emacs.d (If you already have a directory at ~/.emacs.d move it out of the way and put this there instead.)&lt;/li&gt; &#xA; &lt;li&gt;Launch Emacs!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you find yourself missing some autoloads after an update (which should manifest itself as &#34;void function: foobar&#34; errors) try M-x regen-autoloads. After some updates an M-x recompile-init will be necessary; this should be noted in the commit messages.&lt;/p&gt; &#xA;&lt;p&gt;If you want to keep your regular ~/.emacs.d in place and just launch a single instance using the starter kit, try the following invocation:&lt;/p&gt; &#xA;&lt;p&gt;$ emacs -q -l ~/src/emacs-starter-kit/init.el&lt;/p&gt; &#xA;&lt;p&gt;Note that having a ~/.emacs file might override the starter kit loading, so if you&#39;ve having trouble loading it, make sure that file is not present.&lt;/p&gt; &#xA;&lt;h2&gt;Structure&lt;/h2&gt; &#xA;&lt;p&gt;The init.el file is where everything begins. It&#39;s the first file to get loaded. The starter-kit-* files provide what I consider to be better defaults, both for different programming languages and for built-in Emacs features like bindings or registers.&lt;/p&gt; &#xA;&lt;p&gt;Files that are pending submission to ELPA are bundled with the starter kit under the directory elpa-to-submit/. The understanding is that these are bundled just because nobody&#39;s gotten around to turning them into packages, and the bundling of them is temporary. For these libraries, autoloads will be generated and kept in the loaddefs.el file. This allows them to be loaded on demand rather than at startup.&lt;/p&gt; &#xA;&lt;p&gt;There are also a few files that are meant for code that doesn&#39;t belong in the Starter Kit. First, the user-specific-config file is the file named after your user with the extension &#34;.el&#34;. In addition, if a directory named after your user exists, it will be added to the load-path, and any elisp files in it will be loaded. Finally, the Starter Kit will look for a file named after the current hostname ending in &#34;.el&#34; which will allow host-specific configuration. This is where you should put code that you don&#39;t think would be useful to everyone. That will allow you to merge with newer versions of the starter-kit without conflicts.&lt;/p&gt; &#xA;&lt;h2&gt;Packages&lt;/h2&gt; &#xA;&lt;p&gt;Libraries from &lt;a href=&#34;http://marmalade-repo.org&#34;&gt;Marmalade&lt;/a&gt; installed via package.el are preferred when available since dependencies are handled automatically, and the burden to update them is removed from the user.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s no vendor/ directory in the starter kit because if an external library is useful enough to be bundled with the starter kit, it should be useful enough to submit to Marmalade so that everyone can use it, not just users of the starter kit.&lt;/p&gt; &#xA;&lt;h2&gt;Variants of Emacs&lt;/h2&gt; &#xA;&lt;p&gt;The Starter Kit is designed to work with GNU Emacs version 22 or greater. Using it with forks or other variants is not supported. It probably won&#39;t work with XEmacs, though some have reported getting it to work with Aquamacs. However, since Aquamacs is not portable, it&#39;s difficult to test in it, and breakage is common.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you know your way around Emacs, please try out the starter kit as a replacement for your regular dotfiles for a while. If there&#39;s anything you just can&#39;t live without, add it or let me know so I can add it. Take a look at what happens in init.el to get started.&lt;/p&gt; &#xA;&lt;p&gt;Also: see the file TODO. Helping submit new libraries to Marmalade is the easiest way to help out. There are two ways you can do this: either take new libraries and make them ready for Marmalade, dropping them in the elpa-to-submit directory or take files that are already in elpa-to-submit, ensuring all their dependencies are correctly loaded into Marmalade, and uploading them. Grep the project for TODO for other things.&lt;/p&gt; &#xA;&lt;p&gt;Files are licensed under the same license as Emacs unless otherwise specified. See the file COPYING for details.&lt;/p&gt; &#xA;&lt;p&gt;The latest version is at &lt;a href=&#34;http://github.com/technomancy/emacs-starter-kit/&#34;&gt;http://github.com/technomancy/emacs-starter-kit/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;On Unix, /home/$USER/.emacs.d, on windows Documents and Settings/%your user name%/Application Data&lt;/p&gt;</summary>
  </entry>
</feed>