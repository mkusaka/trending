<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-05-31T01:39:20Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Tarmil/FSharp.Data.LiteralProviders</title>
    <updated>2022-05-31T01:39:20Z</updated>
    <id>tag:github.com,2022-05-31:/Tarmil/FSharp.Data.LiteralProviders</id>
    <link href="https://github.com/Tarmil/FSharp.Data.LiteralProviders" rel="alternate"></link>
    <summary type="html">&lt;p&gt;F# Type providers generating literals from the compile-time environment&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;FSharp.Data.LiteralProviders&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Tarmil/FSharp.Data.LiteralProviders/actions?query=workflow%3ABuild+branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/Tarmil/FSharp.Data.LiteralProviders/workflows/Build/badge.svg?branch=master&#34; alt=&#34;Build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://nuget.org/packages/FSharp.Data.LiteralProviders&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/FSharp.Data.LiteralProviders?logo=nuget&#34; alt=&#34;Nuget&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is a collection of type providers that provide literals: compile-time constants that can be used in regular code, but also as parameters to other type providers or .NET attributes.&lt;/p&gt; &#xA;&lt;!-- doctoc --github --notitle README.md --&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#reference&#34;&gt;Reference&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#env&#34;&gt;Env&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#textfile&#34;&gt;TextFile&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#exec&#34;&gt;Exec&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#conditionals&#34;&gt;Conditionals&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#equality&#34;&gt;Equality&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#comparison&#34;&gt;Comparison&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#boolean-operations&#34;&gt;Boolean operations&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#if&#34;&gt;If&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#builddate&#34;&gt;BuildDate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#parsed-value&#34;&gt;Parsed value&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#tips-for-combining-type-providers&#34;&gt;Tips for combining type providers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#packaging&#34;&gt;Packaging&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#using-nuget&#34;&gt;Using NuGet&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Tarmil/FSharp.Data.LiteralProviders/master/#using-paket&#34;&gt;Using Paket&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;h3&gt;Env&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FSharp.Data.LiteralProviders.Env&lt;/code&gt; contains literals for environment variables during compile time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;/// The compile-time value of the &#34;OS&#34; environment variable&#xA;let compileOS = Env.OS.Value&#xA;&#xA;match compileOS with&#xA;| &#34;Windows_NT&#34; -&amp;gt; printfn &#34;This program was compiled on Windows!&#34;&#xA;| &#34;Unix&#34; -&amp;gt; printfn &#34;This program was compiled on OSX or Linux!&#34;&#xA;| _ -&amp;gt; printfn &#34;I don&#39;t know the platform this program was compiled on :(&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is a more useful example, using it as a parameter to another type provider (namely, &lt;a href=&#34;http://fsprojects.github.io/SQLProvider/&#34;&gt;SQLProvider&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.Sql&#xA;open FSharp.Data.LiteralProviders&#xA;&#xA;type Sql = SqlProvider&amp;lt;Common.DatabaseProviderTypes.MSSQLSERVER,&#xA;                       Env.CONNECTION_STRING.Value&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that when called this way, &lt;code&gt;Env&lt;/code&gt; fails to compile if the environment variable is not set.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, the environment variable&#39;s name can be passed as a string parameter. In this case, &lt;code&gt;Env&lt;/code&gt; returns the empty string if the variable is not set.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;let vsVersion = Env&amp;lt;&#34;VisualStudioEdition&#34;&amp;gt;.Value&#xA;&#xA;match vsVersion with&#xA;| &#34;&#34; -&amp;gt; printfn &#34;This program wasn&#39;t compiled with Visual Studio.&#34;&#xA;| v -&amp;gt; printfn &#34;This program was built with Visual Studio %s.&#34; v&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When used with a parameter, &lt;code&gt;Env&lt;/code&gt; also provides a value &lt;code&gt;IsSet : bool&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Additional parameters can be passed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;DefaultValue : string&lt;/code&gt; will be used as the value if the environment variable isn&#39;t set, instead of the empty string.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.Sql&#xA;open FSharp.Data.LiteralProviders&#xA;&#xA;let [&amp;lt;Literal&amp;gt;] connString =&#xA;    Env&amp;lt;&#34;CONNECTION_STRING&#34;, &#34;Server=localhost;Integrated Security=true&#34;&amp;gt;.Value&#xA;&#xA;type Sql = SqlProvider&amp;lt;Common.DatabaseProviderTypes.MSSQLSERVER, connString&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EnsureExists : bool&lt;/code&gt; specifies the behavior when the environment variable isn&#39;t set.&lt;/p&gt; &lt;p&gt;If false (the default), then &lt;code&gt;Value&lt;/code&gt; is an empty string (or &lt;code&gt;DefaultValue&lt;/code&gt; if provided).&lt;/p&gt; &lt;p&gt;If true, then the type provider raises a compile-time error.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;/// Throws a compile-time error &#34;Environment variable does not exist: CONNECTION_STRING&#34;.&#xA;let [&amp;lt;Literal&amp;gt;] connString = Env&amp;lt;&#34;CONNECTION_STRING&#34;, EnsureExists = true&amp;gt;.Text&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;TextFile&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FSharp.Data.LiteralProviders.TextFile&lt;/code&gt; contains literals that are read from text files during compilation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;/// The compile-time contents of the file &amp;lt;projectFolder&amp;gt;/build/version.txt&#xA;let [&amp;lt;Literal&amp;gt;] version = TextFile.build.``version.txt``.Text&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, the file path can be passed as a string parameter. In this case, &lt;code&gt;TextFile&lt;/code&gt; returns the empty string if the file doesn&#39;t exist.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;/// The compile-time contents of the file &amp;lt;projectFolder&amp;gt;/build/version.txt&#xA;/// or &#34;&#34; if this file doesn&#39;t exist.&#xA;let [&amp;lt;Literal&amp;gt;] version = TextFile&amp;lt;&#34;build/version.txt&#34;&amp;gt;.Text&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additional parameters can be passed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;DefaultValue : string&lt;/code&gt; will be used as the value if the file doesn&#39;t exist, instead of the empty string.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;/// The compile-time contents of the file &amp;lt;projectFolder&amp;gt;/build/version.txt&#xA;/// or &#34;1.0&#34; if this file doesn&#39;t exist.&#xA;let [&amp;lt;Literal&amp;gt;] version = TextFile&amp;lt;&#34;build/version.txt&#34;, DefaultValue = &#34;1.0&#34;&amp;gt;.Text&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Encoding : string&lt;/code&gt; specifies the text encoding.&lt;/p&gt; &lt;p&gt;The possible values are &lt;code&gt;UTF-8&lt;/code&gt;, &lt;code&gt;UTF-16-le&lt;/code&gt;, &lt;code&gt;UTF-16-be&lt;/code&gt;, &lt;code&gt;UTF-32-le&lt;/code&gt; and &lt;code&gt;UTF-32-be&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;When not specified, &lt;code&gt;TextFile&lt;/code&gt; tries to guess the encoding.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;let [&amp;lt;Literal&amp;gt;] script = TextFile&amp;lt;&#34;LoadData.sql&#34;, Encoding = &#34;UTF-16-le&#34;&amp;gt;.Text&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Note: regardless of the encoding, if the file starts with a byte order mark, then the BOM is stripped from the string.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EnsureExists : bool&lt;/code&gt; specifies the behavior when the file doesn&#39;t exist.&lt;/p&gt; &lt;p&gt;If false (the default), then the &lt;code&gt;Text&lt;/code&gt; value is an empty string (or &lt;code&gt;DefaultValue&lt;/code&gt; if provided).&lt;/p&gt; &lt;p&gt;If true, then the type provider raises a compile-time error.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;/// Throws a compile-time error &#34;File does not exist: fileThatDoesntExist.txt&#34;.&#xA;let [&amp;lt;Literal&amp;gt;] test = TextFile&amp;lt;&#34;fileThatDoesntExist.txt&#34;, EnsureExists = true&amp;gt;.Text&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Exec&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FSharp.Data.LiteralProviders.Exec&lt;/code&gt; executes an external program during compilation and captures its output.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;let [&amp;lt;Literal&amp;gt;] currentBranch = Exec&amp;lt;&#34;git&#34;, &#34;branch --show-current&#34;&amp;gt;.Output&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additional parameters can be passed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Input: string&lt;/code&gt;: text that is passed to the program&#39;s standard output.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Directory: string&lt;/code&gt;: the working directory. The default is the project directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EnsureSuccess: bool&lt;/code&gt;: if true, the provider ensures that the program exits successfully, and fails otherwise.&lt;br&gt; If false, no error is raised.&lt;br&gt; The default is true.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Timeout: int&lt;/code&gt;: timeout in milliseconds. Raise an error if the program takes longer to finish.&lt;br&gt; The default is 10_000 (10 seconds).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following values are provided:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Output: string&lt;/code&gt;: the program&#39;s standard output.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Error: string&lt;/code&gt;: the program&#39;s standard error.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ExitCode: int&lt;/code&gt;: the program&#39;s exit code. Only useful with &lt;code&gt;EnsureSuccess = false&lt;/code&gt;, otherwise always 0.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Conditionals&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FSharp.Data.LiteralProviders&lt;/code&gt; contains sub-namespaces &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Bool&lt;/code&gt; for conditional operations on these types.&lt;/p&gt; &#xA;&lt;h4&gt;Equality&lt;/h4&gt; &#xA;&lt;p&gt;The providers &lt;code&gt;EQ&lt;/code&gt; and &lt;code&gt;NE&lt;/code&gt; contain &lt;code&gt;Value: bool&lt;/code&gt; that checks whether the two parameters are equal / not equal, respectively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;let [&amp;lt;Literal&amp;gt;] branch = Exec&amp;lt;&#34;git&#34;, &#34;branch --show-current&#34;&amp;gt;.Output&#xA;&#xA;let [&amp;lt;Literal&amp;gt;] isMaster = String.EQ&amp;lt;branch, &#34;master&#34;&amp;gt;.Value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Comparison&lt;/h4&gt; &#xA;&lt;p&gt;In sub-namespace &lt;code&gt;Int&lt;/code&gt;, the providers &lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;LE&lt;/code&gt;, &lt;code&gt;GT&lt;/code&gt; and &lt;code&gt;GE&lt;/code&gt; contain &lt;code&gt;Value: bool&lt;/code&gt; that checks whether the first parameter is less than / less than or equal / greater than / greater than or equal to the second parameter, respectively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;let [&amp;lt;Literal&amp;gt;] gitStatusCode = Exec&amp;lt;&#34;git&#34;, &#34;status&#34;, EnsureSuccess = false&amp;gt;.ExitCode&#xA;&#xA;let [&amp;lt;Literal&amp;gt;] notInGitRepo = Int.GT&amp;lt;gitStatusCode, 0&amp;gt;.Value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Boolean operations&lt;/h4&gt; &#xA;&lt;p&gt;In sub-namespace &lt;code&gt;Bool&lt;/code&gt;, the providers &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, &lt;code&gt;XOR&lt;/code&gt; and &lt;code&gt;NOT&lt;/code&gt; contain &lt;code&gt;Value: bool&lt;/code&gt; that performs the corresponding boolean operation on its parameter(s).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;type GithubAction = Env&amp;lt;&#34;GITHUB_ACTION&#34;&amp;gt;&#xA;&#xA;let [&amp;lt;Literal&amp;gt;] isLocalBuild = Bool.NOT&amp;lt;GithubAction.IsSet&amp;gt;.Value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;If&lt;/h4&gt; &#xA;&lt;p&gt;The provider &lt;code&gt;IF&lt;/code&gt; takes a condition and two values as parameters. It returns the first value if the condition is true, and the second value if the condition is false.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;let [&amp;lt;Literal&amp;gt;] versionSuffix = String.IF&amp;lt;isMaster, &#34;&#34;, &#34;-pre&#34;&amp;gt;.Value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that even though only one value is returned, both are evaluated. So if one branch fails, even though the other one is returned, the whole provider will fail.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;let [&amp;lt;Literal&amp;gt;] isCI = Env&amp;lt;&#34;CI&#34;, &#34;false&#34;&amp;gt;.ValueAsBool&#xA;&#xA;// The following will fail, because when CI is false, GITHUB_REF_NAME is not defined.&#xA;let [&amp;lt;Literal&amp;gt;] badRef =&#xA;    String.IF&amp;lt;isCI,&#xA;        Env.GITHUB_REF_NAME.Value,&#xA;        const Exec&amp;lt;&#34;git&#34;, &#34;branch --current&#34;&amp;gt;.Value&amp;gt;.Value&#xA;&#xA;// Instead, make sure to use a version that never fails.&#xA;// Here, Env returns an empty string if GITHUB_REF_NAME is not defined.&#xA;let [&amp;lt;Literal&amp;gt;] goodRef =&#xA;    String.IF&amp;lt;isCI,&#xA;        Env&amp;lt;&#34;GITHUB_REF_NAME&#34;&amp;gt;.Value,&#xA;        const Exec&amp;lt;&#34;git&#34;, &#34;branch --current&#34;&amp;gt;.Value&amp;gt;.Value&#xA;&#xA;// Even better, avoid using IF if you can achieve the same result with default values.&#xA;// For example, here, no need to check the CI variable:&#xA;// GITHUB_REF_NAME is set iff compiling on Github Actions anyway.&#xA;// So you can directly use GITHUB_REF_NAME, with `git branch` as default value.&#xA;let [&amp;lt;Literal&amp;gt;] betterRef =&#xA;    Env&amp;lt;&#34;GITHUB_REF_NAME&#34;, const Exec&amp;lt;&#34;git&#34;, &#34;branch --current&#34;&amp;gt;.Value&amp;gt;.Value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;BuildDate&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;FSharp.Data.LiteralProviders.BuildDate&lt;/code&gt; contains the build time as a literal string in ISO-8601 format (&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#Roundtrip&#34;&gt;&#34;o&#34; format&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;let utcBuildDate = BuildDate.Utc      // &#34;2019-08-24T19:45:03.2279236Z&#34;&#xA;let localBuildDate = BuildDate.Local  // &#34;2019-08-24T21:45:03.2279236+02:00&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can be optionally parameterized by a &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings&#34;&gt;date format&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;let buildTime = BuildDate&amp;lt;&#34;hh:mm:ss&#34;&amp;gt;.Utc  // &#34;21:45:03&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parsed value&lt;/h3&gt; &#xA;&lt;p&gt;The providers try to parse string values as integer and as boolean. If any of these succeed, a value suffixed with &lt;code&gt;AsInt&lt;/code&gt; or &lt;code&gt;AsBool&lt;/code&gt; is provided.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FSharp.Data.LiteralProviders&#xA;&#xA;let runNumber = Env&amp;lt;&#34;GITHUB_RUN_NUMBER&#34;&amp;gt;.Value // eg. &#34;42&#34;&#xA;&#xA;let runNumber = Env&amp;lt;&#34;GITHUB_RUN_NUMBER&#34;&amp;gt;.ValueAsInt // eg. 42&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following values are parsed this way:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Env.Value&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TextFile.Text&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Exec.Output&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Exec.Error&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tips for combining type providers&lt;/h2&gt; &#xA;&lt;p&gt;One of the main use cases for FSharp.Data.LiteralProviders is to provide a literal to pass to another type provider. There are several ways to do so:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Declare each TP with a type alias:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type ConnectionString = Env&amp;lt;&#34;CONNECTION_STRING&#34;&amp;gt;&#xA;&#xA;type Sql = SqlProvider&amp;lt;Common.DatabaseProviderTypes.MSSQLSERVER, ConnectionString.Value&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Declare a TP&#39;s value as Literal then pass it to another TP:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let [&amp;lt;Literal&amp;gt;] ConnectionString = Env&amp;lt;&#34;CONNECTION_STRING&#34;&amp;gt;.Value&#xA;&#xA;type Sql = SqlProvider&amp;lt;Common.DatabaseProviderTypes.MSSQLSERVER, ConnectionString&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To use a TP entirely inside a parameter of another TP, prefix it with the keyword &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Sql = SqlProvider&amp;lt;Common.DatabaseProviderTypes.MSSQLSERVER,&#xA;                       const Env&amp;lt;&#34;CONNECTION_STRING&#34;&amp;gt;.Value&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Packaging&lt;/h2&gt; &#xA;&lt;p&gt;FSharp.Data.LiteralProviders is a compile-time only package: all of its provided values are baked into the compiled assembly. This means that if you are writing a library that uses FSharp.Data.LiteralProviders, your downstream users don&#39;t need to depend on it.&lt;/p&gt; &#xA;&lt;p&gt;Here is how to exclude FSharp.Data.LiteralProviders from your NuGet dependencies.&lt;/p&gt; &#xA;&lt;h3&gt;Using NuGet&lt;/h3&gt; &#xA;&lt;p&gt;If you are using &lt;code&gt;dotnet&lt;/code&gt;&#39;s built-in package management, then in your project file, replace the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;PackageReference Include=&#34;FSharp.Data.LiteralProviders&#34; Version=&#34;...&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;PackageReference Include=&#34;FSharp.Data.LiteralProviders&#34; Version=&#34;...&#34;&amp;gt;&#xA;    &amp;lt;PrivateAssets&amp;gt;All&amp;lt;/PrivateAssets&amp;gt;&#xA;&amp;lt;/PackageReference&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using Paket&lt;/h3&gt; &#xA;&lt;p&gt;If you are packaging your library with &lt;code&gt;paket pack&lt;/code&gt;, add the following to your &lt;code&gt;paket.template&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;excludeddependencies&#xA;    FSharp.Data.LiteralProviders&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>microsoft/Quantum-NC</title>
    <updated>2022-05-31T01:39:20Z</updated>
    <id>tag:github.com,2022-05-31:/microsoft/Quantum-NC</id>
    <link href="https://github.com/microsoft/Quantum-NC" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Microsoft Quantum Computing Libraries for noncommercial use&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Microsoft Quantum Development Kit: Non-Commercial Libraries&lt;/h1&gt; &#xA;&lt;p&gt;Welcome to the Microsoft Quantum Development Kit!&lt;/p&gt; &#xA;&lt;p&gt;This repository contains shared-source libraries that can be used for research and academics, but that cannot be used for commercial purposes. Please note that these libraries are not intended for production use, and may be modified as research proceeds. For more information please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/Quantum-NC/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Using the non-commercial research libraries&lt;/h2&gt; &#xA;&lt;p&gt;The non-commercial libraries in this repository can be used via NuGet packages beginning with the prefix &lt;a href=&#34;https://www.nuget.org/packages?q=owner:QuantumEngineering%20id:research&#34;&gt;&#34;Microsoft.Quantum.Research.&#34;&lt;/a&gt; For more details, please see:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/Quantum-NC/wiki/Research-packages&#34;&gt;Research packages&lt;/a&gt; on the &lt;a href=&#34;https://github.com/microsoft/Quantum-NC/wiki/&#34;&gt;Quantum-NC wiki&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Feedback&lt;/h2&gt; &#xA;&lt;p&gt;If you have feedback about the libraries in this repository, please let us know by filing a &lt;a href=&#34;https://github.com/microsoft/Quantum-NC/issues/new&#34;&gt;new issue&lt;/a&gt;! If you have feedback about some other part of the Microsoft Quantum Development Kit, please see the &lt;a href=&#34;https://docs.microsoft.com/azure/quantum/contributing-overview&#34;&gt;contribution guide&lt;/a&gt; for more information on the best places to file it.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please note: &lt;strong&gt;this project does not accept external contributions&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like to contribute to the rest of the Quantum Development Kit, please see the &lt;a href=&#34;https://docs.microsoft.com/azure/quantum/contributing-overview&#34;&gt;contribution guide&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>