<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-18T01:28:23Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cmeeren/Faqt</title>
    <updated>2023-09-18T01:28:23Z</updated>
    <id>tag:github.com,2023-09-18:/cmeeren/Faqt</id>
    <link href="https://github.com/cmeeren/Faqt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fluent assertions for F#&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Faqt&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fantastic fluent assertions for your F# tests and domain code.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/cmeeren/Faqt/main/logo/faqt-logo-docs.png&#34; width=&#34;300&#34; align=&#34;right&#34;&gt; &#xA;&lt;p&gt;Faqt improves on the best of &lt;a href=&#34;https://github.com/fluentassertions/fluentassertions&#34;&gt;FluentAssertions&lt;/a&gt; and &lt;a href=&#34;https://github.com/shouldly/shouldly&#34;&gt;Shouldly&lt;/a&gt; and serves it steaming hot on a silver platter to the discerning F# developer.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;It aims to be the best assertion library for F#.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t agree, I consider that a bug - please raise an issue. ðŸ˜‰&lt;/p&gt; &#xA;&lt;h3&gt;Versioning and breaking changes&lt;/h3&gt; &#xA;&lt;p&gt;Faqt follows &lt;a href=&#34;https://semver.org/&#34;&gt;SemVer v2.0.0&lt;/a&gt; and aims to preserve &lt;strong&gt;source and binary&lt;/strong&gt; compatibility between releases, except when the major version is incremented. Note that any change to the assertion message format is considered a non-breaking change.&lt;/p&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;!-- TOC --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cmeeren/Faqt/main/#a-motivating-example&#34;&gt;A motivating example&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cmeeren/Faqt/main/#installation-and-requirements&#34;&gt;Installation and requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cmeeren/Faqt/main/#faqt-in-a-nutshell&#34;&gt;Faqt in a nutshell&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cmeeren/Faqt/main/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cmeeren/Faqt/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- TOC --&gt; &#xA;&lt;h2&gt;A motivating example&lt;/h2&gt; &#xA;&lt;p&gt;Here is an example of what you can do with Faqt. Simply use &lt;code&gt;Should()&lt;/code&gt; to start asserting. For subsequent calls to &lt;code&gt;Should&lt;/code&gt; in the same chain, use &lt;code&gt;Should(())&lt;/code&gt; (double parentheses - this is required for subject names to work properly). Like FluentAssertions, all assertions support an optional &#34;because&#34; parameter that will be used in the output.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-f#&#34;&gt;// Example type definition for clarity&#xA;type Customer =&#xA;    | Internal of {| ContactInfo: {| Name: {| LastName: string |} |} option |}&#xA;    | External of {| Id: int |}&#xA;&#xA;open Faqt&#xA;&#xA;// Assertions in test or domain code&#xA;customer&#xA;    .Should()&#xA;    .BeOfCase(Internal, &#34;This function should only be called with internal customers&#34;)&#xA;    .Whose.ContactInfo.Should(())&#xA;    .BeSome()&#xA;    .Whose.Name.LastName.Should(())&#xA;    .Be(&#34;Armstrong&#34;, &#34;Only customers named Armstrong get free shipping&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(The example is formatted using &lt;a href=&#34;https://fsprojects.github.io/fantomas/&#34;&gt;Fantomas&lt;/a&gt;, which line-breaks fluent chains at method calls. While the readability of Faqt assertion chains could be slightly improved by manual formatting, entirely foregoing automatic formatting is not worth the slight benefit to readability.)&lt;/p&gt; &#xA;&lt;p&gt;Depending on the input, a &lt;code&gt;Faqt.AssertionFailedException&lt;/code&gt; may be raised with one of these messages:&lt;/p&gt; &#xA;&lt;p&gt;If customer is &lt;code&gt;External&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Subject: customer&#xA;Because: This function should only be called with internal customers&#xA;Should: BeOfCase&#xA;Expected: Internal&#xA;But was:&#xA;  External:&#xA;    Id: 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;ContactInfo&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Subject:&#xA;- customer&#xA;- ContactInfo&#xA;Should: BeSome&#xA;But was: None&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;LastName&lt;/code&gt; is not &lt;code&gt;Armstrong&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Subject:&#xA;- customer&#xA;- ContactInfo&#xA;- Name.LastName&#xA;Because: Only customers named Armstrong get free shipping&#xA;Should: Be&#xA;Expected: Armstrong&#xA;But was: Aldrin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, the output is YAML-based (because this is both human readable and works well for arbitrary structured values). The top-level &lt;code&gt;Subject&lt;/code&gt; key tells you which part of the code fails, and an array of values is used when using derived state from an assertion, so you can track the transformations on the original subject.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Yes, this works even in Release mode or when source files are not available!&lt;/strong&gt; See the very simple requirements below.&lt;/p&gt; &#xA;&lt;h2&gt;Installation and requirements&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Faqt &lt;a href=&#34;https://www.nuget.org/packages/Faqt&#34;&gt;from NuGet&lt;/a&gt;. Faqt supports .NET 5.0 and higher.&lt;/li&gt; &#xA; &lt;li&gt;If you use path mapping, deterministic source paths, or want to execute assertions where source files are not available (e.g. in production), set &lt;code&gt;DebugType&lt;/code&gt; to &lt;code&gt;embedded&lt;/code&gt; and &lt;code&gt;EmbedAllSources&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For more details, see the &lt;a href=&#34;https://raw.githubusercontent.com/cmeeren/Faqt/main/DOCUMENTATION.md&#34;&gt;documentation&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Faqt in a nutshell&lt;/h2&gt; &#xA;&lt;p&gt;As expected by the discerning F# developer, Faqt is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Readable:&lt;/strong&gt; Assertions read like natural language and clearly reveal their intention.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Concise:&lt;/strong&gt; Assertion syntax verbosity is kept to an absolute minimum.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Usable:&lt;/strong&gt; Faqt comes with batteries included, and contains many useful assertions, including aliases (like &lt;code&gt;BeTrue()&lt;/code&gt; for &lt;code&gt;Be(true)&lt;/code&gt; on booleans, and &lt;code&gt;BeSome&lt;/code&gt; for &lt;code&gt;BeOfCase(Some)&lt;/code&gt; on &lt;code&gt;option&lt;/code&gt; values).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Safe:&lt;/strong&gt; Assertions are as type-safe as F# allows.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Extensible:&lt;/strong&gt; No assertion? No problem! Writing your own assertions is very simple (details in the &lt;a href=&#34;https://raw.githubusercontent.com/cmeeren/Faqt/main/DOCUMENTATION.md&#34;&gt;documentation&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Informative:&lt;/strong&gt; The assertion failure messages are designed to give you all the information you need in a consistent and easy-to-read format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Discoverable:&lt;/strong&gt; The fluent syntax means you can just type a dot to discover all possible assertions and actions on the current value.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Composable:&lt;/strong&gt; As far as possible, assertions are orthogonal (they check one thing only). For example, predicate-based collection assertions pass for empty collections, just like F#&#39;s &lt;code&gt;Seq.forall&lt;/code&gt; and similar. You can chain assertions with &lt;code&gt;And&lt;/code&gt;, &lt;code&gt;Whose&lt;/code&gt;, &lt;code&gt;WhoseValue&lt;/code&gt;, &lt;code&gt;That&lt;/code&gt;, &lt;code&gt;Derived&lt;/code&gt;, and &lt;code&gt;Subject&lt;/code&gt;, assert on derived values with assertions like &lt;code&gt;BeSome&lt;/code&gt;, and compose assertions with higher-order assertions like &lt;code&gt;Satisfy&lt;/code&gt; and &lt;code&gt;SatisfyAll&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Configurable:&lt;/strong&gt; You can configure, either globally or for a specific scope (such as a test), how assertion failure messages are rendered. You can easily tweak the defaults or completely replace the formatter.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Production-ready:&lt;/strong&gt; Faqt is very well tested and is highly unlikely to break your code, whether test or production.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/cmeeren/Faqt/main/DOCUMENTATION.md&#34;&gt;documentation&lt;/a&gt; for additional details, such as how to use the optional &lt;code&gt;%&lt;/code&gt; operator (alias for &lt;code&gt;ignore&lt;/code&gt;), instructions on writing your own assertions, customizing the output format, security considerations, and a FAQ with, among other things, a brief comparison with other assertion frameworks.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome! Please see the &lt;a href=&#34;https://raw.githubusercontent.com/cmeeren/Faqt/main/CONTRIBUTING.md&#34;&gt;contribution guidelines&lt;/a&gt; before opening an issue or pull request.&lt;/p&gt;</summary>
  </entry>
</feed>