<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-12T01:35:31Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nblockchain/fsx</title>
    <updated>2023-06-12T01:35:31Z</updated>
    <id>tag:github.com,2023-06-12:/nblockchain/fsx</id>
    <link href="https://github.com/nblockchain/fsx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;FSX is the ideal tool for people that use F# for their scripting needs.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;FSX&lt;/h1&gt; &#xA;&lt;h2&gt;PUBLIC SERVICE ANNOUNCEMENT&lt;/h2&gt; &#xA;&lt;p&gt;THIS REPO IS FACING A COMPLETE OVERHAUL/REVAMP/RENOVATION IN ORDER TO SUPPORT .NET6.&lt;/p&gt; &#xA;&lt;p&gt;Unfinished tasks so far:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Revamp this ReadMe.md file to remove any mentions to Mono or the legacy .NET4.x framework.&lt;/li&gt; &#xA; &lt;li&gt;Remove legacy framework support (so that build system can converge into .fsx files instead of autotools in Unix + fsx in Windows).&lt;/li&gt; &#xA; &lt;li&gt;Make fsxc always enable warnAsError and fsx always disable it.&lt;/li&gt; &#xA; &lt;li&gt;After doing the above, make both fsx and fsxc always enable warnAsError for the warning described in &lt;a href=&#34;https://stackoverflow.com/questions/38202685/fsx-script-ignoring-a-function-call-when-i-add-a-parameter-to-it&#34;&gt;https://stackoverflow.com/questions/38202685/fsx-script-ignoring-a-function-call-when-i-add-a-parameter-to-it&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Try creating VMs for CI that uninstall .NETCore/.NET6 completely (not just the dotnet executable removal hack), to make sure legacy framework build still works there.&lt;/li&gt; &#xA; &lt;li&gt;Try creating VMs for CI that uninstall Mono/.NET4.x completey (e.g. for macOS see: &lt;a href=&#34;https://github.com/mono/website/commit/490797429d4b92584394292ff69fbdc0eb002948&#34;&gt;https://github.com/mono/website/commit/490797429d4b92584394292ff69fbdc0eb002948&lt;/a&gt; )&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;FSX is the ideal tool for people that use F# for their scripting needs.&lt;/p&gt; &#xA;&lt;p&gt;The best way to describe it is to start first with some questions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Have you found yourself waiting many seconds until your big script is parsed by FSI and run? This is unacceptable when doing many small changes and expecting a quick feedback loop to test them.&lt;/li&gt; &#xA; &lt;li&gt;Do you have long-running F# scripts that cause too much memory usage in your server?&lt;/li&gt; &#xA; &lt;li&gt;Have you found that your scripts could bitrot over time (i.e. not compile anymore) especially when using helper functions in .fs files loaded by them?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These are the main annoyances when working with F# scripting. Granted, F#+FSI is already much better than the alternatives (as many more errors are thrown much earlier than at runtime, and as strongly-typed functional languages are generally faster). However, we can do better.&lt;/p&gt; &#xA;&lt;p&gt;To the above three questions we could even follow-up with new ones:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Couldn&#39;t we make FSI only compile what&#39;s changed, and reuse binaries from a previous run, to speed this up?&lt;/li&gt; &#xA; &lt;li&gt;Couldn&#39;t we run our script without FSI given that FSI eats a lot of memory (for REPL features, which scripts don&#39;t need)?&lt;/li&gt; &#xA; &lt;li&gt;Couldn&#39;t we have a CI approach that takes care of our scripts in a similar way as we do with (msbuild-ed) C#/F# code?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;FSX answers all of these latter questions with a categorical YES!&lt;/p&gt; &#xA;&lt;p&gt;The creation of FSX was inspired by several facts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;FSI is slower than the F# compiler (obviously).&lt;/li&gt; &#xA; &lt;li&gt;There should be an easy and programatic way to compile an F# script without trying to run it (see &lt;a href=&#34;https://stackoverflow.com/questions/33468298/f-how-can-i-compile-and-then-release-a-file-fsx&#34;&gt;https://stackoverflow.com/questions/33468298/f-how-can-i-compile-and-then-release-a-file-fsx&lt;/a&gt; ).&lt;/li&gt; &#xA; &lt;li&gt;FSI (or the components required to run it) suffers from bugs frequently. Examples: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If your version of Mono is too old (e.g. 4.6.2, the version that comes by default in Ubuntu 18.04), then it might crash with a segmentation fault. More info: &lt;a href=&#34;https://bugzilla.xamarin.com/show_bug.cgi?id=42417&#34;&gt;https://bugzilla.xamarin.com/show_bug.cgi?id=42417&lt;/a&gt; .&lt;/li&gt; &#xA;   &lt;li&gt;If your version of Mono is not too old, but your version of F# is not too new (e.g. what happens exactly with Ubuntu 19.04), then FSI might not work at all. More info: &lt;a href=&#34;https://github.com/fsharp/fsharp/issues/740&#34;&gt;https://github.com/fsharp/fsharp/issues/740&lt;/a&gt; .&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;FSI stands for F Sharp &lt;strong&gt;Interactive&lt;/strong&gt;, which means that it&#39;s not really suited for scripting but more for debugging: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;It doesn&#39;t treat warnings as errors by default (you would need to remember to use the flag --warnaserror when calling fsharpi, which is not handy).&lt;/li&gt; &#xA;   &lt;li&gt;Because of the previous point above about warnings, it can even cancel the advantage of the promise of &#34;statically-compiled scripts&#34; altogether, because what should be a compilation error could be translated to a runtime error when using currified arguments, due to FSI defaulting to &#34;interactive&#34; needs. (More info: &lt;a href=&#34;https://stackoverflow.com/questions/38202685/fsx-script-ignoring-a-function-call-when-i-add-a-parameter-to-it&#34;&gt;https://stackoverflow.com/questions/38202685/fsx-script-ignoring-a-function-call-when-i-add-a-parameter-to-it&lt;/a&gt; )&lt;/li&gt; &#xA;   &lt;li&gt;AFAIK there&#39;s no way to use flags in a shebang (so can&#39;t use &lt;code&gt;#!/usr/bin/env fsharpi --warnaserror&lt;/code&gt; as the flag gets ignored). Note that using fsx in shebang, however, will treat warnings as errors.&lt;/li&gt; &#xA;   &lt;li&gt;It can consume a lot of memory, just compare it this way:&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo $&#39;#!/usr/bin/env fsharpi\nSystem.Threading.Thread.Sleep(999999999)&#39;&amp;gt;testfsi.fsx&#xA;echo $&#39;#!/usr/bin/env fsx\nSystem.Threading.Thread.Sleep(999999999)&#39;&amp;gt;testfsx.fsx&#xA;chmod u+x test*.fsx&#xA;nohup ./testfsi.fsx &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&#xA;nohup ./testfsx.fsx &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&#xA;ps aux | grep testfs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In my machine, the above prints:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;andres   23596 16.6  0.9 254504 148268 pts/24  Sl   03:38   0:01 cli /usr/lib/cli/fsharp/fsi.exe --exename:fsharpi ./testfsi.fsx&#xA;andres   23600  0.0  0.0 129332 15936 pts/24   Sl   03:38   0:00 mono bin/./testfsx.fsx.exe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which is a huge difference in memory footprint.&lt;/p&gt; &#xA;&lt;h2&gt;How to install/use?&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;In Linux/macOS, the old-fashioned way by cloning and compiling it yourself:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./configure.sh --prefix=/usr/local&#xA;make&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(If you&#39;re using Windows, just build with &#34;make.bat&#34; and install with &#34;make install&#34;.)&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;h4&gt;Execution&lt;/h4&gt; &#xA;&lt;p&gt;After installing, you can already use the &lt;code&gt;#!/usr/bin/env fsx&lt;/code&gt; shebang in your scripts.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use fsx without having to change the shebang of all your scripts, just run &lt;code&gt;fsx yourscript.fsx&lt;/code&gt; every time.&lt;/p&gt; &#xA;&lt;h4&gt;Compilation&lt;/h4&gt; &#xA;&lt;p&gt;For your CI needs (to compile all scripts in your repo without executing them), you could call &lt;code&gt;fsxc&lt;/code&gt; using &lt;code&gt;find&lt;/code&gt; in your CI step.&lt;/p&gt; &#xA;&lt;p&gt;An example of how to do this with GitHub Actions, is this YML fragment that you could add to your workflow existing in your &lt;code&gt;.github/workflows/&lt;/code&gt; folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    - name: compile F# scripts&#xA;      shell: bash&#xA;      run: |&#xA;        dotnet new tool-manifest&#xA;        dotnet tool install fsxc&#xA;        find . -type f -name &#34;*.fsx&#34; | xargs -t -I {} dotnet fsxc {}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>