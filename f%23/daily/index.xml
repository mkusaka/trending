<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-17T01:33:20Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>slaveOftime/Fun.Build</title>
    <updated>2022-09-17T01:33:20Z</updated>
    <id>tag:github.com,2022-09-17:/slaveOftime/Fun.Build</id>
    <link href="https://github.com/slaveOftime/Fun.Build" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Fun.Build&lt;/h1&gt; &#xA;&lt;p style=&#34;color: red;&#34;&gt;Current it is under development, use it carefully&lt;/p&gt; &#xA;&lt;p&gt;This is a project mainly used for CICD, you can use it in a fsharp project or as a script. You can check the &lt;strong&gt;build.fsx&lt;/strong&gt; under the root folder to check how the Fun.Build project itself is built and published to nuget.&lt;/p&gt; &#xA;&lt;p&gt;The basic idea is you have &lt;strong&gt;pipeline&lt;/strong&gt; which can contain multiple stages.&lt;br&gt; Every &lt;strong&gt;stage&lt;/strong&gt; can contain multiple steps. In the stage you can set it to run in parallel or run under some conditions (when envVar, cmdArg, branch etc.).&lt;br&gt; Every &lt;strong&gt;step&lt;/strong&gt; is just a &lt;strong&gt;async&amp;lt; int &amp;gt;&lt;/strong&gt;, int is for the exit code.&lt;/p&gt; &#xA;&lt;h2&gt;For what&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple and straight forward DSL&lt;/li&gt; &#xA; &lt;li&gt;Type safety and extendable DSL&lt;/li&gt; &#xA; &lt;li&gt;Build and compose complex pipelines&lt;/li&gt; &#xA; &lt;li&gt;Test your pipelines locally&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example:&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &#34;nuget: Fun.Build, 0.1.2&#34;&#xA;&#xA;open Fun.Build&#xA;&#xA;pipeline &#34;Fun.Build&#34; {&#xA;    timeout 30 // You can set overall timeout for the pipeline&#xA;    timeoutForStep 10 // You can set default timeout for every step in every stage&#xA;    timeoutForStage 10 // You can set default timeout for every stage&#xA;    envVars [ &#34;envKey&#34;, &#34;envValue&#34; ] // You can add or override environment variables&#xA;    cmdArgs [ &#34;arg1&#34;; &#34;arg2&#34; ] // You can reset the command args&#xA;    workingDir __SOURCE_DIRECTORY__&#xA;    stage &#34;Demo1&#34; {&#xA;        timeout 30 // You can set default timeout for the stage&#xA;        timeoutForStep 30 // You can set default timeout for step under the stage&#xA;        envVars [ &#34;envKey&#34;, &#34;envValue&#34; ] // You can add or override environment variables&#xA;        // Use cmd, so we can encrypt sensitive argument for formatable string&#xA;        cmd $&#34;dotnet --version&#34;&#xA;        run (fun ctx -&amp;gt; cmd $&#34;&#34;&#34;dotnet {&#34;--version&#34;}&#34;&#34;&#34;)&#xA;        // You can run command directly with a string&#xA;        run &#34;dotnet --version&#34;&#xA;        run (fun ctx -&amp;gt; &#34;dotnet --version&#34;)&#xA;        run (fun ctx -&amp;gt; async { return &#34;dotnet --version&#34; })&#xA;        // You can run async functions&#xA;        run (Async.Sleep 1000)&#xA;        run (fun _ -&amp;gt; Async.Sleep 1000)&#xA;        run (fun _ -&amp;gt; async { return 0 }) // return an exit code to indicate if it successful&#xA;        // You can also run sync functions&#xA;        run (fun ctx -&amp;gt; ())&#xA;        run (fun ctx -&amp;gt; 0) // return an exit code to indicate if it successful&#xA;        // You can also use the low level api&#xA;        step (fun ctx -&amp;gt; async { return 0 })&#xA;        BuildStep(fun ctx -&amp;gt; async { return 0 })&#xA;    }&#xA;    stage &#34;Demo2&#34; {&#xA;        // whenAny, whenNot, whenAll. They can also be composed.&#xA;        whenAll {&#xA;            branch &#34;master&#34; // Check current branch is master&#xA;            whenAny {&#xA;                envVar &#34;envKey&#34; // Check has environment variable&#xA;                envVar &#34;envKey&#34; &#34;envValue&#34; // Check has environment variable value&#xA;                cmdArg &#34;cmdKey&#34; // Check has cmd arg&#xA;                cmdArg &#34;cmdKey&#34; &#34;cmdValue&#34; // Check has cmd arg value which should be behind the cmdKey&#xA;            }&#xA;        }&#xA;        paralle&#xA;        run &#34;dotnet --version&#34;&#xA;        run &#34;dotnet --version&#34;&#xA;    }&#xA;    stage &#34;Demo3&#34; {&#xA;        workingDir @&#34;C:\Users&#34;&#xA;        run &#34;powershell pwd&#34;&#xA;        // You can also nest stages, the stage will be treated as a single stage for parent stage.&#xA;        stage &#34;Demo nested&#34; {&#xA;            echo &#34;cool nested&#34;&#xA;            stage &#34;Deeper&#34; {&#xA;                echo &#34;cooller&#34;&#xA;            }&#xA;        }&#xA;    }&#xA;    post [ // Post stages are optional. It will run even other normal stages are failed.&#xA;        stage &#34;Post stage&#34; {&#xA;            echo &#34;You are finished ðŸ˜‚&#34;&#xA;            echo (fun ctx -&amp;gt; sprintf &#34;You are finished here: %A&#34; (ctx.GetWorkingDir()))&#xA;            run (fun _ -&amp;gt; async {&#xA;                return 0 // do something&#xA;            })&#xA;        }&#xA;    ]&#xA;    // You can have multiple pipelines, sometimes you only want to run it only if the command specified the pipeline name.&#xA;    // If this is set to false, then it will always run if you do not specify which pipeline to run. By default it is true.&#xA;    // To specify you can do this: dotnet fsi build.fsx -p Fun.Build&#xA;    runIfOnlySpecified false&#xA;    // You can also run it directly&#xA;    // runImmediate&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>