<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-06T01:33:45Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dbrattli/Giraffe.Pipelines</title>
    <updated>2022-09-06T01:33:45Z</updated>
    <id>tag:github.com,2022-09-06:/dbrattli/Giraffe.Pipelines</id>
    <link href="https://github.com/dbrattli/Giraffe.Pipelines" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Functional pipelining for Giraffe&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Giraffe.Pipelines&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dbrattli/Giraffe.Pipelines/actions/workflows/build-and-test.yml&#34;&gt;&lt;img src=&#34;https://github.com/dbrattli/Giraffe.Pipelines/actions/workflows/build-and-test.yml/badge.svg?sanitize=true&#34; alt=&#34;Build and Test&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Giraffe.Pipelines/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/Giraffe.Pipelines&#34; alt=&#34;Nuget&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Functional pipelining for the &lt;a href=&#34;https://github.com/giraffe-fsharp/Giraffe&#34;&gt;Giraffe&lt;/a&gt; ASP.NET Core micro web framework. This library enables you to write Giraffe HTTP handler pipelines using normal F# pipes (&lt;code&gt;|&amp;gt;&lt;/code&gt;) instead of Kleisli composition (&lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;). Kleisli composition can be problematic for several reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Everyone in F# understands the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator, but many do not understand &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Having to use functional or Kleisli composition as the main abstraction for a library is generally a bad idea&lt;/li&gt; &#xA; &lt;li&gt;Having serveral libraries using different &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt; are incompatible with each other. You will get very confusing error messages&lt;/li&gt; &#xA; &lt;li&gt;The IDE support and type annotations are not as good as with the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Giraffe.Pipelines fixes all this by letting you use normal F# pipes (&lt;code&gt;|&amp;gt;&lt;/code&gt;) and normal functional composition (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;) in your Giraffe pipelines.&lt;/p&gt; &#xA;&lt;p&gt;Now you may enjoy your favorite F# library using a simpler and familiar syntax.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;&amp;gt; dotnet add package Giraffe.Pipelines&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To enable pipelining you first you need to open the &lt;code&gt;Giraffe.Pipelines&lt;/code&gt; namespace in your file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;open Giraffe.Pipelines&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pipelines are started using the normal Giraffe pipeline syntax e.g. &lt;code&gt;route &#34;/ping&#34;&lt;/code&gt;. You can think of the standard Giraffe HTTP handlers as the create methods for a pipeline.&lt;/p&gt; &#xA;&lt;p&gt;The pipeline is then transformed by piping the initial handler into &#34;operators&#34; from the &lt;code&gt;HttpHandler&lt;/code&gt; module. This is similar to how you would use normal F# modules such as &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Result&lt;/code&gt;, e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let someHttpHandler: HttpHandler =&#xA;    setStatusCode 200&#xA;    |&amp;gt; HttpHandler.text &#34;Hello World&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The provided &lt;code&gt;HttpHandler&lt;/code&gt; operators have the type &lt;code&gt;HttpHandler -&amp;gt; HttpHandler&lt;/code&gt; and is used to transform the pipeline.&lt;/p&gt; &#xA;&lt;p&gt;You may even compose two &lt;code&gt;HttpHandler&lt;/code&gt; pipeline aware operators together using normal functional composition &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator to create your own pipeline aware operators.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let someHttpOperator: HttpHandler -&amp;gt; HttpHandler =&#xA;    HttpHandler.setStatusCode 200&#xA;    &amp;gt;&amp;gt; HttpHandler.text &#34;Hello World&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that HTTP handlers such as &lt;code&gt;choose&lt;/code&gt; starts new pipelines in the supplied list of handlers so you construct these handlers the same way as you would construct any other handlers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let app =&#xA;    GET&#xA;    |&amp;gt; HttpHandler.choose&#xA;        [ route &#34;/&#34;         |&amp;gt; HttpHandler.text &#34;Hello World&#34;&#xA;          route &#34;/foo&#34;      |&amp;gt; HttpHandler.text &#34;bar&#34;&#xA;          setStatusCode 404 |&amp;gt; HttpHandler.text &#34;Not found&#34; ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is the minimal self-contained example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open System&#xA;open Microsoft.AspNetCore.Builder&#xA;open Microsoft.AspNetCore.Hosting&#xA;open Microsoft.Extensions.Hosting&#xA;open Microsoft.Extensions.Logging&#xA;open Microsoft.Extensions.DependencyInjection&#xA;&#xA;open Giraffe&#xA;open Giraffe.Pipelines&#xA;&#xA;let webApp =&#xA;    choose [&#xA;        route &#34;/ping&#34; |&amp;gt; HttpHandler.text &#34;pong&#34;&#xA;        route &#34;/&#34;     |&amp;gt; HttpHandler.htmlFile &#34;/pages/index.html&#34; ]&#xA;&#xA;type Startup() =&#xA;    member __.ConfigureServices (services : IServiceCollection) =&#xA;        // Register default Giraffe dependencies&#xA;        services.AddGiraffe() |&amp;gt; ignore&#xA;&#xA;    member __.Configure (app : IApplicationBuilder)&#xA;                        (env : IHostEnvironment)&#xA;                        (loggerFactory : ILoggerFactory) =&#xA;        // Add Giraffe to the ASP.NET Core pipeline&#xA;        app.UseGiraffe webApp&#xA;&#xA;[&amp;lt;EntryPoint&amp;gt;]&#xA;let main _ =&#xA;    Host.CreateDefaultBuilder()&#xA;        .ConfigureWebHostDefaults(&#xA;            fun webHostBuilder -&amp;gt;&#xA;                webHostBuilder&#xA;                    .UseStartup&amp;lt;Startup&amp;gt;()&#xA;                    |&amp;gt; ignore)&#xA;        .Build()&#xA;        .Run()&#xA;    0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Operators&lt;/h2&gt; &#xA;&lt;p&gt;You can create your own custom pipeable operators by having a &lt;code&gt;source&lt;/code&gt; HTTP handler as the last argument of your handler, and subscribing it with a &#34;normal&#34; Giraffe HTTP handler function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let customHandler (source: HttpHandler): HttpHandler =&#xA;    fun (next: HttpFunc) (ctx: Microsoft.AspNetCore.Http.HttpContext) -&amp;gt;&#xA;        task {&#xA;            let! result = next ctx&#xA;            return result&#xA;        }&#xA;    |&amp;gt; subscribe source&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>