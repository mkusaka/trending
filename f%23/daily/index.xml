<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-05T01:39:25Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kaeedo/Scrutiny</title>
    <updated>2022-08-05T01:39:25Z</updated>
    <id>tag:github.com,2022-08-05:/kaeedo/Scrutiny</id>
    <link href="https://github.com/kaeedo/Scrutiny" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Randomly test state machines (such as your UI) by randomly navigating through transitions&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kaeedo/Scrutiny/main/header.svg?sanitize=true&#34; alt=&#34;Header&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;F# and C# library for testing state machines by randomly choosing available states and valid transitions. Designed for usage with UI tests&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/Scrutiny/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/scrutiny?color=blue&amp;amp;style=for-the-badge&#34; alt=&#34;Nuget&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/kaeedo/Scrutiny/workflows/Build/badge.svg?branch=master&#34; alt=&#34;Build&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;Describe your UI as a state machine, and then use Scrutiny to simulate a &#34;User&#34; that randomly clicks around on your site. Scrutiny will attempt to create a Directed Adjacency Graph of your states, and then randomly choose an unvisited state to navigate to. It will repeat this process until all states have been visited. During each state, Scrutiny will attempt to run any defined actions within that state. Once all states have been visited, if an exit action has been defined it will then navigate there and quit. Scrutiny will then also generate an HTML file which visualizes the State Machine as a graph.&lt;/p&gt; &#xA;&lt;p&gt;Scrutiny was designed to run UI tests, but using e.g. CanopyUI or Selenium is only an implementation detail. In theory, any state machine can be tested with Scrutiny.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;There are several usage example projects in the &lt;code&gt;usageExamples&lt;/code&gt; directory, implemented using different technologies. The first two are implemented in F#, and the third one in C#.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kaeedo/Scrutiny/main/usageExamples/UsageExample.Canopy&#34;&gt;Canopy UsageExample&lt;/a&gt; for a sample test implemented with &lt;a href=&#34;https://github.com/lefthandedgoat/canopy&#34;&gt;CanopyUI&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kaeedo/Scrutiny/main/usageExamples/UsageExample.Playwright&#34;&gt;Playwright UsageExample&lt;/a&gt; for a sample test implemented with &lt;a href=&#34;https://github.com/microsoft/playwright-sharp&#34;&gt;PlaywrightSharp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kaeedo/Scrutiny/main/usageExamples/UsageExample.CSharp&#34;&gt;C# UsageExample&lt;/a&gt; for a sample test implementation also using Playwright, but this time with C#&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A tiny sample site exists in the &lt;a href=&#34;https://raw.githubusercontent.com/kaeedo/Scrutiny/main/usageExamples/Web&#34;&gt;Usage Example directory&lt;/a&gt;. This is the website that the usage examples are testing. It features three pages, a home page, comment page, and a sign in page. A user can only leave a comment if they are signed in. The usage examples showcase a certain approach a developer can take as to how to model their web site as a state machine. In this case, the home and comment page are each listed twice, once as logged out, and once as logged in. This is only one way to handle this case, and the developer could choose to model it in any other way.&lt;/p&gt; &#xA;&lt;p&gt;Scrutiny will also draw a diagram representing the system under test as has been modeled by the various &lt;code&gt;page&lt;/code&gt;s. The &lt;a href=&#34;https://raw.githubusercontent.com/kaeedo/Scrutiny/main/usageExamples/Web&#34;&gt;Sample Web site&lt;/a&gt; looks like this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kaeedo/Scrutiny/main/images/scrutinyDemo.gif&#34; alt=&#34;SUT sample report&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;i&gt;Click&lt;/i&gt; for F# documentation&lt;/summary&gt; &#xA; &lt;p&gt;Define one &lt;code&gt;page&lt;/code&gt; object for each st ate in your UI. A state can be anything from a page, or an individual modal, or the same page as a different state, but altered, for example a logged in user.&lt;/p&gt; &#xA; &lt;p&gt;The possible custom operations are:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;name&lt;/code&gt;: Name of the state. Required&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;localState&lt;/code&gt;: A type to store some local state. Will be recreated everytime this page object is entered&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;onEnter&lt;/code&gt;: Function to run when entering this page. Only one allowed&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;onExit&lt;/code&gt;: Function to run when exiting this page. Only one allowed&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;transition&lt;/code&gt;: Possible transition. Define how to transition to the next state, as well as which state to navigate to. Any number of transitions allowed&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;action&lt;/code&gt;: Possible action. Define function to run while in this page state. Any number of actions allowed&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;exitAction&lt;/code&gt;: After scrutiny traverses the graph of possible states, will pick a single exit action defined in any state to navigate to and finish the test with&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;A &lt;code&gt;page&lt;/code&gt; looks like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;let loggedInComment = fun (globalState: GlobalState) -&amp;gt;&#xA;    page {&#xA;        name &#34;Logged In Comment&#34;&#xA;&#xA;        localState (LoggedInComment())&#xA;&#xA;        onEnter (fun ls -&amp;gt;&#xA;            printfn &#34;Checking on page comment&#34;&#xA;            // Do something with LocalState e.g. set the HomeLink property&#xA;            ls.HomeLink &amp;lt;- &#34;#home&#34;&#xA;            &#34;#header&#34; == &#34;Comments&#34;&#xA;        )&#xA;&#xA;        onExit (fun _ -&amp;gt;&#xA;            printfn &#34;Exiting comment&#34;&#xA;        )&#xA;&#xA;        transition ((fun ls -&amp;gt; click ls.HomeLink) ==&amp;gt; home)&#xA;        transition ((fun _ -&amp;gt; click &#34;#signin&#34;) ==&amp;gt; signIn)&#xA;&#xA;        action (fun _ -&amp;gt; () /*do something on the page*/)&#xA;        action (fun _ -&amp;gt; () /*do something else on the page*/)&#xA;&#xA;        exitAction (fun _ -&amp;gt; () /*final action to perform before exiting the test*/)&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The &lt;code&gt;name&lt;/code&gt; must be unique. Any number of &lt;code&gt;transition&lt;/code&gt;s and any number of &lt;code&gt;action&lt;/code&gt;s can be defined. The &lt;code&gt;exitAction&lt;/code&gt; is optional, and multiple &lt;code&gt;page&lt;/code&gt;s can have an &lt;code&gt;exitAction&lt;/code&gt;. If multiple are defined, Scrutiny will randomly choose one to perform.&lt;/p&gt; &#xA; &lt;p&gt;The &lt;code&gt;GlobalState&lt;/code&gt; in the example is any type defined in your test that you can use to pass data between states, e.g. &lt;code&gt;Username&lt;/code&gt; or &lt;code&gt;IsLoggedIn&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;The &lt;code&gt;LocalState&lt;/code&gt; is specific to a state, and is constructed each time that state is visited. It&#39;s optional, but when set, all functions will have access to the local state via the function parameter. In the above example, &lt;code&gt;localState&lt;/code&gt; is defined as:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;type LoggedInComment() =&#xA;    member val Comment = String.Empty with get, set&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;h3&gt;Configuration&lt;/h3&gt; &#xA; &lt;p&gt;Some things can be configured via &lt;code&gt;ScrutinyConfig&lt;/code&gt;. The default config is:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;{ ScrutinyConfig.Seed = Environment.TickCount&#xA;  MapOnly = false&#xA;  ComprehensiveActions = true&#xA;  ComprehensiveStates = true&#xA;  ScrutinyResultFilePath = Directory.GetCurrentDirectory() + &#34;/ScrutinyResult.html&#34;&#xA;  Logger = printfn &#34;%s&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;code&gt;Seed&lt;/code&gt; is printed during each test to be able to recreate a specific test run. &lt;code&gt;MapOnly&lt;/code&gt; won&#39;t run the test at all, but only generate the HTML Graph report. &lt;code&gt;ComprehensiveActions&lt;/code&gt; will run ALL defined actions anytime it enters a state with actions defined. If false, it will run a random subset of actions. &lt;code&gt;ComprehensiveStates&lt;/code&gt; will visit ALL states in the state machine. If this is false, then it will visit at least half of all states before randomly quitting. &lt;code&gt;ScrutinyResultFilePath&lt;/code&gt; is the directory and specified file name that the generated HTML report will be saved in &lt;code&gt;Logger&lt;/code&gt; is how individual messages from scrutiny will be logged. The signature is &lt;code&gt;string -&amp;gt; unit&lt;/code&gt;. This is useful for things like XUnit that bring their own console logging mechanism, or if you wanted to integrate a larger logging framework.&lt;/p&gt; &#xA; &lt;p&gt;To actually run the test, call the &lt;code&gt;scrutinize&lt;/code&gt; function with your entry state, config, and global state object. e.g.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;// Sample Global State. This can be anything, and all page states will receive the same instance&#xA;type GlobalState() =&#xA;    member val IsSignedIn = false with get, set&#xA;    member val Username = &#34;MyUsername&#34; with get, set&#xA;    member val Number = 42&#xA;&#xA;[&amp;lt;EntryPoint&amp;gt;]&#xA;let main argv =&#xA;    let options = FirefoxOptions()&#xA;    do options.AddAdditionalCapability(&#34;acceptInsecureCerts&#34;, true, true)&#xA;&#xA;    use ff = new FirefoxDriver(options)&#xA;    let currentDirectory = DirectoryInfo(Directory.GetCurrentDirectory())&#xA;&#xA;    let config =&#xA;        { ScrutinyConfig.Default with&#xA;              Seed = 553931187&#xA;              MapOnly = false&#xA;              ComprehensiveActions = true&#xA;              ComprehensiveStates = true&#xA;              ScrutinyResultFilePath = currentDirectory.Parent.Parent.Parent.FullName + &#34;/myResult.html&#34; }&#xA;&#xA;    // Start tests. In this case we&#39;re using CanopyUI, but can be any test runner e.g. XUnit or Expecto&#xA;    // Start CanopyUI tests&#xA;    &#34;Scrutiny&#34; &amp;amp;&amp;amp;&amp;amp; fun _ -&amp;gt;&#xA;        printfn &#34;opening url&#34;&#xA;        url &#34;https://localhost:5001/home&#34;&#xA;&#xA;        let gs = GlobalState()&#xA;&#xA;        // The call to start Scrutiny, and construct a graph and &#34;click&#34; through all states&#xA;        scrutinize config gs home&#xA;        // or&#xA;        // scrutinizeWithDefaultConfig gs home&#xA;&#xA;    switchTo ff&#xA;    pin canopy.types.direction.Right&#xA;&#xA;    run()&#xA;    quit ff&#xA;&#xA;    0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;At the end of the run, Scrutiny will return an object which contains the generated adjacency graph, as well as a list of individual steps taken, along with the actions performed in each state.&lt;/p&gt; &#xA; &lt;h4&gt;Important note for F# users&lt;/h4&gt; &#xA; &lt;p&gt;As the transitions ultimately depict a cyclic graph, it is necessary to declare module or namespace as recursive so that pages defined later can be referenced by pages earlier. Note the usage of the &lt;code&gt;rec&lt;/code&gt; keyword. e.g.:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;module rec MyPages =&#xA;    let firstPage = fun (globalState: GlobalState) -&amp;gt;&#xA;        page {&#xA;            name &#34;First Page&#34;&#xA;            transition ((fun () -&amp;gt; click &#34;#second&#34;) ==&amp;gt; secondPage)&#xA;        }&#xA;&#xA;    let secondPage = fun (globalState: GlobalState) -&amp;gt;&#xA;        page {&#xA;            name &#34;Second Page&#34;&#xA;            transition ((fun () -&amp;gt; click &#34;#first&#34;) ==&amp;gt; firstPage)&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;i&gt;Click&lt;/i&gt; for C# documentation&lt;/summary&gt; &#xA; &lt;p&gt;Define one class for each state in your UI, and decorate it with the &lt;code&gt;PageState&lt;/code&gt; attribute. A state can be anything from a page, or an individual modal, or the same page as a different state, but altered, for example a logged in user.&lt;/p&gt; &#xA; &lt;p&gt;The possible attributes are:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;PageState&lt;/code&gt;: Define a class as a Page state.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;OnEnter&lt;/code&gt;: Function to run when entering this page. Only one allowed&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;OnExit&lt;/code&gt;: Function to run when exiting this page. Only one allowed&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;TransitionTo&lt;/code&gt;: Possible transition. Define how to transition to the next state, as well as which state to navigate to. Any number of transitions allowed&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;Action&lt;/code&gt;: Possible action. Define function to run while in this page state. Any number of actions allowed&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;ExitAction&lt;/code&gt;: After scrutiny traverses the graph of possible states, will pick a single exit action defined in any state to navigate to and finish the test with&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;A &lt;code&gt;PageState&lt;/code&gt; could look like this:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;using Scrutiny.CSharp;&#xA;&#xA;[PageState]&#xA;public class LoggedInComment&#xA;{&#xA;    private readonly GlobalState globalState;&#xA;    private string localComment = string.Empty;&#xA;&#xA;    public LoggedInComment(GlobalState globalState)&#xA;    {&#xA;        // Construct anything necessary.&#xA;        // The constructor is called everytime Scrutiny navigates to this state&#xA;    }&#xA;&#xA;    [OnEnter]&#xA;    public void OnEnter()&#xA;    {&#xA;        // Do something when scrutiny enters this state&#xA;        // Can optionally be async/await&#xA;        // Can only define one&#xA;    }&#xA;&#xA;    [Action]&#xA;    public async Task WriteComments()&#xA;    {&#xA;        // Do something on the page&#xA;        // Can optionally be non-async&#xA;        // Define any number of these&#xA;    }&#xA;&#xA;    [OnExit]&#xA;    public void OnExit()&#xA;    {&#xA;        // Do something when scrutiny exits this state&#xA;        // Can optionally be async/await&#xA;        // Can only define one&#xA;    }&#xA;&#xA;    [ExitAction]&#xA;    public async Task ExitAction()&#xA;    {&#xA;        // One exit actions amongst all page states is chosen&#xA;        // Define any number of these&#xA;        // Can optionally be non-async&#xA;    }&#xA;&#xA;    [TransitionTo(nameof(AnotherState))]&#xA;    public void TransitionToAnotherState()&#xA;    {&#xA;        // Code to perform state transition&#xA;        // Define any number of these&#xA;        // Can optionally be async/await&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Available attriutes are: &lt;code&gt;PageState&lt;/code&gt; This decorates the class. Scrutiny will search for all &lt;code&gt;PageState&lt;/code&gt;s within an assembly. &lt;code&gt;OnEnter&lt;/code&gt; Only one allowed per class. This method will be run anytime Scrutiny enters this state. &lt;code&gt;OnExit&lt;/code&gt; Only one allowed per class. This method will be run anytime Scrutiny exits this state. &lt;code&gt;ExitAction&lt;/code&gt; Once Scrutiny is done navigating through the states and actions, it will randomly choose a single exit action out of all defined exit actions to exit the state machine. &lt;code&gt;Action&lt;/code&gt; These are any actions that are performed within a state, and then stay in the same state. &lt;code&gt;TransitionTo(string)&lt;/code&gt; These are any methods that perform state transitions. Pass the name of another &lt;code&gt;PageState&lt;/code&gt; to tell Scrutiny where the transition goes to.&lt;/p&gt; &#xA; &lt;h3&gt;Configuration&lt;/h3&gt; &#xA; &lt;p&gt;Some things can be configured via the &lt;code&gt;Scrutiny.CSharp.Configuration.Configuration&lt;/code&gt; POCO. The default config is:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;Seed = Environment.TickCount&#xA;MapOnly = false&#xA;ComprehensiveActions = true&#xA;ComprehensiveStates = true&#xA;ScrutinyResultFilePath = Directory.GetCurrentDirectory() + &#34;/ScrutinyResult.html&#34;&#xA;Logger = (Action&amp;lt;string&amp;gt;)((s) =&amp;gt; Console.WriteLine(s))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;code&gt;Seed&lt;/code&gt; is printed during each test to be able to recreate a specific test run. &lt;code&gt;MapOnly&lt;/code&gt; won&#39;t run the test at all, but only generate the HTML Graph report. &lt;code&gt;ComprehensiveActions&lt;/code&gt; will run ALL defined actions anytime it enters a state with actions defined. If false, it will run a random subset of actions. &lt;code&gt;ComprehensiveStates&lt;/code&gt; will visit ALL states in the state machine. If this is false, then it will visit at least half of all states before randomly quitting. &lt;code&gt;ScrutinyResultFilePath&lt;/code&gt; is the directory and specified file name that the generated HTML report will be saved in &lt;code&gt;Logger&lt;/code&gt; is how individual messages from scrutiny will be logged. This is useful for things like XUnit that bring their own console logging mechanism, or if you wanted to integrate a larger logging framework.&lt;/p&gt; &#xA; &lt;p&gt;To actually run the test, call the &lt;code&gt;Scrutiny.CSharp.Scrutinize.Start&amp;lt;Home&amp;gt;(gs, config)&lt;/code&gt; method. It takes your entry state as a generic type argument, and a constructed global state object as well as your config as parameters.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;using Scrutiny.CSharp;&#xA;&#xA;[Fact]&#xA;public async Task WithAttrs()&#xA;{&#xA;    var browser = await playwright.Firefox.LaunchAsync(headless: false);&#xA;    var context = await browser.NewContextAsync(ignoreHTTPSErrors: true);&#xA;    var page = await context.NewPageAsync();&#xA;&#xA;    await page.GoToAsync(&#34;https://127.0.0.1:5001/home&#34;);&#xA;&#xA;    var config = new Configuration&#xA;    {&#xA;        Seed = 553931187,&#xA;        MapOnly = false,&#xA;        ComprehensiveActions = true,&#xA;        ComprehensiveStates = true&#xA;    };&#xA;&#xA;    var gs = new GlobalState(page, outputHelper);&#xA;    var result = Scrutinize.Start&amp;lt;Home&amp;gt;(gs, config);&#xA;&#xA;    Assert.Equal(7, result.Steps.Count());&#xA;    Assert.Equal(5, result.Graph.Count());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The global state can be any class you want it to be. Scrutiny will pass the instance that is passed into the start around to each &lt;code&gt;PageState&lt;/code&gt; it visits. At the end of the run, Scrutiny will return an object which contains the generated adjacency graph, as well as a list of individual steps taken, along with the actions performed in each state.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;To run the usage examples, you must start the &lt;a href=&#34;https://raw.githubusercontent.com/kaeedo/Scrutiny/main/usageExamples/Web&#34;&gt;web project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The HTML report is a single file with all javascript written inline&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Sponsor&lt;/h2&gt; &#xA;&lt;p&gt;Thank you to &lt;a href=&#34;https://valora.digital&#34;&gt;Valora&lt;/a&gt; for sponsoring this project:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kaeedo/Scrutiny/main/valora.png&#34; alt=&#34;valora_logo&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Donations&lt;/h3&gt; &#xA;&lt;p&gt;Donations are greatly appreciated, but not needed at all. Please only donate if you are in a position to be able to afford it, and only if you truly believe in the gift of giving.&lt;/p&gt; &#xA;&lt;p&gt;Liberapay: &lt;a href=&#34;https://liberapay.com/kaeedo&#34;&gt;&lt;img src=&#34;https://liberapay.com/assets/widgets/donate.svg?sanitize=true&#34; alt=&#34;Liberapay&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;i&gt;Click&lt;/i&gt; for cryptocurrency links&lt;/summary&gt; &#xA; &lt;p&gt;Ethereum: &lt;code&gt;0x05f231D19c19A2111fe03c923F26813Bad43B57f&lt;/code&gt;&lt;/p&gt; &#xA; &lt;p&gt;Cardano ADA: &lt;code&gt;addr1qx35nmy62dfp3n5tqgga92gxcnq5vkvflw963yg7fm5e5my68x9frc2qq0r8nstjtnjcrcnpmtpzwvp0sqz46y4ykrmqrd4dg9&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/details&gt;</summary>
  </entry>
  <entry>
    <title>aardvark-community/aardwars</title>
    <updated>2022-08-05T01:39:25Z</updated>
    <id>tag:github.com,2022-08-05:/aardvark-community/aardwars</id>
    <link href="https://github.com/aardvark-community/aardwars" rel="alternate"></link>
    <summary type="html">&lt;p&gt;FPS game built on Aardvark Platform&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;aardwars&lt;/h1&gt; &#xA;&lt;p&gt;Multiplayer arena shooter FPS game built using Aardvark Platform.&lt;/p&gt; &#xA;&lt;p&gt;Gameplay video: &lt;a href=&#34;https://youtu.be/x7_Yy6IQzog&#34;&gt;https://youtu.be/x7_Yy6IQzog&lt;/a&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://raw.githubusercontent.com/aardvark-community/aardwars/master/screenshots/slice6.jpg&#34; width=&#34;200px&#34;&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://raw.githubusercontent.com/aardvark-community/aardwars/master/screenshots/slice5.jpg&#34; width=&#34;200px&#34;&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://raw.githubusercontent.com/aardvark-community/aardwars/master/screenshots/slice4.jpg&#34; width=&#34;200px&#34;&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://raw.githubusercontent.com/aardvark-community/aardwars/master/screenshots/slice3.jpg&#34; width=&#34;200px&#34;&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://raw.githubusercontent.com/aardvark-community/aardwars/master/screenshots/slice1.jpg&#34; width=&#34;200px&#34;&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;img src=&#34;https://raw.githubusercontent.com/aardvark-community/aardwars/master/screenshots/slice2.jpg&#34; width=&#34;200px&#34;&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h2&gt;How to play&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Either &lt;a href=&#34;https://github.com/aardvark-community/aardwars/releases/latest&#34;&gt;download the latest github Release&lt;/a&gt; and run Aardwars.Launcher.exe (Windows only)&lt;/li&gt; &#xA; &lt;li&gt;Or install as dotnet tool: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;code&gt;dotnet tool install --global aardwars&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;aardwars &amp;lt;server&amp;gt; &amp;lt;port&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Created by&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Georg Haaser (technical programming, &lt;a href=&#34;https://github.com/krauthaufen&#34;&gt;github/krauthaufen&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Lisa Kellner (additional gameplay programming, &lt;a href=&#34;https://github.com/gnufu&#34;&gt;github/gnufu&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Mateusz Kuzaj (3D models, &lt;a href=&#34;https://github.com/M4t3usz1&#34;&gt;github/M4t3usz1&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Sebastian Maierhofer (gameplay programming, &lt;a href=&#34;https://github.com/sebastianjulian&#34;&gt;github/sebastianjulian&lt;/a&gt; &lt;a href=&#34;https://www.instagram.com/sebi_maierhofer/&#34;&gt;instagram @sebi_maierhofer&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Stefan Maierhofer (minecraft world parser, screenshotr, &lt;a href=&#34;https://github.com/stefanmaierhofer&#34;&gt;github/stefanmaierhofer&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Attila Szabo (additional gameplay programming, &lt;a href=&#34;https://github.com/aszabo314&#34;&gt;github/aszabo314&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Andreas Walch (additional gameplay programming, &lt;a href=&#34;https://github.com/WalchAndreas&#34;&gt;github/WalchAndreas&lt;/a&gt;))&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Implementation&lt;/h2&gt; &#xA;&lt;p&gt;This project is a proof-of-concept implementation of a playable real-time video game using the &lt;a href=&#34;https://aardvarkians.com/&#34;&gt;Aardvark Platform&lt;/a&gt; scientific visualization toolset. It was initially created as part of an internship at &lt;a href=&#34;https://www.vrvis.at/&#34;&gt;VRVis&lt;/a&gt;. Features include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Elm-style (&#34;model-view-update&#34;) application structure using &lt;a href=&#34;https://github.com/fsprojects/FSharp.Data.Adaptive&#34;&gt;FSharp.Data.Adaptive&lt;/a&gt;/&lt;a href=&#34;https://github.com/krauthaufen/Adaptify&#34;&gt;Adaptify&lt;/a&gt; and &lt;a href=&#34;https://github.com/aardvark-platform/aardvark.rendering&#34;&gt;aardvark.rendering&#39;s&lt;/a&gt; &lt;code&gt;ISg&lt;/code&gt; graphics API.&lt;/li&gt; &#xA; &lt;li&gt;Heavy use of &lt;a href=&#34;https://github.com/aardvark-platform/aardvark.rendering&#34;&gt;aardvark.rendering&#39;s&lt;/a&gt; automatic instancing (&lt;code&gt;Sg.instanced&lt;/code&gt;) and &lt;a href=&#34;https://www.fshade.org/&#34;&gt;FShade&lt;/a&gt; for high performance rendering&lt;/li&gt; &#xA; &lt;li&gt;Implementation of the Level of Detail renderer in &lt;a href=&#34;https://github.com/aardvark-platform/aardvark.algodat&#34;&gt;aardvark.algodat&lt;/a&gt; to render Minecraft-style worlds&lt;/li&gt; &#xA; &lt;li&gt;Parser for Minecraft world files&lt;/li&gt; &#xA; &lt;li&gt;simple multiplayer using dotnet websockets&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Additional Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;community texture packs from &lt;a href=&#34;https://www.curseforge.com/minecraft/texture-packs/quadral-pack&#34;&gt;https://www.curseforge.com/minecraft/texture-packs/quadral-pack&lt;/a&gt; and &lt;a href=&#34;https://resourcepack.net/mythic-resource-pack/&#34;&gt;https://resourcepack.net/mythic-resource-pack/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Minecraft world file from &lt;a href=&#34;https://www.minecraftmaps.com/pvp-maps/jakobs-kitpvp&#34;&gt;https://www.minecraftmaps.com/pvp-maps/jakobs-kitpvp&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>