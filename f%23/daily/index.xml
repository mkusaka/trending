<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-06-02T01:34:28Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>G-Research/ShapeSifter</title>
    <updated>2024-06-02T01:34:28Z</updated>
    <id>tag:github.com,2024-06-02:/G-Research/ShapeSifter</id>
    <link href="https://github.com/G-Research/ShapeSifter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Type-safe datatype-generic programming for F#&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ShapeSifter&lt;/h1&gt; &#xA;&lt;p&gt;Type-safe datatype-generic programming for F#.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;The most useful place to start is likely with the &lt;code&gt;tType&amp;lt;&#39;a&amp;gt;&lt;/code&gt; function and corresponding active patterns in the &lt;code&gt;Patterns&lt;/code&gt; module. These patterns reflectively determine what type &lt;code&gt;&#39;a&lt;/code&gt; was, and give you evidence in the form of a &lt;code&gt;Teq&lt;/code&gt; (see &lt;a href=&#34;https://github.com/G-Research/TypeEquality&#34;&gt;TypeEquality&lt;/a&gt;). Where appropriate, you also get a type-safe representation of the type&#39;s structure.&lt;/p&gt; &#xA;&lt;p&gt;Here is a brief example. Everything written here was forced by the types: once we chose to match on the &lt;code&gt;Unit&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt; active patterns, there was only one way to write this function so that it compiled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open ShapeSifter&#xA;open ShapeSifter.Patterns&#xA;&#xA;let manipulateType&amp;lt;&#39;a&amp;gt; () =&#xA;    match tType&amp;lt;&#39;a&amp;gt; with&#xA;    | Unit teq -&amp;gt;&#xA;        printfn &#34;&#39;a was a unit type, and `teq` witnesses this!&#34;&#xA;    | Record data -&amp;gt;&#xA;        { new RecordConvEvaluator&amp;lt;_&amp;gt; with&#xA;            member _.Eval (fieldData : RecordTypeField list) (fieldTypes : TypeList&amp;lt;&#39;ts&amp;gt;) (conv : Conv&amp;lt;&#39;a, &#39;ts HList&amp;gt;) =&#xA;                failwith &#34;manipulate the type here&#34;&#xA;        }&#xA;        |&amp;gt; data.Apply&#xA;    | _ -&amp;gt; failwith &#34;unrecognised type&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inside the &lt;code&gt;RecordConvEvaluator&lt;/code&gt;, we have gained access to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The list &lt;code&gt;fieldData&lt;/code&gt; of record fields, telling us the name of each field and any attributes that were on the field (as well as the raw &lt;code&gt;PropertyInfo&lt;/code&gt; associated with each field).&lt;/li&gt; &#xA; &lt;li&gt;The same list of field types, but expressed as a &lt;a href=&#34;https://github.com/G-Research/HeterogeneousCollections/raw/main/HeterogeneousCollections/TypeList.fsi&#34;&gt;&lt;code&gt;HeterogeneousCollections.TypeList&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;code&gt;Conv&lt;/code&gt; (converter) which lets us interchange between an &lt;code&gt;&#39;a&lt;/code&gt; and a heterogeneous list of its field values.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We have now seen a pattern for a primitive type (&lt;code&gt;Unit&lt;/code&gt;) and for an arbitrary record. Using the patterns in ShapeSifter, we can recognise the following types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Many primitive types, and &lt;code&gt;DateTime&lt;/code&gt; and &lt;code&gt;TimeSpan&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Array&amp;lt;_&amp;gt;&lt;/code&gt;, &lt;code&gt;_ list&lt;/code&gt;, &lt;code&gt;Seq&amp;lt;_&amp;gt;&lt;/code&gt;, &lt;code&gt;Set&amp;lt;_&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Option&amp;lt;_&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Map&amp;lt;_, _&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;_ * _&lt;/code&gt;, &lt;code&gt;_ * _ * _&lt;/code&gt;, and arbitrary tuples&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;_ -&amp;gt; _&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Dictionary&amp;lt;_,_&amp;gt;&lt;/code&gt;, &lt;code&gt;ResizeArray&amp;lt;_&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Teq&amp;lt;_, _&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Records and unions&lt;/li&gt; &#xA; &lt;li&gt;&#34;Sums of products&#34; (that is, unions, but where we give you easier access to the products which make up the union fields).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;More examples&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/G-Research/ShapeSifter/main/ShapeSifter.Test&#34;&gt;tests&lt;/a&gt; for examples demonstrating how to perform type-safe manipulation of various different types. There is a &lt;a href=&#34;https://raw.githubusercontent.com/G-Research/ShapeSifter/main/ShapeSifter.Test/TestExamples.fs&#34;&gt;whistlestop tour&lt;/a&gt; and a &lt;a href=&#34;https://raw.githubusercontent.com/G-Research/ShapeSifter/main/ShapeSifter.Test/CsvExample&#34;&gt;specific example of type-safe CSV parsing&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;This library was originally built by &lt;a href=&#34;https://github.com/nickcowle&#34;&gt;Nicholas Cowle&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>G-Research/HeterogeneousCollections</title>
    <updated>2024-06-02T01:34:28Z</updated>
    <id>tag:github.com,2024-06-02:/G-Research/HeterogeneousCollections</id>
    <link href="https://github.com/G-Research/HeterogeneousCollections" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Type-safe heterogeneous collections for F#&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;HeterogeneousCollections&lt;/h1&gt; &#xA;&lt;p&gt;Type-safe heterogeneous collections for F#.&lt;/p&gt; &#xA;&lt;h2&gt;Concepts&lt;/h2&gt; &#xA;&lt;p&gt;A standard F# list is &lt;em&gt;homogeneous&lt;/em&gt;: every list element must have the same type. An &lt;code&gt;int list&lt;/code&gt; can only contain integers.&lt;/p&gt; &#xA;&lt;p&gt;The F# standard library does contain heterogeneous collection types, but there are downsides to their use. For example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;System.Collections.IList&lt;/code&gt; can contain different types of object, because it is not generic: every element is of type &lt;code&gt;obj&lt;/code&gt;. It is therefore highly type-unsafe.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Tuple&lt;/code&gt; is heterogeneous: you can construct &lt;code&gt;(3, &#34;hello&#34;)&lt;/code&gt;. However, it was not designed to be a list, so it is not at all ergonomic to use this way: you can&#39;t use them while being &#34;generic over the length of the list&#34; in the way that genuine lists naturally are.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;HeterogeneousCollections models heterogeneous collections at the type level, so that just as with &lt;code&gt;Tuple&lt;/code&gt; you retain type safety when manipulating the list.&lt;/p&gt; &#xA;&lt;p&gt;Concretely, a &lt;code&gt;HList&amp;lt;&#39;ts&amp;gt;&lt;/code&gt; (for &#34;heterogeneous list&#34;) takes a type parameter &lt;code&gt;&#39;ts&lt;/code&gt; which represents the ordered list of element types. We use function types to encode pairs at the type level.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;HList&amp;lt;unit&amp;gt;&lt;/code&gt; is the type of the empty list.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HList&amp;lt;int -&amp;gt; unit&amp;gt;&lt;/code&gt; is the type of lists of one int element.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HList&amp;lt;string -&amp;gt; int -&amp;gt; unit&amp;gt;&lt;/code&gt; is the type of lists where the first element is a &lt;code&gt;string&lt;/code&gt; and the second element is an &lt;code&gt;int&lt;/code&gt;. (That is, it models the same type as &lt;code&gt;Tuple&amp;lt;string, int&amp;gt;&lt;/code&gt;.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The API of &lt;code&gt;HList&lt;/code&gt; is such that you cannot construct an &lt;code&gt;HList&lt;/code&gt; where the type parameter does not indicate a heterogeneous list in this encoding.&lt;/p&gt; &#xA;&lt;h2&gt;The types available&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;HList&amp;lt;_&amp;gt;&lt;/code&gt;, as described above: heterogeneous lists.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HListT&amp;lt;&#39;ts, &#39;elem&amp;gt;&lt;/code&gt;: like an &lt;code&gt;HList&amp;lt;&#39;ts&amp;gt;&lt;/code&gt;, except every element of the list is a &lt;em&gt;tuple&lt;/em&gt; whose first entry is heterogeneous and whose second entry is the specific fixed &lt;code&gt;&#39;elem&lt;/code&gt; (like &lt;code&gt;int&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HUnion&amp;lt;&#39;ts&amp;gt;&lt;/code&gt;: as a discriminated union is to a tuple, so &lt;code&gt;HUnion&amp;lt;&#39;ts&amp;gt;&lt;/code&gt; is to &lt;code&gt;HList&amp;lt;&#39;ts&amp;gt;&lt;/code&gt;. This type represents &#34;a piece of data which is exactly one of the types encoded in &lt;code&gt;&#39;ts&lt;/code&gt;&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SumOfProducts&amp;lt;&#39;ts&amp;gt;&lt;/code&gt;: essentially an &lt;code&gt;HUnion&lt;/code&gt; of &lt;code&gt;HList&lt;/code&gt;s.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We also provide:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;TypeList&amp;lt;&#39;ts&amp;gt;&lt;/code&gt;, which is essentially &#34;the specification of the type of an &lt;code&gt;HList&amp;lt;&#39;ts&amp;gt;&lt;/code&gt;&#34;. It contains no meaningful data.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;(No type annotations are necessary to use this library; they&#39;re only here for the sake of the examples.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let testHList : HList&amp;lt;string -&amp;gt; int -&amp;gt; unit&amp;gt; =&#xA;    HList.empty |&amp;gt; HList.cons 1234 |&amp;gt; HList.cons &#34;Foo&#34;&#xA;&#xA;// No need to `tryHead`: the type asserts the list to be nonempty&#xA;HList.head testHList |&amp;gt; shouldEqual &#34;Foo&#34;&#xA;&#xA;let tail : HList&amp;lt;int -&amp;gt; unit&amp;gt; =&#xA;    HList.tail testHList&#xA;&#xA;let folder =&#xA;    { new HListFolder&amp;lt;string&amp;gt; with&#xA;        member _.Folder&amp;lt;&#39;a&amp;gt; (state : string) (elt : &#39;a) : string =&#xA;            state + &#34; &#34; + elt.ToString ()&#xA;    }&#xA;&#xA;HList.fold folder &#34;&#34; testHList&#xA;|&amp;gt; shouldEqual &#34; Foo 1234&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Real-world usages are available in the &lt;a href=&#34;https://github.com/G-Research/ShapeSifter&#34;&gt;ShapeSifter&lt;/a&gt; library, which uses &lt;code&gt;HeterogeneousCollections&lt;/code&gt; to decompose and manipulate F# types safely.&lt;/p&gt;</summary>
  </entry>
</feed>