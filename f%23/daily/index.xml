<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-14T01:27:45Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>StereoDB/StereoDB</title>
    <updated>2023-09-14T01:27:45Z</updated>
    <id>tag:github.com,2023-09-14:/StereoDB/StereoDB</id>
    <link href="https://github.com/StereoDB/StereoDB" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ultrafast and lightweight in-process memory database written in F# that supports: transactions, secondary indexes, persistence, and data size larger than RAM.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/StereoDB/StereoDB/raw/dev/assets/stereo_db_logo.png&#34; alt=&#34;StereoDB logo&#34; width=&#34;600px&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/StereoDB/StereoDB/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/StereoDB/StereoDB/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/stereodb/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/stereodb.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;StereoDB&lt;/h4&gt; &#xA;&lt;p&gt;Ultrafast and lightweight in-process memory database written in F# that supports: transactions, secondary indexes, persistence, and data size larger than RAM. The primary use case for this database is building Stateful Services (API or ETL Worker) that keep all data in memory and can provide millions of RPS from a single node.&lt;/p&gt; &#xA;&lt;p&gt;Supported features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; C# and F# API&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Transactions (read-only, read-write)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Secondary Indexes &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Value Index (hash-based index)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Range Scan Index&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Data size larger than RAM&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Data persistence&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Distributed mode &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Server and client discovery&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Range-based sharding&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Intro to Stateful Services&lt;/h4&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/StereoDB/StereoDB/raw/dev/assets/architecture.png&#34; alt=&#34;StereoDB logo&#34; width=&#34;600px&#34;&gt; &lt;/p&gt; &#xA;&lt;h4&gt;Benchmarks&lt;/h4&gt; &#xA;&lt;p&gt;Pure KV workload benchmark (in-process only, without persistence). In &lt;a href=&#34;https://github.com/StereoDB/StereoDB/raw/dev/benchmarks/StereoDB.Benchmarks/Benchmarks/StereoDbBenchmark.cs&#34;&gt;this benchmark&lt;/a&gt;, &lt;strong&gt;we run concurrently 3 million random reads and 100K random writes in 892 ms&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;BenchmarkDotNet=v0.13.5, OS=Windows 11 (10.0.22621.2134/22H2/2022Update/SunValley2)&#xA;AMD Ryzen 7 5800H with Radeon Graphics, 1 CPU, 16 logical and 8 physical cores&#xA;.NET SDK=7.0.400&#xA;  [Host]     : .NET 7.0.10 (7.0.1023.36312), X64 RyuJIT AVX2&#xA;  DefaultJob : .NET 7.0.10 (7.0.1023.36312), X64 RyuJIT AVX2&#xA;&#xA;|    Method | ReadThreadCount | WriteThreadCount | UsersCount | DbReadCount | DbWriteCount |     Mean |    Error |   StdDev | Allocated |&#xA;|---------- |---------------- |----------------- |----------- |------------ |------------- |---------:|---------:|---------:|----------:|&#xA;| ReadWrite |              30 |               30 |    4000000 |     3000000 |       100000 | 891.9 ms | 17.75 ms | 35.86 ms |  13.12 KB |&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;C# API&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using System;&#xA;using StereoDB;&#xA;using StereoDB.CSharp;&#xA;&#xA;// defines a Book type that implements IEntity&amp;lt;TId&amp;gt;&#xA;public record Book : IEntity&amp;lt;int&amp;gt;&#xA;{&#xA;    public int Id { get; init; }&#xA;    public string Title { get; init; }&#xA;    public int Quantity { get; init; }&#xA;}&#xA;&#xA;// defines an Order type that implements IEntity&amp;lt;TId&amp;gt;&#xA;public record Order : IEntity&amp;lt;Guid&amp;gt;&#xA;{&#xA;    public Guid Id { get; init; }&#xA;    public int BookId { get; init; }&#xA;    public int Quantity { get; init; }&#xA;}&#xA;&#xA;public class BooksSchema&#xA;{&#xA;    public ITable&amp;lt;int, Book&amp;gt; Table { get; init; }&#xA;}&#xA;&#xA;public class OrdersSchema&#xA;{&#xA;    public ITable&amp;lt;Guid, Order&amp;gt; Table { get; init; }&#xA;    public IValueIndex&amp;lt;int, Order&amp;gt; BookIdIndex { get; init; }&#xA;}&#xA;&#xA;// defines a DB schema that includes Orders and Books tables&#xA;// and a secondary index: &#39;BookIdIndex&#39; for the Orders table&#xA;public class Schema&#xA;{&#xA;    public BooksSchema Books { get; }&#xA;    public OrdersSchema Orders { get; }&#xA;    &#xA;    public Schema()&#xA;    {&#xA;        Books = new BooksSchema&#xA;        {&#xA;            Table = StereoDbEngine.CreateTable&amp;lt;int, Book&amp;gt;()&#xA;        };&#xA;&#xA;        var ordersTable = StereoDbEngine.CreateTable&amp;lt;Guid, Order&amp;gt;();&#xA;&#xA;        Orders = new OrdersSchema()&#xA;        {&#xA;            Table = ordersTable,&#xA;            BookIdIndex = ordersTable.AddValueIndex(order =&amp;gt; order.BookId)&#xA;        };&#xA;    }&#xA;}&#xA;&#xA;// defines a DB that implements IStereoDb&amp;lt;Schema&amp;gt;&#xA;public class Db : IStereoDb&amp;lt;Schema&amp;gt;&#xA;{&#xA;    private readonly StereoDbEngine&amp;lt;Schema&amp;gt; _engine = StereoDbEngine.Create(new Schema());&#xA;&#xA;    public T ReadTransaction&amp;lt;T&amp;gt;(Func&amp;lt;ReadOnlyTsContext&amp;lt;Schema&amp;gt;, T&amp;gt; transaction) =&amp;gt; &#xA;        _engine.ReadTransaction(transaction);&#xA;    &#xA;    public T WriteTransaction&amp;lt;T&amp;gt;(Func&amp;lt;ReadWriteTsContext&amp;lt;Schema&amp;gt;, T&amp;gt; transaction) =&amp;gt; &#xA;        _engine.WriteTransaction(transaction);&#xA;&#xA;    public void WriteTransaction(Action&amp;lt;ReadWriteTsContext&amp;lt;Schema&amp;gt;&amp;gt; transaction) =&amp;gt;&#xA;        _engine.WriteTransaction(transaction);&#xA;}&#xA;&#xA;public static class Demo&#xA;{&#xA;    public static void Run()&#xA;    {&#xA;        var db = new Db();&#xA;&#xA;        // 1) adds book&#xA;        // WriteTransaction: it&#39;s a read-write transaction: we can query and mutate data&#xA;        &#xA;        db.WriteTransaction(ctx =&amp;gt;&#xA;        {&#xA;            var books = ctx.UseTable(ctx.Schema.Books.Table);&#xA;        &#xA;            foreach (var id in Enumerable.Range(0, 10))&#xA;            {&#xA;                var book = new Book {Id = id, Title = $&#34;book_{id}&#34;, Quantity = 1};&#xA;                books.Set(book);&#xA;            }&#xA;        });&#xA;               &#xA;        // 2) creates an order&#xA;        // WriteTransaction: it&#39;s a read-write transaction: we can query and mutate data&#xA;        &#xA;        db.WriteTransaction(ctx =&amp;gt;&#xA;        {&#xA;            var books = ctx.UseTable(ctx.Schema.Books.Table);&#xA;            var orders = ctx.UseTable(ctx.Schema.Orders.Table);&#xA;        &#xA;            foreach (var id in books.GetIds())&#xA;            {&#xA;                if (books.TryGet(id, out var book) &amp;amp;&amp;amp; book.Quantity &amp;gt; 0)&#xA;                {&#xA;                    var order = new Order {Id = Guid.NewGuid(), BookId = id, Quantity = 1};&#xA;                    var updatedBook = book with { Quantity = book.Quantity - 1 };&#xA;                    &#xA;                    books.Set(updatedBook);&#xA;                    orders.Set(order);&#xA;                }&#xA;            }&#xA;        });&#xA;                &#xA;        // 3) query book and orders&#xA;        // ReadTransaction: it&#39;s a read-only transaction: we can query multiple tables at once&#xA;        &#xA;        var result = db.ReadTransaction(ctx =&amp;gt;&#xA;        {&#xA;            var books = ctx.UseTable(ctx.Schema.Books.Table);&#xA;            var bookIdIndex = ctx.Schema.Orders.BookIdIndex;&#xA;        &#xA;            if (books.TryGet(1, out var book))&#xA;            {&#xA;                var orders = bookIdIndex.Find(book.Id).ToArray();&#xA;                return (book, orders);&#xA;            }&#xA;            &#xA;            return (null, null);&#xA;        });    &#xA;    }    &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;F# API&lt;/h4&gt; &#xA;&lt;p&gt;F# API has some benefits over C# API, mainly in expressiveness and type safety:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/anonymous-records&#34;&gt;Anonymous Records&lt;/a&gt; - It provides in place schema definition. You don&#39;t need to define extra types for schema as you do with C#. Also, it helps you model efficient &lt;strong&gt;(zero-cost, since it supports &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/structs&#34;&gt;structs&lt;/a&gt;)&lt;/strong&gt; and expressive - return result type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/value-options&#34;&gt;ValueOption&amp;lt;&#39;T&amp;gt;&lt;/a&gt; - It&#39;s used for StereoDB API to model emptiness in a type safe manner. Also, it&#39;s a &lt;strong&gt;zero-cost abstraction&lt;/strong&gt; since it&#39;s struct.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions&#34;&gt;Computation Expression&lt;/a&gt; - It helps to express multiple if &amp;amp; else checks on emptiness/null for ValueOption&amp;lt;&#39;T&amp;gt;, into a single &lt;strong&gt;voption { }&lt;/strong&gt; expression. To use &lt;strong&gt;voption { }&lt;/strong&gt;, &lt;a href=&#34;https://github.com/demystifyfp/FsToolkit.ErrorHandling&#34;&gt;FsToolkit.ErrorHandling&lt;/a&gt; should be installed. In the case of &lt;strong&gt;voption {}&lt;/strong&gt;, it&#39;s also a &lt;strong&gt;zero-cost abstraction&lt;/strong&gt;, the compiler generates optimized code without allocations.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open System&#xA;open FsToolkit.ErrorHandling&#xA;open StereoDB&#xA;open StereoDB.FSharp&#xA;&#xA;// defines a Book type that implements IEntity&amp;lt;TId&amp;gt;&#xA;type Book = {&#xA;    Id: int&#xA;    Title: string&#xA;    Quantity: int    &#xA;}&#xA;with&#xA;    interface IEntity&amp;lt;int&amp;gt; with&#xA;        member this.Id = this.Id&#xA;&#xA;// defines an Order type that implements IEntity&amp;lt;TId&amp;gt;&#xA;type Order = {&#xA;    Id: Guid&#xA;    BookId: int&#xA;    Quantity: int    &#xA;}&#xA;with&#xA;    interface IEntity&amp;lt;Guid&amp;gt; with&#xA;        member this.Id = this.Id&#xA;&#xA;// defines a DB schema that includes Orders and Books tables&#xA;// and a secondary index: &#39;BookIdIndex&#39; for the Orders table&#xA;type Schema() =&#xA;    let _books = {| Table = StereoDbEngine.CreateTable&amp;lt;int, Book&amp;gt;() |}&#xA;    &#xA;    let _ordersTable = StereoDbEngine.CreateTable&amp;lt;Guid, Order&amp;gt;()&#xA;    let _orders = {|&#xA;        Table = _ordersTable&#xA;        BookIdIndex = _ordersTable.AddValueIndex(fun order -&amp;gt; order.BookId)&#xA;    |}&#xA;    &#xA;    member this.Books = _books&#xA;    member this.Orders = _orders&#xA;&#xA;// defines a DB that implements IStereoDb&amp;lt;Schema&amp;gt;&#xA;type Db() =    &#xA;    let _engine = StereoDbEngine(Schema())&#xA;    &#xA;    interface IStereoDb&amp;lt;Schema&amp;gt; with&#xA;        member this.ReadTransaction(transaction) = _engine.ReadTransaction transaction&#xA;        member this.WriteTransaction(transaction) = _engine.WriteTransaction transaction&#xA;        member this.WriteTransaction&amp;lt;&#39;T&amp;gt;(transaction) = _engine.WriteTransaction&amp;lt;&#39;T&amp;gt;(transaction)&#xA;        &#xA;    static member Create() = Db() :&amp;gt; IStereoDb&amp;lt;Schema&amp;gt;&#xA;&#xA;let test () =&#xA;    let db = Db.Create()&#xA;&#xA;    // 1) adds book&#xA;    // WriteTransaction: it&#39;s a read-write transaction: we can query and mutate data&#xA;&#xA;    db.WriteTransaction(fun ctx -&amp;gt;&#xA;        let books = ctx.UseTable(ctx.Schema.Books.Table)&#xA;&#xA;        let bookId = 1&#xA;        let book = { Id = bookId; Title = &#34;book_1&#34;; Quantity = 1 }&#xA;        books.Set book&#xA;    )&#xA;&#xA;    // 2) creates an order&#xA;    // WriteTransaction: it&#39;s a read-write transaction: we can query and mutate data&#xA;&#xA;    db.WriteTransaction(fun ctx -&amp;gt;&#xA;        let books = ctx.UseTable(ctx.Schema.Books.Table)&#xA;        let orders = ctx.UseTable(ctx.Schema.Orders.Table)        &#xA;        &#xA;        voption {&#xA;            let bookId = 1&#xA;            let! book = books.Get bookId&#xA;&#xA;            if book.Quantity &amp;gt; 0 then&#xA;                let order = { Id = Guid.NewGuid(); BookId = bookId; Quantity = 1 }&#xA;                let updatedBook = { book with Quantity = book.Quantity - 1 }&#xA;                &#xA;                books.Set updatedBook&#xA;                orders.Set order                    &#xA;        }&#xA;        |&amp;gt; ignore                     &#xA;    )&#xA;&#xA;    // 3) query book and orders&#xA;    // ReadTransaction: it&#39;s a read-only transaction: we can query multiple tables at once&#xA;&#xA;    let result = db.ReadTransaction(fun ctx -&amp;gt;&#xA;        let books = ctx.UseTable(ctx.Schema.Books.Table)&#xA;        let bookIdIndex = ctx.Schema.Orders.BookIdIndex&#xA;        &#xA;        voption {&#xA;            let bookId = 1&#xA;            let! book = books.Get 1&#xA;            let orders = book.Id |&amp;gt; bookIdIndex.Find |&amp;gt; Seq.toArray&#xA;            &#xA;            return struct {| Book = book; Orders = orders |}&#xA;        }&#xA;    )    &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Transactions&lt;/h4&gt; &#xA;&lt;p&gt;StereoDB transactions allow the execution of a group of commands in a single step. StereoDB provides Read-Only and Read-Write transactions.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Read-Only allows you only read data. &lt;strong&gt;Also, they are multithreaded.&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Read-Write allows you read and write data. &lt;strong&gt;They are running in a single-thread fashion.&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;What to expect from transactions in StereoDB:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;they are blazingly fast and cheap to execute.&lt;/li&gt; &#xA; &lt;li&gt;they guarantee you atomic and consistent updates (you can update several tables including secondary indexes in one transaction and no other concurrent transaction will read your data partially; the transaction cannot be observed to be in progress by another database client).&lt;/li&gt; &#xA; &lt;li&gt;they don&#39;t support rollback since supporting rollbacks would have a significant impact on the simplicity and performance of StereoDB.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In terms of ACID, StereoDB provides: TBD&lt;/p&gt; &#xA;&lt;h5&gt;How to deal without rollbacks?&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;we suggest to use only immutable data types to model your data. In C#/F# you can use records/structs to achieve this. Immutable data types allow you to ignore partial failures while updating any data record in memory.&lt;/li&gt; &#xA; &lt;li&gt;run all necessary validation before updating data in tables. Mutating your database should be the latest transaction step after all necessary validations are passed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// it&#39;s an example of WriteTransaction&#xA;db.WriteTransaction(ctx =&amp;gt;&#xA;{&#xA;    var books = ctx.UseTable(ctx.Schema.Books.Table);    &#xA;&#xA;    // read record&#xA;    var bookId = 42;&#xA;    if (books.TryGet(bookId, out var book) &amp;amp;&amp;amp; book.Quantity &amp;gt; 0)&#xA;    {&#xA;        // update record (it&#39;s immutable type, so the book instance wasn&#39;t mutated)        &#xA;        var updatedBook = book with { Quantity = book.Quantity - 1 };&#xA;&#xA;        // and only after this you can safely mutate you state in database&#xA;        books.Set(updatedBook);&#xA;    }    &#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Secondary indexes&lt;/h4&gt; &#xA;&lt;p&gt;TBD&lt;/p&gt; &#xA;&lt;h4&gt;Best practices&lt;/h4&gt; &#xA;&lt;p&gt;TBD&lt;/p&gt; &#xA;&lt;!-- - closures (allocation)&#xA;- use immutable types&#xA;- secondary index IEnumerable convert to array for response&#xA;- GC settings&#xA;- Serializations, HTTP 2 --&gt;</summary>
  </entry>
</feed>