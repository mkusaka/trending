<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-07T01:36:41Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fsprojects/FSharp.Control.TaskSeq</title>
    <updated>2022-11-07T01:36:41Z</updated>
    <id>tag:github.com,2022-11-07:/fsprojects/FSharp.Control.TaskSeq</id>
    <link href="https://github.com/fsprojects/FSharp.Control.TaskSeq" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A computation expression and module for seamless working with IAsyncEnumerable&lt;&#39;T&gt; as if it is just another sequence&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/abelbraaksma/TaskSeq/actions/workflows/main.yaml&#34;&gt;&lt;img src=&#34;https://github.com/abelbraaksma/TaskSeq/actions/workflows/main.yaml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/abelbraaksma/TaskSeq/actions/workflows/test.yaml&#34;&gt;&lt;img src=&#34;https://github.com/abelbraaksma/TaskSeq/actions/workflows/test.yaml/badge.svg?sanitize=true&#34; alt=&#34;test&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;TaskSeq&#xA; &lt;!-- omit in toc --&gt;&lt;/h1&gt; &#xA;&lt;p&gt;An implementation &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerable-1?view=net-7.0&#34;&gt;&lt;code&gt;IAsyncEnumerable&amp;lt;&#39;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as a &lt;code&gt;taskSeq&lt;/code&gt; CE for F# with accompanying &lt;code&gt;TaskSeq&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;IAsyncEnumerable&lt;/code&gt; interface was added to .NET in &lt;code&gt;.NET Core 3.0&lt;/code&gt; and is part of &lt;code&gt;.NET Standard 2.1&lt;/code&gt;. The main use-case was for iterative asynchronous enumeration over some resource. For instance, an event stream or a REST API interface with pagination, where each page is a &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerator-1.movenextasync?view=net-7.0&#34;&gt;&lt;code&gt;MoveNextAsync&lt;/code&gt;&lt;/a&gt; call on the &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerator-1?view=net-7.0&#34;&gt;&lt;code&gt;IAsyncEnumerator&amp;lt;&#39;T&amp;gt;&lt;/code&gt;&lt;/a&gt; given by a call to &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerable-1.getasyncenumerator?view=net-7.0&#34;&gt;&lt;code&gt;GetAsyncEnumerator()&lt;/code&gt;&lt;/a&gt;. It has been relatively challenging to work properly with this type and dealing with each step being asynchronous, and the enumerator implementing &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/api/system.iasyncdisposable?view=net-7.0&#34;&gt;&lt;code&gt;IAsyncDisposable&lt;/code&gt;&lt;/a&gt; as well, which requires careful handling.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Table of contents&#xA; &lt;!-- omit in toc --&gt;&lt;/h2&gt; &#xA;&lt;!--&#xA;    This index can be auto-generated with VS Code&#39;s Markdown All in One extension.&#xA;    The ToC will be updated-on-save, or can be generated on command by using&#xA;    Ctrl-Shift-P: &#34;Create table of contents&#34;.&#xA;    More info: https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one#table-of-contents&#xA;--&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#feature-planning&#34;&gt;Feature planning&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#implementation-progress&#34;&gt;Implementation progress&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#taskseq-ce&#34;&gt;&lt;code&gt;taskSeq&lt;/code&gt; CE&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#taskseq-module-functions&#34;&gt;&lt;code&gt;TaskSeq&lt;/code&gt; module functions&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#more-information&#34;&gt;More information&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#futher-reading-iasyncenumerable&#34;&gt;Futher reading &lt;code&gt;IAsyncEnumerable&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#futher-reading-on-resumable-state-machines&#34;&gt;Futher reading on resumable state machines&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#further-reading-on-computation-expressions&#34;&gt;Further reading on computation expressions&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#building--testing&#34;&gt;Building &amp;amp; testing&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#prerequisites&#34;&gt;Prerequisites&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#build-the-solution&#34;&gt;Build the solution&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#run-the-tests&#34;&gt;Run the tests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#run-the-ci-command&#34;&gt;Run the CI command&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#advanced&#34;&gt;Advanced&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#get-help&#34;&gt;Get help&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#work-in-progress&#34;&gt;Work in progress&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#current-set-of-taskseq-utility-functions&#34;&gt;Current set of &lt;code&gt;TaskSeq&lt;/code&gt; utility functions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Feature planning&lt;/h2&gt; &#xA;&lt;p&gt;Not necessarily in order of importance:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Stabilize and battle-test &lt;code&gt;taskSeq&lt;/code&gt; resumable code. &lt;strong&gt;DONE&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; A growing set of module functions &lt;code&gt;TaskSeq&lt;/code&gt;, see below for progress. &lt;strong&gt;DONE &amp;amp; IN PROGRESS&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Packaging and publishing on Nuget, &lt;strong&gt;PLANNED: 13 November 2022&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add &lt;code&gt;Async&lt;/code&gt; variants for functions taking HOF arguments. &lt;strong&gt;DONE&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add generated docs to &lt;a href=&#34;https://fsprojects.github.io&#34;&gt;https://fsprojects.github.io&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Expand surface area based on &lt;code&gt;AsyncSeq&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; User requests?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Implementation progress&lt;/h2&gt; &#xA;&lt;p&gt;As of 6 November 2022:&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;taskSeq&lt;/code&gt; CE&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;em&gt;resumable state machine&lt;/em&gt; backing the &lt;code&gt;taskSeq&lt;/code&gt; CE is now finished and &lt;em&gt;restartability&lt;/em&gt; (not to be confused with &lt;em&gt;resumability&lt;/em&gt;) has been implemented and stabilized. Full support for empty task sequences is done. Focus is now on adding functionality there, like adding more useful overloads for &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;let!&lt;/code&gt;. Suggestions are welcome!&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;TaskSeq&lt;/code&gt; module functions&lt;/h3&gt; &#xA;&lt;p&gt;We are working hard on getting a full set of module functions on &lt;code&gt;TaskSeq&lt;/code&gt; that can be used with &lt;code&gt;IAsyncEnumerable&lt;/code&gt; sequences. Our guide is the set of F# &lt;code&gt;Seq&lt;/code&gt; functions in F# Core and, where applicable, the functions provided from &lt;code&gt;AsyncSeq&lt;/code&gt;. Each implemented function is documented through XML doc comments to provide the necessary context-sensitive help.&lt;/p&gt; &#xA;&lt;p&gt;The following is the progress report:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Done&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;Seq&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;TaskSeq&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Variants&lt;/th&gt; &#xA;   &lt;th&gt;Remarks&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚ùì&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;allPairs&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;allPairs&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note1&#34; title=&#34;These functions require a form of pre-materializing through &#39;TaskSeq.cache&#39;, similar to the approach taken in the corresponding &#39;Seq&#39; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &#39;AsyncSeq&#39; does implement these, so we&#39;ll probably do so eventually as well.&#34;&gt;note #1&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/81&#34;&gt;#81&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;append&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;append&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/81&#34;&gt;#81&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;appendSeq&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/81&#34;&gt;#81&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;prependSeq&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;average&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;average&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;averageBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;averageBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;averageByAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚ùì&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;cache&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;cache&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note1&#34; title=&#34;These functions require a form of pre-materializing through &#39;TaskSeq.cache&#39;, similar to the approach taken in the corresponding &#39;Seq&#39; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &#39;AsyncSeq&#39; does implement these, so we&#39;ll probably do so eventually as well.&#34;&gt;note #1&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/67&#34;&gt;#67&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;cast&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;cast&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/67&#34;&gt;#67&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;box&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/67&#34;&gt;#67&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;unbox&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;choose&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;choose&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;chooseAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;chunkBySize&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;chunkBySize&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/11&#34;&gt;#11&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;collectAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/11&#34;&gt;#11&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;collectSeq&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;collectSeqAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;compareWith&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;compareWith&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;compareWithAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/69&#34;&gt;#69&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/70&#34;&gt;#70&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;contains&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;contains&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/82&#34;&gt;#82&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;distinct&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;distinct&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;distinctBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;dictinctBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;distinctByAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;exactlyOne&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;exactlyOne&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;except&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;except&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/70&#34;&gt;#70&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;existsAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;exists2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;exists2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;filterAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;find&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;find&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;findAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;üö´&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;findBack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note2&#34; title=&#34;Because of the async nature of TaskSeq sequences, iterating from the back would be bad practice. Instead, materialize the sequence to a list or array and then apply the &#39;Back&#39; iterators.&#34;&gt;note #2&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/68&#34;&gt;#68&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;findIndex&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;findIndex&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;findIndexAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;üö´&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;findIndexBack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;n/a&lt;/td&gt; &#xA;   &lt;td&gt;n/a&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note2&#34; title=&#34;Because of the async nature of TaskSeq sequences, iterating from the back would be bad practice. Instead, materialize the sequence to a list or array and then apply the &#39;Back&#39; iterators.&#34;&gt;note #2&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;foldAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;fold2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;fold2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;fold2Async&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;üö´&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;foldBack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note2&#34; title=&#34;Because of the async nature of TaskSeq sequences, iterating from the back would be bad practice. Instead, materialize the sequence to a list or array and then apply the &#39;Back&#39; iterators.&#34;&gt;note #2&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;üö´&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;foldBack2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note2&#34; title=&#34;Because of the async nature of TaskSeq sequences, iterating from the back would be bad practice. Instead, materialize the sequence to a list or array and then apply the &#39;Back&#39; iterators.&#34;&gt;note #2&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;forall&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;forall&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;forallAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;forall2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;forall2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;forall2Async&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚ùì&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;groupBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;groupBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;groupByAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note1&#34; title=&#34;These functions require a form of pre-materializing through &#39;TaskSeq.cache&#39;, similar to the approach taken in the corresponding &#39;Seq&#39; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &#39;AsyncSeq&#39; does implement these, so we&#39;ll probably do so eventually as well.&#34;&gt;note #1&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;head&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;head&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/68&#34;&gt;#68&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;indexed&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;indexed&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/69&#34;&gt;#69&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;init&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;init&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;initAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/69&#34;&gt;#69&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;initInfinite&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;initInfinite&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;initInfiniteAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;insertAt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;insertAt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;insertManyAt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;insertManyAt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;isEmpty&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;isEmpty&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;item&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;item&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iterAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iter2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iter2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iter2Async&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iteri&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iteri&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iteriAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iteri2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iteri2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;iteri2Async&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;last&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;last&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/53&#34;&gt;#53&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;length&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;length&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/53&#34;&gt;#53&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;lengthBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;lengthByAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;map&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;map&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;map2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;map2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;map2Async&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;map3&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;map3&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;map3Async&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapFold&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapFold&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapFoldAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;üö´&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapFoldBack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note2&#34; title=&#34;Because of the async nature of TaskSeq sequences, iterating from the back would be bad practice. Instead, materialize the sequence to a list or array and then apply the &#39;Back&#39; iterators.&#34;&gt;note #2&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapi&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapi&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapiAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapi2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapi2&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mapi2Async&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;max&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;max&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;maxBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;maxBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;maxByAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;min&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;min&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;minBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;minBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;minByAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofArray&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofArray&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofAsyncArray&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofAsyncList&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofAsyncSeq&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofList&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofList&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofTaskList&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofResizeArray&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofSeq&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofTaskArray&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofTaskList&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ofTaskSeq&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;pairwise&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;pairwise&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;permute&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;permute&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;permuteAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;pick&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;pick&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;pickAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;üö´&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;readOnly&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note3&#34; title=&#34;The motivation for &#39;readOnly&#39; in &#39;Seq&#39; is that a cast from a mutable array or list to a &#39;seq&lt;_&gt;&#39; is valid and can be cast back, leading to a mutable sequence. Since &#39;TaskSeq&#39; doesn&#39;t implement &#39;IEnumerable&lt;_&gt;&#39;, such casts are not possible.&#34;&gt;note #3&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;reduceAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;üö´&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;reduceBack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note2&#34; title=&#34;Because of the async nature of TaskSeq sequences, iterating from the back would be bad practice. Instead, materialize the sequence to a list or array and then apply the &#39;Back&#39; iterators.&#34;&gt;note #2&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;removeAt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;removeAt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;removeManyAt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;removeManyAt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;replicate&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;replicate&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚ùì&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;rev&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note1&#34; title=&#34;These functions require a form of pre-materializing through &#39;TaskSeq.cache&#39;, similar to the approach taken in the corresponding &#39;Seq&#39; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &#39;AsyncSeq&#39; does implement these, so we&#39;ll probably do so eventually as well.&#34;&gt;note #1&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;scanAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;üö´&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;scanBack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note2&#34; title=&#34;Because of the async nature of TaskSeq sequences, iterating from the back would be bad practice. Instead, materialize the sequence to a list or array and then apply the &#39;Back&#39; iterators.&#34;&gt;note #2&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;singleton&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;singleton&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;skipWhile&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;skipWhile&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;skipWhileAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚ùì&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note1&#34; title=&#34;These functions require a form of pre-materializing through &#39;TaskSeq.cache&#39;, similar to the approach taken in the corresponding &#39;Seq&#39; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &#39;AsyncSeq&#39; does implement these, so we&#39;ll probably do so eventually as well.&#34;&gt;note #1&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚ùì&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sortBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note1&#34; title=&#34;These functions require a form of pre-materializing through &#39;TaskSeq.cache&#39;, similar to the approach taken in the corresponding &#39;Seq&#39; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &#39;AsyncSeq&#39; does implement these, so we&#39;ll probably do so eventually as well.&#34;&gt;note #1&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚ùì&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sortByAscending&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note1&#34; title=&#34;These functions require a form of pre-materializing through &#39;TaskSeq.cache&#39;, similar to the approach taken in the corresponding &#39;Seq&#39; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &#39;AsyncSeq&#39; does implement these, so we&#39;ll probably do so eventually as well.&#34;&gt;note #1&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚ùì&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sortByDescending&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note1&#34; title=&#34;These functions require a form of pre-materializing through &#39;TaskSeq.cache&#39;, similar to the approach taken in the corresponding &#39;Seq&#39; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &#39;AsyncSeq&#39; does implement these, so we&#39;ll probably do so eventually as well.&#34;&gt;note #1&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚ùì&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sortWith&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note1&#34; title=&#34;These functions require a form of pre-materializing through &#39;TaskSeq.cache&#39;, similar to the approach taken in the corresponding &#39;Seq&#39; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &#39;AsyncSeq&#39; does implement these, so we&#39;ll probably do so eventually as well.&#34;&gt;note #1&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;splitInto&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;splitInto&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sumBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sumBy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sumByAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/76&#34;&gt;#76&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tail&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tail&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;take&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;take&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;takeWhile&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;takeWhile&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;takeWhileAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toArray&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toArray&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toArrayAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toIList&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toIListAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toList&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toList&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toListAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toResizeArray&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toResizeArrayAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toSeq&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toSeqAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;[‚Ä¶]&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚ùì&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note1&#34; title=&#34;These functions require a form of pre-materializing through &#39;TaskSeq.cache&#39;, similar to the approach taken in the corresponding &#39;Seq&#39; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &#39;AsyncSeq&#39; does implement these, so we&#39;ll probably do so eventually as well.&#34;&gt;note #1&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;truncate&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;truncate&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryExactlyOne&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryExactlyOne&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryExactlyOneAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryFind&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryFind&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryFindAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;üö´&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryFindBack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note2&#34; title=&#34;Because of the async nature of TaskSeq sequences, iterating from the back would be bad practice. Instead, materialize the sequence to a list or array and then apply the &#39;Back&#39; iterators.&#34;&gt;note #2&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/68&#34;&gt;#68&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryFindIndex&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryFindIndex&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryFindIndexAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;üö´&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryFindIndexBack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/fsprojects/FSharp.Control.TaskSeq/main/#note2&#34; title=&#34;Because of the async nature of TaskSeq sequences, iterating from the back would be bad practice. Instead, materialize the sequence to a list or array and then apply the &#39;Back&#39; iterators.&#34;&gt;note #2&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryHead&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryHead&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryItem&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryItem&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryLast&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryLast&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/23&#34;&gt;#23&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryPick&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryPick&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryPickAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/76&#34;&gt;#76&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;tryTail&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;unfold&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;unfold&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;unfoldAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;updateAt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;updateAt&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;where&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;where&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;whereAsync&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;windowed&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;windowed&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;‚úÖ &lt;a href=&#34;https://github.com/fsprojects/FSharp.Control.TaskSeq/pull/2&#34;&gt;#2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;zip3&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;zip3&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;zip4&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sup&gt;¬π‚Åæ &lt;a id=&#34;note1&#34;&gt;&lt;/a&gt;&lt;em&gt;These functions require a form of pre-materializing through &lt;code&gt;TaskSeq.cache&lt;/code&gt;, similar to the approach taken in the corresponding &lt;code&gt;Seq&lt;/code&gt; functions. It doesn&#39;t make much sense to have a cached async sequence. However, &lt;code&gt;AsyncSeq&lt;/code&gt; does implement these, so we&#39;ll probably do so eventually as well.&lt;/em&gt;&lt;/sup&gt;&lt;br&gt; &lt;sup&gt;¬≤‚Åæ &lt;a id=&#34;note2&#34;&gt;&lt;/a&gt;&lt;em&gt;Because of the async nature of &lt;code&gt;TaskSeq&lt;/code&gt; sequences, iterating from the back would be bad practice. Instead, materialize the sequence to a list or array and then apply the &lt;code&gt;xxxBack&lt;/code&gt; iterators.&lt;/em&gt;&lt;/sup&gt;&lt;br&gt; &lt;sup&gt;¬≥‚Åæ &lt;a id=&#34;note3&#34;&gt;&lt;/a&gt;&lt;em&gt;The motivation for &lt;code&gt;readOnly&lt;/code&gt; in &lt;code&gt;Seq&lt;/code&gt; is that a cast from a mutable array or list to a &lt;code&gt;seq&amp;lt;_&amp;gt;&lt;/code&gt; is valid and can be cast back, leading to a mutable sequence. Since &lt;code&gt;TaskSeq&lt;/code&gt; doesn&#39;t implement &lt;code&gt;IEnumerable&amp;lt;_&amp;gt;&lt;/code&gt;, such casts are not possible.&lt;/em&gt;&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;h2&gt;More information&lt;/h2&gt; &#xA;&lt;h3&gt;Futher reading &lt;code&gt;IAsyncEnumerable&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A good C#-based introduction &lt;a href=&#34;https://stu.dev/iasyncenumerable-introduction/&#34;&gt;can be found in this blog&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8&#34;&gt;An MSDN article&lt;/a&gt; written shortly after it was introduced.&lt;/li&gt; &#xA; &lt;li&gt;Converting a &lt;code&gt;seq&lt;/code&gt; to an &lt;code&gt;IAsyncEnumerable&lt;/code&gt; &lt;a href=&#34;https://gist.github.com/akhansari/d88812b742aa6be1c35b4f46bd9f8532&#34;&gt;demo gist&lt;/a&gt; as an example, though &lt;code&gt;TaskSeq&lt;/code&gt; contains many more utility functions and uses a slightly different approach.&lt;/li&gt; &#xA; &lt;li&gt;If you&#39;re looking for using &lt;code&gt;IAsyncEnumerable&lt;/code&gt; with &lt;code&gt;async&lt;/code&gt; and not &lt;code&gt;task&lt;/code&gt;, the excellent &lt;a href=&#34;https://fsprojects.github.io/FSharp.Control.AsyncSeq/AsyncSeq.html&#34;&gt;&lt;code&gt;AsyncSeq&lt;/code&gt;&lt;/a&gt; library should be used. While &lt;code&gt;TaskSeq&lt;/code&gt; is intended to consume &lt;code&gt;async&lt;/code&gt; just like &lt;code&gt;task&lt;/code&gt; does, it won&#39;t create an &lt;code&gt;AsyncSeq&lt;/code&gt; type (at least not yet). If you want classic Async and parallelism, you should get this library instead.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Futher reading on resumable state machines&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A state machine from a monadic perspective in F# &lt;a href=&#34;http://blumu.github.io/ResumableMonad/TheResumableMonad.html&#34;&gt;can be found here&lt;/a&gt;, which works with the pre-F# 6.0 non-resumable internals.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/fsharp/fslang-design/raw/main/FSharp-6.0/FS-1087-resumable-code.md&#34;&gt;original RFC for F# 6.0 on resumable state machines&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/fsharp/fslang-design/raw/main/FSharp-6.0/FS-1097-task-builder.md&#34;&gt;original RFC for introducing &lt;code&gt;task&lt;/code&gt;&lt;/a&gt; to F# 6.0.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;a href=&#34;https://github.com/rspeele/TaskBuilder.fs/&#34;&gt;pre F# 6.0 &lt;code&gt;TaskBuilder&lt;/code&gt;&lt;/a&gt; that motivated the &lt;code&gt;task&lt;/code&gt; CE later added to F# Core.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/task-expressions&#34;&gt;MSDN Documentation on &lt;code&gt;task&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/async-expressions&#34;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Further reading on computation expressions&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions&#34;&gt;Docs on MSDN&lt;/a&gt; form a good summary and starting point.&lt;/li&gt; &#xA; &lt;li&gt;Arguably the best &lt;a href=&#34;https://fsharpforfunandprofit.com/series/computation-expressions/&#34;&gt;step-by-step tutorial to using and building computation expressions&lt;/a&gt; by Scott Wlaschin.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building &amp;amp; testing&lt;/h2&gt; &#xA;&lt;p&gt;TLDR: just run &lt;code&gt;build&lt;/code&gt;. Or load the &lt;code&gt;sln&lt;/code&gt; file in Visual Studio or VS Code and compile.&lt;/p&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;p&gt;At the very least, to get the source to compile, you&#39;ll need:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;.NET 6 or .NET 7 Preview&lt;/li&gt; &#xA; &lt;li&gt;F# 6.0 or 7.0 compiler&lt;/li&gt; &#xA; &lt;li&gt;To use &lt;code&gt;build.cmd&lt;/code&gt;, the &lt;code&gt;dotnet&lt;/code&gt; command must be accessible from your path.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Just check-out this repo locally. Then, from the root of the repo, you can do:&lt;/p&gt; &#xA;&lt;h3&gt;Build the solution&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;build [build] [release|debug]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With no arguments, defaults to &lt;code&gt;release&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Run the tests&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;build test [release|debug]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With no arguments, defaults to &lt;code&gt;release&lt;/code&gt;. By default, all tests are output to the console. If you don&#39;t want that, you can use &lt;code&gt;--logger console;verbosity=summary&lt;/code&gt;. Furthermore, no TRX file is generated and the &lt;code&gt;--blame-xxx&lt;/code&gt; flags aren&#39;t set.&lt;/p&gt; &#xA;&lt;h3&gt;Run the CI command&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;build ci [release|debug]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With no arguments, defaults to &lt;code&gt;release&lt;/code&gt;. This will run &lt;code&gt;dotnet test&lt;/code&gt; with the &lt;code&gt;--blame-xxx&lt;/code&gt; settings enabled to &lt;a href=&#34;https://github.com/abelbraaksma/TaskSeq/issues/25&#34;&gt;prevent hanging tests&lt;/a&gt; caused by an &lt;a href=&#34;https://github.com/xunit/xunit/issues/2587&#34;&gt;xUnit runner bug&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are no special CI environment variables that need to be set for running this locally.&lt;/p&gt; &#xA;&lt;h3&gt;Advanced&lt;/h3&gt; &#xA;&lt;p&gt;You can pass any additional options that are valid for &lt;code&gt;dotnet test&lt;/code&gt; and &lt;code&gt;dotnet build&lt;/code&gt; respectively. However, these cannot be the very first argument, so you should either use &lt;code&gt;build build --myadditionalOptions fizz buzz&lt;/code&gt;, or just specify the build-kind, i.e. this is fine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;build debug --verbosity detailed&#xA;build test --logger console;verbosity=summary&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At this moment, additional options cannot have quotes in them.&lt;/p&gt; &#xA;&lt;p&gt;Command modifiers, like &lt;code&gt;release&lt;/code&gt; and &lt;code&gt;debug&lt;/code&gt;, can be specified with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt; if you so prefer: &lt;code&gt;dotnet build /release&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Get help&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;build help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more info, see this PR: &lt;a href=&#34;https://github.com/abelbraaksma/TaskSeq/pull/29&#34;&gt;https://github.com/abelbraaksma/TaskSeq/pull/29&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Work in progress&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;taskSeq&lt;/code&gt; CE using the statically compilable &lt;em&gt;resumable state machine&lt;/em&gt; approach is based on, and draw heavily from &lt;a href=&#34;https://github.com/dotnet/fsharp/raw/d5312aae8aad650f0043f055bb14c3aa8117e12e/tests/benchmarks/CompiledCodeBenchmarks/TaskPerf/TaskPerf/taskSeq.fs&#34;&gt;Don Symes &lt;code&gt;taskSeq.fs&lt;/code&gt;&lt;/a&gt; as used to test the resumable state machine in the F# core compiler.&lt;/p&gt; &#xA;&lt;p&gt;On top of that, this library adds a set of &lt;code&gt;TaskSeq&lt;/code&gt; module functions, with their &lt;code&gt;Async&lt;/code&gt; variants, on par with &lt;code&gt;Seq&lt;/code&gt; and &lt;code&gt;AsyncSeq&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Current set of &lt;code&gt;TaskSeq&lt;/code&gt; utility functions&lt;/h2&gt; &#xA;&lt;p&gt;The following is the current surface area of the &lt;code&gt;TaskSeq&lt;/code&gt; utility functions. This is just a dump of the signatures with doc comments to be used as a quick ref.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-f#&#34;&gt;module TaskSeq =&#xA;    open System.Collections.Generic&#xA;    open System.Threading.Tasks&#xA;    open FSharp.Control.TaskSeqBuilders&#xA;&#xA;    /// Initialize an empty taskSeq.&#xA;    val empty&amp;lt;&#39;T&amp;gt; : taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns &amp;lt;see cref=&#34;true&#34; /&amp;gt; if the task sequence contains no elements, &amp;lt;see cref=&#34;false&#34; /&amp;gt; otherwise.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val isEmpty: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;bool&amp;gt;&#xA;&#xA;    /// Returns taskSeq as an array. This function is blocking until the sequence is exhausted and will properly dispose of the resources.&#xA;    val toList: t: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; &#39;T list&#xA;&#xA;    /// Returns taskSeq as an array. This function is blocking until the sequence is exhausted and will properly dispose of the resources.&#xA;    val toArray: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; &#39;T[]&#xA;&#xA;    /// Returns taskSeq as a seq, similar to Seq.cached. This function is blocking until the sequence is exhausted and will properly dispose of the resources.&#xA;    val toSeqCached: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; seq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Unwraps the taskSeq as a Task&amp;lt;array&amp;lt;_&amp;gt;&amp;gt;. This function is non-blocking.&#xA;    val toArrayAsync: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T[]&amp;gt;&#xA;&#xA;    /// Unwraps the taskSeq as a Task&amp;lt;list&amp;lt;_&amp;gt;&amp;gt;. This function is non-blocking.&#xA;    val toListAsync: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T list&amp;gt;&#xA;&#xA;    /// Unwraps the taskSeq as a Task&amp;lt;ResizeArray&amp;lt;_&amp;gt;&amp;gt;. This function is non-blocking.&#xA;    val toResizeArrayAsync: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;ResizeArray&amp;lt;&#39;T&amp;gt;&amp;gt;&#xA;&#xA;    /// Unwraps the taskSeq as a Task&amp;lt;IList&amp;lt;_&amp;gt;&amp;gt;. This function is non-blocking.&#xA;    val toIListAsync: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;IList&amp;lt;&#39;T&amp;gt;&amp;gt;&#xA;&#xA;    /// Unwraps the taskSeq as a Task&amp;lt;seq&amp;lt;_&amp;gt;&amp;gt;. This function is non-blocking,&#xA;    /// exhausts the sequence and caches the results of the tasks in the sequence.&#xA;    val toSeqCachedAsync: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;seq&amp;lt;&#39;T&amp;gt;&amp;gt;&#xA;&#xA;    /// Create a taskSeq of an array.&#xA;    val ofArray: array: &#39;T[] -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Create a taskSeq of a list.&#xA;    val ofList: list: &#39;T list -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Create a taskSeq of a seq.&#xA;    val ofSeq: sequence: seq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Create a taskSeq of a ResizeArray, aka List.&#xA;    val ofResizeArray: data: ResizeArray&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Create a taskSeq of a sequence of tasks, that may already have hot-started.&#xA;    val ofTaskSeq: sequence: seq&amp;lt;#Task&amp;lt;&#39;T&amp;gt;&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Create a taskSeq of a list of tasks, that may already have hot-started.&#xA;    val ofTaskList: list: #Task&amp;lt;&#39;T&amp;gt; list -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Create a taskSeq of an array of tasks, that may already have hot-started.&#xA;    val ofTaskArray: array: #Task&amp;lt;&#39;T&amp;gt; array -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Create a taskSeq of a seq of async.&#xA;    val ofAsyncSeq: sequence: seq&amp;lt;Async&amp;lt;&#39;T&amp;gt;&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Create a taskSeq of a list of async.&#xA;    val ofAsyncList: list: Async&amp;lt;&#39;T&amp;gt; list -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Create a taskSeq of an array of async.&#xA;    val ofAsyncArray: array: Async&amp;lt;&#39;T&amp;gt; array -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// Iterates over the taskSeq applying the action function to each item. This function is non-blocking&#xA;    /// exhausts the sequence as soon as the task is evaluated.&#xA;    val iter: action: (&#39;T -&amp;gt; unit) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&#xA;    /// Iterates over the taskSeq applying the action function to each item. This function is non-blocking,&#xA;    /// exhausts the sequence as soon as the task is evaluated.&#xA;    val iteri: action: (int -&amp;gt; &#39;T -&amp;gt; unit) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&#xA;    /// Iterates over the taskSeq applying the async action to each item. This function is non-blocking&#xA;    /// exhausts the sequence as soon as the task is evaluated.&#xA;    val iterAsync: action: (&#39;T -&amp;gt; #Task&amp;lt;unit&amp;gt;) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&#xA;    /// Iterates over the taskSeq, applying the async action to each item. This function is non-blocking,&#xA;    /// exhausts the sequence as soon as the task is evaluated.&#xA;    val iteriAsync: action: (int -&amp;gt; &#39;T -&amp;gt; #Task&amp;lt;unit&amp;gt;) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&#xA;    /// Maps over the taskSeq, applying the mapper function to each item. This function is non-blocking.&#xA;    val map: mapper: (&#39;T -&amp;gt; &#39;U) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// Maps over the taskSeq with an index, applying the mapper function to each item. This function is non-blocking.&#xA;    val mapi: mapper: (int -&amp;gt; &#39;T -&amp;gt; &#39;U) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// Maps over the taskSeq, applying the async mapper function to each item. This function is non-blocking.&#xA;    val mapAsync: mapper: (&#39;T -&amp;gt; #Task&amp;lt;&#39;U&amp;gt;) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// Maps over the taskSeq with an index, applying the async mapper function to each item. This function is non-blocking.&#xA;    val mapiAsync: mapper: (int -&amp;gt; &#39;T -&amp;gt; #Task&amp;lt;&#39;U&amp;gt;) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// Applies the given function to the items in the taskSeq and concatenates all the results in order.&#xA;    val collect: binder: (&#39;T -&amp;gt; #taskSeq&amp;lt;&#39;U&amp;gt;) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// Applies the given function to the items in the taskSeq and concatenates all the results in order.&#xA;    val collectSeq: binder: (&#39;T -&amp;gt; #seq&amp;lt;&#39;U&amp;gt;) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// Applies the given async function to the items in the taskSeq and concatenates all the results in order.&#xA;    val collectAsync: binder: (&#39;T -&amp;gt; #Task&amp;lt;&#39;TSeqU&amp;gt;) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt; when &#39;TSeqU :&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// Applies the given async function to the items in the taskSeq and concatenates all the results in order.&#xA;    val collectSeqAsync: binder: (&#39;T -&amp;gt; #Task&amp;lt;&#39;SeqU&amp;gt;) -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt; when &#39;SeqU :&amp;gt; seq&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the first element of the &amp;lt;see cref=&#34;IAsyncEnumerable&#34; /&amp;gt;, or &amp;lt;see cref=&#34;None&#34; /&amp;gt; if the sequence is empty.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;exception cref=&#34;ArgumentException&#34;&amp;gt;Thrown when the sequence is empty.&amp;lt;/exception&amp;gt;&#xA;    val tryHead: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T option&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the first element of the &amp;lt;see cref=&#34;IAsyncEnumerable&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;exception cref=&#34;ArgumentException&#34;&amp;gt;Thrown when the sequence is empty.&amp;lt;/exception&amp;gt;&#xA;    val head: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the last element of the &amp;lt;see cref=&#34;IAsyncEnumerable&#34; /&amp;gt;, or &amp;lt;see cref=&#34;None&#34; /&amp;gt; if the sequence is empty.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;exception cref=&#34;ArgumentException&#34;&amp;gt;Thrown when the sequence is empty.&amp;lt;/exception&amp;gt;&#xA;    val tryLast: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T option&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the last element of the &amp;lt;see cref=&#34;IAsyncEnumerable&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;exception cref=&#34;ArgumentException&#34;&amp;gt;Thrown when the sequence is empty.&amp;lt;/exception&amp;gt;&#xA;    val last: taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the nth element of the &amp;lt;see cref=&#34;IAsyncEnumerable&#34; /&amp;gt;, or &amp;lt;see cref=&#34;None&#34; /&amp;gt; if the sequence&#xA;    /// does not contain enough elements, or if &amp;lt;paramref name=&#34;index&#34; /&amp;gt; is negative.&#xA;    /// Parameter &amp;lt;paramref name=&#34;index&#34; /&amp;gt; is zero-based, that is, the value 0 returns the first element.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val tryItem: index: int -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T option&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the nth element of the &amp;lt;see cref=&#34;IAsyncEnumerable&#34; /&amp;gt;, or &amp;lt;see cref=&#34;None&#34; /&amp;gt; if the sequence&#xA;    /// does not contain enough elements, or if &amp;lt;paramref name=&#34;index&#34; /&amp;gt; is negative.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;exception cref=&#34;ArgumentException&#34;&amp;gt;Thrown when the sequence has insufficient length or&#xA;    /// &amp;lt;paramref name=&#34;index&#34; /&amp;gt; is negative.&amp;lt;/exception&amp;gt;&#xA;    val item: index: int -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the only element of the task sequence, or &amp;lt;see cref=&#34;None&#34; /&amp;gt; if the sequence is empty of&#xA;    /// contains more than one element.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val tryExactlyOne: source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T option&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the only element of the task sequence.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;exception cref=&#34;ArgumentException&#34;&amp;gt;Thrown when the input sequence does not contain precisely one element.&amp;lt;/exception&amp;gt;&#xA;    val exactlyOne: source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Applies the given function &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; to each element of the task sequence. Returns&#xA;    /// a sequence comprised of the results &#34;x&#34; for each element where&#xA;    /// the function returns &amp;lt;c&amp;gt;Some(x)&amp;lt;/c&amp;gt;.&#xA;    /// If &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; is asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.chooseAsync&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val choose: chooser: (&#39;T -&amp;gt; &#39;U option) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Applies the given asynchronous function &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; to each element of the task sequence. Returns&#xA;    /// a sequence comprised of the results &#34;x&#34; for each element where&#xA;    /// the function returns &amp;lt;see cref=&#34;Some(x)&#34; /&amp;gt;.&#xA;    /// If &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; does not need to be asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.choose&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val chooseAsync: chooser: (&#39;T -&amp;gt; #Task&amp;lt;&#39;U option&amp;gt;) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns a new collection containing only the elements of the collection&#xA;    /// for which the given &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; function returns &amp;lt;see cref=&#34;true&#34; /&amp;gt;.&#xA;    /// If &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; is asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.filterAsync&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val filter: predicate: (&#39;T -&amp;gt; bool) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns a new collection containing only the elements of the collection&#xA;    /// for which the given asynchronous function &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; returns &amp;lt;see cref=&#34;true&#34; /&amp;gt;.&#xA;    /// If &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; does not need to be asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.filter&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val filterAsync: predicate: (&#39;T -&amp;gt; #Task&amp;lt;bool&amp;gt;) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Applies the given function &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; to successive elements of the task sequence&#xA;    /// in &amp;lt;paramref name=&#34;source&#34; /&amp;gt;, returning the first result where the function returns &amp;lt;see cref=&#34;Some(x)&#34; /&amp;gt;.&#xA;    /// If &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; is asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.tryPickAsync&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val tryPick: chooser: (&#39;T -&amp;gt; &#39;U option) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;U option&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Applies the given asynchronous function &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; to successive elements of the task sequence&#xA;    /// in &amp;lt;paramref name=&#34;source&#34; /&amp;gt;, returning the first result where the function returns &amp;lt;see cref=&#34;Some(x)&#34; /&amp;gt;.&#xA;    /// If &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; does not need to be asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.tryPick&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val tryPickAsync: chooser: (&#39;T -&amp;gt; #Task&amp;lt;&#39;U option&amp;gt;) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;U option&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the first element of the task sequence in &amp;lt;paramref name=&#34;source&#34; /&amp;gt; for which the given function&#xA;    /// &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; returns &amp;lt;see cref=&#34;true&#34; /&amp;gt;. Returns &amp;lt;see cref=&#34;None&#34; /&amp;gt; if no such element exists.&#xA;    /// If &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; is asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.tryFindAsync&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val tryFind: predicate: (&#39;T -&amp;gt; bool) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T option&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the first element of the task sequence in &amp;lt;paramref name=&#34;source&#34; /&amp;gt; for which the given asynchronous function&#xA;    /// &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; returns &amp;lt;see cref=&#34;true&#34; /&amp;gt;. Returns &amp;lt;see cref=&#34;None&#34; /&amp;gt; if no such element exists.&#xA;    /// If &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; does not need to be asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.tryFind&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val tryFindAsync: predicate: (&#39;T -&amp;gt; #Task&amp;lt;bool&amp;gt;) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T option&amp;gt;&#xA;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Applies the given function &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; to successive elements of the task sequence&#xA;    /// in &amp;lt;paramref name=&#34;source&#34; /&amp;gt;, returning the first result where the function returns &amp;lt;see cref=&#34;Some(x)&#34; /&amp;gt;.&#xA;    /// If &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; is asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.pickAsync&#34; /&amp;gt;.&#xA;    /// &amp;lt;exception cref=&#34;KeyNotFoundException&#34;&amp;gt;Thrown when every item of the sequence&#xA;    /// evaluates to &amp;lt;see cref=&#34;None&#34; /&amp;gt; when the given function is applied.&amp;lt;/exception&amp;gt;&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val pick: chooser: (&#39;T -&amp;gt; &#39;U option) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Applies the given asynchronous function &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; to successive elements of the task sequence&#xA;    /// in &amp;lt;paramref name=&#34;source&#34; /&amp;gt;, returning the first result where the function returns &amp;lt;see cref=&#34;Some(x)&#34; /&amp;gt;.&#xA;    /// If &amp;lt;paramref name=&#34;chooser&#34; /&amp;gt; does not need to be asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.pick&#34; /&amp;gt;.&#xA;    /// &amp;lt;exception cref=&#34;KeyNotFoundException&#34;&amp;gt;Thrown when every item of the sequence&#xA;    /// evaluates to &amp;lt;see cref=&#34;None&#34; /&amp;gt; when the given function is applied.&amp;lt;/exception&amp;gt;&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val pickAsync: chooser: (&#39;T -&amp;gt; #Task&amp;lt;&#39;U option&amp;gt;) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;U&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the first element of the task sequence in &amp;lt;paramref name=&#34;source&#34; /&amp;gt; for which the given function&#xA;    /// &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; returns &amp;lt;see cref=&#34;true&#34; /&amp;gt;.&#xA;    /// If &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; is asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.findAsync&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;exception cref=&#34;KeyNotFoundException&#34;&amp;gt;Thrown if no element returns &amp;lt;see cref=&#34;true&#34; /&amp;gt; when&#xA;    /// evaluated by the &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; function.&amp;lt;/exception&amp;gt;&#xA;    val find: predicate: (&#39;T -&amp;gt; bool) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Returns the first element of the task sequence in &amp;lt;paramref name=&#34;source&#34; /&amp;gt; for which the given&#xA;    /// asynchronous function &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; returns &amp;lt;see cref=&#34;true&#34; /&amp;gt;.&#xA;    /// If &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; does not need to be asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.find&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;exception cref=&#34;KeyNotFoundException&#34;&amp;gt;Thrown if no element returns &amp;lt;see cref=&#34;true&#34; /&amp;gt; when&#xA;    /// evaluated by the &amp;lt;paramref name=&#34;predicate&#34; /&amp;gt; function.&amp;lt;/exception&amp;gt;&#xA;    val findAsync: predicate: (&#39;T -&amp;gt; #Task&amp;lt;bool&amp;gt;) -&amp;gt; source: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;T&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Zips two task sequences, returning a taskSeq of the tuples of each sequence, in order. May raise ArgumentException&#xA;    /// if the sequences are or unequal length.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;exception cref=&#34;ArgumentException&#34;&amp;gt;The sequences have different lengths.&amp;lt;/exception&amp;gt;&#xA;    val zip: taskSeq1: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; taskSeq2: taskSeq&amp;lt;&#39;U&amp;gt; -&amp;gt; IAsyncEnumerable&amp;lt;&#39;T * &#39;U&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Applies the function &amp;lt;paramref name=&#34;folder&#34; /&amp;gt; to each element in the task sequence,&#xA;    /// threading an accumulator argument of type &amp;lt;paramref name=&#34;&#39;State&#34; /&amp;gt; through the computation.&#xA;    /// If the accumulator function &amp;lt;paramref name=&#34;folder&#34; /&amp;gt; is asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.foldAsync&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val fold: folder: (&#39;State -&amp;gt; &#39;T -&amp;gt; &#39;State) -&amp;gt; state: &#39;State -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;State&amp;gt;&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Applies the asynchronous function &amp;lt;paramref name=&#34;folder&#34; /&amp;gt; to each element in the task sequence,&#xA;    /// threading an accumulator argument of type &amp;lt;paramref name=&#34;&#39;State&#34; /&amp;gt; through the computation.&#xA;    /// If the accumulator function &amp;lt;paramref name=&#34;folder&#34; /&amp;gt; does not need to be asynchronous, consider using &amp;lt;see cref=&#34;TaskSeq.fold&#34; /&amp;gt;.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    val foldAsync: folder: (&#39;State -&amp;gt; &#39;T -&amp;gt; #Task&amp;lt;&#39;State&amp;gt;) -&amp;gt; state: &#39;State -&amp;gt; taskSeq: taskSeq&amp;lt;&#39;T&amp;gt; -&amp;gt; Task&amp;lt;&#39;State&amp;gt;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>