<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-04T01:33:49Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>thinkbeforecoding/Fargo</title>
    <updated>2023-08-04T01:33:49Z</updated>
    <id>tag:github.com,2023-08-04:/thinkbeforecoding/Fargo</id>
    <link href="https://github.com/thinkbeforecoding/Fargo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A functional command line argument parser with builtin completion.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Fargo&lt;/h1&gt; &#xA;&lt;p&gt;A reflectionless command line argument parser with integrated auto completion.&lt;/p&gt; &#xA;&lt;p&gt;Fargo features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An functorial, applicative, monadic and alternative style to avoid reflection&lt;/li&gt; &#xA; &lt;li&gt;Reflection free, Fargo can be used with AOT&lt;/li&gt; &#xA; &lt;li&gt;Typed, the parsed data is validated&lt;/li&gt; &#xA; &lt;li&gt;Error reporting&lt;/li&gt; &#xA; &lt;li&gt;Usage and help auto generation&lt;/li&gt; &#xA; &lt;li&gt;Extensible auto-completion&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Fargo is distributed as a nuget &lt;a href=&#34;https://www.nuget.org/packages/Fargo.CmdLine&#34;&gt;Fargo.CmdLine&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;dotnet add package Fargo.CmdLine&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In a fsx script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &#34;nuget: Fargo.CmdLine&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can try it with this simple hello world. Create a hello project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;dotnet new console -lang F# -o ./hello&#xA;cd ./hello&#xA;dotnet add package Fargo.CmdLine&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and edit the &lt;code&gt;Program.fs&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Fargo&#xA;&#xA;let parser = opt &#34;text&#34; &#34;t&#34; &#34;text&#34; &#34;The text to display&#34; |&amp;gt; reqOpt&#xA;&#xA;[&amp;lt;EntryPoint&amp;gt;]&#xA;let main args =&#xA;    run &#34;hello&#34; parser args (fun ct text -&amp;gt;&#xA;        task { printfn &#34;%s&#34; text; return 0; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;build the project&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;dotnet build -c Release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and add the output path to the &lt;code&gt;PATH&lt;/code&gt; environment variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;$p = Resolve-Path .\bin\Release\net7.0\&#xA;$env:PATH += &#34;;$p&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the program&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;hello --text &#34;Hello world!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To display help:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;hello --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will display:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: --text &amp;lt;text&amp;gt; &#xA;Arguments:&#xA;    --text, -t &amp;lt;text&amp;gt;       The text to display&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If arguments are missing or incorrect, a detailed error is returned:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;hello&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;hello&#xA;Required argument --text not found&#xA;&#xA;Usage: --text &amp;lt;text&amp;gt;&#xA;Arguments:&#xA;    --text, -t &amp;lt;text&amp;gt;       The text to display&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To enable completion in powershell, execute the following line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;hello completion powershell | out-string | invoke-expression&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This line can be added to the $Profile.CurrentUserAllHost file to enable completion for every new session.&lt;/p&gt; &#xA;&lt;p&gt;Now, type &lt;code&gt;hello&lt;/code&gt; followed by a space, and press tab or Ctrl+Space. The arguments are suggested.&lt;/p&gt; &#xA;&lt;h2&gt;Arg&amp;lt;&#39;t&amp;gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Arg&amp;lt;&#39;t&amp;gt;&lt;/code&gt; is the type of a command line parser in Fargo.&lt;/p&gt; &#xA;&lt;h2&gt;Flag&lt;/h2&gt; &#xA;&lt;p&gt;Flags are declared using the &lt;code&gt;flag&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;flag &#34;force&#34; &#34;f&#34; &#34;force the copy&#34; // Arg&amp;lt;bool&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;this creates a &lt;code&gt;--force&lt;/code&gt; flag with a &lt;code&gt;-f&lt;/code&gt; shortcut.&lt;/p&gt; &#xA;&lt;p&gt;A flag creates an &lt;code&gt;Arg&amp;lt;bool&amp;gt;&lt;/code&gt; with a value of &lt;code&gt;Success true&lt;/code&gt; when specified and a value of &lt;code&gt;Success false&lt;/code&gt; otherwise.&lt;/p&gt; &#xA;&lt;p&gt;When the second argument is &lt;code&gt;null&lt;/code&gt; the flag has no short alternate version.&lt;/p&gt; &#xA;&lt;h2&gt;ReqFlag&lt;/h2&gt; &#xA;&lt;p&gt;A flag can be made mandatory by using the &lt;code&gt;reqFlag&lt;/code&gt;function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;flag &#34;force&#34; &#34;f&#34; &#34;force the copy&#34; |&amp;gt; reqFlag // Arg&amp;lt;bool&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It creates an &lt;code&gt;Arg&amp;lt;bool&amp;gt;&lt;/code&gt; with a value of &lt;code&gt;Success true&lt;/code&gt; when specified and a value of &lt;code&gt;Failure [&#34;Required flag --force not found&#34;]&lt;/code&gt; otherwise&lt;/p&gt; &#xA;&lt;h2&gt;Arg&lt;/h2&gt; &#xA;&lt;p&gt;Arguments accept a positional value, and are optional by default:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;arg &#34;value&#34; &#34;the value&#34; // Arg&amp;lt;string option&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Arguments are positional contrary to &lt;a href=&#34;https://raw.githubusercontent.com/thinkbeforecoding/Fargo/main/#opt&#34;&gt;options&lt;/a&gt; which are named&lt;/p&gt; &#xA;&lt;p&gt;It creates an &lt;code&gt;Arg&amp;lt;string option&amp;gt;&lt;/code&gt; with a value of &lt;code&gt;Success(Some &#34;a value&#34;)&lt;/code&gt; containing the value when specified, and &lt;code&gt;Success None&lt;/code&gt; otherwise.&lt;/p&gt; &#xA;&lt;p&gt;When the second argument is &lt;code&gt;null&lt;/code&gt; the flag has no short alternate version.&lt;/p&gt; &#xA;&lt;h2&gt;ReqArg&lt;/h2&gt; &#xA;&lt;p&gt;To make an argument required, use the &lt;code&gt;reqArg&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;arg &#34;value&#34; &#34;the value&#34; |&amp;gt; reqArg |&amp;gt; Arg&amp;lt;string&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It creates an &lt;code&gt;Arg&amp;lt;string&amp;gt;&lt;/code&gt; with a value of &lt;code&gt;Success &#34;a value&#34;&lt;/code&gt; containing the value when specified, and &lt;code&gt;Failure [&#34;Require argument --value not found&#34;]&lt;/code&gt; otherwise.&lt;/p&gt; &#xA;&lt;p&gt;The first parameter is used as a placeholder in the usage syntax.&lt;/p&gt; &#xA;&lt;h2&gt;Opt&lt;/h2&gt; &#xA;&lt;p&gt;Options accept a named value, and are optional by default:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;opt &#34;name&#34; &#34;n&#34; &#34;the-name&#34; &#34;the name&#34; // Arg&amp;lt;string option&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It creates an &lt;code&gt;Arg&amp;lt;string option&amp;gt;&lt;/code&gt; with a value of &lt;code&gt;Success(Some &#34;a value&#34;)&lt;/code&gt; containing the value when specified, and &lt;code&gt;Success None&lt;/code&gt; otherwise.&lt;/p&gt; &#xA;&lt;p&gt;When the second argument is &lt;code&gt;null&lt;/code&gt; the flag has no short alternate version.&lt;/p&gt; &#xA;&lt;p&gt;The third parameter is used as a placeholder in the usage syntax.&lt;/p&gt; &#xA;&lt;h2&gt;ReqArg&lt;/h2&gt; &#xA;&lt;p&gt;To make an argument required, use the &lt;code&gt;reqArg&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;opt &#34;name&#34; &#34;n&#34; &#34;the-name&#34; &#34;the name&#34; |&amp;gt; reqOpt |&amp;gt; Arg&amp;lt;string&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It creates an &lt;code&gt;Arg&amp;lt;string&amp;gt;&lt;/code&gt; with a value of &lt;code&gt;Success &#34;a value&#34;&lt;/code&gt; containing the value when specified, and &lt;code&gt;Failure [&#34;Require argument --value not found&#34;]&lt;/code&gt; otherwise.&lt;/p&gt; &#xA;&lt;h2&gt;Map&lt;/h2&gt; &#xA;&lt;p&gt;To change the type of the return value of any &lt;code&gt;Arg&amp;lt;&#39;t&amp;gt;&lt;/code&gt;, use the &lt;code&gt;map&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;map: (&#39;a -&amp;gt; &#39;b) -&amp;gt; Arg&amp;lt;&#39;a&amp;gt; -&amp;gt; Arg&amp;lt;&#39;b&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It works best with required arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;arg &#34;value&#34; &#34;v&#34; &#34;the value&#34; |&amp;gt; reqArg |&amp;gt; map int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This returns an &lt;code&gt;Arg&amp;lt;int&amp;gt;&lt;/code&gt; that contains the argument value converted to &lt;code&gt;int&lt;/code&gt;. However, any input that cannot be converted to string will throw an exception. To avoid this, use &lt;code&gt;parse&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;OptMap&lt;/h3&gt; &#xA;&lt;p&gt;For optional arguments, use &lt;code&gt;optMap&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;optMap: (&#39;a -&amp;gt; &#39;b) -&amp;gt; Arg&amp;lt;&#39;a option&amp;gt; -&amp;gt; Arg&amp;lt;&#39;b option&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function is applied to the value inside the option. As for &lt;code&gt;map&lt;/code&gt; a problem with the conversion will raise an exception. To avoid this, use &lt;code&gt;optParse&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Parse&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;parse (&#39;a -&amp;gt; Result&amp;lt;&#39;b, string&amp;gt;) -&amp;gt; Arg&amp;lt;&#39;a&amp;gt; -&amp;gt; Arg&amp;lt;&#39;b&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function passed to the &lt;code&gt;parse&lt;/code&gt; functions returns a &lt;code&gt;Result&amp;lt;&#39;b,string&amp;gt;&lt;/code&gt; that can represent a success or an failure with the error message. In case of error, the parser result will contain the error message.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open System&#xA;open System.Globalization&#xA;let tryParseInt (input: string) =&#xA;    match Int32.TryParse(input, CultureInfo.InvariantCulture) with&#xA;    | true, value -&amp;gt; Ok value&#xA;    | false, _ -&amp;gt; Error &#34;Input value is not an integer&#34;&#xA;&#xA;arg &#34;value&#34; &#34;v&#34; &#34;the value&#34; |&amp;gt; reqArg |&amp;gt; parse tryParseInt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of throwing an exception, a parsing failure will be returned. This is especially important for &lt;a href=&#34;https://raw.githubusercontent.com/thinkbeforecoding/Fargo/main/#Alternatives&#34;&gt;Alternatives&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;OptParse&lt;/h3&gt; &#xA;&lt;p&gt;This function is equivalent to &lt;code&gt;parse&lt;/code&gt; for optional arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;optParse (&#39;a -&amp;gt; Result&amp;lt;&#39;b, string&amp;gt;) -&amp;gt; Arg&amp;lt;&#39;a option&amp;gt; -&amp;gt; Arg&amp;lt;&#39;b option&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;arg &#34;value&#34; &#34;v&#34; &#34;the value&#34; |&amp;gt; optParse tryParseInt // Arg&amp;lt;int option&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;DefaultValue&lt;/h3&gt; &#xA;&lt;p&gt;This function is used to specify a default value for optional arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;defaultValue: &#39;a -&amp;gt; Arg&amp;lt;&#39;a option&amp;gt; -&amp;gt; Arg&amp;lt;&#39;a&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;arg &#34;value&#34; &#34;v&#34; &#34;the value&#34;&#xA;|&amp;gt; optParse tryParseInt&#xA;|&amp;gt; defaultValue 0 // Arg&amp;lt;int&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, when the argument is not specified, the value will be 0. When specified, it will be an int if it can be correctly parsed, or return an error otherwise.&lt;/p&gt; &#xA;&lt;h3&gt;Completer&lt;/h3&gt; &#xA;&lt;p&gt;A custom completer can be specified to enable completion on argument values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;argc &#34;value&#34; &#34;the value&#34; (Completer.choices [&#34;one&#34;; &#34;two&#34;; &#34;three&#34; ])&#xA;optc &#34;name&#34; &#34;n&#34; &#34;value&#34; &#34;the name&#34; (Completer.choices [&#34;a&#34;; &#34;b&#34;; &#34;c&#34; ])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pressing the &lt;code&gt;tab&lt;/code&gt; key after &lt;code&gt;--name&lt;/code&gt; will suggest one of the specified values.&lt;/p&gt; &#xA;&lt;p&gt;The function passed must have the following signature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Token list -&amp;gt; string list&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The input string is the text of the argument value when completion is requested. The token list contains all tokens that have not been parsed yet. The function should return a list of suggested values as strings.&lt;/p&gt; &#xA;&lt;h2&gt;Map2 and Applicatives&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;map2&lt;/code&gt; function can be used to combine two arguments together:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;map2: (&#39;a -&amp;gt; &#39;b -&amp;gt; &#39;c) -&amp;gt; Arg&amp;lt;&#39;a&amp;gt; -&amp;gt; Arg&amp;lt;&#39;b&amp;gt; -&amp;gt; Arg&amp;lt;&#39;c&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The specified function is used to combine the values of the two passed arguments. The result is an argument with combined results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;map2 (fun firstName lastName -&amp;gt; firstName + &#34; &#34; + lastName)&#xA;     (arg &#34;first-name&#34; &#34;f&#34; &#34;The user firstname&#34; |&amp;gt; reqArg)&#xA;     (arg &#34;last-name&#34; &#34;l&#34; &#34;The user last name&#34; |&amp;gt; reqArg)&#xA;     // Arg&amp;lt;string&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Is is clearer to use the applicative computation expression &lt;code&gt;fargo&lt;/code&gt; instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;fargo {&#xA;    let! firstName = arg &#34;first-name&#34; &#34;The user firstname&#34; |&amp;gt; reqArg&#xA;    and! lastName = arg &#34;last-name&#34; &#34;The user last name&#34; |&amp;gt; reqArg&#xA;    return firstName + &#34; &#34; + lastName&#xA;}    // Arg&amp;lt;string&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is of course possible to combine values in different ways, especially in a tuple or a record, and to bind more values using &lt;code&gt;and!&lt;/code&gt; :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type User = &#xA;    { FirstName: string&#xA;      LastName string&#xA;      Age: int option }&#xA;&#xA;fargo {&#xA;    let! firstName = arg &#34;first-name&#34; &#34;The user firstname&#34; |&amp;gt; reqArg&#xA;    and! lastName = arg &#34;last-name&#34; &#34;The user last name&#34; |&amp;gt; reqArg&#xA;    and! age = opt &#34;age&#34; null &#34;age&#34; &#34;The user age&#34; |&amp;gt; optParse tryParseInt&#xA;    return { FirstName = firstName&#xA;             LastName = lastName&#xA;             Age = age }&#xA;}   // Arg&amp;lt;User&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cmd&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;cmd&lt;/code&gt; function create a command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;cmd &#34;load&#34; &#34;ld&#34; &#34;Loads the document&#34; // Arg&amp;lt;string&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Contrary to flags and args which can be matched at any position, a command is always matched in the first position. Its value is the name of the command itself. In the example above, the value will be &lt;code&gt;&#34;load&#34;&lt;/code&gt; even if the alternate short version is used.&lt;/p&gt; &#xA;&lt;p&gt;When the second argument is &lt;code&gt;null&lt;/code&gt;, the command has no short alternate version.&lt;/p&gt; &#xA;&lt;h2&gt;Alternatives&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; operator can be used to combine two parsers together. This is especially useful for commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;(cmd &#34;load&#34; &#34;ld&#34; &#34;loads the document&#34;)&#xA;&amp;lt;|&amp;gt; (cmd &#34;save&#34; &#34;sv&#34; &#34;saves the document&#34;)&#xA;    // Arg&amp;lt;string&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the command on the left matches, its value is returned. Otherwise, the second command is tested.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; can be used multiple times to combine more commands.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Cmd = Load | Save | Delete&#xA;(cmd &#34;load&#34; &#34;ld&#34; &#34;loads the document&#34; |~&amp;gt; Load)&#xA;&amp;lt;|&amp;gt; (cmd &#34;save&#34; &#34;sv&#34; &#34;saves the document&#34; |~&amp;gt; Save)&#xA;&amp;lt;|&amp;gt; (cmd &#34;delete&#34; &#34;del&#34; &#34;deletes the document&#34; |~&amp;gt; Delete)&#xA;&amp;lt;|&amp;gt; (error &#34;Invalid file command&#34;) &#xA;&#xA;// Arg&amp;lt;Cmd&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, for each command the &lt;code&gt;|~&amp;gt;&lt;/code&gt; operator is used to replace the original &lt;code&gt;string&lt;/code&gt; value, which is the name of the command, with the supplied value.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;error&lt;/code&gt; function creates an &lt;code&gt;Arg&amp;lt;&#39;t&amp;gt;&lt;/code&gt; that always fails with specified error message. It will be used only if all of the commands above fail, displaying a specific error message.&lt;/p&gt; &#xA;&lt;h2&gt;Bind and Monads&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;bind: (&#39;a -&amp;gt; Arg&amp;lt;&#39;b&amp;gt;) -&amp;gt; Arg&amp;lt;&#39;a&amp;gt; -&amp;gt; Arg&amp;lt;&#39;b&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The use of &lt;code&gt;bind&lt;/code&gt; directly is discouraged, prefer the computation expression:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type FileCmd = Load | Save&#xA;type Command =&#xA;| Load of string&#xA;| Save of string * bool&#xA;fargo {&#xA;    match! (cmd &#34;load&#34; &#34;ld&#34; &#34;loads the document&#34; |~&amp;gt; FileCmd.Load)&#xA;           &amp;lt;|&amp;gt; (cmd &#34;save&#34; &#34;sv&#34; &#34;saves the document&#34; |~&amp;gt; FileCmd.Save)&#xA;           &amp;lt;|&amp;gt; (error &#34;Invalid file command&#34;)  with&#xA;    | FileCmd.Load -&amp;gt;&#xA;        let! path = opt &#34;path&#34; &#34;p&#34; &#34;path&#34; &#34;the path&#34;&#xA;        return Load path&#xA;    | FileCmd.Load -&amp;gt;&#xA;        let! path = opt &#34;path&#34; &#34;p&#34; &#34;path&#34; &#34;the path&#34;&#xA;        and! force = flag &#34;force&#34; &#34;f&#34; &#34;overwrite file&#34;&#xA;        return Save(path, force)&#xA;} // Arg&amp;lt;Command&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using a &lt;code&gt;let!&lt;/code&gt; (&lt;code&gt;match!&lt;/code&gt; is a shortcut for a &lt;code&gt;let!&lt;/code&gt; followed by a &lt;code&gt;match&lt;/code&gt;) followed by another &lt;code&gt;let!&lt;/code&gt; combine them as nested levels. If the match of the command fails, the usage will display commands from the alternative. If it succeeds, the usage will display the arguments of the returned cases.&lt;/p&gt; &#xA;&lt;p&gt;Since commands return their name, it is possible to match directly on it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Command =&#xA;| Load of string&#xA;| Save of string * bool&#xA;fargo {&#xA;    match! cmd &#34;load&#34; &#34;ld&#34; &#34;loads the document&#34;&#xA;           &amp;lt;|&amp;gt; cmd &#34;save&#34; &#34;sv&#34; &#34;saves the document&#34; with&#xA;    | &#34;load&#34; -&amp;gt; &#xA;        let! path = opt &#34;path&#34; &#34;p&#34; &#34;path&#34; &#34;the path&#34;&#xA;        return Load path&#xA;    | &#34;save&#34; -&amp;gt;&#xA;        let! path = opt &#34;path&#34; &#34;p&#34; &#34;path&#34; &#34;the path&#34;&#xA;        and! force = flag &#34;force&#34; &#34;f&#34; &#34;overwrite file&#34;&#xA;        return Save(path, force)&#xA;    | _ -&amp;gt; return error &#34;Unknown command&#34;&#xA;} // Arg&amp;lt;Command&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To define a default command, just handle it in the default case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Command =&#xA;| Load of string&#xA;| Save of string * bool&#xA;| Touch of string&#xA;fargo {&#xA;    match! cmd &#34;load&#34; &#34;ld&#34; &#34;loads the document&#34;&#xA;           &amp;lt;|&amp;gt; cmd &#34;save&#34; &#34;sv&#34; &#34;saves the document&#34; with&#xA;    | &#34;load&#34; -&amp;gt; &#xA;        let! path = opt &#34;path&#34; &#34;p&#34; &#34;path&#34; &#34;the path&#34;&#xA;        return Load path&#xA;    | &#34;save&#34; -&amp;gt;&#xA;        let! path = opt &#34;path&#34; &#34;p&#34; &#34;path&#34; &#34;the path&#34;&#xA;        and! force = flag &#34;force&#34; &#34;f&#34; &#34;overwrite file&#34;&#xA;        return Save(path, force)&#xA;    | _ -&amp;gt;&#xA;        let! path = opt &#34;path&#34; &#34;p&#34; &#34;path&#34; &#34;the path&#34;&#xA;        return Touch path&#xA;} // Arg&amp;lt;Command&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using another nested level of &lt;code&gt;let!&lt;/code&gt; or &lt;code&gt;match!&lt;/code&gt; it is possible to create sub-commands.&lt;/p&gt; &#xA;&lt;h2&gt;Ret&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;ret&lt;/code&gt; function can be used to return a constant value. It can also be used for default command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type FileCmd = Load | Save | Touch&#xA;type Command =&#xA;| Load of string&#xA;| Save of string * bool&#xA;| Touch of string&#xA;fargo {&#xA;    match! (cmd &#34;load&#34; &#34;ld&#34; &#34;loads the document&#34; |~&amp;gt; FileCmd.Load)&#xA;           &amp;lt;|&amp;gt; (cmd &#34;save&#34; &#34;sv&#34; &#34;saves the document&#34; |~&amp;gt; FileCmd.Save)&#xA;           &amp;lt;|&amp;gt; (ret FileCmd.Touch)  with&#xA;    | FileCmd.Load -&amp;gt;&#xA;        let! path = arg &#34;path&#34; &#34;p&#34; &#34;the path&#34;&#xA;        return Load path&#xA;    | FileCmd.Load -&amp;gt;&#xA;        let! path = arg &#34;path&#34; &#34;p&#34; &#34;the path&#34;&#xA;        and! force = flag &#34;force&#34; &#34;f&#34; &#34;overwrite file&#34;&#xA;        return Save(path, force)&#xA;    | FileCmd.Touch -&amp;gt;&#xA;        let! path = arg &#34;path&#34; &#34;p&#34; &#34;the path&#34;&#xA;        return Touch path}&#xA;    // Arg&amp;lt;Command&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or to give default value to optional arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;arg &#34;value&#34; &#34;v&#34; &#34;the value&#34; &amp;lt;|&amp;gt; optParse tryParseInt &amp;lt;|&amp;gt; ret 0 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Pipe / OrPipe&lt;/h2&gt; &#xA;&lt;p&gt;It is possible to get values from standard input. The &lt;code&gt;Pipe.pipe&lt;/code&gt; value is an &lt;code&gt;Arg&amp;lt;string list&amp;gt;&lt;/code&gt; that returns lines read from the standard input. It fails if the input has not been redirected. If the pipe contains no value, it succeeds with an empty list. Use &lt;code&gt;nonEmpty&lt;/code&gt; to ensure there is at list one element.&lt;/p&gt; &#xA;&lt;p&gt;To enable a parameter to be specified either directly or from the pipe, use the &lt;code&gt;Pipe.orPipe&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;arg &#34;value&#34; &#34;v&#34; &#34;the value&#34;&#xA;|&amp;gt; Pipe.orPipe&#xA;|&amp;gt; nonEmpty &#34;The required argument --value is missing&#34;&#xA;|&amp;gt; listParse (Int32.tryParse &#34;Invalid value&#34;)&#xA;// Arg&amp;lt;int list&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The argument returns a list of values, and fails if no value has been provided, either using the argument or the pipe.&lt;/p&gt; &#xA;&lt;h2&gt;Run&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; function runs a parser:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let p =&#xA;    fargo { ... }&#xA;&#xA;[&amp;lt;EntryPoint&amp;gt;]&#xA;let main (args: string[]) =&#xA;    run &#34;myapp&#34; p args (fun ct cmd -&amp;gt;&#xA;        task {&#xA;            // excution of match commands here...&#xA;            return 0&#xA;        }&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first argument of the &lt;code&gt;run&lt;/code&gt; function is the name of the application. It is used in the usage, and to generate the shell completion script.&lt;/p&gt; &#xA;&lt;p&gt;The second argument is the parser, followed by the application argument array. Finally, the last argument is a function that use the result of the parsing to execute the commands.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;run&lt;/code&gt; takes in charge:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the parsing&lt;/li&gt; &#xA; &lt;li&gt;displaying the error returned by the parser&lt;/li&gt; &#xA; &lt;li&gt;showing usage on error, or when the --help flag is used&lt;/li&gt; &#xA; &lt;li&gt;the tab completion&lt;/li&gt; &#xA; &lt;li&gt;emitting code for shell tab completion integration&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>