<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-02T01:29:41Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SteveGilham/altcover</title>
    <updated>2024-01-02T01:29:41Z</updated>
    <id>tag:github.com,2024-01-02:/SteveGilham/altcover</id>
    <link href="https://github.com/SteveGilham/altcover" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cross-platform coverage gathering and processing tool set for dotnet/.Net Framework and Mono&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;altcover&lt;/h1&gt; &#xA;&lt;p&gt;Instrumenting coverage tool for .net (framework 2.0+ and core) and Mono, reimplemented and extended almost beyond recognition from &lt;a href=&#34;https://github.com/SteveGilham/dot-net-coverage&#34;&gt;dot-net-coverage&lt;/a&gt;, plus a set of related utilities for processing the results from this and from other programs producing similar output formats.&lt;/p&gt; &#xA;&lt;h2&gt;Never mind the fluff -- how do I get started?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Start with the &lt;a href=&#34;https://github.com/SteveGilham/altcover/wiki/QuickStart-Guide&#34;&gt;Quick Start guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Read the &lt;a href=&#34;https://github.com/SteveGilham/altcover/wiki/FAQ&#34;&gt;FAQ&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The latest releases can be downloaded from &lt;a href=&#34;https://github.com/SteveGilham/altcover/releases&#34;&gt;releases&lt;/a&gt;, but the easiest (and most automated) way is through the &lt;a href=&#34;https://raw.githubusercontent.com/SteveGilham/altcover/master/#nuget-packages&#34;&gt;nuget packages&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s in the box?&lt;/h2&gt; &#xA;&lt;p&gt;For Mono, .net framework and .net core, except as noted&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AltCover&lt;/code&gt;, a command-line tool for recording code coverage (including dotnet and global tool versions)&lt;/li&gt; &#xA; &lt;li&gt;MSBuild tasks to drive the tool, including &lt;code&gt;dotnet test&lt;/code&gt; integration&lt;/li&gt; &#xA; &lt;li&gt;An API for the above functionality, with Fake and Cake integration&lt;/li&gt; &#xA; &lt;li&gt;A PowerShell module for PowerShell 5.1 and PowerShell Core 6+ containing a cmdlet that drives the tool, and other cmdlets for manipulating coverage reports&lt;/li&gt; &#xA; &lt;li&gt;A coverage visualizer tool &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;For .net framework and mono (for .net framework, needs GTK# v2.12.xx installed separately -- see &lt;a href=&#34;https://www.mono-project.com/download/stable/#download-win&#34;&gt;https://www.mono-project.com/download/stable/#download-win&lt;/a&gt; )&lt;/li&gt; &#xA;   &lt;li&gt;For .net core : uses the cross-platform AvaloniaUI toolkit &lt;img src=&#34;https://github.com/SteveGilham/altcover/raw/master/AltCover.Visualizer/Screenshot-Avalonia.png&#34; alt=&#34;Visualizer screenshot&#34;&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;NuGet Packages&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/AltCover&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/AltCover&#34; alt=&#34;Nuget&#34;&gt; General purpose install&lt;/a&gt; -- excludes the &lt;code&gt;dotnet test&lt;/code&gt; API with FAKE and CAKE integration and the AvaloniaUI visualizer&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/AltCover.api&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/altcover.api&#34; alt=&#34;Nuget&#34;&gt; API install&lt;/a&gt; -- excludes the visualizer in all forms&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/AltCover.global&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/altcover.global&#34; alt=&#34;Nuget&#34;&gt; dotnet global tool install&lt;/a&gt; -- excludes the visualizer in all forms&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/AltCover.visualizer&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/altcover.visualizer&#34; alt=&#34;Nuget&#34;&gt; Visualizer dotnet global tool&lt;/a&gt; -- just the .net core/Avalonia Visualizer as a global tool&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/AltCover.Fake&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/altcover.fake&#34; alt=&#34;Nuget&#34;&gt; FAKE build task utilities&lt;/a&gt; -- just AltCover related helper types for FAKE scripts (v5.23.0 or later), only in this package&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nuget.org/packages/AltCover.Cake&#34;&gt;&lt;img src=&#34;https://buildstats.info/nuget/altcover.cake&#34; alt=&#34;Nuget&#34;&gt; Cake build task utilities&lt;/a&gt; -- just AltCover related helper types for Cake scripts (v2.0.0 or later), only in this package&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Why altcover?&lt;/h2&gt; &#xA;&lt;p&gt;As the name suggests, it&#39;s an alternative coverage approach. Rather than working by hooking the .net profiling API at run-time, it works by weaving the same sort of extra IL into the assemblies of interest ahead of execution. This means that it should work pretty much everywhere, whatever your platform, so long as the executing process has write access to the results file. You can even mix-and-match between platforms used to instrument and those under test.&lt;/p&gt; &#xA;&lt;p&gt;In particular, while instrumenting .net core assemblies &#34;just works&#34; with this approach, it also supports Mono, as long as suitable &lt;code&gt;.mdb&lt;/code&gt; (or &lt;code&gt;.pdb&lt;/code&gt;, in recent versions) symbols are available. One major limitation here is that the &lt;code&gt;.mdb&lt;/code&gt; format only stores the start location in the source of any code sequence point, and not the end; consequently any nicely coloured reports that take that information into account may show a bit strangely.&lt;/p&gt; &#xA;&lt;h3&gt;Why altcover? -- the back-story of why it was ever a thing&lt;/h3&gt; &#xA;&lt;p&gt;Back in 2010, the new .net version finally removed the deprecated profiling APIs that the free NCover 1.5.x series relied upon. The first version of AltCover was written to both fill a gap in functionality, and to give me an excuse for a ground-up F# project to work on. As such, it saw real production use for about a year and a half, until &lt;a href=&#34;https://github.com/OpenCover/opencover&#34;&gt;OpenCover&lt;/a&gt; reached a point where it could be used for .net4/x64 work (and I could find time to adapt everything downstream that consumed NCover format input).&lt;/p&gt; &#xA;&lt;p&gt;Fast forwards to autumn 2017, and I get the chance to dust the project off, with the intention of saying that it worked on Mono, too -- and realise that it&#39;s &lt;em&gt;d√©ja vu&lt;/em&gt; all over again, because .net core didn&#39;t yet have profiler based coverage tools either, and the same approach would work there as well.&lt;/p&gt; &#xA;&lt;h2&gt;Continuous Integration&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Build&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;sup&gt;GitHub&lt;/sup&gt; &lt;a href=&#34;https://github.com/SteveGilham/altcover/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/SteveGilham/altcover/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://github.com/SteveGilham/altcover/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://buildstats.info/github/chart/SteveGilham/altcover?branch=master&#34; alt=&#34;Build history&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Test coverage&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;sup&gt;Coveralls&lt;/sup&gt; &lt;a href=&#34;https://coveralls.io/github/SteveGilham/altcover&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/SteveGilham/altcover/badge.svg?sanitize=true&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/SteveGilham/altcover/wiki/Usage&#34;&gt;Wiki page&lt;/a&gt; for details&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/SteveGilham/altcover/projects/8&#34;&gt;current project&lt;/a&gt; and &lt;a href=&#34;https://github.com/SteveGilham/altcover/projects/9&#34;&gt;long term research items&lt;/a&gt; for details; though &lt;em&gt;ad hoc&lt;/em&gt; items not in the projects will get added as inspiration or need arise.&lt;/p&gt; &#xA;&lt;p&gt;All &lt;code&gt;To do&lt;/code&gt; and &lt;code&gt;On Hold&lt;/code&gt; items are implicitly &lt;code&gt;up for grabs&lt;/code&gt; and &lt;code&gt;Help Wanted&lt;/code&gt;; most of the current project items are XML manipulation or GUI programming.&lt;/p&gt; &#xA;&lt;h3&gt;Possible retirement/obsolescence of support&lt;/h3&gt; &#xA;&lt;p&gt;tl;dr -- legacy framework/Mono support is not going away any time soon.&lt;/p&gt; &#xA;&lt;p&gt;Despite earlier ruminations on the subject, as .net 4.7.2 can consume &lt;code&gt;netstandard2.0&lt;/code&gt; libraries (everything but the recorder), and .net core 2+ can consume &lt;code&gt;net20&lt;/code&gt; libraries (the recorder), legacy framework/Mono support continues until such a time as it is no longer possible to retain those API levels. Framework-targeted builds are kept to a minimum (executable entry-points and the recorder).&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;h3&gt;Tooling&lt;/h3&gt; &#xA;&lt;h4&gt;All platforms&lt;/h4&gt; &#xA;&lt;p&gt;It is assumed that the following are available&lt;/p&gt; &#xA;&lt;p&gt;.net SDK version as per global.json, or later minor version (&lt;code&gt;dotnet&lt;/code&gt;) -- try &lt;a href=&#34;https://www.microsoft.com/net/download&#34;&gt;https://www.microsoft.com/net/download&lt;/a&gt;&lt;br&gt; PowerShell Core 7.3.0 or later (&lt;code&gt;pwsh&lt;/code&gt;) -- try &lt;a href=&#34;https://github.com/powershell/powershell&#34;&gt;https://github.com/powershell/powershell&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The build may target &lt;code&gt;netstandard2.0&lt;/code&gt; or &lt;code&gt;netcoreapp2.0/2.1&lt;/code&gt; for deliverables, and &lt;code&gt;net7.0&lt;/code&gt; for unit tests, but does not need any pre-7.0 runtimes to be installed (roll-forward policies are in place).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; F# compiler code generation changes may cause incompatibilities due to some of the IL inspection performed by AltCover and its self-tests (e.g. by, at 5.0.201, generating non-closure function objects as static fields rather than locally instantiated objects)&lt;/p&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;p&gt;If an IDE is desired, Visual Studio VS2022 (Community Edition) with desktop option, including F# language support&lt;/p&gt; &#xA;&lt;p&gt;For GTK# support, the GTK# latest 2.12 install is expected -- try &lt;a href=&#34;https://www.mono-project.com/download/stable/#download-win&#34;&gt;https://www.mono-project.com/download/stable/#download-win&lt;/a&gt; -- while the latest releases of the GTK#3 libraries will download the native support if the expected version is not detected.&lt;/p&gt; &#xA;&lt;h4&gt;*nix&lt;/h4&gt; &#xA;&lt;p&gt;It is assumed that &lt;code&gt;mono&lt;/code&gt; (version 6.12.x or later) and &lt;code&gt;dotnet&lt;/code&gt; are on the &lt;code&gt;PATH&lt;/code&gt; already, and everything is built from the command line, with your favourite editor used for coding.&lt;/p&gt; &#xA;&lt;h3&gt;Bootstrapping&lt;/h3&gt; &#xA;&lt;p&gt;Start by setting up with &lt;code&gt;dotnet tool restore&lt;/code&gt;; this sets up local tools. Then &lt;code&gt;dotnet run --project .\Build\Setup.fsproj&lt;/code&gt; to do the rest of the set-up.&lt;/p&gt; &#xA;&lt;h3&gt;Normal builds&lt;/h3&gt; &#xA;&lt;p&gt;Running &lt;code&gt;dotnet run --project .\Build\Build.fsproj&lt;/code&gt; performs a full build/test/package process.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;dotnet run --project .\Build\Build.fsproj --target &amp;lt;targetname&amp;gt;&lt;/code&gt; to run to a specific target.&lt;/p&gt; &#xA;&lt;h4&gt;If the build fails&lt;/h4&gt; &#xA;&lt;p&gt;If there&#39;s a passing build on the CI server for this commit, then it&#39;s likely to be one of the &lt;a href=&#34;https://github.com/SteveGilham/altcover/wiki/Intermittent-build-issues&#34;&gt;intermittent build failures&lt;/a&gt; that can arise from the tooling used. The standard remedy is to try again.&lt;/p&gt; &#xA;&lt;h3&gt;Unit Tests&lt;/h3&gt; &#xA;&lt;p&gt;The tests in the &lt;code&gt;AltCover.Test&lt;/code&gt; project are broadly ordered in the same dependency order as the code within the AltCover project (the later &lt;code&gt;Runner&lt;/code&gt; tests aside). While working on any given layer, it would make sense to comment out all the tests for later files so as to show what is and isn&#39;t being covered by explicit testing, rather than merely being cascaded through.&lt;/p&gt; &#xA;&lt;p&gt;Note that some of the unit tests expect that the separate build of test assemblies under Mono, full .net framework and .net core has taken place; these tests will be marked &lt;code&gt;ignore&lt;/code&gt; when running the unit tests under &lt;code&gt;net472&lt;/code&gt; and &lt;code&gt;pass&lt;/code&gt; without doing anything under &lt;code&gt;net7.0&lt;/code&gt; (as Expecto has no &lt;code&gt;ignore&lt;/code&gt; option) if the build is not complete and thus those expected assemblies are not found e.g. in Visual Studio from clean, or after a build to targets like &lt;code&gt;Analysis&lt;/code&gt; that only build code to be analysed.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks to&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://coveralls.io/r/SteveGilham/altcover&#34;&gt;Coveralls&lt;/a&gt; for allowing free services for Open Source projects&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>