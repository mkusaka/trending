<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-12T01:32:10Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dungpa/algorithms1</title>
    <updated>2022-12-12T01:32:10Z</updated>
    <id>tag:github.com,2022-12-12:/dungpa/algorithms1</id>
    <link href="https://github.com/dungpa/algorithms1" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Coursera&#39;s Algorithms Design and Analysis I: slides and F# source code&lt;/p&gt;&lt;hr&gt;&lt;p&gt;The slides and assignments for Algorithms Design and Analysis I on Coursera.&lt;/p&gt; &#xA;&lt;p&gt;Each assignment consists of the main algorithm, test scripts and test cases written in FSUnit and xUnit. A few input files are dropped because their sizes are too big.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>delneg/FSAdventArticleFFI</title>
    <updated>2022-12-12T01:32:10Z</updated>
    <id>tag:github.com,2022-12-12:/delneg/FSAdventArticleFFI</id>
    <link href="https://github.com/delneg/FSAdventArticleFFI" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Guide, description and shared knowledge related to FFI in F# and .NET in general&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Communicating with other languages and runtimes, aka FFI in F#&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#communicating-with-other-languages-and-runtimes--aka-ffi-in-f-&#34;&gt;Communicating with other languages and runtimes, aka FFI in F#&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#what-is-ffi&#34;&gt;What is FFI&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#reasons-to-do-ffi&#34;&gt;Reasons to do FFI&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#decision-making&#34;&gt;Decision making&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#comparison-with-other-languages---runtimes-methods-to-do-ffi&#34;&gt;Comparison with other languages / runtimes methods to do FFI&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#java---jvm&#34;&gt;Java &amp;amp; JVM&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#swift---objc---objc--&#34;&gt;Swift / ObjC / ObjC++&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#go&#34;&gt;Go&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#rust&#34;&gt;Rust&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#nodejs&#34;&gt;Node.js&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#others&#34;&gt;Others&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#show-me-the-code&#34;&gt;Show me the code&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#examples&#34;&gt;Examples&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#c&#34;&gt;C&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#rust-1&#34;&gt;Rust&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#zig&#34;&gt;Zig&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#swift&#34;&gt;Swift&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#advantages-and-drawbacks&#34;&gt;Advantages and drawbacks&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#advantages&#34;&gt;Advantages&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#drawbacks&#34;&gt;Drawbacks&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#use-case-scenarios&#34;&gt;Use-case scenarios&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#caveas-and-gotchas&#34;&gt;Caveas and gotchas&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#tips-and-tricks&#34;&gt;Tips and tricks&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#useful-links&#34;&gt;Useful links&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;DISCLAIMER:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;All of the code &amp;amp; text that&#39;s in the repo and in the README is based on my own experience, and as such may be prone to error, misunderstanding or other flaws. Use at your own risk.&lt;/p&gt; &#xA;&lt;h2&gt;What is FFI&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/delneg/FSAdventArticleFFI/master/#show-me-the-code&#34;&gt;I don&#39;t want to read all of it - just show me the code!&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;When developing applications for server, mobile , web or embedded platforms one might often find oneself in need of extra functionality, that may be unavailable in the language that software is developed in or have the need to tap into other language / runtime&#39;s capabilities for various other reasons. That&#39;s not a new problem, and has existed for quite a while. In fact, according to &lt;a href=&#34;https://en.wikipedia.org/wiki/Foreign_function_interface&#34;&gt;wikipedia&lt;/a&gt; &#34;The term comes from the specification for Common Lisp, which explicitly refers to the language features for inter-language calls as such;&#34;&lt;/p&gt; &#xA;&lt;p&gt;Although the FFI should not be confused with languages that operate on the same runtime - for example, C# / F# interoperability is not actually FFI because they compile to IL. The same argument is true for Java / Kotlin / Scala / Clojure , as well as Erlang / Elixir (&lt;a href=&#34;https://en.wikipedia.org/wiki/Foreign_function_interface#Special_cases&#34;&gt;wiki&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;Terminology and disambiguation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In dotnet FFI is also known by the name of P/Invoke.&lt;/li&gt; &#xA; &lt;li&gt;Managed code - is &#39;home&#39; language / runtime, unmanaged code (or &#39;native&#39; code) - code after FFI bridge, i.e. C/C++/Rust code&lt;/li&gt; &#xA; &lt;li&gt;Runtime / platform - things like BEAM (Erlang), CLR (dotnet), JVM (java) etc.&lt;/li&gt; &#xA; &lt;li&gt;Name mangling - means the names of exported functions are changed and become something like &lt;code&gt;_Z13lib_exported&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;MSDN link: &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/&#34;&gt;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Reasons to do FFI&lt;/h2&gt; &#xA;&lt;p&gt;You might ask yourself - &#34;Why do I even need to do FFI ? I can just re-write it in &lt;del&gt;Rust&lt;/del&gt; F# (or C#, or VB) and use it that way!&#34;&lt;/p&gt; &#xA;&lt;p&gt;And while dotnet has one of &lt;strong&gt;the best&lt;/strong&gt; (in my opinion) FFI interoperability, you will need some convincing for youself (or your colleagues) to dive deep into it.&lt;/p&gt; &#xA;&lt;p&gt;Well, there can be several good (in my opinion) reasons.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;First of all&lt;/strong&gt;, the functionality you need may simply not be available in your language and may be cumbersome / time-consuming / error-prone to re-write it from scratch. For example, you should probably not rewrite cryptography functions like the ones availiable in &lt;code&gt;openssl&lt;/code&gt; or &lt;code&gt;boringssl&lt;/code&gt; or &lt;code&gt;libressl&lt;/code&gt;, because they&#39;ve been battle-tested and highly optimized.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Secondly&lt;/strong&gt;, you might want to have better performance. Of course, there is certain overhead associated with FFI calls (you might want to check out &lt;a href=&#34;https://github.com/dyu/ffi-overhead&#34;&gt;this repo, although it&#39;s quite outdated&lt;/a&gt;) However, even with overhead (which might not matter in your case) - it might be much faster and / or memory-efficient than managed language implementation. &lt;a href=&#34;https://github.com/ncave/fable-raytracer/issues/1&#34;&gt;Here&#39;s&lt;/a&gt; one of the example where that might be the case - although not strictly &#34;FFI&#34; related, the numbers can be interesting, as well as the repo itself.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;And last but not least&lt;/strong&gt;, you might want to build a shared code-base to be able to re-use it across different languages, platforms and runtimes. For example, you might have a business with a C# Xamarin/Maui app for iOS and Android, Web app written in React, Desktop app utilizing Electron with React app sharing code with the web app, and a CLI written in Rust, with backend written in F# Asp.Net Core.&lt;/p&gt; &#xA;&lt;p&gt;So, it might be a good idea to de-couple the logic from the CLI into shared Rust library, which can be built by CI to be re-used across mobile app, web app &amp;amp; desktop app via WASM, CLI app as a Cargo crate and the backend &amp;amp; mobile apps via dotnet FFI (also called P/Invoke). An example of a similar setup can be found on github of messaging app called Signal - &lt;a href=&#34;https://github.com/signalapp/libsignal&#34;&gt;https://github.com/signalapp/libsignal&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Decision making&lt;/h2&gt; &#xA;&lt;p&gt;After all, it all comes down to a decision - to be or not to be (or, in this case - to do FFI or keep it managed) These are the criteria that I might use in order to make such a decision:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ease of consumption&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;Will my FFI-enabled code be easy to consume for my clients (other developers)&lt;/em&gt; ?&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re developing a public dotnet library on github, it can be challenging to make it accessible to broad range of platforms that dotnet runs on, because you&#39;ll need to compile your FFI library independently from your dotnet code. A good example is &lt;a href=&#34;https://github.dev/xoofx/Blake3.NET&#34;&gt;this BLAKE3 hashing library&lt;/a&gt;. It has a Rust crate &lt;code&gt;blake3&lt;/code&gt; wrapped in a FFI-friendly package, together with CI-friendly build scripts, and has pre-built versions for Linux, macOS and Windows for x86_64, arm and arm64 architectures.&lt;/p&gt; &#xA;&lt;p&gt;However, if you&#39;re planning to use your FFI code in company project for backend app running on x86_64 Linux with a recent Kernel, that may be totally not a concern for you.&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Rewrite possibility in managed code&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;Maybe it&#39;s better to write the desired functionality in F# / C# after all ?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sometimes, that&#39;s simply not possible. In another case, you might be better off having a well-performing &amp;amp; optimized managed implementation, than trying to debug another &#34;segmentation fault. core dumped&#34; error.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Small FFI surface&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;Will I be able to keep the exposed &#34;unsafe&#34; / &#34;private&#34; surface of the FFI-code small &amp;amp; approachable ?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Perhaps, sometime after your code using FFI will be landed in production, someone else will have to take a look at it - and it may be very difficult to change some FFI-related code without knowing it&#39;s purpose by trying to check for exposed headers (&lt;code&gt;nm -d libfoo.so&lt;/code&gt;) and guessing what the various flags passed to the function do.&lt;/p&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Application safety &amp;amp; stability&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;Did I manage to wrap the FFI code in a way that&#39;s safe (first of all, memory-safe) and secure (i.e. introduces no new vulnerabilities and doesn&#39;t lead to unexpected crashes) ?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;To help make the answer to this question a confident &#34;Yes&#34;, you might employ the help of such tools like Unit tests, Integration tests and Fuzzer testing. Also, it could be beneficial to utilize tools like &lt;code&gt;memory sanitizer&lt;/code&gt; and / or &lt;code&gt;valgrind&lt;/code&gt; in order to detect memory leaks early, as well as the wide range of dotnet-specific tools available.&lt;/p&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ease of testing &amp;amp; unhandled errors&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;em&gt;Will I be able to set up unit testing / integration testing in such a way that native code is either working correctly 100% of the time or mocked, or can it be a problem?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Due to the nature of FFI code, it&#39;s very easy to have &lt;code&gt;Unhandled exception. System.EntryPointNotFoundException: Unable to find an entry point named &#39;foo&#39; in DLL &#39;bar&#39;&lt;/code&gt; or &lt;code&gt;Unhandled exception. System.DllNotFoundException: Unable to load DLL &#39;bar&#39; or one of its dependencies: The specified module could not be found.&lt;/code&gt; blast in your face in runtime. Yes, you heard that right - those are &lt;code&gt;runtime&lt;/code&gt; errors, meaning that you won&#39;t find out that you have a problem until in crashes. In order to avoid that, you have to understand your target platforms (for development, testing and production environments) - because if, for example, someone new joins the company with an M1/M2 Mac while your library is only built for x86_64 - it will take some time to configure the new build process and get it working. Or, for example, you&#39;re trying to run your fancy integration test suite on CI and everything goes well until AWS Graviton comes around. So, you have to try to predict how your native code will be used and set up build process for all potentially supported &lt;a href=&#34;https://wiki.osdev.org/Target_Triplet&#34;&gt;target triplets&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Comparison with other languages / runtimes methods to do FFI&lt;/h2&gt; &#xA;&lt;h3&gt;Java &amp;amp; JVM&lt;/h3&gt; &#xA;&lt;p&gt;In the JVM world, FFI is mainly done using JNI (&lt;a href=&#34;https://www.baeldung.com/jni&#34;&gt;guide&lt;/a&gt;) which required creating an intermediary C code using Java types.&lt;/p&gt; &#xA;&lt;p&gt;It typically looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;sys/time.h&amp;gt;&#xA;&#xA;#include &#34;jhello_Hello.h&#34;&#xA;#include &#34;../newplus/plus.h&#34;&#xA;&#xA;JNIEXPORT jint JNICALL Java_jhello_Hello_plusone&#xA;  (JNIEnv *env, jclass clazz, jint x)&#xA;{&#xA;    return plusone(x);&#xA;    //return x + 1;&#xA;}&#xA;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package jhello;&#xA;&#xA;public final class Hello&#xA;{&#xA;    public static native int plusone(int x);&#xA;&#xA;    private static void loadNative() throws Exception&#xA;    {&#xA;        java.io.File file = new java.io.File(&#34;.&#34;), &#xA;            jhello = new java.io.File(file, &#34;jhello&#34;);&#xA;        &#xA;        if (jhello.exists())&#xA;            file = jhello;&#xA;        &#xA;        String currentDir = file.getCanonicalPath();&#xA;    &#xA;        System.load(currentDir + &#34;/libjhello.so&#34;);&#xA;    }&#xA;    public static void main(String[] args) throws Exception&#xA;    {&#xA;        // load&#xA;        loadNative();&#xA;        plusone(5);&#xA;    }&#xA;    &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, there&#39;s a recent development called &lt;a href=&#34;https://openjdk.org/projects/panama/&#34;&gt;Project Panama&lt;/a&gt; (a k a &lt;a href=&#34;https://openjdk.org/jeps/424&#34;&gt;JEP-424&lt;/a&gt;) An example of using those can be observed here: &lt;a href=&#34;https://github.com/cryptomator/jfuse&#34;&gt;https://github.com/cryptomator/jfuse&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Swift / ObjC / ObjC++&lt;/h3&gt; &#xA;&lt;p&gt;Swift &lt;a href=&#34;https://developer.apple.com/documentation/swift/using-imported-c-functions-in-swift&#34;&gt;can interoperate with C&lt;/a&gt; (and other Cdecl-enabled FFI languages) directly using header files&lt;/p&gt; &#xA;&lt;p&gt;Swift also supports &lt;a href=&#34;https://developer.apple.com/documentation/swift/using-imported-c-structs-and-unions-in-swift&#34;&gt;C structs and enums (unions)&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However,it can sometimes be not practical - sometimes, it&#39;s easier to create an Objective-C &#34;bridge&#34; to provide a nice API&#39;s for both C code and Swift code. An example of that can be seen in my &lt;a href=&#34;https://github.com/delneg/Nuke-AVIF-Plugin/&#34;&gt;AVIF image format decoder repo&lt;/a&gt;, and specifically &lt;a href=&#34;https://github.com/delneg/Nuke-AVIF-Plugin/raw/main/Source/AVIF/AVIFDataDecoder.h&#34;&gt;here&#39;s what Swift consumes&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Also, there are projects like &lt;a href=&#34;https://github.com/chinedufn/swift-bridge&#34;&gt;this, that utilize Swift stable ABI to create a direct bridge between Swift &amp;lt;-&amp;gt; Rust&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Regarding the C++, ObjC++ can interop with it directly - so it&#39;s typically quite practical to implement some C++ API Surface to be consumed by ObjC++, which is in turn consumed by a Swift wrapper. An &lt;a href=&#34;https://github.com/sitepoint-editors/HelloCpp&#34;&gt;example project, although a bit outdated - can be found here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s a long &amp;amp; extensive &lt;a href=&#34;https://github.com/apple/swift/raw/main/docs/CppInteroperability/CppInteroperabilityManifesto.md&#34;&gt;dedicated document made by a specialized workgroup regarding Swift &amp;lt;-&amp;gt; C++ interop&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Go&lt;/h3&gt; &#xA;&lt;p&gt;In Go, &lt;a href=&#34;https://pkg.go.dev/cmd/cgo&#34;&gt;there&#39;s a special package, that allows developers to use C (or Cdecl-compatible code) from Go, called &lt;code&gt;cgo&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a &lt;a href=&#34;https://zchee.github.io/golang-wiki/cgo/&#34;&gt;guide on CGo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an &lt;a href=&#34;https://github.com/mediremi/rust-plus-golang&#34;&gt;example project, integrating Go and Rust together&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s &lt;a href=&#34;https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride&#34;&gt;a long and opinionated article on Go in general and CGo in particular, which shows the quirks of the approach&lt;/a&gt; (there&#39;s &lt;a href=&#34;https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang#go-is-an-island&#34;&gt;a follow-up post, which includes a part related to CGo&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;However, &lt;a href=&#34;https://dave.cheney.net/2016/01/18/cgo-is-not-go&#34;&gt;CGo is not Go&lt;/a&gt; and while it can be used for FFI, has constraints and limitations, as well as practical issues.&lt;/p&gt; &#xA;&lt;p&gt;In addition to that, you have to specify &lt;a href=&#34;https://github.com/winfsp/cgofuse/raw/master/fuse/host_cgo.go#L19&#34;&gt;linker flags&lt;/a&gt;, &lt;a href=&#34;https://dh1tw.de/2019/12/cross-compiling-golang-cgo-projects/&#34;&gt;OS-specific build instructions&lt;/a&gt; and &lt;a href=&#34;https://akrennmair.github.io/golang-cgo-slides/#9&#34;&gt;includes using a special syntax in the comments.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;It looks something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void hello(char *name);&#xA;void whisper(char *message);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;// NOTE: There should be NO space between the comments and the `import &#34;C&#34;` line.&#xA;&#xA;/*&#xA;#cgo LDFLAGS: -L./lib -lhello&#xA;#include &#34;./lib/hello.h&#34;&#xA;*/&#xA;import &#34;C&#34;&#xA;&#xA;func main() {&#xA;    C.hello(C.CString(&#34;world&#34;))&#xA;    C.whisper(C.CString(&#34;this is code from the dynamic library&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go build -ldflags=&#34;-r $(ROOT_DIR)lib&#34; main_dynamic.go&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rust&lt;/h3&gt; &#xA;&lt;p&gt;Because of the nature of Rust (borrow-checking memory management, lack of runtime and GC , suitable type system, etc.), it&#39;s very easy to interop with it using other languages.&lt;/p&gt; &#xA;&lt;p&gt;Notably, &lt;a href=&#34;https://mozilla.github.io/uniffi-rs/Overview.html&#34;&gt;there&#39;s a project from Mozilla that creates a unified interface for Rust to be used from multiple languages&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s a project to automatically generate Rust code from C/C++ headers &lt;a href=&#34;https://github.com/rust-lang/rust-bindgen&#34;&gt;called rust-bindgen&lt;/a&gt;, as well as &lt;a href=&#34;https://github.com/eqrion/cbindgen&#34;&gt;it&#39;s counterpart for vice versa - to generate C/C++ headers for Rust code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are quite a lot of articles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://doc.rust-lang.org/nomicon/ffi.html&#34;&gt;in the Rustonomicon&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://michael-f-bryan.github.io/rust-ffi-guide/&#34;&gt;Michael F Bryan blog Rust ffi guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://anssi-fr.github.io/rust-guide/07_ffi.html&#34;&gt;Secure Rust Guidelines ffi guide&lt;/a&gt; and so on.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It looks mainly like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::os::raw::c_int;&#xA;// import an external function from libc&#xA;extern &#34;C&#34; {&#xA;    fn abs(args: c_int) -&amp;gt; c_int;&#xA;}&#xA;// export a C-compatible function&#xA;#[no_mangle]&#xA;unsafe extern &#34;C&#34; fn mylib_f(param: u32) -&amp;gt; i32 {&#xA;    if param == 0xCAFEBABE { 0 } else { -1 }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Node.js&lt;/h3&gt; &#xA;&lt;p&gt;Because Node.js runs on top of V8, an execution engine written in C++ and due to JS being an interpreted language, it&#39;s pretty easy to dynamically import C code.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s mainly done using the &lt;a href=&#34;https://github.com/node-ffi/node-ffi&#34;&gt;node-ffi library&lt;/a&gt;, which has a nice &lt;a href=&#34;https://github.com/node-ffi/node-ffi/wiki/Node-FFI-Tutorial&#34;&gt;tutorial here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The code looks something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var ref = require(&#39;ref&#39;);&#xA;var ffi = require(&#39;ffi&#39;);&#xA;&#xA;// typedef&#xA;var sqlite3 = ref.types.void; // we don&#39;t know what the layout of &#34;sqlite3&#34; looks like&#xA;var sqlite3Ptr = ref.refType(sqlite3);&#xA;var sqlite3PtrPtr = ref.refType(sqlite3Ptr);&#xA;var stringPtr = ref.refType(ref.types.CString);&#xA;&#xA;// binding to a few &#34;libsqlite3&#34; functions...&#xA;var libsqlite3 = ffi.Library(&#39;libsqlite3&#39;, {&#xA;  &#39;sqlite3_open&#39;: [ &#39;int&#39;, [ &#39;string&#39;, sqlite3PtrPtr ] ],&#xA;  &#39;sqlite3_close&#39;: [ &#39;int&#39;, [ sqlite3Ptr ] ],&#xA;  &#39;sqlite3_exec&#39;: [ &#39;int&#39;, [ sqlite3Ptr, &#39;string&#39;, &#39;pointer&#39;, &#39;pointer&#39;, stringPtr ] ],&#xA;  &#39;sqlite3_changes&#39;: [ &#39;int&#39;, [ sqlite3Ptr ]]&#xA;});&#xA;&#xA;// now use them:&#xA;var dbPtrPtr = ref.alloc(sqlite3PtrPtr);&#xA;libsqlite3.sqlite3_open(&#34;test.sqlite3&#34;, dbPtrPtr);&#xA;var dbHandle = dbPtrPtr.deref();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s also a &lt;a href=&#34;https://github.com/node-ffi-napi/node-ffi-napi&#34;&gt;neat wrapper, called node-ffi-napi&lt;/a&gt; which you can use.&lt;/p&gt; &#xA;&lt;p&gt;In addition to that, &lt;a href=&#34;https://blog.risingstack.com/writing-native-node-js-modules/&#34;&gt;you can use Node.js headers to write Node.js native modules directly&lt;/a&gt;, also called native addons. An &lt;a href=&#34;https://blog.logrocket.com/rust-and-node-js-a-match-made-in-heaven/&#34;&gt;example project of Rust native module can be seen in here&lt;/a&gt; And a &lt;a href=&#34;https://github.com/napi-rs/napi-rs&#34;&gt;Rust project that simplifies writing native modules&lt;/a&gt; as well as alternatives like &lt;a href=&#34;https://github.com/infinyon/node-bindgen&#34;&gt;node-bindgen&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Because the Javascript is a browser language, Node.js also supports Webassembly (WASM), which can be used to simplify running untrusted code in a constrained environment or to compile native code (C/C++/Rust) to performant WASM.&lt;/p&gt; &#xA;&lt;p&gt;An example of such usage &lt;a href=&#34;https://github.com/bengl/sbffi/raw/master/test/bench.js#L19&#34;&gt;with WAT text code format can be seen here, with benchmarks against other possible use cases&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Others&lt;/h3&gt; &#xA;&lt;p&gt;Although I&#39;ve covered quite a few languages that I&#39;ve had experience with, there&#39;s definitely more to it - for example, I left out BEAM languages, as well as Python. After all, this is an article about FFI in dotnet - and mainly it&#39;s usage with F#.&lt;/p&gt; &#xA;&lt;p&gt;You might be interested &lt;a href=&#34;https://github.com/ralfbiedert/interoptopus&#34;&gt;in automated binding generator - although at the moment of writing this, it only supports C#&lt;/a&gt;. It&#39;s possible to generate C# bindings in a separate project and use that in F# (or re-write only the needed parts in F# by hand).&lt;/p&gt; &#xA;&lt;h2&gt;Show me the code&lt;/h2&gt; &#xA;&lt;p&gt;(Optional, skip if your target platform is macos/linux/windows and not xamarin) In your .fsproj:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;  &amp;lt;ItemGroup&amp;gt;&#xA;    &amp;lt;NativeReference Include=&#34;.\rust-src\libfoo&#34;&amp;gt;&#xA;      &amp;lt;Kind&amp;gt;Static&amp;lt;/Kind&amp;gt;&#xA;      &amp;lt;IsCxx&amp;gt;False&amp;lt;/IsCxx&amp;gt;&#xA;      &amp;lt;ForceLoad&amp;gt;False&amp;lt;/ForceLoad&amp;gt;&#xA;    &amp;lt;/NativeReference&amp;gt;&#xA;  &amp;lt;/ItemGroup&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In your .fs file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Native =&#xA;    let [&amp;lt;Literal&amp;gt;] DllName = &#34;libfoo&#34;&#xA;    &#xA;    [&amp;lt;DllImport(DllName, CallingConvention=CallingConvention.Cdecl)&amp;gt;]&#xA;    //(value1: i32, value2: i32) -&amp;gt; i32&#xA;    extern int32 add_values(int32 value1, int32 value2)&#xA;    &#xA;    &#xA;    &amp;lt;DllImport(DllName, CallingConvention=CallingConvention.Cdecl)&amp;gt;]&#xA;    //(x: i32, y: i32, w: i32, h: i32, angle: f64) -&amp;gt; *const u8&#xA;    extern IntPtr render_scene(int x, int y, int w, int h, float angle)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(for iOS it DllName should be &#39;__Internal&#39;, &lt;a href=&#34;https://learn.microsoft.com/en-us/xamarin/ios/platform/native-interop?source=recommendations#static-libraries&#34;&gt;more on that here&lt;/a&gt; - you can &lt;code&gt;#if SOME_COMPILER_DIRECTIVE&lt;/code&gt; to switch it in code conditionally)&lt;/p&gt; &#xA;&lt;p&gt;Calling:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;printfn $&#34;Native add_values: 5 + 6 = {Native.add_values(5,6)}&#34;&#xA;let ret_ptr = Native.render_scene(x,y,w,h,angle)&#xA;let ptr_hex = String.Format(&#34;{0:X8}&#34;, ret_ptr.ToInt64())&#xA;printfn $&#34;Native big render scene returned 0x{ptr_hex}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And another, more complex example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Native =&#xA; [&amp;lt;Literal&amp;gt;]&#xA; let DllName = &#34;libfoo.so&#34;;&#xA; [&amp;lt;Literal&amp;gt;]&#xA; let FOO_BAR_SIZE = 1337 // FOO_BAR struct size in bytes&#xA;&#xA;&#xA; [&amp;lt;DllImport(DllName, CallingConvention=CallingConvention.Cdecl)&amp;gt;]&#xA; extern int Set_Library_Ptr(byte[] ptrData, int flags, [&amp;lt;In&amp;gt;]IntPtr ptrValue)&#xA; [&amp;lt;DllImport(DllName, CallingConvention=CallingConvention.Cdecl)&amp;gt;]&#xA; extern unit Make_Expensive_computation(byte[] inbuf, byte[] outbuf, uint64 length,[&amp;lt;In&amp;gt;]IntPtr ptrValue, int flag)&#xA;&#xA;&#xA; let nativeWrapper (data: byte[]) (flag: int) (byteBuf: byte[])  =&#xA;   let intPtr = NativePtr.stackalloc&amp;lt;byte&amp;gt; FOO_BAR_SIZE |&amp;gt; NativePtr.toNativeInt&#xA;   let mutable res = Array.zeroCreate data.Length&#xA;   let set_res = Set_Library_Ptr(byteBuf, 64, intPtr)&#xA;   Make_Expensive_computation(data, res, (uint64 data.Length), intPtr, flag)&#xA;   res&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/type-marshalling#default-rules-for-marshalling-common-types&#34;&gt;Type marshalling&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;C&lt;/h3&gt; &#xA;&lt;p&gt;Please look into &lt;code&gt;Program.fs&lt;/code&gt; &amp;amp; corresponding &lt;code&gt;example_c&lt;/code&gt; folder with C code in this repo-s directory. It has been tested on macOS arm64 with &lt;code&gt;openssl&lt;/code&gt; installed with &lt;code&gt;brew install openssl&lt;/code&gt;. But&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake -DOPENSSL_ROOT_DIR=&amp;lt;openssl_dir&amp;gt;  -DOPENSSL_LIBRARIES=&amp;lt;openssl_dir/lib&amp;gt;&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;should work anywhere.&lt;/p&gt; &#xA;&lt;p&gt;The goal of the program is to encrypt a string using AES XTS encryption, and then decrypt it to check if it&#39;s gone through a round trip correctly.&lt;/p&gt; &#xA;&lt;p&gt;When run, the program outputs the following result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Will encode :&#39;Calling C from F#&#39;&#xA;Encryption key:&#39;MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMw==&#39;, initialization vector: &#39;MDEyMzQ1Njc4OTAxMjM0NQ==&#39;&#xA;Ciphertext[17]: 63630A73F208EF8CC3ECE1937AFCDB61210000000000000000000000000000000000 - encrypted in 46ms&#xA;Plaintext[17]: Calling C from F# - decrypted in 46ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rust&lt;/h3&gt; &#xA;&lt;p&gt;Feel free to check out my demo of Rust &amp;lt;-&amp;gt; F# interop running on iOS here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/delneg/fable-raytracer-ios-net6&#34;&gt;https://github.com/delneg/fable-raytracer-ios-net6&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Despite the name, it was recently updated to dotnet 7.&lt;/p&gt; &#xA;&lt;p&gt;The interesting part is passing the pointer Rust -&amp;gt; F# -&amp;gt; ObjC platform code (to &lt;a href=&#34;https://developer.apple.com/documentation/coregraphics/cgdataprovider&#34;&gt;CGDataProvider&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;P.S. I&#39;m not sure this code is memory-safe though, so if you find a potential leak, please ping me.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[no_mangle]&#xA;pub unsafe extern &#34;C&#34; fn render_scene(x: i32, y: i32, w: i32, h: i32, angle: f64) -&amp;gt; *const u8 {&#xA;    let buffer = get_buffer();&#xA;    RayTracerDemo::renderScene(&amp;amp;buffer, &amp;amp;x, &amp;amp;y, &amp;amp;w, &amp;amp;h, &amp;amp;angle);&#xA;    buffer.as_ptr()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Native =&#xA;    let [&amp;lt;Literal&amp;gt;] DllName = &#34;__Internal&#34;&#xA;    &#xA;    [&amp;lt;DllImport(DllName, CallingConvention=CallingConvention.Cdecl)&amp;gt;]&#xA;    extern IntPtr render_scene(nativeint x, nativeint y, nativeint w, nativeint h, float angle)&#xA;    &#xA;    let getUIImageForRGBAData width height (dataPtr:IntPtr) (dataLen:int) =&#xA;        // https://gist.github.com/irskep/e560be65163efcb04115&#xA;        let bytesPerPixel = 4&#xA;        let scanWidth = bytesPerPixel * width&#xA;        let provider = new CGDataProvider(dataPtr, dataLen)&#xA;        let colorSpaceRef = CGColorSpace.CreateDeviceRGB()&#xA;        let bitMapInfo = CGBitmapFlags.Last&#xA;        let renderingIntent = CGColorRenderingIntent.Default&#xA;        let imageRef = new CGImage(width,height,8, bytesPerPixel * 8, scanWidth, colorSpaceRef, bitMapInfo, provider,null,false,renderingIntent)&#xA;        new UIImage(imageRef)&#xA;&#xA;...&#xA;&#xA;let ret_ptr = Native.render_scene(nativeint x,nativeint y,nativeint w,nativeint h,angle)&#xA;let ptr_hex = String.Format(&#34;{0:X8}&#34;, ret_ptr.ToInt64())&#xA;printfn $&#34;Native big render scene returned 0x{ptr_hex}&#34;&#xA;let imageView = new UIImageView()&#xA;imageView.Frame &amp;lt;- CGRect(float x, float y, float w, float h)&#xA;imageView.Image &amp;lt;- Native.getUIImageForRGBAData w h ret_ptr len&#xA;this.View.AddSubview(imageView)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Zig&lt;/h3&gt; &#xA;&lt;p&gt;There&#39;s a simple Zig example in this repo, which can be built with&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;zig build-lib simplemath.zig -dynamic&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-zig&#34;&gt;export fn add(a: i32, b: i32) i32 {&#xA;    return a + b;&#xA;}&#xA;export fn mult(a: i32, b: i32) i32 {&#xA;  return a * b;&#xA;}&#xA;export fn ziggZaggTest() void {&#xA;  ziggZagg() catch {};&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Native_Zig =&#xA;    let [&amp;lt;Literal&amp;gt;] DllName = &#34;example_zig/libsimplemath&#34;&#xA;    &#xA;    [&amp;lt;DllImport(DllName, CallingConvention=CallingConvention.Cdecl)&amp;gt;]&#xA;    extern int add(int a, int b)&#xA;    &#xA;    [&amp;lt;DllImport(DllName, CallingConvention=CallingConvention.Cdecl)&amp;gt;]&#xA;    extern int mult(int a, int b)&#xA;    &#xA;    [&amp;lt;DllImport(DllName, CallingConvention=CallingConvention.Cdecl)&amp;gt;]&#xA;    extern unit ziggZaggTest()&#xA;    &#xA;printfn $&#34;Zig add 5 + 6 = {Native_Zig.add (5,6)} , mult 11 * 42 = {Native_Zig.mult (11,42)}&#34;&#xA;printfn &#34;Zig zagg test&#34;&#xA;Native_Zig.ziggZaggTest()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Zig add 5 + 6 = 11 , mult 11 * 42 = 462&#xA;Zig zagg test&#xA;1&#xA;2&#xA;Zigg&#xA;4&#xA;Zagg&#xA;Zigg&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swift&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gist.github.com/HiImJulien/c79f07a8a619431b88ea33cca51de787&#34;&gt;It turns out&lt;/a&gt;, you can compile Swift code to shared library and execute it normally, utilizing the &#34;hidden&#34; &lt;code&gt;@_cdecl()&lt;/code&gt; attribute.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Foundation&#xA;@_cdecl(&#34;say_hello&#34;)&#xA;public func say_hello(){&#xA;    print(&#34;Hello from Swift!&#34;)&#xA;}&#xA;&#xA;@_cdecl(&#34;advanced_random&#34;)&#xA;public func advanced_random(num: Int, num2: Int) -&amp;gt; Int {&#xA;  return Int.random(in: num..&amp;lt;num2)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Native_Swift =&#xA;    let [&amp;lt;Literal&amp;gt;] DllName = &#34;example_swift/libfunc&#34;&#xA;    &#xA;    [&amp;lt;DllImport(DllName, CallingConvention=CallingConvention.Cdecl)&amp;gt;]&#xA;    extern int advanced_random(int num, int num2)&#xA;    &#xA;    [&amp;lt;DllImport(DllName, CallingConvention=CallingConvention.Cdecl)&amp;gt;]&#xA;    extern unit say_hello()&#xA;    &#xA;Native_Swift.say_hello()&#xA;printfn $&#34;Random number from Swift: {Native_Swift.advanced_random(1,100)}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Hello from Swift!&#xA;Random number from Swift: 21&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Advantages and drawbacks&lt;/h2&gt; &#xA;&lt;h3&gt;Advantages&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Utilize existing libraries in other languages&lt;/li&gt; &#xA; &lt;li&gt;Harness the power of raw assembly via C / Rust easily&lt;/li&gt; &#xA; &lt;li&gt;Share the code with other teams / projects&lt;/li&gt; &#xA; &lt;li&gt;Make &#34;hot paths&#34; in the code execute natively, and be able to perform low-level optimizations where it matters&lt;/li&gt; &#xA; &lt;li&gt;Tools &amp;amp; interface for profiling, which are closer to &#34;bare metal&#34;&lt;/li&gt; &#xA; &lt;li&gt;Do things like Xamarin (call ObjC or JNI from dotnet) and calling Linux / Windows / MacOS / BSD OS-level functions&lt;/li&gt; &#xA; &lt;li&gt;Tap into hardware-specific functionalities (i.e. SIMD instructions, although these already have a lot of nice wrappers)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Drawbacks&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Platform (os, architecture, kernel, platform restrictions) incompatibilities&lt;/li&gt; &#xA; &lt;li&gt;Much harder build process (no more simple &#34;dotnet run&#34; unless you spend time to automate it)&lt;/li&gt; &#xA; &lt;li&gt;Overhead is present, and it depends on the target platform &amp;amp; runtime etc.&lt;/li&gt; &#xA; &lt;li&gt;Adds a lot of complexity for an average dotnet developer&lt;/li&gt; &#xA; &lt;li&gt;Very easy to shoot yourself in the foot (leaks, crashes, vulns, etc.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Use-case scenarios&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Web Apps in WASM - &lt;a href=&#34;https://learn.microsoft.com/en-us/aspnet/core/blazor/webassembly-native-dependencies?view=aspnetcore-7.0#use-native-code&#34;&gt;Blazor WASM native dependencies&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Mobile apps &lt;a href=&#34;https://learn.microsoft.com/en-us/xamarin/android/platform/native-libraries&#34;&gt;Android&lt;/a&gt; and &lt;a href=&#34;https://learn.microsoft.com/en-us/xamarin/ios/platform/native-interop&#34;&gt;iOS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Backends (code in Examples)&lt;/li&gt; &#xA; &lt;li&gt;Performance optimizations&lt;/li&gt; &#xA; &lt;li&gt;Re-using existing libraries - like &lt;a href=&#34;https://github.com/praeclarum/sqlite-net/raw/master/src/SQLite.cs#L4448&#34;&gt;SQLite wrapper in C#&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Access platform-specific libraries like &lt;a href=&#34;https://ziglang.org/learn/overview/#integration-with-c-libraries-without-ffibindings&#34;&gt;libsoundio wrapper in Zig&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Caveas and gotchas&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;AFAIK, currently you can not use a static library on regular dotnet (that is, non-Xamarin or something else). I may be wrong though, but generally look for .so / .dylib compilation - shared libraries work even without added code to .fsproj&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NativeFileReference&lt;/code&gt; &amp;lt;&amp;gt; &lt;code&gt;NativeReference&lt;/code&gt; - small difference in spelling, but totally different meaning&lt;/li&gt; &#xA; &lt;li&gt;On iOS / macOS there &lt;em&gt;are a few extra steps&lt;/em&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;MonoTouch.ObjCRuntime.Dlfcn.dlopen (&#34;/full/path/to/Animal.dylib&#34;, 0);&lt;/code&gt; if using a dylib&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;__Internal&lt;/code&gt; in DllImport - that means, you can&#39;t use more than one static library that way (which is fine in most cases). Solution to that problem ? Pack them into .framework or .xcframework&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Library names search &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/cross-platform?source=recommendations&#34;&gt;differs on different platforms&lt;/a&gt;, all that .dylib / .so / .dll you see&lt;/li&gt; &#xA; &lt;li&gt;Starting with .NET Core 3.1, you can write &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/cross-platform#custom-import-resolver&#34;&gt;custom import resolver to search for your library path&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;AFAIK, the source generation for &lt;code&gt;LibraryImport&lt;/code&gt; &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke-source-generation&#34;&gt;attribute, added in dotnet 7&lt;/a&gt;, only works for C# code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tips and tricks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you want to inspect your DLL that you&#39;ve built, check out &lt;a href=&#34;http://penet.io/&#34;&gt;http://penet.io/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Native interop &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/best-practices&#34;&gt;best practices&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you want to explore the native library that you&#39;ve build in C/C++/Rust/Go/Zig/etc., use &lt;code&gt;otool -TV lib.dylib&lt;/code&gt; or &lt;code&gt;nm -gU lib.dylib&lt;/code&gt; for macOS, &lt;code&gt;dumpbin /EXPORTS lib.dll&lt;/code&gt; for Windows, and &lt;code&gt;readelf -s lib.so&lt;/code&gt; or &lt;code&gt;nm -D lib.so&lt;/code&gt; for Linux (or &lt;code&gt;nm -gDC lib.so&lt;/code&gt; for demangled version)&lt;/li&gt; &#xA; &lt;li&gt;You can do it the other way around, &lt;a href=&#34;https://secanablog.wordpress.com/2020/02/01/writing-a-native-library-in-f-which-can-be-called-from-c/&#34;&gt;here&#39;s a blog post on calling F# from C++&lt;/a&gt; and &lt;a href=&#34;https://github.com/secana/Native-FSharp-Library&#34;&gt;here&#39;s the code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;A few functions and namespaces that you might find useful: &lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;NativePtr.stackalloc&#xA;GC.AllocateUninitializedArray&#xA;Marshal.AllocHGlobal&#xA;Marshal.FreeHGlobal&#xA;NativePtr.toNativeInt&#xA;NativePtr.ofNativeInt&#xA;NativePtr.nullPtr&#xA;Marshal.PtrToStringAnsi&#xA;ArrayPool.Shared.Rent&#xA;ArrayPool.Shared.Return&#xA;GC.KeepAlive&#xA;fixed keyword&#xA;Unchecked.defaultof&amp;lt;&#39;T&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://godbolt.org/&#34;&gt;https://godbolt.org/&lt;/a&gt; - compiler explorer&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/byrefs&#34;&gt;Byref&lt;/a&gt;, a k a &#34;by reference&#34; (opposed to &#34;by value&#34;)&lt;/li&gt; &#xA; &lt;li&gt;Using native libs in &lt;a href=&#34;https://learn.microsoft.com/en-us/xamarin/cross-platform/cpp/&#34;&gt;Xamarin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Sandboxing native code - running WASM code in WASI environment in an Avalonia app via &lt;a href=&#34;https://github.com/bytecodealliance/wasmtime&#34;&gt;Wasmtime&lt;/a&gt; runtime &lt;a href=&#34;https://github.com/delneg/WasmtimeFableRaytracerFSharpAvalonia&#34;&gt;link to repo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Inline ASM in F# &lt;a href=&#34;https://blog.devgenius.io/inline-assembly-in-f-net-language-6d70ab9f58c1?gi=2a8fb0a2ffa8&#34;&gt;post&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;A guide on &lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/apply-interop-attributes&#34;&gt;interop attributes&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Useful links&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.fssnip.net/c1/title/F-yet-another-Interop-example&#34;&gt;http://www.fssnip.net/c1/title/F-yet-another-Interop-example&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/external-functions&#34;&gt;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/external-functions&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://fsharp.github.io/fsharp-core-docs/reference/fsharp-nativeinterop-nativeptrmodule.html&#34;&gt;https://fsharp.github.io/fsharp-core-docs/reference/fsharp-nativeinterop-nativeptrmodule.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/&#34;&gt;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/type-marshalling#default-rules-for-marshalling-common-types&#34;&gt;https://learn.microsoft.com/en-us/dotnet/standard/native-interop/type-marshalling#default-rules-for-marshalling-common-types&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/fixed&#34;&gt;https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/fixed&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/swig/swig&#34;&gt;https://github.com/swig/swig&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/xamarin/android/platform/native-libraries&#34;&gt;https://learn.microsoft.com/en-us/xamarin/android/platform/native-libraries&lt;/a&gt; &lt;a href=&#34;https://learn.microsoft.com/en-us/xamarin/ios/platform/native-interop&#34;&gt;https://learn.microsoft.com/en-us/xamarin/ios/platform/native-interop&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.nativelibrary?view=net-7.0&#34;&gt;https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.nativelibrary?view=net-7.0&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>