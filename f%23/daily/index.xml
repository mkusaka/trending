<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-22T01:40:49Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>farlee2121/FsSpec</title>
    <updated>2022-07-22T01:40:49Z</updated>
    <id>tag:github.com,2022-07-22:/farlee2121/FsSpec</id>
    <link href="https://github.com/farlee2121/FsSpec" rel="alternate"></link>
    <summary type="html">&lt;p&gt;FsSpec represents value constraints as data to reuse one constraint declaration for validation, data generation, error explanation, and more.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;FsSpec&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/farlee2121/FsSpec/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/farlee2121/FsSpec/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI Build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/fsspec&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/fsspec?label=NuGet%3A%20FsSpec&#34; alt=&#34;Nuget (with prereleases)&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;NOTE: Looking for feedback and experiences with the library to smooth it out. Please leave &lt;a href=&#34;https://github.com/farlee2121/FsSpec/issues/2&#34;&gt;a comment&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;What is FsSpec and why would you use it?&lt;/h2&gt; &#xA;&lt;h3&gt;Short Motivation&lt;/h3&gt; &#xA;&lt;p&gt;FsSpec represents value constraints as data to reuse one constraint declaration for validation, data generation, error explanation, and more.&lt;/p&gt; &#xA;&lt;p&gt;It also makes for a concise and consistent Type-Driven approach&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FsSpec&#xA;type InventoryCount = private InventoryCount of int&#xA;module InventoryCount = &#xA;    let spec = Spec.all [Spec.min 0; Spec.max 1000]&#xA;    let tryCreate n =&#xA;      Spec.validate spec n &#xA;      |&amp;gt; Result.map InventoryCount&#xA;&#xA;// Generate data&#xA;let inventoryAmounts = Gen.fromSpec InventoryCount.spec |&amp;gt; Gen.sample 0 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Longer Motivation&lt;/h3&gt; &#xA;&lt;p&gt;Type-Driven and/or Domain-Driven systems commonly model data types with constraints. For example,&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a string that represents an email or phone number (must match format)&lt;/li&gt; &#xA; &lt;li&gt;an inventory amount between 0 and 1000&lt;/li&gt; &#xA; &lt;li&gt;Birthdates (can&#39;t be in the future)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We centralize these constraints by wrapping them in a type, such as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type PhoneNumber = private PhoneNumber of string&#xA;module PhoneNumber = &#xA;    let tryCreate str =&#xA;      if (Regex(@&#34;\d{3}-\d{4}-\d{4}&#34;).IsMatch(str))&#xA;      then Some (PhoneNumber str)&#xA;      else None &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is great. It prevents defensive programming from leaking around the system and clearly encodes expectations on data. It avoids the downsides of &lt;a href=&#34;https://grabbagoft.blogspot.com/2007/12/dealing-with-primitive-obsession.html&#34;&gt;primitive obsession&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, we&#39;re missing out on some power. We&#39;re encoding constraints in a way that only gives us pass/fail validation. We have to duplicate constraint information if we want to explain a failed value, generate data, or similar actions.&lt;/p&gt; &#xA;&lt;p&gt;FsSpec represents these constraints as data so that our programs can understand the constraints on a value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let inventorySpec = Spec.all [Spec.min 0; Spec.max 1000]&#xA;&#xA;// Validation&#xA;Spec.isValid inventorySpec 20&#xA;&#xA;// Explanation: understand what constraints failed (as a data structure)&#xA;Spec.explain inventorySpec -1&#xA;&#xA;// Validation Messages&#xA;Spec.explain inventorySpec -1 |&amp;gt; Formatters.prefix_allresults // returns: &#34;-1 failed with: and [min 0 (FAIL); max 1000 (OK)]&#34;&#xA;&#xA;// Data Generation (with FsCheck)&#xA;Gen.fromSpec inventorySpec |&amp;gt; Gen.sample 0 10  // returns 10 values between 0 and 1000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are also other possibilities FsSpec doesn&#39;t have built-in. For example,&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Comparing specifications (i.e. is one a more constrained version of the other)&lt;/li&gt; &#xA; &lt;li&gt;Serialize and interpret constraints for use in different UI technologies&lt;/li&gt; &#xA; &lt;li&gt;Automatic generator registration with property testing libraries (e.g. FsCheck)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Spec Composition and Resuse&lt;/h2&gt; &#xA;&lt;p&gt;Specs are just values which can be stored and composed. This opens up opportunity for readable and reusable data constraints.&lt;/p&gt; &#xA;&lt;p&gt;For example, we can break up complex constraints&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let markdown = //could vary in complexity&#xA;let sanitizedMarkdown = markdown &amp;amp;&amp;amp;&amp;amp; //whatever sanitization looks like&#xA;let recipeIngredientSpec = sanitizedMarkdown &amp;amp;&amp;amp;&amp;amp; notEmpty &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Breaking out sub-constraints improves readability, but also identifies constraints we might reuse, like &lt;code&gt;markdown&lt;/code&gt; or maybe &lt;code&gt;FullName&lt;/code&gt;, &lt;code&gt;FutureDate&lt;/code&gt;, &lt;code&gt;PastDate&lt;/code&gt;, &lt;code&gt;NonNegativeInt&lt;/code&gt; etc.&lt;/p&gt; &#xA;&lt;p&gt;Such constraints can be centralized and reused like any other data (e.g. readonly members of a module). They do not have to be associated with a type, making them fairly light weight. There is also no duplication if such cross-cutting constraints change in the future.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Value Type using FsSpec&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s still a good idea to create value types for constrained values. Here&#39;s how you might do it with FsSpec&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FsSpec&#xA;type InventoryCount = private InventoryCount of int&#xA;module InventoryCount = &#xA;    let spec = Spec.all [Spec.min 0; Spec.max 1000]&#xA;    let tryCreate n =&#xA;      Spec.validate spec n &#xA;      |&amp;gt; Result.map InventoryCount&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Supported Constraints&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.all spec-list&lt;/code&gt;: Logical and. Requires all sub-specs to pass&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.any spec-list&lt;/code&gt;: Logical or. Requires at least one sub-spec to pass&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.min min&lt;/code&gt;: Minimum value, inclusive. Works for any &lt;code&gt;IComparable&amp;lt;&#39;a&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.max max&lt;/code&gt;: Maximum value, inclusive. Works for any &lt;code&gt;IComparable&amp;lt;&#39;a&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.regex pattern&lt;/code&gt;: String must match the given regex pattern. Only works for strings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.predicate label pred&lt;/code&gt;: Any predicate (&lt;code&gt;&#39;a -&amp;gt; bool&lt;/code&gt;) and a explanation/label&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.minLength min&lt;/code&gt;: set a minimum length for a string or any IEnumerable derivative&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.maxLength max&lt;/code&gt;: set a maximum length for a string or any IEnumerable derivative&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.values values&lt;/code&gt;: an explicit list of allowed values&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.notValues values&lt;/code&gt;: an explicit list of disallowed values&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Generation Limitations&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/FsSpec.FsCheck&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/fsspec.fscheck?label=NuGet%3A%20FsSpec.FsCheck&#34; alt=&#34;Nuget (with prereleases)&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Data generation can&#39;t be done efficiently for all specifications. The library recognizes &lt;a href=&#34;https://raw.githubusercontent.com/farlee2121/FsSpec/main/src/FsSpec.FsCheck/OptimizedCases.fs&#34;&gt;special cases&lt;/a&gt; and filters a standard generator of the base type for everything else.&lt;/p&gt; &#xA;&lt;p&gt;Supported cases&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Common ranges: most numeric ranges, date ranges &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Custom scenarios for other IComparable types would be easy to add, if you encounter a type that isn&#39;t supported.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Regular expressions&lt;/li&gt; &#xA; &lt;li&gt;Logical and/or scenarios&lt;/li&gt; &#xA; &lt;li&gt;String length&lt;/li&gt; &#xA; &lt;li&gt;Collection length: currently support &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, lists, arrays, and readonly lists and collections. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Dictionaries, sets, and other collections are not yet supported but should not be difficult to add if users find they need them.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Spec.values&lt;/code&gt;, an explicit list of allowed values &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;Spec.notValues&lt;/code&gt; works by filtering. This will likely fail if the disallowed values are a significant portion of the total possible values&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Predicates have limited generation support. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let spec = Spec.predicate &#34;predicate min/max&#34; (fun i -&amp;gt; 0 &amp;lt; i &amp;amp;&amp;amp; i &amp;lt; 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above case will probably not generate. It is filtering a list of randomly generated integers, and it is unlikely many of them will be in the narrow range of 0 to 5. FsSpec can&#39;t understand the intent of the predicate to create a smarter generator.&lt;/p&gt; &#xA;&lt;p&gt;Impossible specs (like &lt;code&gt;all [min 10; max 5]&lt;/code&gt;), also cannot produce generators. The library tries to catch impossible specs and thrown an error instead of returning a bad generator.&lt;/p&gt; &#xA;&lt;h2&gt;Complex / Composed Types&lt;/h2&gt; &#xA;&lt;p&gt;FsSpec doesn&#39;t currently support composed types like tuples, records, unions, and objects.&lt;/p&gt; &#xA;&lt;p&gt;The idea is that these types should enforce their expectations through the types they compose. Scott Wlaschin gives a &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/designing-with-types-representing-states/&#34;&gt;great example&lt;/a&gt; as part of his designing with types series.&lt;/p&gt; &#xA;&lt;p&gt;A short sample here.&lt;/p&gt; &#xA;&lt;p&gt;Sum types (i.e. unions) represent &#34;OR&#34;. Any valid value for any of their cases should be a valid union value. The cases themselves should be of types that enforces any necessary assumptions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Contact = &#xA;  | Phone of PhoneNumber&#xA;  | Email of Email&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Product types (records, tuples, objects) should represent &#34;AND&#34;. They expect their members to be filled. If a product type doesn&#39;t require all of it&#39;s members, the members that are not required should be made Options.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Person = {&#xA;  // each field enforces it&#39;s own constraints&#xA;  Name: FullName &#xA;  Phone: PhoneNumber option // use option for non-required fields&#xA;  Email: Email option&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rules involving multiple members should be refactored to a single member of a type that enforces the expectation. A common example is requiring a primary contact method, but allowing multiple contact methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Contact = &#xA;  | Phone of PhoneNumber&#xA;  | Email of Email&#xA;&#xA;type Person = {&#xA;  Name: FullName &#xA;  PrimaryContactInfo: Contact&#xA;  OtherContactInfo: Contact list&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://fsharpforfunandprofit.com/series/designing-with-types/&#34;&gt;Designing with Types&lt;/a&gt; (free blog series) or the fantastic &lt;a href=&#34;https://fsharpforfunandprofit.com/books/#domain-modeling-made-functional&#34;&gt;Domain Modeling Made Functional&lt;/a&gt; (book) for more detailed examples.&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;This library is early in development. The goal is to get feedback and test the library in real applications before adding too many features. Please leave a &lt;a href=&#34;https://github.com/farlee2121/FsSpec/issues/2&#34;&gt;comment&lt;/a&gt; with your feedback.&lt;/p&gt; &#xA;&lt;p&gt;Lines of inquiry include&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Improve customization: Explore how users most often need to extend or modify existing functionality. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;add formatting for their custom constraint?&lt;/li&gt; &#xA;   &lt;li&gt;mapping custom errors? / interpreting error scenarios?&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Identifying base set of constraints that should be built into the library&lt;/li&gt; &#xA; &lt;li&gt;Predicate spec meta: Potentially allow meta separate from predicates so instances of a similar custom constraints can leverage case specific info (e.g. if max were implemented as custom, making the max value accessible to custom formatters, comparisons, generators, etc)&lt;/li&gt; &#xA; &lt;li&gt;Not spec: Negate any specification. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This is easy to add for validation, but makes normalization for inferring generators more complex. It should be doable, but I have to consider negations of specs (i.e. max becomes min, regex becomes ???) and how that would impact other features like explanation&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Project Status&lt;/h2&gt; &#xA;&lt;p&gt;The most foundational features (validation, generation, explanation) are implemented and tested. The library should be reliable, but the public API is subject to change based on feedback.&lt;/p&gt; &#xA;&lt;p&gt;The main goal right now is to gather feedback, validate usefulness, and determine next steps, if any.&lt;/p&gt; &#xA;&lt;h2&gt;Inspiration&lt;/h2&gt; &#xA;&lt;p&gt;This library borrows inspiriation from many sources&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Type-driven Development &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://fsharpforfunandprofit.com/series/designing-with-types/&#34;&gt;Designing with Types&lt;/a&gt; by Scott Wlaschin&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://blog.ploeh.dk/2015/05/07/functional-design-is-intrinsically-testable/#aee72ce959654d9388b448023f469cbc&#34;&gt;Mark Seemann&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://clojure.org/about/spec&#34;&gt;Clojure.spec&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.martinfowler.com/apsupp/spec.pdf&#34;&gt;Specification Pattern&lt;/a&gt; by Eric Evans and Martin Fowler&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Domain-driven_design&#34;&gt;Domain Driven Design&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Original Experiments&lt;/h2&gt; &#xA;&lt;p&gt;I previously looked into adding constraints as a more integrated part of the F# type system. Those experiments failed, but are &lt;a href=&#34;https://github.com/farlee2121/FsSpec-OriginalExperiment&#34;&gt;still available to explore&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want such a type system, you might checkout &lt;a href=&#34;https://www.fstar-lang.org/&#34;&gt;F*&lt;/a&gt;, &lt;a href=&#34;https://www.idris-lang.org/&#34;&gt;Idris&lt;/a&gt;, or &lt;a href=&#34;https://github.com/dafny-lang/dafny&#34;&gt;Dafny&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>