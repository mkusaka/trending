<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-11T01:40:14Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>AngelMunoz/fable-bun</title>
    <updated>2022-07-11T01:40:14Z</updated>
    <id>tag:github.com,2022-07-11:/AngelMunoz/fable-bun</id>
    <link href="https://github.com/AngelMunoz/fable-bun" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A small experimental repository for bun.sh&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://bun.sh&#34;&gt;Bun.sh&lt;/a&gt; + Fable Playground&lt;/h1&gt; &#xA;&lt;p&gt;This is a small repo to add a few bindings for the node.js new competitor runtime &lt;a href=&#34;https://bun.sh&#34;&gt;bun.sh&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Although this is not something serious yet, if you actually want to work with me to make this a true bindings project let me know! I&#39;d be glad to work towards something like that&lt;/p&gt; &#xA;&lt;h2&gt;Fable.Bun&lt;/h2&gt; &#xA;&lt;p&gt;Fable.bun which can be found in &lt;code&gt;src/Fable.Bun&lt;/code&gt; are the bindings to Fable.Bun nothing more, nothing less, these are very minimal and only add a few convenience methods for Bun&#39;s request/response impl consumption&lt;/p&gt; &#xA;&lt;h1&gt;Bix&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bix&lt;/strong&gt; which can be found in &lt;code&gt;src/Bix&lt;/code&gt; is an F# microframework built on top of &lt;code&gt;Bun.serve&lt;/code&gt; although the name is just a &lt;em&gt;codename&lt;/em&gt; for now (until I decide it&#39;s good to go), this microframework is heavily inspired by &lt;a href=&#34;https://giraffe.wiki&#34;&gt;Giraffe&lt;/a&gt;, and &lt;a href=&#34;https://github.com/SaturnFramework/Saturn&#34;&gt;Saturn&lt;/a&gt; frameworks from F# land so if you have ever used that server model then Bix will feel fairly similar, I plan to add a saturn like router eventually but for the moment here&#39;s the sample code you might be looking for&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// For more information see https://aka.ms/fsharp-console-apps&#xA;open Bix&#xA;open Bix.Types&#xA;open Bix.Handlers&#xA;open Bix.Router&#xA;&#xA;&#xA;let checkCredentials: HttpHandler =&#xA;    fun next ctx -&amp;gt;&#xA;        let req: Request = ctx.Request&#xA;        let bearer = req.headers.get &#34;Authorization&#34; |&amp;gt; Option.ofObj&#xA;        // dummy handler&#xA;        match bearer with&#xA;        | None -&amp;gt; (setStatusCode (401) &amp;gt;=&amp;gt; sendText &#34;Not Authorized&#34;) next ctx&#xA;        | Some token -&amp;gt; next ctx&#xA;&#xA;let routes =&#xA;    Router.Empty&#xA;    |&amp;gt; Router.get (&#34;/&#34;, fun next ctx -&amp;gt; sendText &#34;Hello, World!&#34; next ctx)&#xA;    |&amp;gt; Router.get (&#34;/posts/:slug&#34;, fun next ctx -&amp;gt;&#xA;        promise { // promise based handlers are supported&#xA;            let slug = ctx.PathParams &#34;slug&#34;&#xA;            let! post = Database.find slug // database from somewhere&#xA;            let! html = Views.renderPost post // views from somewhere&#xA;            return! sendHtml html next ctx&#xA;        }&#xA;    )&#xA;    |&amp;gt; Router.get (&#34;/json&#34;, fun next ctx -&amp;gt;&#xA;        let content = {| name = &#34;Bix Server!&#34;; Date = System.DateTime.Now |}&#xA;        sendJson content next ctx&#xA;    )&#xA;    |&amp;gt; Router.get (&#34;/protected&#34;, (checkCredentials &amp;gt;=&amp;gt; (fun next ctx -&amp;gt; sendText &#34;I&#39;m protected!&#34; next ctx)))&#xA;&#xA;let server =&#xA;    Server.Empty&#xA;    |&amp;gt; Server.withRouter routes&#xA;    |&amp;gt; Server.withDevelopment true&#xA;    |&amp;gt; Server.withPort 5000&#xA;    |&amp;gt; Server.run&#xA;&#xA;let mode =&#xA;    if server.development then&#xA;        &#34;Development&#34;&#xA;    else&#xA;        &#34;Production&#34;&#xA;&#xA;printfn $&#34;{mode} Server started at {server.hostname}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Interested? check out the samples at &lt;code&gt;src/Fable.Bun.Sample/Program.fs&lt;/code&gt;, and &lt;code&gt;src/Fable.Bun.Sample/Handlers.fs&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;.NET6 and above - &lt;a href=&#34;https://get.dot.net&#34;&gt;https://get.dot.net&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Bun - &lt;a href=&#34;https://bun.sh&#34;&gt;bun.sh&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Try the sample&lt;/h2&gt; &#xA;&lt;p&gt;After installing .NET + Bun just run&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;bun start&lt;/code&gt; on your terminal and it should just work&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>pimbrouwers/Falco</title>
    <updated>2022-07-11T01:40:14Z</updated>
    <id>tag:github.com,2022-07-11:/pimbrouwers/Falco</id>
    <link href="https://github.com/pimbrouwers/Falco" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Functional-first toolkit for building brilliant ASP.NET Core applications using F#.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Falco&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.nuget.org/packages/Falco&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/Falco.svg?sanitize=true&#34; alt=&#34;NuGet Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.org/pimbrouwers/Falco&#34;&gt;&lt;img src=&#34;https://travis-ci.org/pimbrouwers/Falco.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Falco&#xA;open Falco.Routing&#xA;open Falco.HostBuilder&#xA;&#xA;webHost [||] {&#xA;    endpoints [                    &#xA;        get &#34;/&#34; (Response.ofPlainText &#34;Hello World&#34;)&#xA;    ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pimbrouwers/Falco&#34;&gt;Falco&lt;/a&gt; is a toolkit for building fast, functional-first and fault-tolerant web applications using F#.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Built upon the high-performance primitives of ASP.NET Core.&lt;/li&gt; &#xA; &lt;li&gt;Optimized for building HTTP applications quickly.&lt;/li&gt; &#xA; &lt;li&gt;Seamlessly integrates with existing .NET Core middleware and frameworks.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Key Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Asynchronous &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#request-handling&#34;&gt;request handling&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Simple and powerful &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#routing&#34;&gt;routing&lt;/a&gt; API.&lt;/li&gt; &#xA; &lt;li&gt;Fast, secure and configurable &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#host-builder&#34;&gt;web server&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Native F# &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#markup&#34;&gt;view engine&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Uniform API for &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#model-binding&#34;&gt;model binding&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#authentication&#34;&gt;Authentication&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#security&#34;&gt;security&lt;/a&gt; utilities.&lt;/li&gt; &#xA; &lt;li&gt;Built-in support for &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#handling-large-uploads&#34;&gt;large uploads&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Design Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Provide a toolset to build a working full-stack web application.&lt;/li&gt; &#xA; &lt;li&gt;Can be easily learned.&lt;/li&gt; &#xA; &lt;li&gt;Should be extensible.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#sample-applications&#34;&gt;Sample Applications&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#request-handling&#34;&gt;Request Handling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#routing&#34;&gt;Routing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#model-binding&#34;&gt;Model Binding&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#json&#34;&gt;JSON&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#markup&#34;&gt;Markup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#host-builder&#34;&gt;Host Builder&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#authentication&#34;&gt;Authentication&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#security&#34;&gt;Security&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#why-falco&#34;&gt;Why &#34;Falco&#34;?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#find-a-bug&#34;&gt;Find a bug?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Using &lt;code&gt;dotnet new&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The easiest way to get started with Falco is by installing the &lt;code&gt;Falco.Template&lt;/code&gt; package, which adds a new template to your &lt;code&gt;dotnet new&lt;/code&gt; command line tool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;dotnet new -i &#34;Falco.Template::*&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Afterwards you can create a new Falco application by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;dotnet new falco -o HelloWorldApp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Manually installing&lt;/h3&gt; &#xA;&lt;p&gt;Create a new F# web project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;dotnet new web -lang F# -o HelloWorldApp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install the nuget package:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;dotnet add package Falco&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Remove the &lt;code&gt;Startup.fs&lt;/code&gt; file and save the following in &lt;code&gt;Program.fs&lt;/code&gt; (if following the manual install path):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module HelloWorld.Program&#xA;&#xA;open Falco&#xA;open Falco.Routing&#xA;open Falco.HostBuilder&#xA;&#xA;[&amp;lt;EntryPoint&amp;gt;]&#xA;let main args =&#xA;    webHost args {&#xA;        endpoints [ &#xA;            get &#34;/&#34; (Response.ofPlainText &#34;Hello World&#34;)&#xA;        ]&#xA;    }&#xA;    0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;dotnet run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There you have it, an industrial-strength &lt;a href=&#34;https://github.com/pimbrouwers/Falco/tree/master/samples/HelloWorld&#34;&gt;Hello World&lt;/a&gt; web app, achieved using only base ASP.NET Core libraries. Pretty sweet!&lt;/p&gt; &#xA;&lt;h2&gt;Sample Applications&lt;/h2&gt; &#xA;&lt;p&gt;Code is always worth a thousand words, so for the most up-to-date usage, the &lt;a href=&#34;https://github.com/pimbrouwers/Falco/tree/master/samples&#34;&gt;/samples&lt;/a&gt; directory contains a few sample applications.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Sample&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pimbrouwers/Falco/tree/master/samples/HelloWorld&#34;&gt;Hello World&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A basic hello world app&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pimbrouwers/Falco/tree/master/samples/ConfigureHost&#34;&gt;Configure Host&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Demonstrating how to configure the &lt;code&gt;IHost&lt;/code&gt; instance using the &lt;code&gt;webHost&lt;/code&gt; computation expression&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pimbrouwers/Falco/tree/master/samples/Blog&#34;&gt;Blog&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A basic markdown (with YAML frontmatter) blog&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pimbrouwers/Falco/tree/master/samples/ScribanExample&#34;&gt;Third-part View Engine&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Demonstrating how to render with an external view engine, specifically &lt;a href=&#34;https://github.com/scriban/scriban&#34;&gt;Scriban&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pimbrouwers/FalcoJournal&#34;&gt;Falco Journal&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A bullet journal built using Falco&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Request Handling&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;HttpHandler&lt;/code&gt; type is used to represent the processing of a request. It can be thought of as the eventual (i.e. asynchronous) completion and processing of an HTTP request, defined in F# as: &lt;code&gt;HttpContext -&amp;gt; Task&lt;/code&gt;. Handlers will typically involve some combination of: route inspection, form/query binding, business logic and finally response writing. With access to the &lt;code&gt;HttpContext&lt;/code&gt; you are able to inspect all components of the request, and manipulate the response in any way you choose.&lt;/p&gt; &#xA;&lt;p&gt;Basic request/response handling is divided between the aptly named &lt;a href=&#34;https://github.com/pimbrouwers/Falco/tree/master/src/Request.fs&#34;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/pimbrouwers/Falco/tree/master/src/Response.fs&#34;&gt;&lt;code&gt;Response&lt;/code&gt;&lt;/a&gt; modules, which offer a suite of continuation-passing style (CPS) &lt;code&gt;HttpHandler&lt;/code&gt; functions for common scenarios.&lt;/p&gt; &#xA;&lt;h3&gt;Plain Text responses&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let textHandler : HttpHandler =&#xA;    Response.ofPlainText &#34;hello world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;HTML responses&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let htmlHandler : HttpHandler =&#xA;    let html =&#xA;        Elem.html [ Attr.lang &#34;en&#34; ] [&#xA;            Elem.head [] []&#xA;            Elem.body [] [&#xA;                Elem.h1 [] [ Text.raw &#34;Sample App&#34; ]                &#xA;            ]&#xA;        ]&#xA;&#xA;    Response.ofHtml html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, if you&#39;re using an external view engine and want to return an HTML response from a string literal, then you can use &lt;code&gt;Response.ofHtmlString&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let htmlHandler : HttpHandler = &#xA;    Response.ofHtmlString &#34;&amp;lt;html&amp;gt;...&amp;lt;/html&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JSON responses&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;IMPORTANT: This handler uses the default &lt;code&gt;System.Text.Json.JsonSerializer&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#json&#34;&gt;JSON&lt;/a&gt; section below for further information.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Person =&#xA;    { First : string&#xA;      Last  : string }&#xA;&#xA;let jsonHandler : HttpHandler =&#xA;    let name = { First = &#34;John&#34;; Last = &#34;Doe&#34; }&#xA;    Response.ofJson name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Redirect (301/302) Response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let oldUrlHandler : HttpHandler =&#xA;    Response.redirect &#34;/new-url&#34; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: The trailing &lt;code&gt;bool&lt;/code&gt; value is used to indicate permanency (i.e., true = 301 / false = 302)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Accessing Request Data&lt;/h2&gt; &#xA;&lt;p&gt;Falco exposes a &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#model-binding&#34;&gt;uniform API&lt;/a&gt; to obtain typed values from the various sources of request data. Note, the similarity in the various binders below.&lt;/p&gt; &#xA;&lt;h3&gt;Route Collection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let helloHandler : HttpHandler =&#xA;    let routeMap (route : RouteCollectionReader) =&#xA;        let name = route.GetString &#34;name&#34; &#34;World&#34; &#xA;        sprintf &#34;Hello %s&#34; name&#xA;        &#xA;    Request.mapRoute routeMap Response.ofPlainText&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Query Parameters&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let helloHandler : HttpHandler =&#xA;    let queryMap (query : QueryCollectionReader) =&#xA;        let name = query.GetString &#34;name&#34; &#34;World&#34; &#xA;        sprintf &#34;Hello %s&#34; name&#xA;        &#xA;    Request.mapQuery queryMap Response.ofPlainText&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Form Data&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let helloHandler : HttpHandler =&#xA;    let formMap (query : FormCollectionReader) =&#xA;        let name = query.GetString &#34;name&#34; &#34;World&#34; &#xA;        sprintf &#34;Hello %s&#34; name&#xA;        &#xA;    Request.mapForm formMap Response.ofPlainText&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To prevent XSS attacks it is often advisable to use a &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#security&#34;&gt;CSRF token&lt;/a&gt; during form submissions. In these situations, you&#39;ll want to validate the token before processing the form input using the &lt;code&gt;Request.mapFormSecure&lt;/code&gt; (or &lt;code&gt;Request.bindFormSecure&lt;/code&gt;). These functions will automatically validate the token for you before consuming input.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let secureHelloHandler : HttpHandler =&#xA;    let formMap (query : FormCollectionReader) =&#xA;        let name = query.GetString &#34;name&#34; &#34;World&#34; &#xA;        sprintf &#34;Hello %s&#34; name&#xA;&#xA;    let invalidTokenHandler : HttpHandler =&#xA;        Response.withStatusCode 403&#xA;        &amp;gt;&amp;gt; Resposne.ofEmpty&#xA;        &#xA;    Request.mapFormSecure formMap Response.ofPlainText invalidTokenHandler&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Response Modifiers&lt;/h2&gt; &#xA;&lt;p&gt;Response modifiers can be thought of as the in-and-out modification of the &lt;code&gt;HttpResponse&lt;/code&gt;. A preamble to writing and returning. Since these functions receive the &lt;code&gt;Httpcontext&lt;/code&gt; as input and return it as the only output, they can take advantage of &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/22&#34;&gt;function compoistion&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Set the status code of the response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let notFoundHandler : HttpHandler =&#xA;    Response.withStatusCode 404&#xA;    &amp;gt;&amp;gt; Response.ofPlainText &#34;Not found&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Add a header to the response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handlerWithHeader : HttpHandler =&#xA;    Response.withHeader &#34;Content-Language&#34; &#34;en-us&#34;&#xA;    &amp;gt;&amp;gt; Response.ofPlainText &#34;Hello world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Add a cookie to the response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handlerWithHeader : HttpHandler =&#xA;    Response.withCookie &#34;greeted&#34; &#34;1&#34;&#xA;    &amp;gt;&amp;gt; Response.ofPlainText &#34;Hello world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;IMPORTANT: &lt;em&gt;Do not&lt;/em&gt; use this for authentication. Instead use the &lt;code&gt;Auth.signIn&lt;/code&gt; and &lt;code&gt;Auth.signOut&lt;/code&gt; functions found in the &lt;a href=&#34;https://raw.githubusercontent.com/pimbrouwers/Falco/master/#authentication&#34;&gt;Authentication&lt;/a&gt; module.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Routing&lt;/h2&gt; &#xA;&lt;p&gt;The breakdown of &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1#configuring-endpoint-metadata&#34; title=&#34;EndpointRouting in ASP.NET Core&#34;&gt;Endpoint Routing&lt;/a&gt; is simple. Associate a specific &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1#route-template-reference&#34;&gt;route pattern&lt;/a&gt; (and optionally an HTTP verb) to an &lt;code&gt;HttpHandler&lt;/code&gt; which represents the ongoing processing (and eventual return) of a request.&lt;/p&gt; &#xA;&lt;p&gt;Bearing this in mind, routing can practically be represented by a list of these &#34;mappings&#34; known in Falco as an &lt;code&gt;HttpEndpoint&lt;/code&gt; which bind together: a route, verb and handler.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let helloHandler : HttpHandler =&#xA;    let getMessage (route : RouteCollectionReader) =&#xA;        route.GetString &#34;name&#34; &#34;World&#34; &#xA;        |&amp;gt; sprintf &#34;Hello %s&#34;&#xA;        &#xA;    Request.mapRoute getMessage Response.ofPlainText&#xA;&#xA;let loginHandler : HttpHandler = // ...&#xA;&#xA;let loginSubmitHandler : HttpHandler = // ...  &#xA;&#xA;let endpoints : HttpEndpoint list =&#xA;  [&#xA;    // a basic GET handler&#xA;    get &#34;/hello/{name:alpha}&#34; helloHandler&#xA;&#xA;    // multi-method endpoint&#xA;    all &#34;/login&#34;&#xA;        [ POST, loginSubmitHandler&#xA;          GET,  loginHandler ]&#xA;  ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Model Binding&lt;/h2&gt; &#xA;&lt;p&gt;Reflection-based approaches to binding at IO boundaries work well for simple use cases. But as the complexity of the input rises it becomes error-prone and often involves tedious workarounds. This is especially true for an expressive, algebraic type system like F#. As such, it is often advisable to take back control of this process from the runtime. An added bonus of doing this is that it all but eliminates the need for &lt;code&gt;[&amp;lt;CLIMutable&amp;gt;]&lt;/code&gt; attributes.&lt;/p&gt; &#xA;&lt;p&gt;We can make this simpler by creating a succinct API to obtain typed values from &lt;code&gt;IFormCollection&lt;/code&gt;, &lt;code&gt;IQueryCollection&lt;/code&gt;, &lt;code&gt;RouteValueDictionary&lt;/code&gt; and &lt;code&gt;IHeaderCollection&lt;/code&gt;. &lt;em&gt;Readers&lt;/em&gt; for all four exist as derivatives of &lt;code&gt;StringCollectionReader&lt;/code&gt; which is an abstraction intended to make it easier to work with the string-based key/value collections.&lt;/p&gt; &#xA;&lt;p&gt;The built-in model binding handlers come in two flavors, both of which are continuation-style handlers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Request.mapXXX&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Signature: &lt;code&gt;(map: XXXCollectionReader -&amp;gt; &#39;a) (next : &#39;a -&amp;gt; HttpHandler) -&amp;gt; HttpHandler&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;The &#34;map&#34; family of handlers are more commonly used and assume that binding will always succeed in one manner or another, either via default values or &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Request.bindXXX&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Signature: &lt;code&gt;(bind: XXXCollectionReader -&amp;gt; Result&amp;lt;&#39;a, &#39;b&amp;gt;) (handleOk : &#39;a -&amp;gt; HttpHandler) -&amp;gt; (handleError : &#39;b -&amp;gt; HttpHandler) -&amp;gt; HttpHandler&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;The &#34;bind&#34; family of handlers are useful when you explicitly want to indicate errors during binding and return a different response when they occur.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Route Binding&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapRouteHandler : HttpHandler =&#xA;    let routeMap (r : RouteCollectionReader) = &#xA;        r.GetString &#34;Name&#34; &#34;John Doe&#34;&#xA;    &#xA;    Request.mapRoute routeMap Response.ofJson&#xA;&#xA;let bindRouteHandler : HttpHandler = &#xA;    let routeBind (r : RouteCollectionReader) =&#xA;        match r.TryGetString &#34;Name&#34; with&#xA;        | Some name -&amp;gt; Ok name&#xA;        | _         -&amp;gt; Error {| Message = &#34;Invalid route&#34; |}&#xA;    &#xA;    let handleOk = Response.ofJson&#xA;    let handleError = Response.ofJson&#xA;&#xA;    Request.bindRoute routeBind handleOk handleError&#xA;&#xA;let manualRouteHandler : HttpHandler = fun ctx -&amp;gt;&#xA;    let r : RouteCollectionReader = Request.getRoute ctx&#xA;    let name = r.GetString &#34;Name&#34; &#34;John Doe&#34;  &#xA;&#xA;    Response.ofJson name ctx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Query Binding&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Person = { FirstName : string; LastName : string }&#xA;&#xA;let mapQueryHandler : HttpHandler =    &#xA;    let queryMap (q : QueryCollectionReader) =&#xA;        let first = q.GetString &#34;FirstName&#34; &#34;John&#34; // Get value or return default value&#xA;        let last = q.GetString &#34;LastName&#34; &#34;Doe&#34;&#xA;        { FirstName = first; LastName = last }&#xA;&#xA;    Request.mapQuery queryMap Response.ofJson &#xA;&#xA;let bindQueryHandler : HttpHandler = &#xA;    let queryBind (q : QueryCollectionReader) =&#xA;        match q.TryGetString &#34;FirstName&#34;, q.TryGetString &#34;LastName&#34; with&#xA;        | Some f, Some l -&amp;gt; Ok { FirstName = f; LastName = l }&#xA;        | _  -&amp;gt; Error {| Message = &#34;Invalid query string&#34; |}&#xA;&#xA;    let handleOk = Response.ofJson&#xA;    let handleError = Response.ofJson&#xA;&#xA;    Request.bindQuery queryBind handleOk handleError &#xA;&#xA;let manualQueryHandler : HttpHandler = fun ctx -&amp;gt;&#xA;    let q : QueryCollectionReader = Request.getQuery ctx&#xA;    &#xA;    let person = &#xA;        { FirstName = q.GetString &#34;FirstName&#34; &#34;John&#34; // Get value or return default value&#xA;          LastName  = q.GetString &#34;LastName&#34; &#34;Doe&#34; }&#xA;&#xA;    Response.ofJson person ctx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Form Binding&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;FormCollectionReader&lt;/code&gt; has full access to the &lt;code&gt;IFormFilesCollection&lt;/code&gt; via the &lt;code&gt;_.Files&lt;/code&gt; member.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note the addition of &lt;code&gt;Request.mapFormSecure&lt;/code&gt; and &lt;code&gt;Request.bindFormSecure&lt;/code&gt; which will automatically validate CSRF tokens for you.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Person = { FirstName : string; LastName : string }&#xA;&#xA;let mapFormHandler : HttpHandler =   &#xA;    let formMap (f : FormCollectionReader) =&#xA;        let first = f.GetString &#34;FirstName&#34; &#34;John&#34; // Get value or return default value&#xA;        let last = f.GetString &#34;LastName&#34; &#34;Doe&#34;        &#xA;        { FirstName = first; LastName = last }&#xA;&#xA;    Request.mapForm formMap Response.ofJson &#xA;&#xA;let mapFormSecureHandler : HttpHandler =    &#xA;    let formMap (f : FormCollectionReader) =&#xA;        let first = f.GetString &#34;FirstName&#34; &#34;John&#34; // Get value or return default value&#xA;        let last = f.GetString &#34;LastName&#34; &#34;Doe&#34;        &#xA;        { FirstName = first; LastName = last }&#xA;&#xA;    let handleInvalidCsrf : HttpHandler = &#xA;        Response.withStatusCode 400 &amp;gt;&amp;gt; Response.ofEmpty&#xA;&#xA;    Request.mapFormSecure formMap Response.ofJson handleInvalidCsrf&#xA;&#xA;let bindFormHandler : HttpHandler = &#xA;    let formBind (f : FormCollectionReader) =&#xA;        match f.TryGetString &#34;FirstName&#34;, f.TryGetString &#34;LastName&#34; with&#xA;        | Some f, Some l -&amp;gt; Ok { FirstName = f; LastName = l }&#xA;        | _  -&amp;gt; Error {| Message = &#34;Invalid form data&#34; |}&#xA;&#xA;    let handleOk = Response.ofJson&#xA;    let handleError = Response.ofJson&#xA;&#xA;    Request.bindForm formBind handleOk handleError &#xA;&#xA;let bindFormSecureHandler : HttpHandler = &#xA;    let formBind (f : FormCollectionReader) =&#xA;        match f.TryGetString &#34;FirstName&#34;, f.TryGetString &#34;LastName&#34; with&#xA;        | Some f, Some l -&amp;gt; Ok { FirstName = f; LastName = l }&#xA;        | _  -&amp;gt; Error {| Message = &#34;Invalid form data&#34; |}&#xA;&#xA;    let handleOk = Response.ofJson&#xA;    let handleError = Response.ofJson&#xA;    let handleInvalidCsrf : HttpHandler = &#xA;        Response.withStatusCode 400 &amp;gt;&amp;gt; Response.ofEmpty&#xA;&#xA;    Request.bindFormSecure formBind handleOk handleError handleInvalidCsrf&#xA;&#xA;let manualFormHandler : HttpHandler = fun ctx -&amp;gt; task {&#xA;    let! f : FormCollectionReader = Request.getForm ctx&#xA;    &#xA;    let person = &#xA;        { FirstName = f.GetString &#34;FirstName&#34; &#34;John&#34; // Get value or return default value&#xA;          LastName = f.GetString &#34;LastName&#34; &#34;Doe&#34; }&#xA;&#xA;    return! Response.ofJson person ctx&#xA;}        &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;code&gt;multipart/form-data&lt;/code&gt; Binding&lt;/h4&gt; &#xA;&lt;p&gt;Microsoft defines &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-3.1#upload-large-files-with-streaming&#34; title=&#34;Large file uploads&#34;&gt;large uploads&lt;/a&gt; as anything &lt;strong&gt;&amp;gt; 64KB&lt;/strong&gt;, which well... is most uploads. Anything beyond this size and they recommend streaming the multipart data to avoid excess memory consumption.&lt;/p&gt; &#xA;&lt;p&gt;To make this process &lt;strong&gt;a lot&lt;/strong&gt; easier Falco provides a set of four &lt;code&gt;HttpHandler&lt;/code&gt;&#39;s analogous to the form handlers above, which utilize an &lt;code&gt;HttpContext&lt;/code&gt; extension method called &lt;code&gt;TryStreamFormAsync()&lt;/code&gt; that will attempt to stream multipart form data, or return an error message indicating the likely problem.&lt;/p&gt; &#xA;&lt;p&gt;Below is an example demonstrating the insecure map variant:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let imageUploadHandler : HttpHandler =&#xA;    let formBinder (f : FormCollectionReader) : IFormFile option =&#xA;        f.TryGetFormFile &#34;profile_image&#34;&#xA;    &#xA;    let uploadImage (profileImage : IFormFile option) : HttpHandler = &#xA;        // Process the uploaded file ...&#xA;&#xA;    // Safely buffer the multipart form submission&#xA;    Request.mapFormStream formBinder uploadImage&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;JSON&lt;/h2&gt; &#xA;&lt;p&gt;Included in Falco are basic JSON in/out handlers, &lt;code&gt;Request.bindJson&lt;/code&gt; and &lt;code&gt;Response.ofJson&lt;/code&gt; respectively. Both rely on &lt;code&gt;System.Text.Json&lt;/code&gt; and thus have minimal support for F#&#39;s algebraic types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Person = { FirstName : string; LastName : string }&#xA;&#xA;let jsonHandler : HttpHandler =&#xA;    { FirstName = &#34;John&#34;; LastName = &#34;Doe&#34; }&#xA;    |&amp;gt; Response.ofJson&#xA;&#xA;let jsonBindHandler : HttpHandler =    &#xA;    let handleOk person : HttpHandler = &#xA;        let message = sprintf &#34;hello %s %s&#34; person.First person.Last&#xA;        Response.ofPlainText message&#xA;&#xA;    let handleError error : HttpHandler = &#xA;        let message = sprintf &#34;Invalid JSON: %s&#34; error&#xA;        Response.withStatusCode 400 &amp;gt;&amp;gt; Response.ofPlainText message&#xA;&#xA;    Request.bindJson handleOk handleError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Markup&lt;/h2&gt; &#xA;&lt;p&gt;A core feature of Falco is the XML markup module. It can be used to produce any form of angle-bracket markup (i.e. HTML, SVG, XML etc.).&lt;/p&gt; &#xA;&lt;p&gt;For example, the module is easily extended since creating new tags is simple. An example to render &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt;&#39;s:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let svg (width : float) (height : float) =&#xA;    Elem.tag &#34;svg&#34; [&#xA;        Attr.create &#34;version&#34; &#34;1.0&#34;&#xA;        Attr.create &#34;xmlns&#34; &#34;http://www.w3.org/2000/svg&#34;&#xA;        Attr.create &#34;viewBox&#34; (sprintf &#34;0 0 %f %f&#34; width height)&#xA;    ]&#xA;&#xA;let path d = Elem.tag &#34;path&#34; [ Attr.create &#34;d&#34; d ] []&#xA;&#xA;let bars =&#xA;    svg 384.0 384.0 [&#xA;        path &#34;M368 154.668H16c-8.832 0-16-7.168-16-16s7.168-16 16-16h352c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 0M368 32H16C7.168 32 0 24.832 0 16S7.168 0 16 0h352c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 0M368 277.332H16c-8.832 0-16-7.168-16-16s7.168-16 16-16h352c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 0&#34;&#xA;    ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;HTML View Engine&lt;/h3&gt; &#xA;&lt;p&gt;Most of the standard HTML tags &amp;amp; attributes have been built into the markup module and produce objects to represent the HTML node. Nodes are either:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Text&lt;/code&gt; which represents &lt;code&gt;string&lt;/code&gt; values. (Ex: &lt;code&gt;Text.raw &#34;hello&#34;&lt;/code&gt;, &lt;code&gt;Text.rawf &#34;hello %s&#34; &#34;world&#34;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SelfClosingNode&lt;/code&gt; which represent self-closing tags (Ex: &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ParentNode&lt;/code&gt; which represent typical tags with, optionally, other tags within it (Ex: &lt;code&gt;&amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The benefits of using the Falco markup module as an HTML engine include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Writing your views in plain F#, directly in your assembly.&lt;/li&gt; &#xA; &lt;li&gt;Markup is compiled alongside the rest of your code, leading to improved performance and ultimately simpler deployments.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Create an HTML5 document using built-in template&#xA;let doc = &#xA;    Templates.html5 &#34;en&#34;&#xA;        [ Elem.title [] [ Text.raw &#34;Sample App&#34; ] ] // &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&#xA;        [ Elem.h1 [] [ Text.raw &#34;Sample App&#34; ] ]    // &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since views are plain F# they can easily be made strongly-typed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Person = { FirstName : string; LastName : string }&#xA;&#xA;let doc (person : Person) = &#xA;    Elem.html [ Attr.lang &#34;en&#34; ] [&#xA;        Elem.head [] [                    &#xA;            Elem.title [] [ Text.raw &#34;Sample App&#34; ]                                                            &#xA;        ]&#xA;        Elem.body [] [                     &#xA;            Elem.main [] [&#xA;                Elem.h1 [] [ Text.raw &#34;Sample App&#34; ]&#xA;                Elem.p  [] [ Text.rawf &#34;%s %s&#34; person.First person.Last ]&#xA;            ]&#xA;        ]&#xA;    ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Views can also be combined to create more complex views and share output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let master (title : string) (content : XmlNode list) =&#xA;    Elem.html [ Attr.lang &#34;en&#34; ] [&#xA;        Elem.head [] [                    &#xA;            Elem.title [] [ Text.raw &#34;Sample App&#34; ]                                                            &#xA;        ]&#xA;        Elem.body [] content&#xA;    ]&#xA;&#xA;let divider = &#xA;    Elem.hr [ Attr.class&#39; &#34;divider&#34; ]&#xA;&#xA;let homeView =&#xA;    [&#xA;        Elem.h1 [] [ Text.raw &#34;Homepage&#34; ]&#xA;        divider&#xA;        Elem.p  [] [ Text.raw &#34;Lorem ipsum dolor sit amet, consectetur adipiscing.&#34;]&#xA;    ]&#xA;    |&amp;gt; master &#34;Homepage&#34; &#xA;&#xA;let aboutView =&#xA;    [&#xA;        Elem.h1 [] [ Text.raw &#34;About&#34; ]&#xA;        divider&#xA;        Elem.p  [] [ Text.raw &#34;Lorem ipsum dolor sit amet, consectetur adipiscing.&#34;]&#xA;    ]&#xA;    |&amp;gt; master &#34;About Us&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Host Builder&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.1&#34; title=&#34;Kestrel web server implementation in ASP.NET Core&#34;&gt;Kestrel&lt;/a&gt; is the web server at the heart of ASP.NET. It&#39;s performant, secure, and maintained by incredibly smart people. Getting it up and running is usually done using &lt;code&gt;Host.CreateDefaultBuilder(args)&lt;/code&gt;, but it can grow verbose quickly.&lt;/p&gt; &#xA;&lt;p&gt;To make things more expressive, Falco exposes an optional computation expression. Below is an example using the builder taken from the &lt;a href=&#34;https://github.com/pimbrouwers/Falco/tree/master/samples/ConfigureHost&#34;&gt;Configure Host&lt;/a&gt; sample.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;[&amp;lt;EntryPoint&amp;gt;]&#xA;let main args = &#xA;    webHost args {&#xA;        use_ifnot FalcoExtensions.IsDevelopment HstsBuilderExtensions.UseHsts&#xA;        use_https&#xA;        use_compression&#xA;        use_static_files&#xA;&#xA;        use_if    FalcoExtensions.IsDevelopment DeveloperExceptionPageExtensions.UseDeveloperExceptionPage&#xA;        use_ifnot FalcoExtensions.IsDevelopment (FalcoExtensions.UseFalcoExceptionHandler exceptionHandler)&#xA;&#xA;        endpoints [            &#xA;            get &#34;/greet/{name:alpha}&#34; &#xA;                handleGreeting&#xA;&#xA;            get &#34;/json&#34; &#xA;                handleJson&#xA;&#xA;            get &#34;/html&#34; &#xA;                handleHtml&#xA;                &#xA;            get &#34;/&#34; &#xA;                handlePlainText&#xA;        ]&#xA;    }&#xA;    0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fully Customizing the Host&lt;/h3&gt; &#xA;&lt;p&gt;To assume full control over configuring your &lt;code&gt;IHost&lt;/code&gt; use the &lt;code&gt;configure&lt;/code&gt; custom operation. It expects a function with the signature of &lt;code&gt;HttpEndpoint list -&amp;gt; IWebHostBuilder -&amp;gt; IWebHostBuilder&lt;/code&gt; and assumes you will register and activate Falco (i.e., &lt;code&gt;AddFalco()&lt;/code&gt; and &lt;code&gt;UseFalco(endpoints)&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;[&amp;lt;EntryPoint&amp;gt;]&#xA;let main args = &#xA;    let configureServices : IServiceCollection -&amp;gt; unit = &#xA;      fun services -&amp;gt; services.AddFalco() |&amp;gt; ignore&#xA;    &#xA;    let configureApp : HttpEndpoint list -&amp;gt; IApplicationBuilder -&amp;gt; unit =&#xA;       fun endpoints app -&amp;gt; app.UseFalco(endpoints) |&amp;gt; ignore&#xA;&#xA;    let configureWebHost : HttpEndpoint list -&amp;gt; IWebHostBuilder =&#xA;      fun endpoints webHost -&amp;gt;&#xA;          webHost.ConfigureLogging(configureLogging)&#xA;                 .ConfigureServices(configureServices)&#xA;                 .Configure(configureApp endpoints)&#xA;&#xA;    webHost args {&#xA;      configure configureWebHost&#xA;      endpoints []&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Authentication&lt;/h2&gt; &#xA;&lt;p&gt;ASP.NET Core has amazing built-in support for authentication. Review the &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/security/authentication/?view=aspnetcore-3.1&#34; title=&#34;Overview of ASP.NET Core authentication&#34;&gt;docs&lt;/a&gt; for specific implementation details. Falco includes some authentication utilities.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;To use the authentication helpers, ensure the service has been registered (&lt;code&gt;AddAuthentication()&lt;/code&gt;) with the &lt;code&gt;IServiceCollection&lt;/code&gt; and activated (&lt;code&gt;UseAuthentication()&lt;/code&gt;) using the &lt;code&gt;IApplicationBuilder&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Prevent user from accessing secure endpoint:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Falco.Security&#xA;&#xA;let secureResourceHandler : HttpHandler =&#xA;    let handleAuth : HttpHandler = &#xA;        &#34;hello authenticated user&#34;&#xA;        |&amp;gt; Response.ofPlainText &#xA;&#xA;    let handleInvalid : HttpHandler =&#xA;        Response.withStatusCode 403 &#xA;        &amp;gt;&amp;gt; Response.ofPlainText &#34;Forbidden&#34;&#xA;&#xA;    Request.ifAuthenticated handleAuth handleInvalid&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Prevent authenticated user from accessing anonymous-only end-point:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let anonResourceOnlyHandler : HttpHandler =&#xA;    let handleAnon : HttpHandler = &#xA;        Response.ofPlainText &#34;hello anonymous&#34;&#xA;&#xA;    let handleInvalid : HttpHandler = &#xA;        Response.withStatusCode 403 &#xA;        &amp;gt;&amp;gt; Response.ofPlainText &#34;Forbidden&#34;&#xA;&#xA;    Request.ifNotAuthenticated handleAnon handleInvalid&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Allow only user&#39;s from a certain group to access endpoint&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let secureResourceHandler : HttpHandler =&#xA;    let handleAuthInRole : HttpHandler = &#xA;        Response.ofPlainText &#34;hello admin&#34;&#xA;&#xA;    let handleInvalid : HttpHandler = &#xA;        Response.withStatusCode 403 &#xA;        &amp;gt;&amp;gt; Response.ofPlainText &#34;Forbidden&#34;&#xA;&#xA;    let rolesAllowed = [ &#34;Admin&#34; ]&#xA;&#xA;    Request.ifAuthenticatedInRole rolesAllowed handleAuthInRole handleInvalid&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Allow only user&#39;s with a certain scope to access endpoint&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let secureResourceHandler : HttpHandler =&#xA;    let handleAuthHasScope : HttpHandler = &#xA;        Response.ofPlainText &#34;user1, user2, user3&#34;&#xA;&#xA;    let handleInvalid : HttpHandler = &#xA;        Response.withStatusCode 403 &#xA;        &amp;gt;&amp;gt; Response.ofPlainText &#34;Forbidden&#34;&#xA;&#xA;    let issuer = &#34;https://oauth2issuer.com&#34;&#xA;    let scope = &#34;read:users&#34;&#xA;&#xA;    Request.ifAuthenticatedWithScope issuer scope handleAuthHasScope handleInvalid&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;End user session (sign out):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let logOut : HttpHandler =         &#xA;    let authScheme = &#34;...&#34;&#xA;    let redirectTo = &#34;/login&#34;&#xA;&#xA;    Response.signOutAndRedirect authScheme redirectTo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;Cross-site scripting attacks are extremely common since they are quite simple to carry out. Fortunately, protecting against them is as easy as performing them.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-3.1&#34; title=&#34;Prevent Cross-Site Request Forgery (XSRF/CSRF) attacks in ASP.NET Core&#34;&gt;Microsoft.AspNetCore.Antiforgery&lt;/a&gt; package provides the required utilities to easily protect yourself against such attacks.&lt;/p&gt; &#xA;&lt;p&gt;Falco provides a few handlers via &lt;code&gt;Falco.Security.Xss&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;To use the Xss helpers, ensure the service has been registered (&lt;code&gt;AddAntiforgery()&lt;/code&gt;) with the &lt;code&gt;IServiceCollection&lt;/code&gt; and activated (&lt;code&gt;UseAntiforgery()&lt;/code&gt;) using the &lt;code&gt;IApplicationBuilder&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Falco.Markup&#xA;open Falco.Security &#xA;&#xA;let formView token =     &#xA;    Elem.html [] [&#xA;        Elem.body [] [&#xA;            Elem.form [ Attr.method &#34;post&#34; ] [&#xA;                Elem.input [ Attr.name &#34;first_name&#34; ]&#xA;&#xA;                Elem.input [ Attr.name &#34;last_name&#34; ]&#xA;&#xA;                // using the CSRF HTML helper&#xA;                Xss.antiforgeryInput token&#xA;&#xA;                Elem.input [ Attr.type&#39; &#34;submit&#34;; Attr.value &#34;Submit&#34; ]&#xA;            ]                                &#xA;        ]&#xA;    ]&#xA;    &#xA;// A handler that demonstrates obtaining a&#xA;// CSRF token and applying it to a view&#xA;let csrfViewHandler : HttpHandler = &#xA;    formView&#xA;    |&amp;gt; Response.ofHtmlCsrf&#xA;    &#xA;// A handler that demonstrates validating&#xA;// the request&#39;s CSRF token&#xA;let mapFormSecureHandler : HttpHandler =    &#xA;    let mapPerson (form : FormCollectionReader) =&#xA;        { FirstName = form.GetString &#34;first_name&#34; &#34;John&#34; // Get value or return default value&#xA;          LastName = form.GetString &#34;first_name&#34; &#34;Doe&#34; }&#xA;&#xA;    let handleInvalid : HttpHandler = &#xA;        Response.withStatusCode 400 &#xA;        &amp;gt;&amp;gt; Response.ofEmpty&#xA;&#xA;    Request.mapFormSecure mapPerson Response.ofJson handleInvalid&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Crytography&lt;/h3&gt; &#xA;&lt;p&gt;Many sites have the requirement of a secure log in and sign up (i.e. registering and maintaining a user&#39;s database). Thus, generating strong hashes and random salts is important.&lt;/p&gt; &#xA;&lt;p&gt;Falco helpers are accessed by importing &lt;code&gt;Falco.Auth.Crypto&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Falco.Security&#xA;&#xA;// Generating salt,&#xA;// using System.Security.Cryptography.RandomNumberGenerator,&#xA;// create a random 16 byte salt and base 64 encode&#xA;let salt = Crypto.createSalt 16 &#xA;&#xA;// Generate random int for iterations&#xA;let iterations = Crypto.randomInt 10000 50000&#xA;&#xA;// Pbkdf2 Key derivation using HMAC algorithm with SHA256 hashing function&#xA;let password = &#34;5upe45ecure&#34;&#xA;let hashedPassword = password |&amp;gt; Crypto.sha256 iterations 32 salt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why &#34;Falco&#34;?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.1&#34; title=&#34;Kestrel web server implementation in ASP.NET Core&#34;&gt;Kestrel&lt;/a&gt; has been a game changer for the .NET web stack. In the animal kingdom, &#34;Kestrel&#34; is a name given to several members of the falcon genus. Also known as &#34;Falco&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;Find a bug?&lt;/h2&gt; &#xA;&lt;p&gt;There&#39;s an &lt;a href=&#34;https://github.com/pimbrouwers/Falco/issues&#34;&gt;issue&lt;/a&gt; for that.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Built with â™¥ by &lt;a href=&#34;https://github.com/pimbrouwers&#34;&gt;Pim Brouwers&lt;/a&gt; in Toronto, ON. Licensed under &lt;a href=&#34;https://github.com/pimbrouwers/Falco/raw/master/LICENSE&#34;&gt;Apache License 2.0&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>AlexKenna/BioProviders</title>
    <updated>2022-07-11T01:40:14Z</updated>
    <id>tag:github.com,2022-07-11:/AlexKenna/BioProviders</id>
    <link href="https://github.com/AlexKenna/BioProviders" rel="alternate"></link>
    <summary type="html">&lt;p&gt;.NET library for accessing and manipulating bioinformatic datasets.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BioProviders&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://fsharp.org/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Made%20with-FSharp-rgb(184,69,252).svg?sanitize=true&#34; alt=&#34;Made with F#&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/BioProviders/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/BioProviders.svg?sanitize=true&#34; alt=&#34;NuGet Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/AlexKenna/BioProviders/graphs/contributors&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/contributors/AlexKenna/BioProviders.svg?sanitize=true&#34; alt=&#34;GitHub contributors&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The F# BioProviders simplify programmatic access to genomic datasets.&lt;/p&gt; &#xA;&lt;p&gt;This library provides strongly typed access to genomic sequences and data through a set of TypeProviders including the GenBankProvider. The ability to interact with the genomic sequences and data is provided through &lt;a href=&#34;https://github.com/dotnetbio/bio&#34;&gt;.NET Bio&lt;/a&gt; with goals to later incorporate &lt;a href=&#34;https://github.com/CSBiology/BioFSharp&#34;&gt;BioFSharp&lt;/a&gt; functionality.&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/AlexKenna/BioProviders/actions&#34;&gt;&lt;img src=&#34;https://github.com/AlexKenna/BioProviders/actions/workflows/dotnet.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Install .Net SDK 3.0.100 or higher&lt;/p&gt; &#xA;&lt;p&gt;Windows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run &lt;code&gt;dotnet tool restore&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;dotnet paket install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;dotnet build &#34;.\BioProviders.sln&#34;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;More information can be found in the &lt;a href=&#34;https://github.com/AlexKenna/BioProviders/tree/main/docs&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>