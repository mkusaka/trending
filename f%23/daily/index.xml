<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub F# Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-11T01:33:03Z</updated>
  <subtitle>Daily Trending of F# in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cognitedata/oryx</title>
    <updated>2022-11-11T01:33:03Z</updated>
    <id>tag:github.com,2022-11-11:/cognitedata/oryx</id>
    <link href="https://github.com/cognitedata/oryx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;.NET Cross platform and highly composable middleware for building web request handlers in F#&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Oryx&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/cognitedata/oryx/workflows/Build%20and%20Test/badge.svg?sanitize=true&#34; alt=&#34;Build and Test&#34;&gt; &lt;a href=&#34;https://codecov.io/gh/cognitedata/oryx&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/cognitedata/oryx/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/Oryx/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/oryx&#34; alt=&#34;Nuget&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Oryx is a high-performance .NET cross-platform functional HTTP request handler library for writing HTTP clients and orchestrating web requests in F#.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;An SDK for writing HTTP web clients and orchestrating web requests.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This library enables you to write Web and REST clients and SDKs for various APIs and is currently used by the &lt;a href=&#34;https://github.com/cognitedata/cognite-sdk-dotnet&#34;&gt;.NET SDK for Cognite Data Fusion (CDF)&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Oryx is heavily inspired by the &lt;a href=&#34;https://github.com/dbrattli/AsyncRx&#34;&gt;AsyncRx&lt;/a&gt; and &lt;a href=&#34;https://github.com/giraffe-fsharp/Giraffe&#34;&gt;Giraffe&lt;/a&gt; frameworks and applies the same ideas to the client making the web requests. You can think of Oryx as the client equivalent of Giraffe, where the HTTP request processing pipeline starting at the client, going all the way to the server and back again.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Oryx is available as a &lt;a href=&#34;https://www.nuget.org/packages/Oryx/&#34;&gt;NuGet package&lt;/a&gt;. To install:&lt;/p&gt; &#xA;&lt;p&gt;Using Package Manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Install-Package Oryx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using .NET CLI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;dotnet add package Oryx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or &lt;a href=&#34;https://docs.microsoft.com/en-us/nuget/quickstart/install-and-use-a-package-in-visual-studio&#34;&gt;directly in Visual Studio&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;open System.Net.Http&#xA;open System.Text.Json&#xA;&#xA;open FSharp.Control.TaskBuilder&#xA;&#xA;open Oryx&#xA;open Oryx.SystemTextJson.ResponseReader&#xA;&#xA;[&amp;lt;Literal&amp;gt;]&#xA;let Url = &#34;https://en.wikipedia.org/w/api.php&#34;&#xA;&#xA;let options = JsonSerializerOptions()&#xA;&#xA;let query term = [&#xA;    struct (&#34;action&#34;, &#34;opensearch&#34;)&#xA;    struct (&#34;search&#34;, term)&#xA;]&#xA;&#xA;let asyncMain argv = task {&#xA;    use client = new HttpClient ()&#xA;    let request term =&#xA;        httpRequest&#xA;        |&amp;gt; GET&#xA;        |&amp;gt; withHttpClient client&#xA;        |&amp;gt; withUrl Url&#xA;        |&amp;gt; withQuery (query term)&#xA;        |&amp;gt; fetch&#xA;        |&amp;gt; json options&#xA;        &#xA;    let! result = request &#34;F#&#34; |&amp;gt; runAsync&#xA;    printfn &#34;Result: %A&#34; result&#xA;}&#xA;&#xA;[&amp;lt;EntryPoint&amp;gt;]&#xA;let main argv =&#xA;    asyncMain().GetAwaiter().GetResult()&#xA;    0 // return an integer exit code&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Fundamentals&lt;/h2&gt; &#xA;&lt;p&gt;The main building blocks in Oryx are the &lt;code&gt;HttpContext&lt;/code&gt; and the &lt;code&gt;HttpHandler&lt;/code&gt;. The context contains all the state needed for making the request, and also contains any response metadata such as headers, response code, etc received from the remote server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;type Context = {&#xA;    Request: HttpRequest&#xA;    Response: HttpResponse&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;HttpContext&lt;/code&gt; is constructed using a pipeline of asynchronous HTTP handlers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;type IHttpNext&amp;lt;&#39;TSource&amp;gt; =&#xA;    abstract member OnSuccessAsync: ctx: HttpContext * content: &#39;TSource -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;    abstract member OnErrorAsync: ctx: HttpContext * error: exn -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;    abstract member OnCancelAsync: ctx: HttpContext -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&#xA;&#xA;type HttpHandler&amp;lt;&#39;TSource&amp;gt; = IHttpNext&amp;lt;&#39;TSource&amp;gt; -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The relationship can be seen as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;do! handler success error cancel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An HTTP handler (&lt;code&gt;HttpHandler&lt;/code&gt;) is a pipeline that uses or subscribes &lt;code&gt;handler success error cancel&lt;/code&gt; the given continuations &lt;code&gt;success&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;cancel&lt;/code&gt;, and return a &lt;code&gt;Task&lt;/code&gt; of unit.&lt;/p&gt; &#xA;&lt;p&gt;Each &lt;code&gt;HttpHandler&lt;/code&gt; usually transforms the &lt;code&gt;HttpRequest&lt;/code&gt;, &lt;code&gt;HttpResponse&lt;/code&gt; or the &lt;code&gt;content&lt;/code&gt; before passing it down the pipeline by invoking the next &lt;code&gt;success&lt;/code&gt; continuation. It may also signal an error by invoking &lt;code&gt;error&lt;/code&gt; with an exception to fail the processing of the pipeline.&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to get your head around the Oryx &lt;code&gt;HttpHandler&lt;/code&gt; is to think of it as a functional web request processing pipeline. Each handler has the &lt;code&gt;HttpContext&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; at its disposal and can decide whether it wants to fail the request calling &lt;code&gt;error&lt;/code&gt;, or continue the request by calling the &lt;code&gt;success&lt;/code&gt; handler.&lt;/p&gt; &#xA;&lt;h2&gt;HTTP Handlers&lt;/h2&gt; &#xA;&lt;p&gt;The context and content may then be transformed for individual requests using a series of HTTP handlers. HTTP handlers are like lego bricks and may be composed into more complex HTTP handlers. The HTTP handlers included with Oryx are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cache&lt;/code&gt; - Caches the last result of a given handler, both the context and the content.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;catch&lt;/code&gt; - Catches errors and continues using another handler.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;choose&lt;/code&gt; - Choose the first handler that succeeds in a list of handlers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chunk&lt;/code&gt; - Chunks a sequence of HTTP handlers into sequential and concurrent batches.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;concurrent&lt;/code&gt; - Runs a sequence of HTTP handlers concurrently.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;empty&lt;/code&gt; - Creates a default empty request. You would usually start the chain with this handler.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fail&lt;/code&gt;- Fails the pipeline and pushes an exception downstream.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fetch&lt;/code&gt; - Fetches from remote using the current context&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;skip&lt;/code&gt; - Handler that skips (ignores) the content and outputs unit.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;get&lt;/code&gt; - Retrieves the content (for use in &lt;code&gt;http&lt;/code&gt; builder)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;log&lt;/code&gt; - Log information about the given request.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;map&lt;/code&gt; - Map the content of the HTTP handler.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;panic&lt;/code&gt; - Fails the pipeline and pushes an exception downstream. This error cannot be catched or skipped.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;parse&lt;/code&gt; - Parse response stream to a user-specified type synchronously.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;parseAsync&lt;/code&gt; - Parse response stream to a user-specified type asynchronously.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sequential&lt;/code&gt; - Runs a sequence of HTTP handlers sequentially.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;singleton&lt;/code&gt; - Handler that produces a single content value.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;validate&lt;/code&gt; - Validate content using a predicate function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withBearerToken&lt;/code&gt; - Adds an &lt;code&gt;Authorization&lt;/code&gt; header with &lt;code&gt;Bearer&lt;/code&gt; token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withCancellationToken&lt;/code&gt; - Adds a cancellation token to use for the context. This is particularly useful when using Oryx together with C# client code that supplies a cancellation token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withContent&lt;/code&gt; - Add HTTP content to the fetch request&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withMetrics&lt;/code&gt; - Add and &lt;code&gt;IMetrics&lt;/code&gt; interface to produce metrics info.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withError&lt;/code&gt; - Detect if the HTTP request failed, and then fail processing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withHeader&lt;/code&gt; - Adds a header to the context.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withHeaders&lt;/code&gt; - Adds headers to the context.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withHttpClient&lt;/code&gt; - Adds the &lt;code&gt;HttpClient&lt;/code&gt; to use for making requests using the &lt;code&gt;fetch&lt;/code&gt; handler.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withHttpClientFactory&lt;/code&gt; - Adds an &lt;code&gt;HttpClient&lt;/code&gt; factory function to use for producing the &lt;code&gt;HttpClient&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withLogger&lt;/code&gt; - Adds an &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger?view=dotnet-plat-ext-3.1&#34;&gt;&lt;code&gt;ILogger&lt;/code&gt;&lt;/a&gt; for logging requests and responses.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withLogLevel&lt;/code&gt; - The log level (&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel?view=dotnet-plat-ext-3.1&#34;&gt;&lt;code&gt;LogLevel&lt;/code&gt;&lt;/a&gt;) that the logging should be performed at. Oryx will disable logging for &lt;code&gt;LogLevel.None&lt;/code&gt; and this is also the default log level.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withLogFormat&lt;/code&gt; - Specify the log format of the log messages written.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withLogMessage&lt;/code&gt; - Log information about the given request supplying a user-specified message.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withMethod&lt;/code&gt; - with HTTP method. You can use GET, PUT, POST instead.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withQuery&lt;/code&gt; - Add URL query parameters&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withResponseType&lt;/code&gt; - Sets the Accept header of the request.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withTokenRenewer&lt;/code&gt; - Enables refresh of bearer tokens without building a new context.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withUrl&lt;/code&gt; - Use the given URL for the request.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withUrlBuilder&lt;/code&gt; - Use the given URL builder for the request.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withUrlBuilder&lt;/code&gt; - Adds the URL builder to use. An URL builder constructs the URL for the &lt;code&gt;Request&lt;/code&gt; part of the context.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition there are several extension for decoding JSON and Protobuf responses:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;json&lt;/code&gt; - Decodes the given &lt;code&gt;application/json&lt;/code&gt; response into a user-specified type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;protobuf&lt;/code&gt; - - Decodes the given &lt;code&gt;application/protobuf&lt;/code&gt; response into a Protobuf specific type.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/cognitedata/oryx/master/#json-and-protobuf-content-handling&#34;&gt;JSON and Protobuf Content Handling&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h3&gt;HTTP verbs&lt;/h3&gt; &#xA;&lt;p&gt;The HTTP verbs are convenience functions using the &lt;code&gt;withMethod&lt;/code&gt; under the hood:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;GET&lt;/code&gt; - HTTP get request&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PUT&lt;/code&gt; - HTTP put request&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;POST&lt;/code&gt; - HTTP post request&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DELETE&lt;/code&gt; - HTTP delete request&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;OPTIONS&lt;/code&gt; - HTTP options request&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Composition&lt;/h2&gt; &#xA;&lt;p&gt;The real magic of Oryx is composition. The fact that everything is an &lt;code&gt;HttpHandler&lt;/code&gt; makes it easy to compose HTTP handlers together. You can think of them as Lego bricks that you can fit together. Two or more &lt;code&gt;HttpHandler&lt;/code&gt; functions may be composed together using the pipelining, i.e using the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator. This enables you to compose your web requests and decode the response, e.g as we do when listing Assets in the &lt;a href=&#34;https://github.com/cognitedata/cognite-sdk-dotnet/raw/master/Oryx.Cognite/src/Handler.fs&#34;&gt;Cognite Data Fusion SDK&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;    let list (query: AssetQuery) (source: HttpHandler&amp;lt;unit&amp;gt;) : HttpHandler&amp;lt;ItemsWithCursor&amp;lt;AssetReadDto&amp;gt;&amp;gt; =&#xA;        let url = Url +/ &#34;list&#34;&#xA;&#xA;        source&#xA;        |&amp;gt; POST&#xA;        |&amp;gt; withVersion V10&#xA;        |&amp;gt; withResource url&#xA;        |&amp;gt; withContent (() -&amp;gt; new JsonPushStreamContent&amp;lt;AssetQuery&amp;gt;(query, jsonOptions))&#xA;        |&amp;gt; fetch&#xA;        |&amp;gt; withError decodeError&#xA;        |&amp;gt; json jsonOptions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function &lt;code&gt;list&lt;/code&gt; is now also an &lt;code&gt;HttpHandler&lt;/code&gt; and may be composed with other handlers to create complex chains for doing multiple sequential or concurrent requests to a web service. And you can do this without having to worry about error handling.&lt;/p&gt; &#xA;&lt;h2&gt;Retrying Requests&lt;/h2&gt; &#xA;&lt;p&gt;Since Oryx is based on &lt;code&gt;HttpClient&lt;/code&gt; from &lt;code&gt;System.Net.Http&lt;/code&gt;, you may also use &lt;a href=&#34;https://github.com/App-vNext/Polly&#34;&gt;Polly&lt;/a&gt; for handling resilience.&lt;/p&gt; &#xA;&lt;h2&gt;Concurrent and Sequential Handlers&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;code&gt;sequential&lt;/code&gt; operator for running a list of HTTP handlers in sequence.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val sequential:&#xA;    handlers     : seq&amp;lt;HttpHandler&amp;lt;&#39;TResult&amp;gt;&amp;gt;&#xA;                -&amp;gt; HttpHandler&amp;lt;list&amp;lt;&#39;TResult&amp;gt;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And a &lt;code&gt;concurrent&lt;/code&gt; operator that runs a list of HTTP handlers in parallel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val concurrent:&#xA;    handlers     : seq&amp;lt;HttpHandler&amp;lt;&#39;TResult&amp;gt;&amp;gt;&#xA;                -&amp;gt; HttpHandler&amp;lt;list&amp;lt;&#39;TResult&amp;gt;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also combine sequential and concurrent requests by chunking the request. The &lt;code&gt;chunk&lt;/code&gt; handler uses &lt;code&gt;chunkSize&lt;/code&gt; and &lt;code&gt;maxConcurrency&lt;/code&gt; to decide how much will be done in parallel. It takes a list of items and a handler that transforms these items into HTTP handlers. This is nice if you need to e.g read thousands of items from a web service in multiple requests.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val chunk:&#xA;   chunkSize     : int -&amp;gt;&#xA;   maxConcurrency: int -&amp;gt;&#xA;   handler       : (seq&amp;lt;&#39;TSource&amp;gt; -&amp;gt; HttpHandler&amp;lt;seq&amp;lt;&#39;TResult&amp;gt;&amp;gt;) -&amp;gt;&#xA;   items         : seq&amp;lt;&#39;TSource&amp;gt;&#xA;                -&amp;gt; HttpHandler&amp;lt;seq&amp;lt;&#39;TResult&amp;gt;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that chunk will fail if one of the inner requests fails so for e.g a writing scenario you most likely want to create your own custom chunk operator that has different error semantics. If you write such operators then feel free to open a PR so we can include them in the library.&lt;/p&gt; &#xA;&lt;h2&gt;Error handling&lt;/h2&gt; &#xA;&lt;p&gt;To produce a custom error response you can use the &lt;code&gt;withError&lt;/code&gt; handler &lt;em&gt;after&lt;/em&gt; e.g &lt;code&gt;fetch&lt;/code&gt;. The supplied &lt;code&gt;errorHandler&lt;/code&gt; is given full access the the &lt;code&gt;HttpResponse&lt;/code&gt; and the &lt;code&gt;HttpContent&lt;/code&gt; and may produce a custom &lt;code&gt;exception&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val withError:&#xA;   errorHandler  : (HttpResponse -&amp;gt; HttpContent -&amp;gt; Task&amp;lt;exn&amp;gt;) -&amp;gt;&#xA;   source        : HttpHandler&amp;lt;HttpContent&amp;gt; -&amp;gt;&#xA;   next          : IAsyncNext&amp;lt;HttpContext,HttpContent&amp;gt;&#xA;                -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s also possible to catch errors using the &lt;code&gt;catch&lt;/code&gt; handler &lt;em&gt;before&lt;/em&gt; e.g &lt;code&gt;fetch&lt;/code&gt;. The function takes an &lt;code&gt;errorHandler&lt;/code&gt; that is given the returned error and produces a new &lt;code&gt;HttpHandler&lt;/code&gt; that may then decide to transform the error and continue processing or fail with an error. This is very helpful when a failed request not necessarily means an error, e.g if you need to check if an object with a given id exists at the server. It&#39;s not possible to catch a &lt;code&gt;PanicException&lt;/code&gt;, so wrapping an exception in a &lt;code&gt;PanicException&lt;/code&gt; can be used if you need to signal a fatal error and bypass a &lt;code&gt;catch&lt;/code&gt; operator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val catch:&#xA;   errorHandler  : (HttpContext -&amp;gt; exn -&amp;gt; HttpHandler&amp;lt;&#39;TSource&amp;gt;) -&amp;gt;&#xA;   source        : HttpHandler&amp;lt;&#39;TSource&amp;gt; -&amp;gt;&#xA;                -&amp;gt; HttpHandler&amp;lt;&#39;TSource&amp;gt; -&amp;gt;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;choose&lt;/code&gt; operator takes a list of HTTP handlers and tries each of them until one of them succeeds. The &lt;code&gt;choose&lt;/code&gt; operator will record every error that happens except for &lt;code&gt;SkipException&lt;/code&gt; that can be used for skipping to the next handler. Other errors will be recorded. If multiple error happens they will be provided as an &lt;code&gt;AggregateException&lt;/code&gt;. If you need break out of &lt;code&gt;choose&lt;/code&gt; and force an exception without skipping to the next handler you can use the &lt;code&gt;PanicException&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val choose:&#xA;   Handlers    : list&amp;lt;(HttpHandler&amp;lt;&#39;TSource&amp;gt; -&amp;gt;HttpHandler&amp;lt;&#39;TResult&amp;gt;)&amp;gt; -&amp;gt;&#xA;   source      : HttpHandler&amp;lt;&#39;TSource&amp;gt;&#xA;              -&amp;gt; HttpHandler&amp;lt;&#39;TResult&amp;gt;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;JSON and Protobuf Content Handling&lt;/h2&gt; &#xA;&lt;p&gt;Oryx can serialize (and deserialize) content using:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/system.text.json?view=netcore-3.1&#34;&gt;&lt;code&gt;System.Text.Json&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.newtonsoft.com/json&#34;&gt;&lt;code&gt;Newtonsoft.Json&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/thoth-org/Thoth.Json.Net&#34;&gt;&lt;code&gt;Thoth.Json.Net&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers&#34;&gt;&lt;code&gt;Google.Protobuf&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;System.Text.Json&lt;/h3&gt; &#xA;&lt;p&gt;Support for &lt;code&gt;System.Text.Json&lt;/code&gt; is made available using the &lt;a href=&#34;https://www.nuget.org/packages/Oryx.SystemTextJson/&#34;&gt;&lt;code&gt;Oryx.SystemTextJson&lt;/code&gt;&lt;/a&gt; extension.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;json&lt;/code&gt; decode HTTP handler takes a &lt;code&gt;JsonSerializerOptions&lt;/code&gt; to decode the response into user-defined type of &lt;code&gt;&#39;T&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val json:&#xA;   options: JsonSerializerOptions&#xA;         -&amp;gt; HttpHandler&amp;lt;&#39;TResult&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Content can be handled using &lt;code&gt;type JsonPushStreamContent&amp;lt;&#39;a&amp;gt; (content : &#39;T, options : JsonSerializerOptions)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Newtonsoft.Json&lt;/h3&gt; &#xA;&lt;p&gt;Support for &lt;code&gt;Newtonsoft.Json&lt;/code&gt; is made available using the &lt;a href=&#34;https://www.nuget.org/packages/Oryx.NewtonsoftJson/&#34;&gt;&lt;code&gt;Oryx.NewtonsoftJson&lt;/code&gt;&lt;/a&gt; extension.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;json&lt;/code&gt; decode HTTP handler decodes the response into a user-defined type of &lt;code&gt;&#39;TResult&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val json : HttpHandler&amp;lt;HttpContent,&#39;TResult&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Content can be handled using &lt;code&gt;type JsonPushStreamContent (content : JToken)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Thoth.Json.Net&lt;/h3&gt; &#xA;&lt;p&gt;Support for &lt;code&gt;Thoth.Json.Net&lt;/code&gt; is made available using the &lt;a href=&#34;https://www.nuget.org/packages/Oryx.ThothJsonNet/&#34;&gt;&lt;code&gt;Oryx.ThothJsonNet&lt;/code&gt;&lt;/a&gt; extension.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;json&lt;/code&gt; decoder takes a &lt;code&gt;Decoder&lt;/code&gt; from &lt;code&gt;Thoth.Json.Net&lt;/code&gt; to decode the response into a user-defined type of &lt;code&gt;&#39;T&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val json:&#xA;   decoder: Decoder&amp;lt;&#39;TResult&amp;gt;&#xA;         -&amp;gt; HttpHandler&amp;lt;&#39;TResult&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Content can be handled using &lt;code&gt;type JsonPushStreamContent (content : JsonValue)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Protobuf&lt;/h3&gt; &#xA;&lt;p&gt;Protobuf support is made available using the &lt;a href=&#34;https://www.nuget.org/packages/Oryx.ThothJsonNet/&#34;&gt;&lt;code&gt;Oryx.Protobuf&lt;/code&gt;&lt;/a&gt; extension.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;protobuf&lt;/code&gt; decoder takes a &lt;code&gt;Stream -&amp;gt; &#39;T&lt;/code&gt; usually generated by &lt;code&gt;Google.Protobuf&lt;/code&gt; to decode the response into user defined type of &lt;code&gt;&#39;T&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val protobuf: (System.IO.Stream -&amp;gt; &#39;TResult) -&amp;gt;  HttpHandler&amp;lt;System.Net.Http.HttpContent&amp;gt; -&amp;gt; HttpHandler&amp;lt;&#39;TResult&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both encode and decode uses streaming all the way so no large strings or arrays will be allocated in the process.&lt;/p&gt; &#xA;&lt;p&gt;Content can be handled using &lt;code&gt;type ProtobufPushStreamContent (content : IMessage)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Computational Expression Builder&lt;/h2&gt; &#xA;&lt;p&gt;Working with &lt;code&gt;HttpContext&lt;/code&gt; objects can be a bit painful. To make it simpler to handle multiple requests using handlers you can use the &lt;code&gt;req&lt;/code&gt; builder that will let you work with the &lt;code&gt;content&lt;/code&gt; and hide the complexity of both the &lt;code&gt;Context&lt;/code&gt; and the &lt;code&gt;HttpNext&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;http {&#xA;    let! assetDto = Assets.Entity.get key&#xA;&#xA;    let asset = assetDto |&amp;gt; Asset.FromAssetReadDto&#xA;    if expands.Contains(&#34;Parent&#34;) &amp;amp;&amp;amp; assetDto.ParentId.IsSome then&#xA;        let! parentDto = Assets.Entity.get assetDto.ParentId.Value&#xA;        let parent = parentDto |&amp;gt; Asset.FromAssetReadDto&#xA;        let expanded = { asset with Parent = Some parent }&#xA;        return expanded&#xA;    else&#xA;        return asset&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The request may then be composed with other handlers, e.g chunked, retried, and/or logged.&lt;/p&gt; &#xA;&lt;p&gt;To run a handler you can use the &lt;code&gt;runAsync&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val runAsync:&#xA;   handler: HttpHandler&amp;lt;&#39;TResult&amp;gt;&#xA;         -&amp;gt; Task&amp;lt;Result&amp;lt;&#39;TResult,exn&amp;gt;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or the unsafe version that may throw exceptions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val runUnsafeAsync:&#xA;   handler: HttpHandler&amp;lt;unit,&#39;TResult&amp;gt;&#xA;         -&amp;gt; Task&amp;lt;&#39;TResult&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Logging and Metrics&lt;/h2&gt; &#xA;&lt;p&gt;Oryx supports logging using the logging handlers. To setup for logging you first need to enable logging in the context by both setting a logger of type &lt;code&gt;ILogger&lt;/code&gt; (&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger?view=dotnet-plat-ext-3.1&#34;&gt;Microsoft.Extensions.Logging&lt;/a&gt;) and the logging level to something higher than &lt;code&gt;LogLevel.None&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val withLogger : (logger: ILogger) -&amp;gt; (context: EmptyContext) -&amp;gt; (context: EmptyContext)&#xA;val withLogLevel : (logLevel: LogLevel) -&amp;gt; (context: EmptyContext) -&amp;gt; (context: EmptyContext)&#xA;val withLogFormat (format: string) (context: EmptyContext) -&amp;gt; (context: EmptyContext)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The default format string is:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;&#34;Oryx: {Message} {HttpMethod} {Uri}\n{RequestContent}\n{ResponseContent}&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also use a custom log format string by setting the log format using &lt;code&gt;withLogFormat&lt;/code&gt;. The available place holders you may use are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Elapsed&lt;/code&gt; - The elapsed request time for &lt;code&gt;fetch&lt;/code&gt; in milliseconds.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HttpMethod&lt;/code&gt; - The HTTP method used, i.e &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;PATCH&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Message&lt;/code&gt; - A user-supplied message using &lt;code&gt;logWithMessage&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ResponseContent&lt;/code&gt; - The response content received. Must implement &lt;code&gt;ToString&lt;/code&gt; to give meaningful output.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RequestContent&lt;/code&gt; - The request content being sent. Must implement &lt;code&gt;ToString&lt;/code&gt; to give meaningful output.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Url&lt;/code&gt; - The URL used for fetching.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Oryx will not call &lt;code&gt;.ToString ()&lt;/code&gt; but will hand it over to the &lt;code&gt;ILogger&lt;/code&gt; for the actual string interpolation, given that the message will end up being logged.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: The logging handler (&lt;code&gt;log&lt;/code&gt;) do not alter the types of the pipeline and may be composed anywhere. But to give meaningful output they should be composed after fetching (&lt;code&gt;fetch&lt;/code&gt;). To log errors, the log handler should be placed after error handling (&lt;code&gt;withError&lt;/code&gt;), and to log decoded responses the log handler should be placed after the decoder (i.e &lt;code&gt;json&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;val withLogger:&#xA;   logger: ILogger -&amp;gt;&#xA;   source: HttpHandler&amp;lt;&#39;TSource&amp;gt;&#xA;        -&amp;gt; HttpHandler&amp;lt;&#39;TSource&amp;gt;&#xA;&#xA;val withLogLevel:&#xA;   logLevel: LogLevel -&amp;gt;&#xA;   source  : HttpHandler&amp;lt;&#39;TSource&amp;gt;&#xA;          -&amp;gt; HttpHandler&amp;lt;&#39;TSource&amp;gt;&#xA;&#xA;val withLogMessage:&#xA;   msg : string              -&amp;gt;&#xA;   next: IHttpNext&amp;lt;&#39;TSource&amp;gt;&#xA;      -&amp;gt; IHttpNext&amp;lt;&#39;TSource&amp;gt;&#xA;&#xA;val withLogMessage:&#xA;   msg   : string -&amp;gt;&#xA;   source: HttpHandler&amp;lt;&#39;TSource&amp;gt;&#xA;        -&amp;gt; HttpHandler&amp;lt;&#39;TSource&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Oryx may also emit metrics using the &lt;code&gt;IMetrics&lt;/code&gt; interface (Oryx specific) that you can use with e.g Prometheus.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;type IMetrics =&#xA;    abstract member Counter : metric: string -&amp;gt; labels: IDictionary&amp;lt;string, string&amp;gt; -&amp;gt; increase: int64 -&amp;gt; unit&#xA;    abstract member Gauge : metric: string -&amp;gt; labels: IDictionary&amp;lt;string, string&amp;gt; -&amp;gt; value: float -&amp;gt; unit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The currently defined Metrics are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Metric.FetchInc&lt;/code&gt; - (&#34;MetricFetchInc&#34;) The increase in the number of fetches when using the &lt;code&gt;fetch&lt;/code&gt; handler.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Metric.FetchErrorInc&lt;/code&gt; - (&#34;MetricFetchErrorInc&#34;). The increase in the number of fetch errors when using the &lt;code&gt;fetch&lt;/code&gt; handler.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Metrics.FetchRetryInc&lt;/code&gt; - (&#34;MetricsFetchRetryInc&#34;). The increase in the number of retries when using the &lt;code&gt;retry&lt;/code&gt; handler.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Metric.FetchLatencyUpdate&lt;/code&gt; - (&#34;MetricFetchLatencyUpdate&#34;). The update in fetch latency (in milliseconds) when using the &lt;code&gt;fetch&lt;/code&gt; handler.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Metric.DecodeErrorInc&lt;/code&gt; - (&#34;Metric.DecodeErrorInc&#34;). The increase in decode errors when using a &lt;code&gt;json&lt;/code&gt; decode handler.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Labels are currently not set but are added for future use, e.g setting the error code for fetch errors etc.&lt;/p&gt; &#xA;&lt;h2&gt;Extending Oryx&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s easy to extend Oryx with your own HTTP handlers. Everything is functions, so you can easily add your own HTTP handlers.&lt;/p&gt; &#xA;&lt;h3&gt;Custom HTTP Handlers&lt;/h3&gt; &#xA;&lt;p&gt;Custom HTTP handlers may e.g populate the context, make asynchronous web requests and parse response content. HTTP handlers are functions that takes an &lt;code&gt;HttpHandler&#39;TSource&amp;gt;&lt;/code&gt;, and returns an &lt;code&gt;HttpHandler&amp;lt;&#39;TSource&amp;gt;&lt;/code&gt;. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;let withResource (resource: string) (source: HttpHandler&amp;lt;&#39;TSource): HttpHandler&amp;lt;&#39;TSource&amp;gt; =&#xA;    source&#xA;    |&amp;gt; update (fun ctx -&amp;gt;&#xA;        { ctx with&#xA;            Request =&#xA;                { ctx.Request with Items = ctx.Request.Items.Add(PlaceHolder.Resource, Value.String resource) } })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;/// Parse response stream to a user specified type synchronously.&#xA;let parse&amp;lt;&#39;TResult&amp;gt; (parser: Stream -&amp;gt; &#39;TResult) (source: HttpHandler&amp;lt;HttpContent&amp;gt;) : HttpHandler&amp;lt;&#39;TResult&amp;gt; =&#xA;    fun next -&amp;gt;&#xA;        { new IHttpNext&amp;lt;HttpContent&amp;gt; with&#xA;            member _.OnSuccessAsync(ctx, content: HttpContent) =&#xA;                task {&#xA;                    let! stream = content.ReadAsStreamAsync()&#xA;&#xA;                    try&#xA;                        let item = parser stream&#xA;                        return! next.OnSuccessAsync(ctx, item)&#xA;                    with&#xA;                    | ex -&amp;gt;&#xA;                        ctx.Request.Metrics.Counter Metric.DecodeErrorInc ctx.Request.Labels 1L&#xA;                        raise ex&#xA;                }&#xA;&#xA;            member _.OnErrorAsync(ctx, exn) = next.OnErrorAsync(ctx, exn)&#xA;            member _.OnCancelAsync(ctx) = next.OnCancelAsync(ctx) }&#xA;        |&amp;gt; source&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;What is new in Oryx v5&lt;/h2&gt; &#xA;&lt;p&gt;Oryx v5 continues to simplify the HTTP handlers by reducing the number of generic parameters so you only need to specify the type the handler is producing (not what it&#39;s consuming). The &lt;code&gt;HttpHandler&lt;/code&gt; have also been reduced to plain functions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;type IHttpNext&amp;lt;&#39;TSource&amp;gt; =&#xA;    abstract member OnSuccessAsync: ctx: HttpContext * content: &#39;TSource -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;    abstract member OnErrorAsync: ctx: HttpContext * error: exn -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;    abstract member OnCancelAsync: ctx: HttpContext -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&#xA;&#xA;type HttpHandler&amp;lt;&#39;TSource&amp;gt; = IHttpNext&amp;lt;&#39;TSource&amp;gt; -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The great advantage is that you can now use the normal pipe operator (&lt;code&gt;|&amp;gt;&lt;/code&gt;) instead of Kleisli composition (&lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;). which will give you better type hinting and debugging in most IDEs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;use client = new HttpClient()&#xA;&#xA;let common =&#xA;    httpRequest&#xA;    |&amp;gt; GET&#xA;    |&amp;gt; withHttpClient client&#xA;    |&amp;gt; withUrl Url&#xA;    |&amp;gt; cache&#xA;&#xA;let! result =&#xA;    request common &#34;F#&#34;&#xA;    |&amp;gt; runUnsafeAsync&#xA;printfn $&#34;Result: {result}&#34;&#xA;&#xA;let! result =&#xA;    request common &#34;C#&#34;&#xA;    |&amp;gt; runUnsafeAsync&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;What is new in Oryx v4&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;A &lt;code&gt;validate&lt;/code&gt; handler has been added that can validate the passing content using a predicate function. If the predicate fails then the error path will be taken.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A &lt;code&gt;protect&lt;/code&gt; handler has been added that protects the pipeline from exceptions (thrown upwards) and protocol error with regards to error / complete handling. E.g not allowed to call &lt;code&gt;OnNextAsync()&lt;/code&gt; after &lt;code&gt;OnErrorAsync()&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The semantics of the &lt;code&gt;choose&lt;/code&gt; operator have been modified so it continues processing the next handler if the current handler produces error i.e &lt;code&gt;OnErrorAsync&lt;/code&gt;. Previously it was triggered by not calling &lt;code&gt;.OnNextAsync()&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Oryx v4 makes the content non-optional to simplify the HTTP handlers.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;type IHttpNext&amp;lt;&#39;TSource&amp;gt; =&#xA;    abstract member OnNextAsync: ctx: HttpContext * content: &#39;TSource -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;    abstract member OnErrorAsync: ctx: HttpContext * error: exn -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;    abstract member OnCompletedAsync: ctx: HttpContext -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&#xA;type HttpHandler&amp;lt;&#39;TSource, &#39;TResult&amp;gt; =&#xA;    abstract member Subscribe: next: IHttpNext&amp;lt;&#39;TResult&amp;gt; -&amp;gt; IHttpNext&amp;lt;&#39;TSource&amp;gt;&#xA;&#xA;type HttpHandler&amp;lt;&#39;TSource&amp;gt; = HttpHandler&amp;lt;&#39;TSource, &#39;TSource&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;What is new in Oryx v3&lt;/h2&gt; &#xA;&lt;p&gt;Oryx v3 will significantly simplify the typing of HTTP handlers by:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Be based on Async Observables instead of result returning continuations. The result returning continuations were problematic in the sense that they both push values down in addition to returning (pulling) async values up, thus each HTTP handler needed to care about the input (&lt;code&gt;TSource&lt;/code&gt;), output (&lt;code&gt;TNext&lt;/code&gt;), the final result (&lt;code&gt;TResult&lt;/code&gt;) and error (&lt;code&gt;TError&lt;/code&gt;) types. By never returning anything (&lt;code&gt;Task&amp;lt;unit&amp;gt;&lt;/code&gt;) we get rid of the annoying return type.&lt;/li&gt; &#xA; &lt;li&gt;Error type (&lt;code&gt;&#39;TError&lt;/code&gt;) is now simply an exception (&lt;code&gt;exn&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Core logic refactored into a generic middleware (that can be reused for other purposes).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This change effectively makes Oryx an Async Observable (with context):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;type IHttpNext&amp;lt;&#39;TSource&amp;gt; =&#xA;    abstract member OnNextAsync: ctx: HttpContext * ?content: &#39;TSource -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;    abstract member OnErrorAsync: ctx: HttpContext * error: exn -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;    abstract member OnCompletedAsync: ctx: HttpContext -&amp;gt; Task&amp;lt;unit&amp;gt;&#xA;&#xA;type IHttpHandler&amp;lt;&#39;TSource, &#39;TResult&amp;gt; =&#xA;    abstract member Subscribe: next: IHttpNext&amp;lt;&#39;TResult&amp;gt; -&amp;gt; IHttpNext&amp;lt;&#39;TSource&amp;gt;&#xA;&#xA;type IHttpHandler&amp;lt;&#39;TSource&amp;gt; = IHttpHandler&amp;lt;&#39;TSource, &#39;TSource&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The difference from observables is that the &lt;code&gt;IHttpHandler&lt;/code&gt; subscribe method returns another &#34;observer&#34; (&lt;code&gt;IHttpNext&lt;/code&gt;) instead of a &lt;code&gt;Disposable&lt;/code&gt; and this observable is the side-effect that injects values into the pipeline (&lt;code&gt;Subject&lt;/code&gt;). The composition stays exactly the same so all HTTP pipelines will works as before. The typing just gets simpler to handle.&lt;/p&gt; &#xA;&lt;p&gt;The custom error type (&lt;code&gt;TError&lt;/code&gt;) has also been removed and we now use plain exceptions for all errors. Any custom error types now needs to be an Exception subtype.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;retry&lt;/code&gt; operator has been deprecated. Use &lt;a href=&#34;https://github.com/App-vNext/Polly&#34;&gt;Polly&lt;/a&gt; instead. It might get back in a later release but the observable pattern makes it hard to retry something upstream.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;choose&lt;/code&gt; operator has been added. This operator takes a list of HTTP handlers and tries each of them until one of them succeeds.&lt;/p&gt; &#xA;&lt;h2&gt;What is new in Oryx v2&lt;/h2&gt; &#xA;&lt;p&gt;We needed to change Oryx to preserve any response headers and status-code that got lost after decoding the response content into a custom type. The response used to be a custom &lt;code&gt;&#39;T&lt;/code&gt; so it could not hold any additional info. We changed this so the response is now an &lt;code&gt;HttpResponse&lt;/code&gt; type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;type HttpResponse&amp;lt;&#39;T&amp;gt; =&#xA;    {&#xA;        /// Response content&#xA;        Content: &#39;T&#xA;        /// Map of received headers&#xA;        Headers: Map&amp;lt;string, seq&amp;lt;string&amp;gt;&amp;gt;&#xA;        /// Http status code&#xA;        StatusCode: HttpStatusCode&#xA;        /// True if response is successful&#xA;        IsSuccessStatusCode: bool&#xA;        /// Reason phrase which typically is sent by servers together with the status code&#xA;        ReasonPhrase: string&#xA;    }&#xA;&#xA;    /// Replaces the content of the HTTP response.&#xA;    member x.Replace&amp;lt;&#39;TResult&amp;gt;(content: &#39;TResult): HttpResponse&amp;lt;&#39;TResult&amp;gt; =&#xA;        {&#xA;            Content = content&#xA;            StatusCode = x.StatusCode&#xA;            IsSuccessStatusCode = x.IsSuccessStatusCode&#xA;            Headers = x.Headers&#xA;            ReasonPhrase = x.ReasonPhrase&#xA;        }&#xA;&#xA;type Context&amp;lt;&#39;T&amp;gt; =&#xA;    {&#xA;        Request: HttpRequest&#xA;        Response: HttpResponse&amp;lt;&#39;T&amp;gt;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Upgrade from Oryx v4 to v5&lt;/h2&gt; &#xA;&lt;p&gt;The context builders are gone. In Oryx v5 there is only HTTP handlers (&lt;code&gt;HttpHandler&lt;/code&gt;). This means that there is only one way to build and transform the context. This might seem inefficient when you need to reuse the same part of the context for multiple requests. The way to handle this is to use the &lt;code&gt;cache&lt;/code&gt; handler.&lt;/p&gt; &#xA;&lt;h2&gt;Upgrade from Oryx v3 to v4&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;throw&lt;/code&gt; operator have been renamed to &lt;code&gt;fail&lt;/code&gt;. The &lt;code&gt;throw&lt;/code&gt; operator is still available but will give an obsoleted warning.&lt;/p&gt; &#xA;&lt;p&gt;The content used through the handler pipeline is now non-optional. Thus custom code such as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;let withResource (resource: string): HttpHandler&amp;lt;&#39;TSource&amp;gt; =&#xA;    { new IHttpHandler&amp;lt;&#39;TSource, &#39;TResult&amp;gt; with&#xA;        member _.Subscribe(next) =&#xA;            { new IHttpNext&amp;lt;&#39;TSource&amp;gt; with&#xA;                member _.OnNextAsync(ctx, ?content) =&#xA;                    next.OnNextAsync(&#xA;                        { ctx with&#xA;                            Request =&#xA;                                { ctx.Request with&#xA;                                    Items = ctx.Request.Items.Add(PlaceHolder.Resource, String resource)&#xA;                                }&#xA;                        },&#xA;                        ?content = content&#xA;                    )&#xA;&#xA;                member _.OnErrorAsync(ctx, exn) = next.OnErrorAsync(ctx, exn)&#xA;                member _.OnCompletedAsync() = next.OnCompletedAsync()&#xA;            }}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Needs to be refactored to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;let withResource (resource: string): HttpHandler&amp;lt;&#39;TSource&amp;gt; =&#xA;    { new HttpHandler&amp;lt;&#39;TSource, &#39;TResult&amp;gt; with&#xA;        member _.Subscribe(next) =&#xA;            { new IHttpNext&amp;lt;&#39;TSource&amp;gt; with&#xA;                member _.OnNextAsync(ctx, content) =&#xA;                    next.OnNextAsync(&#xA;                        { ctx with&#xA;                            Request =&#xA;                                { ctx.Request with&#xA;                                    Items = ctx.Request.Items.Add(PlaceHolder.Resource, String resource)&#xA;                                }&#xA;                        },&#xA;                        content = content&#xA;                    )&#xA;&#xA;                member _.OnErrorAsync(ctx, exn) = next.OnErrorAsync(ctx, exn)&#xA;                member _.OnCompletedAsync() = next.OnCompletedAsync()&#xA;            }}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Upgrade from Oryx v2 to v3&lt;/h2&gt; &#xA;&lt;p&gt;Oryx v3 is mostly backwards compatible with v2. Your chains of operators will for most part look and work exactly the same. There are however some notable changes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Context&lt;/code&gt; have been renamed to &lt;code&gt;HttpContext&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HttpHandler&lt;/code&gt; have been renamed &lt;code&gt;HttpHandler&lt;/code&gt;. This is because &lt;code&gt;HttpHandler&lt;/code&gt; is now an interface.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;retry&lt;/code&gt; operator has been deprecated for now. Use &lt;a href=&#34;https://github.com/App-vNext/Polly&#34;&gt;Polly&lt;/a&gt; instead.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;catch&lt;/code&gt; operator needs to run &lt;strong&gt;after&lt;/strong&gt; the error producing operator e.g &lt;code&gt;fetch&lt;/code&gt; (not before). This is because Oryx v3 pushes results &#34;down&#34; instead of returning them &#34;up&#34; the chain of operators. The good thing with this change is that a handler can now continue processing the rest of the pipeline after catching an error. This was not possible in v2 / v1 where the &lt;code&gt;catch&lt;/code&gt; operator had to abort processing and produce a result.&lt;/li&gt; &#xA; &lt;li&gt;The log operator needs to be placed &lt;strong&gt;after&lt;/strong&gt; the handler you want it to log. E.g to log JSON decoded data you need to place it after &lt;code&gt;json&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Http handlers take 2 generic types instead of 4. E.g &lt;code&gt;fetch&amp;lt;&#39;TSource, &#39;TNext, &#39;TResult, &#39;TError&amp;gt;&lt;/code&gt; now becomes &lt;code&gt;fetch&amp;lt;&#39;TSource, &#39;TNext&amp;gt;&lt;/code&gt; and the last two types can simply be removed from your code.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ResponseError&lt;/code&gt; is gone. You need to sub-class an exception instead. This means that the `&#39;TError&#39; type is also gone from the handlers.&lt;/li&gt; &#xA; &lt;li&gt;Custom context builders do not need any changes except renaming &lt;code&gt;Context&lt;/code&gt; to &lt;code&gt;HttpContext&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Custom HTTP handlers must be refactored. Instead of returning a result (Ok/Error) the handler needs to push down the result either using the Ok path &lt;code&gt;next.OnNextAsync()&lt;/code&gt; or fail with an error &lt;code&gt;next.OnErrorAsync()&lt;/code&gt;. This is very similar to e.g Reactive Extensions (Rx) &lt;code&gt;OnNext&lt;/code&gt; / &lt;code&gt;OnError&lt;/code&gt;. E.g:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt; let withResource (resource: string) (next: NextFunc&amp;lt;_,_&amp;gt;) (context: HttpContext) =&#xA;    next { context with Request = { context.Request with Items = context.Request.Items.Add(PlaceHolder.Resource, String resource) } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Needs to be refactored to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;let withResource (resource: string): HttpHandler&amp;lt;&#39;TSource&amp;gt; =&#xA;    { new HttpHandler&amp;lt;&#39;TSource, &#39;TResult&amp;gt; with&#xA;        member _.Subscribe(next) =&#xA;            { new IHttpNext&amp;lt;&#39;TSource&amp;gt; with&#xA;                member _.OnNextAsync(ctx, ?content) =&#xA;                    next.OnNextAsync(&#xA;                        { ctx with&#xA;                            Request =&#xA;                                { ctx.Request with&#xA;                                    Items = ctx.Request.Items.Add(PlaceHolder.Resource, String resource)&#xA;                                }&#xA;                        },&#xA;                        ?content = content&#xA;                    )&#xA;&#xA;                member _.OnErrorAsync(ctx, exn) = next.OnErrorAsync(ctx, exn)&#xA;                member _.OnCompletedAsync() = next.OnCompletedAsync()&#xA;            }}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s a bit more verbose, but the hot path of the code is mostly the same as before.&lt;/p&gt; &#xA;&lt;h2&gt;Upgrade from Oryx v1 to v2&lt;/h2&gt; &#xA;&lt;p&gt;The context is now initiated with a content &lt;code&gt;&#39;T&lt;/code&gt; of &lt;code&gt;unit&lt;/code&gt;. E.g your custom HTTP handlers that is used before &lt;code&gt;fetch&lt;/code&gt; need to be rewritten from using a &lt;code&gt;&#39;TSource&lt;/code&gt; of &lt;code&gt;HttpResponseMessage&lt;/code&gt; to &lt;code&gt;unit&lt;/code&gt; e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- let withLogMessage (msg: string) (next: HttpFunc&amp;lt;HttpResponseMessage, &#39;T, &#39;TError&amp;gt;) (context: EmptyContext) =&#xA;+ let withLogMessage (msg: string) (next: HttpFunc&amp;lt;unit, &#39;T, &#39;TError&amp;gt;) (context: EmptyContext) =&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is now also a &lt;code&gt;runAsync&#39;&lt;/code&gt; overload that returns the full &lt;code&gt;HttpResponse&lt;/code&gt; record i.e: &lt;code&gt;Task&amp;lt;Result&amp;lt;HttpResponse&amp;lt;&#39;TResult&amp;gt;, HandlerError&amp;lt;&#39;TError&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. This makes it possible to get the response status-code, response-headers etc even after decoding of the content. This is great when using Oryx for a web-proxy or protocol converter where you need to pass on any response-headers.&lt;/p&gt; &#xA;&lt;h2&gt;Using Oryx with Giraffe&lt;/h2&gt; &#xA;&lt;p&gt;You can use Oryx within your Giraffe server if you need to make HTTP requests to other services. But then you must be careful about the order when opening namespaces so you know if you use the &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt; operator from Oryx or Giraffe. Usually, this will not be a problem since the Giraffe &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt; will be used within your e.g &lt;code&gt;WebApp.fs&lt;/code&gt; or &lt;code&gt;Server.fs&lt;/code&gt;, while the Oryx &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt; will be used within the controller handler function itself e.g &lt;code&gt;Controllers/Index.fs&lt;/code&gt;. Thus just make sure you open Oryx after Giraffe in the controller files.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-fs&#34;&gt;open Giraffe&#xA;open Oryx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Libraries using Oryx:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cognitedata/cognite-sdk-dotnet&#34;&gt;Cognite SDK .NET&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dbrattli/oryx-netatmo&#34;&gt;oryx-netatmo&lt;/a&gt; (Currently a bit outdated)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;This project follows &lt;a href=&#34;https://www.contributor-covenant.org&#34;&gt;https://www.contributor-covenant.org&lt;/a&gt;, see our &lt;a href=&#34;https://github.com/cognitedata/oryx/raw/master/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Apache v2, see &lt;a href=&#34;https://github.com/cognitedata/oryx/raw/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>