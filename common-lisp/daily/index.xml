<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-13T01:34:15Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>marcoheisig/Petalisp</title>
    <updated>2023-07-13T01:34:15Z</updated>
    <id>tag:github.com,2023-07-13:/marcoheisig/Petalisp</id>
    <link href="https://github.com/marcoheisig/Petalisp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Elegant High Performance Computing&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Petalisp&lt;/p&gt; &#xA;&lt;p&gt;Petalisp is an attempt to generate high performance code for parallel computers by JIT-compiling array definitions. It is not a full blown programming language, but rather a carefully crafted extension of Common Lisp that allows for extreme optimization and parallelization.&lt;/p&gt; &#xA;&lt;p&gt;** Getting Started&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Lisp and a suitable IDE. If unsure, pick [[https://portacle.github.io/][Portacle]].&lt;/li&gt; &#xA; &lt;li&gt;Download Petalisp via [[https://www.quicklisp.org/][Quicklisp]].&lt;/li&gt; &#xA; &lt;li&gt;Check out some of the [[file:examples][examples]].&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;** Showcases Petalisp is still under development, so the following examples may still change slightly. Nevertheless they give a good glimpse on what programming with Petalisp will be like.&lt;/p&gt; &#xA;&lt;p&gt;Example 1: transposing a matrix #+BEGIN_SRC lisp (defun lazy-transpose (A) (lazy-reshape A (transform m n to n m))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Example 2: matrix-matrix multiplication #+BEGIN_SRC lisp (defun matrix-multiplication (A B) (lazy-reduce #&#39;+ (lazy #&#39;* (lazy-reshape A (transform m n to n m 1)) (lazy-reshape B (transform n k to n 1 k))))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Example 3: the numerical Jacobi scheme in two dimensions #+BEGIN_SRC lisp (defun lazy-jacobi-2d (grid iterations) (let ((interior (interior grid))) (if (zerop iterations) grid (lazy-jacobi-2d (lazy-fuse x (lazy #&#39;* 0.25 (lazy #&#39;+ (lazy-reshape x (transform i0 i1 to (+ i0 1) i1) interior) (lazy-reshape x (transform i0 i1 to (- i0 1) i1) interior) (lazy-reshape x (transform i0 i1 to i0 (+ i1 1)) interior) (lazy-reshape x (transform i0 i1 to i0 (- i1 1)) interior)))) (- iterations 1))))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;** Performance&lt;/p&gt; &#xA;&lt;p&gt;Coming soon!&lt;/p&gt; &#xA;&lt;p&gt;** Frequently Asked Questions&lt;/p&gt; &#xA;&lt;p&gt;*** Is Petalisp similar to NumPy? NumPy is a widely used Python library for scientific computing on arrays. It provides powerful N-dimensional arrays and a variety of functions for working with these arrays.&lt;/p&gt; &#xA;&lt;p&gt;Petalisp works on a more fundamental level. It provides even more powerful N-dimensional arrays, but just a few building blocks for working on them - element-wise function application, reduction, reshaping and array fusion.&lt;/p&gt; &#xA;&lt;p&gt;So Petalisp is not a substitute for NumPy. However, it could be used to write a library that behaves like NumPy, but that is much faster and fully parallelized. In fact, writing such a library is one of my future goals.&lt;/p&gt; &#xA;&lt;p&gt;*** Do I have to program Lisp to use Petalisp? Not necessarily. Not everyone has the time to learn Common Lisp. That is why I am also working on some [[https://github.com/marcoheisig/petalisp-for-python][convenient Python bindings]] for Petalisp.&lt;/p&gt; &#xA;&lt;p&gt;But: If you ever have time to learn Lisp, do it! It is an enlightening experience.&lt;/p&gt; &#xA;&lt;p&gt;*** How can I get Emacs to indent Petalisp code nicely?&lt;/p&gt; &#xA;&lt;p&gt;Put the following code in your initialization file:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src elisp (put &#39;lazy &#39;common-lisp-indent-function &#39;(1 &amp;amp;rest 1)) (put &#39;lazy-reduce &#39;common-lisp-indent-function &#39;(1 &amp;amp;rest 1)) (put &#39;lazy-multireduce &#39;common-lisp-indent-function &#39;(1 1 &amp;amp;rest 1)) (put &#39;lazy-multiple-value &#39;common-lisp-indent-function &#39;(1 1 &amp;amp;rest 1)) (put &#39;lazy-reshape &#39;common-lisp-indent-function &#39;(1 &amp;amp;rest 1)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Why is Petalisp licensed under AGPL? I am aware that this license prevents some people from using or contributing to this piece of software, which is a shame. But unfortunately the majority of software developers have not yet understood that&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;In a digital world, free software is a necessary prerequisite for a free society.&lt;/li&gt; &#xA; &lt;li&gt;When developing software, open collaboration is way more efficient than competition.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;So as long as distribution of non-free software is socially accepted, copyleft licenses like the AGPL seem to be the lesser evil.&lt;/p&gt; &#xA;&lt;p&gt;That being said, I am willing to discuss relicensing on an individual basis.&lt;/p&gt; &#xA;&lt;p&gt;*** Why is Petalisp written in Common Lisp? I couldn&#39;t wish for a better tool for the job. Common Lisp is extremely rich in features, standardized, fast, safe and mature. The Lisp community is amazing and there are excellent libraries for almost every imaginable task.&lt;/p&gt; &#xA;&lt;p&gt;To illustrate why Lisp is particularly well suited for a project like Petalisp, consider the following implementation of a JIT-compiler for mapping a function over a vector of a certain element type:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (defun vector-mapper (element-type) (compile nil `(lambda (fn vec) (declare (function fn) (type (simple-array ,element-type (*)) vec) (optimize (speed 3) (safety 0))) (loop for index below (length vec) do (symbol-macrolet ((elt (aref vec index))) (setf elt (funcall fn elt))))))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Not only is this JIT-compiler just 8 lines of code, it is also 20 times faster than invoking GCC or Clang on a roughly equivalent piece of C code.&lt;/p&gt;</summary>
  </entry>
</feed>