<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-13T01:38:35Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>inconvergent/weird</title>
    <updated>2022-07-13T01:38:35Z</updated>
    <id>tag:github.com,2022-07-13:/inconvergent/weird</id>
    <link href="https://github.com/inconvergent/weird" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Generative art in Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;WEIRD-A Generative Art System&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE: This code is likely to change with little or no warning. You should not use this for anything remotely important. Make sure to clone the repo if you need it to remain stable.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;weird&lt;/code&gt; is the next iteration of &lt;a href=&#34;https://github.com/inconvergent/weir&#34;&gt;weir&lt;/a&gt;, which was the next iteration of &lt;a href=&#34;https://github.com/inconvergent/snek&#34;&gt;snek&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The library is written to be useful for a broad range of ways in which I create art using generative algorithms. Almost everything I have made over the past several years has been made using some version of this system.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/img/web.png&#34; alt=&#34;Elastic Web&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Components&lt;/h2&gt; &#xA;&lt;p&gt;Here are the main components:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;2d/3d vector mathematics via &lt;a href=&#34;https://github.com/inconvergent/cl-veq&#34;&gt;cl-veq&lt;/a&gt;. See &lt;a href=&#34;https://github.com/inconvergent/cl-veq/raw/master/examples/ex.lisp&#34;&gt;examples&lt;/a&gt; in veq for more details.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A simple (undirected) graph data structure called &lt;code&gt;weir&lt;/code&gt;. The structure can be manipulated directly, or via &lt;code&gt;alterations&lt;/code&gt;. The latter is described in more detail below. Here is a simple example of how you can manipulate the structure directly:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package :weir)&#xA;(let ((wer (make)))&#xA;  ; add three edges&#xA;  (loop repeat 3&#xA;        do (add-edge! wer&#xA;             (2add-vert! wer&#xA;               (rnd:2in-circ 200.0))&#xA;             (2add-vert! wer&#xA;               (veq:f2+ (veq:2rep 500.0)&#xA;                        (rnd:2in-circ 200.0))))&#xA;  ; iterate verts&#xA;  (itr-verts (wer v)&#xA;    ; prints vert coordinates&#xA;    (veq:vpr (2get-vert wer v)))&#xA;&#xA;  ; iterate edges&#xA;  (itr-edges (wer vv)&#xA;    (veq:vpr (2get-verts wer vv)))&#xA;&#xA;  ; move a vert relativ to current position:&#xA;  (2move-vert! wer 0 1.0 2.0)&#xA;  ; or to an absolute position&#xA;  (2move-vert! wer 1 1.0 2.0 :rel nil)&#xA;&#xA;  ; edges are represented as lists of verts, and they are always&#xA;  ; sorted with the smallest vert index first, so both of these&#xA;  ; return t:&#xA;  (edge-exists wer &#39;(0 1))&#xA;  (edge-exists wer &#39;(1 0))&#xA;&#xA;  ; get edges incident to vert 0&#xA;  (get-incident-edges wer 0))&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/examples/draw.lisp&#34;&gt;examples/draw.lisp&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/examples/ex.lisp&#34;&gt;examples/ex.lisp&lt;/a&gt; for more.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Random numbers, some examples:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package :rnd)&#xA;(rnd a) ; in range [0.0, a), defaults to a=1.0.&#xA;(rnd* a) ; in range [-a, a), defaults to a=1.0.&#xA;(rndrng a b) ; in range [a, b)&#xA;(rndi 10) ; random fixnum&#xA;(rndspace n a b) ; n numbers in [a, b)&#xA;(norm :mu 0.0 :sigma 1.0) ; normal distribution&#xA;(2in-circ a) ; in circle of radius a&#xA;(2in-rect w h) ; in a rectangle&#xA;(2nin-rect n w h) ; n in rectangle.&#xA;(2on-line ax ay bx by) ; point between points a and b&#xA;&#xA;; do something with probability 0.1, second form is optional&#xA;(prob 0.1 (print &#34;10% hi&#34;) (print &#34;90% oh no&#34;))&#xA;&#xA;; perform either form 1 or (optionally) 2&#xA;(either (print &#34;form 1&#34;) (print &#34;form 2&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/src/rnd/rnd.lisp&#34;&gt;rnd.lisp&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/src/rnd/2rnd.lisp&#34;&gt;2rnd.lisp&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/src/rnd/3rnd.lisp&#34;&gt;3rnd.lisp&lt;/a&gt;, for all available functions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A tool for drawing &lt;code&gt;svg&lt;/code&gt; files: &lt;code&gt;wsvg&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/examples/draw.lisp&#34;&gt;draw.lisp&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In addition the library contains a number of useful tools for dealing with (predominantly) vector graphics.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/img/sun.png&#34; alt=&#34;Sun&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Weir Graphs and Alterations&lt;/h2&gt; &#xA;&lt;p&gt;In my opinion, the most interesting part of the &lt;code&gt;weir&lt;/code&gt; graph structure is &lt;code&gt;alterations&lt;/code&gt;. An &lt;code&gt;alteration&lt;/code&gt; is a change that will be applied to the structure at the end of a given context, provided it is valid.&lt;/p&gt; &#xA;&lt;p&gt;The main motivation behind this is that this makes it possible to gather up a number of changes that will be applied to the graph at a later time. This makes it possible to access the state in the &lt;code&gt;weir&lt;/code&gt; instance while you are creating the alterations. Without there being any changes made to the state of the &lt;code&gt;weir&lt;/code&gt; instance while the alterations are being created. Once all alterations are created, the valid ones will be applied.&lt;/p&gt; &#xA;&lt;p&gt;Existing alterations in &lt;code&gt;weir&lt;/code&gt; are postfixed with &lt;code&gt;?&lt;/code&gt;. It might look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(weir:with (wer %)&#xA;  (% (add-vert? (veq:f2 100.0 740.0))&#xA;  (% (add-edge? 1 4)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;(% ...)&lt;/code&gt; is used to collect alterations. They will be executed at the end of the &lt;code&gt;with&lt;/code&gt; context. If an &lt;code&gt;alteration&lt;/code&gt; evaluates to &lt;code&gt;nil&lt;/code&gt;, nothing will happen.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example of how the forces are calculated in my &lt;a href=&#34;https://inconvergent.net/2019/a-tangle-of-webs/&#34;&gt;Tangle of Webs simulation&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(veq:vdef* reciprocal-edge-forces (wer &amp;amp;key (stp 0.1))&#xA;  (weir:with (wer %)&#xA;    ; state of wer is unaltered&#xA;    (weir:itr-edges (wer e) ; edge (v0 v1)&#xA;      ; vector from v0 to v1&#xA;      ; force is proportional to this &#34;oriented distance&#34;&#xA;      (veq:f2let ((force (veq:f2-&#xA;                           (veq:f2$ (weir:2get-verts wer e)&#xA;                                    1 0))))&#xA;        (loop for i in e and s in &#39;(-1.0 1.0)&#xA;              ; alteration is created, but nothing happens&#xA;              do (% (2move-vert? i&#xA;                      (veq:f2scale force (* s stp)))))))))&#xA;    ; alterations are applied at the end&#xA;    ; of the context&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The important thing to note here is that for the forces to be calculated correctly, all edge lengths must be calculated &lt;em&gt;before&lt;/em&gt; the forces are applied to the vertices.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/img/symbols.png&#34; alt=&#34;Symbols&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Futures and Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;You can assign a name to the result of an alteration using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(% (add-edge? 1 3) :res :some-name?)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This makes it possible to create alterations that depend on the result of other alterations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package :weir)&#xA;(with (wer %)&#xA;  (veq:f2let ((pt (veq:f2 1f0 3f0)))&#xA;    (% (2add-vert? pt) :res :a?) ; alteration result is named :a?&#xA;    (% (2add-vert? (veq:f2 1.0 2.0)) :res :b?) ; result named :b?&#xA;    (% (add-edge? :a? :b?)))) ; depends on :a? and :b?&#xA;&#xA;; all alteration results:&#xA;(print (get-alteration-result-list wer))&#xA;; or as a `hash-map`:&#xA;(print (get-alteration-result-map wer))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;alteration&lt;/code&gt; names must be &lt;code&gt;keywords&lt;/code&gt; that end with &lt;code&gt;?&lt;/code&gt;. (There is an exception, see &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/#Looping&#34;&gt;Looping&lt;/a&gt; below.) And using the same name for multiple alterations &lt;em&gt;will&lt;/em&gt; result in undefined behaviour.&lt;/p&gt; &#xA;&lt;p&gt;As you can see, a named alteration is akin to a &lt;em&gt;future&lt;/em&gt;; a reference to a result that may or may not exist eventually. For this to work, any alteration that depends on a future that fails (or returns &lt;code&gt;nil&lt;/code&gt;) will be skipped.&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;(weir:with (wer % :bd t) ...)&lt;/code&gt; to see how an alteration is expanded. This might make it easier to see what is going on.&lt;/p&gt; &#xA;&lt;p&gt;As en example. The &lt;code&gt;alteration&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(% (2move-vert? :vert?&#xA;     (veq:f2scale&#xA;       (veq:f2- (veq:f2$ (weir:2get-verts wer &#39;(1 3)) 1 0))&#xA;       1f0)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will be expanded to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(VEQ:F2LET&#xA; ((#:OUT-F2!P53&#xA;   (VEQ:F2SCALE (VEQ:F2- (VEQ:F2$ (WEIR:2GET-VERTS WER &#39;(1 3)) 1 0)) 1.0)))&#xA; (LET ((#:OUT-REL54 T))&#xA;   (LAMBDA (#:WER541)&#xA;     (CASE (WEIR::-IF-ALL-RESOLVED #:ALT-RES29 (LIST :VERT?))&#xA;       (:OK&#xA;        (VALUES T&#xA;                (PROGN&#xA;                 (WHEN&#xA;                     (WEIR::-VALID-VERT #:WER541&#xA;                                        (VALUES (GETHASH :VERT? #:ALT-RES29)))&#xA;                   (PROGN&#xA;                    (WEIR:2MOVE-VERT! #:WER541&#xA;                                      (VALUES (GETHASH :VERT? #:ALT-RES29))&#xA;                                      (WEIR::VAL* #:OUT-F2!P53)&#xA;                                      :REL #:OUT-REL54)&#xA;                    (VALUES (GETHASH :VERT? #:ALT-RES29)))))))&#xA;       (:BAIL (PROGN NIL (VALUES T NIL)))&#xA;       (T (VALUES NIL NIL))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which won&#39;t work in its own unless &lt;code&gt;:VERT?&lt;/code&gt; is also defined. But you can see how the promise resolution is handled. And how values (&lt;code&gt;#:OUT-REL54&lt;/code&gt;, &lt;code&gt;#:OUT-F2!P53&lt;/code&gt;) are defined in the surrounding closure.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/img/scribble.png&#34; alt=&#34;Scribbles&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Looping&lt;/h3&gt; &#xA;&lt;p&gt;It is possible to use &lt;code&gt;alterations&lt;/code&gt; inside loops as well. but it requires a bit more careful consideration. Here is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package :weir)&#xA;(with (wer % :db t)&#xA;  (loop for x in (math:linspace 20 -20.0 20.0) do&#xA;    (loop for z in (list 1.0 2.0) do&#xA;      (veq:f3let ((xy (veq:f3 x y z)))&#xA;        ; create a distinct name&#xA;        (let ((g? (gensym &#34;g&#34;)))&#xA;          (% (add-grp? :name (gensym &#34;line&#34;)) :res g?)&#xA;          (% (2add-path?&#xA;               (veq:f$_ (list (veq:f3-&#xA;                                xy (veq:f3 1.0 8.0 (rnd:rnd)))&#xA;                              (veq:f3+&#xA;                                xy (veq:f3 1.0 2.0 (rnd:rnd)))))&#xA;               :g g?)))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Writing&lt;/h2&gt; &#xA;&lt;p&gt;I have written about things related to this code at:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inconvergent.net/2017/snek-is-not-an-acronym/&#34;&gt;https://inconvergent.net/2017/snek-is-not-an-acronym/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inconvergent.net/2017/a-method-for-mistakes/&#34;&gt;https://inconvergent.net/2017/a-method-for-mistakes/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inconvergent.net/2017/arbitrary-alterations/&#34;&gt;https://inconvergent.net/2017/arbitrary-alterations/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inconvergent.net/2017/grains-of-sand/&#34;&gt;https://inconvergent.net/2017/grains-of-sand/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inconvergent.net/2017/a-propensity-for-mistakes/&#34;&gt;https://inconvergent.net/2017/a-propensity-for-mistakes/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inconvergent.net/2020/future-alterations/&#34;&gt;https://inconvergent.net/2020/future-alterations/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inconvergent.net/2021/future-alterations-and-loops/&#34;&gt;https://inconvergent.net/2021/future-alterations-and-loops/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that these posts refer to older iterations of the code. So some of the things will be out of date.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/inconvergent/weird/master/img/boxes.png&#34; alt=&#34;Boxes&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;On Use and Contributions&lt;/h2&gt; &#xA;&lt;p&gt;This code is written for my personal use, and parts of it is rather experimental. Also, it is likely to change at my whim. For this reason I don&#39;t recommend depending on this library for anything.&lt;/p&gt; &#xA;&lt;p&gt;I release it publicly in case people find it useful or interesting. It is not, however, intended as a collaboration/Open Source project. As such I am unlikely to accept PRs, reply to issues, or take requests.&lt;/p&gt; &#xA;&lt;h2&gt;Installation and Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;weird&lt;/code&gt; depends on &lt;a href=&#34;https://github.com/inconvergent/cl-veq&#34;&gt;cl-veq&lt;/a&gt;, and it requires Quicklisp to install dependencies (which are listed in &lt;code&gt;weird.asd&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;To install and load &lt;code&gt;weird&lt;/code&gt;, do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(ql:quickload :weird)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If this does not work, &lt;code&gt;weird&lt;/code&gt; may not be in a place Quicklisp or ASDF can see them. To fix this, either:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(load &#34;weird.asd&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a long term solution, add the following to &lt;code&gt;.sbclrc&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;#+quicklisp&#xA;(push &#34;/path/to/dir/containing/weird&#34; ql:*local-project-directories*)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will have to make sure &lt;code&gt;cl-veq&lt;/code&gt; is also available in the same fashion for any of this to work.&lt;/p&gt; &#xA;&lt;h3&gt;Versions and Compatability&lt;/h3&gt; &#xA;&lt;p&gt;Weird version 6.1.0 requires version &lt;code&gt;cl-veq&lt;/code&gt; 2.2.0.&lt;/p&gt; &#xA;&lt;h3&gt;Tests&lt;/h3&gt; &#xA;&lt;p&gt;Tests can be executed using: &lt;code&gt;(asdf:test-system :weird)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;I would like to thank:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/RainerJoswig&#34;&gt;https://twitter.com/RainerJoswig&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/jackrusher&#34;&gt;https://twitter.com/jackrusher&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/paulg&#34;&gt;https://twitter.com/paulg&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/porglezomp&#34;&gt;https://twitter.com/porglezomp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/stylewarning&#34;&gt;https://twitter.com/stylewarning&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Hellseher&#34;&gt;https://github.com/Hellseher&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Who have provided me with useful hints and code feedback.&lt;/p&gt; &#xA;&lt;p&gt;The ASDF config and test setup was kindly suggested and implemented by Robert Smith (&lt;a href=&#34;https://twitter.com/stylewarning&#34;&gt;https://twitter.com/stylewarning&lt;/a&gt;). Although I have made some changes since then.&lt;/p&gt; &#xA;&lt;p&gt;Also, many thanks to &lt;a href=&#34;https://twitter.com/xach&#34;&gt;https://twitter.com/xach&lt;/a&gt; for making Quicklisp.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Shirakumo/trial</title>
    <updated>2022-07-13T01:38:35Z</updated>
    <id>tag:github.com,2022-07-13:/Shirakumo/trial</id>
    <link href="https://github.com/Shirakumo/trial" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fully-fledged Common Lisp game engine&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Shirakumo/trial/master/logo.svg?sanitize=true&#34; alt=&#34;logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About Trial&lt;/h2&gt; &#xA;&lt;p&gt;Trial is a game engine written in Common Lisp. Unlike many other engines, it is meant to be more of a loose connection of components that can be fit together as required by any particular game.&lt;/p&gt; &#xA;&lt;p&gt;The project is still in its very early stages and may change heavily as new constraints become clear. As such there is no guarantee for API stability at this point and no documentation is available. However, you may use projects such as &lt;a href=&#34;https://github.com/shinmera/vpetjam&#34;&gt;Vegetable Mash&lt;/a&gt; as a reference on how to start using it.&lt;/p&gt; &#xA;&lt;p&gt;Come talk to us at the shirakumo channel, reachable through &lt;a href=&#34;https://chat.tymoon.eu/?channel=shirakumo&#34;&gt;lichat&lt;/a&gt; or IRC on Libera.&lt;/p&gt; &#xA;&lt;h2&gt;Projects Using Trial&lt;/h2&gt; &#xA;&lt;p&gt;Here are a few games that are using Trial as their engine. Kandria and Eternia: Pet Whisperer are commercial games available on Steam.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kandria.com&#34;&gt;&lt;img src=&#34;https://kandria.com/media/small%20capsule.png&#34; alt=&#34;logo&#34;&gt;&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://kandria.com&#34;&gt;Kandria&lt;/a&gt; On &lt;a href=&#34;https://store.steampowered.com/app/1261430/Kandria/&#34;&gt;Steam&lt;/a&gt;!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kandria.com/eternia&#34;&gt;&lt;img src=&#34;https://kandria.com/eternia/media/small%20capsule.png&#34; alt=&#34;logo&#34;&gt;&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://kandria.com/eternia&#34;&gt;Eternia Pet Whisperer&lt;/a&gt; On &lt;a href=&#34;https://store.steampowered.com/app/1605720/Eternia_Pet_Whisperer/&#34;&gt;Steam&lt;/a&gt;!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://shinmera.itch.io/vegetablemash&#34;&gt;Vegetable Mash&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://shinmera.itch.io/rush&#34;&gt;Rush&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://shinmera.itch.io/outsider&#34;&gt;Outsider&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>