<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-27T01:32:12Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sim642/odep</title>
    <updated>2023-01-27T01:32:12Z</updated>
    <id>tag:github.com,2023-01-27:/sim642/odep</id>
    <link href="https://github.com/sim642/odep" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Dependency graphs for OCaml modules, libraries and packages&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;odep&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sim642/odep/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/sim642/odep/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;ci workflow status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sim642/odep/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/sim642/odep&#34; alt=&#34;GitHub release status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opam.ocaml.org/packages/odep&#34;&gt;&lt;img src=&#34;https://badgen.net/opam/v/odep&#34; alt=&#34;opam package status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Dependency graphs for OCaml modules, libraries and packages.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;opam install odep&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;dune&lt;/h3&gt; &#xA;&lt;p&gt;Dependency graphs for dune project modules and libraries, examples here for this repository. Includes clusters for libraries and opam packages.&lt;/p&gt; &#xA;&lt;h4&gt;xdot&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;odep dune | xdot -&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;opens &lt;code&gt;xdot&lt;/code&gt; for interactive dot graph viewing.&lt;/p&gt; &#xA;&lt;h4&gt;dot&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;odep dune | dot -Tsvg &amp;gt; img/odep.svg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;produces: &lt;a href=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/dune-odep.svg&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/dune-odep.svg?sanitize=true&#34; alt=&#34;Dune dependency graph for odep&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Mermaid&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;odep dune -t mermaid&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;copied into a &lt;code&gt;mermaid&lt;/code&gt; language block in GitHub Flavored Markdown produces:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart TD&#xA;  subgraph 102489341 [&#34;parsexp&#34;]&#xA;    id705946596([&#34;parsexp&#34;])&#xA;    style id705946596 fill:#BBB&#xA;  end&#xA;  subgraph 1029800924 [&#34;opam-file-format&#34;]&#xA;    id430993069([&#34;opam-file-format&#34;])&#xA;    style id430993069 fill:#BBB&#xA;  end&#xA;  subgraph 129913994 [&#34;(compiler)&#34;]&#xA;    id266426620([&#34;unix&#34;])&#xA;    style id266426620 fill:#BBB&#xA;    id255847688([&#34;compiler-libs.common&#34;])&#xA;    style id255847688 fill:#BBB&#xA;    id612096776([&#34;bigarray&#34;])&#xA;    style id612096776 fill:#BBB&#xA;  end&#xA;  subgraph 154672022 [&#34;astring&#34;]&#xA;    id96640315([&#34;astring&#34;])&#xA;    style id96640315 fill:#BBB&#xA;  end&#xA;  subgraph 195080345 [&#34;base&#34;]&#xA;    id498790760([&#34;base.shadow_stdlib&#34;])&#xA;    style id498790760 fill:#BBB&#xA;    id301824178([&#34;base.caml&#34;])&#xA;    style id301824178 fill:#BBB&#xA;    id346353879([&#34;base.base_internalhash_types&#34;])&#xA;    style id346353879 fill:#BBB&#xA;    id820557841([&#34;base&#34;])&#xA;    style id820557841 fill:#BBB&#xA;  end&#xA;  subgraph 198614204 [&#34;fpath&#34;]&#xA;    id365328357([&#34;fpath&#34;])&#xA;    style id365328357 fill:#BBB&#xA;  end&#xA;  subgraph 225091939 [&#34;stdlib-shims&#34;]&#xA;    id638246448([&#34;stdlib-shims&#34;])&#xA;    style id638246448 fill:#BBB&#xA;  end&#xA;  subgraph 284891543 [&#34;result&#34;]&#xA;    id65125095([&#34;result&#34;])&#xA;    style id65125095 fill:#BBB&#xA;  end&#xA;  subgraph 305955603 [&#34;opam-repository&#34;]&#xA;    id523500181([&#34;opam-repository&#34;])&#xA;    style id523500181 fill:#BBB&#xA;  end&#xA;  subgraph 344936565 [&#34;rresult&#34;]&#xA;    id779206996([&#34;rresult&#34;])&#xA;    style id779206996 fill:#BBB&#xA;  end&#xA;  subgraph 345009057 [&#34;sexplib0&#34;]&#xA;    id267566403([&#34;sexplib0&#34;])&#xA;    style id267566403 fill:#BBB&#xA;  end&#xA;  subgraph 37868010 [&#34;ppx_sexp_conv&#34;]&#xA;    id384587701([&#34;ppx_sexp_conv.runtime-lib&#34;])&#xA;    style id384587701 fill:#BBB&#xA;    id490832801([&#34;ppx_sexp_conv.expander&#34;])&#xA;    style id490832801 fill:#BBB&#xA;    id431945222([&#34;ppx_sexp_conv&#34;])&#xA;    style id431945222 fill:#BBB&#xA;  end&#xA;  subgraph 393735124 [&#34;ocaml-compiler-libs&#34;]&#xA;    id250303275([&#34;ocaml-compiler-libs.shadow&#34;])&#xA;    style id250303275 fill:#BBB&#xA;    id196159797([&#34;ocaml-compiler-libs.common&#34;])&#xA;    style id196159797 fill:#BBB&#xA;  end&#xA;  subgraph 50838805 [&#34;re&#34;]&#xA;    id736186284([&#34;re&#34;])&#xA;    style id736186284 fill:#BBB&#xA;  end&#xA;  subgraph 589116851 [&#34;ocamlfind&#34;]&#xA;    id625691540([&#34;findlib.internal&#34;])&#xA;    style id625691540 fill:#BBB&#xA;    id701773260([&#34;findlib&#34;])&#xA;    style id701773260 fill:#BBB&#xA;  end&#xA;  subgraph 668538665 [&#34;fmt&#34;]&#xA;    id9672888([&#34;fmt&#34;])&#xA;    style id9672888 fill:#BBB&#xA;  end&#xA;  subgraph 728143533 [&#34;ppxlib&#34;]&#xA;    id597334381([&#34;ppxlib.traverse_builtins&#34;])&#xA;    style id597334381 fill:#BBB&#xA;    id917977464([&#34;ppxlib.stdppx&#34;])&#xA;    style id917977464 fill:#BBB&#xA;    id451125523([&#34;ppxlib.print_diff&#34;])&#xA;    style id451125523 fill:#BBB&#xA;    id500424639([&#34;ppxlib.metaquot_lifters&#34;])&#xA;    style id500424639 fill:#BBB&#xA;    id591717662([&#34;ppxlib.astlib&#34;])&#xA;    style id591717662 fill:#BBB&#xA;    id493940453([&#34;ppxlib.ast&#34;])&#xA;    style id493940453 fill:#BBB&#xA;    id1060173278([&#34;ppxlib&#34;])&#xA;    style id1060173278 fill:#BBB&#xA;  end&#xA;  subgraph 736354641 [&#34;ocamlgraph&#34;]&#xA;    id932964826([&#34;ocamlgraph&#34;])&#xA;    style id932964826 fill:#BBB&#xA;  end&#xA;  subgraph 737393125 [&#34;sexplib&#34;]&#xA;    id769040463([&#34;sexplib&#34;])&#xA;    style id769040463 fill:#BBB&#xA;  end&#xA;  subgraph 74961155 [&#34;bos&#34;]&#xA;    id261970978([&#34;bos&#34;])&#xA;    style id261970978 fill:#BBB&#xA;  end&#xA;  subgraph 760144722 [&#34;cmdliner&#34;]&#xA;    id316126800([&#34;cmdliner&#34;])&#xA;    style id316126800 fill:#BBB&#xA;  end&#xA;  subgraph 771236823 [&#34;seq&#34;]&#xA;    id767300645([&#34;seq&#34;])&#xA;    style id767300645 fill:#BBB&#xA;  end&#xA;  subgraph 796857884 [&#34;opam-format&#34;]&#xA;    id27811258([&#34;opam-format&#34;])&#xA;    style id27811258 fill:#BBB&#xA;  end&#xA;  subgraph 804871866 [&#34;ppx_derivers&#34;]&#xA;    id419787933([&#34;ppx_derivers&#34;])&#xA;    style id419787933 fill:#BBB&#xA;  end&#xA;  subgraph 86790983 [&#34;logs&#34;]&#xA;    id350898877([&#34;logs&#34;])&#xA;    style id350898877 fill:#BBB&#xA;  end&#xA;  subgraph 870055720 [&#34;ppx_deriving&#34;]&#xA;    id220745025([&#34;ppx_deriving.runtime&#34;])&#xA;    style id220745025 fill:#BBB&#xA;    id552404124([&#34;ppx_deriving.ord&#34;])&#xA;    style id552404124 fill:#BBB&#xA;    id980760749([&#34;ppx_deriving.eq&#34;])&#xA;    style id980760749 fill:#BBB&#xA;    id878950795([&#34;ppx_deriving.api&#34;])&#xA;    style id878950795 fill:#BBB&#xA;  end&#xA;  subgraph 881110897 [&#34;opam-core&#34;]&#xA;    id125670630([&#34;opam-core&#34;])&#xA;    style id125670630 fill:#BBB&#xA;  end&#xA;  subgraph 902546259 [&#34;(local)&#34;]&#xA;&#xA;    subgraph 122612022 [&#34;depgraph&#34;]&#xA;      id439874552(Opam_installed_graph)&#xA;      id882674132(Opam_findlib)&#xA;      id890445863(Findlib_graph)&#xA;      id130907115(Dune_describe_graph)&#xA;      id658580835(Dot_graph)&#xA;      id593996496(Depgraph)&#xA;      id175675044(Common)&#xA;      id122612022([&#34;depgraph&#34;])&#xA;    end&#xA;    subgraph 158492278 [&#34;std&#34;]&#xA;      id1008512934(Std)&#xA;      id916334710(Result_syntax)&#xA;      id262221135(Option_syntax)&#xA;      id768355202(Common_syntax)&#xA;      id158492278([&#34;std&#34;])&#xA;    end&#xA;    subgraph 189591663 [&#34;main&#34;]&#xA;      id591715563(Opam_installed)&#xA;      id725600054(Main)&#xA;      id1004882373(Findlib)&#xA;      id8714191(Dune_describe_file)&#xA;      id952370123(Dune)&#xA;      id326418831(Common)&#xA;      id189591663{&#34;main&#34;}&#xA;    end&#xA;    subgraph 312718400 [&#34;ocamlgraph_extra&#34;]&#xA;      id872997936(Ocamlgraph_extra)&#xA;      id157893572(Mermaid)&#xA;      id383119909(Graphviz)&#xA;      id312718400([&#34;ocamlgraph_extra&#34;])&#xA;    end&#xA;    subgraph 557698697 [&#34;dune_describe&#34;]&#xA;      id15495529(Dune_describe)&#xA;      id557698697([&#34;dune_describe&#34;])&#xA;    end&#xA;  end&#xA;  subgraph 997476828 [&#34;opam-state&#34;]&#xA;    id549045298([&#34;opam-state&#34;])&#xA;    style id549045298 fill:#BBB&#xA;  end&#xA;  189591663--&amp;gt;id261970978&#xA;  189591663--&amp;gt;id316126800&#xA;  189591663--&amp;gt;122612022&#xA;  id189591663--&amp;gt;id725600054&#xA;  id820557841--&amp;gt;id346353879&#xA;  id820557841--&amp;gt;id498790760&#xA;  id820557841--&amp;gt;id267566403&#xA;  id498790760--&amp;gt;id301824178&#xA;  id261970978--&amp;gt;id9672888&#xA;  id261970978--&amp;gt;id365328357&#xA;  id261970978--&amp;gt;id350898877&#xA;  id261970978--&amp;gt;id779206996&#xA;  id261970978--&amp;gt;id266426620&#xA;  id365328357--&amp;gt;id96640315&#xA;  id196159797--&amp;gt;id255847688&#xA;  id701773260--&amp;gt;id625691540&#xA;  id932964826--&amp;gt;id638246448&#xA;  id125670630--&amp;gt;id932964826&#xA;  id125670630--&amp;gt;id736186284&#xA;  id125670630--&amp;gt;id612096776&#xA;  id27811258--&amp;gt;id125670630&#xA;  id27811258--&amp;gt;id430993069&#xA;  id523500181--&amp;gt;id27811258&#xA;  id549045298--&amp;gt;id523500181&#xA;  id705946596--&amp;gt;id301824178&#xA;  id705946596--&amp;gt;id267566403&#xA;  id878950795--&amp;gt;id1060173278&#xA;  id878950795--&amp;gt;id65125095&#xA;  id980760749--&amp;gt;id878950795&#xA;  id552404124--&amp;gt;id878950795&#xA;  id220745025--&amp;gt;id65125095&#xA;  id431945222--&amp;gt;id490832801&#xA;  id490832801--&amp;gt;id820557841&#xA;  id490832801--&amp;gt;id500424639&#xA;  id384587701--&amp;gt;id267566403&#xA;  id1060173278--&amp;gt;id250303275&#xA;  id1060173278--&amp;gt;id419787933&#xA;  id1060173278--&amp;gt;id493940453&#xA;  id1060173278--&amp;gt;id451125523&#xA;  id1060173278--&amp;gt;id917977464&#xA;  id1060173278--&amp;gt;id597334381&#xA;  id493940453--&amp;gt;id591717662&#xA;  id493940453--&amp;gt;id638246448&#xA;  id591717662--&amp;gt;id196159797&#xA;  id500424639--&amp;gt;id1060173278&#xA;  id917977464--&amp;gt;id267566403&#xA;  id917977464--&amp;gt;id638246448&#xA;  id736186284--&amp;gt;id767300645&#xA;  id769040463--&amp;gt;id705946596&#xA;  id769040463--&amp;gt;id612096776&#xA;  id612096776--&amp;gt;id266426620&#xA;  122612022--&amp;gt;id701773260&#xA;  122612022--&amp;gt;id549045298&#xA;  122612022--&amp;gt;557698697&#xA;  122612022--&amp;gt;312718400&#xA;  122612022--&amp;gt;158492278&#xA;  id122612022--&amp;gt;id593996496&#xA;  557698697--&amp;gt;id220745025&#xA;  557698697--&amp;gt;id384587701&#xA;  557698697--&amp;gt;id769040463&#xA;  id557698697--&amp;gt;id15495529&#xA;  312718400--&amp;gt;id932964826&#xA;  id312718400--&amp;gt;id872997936&#xA;  id158492278--&amp;gt;id1008512934&#xA;  id952370123--&amp;gt;id326418831&#xA;  id8714191--&amp;gt;id326418831&#xA;  id1004882373--&amp;gt;id326418831&#xA;  id725600054--&amp;gt;id952370123&#xA;  id725600054--&amp;gt;id8714191&#xA;  id725600054--&amp;gt;id1004882373&#xA;  id725600054--&amp;gt;id591715563&#xA;  id591715563--&amp;gt;id326418831&#xA;  id593996496--&amp;gt;id658580835&#xA;  id593996496--&amp;gt;id130907115&#xA;  id593996496--&amp;gt;id890445863&#xA;  id593996496--&amp;gt;id439874552&#xA;  id658580835--&amp;gt;id175675044&#xA;  id130907115--&amp;gt;id882674132&#xA;  id890445863--&amp;gt;id882674132&#xA;  id882674132--&amp;gt;id175675044&#xA;  id439874552--&amp;gt;id175675044&#xA;  id157893572--&amp;gt;id383119909&#xA;  id872997936--&amp;gt;id157893572&#xA;  id1008512934--&amp;gt;id768355202&#xA;  id1008512934--&amp;gt;id262221135&#xA;  id1008512934--&amp;gt;id916334710&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;findlib&lt;/h3&gt; &#xA;&lt;p&gt;Dependency graphs for &lt;em&gt;installed&lt;/em&gt; findlib libraries. Includes clusters for opam packages.&lt;/p&gt; &#xA;&lt;h4&gt;Dependencies&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;odep findlib --depends=dune-release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/findlib-depends-dune-release.svg&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/findlib-depends-dune-release.svg?sanitize=true&#34; alt=&#34;Findlib dependency graph for dune-release&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Reverse dependencies&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;odep findlib --rdepends=fmt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/findlib-rdepends-fmt.svg&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/findlib-rdepends-fmt.svg?sanitize=true&#34; alt=&#34;Findlib reverse dependency graph for fmt&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Intersection of dependencies and reverse dependencies&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;odep findlib --depends=dune-release --rdepends=fmt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/findlib-depends-dune-release-rdepends-fmt.svg&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/findlib-depends-dune-release-rdepends-fmt.svg?sanitize=true&#34; alt=&#34;Findlib dependency and reverse dependency intersection graph for dune-release and fmt&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;opam&lt;/h3&gt; &#xA;&lt;p&gt;Dependency graphs for &lt;em&gt;installed&lt;/em&gt; opam packages.&lt;/p&gt; &#xA;&lt;h4&gt;Dependencies&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;odep opam --depends=dune-release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/opam-depends-dune-release.svg&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/opam-depends-dune-release.svg?sanitize=true&#34; alt=&#34;Opam dependency graph for dune-release&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Reverse dependencies&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;odep opam --rdepends=fmt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/opam-rdepends-fmt.svg&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/opam-rdepends-fmt.svg?sanitize=true&#34; alt=&#34;Opam reverse dependency graph for fmt&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Intersection of dependencies and reverse dependencies&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;odep opam --depends=dune-release --rdepends=fmt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/opam-depends-dune-release-rdepends-fmt.svg&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sim642/odep/master/img/opam-depends-dune-release-rdepends-fmt.svg?sanitize=true&#34; alt=&#34;Opam dependency and reverse dependency intersection graph for dune-release and fmt&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Other tools&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mjambon/dune-deps&#34;&gt;dune-deps&lt;/a&gt; — dune only, custom dune files parsing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Drup/opam-dot&#34;&gt;opam-dot&lt;/a&gt; — opam only, outdated (&lt;a href=&#34;https://github.com/sim642/opam-dot&#34;&gt;fork&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rgrinberg/ocaml-depgraph&#34;&gt;depgraph&lt;/a&gt; — modules only (via &lt;code&gt;ocamldep&lt;/code&gt;), inactive.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/zoggy/odoc_depgraph&#34;&gt;odoc-depgraph&lt;/a&gt; — modules only (in &lt;code&gt;ocamldoc&lt;/code&gt;), inactive.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://v2.ocaml.org/manual/ocamldoc.html&#34;&gt;&lt;code&gt;ocamldoc -dot&lt;/code&gt;&lt;/a&gt; — modules only (in &lt;code&gt;ocamldoc&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Octachron/codept&#34;&gt;codept&lt;/a&gt; — &lt;code&gt;ocamldep&lt;/code&gt; alternative, has &lt;code&gt;dot&lt;/code&gt; output, no dune integration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ocurrent/opam-dune-lint&#34;&gt;opam-dune-lint&lt;/a&gt; — package-library mapping, no graphing.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>dnaeon/clingon</title>
    <updated>2023-01-27T01:32:12Z</updated>
    <id>tag:github.com,2023-01-27:/dnaeon/clingon</id>
    <link href="https://github.com/dnaeon/clingon" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Command-line options parser system for Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;clingon&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=clingon= is a command-line options parser system for Common Lisp.&lt;/p&gt; &#xA;&lt;p&gt;A summary of the features supported by =clingon= is provided below.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Native support for sub-commands&lt;/li&gt; &#xA; &lt;li&gt;Support for command aliases&lt;/li&gt; &#xA; &lt;li&gt;Short and long option names support&lt;/li&gt; &#xA; &lt;li&gt;Related options may be grouped into categories&lt;/li&gt; &#xA; &lt;li&gt;Short options may be collapsed as a single argument, e.g. =-xyz=&lt;/li&gt; &#xA; &lt;li&gt;Long options support both notations - =--long-opt arg= and =--long-opt=arg=.&lt;/li&gt; &#xA; &lt;li&gt;Automatic generation of help/usage information for commands and sub-commands&lt;/li&gt; &#xA; &lt;li&gt;Out of the box support for =--version= and =--help= flags&lt;/li&gt; &#xA; &lt;li&gt;Support for various kinds of options like /string/, /integer/, /boolean/, /switches/, /enums/, /list/, /counter/, /filepath/, etc.&lt;/li&gt; &#xA; &lt;li&gt;Sub-commands can lookup global options and flags defined in parent commands&lt;/li&gt; &#xA; &lt;li&gt;Support for options, which may be required&lt;/li&gt; &#xA; &lt;li&gt;Options can be initialized via environment variables&lt;/li&gt; &#xA; &lt;li&gt;Single interface for creating options using =CLINGON:MAKE-OPTION=&lt;/li&gt; &#xA; &lt;li&gt;Generate documentation for your command-line app&lt;/li&gt; &#xA; &lt;li&gt;Support for =pre-hook= and =post-hook= actions for commands, which allows invoking functions before and after the respective handler of the command is executed&lt;/li&gt; &#xA; &lt;li&gt;Support for Bash and Zsh shell completions&lt;/li&gt; &#xA; &lt;li&gt;=clingon= is extensible, so if you don&#39;t find something you need you can extend it by developing a new option kind, or even new mechanism for initializing options, e.g. by looking up an external key/value store.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Scroll to the demo section in order to see some examples of =clingon= in action.&lt;/p&gt; &#xA;&lt;p&gt;Other Common Lisp option parser systems, which you might consider checking out.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://github.com/libre-man/unix-opts][unix-opts]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/sjl/adopt/][adopt]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://github.com/didierverna/clon][clon]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Quick Example&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here&#39;s a really quick example of a simple CLI application, which greets people.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (in-package :cl-user) (defpackage :clingon.example.greet (:use :cl) (:import-from :clingon) (:export :main)) (in-package :clingon.example.greet)&lt;/p&gt; &#xA;&lt;p&gt;(defun greet/options () &#34;Returns the options for the `greet&#39; command&#34; (list (clingon:make-option :string :description &#34;Person to greet&#34; :short-name #\u :long-name &#34;user&#34; :initial-value &#34;stranger&#34; :env-vars &#39;(&#34;USER&#34;) :key :user)))&lt;/p&gt; &#xA;&lt;p&gt;(defun greet/handler (cmd) &#34;Handler for the `greet&#39; command&#34; (let ((who (clingon:getopt cmd :user))) (format t &#34;Hello, &lt;del&gt;A!&lt;/del&gt;%&#34; who)))&lt;/p&gt; &#xA;&lt;p&gt;(defun greet/command () &#34;A command to greet someone&#34; (clingon:make-command :name &#34;greet&#34; :description &#34;greets people&#34; :version &#34;0.1.0&#34; :authors &#39;(&#34;John Doe &amp;lt;&lt;a href=&#34;mailto:john.doe@example.org&#34;&gt;john.doe@example.org&lt;/a&gt;&#34;) :license &#34;BSD 2-Clause&#34; :options (greet/options) :handler #&#39;greet/handler))&lt;/p&gt; &#xA;&lt;p&gt;(defun main () &#34;The main entrypoint of our CLI program&#34; (let ((app (greet/command))) (clingon:run app))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This small example shows a lot of details about how apps are structured with =clingon=.&lt;/p&gt; &#xA;&lt;p&gt;You can see there&#39;s a =main= function, which will be the entrypoint for our ASDF system. Then you can find the =greet/command= function, which creates and returns a new command.&lt;/p&gt; &#xA;&lt;p&gt;The =greet/options= functions returns the options associated with our sample command.&lt;/p&gt; &#xA;&lt;p&gt;And we also have the =greet/handler= function, which is the function that will be invoked when users run our command-line app.&lt;/p&gt; &#xA;&lt;p&gt;This way of organizing command, options and handlers makes it easy to re-use common options, or even handlers, and wire up any sub-commands anyway you prefer.&lt;/p&gt; &#xA;&lt;p&gt;You can find additional examples included in the test suite for =clingon=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Demo&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can also build and run the =clingon= demo application, which includes the =greet= command introduced in the previous section, along with other examples.&lt;/p&gt; &#xA;&lt;p&gt;[[./images/clingon-demo.gif]]&lt;/p&gt; &#xA;&lt;p&gt;Clone the [[https://github.com/dnaeon/clingon][clingon]] repo in your [[https://www.quicklisp.org/beta/faq.html][Quicklisp local-projects]] directory.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell git clone &lt;a href=&#34;https://github.com/dnaeon/clingon&#34;&gt;https://github.com/dnaeon/clingon&lt;/a&gt; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Register it to your local Quicklisp projects.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (ql:register-local-projects) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Building the Demo App&lt;/p&gt; &#xA;&lt;p&gt;You can build the demo app using SBCL with the following command.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell LISP=sbcl make demo #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Build the demo app using Clozure CL:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell LISP=ccl make demo #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In order to build the demo app using ECL you need to follow these instructions, which are ECL-specific. See [[https://common-lisp.net/project/ecl/static/manual/System-building.html#Compiling-with-ASDF][Compiling with ASDF from the ECL manual]] for more details. First, load the =:clingon.demo= system.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (ql:quickload :clingon.demo) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;And now build the binary with ECL:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (asdf:make-build :clingon.demo :type :program :move-here #P&#34;./&#34; :epilogue-code &#39;(clingon.demo:main)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This will create a new executable =clingon-demo=, which you can now execute.&lt;/p&gt; &#xA;&lt;p&gt;Optionally, you can also enable the bash completions support.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell APP=clingon-demo source extras/completions.bash #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In order to activate the Zsh completions, install the completions script in your =&lt;del&gt;/.zsh-completions= directory (or anywhere else you prefer) and update your =&lt;/del&gt;/.zshrc= file, so that the completions are loaded.&lt;/p&gt; &#xA;&lt;p&gt;Make sure that you have these lines in your =~/.zshrc= file.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell fpath=(~/.zsh-completions $fpath) autoload -U compinit compinit #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The following command will generate the Zsh completions script.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell ./clingon-demo zsh-completion &amp;gt; ~/.zsh-completions/_clingon-demo #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Use the =--help= flag to see some usage information about the demo application.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell ./clingon-demo --help #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Requirements&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://www.quicklisp.org/beta/][Quicklisp]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The =clingon= system is not yet part of Quicklisp, so for now you need to install it in your local Quicklisp projects.&lt;/p&gt; &#xA;&lt;p&gt;Clone the repo in your [[https://www.quicklisp.org/beta/faq.html][Quicklisp local-projects]] directory.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (ql:register-local-projects) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Then load the system.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (ql:quickload :clingon) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Step By Step Guide&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In this section we will implement a simple CLI application, and explain at each step what and why we do the things we do.&lt;/p&gt; &#xA;&lt;p&gt;Once you are done with it, you should have a pretty good understanding of the =clingon= system and be able to further extend the sample application on your own.&lt;/p&gt; &#xA;&lt;p&gt;We will be developing the application interactively and in the REPL. Finally we will create an ASDF system for our CLI app, so we can build it and ship it.&lt;/p&gt; &#xA;&lt;p&gt;The code we develop as part of this section will reside in a file named =intro.lisp=. Anything we write will be sent to the Lisp REPL, so we can compile it and get quick feedback about the things we&#39;ve done so far.&lt;/p&gt; &#xA;&lt;p&gt;You can find the complete code we&#39;ll develop in this section in the =clingon/examples/intro= directory.&lt;/p&gt; &#xA;&lt;p&gt;** Start the REPL&lt;/p&gt; &#xA;&lt;p&gt;Start up your REPL session and let&#39;s load the =clingon= system.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (ql:quickload :clingon) To load &#34;clingon&#34;: Load 1 ASDF system: clingon ; Loading &#34;clingon&#34;&lt;/p&gt; &#xA;&lt;p&gt;(:CLINGON) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Create a new package&lt;/p&gt; &#xA;&lt;p&gt;First, we will define a new package for our application and switch to it.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (in-package :cl-user) (defpackage :clingon.intro (:use :cl) (:import-from :clingon) (:export :main)) (in-package :clingon.intro) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;We have our package, so now we can proceed to the next section and create our first command.&lt;/p&gt; &#xA;&lt;p&gt;** Creating a new command&lt;/p&gt; &#xA;&lt;p&gt;The first thing we&#39;ll do is to create a new command. Commands are created using the =CLINGON:MAKE-COMMAND= function.&lt;/p&gt; &#xA;&lt;p&gt;Each command has a name, description, any options that the command accepts, any sub-commands the command knows about, etc.&lt;/p&gt; &#xA;&lt;p&gt;The command in =clingon= is represented by the =CLINGON:COMMAND= class, which contains many other slots as well, which you can lookup.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun top-level/command () &#34;Creates and returns the top-level command&#34; (clingon:make-command :name &#34;clingon-intro&#34; :description &#34;my first clingon cli app&#34; :version &#34;0.1.0&#34; :license &#34;BSD 2-Clause&#34; :authors &#39;(&#34;John Doe &lt;a href=&#34;mailto:john.doe@example.com&#34;&gt;john.doe@example.com&lt;/a&gt;&#34;))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This is how our simple command looks like. For now it doesn&#39;t do much, and in fact it won&#39;t execute anything, but we will fix that as we go.&lt;/p&gt; &#xA;&lt;p&gt;What is important to note, is that we are using a convention here to make things easier to understand and organize our code base.&lt;/p&gt; &#xA;&lt;p&gt;Functions that return new commands will be named =&#xA; &lt;name&gt;&#xA;  /command=. A similar approach is taken when we define options for a given command, e.g. =&#xA;  &lt;name&gt;&#xA;   /options= and for sub-commands we use =&#xA;   &lt;name&gt;&#xA;    /sub-commands=. Handlers will use the =&#xA;    &lt;name&gt;&#xA;     /handler= notation.&#xA;    &lt;/name&gt;&#xA;   &lt;/name&gt;&#xA;  &lt;/name&gt;&#xA; &lt;/name&gt;&lt;/p&gt; &#xA;&lt;p&gt;This makes things easier later on, when we introduce new sub-commands, and when we need to wire things up we can refer to our commands using the established naming convention. Of course, it&#39;s up to you to decide which approach to take, so feel free to adjust the layout of the code to your personal preferences. In this guide we will use the afore mentioned approach.&lt;/p&gt; &#xA;&lt;p&gt;Commands can be linked together in order to form a tree of commands and sub-commands. We will talk about that one in more details in the later sections of this guide.&lt;/p&gt; &#xA;&lt;p&gt;** Adding options&lt;/p&gt; &#xA;&lt;p&gt;Next, we will add a couple of options. Similar to the previous section we will define a new function, which simply returns a list of valid options. Defining it in the following way would make it easier to re-use these options later on, in case you have another command, which uses the exact same set of options.&lt;/p&gt; &#xA;&lt;p&gt;=clingon= exposes a single interface for creating options via the =CLINGON:MAKE-OPTION= generic function. This unified interface will allow developers to create and ship new option kinds, and still have their users leverage a common interface for the options via the =CLINGON:MAKE-OPTION= interface.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun top-level/options () &#34;Creates and returns the options for the top-level command&#34; (list (clingon:make-option :counter :description &#34;verbosity level&#34; :short-name #\v :long-name &#34;verbose&#34; :key :verbose) (clingon:make-option :string :description &#34;user to greet&#34; :short-name #\u :long-name &#34;user&#34; :initial-value &#34;stranger&#34; :env-vars &#39;(&#34;USER&#34;) :key :user))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s break things down a bit and explain what we just did.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ve defined two options -- one of =:COUNTER= kind and another one, which is of =:STRING= kind. Each option specifies a short and long name, along with a description of what the option is meant for.&lt;/p&gt; &#xA;&lt;p&gt;Another important thing we did is to specify a =:KEY= for our options. This is the key which we will later use in order to get the value associated with our option, when we use =CLINGON:GETOPT=.&lt;/p&gt; &#xA;&lt;p&gt;And we have also defined that our =--user= option can be initialized via environment variables. We can specify multiple environment variables, if we need to, and the first one that resolves to something will be used as the initial value for the option.&lt;/p&gt; &#xA;&lt;p&gt;If none of the environment variables are defined, the option will be initialized with the value specified by the =:INITIAL-VALUE= initarg.&lt;/p&gt; &#xA;&lt;p&gt;Before we move to the next section of this guide we will update the definition of our =TOP-LEVEL/COMMAND= function, so that we include our options.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun top-level/command () &#34;Creates and returns the top-level command&#34; (clingon:make-command :name &#34;clingon-intro&#34; ... :usage &#34;[-v] [-u &#xA; &lt;user&gt;&#xA;  ]&#34; ;; &amp;lt;- new code :options (top-level/options))) ;; &amp;lt;- new code #+end_src&#xA; &lt;/user&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Defining a handler&lt;/p&gt; &#xA;&lt;p&gt;A /handler/ in =clingon= is a function, which accepts an instance of =CLINGON:COMMAND= and is responsible for performing some work.&lt;/p&gt; &#xA;&lt;p&gt;The single argument a handler receives will be used to inspect the values of parsed options and any free arguments that were provided on the command-line.&lt;/p&gt; &#xA;&lt;p&gt;A command may or may not specify a handler. Some commands may be used purely as /namespaces/ for other sub-commands, and it might make no sense to have a handler for such commands. In other situations you may still want to provide a handler for the parent commands.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s define the handler for our /top-level/ command.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun top-level/handler (cmd) &#34;The top-level handler&#34; (let ((args (clingon:command-arguments cmd)) (user (clingon:getopt cmd :user)) (verbose (clingon:getopt cmd :verbose))) (format t &#34;Hello, &lt;del&gt;A!&lt;/del&gt;%&#34; user) (format t &#34;The current verbosity level is set to &lt;del&gt;A&lt;/del&gt;%&#34; verbose) (format t &#34;You have provided &lt;del&gt;A arguments&lt;/del&gt;%&#34; (length args)) (format t &#34;Bye.~%&#34;))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;We are introducing a couple of new functions, which we haven&#39;t described before.&lt;/p&gt; &#xA;&lt;p&gt;We are using =CLINGON:COMMAND-ARGUMENTS=, which will give us the free arguments we&#39;ve provided to our command, when we invoke it on the command-line.&lt;/p&gt; &#xA;&lt;p&gt;We also use the =CLINGON:GETOPT= function to lookup the values associated with our options. Remember the =:KEY= initarg we&#39;ve used in =CLINGON:MAKE-OPTION= when defining our options?&lt;/p&gt; &#xA;&lt;p&gt;And we will again update our =TOP-LEVEL/COMMAND= definition, this time with our handler included.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun top-level/command () &#34;Creates and returns the top-level command&#34; (clingon:make-command :name &#34;clingon-intro&#34; ... :handler #&#39;top-level/handler)) ;; &amp;lt;- new code #+end_src&lt;/p&gt; &#xA;&lt;p&gt;At this point we are basically done with our simple application. But before we move to the point where build our binary and start playing with it on the command-line we can test things out on the REPL, just to make sure everything works as expected.&lt;/p&gt; &#xA;&lt;p&gt;** Testing things out on the REPL&lt;/p&gt; &#xA;&lt;p&gt;Create a new instance of our command and bind it to some variable.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp INTRO&amp;gt; (defparameter &lt;em&gt;app&lt;/em&gt; (top-level/command)) &lt;em&gt;APP&lt;/em&gt; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Inspecting the returned instance would give you something like this.&lt;/p&gt; &#xA;&lt;h2&gt;#+begin_src lisp #&amp;lt;CLINGON.COMMAND:COMMAND {1004648293}&amp;gt;&lt;/h2&gt; &#xA;&lt;h2&gt;Class: #&#xA; &lt;standard-class clingon.command:command&gt;&lt;/standard-class&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Group slots by inheritance [ ] Sort slots alphabetically [X]&lt;/p&gt; &#xA;&lt;p&gt;All Slots: [ ] ARGS-TO-PARSE = NIL [ ] ARGUMENTS = NIL [ ] AUTHORS = (&#34;John Doe &lt;a href=&#34;mailto:john.doe@example.com&#34;&gt;john.doe@example.com&lt;/a&gt;&#34;) [ ] CONTEXT = #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 0 {1004648433}&amp;gt; [ ] DESCRIPTION = &#34;my first clingon cli app&#34; [ ] EXAMPLES = NIL [ ] HANDLER = #&amp;lt;FUNCTION TOP-LEVEL/HANDLER&amp;gt; [ ] LICENSE = &#34;BSD 2-Clause&#34; [ ] LONG-DESCRIPTION = NIL [ ] NAME = &#34;clingon-intro&#34; [ ] OPTIONS = (#&amp;lt;CLINGON.OPTIONS:OPTION-BOOLEAN-TRUE short=NIL long=bash-completions&amp;gt; #&amp;lt;CLINGON.OPTIONS:OPTION-BOOLEAN-TRUE short=NIL long=version&amp;gt; #&amp;lt;CLINGON.OPTIONS:OPTION-BOOLEAN-TRUE short=NIL long=help&amp;gt; #&amp;lt;CLINGON.OPTIONS:OPTION-COUNTER short=v long=verbose&amp;gt; #&amp;lt;CLINGON.OPTIONS::OPTION-STRING short=u long=user&amp;gt;) [ ] PARENT = NIL [ ] SUB-COMMANDS = NIL [ ] USAGE = &#34;[-v] [-u &#xA; &lt;user&gt;&#xA;  ]&#34; [ ] VERSION = &#34;0.1.0&#34;&#xA; &lt;/user&gt;&lt;/p&gt; &#xA;&lt;p&gt;[set value] [make unbound] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You might also notice that besides the options we&#39;ve defined ourselves, there are few additional options, that we haven&#39;t defined at all.&lt;/p&gt; &#xA;&lt;p&gt;These options are automatically added by =clingon= itself for each new command and provide flags for =--help=, =--version= and =--bash-completions= for you automatically, so you don&#39;t have to deal with them manually.&lt;/p&gt; &#xA;&lt;p&gt;Before we dive into testing out our application, first we will check that we have a correct help information for our command.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp INTRO&amp;gt; (clingon:print-usage &lt;em&gt;app&lt;/em&gt; t) NAME: clingon-intro - my first clingon cli app&lt;/p&gt; &#xA;&lt;p&gt;USAGE: clingon-intro [-v] [-u &#xA; &lt;user&gt;&#xA;  ]&#xA; &lt;/user&gt;&lt;/p&gt; &#xA;&lt;p&gt;OPTIONS: --help display usage information and exit --version display version and exit -u, --user &#xA; &lt;value&gt;&#xA;   user to greet [default: stranger] [env: $USER] -v, --verbose verbosity level [default: 0]&#xA; &lt;/value&gt;&lt;/p&gt; &#xA;&lt;p&gt;AUTHORS: John Doe &lt;a href=&#34;mailto:john.doe@example.com&#34;&gt;john.doe@example.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;LICENSE: BSD 2-Clause&lt;/p&gt; &#xA;&lt;p&gt;NIL #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This help information will make it easier for our users, when they need to use it. And that is automatically handled for you, so you don&#39;t have to manually maintain an up-to-date usage information, each time you introduce a new option.&lt;/p&gt; &#xA;&lt;p&gt;Time to test out our application on the REPL. In order to test things out you can use the =CLINGON:PARSE-COMMAND-LINE= function by passing it an instance of your command, along with any arguments that need to be parsed. Let&#39;s try it out without any command-line arguments.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp INTRO&amp;gt; (clingon:parse-command-line &lt;em&gt;app&lt;/em&gt; nil) #&amp;lt;CLINGON.COMMAND:COMMAND name=clingon-intro options=5 sub-commands=0&amp;gt; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =CLINGON:PARSE-COMMAND-LINE= function will (as the name suggests) parse the given arguments against the options associated with our command. Finally it will return an instance of =CLINGON:COMMAND=.&lt;/p&gt; &#xA;&lt;p&gt;In our simple CLI application, that would be the same instance as our =&lt;em&gt;APP&lt;/em&gt;=, but things look differently when we have sub-commands.&lt;/p&gt; &#xA;&lt;p&gt;When we start adding new sub-commands, the result of =CLINGON:PARSE-COMMAND-LINE= will be different based on the arguments it needs to parse. That means that if our input matches a sub-command you will receive an instance of the sub-command that matched the given arguments.&lt;/p&gt; &#xA;&lt;p&gt;Internally the =clingon= system maintains a tree data structure, describing the relationships between commands. This allows a command to be related to some other command, and this is how the command and sub-commands support is implemented in =clingon=.&lt;/p&gt; &#xA;&lt;p&gt;Each command in =clingon= is associated with a /context/. The /context/ or /environment/ provides the options and their values with respect to the command itself. This means that a parent command and a sub-command may have exactly the same set of options defined, but they will reside in different contexts. Depending on how you use it, sub-commands may /shadow/ a parent command option, but it also means that a sub-command can refer to an option defined in a global command.&lt;/p&gt; &#xA;&lt;p&gt;The /context/ of a command in =clingon= is available via the =CLINGON:COMMAND-CONTEXT= accessor. We will use the context in order to lookup our options and the values associated with them.&lt;/p&gt; &#xA;&lt;p&gt;The function that operates on command&#39;s context and retrieves values from it is called =CLINGON:GETOPT=.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s see what we&#39;ve got for our options.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp INTRO&amp;gt; (let ((c (clingon:parse-command-line &lt;em&gt;app&lt;/em&gt; nil))) (clingon:getopt c :user)) &#34;dnaeon&#34; T #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =CLINGON:GETOPT= function returns multiple values -- first one specifies the value of the option, if it had any, the second one indicates whether or not that option has been set at all on the command-line, and the third value is the command which provided the value for the option, if set.&lt;/p&gt; &#xA;&lt;p&gt;If you need to simply test things out and tell whether an option has been set at all you can use the =CLINGON:OPT-IS-SET-P= function instead.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s try it out with a different input.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp INTRO&amp;gt; (let ((c (clingon:parse-command-line &lt;em&gt;app&lt;/em&gt; (list &#34;-vvv&#34; &#34;--user&#34; &#34;foo&#34;)))) (format t &#34;Verbose is &lt;del&gt;A&lt;/del&gt;%&#34; (clingon:getopt c :verbose)) (format t &#34;User is &lt;del&gt;A&lt;/del&gt;%&#34; (clingon:getopt c :user))) Verbose is 3 User is foo #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Something else, which is important to mention here. The default precedence list for options is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The value provided by the =:INITIAL-VALUE= initarg&lt;/li&gt; &#xA; &lt;li&gt;The value of the first environment variable, which successfully resolved, provided by the =:ENV-VARS= initarg&lt;/li&gt; &#xA; &lt;li&gt;The value provided on the command-line when invoking the application.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Play with it using different command-line arguments. If you specify invalid or unknown options =clingon= will signal a condition and provide you a few recovery options. For example, if you specify an invalid flag like this:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp INTRO&amp;gt; (clingon:parse-command-line &lt;em&gt;app&lt;/em&gt; (list &#34;--invalid-flag&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;We will be dropped into the debugger and be provided with restarts we can choose from, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp Unknown option --invalid-flag of kind LONG [Condition of type CLINGON.CONDITIONS:UNKNOWN-OPTION]&lt;/p&gt; &#xA;&lt;p&gt;Restarts: 0: [DISCARD-OPTION] Discard the unknown option 1: [TREAT-AS-ARGUMENT] Treat the unknown option as a free argument 2: [SUPPLY-NEW-VALUE] Supply a new value to be parsed 3: [RETRY] Retry SLY mREPL evaluation request. 4: [ABORT] Return to sly-db level 1. 5: [RETRY] Retry SLY mREPL evaluation request. --more-- ... #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This is similar to the way other Common Lisp options parsing systems behave such as [[https://github.com/sjl/adopt][adopt]] and [[https://github.com/libre-man/unix-opts][unix-opts]].&lt;/p&gt; &#xA;&lt;p&gt;Also worth mentioning again here is that =CLINGON:PARSE-COMMAND-LINE= is meant to be used within the REPL, and not called directly by handlers.&lt;/p&gt; &#xA;&lt;p&gt;** Adding a sub-command&lt;/p&gt; &#xA;&lt;p&gt;Sub-commands are no different than regular commands, and in fact are created exactly the way we did it for our /top-level/ command.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun shout/handler (cmd) &#34;The handler for the `shout&#39; command&#34; (let ((args (mapcar #&#39;string-upcase (clingon:command-arguments cmd))) (user (clingon:getopt cmd :user))) ;; &amp;lt;- a global option (format t &#34;HEY, &lt;del&gt;A!&lt;/del&gt;%&#34; user) (format t &#34;&lt;del&gt;A!&lt;/del&gt;%&#34; (clingon:join-list args #\Space))))&lt;/p&gt; &#xA;&lt;p&gt;(defun shout/command () &#34;Returns a command which SHOUTS back anything we write on the command-line&#34; (clingon:make-command :name &#34;shout&#34; :description &#34;shouts back anything you write&#34; :usage &#34;[options] [arguments ...]&#34; :handler #&#39;shout/handler)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;And now, we will wire up our sub-command making it part of the /top-level/ command we have so far.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun top-level/command () &#34;Creates and returns the top-level command&#34; (clingon:make-command :name &#34;clingon-intro&#34; ... :sub-commands (list (shout/command)))) ;; &amp;lt;- new code #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You should also notice here that within the =SHOUT/HANDLER= we are actually referencing an option, which is defined somewhere else. This option is actually defined on our top-level command, but thanks&#39;s to the automatic management of relationships that =clingon= provides we can now refer to global options as well.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s move on to the final section of this guide, where we will create a system definition for our application and build it.&lt;/p&gt; &#xA;&lt;p&gt;** Packaging it up&lt;/p&gt; &#xA;&lt;p&gt;One final piece which remains to be added to our code is to provide an entrypoint for our application, so let&#39;s do it now.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun main () (let ((app (top-level/command))) (clingon:run app))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This is the entrypoint which will be used when we invoke our application on the command-line, which we&#39;ll set in our ASDF definition.&lt;/p&gt; &#xA;&lt;p&gt;And here&#39;s a simple system definition for the application we&#39;ve developed so far.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defpackage :clingon-intro-system (:use :cl :asdf)) (in-package :clingon-intro-system)&lt;/p&gt; &#xA;&lt;p&gt;(defsystem &#34;clingon.intro&#34; :name &#34;clingon.intro&#34; :long-name &#34;clingon.intro&#34; :description &#34;An introduction to the clingon system&#34; :version &#34;0.1.0&#34; :author &#34;John Doe &lt;a href=&#34;mailto:john.doe@example.org&#34;&gt;john.doe@example.org&lt;/a&gt;&#34; :license &#34;BSD 2-Clause&#34; :depends-on (:clingon) :components ((:module &#34;intro&#34; :pathname #P&#34;examples/intro/&#34; :components ((:file &#34;intro&#34;)))) :build-operation &#34;program-op&#34; :build-pathname &#34;clingon-intro&#34; :entry-point &#34;clingon.intro:main&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Now we can build our application and start using it on the command-line.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell sbcl --eval &#39;(ql:quickload :clingon.intro)&#39; &lt;br&gt; --eval &#39;(asdf:make :clingon.intro)&#39; &lt;br&gt; --eval &#39;(quit)&#39; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This will produce a new binary called =clingon-intro= in the directory of the =clingon.intro= system.&lt;/p&gt; &#xA;&lt;p&gt;** Testing it out on the command-line&lt;/p&gt; &#xA;&lt;p&gt;Time to check things up on the command-line.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ ./clingon-intro --help NAME: clingon-intro - my first clingon cli app&lt;/p&gt; &#xA;&lt;p&gt;USAGE: clingon-intro [-v] [-u &#xA; &lt;user&gt;&#xA;  ]&#xA; &lt;/user&gt;&lt;/p&gt; &#xA;&lt;p&gt;OPTIONS: --help display usage information and exit --version display version and exit -u, --user &#xA; &lt;value&gt;&#xA;   user to greet [default: stranger] [env: $USER] -v, --verbose verbosity level [default: 0]&#xA; &lt;/value&gt;&lt;/p&gt; &#xA;&lt;p&gt;COMMANDS: shout shouts back anything you write&lt;/p&gt; &#xA;&lt;p&gt;AUTHORS: John Doe &lt;a href=&#34;mailto:john.doe@example.com&#34;&gt;john.doe@example.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;LICENSE: BSD 2-Clause #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s try out our commands.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ ./clingon-intro -vvv --user Lisper Hello, Lisper! The current verbosity level is set to 3 You have provided 0 arguments Bye. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;And let&#39;s try our sub-command as well.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ ./clingon-intro --user stranger shout why are yelling at me? HEY, stranger! WHY ARE YELLING AT ME?! #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can find the full code we&#39;ve developed in this guide in the [[https://github.com/dnaeon/clingon/tree/master/examples][clingon/examples]] directory of the repo.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Exiting&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When a command needs to exit with a given status code you can use the =CLINGON:EXIT= function.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Handling SIGINT (CTRL-C) signals&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=clingon= by default will provide a handler for =SIGINT= signals, which when detected will cause the application to immediately exit with status code =130=.&lt;/p&gt; &#xA;&lt;p&gt;If your commands need to provide some cleanup logic as part of their job, e.g. close out all open files, TCP session, etc., you could wrap your =clingon= command handlers in [[http://www.lispworks.com/documentation/HyperSpec/Body/s_unwind.htm][UNWIND-PROTECT]] to make sure that your cleanup tasks are always executed.&lt;/p&gt; &#xA;&lt;p&gt;However, using [[http://www.lispworks.com/documentation/HyperSpec/Body/s_unwind.htm][UNWIND-PROTECT]] may not be appropriate in all cases, since the cleanup forms will always be executed, which may or may not be what you need.&lt;/p&gt; &#xA;&lt;p&gt;For example if you are developing a =clingon= application, which populates a database in a transaction you would want to use [[http://www.lispworks.com/documentation/HyperSpec/Body/s_unwind.htm][UNWIND-PROTECT]], but only for releasing the database connection itself.&lt;/p&gt; &#xA;&lt;p&gt;If the application is interrupted while it inserts or updates records, what you want to do is to rollback the transaction as well, so your database is left in a consistent state.&lt;/p&gt; &#xA;&lt;p&gt;In those situations you would want to use the [[https://github.com/compufox/with-user-abort][WITH-USER-ABORT]] system, so that your =clingon= command can detect the =SIGINT= signal and act upon it, e.g. taking care of rolling back the transaction.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Generating Documentation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=clingon= can generate documentation for your application by using the =CLINGON:PRINT-DOCUMENTATION= generic function.&lt;/p&gt; &#xA;&lt;p&gt;Currently the documentation generator supports only the /Markdown/ format, but other formats can be developed as separate extensions to =clingon=.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how you can generate the Markdown documentation for the =clingon-demo= application from the REPL.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (ql:quickload :clingon.demo) CL-USER&amp;gt; (in-package :clingon.demo) DEMO&amp;gt; (with-open-file (out #P&#34;clingon-demo.md&#34; :direction :output) (clingon:print-documentation :markdown (top-level/command) out)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can also create a simple command, which can be added to your =clingon= apps and have it generate the documentation for you, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun print-doc/command () &#34;Returns a command which will print the app&#39;s documentation&#34; (clingon:make-command :name &#34;print-doc&#34; :description &#34;print the documentation&#34; :usage &#34;&#34; :handler (lambda (cmd) ;; Print the documentation starting from the parent ;; command, so we can traverse all sub-commands in the ;; tree. (clingon:print-documentation :markdown (clingon:command-parent cmd) t)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Above command can be wired up anywhere in your application.&lt;/p&gt; &#xA;&lt;p&gt;Make sure to also check the =clingon-demo= app, which provides a =print-doc= sub-command, which operates on the /top-level/ command and generates the documentation for all sub-commands.&lt;/p&gt; &#xA;&lt;p&gt;You can also find the generated documentation for the =clingon-demo= app in the =docs/= directory of the =clingon= repo.&lt;/p&gt; &#xA;&lt;p&gt;** Generate tree representation of your commands in Dot&lt;/p&gt; &#xA;&lt;p&gt;Using =CLINGON:PRINT-DOCUMENTATION= you can also generate the tree representation of your commands in [[https://en.wikipedia.org/wiki/DOT_(graph_description_language)][Dot]] format.&lt;/p&gt; &#xA;&lt;p&gt;Make sure to check the =clingon.demo= system and the provided =clingon-demo= app, which provides an example command for generating the Dot representation.&lt;/p&gt; &#xA;&lt;p&gt;The example below shows the generation of the Dot representation for the =clingon-demo= command.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;clingon-demo dot digraph G { node [color=lightblue fillcolor=lightblue fontcolor=black shape=record style=&#34;filled, rounded&#34;]; &#34;clingon-demo&#34; -&amp;gt; &#34;greet&#34;; &#34;clingon-demo&#34; -&amp;gt; &#34;logging&#34;; &#34;logging&#34; -&amp;gt; &#34;enable&#34;; &#34;logging&#34; -&amp;gt; &#34;disable&#34;; &#34;clingon-demo&#34; -&amp;gt; &#34;math&#34;; &#34;clingon-demo&#34; -&amp;gt; &#34;echo&#34;; &#34;clingon-demo&#34; -&amp;gt; &#34;engine&#34;; &#34;clingon-demo&#34; -&amp;gt; &#34;print-doc&#34;; &#34;clingon-demo&#34; -&amp;gt; &#34;sleep&#34;; &#34;clingon-demo&#34; -&amp;gt; &#34;zsh-completion&#34;; &#34;clingon-demo&#34; -&amp;gt; &#34;dot&#34;; } #+end_src&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We can generate the resulting graph using [[https://graphviz.org/][graphviz]].&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;clingon-demo dot &amp;gt; clingon-demo.dot dot -Tpng clingon-demo.dot &amp;gt; clingon-demo-tree.png #+end_src&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This is what the resulting tree looks like.&lt;/p&gt; &#xA;&lt;p&gt;[[./images/clingon-demo-tree.png]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Command Hooks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=clingon= allows you to associate =pre= and =post= hooks with a command.&lt;/p&gt; &#xA;&lt;p&gt;The =pre= and =post= hooks are functions which will be invoked before and after the respective command handler is executed. They are useful in cases when you need to set up or tear things down before executing the command&#39;s handler.&lt;/p&gt; &#xA;&lt;p&gt;An example of a =pre-hook= might be to configure the logging level of your application based on the value of a global flag. A =post-hook= might be responsible for shutting down any active connections, etc.&lt;/p&gt; &#xA;&lt;p&gt;The =pre-hook= and =post-hook= functions accept a single argument, which is an instance of =CLINGON:COMMAND=. That way the hooks can examine the command&#39;s context and lookup any flags or options.&lt;/p&gt; &#xA;&lt;p&gt;Hooks are also hierachical in the sense that they will be executed based on the command&#39;s lineage.&lt;/p&gt; &#xA;&lt;p&gt;Consider the following example, where we have a CLI app with three commands.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src text main -&amp;gt; foo -&amp;gt; bar #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In above example the =bar= command is a sub-command of =foo=, which in turn is a sub-command of =main=. Also, consider that we have added pre- and post-hooks to each command.&lt;/p&gt; &#xA;&lt;p&gt;If a user executed the following on the command-line:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ main foo bar #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Based on the above command-line =clingon= would do the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Execute any =pre-hook= functions starting from the least-specific up to the most-specific node from the commands&#39; lineage&lt;/li&gt; &#xA; &lt;li&gt;Execute the command&#39;s handler&lt;/li&gt; &#xA; &lt;li&gt;Execute any =post-hook= functions starting from the most-specific down to the least-specific node from the command&#39;s lineage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In above example that would be:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src text&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;main (pre-hook)&lt;/p&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;foo (pre-hook)&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;bar (pre-hook)&lt;/p&gt; &#xA;   &lt;blockquote&gt; &#xA;    &lt;p&gt;bar (handler) bar (post-hook) foo (post-hook) main (post-hook) #+end_src&lt;/p&gt; &#xA;   &lt;/blockquote&gt; &#xA;  &lt;/blockquote&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Associating hooks with commands is done during instantiation of a command. The following example creates a new command with a =pre-hook= and =post-hook=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun foo/pre-hook (cmd) &#34;The pre-hook for `foo&#39; command&#34; (declare (ignore cmd)) (format t &#34;foo pre-hook has been invoked~&amp;amp;&#34;))&lt;/p&gt; &#xA;&lt;p&gt;(defun foo/post-hook (cmd) &#34;The post-hook for `foo&#39; command&#34; (declare (ignore cmd)) (format t &#34;foo post-hook has been invoked~&amp;amp;&#34;))&lt;/p&gt; &#xA;&lt;p&gt;(defun foo/handler (cmd) (declare (ignore cmd)) (format t &#34;foo handler has been invoked~&amp;amp;&#34;))&lt;/p&gt; &#xA;&lt;p&gt;(defun foo/command () &#34;Returns the `foo&#39; command&#34; (clingon:make-command :name &#34;foo&#34; :description &#34;the foo command&#34; :authors &#39;(&#34;John Doe &lt;a href=&#34;mailto:john.doe@example.org&#34;&gt;john.doe@example.org&lt;/a&gt;&#34;) :handler #&#39;foo/handler :pre-hook #&#39;foo/pre-hook :post-hook #&#39;foo/post-hook :options nil :sub-commands nil)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If we have executed above command we would see the following output.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell foo pre-hook has been invoked foo handler has been invoked foo post-hook has been invoked #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Options&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The =clingon= system supports various kinds of options, each of which is meant to serve a specific purpose.&lt;/p&gt; &#xA;&lt;p&gt;Each builtin option can be initialized via environment variables, and new mechanisms for initializing options can be developed, if needed.&lt;/p&gt; &#xA;&lt;p&gt;Options are created via the single =CLINGON:MAKE-OPTION= interface.&lt;/p&gt; &#xA;&lt;p&gt;The supported option kinds include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=counter=&lt;/li&gt; &#xA; &lt;li&gt;=integer=&lt;/li&gt; &#xA; &lt;li&gt;=string=&lt;/li&gt; &#xA; &lt;li&gt;=boolean=&lt;/li&gt; &#xA; &lt;li&gt;=boolean/true=&lt;/li&gt; &#xA; &lt;li&gt;=boolean/false=&lt;/li&gt; &#xA; &lt;li&gt;=flag=&lt;/li&gt; &#xA; &lt;li&gt;=choice=&lt;/li&gt; &#xA; &lt;li&gt;=enum=&lt;/li&gt; &#xA; &lt;li&gt;=list=&lt;/li&gt; &#xA; &lt;li&gt;=list/integer=&lt;/li&gt; &#xA; &lt;li&gt;=filepath=&lt;/li&gt; &#xA; &lt;li&gt;=list/filepath=&lt;/li&gt; &#xA; &lt;li&gt;=switch=&lt;/li&gt; &#xA; &lt;li&gt;etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Counters Options&lt;/p&gt; &#xA;&lt;p&gt;A =counter= is an option kind, which increments every time it is set on the command-line.&lt;/p&gt; &#xA;&lt;p&gt;A good example for =counter= options is to provide a flag, which increases the verbosity level, depending on the number of times the flag was provided, similar to the way =ssh(1)= does it, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell ssh -vvv user@host #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of creating a =counter= option.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :counter :short-name #\v :long-name &#34;verbose&#34; :description &#34;how noisy we want to be&#34; :key :verbose) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The default =step= for counters is set to =1=, but you can change that, if needed.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :counter :short-name #\v :long-name &#34;verbose&#34; :description &#34;how noisy we want to be&#34; :step 42 :key :verbose) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Boolean Options&lt;/p&gt; &#xA;&lt;p&gt;The following boolean option kinds are supported by =clingon=.&lt;/p&gt; &#xA;&lt;p&gt;The =:boolean= kind is an option which expects an argument, which represents a boolean value.&lt;/p&gt; &#xA;&lt;p&gt;Arguments =true= and =1= map to =T= in Lisp, anything else is considered a falsey value and maps to =NIL=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :boolean :description &#34;my boolean&#34; :short-name #\b :long-name &#34;my-boolean&#34; :key :boolean) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;This creates an option =-b, --my-boolean &#xA; &lt;value&gt;&#xA;  =, which can be provided on the command-line, where =&#xA;  &lt;value&gt;&#xA;   = should be =true= or =1= for truthy values, and anything else maps to =NIL=.&#xA;  &lt;/value&gt;&#xA; &lt;/value&gt;&lt;/p&gt; &#xA;&lt;p&gt;The =:boolean/true= option kind creates a flag, which always returns =T=.&lt;/p&gt; &#xA;&lt;p&gt;The =:boolean/false= option kind creates a flag, which always returns =NIL=.&lt;/p&gt; &#xA;&lt;p&gt;The =:flag= option kind is an alias for =:boolean/true=.&lt;/p&gt; &#xA;&lt;p&gt;** Integer Options&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of creating an option, which expects an integer argument.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :integer :description &#34;my integer opt&#34; :short-name #\i :long-name &#34;int&#34; :key :my-int :initial-value 42) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Choice Options&lt;/p&gt; &#xA;&lt;p&gt;=choice= options are useful when you have to limit the arguments provided on the command-line to a specific set of values.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :choice :description &#34;log level&#34; :short-name #\l :long-name &#34;log-level&#34; :key :choice :items &#39;(&#34;info&#34; &#34;warn&#34; &#34;error&#34; &#34;debug&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;With this option defined, you can now set the logging level only to =info=, =warn=, =error= or =debug=, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell -l, --log-level [info|warn|error|debug] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Enum Options&lt;/p&gt; &#xA;&lt;p&gt;Enum options are similar to the =choice= options, but instead of returning the value itself they can be mapped to something else.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :enum :description &#34;enum option&#34; :short-name #\e :long-name &#34;my-enum&#34; :key :enum :items &#39;((&#34;one&#34; . 1) (&#34;two&#34; . 2) (&#34;three&#34; . 3))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If a user specifies =--my-enum=one= on the command-line the option will be have the value =1= associated with it, when being looked up via =CLINGON:GETOPT=.&lt;/p&gt; &#xA;&lt;p&gt;The values you associate with the enum variant, can be any object.&lt;/p&gt; &#xA;&lt;p&gt;This is one of the options being used by the /clingon-demo/ application, which maps user input to Lisp functions, in order to perform some basic math operations.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :enum :description &#34;operation to perform&#34; :short-name #\o :long-name &#34;operation&#34; :required t :items `((&#34;add&#34; . ,#&#39;+) (&#34;sub&#34; . ,#&#39;-) (&#34;mul&#34; . ,#&#39;*) (&#34;div&#34; . ,#&#39;/)) :key :math/operation) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** List / Accumulator Options&lt;/p&gt; &#xA;&lt;p&gt;The =:list= option kind accumulates each argument it is given on the command-line into a list.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :list :description &#34;files to process&#34; :short-name #\f :long-name &#34;file&#34; :key :files) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If you invoke an application, which uses a similar option like the one above using the following command-line arguments:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ my-app --file foo --file bar --file baz #+end_src&lt;/p&gt; &#xA;&lt;p&gt;When you retrieve the value associated with your option, you will get a list of all the files specified on the command-line, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:getopt cmd :files) ;; =&amp;gt; &#39;(&#34;foo&#34; &#34;bar&#34; &#34;baz&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;A similar option exists for integer values using the =:list/integer= option, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :list/integer :description &#34;list of integers&#34; :short-name #\l :long-name &#34;int&#34; :key :integers) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Switch Options&lt;/p&gt; &#xA;&lt;p&gt;=:SWITCH= options are a variation of =:BOOLEAN= options with an associated list of known states that can turn a switch /on/ or /off/.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example of a =:SWITCH= option.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :switch :description &#34;my switch option&#34; :short-name #\s :long-name &#34;state&#34; :key :switch) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The default states for a switch to be considered as /on/ are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;/on/, /yes/, /true/, /enable/ and /1/&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The default states considered to turn the switch /off/ are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;/off/, /no/, /false/, /disable/ and /0/&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can customize the list of /on/ and /off/ states by specifying them using the =:ON-STATES= and =:OFF-STATES= initargs, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (clingon:make-option :switch :description &#34;engine switch option&#34; :short-name #\s :long-name &#34;state&#34; :on-states &#39;(&#34;start&#34;) :off-states &#39;(&#34;stop&#34;) :key :engine) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;These sample command-line arguments will turn a switch on and off.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell my-app --engine=start --engine=stop #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The final value of the =:engine= option will be =NIL= in the above example.&lt;/p&gt; &#xA;&lt;p&gt;** Persistent Options&lt;/p&gt; &#xA;&lt;p&gt;An option may be marked as /persistent/. A /persistent/ option is such an option, which will be propagated from a parent command to all sub-commands associated with it.&lt;/p&gt; &#xA;&lt;p&gt;This is useful when you need to provide the same option across sub-commands.&lt;/p&gt; &#xA;&lt;p&gt;The following example creates one top-level command (=demo= in the example), which has two sub-commands (=foo= and =bar= commands). The =foo= command has a single sub-command, =qux= in the following example.&lt;/p&gt; &#xA;&lt;p&gt;The =top-level= command has a single option (=persistent-opt= in the example), which is marked as /persistent/.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell (defun qux/command () &#34;Returns the `qux&#39; command&#34; (clingon:make-command :name &#34;qux&#34; :description &#34;the qux command&#34; :handler (lambda (cmd) (declare (ignore cmd)) (format t &#34;qux has been invoked&#34;))))&lt;/p&gt; &#xA;&lt;p&gt;(defun foo/command () &#34;Returns the `foo&#39; command&#34; (clingon:make-command :name &#34;foo&#34; :description &#34;the foo command&#34; :sub-commands (list (qux/command)) :handler (lambda (cmd) (declare (ignore cmd)) (format t &#34;foo has been invoked&#34;))))&lt;/p&gt; &#xA;&lt;p&gt;(defun bar/command () &#34;Returns the `bar&#39; command&#34; (clingon:make-command :name &#34;bar&#34; :description &#34;the bar command&#34; :handler (lambda (cmd) (declare (ignore cmd)) (format t &#34;bar has been invoked&#34;))))&lt;/p&gt; &#xA;&lt;p&gt;(defun top-level/command () &#34;Returns the top-level command&#34; (clingon:make-command :name &#34;demo&#34; :description &#34;the demo app&#34; :options (list (clingon:make-option :string :long-name &#34;persistent-opt&#34; :description &#34;an example persistent option&#34; :persistent t :key :persistent-opt)) :sub-commands (list (foo/command) (bar/command)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Since the option is marked as persistent and is associated with the top-level command, it will be inherited by all sub-commands.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Generic Functions Operating on Options&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If the existing options provided by =clingon= are not enough for you, and you need something a bit more specific for your use case, then you can always implement a new option kind.&lt;/p&gt; &#xA;&lt;p&gt;The following generic functions operate on options and are exported by the =clingon= system.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=CLINGON:INITILIAZE-OPTION=&lt;/li&gt; &#xA; &lt;li&gt;=CLINGON:FINALIZE-OPTION=&lt;/li&gt; &#xA; &lt;li&gt;=CLINGON:DERIVE-OPTION-VALUE=&lt;/li&gt; &#xA; &lt;li&gt;=CLINGON:OPTION-USAGE-DETAILS=&lt;/li&gt; &#xA; &lt;li&gt;=CLINGON:OPTION-DESCRIPTION-DETAILS=&lt;/li&gt; &#xA; &lt;li&gt;=CLINGON:MAKE-OPTION=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;New option kinds should inherit from the =CLINGON:OPTION= class, which implements all of the above generic functions. If you need to customize the behaviour of your new option, you can still override the default implementations.&lt;/p&gt; &#xA;&lt;p&gt;** CLINGON:INITIALIZE-OPTION&lt;/p&gt; &#xA;&lt;p&gt;The =CLINGON:INITIALIZE-OPTION= as the name suggests is being used to initialize an option.&lt;/p&gt; &#xA;&lt;p&gt;The default implementation of this generic function supports initialization from environment variables, but implementors can choose to support other initialization methods, e.g. be able to initialize an option from a key/value store like /Redis/, /Consul/ or /etcd/ for example.&lt;/p&gt; &#xA;&lt;p&gt;** CLINGON:FINALIZE-OPTION&lt;/p&gt; &#xA;&lt;p&gt;The =CLINGON:FINALIZE-OPTION= generic function is called after all command-line arguments have been processed and values for them have been derived already.&lt;/p&gt; &#xA;&lt;p&gt;=CLINGON:FINALIZE-OPTION= is meant to /finalize/ the option&#39;s value, e.g. transform it to another object, if needed.&lt;/p&gt; &#xA;&lt;p&gt;For example the =:BOOLEAN= option kind transforms user-provided input like =true=, =false=, =1= and =0= into their respective Lisp counterparts like =T= and =NIL=.&lt;/p&gt; &#xA;&lt;p&gt;Another example where you might want to customize the behaviour of =CLINGON:FINALIZE-OPTION= is to convert a string option provided on the command-line, which represents a database connection string into an actual session object for the database.&lt;/p&gt; &#xA;&lt;p&gt;The default implementation of this generic function simply returns the already set value, e.g. calls =#&#39;IDENTITY= on the last derived value.&lt;/p&gt; &#xA;&lt;p&gt;** CLINGON:DERIVE-OPTION-VALUE&lt;/p&gt; &#xA;&lt;p&gt;The =CLINGON:DERIVE-OPTION-VALUE= is called whenever an option is provided on the command-line.&lt;/p&gt; &#xA;&lt;p&gt;If that option accepts an argument, it will be passed the respective value from the command-line, otherwise it will be called with a =NIL= argument.&lt;/p&gt; &#xA;&lt;p&gt;Responsibility of the option is to derive a value from the given input and return it to the caller. The returned value will be set by the parser and later on it will be used to produce a final value, by calling the =CLINGON:FINALIZE-OPTION= generic function.&lt;/p&gt; &#xA;&lt;p&gt;Different kinds of options implement this one different -- for example the =:LIST= option kind accumulates each given argument, while others ignore any previously derived values and return the last provided argument.&lt;/p&gt; &#xA;&lt;p&gt;The =:ENUM= option kind for example will derive a value from a pre-defined list of allowed values.&lt;/p&gt; &#xA;&lt;p&gt;If an option fails to derive a value (e.g. invalid value has been provided) the implementation of this generic function should signal a =CLINGON:OPTION-DERIVE-ERROR= condition, so that =clingon= can provide appropriate restarts.&lt;/p&gt; &#xA;&lt;p&gt;** CLINGON:OPTION-USAGE-DETAILS&lt;/p&gt; &#xA;&lt;p&gt;This generic function is used to provide a pretty-printed usage format for the given option. It will be used when printing usage information on the command-line for the respective commands.&lt;/p&gt; &#xA;&lt;p&gt;** CLINGON:OPTION-DESCRIPTION-DETAILS&lt;/p&gt; &#xA;&lt;p&gt;This generic function is meant to enrich the description of the option by providing as much details as possible for the given option, e.g. listing the available values that an option can accept.&lt;/p&gt; &#xA;&lt;p&gt;** CLINGON:MAKE-OPTION&lt;/p&gt; &#xA;&lt;p&gt;The =CLINGON:MAKE-OPTION= generic function is the primary way for creating new options. Implementors of new option kinds should simply provide an implementation of this generic function, along with the respective option kind.&lt;/p&gt; &#xA;&lt;p&gt;Additional option kinds may be implemented as separate sub-systems, but still follow the same principle by providing a single and consistent interface for option creation.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Developing New Options&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This section contains short guides explaining how to develop new options for =clingon=.&lt;/p&gt; &#xA;&lt;p&gt;** Developing an Email Option&lt;/p&gt; &#xA;&lt;p&gt;The option which we&#39;ll develop in this section will be used for specifying email addresses.&lt;/p&gt; &#xA;&lt;p&gt;Start up your Lisp REPL session and do let&#39;s some work. Load the =:clingon= and =:cl-ppcre= systems, since we will need them.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (ql:quickload :clingon) CL-USER&amp;gt; (ql:quickload :cl-ppcre) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;We will first create a new package for our extension and import the symbols we will need from the =:clingon= and =:cl-ppcre= systems.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defpackage :clingon.extensions/option-email (:use :cl) (:import-from :cl-ppcre :scan) (:import-from :clingon :option :initialize-option :derive-option-value :make-option :option-value :option-derive-error) (:export :option-email)) (in-package :clingon.extensions/option-email) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Then lets define the class, which will represent an email address option.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defclass option-email (option) ((pattern :initarg :pattern :initform &#34;^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+$&#34; :reader option-email-pattern :documentation &#34;Pattern used to match for valid email addresses&#34;)) (:default-initargs :parameter &#34;EMAIL&#34;) (:documentation &#34;An option used to represent an email address&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Now we will implement =CLINGON:INITIALIZE-OPTION= for our new option. We will keep the default initialization logic as-is, but also add an additional step to validate the email address, if we have any initial value at all.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defmethod initialize-option ((option option-email) &amp;amp;key) &#34;Initializes our new email address option&#34; ;; Make sure to invoke our parent initialization method first, so ;; various things like setting up initial value from environment ;; variables can still be applied. (call-next-method)&lt;/p&gt; &#xA;&lt;p&gt;;; If we don&#39;t have any value set, there&#39;s nothing else to ;; initialize further here. (unless (option-value option) (return-from initialize-option))&lt;/p&gt; &#xA;&lt;p&gt;;; If we get to this point, that means we&#39;ve got some initial value, ;; which is either set as a default, or via environment ;; variables. Next thing we need to do is make sure we&#39;ve got a good ;; initial value, so let&#39;s derive a value from it. (let ((current (option-value option))) (setf (option-value option) (derive-option-value option current)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Next we will implement =CLINGON:DERIVE-OPTION-VALUE= for our new option kind.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defmethod derive-option-value ((option option-email) arg &amp;amp;key) &#34;Derives a new value based on the given argument. If the given ARG represents a valid email address according to the pattern we know of we consider this as a valid email address.&#34; (unless (scan (option-email-pattern option) arg) (error &#39;option-derive-error :reason (format nil &#34;~A is not a valid email address&#34; arg))) arg) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Finally, lets register our new option as a valid kind by implemeting the =CLINGON:MAKE-OPTION= generic function.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defmethod make-option ((kind (eql :email)) &amp;amp;rest rest) (apply #&#39;make-instance &#39;option-email rest)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;We can test things out now. Go back to your REPL and try these expressions out. First we make a new instance of our new option.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defparameter &lt;em&gt;opt&lt;/em&gt; (make-option :email :short-name #\e :description &#34;email opt&#34; :key :email)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;And now, lets validate a couple of good email addresses.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp EXTENSIONS/OPTION-EMAIL&amp;gt; (derive-option-value &lt;em&gt;opt&lt;/em&gt; &#34;&lt;a href=&#34;mailto:test@example.com&#34;&gt;test@example.com&lt;/a&gt;&#34;) &#34;&lt;a href=&#34;mailto:test@example.com&#34;&gt;test@example.com&lt;/a&gt;&#34; EXTENSIONS/OPTION-EMAIL&amp;gt; (derive-option-value &lt;em&gt;opt&lt;/em&gt; &#34;&lt;a href=&#34;mailto:foo@bar.com&#34;&gt;foo@bar.com&lt;/a&gt;&#34;) &#34;&lt;a href=&#34;mailto:foo@bar.com&#34;&gt;foo@bar.com&lt;/a&gt;&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;If we try deriving a value from a bad email address we will have a condition of type =CLINGON:OPTION-DERIVE-ERROR= signalled.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp EXTENSIONS/OPTION-EMAIL&amp;gt; (derive-option-value opt &#34;bad-email-address-here&#34;) ; Debugger entered on #&amp;lt;OPTION-DERIVE-ERROR {1002946463}&amp;gt; ... bad-email-address-here is not a valid email address [Condition of type OPTION-DERIVE-ERROR] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Good, we can catch invalid email addresses as well. Whenever an option fails to derive a new value from a given argument, and we signal =CLINGON:OPTION-DERIVE-ERROR= condition we can recover by providing new values or discarding them completely, thanks to the Common Lisp Condition System.&lt;/p&gt; &#xA;&lt;p&gt;Last thing to do is actually package this up as an extension system and register it in Quicklisp. That way everyone else can benefit from the newly developed option.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Shell Completions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=clingon= provides support for Bash and Zsh shell completions.&lt;/p&gt; &#xA;&lt;p&gt;** Bash Completions&lt;/p&gt; &#xA;&lt;p&gt;In order to enable the Bash completions for your =clingon= app, follow these instructions.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell APP=app-name source extras/completions.bash #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Make sure to set =APP= to your correct application name.&lt;/p&gt; &#xA;&lt;p&gt;The [[https://github.com/dnaeon/clingon/blob/master/extras/completions.bash][completions.bash]] script will dynamically provide completions by invoking the =clingon= app with the =--bash-completions= flag. This builtin flag when provided on the command-line will return completions for the sub-commands and the available flags.&lt;/p&gt; &#xA;&lt;p&gt;** Zsh Completions&lt;/p&gt; &#xA;&lt;p&gt;When developing your CLI app with =clingon= you can provide an additional command, which will take care of generating the Zsh completion script for your users.&lt;/p&gt; &#xA;&lt;p&gt;The following code can be used in your app and added as a sub-command to your top-level command.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun zsh-completion/command () &#34;Returns a command for generating the Zsh completion script&#34; (clingon:make-command :name &#34;zsh-completion&#34; :description &#34;generate the Zsh completion script&#34; :usage &#34;&#34; :handler (lambda (cmd) ;; Use the parent command when generating the completions, ;; so that we can traverse all sub-commands in the tree. (let ((parent (clingon:command-parent cmd))) (clingon:print-documentation :zsh-completions parent t))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can also check out the =clingon-demo= app for a fully working CLI app with Zsh completions support.&lt;/p&gt; &#xA;&lt;p&gt;[[./images/clingon-zsh-completions.gif]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ideas For Future Improvements&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Additional Documentation Generators&lt;/p&gt; &#xA;&lt;p&gt;As of now =clingon= supports generating documentation only in /Markdown/ format.&lt;/p&gt; &#xA;&lt;p&gt;Would be nice to have additional documentation generators, e.g. /man pages/, /HTML/, etc.&lt;/p&gt; &#xA;&lt;p&gt;** Performance Notes&lt;/p&gt; &#xA;&lt;p&gt;=clingon= has been developed and tested on a GNU/Linux system using SBCL.&lt;/p&gt; &#xA;&lt;p&gt;Performance of the resulting binaries with SBCL seem to be good, although I have noticed better performance when the binaries have been produced with Clozure CL. And by better I mean better in terms of binary size and speed (startup + run time).&lt;/p&gt; &#xA;&lt;p&gt;Although you can enable compression on the image when using SBCL you have to pay the extra price for the startup time.&lt;/p&gt; &#xA;&lt;p&gt;Here are some additional details. Build the =clingon-demo= app with SBCL.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ LISP=sbcl make demo sbcl --eval &#39;(ql:quickload :clingon.demo)&#39; &lt;br&gt; --eval &#39;(asdf:make :clingon.demo)&#39; &lt;br&gt; --eval &#39;(quit)&#39; This is SBCL 2.1.7, an implementation of ANSI Common Lisp. More information about SBCL is available at &lt;a href=&#34;http://www.sbcl.org/&#34;&gt;http://www.sbcl.org/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;SBCL is free software, provided as is, with absolutely no warranty. It is mostly in the public domain; some portions are provided under BSD-style licenses. See the CREDITS and COPYING files in the distribution for more information. To load &#34;clingon.demo&#34;: Load 1 ASDF system: clingon.demo ; Loading &#34;clingon.demo&#34; [package clingon.utils]........................... [package clingon.conditions]...................... [package clingon.options]......................... [package clingon.command]......................... [package clingon]................................. [package clingon.demo] [undoing binding stack and other enclosing state... done] [performing final GC... done] [defragmenting immobile space... (fin,inst,fdefn,code,sym)=1118+969+19070+19610+26536... done] [saving current Lisp image into /home/dnaeon/Projects/lisp/clingon/clingon-demo: writing 0 bytes from the read-only space at 0x50000000 writing 736 bytes from the static space at 0x50100000 writing 31391744 bytes from the dynamic space at 0x1000000000 writing 2072576 bytes from the immobile space at 0x50200000 writing 12341248 bytes from the immobile space at 0x52a00000 done] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Now, build it using Clozure CL.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ LISP=ccl make demo ccl --eval &#39;(ql:quickload :clingon.demo)&#39; &lt;br&gt; --eval &#39;(asdf:make :clingon.demo)&#39; &lt;br&gt; --eval &#39;(quit)&#39; To load &#34;clingon.demo&#34;: Load 1 ASDF system: clingon.demo ; Loading &#34;clingon.demo&#34; [package clingon.utils]........................... [package clingon.conditions]...................... [package clingon.options]......................... [package clingon.command]......................... [package clingon]................................. [package clingon.demo]. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;In terms of file size the binaries produced by Clozure CL are smaller.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ ls -lh clingon-demo* -rwxr-xr-x 1 dnaeon dnaeon 33M Aug 20 12:56 clingon-demo.ccl -rwxr-xr-x 1 dnaeon dnaeon 45M Aug 20 12:55 clingon-demo.sbcl #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Generating the Markdown documentation for the demo app when using the SBCL executable looks like this.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ time ./clingon-demo.sbcl print-doc &amp;gt; /dev/null&lt;/p&gt; &#xA;&lt;p&gt;real 0m0.098s user 0m0.071s sys 0m0.027s #+end_src&lt;/p&gt; &#xA;&lt;p&gt;And when doing the same thing with the executable produced by Clozure CL we see these results.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ time ./clingon-demo.ccl print-doc &amp;gt; /dev/null&lt;/p&gt; &#xA;&lt;p&gt;real 0m0.017s user 0m0.010s sys 0m0.007s #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tests&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The =clingon= tests are provided as part of the =:clingon.test= system.&lt;/p&gt; &#xA;&lt;p&gt;In order to run the tests you can evaluate the following expressions.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (ql:quickload :clingon.test) CL-USER&amp;gt; (asdf:test-system :clingon.test) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Or you can run the tests using the =run-tests.sh= script instead, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell LISP=sbcl ./run-tests.sh #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how to run the tests against SBCL, CCL and ECL for example.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell for lisp in sbcl ccl ecl; do echo &#34;Running tests using ${lisp} ...&#34; LISP=${lisp} make test &amp;gt; ${lisp}-tests.out done #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker Images&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A few Docker images are available.&lt;/p&gt; &#xA;&lt;p&gt;Build and run the tests in a container.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell docker build -t clingon.test:latest -f Dockerfile.tests . docker run --rm clingon.test:latest #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Build and run the =clingon-intro= application.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell docker build -t clingon.intro:latest -f Dockerfile.intro . docker run --rm clingon.intro:latest #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Build and run the =clingon.demo= application.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp docker build -t clingon.demo:latest -f Dockerfile.demo . docker run --rm clingon.demo:latest #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=clingon= is hosted on [[https://github.com/dnaeon/clingon][Github]]. Please contribute by reporting issues, suggesting features or by sending patches using pull requests.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;License&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This project is Open Source and licensed under the [[http://opensource.org/licenses/BSD-2-Clause][BSD License]].&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Authors&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Marin Atanasov Nikolov &lt;a href=&#34;mailto:dnaeon@gmail.com&#34;&gt;dnaeon@gmail.com&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>