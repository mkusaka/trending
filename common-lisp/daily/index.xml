<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-25T01:36:32Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tfeb/dsm</title>
    <updated>2022-07-25T01:36:32Z</updated>
    <id>tag:github.com,2022-07-25:/tfeb/dsm</id>
    <link href="https://github.com/tfeb/dsm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Destructuring match&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Destructuring match&lt;/h1&gt; &#xA;&lt;p&gt;Common Lisp doesn&#39;t have any pattern-matching facilities in the language. A number have been written: &lt;a href=&#34;https://www.cliki.net/pattern%20matching&#34; title=&#34;CLiki pattern matching&#34;&gt;CLiki&lt;/a&gt; has a list: Marco Antoniotti&#39;s &lt;a href=&#34;https://gitlab.common-lisp.net/cl-unification/cl-unification&#34; title=&#34;CL-UNIFICATION&#34;&gt;CL-UNIFICATION&lt;/a&gt; is my favourite, as I used to be interested in unification grammars. Many of these systems are quite general: they seek to be able to match very general objects to be extensible and to have very good performance. This causes inevitable hair in their implementations, and also means that they often make doing something rather simple much harder than it needs to be.&lt;/p&gt; &#xA;&lt;p&gt;That simple thing is to provide a generalised version of &lt;code&gt;destructuring-bind&lt;/code&gt;or, equivalently[^1], macro argument lists. That&#39;s what &lt;code&gt;dsm&lt;/code&gt; does, and that&#39;s &lt;em&gt;all&lt;/em&gt; it does: if you understand &lt;code&gt;destructuring-bind&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; you can pretty much stop reading now: &lt;code&gt;destructuring-match&lt;/code&gt; is pretty much &lt;code&gt;case&lt;/code&gt; except that the cases are lambda lists for &lt;code&gt;destructuring-bind&lt;/code&gt;. &lt;code&gt;dsm&lt;/code&gt; cares about correctness, but does not care about performance as the performance of macroexpansion never matters.&lt;/p&gt; &#xA;&lt;h2&gt;An example&lt;/h2&gt; &#xA;&lt;p&gt;As an example, let&#39;s consider a macro where there are a few possible variations on the syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(with-foo x ... use x ...)&#xA;(with-foo (x a) ... use x ...)&#xA;(with-foo (x a b) ... use x ...)&#xA;(with-foo ((x y) a b) ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Well, to write a reasonably error-protected version of this you end up with code like, for instance&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro with-foo (binding &amp;amp;body forms)&#xA;  (typecase binding&#xA;    (symbol&#xA;     ...)&#xA;    (cons&#xA;     (destructuring-bind (thing . more) binding&#xA;       (typecase thing&#xA;         (symbol ...)&#xA;         (cons&#xA;          (unless (= (length thing) 2)&#xA;            (error ...))&#xA;          (destructuring-bind (var opt) thing&#xA;            ...))&#xA;         (t (error ...)))))&#xA;    (t (error ...))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And this is just horrible.&lt;/p&gt; &#xA;&lt;p&gt;This can be improved with, for instance, a system like my &lt;a href=&#34;https://tfeb.github.io/tfeb-lisp-hax/#simple-pattern-matching-spam&#34; title=&#34;spam&#34;&gt;simple pattern matcher, &lt;code&gt;spam&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro with-foo (binding &amp;amp;body forms)&#xA;  (matching binding&#xA;    ((var)&#xA;     ...)&#xA;    ((one-of&#xA;      (list-matches (var) (any))&#xA;      (list-matches (var) (any) (any)))&#xA;     (destructuring-bind (var &amp;amp;optional a1 a2) binding&#xA;       ...))&#xA;    ((one-of&#xA;      (list-matches (list-matches (var) (any)) (any))&#xA;      (list-matches (list-matches (var) (any)) (any) (any)))&#xA;     (destructuring-bind ((var opt) &amp;amp;optional a1 a2) binding&#xA;       ...))&#xA;    (otherwise&#xA;     (error ...))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is a lot better.&lt;/p&gt; &#xA;&lt;p&gt;The underlying problem here is that, before you can use &lt;code&gt;destructuring-bind&lt;/code&gt; you need to wrap numerous guards around it, and this is especially true if you want to allow variations in syntax which don&#39;t match the same lambda list. What would be nice is something that did what &lt;code&gt;destructuring-bind&lt;/code&gt; does, but which could &lt;em&gt;also&lt;/em&gt; try several possibilities. Like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro with-foo (binding &amp;amp;rest forms)&#xA;  (destructuring-match binding&#xA;    (var&#xA;     (:when (symbolp var))&#xA;     ...)&#xA;    ((var &amp;amp;optional a1 a2)&#xA;     (:when (symbolp var))&#xA;     ...)&#xA;    (((var opt) &amp;amp;optional a1 a2)&#xA;     (:when (symbolp var))&#xA;     ...)&#xA;    (otherwise&#xA;     (error ...))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is what &lt;code&gt;dsm&lt;/code&gt; lets you do: it provides a macro, &lt;code&gt;destructuring-match&lt;/code&gt;, which understands lambda lists similar to &lt;code&gt;destructuring-bind&lt;/code&gt;s although slightly extended, except that it also matches against many possible lambda lists, and that matches can have &#39;guard clauses&#39; which allow arbitrary additional tests before a match succeeds.&lt;/p&gt; &#xA;&lt;p&gt;Again,&lt;code&gt;dsm&lt;/code&gt; is not intended as a general-purpose pattern matcher: all it does is allow matching against many possible lambda lists, succeeding on the first match. Guard clauses allow some additional tests before a match succeeds, but that&#39;s it. The best way to understand &lt;code&gt;dsm&lt;/code&gt; is that it&#39;s a &lt;em&gt;tool for writing macros&lt;/em&gt;: it&#39;s not anything more general than that. But as a tool for writing macros it can make your life a &lt;em&gt;lot&lt;/em&gt; easier. It would be relatively simple to implement, on top of &lt;code&gt;destructuring-match&lt;/code&gt;, a pattern-matching macro language like Scheme&#39;s &lt;code&gt;syntax-rules&lt;/code&gt;although without hygiene of course[^2].&lt;/p&gt; &#xA;&lt;h2&gt;The interface&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;dsm&lt;/code&gt; provides a single macro: &lt;code&gt;destructuring-match&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;destructuring-match&lt;/code&gt;&lt;/strong&gt; is a macro which combines something like &lt;code&gt;case&lt;/code&gt; with a slightly extended&lt;code&gt;destructuring-bind&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(destructuring-match &amp;lt;expression&amp;gt;&#xA;  &amp;lt;clause&amp;gt; ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;expression&amp;gt;&lt;/code&gt; is any expression.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;clause&amp;gt;&lt;/code&gt; is one of &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;(&amp;lt;lambda-list&amp;gt; [&amp;lt;guard&amp;gt;] ...)&lt;/code&gt;;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;(otherwise ...)&lt;/code&gt;;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;(t ...)&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;For &lt;code&gt;&amp;lt;lambda-list&amp;gt;&lt;/code&gt; see below.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;guard&amp;gt;&lt;/code&gt; is a form like &lt;code&gt;(&amp;lt;when/unless) expression ...)&lt;/code&gt;, where &lt;code&gt;&amp;lt;when/unless&amp;gt;&lt;/code&gt; is &lt;code&gt;:when&lt;/code&gt; or &lt;code&gt;:unless&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The lambda lists understood by &lt;code&gt;destructuring-match&lt;/code&gt; are[^3] the same as the lambda lists understood by &lt;code&gt;destructuring-bind&lt;/code&gt;, extended in two ways:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;a &#39;lambda list&#39; which is a symbol binds the whole value of the expression, in the same way that &lt;code&gt;(lambda x ...)&lt;/code&gt; does in Scheme;&lt;/li&gt; &#xA; &lt;li&gt;any variable whose name is &lt;code&gt;_&lt;/code&gt;, regardless of package, is a &#39;blank&#39;, and is turned into an anonymous variable which is ignored, with each occurrence of such a variable being distinct.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The guards specified by a guard clause may be repeated, so &lt;code&gt;(:when ... :unless ... :when ...)&lt;/code&gt; is perfectly legal. Guards are evaluated after variables are bound but before the match is committed. If the guards fail the next clause is tried.&lt;/p&gt; &#xA;&lt;p&gt;Clauses which begin&lt;code&gt;otherwise&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; are the same: they&#39;re the default case, and bind no variables.&lt;/p&gt; &#xA;&lt;h2&gt;Conditions&lt;/h2&gt; &#xA;&lt;p&gt;In addition, &lt;code&gt;dsm&lt;/code&gt; exposes three condition classes:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;dsm-error&lt;/code&gt;&lt;/strong&gt; is the condition type of all errors that &lt;code&gt;dsm&lt;/code&gt; knowingly signals.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;dsm-error/yours&lt;/code&gt;&lt;/strong&gt; is the type of errors signalled by &lt;code&gt;dsm&lt;/code&gt; which it considers to be your fault: things like botched lambda lists and so on.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;dsm-error/mine&lt;/code&gt;&lt;/strong&gt; is the type of errors signalled by &lt;code&gt;dsm&lt;/code&gt; which it considers to be its fault. Please report any of these.&lt;/p&gt; &#xA;&lt;p&gt;Of course, other errors may occur which it has not foreseen: report these also.&lt;/p&gt; &#xA;&lt;h2&gt;Some simple examples&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro bind (v/v &amp;amp;body forms)&#xA;  (destructuring-match v/v&#xA;    (var&#xA;     (:when (symbolp var))&#xA;     `(let ((,var nil)) ,@forms))&#xA;    ((var val)&#xA;     (:when (symbolp var))&#xA;     `(let ((,var ,val)) ,@forms))&#xA;    (otherwise&#xA;     (error &#34;bad binding ~S&#34; v/v))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is a trivial version of &lt;code&gt;let&lt;/code&gt; which binds only one variable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro bind* (bindings &amp;amp;body forms)&#xA;  (destructuring-match bindings&#xA;    (()&#xA;     `(locally ,@forms))&#xA;    (((var &amp;amp;optional (val nil)))&#xA;     (:when (symbolp var))&#xA;     `((lambda (,var) ,@forms) ,val))&#xA;    ((var)&#xA;     (:when (symbolp var))&#xA;     `((lambda (,var) ,@forms) nil))&#xA;    (((var &amp;amp;optional (val nil)) . more)&#xA;     (:when (symbolp var))&#xA;     `((lambda (,var) (bind* ,more ,@forms)) ,val))&#xA;    ((var . more)&#xA;     (:when (symbolp var))&#xA;     `((lambda (,var) (bind* ,more ,@forms)) nil))&#xA;    (otherwise&#xA;     (error &#34;what even is this?&#34;))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is a more elaborate version of &lt;code&gt;let*&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;An example of blank variables: this function will extract a list of keyword variable names from the various possible keyword argument specifications allowed by CL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun keyword-variable-names (keyword-argument-specifications)&#xA;  (mapcar (lambda (spec)&#xA;            (destructuring-match spec&#xA;              (v&#xA;               (:when (symbolp v))&#xA;               v)&#xA;              ((v _ &amp;amp;optional _)&#xA;               (:when (symbolp v))&#xA;               v)&#xA;              (((_ v) _ &amp;amp;optional _)&#xA;               (:when (symbolp v))&#xA;               v)&#xA;              (otherwise&#xA;               (error &#34;not a keyword argument specification&#34;))))&#xA;          keyword-argument-specifications))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Without blank variables, something like this would need to be covered in explicit&lt;code&gt;ignore&lt;/code&gt; declarations.&lt;/p&gt; &#xA;&lt;h2&gt;Another example: &lt;code&gt;define-destructuring-macro&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;destructuring-match&lt;/code&gt; was designed for writing macros, and it&#39;s easy to use it to write this[^4]:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro define-matching-macro (name &amp;amp;body clauses)&#xA;  (let ((&amp;lt;whole&amp;gt; (make-symbol &#34;WHOLE&#34;))&#xA;        (&amp;lt;junk&amp;gt; (make-symbol &#34;JUNK&#34;)))&#xA;    (destructuring-match clauses&#xA;      ((doc . the-clauses)&#xA;       (:when (stringp doc))&#xA;       `(defmacro ,name (&amp;amp;whole ,&amp;lt;whole&amp;gt; &amp;amp;rest ,&amp;lt;junk&amp;gt;)&#xA;          ,doc&#xA;          (destructuring-match ,&amp;lt;whole&amp;gt; ,@the-clauses)))&#xA;      (the-clauses&#xA;       `(defmacro ,name (&amp;amp;whole ,&amp;lt;whole&amp;gt; &amp;amp;rest ,&amp;lt;junk&amp;gt;)&#xA;          (destructuring-match ,&amp;lt;whole&amp;gt; ,@the-clauses))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can then be used, for instance, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(define-matching-macro with-scrot&#xA; ((_ (s) &amp;amp;body forms)&#xA;  (:when (symbolp s))&#xA;  `(call-with-simple-scrot (lambda (,s) ,@forms)))&#xA; ((_ (s v) &amp;amp;body forms)&#xA;  (:when (symbolp s))&#xA;  `(call-with-general-scrot (lambda (,s) ,@forms) (ensure-scrot ,v)))&#xA; (badness&#xA;  (error &#34;~S is a bad bad thing&#34; badness)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So now it&#39;s very easy to write macros which accept several argument patterns and which can also report syntax errors usefully.&lt;/p&gt; &#xA;&lt;h2&gt;Notes on the implementation&lt;/h2&gt; &#xA;&lt;h3&gt;Lambda lists&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;dsm&lt;/code&gt; has to implement its own parsing and compilation of lambda lists. It is intended to be compatible with &lt;code&gt;destructuring-bind&lt;/code&gt; with the extension of &#39;lambda lists&#39; which are a symbol. However there are many corner cases, especially around keyword handling: I &lt;em&gt;think&lt;/em&gt; it gets these right, but there may be bugs remaining: please let me know if you find any.&lt;/p&gt; &#xA;&lt;p&gt;There is a fairly extensive test-suite included with &lt;code&gt;dem&lt;/code&gt; which tests quite a lot of the corner cases, but it is not completely comprehensive, and I may also just not understand a lot of the corner cases of lambda list parsing.&lt;/p&gt; &#xA;&lt;h3&gt;Structure sharing&lt;/h3&gt; &#xA;&lt;p&gt;When &lt;code&gt;dsm&lt;/code&gt; binds a variable to an object which is part of the structure of the lambda list, that object will actually be part of that structure. So, for instance&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(let ((l &#39;(a b c)))&#xA;  (destructuring-match l&#xA;    ((&amp;amp;rest r)&#xA;     (eq l r))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will be true.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;&amp;amp;rest&lt;/code&gt; lists may not be&lt;/h3&gt; &#xA;&lt;p&gt;A lambda list like &lt;code&gt;(a &amp;amp;rest b)&lt;/code&gt; just peels off the first element of the thing it&#39;s matching for &lt;code&gt;a&lt;/code&gt; and then puts everything else in &lt;code&gt;b&lt;/code&gt;: that may not be a proper list or even a cons. In particular&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;this&lt;/th&gt; &#xA;   &lt;th&gt;is the same as this&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;(a b ... &amp;amp;rest c)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;(a b ... . c)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;(&amp;amp;rest r)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;r&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;and so on. Checking that &lt;code&gt;&amp;amp;rest&lt;/code&gt; lists are in fact proper lists is expensive and probably not actually useful since it would make cyclic structures impossible to match, so &lt;code&gt;dsm&lt;/code&gt; does not waste time doing so.&lt;/p&gt; &#xA;&lt;h3&gt;Declarations&lt;/h3&gt; &#xA;&lt;p&gt;Declarations are &#39;raised&#39; to where they belong by the compiler, so something like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(destructuring-match x&#xA;  ((&amp;amp;key y)&#xA;   (:when (evenp y))&#xA;   (declare (type integer y))&#xA;   y))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will do the right thing, and the guard clause will be within the scope of the declaration.&lt;/p&gt; &#xA;&lt;p&gt;However, &lt;strong&gt;no attempt is made to recognise the alternative form of type declarations&lt;/strong&gt;: &lt;code&gt;(declare (integer y))&lt;/code&gt; is simply not recognised at all. That&#39;s because it&#39;s essentially not possible to reliably recognise that declarations of the form &lt;code&gt;(&amp;lt;something&amp;gt; ...)&lt;/code&gt; are in fact type declarations at all because CL has no &#39;is this a type specifier?&#39; predicate. So if you want to declare types, use the long form[^5].&lt;/p&gt; &#xA;&lt;p&gt;Other declaration types which affect variable bindings, such as &lt;code&gt;ignore&lt;/code&gt;, &lt;code&gt;dynamic-extent&lt;/code&gt; and so on, are also raised.&lt;/p&gt; &#xA;&lt;h3&gt;Dead code&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;dsm&lt;/code&gt; can generate code like this as a particular case (this often happens when using &lt;code&gt;&amp;amp;rest&lt;/code&gt; lists in particular):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(let ((x &#39;()))&#xA;  (if (not (null x))&#xA;      (fail ...)&#xA;      ...))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can cause SBCL at least to mutter about eliminating dead code: I decided that the additional complexity to deal with this special case wasn&#39;t worth it: probably any serious compiler will work it out and remove the test.&lt;/p&gt; &#xA;&lt;h3&gt;The lambda list parser &amp;amp; compiler&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;dsm&lt;/code&gt; contains the seeds of what could be a general-purpose lambda list parser &amp;amp; compiler, which could, in theory, be taught how to parse &amp;amp; compile other sorts of lambda lists, including lambda lists not native to CL. At present these are not well-separated from the code that recognizes and compiles &lt;code&gt;destructuring-bind&lt;/code&gt;-style lambda lists, but they might one day be.&lt;/p&gt; &#xA;&lt;h3&gt;Performance&lt;/h3&gt; &#xA;&lt;p&gt;Since &lt;code&gt;dsm&lt;/code&gt; is intended for use in macros I made no real attempt to worry about performance. There is a small set of rudimentary benchmarks which compare its performance with &lt;code&gt;destructuring-bind&lt;/code&gt; for various cases: the results are obviously implementation-dependent, but generally it seems to be between about 1/2 and 1/10 the speed. Given that it&#39;s portable code I&#39;m happy with this[^6].&lt;/p&gt; &#xA;&lt;h3&gt;Layers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;dsm&lt;/code&gt; contains an &#39;implementation&#39; layer which has its own package, and which may one day expose more of it with some documented interface. Currently this interface is entirely internal to &lt;code&gt;dsm&lt;/code&gt; and may change at any time.&lt;/p&gt; &#xA;&lt;h2&gt;Other notes&lt;/h2&gt; &#xA;&lt;p&gt;&#39;Lambda lists&#39; which are symbols happened by mistake (there&#39;s what is essentially an error in the recognizer where it&#39;s looking for dotted lambda lists), but they are in fact so useful that I decided this was a feature, not a bug.&lt;/p&gt; &#xA;&lt;h2&gt;Lost futures&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;dsm&lt;/code&gt; contains a lambda list parser and compiler which, in principle, are fairly general. Cleaning up and exposing their interfaces was too exhausting when I was writing &lt;code&gt;dsm&lt;/code&gt; but might happen in future.&lt;/p&gt; &#xA;&lt;p&gt;What constitutes a blank variable is parameterized internally and could be made user-configurable. On the other hand everybody elsr uses &lt;code&gt;_&lt;/code&gt;, so I am not sure any useful purpose would be served by doing so.&lt;/p&gt; &#xA;&lt;h2&gt;Package, module, feature, dependencies&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;dsm&lt;/code&gt; lives in &lt;code&gt;org.tfeb.dsm&lt;/code&gt; and provides &lt;code&gt;:org.tfeb.dsm&lt;/code&gt;. There is an ASDF system definition for both it and its tests.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;dsm&lt;/code&gt; depends on a fair number of other things I have written: if you have a recent Quicklisp distribution then it &lt;em&gt;should&lt;/em&gt; know about all of them. At least, by the time &lt;code&gt;dsm&lt;/code&gt; makes it into Quicklisp it should. If not, you need at least version 5 of &lt;a href=&#34;https://tfeb.github.io/tfeb-lisp-hax/&#34; title=&#34;TFEB.ORG Lisp hax&#34;&gt;my CL hax&lt;/a&gt;, and at least version 8 of &lt;a href=&#34;https://tfeb.github.io/tfeb-lisp-tools/&#34; title=&#34;TFEB.ORG Lisp tools&#34;&gt;my CL tools&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Destructuring match is copyright 2022 by Tim Bradshaw. See &lt;code&gt;LICENSE&lt;/code&gt; for the license.&lt;/p&gt; &#xA;&lt;p&gt;[^1]: Almost equivalently: neither &lt;code&gt;destructuring-bind&lt;/code&gt; not &lt;code&gt;destructuring-match&lt;/code&gt; support the &lt;code&gt;&amp;amp;environment&lt;/code&gt; lambda list keyword.&lt;/p&gt; &#xA;&lt;p&gt;[^2]: A toy version of a macro to define pattern-matching macros like this is included as an example.&lt;/p&gt; &#xA;&lt;p&gt;[^3]: Or should be!&lt;/p&gt; &#xA;&lt;p&gt;[^4]: Note that this is 12 lines, 6 of which is code to handle docstrings.&lt;/p&gt; &#xA;&lt;p&gt;[^5]: I think you should always do this, anyway.&lt;/p&gt; &#xA;&lt;p&gt;[^6]: Apocryphally it also outperforms some of those hairy pattern matchers which obsess about performance, although they obviously do a lot more than &lt;code&gt;dsm&lt;/code&gt; does.&lt;/p&gt;</summary>
  </entry>
</feed>