<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-09T01:35:08Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>atlas-engineer/cl-xmpp</title>
    <updated>2022-09-09T01:35:08Z</updated>
    <id>tag:github.com,2022-09-09:/atlas-engineer/cl-xmpp</id>
    <link href="https://github.com/atlas-engineer/cl-xmpp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cleaned-up version of CL-XMPP.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This is a Common Lisp implementation of the XMPP RFCs. Please see &lt;a href=&#34;http://common-lisp.net/project/cl-xmpp&#34;&gt;http://common-lisp.net/project/cl-xmpp&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;(require :cl-xmpp)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;(defvar &lt;em&gt;connection&lt;/em&gt; (xmpp:connect :hostname &#34;jabber.org&#34;)) ;; or xmpp:connect-tls if you loaded cl-xmpp-tls&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;;; note that for XMPP servers which do not have the same hostname ;; as the domain-part of the user&#39;s JID you will have to pass that ;; in. eg for Google Talk: ;; (defvar &lt;em&gt;connection&lt;/em&gt; (xmpp:connect-tls :hostname &#34;talk.google.com&#34; :jid-domain-part &#34;gmail.com&#34;))&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(xmpp:auth &lt;em&gt;connection&lt;/em&gt; &#34;username&#34; &#34;password&#34; &#34;resource&#34;) ;; or pass :mechanism :sasl-plain, :digest-md5 or sasl-digest-md5 ;; if you loaded cl-xmpp-sasl or cl-xmpp-tls.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;;; send someone a message&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(xmpp:message &lt;em&gt;connection&lt;/em&gt; &#34;username@hostname&#34; &#34;what&#39;s going on?&#34;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;;; then sit back and watch the messages roll in:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(xmpp:receive-stanza-loop &lt;em&gt;connection&lt;/em&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;message from=&#34;username@hostname&#34; to=&#34;me@myserver&#34;&gt;&#xA;  [....] ;; or use xmpp:receive-stanza if you&#39;re just wanting one stanza ;; (note it will still block until you have received a complete ;; stanza) &#xA; &lt;p&gt;;; That&#39;s it. Interrupt the loop to issue other commands, eg:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;(xmpp:get-roster &lt;em&gt;connection&lt;/em&gt;)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;;; or any of the other ones you may find by looking through cl-xmpp.lisp ;; and package.lisp to see which ones are exported.&lt;/p&gt; &#xA; &lt;p&gt;;; If you wish to handle the incoming messages or other objects simply ;; specify an xmpp:handle method for the objects you are interested in ;; or (defmethod xmpp:handle (connection object) ...) to get them ;; all. Or alternatively specify :dom-repr t to receive-stanza-loop ;; to get DOM-ish objects.&lt;/p&gt; &#xA; &lt;p&gt;;; For example, if you wanted to create an annoying reply bot:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;(defmethod xmpp:handle ((connection xmpp:connection) (message xmpp:message)) (xmpp:message connection (xmpp:from message) (format nil &#34;reply to: ~a&#34; (xmpp:message object))))&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/message&gt;</summary>
  </entry>
  <entry>
    <title>mctuva/ccl-armv8-early-experiments</title>
    <updated>2022-09-09T01:35:08Z</updated>
    <id>tag:github.com,2022-09-09:/mctuva/ccl-armv8-early-experiments</id>
    <link href="https://github.com/mctuva/ccl-armv8-early-experiments" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simulators: subset of x86, 32- and 64-bit ARM, CCL compiler output: Lisp examples, hand-compiled: ARMv8 code&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ccl-armv8-early-experiments&lt;/h1&gt; &#xA;&lt;p&gt;This project is for &lt;em&gt;students&lt;/em&gt; and &lt;em&gt;professionals&lt;/em&gt; with a &lt;strong&gt;Common Lisp&lt;/strong&gt; background (or curiosity) who are interested in Lisp &lt;em&gt;compilation techniques, language translators, and simulators.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;The project includes the &lt;em&gt;executable&lt;/em&gt; results of a number of experiments undertaken to learn how the &lt;strong&gt;Clozure Common Lisp&lt;/strong&gt; (CCL) &lt;em&gt;compiler&lt;/em&gt; and run-time &lt;em&gt;kernel&lt;/em&gt; work. It includes three architectural simulators: one for a small subset of the Intel x86-64, a second for the 32-bit ARM, and a third for the 64-bit ARMv8. (*) These simulators let you trace execution simply by inserting Lisp code into the assembly language, and the Lisp Read-Eval-Print Loop (REPL) lets you interactively examine simulated memory and register contents.&lt;/p&gt; &#xA;&lt;p&gt;For the x86 and the 32-bit ARM, there are &lt;em&gt;runnable&lt;/em&gt; examples of the CCL Lisp compiler output from small, carefully curated Lisp programs: one recursive integer algorithm, and one example of in-line, thread-safe storage allocation (i.e. CONS). For the 64-bit ARMv8 there is experimental (&#34;straw man&#34;), hand-compiled, &lt;em&gt;verified&lt;/em&gt; ARMv8 code for the same Lisp examples.&lt;/p&gt; &#xA;&lt;p&gt;Also included is a pre-built version of the automatically-generated &lt;strong&gt;.s&lt;/strong&gt; file that successfully runs on a Raspberry Pi 400 with a &lt;em&gt;64-bit&lt;/em&gt; Linux distro (when linked with a choice of C &#34;main&#34; source files). This assembly language code is not a conclusion, but rather a conversation-&lt;em&gt;starter&lt;/em&gt; on how to port CCL to the ARMv8, and eventually to MacOS on the Apple Silicon &#34;M1&#34; system-on-a-chip family and its successors.&lt;/p&gt; &#xA;&lt;p&gt;Advanced Lisp programmers might be interested in seeing how the authors wrote a &#34;LAP&#34; (Lisp Assembly Language) to Common Lisp compiler that uses LAMBDA and GO to implement branch addresses (Hint: each simulation is a single, giant TAGBODY, but how do you push a &#34;return address&#34; onto the stack when there is no program-counter?).&lt;/p&gt; &#xA;&lt;p&gt;For more details, please refer to the included documentation: &lt;strong&gt;2022-CCL-project-write-up&lt;/strong&gt; (in both PDF and OpenDocument format). &lt;strong&gt;Invitation&lt;/strong&gt;: If you have the means to convert the &lt;strong&gt;.odt&lt;/strong&gt; file to Markdown format and the willingness to check it in, be our guest. Thanks!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Footnotes&lt;/strong&gt;: (*) Do not even &lt;em&gt;dream&lt;/em&gt; that these simulators are accurate or comprehensive (look elsewhere if you have a requirement for that). They only implement the instructions emitted by the CCL Lisp compiler. The simulated instructions are not bit- or flag-accurate, and do not reflect limitations of the instruction formats (e.g. the size of literal constants). Thankfully, these simulators &lt;em&gt;are&lt;/em&gt; small and distraction-free enough for study and &lt;em&gt;teaching&lt;/em&gt; purposes.&lt;/p&gt;</summary>
  </entry>
</feed>