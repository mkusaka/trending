<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-08T01:25:07Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>guicho271828/cl-rrt</title>
    <updated>2024-03-08T01:25:07Z</updated>
    <id>tag:github.com,2024-03-08:/guicho271828/cl-rrt</id>
    <link href="https://github.com/guicho271828/cl-rrt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Common Lisp implementation of RRT (Rapidily exploring Random Tree), a fast probabilistic multidimentional path-plannning algorithm. Note: It will still work, but it is an old work. I think the implementation is not be very efficient because my lisp hacking has significantly improved since when I wrote this library.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+LINK: hs &lt;a href=&#34;http://www.lispworks.com/reference/HyperSpec//%s&#34;&gt;http://www.lispworks.com/reference/HyperSpec//%s&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CL-RRT - Common Lisp implementation of RRT (Rapidily exploring Random Tree)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;[[https://raw.github.com/guicho271828/cl-rrt/master/figure.png]]&lt;/p&gt; &#xA;&lt;p&gt;RRT is a fast probabilistic multidimentional path-plannning algorithm introduced by S.M.LaValle (1). It now has a widespread use in robotics and now able to handle the real time systems such as automatic car driving AI. Also, it has various extentions and optimization methods (but not yet implemented here) such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MP-RRT -- optimizing version of RRT&lt;/li&gt; &#xA; &lt;li&gt;RR-belief-tree -- RRT under uncertainity&lt;/li&gt; &#xA; &lt;li&gt;RRG -- use a graph structure instead of a tree&lt;/li&gt; &#xA; &lt;li&gt;RRT* -- optimizing version of RRT&lt;/li&gt; &#xA; &lt;li&gt;St-RRT -- temporal algorithm&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The above image is a test result of a motion planner from the start(red) to the end (blue). The path is avoiding the collision to the randomly generated obstacles. Note that the path is not optimized -- RRT gains speed sacrificing the cost of the path. The source is in =t/= .&lt;/p&gt; &#xA;&lt;p&gt;(1) S.M. LaValle and J.J. Kuffner. Randomized kinodynamic planning. /The International Journal of Robotics Research/, Vol. 20, No. 5, pp. 378â€“400, 2001.&lt;/p&gt; &#xA;&lt;p&gt;** Recent changes&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=edge-prohibited-p= and =finish-p= is now keyword arguments. (2013 March 1st)&lt;/li&gt; &#xA; &lt;li&gt;Supported R-tree based nearest neighbor search (2013 Dec 8th). &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;It&#39;s computational order is smaller than the other trivial implementations, but in practice it may be slow sometimes (especially for the small problems)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Future extension&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;improvements in the nearest search. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;with R-tree or kd-tree&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Dependencies&lt;/p&gt; &#xA;&lt;p&gt;This library is at least tested on implementations listed below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SBCL 1.1.2 on X86-64 Linux 3.2.0-39-generic (author&#39;s environment)&lt;/li&gt; &#xA; &lt;li&gt;Clozure Common Lisp Version 1.9-r15757 on X86-64 Linux 3.2.0-39-generic (author&#39;s environment)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also, it depends on the following libraries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;ITERATE :: Jonathan Amsterdam&#39;s iterator/gatherer/accumulator facility&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;ALEXANDRIA :: Alexandria is a collection of portable public domain utilities.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CL-ANNOT by Tomohiro Matsuyama :: Python-like Annotation Syntax for Common Lisp&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;ANAPHORA ::&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Installation&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Quicklisp loadable. First open slime REPL.&lt;/li&gt; &#xA; &lt;li&gt;=(ql:quickload :cl-rrt)= and the library will be installed along with all the dependencies.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Author&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Masataro Asai (&lt;a href=&#34;mailto:guicho2.71828@gmail.com&#34;&gt;guicho2.71828@gmail.com&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Univ. Tokyo -&amp;gt; Grad. school of Tokyo University&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Concepts and API&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The key concept in RRT is C-space and State-space.&lt;/p&gt; &#xA;&lt;p&gt;C-space (configuration space) is a multidimentional space which represents &lt;em&gt;the state of a robot&lt;/em&gt;. For example, a human arm has 6 degrees of freedom and its C-space also has at least 6 dimension. However, in this example the dimension of C-space can be up to 18 because it is allowed to have the differencial factor for each coordinate -- its velocity and the accelaration.&lt;/p&gt; &#xA;&lt;p&gt;State-space is also a multidimentional space. It contains all the values in C-space and also &lt;em&gt;the controls of the robot&lt;/em&gt;. A control is an output of the robot and it is different from the speed and the accelaration. For example, if you implement a car AI, the actual acceleration would not nessesarily match the output of the engine because there is a drift between the tire and the ground.&lt;/p&gt; &#xA;&lt;p&gt;In each step of a search, RRT randomly choose a point in a State-space and create a node. It search for the nearest node in the existing tree to the new node (&lt;em&gt;NNS:Nearest Neighbor Search&lt;/em&gt;), using the user-specified distance function, and the found node is connected with the new node. The search finishes when a certain criteria is met.&lt;/p&gt; &#xA;&lt;p&gt;Each new point subdivides the Voronoi Cell in the State-space. Since the larger Volonoi Cell more likely contains the new node, the direction of the search is heavily biased to the less-searched space.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example and Tutorial&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Not written yet. See =t/= for example, there is a testing code. To run a test, =(asdf:load-system :cl-rrt-test)=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;API&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See [[./references.org]] .&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Copyright&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Copyright (c) 2013 Masataro Asai (&lt;a href=&#34;mailto:guicho2.71828@gmail.com&#34;&gt;guicho2.71828@gmail.com&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;License&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Licensed under the LLGPL License.&lt;/p&gt;</summary>
  </entry>
</feed>