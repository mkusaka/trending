<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-10T01:32:59Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>woodrush/lambda-8cc</title>
    <updated>2022-10-10T01:32:59Z</updated>
    <id>tag:github.com,2022-10-10:/woodrush/lambda-8cc</id>
    <link href="https://github.com/woodrush/lambda-8cc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;x86 C compiler written in untyped lambda calculus&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lambda-8cc - An x86 C Compiler Written in Untyped Lambda Calculus&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/bin/lambdavm-diagram.png&#34; alt=&#34;Lambda calculus diagram for LambdaVM.&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/woodrush/lambda-8cc/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/woodrush/lambda-8cc/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;lambda-8cc is an x86 C compiler written as a monolithic closed untyped lambda calculus term.&lt;/p&gt; &#xA;&lt;p&gt;When printed on letter-sized paper, it becomes 18,506 pages long on a 22 MB PDF without any figures. The PDF can be seen on my GitHub Pages &lt;a href=&#34;https://woodrush.github.io/lambda-8cc.pdf&#34;&gt;here&lt;/a&gt;. The LaTeX source is 448 MB, and the LaTeX compilation log file &lt;code&gt;main.log&lt;/code&gt; is 284 MB. I couldn&#39;t believe LaTeX was able to do that.&lt;/p&gt; &#xA;&lt;p&gt;This gigantic lambda calculus term is a C compiler. Here is &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/rot13.c&#34;&gt;rot13.c&lt;/a&gt;, a program that compiles on GCC with no errors. The same program can be compiled using lambda-8cc producing the x86 executable &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/out/rot13.bin&#34;&gt;rot13.bin&lt;/a&gt;, runnable on x86/x86-64 Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ echo &#39;Hello, world!&#39; | ./rot13.bin&#xA;Uryyb, jbeyq!&#xA;$ echo &#39;Uryyb, jbeyq!&#39; | ./rot13.bin&#xA;Hello, world!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Despite its massive size, compiling rot13.c finishes in 8 minutes on my machine using a lambda calculus interpreter. You can try it out on your own PC by cloning this repo. Running time stats are summarized in the &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/#running-times-and-memory-usage&#34;&gt;Running Times and Memory Usage&lt;/a&gt; section. Note that although the compilation takes time, the compiled binary runs instantaneously.&lt;/p&gt; &#xA;&lt;!-- A zipped plaintext file is also available in this repo [here](./bin/lambda-8cc.lam.zip). --&gt; &#xA;&lt;h3&gt;Additional Feature: C to Lambda Calculus&lt;/h3&gt; &#xA;&lt;p&gt;As an additional feature, not only can lambda-8cc compile C to x86, but it can also compile C to lambda calculus terms, producing something like &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/out/rot13.lam&#34;&gt;rot13.lam&lt;/a&gt;. Compiled lambda terms run on the same lambda calculus interpreter used to run lambda-8cc itself.&lt;/p&gt; &#xA;&lt;p&gt;Using its &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/#compilation-options&#34;&gt;compilation options&lt;/a&gt;, lambda-8cc can compile C to 5 different formats. Here is a full list of its features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compile C to: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;x86 executable (a.out)&lt;/li&gt; &#xA;   &lt;li&gt;Lambda calculus term (runs on the same interpreter as lambda-8cc)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tromp.github.io/cl/Binary_lambda_calculus.html&#34;&gt;Binary lambda calculus&lt;/a&gt; program&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/SKI_combinator_calculus&#34;&gt;SKI combinator calculus&lt;/a&gt; term (runnable as a &lt;a href=&#34;https://tromp.github.io/cl/lazy-k.html&#34;&gt;Lazy K&lt;/a&gt; program)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/shinh/elvm&#34;&gt;ELVM&lt;/a&gt; assembly listing (example: &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/out/rot13.s&#34;&gt;rot13.s&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Compile ELVM assembly to: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;x86/lambda calculus/BLC/SKI combinator calculus (all of the above)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Among the list is &lt;a href=&#34;https://tromp.github.io/cl/lazy-k.html&#34;&gt;Lazy K&lt;/a&gt;, a minimal purely functional language with only 4 built-in operators, similar to the minimal imperative language &lt;a href=&#34;https://en.wikipedia.org/wiki/Brainfuck&#34;&gt;BF&lt;/a&gt; which only has 8 instructions. I have covered a little bit about it in &lt;a href=&#34;https://woodrush.github.io/blog/lambdalisp.html#lazy-k&#34;&gt;my blog post&lt;/a&gt; as well.&lt;/p&gt; &#xA;&lt;p&gt;lambda-8cc is based on the following 3 projects: The first one is &lt;a href=&#34;https://github.com/woodrush/lambdavm&#34;&gt;LambdaVM&lt;/a&gt; written by the author of this repo &lt;a href=&#34;https://github.com/woodrush&#34;&gt;Hikaru Ikuta&lt;/a&gt;, a programmable virtual CPU written as an untyped lambda calculus term. This is combined with &lt;a href=&#34;https://github.com/rui314/8cc&#34;&gt;8cc&lt;/a&gt; by &lt;a href=&#34;https://github.com/rui314&#34;&gt;Rui Ueyama&lt;/a&gt;, and a modified version of &lt;a href=&#34;https://github.com/shinh/elvm&#34;&gt;ELVM&lt;/a&gt; by &lt;a href=&#34;https://github.com/shinh&#34;&gt;Shinichiro Hamaji&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Gallery&lt;/h2&gt; &#xA;&lt;p&gt;The first page of the PDF looks like this. Notice the page count on the top left:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/bin/lambda-8cc-page1.png&#34; alt=&#34;The first page of a PDF showing lambda-8cc&#39;s lambda term&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Its grand finale is a round of applause by a page full of right parentheses:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/bin/lambda-8cc-page18506.png&#34; alt=&#34;The last page of a PDF showing lambda-8cc&#39;s lambda term&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;h3&gt;Lambdas All the Way Down&lt;/h3&gt; &#xA;&lt;p&gt;lambda-8cc is written as a closed untyped lambda calculus term ${\rm lambda8cc} = \lambda x. \cdots$ which takes an input string $x$ representing a C program and outputs an x86 Linux ELF executable expressed as a list of bytes.&lt;/p&gt; &#xA;&lt;p&gt;Here, even strings are encoded as lambda terms. Characters and bytes are encoded as a list of bits with $0 = \lambda x. \lambda y.x$, $1 = \lambda x. \lambda y.y$, and lists are encoded in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding&#34;&gt;Scott encoding&lt;/a&gt; with ${\rm cons} = \lambda x.\lambda y.\lambda f.(f x y)$, ${\rm nil} = \lambda x.\lambda y.y$.&lt;/p&gt; &#xA;&lt;p&gt;Therefore, &lt;em&gt;everything&lt;/em&gt; in the computation process, even including integers, is closed in the world of pure lambda terms, without the need of introducing any non-lambda type object whatsoever. It doesn&#39;t use any primitive types other than lambdas. lambda-8cc makes &lt;a href=&#34;https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction&#34;&gt;beta reduction&lt;/a&gt; the sole requirement for compiling C to x86. Note that the process doesn&#39;t depend on the choice of variable names as well. Instead of encoding the character &lt;code&gt;A&lt;/code&gt; as a variable with the name $A$, &lt;code&gt;A&lt;/code&gt; is encoded as a list of bits of its ASCII encoding &lt;code&gt;01000001&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The encoding process is a little cumbersome to say at the least to do by hand. This can be solved by using a lambda calculus interpreter. Various lambda calculus interpreters automatically handle this I/O format so that it runs on the terminal - standard input is encoded into lambda terms, and the output lambda term is decoded and shown on the terminal. Using these interpreters, lambda-8cc can be run on the terminal to compile C programs just like GCC.&lt;/p&gt; &#xA;&lt;p&gt;For further details on how I/O is handled and how programs are written in lambda calculus, please see the implementation details of my other project &lt;a href=&#34;https://github.com/woodrush/lambdalisp&#34;&gt;LambdaLisp&lt;/a&gt;, a Lisp interpreter written as an untyped lambda calculus term.&lt;/p&gt; &#xA;&lt;h3&gt;C to Lambda Calculus&lt;/h3&gt; &#xA;&lt;p&gt;In addition to x86, lambda-8cc can compile C to lambda calculus as well. The output program runs on the same lambda calculus interpreter used to run lambda-8cc itself. Compiled lambda terms also run on minimal interpreters such as the 521-byte lambda calculus interpreter &lt;a href=&#34;https://justine.lol/lambda/&#34;&gt;SectorLambda&lt;/a&gt; written by &lt;a href=&#34;https://github.com/jart&#34;&gt;Justine Tunney&lt;/a&gt;, and the &lt;a href=&#34;https://www.ioccc.org/&#34;&gt;IOCCC&lt;/a&gt; 2012 &lt;a href=&#34;https://www.ioccc.org/2012/tromp/hint.html&#34;&gt;&#34;Most functional&#34;&lt;/a&gt; interpreter written by &lt;a href=&#34;https://github.com/tromp&#34;&gt;John Tromp&lt;/a&gt; (its &lt;a href=&#34;https://www.ioccc.org/2012/tromp/tromp.c&#34;&gt;source&lt;/a&gt; is in the shape of a λ). This makes lambda-8cc self-contained in the realm of lambda calculus.&lt;/p&gt; &#xA;&lt;p&gt;It has long been known in computer science that lambda calculus is Turing-complete. lambda-8cc demonstrates this in a rather straightforward way by showing that C programs can directly be compiled into lambda calculus terms.&lt;/p&gt; &#xA;&lt;p&gt;The nice thing about lambda calculus is that the language specs are extremely simple. With lambda-8cc, we are preserving knowledge about how to compile C in a timeless method. Even if humanity loses knowledge about the x86 instruction set, as long as we remember the rules for lambda calculus and have &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/bin/lambda-8cc.lam.zip&#34;&gt;the lambda term for lambda-8cc&lt;/a&gt;, we can still use the entire C language through lambda-8cc and build everything on top of it again.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Usage Example&lt;/h2&gt; &#xA;&lt;p&gt;Here is a program &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/rot13.c&#34;&gt;rot13.c&lt;/a&gt; that encodes/decodes standard input to/from the &lt;a href=&#34;https://en.wikipedia.org/wiki/ROT13&#34;&gt;ROT13&lt;/a&gt; cipher. It compiles without errors using GCC:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// rot13.c: Encodes/decodes standard input to/from the ROT13 cipher&#xA;&#xA;#define EOF -1&#xA;&#xA;int putchar(int c);&#xA;char getchar(void);&#xA;&#xA;char c;&#xA;int offset;&#xA;&#xA;int main (void) {&#xA;    for (;;) {&#xA;        c = getchar();&#xA;        if (c == EOF) {&#xA;            break;&#xA;        }&#xA;&#xA;        offset = 0;&#xA;        if ((&#39;a&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt; &#39;n&#39;) || (&#39;A&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt; &#39;N&#39;)) {&#xA;            offset = 13;&#xA;        } else if ((&#39;n&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &#39;z&#39;) || (&#39;N&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &#39;Z&#39;)) {&#xA;            offset = -13;&#xA;        }&#xA;        putchar(c + offset);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same program can be compiled by lambda-8cc out of the box as follows.&lt;/p&gt; &#xA;&lt;h3&gt;Build the Tools&lt;/h3&gt; &#xA;&lt;p&gt;First build the tools and prepare lambda-8cc:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make tools  # Build the interpreter uni++ and the tools lam2bin, asc2bin&#xA;$ unzip bin/lambda-8cc.lam.zip&#xA;$ cat lambda-8cc.lam | bin/lam2bin | bin/asc2bin &amp;gt; lambda-8cc.Blc  # Prepare format for uni++&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The requirements are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;clang++&lt;/code&gt; for building &lt;code&gt;uni++&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; for building &lt;code&gt;lam2bin&lt;/code&gt; and &lt;code&gt;asc2bin&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The tools built here are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;uni++&lt;/code&gt;: A very fast &lt;a href=&#34;https://github.com/melvinzhang/binary-lambda-calculus&#34;&gt;lambda calculus interpreter&lt;/a&gt; written by &lt;a href=&#34;https://github.com/melvinzhang&#34;&gt;Melvin Zhang&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lam2bin&lt;/code&gt;: A utility written by &lt;a href=&#34;https://github.com/jart&#34;&gt;Justine Tunney&lt;/a&gt; (available at &lt;a href=&#34;https://justine.lol/lambda/&#34;&gt;https://justine.lol/lambda/&lt;/a&gt;), that converts plaintext lambda calculus notation such as &lt;code&gt;\x.x&lt;/code&gt; to &lt;a href=&#34;https://tromp.github.io/cl/Binary_lambda_calculus.html#Lambda_encoding&#34;&gt;binary lambda calculus&lt;/a&gt; notation, the format accepted by uni++.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;asc2bin&lt;/code&gt;: A utility that packs the 0/1 ASCII bitstream to bytes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The tools are build via the &lt;a href=&#34;https://github.com/woodrush/lambda-calculus-devkit&#34;&gt;lambda calculus development kit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The conversion from lambda-8cc.lam to lambda-8cc.Blc is simply a transformation of notation for a format that&#39;s accepted by the interpreter uni++. Details are described in &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/details.md#what-is-lambda-8ccblc&#34;&gt;details.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Compile the Program Using lambda-8cc&lt;/h3&gt; &#xA;&lt;p&gt;Then rot13.c can be compiled as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cat lambda-8cc.Blc examples/rot13.c | bin/uni++ -o &amp;gt; a.out&#xA;$ chmod 755 a.out&#xA;&#xA;$ echo &#39;Hello, world!&#39; | ./a.out&#xA;Uryyb, jbeyq!&#xA;$ echo &#39;Uryyb, jbeyq!&#39; | ./a.out&#xA;Hello, world!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This runs in about 8 minutes on my machine. But be careful - it takes 145 GB of memory to run it! If you have free storage space or a USB drive, you can use a &lt;a href=&#34;https://askubuntu.com/questions/178712/how-to-increase-swap-space&#34;&gt;swap file&lt;/a&gt; with &lt;code&gt;mkswap&lt;/code&gt; and &lt;code&gt;swapon&lt;/code&gt; to extend the swap without configuring the partition settings. Also, by compiling the assembly and x86 executable separately, you can halve the RAM usage to 65 GB, as shown in the &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/#detailed-usage&#34;&gt;Detailed Usage&lt;/a&gt; section. Small programs such as &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/putchar.c&#34;&gt;putchar.c&lt;/a&gt; only take about 40 GB of memory. I suspect that the RAM usage can be decreased by introducing a mark-and-sweep GC to the interpreter, although I haven&#39;t confirmed it yet.&lt;/p&gt; &#xA;&lt;p&gt;More running time stats are available in the &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/#running-times-and-memory-usage&#34;&gt;Running Times and Memory Usage&lt;/a&gt; section. More example C programs compilable by lambda-8cc can be found under &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples&#34;&gt;./examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Other compilation options are described in the &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/#detailed-usage&#34;&gt;Detailed Usage&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;Detailed Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Compilation Options&lt;/h3&gt; &#xA;&lt;p&gt;Being written in lambda calculus, naturally, lambda-8cc&#39;s compilation options are expressed as lambda calculus terms as well. These options can be used to unlock the full features of lambda-8cc.&lt;/p&gt; &#xA;&lt;p&gt;Compilation options are used by applying an optional term as &lt;code&gt;(lambda-8cc option)&lt;/code&gt; beforehand of the input. This changes the behavior of the lambda term &lt;code&gt;lambda-8cc&lt;/code&gt; so that it accepts/produces a different input/output format.&lt;/p&gt; &#xA;&lt;p&gt;Here are all of lambda-8cc&#39;s compilation options:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Input&lt;/th&gt; &#xA;   &lt;th&gt;Output&lt;/th&gt; &#xA;   &lt;th&gt;Compilation Option&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;x86 executable&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. x) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.x) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;Plaintext lambda calculus term&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. x) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.y) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;Binary lambda calculus notation (BLC program)&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. x) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.z) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;SKI combinator calculus (Lazy K program)&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. x) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.a) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;ELVM assembly&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. x) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.b) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ELVM assembly&lt;/td&gt; &#xA;   &lt;td&gt;x86 executable&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. y) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.x) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ELVM assembly&lt;/td&gt; &#xA;   &lt;td&gt;Plaintext lambda calculus term&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. y) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.y) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ELVM assembly&lt;/td&gt; &#xA;   &lt;td&gt;Binary lambda calculus notation (BLC program)&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. y) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.z) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ELVM assembly&lt;/td&gt; &#xA;   &lt;td&gt;SKI combinator calculus (Lazy K program)&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. y) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.a) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Each option is in the format of a 3-tuple ${\rm cons3} ~ {\rm input} ~ {\rm output} ~ X$ where ${\rm cons 3} = \lambda x. \lambda y. \lambda z. \lambda f. (f x y z)$. The first element ${\rm input}$ is a selector of a 2-tuple specifying the input format. The second element ${\rm output}$ is a selector of a 5-tuple specifying the output format. The third element $X = \lambda x.x$ is a placeholder used to distinguish the data structure from the standard input, also existing for backward portability in the case when more options are added in the future.&lt;/p&gt; &#xA;&lt;h3&gt;Applying Compilation Options&lt;/h3&gt; &#xA;&lt;p&gt;The compilation options shown before can be used in the terminal as follows.&lt;/p&gt; &#xA;&lt;p&gt;To compile C to an ELVM assembly listing &lt;code&gt;a.s&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;( ( cat lambda-8cc.lam; printf &#39;(\\f.(f (\\x.\\y.x) (\\x.\\y.\\z.\\a.\\b.b) (\\x.x)))&#39; ) \&#xA;  | bin/lam2bin | bin/asc2bin; cat input.c ) | bin/uni++ -o &amp;gt; a.s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To compile an ELVM assembly listing &lt;code&gt;a.s&lt;/code&gt; to x86 executable &lt;code&gt;a.out&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;( ( cat lambda-8cc.lam; printf &#39;(\\f.(f (\\x.\\y.y) (\\x.\\y.\\z.\\a.\\b.x) (\\x.x)))&#39; ) \&#xA;  | bin/lam2bin | bin/asc2bin; cat a.s ) | bin/uni++ -o &amp;gt; a.out&#xA;chmod 755 a.out&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As described before, by separately compiling &lt;code&gt;a.s&lt;/code&gt; and &lt;code&gt;a.out&lt;/code&gt; using these commands, the maximum RAM usage can be cut in half since the memory is freed when each process finishes.&lt;/p&gt; &#xA;&lt;p&gt;By running lambda-8cc without any input or options, you can see a usage message showing the full set of options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ cat lambda-8cc.lam | bin/lam2bin | bin/asc2bin | bin/uni++ -o&#xA;lambda-8cc v1.0.0&#xA;&#xA;Usage:&#xA;    apply lambda-8cc.lam [input-file]&#xA;    apply lambda-8cc.lam [option] [input-file]&#xA;&#xA;Options:&#xA;    (\f.(f [input] [output] (\x.x)))&#xA;    (\f.(f (\x.\y.x) (\x.\y.\z.\a.\b.x) (\x.x))) : C to x86 (defualt)&#xA;    (\f.(f (\x.\y.x) (\x.\y.\z.\a.\b.y) (\x.x))) : C to *.lam (plaintext lambda calculus program)&#xA;    (\f.(f (\x.\y.x) (\x.\y.\z.\a.\b.z) (\x.x))) : C to *.blc (binary lambda calculus program)&#xA;    (\f.(f (\x.\y.x) (\x.\y.\z.\a.\b.a) (\x.x))) : C to *.lazy (SKI combinator calculus, as a Lazy K program)&#xA;    (\f.(f (\x.\y.x) (\x.\y.\z.\a.\b.b) (\x.x))) : C to ELVM assembly&#xA;    (\f.(f (\x.\y.y) (\x.\y.\z.\a.\b.x) (\x.x))) : ELVM assembly to x86&#xA;    (\f.(f (\x.\y.y) (\x.\y.\z.\a.\b.y) (\x.x))) : ELVM assembly to *.lam&#xA;    (\f.(f (\x.\y.y) (\x.\y.\z.\a.\b.z) (\x.x))) : ELVM assembly to *.blc&#xA;    (\f.(f (\x.\y.y) (\x.\y.\z.\a.\b.a) (\x.x))) : ELVM assembly to *.lazy&#xA;&#xA;lambda-8cc includes the following projects. All of the following projects&#xA;are released under the MIT license. See the LICENSE in each location for details.&#xA;    8cc: By Rui Ueyama - https://github.com/rui314/8cc&#xA;    ELVM: By Shinichiro Hamaji - https://github.com/shinh/elvm&#xA;    LambdaVM: By Hikaru Ikuta - https://github.com/woodrush/lambdavm&#xA;    lambda-8cc: By Hikaru Ikuta - https://github.com/woodrush/lambda-8cc&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running Times and Memory Usage&lt;/h2&gt; &#xA;&lt;p&gt;The following table shows the compilation time and memory usage on &lt;a href=&#34;https://github.com/melvinzhang&#34;&gt;Melvin Zhang&lt;/a&gt;&#39;s &lt;a href=&#34;https://github.com/melvinzhang/binary-lambda-calculus&#34;&gt;lambda calculus interpreter&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Program&lt;/th&gt; &#xA;   &lt;th&gt;Compilation Time&lt;/th&gt; &#xA;   &lt;th&gt;Max. RAM Usage at Compilation Time&lt;/th&gt; &#xA;   &lt;th&gt;x86 Binary Size&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/putchar.c&#34;&gt;putchar.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1.8 min&lt;/td&gt; &#xA;   &lt;td&gt;31 GB&lt;/td&gt; &#xA;   &lt;td&gt;342 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Prints &lt;code&gt;A&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/hello.c&#34;&gt;hello.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;2.4 min&lt;/td&gt; &#xA;   &lt;td&gt;42 GB&lt;/td&gt; &#xA;   &lt;td&gt;802 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Prints &lt;code&gt;Hello, world!&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/echo.c&#34;&gt;echo.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;2.5 min&lt;/td&gt; &#xA;   &lt;td&gt;46 GB&lt;/td&gt; &#xA;   &lt;td&gt;663 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Echoes standard input&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/rot13.c&#34;&gt;rot13.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;7.7 min&lt;/td&gt; &#xA;   &lt;td&gt;84 GB&lt;/td&gt; &#xA;   &lt;td&gt;2,118 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Encodes/decodes stdin to/from &lt;a href=&#34;https://en.wikipedia.org/wiki/ROT13&#34;&gt;ROT13&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/fizzbuzz.c&#34;&gt;fizzbuzz.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;49.7 min&lt;/td&gt; &#xA;   &lt;td&gt;240 GB&lt;/td&gt; &#xA;   &lt;td&gt;5,512 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Prints FizzBuzz sequence up to 30&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/primes.c&#34;&gt;primes.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;53.0 min&lt;/td&gt; &#xA;   &lt;td&gt;241 GB&lt;/td&gt; &#xA;   &lt;td&gt;5,500 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Prints primes up to 100&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Now that is a lot of memory! To compile programs that require a huge RAM, you can extend your swap region without changing the partition settings by using a swap file. If you run Linux and have any free storage or a USB drive, you can use that storage to easily and dynamically extend your swap region using &lt;code&gt;mkswap&lt;/code&gt; and &lt;code&gt;swapon&lt;/code&gt;. The stats on this table are run with an extended swap region this way. Instructions are explained in this &lt;a href=&#34;https://askubuntu.com/questions/178712/how-to-increase-swap-space&#34;&gt;askubuntu thread&lt;/a&gt;. I suspect that the RAM usage can be decreased by introducing a mark-and-sweep GC to the interpreter, although I haven&#39;t confirmed it yet.&lt;/p&gt; &#xA;&lt;p&gt;Note that these are the compilation times - the running times for the compiled x86 binary are instantaneous. This even holds when compiling C to lambda calculus terms. Compiled lambda terms also run instantaneously and only use a few gigabytes of memory when run on a lambda calculus interpreter.&lt;/p&gt; &#xA;&lt;p&gt;The compilations for these stats were run on an Ubuntu 22.04.1 machine with 48 GB RAM, 16GB SSD swap (default partition), and 274GB (256GiB) HDD swap (dynamically added with &lt;code&gt;mkswap&lt;/code&gt; and &lt;code&gt;swapon&lt;/code&gt;). The running time shown here is the wall clock running time including memory operations. For swap-heavy programs, the running time could be decreased by using a device with a faster I/O speed.&lt;/p&gt; &#xA;&lt;p&gt;The stats were measured by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cp examples/[program].c ./input.c&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which compiles &lt;code&gt;a.s&lt;/code&gt; and &lt;code&gt;a.out&lt;/code&gt; for &lt;code&gt;input.c&lt;/code&gt; separately to save the total memory usage. A more detailed table of stats for each pass is shown in &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/details.md&#34;&gt;details.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How is it done?&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/details.md&#34;&gt;details.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building From Source&lt;/h2&gt; &#xA;&lt;p&gt;For details on building from source, please see &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/details.md&#34;&gt;details.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;lambda-8cc is a combination of 3 projects, &lt;a href=&#34;https://github.com/woodrush/lambdavm&#34;&gt;LambdaVM&lt;/a&gt;, &lt;a href=&#34;https://github.com/shinh/elvm&#34;&gt;ELVM&lt;/a&gt;, and &lt;a href=&#34;https://github.com/rui314/8cc&#34;&gt;8cc&lt;/a&gt;. &lt;a href=&#34;https://github.com/woodrush/lambdavm&#34;&gt;LambdaVM&lt;/a&gt; was written by &lt;a href=&#34;https://github.com/woodrush&#34;&gt;Hikaru Ikuta&lt;/a&gt;, the author of this repository (lambda-8cc). The &lt;a href=&#34;https://github.com/shinh/elvm&#34;&gt;ELVM&lt;/a&gt; architecture was written by &lt;a href=&#34;https://github.com/shinh&#34;&gt;Shinichiro Hamaji&lt;/a&gt;. &lt;a href=&#34;https://github.com/rui314/8cc&#34;&gt;8cc&lt;/a&gt; was written by &lt;a href=&#34;https://github.com/rui314&#34;&gt;Rui Ueyama&lt;/a&gt;. The version of 8cc used in lambda-8cc is a modified version of 8cc included as a part of ELVM, modified by Shinichiro Hamaji and others. lambda-8cc also includes elc, a part of ELVM written by Shinichiro Hamaji, modified by Hikaru Ikuta so that it can compile ELVM assembly to lambda calculus. The lambda calculus backend for ELVM was written by Hikaru Ikuta, by integrating LambdaVM into ELVM. The running time and memory usage statistics were measured using a &lt;a href=&#34;https://github.com/melvinzhang/binary-lambda-calculus&#34;&gt;lambda calculus interpreter&lt;/a&gt; written by &lt;a href=&#34;https://github.com/melvinzhang&#34;&gt;Melvin Zhang&lt;/a&gt;. lam2bin was written by &lt;a href=&#34;https://github.com/jart&#34;&gt;Justine Tunney&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>woodrush/lambdavm</title>
    <updated>2022-10-10T01:32:59Z</updated>
    <id>tag:github.com,2022-10-10:/woodrush/lambdavm</id>
    <link href="https://github.com/woodrush/lambdavm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A programmable virtual CPU written in untyped lambda calculus&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LambdaVM - A Programmable Virtual CPU Written as an Untyped Lambda Calculus Term&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/woodrush/lambdavm/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/woodrush/lambdavm/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;test&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/woodrush/lambdavm/main/bin/lambdavm-diagram.png&#34; alt=&#34;Lambda calculus diagram for LambdaVM.&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;LambdaVM is a programmable virtual CPU written as a closed untyped lambda calculus term. It supports an extended version of the &lt;a href=&#34;https://github.com/shinh/elvm&#34;&gt;ELVM&lt;/a&gt; instruction set and architecture written by &lt;a href=&#34;https://github.com/shinh&#34;&gt;Shinichiro Hamaji&lt;/a&gt;. Using LambdaVM, you can enjoy assembly programming to write programs in untyped lambda calculus.&lt;/p&gt; &#xA;&lt;p&gt;LambdaVM supports 8 instructions including standard I/O and virtual memory operations, and has an arbitrarily configurable ROM/RAM address size and word size, and an arbitrarily configurable number of registers.&lt;/p&gt; &#xA;&lt;p&gt;Despite its rather rich capability, LambdaVM&#39;s lambda term is quite small. Here is its entire lambda term written in plaintext:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;LambdaVM = \x.\y.\z.\a.\b.((\c.((\d.((\e.((\f.((\g.((\h.(a ((\i.(i (d (\j.\k.(k &#xA;(\l.\m.\n.\o.(o k (j m))) k)) a) (\j.(i z (d (\k.\l.\m.\n.\o.\p.((\q.((\r.((\s.(&#xA;n (\t.\u.\v.\w.v) (\t.t) (\t.\u.\v.u) (\t.\u.u) (o (\t.\u.\v.(o (k l m) p)) o) (&#xA;n (\t.\u.((\v.(t (\w.\A.\B.((\C.(A (C B) (s B C))) (\C.\D.(w (D ((\E.(m (\F.\G.\&#xA;H.(E (y (\I.\J.(J (\K.\L.K) I)) F) G)) (E c m))) (\E.\F.(r B E (k l F u o)))) (\&#xA;E.(E (y (\F.(F (\G.\H.H))) C) (v p))) A) (D (\E.\F.\G.\H.((\I.(F (I G) (s G I)))&#xA; (s H (\I.\J.(E (e I C) (q J) (v p))))))) (D (\E.\F.((\G.(f (\H.\I.I) (E (s F e &#xA;C)) G G (\H.(r F)))) c)) v) (q C) (h l C (r D) v) (s D (g l C) k m u o p) (D (\E&#xA;.\F.(s E (f F F) C (\G.(r E)))) v) (r D C v))))))) (k l m u o)))))) (h p))) (g p&#xA;))) (\q.(h j q (\r.(r (k l m) p))))))))))) (\i.\j.(d (\k.\l.\m.\n.(l (\o.\p.\q.(&#xA;m (\r.\s.\t.(k l s (\u.\v.(k v s (\w.(n (\A.(A u w)))))))) (l n))) (n l l))) i c&#xA; (\k.\l.(j k)))) b) (\i.\j.j))) (d (\h.\i.\j.\k.(i (\l.\m.\n.(j (\o.\p.\q.(o (h &#xA;l) (h m) p k)) (k i))) (k c)))))) (d (\g.\h.\i.\j.\k.(i (\l.\m.\n.((\o.(h (\p.\q&#xA;.\r.(l (h o) (o q p))) (o (\p.\q.q) (\p.\q.q)))) (\o.(g o m j (\p.\q.(l (k (\r.(&#xA;r p q))) (k (\r.(r q p))))))))) (k j)))))) (d (\f.\g.\h.\i.\j.\k.(i (\l.\m.\n.(j&#xA; (\o.\p.(f g h m p (\q.\r.((\s.((\t.((\u.((\v.(t s q (v (\w.\A.w)) (v (\w.\A.A))&#xA;)) (t q (q (\v.\w.w) (\v.\w.v)) (u (\v.\w.v)) (u (\v.\w.w))))) (\u.\v.(k v (\w.(&#xA;w u r)))))) (\t.\u.(l (s t u) (s u t))))) (h o (o (\s.\t.t) (\s.\t.s))))))))) (k&#xA; g i)))))) (d (\e.\f.\g.(f (\h.\i.\j.(g (\k.\l.((\m.(h (k m (\n.\o.\p.o)) (k (\n&#xA;.\o.\p.p) m))) (e i l))))) (\h.\i.\j.h)))))) (\d.((\e.(d (e e))) (\e.(d (e e))))&#xA;))) ((\c.(y c (x c (\d.\e.e)))) (\c.\d.(d (\e.\f.e) c))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Shown here is a lambda calculus term featuring a RAM unit with 8 instructions including I/O and memory operations. With LambdaVM, you can write an assembly program that runs on this virtual machine.&lt;/p&gt; &#xA;&lt;p&gt;The image on the top of this repo is LambdaVM&#39;s &lt;a href=&#34;http://tromp.github.io/cl/diagrams.html&#34;&gt;lambda calculus diagram&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Various designs for LambdaVM are borrowed from &lt;a href=&#34;https://github.com/irori&#34;&gt;Kunihiko Sakamoto&lt;/a&gt;&#39;s &lt;a href=&#34;https://irori.hatenablog.com/entry/elvm-unlambda-part2&#34;&gt;UnlambdaVM&lt;/a&gt; (in Japanese), with many modifications. Details are described later.&lt;/p&gt; &#xA;&lt;p&gt;LambdaVM is built using &lt;a href=&#34;https://github.com/woodrush/lambdacraft&#34;&gt;LambdaCraft&lt;/a&gt;, a Common Lisp DSL that I wrote for building large lambda calculus programs, also used to build &lt;a href=&#34;https://github.com/woodrush/lambdalisp&#34;&gt;LambdaLisp&lt;/a&gt;, a Lisp interpreter implemented in untyped lambda calculus.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;h3&gt;Lambda Calculus as a Programming Language&lt;/h3&gt; &#xA;&lt;p&gt;Using LambdaVM, you can write lambda calculus programs in assembly style. But what does it mean to write programs in lambda calculus?&lt;/p&gt; &#xA;&lt;p&gt;Lambda calculus terms can be interpreted as programs, by interpreting it as a program that takes an input string and returns an output string. Characters and bytes are encoded as a list of bits with $0 = \lambda x. \lambda y.x$, $1 = \lambda x. \lambda y.y$, and lists are encoded in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding&#34;&gt;Scott encoding&lt;/a&gt; with ${\rm cons} = \lambda x.\lambda y.\lambda f.(f x y)$, ${\rm nil} = \lambda x.\lambda y.y$. This way, &lt;em&gt;everything&lt;/em&gt; in the computation process, even including integers, is expressed as pure lambda terms, without the need of introducing any non-lambda type object whatsoever.&lt;/p&gt; &#xA;&lt;p&gt;Various lambda calculus interpreters automatically handle this I/O format so that it runs on the terminal - standard input is encoded into lambda terms, and the output lambda term is decoded and shown on the terminal. Using these interpreters, lambda calculus programs can be run on the terminal just like any other terminal utility with I/O.&lt;/p&gt; &#xA;&lt;p&gt;A thorough explanation of programming in lambda calculus is described in &lt;a href=&#34;https://woodrush.github.io/blog/lambdalisp.html&#34;&gt;my blog post&lt;/a&gt; about &lt;a href=&#34;https://github.com/woodrush/lambdalisp&#34;&gt;LambdaLisp&lt;/a&gt;, a Lisp interpreter written as an untyped lambda calculus term.&lt;/p&gt; &#xA;&lt;h3&gt;Programming Languages Based on Lambda Calculus&lt;/h3&gt; &#xA;&lt;p&gt;There are various programming languages that use this I/O strategy. Examples are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tromp.github.io/cl/Binary_lambda_calculus.html&#34;&gt;Binary lambda calculus&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://esolangs.org/wiki/Universal_Lambda&#34;&gt;Universal Lambda&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tromp.github.io/cl/lazy-k.html&#34;&gt;Lazy K&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Seen as a programming language, these languages are purely functional languages with lazy evaluation. The &#34;purely&#34; part is emphasized even more than languages such as Haskell, since no primitive data types such as integers exist except for lambdas exist in these languages. Each of these languages have a different I/O encoding and a different notation for expressing lambda calculus terms. The I/O encoding can be absorbed by using a &lt;a href=&#34;https://github.com/woodrush/lambdavm/raw/main/src/blc-clamb-wrapper.cl&#34;&gt;wrapper&lt;/a&gt;, and the notation can be adapted by using a &lt;a href=&#34;https://github.com/woodrush/lambdacraft&#34;&gt;compiler&lt;/a&gt; to write lambdas in the expected format.&lt;/p&gt; &#xA;&lt;p&gt;Using LambdaVM, you can write programs for these languages. A FizzBuzz program written in LambdaVM assembly looks like &lt;a href=&#34;https://github.com/woodrush/lambdavm/raw/main/examples/fizzbuzz.cl&#34;&gt;./examples/fizzbuzz.cl&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Compiled programs can be run on the terminal using various interpreters, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SectorLambda, the &lt;a href=&#34;https://justine.lol/lambda/&#34;&gt;521-byte lambda calculus interpreter&lt;/a&gt; written by Justine Tunney&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://www.ioccc.org/&#34;&gt;IOCCC&lt;/a&gt; 2012 &lt;a href=&#34;https://www.ioccc.org/2012/tromp/hint.html&#34;&gt;&#34;Most functional&#34;&lt;/a&gt; interpreter written by John Tromp (the &lt;a href=&#34;https://www.ioccc.org/2012/tromp/tromp.c&#34;&gt;source&lt;/a&gt; is in the shape of a λ)&lt;/li&gt; &#xA; &lt;li&gt;Universal Lambda interpreter &lt;a href=&#34;https://github.com/irori/clamb&#34;&gt;clamb&lt;/a&gt; and Lazy K interpreter &lt;a href=&#34;https://github.com/irori/lazyk&#34;&gt;lazyk&lt;/a&gt; written by Kunihiko Sakamoto&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Compiling C to Lambda Calculus&lt;/h3&gt; &#xA;&lt;p&gt;I have integrated LambdaVM into ELVM to implement ELVM&#39;s lambda calculus backend. Using this backend, you can even compile interactive C code to LambdaVM&#39;s assembly. Since ELVM implements its &lt;a href=&#34;https://github.com/shinh/elvm/tree/master/libc&#34;&gt;own libc&lt;/a&gt;, you can even &lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt; and use library functions such as &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is entirely contained in the realm of the ELVM repository. Please see the documentation for ELVM for details. Instead of compiling C to assembly, you can enjoy hand-assembling programs for lambda calculus using the examples in this repository.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Instruction set: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;mov&lt;/code&gt; &lt;code&gt;load&lt;/code&gt; &lt;code&gt;store&lt;/code&gt; &lt;code&gt;addsub&lt;/code&gt; &lt;code&gt;cmp&lt;/code&gt; &lt;code&gt;jmpcmp&lt;/code&gt; &lt;code&gt;jmp&lt;/code&gt; &lt;code&gt;putchar&lt;/code&gt; &lt;code&gt;getchar&lt;/code&gt; &lt;code&gt;exit&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;The behavior of each instruction is mostly the same as ELVM. Please see &lt;a href=&#34;https://github.com/shinh/elvm/raw/master/ELVM.md&#34;&gt;elvm.md&lt;/a&gt; from the ELVM repo for details.&lt;/li&gt; &#xA;   &lt;li&gt;The lambda calculus data structure for each instruction is described later.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;ROM/RAM address size and word size: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Pre-configurable to an arbitrary integer&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;I/O bit size: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Pre-configurable to an arbitrary integer&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Registers: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Word size is pre-configurable to an arbitrary integer&lt;/li&gt; &#xA;   &lt;li&gt;Number of registers is arbitrarily pre-configurable&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Hand-Assembling Your Own LambdaVM Programs&lt;/h3&gt; &#xA;&lt;p&gt;You can hand-assemble your own LambdaVM programs using &lt;a href=&#34;https://github.com/woodrush/lambdacraft&#34;&gt;LambdaCraft&lt;/a&gt;, a Common Lisp DSL I wrote for building lambda calculus programs, also used to build &lt;a href=&#34;https://github.com/woodrush/lambdalisp&#34;&gt;LambdaLisp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/woodrush/lambdavm/tree/main/examples&#34;&gt;examples&lt;/a&gt; directory in this repo contains 3 example LambdaVM assembly programs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/woodrush/lambdavm/raw/main/examples/fizzbuzz.cl&#34;&gt;fizzbuzz.cl&lt;/a&gt;: Prints the FizzBuzz sequence in unary.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/woodrush/lambdavm/raw/main/examples/rot13.cl&#34;&gt;rot13.cl&lt;/a&gt;: Encodes/decodes standard input to/from the &lt;a href=&#34;https://en.wikipedia.org/wiki/ROT13&#34;&gt;ROT13&lt;/a&gt; cipher.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/woodrush/lambdavm/raw/main/examples/yes.cl&#34;&gt;yes.cl&lt;/a&gt;: The Unix &lt;code&gt;yes&lt;/code&gt; command, printing infinite lines of &lt;code&gt;y&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here is what the beginning of the assembly listing for rot13.cl looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(def-lazy asm (list&#xA;  ;; Initialization (PC == 0)&#xA;  (list&#xA;    ;; Store 26/2 = 13 at reg-B&#xA;    (mov reg-B &#34;N&#34;)&#xA;    (sub reg-B &#34;A&#34;)&#xA;  )&#xA;  ;; tag-main (PC == 1)&#xA;  (list&#xA;    (getc reg-A)&#xA;&#xA;    ;; Exit at EOF&#xA;    (jmpcmp reg-A == EOF -&amp;gt; tag-exit)&#xA;&#xA;    ;; &#34;a&#34; &amp;lt;= reg-A &amp;lt; &#34;n&#34; : add 13&#xA;    (mov reg-C reg-A)&#xA;    (cmp reg-C &amp;gt;= &#34;a&#34;)&#xA;    (mov reg-D reg-A)&#xA;    (cmp reg-D &amp;lt; &#34;n&#34;)&#xA;    (add reg-C reg-D)&#xA;    (jmpcmp reg-C == int-2 -&amp;gt; tag-plus13)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As shown here, the assembly is written as Common Lisp macros. These listings can be compiled by running *.cl on a Common Lisp interpreter such as SBCL.&lt;/p&gt; &#xA;&lt;p&gt;Since these programs are based on LambdaCraft and LambdaCraft runs on LambdaLisp, it is expected that these programs run on LambdaLisp as well, although it takes a lot of time compared to fast interpreters such as SBCL.&lt;/p&gt; &#xA;&lt;p&gt;Please use these example programs as a template for hand-assembling your own LambdaVM programs.&lt;/p&gt; &#xA;&lt;h2&gt;Specifications&lt;/h2&gt; &#xA;&lt;p&gt;LambdaVM is written as the following lambda calculus term:&lt;/p&gt; &#xA;&lt;p&gt;$$ {\rm LambdaVM} = \lambda.{\rm iobitsize} ~ \lambda.{\rm suppbitsize} ~ \lambda.{\rm proglist} ~ \lambda.{\rm memlist} ~ \lambda.{\rm stdin} ~ \cdots $$&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The first 2 arguments ${\rm iobitsize}$ and ${\rm suppbitsize}$ are configuration parameters specifying the CPU&#39;s I/O word size and RAM word size.&lt;/li&gt; &#xA; &lt;li&gt;${\rm proglist}$ represents the assembly listing to be executed.&lt;/li&gt; &#xA; &lt;li&gt;${\rm memlist}$ represents the memory initialization state. Unspecified memory regions are initialized to 0.&lt;/li&gt; &#xA; &lt;li&gt;${\rm stdin}$ is the input string provided by the interpreter.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By applying the first 4 arguments except ${\rm stdin}$ to ${\rm LambdaVM}$, the combined lambda term $({\rm LambdaVM} ~ {\rm iobitsize} ~ {\rm suppbitsize} ~ {\rm proglist} ~ {\rm memlist})$ behaves as a lambda calculus program that accepts a string ${\rm stdin}$, processes it, and returns some string.&lt;/p&gt; &#xA;&lt;h3&gt;Implementation Design&lt;/h3&gt; &#xA;&lt;p&gt;Various designs for LambdaVM are borrowed from &lt;a href=&#34;https://github.com/irori&#34;&gt;Kunihiko Sakamoto&lt;/a&gt;&#39;s &lt;a href=&#34;https://irori.hatenablog.com/entry/elvm-unlambda-part2&#34;&gt;UnlambdaVM&lt;/a&gt; (in Japanese):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using a binary tree structure to represent the RAM&lt;/li&gt; &#xA; &lt;li&gt;Using a list of lists of instructions to represent the program&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;LambdaVM has the following differences:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;While Unlambda is a strictly evaluated language, LambdaVM assumes a lazily evaluated language. While UnlambdaVM is written in direct style using function applications to mutate the VM&#39;s global state, LambdaVM is written using continuation-passing style to handle monadic I/O.&lt;/li&gt; &#xA; &lt;li&gt;The binary tree structure is modified so that an empty tree can be initialized with &lt;code&gt;nil = \x.\y.y&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Standard Input and Output&lt;/h3&gt; &#xA;&lt;p&gt;By loading the program and initialization configurations to LambdaVM, the resulting lambda calculus term $({\rm LambdaVM} ~ {\rm iobitsize} ~ {\rm suppbitsize} ~ {\rm proglist} ~ {\rm memlist})$ behaves as a function that accepts a string as an input and outputs a string.&lt;/p&gt; &#xA;&lt;p&gt;Here, characters and bytes are encoded as a list of bits with $0 = \lambda x. \lambda y.x$, $1 = \lambda x. \lambda y.y$, and lists are encoded in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding&#34;&gt;Scott encoding&lt;/a&gt; with ${\rm cons} = \lambda x.\lambda y.\lambda f.(f x y)$, ${\rm nil} = \lambda x.\lambda y.y$.&lt;/p&gt; &#xA;&lt;p&gt;The variable ${\rm stdin}$, the last argument of ${\rm LambdaVM}$, is expected to be provided by the interpreter in this format.&lt;/p&gt; &#xA;&lt;p&gt;Various lambda calculus languages use a slightly different I/O encoding, such as using &lt;a href=&#34;https://en.wikipedia.org/wiki/Church_encoding&#34;&gt;Church numerals&lt;/a&gt; to express each character. Such differences can be absorbed by using a &lt;a href=&#34;https://github.com/woodrush/lambdavm/raw/main/src/blc-clamb-wrapper.cl&#34;&gt;wrapper&lt;/a&gt; that adapts the program to its surrounding environment. This is discussed later in the &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdavm/main/#adaptation-to-different-languages&#34;&gt;Adaptation to Different Languages&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h3&gt;iobitsize and suppbitsize&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;iobitsize&lt;/code&gt; and &lt;code&gt;suppbitsize&lt;/code&gt; are integers encoded as lambda terms in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Church_encoding&#34;&gt;Church encoding&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;iobitsize&lt;/code&gt; specifies the number of bits used for the input string. In the &lt;a href=&#34;https://www.ioccc.org/&#34;&gt;IOCCC&lt;/a&gt; 2012 &lt;a href=&#34;https://www.ioccc.org/2012/tromp/hint.html&#34;&gt;&#34;Most functional&#34;&lt;/a&gt; interpreter, &lt;code&gt;iobitsize == 8&lt;/code&gt; since it uses 8 bits for encoding the I/O.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;suppbitsize&lt;/code&gt; represents the additional number of bits added to &lt;code&gt;iobitsize&lt;/code&gt; to make the machine&#39;s RAM and register word size. The word size becomes &lt;code&gt;iobitsize + suppbitsize&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In ELVM, the machine word size is 24 and the I/O bit size is 8, so &lt;code&gt;iobitsize&lt;/code&gt; and &lt;code&gt;suppbitsize&lt;/code&gt; are set to 8 and 16, respectively.&lt;/p&gt; &#xA;&lt;h3&gt;proglist&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;proglist&lt;/code&gt; is represented as a list of lists, where each sublist is a &lt;em&gt;tag&lt;/em&gt; containing a list of instructions. The instruction format is described later. The beginning of each list represents a tag that can be jumped to using the &lt;code&gt;jmp&lt;/code&gt; or &lt;code&gt;jmpcmp&lt;/code&gt; instructions. When the &lt;code&gt;jmp&lt;/code&gt; or &lt;code&gt;jmpcmp&lt;/code&gt; instruction is run, the program proceeds to the beginning of the specified tag.&lt;/p&gt; &#xA;&lt;h3&gt;memlist&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;memlist&lt;/code&gt; is represented as a list of N-bit unsigned integers with the machine&#39;s word size, where each integer is represented as a list of bits with $0 = \lambda x. \lambda y.x$ and $1 = \lambda x. \lambda y.y$. The elements of each list are assigned to contiguous RAM addresses startting from the address zero. The rest of the memory is initiliazed with the integer zero.&lt;/p&gt; &#xA;&lt;h2&gt;Instruction Structure&lt;/h2&gt; &#xA;&lt;p&gt;Each instruction ${\rm inst}$ is a 4-tuple containing 4 arguments:&lt;/p&gt; &#xA;&lt;p&gt;$$ {\rm inst} = {\rm cons4} ~ {\rm insttag} ~ {\rm srcisimm} ~ {\rm src} ~ {\rm opt} $$&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;${\rm cons4}$ is a 4-tuple constructor, ${\rm cons4} = \lambda x. \lambda y. \lambda z. \lambda w. \lambda f. (f x y z w)$.&lt;/li&gt; &#xA; &lt;li&gt;${\rm insttag}$ is an 8-tuple specifying the instruction.&lt;/li&gt; &#xA; &lt;li&gt;${\rm srcisimm}$ is a boolean of either ${\rm t} = \lambda x. \lambda y. y$ or ${\rm nil} = \lambda x. \lambda y. y$. It specifies whether if the following ${\rm src}$ is an immediate value or a register.&lt;/li&gt; &#xA; &lt;li&gt;${\rm src}$ is either an N-bit integer or a register address.&lt;/li&gt; &#xA; &lt;li&gt;${\rm opt}$ is an instruction-specific option with an instruction-specific data structure.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;insttag and opt&lt;/h3&gt; &#xA;&lt;p&gt;${\rm insttag}$ is used to specify the instruction type:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Instruction&lt;/th&gt; &#xA;   &lt;th&gt;${\rm insttag}$&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;mov&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda a. \lambda b. \lambda c. \lambda d. \lambda e. \lambda f. \lambda g. \lambda h. a$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;load&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda a. \lambda b. \lambda c. \lambda d. \lambda e. \lambda f. \lambda g. \lambda h. b$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;store&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda a. \lambda b. \lambda c. \lambda d. \lambda e. \lambda f. \lambda g. \lambda h. c$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;addsub&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda a. \lambda b. \lambda c. \lambda d. \lambda e. \lambda f. \lambda g. \lambda h. d$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda a. \lambda b. \lambda c. \lambda d. \lambda e. \lambda f. \lambda g. \lambda h. e$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;jmpcmp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda a. \lambda b. \lambda c. \lambda d. \lambda e. \lambda f. \lambda g. \lambda h. f$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;jmp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda a. \lambda b. \lambda c. \lambda d. \lambda e. \lambda f. \lambda g. \lambda h. g$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;io&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda a. \lambda b. \lambda c. \lambda d. \lambda e. \lambda f. \lambda g. \lambda h. h$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Instruction&lt;/th&gt; &#xA;   &lt;th&gt;${\rm opt}$&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;mov&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;${\rm dst}$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;load&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;${\rm dst}$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;store&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;${\rm dst}$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;addsub&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;${\rm cons} ~ {\rm dst} ~ {\rm isadd}$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;${\rm cons} ~ {\rm enumcmp} ~ {\rm dst}$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;jmpcmp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;${\rm cons4} ~ {\rm enumcmp} ~ {\rm jmpisimm} ~ {\rm jmp} ~ {\rm dst}$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;jmp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;(unused)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;io&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;${\rm enumio}$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Implementation in LambdaCraft&lt;/h3&gt; &#xA;&lt;p&gt;The examples under &lt;a href=&#34;https://github.com/woodrush/lambdavm/tree/main/examples&#34;&gt;./examples&lt;/a&gt; wrap this instruction structure as Lisp macros so that they can be written in an assembly-like notation. Macros are defined in &lt;a href=&#34;https://github.com/woodrush/lambdavm/raw/main/src/lambda-asm-header.cl&#34;&gt;./src/lambda-asm-header.cl&lt;/a&gt;. For further details on the instruction structure, please see this source.&lt;/p&gt; &#xA;&lt;h2&gt;Adaptation to Different Languages&lt;/h2&gt; &#xA;&lt;p&gt;As mentioned earlier, various lambda calculus languages use a slightly different I/O encoding, such as using &lt;a href=&#34;https://en.wikipedia.org/wiki/Church_encoding&#34;&gt;Church numerals&lt;/a&gt; to express each character. Such differences can be absorbed by using a &lt;a href=&#34;https://github.com/woodrush/lambdavm/raw/main/src/blc-clamb-wrapper.cl&#34;&gt;wrapper&lt;/a&gt; that adapts the program to its surrounding environment.&lt;/p&gt; &#xA;&lt;p&gt;To run a lambda program $F = \lambda s. {\rm code}$ that uses an I/O encoding of method A in a different environment that uses an I/O encoding B, you can wrap $F$ by writing a wrapper ${\rm AtoB}$ and ${\rm BtoA}$:&lt;/p&gt; &#xA;&lt;p&gt;$$ F&#39; = \lambda s. ({\rm AtoB} ~ (F ~ ({\rm BtoA} ~ s))) $$&lt;/p&gt; &#xA;&lt;p&gt;When $F&#39;$ is run in the environment B, the input string $s$ is first encoded in the method of B. However, $F$ expects strings to be encoded in method A. This difference in the input is first absorbed by the wrapper ${\rm BtoA}$ which translates $s$ to a format recognizable by $F$.&lt;/p&gt; &#xA;&lt;p&gt;After calculuations, $F$ outputs a string in the method A. However, this string is not recognizable by the surrounding environment B. This difference in the output is then absorbed by the wrapper ${\rm AtoB}$ so that the interpreter recognizes the output by $F$.&lt;/p&gt; &#xA;&lt;p&gt;Using this strategy, any program $F$ compiled in a lambda-like language A can easily be transplied to $F&#39;$ that runs on a different language B. The same holds for programs written using LambdaVM, making LambdaVM run in various lambda-based languages such as Binary Lambda Calculus, Universal Lambda, and Lazy K. The &lt;a href=&#34;https://github.com/woodrush/lambdavm/raw/main/src/blc-clamb-wrapper.cl&#34;&gt;wrapper&lt;/a&gt; used in LambdaVM is implemented exactly this way.&lt;/p&gt; &#xA;&lt;h2&gt;Implementation Details&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdavm/main/details.md&#34;&gt;details.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;LambdaVM was written by Hikaru Ikuta, inspired by &lt;a href=&#34;https://github.com/irori&#34;&gt;Kunihiko Sakamoto&lt;/a&gt;&#39;s &lt;a href=&#34;https://irori.hatenablog.com/entry/elvm-unlambda-part2&#34;&gt;UnlambdaVM&lt;/a&gt; (in Japanese). The instruction set for LambdaVM is based on and is extended from the &lt;a href=&#34;https://github.com/shinh/elvm&#34;&gt;ELVM&lt;/a&gt; architecture written by &lt;a href=&#34;https://github.com/shinh&#34;&gt;Shinichiro Hamaji&lt;/a&gt;. LambdaVM is written using &lt;a href=&#34;https://github.com/woodrush/lambdacraft&#34;&gt;LambdaCraft&lt;/a&gt; written by Hikaru Ikuta.&lt;/p&gt;</summary>
  </entry>
</feed>