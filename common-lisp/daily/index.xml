<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-15T01:35:48Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>anoma/zkp-compiler-shootout</title>
    <updated>2022-10-15T01:35:48Z</updated>
    <id>tag:github.com,2022-10-15:/anoma/zkp-compiler-shootout</id>
    <link href="https://github.com/anoma/zkp-compiler-shootout" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Evaluating &amp; benchmarking ZKP compilation strategies.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ZKP (circuit) compiler shootout&lt;/h1&gt; &#xA;&lt;p&gt;Evaluating &amp;amp; benchmarking ZKP compilation strategies.&lt;/p&gt; &#xA;&lt;p&gt;Currently we are testing the following Zero Knowledge machines&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/risc0/risc0&#34;&gt;RISC0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/maticnetwork/miden&#34;&gt;Miden&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ZK-Garage/plonk&#34;&gt;Plonk&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/zcash/halo2&#34;&gt;Halo2&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you would like your machine / framework / compilation strategy to be benchmarked against the standard suite, please submit a PR! You can find instructions below.&lt;/p&gt; &#xA;&lt;p&gt;Results can be seen in the following files:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/anoma/zkp-compiler-shootout/main/BENCHMARKS.md&#34;&gt;BENCHMARKS.md&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The results rendered in a mark down table&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://anoma.github.io/zkp-compiler-shootout/&#34;&gt;anoma.github.io/zkp-compiler-shootout/&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The results with graphs and standard deviations, means, etc.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The results were collected on a &lt;code&gt;AMD Ryzen 7 5700X 8-Core @ 16x 3.4GHz&lt;/code&gt; CPU.&lt;/p&gt; &#xA;&lt;p&gt;To see very rough notes about the languages in the benchmark and potential improvement points please read &lt;a href=&#34;https://raw.githubusercontent.com/anoma/zkp-compiler-shootout/main/shootout/notes.org&#34;&gt;my notes file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to get benchmark results&lt;/h2&gt; &#xA;&lt;p&gt;There are two commands for producing results&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;make table&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make bench&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;It is recommended to run &lt;code&gt;make table&lt;/code&gt;. However it requires two external dependencies&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo-criterion&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;criterion-table&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;these can both be installed with the following command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cargo install cargo-criterion&#xA;cargo install criterion-table&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure cargo packages are on your path.&lt;/p&gt; &#xA;&lt;p&gt;Either way, the results can be seen&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;run &lt;code&gt;make table&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;or &lt;code&gt;make bench&lt;/code&gt;, if one does not wish to install the cargo packages&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;sit back and watch your CPU spin&lt;/li&gt; &#xA; &lt;li&gt;The HTML results should be in &lt;code&gt;./shootout/target/criterion/reports/index.html&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;If &lt;code&gt;make table&lt;/code&gt; was run, the updated benchmark results should be seen in &lt;code&gt;./BENCHMARKS.md&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;This repository serves as a base for contributions and so contributions should hopefully be easy, and deficiencies on the implementations well known.&lt;/p&gt; &#xA;&lt;p&gt;Hopefully the process is rather straight forward, however we give a guide below to more quickly get familiar with the structure of the project.&lt;/p&gt; &#xA;&lt;p&gt;To get a quick &lt;code&gt;TL;DR&lt;/code&gt; feeling of this you could alternatively read how the &lt;code&gt;miden&lt;/code&gt; backend plugs in both in the &lt;code&gt;miden.rs&lt;/code&gt;, &lt;code&gt;main.rs&lt;/code&gt;, &lt;code&gt;bench.rs&lt;/code&gt;, and the &lt;code&gt;miden&lt;/code&gt; sub directory for project layout. That should hopefully be readable enough without having to read the full guide below.&lt;/p&gt; &#xA;&lt;h3&gt;Layout Structure: SRC&lt;/h3&gt; &#xA;&lt;p&gt;The project has two components of organization, the &lt;code&gt;shootout&lt;/code&gt; directory has an &lt;code&gt;src&lt;/code&gt; folder that hosts a file per backend. These files (&lt;code&gt;miden.rs&lt;/code&gt;, &lt;code&gt;risc.rs&lt;/code&gt;, etc.) are rather basic, just hosting an implementation of the given backend &lt;code&gt;struct&lt;/code&gt; that was created.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;.&#xA;├── Cargo.lock&#xA;├── Cargo.toml&#xA;├── src&#xA;│&amp;nbsp;&amp;nbsp; ├── bench.rs&#xA;│&amp;nbsp;&amp;nbsp; ├── halo.rs&#xA;│&amp;nbsp;&amp;nbsp; ├── main.rs&#xA;│&amp;nbsp;&amp;nbsp; ├── miden.rs&#xA;│&amp;nbsp;&amp;nbsp; ├── plonk.rs&#xA;│&amp;nbsp;&amp;nbsp; └── risc.rs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can see other files as well such as &lt;code&gt;bench.rs&lt;/code&gt; and &lt;code&gt;main.rs&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For creating a new backend to test, one will have to touch &lt;a href=&#34;https://raw.githubusercontent.com/anoma/zkp-compiler-shootout/main/shootout/src/bench.rs&#34;&gt;&lt;code&gt;bench.rs&lt;/code&gt;&lt;/a&gt; to have their new backend be tested. Since the code added is just a way to get around Rust&#39;s lack of typing of existentials this should be an easy task.&lt;/p&gt; &#xA;&lt;p&gt;Finally, in &lt;a href=&#34;https://raw.githubusercontent.com/anoma/zkp-compiler-shootout/main/shootout/src/main.rs&#34;&gt;&lt;code&gt;main.rs&lt;/code&gt;&lt;/a&gt; we hook up our tests to a certain benchmark we care about.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn bench_sudoku(c: &amp;amp;mut Criterion) {&#xA;    let to_bench = vec![&#xA;        ZKP::Miden(miden::sudoku()),&#xA;        ZKP::Plonk(plonk::sudoku()),&#xA;        ZKP::Risc0(risc::sudoku()),&#xA;        ZKP::Halo2(halo::sudoku()),&#xA;    ];&#xA;    bench_zkp(c, String::from(&#34;Sudoku&#34;), to_bench)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As we can see it&#39;s just adding the backend&#39;s struct to a vector list and wrapped with the enum found in &lt;code&gt;bench.rs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This structure should also make it easy to add new benchmark programs, please feel free to add new kinds of programs we wish to test here with whatever backend you are interested in! Hopefully others, including myself, can contribute to other backends for your test!&lt;/p&gt; &#xA;&lt;h3&gt;Layout Structure: sub directories&lt;/h3&gt; &#xA;&lt;p&gt;The layout structures of the other directories are as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;.&#xA;├── Cargo.lock&#xA;├── Cargo.toml&#xA;├── miden&#xA;├── notes.org&#xA;├── risc&#xA;├── sudoku-halo2&#xA;├── sudoku-plonk&#xA;└── zero-knowledge&#xA;    ├── Cargo.toml&#xA;    └── src&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The most important folder is &lt;code&gt;zero-knowledge&lt;/code&gt; as this has the trait needed to implement to have the benchmarker work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait ZeroKnowledge {&#xA;    type C;&#xA;    type R;&#xA;    fn name(&amp;amp;self) -&amp;gt; String;&#xA;    fn compile(&amp;amp;self) -&amp;gt; Self::C;&#xA;    fn prove(&amp;amp;self, setup: &amp;amp;Self::C) -&amp;gt; Self::R;&#xA;    fn verify(&amp;amp;self, receipt: Self::R, program: &amp;amp;Self::C) -&amp;gt; ();&#xA;    fn prove_and_verify(&amp;amp;self) -&amp;gt; () {&#xA;        let circuit = self.compile();&#xA;        let receipt = self.prove(&amp;amp;circuit);&#xA;        self.verify(receipt, &amp;amp;circuit);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here for a custom backend one just needs to implement &lt;code&gt;compile&lt;/code&gt;, &lt;code&gt;prove&lt;/code&gt;, &lt;code&gt;verify&lt;/code&gt;, and a &lt;code&gt;name&lt;/code&gt;, and your new zero knowledge backend can be tested!&lt;/p&gt; &#xA;&lt;p&gt;The other folders like &lt;code&gt;miden&lt;/code&gt; and &lt;code&gt;risc&lt;/code&gt;, represent stand alone backends. Adding a new program to benchmark or improve a current benchmark should be quite easy.&lt;/p&gt; &#xA;&lt;p&gt;the &lt;code&gt;sudoku-halo2&lt;/code&gt; and &lt;code&gt;sudoku-plonk&lt;/code&gt; are similar, but represent a single program/project style structure (In the future we will likely transform these to fit the mold of what &lt;code&gt;risc&lt;/code&gt; and &lt;code&gt;miden&lt;/code&gt; have).&lt;/p&gt; &#xA;&lt;p&gt;Lastly, the &lt;code&gt;notes.org&lt;/code&gt; file lays out notes about the backends and deficiencies in any particular implementation, hopefully over time all the programs will be optimal for their specific backend to have a more accurate and fair results.&lt;/p&gt; &#xA;&lt;h3&gt;Project Structure&lt;/h3&gt; &#xA;&lt;p&gt;For adding a new backend or adding new programs for backends like &lt;code&gt;halo2&lt;/code&gt; or &lt;code&gt;plonk&lt;/code&gt;. One may have to create a new sub directory.&lt;/p&gt; &#xA;&lt;p&gt;this can be done with &lt;code&gt;cargo new&lt;/code&gt;, or if you already have working code, just copy and paste your code into the directory! each of the sub-directories are standalone independent projects with their own &lt;code&gt;workspace&lt;/code&gt;. The only new dependency you&#39;ll have to add is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;[dependencies]&#xA;zero-knowledge = { path = &#34;../zero-knowledge&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and make sure the top level &lt;code&gt;Cargo.toml&lt;/code&gt; excludes the project and brings it in as a dependency.&lt;/p&gt; &#xA;&lt;p&gt;If you are importing existing code for a new backend, make sure you implement the &lt;code&gt;ZeroKnowledge&lt;/code&gt; trait, and you&#39;re all set!&lt;/p&gt; &#xA;&lt;p&gt;We will now talk about backend specific considerations, feel free to skip these if they aren&#39;t a backend you care about contributing to&lt;/p&gt; &#xA;&lt;h3&gt;Project Structure: Miden&lt;/h3&gt; &#xA;&lt;p&gt;The miden backend can be found in the &lt;code&gt;miden&lt;/code&gt; sub directory. Really one does not have to alter this code at all, just add your program to &lt;code&gt;src/miden.rs&lt;/code&gt; to mainly fill in the starting advice tape or the starting stack, along with the file path where the miden program is stored.&lt;/p&gt; &#xA;&lt;p&gt;Ι personally keep my miden code in &lt;a href=&#34;https://raw.githubusercontent.com/anoma/zkp-compiler-shootout/main/miden-assembler/miden&#34;&gt;miden-assembler&lt;/a&gt;, as Ι generate out miden code from my Common lisp DSL in &lt;a href=&#34;https://raw.githubusercontent.com/anoma/zkp-compiler-shootout/main/miden-assembler/src/programs.lisp&#34;&gt;programs&lt;/a&gt; sub directory. All one needs to run this code is &lt;a href=&#34;https://www.quicklisp.org/beta/&#34;&gt;quick-lisp&lt;/a&gt; and just write&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;; if you need to load the file by hand&#xA;;; I will assume the repl is in the miden-assembler directory&#xA;(load &#34;miden-assembler.asd&#34;)&#xA;;; load the project&#xA;(ql:quickload :miden-assembler)&#xA;;; switch to the project&#xA;(in-package :miden)&#xA;;; dump the code changes&#xA;(dump)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However you may keep it wherever you feel, just make sure path is properly given in the &lt;code&gt;miden.rs&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;the rest is just hooking up your new program to &lt;code&gt;main.rs&lt;/code&gt; which should be straight forward.&lt;/p&gt; &#xA;&lt;h3&gt;Project Structure: Risc0&lt;/h3&gt; &#xA;&lt;p&gt;Risc0 can compile straight rust code, which is nice, however this means the structure is a bit different from &lt;code&gt;miden&lt;/code&gt; or other ZKVMs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;.&#xA;├── Cargo.toml&#xA;├── methods&#xA;│&amp;nbsp;&amp;nbsp; ├── build.rs&#xA;│&amp;nbsp;&amp;nbsp; ├── Cargo.toml&#xA;│&amp;nbsp;&amp;nbsp; ├── guest&#xA;│&amp;nbsp;&amp;nbsp; └── src&#xA;├── README.md&#xA;├── src&#xA;│&amp;nbsp;&amp;nbsp; ├── lib.rs&#xA;│&amp;nbsp;&amp;nbsp; └── main.rs&#xA;├── sudoku-core&#xA;│&amp;nbsp;&amp;nbsp; ├── Cargo.toml&#xA;│&amp;nbsp;&amp;nbsp; └── src&#xA;└── target&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;the &lt;code&gt;src&lt;/code&gt; directory contains &lt;code&gt;lib.rs&lt;/code&gt; which you will only need to touch the imports from the &lt;code&gt;methods&lt;/code&gt; directory. the &lt;code&gt;Risc&lt;/code&gt; struct should be general enough to handle any program you wish to compile.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;.&#xA;├── build.rs&#xA;├── Cargo.toml&#xA;├── guest&#xA;│&amp;nbsp;&amp;nbsp; ├── build.rs&#xA;│&amp;nbsp;&amp;nbsp; ├── Cargo.lock&#xA;│&amp;nbsp;&amp;nbsp; ├── Cargo.toml&#xA;│&amp;nbsp;&amp;nbsp; ├── src&#xA;│&amp;nbsp;&amp;nbsp; │&amp;nbsp;&amp;nbsp; └── bin&#xA;│&amp;nbsp;&amp;nbsp; │&amp;nbsp;&amp;nbsp;     ├── fib_fifty.rs&#xA;│&amp;nbsp;&amp;nbsp; │&amp;nbsp;&amp;nbsp;     ├── fib_ninty_two.rs&#xA;│&amp;nbsp;&amp;nbsp; │&amp;nbsp;&amp;nbsp;     ├── fib.rs&#xA;│&amp;nbsp;&amp;nbsp; │&amp;nbsp;&amp;nbsp;     └── sudoku.rs&#xA;└── src&#xA;    └── lib.rs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;inside &lt;code&gt;methods&lt;/code&gt;, you should place your code in the &lt;code&gt;bin&lt;/code&gt; of &lt;code&gt;guest&lt;/code&gt;. As you can see the names of the current programs, these correspond to the imports in &lt;code&gt;lib.rs&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub use methods_fib::{FIB_ID,           FIB_PATH,&#xA;                      FIB_FIFTY_ID,     FIB_FIFTY_PATH,&#xA;                      FIB_NINTY_TWO_ID, FIB_NINTY_TWO_PATH,&#xA;                      SUDOKU_ID,        SUDOKU_PATH};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that any dependency you want to be compiled with these should be placed in the &lt;code&gt;Cargo.toml&lt;/code&gt; in the guest directory. This includes shared code like we have for &lt;code&gt;sudoku-core&lt;/code&gt;, which is linked both to the &lt;code&gt;guest&lt;/code&gt; and to the native rust code in &lt;code&gt;src&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Much like miden, all that is now required is to make the &lt;code&gt;Risc&lt;/code&gt; struct in &lt;code&gt;shootout/src/risc.rs&lt;/code&gt; for your new program and tell &lt;code&gt;main.rs&lt;/code&gt; to benchmark it!&lt;/p&gt; &#xA;&lt;h3&gt;Project Structure: Stand alone.&lt;/h3&gt; &#xA;&lt;p&gt;Hopefully &lt;code&gt;miden&lt;/code&gt; shows a good way to create standalone projects. So if one has existing &lt;code&gt;halo2&lt;/code&gt; or &lt;code&gt;plonk&lt;/code&gt; code, one could just copy and paste it into a directory and implement the &lt;code&gt;ZeroKnowledge&lt;/code&gt; trait. for their program.&lt;/p&gt; &#xA;&lt;h2&gt;Alucard/VAMP-IR&lt;/h2&gt; &#xA;&lt;p&gt;Please see the official &lt;a href=&#34;https://github.com/anoma/juvix-circuits&#34;&gt;Alucard repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Geb&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/anoma/geb&#34;&gt;Geb repository&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>