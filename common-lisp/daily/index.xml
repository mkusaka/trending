<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-21T01:31:45Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mark-watson/mistral</title>
    <updated>2024-01-21T01:31:45Z</updated>
    <id>tag:github.com,2024-01-21:/mark-watson/mistral</id>
    <link href="https://github.com/mark-watson/mistral" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mistral LLM API examples for my book &#34;Loving Common Lisp, or the Savvy Programmer&#39;s Secret Weapon&#34;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Common Lisp library to access Mistral LLM APIs&lt;/h1&gt; &#xA;&lt;p&gt;From my book URI: &lt;a href=&#34;https://leanpub.com/lovinglisp&#34;&gt;https://leanpub.com/lovinglisp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;There is a &lt;strong&gt;Makefile&lt;/strong&gt; in the repo &lt;a href=&#34;https://github.com/mark-watson/loving-common-lisp&#34;&gt;https://github.com/mark-watson/loving-common-lisp&lt;/a&gt; that can be copied to your &lt;strong&gt;~/quicklisp/local-projects&lt;/strong&gt; directory. Then in &lt;strong&gt;~/quicklisp/local-projects&lt;/strong&gt; run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make fetch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to get all of the library examples from my book.&lt;/p&gt; &#xA;&lt;h2&gt;setting your mistral API key&lt;/h2&gt; &#xA;&lt;p&gt;Define the &#34;MISTRAL_API_KEY&#34; environment variable with the value of your mistral API key&lt;/p&gt; &#xA;&lt;h2&gt;Example:&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;cl-user&amp;gt; (ql:quickload :mistral)&#xA;cl-user&amp;gt; (mistral:completions &#34;The President went to Congress&#34; 200)&#xA;&#34;When the President of a country goes to Congress, it typically means that they are making a formal address to a joint session of the legislative body. This is often done to present the State of the Union address, which outlines the administration&#39;s goals and priorities for the upcoming year. The President may also go to Congress to propose new legislation, rally support for existing bills, or address important national issues.&#xA;&#xA;During the address, members of Congress from both parties are usually present in the chamber, and they may respond with applause, standing ovations, or other forms of expression. The President&#39;s speech is typically broadcast live on television and radio, and it is covered extensively by the news media.&#xA;&#xA;The practice of the President going to Congress to deliver a State of the Union address dates back to the early years of the United States, when President George Washington gave the first such address in 1790. Since then, it has become a regular tradition for&#34;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>inconvergent/lqn</title>
    <updated>2024-01-21T01:31:45Z</updated>
    <id>tag:github.com,2024-01-21:/inconvergent/lqn</id>
    <link href="https://github.com/inconvergent/lqn" rel="alternate"></link>
    <summary type="html">&lt;p&gt;query language and terminal utility for querying and transforming Lisp, JSON and other text files. written in Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LQN - Lisp Query Notation&lt;/h1&gt; &#xA;&lt;p&gt;LQN is a compiler for a query language (DSL), with terminal utilities to query and transform LISP data (&lt;code&gt;LDN&lt;/code&gt;), JSON and TXT files. The terminal utilities will parse the input data to internal lisp strucutres according to the mode. Then the &lt;code&gt;lqn&lt;/code&gt; language can be used for queries and transformations.&lt;/p&gt; &#xA;&lt;p&gt;See this post for a small tutorial: &lt;a href=&#34;https://inconvergent.net/2024/lisp-query-notation/&#34;&gt;https://inconvergent.net/2024/lisp-query-notation/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;lqn&lt;/code&gt; consists of three terminal commands &lt;code&gt;lqn&lt;/code&gt;, &lt;code&gt;jqn&lt;/code&gt; and &lt;code&gt;tqn&lt;/code&gt;. Some examples below.&lt;/p&gt; &#xA;&lt;h2&gt;JQN Example (JSON)&lt;/h2&gt; &#xA;&lt;p&gt;Here is a full example where we select and transform some parts of a JSON object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;❭ echo &#39;&#xA;       [{ &#34;_id&#34;: &#34;65679&#34;, &#34;msg&#34;: &#34;HAI!&#34;,&#xA;          &#34;things&#34;: [{ &#34;id&#34;: 10, &#34;name&#34;: &#34;Win&#34;, &#34;extra&#34;: &#34;ex1&#34; },&#xA;                     { &#34;id&#34;: 12, &#34;name&#34;: &#34;Kle&#34; }] },&#xA;        { &#34;_id&#34;: &#34;6AABB&#34;, &#34;msg&#34;: &#34;NIH!&#34;,&#xA;          &#34;things&#34;: [{ &#34;id&#34;: 32, &#34;name&#34;: &#34;Bal&#34; },&#xA;                     { &#34;id&#34;: 31, &#34;name&#34;: &#34;Sta&#34;, &#34;extra&#34;: null}] }]&#39;\&#xA;  | jqn &#39;#{ :_id&#xA;         (:things #[:name :?@extra])&#xA;         (:msg (sup _))}&#39;&#xA;⇒ [{ &#34;_id&#34;: &#34;65679&#34;, &#34;msg&#34;: &#34;HAI!&#34;,&#xA;     &#34;things&#34;: [&#34;Win&#34;, &#34;ex1&#34;, &#34;Hai&#34;, &#34;ex2&#34;, &#34;Kle&#34;] },&#xA;   { &#34;_id&#34;: &#34;CAABB&#34;, &#34;msg&#34;: &#34;NIH!&#34;,&#xA;     &#34;things&#34;: [&#34;Sta&#34;, &#34;Bal&#34;] }]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In general &lt;code&gt;jqn&lt;/code&gt; can be used in the terminal like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;❭ jqn -h&#xA;⇒ Usage:&#xA;    jqn [options] &amp;lt;qry&amp;gt; [files ...]&#xA;    cat sample.json | jqn [options] &amp;lt;qry&amp;gt;&#xA;&#xA;  Options:&#xA;    -v prints the full compiled qry to stdout before the result&#xA;    -j output as JSON [default]&#xA;    -l output to readable lisp data (LDN)&#xA;    -t output as TXT&#xA;    -m minified json. indented is default.&#xA;    -h show this message.&#xA;&#xA;    options can be written as -i -v or -iv.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The other terminal commands have the same syntax and options. Below are some more examples of usage in the terminal.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/inconvergent/lqn/master/img/20180115-210522.png&#34; alt=&#34;asemic writing&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;TQN Example (TXT)&lt;/h2&gt; &#xA;&lt;p&gt;the &lt;code&gt;tqn&lt;/code&gt; mode is for reading lines of text into a &lt;code&gt;vector&lt;/code&gt; (i.e. JSON array). &lt;code&gt;tqn&lt;/code&gt; has slightly different default behaviour to &lt;code&gt;jqn&lt;/code&gt;. Notably, it ignores &lt;code&gt;nil&lt;/code&gt; in the output. &lt;code&gt;tqn&lt;/code&gt; defaults to printing the &lt;code&gt;vector&lt;/code&gt; as rows, but &lt;code&gt;-j&lt;/code&gt; will output to JSON instead. &lt;code&gt;-t&lt;/code&gt; does the oposite for &lt;code&gt;jqn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# split string and sum as integers:&#xA;❭ echo &#39;1 x 1 x 7 x 100&#39;\&#xA;  | tqn &#39;(splt _ :x) int!? (*fld 0 +)&#39;&#xA;⇒ 109&#xA;&#xA;# split string, search and replace:&#xA;❭ echo &#39;abk c x dkef x ttuuxx x ttxx33&#39;\&#xA;  | tqn &#39;(splt _ :x)&#xA;         (?txpr +@str!? :+@tt :+@uu&#xA;                 (str! _ :-hit))&#39;&#xA;⇒ abk c&#xA;  dkef&#xA;  ttuu-hit&#xA;  tt&#xA;  33&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;LQN Example (LDN)&lt;/h2&gt; &#xA;&lt;p&gt;You can also read CL code from pipe or file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# find small items, insert symbol, flatten&#xA;❭ echo &#39;#(1 2 3 4 5 6 7 8)&#39;\&#xA;  | lqn &#39;#((?txpr (&amp;lt; _ 3) (new* :xx _))) (flatall* _ t)&#39;&#xA;⇒ #(:XX 1 :XX 2 3 4 5 6 7 8)&#xA;&#xA;# or search for defmacro symbol in several source code files:&#xA;❭ lqn -t &#39;#((?srch (msym? _ defmacro)&#xA;                   (new$ :fn (fn) :hit (head* (itr) 3))))&#xA;          [is?] (flatall* _)&#39; src/*lisp&#xA;⇒ ((:FN . &#34;src/docs.lisp&#34;) (:HIT DEFMACRO PCKGS (PKG)))&#xA;  ((:FN . &#34;src/init.lisp&#34;) (:HIT DEFMACRO PRETTY-JSON (V)))&#xA;  ((:FN . &#34;src/qry.lisp&#34;) (:HIT DEFMACRO JSNQRYF (FN Q &amp;amp;KEY DB)))&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why??&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;lqn&lt;/code&gt; started as an experiment and programming exercise. But it has turned into a little language I think I will use in the future. Both in the terminal, and more interestingly, as a meta language for writing macros in CL.&lt;/p&gt; &#xA;&lt;p&gt;The main purpose of the design is to make something that is intuitive, terse, yet flexible enough that you can write generic CL if you need to. I also wanted to make something that requres a relatively simple compiler. I have written about similar approaches to making small DSLs in these blog posts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inconvergent.net/2023/vectors-and-symbols/&#34;&gt;https://inconvergent.net/2023/vectors-and-symbols/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inconvergent.net/2023/lets-write-a-dsl/&#34;&gt;https://inconvergent.net/2023/lets-write-a-dsl/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inconvergent.net/2023/a-vector-dsl/&#34;&gt;https://inconvergent.net/2023/a-vector-dsl/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are several parts of the design that i&#39;m not entirely happy with, so things might change in the future.&lt;/p&gt; &#xA;&lt;p&gt;You can find some more termianl documentation and examples in &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/lqn/master/lqn&#34;&gt;bin/lqn-sh.lisp&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/lqn/master/jqn&#34;&gt;bin/jqn-sh.lisp&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/lqn/master/tqn&#34;&gt;bin/tqn-sh.lisp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/lqn/master/docs/lqn.md&#34;&gt;docs/lqn.md&lt;/a&gt; for symbol documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Lisp Example&lt;/h2&gt; &#xA;&lt;p&gt;Using the &lt;code&gt;lqn&lt;/code&gt; compiler in lisp looks like this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(pretty-json&#xA;  (qry #(&#34;1 x 1 x 7 x 100&#34; &#34;3 x 8 x 30&#34;)&#xA;       #((splt _ :x) int!? ; for each row, split and parse as int&#xA;         ($new :num (num)  ; new nested dict for each row&#xA;               :items #(($new :v _ :i (cnt)))))))&#xA;⇒ [{ &#34;num&#34;: 4,&#xA;     &#34;items&#34;: [ { &#34;v&#34;: 1, &#34;i&#34;: 0 }, { &#34;v&#34;: 1, &#34;i&#34;: 1 },&#xA;                { &#34;v&#34;: 7, &#34;i&#34;: 2 }, { &#34;v&#34;: 100, &#34;i&#34;: 3 } ]},&#xA;   { &#34;num&#34;: 3,&#xA;     &#34;items&#34;: [ { &#34;v&#34;: 3, &#34;i&#34;: 0 }, { &#34;v&#34;: 8, &#34;i&#34;: 1 },&#xA;                { &#34;v&#34;: 30, &#34;i&#34;: 2 } ] }]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/inconvergent/lqn/master/bin/ex.lisp&#34;&gt;bin/ex.lisp&lt;/a&gt; for more examples.&lt;/p&gt; &#xA;&lt;h2&gt;Object Representation&lt;/h2&gt; &#xA;&lt;p&gt;Internally JSON arrays are represented as &lt;code&gt;vector&lt;/code&gt;. and JSON objects are represented as &lt;code&gt;hash-table&lt;/code&gt;; &lt;code&gt;kv&lt;/code&gt; (key/value) is used in the docs for short. In &lt;code&gt;tqn&lt;/code&gt; lines of text are &lt;code&gt;vectors&lt;/code&gt; of &lt;code&gt;strings&lt;/code&gt;. In &lt;code&gt;lqn&lt;/code&gt; Lisp files are read as a &lt;code&gt;vector&lt;/code&gt; of lisp data.&lt;/p&gt; &#xA;&lt;h2&gt;Operators&lt;/h2&gt; &#xA;&lt;p&gt;The following operators have special behaviour. You can also write generic CL code, anywhere you can use an operator. Including the functions further down. Note that you can use &lt;code&gt;_&lt;/code&gt; to refer to the current value.&lt;/p&gt; &#xA;&lt;p&gt;In the following sections &lt;code&gt;[d]&lt;/code&gt; represents an optional default value. E.g. if key/index is missing, or if a functon returns &lt;code&gt;nil&lt;/code&gt;. &lt;code&gt;k&lt;/code&gt; is an initial counter value. Whereas &lt;code&gt;..&lt;/code&gt; menans that there can be arbitrary arguments, &lt;code&gt;Selectors&lt;/code&gt; or &lt;code&gt;exprs&lt;/code&gt;; depending on the context. &lt;code&gt;expr&lt;/code&gt; denotes any expression or operator, like &lt;code&gt;(+ 1 _)&lt;/code&gt; or &lt;code&gt;#[:id]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Strings and :keywords&lt;/h3&gt; &#xA;&lt;p&gt;In operators, and many functions, &lt;code&gt;:keywords&lt;/code&gt; can be used to represent lowercase &lt;code&gt;strings&lt;/code&gt;. This is useful in the terminal to avoid escaping strings. Particularly when using &lt;code&gt;Selector&lt;/code&gt; operators.&lt;/p&gt; &#xA;&lt;h3&gt;Pipe Operator - &lt;code&gt;||&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;(|| expr ..)&lt;/code&gt; pipes the results from the first clause/expression into the second etc. Returns the result of the last clause. Pipe is the operator that surrounds all terminal queries by default.&lt;/p&gt; &#xA;&lt;p&gt;For convenience, particularly in the terminal, pipe has the following default translations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;fx&lt;/code&gt;: to &lt;code&gt;(*map (fx _))&lt;/code&gt;: map &lt;code&gt;fx&lt;/code&gt; across all items.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:word&lt;/code&gt;: to &lt;code&gt;[(isub? _ &#34;word&#34;)]&lt;/code&gt; to filter by &lt;code&gt;&#34;word&#34;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;Word&#34;&lt;/code&gt;: to &lt;code&gt;[(sub? _ &#34;Word&#34;)]&lt;/code&gt; to filter all items by this &lt;code&gt;string&lt;/code&gt; with case.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(..)&lt;/code&gt;: to itself. That is, expressions are not translated.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Map Operator - &lt;code&gt;#()&lt;/code&gt;/&lt;code&gt;*map&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Map operations over &lt;code&gt;vector&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;#(fx)&lt;/code&gt; or &lt;code&gt;(*map fx)&lt;/code&gt;: map &lt;code&gt;(fx _)&lt;/code&gt; across all items.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;#(expr ..)&lt;/code&gt; or &lt;code&gt;(*map expr ..)&lt;/code&gt;: evaluate these expressions sequentially on all items in &lt;code&gt;sequence&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Fold Operator - &lt;code&gt;*fld&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Reduce &lt;code&gt;vector&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(*fld init fx)&lt;/code&gt;: fold &lt;code&gt;(fx acc _)&lt;/code&gt; with &lt;code&gt;init&lt;/code&gt; as the first &lt;code&gt;acc&lt;/code&gt; value. &lt;code&gt;acc&lt;/code&gt; is inserted as the first argument to &lt;code&gt;fx&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(*fld init (fx .. _ ..))&lt;/code&gt;: fold &lt;code&gt;(fx acc .. _ ..)&lt;/code&gt;. The accumulator is inserted as the first argument to &lt;code&gt;fx&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(*fld init acc (fx .. acc .. nxt))&lt;/code&gt;: fold &lt;code&gt;(fx .. acc .. nxt)&lt;/code&gt;. Use this if you need to name the accumulator explicity.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Filter Operator - &lt;code&gt;*?&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Filter and map operations over &lt;code&gt;vector&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(*? test-expr [expr=test])&lt;/code&gt; new &lt;code&gt;vector&lt;/code&gt; where &lt;code&gt;expr&lt;/code&gt; has been evaluated for all items where &lt;code&gt;test-expr&lt;/code&gt; is not &lt;code&gt;nil&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Selector Operators - &lt;code&gt;{}&lt;/code&gt;/&lt;code&gt;$$&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;/&lt;code&gt;**&lt;/code&gt;, &lt;code&gt;#{}&lt;/code&gt;/&lt;code&gt;*$&lt;/code&gt;, &lt;code&gt;#[]&lt;/code&gt;/&lt;code&gt;$*&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Select from on structure into a new data structure. &lt;code&gt;Selectors&lt;/code&gt; are explained below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;#{s1 sel ..}&lt;/code&gt; or &lt;code&gt;(*$ sel ..)&lt;/code&gt;: from &lt;code&gt;vector&lt;/code&gt; of &lt;code&gt;kvs&lt;/code&gt; into new &lt;code&gt;vector&lt;/code&gt; of &lt;code&gt;kvs&lt;/code&gt; using &lt;code&gt;KV Selectors&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;#[s1 sel ..]&lt;/code&gt; or &lt;code&gt;($* sel ..)&lt;/code&gt;: from &lt;code&gt;vector&lt;/code&gt; of &lt;code&gt;kvs&lt;/code&gt; into new &lt;code&gt;vector&lt;/code&gt; using &lt;code&gt;KV Selectors&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt; {s1 sel ..}&lt;/code&gt; or &lt;code&gt;($$ sel ..)&lt;/code&gt;: from &lt;code&gt;kv&lt;/code&gt; into new &lt;code&gt;kv&lt;/code&gt; using &lt;code&gt;KV Selectors&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt; [s1 sel ..]&lt;/code&gt; or &lt;code&gt;(** sel ..)&lt;/code&gt;: from &lt;code&gt;vector&lt;/code&gt; into new &lt;code&gt;vector&lt;/code&gt; using &lt;code&gt;EXPR Selectors&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;select keys or indexes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(@ k)&lt;/code&gt;: get this key/index from current value.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(@ k [d])&lt;/code&gt;: get this key/index from current value.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(@ o k [d])&lt;/code&gt;: get this key/index from &lt;code&gt;o&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;KV Selectors&lt;/h4&gt; &#xA;&lt;p&gt;A &lt;code&gt;KV Selector&lt;/code&gt; is a triple &lt;code&gt;(mode key expr)&lt;/code&gt;. And are used in &lt;code&gt;{}&lt;/code&gt;, &lt;code&gt;#[]&lt;/code&gt; and &lt;code&gt;#{}&lt;/code&gt;. Only the key is required. If &lt;code&gt;expr&lt;/code&gt; is not provided the &lt;code&gt;expr&lt;/code&gt; is &lt;code&gt;_&lt;/code&gt;, that is: the value of the &lt;code&gt;key&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The modes are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;+&lt;/code&gt;: always include this &lt;code&gt;expr&lt;/code&gt;. [default]&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;?&lt;/code&gt;: include &lt;code&gt;expr&lt;/code&gt; if the key is present and not &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;%&lt;/code&gt;: include Selector if &lt;code&gt;expr&lt;/code&gt; is not &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-&lt;/code&gt;: drop this key in &lt;code&gt;#{}&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; operators; ignore Selector entirely in &lt;code&gt;#[]&lt;/code&gt; E.g. &lt;code&gt;{_ -@key3}&lt;/code&gt; to select all keys except &lt;code&gt;key3&lt;/code&gt;. &lt;code&gt;expr&lt;/code&gt; is ignored.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;KV Selectors&lt;/code&gt; can either be written out in full, or they can be be written in short form depending on what you want to achieve. Note that the &lt;code&gt;@&lt;/code&gt; in the following examples is used to append a mode to a key without having to wrap the Selector in parenthesis. If you need eg. case or spaces you can use &lt;code&gt;&#34;strings&#34;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;{_}               ; select all keys.&#xA;{_ :-@key1}       ; select all keys except &#34;key1&#34;.&#xA;{:key1 &#34;Key2&#34;}    ; select &#34;key1&#34; and &#34;Key2&#34;.&#xA;{:+@key}          ; same as :key [+ mode is default].&#xA;{&#34;+@Key&#34;}         ; select &#34;Key&#34;.&#xA;{:?@key }         ; select &#34;key&#34; if the value is not nil.&#xA;{(:%@key expr)}   ; select &#34;key&#34; if expr is not nil.&#xA;{(&#34;?@Key&#34; expr)}  ; select &#34;Key&#34; if the value is not nil.&#xA;{(&#34;%@Key&#34; expr)}  ; select &#34;Key&#34; if expr is not nil.&#xA;{(:+ &#34;Key&#34; expr)} ; same as (&#34;+@Key&#34; expr).&#xA;&#xA;; Use `_` in `expr` to refer to the value of the selected key:&#xA;{(:key1 sup))          ; convert value of &#34;key1&#34; to uppercase&#xA; (:key3 (or _ &#34;That&#34;)) ; select the value of &#34;key3&#34; or literally &#34;That&#34;.&#xA; (:key2 (+ 33 _))}     ; add 33 to value of &#34;key2&#34;&#xA;&#xA;; override and drop keys:&#xA;{_                ; select all keys, then override these:&#xA; (:key2 (sdwn _)) ; lowercase the value of &#34;key2&#34;&#xA;  :-@key3}        ; drop &#34;key3&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use &lt;code&gt;{}&lt;/code&gt; in the examples but all &lt;code&gt;KV Selectors&lt;/code&gt; have the same behaviour.&lt;/p&gt; &#xA;&lt;h4&gt;EXPR Selectors&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;EXPR Selectors&lt;/code&gt; serve a similar purpose as &lt;code&gt;KV Selectors&lt;/code&gt;, but they are used with &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;?srch&lt;/code&gt;, &lt;code&gt;?xpr&lt;/code&gt;, &lt;code&gt;?txpr&lt;/code&gt;, &lt;code&gt;?mxpr&lt;/code&gt; operators, and the modes behave a little differently:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;+&lt;/code&gt;: if there are multiple &lt;code&gt;Selectors&lt;/code&gt; with &lt;code&gt;+&lt;/code&gt; mode, requires ALL of them to be &lt;code&gt;t&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;?&lt;/code&gt;: if there are any clauses with &lt;code&gt;?&lt;/code&gt; mode, it will select items where either of these clauses is &lt;code&gt;t&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-&lt;/code&gt;: items that match any clause with &lt;code&gt;-&lt;/code&gt; mode will ALWAYS be ignored.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If this is not what you need, you can compose boolean expressions with regular CL boolen operators. Here are some examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;[:hello]               ; strings containing &#34;hello&#34;.&#xA;[:hi &#34;Hello&#34;]          ; strings containing either &#34;Hello&#34; or &#34;hi&#34;.&#xA;[:+@hi :+@hello]       ; strings containing &#34;hi&#34; and &#34;hello&#34;.&#xA;[:+@hi :+@hello &#34;OH&#34;]  ; strings containing (&#34;hi&#34; and &#34;hello&#34;) or &#34;OH&#34;.&#xA;[int!?]                ; items that can be parsed as int.&#xA;[(&amp;gt; _ 3)]              ; numbers larger than 3.&#xA;[_ :-@hi]              ; strings except those that contain &#34;hi&#34;.&#xA;[(+@pref? _ &#34;start&#34;)   ; strings that start with &#34;start&#34; and end with &#34;end&#34;.&#xA; (+@post? _ &#34;end&#34;)]&#xA;[(fx1 _)]              ; items where this expression is not nil.&#xA;[(or (fx1 _) (fx2 _))] ; ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Recursion Operator - &lt;code&gt;?rec&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Repeat the same expression while something is true:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(?rec test-expr expr)&lt;/code&gt;: repeat &lt;code&gt;expr&lt;/code&gt; while &lt;code&gt;test-expr&lt;/code&gt;. &lt;code&gt;_&lt;/code&gt; refers to the input value, then to the most recent evaluation of &lt;code&gt;expr&lt;/code&gt;. Use &lt;code&gt;(cnt)&lt;/code&gt; to get the number of the current iteration. &lt;code&gt;(par)&lt;/code&gt; always refers to the input value.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Transformer Operators - &lt;code&gt;?xpr&lt;/code&gt;, &lt;code&gt;?txpr&lt;/code&gt;, &lt;code&gt;?mxpr&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Perform operation on when pattern or condition is satisfied:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(?xpr sel)&lt;/code&gt;: match current value against &lt;code&gt;EXPR Selector&lt;/code&gt;. Return the result if not &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(?xpr sel hit-expr)&lt;/code&gt;: match current value against &lt;code&gt;EXPR Selector&lt;/code&gt;. Evaluates &lt;code&gt;hit-expr&lt;/code&gt; if not nil. &lt;code&gt;_&lt;/code&gt; is the matching item.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(?xpr sel .. hit-expr miss-expr)&lt;/code&gt;: match current value against &lt;code&gt;expr selectors&lt;/code&gt;. Evaluate &lt;code&gt;hit-expr&lt;/code&gt; if not &lt;code&gt;nil&lt;/code&gt;; else evaluate &lt;code&gt;miss-expr&lt;/code&gt;. &lt;code&gt;_&lt;/code&gt; is the matching item.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Recursively traverse a structure of &lt;code&gt;sequences&lt;/code&gt; and &lt;code&gt;kvs&lt;/code&gt; and return a new value for each match:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(?txpr sel .. tx-expr)&lt;/code&gt;: recursively traverse current value and replace matches with &lt;code&gt;tx-expr&lt;/code&gt;. &lt;code&gt;tx-expr&lt;/code&gt; can be a function name or expression. Also traverses vectors and &lt;code&gt;kv&lt;/code&gt; values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(?mxpr (sel .. tx-expr) .. (sel .. tx-expr))&lt;/code&gt;: one or more matches and transforms. Performs the transform of the first match only.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Search Operator - &lt;code&gt;?srch&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Iterate a datastructure (as if with &lt;code&gt;?txpr&lt;/code&gt;) and collect the matches in a new &lt;code&gt;vector&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(?srch sel)&lt;/code&gt;: collect &lt;code&gt;_&lt;/code&gt; whenever the &lt;code&gt;Selector&lt;/code&gt; matches.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(?srch sel .. expr)&lt;/code&gt;: collect &lt;code&gt;expr&lt;/code&gt; whenever the &lt;code&gt;Selector&lt;/code&gt; matches.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Query Utility Functions&lt;/h2&gt; &#xA;&lt;p&gt;The internal representation of in &lt;code&gt;lqn&lt;/code&gt; means you can use the regular CL utilities such as &lt;code&gt;gethash&lt;/code&gt;, &lt;code&gt;aref&lt;/code&gt;, &lt;code&gt;subseq&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt; etc. But for convenience there are some utility functions/macros in defined in &lt;code&gt;lqn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Global Query Context Fxs&lt;/h3&gt; &#xA;&lt;p&gt;Defined in the query scope:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(fi [k=0])&lt;/code&gt;: counts files from &lt;code&gt;k&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(fn)&lt;/code&gt;: name of the current file; or &lt;code&gt;&#34;:internal:&#34;&lt;/code&gt;, &lt;code&gt;&#34;pipe&#34;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(hld k v)&lt;/code&gt;: hold this value at this key in a key value store.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(ghv k [d])&lt;/code&gt;: get the value of this key; or &lt;code&gt;d&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(nope [d])&lt;/code&gt;: stop execution, return &lt;code&gt;d&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(err [msg])&lt;/code&gt;: raise &lt;code&gt;error&lt;/code&gt; with &lt;code&gt;msg&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(wrn [msg])&lt;/code&gt;: raise &lt;code&gt;warn&lt;/code&gt; with &lt;code&gt;msg&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Operator Context Fxs&lt;/h3&gt; &#xA;&lt;p&gt;Defined in all operators:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;_&lt;/code&gt;: the current value.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(itr)&lt;/code&gt;: the current object in the iteration of the enclosing &lt;code&gt;Selector&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(par)&lt;/code&gt;: the object containing &lt;code&gt;(itr)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(psize)&lt;/code&gt;: number of items in &lt;code&gt;(par)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(isize)&lt;/code&gt;: number of items in &lt;code&gt;(itr)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(cnt [k=0])&lt;/code&gt;: counts from &lt;code&gt;k&lt;/code&gt; in the enclosing &lt;code&gt;Selector&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Generic Utilities&lt;/h3&gt; &#xA;&lt;p&gt;General utilities:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(?? a expr [res=expr])&lt;/code&gt;: execute &lt;code&gt;expr&lt;/code&gt; only if &lt;code&gt;a&lt;/code&gt; is not &lt;code&gt;nil&lt;/code&gt;. if &lt;code&gt;expr&lt;/code&gt; is not nil it returns &lt;code&gt;expr&lt;/code&gt; or &lt;code&gt;res&lt;/code&gt;; otherwise &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(fmt f ..)&lt;/code&gt;: format &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;string&lt;/code&gt; with these (&lt;code&gt;format&lt;/code&gt;) args.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(fmt s)&lt;/code&gt;: get printed representation of &lt;code&gt;s&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(out f ..)&lt;/code&gt;: format &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;*standard-output*&lt;/code&gt; with these (&lt;code&gt;format&lt;/code&gt;) args. returns &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(out s)&lt;/code&gt;: output printed representation of &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;*standard-output*&lt;/code&gt;. returns &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(msym? a b)&lt;/code&gt;: compare &lt;code&gt;symbol&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;. if &lt;code&gt;b&lt;/code&gt; is a &lt;code&gt;keyword&lt;/code&gt; or &lt;code&gt;symbol&lt;/code&gt; a perfect match is required. if &lt;code&gt;b&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt; it performs a substring match. If &lt;code&gt;b&lt;/code&gt; is an expression, &lt;code&gt;a&lt;/code&gt; is compared to the evaluated value of &lt;code&gt;b&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(noop ..)&lt;/code&gt;: do nothing, return &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;KV / Strings / Vectors / Sequences&lt;/h3&gt; &#xA;&lt;p&gt;For all &lt;code&gt;sequences&lt;/code&gt; and &lt;code&gt;kvs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(@* o d i ..)&lt;/code&gt;: pick these indices/keys from &lt;code&gt;sequence&lt;/code&gt;/&lt;code&gt;kv&lt;/code&gt; into new &lt;code&gt;vector&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(size? o [d])&lt;/code&gt;: length of &lt;code&gt;sequence&lt;/code&gt; or number of keys in &lt;code&gt;kv&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(compct o)&lt;/code&gt;: Remove &lt;code&gt;nil&lt;/code&gt;, empty &lt;code&gt;vectors&lt;/code&gt;, empty &lt;code&gt;kvs&lt;/code&gt; and keys with empty &lt;code&gt;kvs&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Make or join &lt;code&gt;kvs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(cat$ ..)&lt;/code&gt;: add all keys from these &lt;code&gt;kvs&lt;/code&gt; to a new &lt;code&gt;kv&lt;/code&gt;. left to right.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(new$ :k1 expr1 ..)&lt;/code&gt;: new &lt;code&gt;kv&lt;/code&gt; with these keys and expressions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Primarily for &lt;code&gt;sequences&lt;/code&gt; (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(new* ..)&lt;/code&gt;: new &lt;code&gt;vector&lt;/code&gt; with these elements.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(ind* s i)&lt;/code&gt;: get this index from &lt;code&gt;sequence&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(sel* ..)&lt;/code&gt;: get new &lt;code&gt;vector&lt;/code&gt; with these &lt;code&gt;ind*s&lt;/code&gt; or &lt;code&gt;seq*s&lt;/code&gt; from &lt;code&gt;sequence&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(seq* v i [j])&lt;/code&gt;: get range &lt;code&gt;i ..&lt;/code&gt; or &lt;code&gt;i .. (1- j)&lt;/code&gt; from &lt;code&gt;sequence&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(head* s [n=10])&lt;/code&gt;: first &lt;code&gt;n&lt;/code&gt; items of &lt;code&gt;sequence&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(tail* s [n=10])&lt;/code&gt;: last &lt;code&gt;n&lt;/code&gt; items of &lt;code&gt;sequence&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(cat* s ..)&lt;/code&gt;: concatenate these &lt;code&gt;sequences&lt;/code&gt; to a &lt;code&gt;vector&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(flatn* s [n=1] [str=nil])&lt;/code&gt;: flatten &lt;code&gt;sequence&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; times into a &lt;code&gt;vector&lt;/code&gt;. if &lt;code&gt;str=t&lt;/code&gt; strings are flattened into individual chars as well.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(flatall* s [str=nil])&lt;/code&gt;: flatten all &lt;code&gt;sequences&lt;/code&gt; (except &lt;code&gt;strings&lt;/code&gt;) into new &lt;code&gt;vector&lt;/code&gt;. Use &lt;code&gt;t&lt;/code&gt; as the second argument to flatten &lt;code&gt;strings&lt;/code&gt; to individual chars as well.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(flatn$ s n)&lt;/code&gt;: flatten &lt;code&gt;kv&lt;/code&gt; into vector &lt;code&gt;(new* k0 v0 k1 v1 ..)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Primarily for &lt;code&gt;string&lt;/code&gt; searching. &lt;code&gt;[i]&lt;/code&gt; means case insensitive:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;([i]pref? s pref [d])&lt;/code&gt;: &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;pref&lt;/code&gt; is a prefix of &lt;code&gt;s&lt;/code&gt;; or &lt;code&gt;d&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;([i]sub? s sub [d])&lt;/code&gt;: &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;sub&lt;/code&gt; is a substring of &lt;code&gt;s&lt;/code&gt;; or &lt;code&gt;d&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;([i]subx? s sub)&lt;/code&gt;: index where &lt;code&gt;sub&lt;/code&gt; starts in &lt;code&gt;s&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;([i]suf? s suf [d])&lt;/code&gt;: &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;suf&lt;/code&gt; is a suffix of &lt;code&gt;s&lt;/code&gt;; or &lt;code&gt;d&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(repl s from to)&lt;/code&gt;: replace &lt;code&gt;from&lt;/code&gt; with &lt;code&gt;to&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;String maniuplation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(sup s ..)&lt;/code&gt;: &lt;code&gt;str!&lt;/code&gt; and upcase.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(sdwn s ..)&lt;/code&gt;: &lt;code&gt;str!&lt;/code&gt; and downcase.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(trim s)&lt;/code&gt;: trim leading and trailing whitespace from &lt;code&gt;string&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(splt s x [trim=t] [prune=nil])&lt;/code&gt;: split &lt;code&gt;s&lt;/code&gt; at all &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;vector&lt;/code&gt; of &lt;code&gt;strings&lt;/code&gt;. &lt;code&gt;trim&lt;/code&gt; removes whitespace. &lt;code&gt;prune&lt;/code&gt; drops empty strings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(join s x ..)&lt;/code&gt;: join sequence with &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;strings&lt;/code&gt; or &lt;code&gt;chars&lt;/code&gt;), returns &lt;code&gt;string&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(strcat s ..)&lt;/code&gt;: concatenate these &lt;code&gt;strings&lt;/code&gt;, or all &lt;code&gt;strings&lt;/code&gt; in one or more &lt;code&gt;sequences&lt;/code&gt; of &lt;code&gt;strings&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Type Tests&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;(is? o [d])&lt;/code&gt; returns &lt;code&gt;o&lt;/code&gt; if not &lt;code&gt;nil&lt;/code&gt;, empty &lt;code&gt;sequence&lt;/code&gt;, or empty &lt;code&gt;kv&lt;/code&gt;; or &lt;code&gt;d&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;These functions return the argument if the argument is the corresponding type: &lt;code&gt;flt?&lt;/code&gt;, &lt;code&gt;int?&lt;/code&gt;, &lt;code&gt;kv?&lt;/code&gt;, &lt;code&gt;lst?&lt;/code&gt;, &lt;code&gt;num?&lt;/code&gt;, &lt;code&gt;str?&lt;/code&gt;, &lt;code&gt;vec?&lt;/code&gt;, &lt;code&gt;seq?&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;These functions return the argument parsed as the corresponding type if possible; otherwise they return the optional second argument: &lt;code&gt;int!?&lt;/code&gt;, &lt;code&gt;flt!?&lt;/code&gt;, &lt;code&gt;num!?&lt;/code&gt;, &lt;code&gt;str!?&lt;/code&gt;, &lt;code&gt;vec!?&lt;/code&gt;, &lt;code&gt;seq!?&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Type Coercion&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(str! s ..)&lt;/code&gt;: coerce everything to a &lt;code&gt;string&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(vec! a)&lt;/code&gt;: coerce &lt;code&gt;sequence&lt;/code&gt; to &lt;code&gt;vector&lt;/code&gt;; or return &lt;code&gt;(new* a)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(sym! a ..)&lt;/code&gt;: do &lt;code&gt;str!&lt;/code&gt;, &lt;code&gt;sdwn&lt;/code&gt;, and make new &lt;code&gt;symbol&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;lqn&lt;/code&gt; requires &lt;a href=&#34;https://www.sbcl.org/&#34;&gt;SBCL&lt;/a&gt;. And is pretty easy to install via &lt;code&gt;quicklisp&lt;/code&gt;. SBCL is available in most package managers. And you can get quicklisp at &lt;a href=&#34;https://www.quicklisp.org/beta/&#34;&gt;https://www.quicklisp.org/beta/&lt;/a&gt;. Make sure &lt;code&gt;lqn&lt;/code&gt; is available in your &lt;code&gt;quicklisp&lt;/code&gt; &lt;code&gt;local-projects&lt;/code&gt; folder. Mine is at &lt;code&gt;~/quicklisp/local-projects/&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Then create an alias for SBCL to execute shell wrappers e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;alias jqn=&#34;sbcl --script ~/path/to/lqn/bin/jqn-sh.lisp&#34;&#xA;alias tqn=&#34;sbcl --script ~/path/to/lqn/bin/tqn-sh.lisp&#34;&#xA;alias lqn=&#34;sbcl --script ~/path/to/lqn/bin/lqn-sh.lisp&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unfortunately this will tend to have a high startup tim. To make it run faster you can create an SBCL image/core that has &lt;code&gt;lqn&lt;/code&gt; preloaded and dump it using &lt;code&gt;sb-ext:save-lisp-and-die&lt;/code&gt;. Then use the core in the alias instead of SBCL.&lt;/p&gt; &#xA;&lt;p&gt;Below is an example script for creating your own core. You can also preload your own libraries which will be available to &lt;code&gt;lqn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash&#xA;sbcl --quit \&#xA;     --eval &#39;(ql:quickload :sb-introspect)&#39;\&#xA;     --eval &#39;(load &#34;/path/to/quicklisp/setup.lisp&#34;)&#39;\&#xA;     --eval &#39;(ql:quickload :lqn)&#39;\ # add more evals to load your own pkg&#xA;     --eval &#39;(save-lisp-and-die &#34;/path/to/lsp.core&#34;&#xA;               :executable t :compression nil&#xA;               :purify t     :save-runtime-options t)&#39;&#xA;&#xA;# Then make aliases like this:&#xA;alias lqn=&#34;/path/to/lsp.core --script ~/path/to/lqn/bin/lqn-sh.lisp&#34;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>