<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-07T01:33:12Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fosskers/cl-transducers</title>
    <updated>2023-03-07T01:33:12Z</updated>
    <id>tag:github.com,2023-03-07:/fosskers/cl-transducers</id>
    <link href="https://github.com/fosskers/cl-transducers" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Transducers: Ergonomic, efficient data processing&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: Transducers: Ergonomic, efficient data processing&lt;/p&gt; &#xA;&lt;p&gt;#+begin_quote I think Transducers are a fundamental primitive that decouples critical logic from list/sequence processing, and if I had to do Clojure all over I would put them at the bottom.&lt;/p&gt; &#xA;&lt;p&gt;-- Rich Hickey #+end_quote&lt;/p&gt; &#xA;&lt;p&gt;Transducers are an ergonomic and extremely memory-efficient way to process a data source. Here &#34;data source&#34; means simple collections like Lists or Vectors, but also potentially large files or generators of infinite data.&lt;/p&gt; &#xA;&lt;p&gt;Transducers...&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;allow the chaining of operations like =map= and =filter= without allocating memory between each step.&lt;/li&gt; &#xA; &lt;li&gt;aren&#39;t tied to any specific data type; they need only be implemented once.&lt;/li&gt; &#xA; &lt;li&gt;vastly simplify &#34;data transformation code&#34;.&lt;/li&gt; &#xA; &lt;li&gt;are a joy to use!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example: /While skipping every second line of a file, sum the lengths of only evenly-lengthed lines./&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (transduce ;; How do we want to process each element? (comp (step 2) (map #&#39;length) (filter #&#39;evenp)) ;; How do we want to combine all the elements together? #&#39;+ ;; What&#39;s our original data source? #p&#34;giant-file.txt&#34;) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Table of Contents :toc_2_gh:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[#history-and-motivation][History and Motivation]]&lt;/li&gt; &#xA; &lt;li&gt;[[#installation][Installation]]&lt;/li&gt; &#xA; &lt;li&gt;[[#usage][Usage]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#importing][Importing]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#transducers-reducers-and-sources][Transducers, Reducers, and Sources]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#using-the-fold-reducer][Using the =fold= Reducer]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#processing-json-data][Processing JSON Data]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#api-and-compatibility-charts][API and Compatibility Charts]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#transducers][Transducers]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#higher-order-transducers][Higher-order Transducers]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#reducers][Reducers]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#generators][Generators]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#data-sources][Data Sources]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#example-gallery][Example Gallery]] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;[[#words-in-a-file][Words in a File]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#sieve-of-eratosthenes][Sieve of Eratosthenes]]&lt;/li&gt; &#xA;   &lt;li&gt;[[#json-calculating-average-age][JSON: Calculating average age]]&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;[[#limitations][Limitations]]&lt;/li&gt; &#xA; &lt;li&gt;[[#further-work][Further Work]]&lt;/li&gt; &#xA; &lt;li&gt;[[#resources][Resources]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;History and Motivation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Originally invented in Clojure and adapted to Scheme as SRFI-171, Transducers are an excellent way to think about - and efficiently operate on - collections or streams of data. Transduction operations are strict and don&#39;t involve &#34;laziness&#34; or &#34;thunking&#34; in any way, yet only process the exact amount of data you ask them to.&lt;/p&gt; &#xA;&lt;p&gt;This library draws inspiration from both the original Clojure and SRFI-171, while adding many other convenient operations commonly found in other languages. It is, in general, the most complete implementation of the Transducer pattern.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This library is available on [[https://ultralisp.org/projects/fosskers/cl-transducers][Ultralisp]]. With [[https://ultralisp.org/][Ultralisp installed as a distribution]], you can simply run the following to download the main system:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (ql:quickload :transducers) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;For the JSON extensions:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (ql:quickload :transducers-jzon) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Importing&lt;/p&gt; &#xA;&lt;p&gt;Since this library reuses some symbol names also found in =:cl=, it is expected that you import =transducers= as follows in your =defpackage=:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (:local-nicknames (#:t #:transducers)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can then make relatively clean calls like:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (t:transduce (t:map #&#39;1+) #&#39;t:vector &#39;(1 2 3)) ;; =&amp;gt; #(2 3 4) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Transducers, Reducers, and Sources&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp ;; The fundamental pattern. (t:transduce &#xA; &lt;transducer-chain&gt; &#xA;  &lt;reducer&gt; &#xA;   &lt;source&gt;) #+end_src&#xA;  &lt;/reducer&gt;&#xA; &lt;/transducer-chain&gt;&lt;/p&gt; &#xA;&lt;p&gt;Data processing largely has three concerns:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Where is my data coming from? (sources)&lt;/li&gt; &#xA; &lt;li&gt;What do I want to do to each element? (transducers)&lt;/li&gt; &#xA; &lt;li&gt;How do I want to collect the results? (reducers)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Each full &#34;transduction&#34; requires all three. We pass one of each to the =transduce= function, which drives the process. It knows how to pull values from the source, feed them through the transducer chain, and wrap everything together via the reducer.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Typical transducers are =map=, =filter=, and =take=.&lt;/li&gt; &#xA; &lt;li&gt;Typical reducers are =+=, =count=, and =fold=.&lt;/li&gt; &#xA; &lt;li&gt;Typical sources are lists, vectors, strings, hash tables, and files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;/Generators/ are a special kind of source that yield infinite data. Typical generators are =repeat=, =cycle=, and =ints=.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s sum the squares of the first 1000 odd integers:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (t:transduce (t:comp (t:filter #&#39;oddp) ;; (2) Keep only odd numbers. (t:take 1000) ;; (3) Keep the first 1000 filtered odds. (t:map (lambda (n) (* n n)))) ;; (4) Square those 1000. #&#39;+ ;; (5) Reducer: Add up all the squares. (t:ints 1)) ;; (1) Source: Generate all positive integers. ;; =&amp;gt; 1333333000 (31 bits, #x4F790C08) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Two things of note here:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;=comp= is used here to chain together different transducer steps. Notice that the order appears &#34;backwards&#34; from usual function composition. It may help to image that =comp= is acting like the =-&amp;gt;&amp;gt;= macro here. =comp= is supplied here as a convenience; you&#39;re free to use =alexandria:compose= if you wish.&lt;/li&gt; &#xA; &lt;li&gt;The reduction via =+= is listed as Step 5, but really it&#39;s occuring throughout the transduction process. Each value that makes it through the composed transducer chain is immediately added to an internal accumulator.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Explore the other transducers and reducers to see what&#39;s possible! You&#39;ll never write a =loop= again.&lt;/p&gt; &#xA;&lt;p&gt;** Using the =fold= Reducer&lt;/p&gt; &#xA;&lt;p&gt;=fold= is the ultimate reducer, and thus deserves special attention. =fold= creates an ad-hoc reducer based on a given 2-argument function. A SEED is also required as the initial accumulator value, which also becomes the return value in case there were no input left in the transduction.&lt;/p&gt; &#xA;&lt;p&gt;The normal CL functions =+= and =*= are automatically valid reducers, because they yield sane values even when given 0 or 1 arguments. Other functions like =max= cannot be used as-is as reducers since they require at least 2 arguments. For functions like this, =fold= is appropriate.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp ;; The length of the longest word in this README. (let ((xf (t:comp (t:map #&#39;str:words) #&#39;t:concatenate (t:filter (lambda (w) (every #&#39;alpha-char-p w))) (t:map #&#39;length)))) (t:transduce xf (t:fold #&#39;cl:max 0) #p&#34;README.org&#34;)) ;; =&amp;gt; 14 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Processing JSON Data&lt;/p&gt; &#xA;&lt;p&gt;The system =transducers-jzon= provides automatic JSON streaming support via the [[https://github.com/Zulu-Inuoe/jzon][jzon]] library. Like =transducers= itself, it is expected that you import this system with a nickname:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (:local-nicknames (#:j #:transducers-jzon)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Only two functions are exposed: =read= and =write=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=read= is a /source/ that accepts a pathname, open stream, or a string. It produces parsed JSON values as Lisp types. JSON Objects become Hash Tables.&lt;/li&gt; &#xA; &lt;li&gt;=write= is a /reducer/ that expects an open stream. It writes the stream of Lisp types into their logical JSON equivalents.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here is a simple example of reading some JSON data from a string, doing nothing to it, and outputting it again to a new string:&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (with-output-to-string (stream) (t:transduce #&#39;t:pass (j:write stream) (j:read &#34;[{&#34;name&#34;: &#34;A&#34;}, {&#34;name&#34;: &#34;B&#34;}]&#34;))) ;; =&amp;gt; &#34;[{&#34;name&#34;:&#34;A&#34;},{&#34;name&#34;:&#34;B&#34;}]&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Note that the JSON data &lt;em&gt;must&lt;/em&gt; be a JSON array. There is otherwise no size limit; the library can handle any amount of JSON input.&lt;/p&gt; &#xA;&lt;p&gt;For more examples, see the Gallery below.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;API and Compatibility Charts&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This library offers the most complete implementation of the Transducer pattern across a number of languages.&lt;/p&gt; &#xA;&lt;p&gt;** Transducers&lt;/p&gt; &#xA;&lt;p&gt;| | CL =transducers= | =loop= macro | Clojure | Scheme | Rust | Haskell | |---------------+----------------+--------------------+---------------+--------------+--------------+----------| | =pass= | ✓ | | =map identity= | =map identity= | Just =collect= | =map id= | | =map= | ✓ | =for x being the...= | ✓ | ✓ | ✓ | ✓ | | =filter= | ✓ | =if= / =when= | ✓ | ✓ | ✓ | ✓ | | =filter-map= | ✓ | | =keep= | | ✓ | =mapMaybe= | | =remove= | | =unless= | ✓ | | | | | =unique= | ✓ | | =distinct= | ✓ | | =nub= | | =dedup= | ✓ | | =dedupe= | ✓ | | | | =drop= | ✓ | | ✓ | ✓ | ✓ | ✓ | | =drop-while= | ✓ | | ✓ | ✓ | ✓ | ✓ | | =take= | ✓ | | ✓ | ✓ | ✓ | ✓ | | =take-while= | ✓ | =while= etc. | ✓ | ✓ | ✓ | ✓ | | =replace= | | | ✓ | ✓ | | | | Flat Map | | | =mapcat= | =tappend-map= | =flat_map= | &lt;del&gt;&amp;gt;&amp;gt;=&lt;/del&gt; | | =concatenate= | ✓ | | =cat= | ✓ | =flatten= | =join= | | =flatten= | ✓ | | | ✓ | | | | =segment= | ✓ | | =partition-all= | ✓ | | | | =window= | ✓ | | | | =chunks= | | | =group-by= | ✓ | | =partition-by= | | | ✓ | | =intersperse= | ✓ | | =interpose= | ✓ | ✓ | ✓ | | =enumerate= | ✓ | | =map-indexed= | ✓ | ✓ | | | =step= | ✓ | =by= | =take-nth= | | | | | =scan= | ✓ | | | | | ✓ | | =random-sample= | | | ✓ | | | | | =log= | ✓ | Print in loop body | | ✓ | =trace= | |&lt;/p&gt; &#xA;&lt;p&gt;** Higher-order Transducers&lt;/p&gt; &#xA;&lt;p&gt;Transducers which can alter the transduction chain itself during runtime.&lt;/p&gt; &#xA;&lt;p&gt;| | CL =transducers= | =loop= macro | Clojure | Scheme | Rust | Haskell | |--------+----------------+------------+---------+--------+------+---------| | =branch= | ✓ | | | | | | | =inject= | ✓ | | | | | | | =split= | ✓ | | | | | | | =zip= | | ✓ | | | ✓ | ✓ |&lt;/p&gt; &#xA;&lt;p&gt;** Reducers&lt;/p&gt; &#xA;&lt;p&gt;| | CL =transducers= | =loop= macro | Clojure | Scheme | Rust | Haskell | |-------------+----------------+-------------+---------+--------+------+---------| | Into List | ✓ | =collect= | =into= | ✓ | ✓ | ✓ | | Into Vector | ✓ | =vconcat= | =into= | | ✓ | ✓ | | Into String | ✓ | =concat= | | | ✓ | ✓ | | Into Map | | | =into= | | ✓ | ✓ | | =count= | ✓ | ✓ | | ✓ | ✓ | ✓ | | =average= | ✓ | | | | | | | =any= | ✓ | | | ✓ | ✓ | ✓ | | =all= | ✓ | | | ✓ | ✓ | ✓ | | =first= | ✓ | &lt;del&gt;return&lt;/del&gt; etc. | | | ✓ | ✓ | | =last= | ✓ | | | | ✓ | ✓ | | =fold= | ✓ | | | | ✓ | ✓ | | =max= | ✓ | =maximize= | | | ✓ | ✓ | | =min= | ✓ | =minimize= | | | ✓ | ✓ | | =find= | ✓ | &lt;del&gt;return&lt;/del&gt; etc. | | | ✓ | |&lt;/p&gt; &#xA;&lt;p&gt;Why oh why is it so difficult to find an implementation of =average= in many languages?&lt;/p&gt; &#xA;&lt;p&gt;** Generators&lt;/p&gt; &#xA;&lt;p&gt;| | CL =transducers= | =loop= macro | Clojure | Scheme | Rust | Haskell | |---------+----------------+-------------------+---------+--------+------+---------| | =ints= | ✓ | =for x from N to M= | | | =1..= | =[1..]= | | =cycle= | ✓ | | | | ✓ | ✓ | | =repeat= | ✓ | =repeat= | | | ✓ | ✓ | | =random= | ✓ | | | | | | | =shuffle= | ✓ | | | | | |&lt;/p&gt; &#xA;&lt;p&gt;** Data Sources&lt;/p&gt; &#xA;&lt;p&gt;| | CL =transducers= | =loop= macro | Clojure | Scheme | Rust | Haskell | |-------------+----------------+------------+---------+--------+------+---------| | File Lines | ✓ | | | ✓ | ✓ | ✓ | | JSON Stream | ✓ | | | | ✓ | ✓ |&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example Gallery&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Words in a File&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (t:transduce (t:comp (t:map #&#39;str:words) #&#39;t:concatenate) #&#39;t:count #p&#34;README.org&#34;) ;; =&amp;gt; 977 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Sieve of Eratosthenes&lt;/p&gt; &#xA;&lt;p&gt;An ancient method of calculating Prime Numbers.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (let ((xf (t:comp (t:inject (lambda (prime) (t:filter (lambda (n) (/= 0 (mod n prime)))))) (t:take 10)))) (cons 2 (t:transduce xf #&#39;t:cons (t:ints 3 :step 2)))) ;; =&amp;gt; (2 3 5 7 11 13 17 19 23 29 31) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** JSON: Calculating average age&lt;/p&gt; &#xA;&lt;p&gt;Since JSON Objects are parsed as Hash Tables, we use the usual functions to retrieve fields we want.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (t:transduce (t:filter-map (lambda (ht) (gethash &#34;age&#34; ht))) (t:average :none) (j:read &#34;[{&#34;age&#34;: 34}, {&#34;age&#34;: 25}]&#34;)) ;; =&amp;gt; 59/2 (29.5) #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Limitations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;This library is generally portable, but assumes your CL implementation supports tail-recursion.&lt;/li&gt; &#xA; &lt;li&gt;A way to model the common =zip= function has not yet been found.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Further Work&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Notes on performance.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; More higher-order transducers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; =transducers-csv= &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Decoding numbers.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Encoding from classes.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Resources&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://clojure.org/reference/transducers][Clojure: Transducers]]&lt;/li&gt; &#xA; &lt;li&gt;[[https://clojure.org/guides/faq#transducers_vs_seqs][Clojure: What are good uses cases for transducers?]]&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>