<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-18T01:39:35Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Shirakumo/alloy</title>
    <updated>2022-07-18T01:39:35Z</updated>
    <id>tag:github.com,2022-07-18:/Shirakumo/alloy</id>
    <link href="https://github.com/Shirakumo/alloy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A new user interface protocol and toolkit implementation&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;About Alloy&lt;/h1&gt; &#xA;&lt;p&gt;Alloy is a user interface toolkit. It is defined through a set of protocols that allow for a clear interface, as well as a standardised way to integrate Alloy into a target backend.&lt;/p&gt; &#xA;&lt;p&gt;&#34;The project is currently still in its design phase and large parts of it may change. Please wait warmly.&#34;(bold, size 20pt, red)&lt;/p&gt; &#xA;&lt;p&gt;; TODO: I&#39;d really like an index to be generated by Markless for this. Will need to think about that. Probably a custom instruction in cl-markless.&lt;/p&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;p&gt;A set of simple examples for Alloy can be found in the &lt;code&gt;examples&lt;/code&gt; directory of the source tree.&lt;/p&gt; &#xA;&lt;h1&gt;Helping Out&lt;/h1&gt; &#xA;&lt;p&gt;If you are looking for tasks to help Alloy along, please see the various todo comments in the code base, open &#34;issue tickets&#34;(&lt;a href=&#34;https://github.com/shirakumo/alloy/issues&#34;&gt;https://github.com/shirakumo/alloy/issues&lt;/a&gt;) on GitHub, and the &#34;TODO file&#34;(link TODO.mess).&lt;/p&gt; &#xA;&lt;h1&gt;Alloy Protocols&lt;/h1&gt; &#xA;&lt;p&gt;Alloy is structured as a family of protocols. This allows it to be very flexible, and allows you, the user, to put together the system in a way that fits your needs. The Alloy project (henceforth &#34;the project&#34;), consists of the following set of protocols:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Core &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&#34;Component&#34;(link #Component)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Data&#34;(link #Data)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Elements and Containers&#34;(link #Elements and Containers)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Events&#34;(link #Events)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Focus&#34;(link #Focus)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Geometry&#34;(link #Geometry)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Layout&#34;(link #Layout)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Observables&#34;(link #Observables)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Renderer&#34;(link #Renderer)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;UI&#34;(link #UI)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Units&#34;(link #Units)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&#34;OpenGL&#34;(link alloy-opengl/index.html#protocol)&lt;/li&gt; &#xA; &lt;li&gt;&#34;Simple&#34;(link alloy-simple/index.html#protocol) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&#34;Presentations&#34;(link alloy-simple-presentations/index.html#protocol)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Shapes&#34;(link alloy-simple/index.html#shapes)&lt;/li&gt; &#xA;   &lt;li&gt;&#34;Transforms&#34;(link alloy-simple/index.html#transforms)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&#34;Windowing&#34;(link alloy-windowing/index.html#protocol)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The documentation in this document will focus only on the Core protocol. The Core protocol defines the fundamentals of Alloy, while the other protocols focus on extensions built around it. Note that the project also contains implementations of these protocols, not just the protocol definitions themselves.&lt;/p&gt; &#xA;&lt;p&gt;The order of the protocols as follows is intended to give a clear understanding of each, only introducing further protocols if the ones they depend on have already been explained. If you need to jump to a specific section, please use the index above.&lt;/p&gt; &#xA;&lt;h2&gt;Units&lt;/h2&gt; &#xA;&lt;p&gt;Whenever we deal with real-world measurements we need to talk about units. In the case of a UI toolkit we are concerned with distances. Alloy offers a &lt;code&gt;unit&lt;/code&gt; type that encapsulates a numeric value and allows us to reason about various measurements. In the base protocol there are two absolute units and five relative units. Absolute in this context means that the unit can be translated to device units (typically &#34;pixels&#34;) no matter the context it is used in. Relative in turn means that the device unit size is dependent on the context in which the unit is used in. The available units are as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;px&lt;/code&gt; A direct representation of a number of device pixels. Note that this may still be subject to reinterpretation by the underlying rendering backend. However, as this is the base unit in Alloy, all other units will be subject to the same backend scaling factor in the end.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cm&lt;/code&gt; A representation of real-world centimetres. This should allow measuring things that correspond to an actual real-world extent. However, this translation depends on user-supplied data, see &lt;code&gt;dots-per-cm&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;un&lt;/code&gt; The standard unit in Alloy. &lt;code&gt;un&lt;/code&gt;s are scaled relative to the user interface&#39;s target resolution and current, actual resolution. This allows the interface to scale up and down dynamically depending on the current resolution and preserve the layout. It is recommended that you use &lt;code&gt;un&lt;/code&gt;s wherever possible. For the scaling factors involved in computing pixels from a &lt;code&gt;un&lt;/code&gt;, see &lt;code&gt;base-scale&lt;/code&gt; and &lt;code&gt;resolution-scale&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;vw&lt;/code&gt; &amp;amp; &lt;code&gt;vh&lt;/code&gt; A fraction of the total view width or height. The view is the total visible area in which the renderer can operate, which typically either corresponds to the virtual screen size, the monitor resolution, or a single window.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pw&lt;/code&gt; &amp;amp; &lt;code&gt;ph&lt;/code&gt; A fraction of the parent width or height. The &#34;parent&#34; is a dynamically determined layout element with a logical extent. See &#34;Layout&#34;(link #Layout).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can convert between units by simply passing the unit to the constructor of another, or compute directly with units by using one of the many math functions defined for units: &lt;code&gt;u+&lt;/code&gt; &lt;code&gt;u*&lt;/code&gt; &lt;code&gt;u-&lt;/code&gt; &lt;code&gt;u/&lt;/code&gt; &lt;code&gt;umax&lt;/code&gt; &lt;code&gt;umin&lt;/code&gt; &lt;code&gt;u=&lt;/code&gt; &lt;code&gt;u/=&lt;/code&gt; &lt;code&gt;u&amp;lt;&lt;/code&gt; &lt;code&gt;u&amp;gt;&lt;/code&gt; &lt;code&gt;u&amp;lt;=&lt;/code&gt; &lt;code&gt;u&amp;gt;=&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Often when needing to compute with units, the unit needs to be converted into some numerical value. To do so, use &lt;code&gt;to-px&lt;/code&gt;, which will return an absolute pixel representation of the unit. Beware however that this is subject to the current parent, and conversion without an active parent will signal an error. The unit parent should be bound dynamically with &lt;code&gt;with-unit-parent&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Units are immutable and are cached or constructed at compile time wherever possible. It is safe to dump them to FASLs, too. While two units of the same type and with the same value may be &lt;code&gt;eq&lt;/code&gt;, this is not guaranteed. To ensure unit size equality, use &lt;code&gt;u=&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Geometry&lt;/h2&gt; &#xA;&lt;p&gt;While units give us the tool to denote measurements, the geometry protocol gives access to a set of tools to describe and operate on geometric data. All of the geometry in Alloy is based on a two dimensional Cartesian coordinate system. All of the measurements in the geometrical structures are expressed in terms of &lt;code&gt;unit&lt;/code&gt; instances. Specifically, the following structures are available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;point&lt;/code&gt; A singular position in space, denoted by &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt; The span of a construct in space, denoted by &lt;code&gt;w&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;extent&lt;/code&gt; A delimited extent in space, denoted by &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;margins&lt;/code&gt; The offset from the borders of a surrounding extent, denoted by &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;, and &lt;code&gt;b&lt;/code&gt;. Positive measurements decrease the extent, negative measurements increase the extent.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The default constructors of these structures take unit instances, or a real number that is interpreted as a &lt;code&gt;un&lt;/code&gt; unit. There are alternate convenience constructors that create the structures from device pixel units. These constructors are simply prefixed by &lt;code&gt;px-&lt;/code&gt; (&lt;code&gt;px-extent&lt;/code&gt;, etc). In the other direction, convenience accessors for device pixels of all the coordinates are also available with a &lt;code&gt;px&lt;/code&gt; prefix (&lt;code&gt;pxx&lt;/code&gt;, etc).&lt;/p&gt; &#xA;&lt;p&gt;Just like units, geometrical constructs are immutable and may be constructed at compile time, or emitted into FASLs. To compare them, you should use the respective type&#39;s comparison function (&lt;code&gt;extent=&lt;/code&gt;, etc).&lt;/p&gt; &#xA;&lt;p&gt;A couple of extra functions exist for convenience purposes, such as &lt;code&gt;destructure-margins&lt;/code&gt; and &lt;code&gt;destructure-extent&lt;/code&gt; to easily deal with all of the fields, &lt;code&gt;contained-p&lt;/code&gt; to check for inclusion, &lt;code&gt;overlapping-p&lt;/code&gt; to check for intersection, &lt;code&gt;extent-intersection&lt;/code&gt; to compute the intersection, and &lt;code&gt;ensure-extent&lt;/code&gt; to coerce any structure into an &lt;code&gt;extent&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Elements and Containers&lt;/h2&gt; &#xA;&lt;p&gt;In order to abstract away a number of traversal operations, Alloy offers the basic &lt;code&gt;element&lt;/code&gt; and &lt;code&gt;container&lt;/code&gt; classes. A container contains a number of elements and acts similar to a sequence. Whenever a hierarchy is composed in Alloy, it is made up of elements and containers. The following operations are defined on containers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enter&lt;/code&gt; Enters a new element into the container. Where and how the element is inserted is up to the container. A container may specify additional keyword arguments that influence the element&#39;s positioning or other metadata the container might have.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;leave&lt;/code&gt; Removes the element from the container.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;update&lt;/code&gt; Changes the metadata of the element and possibly its position within the container. A container may specify keyword arguments that let the user change the element&#39;s positioning or other metadata.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;element-count&lt;/code&gt; Returns the number of elements currently contained in the container.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;elements&lt;/code&gt; Returns a sequence of all the elements contained in the container. You may not modify this sequence.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;element-index&lt;/code&gt; Returns the current index of the element within the container. This index may change if elements are entered, left, or updated within the container. Note that the index is not required to be numeric.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;call-with-elements&lt;/code&gt; / &lt;code&gt;do-elements&lt;/code&gt; Repeatedly calls the supplied function with successive elements. The start and end indices may influence the region of iterated elements. A container may ignore the start and end indices if they are not applicable.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clear&lt;/code&gt; Leaves all elements from the container. This requires &lt;code&gt;leave&lt;/code&gt; to be called on every element in the container, though the order is unspecified.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Renderer&lt;/h2&gt; &#xA;&lt;p&gt;Alloy is a graphical user interface, and so rendering of the interface plays an important role. In the Core protocol, rendering is extremely simplified, in order to allow the backend the greatest amount of flexibility and control. In fact, it is so simple that components (See &#34;Components&#34;(link #components)) could be just representations of widgets or controls in another UI toolkit.&lt;/p&gt; &#xA;&lt;p&gt;The renderer protocol is based around a set of generic functions and two classes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;renderer&lt;/code&gt; Any rendering backend must provide a subclass of this that is responsible for visually presenting elements in some way.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;renderable&lt;/code&gt; Any element that should be drawn must be a subclass of this. It is illegal to attempt to render objects that are not &lt;code&gt;renderable&lt;/code&gt;s unless backend explicitly allows it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The protocol is split into two sections, the first dealing with resource allocation, and the second with the control of visualisations.&lt;/p&gt; &#xA;&lt;h3&gt;Rendering Resource Management&lt;/h3&gt; &#xA;&lt;p&gt;Before a &lt;code&gt;renderable&lt;/code&gt; can be visualised with a &lt;code&gt;renderer&lt;/code&gt;, the &lt;code&gt;register&lt;/code&gt; function must be called to inform the renderer of the renderable. The user must add methods to this function for both renderables and renderers, as appropriate. Specifically, any renderable that contains child elements that should be renderable, must also call &lt;code&gt;register&lt;/code&gt; on its child elements when it itself is registered. The register function may be called at any point.&lt;/p&gt; &#xA;&lt;p&gt;Before any visualisation at all can be done, the &lt;code&gt;allocate&lt;/code&gt; function must be called with the renderer. Calling this function multiple times should have no further effect. The renderer is encouraged to defer allocation of resources that pop up during &lt;code&gt;register&lt;/code&gt; calls until this point, unless the renderer has already been allocated before. The user is encouraged to call &lt;code&gt;allocate&lt;/code&gt; at a strategic point where it is permissible for loading pauses to occur. A renderer may signal an error of type &lt;code&gt;allocation-failed&lt;/code&gt; if it is currently impossible for the renderer to perform rendering actions for whatever reason.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;deallocate&lt;/code&gt; is called the renderer should free all resources it can. This returns the renderer to the state before &lt;code&gt;allocate&lt;/code&gt; was called for the first time, but does not influence the elements known to the renderer via &lt;code&gt;register&lt;/code&gt;. A renderer may deallocate itself in case a critical failure occurs that prevents it from operating further.&lt;/p&gt; &#xA;&lt;p&gt;; TODO: Deregistering / deallocating of resources&lt;/p&gt; &#xA;&lt;h3&gt;Renderer Visualisation Control&lt;/h3&gt; &#xA;&lt;p&gt;Visualisation of elements is done via &lt;code&gt;render&lt;/code&gt;. When &lt;code&gt;render&lt;/code&gt; is called, the renderer should perform whatever steps necessary to render the given renderable. The behaviour is undefined if &lt;code&gt;allocate&lt;/code&gt; was not successfully called prior to this, or the renderer was not notified of the renderable via &lt;code&gt;register&lt;/code&gt;. The user is allowed to provide non-primary methods to further customise the rendering behaviour. The user is not allowed to provide primary methods unless the renderer protocol used specifically permits it.&lt;/p&gt; &#xA;&lt;p&gt;During rendering the renderer must only visualise things if the region to visualise is within the &lt;code&gt;visible-bounds&lt;/code&gt; of the renderer. These bounds can be dynamically constrained via &lt;code&gt;call-with-constrained-visibility&lt;/code&gt;/&lt;code&gt;with-constrained-visibility&lt;/code&gt;. Whether an extent is visible or not can be checked via &lt;code&gt;extent-visible-p&lt;/code&gt;. Specifically, if an extent is partially visible, the renderer must only render the part of the extent that is fully within the visible bounds.&lt;/p&gt; &#xA;&lt;p&gt;If the renderer supports partial updates, the user is encouraged to call into the rendering machinery via &lt;code&gt;maybe-render&lt;/code&gt; instead. Unlike &lt;code&gt;render&lt;/code&gt;, &lt;code&gt;maybe-render&lt;/code&gt; will silently traverse the hierarchy and only invoke &lt;code&gt;render&lt;/code&gt; on an element if the element was previously marked with &lt;code&gt;mark-for-render&lt;/code&gt;. After &lt;code&gt;render&lt;/code&gt; has been called on a renderable, &lt;code&gt;render-needed-p&lt;/code&gt; will always be &lt;code&gt;NIL&lt;/code&gt;. The user should always call &lt;code&gt;mark-for-render&lt;/code&gt; if any property of a renderable was changed that would change its visual representation.&lt;/p&gt; &#xA;&lt;h2&gt;Focus&lt;/h2&gt; &#xA;&lt;p&gt;In alloy there is a notion of a &#34;focus tree&#34; -- a hierarchy of elements that designates how the focus flows between elements. Focus in this case refers to how important an element currently is. A &lt;code&gt;focus-element&lt;/code&gt; in alloy can have three states; &lt;code&gt;NIL&lt;/code&gt; for no focus at all, &lt;code&gt;:strong&lt;/code&gt; for when it is fully focused, and &lt;code&gt;:weak&lt;/code&gt; for when it should be considered for strong focus.&lt;/p&gt; &#xA;&lt;p&gt;Within a &lt;code&gt;focus-tree&lt;/code&gt; there must always be exactly one element with strong focus, but there may be many elements with weak or no focus. Every element in a focus tree has exactly one parent element. For the element at the root of the focus tree, this is the element itself. Focus may flow inwards and outwards, meaning that a strongly focused element may pass the strong focus to a child element (&lt;code&gt;activate&lt;/code&gt;), or it may pass the focus to its parent (&lt;code&gt;exit&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;An element may also be strongly focused directly, referred to as &#34;focus stealing&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Within a &lt;code&gt;focus-chain&lt;/code&gt; -- an element that can contain child elements -- only one of its direct children may have strong or weak focus. This is used when the focus-chain is activated, to determine which of the child elements to give strong focus to. Each child also has a direct successor and predecessor. There may be additional ties between child elements that offer more intuitive navigation, but this basic connection is always present.&lt;/p&gt; &#xA;&lt;p&gt;Note that there is no necessary visual correspondence to the way focus moves between elements. This is important as elements may have a certain visual grouping, but the ideal way focus travels between the elements may not be directly encoded in this grouping.&lt;/p&gt; &#xA;&lt;p&gt;An element may only be contained in one focus chain at a time. Attempting to &lt;code&gt;enter&lt;/code&gt; an element into multiply focus chain before &lt;code&gt;leave&lt;/code&gt;ing it will signal an error.&lt;/p&gt; &#xA;&lt;p&gt;More specifically, within a &lt;code&gt;focus-tree&lt;/code&gt; the following invariants must be upheld at any time:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There must always be exactly one strongly focused element&lt;/li&gt; &#xA; &lt;li&gt;All predecessors of the strongly focused element must be weakly focused&lt;/li&gt; &#xA; &lt;li&gt;An element may only be weakly focused if: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Its immediate predecessor is strongly focused&lt;/li&gt; &#xA;   &lt;li&gt;Or one of its successors is strongly focused&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;If an element is an immediate successor of another, the other element must be its &lt;code&gt;focus-parent&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Events&lt;/h2&gt; &#xA;&lt;p&gt;Alloy is a retained mode toolkit where you construct an interface, which then reacts to changes in the environment. These changes are communicated via events. When an element &lt;code&gt;handle&lt;/code&gt;s an event, it can either decide to handle it and perform whatever action necessary to do so, or call &lt;code&gt;decline&lt;/code&gt; in order to allow the event to propagate to an element that might want to handle it instead. The behaviour of this propagation is distinguished between the following two types of events:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;direct-event&lt;/code&gt; Direct events are events without geometric information and are handled by being directed to the element that currently has strong focus, and then bubble outwards in the focus hierarchy if the handling is declined.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pointer-event&lt;/code&gt; Pointer events are events that have a specific associated location. They are first directed to the element with strong focus similar to direct-events, but if declined will bubble inwards from the root element until the last element that geometrically contains the point is found.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Alloy contains a variety of event classes to describe general user interface changes. These events are loosely grouped into either being specific or descriptive. Specific means that the event describes a particular hardware action directly, such as a key press. Descriptive events on the other hand may be translated from a variety of hardware actions and are used to describe a particular action in the interface, such as focusing the next element.&lt;/p&gt; &#xA;&lt;p&gt;Descriptive events allow you to write the user interface interaction in a more action-oriented way, which allows the end-user to decide how to map physical buttons and gestures to the interactions they want. This is important for accessibility, internationalisation, and customisation.&lt;/p&gt; &#xA;&lt;p&gt;; TODO: Translation mechanism, more descriptive events&lt;/p&gt; &#xA;&lt;h2&gt;Layout&lt;/h2&gt; &#xA;&lt;p&gt;Layouting in alloy refers to the decisions made to determine where elements are positioned in space and how large they are. In other words, it&#39;s the mechanism to determine the &lt;code&gt;extent&lt;/code&gt; of each element that should be rendered. Similar to focus trees, there are &#34;layout trees&#34; in Alloy -- hierarchies of elements that govern the layouting decisions.&lt;/p&gt; &#xA;&lt;p&gt;Every element in a layout tree has exactly one parent, with the element at the root having itself as its own parent. Every element also has a &lt;code&gt;bounds&lt;/code&gt; that determines its axis aligned bounding box. When rendered, the visual representation of the element should not exceed this extent.&lt;/p&gt; &#xA;&lt;p&gt;Layout decisions are primarily made by &lt;code&gt;layout&lt;/code&gt; instances, for which Alloy specifies a protocol to communicate an agreeable layouting between elements. The actual layout decisions are left up completely to the layout implementation.&lt;/p&gt; &#xA;&lt;p&gt;When an element&#39;s bounds change, it must call &lt;code&gt;notice-bounds&lt;/code&gt; in order to notify its parent of the updated bounds. If an element decides that it needs more space, it should call &lt;code&gt;notice-bounds&lt;/code&gt; to ensure a consistent layout. Typically this will result in a standard layout update being run, same as when the layout instance itself changes bounds.&lt;/p&gt; &#xA;&lt;p&gt;When a layout&#39;s bounds change it may recompute the bounds of its direct children. It must do so in the following steps for each of its child elements:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Compute the new bounds for one element.&lt;/li&gt; &#xA; &lt;li&gt;Call &lt;code&gt;suggest-bounds&lt;/code&gt; with the new bounds for the element. The element must then extend, contract, or otherwise change the suggested event and return a new extent that it finds more agreeable than the last.&lt;/li&gt; &#xA; &lt;li&gt;Adjust the layouting decisions to account for the element&#39;s preferred extent.&lt;/li&gt; &#xA; &lt;li&gt;Force the final computed extent on the element by calling &lt;code&gt;(setf bounds)&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;A layout may perform steps 2 and 3 multiple times before settling on a final extent, though it must guarantee to reach step 4 eventually. &lt;code&gt;suggest-bounds&lt;/code&gt; is primarily used to handle the case of nested layouts or other kinds of elements that may need to shrink or expand to fit their contents. Whether the element&#39;s preferred extent is used at all or not however is still up to the layout.&lt;/p&gt; &#xA;&lt;p&gt;A layout //must// deal in &lt;code&gt;px&lt;/code&gt; units. The extent supplied to &lt;code&gt;suggest-bounds&lt;/code&gt; and &lt;code&gt;(setf bounds)&lt;/code&gt; must only contain &lt;code&gt;px&lt;/code&gt; units. An element is however allowed to use other units for the extent returned from &lt;code&gt;suggest-bounds&lt;/code&gt;. However, be aware that the absolute size of units depends on the currently bound unit parent (See &#34;Units&#34;(link #units)). The layout //must// set this parent to itself when resolving units.&lt;/p&gt; &#xA;&lt;p&gt;Some layouts may temporarily hide elements or regions from view. In order to force a region to be visible, the function &lt;code&gt;ensure-visible&lt;/code&gt; can be used. This function will traverse upwards to ensure that every layout along the way makes the desired region visible as best possible.&lt;/p&gt; &#xA;&lt;p&gt;An element may only be contained in one layout at a time. Attempting to &lt;code&gt;enter&lt;/code&gt; an element into multiply layouts before &lt;code&gt;leave&lt;/code&gt;ing it will signal an error.&lt;/p&gt; &#xA;&lt;h2&gt;UI&lt;/h2&gt; &#xA;&lt;p&gt;Since layout trees and focus trees are disjoint, there needs to be a way to tie them together, including any other global information necessary. For this, Alloy has the &lt;code&gt;UI&lt;/code&gt; object, the main entry point once the interface has been constructed. It has a &lt;code&gt;layout-tree&lt;/code&gt; and &lt;code&gt;focus-tree&lt;/code&gt;, as well as provides access to the global unit scaling factors, &lt;code&gt;dots-per-cm&lt;/code&gt;, &lt;code&gt;target-resolution&lt;/code&gt;, &lt;code&gt;resolution-scale&lt;/code&gt;, and &lt;code&gt;base-scale&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Once you&#39;ve constructed a UI instance, you should be able to add elements to its focus tree and layout tree, set the desired &#34;native&#34; resolution, and finally &lt;code&gt;render&lt;/code&gt; it, &lt;code&gt;handle&lt;/code&gt; events, or change the effective resolution with &lt;code&gt;suggest-bounds&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you would like to switch out the layout or focus hierarchies on the fly, you can set the &lt;code&gt;root&lt;/code&gt; of either tree instance.&lt;/p&gt; &#xA;&lt;p&gt;; TODO: It might be better to have the slots be different and inherit from focus-tree/layout-tree to remove the indirection.&lt;/p&gt; &#xA;&lt;h2&gt;Observables&lt;/h2&gt; &#xA;&lt;p&gt;In order to allow parts of the system to react to changes that happen elsewhere, Alloy implements an observation protocol. Any object that can be observed for changes must be an &lt;code&gt;observable&lt;/code&gt;. Observations happen based on functions to observe. When an observable function is called with an observable instance, a set of functions that observe this combination is called with the same arguments as the original function call.&lt;/p&gt; &#xA;&lt;p&gt;An observable may either have observations fired automatically on generic functions that have been defined with &lt;code&gt;define-observable&lt;/code&gt; or made observable with &lt;code&gt;make-observable&lt;/code&gt;, or it may manually fire observations with &lt;code&gt;notify-observers&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;New observers can be added with &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;observe&lt;/code&gt;, and managed with &lt;code&gt;remove-observers&lt;/code&gt; and &lt;code&gt;list-observers&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;; TODO: Might be better to have observables as a separate library, with more of the basic data types reimplemented.&lt;/p&gt; &#xA;&lt;h2&gt;Data&lt;/h2&gt; &#xA;&lt;p&gt;Alloy is created around the idea that the data you present in your interface should be decoupled from the elements that present it. However, to provide standardised interfaces to the data, and to express the requirements for data structure and metadata an element might have, Alloy provides a Data protocol.&lt;/p&gt; &#xA;&lt;p&gt;The base protocol is very light, though it is expected that elements add further constraints to the protocol in order to express their needs. The basis involves a &lt;code&gt;data&lt;/code&gt; class, from which any data representation should inherit. Every data representation object is observable, to allow the interface to respond to changes.&lt;/p&gt; &#xA;&lt;p&gt;In order to obtain the most appropriate data representation instance for a place, use &lt;code&gt;place-data&lt;/code&gt;. The user is encouraged to provide additional methods on &lt;code&gt;expand-place-data&lt;/code&gt; and especially &lt;code&gt;exand-compound-place-data&lt;/code&gt; if they add new data representation types.&lt;/p&gt; &#xA;&lt;p&gt;Note that as long as an object is observable, and the generic functions and observable places as required by the element&#39;s data protocol are implemented for the object, the object may be used as a data representation object directly.&lt;/p&gt; &#xA;&lt;h2&gt;Component&lt;/h2&gt; &#xA;&lt;p&gt;Representing user interactions happens through Components. Components are &#34;leaf elements&#34; and should not contain any further elements. Instead, if something should be made up of different interactions, it should be modelled as a combination of layouts, focus chains, and components. Every component is tied to a &lt;code&gt;data&lt;/code&gt; instance that provides the data to visualise and the metadata to determine the interaction constraints.&lt;/p&gt; &#xA;&lt;p&gt;Being an interactable leaf element, a component is both a &lt;code&gt;layout-element&lt;/code&gt;, a &lt;code&gt;focus-element&lt;/code&gt;, a &lt;code&gt;renderable&lt;/code&gt;, and an &lt;code&gt;observable&lt;/code&gt;. Particularly, it is possible to observe any component&#39;s focus and size changes, and react to them remotely. Specific components may offer additional interactions, though typically it is more apt to observe the changes on its data object instead.&lt;/p&gt; &#xA;&lt;p&gt;Multiple components may share the same data instance and changes between them will update automatically. This allows representing the same information in multiple places, potentially in different ways simultaneously.&lt;/p&gt; &#xA;&lt;p&gt;Components are typically created for a place or data instance through &lt;code&gt;represent&lt;/code&gt; and &lt;code&gt;represent-with&lt;/code&gt;. Alloy can try to pick the component type for a data type automatically by using &lt;code&gt;T&lt;/code&gt; for the component type. In this case the actual component type to use is resolved via &lt;code&gt;component-class-for-object&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Standard Implementations&lt;/h1&gt; &#xA;&lt;p&gt;Aside from the protocols, Core provides a set of standard implementations of the protocols that should fill a lot of the needs for an interface.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Components &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Button&lt;/li&gt; &#xA;   &lt;li&gt;Combo&lt;/li&gt; &#xA;   &lt;li&gt;Icon&lt;/li&gt; &#xA;   &lt;li&gt;Text Input&lt;/li&gt; &#xA;   &lt;li&gt;Label&lt;/li&gt; &#xA;   &lt;li&gt;Plot&lt;/li&gt; &#xA;   &lt;li&gt;Progress&lt;/li&gt; &#xA;   &lt;li&gt;Radio&lt;/li&gt; &#xA;   &lt;li&gt;Scroll&lt;/li&gt; &#xA;   &lt;li&gt;Slider&lt;/li&gt; &#xA;   &lt;li&gt;Switch&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Data Representations &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Place Data&lt;/li&gt; &#xA;   &lt;li&gt;Slot Data&lt;/li&gt; &#xA;   &lt;li&gt;Aref Data&lt;/li&gt; &#xA;   &lt;li&gt;Computed Data&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Focus Chains &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Focus List&lt;/li&gt; &#xA;   &lt;li&gt;Focus Grid&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Layouts &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Border Layout&lt;/li&gt; &#xA;   &lt;li&gt;Clip View&lt;/li&gt; &#xA;   &lt;li&gt;Fixed Layout&lt;/li&gt; &#xA;   &lt;li&gt;Grid Layout&lt;/li&gt; &#xA;   &lt;li&gt;Linear Layouts&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Observables &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Observable Object&lt;/li&gt; &#xA;   &lt;li&gt;Observable Table&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Structures &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Query&lt;/li&gt; &#xA;   &lt;li&gt;Scroll View&lt;/li&gt; &#xA;   &lt;li&gt;Tab View&lt;/li&gt; &#xA;   &lt;li&gt;Window&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that Core does //not// provide any standard implementations for renderers. Rendering is a very involved and complex process, and as such is left up to secondary systems and protocol extensions.&lt;/p&gt; &#xA;&lt;h2&gt;Observables&lt;/h2&gt; &#xA;&lt;h2&gt;Data Representations&lt;/h2&gt; &#xA;&lt;h2&gt;Focus Chains&lt;/h2&gt; &#xA;&lt;h2&gt;Layouts&lt;/h2&gt; &#xA;&lt;h2&gt;Components&lt;/h2&gt; &#xA;&lt;h3&gt;Button&lt;/h3&gt; &#xA;&lt;h3&gt;Combo&lt;/h3&gt; &#xA;&lt;h3&gt;Icon&lt;/h3&gt; &#xA;&lt;h3&gt;Text Input&lt;/h3&gt; &#xA;&lt;h3&gt;Label&lt;/h3&gt; &#xA;&lt;h3&gt;Plot&lt;/h3&gt; &#xA;&lt;h3&gt;Progress&lt;/h3&gt; &#xA;&lt;h3&gt;Radio&lt;/h3&gt; &#xA;&lt;h3&gt;Scroll&lt;/h3&gt; &#xA;&lt;h3&gt;Slider&lt;/h3&gt; &#xA;&lt;h3&gt;Switch&lt;/h3&gt; &#xA;&lt;h2&gt;Structures&lt;/h2&gt; &#xA;&lt;h3&gt;Query&lt;/h3&gt; &#xA;&lt;h3&gt;Scroll View&lt;/h3&gt; &#xA;&lt;h3&gt;Tab View&lt;/h3&gt; &#xA;&lt;h3&gt;Window&lt;/h3&gt; &#xA;&lt;h1&gt;Project Systems&lt;/h1&gt; &#xA;&lt;p&gt;Aside from this Core, the project also includes several other systems that fill or extend parts of Alloy.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;Constraint Layout&#34;(link alloy-constraint/index.html)&lt;/li&gt; &#xA; &lt;li&gt;&#34;GLFW&#34;(link alloy-glfw/index.html)&lt;/li&gt; &#xA; &lt;li&gt;&#34;OpenGL&#34;(link alloy-opengl/index.html)&lt;/li&gt; &#xA; &lt;li&gt;&#34;SVG&#34;(link alloy-svg/index.html)&lt;/li&gt; &#xA; &lt;li&gt;&#34;Simple&#34;(link alloy-simple/index.html)&lt;/li&gt; &#xA; &lt;li&gt;&#34;Simple Presentations&#34;(link alloy-simple-presentations/index.html)&lt;/li&gt; &#xA; &lt;li&gt;&#34;Windowing&#34;(link alloy-windowing/index.html)&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>