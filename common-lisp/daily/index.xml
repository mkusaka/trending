<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-14T01:36:55Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zellerin/http2</title>
    <updated>2022-07-14T01:36:55Z</updated>
    <id>tag:github.com,2022-07-14:/zellerin/http2</id>
    <link href="https://github.com/zellerin/http2" rel="alternate"></link>
    <summary type="html">&lt;p&gt;HTTP/2 implementation in Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: http/2 in Common Lisp&lt;/p&gt; &#xA;&lt;p&gt;[[https://github.com/zellerin/http2/actions/workflows/test.yml/badge.svg]]&lt;/p&gt; &#xA;&lt;p&gt;This is a (work in progress) implementation of HTTP/2 protocol as described in RFC9113 (and RFC7540 before) and RFC7541 (HPACK).&lt;/p&gt; &#xA;&lt;p&gt;The core part of the library is implementing writing http2 frames, reading them, and reacting on read frames. What to do with the frames is managed by classes &lt;del&gt;CONNECTION&lt;/del&gt; and &lt;del&gt;HTTP2-STREAM&lt;/del&gt; that are supposed to be extended by application to do something reasonable with headers and payload; see [[./client/client.lisp][client.lisp]] or [[./server/server.lisp][server.lisp]] for an example.&lt;/p&gt; &#xA;&lt;p&gt;** Status and quickstart Almost all parts standards implemented, see below for exceptions.&lt;/p&gt; &#xA;&lt;p&gt;The library definitely allow to implement a client or server, and a simple ones are attached to it as examples.&lt;/p&gt; &#xA;&lt;p&gt;*** Client&lt;/p&gt; &#xA;&lt;p&gt;The bundled client requests remote page and returns values of body (converted to string), result status, and response headers.&lt;/p&gt; &#xA;&lt;p&gt;Improvements to allow for cookie management, decoding to proper charset, .. are out of scope of this library, as they would probably be better taken over from some existing http1 library or incorporated there.&lt;/p&gt; &#xA;&lt;p&gt;Improvements to provide stream for reading the output, to query several resources on one server, and to receive pushes are considered for future, as they are http2 specific.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (ql:quickload &#39;http2/client) (http2/client:retrieve-url &#34;&lt;a href=&#34;https://example.com&#34;&gt;https://example.com&lt;/a&gt;&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;#+RESULTS: #+begin_src text &amp;lt;!doctype html&amp;gt;&lt;/p&gt;   &amp;lt;title&amp;gt;Example Domain&amp;lt;/title&amp;gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;meta charset=&#34;utf-8&#34; /&amp;gt;&#xA;&amp;lt;meta http-equiv=&#34;Content-type&#34; content=&#34;text/html; charset=utf-8&#34; /&amp;gt;&#xA;&amp;lt;meta name=&#34;viewport&#34; conten...[sly-elided string of length 1256]&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&#34;200&#34; ((&#34;content-length&#34; . &#34;1256&#34;) (&#34;x-cache&#34; . &#34;HIT&#34;) (&#34;vary&#34; . &#34;Accept-Encoding&#34;) (&#34;server&#34; . &#34;ECS (bsa/EB24)&#34;) (&#34;last-modified&#34; . &#34;Thu, 17 Oct 2019 07:18:26 GMT&#34;) (&#34;expires&#34; . &#34;Thu, 16 Jun 2022 09:35:21 GMT&#34;) (&#34;etag&#34; . &#34;&#34;3147526947+ident&#34;&#34;) (&#34;date&#34; . &#34;Thu, 09 Jun 2022 09:35:21 GMT&#34;) (&#34;content-type&#34; . &#34;text/html; charset=UTF-8&#34;) (&#34;cache-control&#34; . &#34;max-age=604800&#34;) (&#34;age&#34; . &#34;239205&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** Server Example https server (that signals h2 support with ALPN) is implemented; TLS key and certificate is needed ([[./scaffolding/run-server.lisp][test script]] generates it when missing). It handles requests one by one by default; this is trivial to improve in several ways (thread for request, workers, polling...) with customizing &lt;del&gt;&lt;em&gt;dispatch-fn&lt;/em&gt;&lt;/del&gt; but out of scope of this project.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (ql:quickload &#39;http2/server) (http2::create-server 1234 &#34;key.pem&#34; &#34;cert.pem&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Then point your browser (not eww nor drakma, of course - must support http2) to &lt;a href=&#34;https://localhost:1234&#34;&gt;https://localhost:1234&lt;/a&gt; or #+begin_src sh [zellerin@winter http2]$ curl &lt;a href=&#34;http://localhost:1234/&#34;&gt;http://localhost:1234/&lt;/a&gt; Hello World #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Customize PEER-ENDS-HTTP-STREAM to send something else (or process-end-headers if you do not want to see their data), and maybe add a method to ADD-HEADER to pay attention to what other headers than URL the client sends.&lt;/p&gt; &#xA;&lt;p&gt;For simple cases, handlers can be defined to send data as text or binary streams, see sample server. Splitting the payload based on window size is done.&lt;/p&gt; &#xA;&lt;p&gt;** Missing pieces&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No handling of priorities is implemented. This is OK, as these are only suggestions, and they are more or less dropped in RFC9113 anyway.&lt;/li&gt; &#xA; &lt;li&gt;Push promises are not implemented in the client. This is OK, they are disabled by default (settings)&lt;/li&gt; &#xA; &lt;li&gt;Option to encode headers to /Literal Header Field Never Indexed/ format is not implemented. This is simple to do, but interface would need to be though out.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Implementation details&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[./core/frames.lisp]] implements frame reading and writing. It is intended to be correct and fast, in this order. Read frames call callbacks that are supposed to be generic functions for extensibility.&lt;/li&gt; &#xA; &lt;li&gt;[[./core/classes.lisp]] defines class hierarchy for vanilla connections and streams, and the generic methods for callbacks for these classes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Dependencies&lt;/p&gt; &#xA;&lt;p&gt;(to be reviewed)&lt;/p&gt; &#xA;&lt;p&gt;The core library used trivial-gray-streams to implement streams over data frames.&lt;/p&gt; &#xA;&lt;p&gt;Client and server require usocket and cl+ssl to talk over TLS.&lt;/p&gt; &#xA;&lt;p&gt;Client uses puri to manipulate URLs.&lt;/p&gt; &#xA;&lt;p&gt;Server also uses cffi directly to [[file:tls/cl+ssl.lisp][check and confirm alpn]]. The sample server uses cl-who to create html; this is an arbitrary choice and your server can use anything else.&lt;/p&gt; &#xA;&lt;p&gt;Additioanlly, fiasco is used for testing.&lt;/p&gt; &#xA;&lt;p&gt;** License Licensed by MIT license.&lt;/p&gt; &#xA;&lt;p&gt;Some comments are taken over from the RFCs above and copyrighted by RFC contributors. I read the copyright licenses for RFC that this is allowed. Big chunks of RFC text mean usually something is not implemented and are slowly converted to code.&lt;/p&gt; &#xA;&lt;p&gt;** Related software There is an Akamai code on &lt;a href=&#34;https://github.com/akamai/cl-http2-protocol&#34;&gt;https://github.com/akamai/cl-http2-protocol&lt;/a&gt; that supported bigger parts of the drafted HTTP/2 protocol in 2014; apparently hard to run now, used NPN instead of ALPN. It might be reasonable to pilfer some pieces and ideas (especially interface level) from that one, but I have not done so (yet).&lt;/p&gt;</summary>
  </entry>
</feed>