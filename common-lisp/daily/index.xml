<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-15T01:32:33Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Clozure/ccl</title>
    <updated>2023-01-15T01:32:33Z</updated>
    <id>tag:github.com,2023-01-15:/Clozure/ccl</id>
    <link href="https://github.com/Clozure/ccl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Clozure Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Clozure CL&lt;/h1&gt; &#xA;&lt;p&gt;This is the source code for Clozure CL.&lt;/p&gt; &#xA;&lt;p&gt;Because CCL is written in itself, you need an already-working version of CCL to compile it.&lt;/p&gt; &#xA;&lt;p&gt;A working CCL consists of three parts.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The heap image is a file that can be quickly mapped into a process&#39;s address space. The heap image contains the lisp code and (other) data that make up the vast majority of CCL.&lt;/li&gt; &#xA; &lt;li&gt;The lisp kernel is a C program with a fair amount of platform-specific assembly language code. The lisp kernel provides runtime support for lisp code. When the lisp kernel starts up, it maps the heap image into memory and transfers control to compiled lisp code contained in the heap image.&lt;/li&gt; &#xA; &lt;li&gt;The interface database is a set of files derived from the operating system&#39;s C header files. The &lt;code&gt;#_&lt;/code&gt; and &lt;code&gt;#$&lt;/code&gt; reader macros consult this database to look up the definitions of foreign functions and constants. The interface database is not required for CCL to start up and run already-compiled code, but it is required to compile CCL itself.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For the latest released version of CCL, please see &lt;a href=&#34;https://github.com/Clozure/ccl/releases/latest&#34;&gt;https://github.com/Clozure/ccl/releases/latest&lt;/a&gt; and download the archive for your platform. These archives contain not only the necessary binaries, but also a full clone of the source code. So, to install a complete CCL, all you have to do is download one archive and extract it.&lt;/p&gt; &#xA;&lt;p&gt;If you want to run the development version of CCL, please see &lt;a href=&#34;https://github.com/Clozure/ccl/releases&#34;&gt;https://github.com/Clozure/ccl/releases&lt;/a&gt;. You will typically want the most recent development snapshot. Note that archives for a development snapshot include only binaries (heap image, lisp kernel, and interface database). You must clone the repository first, and then unpack the binaries into your clone.&lt;/p&gt; &#xA;&lt;p&gt;To report a bug or request an enhancement, please make an issue at &lt;a href=&#34;https://github.com/Clozure/ccl/issues&#34;&gt;https://github.com/Clozure/ccl/issues&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you run into problems, please send mail to &lt;a href=&#34;mailto:openmcl-devel@clozure.com&#34;&gt;openmcl-devel@clozure.com&lt;/a&gt;, ask on #ccl on freenode, or create an issue here, especially if you think you have found a bug.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Wukix/LambdaLite</title>
    <updated>2023-01-15T01:32:33Z</updated>
    <id>tag:github.com,2023-01-15:/Wukix/LambdaLite</id>
    <link href="https://github.com/Wukix/LambdaLite" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A functional, relational database in about 250 lines of Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LambdaLite&lt;/h1&gt; &#xA;&lt;p&gt;A functional, relational database in about 250 lines of Common Lisp.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;Woah! This is really cool&#34; — &lt;a href=&#34;https://news.ycombinator.com/item?id=8701006&#34;&gt;marknadal&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&#34;stunningly lovely&#34; — &lt;a href=&#34;http://www.reddit.com/r/lisp/comments/2o4nxy/lambdalite_functional_relational_inprocess_lisp/cmko589&#34;&gt;hal68k&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;SQL. NoSQL. ORMs. Key-value stores. There are a variety of approaches available for dealing with data. LambdaLite might be called functional and relational, for lack of better terms. The &#34;relational&#34; part is straightfoward: data is organized into tables. The &#34;functional&#34; part comes from a break with traditional SQL-style query languages: Lisp function closures are used to express queries over in-memory, in-process Lisp data.&lt;/p&gt; &#xA;&lt;h2&gt;Lisp Plug&lt;/h2&gt; &#xA;&lt;p&gt;People often ask &#34;why Lisp?&#34; It&#39;s hard to sum up all the benefits of Lisp in a few words. However, what LambdaLite does would be impossible in most languages. LambdaLite&#39;s &lt;code&gt;where&lt;/code&gt; clauses are macros that seek out &#39;/&#39;-prefixed keywords and replace them with row attribute references. The resulting expression becomes a function closure that is compiled by most Lisp implementations into native code. Is that cool or what?&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Consider the following SQL query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;SELECT * FROM USERS WHERE UPPER(name) = &#39;BOB&#39;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A few problems are apparent:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The UPPER function is part of a separate language with its own syntax and semantics&lt;/li&gt; &#xA; &lt;li&gt;The whole query is represented as a string in our application language, so it misses out on highlighting, completion, validation, etc.&lt;/li&gt; &#xA; &lt;li&gt;Parameterization of &#39;BOB&#39; into a variable lacks elegance in most SQL client libraries&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Under LambdaLite, we could instead write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(select :users (where (equal (string-upcase :/name) &#34;BOB&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Why is this useful?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It&#39;s actual Lisp syntax: everything is a Lisp function (e.g. string-upcase) or macro&lt;/li&gt; &#xA; &lt;li&gt;&#34;BOB&#34; can be parameterized natively by any Lisp variable&lt;/li&gt; &#xA; &lt;li&gt;The where clause forms a compiled function closure with the full expressiveness of Lisp&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Notice that :/name begins with a slash; this is to distinguish it as a row attribute instead of an ordinary Lisp keyword.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;LambdaLite is schemaless for flexibility. Rather than defining tables themselves, you define attributes that can be used on any table, using &lt;code&gt;defattributes&lt;/code&gt; like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defmacro str-member (&amp;amp;rest strings)&#xA;  `(lambda (x) (member x &#39;(,@strings) :test #&#39;string=)))&#xA;&#xA;(defattributes&#xA;  :/ticket-id #&#39;integerp&#xA;  :/title (lambda (x) (&amp;lt;= 1 (length x) 200))&#xA;  :/ticket-type (str-member &#34;defect&#34; &#34;enhancement&#34; &#34;question&#34;)&#xA;  :/mocl-version (str-member &#34;14.08&#34; &#34;14.05&#34; &#34;14.02&#34; &#34;13.08&#34; &#34;13.06&#34; &#34;n/a&#34;)&#xA;  :/target-os (str-member &#34;iOS&#34; &#34;Android&#34; &#34;OS X&#34; &#34;n/a&#34;)&#xA;  :/dev-os (str-member &#34;Mac OS X&#34; &#34;Linux 32-bit&#34; &#34;Linux 64-bit&#34; &#34;n/a&#34;)&#xA;  :/description (lambda (x) (&amp;lt;= 1 (length x) 64000))&#xA;  :/created-date&#xA;  :/created-by&#xA;  :/modified-date&#xA;  :/user-id&#xA;  :/display-name (lambda (x) (and x (&amp;lt;= 3 (length x) 20) (ppcre:scan &#34;^[a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9]+$&#34; x))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will define getter functions that can be used like &lt;code&gt;(:/ticket-id row)&lt;/code&gt; as well as validation functions like &lt;code&gt;(valid-title-p title)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Example Session&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require :lambdalite)&#xA;(use-package :lambdalite)&#xA;(load-db :path &#34;~/db/&#34;)&#xA;(insert :cars &#39;(:/car-id 1 :/make &#34;Honda&#34; :/color &#34;blue&#34;)&#xA;              &#39;(:/car-id 2 :/make &#34;Ford&#34; :/color &#34;red&#34;))&#xA;  =&amp;gt; 2&#xA;(select :cars (where (equal :/color &#34;red&#34;)))&#xA;  =&amp;gt; ((:/CAR-ID 2 :/MAKE &#34;Ford&#34; :/COLOR &#34;red&#34;))&#xA;(defmacro str-member (&amp;amp;rest strings)&#xA;  `(lambda (x) (member x &#39;(,@strings) :test #&#39;string=)))&#xA;(defattributes&#xA;  :/car-id #&#39;integerp &#xA;  :/make #&#39;stringp &#xA;  :/color (str-member &#34;red&#34; &#34;green&#34; &#34;blue&#34;))&#xA;(valid-color-p &#34;asdf&#34;)&#xA;  =&amp;gt; nil&#xA;(dolist (row (select :cars)) &#xA;  (format t &#34;Make: ~A, Color: ~A~%&#34; (:/make row) (:/color row)))&#xA;  &amp;gt;&amp;gt; Make: Honda, Color: blue&#xA;     Make: Ford, Color: red&#xA;(mapcar #&#39;:/color (select :cars))&#xA;  =&amp;gt; (&#34;blue&#34; &#34;red&#34;)&#xA;(insert :cars &#39;(:/car-id 3 :/make &#34;Toyota&#34; :/color &#34;green&#34;) &#xA;              &#39;(:/car-id 4 :/make &#34;Audi&#34; :/color &#34;red&#34;))&#xA;  =&amp;gt; 2&#xA;(sort (select :cars) #&#39;string&amp;lt; :key #&#39;:/make)&#xA;  =&amp;gt; ((:/CAR-ID 4 :/MAKE &#34;Audi&#34; :/COLOR &#34;red&#34;)&#xA;      (:/CAR-ID 2 :/MAKE &#34;Ford&#34; :/COLOR &#34;red&#34;)&#xA;      (:/CAR-ID 1 :/MAKE &#34;Honda&#34; :/COLOR &#34;blue&#34;)&#xA;      (:/CAR-ID 3 :/MAKE &#34;Toyota&#34; :/COLOR &#34;green&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Transactions&lt;/h2&gt; &#xA;&lt;p&gt;LambdaLite provides the &lt;code&gt;with-tx&lt;/code&gt; macro to wrap transactions, which are executed serially across threads. For example, the following code is safe under a multi-threaded web server like Hunchentoot:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; ... create a new ticket&#xA;(with-tx &#xA;  (let ((user-id (logged-in-user-id))&#xA;        (ticket-id (1+ (length (select :tickets)))))&#xA;    (unless user-id &#xA;      (error &#34;Not logged in&#34;))&#xA;    (insert :tickets (list :/ticket-id ticket-id :/created-by user-id :/ticket-status &#34;open&#34;))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any data commands that are used outside of a with-tx transaction will automatically be treated each individually as separate transactions.&lt;/p&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;p&gt;&#34;Do things that don&#39;t scale&#34; — Paul Graham&lt;/p&gt; &#xA;&lt;p&gt;LambdaLite is completely unscalable — by design. Don&#39;t use it for heavy loads or large data sets. Even medium-sized jobs are a stretch. That&#39;s why &#39;Lite&#39; is in the name.&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;LambdaLite works under SBCL and probably other Lisps&lt;/li&gt; &#xA; &lt;li&gt;LambdaLite runs on &lt;a href=&#34;https://wukix.com/mocl&#34;&gt;mocl&lt;/a&gt; for mobile data storage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Who is using LambdaLite?&lt;/h2&gt; &#xA;&lt;p&gt;LambdaLite powers the mocl support site at &lt;a href=&#34;https://wukix.com/support/&#34;&gt;https://wukix.com/support/&lt;/a&gt; with delightfully low query latency on a single Amazon EC2 micro instance.&lt;/p&gt;</summary>
  </entry>
</feed>