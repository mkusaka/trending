<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-17T01:39:59Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>quil-lang/magicl</title>
    <updated>2022-08-17T01:39:59Z</updated>
    <id>tag:github.com,2022-08-17:/quil-lang/magicl</id>
    <link href="https://github.com/quil-lang/magicl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Matrix Algebra proGrams In Common Lisp.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MAGICL&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Matrix Algebra proGrams In Common Lisp&lt;/em&gt; by &lt;a href=&#34;http://www.rigetti.com&#34;&gt;Rigetti Computing&lt;/a&gt;. (n√©e FLAIL: &lt;em&gt;Finally, Linear Algebra In Lisp!&lt;/em&gt;)&lt;/p&gt; &#xA;&lt;p&gt;(&lt;strong&gt;Note&lt;/strong&gt;: The high-level interface is experimental and subject to change.)&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;MAGICL has two main systems:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;MAGICL/CORE&lt;/code&gt;: This is pure Lisp code with no foreign dependencies. This system establishes MAGICL&#39;s API (for the most part).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;MAGICL&lt;/code&gt;: This is MAGICL with all extensions loaded.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The system &lt;code&gt;MAGICL/CORE&lt;/code&gt; requires:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SBCL (&amp;gt; 1.3.19), CCL (&amp;gt;= 1.11) or ECL (&amp;gt;= 20.4.24) on AMD64&lt;/li&gt; &#xA; &lt;li&gt;quicklisp&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The system &lt;code&gt;MAGICL&lt;/code&gt;, on the other hand, requires several foreign dependencies not shipped with MAGICL, like:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;libffi&lt;/li&gt; &#xA; &lt;li&gt;BLAS and LAPACK&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Detailed instructions on how to install &lt;code&gt;libffi&lt;/code&gt; and BLAS/LAPACK can be found &lt;a href=&#34;https://raw.githubusercontent.com/quil-lang/magicl/master/doc/requirements.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Currently this library is SBCL-, CCL- and ECL-only. The non-portable code is in &lt;code&gt;with-array-pointers.lisp&lt;/code&gt; and &lt;code&gt;magicl.lisp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;First ensure you have the necessary requirements installed, as described in the previous section.&lt;/p&gt; &#xA;&lt;p&gt;To install MAGICL, clone this repository into your Quicklisp&#39;s &lt;code&gt;local-projects&lt;/code&gt; folder. You can quickly check where this is by running &lt;code&gt;sbcl&lt;/code&gt; and evaluating &lt;code&gt;ql:*local-project-directories*&lt;/code&gt;. Once installed, confirm that MAGICL is working properly by running the tests, as described in the next section.&lt;/p&gt; &#xA;&lt;h2&gt;Lisp-Only vs Accelerated MAGICL&lt;/h2&gt; &#xA;&lt;h3&gt;Extensions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;MAGICL/CORE&lt;/code&gt; only uses pure ANSI Common Lisp code. If you wish to accelerate it or extend the functionality, you may load &lt;em&gt;MAGICL extensions&lt;/em&gt;. These extensions typically install new backends to MAGICL functions. The available extensions are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;MAGICL/EXT-BLAS&lt;/code&gt;: for BLAS functions&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MAGICL/EXT-LAPACK&lt;/code&gt;: for LAPACK functions&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;MAGICL/EXT-EXPOKIT&lt;/code&gt;: for expokit (matrix &lt;code&gt;exp()&lt;/code&gt;) functions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For backwards compatibility, &lt;code&gt;MAGICL&lt;/code&gt; loads every extension under the kitchen sink. &lt;strong&gt;This may change in future versions of MAGICL! If you depend on an extension, depend on it explicitly!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you use extensions, you&#39;ll need the requisite C/Fortran libraries. Expokit will automatically build for you, as its source is included in the distribution of MAGICL.&lt;/p&gt; &#xA;&lt;h3&gt;Backends&lt;/h3&gt; &#xA;&lt;p&gt;Accelerated functionality is installed with a notion called &#34;backends&#34;. A &lt;em&gt;backend&lt;/em&gt; is a name of a group of functionality, typically denoted by a symbol or keyword. The &lt;code&gt;:lisp&lt;/code&gt; backend is the default one, and several backends can be active all at once. Each extension above adds a new backend. The current backends are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:lisp&lt;/code&gt;: Pure Lisp code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:blas&lt;/code&gt;: BLAS-backed code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:lapack&lt;/code&gt;: LAPACK-backed code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:expokit&lt;/code&gt;: expokit-backed code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In most cases, one does not need to concern themselves with backends; MAGICL functionality should &#34;just work&#34; and dispatch to the appropriate backend. However, the programmer always has control, even dynamically in the program, of which backends should be used at a given time with the &lt;code&gt;magicl.backends:with-backends&lt;/code&gt; macro. For instance,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(magicl.backends:with-backends (:blas :lisp)&#xA;  ;; ... code ...&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;says that the code should be executed, always preferring &lt;code&gt;:blas&lt;/code&gt;-accelerated functions, and using &lt;code&gt;:lisp&lt;/code&gt;-implemented functions as a fall-back.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(magicl.backends:with-backends (:lisp)&#xA;  ;; ... code ...&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;says to &lt;em&gt;only&lt;/em&gt; use &lt;code&gt;:lisp&lt;/code&gt;-implemented functions, even if other backends are loaded.&lt;/p&gt; &#xA;&lt;p&gt;The active backends can be found with the function &lt;code&gt;magicl.backends:active-backends&lt;/code&gt;, which lists the backends to use in priority order.&lt;/p&gt; &#xA;&lt;p&gt;One can be even finer-grained than &lt;code&gt;with-backends&lt;/code&gt;. Given a function &lt;code&gt;f&lt;/code&gt; which has many backend implementations, one can get a specific implementation by using the function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(magicl.backends:backend-implementation &#39;f :backend-name)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For instance&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(magicl.backends:backend-implementation &#39;magicl:csd :lapack)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will give the implementation of the cosine-sine decomposition function in LAPACK. This can be called in exactly the same way &lt;code&gt;magicl:csd&lt;/code&gt; can be called.&lt;/p&gt; &#xA;&lt;p&gt;In &lt;code&gt;backend-implementation&lt;/code&gt;, if both the function name and the backend name are (quoted) constants, this will be looked up at compile-time, which is useful for writing efficient code that does not dispatch. But note that by doing this, &lt;code&gt;with-backends&lt;/code&gt; will not be respected.&lt;/p&gt; &#xA;&lt;h2&gt;Testing MAGICL&lt;/h2&gt; &#xA;&lt;p&gt;You can run the MAGICL tests from your Lisp REPL with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(asdf:test-system :magicl)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You currently need all of the extensions working for the tests to run.&lt;/p&gt; &#xA;&lt;h2&gt;High-level Interface&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/quil-lang/magicl/master/doc/high-level.md&#34;&gt;high-level doc&lt;/a&gt; for an extensive discussion and comparison of MAGICL functions with those of MATLAB and NumPy.&lt;/p&gt; &#xA;&lt;h2&gt;Developer&#39;s Guide: How to Add New Functions&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/quil-lang/magicl/master/doc/dev-how-to.md&#34;&gt;developer how-to&lt;/a&gt; to understand how to add new functionality to MAGICL.&lt;/p&gt; &#xA;&lt;h2&gt;Fortran Bindings&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/quil-lang/magicl/master/doc/fortran-functions.md&#34;&gt;Fortran Functions&lt;/a&gt; on how to re-generate the Fortran bindings from the original BLAS, LAPACK, and Expokit reference code.&lt;/p&gt; &#xA;&lt;p&gt;See the same document for how to query for available Fortran functions in the currently loaded dynamic libraries.&lt;/p&gt; &#xA;&lt;h2&gt;History and Credits&lt;/h2&gt; &#xA;&lt;p&gt;MAGICL development started at Rigetti Computing by Robert Smith and Joe Lin in 2017.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/blindglobe/cl-blapack&#34;&gt;CL-BLAPACK&lt;/a&gt; is a library developed by Ryan Rifkin and Evan Monroig. Rigetti Computing created a fork of this library and renamed it MAGICL, and made significant changes that departed from the original design, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Fixing several bugs in the Fortran parsing to make it work with the latest reference BLAS and LAPACK, leading to significant refactoring.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Adding support for matrix exponentiation with Expokit.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Adding support for loading various BLAS and LAPACK implementations.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Removing the use of the FNV library in favor of native Lisp arrays.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Adding a high-level interface to various functions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Adding function availability reporting.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The most important common design decision between CL-BLAPACK and MAGICL is allowing direct access to the Fortran library functions by way of automatically generated Lisp bindings from the reference sources.&lt;/p&gt;</summary>
  </entry>
</feed>