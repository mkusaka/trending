<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-07T01:33:48Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>endatabas/endb</title>
    <updated>2023-07-07T01:33:48Z</updated>
    <id>tag:github.com,2023-07-07:/endatabas/endb</id>
    <link href="https://github.com/endatabas/endb" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Immutable, cloud-first, dynamic SQL database.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://www.endatabas.com/resources/images/github-banner-logo_3200x476.png&#34; alt=&#34;Endatabas&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Endatabas is an immutable, cloud-first, dynamic SQL database.&lt;/p&gt; &#xA;&lt;p&gt;For more information, please contact us at &lt;a href=&#34;mailto:hello@endatabas.com&#34;&gt;hello@endatabas.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;Endatabas is &lt;strong&gt;experimental software.&lt;/strong&gt; Learn more by reading our &lt;a href=&#34;https://raw.githubusercontent.com/endatabas/endb/main/ROADMAP.md&#34;&gt;roadmap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://www.quicklisp.org/&#34;&gt;https://www.quicklisp.org/&lt;/a&gt; and &lt;a href=&#34;https://www.sbcl.org/&#34;&gt;https://www.sbcl.org/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;On Ubuntu:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install sbcl cl-quicklisp&#xA;sbcl --load /usr/share/common-lisp/source/quicklisp/quicklisp.lisp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On MacOS:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install sbcl&#xA;# For full instructions, see https://www.quicklisp.org/beta/#installation&#xA;curl -O https://beta.quicklisp.org/quicklisp.lisp&#xA;sbcl --load quicklisp.lisp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Initialise Quicklisp:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(quicklisp-quickstart:install)&#xA;(ql:add-to-init-file)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Clone or link this project under &lt;code&gt;~/quicklisp/local-projects&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ln -s $PWD ~/quicklisp/local-projects&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Initialise submodules:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git submodule update --init --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;https://www.rust-lang.org/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the tests and build the binary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sqllogictest&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://www.sqlite.org/sqllogictest/&#34;&gt;https://www.sqlite.org/sqllogictest/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Install gcc or Clang which is needed to build the test runner. On MacOS, Clang will be automatically installed. On Ubuntu:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install build-essential libsqlite3-0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build and run sanity checks. We patch the build slightly to inject our own database engine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make slt-test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Docker&lt;/h2&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://podman.io/&#34;&gt;https://podman.io/&lt;/a&gt; or Docker:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install podman&#xA;alias docker=podman&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build the image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make run-docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development Environment&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://lispcookbook.github.io/cl-cookbook/getting-started.html&#34;&gt;https://lispcookbook.github.io/cl-cookbook/getting-started.html&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright and License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright 2023 Håkan Råberg and Steven Deobald.&lt;/p&gt; &#xA;&lt;p&gt;Licensed under the GNU Affero General Public License v3.0.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>vindarel/cl-str</title>
    <updated>2023-07-07T01:33:48Z</updated>
    <id>tag:github.com,2023-07-07:/vindarel/cl-str</id>
    <link href="https://github.com/vindarel/cl-str" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Modern, simple and consistent Common Lisp string manipulation library.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;http://quickdocs.org/cl-str&#34;&gt;&lt;img src=&#34;http://quickdocs.org/badge/cl-str.svg?sanitize=true&#34; alt=&#34;Quicklisp&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;A modern and consistent Common Lisp string manipulation library&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ql:quickload &#34;str&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;also on &lt;a href=&#34;http://ultralisp.org/&#34;&gt;Ultralisp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Why ?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;modernity, simplicity and discoverability:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;(str:trim s)&lt;/code&gt; instead of &lt;code&gt;(string-trim &#39;(#\Backspace #\Tab #\Linefeed #\Newline #\Vt #\Page #\Return #\Space #\Rubout #\Next-Line #\No-break_space) s))&lt;/code&gt;, or &lt;code&gt;str:concat strings&lt;/code&gt; instead of an unusual &lt;code&gt;format&lt;/code&gt; construct; one discoverable library instead of many;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;consistence and composability, where &lt;code&gt;s&lt;/code&gt; is always the last argument, which makes it easier to feed pipes and arrows.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;fixing built-in surprises: &lt;code&gt;(string-downcase nil&lt;/code&gt;) =&amp;gt; &lt;code&gt;&#34;nil&#34;&lt;/code&gt; the string, whereas &lt;code&gt;(str:downcase nil)&lt;/code&gt; =&amp;gt; &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The only dependency is &lt;code&gt;cl-ppcre&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;!-- markdown-toc start - Don&#39;t edit this section. Run M-x markdown-toc-refresh-toc --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#a-modern-and-consistent-common-lisp-string-manipulation-library&#34;&gt;A modern and consistent Common Lisp string manipulation library&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#install&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#global-parameters&#34;&gt;Global parameters&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#functions&#34;&gt;Functions&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#tweak-whitespace&#34;&gt;Tweak whitespace&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#trim-s-key-char-bag-whitespaces&#34;&gt;trim &lt;code&gt;(s &amp;amp;key (char-bag *whitespaces*))&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#collapse-whitespaces-s&#34;&gt;collapse-whitespaces &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#to-longer-strings&#34;&gt;To longer strings&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#join-separator-list-of-strings&#34;&gt;join &lt;code&gt;(separator list-of-strings)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#concat-rest-strings&#34;&gt;concat &lt;code&gt;(&amp;amp;rest strings)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#ensure-s-key-wrapped-in-prefix-suffix-new-in-march-2023&#34;&gt;ensure &lt;code&gt;(s &amp;amp;key wrapped-in prefix suffix)&lt;/code&gt; NEW in March, 2023&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#ensure-prefix-ensure-suffix-startend-s-new-in-march-2023&#34;&gt;ensure-prefix, ensure-suffix &lt;code&gt;(start/end s)&lt;/code&gt; NEW in March, 2023&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#ensure-wrapped-in-startend-s&#34;&gt;ensure-wrapped-in &lt;code&gt;(start/end s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#insert-stringchar-index-s&#34;&gt;insert &lt;code&gt;(string/char index s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#repeat-count-s&#34;&gt;repeat &lt;code&gt;(count s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#add-prefix-add-suffix-items-s&#34;&gt;add-prefix, add-suffix &lt;code&gt;(items s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#pad-len-s-key-pad-side-right-pad-char-space-pad-left-pad-right-pad-center-new-in-016-201912&#34;&gt;pad &lt;code&gt;(len s &amp;amp;key (pad-side :right) (pad-char #\Space))&lt;/code&gt;, pad-left, pad-right, pad-center (new in 0.16, 2019/12)&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#to-shorter-strings&#34;&gt;To shorter strings&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#substring-start-end-s&#34;&gt;substring &lt;code&gt;(start end s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#s-first-s&#34;&gt;s-first &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#s-last-s&#34;&gt;s-last &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#s-rest-s&#34;&gt;s-rest &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#s-nth-n-s&#34;&gt;s-nth &lt;code&gt;(n s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#shorten-len-s-key-ellipsis&#34;&gt;shorten &lt;code&gt;(len s &amp;amp;key ellipsis)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#to-a-fixed-length&#34;&gt;To a fixed length&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#fit-len-s&#34;&gt;fit &lt;code&gt;(len s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#to-and-from-lists&#34;&gt;To and from lists&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#words-s&#34;&gt;words &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#unwords-strings&#34;&gt;unwords &lt;code&gt;(strings)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#lines-s-key-omit-nulls&#34;&gt;lines &lt;code&gt;(s &amp;amp;key omit-nulls)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#unlines-strings&#34;&gt;unlines &lt;code&gt;(strings)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#split-separator-s-key-omit-nulls-limit-start-end&#34;&gt;split &lt;code&gt;(separator s &amp;amp;key omit-nulls limit start end)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#rsplit-separator-s-key-limit&#34;&gt;rsplit &lt;code&gt;(separator s &amp;amp;key limit)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#split-omit-nulls&#34;&gt;split-omit-nulls&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#to-and-from-files&#34;&gt;To and from files&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#from-file-filename&#34;&gt;from-file &lt;code&gt;(filename)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#to-file-filename-s&#34;&gt;to-file &lt;code&gt;(filename s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#predicates&#34;&gt;Predicates&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#emptyp-s&#34;&gt;emptyp &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#blankp-s&#34;&gt;blankp &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#starts-with-p-start-s-key-ignore-case&#34;&gt;starts-with-p &lt;code&gt;(start s &amp;amp;key ignore-case)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#ends-with-p-end-s-key-ignore-case&#34;&gt;ends-with-p &lt;code&gt;(end s &amp;amp;key ignore-case)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#containsp-substring-s-key-ignore-case-nil&#34;&gt;containsp &lt;code&gt;(substring s &amp;amp;key (ignore-case nil))&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#s-member-list-s-key-ignore-case-ignore-case-test-string&#34;&gt;s-member &lt;code&gt;(list s &amp;amp;key (ignore-case *ignore-case*) (test #&#39;string=))&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#prefixp-and-suffixp-items-s&#34;&gt;prefixp and suffixp &lt;code&gt;(items s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#wrapped-in-p-startend-s-new-in-march-2023&#34;&gt;wrapped-in-p (&lt;code&gt;start/end&lt;/code&gt; &lt;code&gt;s&lt;/code&gt;) NEW in March, 2023&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#case&#34;&gt;Case&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#functions-to-change-case-camel-case-snake-case&#34;&gt;Functions to change case: camel-case, snake-case,...&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#downcase-upcase-capitalize-s-fixing-a-built-in-suprise&#34;&gt;downcase, upcase, capitalize &lt;code&gt;(s)&lt;/code&gt; fixing a built-in suprise.&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#downcasep-upcasep-s&#34;&gt;downcasep, upcasep &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#alphap-lettersp-s&#34;&gt;alphap, lettersp &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#alphanump-lettersnump-s&#34;&gt;alphanump, lettersnump &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#ascii-p-chars&#34;&gt;ascii-p &lt;code&gt;(char/s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#digitp-s&#34;&gt;digitp &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#has-alpha-p-has-letters-p-has-alphanum-p-s&#34;&gt;has-alpha-p, has-letters-p, has-alphanum-p &lt;code&gt;(s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#others&#34;&gt;Others&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#replace-first-old-new-s&#34;&gt;replace-first &lt;code&gt;(old new s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#replace-all-old-new-s&#34;&gt;replace-all &lt;code&gt;(old new s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#replace-using-plist-s&#34;&gt;replace-using &lt;code&gt;(plist s)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#remove-punctuation-s-key-replacement&#34;&gt;remove-punctuation (s &amp;amp;key replacement)&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#prefix-list-of-strings-renamed-in-09&#34;&gt;prefix &lt;code&gt;(list-of-strings)&lt;/code&gt; (renamed in 0.9)&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#suffix-list-of-strings&#34;&gt;suffix &lt;code&gt;(list-of-strings)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#count-substring-substring-s-key-start-end&#34;&gt;count-substring &lt;code&gt;(substring s &amp;amp;key start end)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#s-assoc-value-alist-key&#34;&gt;s-assoc-value &lt;code&gt;(alist key)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#macros&#34;&gt;Macros&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#string-case&#34;&gt;string-case&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#changelog&#34;&gt;Changelog&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#dev-and-test&#34;&gt;Dev and test&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#main-test-suite&#34;&gt;Main test suite&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#specific-test-suite&#34;&gt;Specific test suite&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#specific-test&#34;&gt;Specific test&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#test-when-defined&#34;&gt;Test when defined&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/vindarel/cl-str/master/#see-also&#34;&gt;See also&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;Install with &lt;a href=&#34;https://www.quicklisp.org/beta/&#34;&gt;Quicklisp&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ql:quickload :str)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add it in your .asd&#39;s project dependencies, and call functions with the &lt;code&gt;str&lt;/code&gt; prefix. It is not recommended to &lt;code&gt;:use :str&lt;/code&gt; in a package. It&#39;s safer to use the &lt;code&gt;str&lt;/code&gt; prefix.&lt;/p&gt; &#xA;&lt;p&gt;Check its version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(str:version)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To get a newer version, you need to update the Quicklisp dist (think of QL as Debian&#39;s apt rather than pip/npm/etc):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ql:update-dist &#34;quicklisp&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Don&#39;t have a full Common Lisp development environment yet ? Get &lt;a href=&#34;https://shinmera.github.io/portacle/&#34;&gt;Portacle&lt;/a&gt;, a portable and multiplatform development environment shipping Emacs, Quicklisp, SBCL and Git. See also &lt;a href=&#34;https://lispcookbook.github.io/cl-cookbook/editor-support.html&#34;&gt;editor support&lt;/a&gt; (Vim, Lem, Atom, Eclipse,…).&lt;/p&gt; &#xA;&lt;h2&gt;Global parameters&lt;/h2&gt; &#xA;&lt;p&gt;Some parameters are common to various functions and often used: &lt;code&gt;:ignore-case&lt;/code&gt; and &lt;code&gt;:omit-nulls&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Consequently we can also manage them with global parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(let ((str:*ignore-case* t))&#xA;  (str:ends-with-p &#34;BAR&#34; &#34;foobar&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is equivalent to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:ends-with-p &#34;BAR&#34; &#34;foobar&#34; :ignore-case t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Functions&lt;/h2&gt; &#xA;&lt;h3&gt;Tweak whitespace&lt;/h3&gt; &#xA;&lt;h4&gt;trim &lt;code&gt;(s &amp;amp;key (char-bag *whitespaces*))&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Removes all characters in &lt;code&gt;char-bag&lt;/code&gt; (default: whitespaces) at the beginning and end of &lt;code&gt;s&lt;/code&gt;. If supplied, &lt;code&gt;char-bag&lt;/code&gt; has to be a sequence (e.g. string or list of characters).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:trim &#34;  rst  &#34;) ;; =&amp;gt; &#34;rst&#34;&#xA;(str:trim &#34;+-*foo-bar*-+&#34; :char-bag &#34;+-*&#34;) =&amp;gt; &#34;foo-bar&#34;&#xA;(str:trim &#34;afood&#34; :char-bag (concat &#34;a&#34; &#34;d&#34;)) =&amp;gt; &#34;foo&#34;&#34;&#xA;(str:trim &#34;cdoooh&#34; :char-bag (str:concat &#34;c&#34; &#34;d&#34; &#34;h&#34;)) =&amp;gt; &#34;ooo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also &lt;code&gt;trim-left&lt;/code&gt; and &lt;code&gt;trim-right&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Uses the built-in &lt;a href=&#34;https://lispcookbook.github.io/cl-cookbook/strings.html#trimming-blanks-from-the-ends-of-a-string&#34;&gt;string-trim&lt;/a&gt; where whitespaces are &lt;code&gt;&#39;(#\Space #\Newline #\Backspace #\Tab #\Linefeed #\Page #\Return #\Rubout)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;collapse-whitespaces &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Ensure there is only one space character between words. Remove newlines.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:collapse-whitespaces &#34;foo  bar&#xA;&#xA;&#xA;  baz&#34;)&#xA;;; &#34;foo bar baz&#34;&#xA;;;T&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;To longer strings&lt;/h3&gt; &#xA;&lt;h4&gt;join &lt;code&gt;(separator list-of-strings)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Join strings in list &lt;code&gt;list-of-strings&lt;/code&gt; with &lt;code&gt;separator&lt;/code&gt; (either a string or a char) in between.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(join &#34; &#34; &#39;(&#34;foo&#34; &#34;bar&#34; &#34;baz&#34;)) ;; =&amp;gt; &#34;foo bar baz&#34;&#xA;(join #\Space &#39;(&#34;foo&#34; &#34;bar&#34; &#34;baz&#34;)) ;; =&amp;gt; &#34;foo bar baz&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;concat &lt;code&gt;(&amp;amp;rest strings)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Join strings into one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(concat &#34;f&#34; &#34;o&#34; &#34;o&#34;) ;; =&amp;gt; &#34;foo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Simple call of the built-in &lt;a href=&#34;https://lispcookbook.github.io/cl-cookbook/strings.html#concatenating-strings&#34;&gt;concatenate&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We actually also have &lt;code&gt;uiop:strcat&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;ensure &lt;code&gt;(s &amp;amp;key wrapped-in prefix suffix)&lt;/code&gt; NEW in March, 2023&lt;/h4&gt; &#xA;&lt;p&gt;The &#34;ensure-&#34; functions return a string that has the specified prefix or suffix, appended if necessary.&lt;/p&gt; &#xA;&lt;p&gt;This &lt;code&gt;str:ensure&lt;/code&gt; function looks for the following key parameters, in order:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:wrapped-in&lt;/code&gt;: if non nil, call &lt;code&gt;str:ensure-wrapped-in&lt;/code&gt;. This checks that &lt;code&gt;s&lt;/code&gt; both starts and ends with the supplied string or character.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:prefix&lt;/code&gt; and &lt;code&gt;:suffix&lt;/code&gt;: if both are supplied and non-nil, call &lt;code&gt;str:ensure-suffix&lt;/code&gt; followed by &lt;code&gt;str:ensure-prefix&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:prefix&lt;/code&gt;: call &lt;code&gt;str:ensure-prefix&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:suffix&lt;/code&gt;: call &lt;code&gt;str:ensure-suffix&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:ensure &#34;abc&#34; :wrapped-in &#34;/&#34;)  ;; =&amp;gt; &#34;/abc/&#34;&#xA;(str:ensure &#34;/abc&#34; :prefix &#34;/&#34;)  ;; =&amp;gt; &#34;/abc&#34;  =&amp;gt; no change, still one &#34;/&#34;&#xA;(str:ensure &#34;/abc&#34; :suffix &#34;/&#34;)  ;; =&amp;gt; &#34;/abc/&#34; =&amp;gt; added a &#34;/&#34; suffix.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These functions accept strings and characters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:ensure &#34;/abc&#34; :prefix #\/)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;warn: if both &lt;code&gt;:wrapped-in&lt;/code&gt; and &lt;code&gt;:prefix&lt;/code&gt; (and/or &lt;code&gt;:suffix&lt;/code&gt;) are supplied together, &lt;code&gt;:wrapped-in&lt;/code&gt; takes precedence and &lt;code&gt;:prefix&lt;/code&gt; (and/or &lt;code&gt;:suffix&lt;/code&gt;) is ignored.&lt;/p&gt; &#xA;&lt;h4&gt;ensure-prefix, ensure-suffix &lt;code&gt;(start/end s)&lt;/code&gt; NEW in March, 2023&lt;/h4&gt; &#xA;&lt;p&gt;Ensure that &lt;code&gt;s&lt;/code&gt; starts with &lt;code&gt;start/end&lt;/code&gt; (or ends with &lt;code&gt;start/end&lt;/code&gt;, respectively).&lt;/p&gt; &#xA;&lt;p&gt;Return a new string with its prefix (or suffix) added, if necessary.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:ensure-prefix &#34;/&#34; &#34;abc/&#34;) =&amp;gt; &#34;/abc/&#34; (a prefix was added)&#xA;;; and&#xA;(str:ensure-prefix &#34;/&#34; &#34;/abc/&#34;) =&amp;gt; &#34;/abc/&#34; (does nothing)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ensure-wrapped-in &lt;code&gt;(start/end s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Ensure that &lt;code&gt;s&lt;/code&gt; both starts and ends with &lt;code&gt;start/end&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Return a new string with the necessary added bits, if required.&lt;/p&gt; &#xA;&lt;p&gt;It simply calls &lt;code&gt;str:ensure-suffix&lt;/code&gt; followed by &lt;code&gt;str:ensure-prefix&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;code&gt;str:wrapped-in-p&lt;/code&gt; and &lt;code&gt;uiop:string-enclosed-p prefix s suffix&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:ensure-wrapped-in &#34;/&#34; &#34;abc&#34;) ;; =&amp;gt; &#34;/abc/&#34;  (added both a prefix and a suffix)&#xA;(str:ensure-wrapped-in &#34;/&#34; &#34;/abc/&#34;) ;; =&amp;gt; &#34;/abc/&#34; (does nothing)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;insert &lt;code&gt;(string/char index s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Insert the given string (or character) at the index &lt;code&gt;index&lt;/code&gt; into &lt;code&gt;s&lt;/code&gt; and return a new string.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;index&lt;/code&gt; is out of bounds, just return &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:insert &#34;l&#34; 2 &#34;helo&#34;) ; =&amp;gt; &#34;hello&#34;&#xA;&#xA;(str:insert &#34;o&#34; 99 &#34;hell&#34;) : =&amp;gt; &#34;hell&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;repeat &lt;code&gt;(count s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Make a string of &lt;code&gt;s&lt;/code&gt; repeated &lt;code&gt;count&lt;/code&gt; times.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(repeat 3 &#34;foo&#34;) ;; =&amp;gt; &#34;foofoofoo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;add-prefix, add-suffix &lt;code&gt;(items s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Respectively prepend or append &lt;code&gt;s&lt;/code&gt; to the front of each item.&lt;/p&gt; &#xA;&lt;h4&gt;pad &lt;code&gt;(len s &amp;amp;key (pad-side :right) (pad-char #\Space))&lt;/code&gt;, pad-left, pad-right, pad-center (new in 0.16, 2019/12)&lt;/h4&gt; &#xA;&lt;p&gt;Fill &lt;code&gt;s&lt;/code&gt; with characters until it is of the given length. By default, add spaces on the right:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:pad 10 &#34;foo&#34;)&#xA;&#34;foo       &#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pad-side&lt;/code&gt;: one of &lt;code&gt;:right&lt;/code&gt; (the default), &lt;code&gt;:left&lt;/code&gt; or &lt;code&gt;:center&lt;/code&gt;. See &lt;code&gt;*pad-side*&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pad-char&lt;/code&gt;: the padding character (or string of one character). Defaults to a space. See &lt;code&gt;*pad-char*&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:pad 10 &#34;foo&#34; :pad-side :center :pad-char &#34;+&#34;)&#xA;&#34;+++foo++++&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the given length is smaller than the length o &lt;code&gt;s&lt;/code&gt;, return &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Filling with spaces can easily be done with format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(format nil &#34;~va&#34; len s) ;; =&amp;gt; &#34;foo       &#34;&#xA;(format nil &#34;~v@a&#34; 10 &#34;foo&#34;) ;; =&amp;gt; &#34;       foo&#34; (with @)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;To shorter strings&lt;/h3&gt; &#xA;&lt;h4&gt;substring &lt;code&gt;(start end s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the substring of &lt;code&gt;s&lt;/code&gt; from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It uses &lt;code&gt;subseq&lt;/code&gt; with differences:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;argument order, s at the end&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; can be lower than 0 or bigger than the length of s.&lt;/li&gt; &#xA; &lt;li&gt;for convenience &lt;code&gt;end&lt;/code&gt; can be nil or t to denote the end of the string.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  (is &#34;abcd&#34; (substring 0 t &#34;abcd&#34;) &#34;t denotes the end of the string&#34;)&#xA;  (is &#34;abcd&#34; (substring 0 nil &#34;abcd&#34;) &#34;nil too&#34;)&#xA;  (is &#34;abcd&#34; (substring 0 100 &#34;abcd&#34;) &#34;end can be too large&#34;)&#xA;  (is &#34;abc&#34; (substring 0 -1 &#34;abcd&#34;) &#34;end can be negative. Counts from the end.&#34;)&#xA;  (is &#34;&#34; (substring 0 -100 &#34;abcd&#34;) &#34;end can be negative and too low&#34;)&#xA;  (is &#34;&#34; (substring 100 1 &#34;abcd&#34;) &#34;start can be too big&#34;)&#xA;  (is &#34;abcd&#34; (substring -100 4 &#34;abcd&#34;) &#34;start can also be too low&#34;)&#xA;  (is &#34;&#34; (substring 2 1 &#34;abcd&#34;) &#34;start is bigger than end&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;s-first &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the first letter of &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  (s-first &#34;foobar&#34;) ;; =&amp;gt; &#34;f&#34;&#xA;  (s-first &#34;&#34;) ;; =&amp;gt; &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;s-last &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the last letter of &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;s-rest &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the rest substring of &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  (s-rest &#34;foobar&#34;) ;; =&amp;gt; &#34;oobar&#34;&#xA;  (s-rest &#34;&#34;) ;; =&amp;gt; &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;s-nth &lt;code&gt;(n s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return the nth letter of &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  (s-nth 3 &#34;foobar&#34;) ;; =&amp;gt; &#34;b&#34;&#xA;  (s-nth 3 &#34;&#34;) ;; =&amp;gt; &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You could also use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(elt &#34;test&#34; 1)&#xA;;; =&amp;gt; #\e&#xA;(string (elt &#34;test&#34; 1))&#xA;;; =&amp;gt; &#34;e&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;shorten &lt;code&gt;(len s &amp;amp;key ellipsis)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;If &lt;code&gt;s&lt;/code&gt; is longer than &lt;code&gt;len&lt;/code&gt;, truncate it and add an ellipsis at the end (&lt;code&gt;...&lt;/code&gt; by default). &lt;code&gt;s&lt;/code&gt; is cut down to &lt;code&gt;len&lt;/code&gt; minus the length of the ellipsis (3 by default).&lt;/p&gt; &#xA;&lt;p&gt;Optionally, give an &lt;code&gt;:ellipsis&lt;/code&gt; keyword argument. Also set it globally with &lt;code&gt;*ellipsis*&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(shorten 8 &#34;hello world&#34;)&#xA;;; =&amp;gt; &#34;hello...&#34;&#xA;(shorten 3 &#34;hello world&#34;)&#xA;;; =&amp;gt; &#34;...&#34;&#xA;(shorten 8 &#34;hello world&#34; :ellipsis &#34;-&#34;)&#xA;;; =&amp;gt; &#34;hello w-&#34;&#xA;(let ((*ellipsis* &#34;-&#34;))&#xA;  (shorten 8 &#34;hello world&#34;))&#xA;;; =&amp;gt; &#34;hello w-&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;To a fixed length&lt;/h3&gt; &#xA;&lt;h4&gt;fit &lt;code&gt;(len s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Fit this string to the given length:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;if it&#39;s too long, shorten it (showing the &lt;code&gt;ellipsis&lt;/code&gt;),&lt;/li&gt; &#xA; &lt;li&gt;if it&#39;s too short, add paddding (to the side &lt;code&gt;pad-side&lt;/code&gt;, adding the character &lt;code&gt;pad-char&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As such, it accepts the same key arguments as &lt;code&gt;str:shorten&lt;/code&gt; and &lt;code&gt;str:pad&lt;/code&gt;: &lt;code&gt;ellipsis&lt;/code&gt;, &lt;code&gt;pad-side&lt;/code&gt;, &lt;code&gt;pad-char&lt;/code&gt;…&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;CL-USER&amp;gt; (str:fit 10 &#34;hello&#34; :pad-char &#34;+&#34;)&#xA;&#34;hello+++++&#34;&#xA;&#xA;CL-USER&amp;gt; (str:fit 10 &#34;hello world&#34; :ellipsis &#34;…&#34;)&#xA;&#34;hello wor…&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If, like me, you want to print a list of data as a table, see:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vindarel/cl-ansi-term/&#34;&gt;cl-ansi-term&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;CL-USER&amp;gt; (ql:quickload &#34;cl-ansi-term&#34;)&#xA;CL-USER&amp;gt; (term:table &#39;((&#34;name&#34; &#34;age&#34; &#34;email&#34;)&#xA;              (&#34;me&#34; 7 &#34;some@blah&#34;)&#xA;              (&#34;me&#34; 7 &#34;some@with-some-longer.email&#34;))&#xA;             :column-width &#39;(10 4 20))&#xA;+---------+---+-------------------+&#xA;|name     |age|email              |&#xA;+---------+---+-------------------+&#xA;|me       |7  |some@blah          |&#xA;+---------+---+-------------------+&#xA;|me       |7  |some@with-some-l(…)|&#xA;+---------+---+-------------------+&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/telephil/cl-ascii-table/&#34;&gt;cl-ascii-table&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;CL-USER&amp;gt; (ql:quickload &#34;cl-ascii-table&#34;)&#xA;CL-USER&amp;gt; (let ((table (ascii-table:make-table &#39;(&#34;Id&#34; &#34;Name&#34; &#34;Amount&#34;) :header &#34;Infos&#34;)))&#xA;  (ascii-table:add-row table &#39;(1 &#34;Bob&#34; 150))&#xA;  (ascii-table:add-row table &#39;(2 &#34;Joe&#34; 200))&#xA;  (ascii-table:add-separator table)&#xA;  (ascii-table:add-row table &#39;(&#34;&#34; &#34;Total&#34; 350))&#xA;  (ascii-table:display table))&#xA;&#xA;.---------------------.&#xA;|        Infos        |&#xA;+----+-------+--------+&#xA;| Id | Name  | Amount |&#xA;+----+-------+--------+&#xA;|  1 | Bob   |    150 |&#xA;|  2 | Joe   |    200 |&#xA;+----+-------+--------+&#xA;|    | Total |    350 |&#xA;+----+-------+--------+&#xA;NIL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;To and from lists&lt;/h3&gt; &#xA;&lt;h4&gt;words &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return list of words, which were delimited by whitespace.&lt;/p&gt; &#xA;&lt;h4&gt;unwords &lt;code&gt;(strings)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Join the list of strings with a whitespace.&lt;/p&gt; &#xA;&lt;h4&gt;lines &lt;code&gt;(s &amp;amp;key omit-nulls)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Split string by newline character and return list of lines.&lt;/p&gt; &#xA;&lt;p&gt;A terminal newline character does &lt;em&gt;not&lt;/em&gt; result in an extra empty string (new in &lt;strong&gt;v0.14&lt;/strong&gt;, october 2019).&lt;/p&gt; &#xA;&lt;h4&gt;unlines &lt;code&gt;(strings)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Join the list of strings with a newline character.&lt;/p&gt; &#xA;&lt;h4&gt;split &lt;code&gt;(separator s &amp;amp;key omit-nulls limit start end)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Split into subtrings (unlike cl-ppcre, without a regexp). If &lt;code&gt;omit-nulls&lt;/code&gt; is non-nil, zero-length substrings are omitted.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(split &#34;+&#34; &#34;foo++bar&#34;) ;; =&amp;gt; (&#34;foo&#34; &#34;&#34; &#34;bar&#34;)&#xA;(split #\+ &#34;foo++bar&#34;) ;; =&amp;gt; (&#34;foo&#34; &#34;&#34; &#34;bar&#34;)&#xA;(split &#34;+&#34; &#34;foo++bar&#34; :omit-nulls t) ;; =&amp;gt; (&#34;foo&#34; &#34;bar&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;cl-ppcre has an inconsistency such that when the separator appears at the end, it doesn&#39;t return a trailing empty string. But we do &lt;strong&gt;since v0.14&lt;/strong&gt; (october, 2019).&lt;/p&gt; &#xA;&lt;h4&gt;rsplit &lt;code&gt;(separator s &amp;amp;key limit)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;split&lt;/code&gt;, but split from the end. In particular, this will be different from &lt;code&gt;split&lt;/code&gt; when a &lt;code&gt;:limit&lt;/code&gt; is provided, but in more obscure cases it can be different when there are multiple different ways to split the string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(rsplit &#34;/&#34; &#34;/var/log/mail.log&#34; :limit 2) ;; =&amp;gt; (&#34;/var/log&#34; &#34;mail.log&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(cl-ppcre:split &#34; &#34; &#34;a b c &#34;)&#xA;(&#34;a&#34; &#34;b&#34; &#34;c&#34;)&#xA;&#xA;(str:split &#34; &#34; &#34;a b c &#34;)&#xA;(&#34;a&#34; &#34;b&#34; &#34;c&#34; &#34;&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;split-omit-nulls&lt;/h4&gt; &#xA;&lt;p&gt;Because it is a common pattern and it can be clearer than an option coming after many parenthesis.&lt;/p&gt; &#xA;&lt;h3&gt;To and from files&lt;/h3&gt; &#xA;&lt;h4&gt;from-file &lt;code&gt;(filename)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Read the file and return its content as a string.&lt;/p&gt; &#xA;&lt;p&gt;Example: &lt;code&gt;(str:from-file &#34;path/to/file.txt&#34;)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;:external-format&lt;/code&gt;: if nil, the system default. Can be bound to &lt;code&gt;:utf-8&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;But you might just call &lt;a href=&#34;https://github.com/fare/asdf/raw/master/uiop/stream.lisp#L445&#34;&gt;uiop&#39;s &lt;code&gt;uiop:read-file-string&lt;/code&gt;&lt;/a&gt; directly.&lt;/p&gt; &#xA;&lt;p&gt;There is also &lt;code&gt;uiop:read-file-lines&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;to-file &lt;code&gt;(filename s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Write the string &lt;code&gt;s&lt;/code&gt; to the file &lt;code&gt;filename&lt;/code&gt;. If the file does not exist, create it, if it already exists, replace it.&lt;/p&gt; &#xA;&lt;p&gt;Options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:if-does-not-exist&lt;/code&gt;: &lt;code&gt;:create&lt;/code&gt; (default), &lt;code&gt;:error&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:if-exists&lt;/code&gt;: &lt;code&gt;:supersede&lt;/code&gt; (default), &lt;code&gt;:append&lt;/code&gt;, &lt;code&gt;:overwrite&lt;/code&gt;, &lt;code&gt;:rename&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt;,...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Returns the string written to file.&lt;/p&gt; &#xA;&lt;h3&gt;Predicates&lt;/h3&gt; &#xA;&lt;h4&gt;emptyp &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;True if &lt;code&gt;s&lt;/code&gt; is nil or the empty string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  (emptyp nil) ;; =&amp;gt; T&#xA;  (emptyp &#34;&#34;)  ;; =&amp;gt; T&#xA;  (emptyp &#34; &#34;) ;; =&amp;gt; NIL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also &lt;code&gt;str:non-empty-string-p&lt;/code&gt;, which adds a &lt;code&gt;stringp&lt;/code&gt; check.&lt;/p&gt; &#xA;&lt;h4&gt;blankp &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;True if &lt;code&gt;s&lt;/code&gt; is empty or only contains whitespaces.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(blankp &#34;&#34;) ;; =&amp;gt; T&#xA;(blankp &#34; &#34;) ;; =&amp;gt; T&#xA;(emptyp &#34; &#34;) ;; =&amp;gt; NIL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also &lt;code&gt;str:non-blank-string-p&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;starts-with-p &lt;code&gt;(start s &amp;amp;key ignore-case)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;True if &lt;code&gt;s&lt;/code&gt; starts with the substring &lt;code&gt;start&lt;/code&gt;, nil otherwise. Ignore case by default.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(starts-with-p &#34;foo&#34; &#34;foobar&#34;) ;; =&amp;gt; T&#xA;(starts-with-p &#34;FOO&#34; &#34;foobar&#34;) ;; =&amp;gt; NIL&#xA;(starts-with-p &#34;FOO&#34; &#34;foobar&#34; :ignore-case t) ;; =&amp;gt; T&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Calls &lt;code&gt;string=&lt;/code&gt; or &lt;code&gt;string-equal&lt;/code&gt; depending on the case, with their &lt;code&gt;:start&lt;/code&gt; and &lt;code&gt;:end&lt;/code&gt; delimiters.&lt;/p&gt; &#xA;&lt;h4&gt;ends-with-p &lt;code&gt;(end s &amp;amp;key ignore-case)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;True if &lt;code&gt;s&lt;/code&gt; ends with the substring &lt;code&gt;end&lt;/code&gt;. Ignore case by default.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ends-with-p &#34;bar&#34; &#34;foobar&#34;) ;; =&amp;gt; T&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;end&lt;/code&gt; can be a string or a character.&lt;/p&gt; &#xA;&lt;h4&gt;containsp &lt;code&gt;(substring s &amp;amp;key (ignore-case nil))&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return true if &lt;code&gt;s&lt;/code&gt; contains &lt;code&gt;substring&lt;/code&gt;, nil otherwise. Ignore the case with &lt;code&gt;:ignore-case t&lt;/code&gt; (don&#39;t ignore by default).&lt;/p&gt; &#xA;&lt;p&gt;Based on a simple call to the built-in &lt;code&gt;search&lt;/code&gt; (which returns the position of the substring).&lt;/p&gt; &#xA;&lt;h4&gt;s-member &lt;code&gt;(list s &amp;amp;key (ignore-case *ignore-case*) (test #&#39;string=))&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return T if &lt;code&gt;s&#39; is a member of &lt;/code&gt;list&#39;. Do not ignore case by default.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: &lt;code&gt;s-member&lt;/code&gt;&#39;s arguments&#39; order is the reverse of CL&#39;s &lt;code&gt;member&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;:ignore-case&lt;/code&gt; or &lt;code&gt;*ignore-case*&lt;/code&gt; are not nil, ignore case (using &lt;code&gt;string-equal&lt;/code&gt; instead of &lt;code&gt;string=&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Unlike CL&#39;s &lt;code&gt;member&lt;/code&gt;, &lt;code&gt;s-member&lt;/code&gt; returns T or NIL, instead of the tail of LIST whose first element satisfies the test.&lt;/p&gt; &#xA;&lt;h4&gt;prefixp and suffixp &lt;code&gt;(items s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return &lt;code&gt;s&lt;/code&gt; if all &lt;code&gt;items&lt;/code&gt; start (or end) with it.&lt;/p&gt; &#xA;&lt;p&gt;See also &lt;code&gt;uiop:string-prefix-p prefix s&lt;/code&gt;, which returns &lt;code&gt;t&lt;/code&gt; if &lt;code&gt;prefix&lt;/code&gt; is a prefix of &lt;code&gt;s&lt;/code&gt;,&lt;/p&gt; &#xA;&lt;p&gt;and &lt;code&gt;uiop:string-enclosed-p prefix s suffix&lt;/code&gt;, which returns &lt;code&gt;t&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; begins with &lt;code&gt;prefix&lt;/code&gt; and ends with &lt;code&gt;suffix&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;wrapped-in-p (&lt;code&gt;start/end&lt;/code&gt; &lt;code&gt;s&lt;/code&gt;) NEW in March, 2023&lt;/h4&gt; &#xA;&lt;p&gt;Does &lt;code&gt;s&lt;/code&gt; start and end with `start/end&#39;?&lt;/p&gt; &#xA;&lt;p&gt;If true, return &lt;code&gt;s&lt;/code&gt;. Otherwise, return nil.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:wrapped-in-p &#34;/&#34; &#34;/foo/&#34;  ;; =&amp;gt; &#34;/foo/&#34;&#xA;(str:wrapped-in-p &#34;/&#34; &#34;/foo&#34;  ;; =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See also: &lt;code&gt;UIOP:STRING-ENCLOSED-P (prefix s suffix)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Case&lt;/h3&gt; &#xA;&lt;h4&gt;Functions to change case: camel-case, snake-case,...&lt;/h4&gt; &#xA;&lt;p&gt;We use &lt;a href=&#34;https://github.com/rudolfochrist/cl-change-case/&#34;&gt;cl-change-case&lt;/a&gt; (go thank him and star the repo!). We adapt these functions to also accept symbols and characters (like the inbuilt casing functions). Also the functions return &lt;code&gt;nil&lt;/code&gt; when argument is &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The available functions are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:no-case (s &amp;amp;key replacement)&#xA;:camel-case (s &amp;amp;key merge-numbers)&#xA;:dot-case&#xA;:header-case&#xA;:param-case&#xA;:pascal-case&#xA;:path-case&#xA;:sentence-case&#xA;:snake-case&#xA;:swap-case&#xA;:title-case&#xA;:constant-case&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More documentation and examples are there.&lt;/p&gt; &#xA;&lt;h4&gt;downcase, upcase, capitalize &lt;code&gt;(s)&lt;/code&gt; fixing a built-in suprise.&lt;/h4&gt; &#xA;&lt;p&gt;The functions &lt;code&gt;str:downcase&lt;/code&gt;, &lt;code&gt;str:upcase&lt;/code&gt; and &lt;code&gt;str:capitalize&lt;/code&gt; return a new string. They call the built-in &lt;code&gt;string-downcase&lt;/code&gt;, &lt;code&gt;string-upcase&lt;/code&gt; and &lt;code&gt;string-capitalize&lt;/code&gt; respectively, but they fix something surprising. When the argument is &lt;code&gt;nil&lt;/code&gt;, the built-ins return &#34;nil&#34; or &#34;NIL&#34; or &#34;Nil&#34;, a &lt;em&gt;string&lt;/em&gt;. Indeed, they work on anything:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(string-downcase nil) ;; =&amp;gt; &#34;nil&#34; the string !&#xA;(str:downcase nil) ;; nil&#xA;&#xA;(string-downcase :FOO) ;; =&amp;gt; &#34;foo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;downcasep, upcasep &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;These functions return &lt;code&gt;t&lt;/code&gt; if the given string contains at least one letter and all its letters are lowercase or uppercase, respectively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(is (downcasep &#34; a+,. &#34;) t &#34;downcasep with one letter and punctuation is true.&#34;)&#xA;(is (downcasep &#34; +,. &#34;) nil &#34;downcasep with only punctuation or spaces is false&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;alphap, lettersp &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;alphap&lt;/code&gt; returns t if &lt;code&gt;s&lt;/code&gt; contains at least one character and all characters are alpha (as in &lt;code&gt;&#34;^[a-zA-Z]+$&#34;&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;lettersp&lt;/code&gt; works for unicode letters too.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(is (alphap &#34;abcdeé&#34;) nil &#34;alphap is nil with accents&#34;)&#xA;(is (lettersp &#34;éß&#34;) t &#34;lettersp is t with accents and ß&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;alphanump, lettersnump &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;alphanump&lt;/code&gt; returns t if &lt;code&gt;s&lt;/code&gt; contains at least one character and all characters are alphanumeric (as in &lt;code&gt;^[a-zA-Z0-9]+$&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;lettersnump&lt;/code&gt; also works on unicode letters (as in &lt;code&gt;^[\\p{L}a-zA-Z0-9]+$&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;ascii-p &lt;code&gt;(char/s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return t if the character / string is an ASCII character / is composed of ASCII characters.&lt;/p&gt; &#xA;&lt;p&gt;An ASCII character has a &lt;code&gt;char-code&lt;/code&gt; inferior to 128.&lt;/p&gt; &#xA;&lt;h4&gt;digitp &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns t if &lt;code&gt;s&lt;/code&gt; contains at least one character and all characters are numerical (as for &lt;code&gt;digit-char-p&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;has-alpha-p, has-letters-p, has-alphanum-p &lt;code&gt;(s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Return t if &lt;code&gt;s&lt;/code&gt; has at least one alpha, letter, alphanum character (as with &lt;code&gt;alphanumericp&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Others&lt;/h3&gt; &#xA;&lt;h4&gt;replace-first &lt;code&gt;(old new s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Replace the first occurence of &lt;code&gt;old&lt;/code&gt; by &lt;code&gt;new&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;. Arguments are not regexs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(replace-first &#34;a&#34; &#34;o&#34; &#34;faa&#34;) ;; =&amp;gt; &#34;foa&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Uses &lt;a href=&#34;http://weitz.de/cl-ppcre/#regex-replace&#34;&gt;cl-ppcre:regex-replace&lt;/a&gt; but quotes the user input to not treat it as a regex.&lt;/p&gt; &#xA;&lt;h4&gt;replace-all &lt;code&gt;(old new s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Replace all occurences of &lt;code&gt;old&lt;/code&gt; by &lt;code&gt;new&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;. Arguments are not regexs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(replace-all &#34;a&#34; &#34;o&#34; &#34;faa&#34;) ;; =&amp;gt; &#34;foo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Uses &lt;a href=&#34;http://weitz.de/cl-ppcre/#regex-replace-all&#34;&gt;cl-ppcre:regex-replace-all&lt;/a&gt; but quotes the user input to not treat it as a regex.&lt;/p&gt; &#xA;&lt;p&gt;If the replacement is only one character, you can use &lt;code&gt;substitute&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(substitute #\+ #\Space &#34;foo bar baz&#34;)&#xA;;; &#34;foo+bar+baz&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;replace-using &lt;code&gt;(plist s)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Replace all associations given by pairs in a plist and return a new string.&lt;/p&gt; &#xA;&lt;p&gt;The plist is a list alternating a string to replace (case sensitive) and its replacement.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(replace-using (list &#34;%phone%&#34; &#34;987&#34;)&#xA;               &#34;call %phone%&#34;)&#xA;;; &#34;call 987&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;remove-punctuation (s &amp;amp;key replacement)&lt;/h4&gt; &#xA;&lt;p&gt;Remove the punctuation characters from &lt;code&gt;s&lt;/code&gt;, replace them with &lt;code&gt;replacement&lt;/code&gt; (defaults to a space) and strip continuous whitespace.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:remove-punctuation &#34;I say: - &#39;Hello, world?&#39;&#34;) ;; =&amp;gt; &#34;I say Hello world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;str:no-case&lt;/code&gt; to remove punctuation and return the string as lower-case.&lt;/p&gt; &#xA;&lt;h4&gt;prefix &lt;code&gt;(list-of-strings)&lt;/code&gt; (renamed in 0.9)&lt;/h4&gt; &#xA;&lt;p&gt;(renamed from &lt;code&gt;common-prefix&lt;/code&gt; in v0.9)&lt;/p&gt; &#xA;&lt;p&gt;Find the common prefix between strings.&lt;/p&gt; &#xA;&lt;p&gt;Example: &lt;code&gt;(str:prefix &#39;(\&#34;foobar\&#34; \&#34;foozz\&#34;))&lt;/code&gt; =&amp;gt; &#34;foo&#34;&lt;/p&gt; &#xA;&lt;p&gt;Uses the built-in &lt;code&gt;mismatch&lt;/code&gt;, that returns the position at which the strings fail to match.&lt;/p&gt; &#xA;&lt;p&gt;Return a string or nil when the input is the void list.&lt;/p&gt; &#xA;&lt;h4&gt;suffix &lt;code&gt;(list-of-strings)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Find the common suffix between strings.&lt;/p&gt; &#xA;&lt;h4&gt;count-substring &lt;code&gt;(substring s &amp;amp;key start end)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Counts the non-overlapping occurrences of &lt;code&gt;substring&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;. You could also count only the ocurrencies between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(count-substring &#34;abc&#34; &#34;abcxabcxabc&#34;)&#xA;;; =&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(count-substring &#34;abc&#34; &#34;abcxabcxabc&#34; :start 3 :end 7)&#xA;;; =&amp;gt; 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;s-assoc-value &lt;code&gt;(alist key)&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Returns the value of a cons cell in &lt;code&gt;alist&lt;/code&gt; with key &lt;code&gt;key&lt;/code&gt;, when &lt;code&gt;key&lt;/code&gt; is a string. The second return value is the cons cell, if any was matched.&lt;/p&gt; &#xA;&lt;p&gt;The arguments are in the opposite order of &lt;code&gt;cl:assoc&lt;/code&gt;&#39;s, but are consistent with &lt;code&gt;alexandria:assoc-value&lt;/code&gt; (and &lt;code&gt;str&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(s-assoc-value &#39;((&#34;hello&#34; . 1)) &#34;hello&#34;)&#xA;;; 1&#xA;;; (&#34;hello&#34; . 1)&#xA;&#xA;(alexandria:assoc-value &#39;((&#34;hello&#34; . 1)) &#34;hello&#34;)&#xA;;; NIL&#xA;(alexandria:assoc-value &#39;((&#34;hello&#34; . 1)) &#34;hello&#34; :test #&#39;string=)&#xA;;; 1&#xA;;; (&#34;hello&#34; . 1)&#xA;&#xA;(assoc &#34;hello&#34; &#39;((&#34;hello&#34; . 1)))&#xA;;; NIL&#xA;(assoc &#34;hello&#34; &#39;((&#34;hello&#34; . 1)) :test #&#39;string=)&#xA;;; (&#34;hello&#34; . 1)&#xA;(cdr *)&#xA;;; 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Macros&lt;/h2&gt; &#xA;&lt;h3&gt;string-case&lt;/h3&gt; &#xA;&lt;p&gt;A case-like macro that works with strings (CL case&#39;s test function is &lt;code&gt;eql&lt;/code&gt;, and that isn&#39;t enough for strings).&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:string-case input&#xA;  (&#34;foo&#34; (do something))&#xA;  (nil (print &#34;input is nil&#34;)&#xA;  (otherwise (print &#34;non of the previous forms was caught.&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You might also like pattern matching. The example below with &lt;a href=&#34;https://github.com/guicho271828/trivia/&#34;&gt;trivia&lt;/a&gt; is very similar:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(trivia:match &#34;hey&#34;&#xA;  (&#34;hey&#34; (print &#34;it matched&#34;))&#xA;  (otherwise :nothing))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that there is also &lt;a href=&#34;http://quickdocs.org/string-case/&#34;&gt;http://quickdocs.org/string-case/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;March, 2023: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;added &lt;code&gt;str:ensure&lt;/code&gt;, &lt;code&gt;str:ensure-prefix&lt;/code&gt;, &lt;code&gt;str:ensure-suffix&lt;/code&gt;, &lt;code&gt;str:ensure-wrapped-in&lt;/code&gt; and &lt;code&gt;str:wrapped-in-p&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;January, 2023: added the &lt;code&gt;:char-barg&lt;/code&gt; parameter to &lt;code&gt;trim&lt;/code&gt;, &lt;code&gt;trim-left&lt;/code&gt;, &lt;code&gt;trim-right&lt;/code&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;minor: &lt;code&gt;ends-with-p&lt;/code&gt; now works with a character.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;June, 2022: small breaking change: fixed &lt;code&gt;prefixp&lt;/code&gt; when used with a smaller prefix: &#34;f&#34; was not recognized as a prefix of &#34;foobar&#34; and &#34;foobuz&#34;, only &#34;foo&#34; was. Now it is fixed. Same for &lt;code&gt;suffixp&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Feb, 2022: added &lt;code&gt;fit&lt;/code&gt;: fit the string to the given length: either shorten it, either padd padding.&lt;/li&gt; &#xA; &lt;li&gt;0.20, May, 2021: added &lt;code&gt;ascii-p&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;0.19.1, May, 2021: speed up &lt;code&gt;join&lt;/code&gt; (by a factor of 4).&lt;/li&gt; &#xA; &lt;li&gt;0.19, October, 2020: added s-member *0.18.1, September, 2020: fix replace-all edge case when the replacement string ends with two backslashes and a single quote.&lt;/li&gt; &#xA; &lt;li&gt;0.18, June, 2020: added &lt;code&gt;replace-using&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;0.17, April 2020: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;added &lt;code&gt;collapse-whitespaces&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;join&lt;/code&gt; and &lt;code&gt;split&lt;/code&gt; also accept a char as separator&lt;/li&gt; &#xA;   &lt;li&gt;fixed &lt;code&gt;remove-punctuation&lt;/code&gt; that did not respect the case. Use &lt;code&gt;no-case&lt;/code&gt; for this&lt;/li&gt; &#xA;   &lt;li&gt;fixed &lt;code&gt;from-file&lt;/code&gt; &#34;odd number of arguments&#34; error.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;0.16, November 2019: added &lt;code&gt;pad&lt;/code&gt;, &lt;code&gt;pad-[left, right, center]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;0.15, October 2019: added functions to change case (based on cl-change-case). added remove-punctuation.&lt;/li&gt; &#xA; &lt;li&gt;0.14, October, 2019: fixed the cl-ppcre inconsistency in &lt;code&gt;split&lt;/code&gt; and &lt;code&gt;lines&lt;/code&gt;. A trailing separator now returns a trailing empty string.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Before:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:split &#34; &#34; &#34;a b c &#34;)&#xA;(&#34;a&#34; &#34;b&#34; &#34;c&#34;)  ;; like cl-ppcre:split&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(str:split &#34; &#34; &#34;a b c &#34;)&#xA;(&#34;a&#34; &#34;b&#34; &#34;c&#34; &#34;&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;august, 2019: deprecated &lt;code&gt;prune&lt;/code&gt;, renamed to &lt;code&gt;shorten&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;added &lt;code&gt;:limit&lt;/code&gt; to &lt;code&gt;split&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;0.13 june, 2019 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;added &lt;code&gt;insert&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;0.12 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;added case predicates (&lt;code&gt;downcasep&lt;/code&gt;, &lt;code&gt;alphap&lt;/code&gt;, &lt;code&gt;has-x&lt;/code&gt; and friends).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;0.11 (Quicklisp end of march, 2019, also in Ultralisp) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;added &lt;code&gt;str:downcase&lt;/code&gt;, &lt;code&gt;str:upcase&lt;/code&gt; and &lt;code&gt;str:capitalize&lt;/code&gt;, that fix the &lt;code&gt;nil&lt;/code&gt; argument surprise.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;0.10 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;split&lt;/code&gt; doesn&#39;t fix cl-ppcre&#39;s inconsistency anymore (when the separator appears at the end). See issue #18. So &lt;code&gt;(str:split &#34;xx&#34; &#34;fooxxbarxx&#34;)&lt;/code&gt; doesn&#39;t return a trailing &lt;code&gt;&#34;&#34;&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;added &lt;code&gt;s-last&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;s-first&lt;/code&gt; and friends return &lt;code&gt;nil&lt;/code&gt; when appropriate, not &lt;code&gt;&#34;&#34;&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;0.9 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;added &lt;code&gt;s-first&lt;/code&gt; , &lt;code&gt;s-rest&lt;/code&gt; and &lt;code&gt;s-nth&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;added &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;suffix&lt;/code&gt; functions and predicates.&lt;/li&gt; &#xA;   &lt;li&gt;added &lt;code&gt;prune&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;0.8 added &lt;code&gt;string-case&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;0.7 added &lt;code&gt;version&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;0.6 added &lt;code&gt;split-omit-nulls&lt;/code&gt; (QL, january 2018)&lt;/li&gt; &#xA; &lt;li&gt;0.5 added &lt;code&gt;common-prefix&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;0.4 added &lt;code&gt;from-file&lt;/code&gt; and &lt;code&gt;to-file&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;0.3 added &lt;code&gt;substring&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Dev and test&lt;/h2&gt; &#xA;&lt;p&gt;Regression testing is implemented with &lt;a href=&#34;https://github.com/lispci/fiveam&#34;&gt;fiveam&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Main test suite&lt;/h3&gt; &#xA;&lt;p&gt;Either use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  (asdf:test-system :str)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or load the test package &lt;code&gt;str.test&lt;/code&gt; and then&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  (fiveam:run! &#39;test-str:str)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specific test suite&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  (fiveam:run! &#39;test-str:replace-functions)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Test suite names:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;replace-functions&lt;/li&gt; &#xA; &lt;li&gt;lengthen-functions&lt;/li&gt; &#xA; &lt;li&gt;ensure-functions&lt;/li&gt; &#xA; &lt;li&gt;pad-functions&lt;/li&gt; &#xA; &lt;li&gt;substring-functions&lt;/li&gt; &#xA; &lt;li&gt;list-functions&lt;/li&gt; &#xA; &lt;li&gt;from-list-to-string&lt;/li&gt; &#xA; &lt;li&gt;from-list-to-list&lt;/li&gt; &#xA; &lt;li&gt;from-string-to-list&lt;/li&gt; &#xA; &lt;li&gt;predicates, case-functions&lt;/li&gt; &#xA; &lt;li&gt;miscellaneous&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Specific test&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  (fiveam:run! &#39;test-str::downcase) ;; (test symbols are unexported)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Test when defined&lt;/h3&gt; &#xA;&lt;p&gt;First you need to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(setf fiveam:*run-test-when-defined* t)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then the test is run after each definition / compilation. This can be done with C-c C-c on emacs.&lt;/p&gt; &#xA;&lt;h2&gt;See also&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the &lt;a href=&#34;https://lispcookbook.github.io/cl-cookbook/strings.html&#34;&gt;Common Lisp Cookbook&lt;/a&gt;, strings page.&lt;/li&gt; &#xA; &lt;li&gt;my &lt;a href=&#34;https://www.udemy.com/course/common-lisp-programming/?referralCode=2F3D698BBC4326F94358&#34;&gt;Common Lisp course on Udemy: from novice to effective developer&lt;/a&gt;. Check out my blog for regular coupons.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://lisp-journey.gitlab.io/&#34;&gt;https://lisp-journey.gitlab.io/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;video: &lt;a href=&#34;https://www.youtube.com/watch?v=XFc513MJjos&#34;&gt;how to create a Common Lisp project from scratch with our project generator&lt;/a&gt;: it sums up in 5 minutes what took me a much longer time to gather.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Inspired by the famous Emacs Lisp&#39;s &lt;a href=&#34;https://github.com/magnars/s.el&#34;&gt;s.el&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>