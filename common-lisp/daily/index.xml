<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-01T01:36:38Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>deepin-community/clisp</title>
    <updated>2022-10-01T01:36:38Z</updated>
    <id>tag:github.com,2022-10-01:/deepin-community/clisp</id>
    <link href="https://github.com/deepin-community/clisp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>deepin-community/cl-babel</title>
    <updated>2022-10-01T01:36:38Z</updated>
    <id>tag:github.com,2022-10-01:/deepin-community/cl-babel</id>
    <link href="https://github.com/deepin-community/cl-babel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/cl-babel/babel&#34;&gt;&lt;img src=&#34;https://travis-ci.org/cl-babel/babel.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Babel is a charset encoding/decoding library, not unlike GNU libiconv, but completely written in Common Lisp.&lt;/p&gt; &#xA;&lt;p&gt;It strives to achieve decent performance. To that effect, we use OpenMCL&#39;s approach of calculating the destination buffer size in advance. Most of the encoding/decoding algorithms have been adapted from OpenMCL&#39;s source.&lt;/p&gt; &#xA;&lt;p&gt;Another important goal is reusability. Similarly to SBCL, we define an interface wherein the algorithms can be reused between a variety of data types so long we&#39;re dealing with conversions between octets and unicode code points.&lt;/p&gt; &#xA;&lt;p&gt;Babel comes with converters between strings and (unsigned-byte 8) vectors but can be easily extended to deal with, e.g., strings and foreign memory, vectors and Closure&#39;s runes, etc...&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>deepin-community/cl-regex</title>
    <updated>2022-10-01T01:36:38Z</updated>
    <id>tag:github.com,2022-10-01:/deepin-community/cl-regex</id>
    <link href="https://github.com/deepin-community/cl-regex" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;(documentation from: &lt;a href=&#34;url:http://www.geocities.com/mparker762/clawk.html&#34;&gt;url:http://www.geocities.com/mparker762/clawk.html&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;REGEX package&lt;/p&gt; &#xA;&lt;p&gt;The regex engine is a pretty full-featured matcher, and thus is useful by itself. It was originally written as a prototype for a C++ matcher, though it has since diverged greatly.&lt;/p&gt; &#xA;&lt;p&gt;The regex compiler supports the following pattern syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;* ^ matches the start of a string.&#xA;* $ matches the end of a string.&#xA;* [...] denotes a character class.&#xA;* [^...] denotes a negated character class.&#xA;* [:...:] denotes a special character class.&#xA;      o [:alpha:] == [A-Za-z]&#xA;      o [:upper:] == [A-Z]&#xA;      o [:lower:] == [a-z]&#xA;      o [:digit:] == [0-9]&#xA;      o [:alnum:] == [A-Za-z0-9]&#xA;      o [:xdigit:] == [A-Fa-f0-9]&#xA;      o [:space:] == whitespace&#xA;      o [:punct:] == punctuation marks&#xA;      o [:graph:] == printable characters other than space&#xA;      o [:cntrl:] == control characters&#xA;      o [:word:] == wordlike characters&#xA;      o [^:...:] denotes a negated special character class.&#xA;* . matches any character.&#xA;* (...) delimits a regex subexpression. Also denotes a register pattern.&#xA;* (?...) denotes a regex subexpression that will not be captured in a register.&#xA;* (?=...) denotes a regex subexpression that will be used as a forward&#xA;lookahead. If the subexpression matches, then the rest of the match will&#xA;continue as if the lookahead match had not occurred (i.e. it does not consume&#xA;the candidate string). It will not be captured in a register, though it can&#xA;contain subexpressions that may be captured.&#xA;* (?!...) denotes a regex subexpression that will be used as a negative&#xA;forward lookahead (the match will continue only if the lookahead failed to&#xA;match). It will not be captured in a register, though it can contain&#xA;subexpressions that may be captured.&#xA;* * denotes the kleene closure of the previous regex subexpression.&#xA;* + denotes the positive closure of the previous regex subexpression.&#xA;* *? denotes the non-greedy kleene closure of the previous regex subexpression.&#xA;* +? denotes the non-greedy positive closure of the previous regex subexpression.&#xA;* ? denotes the greedy match of 0 or 1 occurrences of the previous regex subexpression.&#xA;* ?? denotes the non-greedy match of 0 or 1 occurrences of the previous&#xA;regex subexpression.&#xA;* \nn denotes a back-match against the contents of a previously-matched register.&#xA;* {nn,mm} denotes a bounded repetition.&#xA;* {nn,mm}? denotes a non-greedy bounded repetition.&#xA;* \n, \t, \r have their normal meanings.&#xA;* \d matches any decimal character, \D matches any nondecimal character.&#xA;* \w matches any wordlike character, \W matches any nonwordlike character.&#xA;* \s matches any whitespace character, \S matches any nonspace character.&#xA;* \&amp;lt; matches at the start of a word. \&amp;gt; matches at the end of a word.&#xA;* \&amp;lt;char&amp;gt; that character (escapes an otherwise special meaning).&#xA;* Special characters lose their specialness when escaped. There is a flag&#xA;to control this.&#xA;* All other characters are matched literally.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a variety of functions in the REGEX package that allow the programmer to adjust the allowable regular expression syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;* The function ESCAPE-SPECIAL-CHARS allows you to change whether the&#xA;meta-characters have their magic meaning when escaped or unescaped. The default&#xA;behavior (per AWK syntax) is that special chars are unescaped.&#xA;* The function ALLOW-BACKMATCH allows you to change whether or not the \nn&#xA;syntax is allowed. By default it is allowed.&#xA;* The function ALLOW-RANGEMATCH allows you to change whether or not the the&#xA;{nn,mm} bounded repetition syntax is allowed. By default it is allowed.&#xA;* The function ALLOW-NONGREEDY-QUANTIFIERS allows you to change whether or&#xA;not the *?, +?, ??, and {nn,mm}? quantifiers are recognized. By default they&#xA;are allowed.&#xA;* The function ALLOW-NONREGISTER-GROUPS allows you to change whether or not&#xA;the (?...) syntax is recognized. By default it is allowed.&#xA;* The function DOT-MATCHES-NEWLINE allows you to change whether &#39;.&#39; in a&#xA;pattern matches the newline character. This is false by default.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Parenthesized expressions within the pattern are considered a register pattern, and will be recorded for use after the match. There is an implicit set of parentheses around the entire expression, so the bounds of the matched text itself will always occupy register 0.&lt;/p&gt; &#xA;&lt;p&gt;Extensions that will be coming soon include:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;I am working on a second backend for the regex compiler that generates an even faster matcher (~4-20x faster on Symbolics, ~ 2x faster on LWW). The compilation process itself is substantially slower. I&#39;ve got some more work to do to get the speed up even further on Lispworks, although the current system is already much, much faster than GNU Regex.&lt;/li&gt; &#xA; &lt;li&gt;Optionally allowing a negated regex pattern using the &#xA;  &lt;pattern&gt;&#xA;    &#39;^&#39; syntax. This also subsumes the negated character class in that [^...] === [...]^.&#xA;  &lt;/pattern&gt;&lt;/li&gt; &#xA; &lt;li&gt;Faster scans by using a possible-prefix set. This isn&#39;t real high priority at the moment since matching is plenty fast already :-)&lt;/li&gt; &#xA; &lt;li&gt;Prefix and postfix context patterns ala LEX.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Regex has been recently enhanced. Everything from the parser back has been completely rewritten. The regex system now includes a bunch of functions for manipulating regex parse trees directly, a multipass optimizer and code generator, and a new matching engine.&lt;/p&gt; &#xA;&lt;p&gt;The new regex system does a better job of optimizing a wider range of patterns. It also supports an extension that allows you to provide an &#34;accept&#34; function to the match-str function. This acceptfn takes the start and end position as parameters, and can find the string itself in the special variable &lt;em&gt;STR&lt;/em&gt; and the registers in the special variable &lt;em&gt;regs&lt;/em&gt;. It returns either nil to force the matcher to backtrack, or a non-nil value which will be returned as the success code for the match.&lt;/p&gt; &#xA;&lt;p&gt;An additional change is that register patterns within quantified patterns now return the leftmost occurrence in the source string. There is a flag to force the more usual rightmost match, but this will reduce the applicability of many critical optimizations.&lt;/p&gt; &#xA;&lt;p&gt;The latest version of regex supports the Perl \d, \D, \w, \W, \s, and \S metasequences, as well as the egrep &amp;lt; start-of-word and &amp;gt; end-of-word metasequences.&lt;/p&gt;</summary>
  </entry>
</feed>