<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-18T01:32:10Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>attila-lendvai/maru</title>
    <updated>2023-02-18T01:32:10Z</updated>
    <id>tag:github.com,2023-02-18:/attila-lendvai/maru</id>
    <link href="https://github.com/attila-lendvai/maru" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Maru - a tiny self-hosting lisp dialect&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Maru&lt;/h1&gt; &#xA;&lt;h2&gt;What&lt;/h2&gt; &#xA;&lt;p&gt;Maru is a programming language. It&#39;s a &lt;a href=&#34;https://en.wikipedia.org/wiki/Self-hosting_(compilers)&#34;&gt;self-hosting&lt;/a&gt;, yet tiny &lt;a href=&#34;https://en.wikipedia.org/wiki/Lisp_(programming_language)&#34;&gt;lisp&lt;/a&gt; dialect: a symbolic expression evaluator that can compile its own implementation to &lt;a href=&#34;https://en.wikipedia.org/wiki/Machine_code&#34;&gt;machine code&lt;/a&gt;, in about 2000 LoC altogether.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Maru is in particular trying to be malleable at the very lowest levels, so any special interest that cannot be accommodated easily within the common platform would be a strong indicator of a deficiency within the platform that should be addressed rather than disinherited. (Ian Piumarta)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This repo is also a place for exploration in the land of &lt;a href=&#34;https://raw.githubusercontent.com/attila-lendvai/maru/maru.10/doc/bootstrap.md&#34;&gt;bootstrapping&lt;/a&gt; and computing system development. My primary drive with Maru is to clearly and formally express that which is mostly treated as black magic: the bootstrapping of a language on top of other languages (which includes the previous developmental stage of the same language).&lt;/p&gt; &#xA;&lt;h2&gt;Meta&lt;/h2&gt; &#xA;&lt;p&gt;This document aims to present an overview of Maru. There are various documents in the &lt;a href=&#34;https://raw.githubusercontent.com/attila-lendvai/maru/maru.10/doc/&#34;&gt;&lt;code&gt;doc/&lt;/code&gt;&lt;/a&gt; directory that discuss some topics in more detail.&lt;/p&gt; &#xA;&lt;h2&gt;How&lt;/h2&gt; &#xA;&lt;p&gt;Maru&#39;s architecture is described in &lt;a href=&#34;https://raw.githubusercontent.com/attila-lendvai/maru/maru.10/doc/how.md&#34;&gt;doc/how.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Build instructions&lt;/h4&gt; &#xA;&lt;p&gt;To test a bootstrap cycle using one or all of the backends:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make test-bootstrap-x86    # defaults to the libc platform&#xA;make PLATFORM=[libc,linux] test-bootstrap[-llvm,-x86]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Platform specific instructions&lt;/summary&gt; &#xA; &lt;h4&gt;Nix and NixOS&lt;/h4&gt; &#xA; &lt;p&gt;My primary platform. There&#39;s a &lt;code&gt;default.nix&lt;/code&gt; file in the repo, so you can run &lt;code&gt;nix-shell&lt;/code&gt; to enter into the same environment that I use when I work on Maru.&lt;/p&gt; &#xA; &lt;h4&gt;Debian, and derivatives&lt;/h4&gt; &#xA; &lt;pre&gt;&lt;code&gt;sudo apt install make time rlwrap&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;You will need LLVM, and/or a C compiler (any version beyond LLVM 8 should work):&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;sudo apt install llvm clang&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;For now the x86 backend only supports 32 bit mode. To use it you will need to have support for compiling and running 32 bit C code. On Debian based x86_64 systems this will install all the necessary libraries:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;sudo apt install gcc-multilib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;h4&gt;MacOS&lt;/h4&gt; &#xA; &lt;p&gt;Please note that recent MacOS versions don&#39;t support 32 bit executables anymore, but Maru&#39;s LLVM backend should work fine. I don&#39;t test it regularly, so things may not always work out of the box.&lt;/p&gt; &#xA; &lt;ol&gt; &#xA;  &lt;li&gt;Make sure XCode is installed. In a Terminal:&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;pre&gt;&lt;code&gt;xcode-select --install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;ol start=&#34;2&#34;&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://brew.sh/&#34;&gt;Install Homebrew&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;pre&gt;&lt;code&gt;/bin/bash -c &#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;ol start=&#34;3&#34;&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://embeddedartistry.com/blog/2017/02/24/installing-llvm-clang-on-osx/&#34;&gt;Install LLVM using Homebrew&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ol&gt; &#xA; &lt;pre&gt;&lt;code&gt;brew install llvm&#xA;echo export PATH=&#34;$(brew --prefix llvm)/bin:$PATH&#34; &amp;gt;&amp;gt; ~/.bash_profile&#xA;source ~/.bash_profile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;h4&gt;Other platforms&lt;/h4&gt; &#xA; &lt;p&gt;Currently Maru should work everywhere where there&#39;s a &lt;code&gt;libc&lt;/code&gt;, and either the GNU toolchain, or LLVM is available.&lt;/p&gt; &#xA; &lt;p&gt;Patches are welcome for other platforms.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Who&lt;/h2&gt; &#xA;&lt;p&gt;Originally written by &lt;a href=&#34;https://www.piumarta.com/software/maru/&#34;&gt;Ian Piumarta&lt;/a&gt;, at around 2011. Full commit history is available in the &lt;a href=&#34;https://github.com/attila-lendvai/maru/tree/piumarta&#34;&gt;&lt;code&gt;piumarta&lt;/code&gt;&lt;/a&gt; branch.&lt;/p&gt; &#xA;&lt;p&gt;The current gardener is &lt;a href=&#34;mailto:attila@lendvai.name&#34;&gt;attila@lendvai.name&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Where&lt;/h2&gt; &#xA;&lt;p&gt;Bugs and patches: &lt;a href=&#34;https://github.com/attila-lendvai/maru&#34;&gt;maru github page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Discussion: &lt;a href=&#34;https://groups.google.com/forum/#!forum/maru-dev&#34;&gt;maru-dev google group&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Why&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Programming badly needs &lt;a href=&#34;https://github.com/nagydani/seedling/raw/master/RATIONALE.md&#34;&gt;better foundations&lt;/a&gt;, and Maru is part of this exploration. The foundations should get &lt;strong&gt;smaller, simpler, more self-contained, and more approachable&lt;/strong&gt; by people who set out to learn programming.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;We lose a lot of value by not capturing the history of the growth of a language, including the formal encoding of its build instructions. They are useful both for educational purposes, and also for practical reasons: to have a minimal seed that is very simple to port to a new architecture, and then have a self-contained, formal bootstrap process that can automatically &#34;grow&#34; an entire computing system on top of that freshly laid, tiny foundation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Maru is very small: in about 1700 lines of code in the &lt;code&gt;maru.1&lt;/code&gt; branch it can self-host (plus around 2300 LoC of throwaway C code for the initial step).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ian seems to have stopped working on Maru, but it&#39;s an interesting piece of code that deserves a repo and a maintainer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;This work is full of puzzles that are a whole lot of fun to solve!&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;You are very welcome to contribute, but beware that until further notice &lt;strong&gt;this repo will receive forced pushes&lt;/strong&gt; (i.e. &lt;strong&gt;&lt;code&gt;git push -f&lt;/code&gt;&lt;/strong&gt; rewriting git history (except the &lt;code&gt;piumarta&lt;/code&gt; branch)). This will stop eventually when I settle with a build setup that nicely facilitates bootstrapping multiple, parallel paths of language development. Please make sure that you open a branch for your work, and/or that you are ready for some &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git rebase&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;h3&gt;Maru&#39;s status&lt;/h3&gt; &#xA;&lt;p&gt;Backporting and bootstrapping the latest semantics from the &lt;code&gt;piumarta&lt;/code&gt; branch is done: the &lt;code&gt;eval.l&lt;/code&gt; in the latest branch of this repo should be semantically equivalent with the &lt;code&gt;eval.l&lt;/code&gt; that resides in the &lt;code&gt;piumarta&lt;/code&gt; branch, although, we have arrived to this state on two different paths:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Ian, while evolving Maru, kept his &lt;code&gt;eval.c&lt;/code&gt; and &lt;code&gt;eval.l&lt;/code&gt; semantically in sync&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;while I have bootstrapped the new features: I started out from an earlier version of the &lt;code&gt;eval.l&lt;/code&gt; + &lt;code&gt;eval.c&lt;/code&gt; couple (the &lt;a href=&#34;https://www.piumarta.com/software/maru/&#34;&gt;minimal ones&lt;/a&gt; published on Ian&#39;s website). Then I bootstrapped the later stages of &lt;code&gt;eval.l&lt;/code&gt; using an earlier stage of itself. I only used the C code as the initial stepping stone in the bootstrap process, and then I left it behind.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Notable new features&lt;/h3&gt; &#xA;&lt;p&gt;There are several Maru stages/branches now, introducing non-trivial new features. Some that are worth mentioning:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Introduction of &lt;a href=&#34;https://raw.githubusercontent.com/attila-lendvai/maru/maru.10/platforms.md&#34;&gt;&lt;em&gt;platforms&lt;/em&gt;&lt;/a&gt;, and notably the &lt;code&gt;linux&lt;/code&gt; platform that compiles to a statically linked executable that only uses Linux kernel &lt;a href=&#34;https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux&#34;&gt;&lt;code&gt;syscalls&lt;/code&gt;&lt;/a&gt;; From a practical perspective this is almost equivalent with running directly on the bare metal (i.e. all dynamically allocated memory needs to be managed by our own GC, all IO behind our own abstractions, etc).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The host and the slave are isolated while bootstrapping which makes it possible to do things like reordering types (changing their type id in the target), or changing their object layout.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Relying on this isolation, the code in &lt;code&gt;eval.l&lt;/code&gt; now looks pretty much the same as something that is meant to be loaded into the evaluator (i.e. the function implementing &lt;code&gt;car&lt;/code&gt; in &lt;code&gt;eval.l&lt;/code&gt; is now called &lt;code&gt;car&lt;/code&gt;). This paves the way for metacircularity: to be able to &#34;bring alive&#34; the evaluator by loading it verbatim into another instance of itself (as opposed to compiling it to machine code and giving it to a CPU to bring it alive).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The addition of an LLVM backend.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Future plans&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Assorted TODO list&lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt; &lt;p&gt;Make Maru Scheme compatible, either by forking it, or by some sort of a compatibility layer that is loadable into vanilla Maru. Then consider how that relates to &lt;a href=&#34;https://www.gnu.org/software/mes/&#34;&gt;GNU Mes&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Finish the proof of concept in &lt;code&gt;tests/test-elf.l&lt;/code&gt; to compile the Linux plaform directly into an ELF binary. This would reduce the list of external dependencies to a single one (GNU Make).&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Rewrite the build process in Maru; eliminate dependency on GNU Make.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Replace the hand-written parser in &lt;code&gt;eval.l&lt;/code&gt; with something generated by a parser generator, maybe the &lt;a href=&#34;https://en.wikipedia.org/wiki/Parsing_expression_grammar&#34;&gt;PEG&lt;/a&gt; compiler. More generally, make the parser extendable.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Implement modules and phase separation along with what is outlined in &lt;a href=&#34;https://www.cs.utah.edu/plt/publications/gpce13-f-color.pdf&#34;&gt;Submodules in Racket - You Want it When, Again?&lt;/a&gt;. Part of this is already done and is used in the bootstrap process.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Compile to, and bootstrap on the bare metal of some interesting targets. It&#39;s already demonstrated by the Linux platform. Another one could be &lt;a href=&#34;https://github.com/cirosantilli/x86-bare-metal-examples&#34;&gt;pc-bios&lt;/a&gt;, or &lt;a href=&#34;https://kuroko-lang.github.io/&#34;&gt;EFI&lt;/a&gt;, because it&#39;s easily testable using QEMU. Or port it on an ARM board (like Raspberry Pi)? Or maybe even attempt a C64 port?&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Revive all the goodies in the &lt;code&gt;piumarta&lt;/code&gt; branch, but in a structured way.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Investigate &lt;a href=&#34;https://github.com/bytecodealliance/wasmtime/tree/main/cranelift&#34;&gt;Cranelift&lt;/a&gt; and consider adding it as a backend.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Simplify the types-are-objects part and its bootstrap, and maybe even make it optional?&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Weed out some of the added bloat/complexity (e.g. compile closures instead of &lt;code&gt;&amp;lt;selector&amp;gt;&lt;/code&gt;s, and use them to implement streams; write a tree shaker; etc).&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Merge the language and API that the compiler and the evaluator understands; i.e. make the level-shifted code (&lt;code&gt;eval.l&lt;/code&gt; &amp;amp; co.) less different than code understood by the evaluator. This would mean that we can e.g. load/compile &lt;code&gt;source/buffer.l&lt;/code&gt; both into the level-shifted code and into the evaluator. This is slowly happening, but it&#39;s nowhere near done, and I&#39;m not even sure what being done means here.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Use LLVM&#39;s &lt;a href=&#34;https://llvm.org/docs/TableGen/index.html&#34;&gt;tablegen&lt;/a&gt; definitions to generate bytecode assemblers. It requires either the reimplementation of the tablegen parser/logic in Maru (doesn&#39;t seem to be trivial), or writing C++ code (uhh!) to compile the data to the Maru definitions implementing an assembler.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Maybe add &lt;a href=&#34;https://www.piumarta.com/S3-2010/&#34;&gt;PEG-based tree rewriter&lt;/a&gt; to the repo as a branch. It seems to be an earlier iteration of the same idea.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Introduce a simplified language that drops some langauge features, e.g. remove &lt;em&gt;forms&lt;/em&gt; and the &lt;em&gt;expand&lt;/em&gt; protocol. Make sure that this language can bootstrap itself off of C99. Then reintroduce &lt;em&gt;forms&lt;/em&gt; and &lt;em&gt;expand&lt;/em&gt; by using this simplified Maru as the bootstrap host.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;Understand and incorporate François René Rideau&#39;s model of &lt;a href=&#34;https://www.youtube.com/watch?v=fH51qhI3hq0&#34;&gt;First Class Implementations: Climbing up the Semantic Tower&lt;/a&gt;, (see this &lt;a href=&#34;https://github.com/fare/climbing&#34;&gt;couple of page summary&lt;/a&gt;, or see his &lt;a href=&#34;http://fare.tunes.org/reflection.html&#34;&gt;page on reflection&lt;/a&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;History and perspective&lt;/h3&gt; &#xA;&lt;h4&gt;Around 2010-2013&lt;/h4&gt; &#xA;&lt;p&gt;Maru was developed as part of Alan Kay&#39;s &lt;em&gt;Fundamentals of New Computing&lt;/em&gt; project, by the &lt;em&gt;&lt;a href=&#34;https://web.archive.org/web/20111002111856/http://www.viewpointsresearch.org/fonc_wiki/index.php/Idst&#34;&gt;Viewpoints Research Institute&lt;/a&gt;&lt;/em&gt;. The goal of the project was to implement an entirely new, self-hosting computing system, with GUI, in 20.000 lines of code.&lt;/p&gt; &#xA;&lt;p&gt;At some point VPRI went quiet and closed down in 2018. Much of their online content disappeared, and the team (probably) also dissolved.&lt;/p&gt; &#xA;&lt;p&gt;Their annual reports: &lt;a href=&#34;http://www.vpri.org/pdf/tr2007008_steps.pdf&#34;&gt;2007&lt;/a&gt;, &lt;a href=&#34;http://www.vpri.org/pdf/tr2008004_steps08.pdf&#34;&gt;2008&lt;/a&gt;, &lt;a href=&#34;http://www.vpri.org/pdf/tr2009016_steps09.pdf&#34;&gt;2009&lt;/a&gt;, &lt;a href=&#34;http://www.vpri.org/pdf/tr2010004_steps10.pdf&#34;&gt;2010&lt;/a&gt;, &lt;a href=&#34;http://www.vpri.org/pdf/tr2011004_steps11.pdf&#34;&gt;2011&lt;/a&gt;, &lt;a href=&#34;http://www.vpri.org/pdf/tr2012001_steps.pdf&#34;&gt;2012&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;This git repo&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;piumarta&lt;/code&gt; branch of this git repo is a conversion of Ian Piumarta&#39;s Mercurial repo that was once available at &lt;a href=&#34;http://piumarta.com/hg/maru/&#34;&gt;http://piumarta.com/hg/maru/&lt;/a&gt;. To the best of my knowledge this is the latest publicly available state of Ian&#39;s work. This repo was full of assorted code, probably driving the VPRI demos.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;piumarta&lt;/code&gt; branch will be left stale (modulo small fixes and cleanups). My plan is to eventually revive most of the goodies from this branch, but in a more organized and approachable manner, and also paying attention to the bootstrapping issues.&lt;/p&gt; &#xA;&lt;p&gt;Ian published another Mercurial repo somewhere halfway in the commit history with only a couple of commits from around 2011. I assume that it was meant to hold the &lt;a href=&#34;https://www.piumarta.com/software/maru/&#34;&gt;minimal/historical version&lt;/a&gt; of Maru that can already self-host. I started out my work from this minimal repo (hence the divergence between the &lt;code&gt;piumarta&lt;/code&gt; and the &lt;code&gt;maru.x&lt;/code&gt; branches in this repo).&lt;/p&gt; &#xA;&lt;h4&gt;Other instances&lt;/h4&gt; &#xA;&lt;p&gt;There are some other copies/versions of Maru. Here are the ones that I know about and contain interesting code:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/melvinzhang/maru&#34;&gt;github.com/melvinzhang/maru&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/jbulow/below-the-top&#34;&gt;below-the-top&lt;/a&gt; is some kind of generic sexp tokenizer and evaluator written in Common Lisp that can be configured so that it can bootstrap Maru. I haven&#39;t tried it myself.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Related projects&lt;/h4&gt; &#xA;&lt;p&gt;A list of projects that are relevant in this context:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/nagydani/seedling/&#34;&gt;Seedling&lt;/a&gt;: a ladder of languages, with a minimalistic core language at the bottom called &lt;em&gt;Seed&lt;/em&gt; (it&#39;s a Forth like). Seed can self-host in less than 1k LoC. The higher level languages above Seed are (going to be) extensions of it, and are implemented on top of Seed. Porting to a new architecture will be trivial. And an interesting tidbit: the initial bootstrap was done not by using another programming language/compiler, but by pen and paper!&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://bootstrappable.org/&#34;&gt;bootstrappable.org&lt;/a&gt;: a community around bootstrapping, and making/keeping projects bootstrapable. It brings together many interesting projects: &lt;a href=&#34;https://github.com/oriansj/stage0&#34;&gt;stage0&lt;/a&gt; (~500 byte self-hosting hex assembler), &lt;a href=&#34;https://github.com/fosslinux/live-bootstrap/&#34;&gt;live-bootstrap&lt;/a&gt;, &lt;a href=&#34;https://www.gnu.org/software/mes/&#34;&gt;GNU Mes&lt;/a&gt; (Scheme + C, mutually self-hosting each other), &lt;a href=&#34;https://github.com/oriansj/m2-planet&#34;&gt;m2-planet&lt;/a&gt; (a tiny C compiler).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://intuitiveexplanations.com/tech/kalyn&#34;&gt;Kalyn&lt;/a&gt;: a subset of Haskell semantics (mostly; not lazy), but with Lisp syntax. Entirely (!) self-hosting over x86-64 in 4-5 kLoC. The project feels of high standard, including its documentation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/bkomuves/nanohs&#34;&gt;nanohs&lt;/a&gt;: a tiny self-hosting subset of Haskell.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.piumarta.com/S3-2010/&#34;&gt;PEG-based tree rewriter&lt;/a&gt;: runnable code to accompany Ian Piumarta&#39;s paper called &lt;em&gt;PEG-based tree rewriter provides front-, middle- and back-end stages in a simple compiler&lt;/em&gt;. Ian wrote this before Maru, and there are several similarities between the two. See the &lt;a href=&#34;https://groups.google.com/g/maru-dev/c/0Cnq1RB-Ahk&#34;&gt;mailing list thread&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/blynn/compiler&#34;&gt;blynn&#39;s Haskell compiler&lt;/a&gt;: bootstrap a Haskell compiler incrementally from C, with extensive documentation..&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://refpersys.org/&#34;&gt;RefPerSys&lt;/a&gt;: a mostly symbolic artificial intelligence long-term project, with ambitious Artificial General Intelligence goals. It contains interesting and relevant ideas, e.g. in &lt;a href=&#34;http://starynkevitch.net/Basile/refpersys-design.pdf&#34;&gt;refpersys-design.pdf&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://www.projectoberon.com/&#34;&gt;Project Oberon&lt;/a&gt;: a project which encompasses CPU, language, operating system and user interface, and which can be run on a relatively inexpensive FPGA board, and simple enough for one person to understand it all.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/kstephens/tort&#34;&gt;tort&lt;/a&gt;: Inspired by Ian Piumarta&#39;s idst, maru and other small runtimes. Core is approx. 5000 lines of C.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://web.cs.wpi.edu/~jshutt/kernel.html&#34;&gt;kernel&lt;/a&gt;: &#34;Kernel is a conservative, Scheme-like dialect of Lisp in which &lt;strong&gt;everything&lt;/strong&gt; is a first-class object.&#34; (including special forms) You may want to also see &lt;a href=&#34;https://axisofeval.blogspot.com/search/label/kernel&#34;&gt;this blog&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://bernsteinbear.com/blog/compiling-a-lisp-0/&#34;&gt;Compiling a Lisp: Overture&lt;/a&gt;: Educational article series about constructing a simple Lisp compiler, implemented in C.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>chfin/distsys_hw2</title>
    <updated>2023-02-18T01:32:10Z</updated>
    <id>tag:github.com,2023-02-18:/chfin/distsys_hw2</id>
    <link href="https://github.com/chfin/distsys_hw2" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Distributed Systems homework assignment 2&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DistSys homework assignment 2&lt;/h1&gt; &#xA;&lt;p&gt;A snapshot program.&lt;/p&gt; &#xA;&lt;p&gt;It listens on port 19835 for the line &#34;snapshot&#34; and saves a snapshot file in it&#39;s working direktory. Optionally, other hosts can be notified. To request a snapshot you can for example use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#34;snapshot&#34; | nc host 19835&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Python&lt;/h2&gt; &#xA;&lt;p&gt;Run the python version with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./snap.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can define hostnames to notify as additional arguments&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./snap.py host1 host2 ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Common Lisp&lt;/h2&gt; &#xA;&lt;p&gt;Ignore this ;)&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/chfin/distsys_hw2/raw/master/cl-snapshot/README.md&#34;&gt;cl-snapshot/README.md&lt;/a&gt; for instructions. This will not run on ukko, unless you compile a more recent version of sbcl yourself.&lt;/p&gt;</summary>
  </entry>
</feed>