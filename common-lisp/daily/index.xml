<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-25T01:26:50Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cffi/cffi</title>
    <updated>2023-10-25T01:26:50Z</updated>
    <id>tag:github.com,2023-10-25:/cffi/cffi</id>
    <link href="https://github.com/cffi/cffi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Common Foreign Function Interface&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/cffi/cffi&#34;&gt;&lt;img src=&#34;https://travis-ci.org/cffi/cffi.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;What&lt;/h1&gt; &#xA;&lt;p&gt;CFFI, the Common Foreign Function Interface, purports to be a portable FFI for Common Lisp. It abstracts away the differences between the API of the native FFI&#39;s of the various Common Lisp implementations.&lt;/p&gt; &#xA;&lt;h1&gt;How&lt;/h1&gt; &#xA;&lt;p&gt;The CFFI library is composed of a Lisp-implementation-specific backend in the CFFI-SYS package, and a portable frontend in the CFFI package.&lt;/p&gt; &#xA;&lt;p&gt;The CFFI-SYS backend package defines a low-level interface to the native FFI support in the Lisp implementation. It offers operators for allocating and dereferencing foreign memory, calling foreign functions, and loading shared libraries.&lt;/p&gt; &#xA;&lt;p&gt;The CFFI frontend provides a more comfortable, declarative interface for defining foreign functions, structures, typedefs, enumerated types, etc. It is implemented in portable ANSI CL making use of the low-level operators exported by CFFI-SYS.&lt;/p&gt; &#xA;&lt;p&gt;The CFFI-LIBFFI subsystem loads support for passing structs by value. It requires &lt;a href=&#34;https://sourceware.org/libffi/&#34;&gt;libffi&lt;/a&gt; for that.&lt;/p&gt; &#xA;&lt;p&gt;Please consult &lt;a href=&#34;http://common-lisp.net/project/cffi/manual/html_node/&#34;&gt;the manual&lt;/a&gt; for further details, including installation instructions.&lt;/p&gt; &#xA;&lt;h1&gt;Where&lt;/h1&gt; &#xA;&lt;p&gt;Please visit &lt;a href=&#34;https://github.com/cffi/cffi/issues&#34;&gt;Github&lt;/a&gt; for bug reports, feature suggestions, the latest version, and to send your contributions. CFFI also has a &lt;a href=&#34;https://mailman.common-lisp.net/listinfo/cffi-devel&#34;&gt;mailing list&lt;/a&gt;, and a project page at &lt;a href=&#34;https://cffi.common-lisp.dev/&#34;&gt;cffi.common-lisp.dev&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Notes&lt;/h1&gt; &#xA;&lt;h3&gt;CFFI/C2FFI&lt;/h3&gt; &#xA;&lt;p&gt;CFFI/C2FFI is an ASDF-integrated mechanism to automatically generate a complete CFFI binding from C header files.&lt;/p&gt; &#xA;&lt;p&gt;Its input is one &lt;code&gt;.h&lt;/code&gt; file (with possible &lt;code&gt;#include&lt;/code&gt;s of course), and its final output is a lisp file with the relevant CFFI binding forms.&lt;/p&gt; &#xA;&lt;p&gt;It requires a CLI tool called &lt;a href=&#34;https://github.com/rpav/c2ffi&#34;&gt;c2ffi&lt;/a&gt;, but only for the developers of the C binding libraries, not their users. &lt;code&gt;c2ffi&lt;/code&gt; is written in C++, and it uses Clang as a library to parse the C code, and emit the result as JSON. To skip this step, these host-specific JSON files can be checked into the repos of the binding libraries. This breaks the dependence on a working c2ffi binary and the C header files, which can be a hurdle.&lt;/p&gt; &#xA;&lt;p&gt;These JSON files are then used to automatically generate a CL file with the corresponding CFFI forms. The generated bindings mirror the C namespace into an empty CL package as closely as possible. This means that the upper/lower case of the C names are retained. It helps with reading the original docs and with rewriting C examples into lisp. &lt;code&gt;#define&lt;/code&gt;s are also mirrored as CL &lt;code&gt;defconstant&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;p&gt;Binding library developers are advised to introduce another package on top of this raw layer to add more lispy constructs where appropriate (e.g. &lt;code&gt;with-&lt;/code&gt; macros that manage resources, etc).&lt;/p&gt; &#xA;&lt;p&gt;Until CFFI/C2FFI is properly documented, you may check out these projects as examples: &lt;a href=&#34;https://github.com/hu-dwim/hu.dwim.zlib&#34;&gt;hu.dwim.zlib&lt;/a&gt;, &lt;a href=&#34;https://github.com/hu-dwim/hu.dwim.sdl&#34;&gt;hu.dwim.sdl&lt;/a&gt;, &lt;a href=&#34;https://github.com/hu-dwim/hu.dwim.bluez&#34;&gt;hu.dwim.bluez&lt;/a&gt;, and &lt;a href=&#34;https://github.com/attila-lendvai/hu.dwim.mosquitto&#34;&gt;hu.dwim.mosquitto&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Related projects&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rpav/cl-autowrap&#34;&gt;cl-autowrap&lt;/a&gt; is another project that uses &lt;code&gt;c2ffi&lt;/code&gt; to generate CFFI bindings.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>