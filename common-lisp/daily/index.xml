<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-12T01:35:18Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>atlas-engineer/njson</title>
    <updated>2022-09-12T01:35:18Z</updated>
    <id>tag:github.com,2022-09-12:/atlas-engineer/njson</id>
    <link href="https://github.com/atlas-engineer/njson" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Common Lisp JSON handling library, with the aim for convenience and brevity.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE:njson&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;A JSON handling framework aiming for convenience and brevity.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;NJSON aims to make it extremely convenient for you to decode and encode JSON data, in the minimum keystrokes/minutes possible.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;COMMENT Getting started Clone the Git repository: #+begin_src sh git clone --recursive &lt;a href=&#34;https://github.com/atlas-engineer/njson&#34;&gt;https://github.com/atlas-engineer/njson&lt;/a&gt; ~/common-lisp/ #+end_src&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Load NJSON in the REPL: #+begin_src lisp ;; Show ASDF where NJSON is. (asdf:load-asd #p&#34;/path/to/checkout/njson.asd&#34;) ;; Load it with ASDF. (asdf:load-system :njson) ;; Alternatively, load it with Quicklisp. (ql:quickload :njson) ;; NOTE: :NJSON system implicitly includes :NJSON/CL-JSON backend for ;; your convenience. If you want other backend, load :NJSON/BACKEND. #+end_src&lt;/p&gt; &#xA;&lt;p&gt;And start parsing right away, be it from file: #+begin_src lisp (njson:decode #p&#34;/path/to/njson/checkout/tests/test.json&#34;) ;; =&amp;gt; (1 3.8 T NIL :UNDEFINED :NULL &#34;foo&#34; (1 2 3) (&#34;bar&#34; 8.3 T :NULL 1000000) ;; #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 1 {100EAB1383}&amp;gt; ;; #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 3 {100EAB16D3}&amp;gt;)&lt;/p&gt; &#xA;&lt;p&gt;#+end_src&lt;/p&gt; &#xA;&lt;p&gt;or from string: #+begin_src lisp (njson:decode &#34;[&#34;hello&#34;, 5]&#34;) ;; =&amp;gt; (&#34;hello&#34;, 5) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;or other types. Default methods support:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;pathnames,&lt;/li&gt; &#xA; &lt;li&gt;strings,&lt;/li&gt; &#xA; &lt;li&gt;streams.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;What NJSON is not (and what it is, instead)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** NJSON is not a JSON parsing library.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s one level higher: it&#39;s a convenience wrapper around your JSON parser of choice. NJSON is made in such a way so as to be usable with almost any JSON library out there. The default backend is CL-JSON, that proven itself extensible enough.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To make NJSON support your preferred JSON parser, you have to specialize as little as two methods: &lt;del&gt;decode-json-from-stream&lt;/del&gt; and &lt;del&gt;encode-json-to-stream&lt;/del&gt;. If you care about correctness or proper type dispatching, you may also define &lt;del&gt;(en|de)code-json-(to|from)-string&lt;/del&gt; and &lt;del&gt;(en|de)code-json-(to|from)-file&lt;/del&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** NJSON is not propagating unnecessary dependencies on you.&lt;/p&gt; &#xA;&lt;p&gt;The dependencies of the core are pretty lightweight and are likely to be the dependencies of your project already:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Alexandria.&lt;/li&gt; &#xA; &lt;li&gt;Flexi Streams.&lt;/li&gt; &#xA; &lt;li&gt;Serapeum.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Every other dependency (including CL-JSON) is optional and depends on which backend you want to use for parsing.&lt;/p&gt; &#xA;&lt;p&gt;** NJSON is not the fastest JSON handling solution out there.&lt;/p&gt; &#xA;&lt;p&gt;Plug-n-play usability and type variety are much higher of a priority than the performance. The types NJSON returns from its methods (and that your own methods extending NJSON should expect/return) are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lisp &lt;del&gt;number&lt;/del&gt;-s for JSON numbers.&lt;/li&gt; &#xA; &lt;li&gt;Lisp strings for JSON strings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:null&lt;/del&gt; for JSON &lt;del&gt;null&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;t&lt;/del&gt; for &lt;del&gt;true&lt;/del&gt; and &lt;del&gt;nil&lt;/del&gt; for &lt;del&gt;false&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;del&gt;:undefined&lt;/del&gt; for &lt;del&gt;undefined&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Lists for JSON arrays.&lt;/li&gt; &#xA; &lt;li&gt;Hash-tables for JSON objects.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With this basic (yet disjoint) set of types, you can easily &lt;del&gt;typecase&lt;/del&gt; over NJSON output and make informed decisions about the JSON you have.&lt;/p&gt; &#xA;&lt;p&gt;** NJSON is not minimalist.&lt;/p&gt; &#xA;&lt;p&gt;NJSON has strict requirements on the returned data, but this strictness enables a rich set of JSON-handling primitives/helpers. You can safely import those helpers into your code if you are concerned with convenient JSON handling; or you can define a package local nickname for NJSON to be a mere &lt;del&gt;j:&lt;/del&gt;, so that these helpers are just a couple of characters longer than the regular Lisp constructs. The helpers are:&lt;/p&gt; &#xA;&lt;p&gt;*** FUNCTION njson:jget (alias: njson:get_)&lt;/p&gt; &#xA;&lt;p&gt;Gets the value from the JSON object/array indexed by a certain key&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (njson:jget &#34;key&#34; (njson:decode &#34;{&#34;key&#34;: 5}&#34;)) ;; =&amp;gt; 5 (njson:jget 5 (njson:decode &#34;[0, 1, 2, 3, 4, 5]&#34;)) ;; =&amp;gt; 5 #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** FUNCTION njson:jrem (alias: njson:rem_)&lt;/p&gt; &#xA;&lt;p&gt;Removes the value from the JSON object/array indexed by a certain key&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defvar data (njson:decode &#34;{&#34;key&#34;: 5}&#34;)) data ;; =&amp;gt; #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 1 {1007F2F1A3}&amp;gt; (njson:jrem &#34;key&#34; data) data ;; =&amp;gt; #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 0 {1007F2F1A3}&amp;gt; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** FUNCTION njson:jtruep (aliases: njson:jtrue-p, njson:jtrue?, njson:truep, njson:true-p, njson:true?)&lt;/p&gt; &#xA;&lt;p&gt;Checks whether the given value is true (in other words, neither &lt;del&gt;false&lt;/del&gt;, nor &lt;del&gt;null&lt;/del&gt;) per JSON standard.&lt;/p&gt; &#xA;&lt;p&gt;All the macros below utilize it, so, if you want to change the behavior of those, specialize this function. *** MACRO njson:jwhen (alias: njson:when_)&lt;/p&gt; &#xA;&lt;p&gt;A regular CL &lt;del&gt;when&lt;/del&gt; made aware of JSON&#39;s &lt;del&gt;null&lt;/del&gt; and &lt;del&gt;false&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (njson:jwhen (njson:decode &#34;null&#34;) &#34;This is never returned.&#34;) ;; nil (njson:jwhen (njson:decode &#34;5&#34;) &#34;This is always returned.&#34;) ;; &#34;This is always returned&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** MACRO njson:if (alias: njson:if_)&lt;/p&gt; &#xA;&lt;p&gt;A regular Lisp &lt;del&gt;if&lt;/del&gt; aware of JSON truths and lies.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (njson:jif (njson:decode &#34;5&#34;) &#34;This is always returned.&#34; &#34;This is never returned.&#34;) ;; &#34;This is always returned&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;*** MACRO njson:jor, njson:jand, njson:jnot (and aliases: njson:or_, njson:and_, njson:not_)&lt;/p&gt; &#xA;&lt;p&gt;Regular Lisp logic operators, with awareness of JSON values.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Roadmap&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Make an in-depth guide on supporting other backends.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>