<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-29T01:33:16Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>40ants/openrpc</title>
    <updated>2022-10-29T01:33:16Z</updated>
    <id>tag:github.com,2022-10-29:/40ants/openrpc</id>
    <link href="https://github.com/40ants/openrpc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;OpenRPC implementation for Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-DOCS-2FINDEX-3A-40README-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;OpenRPC for Common Lisp&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/40ants/openrpc/actions&#34;&gt;&lt;img src=&#34;https://github-actions.40ants.com/40ants/openrpc/matrix.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This framework is built on top of &lt;a href=&#34;https://github.com/cxxxr/jsonrpc&#34;&gt;&lt;code&gt;JSON-RPC&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/fukamachi/clack&#34;&gt;&lt;code&gt;Clack&lt;/code&gt;&lt;/a&gt;. Comparing to &lt;code&gt;JSON-RPC&lt;/code&gt; library, it provides these key features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatic &lt;a href=&#34;https://spec.open-rpc.org/&#34;&gt;OpenRPC spec&lt;/a&gt; generation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatic &lt;code&gt;JSON-RPC&lt;/code&gt; client building by Open&lt;code&gt;RPC&lt;/code&gt; spec. This includes creation of Common Lisp classes and methods for making &lt;code&gt;RPC&lt;/code&gt; requests and returning native &lt;code&gt;CL&lt;/code&gt; objects.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;On both server and client sides your code looks very lispy, all &lt;code&gt;JSON&lt;/code&gt; marshalling is done under the hood.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FDOCS-3A-3A-40SERVER-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Server&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FDOCS-3A-3A-40DEFINING-METHODS-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Defining Methods&lt;/h3&gt; &#xA;&lt;p&gt;Here is an example of openrpc-server &lt;code&gt;ASDF&lt;/code&gt; system allows to define &lt;code&gt;JSON-RPC&lt;/code&gt; methods and data-structures they return.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s see how we can define an &lt;code&gt;API&lt;/code&gt; for usual PetShop example.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FDOCS-3A-3A-40SIMPLE-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Simple Example&lt;/h4&gt; &#xA;&lt;p&gt;First, we will operate on usual Common Lisp class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defclass pet ()&#xA;  ((id :initarg :id&#xA;       :type integer&#xA;       :reader pet-id)&#xA;   (name :initarg :name&#xA;         :type string&#xA;         :reader pet-name)&#xA;   (tag :initarg :tag&#xA;        :type string&#xA;        :reader pet-tag)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can define an &lt;code&gt;RPC&lt;/code&gt; method to create a new pet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(openrpc-server:define-rpc-method create-pet (name tag)&#xA;  (:param name string)&#xA;  (:param tag string)&#xA;  (:result pet)&#xA;  (let* ((new-id (get-new-id))&#xA;         (pet (make-instance &#39;pet&#xA;                             :id new-id&#xA;                             :name name&#xA;                             :tag tag)))&#xA;    (setf (gethash new-id *pets*)&#xA;          pet)&#xA;    pet))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we should explicitly specify type for each parameter and result&#39;s type.&lt;/p&gt; &#xA;&lt;p&gt;But to make this work with our pet class, we have to define a two more methods. First one will tell framework to which &lt;code&gt;JSON-SCHEMA&lt;/code&gt; should be mapped objects of this type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defmethod type-to-schema ((type (eql &#39;pet)))&#xA;  (dict &#34;type&#34; &#34;object&#34;&#xA;        &#34;properties&#34; (dict &#34;id&#34; (type-to-schema &#39;integer)&#xA;                           &#34;name&#34; (type-to-schema &#39;string)&#xA;                           &#34;tag&#34; (type-to-schema &#39;string))&#xA;        &#34;required&#34; (list &#34;id&#34; &#34;name&#34; &#34;tag&#34;)&#xA;        &#34;x-cl-class&#34; (symbol-name type)&#xA;        &#34;x-cl-package&#34; (package-name (symbol-package type))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And second method should transform pet instance into simple datastructures according to scheme. Later result of this transformation will be serialized to &lt;code&gt;JSON&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defmethod transform-result ((obj pet))&#xA;  (dict &#34;id&#34; (pet-id obj)&#xA;        &#34;name&#34; (pet-name obj)&#xA;        &#34;tag&#34; (pet-tag obj)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Probably, someday framework will generate these methods automatically, using types from &lt;code&gt;DEFCLASS&lt;/code&gt; form.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FDOCS-3A-3A-40LISTS-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Returning Lists&lt;/h4&gt; &#xA;&lt;p&gt;To return result as a list of objects of some kind, use &lt;code&gt;(:result (list-of pet))&lt;/code&gt; form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(openrpc-server:define-rpc-method list-pets ()&#xA;  (:param limit integer)&#xA;  (:param page-key integer)&#xA;  (:result (list-of pet))&#xA;  (retrieve-all-pets))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FDOCS-3A-3A-40PAGINATION-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Paginated Results&lt;/h4&gt; &#xA;&lt;p&gt;Sometimes your system might operate on a lot of objects and you don&#39;t want to return all of them at once. For this case, framework supports a &lt;a href=&#34;https://use-the-index-luke.com/no-offset&#34;&gt;keyset pagination&lt;/a&gt;. To use it, your method should accept &lt;code&gt;LIMIT&lt;/code&gt; argument and &lt;code&gt;PAGE-KEY&lt;/code&gt; argument. And if there are more results, than method should return as a second value the page key for retrieving the next page.&lt;/p&gt; &#xA;&lt;p&gt;In this simplified example, we&#39;ll return &lt;code&gt;(list 1 2 3)&lt;/code&gt; for the first page, &lt;code&gt;(list 4 5 6)&lt;/code&gt; for the second and &lt;code&gt;(list 7 8)&lt;/code&gt; for the third. Pay attention how &lt;code&gt;VALUES&lt;/code&gt; form is used for first two pages but omitted for the third:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(openrpc-server:define-rpc-method list-pets (&amp;amp;key (limit 3) page-key)&#xA;  (:param limit integer)&#xA;  (:param page-key integer)&#xA;  (:result (paginated-list-of integer))&#xA;&#xA;  (cond&#xA;    ((null page-key)&#xA;     (values (list 1 2 3)&#xA;             3))&#xA;    ((= page-key 3)&#xA;     (values (list 4 5 6)&#xA;             6))&#xA;    (t&#xA;      (list 7 8))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of cause, in the real world application, you should use &lt;code&gt;PAGE-KEY&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; arguments in the &lt;code&gt;WHERE&lt;/code&gt; &lt;code&gt;SQL&lt;/code&gt; clause.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FDOCS-3A-3A-40STARTING-SERVER-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Using Clack to Start Server&lt;/h3&gt; &#xA;&lt;p&gt;Framework is based on Clack. Use &lt;a href=&#34;https://40ants.com/openrpc/#x-28OPENRPC-SERVER-2FCLACK-3AMAKE-CLACK-APP-20FUNCTION-29&#34;&gt;&lt;code&gt;make-clack-app&lt;/code&gt;&lt;/a&gt; to create an application suitable for serving with &lt;code&gt;CLACK:CLACKUP&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Then just start the web application as usual.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(clack:clackup (make-clack-app)&#xA;               :address interface&#xA;               :port port)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, you might use any Lack middlewares. For example, here is how &#34;mount&#34; middleware can be used to make &lt;code&gt;API&lt;/code&gt; work on &lt;code&gt;/api/&lt;/code&gt; &lt;code&gt;URL&lt;/code&gt; path, while the main application is working on other &lt;code&gt;URL&lt;/code&gt; paths:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defparameter *app*&#xA;  (lambda (env)&#xA;    &#39;(200 (:content-type &#34;text/plain&#34;) (&#34;Hello, World!&#34;))))&#xA;&#xA;(clack:clackup&#xA; (lambda (app)&#xA;   (funcall (lack.util:find-middleware :mount)&#xA;            app&#xA;            &#34;/api&#34;&#xA;            (make-clack-app)))&#xA; *app*)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FDOCS-3A-3A-40SPEC-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;OpenRPC Spec&lt;/h3&gt; &#xA;&lt;p&gt;The key feature of the framework, is an automatic &lt;code&gt;OpenRPC spec&lt;/code&gt; generation.&lt;/p&gt; &#xA;&lt;p&gt;When you have your &lt;code&gt;API&lt;/code&gt; up and running, spec will be available on &lt;code&gt;/openrpc.json&lt;/code&gt; path. For our example project it will looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;methods&#34;: [&#xA;    {&#xA;      &#34;name&#34;: &#34;rpc.discover&#34;,&#xA;      &#34;params&#34;: [],&#xA;      &#34;result&#34;: {&#xA;        &#34;name&#34;: &#34;OpenRPC Schema&#34;,&#xA;        &#34;schema&#34;: {&#xA;          &#34;$ref&#34;: &#34;https://raw.githubusercontent.com/open-rpc/meta-schema/master/schema.json&#34;&#xA;        }&#xA;      }&#xA;    },&#xA;    {&#xA;      &#34;name&#34;: &#34;list-pets&#34;,&#xA;      &#34;params&#34;: [&#xA;        {&#xA;          &#34;name&#34;: &#34;page-key&#34;,&#xA;          &#34;schema&#34;: {&#xA;            &#34;type&#34;: &#34;integer&#34;&#xA;          }&#xA;        },&#xA;        {&#xA;          &#34;name&#34;: &#34;limit&#34;,&#xA;          &#34;schema&#34;: {&#xA;            &#34;type&#34;: &#34;integer&#34;&#xA;          }&#xA;        }&#xA;      ],&#xA;      &#34;result&#34;: {&#xA;        &#34;name&#34;: &#34;list-pets-result&#34;,&#xA;        &#34;schema&#34;: {&#xA;          &#34;type&#34;: &#34;object&#34;,&#xA;          &#34;properties&#34;: {&#xA;            &#34;items&#34;: {&#xA;              &#34;type&#34;: &#34;array&#34;,&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FDOCS-3A-3A-40API-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;API&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FMETHOD-3ADEFINE-RPC-METHOD-20-2840ANTS-DOC-2FLOCATIVES-3AMACRO-29-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/40ants/openrpc/master/dbb3&#34;&gt;macro&lt;/a&gt; &lt;code&gt;openrpc-server/method:define-rpc-method&lt;/code&gt; name args &amp;amp;body body&lt;/h4&gt; &#xA;&lt;p&gt;Macro to define &lt;code&gt;RPC&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;All arguments should have corresponding (:param arg type) form in the &lt;code&gt;BODY&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Also, there should be one (:result type) form in the &lt;code&gt;BODY&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FINTERFACE-3ATYPE-TO-SCHEMA-20GENERIC-FUNCTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/40ants/openrpc/master/034c&#34;&gt;generic-function&lt;/a&gt; &lt;code&gt;openrpc-server/interface:type-to-schema&lt;/code&gt; type&lt;/h4&gt; &#xA;&lt;p&gt;This method is called for all types for which &lt;a href=&#34;https://40ants.com/openrpc/#x-28OPENRPC-SERVER-2FINTERFACE-3APRIMITIVE-TYPE-P-20GENERIC-FUNCTION-29&#34;&gt;&lt;code&gt;primitive-type-p&lt;/code&gt;&lt;/a&gt; generic-function returns &lt;code&gt;NIL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It should return as hash-table with &lt;code&gt;JSON-SCHEMA&lt;/code&gt; corresponding to type. Keys of the dictionary should be strings. It is convenient to use &lt;code&gt;SERAPEUM:DICT&lt;/code&gt; for building the result.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FINTERFACE-3ATRANSFORM-RESULT-20GENERIC-FUNCTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/40ants/openrpc/master/0a8a&#34;&gt;generic-function&lt;/a&gt; &lt;code&gt;openrpc-server/interface:transform-result&lt;/code&gt; object&lt;/h4&gt; &#xA;&lt;p&gt;Prepares object for serialization before responding to &lt;code&gt;RPC&lt;/code&gt; call.&lt;/p&gt; &#xA;&lt;p&gt;Result should be list, hash-map or a value of primitive type.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FINTERFACE-3APRIMITIVE-TYPE-P-20GENERIC-FUNCTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/40ants/openrpc/master/bab5&#34;&gt;generic-function&lt;/a&gt; &lt;code&gt;openrpc-server/interface:primitive-type-p&lt;/code&gt; type&lt;/h4&gt; &#xA;&lt;p&gt;Should return t for type if it&#39;s name matched to simple types supported by &lt;a href=&#34;https://json-schema.org/&#34;&gt;JSON-SCHEMA&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Argument &lt;code&gt;TYPE&lt;/code&gt; is a symbol.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FINTERFACE-3AMAKE-INFO-20GENERIC-FUNCTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/40ants/openrpc/master/da44&#34;&gt;generic-function&lt;/a&gt; &lt;code&gt;openrpc-server/interface:make-info&lt;/code&gt; server&lt;/h4&gt; &#xA;&lt;p&gt;Returns a basic information about &lt;code&gt;API&lt;/code&gt; for &lt;a href=&#34;https://spec.open-rpc.org/#info-object&#34;&gt;info section&lt;/a&gt; of Open&lt;code&gt;RPC&lt;/code&gt; spec.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FERRORS-3ARETURN-ERROR-20FUNCTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/40ants/openrpc/master/5950&#34;&gt;function&lt;/a&gt; &lt;code&gt;openrpc-server/errors:return-error&lt;/code&gt; message &amp;amp;key (code -1)&lt;/h4&gt; &#xA;&lt;p&gt;Raises an error to interrupt processing and return status to the caller.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-SERVER-2FCLACK-3AMAKE-CLACK-APP-20FUNCTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/40ants/openrpc/master/1b8d&#34;&gt;function&lt;/a&gt; &lt;code&gt;openrpc-server/clack:make-clack-app&lt;/code&gt; &amp;amp;key (http t) (websocket t)&lt;/h4&gt; &#xA;&lt;p&gt;Returns an Clack application to serve &lt;code&gt;JSON-RPC&lt;/code&gt; &lt;code&gt;API&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;x-28OPENRPC-CLIENT-2FDOCS-3A-3A-40CLIENT-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Client&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;OPENRPC-CLIENT&lt;/code&gt; &lt;code&gt;ASDF&lt;/code&gt; system provides a way to build &lt;code&gt;CL&lt;/code&gt; classes and methods for working with &lt;code&gt;JSON-RPC&lt;/code&gt; &lt;code&gt;API&lt;/code&gt;. All you need is to give it an &lt;code&gt;URL&lt;/code&gt; and all code will be created in compile-time as a result of macro-expansion.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a id=&#34;generating&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Generating&lt;/h3&gt; &#xA;&lt;p&gt;For example, this macro call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#xA;(generate-client petshop&#xA;                 &#34;http://localhost:8000/openrpc.json&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Will generate the whole bunch of classes and methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defclass petshop (jsonrpc/class:client) nil)&#xA;&#xA;(defun make-petshop () (make-instance &#39;petshop))&#xA;&#xA;(defmethod describe-object ((openrpc-client/core::client petshop) stream)&#xA;  (format stream &#34;Supported RPC methods:~2%&#34;)&#xA;  (format stream &#34;- ~S~%&#34; &#39;(rpc-discover))&#xA;  (format stream &#34;- ~S~%&#34;&#xA;          &#39;(list-pets &amp;amp;key (page-key nil page-key-given-p)&#xA;            (limit nil limit-given-p)))&#xA;  (format stream &#34;- ~S~%&#34; &#39;(create-pet (name string) (tag string)))&#xA;  (format stream &#34;- ~S~%&#34; &#39;(get-pet (id integer))))&#xA;&#xA;(defclass pet nil&#xA;  ((id :initform nil :initarg :id :reader pet-id)&#xA;   (name :initform nil :initarg :name :reader pet-name)&#xA;   (tag :initform nil :initarg :tag :reader pet-tag)))&#xA;&#xA;(defmethod print-object ((openrpc-client/core::obj pet) stream)&#xA;  (print-unreadable-object (openrpc-client/core::obj stream :type t)&#xA;    (format stream &#34; ~A=~S&#34; &#39;id (pet-id openrpc-client/core::obj))&#xA;    (format stream &#34; ~A=~S&#34; &#39;name (pet-name openrpc-client/core::obj))&#xA;    (format stream &#34; ~A=~S&#34; &#39;tag (pet-tag openrpc-client/core::obj))))&#xA;&#xA;(defmethod rpc-discover ((openrpc-client/core::client petshop))&#xA;  ...)&#xA;&#xA;(defmethod list-pets&#xA;    ((openrpc-client/core::client petshop)&#xA;     &amp;amp;key (page-key nil page-key-given-p) (limit nil limit-given-p))&#xA;  ...)&#xA;&#xA;(defmethod create-pet&#xA;    ((openrpc-client/core::client petshop) (name string) (tag string))&#xA;  ...)&#xA;&#xA;(defmethod get-pet ((openrpc-client/core::client petshop) (id integer))&#xA;  ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a id=&#34;using&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Using&lt;/h3&gt; &#xA;&lt;p&gt;When client is generated, you need to make an instance of it and to connect it to the server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(let ((cl (make-petshop)))&#xA;    (jsonrpc:client-connect cl :url &#34;http://localhost:8000/&#34; :mode :http)&#xA;    cl)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use any transport, supported by &lt;code&gt;JSONRPC&lt;/code&gt; library.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;DESCRIBE-OBJECT&lt;/code&gt; method is defined for a client, so you might see which methods are supported right in the &lt;code&gt;REPL&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp-repl&#34;&gt;OPENRPC-EXAMPLE/CLIENT&amp;gt; (defvar *client* (make-test-client))&#xA;#&amp;lt;PETSHOP {1007AB2B13}&amp;gt;&#xA;&#xA;OPENRPC-EXAMPLE/CLIENT&amp;gt; (describe *client*)&#xA;Supported RPC methods:&#xA;&#xA;- (RPC-DISCOVER)&#xA;- (LIST-PETS &amp;amp;KEY (PAGE-KEY NIL PAGE-KEY-GIVEN-P)&#xA;             (LIMIT NIL LIMIT-GIVEN-P))&#xA;- (CREATE-PET (NAME STRING) (TAG STRING))&#xA;- (GET-PET (ID INTEGER))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then to call these methods as usually you do in Common Lisp. Pay attention, that the library returns not &lt;code&gt;JSON&lt;/code&gt; dictionaries, but ready to use &lt;code&gt;CL&lt;/code&gt; class instances:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp-repl&#34;&gt;OPENRPC-EXAMPLE/CLIENT&amp;gt; (create-pet *client* &#34;Bobik&#34; &#34;the dog&#34;)&#xA;#&amp;lt;PET  ID=1 NAME=&#34;Bobik&#34; TAG=&#34;the dog&#34;&amp;gt;&#xA;&#xA;OPENRPC-EXAMPLE/CLIENT&amp;gt; (create-pet *client* &#34;Murzik&#34; &#34;the cat&#34;)&#xA;#&amp;lt;PET  ID=2 NAME=&#34;Murzik&#34; TAG=&#34;the cat&#34;&amp;gt;&#xA;&#xA;OPENRPC-EXAMPLE/CLIENT&amp;gt; (create-pet *client* &#34;Homa&#34; &#34;the hamster&#34;)&#xA;#&amp;lt;PET  ID=3 NAME=&#34;Homa&#34; TAG=&#34;the hamster&#34;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, pay attention how pagination does work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp-repl&#34;&gt;OPENRPC-EXAMPLE/CLIENT&amp;gt; (list-pets *client* :limit 2)&#xA;(#&amp;lt;PET  ID=1 NAME=&#34;Bobik&#34; TAG=&#34;the dog&#34;&amp;gt;&#xA; #&amp;lt;PET  ID=2 NAME=&#34;Murzik&#34; TAG=&#34;the cat&#34;&amp;gt;)&#xA;#&amp;lt;FUNCTION (FLET OPENRPC-CLIENT/CORE::RETRIEVE-NEXT-PAGE :IN LIST-PETS) {1006D1F3CB}&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This call has returned a list of objects as the first value and a closure, which can be called to retrive the next page. Let&#39;s retrieve it now!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp-repl&#34;&gt;OPENRPC-EXAMPLE/CLIENT&amp;gt; (funcall #v167:1)&#xA;(#&amp;lt;PET  ID=3 NAME=&#34;Homa&#34; TAG=&#34;the hamster&#34;&amp;gt;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now this is the last page and there is now a closure to retrieve the next page. Learn more how to implement pagination on server-side in the &lt;a href=&#34;https://40ants.com/openrpc/#x-28OPENRPC-SERVER-2FDOCS-3A-3A-40PAGINATION-2040ANTS-DOC-2FLOCATIVES-3ASECTION-29&#34;&gt;&lt;code&gt;Paginated Results&lt;/code&gt;&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h6&gt;[generated by &lt;a href=&#34;https://40ants.com/doc/&#34;&gt;40ANTS-DOC&lt;/a&gt;]&lt;/h6&gt;</summary>
  </entry>
</feed>