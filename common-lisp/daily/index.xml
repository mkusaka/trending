<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-18T01:31:06Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rpav/turipong</title>
    <updated>2022-12-18T01:31:06Z</updated>
    <id>tag:github.com,2022-12-18:/rpav/turipong</id>
    <link href="https://github.com/rpav/turipong" rel="alternate"></link>
    <summary type="html">&lt;p&gt;TuriPong .. PLTG Dec2012 challenge&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;TURIPONG&lt;/h1&gt; &#xA;&lt;p&gt;Turipong is inspired by Befunge and Pong for the Dec2012 PLT Games. Befunge is too straightforward and useful. Enter Turipong:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Balls are state, each contains a stack&lt;/li&gt; &#xA; &lt;li&gt;Walls are operations&lt;/li&gt; &#xA; &lt;li&gt;Flow control is literally redirecting the ball&lt;/li&gt; &#xA; &lt;li&gt;Parallelism is multiple balls&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;            &amp;gt;&#xA;    @       &amp;gt;&#xA;       1n   &amp;gt;&#xA;       1n    &#xA;   ,   1n   `&#xA;   ,   -    `&#xA;   ,          &#xA;              &#xA;     222?????&#xA;            ` &#xA;            `&#xA;        y   `&#xA;        y     &#xA;        y   &amp;gt; &#xA;            &amp;gt;&#xA;            &amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Walls are placed about a field. To keep things simple for version 1.0, there aren&#39;t player-controlled paddles. Input is via a text file. Operations are as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34; &#34;&lt;/code&gt; (blank, space): The ball passes through.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;: Append an alphanumeric character to the top of the stack, and bounce. &#34;_&#34; appends a space character.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;,&lt;/code&gt;: Push a new blank onto the stack, if there is not already a &lt;em&gt;blank&lt;/em&gt; value. (Can separate other non-blank false values.) Think of this as a &#34;stack separator&#34;. Bounce.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&#34;`&#34;&lt;/code&gt; (backtick): Pop a value from the stack. It gets lost. Bounce.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:&lt;/code&gt;: Duplicate the value on the stack. Bounce.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;;&lt;/code&gt;: Swap the top two values on the stack. Bounce.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;: Output the top of the stack to stdout, and bounce. If the top of the stack is a &lt;em&gt;blank&lt;/em&gt; (the blank string, via &lt;code&gt;,&lt;/code&gt;, not a space), a newline is printed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;: Input one char, appending to the top value on the stack, as per alphanumerics. If there is no input, nothing is appended. Bounce.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;?&lt;/code&gt;: Test. If the top of the stack is a blank, space, or zero, the ball will pass through as if the &#34;?&#34; is a &#34; &#34;. Otherwise, bounce.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;!&lt;/code&gt;: Not. If the state of the ball is other than false, the state is set to 0. If the state is false, the state is set to &#34;1&#34;. In any case, bounce.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;+&lt;/code&gt;: Add the top two numbers on the stack, or concatenate the top two strings on the stack. Bounce.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-&lt;/code&gt;: Subtract the top two numbers on the stack. Note this subtracts the topmost &lt;em&gt;from&lt;/em&gt; the next-topmost; e.g., if you push 2, then 1, and subtract, you get 1, not -1. Bounce.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;@&lt;/code&gt;: The ball. Balls bounce off each other. When doing so, they exchange the top of their stack. Balls always start off moving at a 45Â° angle in the southeast direction. When a ball leaves the field, its state is removed and it is considered to have exited. When all balls have exited, the program finishes.&lt;/li&gt; &#xA; &lt;li&gt;Other: Bounce. The stack is unchanged.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;This is written in Common Lisp and will thus require a Common Lisp to run. Put &lt;code&gt;turipong.asd&lt;/code&gt; somewhere your CL can find it, and do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(asdf:load-system :turipong)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run Turipong files in one of the following ways:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;; Basic load and run:&#xA;(turipong:run-program-file &#34;/PATH/TO/FILE.tp&#34;)&#xA;&#xA;;; Load and run with ANSI output, only works on a term:&#xA;(turipong.visual:run-program-file &#34;/PATH/TO/FILE.tp&#34;)&#xA;&#xA;;; Load and print a lot, not pretty, but possibly useful:&#xA;(let ((program (turipong:read-program-file &#34;/PATH/TO/FILE&#34;)))&#xA;  (turipong:print-program program)&#xA;  (loop while (turipong:runningp program) do&#xA;    (turipong:run-iteration program)&#xA;    (turipong:print-program program)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that your CL will probably default to &lt;code&gt;$HOME&lt;/code&gt; as the current working directory.&lt;/p&gt; &#xA;&lt;h1&gt;Types&lt;/h1&gt; &#xA;&lt;p&gt;Turipong is weakly-typed. The stack always contains a string, but this may be interpreted as a number if it contains only digits. The space character or zero are considered false, as is an actual blank (i.e., zero-length string), which can be obtained using &#34;,&#34;.&lt;/p&gt; &#xA;&lt;h1&gt;Bounces&lt;/h1&gt; &#xA;&lt;p&gt;Understanding the exact method for bouncing is critical. A ball has a given motion vector &lt;code&gt;#(ROW COLUMN)&lt;/code&gt;. However, bounces happen on surfaces first:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   @X&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If this were a roguelike, @ could probably move past X diagonally with no problem. However, in Turipong, this is a bounce (slashes used for illustration):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  \&#xA;   @X&#xA;  /&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Likewise:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; \ /&#xA;  @&#xA;  X&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, if we do hit edges, the ball will bounce back directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; \&#xA;  @&#xA;   X&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The ball will return the direction it came from. However, what happens in corner cases, such as the following?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; \&#xA;  @X&#xA;  YZ&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You might predict that the ball returns in the direction it comes from, and you&#39;d be right, but what is the state of the ball after this? The state is actually &lt;em&gt;randomly&lt;/em&gt; &#34;XY&#34; or &#34;YX&#34;. But not Z! This is due to how bounces are processed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First, &lt;em&gt;randomly&lt;/em&gt; (50/50) check up/down or left/right&lt;/li&gt; &#xA; &lt;li&gt;Update the vector&lt;/li&gt; &#xA; &lt;li&gt;Check the opposite (left/right or up/down)&lt;/li&gt; &#xA; &lt;li&gt;Update the vector&lt;/li&gt; &#xA; &lt;li&gt;Check the diagonal&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In this case, we hit &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, then &lt;code&gt;Y&lt;/code&gt; or &lt;code&gt;X&lt;/code&gt;, and the vector is now &lt;code&gt;#(-1 -1)&lt;/code&gt;. Since there&#39;s nothing there (our &#34;&#34; is just for illustration!), the ball will be moving away with a random value.&lt;/p&gt; &#xA;&lt;p&gt;This is, of course, useful for producing random values. Like everything else, actually making use of this may prove to be a bit of work.&lt;/p&gt; &#xA;&lt;h1&gt;Conflicts&lt;/h1&gt; &#xA;&lt;p&gt;One type of conflict may happen if two balls attempt to move onto the same square:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; @   @&#xA;        1&#xA;        1&#xA;        1&#xA; &amp;gt;&#xA; &amp;gt;&#xA; &amp;gt;&#xA; &amp;gt;&#xA; &amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After a few steps, the balls will be moving in opposite directions, and try and collide (the &#34;*&#34; is a marker only):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;          1&#xA;          1&#xA;      @ @ 1&#xA;   &amp;gt;   *&#xA;   &amp;gt;&#xA;   &amp;gt;&#xA;   &amp;gt;&#xA;   &amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These will both try and occupy the space with the &#34;*&#34;. Motion happens in parallel, but Turipong will abort &lt;em&gt;one&lt;/em&gt; of the balls&#39; intended motion, and it will be evaluated again the following iteration.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;em&gt;effects&lt;/em&gt; will happen on both rounds. However, in this case, no effects happened on the round both balls tried to occupy the &#34;*&#34;, because the space is blank.&lt;/p&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;h2&gt;hello world&lt;/h2&gt; &#xA;&lt;p&gt;Doing some basic things is fairly simple:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  @   eee lll ___ ooo lll &amp;gt;&amp;gt;&amp;gt;&#xA;&#xA;&#xA;&#xA;    hhh lll ooo www rrr ddd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This prints &#34;hello world&#34; and exits. Of course, walls need not be more than one character, but it may make things easier.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Operations&lt;/h2&gt; &#xA;&lt;p&gt;Here are some basic operations framed in Turipong:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/rpav/turipong/raw/master/examples/add.tp&#34;&gt;Test&lt;/a&gt;: Basic test for equality; in this case we push 1 and 2 on the stack, subtract, and test. If they are equal, the ball will pass through the &lt;code&gt;???&lt;/code&gt; and print &lt;code&gt;y&lt;/code&gt;, otherwise it will bounce and print &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/rpav/turipong/raw/master/examples/input.tp&#34;&gt;I/O&lt;/a&gt;: Nothing special, just print three letters, input three characters, printing them. Also demonstrates newlines.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/rpav/turipong/raw/master/examples/swap.tp&#34;&gt;Message Passing&lt;/a&gt;: Parallelism isn&#39;t useful if processes can&#39;t communicate. Fortunately, Turipong implements message passing via you precisely timing the bounce of the ball.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/rpav/turipong/raw/master/examples/loop.tp&#34;&gt;Loops&lt;/a&gt;: Make the ball go around and count down. This example could obviously use some optimization... tighten up the loop by actually shrinking it down!&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Beyond&lt;/h2&gt; &#xA;&lt;p&gt;Further examples are left to the reader as an exercise, probably in frustration. Turipong has just enough operations to make things seem easy, and just enough practical limitations to make them all painfully difficult. You will likely need to make heavy use of the visualizer, Emacs&#39; picture-mode, and trial and error.&lt;/p&gt;</summary>
  </entry>
</feed>