<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-26T01:24:34Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>DusteDdk/eepromlogic</title>
    <updated>2023-10-26T01:24:34Z</updated>
    <id>tag:github.com,2023-10-26:/DusteDdk/eepromlogic</id>
    <link href="https://github.com/DusteDdk/eepromlogic" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Use EEPROM chips as programmable logic&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Easily use EEPROMs as programmable logic&lt;/h1&gt; &#xA;&lt;p&gt;Once upon a time in the old world, someone way smarter than me observed that EEPROM memory chips can be used as a programmable logic devices.&lt;/p&gt; &#xA;&lt;p&gt;You can consider the address pins as input pins, and the data pins as output pins. You can define arbitrarily complex logic expressions for each output pin.&lt;/p&gt; &#xA;&lt;p&gt;Said even less elegant, whatever logic function you can dream up, as long as its input relies only on the state of the input pins, you can make the EEPROM carry out.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Example: One of each of the common logic gates, just write the generated &#34;gates.bin&#34; to the EEPROM chip and wire it up.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(load &#34;eepromlogic.lisp&#34;)&#xA;(use-package :eeprom-logic)&#xA;&#xA;(truth nil &#34;gates.bin&#34; 0 65535&#xA;       (q (a0 a1) (and a0 a1))          ; Input on A0 and A1. Output on D0&#xA;       (q (a2 a3) (or a2 a3))           ; D1&#xA;       (q (a4 a5) (xor a4 a5))          ; D2&#xA;       (q (a6) (not a6))                ; D3&#xA;       (q (a7 a8) (nand a7 a8))         ; D4&#xA;       (q (a9 a10) (nor a9 a10))        ; D5&#xA;       (q (a11 a12) (xnor a11 a12))     ; D6&#xA;       (q () :off)                      ; D7 is always 0&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;This is a simple example. You&#39;re not limited to &#34;one gate per output&#34;, your expressions can be as complex as you need. See documentation and examples below.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Intrigued? Read and run the &lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/examples.lisp&#34;&gt;examples.lisp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The file contains a few examples of gates and other logic, such as 7 bit full adders with different pinouts, and a binary to hex 7 segment display decoder.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sbcl --load &#34;examples.lisp&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation / Reference&lt;/h2&gt; &#xA;&lt;p&gt;The following stuff is made available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#truth&#34;&gt;truth&lt;/a&gt; - Make truth table&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#Q&#34;&gt;q&lt;/a&gt; - Create expression for output bit&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#ltn&#34;&gt;ltn&lt;/a&gt; - Convert list of booleans to number&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#btn&#34;&gt;btn&lt;/a&gt; - Convert boolean to number&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#gates&#34;&gt;nand&lt;/a&gt; - 2 input logic&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#gates&#34;&gt;nor&lt;/a&gt; - 2 input logicocs below.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#gates&#34;&gt;xor&lt;/a&gt; - 2 input logic&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#gates&#34;&gt;xnor&lt;/a&gt; - 2 input logic&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Additionally, any LISP function can be used to build expressions.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Which EEPROMs can I use ?&lt;/h3&gt; &#xA;&lt;p&gt;You can use any eeprom arranged into 8 bytes, with up to 20 address, see &lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#eeprom-sizes&#34;&gt;EEPROM sizes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In my examples, I&#39;m using an Atmel AT27C512 (64Kx8). Feel free to expand this package to work with 16 bit chips.&lt;/p&gt; &#xA;&lt;h3&gt;How to think about descibing logic&lt;/h3&gt; &#xA;&lt;p&gt;When using this tool, it&#39;s helpful to think of what you&#39;re doing in a certain way: You are describing a desired output state for a given input state.&lt;/p&gt; &#xA;&lt;p&gt;Abstract enough for you? Okay, look at some chip, it has input pins and output pins, now, select a couple of input pins, and &lt;em&gt;ONE&lt;/em&gt; output pin.&lt;/p&gt; &#xA;&lt;p&gt;You want to describe the logic that sets the state of that &lt;em&gt;ONE&lt;/em&gt; output pin based on those specific input pins. Nothing more, nothing less.&lt;/p&gt; &#xA;&lt;p&gt;Basically, you will define 8 expressions, one for each output bit, which the &#34;truth&#34; function will then call, once for every possible bit combination, to generate the truth table.&lt;/p&gt; &#xA;&lt;p&gt;Always think about one &lt;em&gt;output&lt;/em&gt; pin at a time.&lt;/p&gt; &#xA;&lt;p&gt;That might feel constrained but it&#39;s not. You&#39;re totally free to use &lt;em&gt;as many or as few&lt;/em&gt; of the input pins, in whatever combination you want, along with any lisp function, to build your expression.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also fine to use the same input pins in the expressions for muliple output pins.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Start by having a look at the truth function and q macro.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Truth&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#truth-function&#34;&gt;Truth function&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#truth-checks&#34;&gt;Truth logic check&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#eeprom-sizes&#34;&gt;Truth lastAddr: EEPROM sizes&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Truth function&lt;/h3&gt; &#xA;&lt;p&gt;The truth function generates the truth table. It can show it on the screen. It can also save it to a binary file, ready to write onto a EEPROM. This is the main function you&#39;ll want to call to do anything with this package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(truth&#xA;       show          ; Show truth table on console&#xA;       filename      ; Save binary to file&#xA;       firstAddr     ; Generate from this address&#xA;       lastAddr      ; Generate to this address&#xA;       q0            ; Logic expression for EEPROM pin Q0&#xA;       q1            ; Logic expression for EEPROM pin Q1&#xA;       q2            ; Logic expression for EEPROM pin Q2&#xA;       q3            ; Logic expression for EEPROM pin Q3&#xA;       q4            ; Logic expression for EEPROM pin Q3&#xA;       q5            ; Logic expression for EEPROM pin Q5&#xA;       q6            ; Logic expression for EEPROM pin Q6&#xA;       q7            ; Logic expression for EEPROM pin Q7&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;show - (t / nil) Show truth table on console so we can see how our expressions behave&lt;/li&gt; &#xA; &lt;li&gt;filename - (nil / string) If not nil: Save binary output to this filename&lt;/li&gt; &#xA; &lt;li&gt;firstAddr - Generate from this address (usually 0)&lt;/li&gt; &#xA; &lt;li&gt;lastAddr - Generate to this address (Usually EEPROM size, see &lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#eeprom-sizes&#34;&gt;eeprom sizes&lt;/a&gt;))&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You want &#34;show&#34; to be nil when generating a full truth-table, otherwise it&#39;s a lot of output.&lt;/p&gt; &#xA;&lt;p&gt;If you want to check the output of just a single pattern, you can set &#34;firstAddr&#34; and &#34;lastAddr&#34; to the same value, or a short range covering the patterns you want to check. The #b prefix to a number is convenient, so you can type in the binary pattern you want to see the output for. For example, to check what happens when both A0 and A2 is set, you could set both &#34;firstAddr&#34; and &#34;lastAddr&#34; to #b101&lt;/p&gt; &#xA;&lt;p&gt;The &#34;q&#34; parameters are lambda functions, but you won&#39;t notice that, use &lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#q&#34;&gt;the Q macro&lt;/a&gt; to write them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: The bit-order of the &#34;truth&#34; function is LSB (least significant bit first) because, I find it&#39;s easier to understand that I&#39;m defining the expression for the first bit first and the last bit last... This means that the q0 parameter to &#34;truth&#34; defines the logic behaviour for output bit 0, so it is the &lt;em&gt;rightmost&lt;/em&gt; bit in the truth table.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Everywhere else, the bit-order is MSB (most significant bit first).&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#truth&#34;&gt;Truth overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Truth checks&lt;/h4&gt; &#xA;&lt;p&gt;The truth function will check that all functions returned both t and nil at some point (that they are not always providing the same output), this check will fail if you write some logical error, such as &lt;code&gt;(and a0 (not a0))&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It will often fail when not generating the entire table, so if you expect your check to pass, but it fails, try using the full address range.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t want to implement any behaviour for an output, use the &lt;code&gt;:on &lt;/code&gt; or &lt;code&gt;:off &lt;/code&gt; symbol, instead of t or nil. This allows the checker to understand that it&#39;s intended that those outputs never change.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(q () :off) ; Bit always off&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#truth&#34;&gt;Truth overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;EEPROM Sizes&lt;/h4&gt; &#xA;&lt;p&gt;When generating a binary output file for writing to the EEPROM, be sure to select the correct &#34;firstAddr&#34; and &#34;lastAddr&#34;.&lt;/p&gt; &#xA;&lt;p&gt;&#34;firstAddr&#34; should probably always be 0.&lt;/p&gt; &#xA;&lt;p&gt;If you set the &#34;lastAddr&#34; value too small, your chip won&#39;t be fully programmed any floating address pins may generate wrong results.&lt;/p&gt; &#xA;&lt;p&gt;If you set the &#34;lastAddr&#34; value too large, the generated binary is too big and won&#39;t fit on the chip, you may truncate it, it might or might not work, but the logic check wouldn&#39;t have warned you if you requested address bits from pins not actually present on your chip.&lt;/p&gt; &#xA;&lt;p&gt;An easy way to set the right &#34;lastAddr&#34; is to simply count the address pins on your chip, and punch 1 for every pin, that binary number is your &#34;lastAddr&#34;, you can prefix a binary number with &lt;code&gt;#b&lt;/code&gt; and use it directly&lt;/p&gt; &#xA;&lt;p&gt;Example: For a chip with 10 address pins, the &#34;lastAddr&#34; is the binary number &#34;ten ones&#34;, so #b1111111111 in binary, #x3FF in hex and 1023 in decimal.&lt;/p&gt; &#xA;&lt;p&gt;&#34;truth&#34; don&#39;t care which representation you use, they&#39;re all the same number.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Chip&lt;/th&gt; &#xA;   &lt;th&gt;Size&lt;/th&gt; &#xA;   &lt;th&gt;Arrangement&lt;/th&gt; &#xA;   &lt;th&gt;Available addresses&lt;/th&gt; &#xA;   &lt;th&gt;lastAddr&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;27080&lt;/td&gt; &#xA;   &lt;td&gt;80 Mbit&lt;/td&gt; &#xA;   &lt;td&gt;1M x 8&lt;/td&gt; &#xA;   &lt;td&gt;A0 to A19&lt;/td&gt; &#xA;   &lt;td&gt;#xFFFFF&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;27040&lt;/td&gt; &#xA;   &lt;td&gt;40 Mbit&lt;/td&gt; &#xA;   &lt;td&gt;512K x 8&lt;/td&gt; &#xA;   &lt;td&gt;A0 to A18&lt;/td&gt; &#xA;   &lt;td&gt;#x7FFFF&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;27512&lt;/td&gt; &#xA;   &lt;td&gt;64 Kbit&lt;/td&gt; &#xA;   &lt;td&gt;64K x 8&lt;/td&gt; &#xA;   &lt;td&gt;A0 to A15&lt;/td&gt; &#xA;   &lt;td&gt;#xFFFF&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;27256&lt;/td&gt; &#xA;   &lt;td&gt;32 Kbit&lt;/td&gt; &#xA;   &lt;td&gt;32K x 8&lt;/td&gt; &#xA;   &lt;td&gt;A0 to A14&lt;/td&gt; &#xA;   &lt;td&gt;#x3FFF&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;27128&lt;/td&gt; &#xA;   &lt;td&gt;16 Kbit&lt;/td&gt; &#xA;   &lt;td&gt;16K x 8&lt;/td&gt; &#xA;   &lt;td&gt;A0 to A13&lt;/td&gt; &#xA;   &lt;td&gt;#x1FFF&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2764&lt;/td&gt; &#xA;   &lt;td&gt;64 Kbit&lt;/td&gt; &#xA;   &lt;td&gt;8K x 8&lt;/td&gt; &#xA;   &lt;td&gt;A0 to A12&lt;/td&gt; &#xA;   &lt;td&gt;#xFFF&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2732&lt;/td&gt; &#xA;   &lt;td&gt;32 Kbit&lt;/td&gt; &#xA;   &lt;td&gt;4K x 8&lt;/td&gt; &#xA;   &lt;td&gt;A0 to A11&lt;/td&gt; &#xA;   &lt;td&gt;#x7FF&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2716&lt;/td&gt; &#xA;   &lt;td&gt;16 Kbit&lt;/td&gt; &#xA;   &lt;td&gt;2K x 8&lt;/td&gt; &#xA;   &lt;td&gt;A0 to A10&lt;/td&gt; &#xA;   &lt;td&gt;#x3FF&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;You&lt;/td&gt; &#xA;   &lt;td&gt;get&lt;/td&gt; &#xA;   &lt;td&gt;the&lt;/td&gt; &#xA;   &lt;td&gt;idea&lt;/td&gt; &#xA;   &lt;td&gt;now&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2704&lt;/td&gt; &#xA;   &lt;td&gt;4 Kbit&lt;/td&gt; &#xA;   &lt;td&gt;512 X 8&lt;/td&gt; &#xA;   &lt;td&gt;A0 to A8&lt;/td&gt; &#xA;   &lt;td&gt;#xFF&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Note: &#34;truth&#34; don&#39;t detect if you request address bits for pins not on your chip, those bits will always be set to 0, and your logic will not work.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#truth&#34;&gt;Truth overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#documentation--reference&#34;&gt;Package overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Q&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#the-q-macro&#34;&gt;The Q Macro&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#q-extra-neatness&#34;&gt;Q - More detail&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#q-brain-melty-extra-messiness&#34;&gt;Q - Slightly weird stuff&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#q-clarification&#34;&gt;Q - Clarification&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;The Q Macro&lt;/h3&gt; &#xA;&lt;p&gt;The Q macro allows you to write a logic expression for an output pin (the data or &#34;Q&#34; pin on the EEPROM chip).&lt;/p&gt; &#xA;&lt;p&gt;You must provide an expression for each of the q0..q7 parameters that the &lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#truth&#34;&gt;truth&lt;/a&gt; function takes.&lt;/p&gt; &#xA;&lt;p&gt;Usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(q &#xA;       (inputs)&#xA;       logic)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(truth t nil 0 3                   ; Show truth table for address 0..3&#xA;       (q                          ; Create expression for pin Q0&#xA;              (a2 a5)              ; Request the a2 and a5 variables&#xA;              (and a2 (not a5)))   ; Implement the expression&#xA;&#xA;       (q                          ; Create expression for pin Q1&#xA;              (a1)                 ; Request the a1 variable&#xA;              (not a1))            ; Set pin Q1 to the inverse of A1&#xA;       &#xA;       (q                          ; Create expression for pin Q2&#xA;              (a2)                 ; Request a2 variable&#xA;              a2)                  ; Set pin Q2 equal to the state of A2&#xA;       ;; Snip for brewity, but all 8 Qs must be provided.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The logic expression is evaluated by &#34;truth&#34; for every possible input combination and its resulting state saved in the truth table.&lt;/p&gt; &#xA;&lt;p&gt;It works by you telling which input bits (address pins on the EEPROM chip) you want to consider in your expression, and an expression that returns the desired state of the output bit based on the state of those input bits.&lt;/p&gt; &#xA;&lt;p&gt;You can do whatever LISP you want in your expression, but remember each expression is evaluated only once per bitpattern, there&#39;s no state to be modified inside the EEPROM.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Your expression must return t or nil.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example, where we want pins A0, A5 and A10 for some reason, and we want the output bit to be 1 if exactly any two bits are set and 0 otherwise.&lt;/p&gt; &#xA;&lt;p&gt;We could implement this with pure boolean logic. But all of LISP is available and we can solve it however we please. In this example I convert the boolean state of the pins to numbers (1 or 0) and sum them, if the result is 2, then exactly two of the input pins were high.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(q (a0 a5 a10) ; Request the a0 a5 and a10 variables&#xA;       (eq (+ (btn a0) (btn a5) (btn a10)) 2)) ; The logic expression&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Remember that you can use the same input in as many of your expressions as you want:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(truth t nil 0 1&#xA;       (q (a0 a1) (and a0 a1)) ; q0 - Uses a0&#xA;       (q (a1 a2) (and a1 a2)) ; q1 - Also uses a0&#xA;       ; ... snip for brewity, all 8 Qs must be provided&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#q&#34;&gt;Q overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Q Extra neatness!&lt;/h4&gt; &#xA;&lt;p&gt;Q provides two other inputs, the first is easy to understand: &#34;adr&#34;, the integer value on the address bus.&lt;/p&gt; &#xA;&lt;p&gt;In this example, we want the output pin to be high whever the number present on the bus is in the range 16384..24576&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(q (adr) (and (&amp;gt;= adr 16384) (&amp;lt;= adr 24576)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also check for a specific address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(q (adr) (eq adr 34215))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;The adr variable is convenient for creating memory mappers, decoders and bus controllers.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#q&#34;&gt;Q overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Q Brain-melty extra messiness!&lt;/h4&gt; &#xA;&lt;p&gt;The next feature is slightly less obvious: When defining logic expressions for output pins HIGHER than q0, you can also access the output state of all the lower pins!&lt;/p&gt; &#xA;&lt;p&gt;For q0, there&#39;s no extra information, because there is no lower pin.&lt;/p&gt; &#xA;&lt;p&gt;For q1, you can access the output of q0 through a variable named d0&lt;/p&gt; &#xA;&lt;p&gt;For q7, you can access the output of q0..q6 through variables d0..d6!&lt;/p&gt; &#xA;&lt;p&gt;In this example, we define q7, let&#39;s say we want q7 to be high if &lt;em&gt;any&lt;/em&gt; other pin is high:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(q (d0 d1 d2 d3 d4 d5 d6) (or d0 d1 d2 d3 d4 d5 d6))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;re allowed to mix them all, say this might be for o3&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(q (d1 a0 adr) (and (&amp;gt; adr 5) (or d1 a0)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Q Clarification&lt;/h4&gt; &#xA;&lt;p&gt;The q macro allows you to request for for variables a0..a19 d0..d6 and &#34;adr&#34; to be available in your expression body, and then define a logic expression using those variables to determine the output state for the bit.&lt;/p&gt; &#xA;&lt;p&gt;&#34;adr&#34; is a number, a0..a19 and d0..d6 are boolean.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Wonder how to tell the q macro which bit you&#39;re defining output state for ?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;The argument position in the call to &#34;truth&#34; determines this. &#34;truth&#34; calls the every function in order from q0 to q7, first function describes expression for lowest bit, this should be clear if you re-read the &lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#truth-function&#34;&gt;truth function&lt;/a&gt; description.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Wonder how to tell the q macro that you don&#39;t want to implement anything on a pin, and not have the checker tell you about &#34;stuck bits&#34; ?&lt;/em&gt; See the &lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#truth-checks&#34;&gt;truth checks&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#q&#34;&gt;Q overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#documentation--reference&#34;&gt;Package overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Ltn&lt;/h3&gt; &#xA;&lt;p&gt;Convert list of booleans representing a binary number to a number, most significant bit first in list.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(ltn (list t t nil)) ; =&amp;gt; 6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#documentation--reference&#34;&gt;Package overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Btn&lt;/h3&gt; &#xA;&lt;p&gt;Convert a single boolean to number.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(btn (nil)) ; =&amp;gt; 0&#xA;(btn (t))   ; =&amp;gt; 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#documentation--reference&#34;&gt;Package overview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Gates&lt;/h3&gt; &#xA;&lt;p&gt;The gates nand nor xor xnor implement the logic functions they&#39;re named after.&lt;/p&gt; &#xA;&lt;p&gt;They all take exactly two boolean arguemnts and return a boolean value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(nand t t)&#xA;(xor a1 a5)&#xA;(nor d1 a6)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Remember, LISP also provides logic functions that you can use, among them are &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;logbitp&lt;/code&gt; and lots of other stuff I don&#39;t know about, but as long as it ends up t or nil, it&#39;s fine to use.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DusteDdk/eepromlogic/master/#documentation--reference&#34;&gt;Package overview&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>