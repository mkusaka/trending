<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-12T01:31:10Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dnaeon/cl-jingle</title>
    <updated>2022-12-12T01:31:10Z</updated>
    <id>tag:github.com,2022-12-12:/dnaeon/cl-jingle</id>
    <link href="https://github.com/dnaeon/cl-jingle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Common Lisp web framework with bells and whistles (based on ningle)&lt;/p&gt;&lt;hr&gt;&lt;ul&gt; &#xA; &lt;li&gt;jingle&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=jingle= is [[https://github.com/fukamachi/ningle][ningle]], but with bells and whistles.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Requirements&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[https://www.quicklisp.org/beta/][Quicklisp]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=jingle= is not yet in Quicklisp, so in order to install it you will need to clone the repo and add it to your [[https://www.quicklisp.org/beta/faq.html][Quicklisp local-projects]].&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell cd ~/quicklisp/local-projects git clone &lt;a href=&#34;https://github.com/dnaeon/jingle.git&#34;&gt;https://github.com/dnaeon/jingle.git&lt;/a&gt; #+end_src&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Start up your REPL and load the =JINGLE= system.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (ql:quickload :jingle) To load &#34;jingle&#34;: Load 1 ASDF system: jingle ; Loading &#34;jingle&#34; .................................................. [package jingle.core]............................. [package jingle]&lt;/p&gt; &#xA;&lt;p&gt;(:JINGLE) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;First thing we need to do is to create a new =JINGLE:APP= instance.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (defparameter &lt;em&gt;app&lt;/em&gt; (jingle:make-app)) &lt;em&gt;APP&lt;/em&gt; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;When creating a new instance of =JINGLE:APP= you can provide additional keyword args, which specify what HTTP server to use, address to bind to, the port to listen on, middlewares, etc..&lt;/p&gt; &#xA;&lt;p&gt;A very simple HTTP handler, which returns =Hello, World!= looks like this.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun hello-handler (params) (declare (ignore params)) &#34;Hello, World!&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The following is an example of an HTTP handler which echoes back the payload you send to it.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun echo-handler (params) &#34;A simple handler which echoes back the payload you send to it&#34; (declare (ignore params)) (jingle:set-response-header :content-type (jingle:request-content-type jingle:&lt;em&gt;request&lt;/em&gt;)) (jingle:set-response-header :content-length (jingle:request-content-length jingle:&lt;em&gt;request&lt;/em&gt;)) (maphash (lambda (k v) (jingle:set-response-header k v)) (jingle:request-headers jingle:&lt;em&gt;request&lt;/em&gt;)) (jingle:request-content jingle:&lt;em&gt;request&lt;/em&gt;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Next thing we need to do is register our handlers.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (setf (jingle:route &lt;em&gt;app&lt;/em&gt; &#34;/hello&#34;) #&#39;hello-handler) CL-USER&amp;gt; (setf (jingle:route &lt;em&gt;app&lt;/em&gt; &#34;/echo&#34; :method :post) #&#39;echo-handler) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;And now we can start the app.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (jingle:start &lt;em&gt;app&lt;/em&gt;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Trying out our endpoints using =curl(1)= gives us this result.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ curl -vvv --get &lt;a href=&#34;http://localhost:5000/hello&#34;&gt;http://localhost:5000/hello&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Trying 127.0.0.1:5000...&lt;/li&gt; &#xA; &lt;li&gt;Connected to localhost (127.0.0.1) port 5000 (#0)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;GET /hello HTTP/1.1 Host: localhost:5000 User-Agent: curl/7.86.0 Accept: &lt;em&gt;/&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mark bundle as not supporting multiuse &amp;lt; HTTP/1.1 200 OK &amp;lt; Date: Fri, 09 Dec 2022 09:46:13 GMT &amp;lt; Server: Hunchentoot 1.3.0 &amp;lt; Transfer-Encoding: chunked &amp;lt; Content-Type: text/html; charset=utf-8 &amp;lt;&lt;/li&gt; &#xA; &lt;li&gt;Connection #0 to host localhost left intact Hello, World! #+end_src&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And this is our echo handler.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ curl -v -s --data &#39;{&#34;foo&#34;: &#34;bar&#34;, &#34;baz&#34;: &#34;42&#34;}&#39; -H &#34;My-Header: SomeValue&#34; -H &#34;Content-Type: application/json&#34; -X POST &lt;a href=&#34;http://localhost:5000/echo&#34;&gt;http://localhost:5000/echo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Trying 127.0.0.1:5000...&lt;/li&gt; &#xA; &lt;li&gt;Connected to localhost (127.0.0.1) port 5000 (#0)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;POST /echo HTTP/1.1 Host: localhost:5000 User-Agent: curl/7.86.0 Accept: &lt;em&gt;/&lt;/em&gt; My-Header: SomeValue Content-Type: application/json Content-Length: 27&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mark bundle as not supporting multiuse &amp;lt; HTTP/1.1 200 OK &amp;lt; Date: Fri, 09 Dec 2022 13:57:30 GMT &amp;lt; Server: Hunchentoot 1.3.0 &amp;lt; My-Header: SomeValue &amp;lt; Accept: &lt;em&gt;/&lt;/em&gt; &amp;lt; User-Agent: curl/7.86.0 &amp;lt; Host: localhost:5000 &amp;lt; Content-Length: 27 &amp;lt; Content-Type: application/json &amp;lt;&lt;/li&gt; &#xA; &lt;li&gt;Connection #0 to host localhost left intact {&#34;foo&#34;: &#34;bar&#34;, &#34;baz&#34;: &#34;42&#34;} #+end_src&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In order to stop the application, evaluate the following expression.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (jingle:stop &lt;em&gt;app&lt;/em&gt;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Handlers&lt;/p&gt; &#xA;&lt;p&gt;Handlers are regular [[https://github.com/fukamachi/ningle][ningle]] routes, which accept a single argument, representing the request parameters.&lt;/p&gt; &#xA;&lt;p&gt;** Environment&lt;/p&gt; &#xA;&lt;p&gt;=jingle= exports the special variable =JINGLE:&lt;em&gt;ENV&lt;/em&gt;= which is dynamically bound to the request environment of [[https://github.com/fukamachi/lack][Lack]]. You can query the environment directly from =jingle= and don&#39;t have to worry about where the environment is coming from.&lt;/p&gt; &#xA;&lt;p&gt;** Headers&lt;/p&gt; &#xA;&lt;p&gt;=jingle= provides the =JINGLE:SET-RESPONSE-HEADER= function for setting up HTTP response headers.&lt;/p&gt; &#xA;&lt;p&gt;A simple handler which sets the =Content-Type= header to =text/plain= looks like this.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun hello (params) (declare (ignore params)) (jingle:set-response-header :content-type &#34;text/plain&#34;) &#34;Hello, World!&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Other useful functions which operate on HTTP headers are =JINGLE:GET-REQUEST-HEADER= and =JINGLE:GET-RESPONSE-HEADER=, which retrieve the value of the HTTP header associated with the request and response respectively.&lt;/p&gt; &#xA;&lt;p&gt;** Status Codes&lt;/p&gt; &#xA;&lt;p&gt;The =JINGLE:SET-RESPONSE-STATUS= function sets the Status Code for the HTTP Response.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun foo-handler (params) (declare (ignore params)) (jingle:set-response-status :accepted) &#34;Task accepted&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Arguments passed to =JINGLE:SET-RESPONSE-STATUS= may be a number (e.g. =400=), a keyword (e.g. =:bad-request=), or a string (e.g. =Bad Request=) of the status code. The following three expressions are equivalent, and they all set the HTTP Status Code to =400 (Bad Request)=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (jingle:set-response-status 400) (jingle:set-response-status :bad-request) (jingle:set-response-status &#34;Bad Request&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Another useful function operating on HTTP Status Codes is =JINGLE:EXPLAIN-STATUS-CODE=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (jingle:explain-status-code 400) &#34;Bad Request&#34; CL-USER&amp;gt; (jingle:explain-status-code :bad-request) &#34;Bad Request&#34; #+end_src&lt;/p&gt; &#xA;&lt;p&gt;=JINGLE:STATUS-CODE-KIND= returns the kind of the HTTP Status Code as classified by [[https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml][IANA]], e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (jingle:status-code-kind 400) :CLIENT-ERROR CL-USER&amp;gt; (jingle:status-code-kind :unauthorized) :CLIENT-ERROR CL-USER&amp;gt; (jingle:status-code-kind :internal-server-error) :SERVER-ERROR CL-USER&amp;gt; (jingle:status-code-kind :moved-permanently) :REDIRECTION CL-USER&amp;gt; (jingle:status-code-kind 100) :INFORMATIONAL CL-USER&amp;gt; (jingle:status-code-kind &#34;Accepted&#34;) :SUCCESS #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Other HTTP status code predicates you may find useful are =JINGLE:INFORMATIONAL-CODE-P=, =JINGLE:SUCCESS-CODE-P=, =JINGLE:REDIRECTION-CODE-P=, =JINGLE:CLIENT-ERROR-CODE-P= and =JINGLE:SERVER-ERROR-CODE-P=.&lt;/p&gt; &#xA;&lt;p&gt;** Static Resources&lt;/p&gt; &#xA;&lt;p&gt;Static resources can be served by adding them using =JINGLE:STATIC-PATH= method, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (jingle:static-path &lt;em&gt;app&lt;/em&gt; &#34;/static/&#34; &#34;~/public_html/&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can serve static resources from multiple directories as well. In order to do that simply install them, before you start up the app.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (jingle:static-path &lt;em&gt;app&lt;/em&gt; &#34;/static-1/&#34; &#34;/path/to/static-1/&#34;) (jingle:static-path &lt;em&gt;app&lt;/em&gt; &#34;/static-2/&#34; &#34;/path/to/static-2/&#34;) (jingle:static-path &lt;em&gt;app&lt;/em&gt; &#34;/static-3/&#34; &#34;/path/to/static-3/&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Directory Browser&lt;/p&gt; &#xA;&lt;p&gt;The =JINGLE:SERVE-DIRECTORY= method installs a middleware which allows you to browse the contents of a given path. For example the following code exposes the =&lt;del&gt;/Documents= and =&lt;/del&gt;/Projects= directories.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (jingle:serve-directory &lt;em&gt;app&lt;/em&gt; &#34;/docs&#34; &#34;&lt;del&gt;/Documents&#34;) (jingle:serve-directory &lt;em&gt;app&lt;/em&gt; &#34;/projects&#34; &#34;&lt;/del&gt;/Projects&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;When accessing the directories from the browser make sure to add a slash at the end of the paths. For example the above directories will have to accessed at &lt;a href=&#34;http://localhost:5000/docs/&#34;&gt;http://localhost:5000/docs/&lt;/a&gt; and &lt;a href=&#34;http://localhost:5000/projects/&#34;&gt;http://localhost:5000/projects/&lt;/a&gt; respectively, if you are using the default HTTP port when starting up the app.&lt;/p&gt; &#xA;&lt;p&gt;** Middlewares&lt;/p&gt; &#xA;&lt;p&gt;You can use regular [[https://github.com/fukamachi/lack#middlewares][Lack middlewares]] with =jingle= as well. Simply install them using the =JINGLE:INSTALL-MIDDLEWARE= method.&lt;/p&gt; &#xA;&lt;p&gt;The following simple middleware pushes a new property to the request environment, which can be queried by the HTTP handlers.&lt;/p&gt; &#xA;&lt;p&gt;First, implement the middleware.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun my-middleware (app) &#34;A custom middleware which pushes a new property to the request environment and exposes it to HTTP handlers.&#34; (lambda (env) (setf (getf env :my-middleware/message) &#34;my middleware message&#34;) (funcall app env))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Then we create a =JINGLE:APP= and install it.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (defparameter &lt;em&gt;app&lt;/em&gt; (jingle:make-app)) CL-USER&amp;gt; (jingle:install-middleware &lt;em&gt;app&lt;/em&gt; #&#39;my-middleware) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;An example handler which uses the message placed by our middleware may look like this.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun my-handler (params) (declare (ignore params)) (jingle:set-response-status :ok) (jingle:set-response-header :content-type &#34;text/plain&#34;) (getf jingle:&lt;em&gt;env&lt;/em&gt; :my-middleware/message)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Finally we have to register our handler and start the app.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (setf (jingle:route &lt;em&gt;app&lt;/em&gt; &#34;/my-middleware&#34;) #&#39;my-handler) CL-USER&amp;gt; (jingle:start &lt;em&gt;app&lt;/em&gt;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Trying it out using =curl(1)= returns the following response.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ curl -vvv --get &lt;a href=&#34;http://localhost:5000/my-middleware&#34;&gt;http://localhost:5000/my-middleware&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Trying 127.0.0.1:5000...&lt;/li&gt; &#xA; &lt;li&gt;Connected to localhost (127.0.0.1) port 5000 (#0)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;GET /my-middleware HTTP/1.1 Host: localhost:5000 User-Agent: curl/7.86.0 Accept: &lt;em&gt;/&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mark bundle as not supporting multiuse &amp;lt; HTTP/1.1 200 OK &amp;lt; Date: Fri, 09 Dec 2022 11:42:17 GMT &amp;lt; Server: Hunchentoot 1.3.0 &amp;lt; Transfer-Encoding: chunked &amp;lt; Content-Type: text/plain &amp;lt;&lt;/li&gt; &#xA; &lt;li&gt;Connection #0 to host localhost left intact my middleware message #+end_src&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here&#39;s an example which uses Lack&#39;s =accesslog= middleware and how to use it with =jingle=. First, load the respective system, which provides the middleware, and then simply install it into the =jingle= app.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (ql:quickload :lack-middleware-accesslog) CL-USER&amp;gt; (jingle:install-middleware &lt;em&gt;app&lt;/em&gt; lack.middleware.accesslog:&lt;em&gt;lack-middleware-accesslog&lt;/em&gt;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Search for other middlewares you can already use in Quicklisp, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (ql:system-apropos &#34;lack-middleware&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;You can use middlewares to push metadata into the environment for HTTP handlers to use. For example, if your HTTP handlers need to read from and write to a database, you may want to create a middleware, which pushes a =CL-DBI= connection into the environment, so that HTTP handlers can use it, when needed.&lt;/p&gt; &#xA;&lt;p&gt;In order to clear out all installed middlewares you can use the =JINGLE:CLEAR-MIDDLEWARES= method, e.g.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (jingle:clear-middlewares &lt;em&gt;app&lt;/em&gt;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Redirects&lt;/p&gt; &#xA;&lt;p&gt;Redirects in =jingle= are handled by the =JINGLE:REDIRECT= function.&lt;/p&gt; &#xA;&lt;p&gt;An example HTTP handler which redirects to [[https://lispcookbook.github.io/cl-cookbook/][The Common Lisp Cookbook]] looks like this.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun to-the-cookbook (params) (declare (ignore params)) (jingle:redirect &#34;&lt;a href=&#34;https://lispcookbook.github.io/cl-cookbook/&#34;&gt;https://lispcookbook.github.io/cl-cookbook/&lt;/a&gt;&#34;)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Register the HTTP handler and start the app.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (setf (jingle:route &lt;em&gt;app&lt;/em&gt; &#34;/cookbook&#34;) #&#39;to-the-cookbook) CL-USER&amp;gt; (jingle:start &lt;em&gt;app&lt;/em&gt;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Navigate to &lt;a href=&#34;http://localhost:5000/cookbook&#34;&gt;http://localhost:5000/cookbook&lt;/a&gt; and you will be automatically redirected.&lt;/p&gt; &#xA;&lt;p&gt;There is also another way for defining redirects using =JINGLE:REDIRECT-ROUTE=. The following example shows how to install two redirect routes to your =jingle= app, without having to explicitely define the HTTP handlers in advance.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (jingle:redirect-route &lt;em&gt;app&lt;/em&gt; &#34;/sbcl&#34; &#34;&lt;a href=&#34;https://sbcl.org/&#34;&gt;https://sbcl.org/&lt;/a&gt;&#34;) CL-USER&amp;gt; (jingle:redirect-route &lt;em&gt;app&lt;/em&gt; &#34;/ecl&#34; &#34;&lt;a href=&#34;https://ecl.common-lisp.dev/&#34;&gt;https://ecl.common-lisp.dev/&lt;/a&gt;&#34;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Request Parameters&lt;/p&gt; &#xA;&lt;p&gt;The =JINGLE:GET-REQUEST-PARAM= function may be used within HTTP handlers to get the value associated with a given parameter.&lt;/p&gt; &#xA;&lt;p&gt;Suppose we have the following example HTTP handler, which returns information about supported products and is exposed via the =/api/v1/product/:name= endpoint.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defparameter &lt;em&gt;products&lt;/em&gt; &#39;((:|id| 1 :|name| &#34;foo&#34;) (:|id| 2 :|name| &#34;bar&#34;) (:|id| 3 :|name| &#34;baz&#34;) (:|id| 4 :|name| &#34;qux&#34;) (:|id| 5 :|name| &#34;foo v2&#34;) (:|id| 6 :|name| &#34;bar v3&#34;) (:|id| 7 :|name| &#34;baz v4&#34;) (:|id| 8 :|name| &#34;qux v5&#34;)) &#34;The list of our supported products&#34;)&lt;/p&gt; &#xA;&lt;p&gt;(defun find-product-by-name (name) &#34;Finds a product by name&#34; (find name &lt;em&gt;products&lt;/em&gt; :key (lambda (item) (getf item :|name|)) :test #&#39;string=))&lt;/p&gt; &#xA;&lt;p&gt;(defun product-handler (params) &#34;Handles requests for /api/v1/product/:name endpoint&#34; (jingle:set-response-status :ok) (jingle:set-response-header :content-type &#34;application/json&#34;) (let* ((name (jingle:get-request-param params :name)) (product (find-product-by-name name))) (if product (jonathan:to-json product) (progn (jingle:set-response-status :not-found) (jonathan:to-json &#39;(:|error| &#34;Product not found&#34;)))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Register the HTTP handler and start the app.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (setf (jingle:route &lt;em&gt;app&lt;/em&gt; &#34;/api/v1/product/:name&#34;) #&#39;product-handler) CL-USER&amp;gt; (jingle:start &lt;em&gt;app&lt;/em&gt;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Testing it out with different product names using =curl(1)=.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ curl -s --get &lt;a href=&#34;http://localhost:5000/api/v1/product/foo&#34;&gt;http://localhost:5000/api/v1/product/foo&lt;/a&gt; | jq &#39;.&#39; { &#34;id&#34;: 1, &#34;name&#34;: &#34;foo&#34; }&lt;/p&gt; &#xA;&lt;p&gt;$ curl -s --get &lt;a href=&#34;http://localhost:5000/api/v1/product/bar&#34;&gt;http://localhost:5000/api/v1/product/bar&lt;/a&gt; | jq &#39;.&#39; { &#34;id&#34;: 2, &#34;name&#34;: &#34;bar&#34; }&lt;/p&gt; &#xA;&lt;p&gt;$ curl -s --get &lt;a href=&#34;http://localhost:5000/api/v1/product/unknown&#34;&gt;http://localhost:5000/api/v1/product/unknown&lt;/a&gt; | jq &#39;.&#39; { &#34;error&#34;: &#34;Product not found&#34; } #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Another example HTTP handler which returns a list of products in a paginated way, exposed via the =/api/v1/products= endpoint.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun take (items from to) &#34;A helper function to return the ITEMS between FROM and TO range&#34; (let* ((len (length items)) (to (if (&amp;gt;= to len) len to))) (if (&amp;gt;= from len) nil (subseq items from to))))&lt;/p&gt; &#xA;&lt;p&gt;(defun products-handler (params) &#34;Handles requests for /api/v1/product and returns a page of products&#34; (jingle:set-response-status :ok) (jingle:set-response-header :content-type &#34;application/json&#34;) ;; Parse the &lt;code&gt;FROM&#39; and &lt;/code&gt;TO&#39; query parameters. Use default values of ;; 0 and 5 for the params. (let ((from (parse-integer (jingle:get-request-param params &#34;from&#34; &#34;0&#34;) :junk-allowed t)) (to (parse-integer (jingle:get-request-param params &#34;to&#34; &#34;5&#34;) :junk-allowed t))) (cond ((or (null from) (null to)) (jingle:set-response-status :bad-request) nil) ;; NIL added here for the response body ((or (minusp from) (minusp to)) (jingle:set-response-status :bad-request) nil) ;; NIL added here for the response body (t (jonathan:to-json (take &lt;em&gt;products&lt;/em&gt; from to)))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Register the new API endpoint.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (setf (jingle:route &lt;em&gt;app&lt;/em&gt; &#34;/api/v1/products&#34;) #&#39;products-handler) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Testing it out using =curl(1)= with different values for =from= and =to= query params.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ curl -s --get &#39;&lt;a href=&#34;http://localhost:5000/api/v1/products?from=0&amp;amp;to=2&#34;&gt;http://localhost:5000/api/v1/products?from=0&amp;amp;to=2&lt;/a&gt;&#39; | jq &#39;.&#39; [ { &#34;id&#34;: 1, &#34;name&#34;: &#34;foo&#34; }, { &#34;id&#34;: 2, &#34;name&#34;: &#34;bar&#34; } ]&lt;/p&gt; &#xA;&lt;p&gt;$ curl -s --get &#39;&lt;a href=&#34;http://localhost:5000/api/v1/products?from=2&amp;amp;to=4&#34;&gt;http://localhost:5000/api/v1/products?from=2&amp;amp;to=4&lt;/a&gt;&#39; | jq &#39;.&#39; [ { &#34;id&#34;: 3, &#34;name&#34;: &#34;baz&#34; }, { &#34;id&#34;: 4, &#34;name&#34;: &#34;qux&#34; } ] #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Another way to retrieve request parameter values is to use the =JINGLE:WITH-REQUEST-PARAMS= macro. The previous example handler can be rewritten this way.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun products-handler (params) (jingle:with-json-response (jingle:with-request-params ((from-param &#34;from&#34; &#34;0&#34;) (to-param &#34;to&#34; &#34;5&#34;)) params ;; Parse the query parameters and make sure we&#39;ve got good values (let ((from (parse-integer from-param :junk-allowed t)) (to (parse-integer to-param :junk-allowed t))) (cond ((or (null from) (null to)) (jingle:set-response-status :bad-request) nil) ;; NIL added here for the response body ((or (minusp from) (minusp to)) (jingle:set-response-status :bad-request) nil) ;; NIL added here for the response body (t (take &lt;em&gt;products&lt;/em&gt; from to))))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;** Macros&lt;/p&gt; &#xA;&lt;p&gt;The following helper macros are available in =jingle=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;=JINGLE:WITH-JSON-RESPONSE=&lt;/li&gt; &#xA; &lt;li&gt;=JINGLE:WITH-REQUEST-PARAMS=&lt;/li&gt; &#xA; &lt;li&gt;=JINGLE:WITH-HTML-RESPONSE=&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The =JINGLE:WITH-JSON-RESPONSE= macro sets up various HTTP headers such as =Content-Type= to =application/json= for you and evaluates the body. The last evaluated expression from the body is encoded as a JSON object using =JONATHAN:TO-JSON=.&lt;/p&gt; &#xA;&lt;p&gt;The following example uses =LOCAL-TIME= and =JONATHAN= systems, so make sure you have them loaded already.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defclass ping-response () ((message :initarg :message :initform &#34;pong&#34; :reader ping-response-message :documentation &#34;Message to send as part of the response&#34;) (timestamp :initarg :timestamp :initform (local-time:now) :reader ping-response-timestamp)) (:documentation &#34;A response sent as part of a PING request&#34;))&lt;/p&gt; &#xA;&lt;p&gt;(defmethod jonathan:%to-json ((object ping-response)) (jonathan:with-object (jonathan:write-key-value &#34;message&#34; (ping-response-message object)) (jonathan:write-key-value &#34;timestamp&#34; (ping-response-timestamp object))))&lt;/p&gt; &#xA;&lt;p&gt;(defun ping-handler (params) (declare (ignore params)) (jingle:with-json-response (make-instance &#39;ping-response))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Register the HTTP handler and start the app.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (setf (jingle:route &lt;em&gt;app&lt;/em&gt; &#34;/api/v1/ping&#34;) #&#39;ping-handler) CL-USER&amp;gt; (jingle:start &lt;em&gt;app&lt;/em&gt;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Trying it you should see results similar to the ones below.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell $ curl -s --get &lt;a href=&#34;http://localhost:5000/api/v1/ping&#34;&gt;http://localhost:5000/api/v1/ping&lt;/a&gt; | jq &#39;.&#39; { &#34;message&#34;: &#34;pong&#34;, &#34;timestamp&#34;: 1670593969 }&lt;/p&gt; &#xA;&lt;p&gt;$ curl -s --get &lt;a href=&#34;http://localhost:5000/api/v1/ping&#34;&gt;http://localhost:5000/api/v1/ping&lt;/a&gt; | jq &#39;.&#39; { &#34;message&#34;: &#34;pong&#34;, &#34;timestamp&#34;: 1670593974 }&lt;/p&gt; &#xA;&lt;p&gt;$ curl -s --get &lt;a href=&#34;http://localhost:5000/api/v1/ping&#34;&gt;http://localhost:5000/api/v1/ping&lt;/a&gt; | jq &#39;.&#39; { &#34;message&#34;: &#34;pong&#34;, &#34;timestamp&#34;: 1670593976 } #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =JINGLE:WITH-REQUEST-PARAMS= macro provides an easy way to bind symbols to request params from within HTTP handlers.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun foo-handler (params) (jingle:with-request-params ((foo &#34;foo&#34;) (bar &#34;bar&#34;)) params ;; Use FOO and BAR params in order to ... ...)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The =JINGLE:WITH-HTML-RESPONSE= is similar to =JINGLE:WITH-JSON-RESPONSE=, but sets up the response with a =Content-Type: text/html; charset=utf-8= header.&lt;/p&gt; &#xA;&lt;p&gt;** Error Handling&lt;/p&gt; &#xA;&lt;p&gt;The =JINGLE:BASE-HTTP-ERROR= condition may be used as the base for user-defined conditions.&lt;/p&gt; &#xA;&lt;p&gt;If a condition is signalled from within HTTP handlers and the condition is a sub-class of =JINGLE:BASE-HTTP-ERROR=, then the =JINGLE:HANDLE-ERROR= method will be invoked.&lt;/p&gt; &#xA;&lt;p&gt;The purpose of =JINGLE:HANDLE-ERROR= is to handle the error and set up an appropriate HTTP response, which will be returned to the client.&lt;/p&gt; &#xA;&lt;p&gt;The rest of this section describes how to create and use custom errors for a very simple REST API. The API we will develop provides the following endpoints.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell GET /api/v1/product =&amp;gt; Returns a list of products (supports &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; query params) GET /api/v1/product/:name =&amp;gt; Returns a product by name, if found #+end_src&lt;/p&gt; &#xA;&lt;p&gt;The error responses which we will return to clients would look like this.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src javascript { &#34;error&#34;: &#34;&#xA; &lt;reason for the error response&gt;&#xA;  &#34; } #+end_src&#xA; &lt;/reason&gt;&lt;/p&gt; &#xA;&lt;p&gt;First we will define our =API-ERROR= condition, and then define the =JINGLE:HANDLE-ERROR= method on it, so that we return consistent error responses to our API clients.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (define-condition api-error (jingle:base-http-error) () (:documentation &#34;Represents a condition which will be signalled on API errors&#34;))&lt;/p&gt; &#xA;&lt;p&gt;(defmethod jingle:handle-error ((error api-error)) &#34;Handles the error and sets up the HTTP error response to be sent to clients&#34; (with-accessors ((code jingle:http-error-code) (body jingle:http-error-body)) error (jingle:set-response-status code) (jingle:set-response-header :content-type &#34;application/json&#34;) (jonathan:to-json (list :|error| body)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Next, we will implement some helper functions that signal common client-error HTTP responses.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun throw-not-found-error (message) &#34;Throws a 404 (Not Found) HTTP response&#34; (error &#39;api-error :code :not-found :body message))&lt;/p&gt; &#xA;&lt;p&gt;(defun throw-bad-request-error (message) &#34;Throws a 400 (Bad Request) HTTP response&#34; (error &#39;api-error :code :bad-request :body message)) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Having our conditions and error-related functions we will also define another helper function, which will be responsible for parsing HTTP query parameters as integers, which we will use in our handlers.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun get-int-param (params name &amp;amp;optional default) &#34;Gets the NAME parameter from PARAMS and parses it as an integer. In case of invalid input it will signal a 400 (Bad Request) error&#34; (let ((raw (jingle:get-request-param params name default))) (typecase raw (number raw) (null (throw-bad-request-error (format nil &#34;missing value for &lt;code&gt;~A&lt;/code&gt; param&#34; name))) (string (let ((parsed (parse-integer raw :junk-allowed t))) (unless parsed (throw-bad-request-error (format nil &#34;invalid value for &lt;code&gt;~A&lt;/code&gt; param&#34; name))) parsed)) (t (throw-bad-request-error (format nil &#34;unsupported value for &lt;code&gt;~A&lt;/code&gt; param&#34; name)))))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;We will be building on top of the /products/ API, which was shown in a previous section. The =&lt;em&gt;PRODUCTS&lt;/em&gt;= var will be our &#34;database&#34; in this simple API.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defparameter &lt;em&gt;products&lt;/em&gt; &#39;((:|id| 1 :|name| &#34;foo&#34;) (:|id| 2 :|name| &#34;bar&#34;) (:|id| 3 :|name| &#34;baz&#34;) (:|id| 4 :|name| &#34;qux&#34;) (:|id| 5 :|name| &#34;foo v2&#34;) (:|id| 6 :|name| &#34;bar v3&#34;) (:|id| 7 :|name| &#34;baz v4&#34;) (:|id| 8 :|name| &#34;qux v5&#34;)) &#34;The list of our supported products&#34;)&lt;/p&gt; &#xA;&lt;p&gt;(defun find-product-by-name (name) &#34;Finds a product by name&#34; (find name &lt;em&gt;products&lt;/em&gt; :key (lambda (item) (getf item :|name|)) :test #&#39;string=))&lt;/p&gt; &#xA;&lt;p&gt;(defun take (items from to) &#34;A helper function to return the ITEMS between FROM and TO range&#34; (let* ((len (length items)) (to (if (&amp;gt;= to len) len to))) (if (&amp;gt;= from len) nil (subseq items from to)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;And these are the actual HTTP handlers, which will accept and handle client requests.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp (defun get-product-handler (params) &#34;Handles requests for the /api/v1/product/:name endpoint&#34; (jingle:with-json-response (let* ((name (jingle:get-request-param params :name)) (product (find-product-by-name name))) (unless product (throw-not-found-error &#34;product not found&#34;)) product)))&lt;/p&gt; &#xA;&lt;p&gt;(defun get-products-page-handler (params) &#34;Handles requests for the /api/v1/product endpoint&#34; (jingle:with-json-response (let ((from (get-int-param params &#34;from&#34; 0)) (to (get-int-param params &#34;to&#34; 2))) (when (or (minusp from) (minusp to)) (throw-bad-request-error &#34;&lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; must be positive&#34;)) (take &lt;em&gt;products&lt;/em&gt; from to)))) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Finally, we will create our =JINGLE:APP=, register our handlers and start serving HTTP requests.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src lisp CL-USER&amp;gt; (defparameter &lt;em&gt;app&lt;/em&gt; (jingle:make-app)) CL-USER&amp;gt; (setf (jingle:route &lt;em&gt;app&lt;/em&gt; &#34;/api/v1/product&#34;) #&#39;get-products-page-handler) CL-USER&amp;gt; (setf (jingle:route &lt;em&gt;app&lt;/em&gt; &#34;/api/v1/product/:name&#34;) #&#39;get-product-handler) CL-USER&amp;gt; (jingle:start &lt;em&gt;app&lt;/em&gt;) #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Time to test things out.&lt;/p&gt; &#xA;&lt;p&gt;#+begin_src shell&lt;/p&gt; &#xA;&lt;h1&gt;Getting a page of products using default &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; params&lt;/h1&gt; &#xA;&lt;p&gt;$ curl -s --get &#39;&lt;a href=&#34;http://localhost:5000/api/v1/product&#34;&gt;http://localhost:5000/api/v1/product&lt;/a&gt;&#39; | jq &#39;.&#39; [ { &#34;id&#34;: 1, &#34;name&#34;: &#34;foo&#34; }, { &#34;id&#34;: 2, &#34;name&#34;: &#34;bar&#34; } ]&lt;/p&gt; &#xA;&lt;h1&gt;Getting next page of products&lt;/h1&gt; &#xA;&lt;p&gt;$ curl -s --get &#39;&lt;a href=&#34;http://localhost:5000/api/v1/product?from=2&amp;amp;to=4&#34;&gt;http://localhost:5000/api/v1/product?from=2&amp;amp;to=4&lt;/a&gt;&#39; | jq &#39;.&#39; [ { &#34;id&#34;: 3, &#34;name&#34;: &#34;baz&#34; }, { &#34;id&#34;: 4, &#34;name&#34;: &#34;qux&#34; } ]&lt;/p&gt; &#xA;&lt;h1&gt;Passing invalid query params&lt;/h1&gt; &#xA;&lt;p&gt;$ curl -s --get &#39;&lt;a href=&#34;http://localhost:5000/api/v1/product?from=bad-value&#34;&gt;http://localhost:5000/api/v1/product?from=bad-value&lt;/a&gt;&#39; | jq &#39;.&#39; { &#34;error&#34;: &#34;invalid value for &lt;code&gt;from&lt;/code&gt; param&#34; }&lt;/p&gt; &#xA;&lt;h1&gt;Passing negative values&lt;/h1&gt; &#xA;&lt;p&gt;$ curl -s --get &#39;&lt;a href=&#34;http://localhost:5000/api/v1/product?to=-42&#34;&gt;http://localhost:5000/api/v1/product?to=-42&lt;/a&gt;&#39; | jq &#39;.&#39; { &#34;error&#34;: &#34;&lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; must be positive&#34; }&lt;/p&gt; &#xA;&lt;h1&gt;Getting a product by name&lt;/h1&gt; &#xA;&lt;p&gt;$ curl -s --get &#39;&lt;a href=&#34;http://localhost:5000/api/v1/product/foo&#34;&gt;http://localhost:5000/api/v1/product/foo&lt;/a&gt;&#39; | jq &#39;.&#39; { &#34;id&#34;: 1, &#34;name&#34;: &#34;foo&#34; }&lt;/p&gt; &#xA;&lt;h1&gt;Getting a non-existing product&lt;/h1&gt; &#xA;&lt;p&gt;$ curl -s --get &#39;&lt;a href=&#34;http://localhost:5000/api/v1/product/unknown&#34;&gt;http://localhost:5000/api/v1/product/unknown&lt;/a&gt;&#39; | jq &#39;.&#39; { &#34;error&#34;: &#34;product not found&#34; } #+end_src&lt;/p&gt; &#xA;&lt;p&gt;Great, things work as expected and our API clients will receive consistent error responses with the proper HTTP status codes set.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;=jingle= is hosted on [[https://github.com/dnaeon/jingle][Github]]. Please contribute by reporting issues, suggesting features or by sending patches using pull requests.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;License&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This project is Open Source and licensed under the [[http://opensource.org/licenses/BSD-2-Clause][BSD License]].&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Authors&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Marin Atanasov Nikolov &lt;a href=&#34;mailto:dnaeon@gmail.com&#34;&gt;dnaeon@gmail.com&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>