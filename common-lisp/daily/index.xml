<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-10T01:36:45Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fukamachi/woo</title>
    <updated>2022-06-10T01:36:45Z</updated>
    <id>tag:github.com,2022-06-10:/fukamachi/woo</id>
    <link href="https://github.com/fukamachi/woo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fast non-blocking HTTP server on top of libev&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Woo&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/fukamachi/woo&#34;&gt;&lt;img src=&#34;https://travis-ci.org/fukamachi/woo.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Woo is a fast non-blocking HTTP server built on top of &lt;a href=&#34;http://software.schmorp.de/pkg/libev.html&#34;&gt;libev&lt;/a&gt;. Although Woo is written in Common Lisp, it aims to be the fastest web server written in any programming language.&lt;/p&gt; &#xA;&lt;h2&gt;Warning&lt;/h2&gt; &#xA;&lt;p&gt;This software is still BETA quality.&lt;/p&gt; &#xA;&lt;h2&gt;How fast?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fukamachi/woo/master/images/benchmark.png&#34; alt=&#34;Benchmark graph&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/fukamachi/woo/master/benchmark.md&#34;&gt;benchmark.md&lt;/a&gt; for the detail.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Start a server&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(ql:quickload :woo)&#xA;&#xA;(woo:run&#xA;  (lambda (env)&#xA;    (declare (ignore env))&#xA;    &#39;(200 (:content-type &#34;text/plain&#34;) (&#34;Hello, World&#34;))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Start with Clack&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(ql:quickload :clack)&#xA;&#xA;(clack:clackup&#xA;  (lambda (env)&#xA;    (declare (ignore env))&#xA;    &#39;(200 (:content-type &#34;text/plain&#34;) (&#34;Hello, World&#34;)))&#xA;  :server :woo&#xA;  :use-default-middlewares nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cluster&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(woo:run&#xA;  (lambda (env)&#xA;    (declare (ignore env))&#xA;    &#39;(200 (:content-type &#34;text/plain&#34;) (&#34;Hello, World&#34;)))&#xA;  :worker-num 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Signal handling&lt;/h2&gt; &#xA;&lt;p&gt;When the master process gets these signals, it kills worker processes and quits afterwards.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;QUIT: graceful shutdown, waits for all requests are finished.&lt;/li&gt; &#xA; &lt;li&gt;INT/TERM: shutdown immediately.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/fukamachi/woo/master/benchmark.md&#34;&gt;benchmark.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Woo has switched the backend from cl-async to libev after the latest Quicklisp dist release. If you&#39;re gonna run the benchmarks by your own, please use the latest one.&lt;/p&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;UNIX (GNU Linux, Mac, *BSD)&lt;/li&gt; &#xA; &lt;li&gt;SBCL&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://libev.schmorp.de&#34;&gt;libev&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installing via Quicklisp&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(ql:quickload :woo)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;See Also&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://software.schmorp.de/pkg/libev.html&#34;&gt;libev&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://clacklisp.org/&#34;&gt;Clack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://wookie.beeets.com&#34;&gt;Wookie&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Eitaro Fukamachi (&lt;a href=&#34;mailto:e.arrows@gmail.com&#34;&gt;e.arrows@gmail.com&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2014 Eitaro Fukamachi &amp;amp; &lt;a href=&#34;https://github.com/fukamachi/woo/graphs/contributors&#34;&gt;contributors&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under the MIT License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ruricolist/cloture</title>
    <updated>2022-06-10T01:36:45Z</updated>
    <id>tag:github.com,2022-06-10:/ruricolist/cloture</id>
    <link href="https://github.com/ruricolist/cloture" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Clojure in Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cloture&lt;/h1&gt; &#xA;&lt;p&gt;Cloture is an implementation of Clojure in Common Lisp. It is designed above all to interoperate well with Common Lisp; Clojure is read by the Lisp reader and Clojure namespaces are Lisp packages.&lt;/p&gt; &#xA;&lt;p&gt;Cloture is in very early (pre-alpha) stages, but it has progressed far enough to load &lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/cloture/master/test.clj&#34;&gt;clojure.test&lt;/a&gt;, allowing the &lt;a href=&#34;https://github.com/ruricolist/cloture/raw/master/t/cloture-tests.cljc&#34;&gt;test suite&lt;/a&gt; to actually be written in Clojure.&lt;/p&gt; &#xA;&lt;p&gt;Work so far has been focused on the critical path to get real Clojure code working in CL. But if there is interest from Clojurists I may work toward making it a more complete Clojure implementation.&lt;/p&gt; &#xA;&lt;h2&gt;Clojure vs. ClojureScript&lt;/h2&gt; &#xA;&lt;p&gt;Cloture is closer to Clojure than to ClojureScript. Among other things, the plan is to support Clojure’s concurrency primitives (&lt;code&gt;atom&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;agent&lt;/code&gt;, &lt;code&gt;future&lt;/code&gt;, &lt;code&gt;promise&lt;/code&gt;). However, Cloture follows ClojureScript in making exclusive use of protocols - interfaces are not used or supported. Protocol names are also derived from ClojureScript.&lt;/p&gt; &#xA;&lt;p&gt;Like ClojureScript, Cloture supports &lt;code&gt;(catch :default)&lt;/code&gt; to catch everything.&lt;/p&gt; &#xA;&lt;h2&gt;A note about FSet&lt;/h2&gt; &#xA;&lt;p&gt;Cloture uses &lt;a href=&#34;https://github.com/slburson/fset&#34;&gt;FSet&lt;/a&gt; seqs, maps, and sets to implement Clojure vectors, maps, and sets, respectively. This involves &lt;a href=&#34;https://github.com/ruricolist/cloture/raw/master/fset-hacks.lisp&#34;&gt;a few hacks&lt;/a&gt; to FSet that might possibly affect other programs using FSet.&lt;/p&gt; &#xA;&lt;h2&gt;Starting a REPL&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;code&gt;(cloture:repl)&lt;/code&gt; to start a Clojure REPL. You can exit the REPL with &lt;code&gt;(quit)&lt;/code&gt; or &lt;code&gt;(exit)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that not much work has been done yet on Clojure-style printing, so the “Print” in REPL is still mostly the Common Lisp printer.&lt;/p&gt; &#xA;&lt;h2&gt;Interoperation&lt;/h2&gt; &#xA;&lt;h3&gt;Using Clojure from Lisp&lt;/h3&gt; &#xA;&lt;p&gt;The design goal of Cloture is to keep things as close to Common Lisp as possible: Clojure is read by the Lisp reader and Clojure namespaces are just packages. Clojure packages and functions, however, usually have lower-case names, so to call them from Lisp you will need to quote them with pipe characters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(|clojure.core|:|cons| 1 &#39;(2))&#xA;=&amp;gt; &#39;(1 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lisp’s nil is used only as the empty list; Clojure nil, true, and false are singletons. To use Clojure predicates from Lisp, you can use &lt;code&gt;cloture:truthy?&lt;/code&gt; to translate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(cloture:truthy? (|clojure.core|:|=| &#39;(1 2 3) #(1 2 3)))&#xA;=&amp;gt; T&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, however, you should use &lt;code&gt;cloture:egal&lt;/code&gt;, which tells you if two objects are equal according to Clojure’s idea of equality.&lt;/p&gt; &#xA;&lt;p&gt;Cloture exports Iterate drivers for working with collections that satisfy Clojure protocols:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cloture:in-seq&lt;/code&gt; iterates over &lt;code&gt;ISeq&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cloture:on-seq&lt;/code&gt; iterates over the rests of &lt;code&gt;ISeq&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cloture:in-indexed&lt;/code&gt; iterates over &lt;code&gt;IIndexed&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cloture:index-of-indexed&lt;/code&gt; iterates over the indices of &lt;code&gt;IIndexed&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Clojure files can be integrated into Lisp systems by making the system definition depend on Cloture &lt;code&gt;(:defsystem-depends-on (&#34;cloture&#34;)&lt;/code&gt; and using &lt;code&gt;&#34;cloture:cljc&#34;&lt;/code&gt; as the file type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defsystem ...&#xA;  :defsystem-depends-on (&#34;cloture&#34;)&#xA;  :components ((:file &#34;cloture:cljc&#34; &#34;my-clojure-code&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use &lt;code&gt;&#34;cloture:clj&#34;&lt;/code&gt; or &lt;code&gt;&#34;cloture:cljs&#34;&lt;/code&gt; to load straight Clojure or ClojureScript files. Using &lt;code&gt;.cljc&lt;/code&gt; is recommended, however.&lt;/p&gt; &#xA;&lt;h3&gt;Using Lisp from Clojure&lt;/h3&gt; &#xA;&lt;p&gt;Since Clojure uses the Lisp reader, you can call Lisp functions just by uppercasing them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(letfn [(fst [xs] (CL:FIRST xs))]&#xA;  (fst &#39;(1 2 3)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will also need to spell out &lt;code&gt;CL:QUOTE&lt;/code&gt; and &lt;code&gt;CL:FUNCTION&lt;/code&gt; (or refer them), as Clojure quote is not the same thing as CL quote and sharp-quote is used in Clojure for a different purpose.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ns ...&#xA;  (:require [CL :refer [QUOTE FUNCTION]]))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Cloture defines a Clojure namespace, &lt;code&gt;cloture&lt;/code&gt;, with exports whose names (and keyword arguments!) are already conveniently lowercased and otherwise follow Clojure conventions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ns ...&#xA;  (:require [cloture:refer [parse-integer]]))&#xA;&#xA;(parse-integer &#34;1234x&#34; :start 1 :junk-allowed true)&#xA;=&amp;gt; 234&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All Lisp sequences (lists, vectors, and extensible sequences on implementations that support them) implement ISeq.&lt;/p&gt; &#xA;&lt;h2&gt;Reader conditionals&lt;/h2&gt; &#xA;&lt;p&gt;In reader conditionals in &lt;code&gt;.cljc&lt;/code&gt; files (and at the REPL), Cloture looks for a &lt;code&gt;:cl&lt;/code&gt; key.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/EPL-1.0&#34;&gt;Eclipse Public License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;I would like to be able to use Clojure libraries from Common Lisp.&lt;/p&gt; &#xA;&lt;h2&gt;Why “Cloture”?&lt;/h2&gt; &#xA;&lt;p&gt;Beside the obvious: &lt;a href=&#34;https://en.wikipedia.org/wiki/Cloture&#34;&gt;cloture&lt;/a&gt; is a parliamentary procedure to end debate on a subject, and I would like to end certain debates. Yes, Common Lisp is “modern.” Yes, Clojure is a Lisp.&lt;/p&gt;</summary>
  </entry>
</feed>