<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-07T01:32:59Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tdrhq/easy-macros</title>
    <updated>2022-10-07T01:32:59Z</updated>
    <id>tag:github.com,2022-10-07:/tdrhq/easy-macros</id>
    <link href="https://github.com/tdrhq/easy-macros" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Common Lisp library to define less error-prone macros, faster.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;easy-macros: An easy way to write 90% of your macros&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://app.circleci.com/pipelines/github/tdrhq/easy-macros?branch=main&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/tdrhq/easy-macros.svg?style=shield&#34; alt=&#34;tdrhq&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Easy-macros help you write macros of this form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  (with-&amp;lt;something&amp;gt; (...args...)&#xA;     ...body...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Under the hood, this automates the call-with pattern.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s rewrite some well known examples to show what we mean.&lt;/p&gt; &#xA;&lt;h3&gt;ignore-errors&lt;/h3&gt; &#xA;&lt;p&gt;First let&#39;s see how we might write &lt;code&gt;ignore-errors&lt;/code&gt; the Old-Fashioned way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro custom-ignore-errors (&amp;amp;body body)&#xA;  `(handler-case&#xA;     (progn ,@body)&#xA;    (error () nil)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Not too bad, but it&#39;s error-prone. You might forget to use a &lt;code&gt;,&lt;/code&gt;, you might forget to wrap body in &lt;code&gt;progn&lt;/code&gt; etc. But worst, if you change the definition of &lt;code&gt;custom-ignore-errors&lt;/code&gt;, you will have to recompile all the functions that use it.&lt;/p&gt; &#xA;&lt;p&gt;You can avoid some of these issues by using the CALL-WITH pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defmacro custom-ignore-errors (&amp;amp;body body)&#xA;  `(call-custom-ignore-errors (lambda () ,@body)))&#xA;&#xA;(defun call-custom-ignore-errors (fn)&#xA;  (handler-case&#xA;    (funcall fn)&#xA;   (error () nil)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now most of the logic is inside a non-backticked function. But there&#39;s still some backquoting and macro expansion we need to do which is error-prone, and it&#39;s also very verbose for simple macros.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;def-easy-macro&lt;/code&gt; to essentially automate this process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(def-easy-macro custom-ignore-errors (&amp;amp;fn fn)&#xA;  (handler-case&#xA;     (funcall fn)&#xA;    (error () nil)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This &lt;code&gt;custom-ignore-errors&lt;/code&gt; has a slightly different API though:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(custom-ignore-errors ()&#xA;  ...body...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All easy-macros takes a second list for arguments. This is true even if it takes no arguments and only a body.&lt;/p&gt; &#xA;&lt;p&gt;Notice a few things:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We don&#39;t use backticks anywhere&lt;/li&gt; &#xA; &lt;li&gt;Instead of a body, we get a lambda function. This function is provided by the &lt;code&gt;&amp;amp;fn&lt;/code&gt; argument.&lt;/li&gt; &#xA; &lt;li&gt;If you redefine custom-ignore-errors, all callers of the macro will point to the new code, unlike with regular macros. (With some caveats! See below.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We don&#39;t need to use &lt;code&gt;funcall&lt;/code&gt; by the way, the following is equivalent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(def-easy-macro custom-ignore-errors (&amp;amp;fn fn)&#xA;  (handler-case&#xA;     (fn)&#xA;    (error () nil)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;re still figuring out which one we like better. This version obviously is lesser code, but it also breaks the expectation that arguments in the lambda-list are variables. But anyway, moving on to next examples.&lt;/p&gt; &#xA;&lt;h3&gt;with-open-file&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(def-easy-macro with-custom-open-file (&amp;amp;binding stream file &amp;amp;rest args &amp;amp;fn fn)&#xA;  (let ((stream (apply #&#39;open file args)))&#xA;    (unwind-protect&#xA;       (funcall fn stream)&#xA;      (close stream))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can be used almost exactly like with-open-file.&lt;/p&gt; &#xA;&lt;p&gt;Notice a few things:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We don&#39;t use backticks anywhere&lt;/li&gt; &#xA; &lt;li&gt;This function takes one argument. easy-macro knows this based on the &lt;code&gt;&amp;amp;binding&lt;/code&gt; argument, unlike the previous example.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;uiop:with-temporary-file&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(def-easy-macro my-with-custom-temporary-file (&amp;amp;key &amp;amp;binding stream &amp;amp;binding pathname prefix suffix &amp;amp;fn)&#xA;   ;; ... you get the idea&#xA;    (funcall fn my-stream my-pathname))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I didn&#39;t build out the example completely, but I wanted to show you how you could write more complex arguments in the macro.&lt;/p&gt; &#xA;&lt;p&gt;All the arguments named with &lt;code&gt;&amp;amp;binding&lt;/code&gt; are not part of argument-list, they will be sequentially bound to the &lt;code&gt;&amp;amp;fn&lt;/code&gt; body function. The rest of expressions form the lambda-list for the argument-list.&lt;/p&gt; &#xA;&lt;h3&gt;maplist&lt;/h3&gt; &#xA;&lt;p&gt;Common Lisp comes with &lt;code&gt;dolist&lt;/code&gt;, but not a &lt;code&gt;maplist&lt;/code&gt;. Let&#39;s implement a quick &lt;code&gt;maplist&lt;/code&gt; macro using &lt;code&gt;loop&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(def-easy-macro maplist (&amp;amp;binding x list &amp;amp;fn fn)&#xA;  (loop for value in list collect (funcall fn value))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Before &lt;code&gt;def-easy-macro&lt;/code&gt; this would&#39;ve been too much work to define for something simple. With &lt;code&gt;def-easy-macro&lt;/code&gt; it&#39;s just as easy to work with as any regular function, so you tend to macrofy even tiny abstractions like this.&lt;/p&gt; &#xA;&lt;h2&gt;Caveats with redefinitions&lt;/h2&gt; &#xA;&lt;p&gt;Most redefinitions will automatically be applied to all callers. If you change the lambda-list (either &lt;code&gt;&amp;amp;binding&lt;/code&gt; or otherwise), the new definition may not be compatible.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re waiting on this to be part of the next Quicklisp distribution, in the meantime you can use quick-patch to install:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(ql:quickload :quick-patch)&#xA;(quick-patch:register &#34;https://github.com/tdrhq/easy-macros.git&#34; &#34;main&#34;)&#xA;(quick-patch:checkout-all &#34;.quick-patch/&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;p&gt;This library is NOT very polished.&lt;/p&gt; &#xA;&lt;p&gt;However, even with its limited polish it&#39;s been ridiculously useful in my work, so I thought I should put it out there and accept feedback and pull requests. There are few things that I&#39;d personally like to see:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Less brittle lambda-list parsing: currently it&#39;s really hacky&lt;/li&gt; &#xA; &lt;li&gt;A way to implement macros of the form:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(def-stuff my-stuff (...)&#xA;  ,@body)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In a similar vein as above: sometimes in macros you want to pass the quoted symbol name instead of the evaluated expression. In theory I can build that...&lt;/li&gt; &#xA; &lt;li&gt;But I want to limit what this library does. I want to make it easy for somebody new to CL to write macros &lt;em&gt;most&lt;/em&gt; of the time. Just because I can doesn&#39;t mean I should.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Arnold Noronha &lt;a href=&#34;mailto:arnold@screenshotbot.io&#34;&gt;arnold@screenshotbot.io&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Apache License, Version 2.0&lt;/p&gt;</summary>
  </entry>
</feed>