<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-20T01:33:14Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>woodrush/lambdalisp</title>
    <updated>2022-09-20T01:33:14Z</updated>
    <id>tag:github.com,2022-09-20:/woodrush/lambdalisp</id>
    <link href="https://github.com/woodrush/lambdalisp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Lisp interpreter written in untyped lambda calculus&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/bin/lambdalisp_logo.png&#34; alt=&#34;LambdaLisp&#39;s logo&#34;&gt; &lt;br&gt; &lt;a href=&#34;https://github.com/woodrush/lambdalisp/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/woodrush/lambdalisp/actions/workflows/test.yml/badge.svg?branch=main&#34; alt=&#34;test&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;LambdaLisp is a Lisp interpreter written as an untyped lambda calculus term. The entire lambda calculus expression is viewable as a PDF &lt;a href=&#34;https://woodrush.github.io/lambdalisp.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;LambdaLisp is a Lisp interpreter written as a closed untyped lambda calculus term. It is written as a lambda calculus term &lt;code&gt;LambdaLisp = λx. ...&lt;/code&gt; which takes a string &lt;code&gt;x&lt;/code&gt; as an input and returns a string as an output. The input &lt;code&gt;x&lt;/code&gt; is the Lisp program and the user&#39;s standard input, and the output is the standard output. Characters are encoded into lambda term representations of natural numbers using the &lt;a href=&#34;https://en.wikipedia.org/wiki/Church_encoding&#34;&gt;Church encoding&lt;/a&gt;, and strings are encoded as a list of characters with lists expressed as lambdas in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding&#34;&gt;Mogensen-Scott encoding&lt;/a&gt;, so the entire computation process solely consists of the beta-reduction of lambda terms, without introducing any non-lambda-type object.&lt;/p&gt; &#xA;&lt;p&gt;Supported features are closures and persistent bindings with &lt;code&gt;let&lt;/code&gt;, reader macros, 32-bit signed integers, strings, and much more. LambdaLisp is tested by running programs on both Common Lisp and LambdaLisp and comparing their outputs. The largest LambdaLisp-Common-Lisp polyglot program that has been tested is &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/examples/lambdacraft.cl&#34;&gt;lambdacraft.cl&lt;/a&gt;, which runs the Lisp-to-lambda-calculus compiler &lt;a href=&#34;https://github.com/woodrush/lambdacraft&#34;&gt;LambdaCraft&lt;/a&gt; written for this project, also used to compile LambdaLisp itself.&lt;/p&gt; &#xA;&lt;p&gt;When run on a lambda calculus interpreter that runs on the terminal, LambdaLisp presents a REPL where you can interactively define and evaluate Lisp expressions. These interpreters automatically process the string-to-lambda encoding for handling I/O through the terminal. Supported interpreters are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SectorLambda, the &lt;a href=&#34;https://justine.lol/lambda/&#34;&gt;521-byte lambda calculus interpreter&lt;/a&gt; written by Justine Tunney&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://www.ioccc.org/&#34;&gt;IOCCC&lt;/a&gt; 2012 &lt;a href=&#34;https://www.ioccc.org/2012/tromp/hint.html&#34;&gt;&#34;Most functional&#34;&lt;/a&gt; interpreter written by John Tromp (the &lt;a href=&#34;https://www.ioccc.org/2012/tromp/tromp.c&#34;&gt;source&lt;/a&gt; is in the shape of a λ)&lt;/li&gt; &#xA; &lt;li&gt;Universal Lambda interpreter &lt;a href=&#34;https://github.com/irori/clamb&#34;&gt;clamb&lt;/a&gt; and Lazy K interpreter &lt;a href=&#34;https://github.com/irori/lazyk&#34;&gt;lazyk&lt;/a&gt; written by Kunihiko Sakamoto&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More implementation details are introduced in &lt;a href=&#34;https://woodrush.github.io/blog/lambdalisp.html&#34;&gt;this blog post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;LambdaLisp runs on x86-64-Linux and other platforms such as Mac.&lt;/p&gt; &#xA;&lt;h3&gt;Trying the LambdaLisp REPL (on x86-64-Linux)&lt;/h3&gt; &#xA;&lt;p&gt;You can try the LambdaLisp REPL by simply running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/woodrush/lambdalisp&#xA;cd lambdalisp&#xA;make run-repl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The requirement is &lt;code&gt;cc&lt;/code&gt; which should be installed by default. To try it on a Mac, please see the next section.&lt;/p&gt; &#xA;&lt;p&gt;This will run LambdaLisp on SectorLambda, the &lt;a href=&#34;https://justine.lol/lambda/&#34;&gt;521-byte lambda calculus interpreter&lt;/a&gt;. The source code being run is &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/bin/lambdalisp.blc&#34;&gt;lambdalisp.blc&lt;/a&gt;, which is the lambda calculus term shown in &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/lambdalisp.pdf&#34;&gt;lambdalisp.pdf&lt;/a&gt; written in &lt;a href=&#34;https://tromp.github.io/cl/Binary_lambda_calculus.html&#34;&gt;binary lambda calculus&lt;/a&gt; notation.&lt;/p&gt; &#xA;&lt;p&gt;SectorLambda automatically takes care of the string-to-lambda I/O encoding to run LambdaLisp on the terminal. Interaction is done by writing LambdaLisp in continuation-passing style, allowing a Haskell-style interactive I/O to work on lambda calculus interpreters.&lt;/p&gt; &#xA;&lt;p&gt;When building SectorLambda, Make runs the following commands to get its source codes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Blc.S&lt;/code&gt;: &lt;code&gt;wget https://justine.lol/lambda/Blc.S?v=2&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;flat.lds&lt;/code&gt;: &lt;code&gt;wget https://justine.lol/lambda/flat.lds&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After running &lt;code&gt;make run-repl&lt;/code&gt;, the REPL can also be run as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;( cat ./bin/lambdalisp.blc | ./bin/asc2bin; cat ) | ./bin/Blc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Trying the LambdaLisp REPL (on Other Platforms)&lt;/h3&gt; &#xA;&lt;p&gt;SectorLambda is x86-64-Linux exclusive. On other platforms such as a Mac, the following command can be used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/woodrush/lambdalisp&#xA;cd lambdalisp&#xA;make run-repl-ulamb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This runs LambdaLisp on the lambda calculus interpreter &lt;code&gt;clamb&lt;/code&gt;. The requirement for this is &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;After running &lt;code&gt;make run-repl-ulamb&lt;/code&gt;, the REPL can also be run as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;( cat ./bin/lambdalisp.ulamb | ./bin/asc2bin; cat ) | ./bin/clamb -u&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run LambdaLisp on other lambda calculus interpreters, please see the Supported Lambda Calculus Interpreters section.&lt;/p&gt; &#xA;&lt;h3&gt;Playing the Number Guessing Game&lt;/h3&gt; &#xA;&lt;p&gt;Once &lt;code&gt;make run-repl&lt;/code&gt; is run, you can play the &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/examples/number-guessing-game.cl&#34;&gt;number guessing game&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;( cat ./bin/lambdalisp.blc | ./bin/asc2bin; cat ./examples/number-guessing-game.cl; cat ) | ./bin/Blc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you ran &lt;code&gt;make run-repl-ulamb&lt;/code&gt;, you can run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;( cat ./bin/lambdalisp.ulamb | ./bin/asc2bin; cat ./examples/number-guessing-game.cl; cat ) | ./bin/clamb -u&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run the same script on Common Lisp. If you use SBCL, you can run it with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbcl --script ./examples/number-guessing-game.cl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Closures&lt;/h3&gt; &#xA;&lt;p&gt;The following LambdaLisp code runs right out of the box:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun new-counter (init)&#xA;  ;; Return a closure.&#xA;  ;; Use the let over lambda technique for creating independent and persistent variables.&#xA;  (let ((i init))&#xA;    (lambda () (setq i (+ 1 i)))))&#xA;&#xA;;; Instantiate counters&#xA;(setq counter1 (new-counter 0))&#xA;(setq counter2 (new-counter 10))&#xA;&#xA;(print (counter1)) ;; =&amp;gt; 1&#xA;(print (counter1)) ;; =&amp;gt; 2&#xA;(print (counter2)) ;; =&amp;gt; 11&#xA;(print (counter1)) ;; =&amp;gt; 3&#xA;(print (counter2)) ;; =&amp;gt; 12&#xA;(print (counter1)) ;; =&amp;gt; 4&#xA;(print (counter1)) ;; =&amp;gt; 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An equivalent JavaScript code is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Runs on the browser&#39;s console&#xA;function new_counter (init) {&#xA;    let i = init;&#xA;    return function () {&#xA;        return ++i;&#xA;    }&#xA;}&#xA;&#xA;var counter1 = new_counter(0);&#xA;var counter2 = new_counter(10);&#xA;&#xA;console.log(counter1()); // =&amp;gt; 1&#xA;console.log(counter1()); // =&amp;gt; 2&#xA;console.log(counter2()); // =&amp;gt; 11&#xA;console.log(counter1()); // =&amp;gt; 3&#xA;console.log(counter2()); // =&amp;gt; 12&#xA;console.log(counter1()); // =&amp;gt; 4&#xA;console.log(counter1()); // =&amp;gt; 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Object-Oriented Programming&lt;/h3&gt; &#xA;&lt;p&gt;As described in &lt;a href=&#34;https://letoverlambda.com/&#34;&gt;Let Over Lambda&lt;/a&gt;, when you have closures, you get object-oriented programming for free. LambdaLisp has a built-in OOP feature implemented as predefined macros based on closures. It supports Python-like classes with class inheritance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;; Runs on LambdaLisp&#xA;(defclass Counter ()&#xA;  (i 0)&#xA;&#xA;  (defmethod inc ()&#xA;    (setf (. self i) (+ 1 (. self i))))&#xA;&#xA;  (defmethod dec ()&#xA;    (setf (. self i) (- (. self i) 1))))&#xA;&#xA;&#xA;(defclass Counter-add (Counter)&#xA;  (defmethod *init (i)&#xA;    (setf (. self i) i))&#xA;&#xA;  (defmethod add (n)&#xA;    (setf (. self i) (+ (. self i) n))))&#xA;&#xA;&#xA;(defparameter counter1 (new Counter))&#xA;(defparameter counter2 (new Counter-add 100))&#xA;&#xA;((. counter1 inc))&#xA;((. counter2 add) 100)&#xA;&#xA;(setf (. counter1 i) 5)&#xA;(setf (. counter2 i) 500)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An equivalent Python code is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Counter ():&#xA;    i = 0&#xA;&#xA;    def inc (self):&#xA;        self.i += 1&#xA;        return self.i&#xA;    &#xA;    def dec (self):&#xA;        self.i -= 1&#xA;        return self.i&#xA;&#xA;class Counter_add (Counter):&#xA;    def __init__ (self, i):&#xA;        self.i = i&#xA;    &#xA;    def add (self, n):&#xA;        self.i += n&#xA;        return self.i&#xA;&#xA;counter1 = Counter()&#xA;counter2 = Counter_add(100)&#xA;&#xA;counter1.inc()&#xA;counter2.add(100)&#xA;&#xA;counter1.i = 5&#xA;counter2.i = 500&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;More Examples&lt;/h3&gt; &#xA;&lt;p&gt;More examples can be found under &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/examples&#34;&gt;./examples&lt;/a&gt;. The largest program written for LambdaLisp that has been tested is &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/examples/lambdacraft.cl&#34;&gt;lambdacraft.cl&lt;/a&gt;, which runs the lambda calculus compiler &lt;a href=&#34;https://github.io/woodrush/lambdacraft&#34;&gt;LambdaCraft&lt;/a&gt; written for this project, also used to compile LambdaLisp itself.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Key features are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Signed 32-bit integers&lt;/li&gt; &#xA; &lt;li&gt;Strings&lt;/li&gt; &#xA; &lt;li&gt;Closures, lexical scopes, and persistent bindings with &lt;code&gt;let&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Object-oriented programming feature with class inheritance&lt;/li&gt; &#xA; &lt;li&gt;Reader macros with &lt;code&gt;set-macro-character&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Access to the interpreter&#39;s virtual heap memory with &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;memread&lt;/code&gt;, and &lt;code&gt;memwrite&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Show the call stack trace when an error is invoked&lt;/li&gt; &#xA; &lt;li&gt;Garbage collection during macro expansion&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported special forms and functions are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;defun, defmacro, lambda (&amp;amp;rest can be used)&lt;/li&gt; &#xA; &lt;li&gt;quote, atom, car, cdr, cons, eq&lt;/li&gt; &#xA; &lt;li&gt;+, -, *, /, mod, =, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=, integerp&lt;/li&gt; &#xA; &lt;li&gt;read (reads Lisp expressions), print, format (supports &lt;code&gt;~a&lt;/code&gt; and &lt;code&gt;~%&lt;/code&gt;), write-to-string, intern, stringp&lt;/li&gt; &#xA; &lt;li&gt;let, let*, labels, setq, boundp&lt;/li&gt; &#xA; &lt;li&gt;progn, loop, block, return, return-from, if, cond, error&lt;/li&gt; &#xA; &lt;li&gt;list, append, reverse, length, position, mapcar&lt;/li&gt; &#xA; &lt;li&gt;make-hash-table, gethash (setf can be used)&lt;/li&gt; &#xA; &lt;li&gt;equal, and, or, not&lt;/li&gt; &#xA; &lt;li&gt;eval, apply&lt;/li&gt; &#xA; &lt;li&gt;set-macro-character, peek-char, read-char, &lt;code&gt;`&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;,@&lt;/code&gt; &lt;code&gt;&#39;&lt;/code&gt; &lt;code&gt;#\&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;carstr, cdrstr, str, string comparison with =, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=, string concatenation with +&lt;/li&gt; &#xA; &lt;li&gt;defun-local, defglobal, type, macro&lt;/li&gt; &#xA; &lt;li&gt;malloc, memread, memwrite&lt;/li&gt; &#xA; &lt;li&gt;new, defclass, defmethod, &lt;code&gt;.&lt;/code&gt;, field assignment by setf&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported Lambda Calculus Interpreters&lt;/h2&gt; &#xA;&lt;p&gt;Below is a summary of the supported lambda calculus interpreters. All interpreters run on the terminal and automatically handles the previously described string-to-lambda encoding for the standard I/O. Each interpreter uses a slightly different I/O encoding, classified below as languages.&lt;/p&gt; &#xA;&lt;p&gt;LambdaLisp is written natively as a lambda term based on the language &lt;a href=&#34;https://tromp.github.io/cl/cl.html&#34;&gt;Binary Lambda Calculus&lt;/a&gt;. It is adapted to other languages by wrapping it with an &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/src/lazyk-ulamb-blc-wrapper.cl&#34;&gt;encoder-decoder&lt;/a&gt; that absorbs the language spec differences.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Language&lt;/th&gt; &#xA;   &lt;th&gt;Extension&lt;/th&gt; &#xA;   &lt;th&gt;Engine&lt;/th&gt; &#xA;   &lt;th&gt;Program Format&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://tromp.github.io/cl/cl.html&#34;&gt;Binary Lambda Calculus&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;*.blc&lt;/td&gt; &#xA;   &lt;td&gt;Untyped Lambda Calculus&lt;/td&gt; &#xA;   &lt;td&gt;Binary (asc2bin can be used)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;http://www.golfscript.com/lam/&#34;&gt;Universal Lambda&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;*.ulamb&lt;/td&gt; &#xA;   &lt;td&gt;Untyped Lambda Calculus&lt;/td&gt; &#xA;   &lt;td&gt;Binary (asc2bin can be used)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://tromp.github.io/cl/lazy-k.html&#34;&gt;Lazy K&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;*.lazy&lt;/td&gt; &#xA;   &lt;td&gt;SKI Combinator Calculus&lt;/td&gt; &#xA;   &lt;td&gt;ASCII&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Interpreter&lt;/th&gt; &#xA;   &lt;th&gt;Language&lt;/th&gt; &#xA;   &lt;th&gt;Platforms&lt;/th&gt; &#xA;   &lt;th&gt;Build Command&lt;/th&gt; &#xA;   &lt;th&gt;Author&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://justine.lol/lambda/&#34;&gt;Blc&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Binary Lambda Calculus&lt;/td&gt; &#xA;   &lt;td&gt;x86-64-Linux&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;make blc&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/jart&#34;&gt;@jart&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://justine.lol/lambda/&#34;&gt;521-byte interpreter&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.ioccc.org/2012/tromp/hint.html&#34;&gt;tromp&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Binary Lambda Calculus&lt;/td&gt; &#xA;   &lt;td&gt;Any&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;make tromp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/tromp&#34;&gt;@tromp&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.ioccc.org/&#34;&gt;IOCCC&lt;/a&gt; 2012 &lt;a href=&#34;https://www.ioccc.org/2012/tromp/hint.html&#34;&gt;&#34;Most functional&#34;&lt;/a&gt; - the &lt;a href=&#34;https://www.ioccc.org/2012/tromp/tromp.c&#34;&gt;source&lt;/a&gt; is in the shape of a λ&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://tromp.github.io/cl/cl.html&#34;&gt;uni&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Binary Lambda Calculus&lt;/td&gt; &#xA;   &lt;td&gt;Any&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;make uni&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/tromp&#34;&gt;@tromp&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Unobfuscated version of &lt;code&gt;tromp&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/irori/clamb&#34;&gt;clamb&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Universal Lambda&lt;/td&gt; &#xA;   &lt;td&gt;Any&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;make clamb&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/irori&#34;&gt;@irori&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fast UL interpreter&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/irori/lazyk&#34;&gt;lazyk&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Lazy K&lt;/td&gt; &#xA;   &lt;td&gt;Any&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;make lazyk&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/irori&#34;&gt;@irori&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fast Lazy K interpreter&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Building the Lambda Calculus Interpreters&lt;/h3&gt; &#xA;&lt;p&gt;Several notes about the interpreters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The BLC intepreter &lt;code&gt;Blc&lt;/code&gt; runs only on x86-64-Linux systems.&lt;/li&gt; &#xA; &lt;li&gt;The BLC interpreter &lt;code&gt;tromp&lt;/code&gt; may not compile on a Mac with the defualt gcc (which is actually an alias of clang). Details are provided below.&lt;/li&gt; &#xA; &lt;li&gt;The most reliably compilable BLC interpreter is &lt;code&gt;uni&lt;/code&gt;, which compiles and runs on both Linux and Mac.&lt;/li&gt; &#xA; &lt;li&gt;The interpreters for Universal Lambda and Lazy K, &lt;code&gt;clamb&lt;/code&gt; and &lt;code&gt;lazyk&lt;/code&gt;, can be built and run on both of these systems.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To build all interpreters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make interpreters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, to build them individually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make blc tromp uni clamb lazyk asc2bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, asc2bin is a utility that packs ASCII 0/1 bitstreams to a byte stream, the format accepted by the BLC and UL interpreters.&lt;/p&gt; &#xA;&lt;p&gt;The interpreters&#39; source codes are obtained from external locations. When the make recipe is run, each recipe obtains these external source codes using the following commands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;blc&lt;/code&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;Blc.S&lt;/code&gt;: &lt;code&gt;wget https://justine.lol/lambda/Blc.S?v=2&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;flat.lds&lt;/code&gt;: &lt;code&gt;wget https://justine.lol/lambda/flat.lds&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;uni&lt;/code&gt;: &lt;code&gt;wget https://tromp.github.io/cl/uni.c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tromp&lt;/code&gt;: &lt;code&gt;wget http://www.ioccc.org/2012/tromp/tromp.c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clamb&lt;/code&gt;: &lt;code&gt;git clone https://github.com/irori/clamb&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lazyk&lt;/code&gt;: &lt;code&gt;git clone https://github.com/irori/lazyk&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Running LambdaLisp&lt;/h3&gt; &#xA;&lt;h4&gt;On Binary Lambda Calculus&lt;/h4&gt; &#xA;&lt;p&gt;After building all of the required tools and interpreters, running LambdaLisp on the Binary Lambda Calculus interpreter &lt;code&gt;Blc&lt;/code&gt; can be done as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd ./bin&#xA;# Pack the 01 bitstream to a bytestream&#xA;cat lambdalisp.blc | ./asc2bin &amp;gt; lambdalisp.blc.bin&#xA;&#xA;cat lambdalisp.blc.bin -            | ./Blc # Run the LambdaLisp REPL&#xA;cat lambdalisp.blc.bin [filepath]   | ./Blc # Run a LambdaLisp script and exit&#xA;cat lambdalisp.blc.bin [filepath] - | ./Blc # Run a LambdaLisp script, then enter the REPL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run on &lt;code&gt;tromp&lt;/code&gt; or &lt;code&gt;uni&lt;/code&gt;, replace &lt;code&gt;Blc&lt;/code&gt; with &lt;code&gt;tromp&lt;/code&gt; or &lt;code&gt;uni&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Running &lt;code&gt;cat -&lt;/code&gt; with the hyphen connects the standard input after the specified input files, allowing the user to interact with the interpreter through the terminal after reading a file. If &lt;code&gt;cat -&lt;/code&gt; doesn&#39;t work, the following command can be used instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;( cat lambdalisp.blc.bin [filepath]; cat ) | ./Blc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;On Universal Lambda&lt;/h4&gt; &#xA;&lt;p&gt;Running LambdaLisp on the Universal Lambda interpreter &lt;code&gt;clamb&lt;/code&gt; can be done as follows. Note that &lt;code&gt;lambdalisp.ulamb&lt;/code&gt; and &lt;code&gt;lambdalisp.blc&lt;/code&gt; are different files although they look similar, since they are different languages. This is since the I/O lambda term encoding is different for these languages. Otherwise, both languages are based entirely on untyped lambda calculus.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd ./bin&#xA;&#xA;# Pack the 01 bitstream to a bytestream&#xA;cat lambdalisp.ulamb | ./asc2bin &amp;gt; lambdalisp.ulamb.bin&#xA;&#xA;# The -u option is required for handling I/O properly&#xA;./clamb lambdalisp.ulamb.bin -u                    # Run the LambdaLisp REPL&#xA;cat [filepath]   | ./clamb -u lambdalisp.ulamb.bin # Run a LambdaLisp script and exit&#xA;cat [filepath] - | ./clamb -u lambdalisp.ulamb.bin # Run a LambdaLisp script, then enter the REPL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;On Lazy K&lt;/h4&gt; &#xA;&lt;p&gt;Running LambdaLisp on the Lazy K interpreter &lt;code&gt;lazyk&lt;/code&gt; can be done as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd ./bin&#xA;# The -u option is required for handling I/O properly&#xA;./lazyk ./lambdalisp.lazy -u                    # Run the LambdaLisp REPL&#xA;cat [filepath]   | ./lazyk lambdalisp.lazy -u # Run a LambdaLisp script and exit&#xA;cat [filepath] - | ./lazyk lambdalisp.lazy -u # Run a LambdaLisp script, then enter the REPL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building &#39;tromp&#39; on a Mac&lt;/h3&gt; &#xA;&lt;p&gt;Mac has &lt;code&gt;gcc&lt;/code&gt; installed by default or via Xcode Command Line Tools. However, &lt;code&gt;gcc&lt;/code&gt; is actually installed as an alias to &lt;code&gt;clang&lt;/code&gt;, which is a different compiler that doesn&#39;t compile &lt;code&gt;tromp&lt;/code&gt;. This is confirmable by running &lt;code&gt;gcc --version&lt;/code&gt;. On my Mac, running it shows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gcc --version&#xA;Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX10.15.sdk/usr/include/c++/4.2.1&#xA;Apple clang version 12.0.0 (clang-1200.0.32.29)&#xA;Target: x86_64-apple-darwin19.6.0&#xA;Thread model: posix&#xA;InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A workaround for this is to use &lt;code&gt;uni&lt;/code&gt; instead, which is an unobfuscated version of &lt;code&gt;tromp&lt;/code&gt; compilable with clang. To build &lt;code&gt;tromp&lt;/code&gt;, first install gcc via &lt;a href=&#34;https://brew.sh/&#34;&gt;Homebrew&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install gcc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Currently, this should install the command &lt;code&gt;gcc-11&lt;/code&gt;. After installing gcc, check the command it has installed.&lt;/p&gt; &#xA;&lt;p&gt;Then, edit the &lt;code&gt;Makefile&lt;/code&gt;&#39;s &lt;code&gt;CC&lt;/code&gt; configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- CC=cc&#xA;+ CC=gcc-11&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make tromp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will compile &lt;code&gt;tromp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building from Source&lt;/h2&gt; &#xA;&lt;p&gt;LambdaLisp&#39;s source code is written using &lt;a href=&#34;https://github.com/woodrush/lambdacraft&#34;&gt;LambdaCraft&lt;/a&gt;, a DSL written in Common Lisp for compiling Common Lisp to lambda calculus terms which written for this project. Building from source requires SBCL (Steel Bank Common Lisp), a Common Lisp interpreter.&lt;/p&gt; &#xA;&lt;p&gt;First install SBCL with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt install sbcl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or on a Mac with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install sbcl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;LambdaLisp can then be compiled with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make blc-src     # Builds lambdalisp.blc, for Binary Lambda Calculus&#xA;make ulamb-src   # Builds lambdalisp.ulamb, for Universal Lambda&#xA;make lazyk-src   # Builds lambdalisp.lazy, for Lazy K&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To compile &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/lambdalisp.pdf&#34;&gt;lambdalisp.pdf&lt;/a&gt;, first install LaTeX, and then run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make pdf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;There are 2 types of tests for LambdaLisp. Each test requires SBCL (Steel Bank Common Lisp), a Common Lisp interpreter.&lt;/p&gt; &#xA;&lt;p&gt;To run the tests, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make test      # Runs the tests on the BLC interpreter `uni`&#xA;make test-all  # Runs the tests on all of the available interpreters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;make test-all&lt;/code&gt; uses a maximum of about 5GB of memory (on the largest program &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/examples/lambdacraft.cl&#34;&gt;examples/lambdacraft.cl&lt;/a&gt;, which takes several minutes) and takes about 10 minutes on my machine.&lt;/p&gt; &#xA;&lt;p&gt;The GitHub Actions CI runs &lt;code&gt;make test-ulamb&lt;/code&gt;, which does the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compiles &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/bin/lambdalisp.blc&#34;&gt;./bin/lambdalisp.blc&lt;/a&gt; from &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambdalisp/main/src/main.cl&#34;&gt;./src/main.cl&lt;/a&gt; using SBCL&lt;/li&gt; &#xA; &lt;li&gt;Builds &lt;code&gt;Blc&lt;/code&gt; (SectorLambda)&lt;/li&gt; &#xA; &lt;li&gt;Runs &lt;code&gt;./examples/src/*.cl&lt;/code&gt; on both LambdaLisp (run with &lt;code&gt;Blc&lt;/code&gt;) and SBCL and compares the outputs&lt;/li&gt; &#xA; &lt;li&gt;Runs &lt;code&gt;./examples/src/*.lisp&lt;/code&gt; on LambdaLisp and compares the outputs with &lt;code&gt;./test/*.lisp.out&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Runs the LambdaCraft Compiler Hosting Test (described below)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Output Comparison Test&lt;/h3&gt; &#xA;&lt;p&gt;Runs the programs in &lt;code&gt;./examples/&lt;/code&gt;. Runnable with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make test-blc test-blc-uni test-blc-tromp test-ulamb test-lazyk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The files &lt;code&gt;examples/*.cl&lt;/code&gt; run both on Common Lisp and LambdaLisp producing identical results, except for the initial &lt;code&gt;&amp;gt; &lt;/code&gt; printed by the REPL in LambdaLisp. For programs with the extension &lt;code&gt;*.cl&lt;/code&gt;, the programs are run in Steel Bank Common Lisp (SBCL) and LambdaLisp, and the outputs are compared.&lt;/li&gt; &#xA; &lt;li&gt;The files &lt;code&gt;examples/*.lisp&lt;/code&gt; are LambdaLisp-exclusive programs. The output of these files are compared with &lt;code&gt;test/*.lisp.out&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;LambdaLisp runs on three lambda-calculus-based and SKI-combinator-calculus-based languages, binary lambda calculus, Universal Lambda, and Lazy K. For binary lambda calculus, there are three interpreters, Blc, uni, and tromp. Each &lt;code&gt;make&lt;/code&gt; command shown here runs this test in each of the languages and interpreters.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;LambdaCraft Compiler Hosting Test&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;examples/lambdacraft.cl&lt;/code&gt; runs &lt;a href=&#34;https://github.com/woodrush/lambdacraft&#34;&gt;LambdaCraft&lt;/a&gt;, a Common-Lisp-to-lambda-calculus compiler written in Common Lisp, used to compile the lambda calculus source for LambdaLisp. It defines a binary lambda calculus (BLC) program that prints the letter &lt;code&gt;A&lt;/code&gt; and exits, and prints the BLC source code for the defined program.&lt;/li&gt; &#xA; &lt;li&gt;The LambdaCraft compiler hosting test first executes &lt;code&gt;examples/lambdacraft.cl&lt;/code&gt; on LambdaLisp, then runs the output BLC program on a BLC interpreter, and checks if it prints the letter &lt;code&gt;A&lt;/code&gt; and exits.&lt;/li&gt; &#xA; &lt;li&gt;The test is run on binary lambda calculus, with either the interpreter Blc or uni.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Runnable with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make test-compiler-hosting-blc test-compiler-hosting-blc-uni&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Experimental: Self-Hosting Test&lt;/h3&gt; &#xA;&lt;p&gt;This test is currently theoretical since it requires a lot of time and memory, and is unused in &lt;code&gt;make test-all&lt;/code&gt;. This test extends the previous LambdaCraft compiler hosting test and checks if the Common Lisp source code for LambdaLisp runs on LambdaLisp itself. Since the LambdaCraft compiler hosting test runs properly, this test should theoretically run as well, although it requires a tremendous amount of memory and time. The test is run on the binary lambda calculus interpreter Blc.&lt;/p&gt; &#xA;&lt;p&gt;One concern is whether the 32-bit heap address space used internally in LambdaLisp is enough to compile this program. This can be solved by compiling LambdaLisp with an address space of 64-bit or larger, which can be done simply by replacing the literal &lt;code&gt;32&lt;/code&gt; (which only appears once in &lt;code&gt;src/lambdalisp.cl&lt;/code&gt;) with &lt;code&gt;64&lt;/code&gt;, etc. Another concern is whether if the execution hits Blc&#39;s maximum term limit. This can be solved by compiling Blc with a larger memory limit, by editing the rule for &lt;code&gt;$(BLC)&lt;/code&gt; in the Makefile.&lt;/p&gt; &#xA;&lt;p&gt;Runnable with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make test-self-host&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How it Works&lt;/h2&gt; &#xA;&lt;p&gt;Implementation details are introduced in &lt;a href=&#34;https://woodrush.github.io/blog/lambdalisp.html&#34;&gt;this blog post&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>wqwa/sandbox</title>
    <updated>2022-09-20T01:33:14Z</updated>
    <id>tag:github.com,2022-09-20:/wqwa/sandbox</id>
    <link href="https://github.com/wqwa/sandbox" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>