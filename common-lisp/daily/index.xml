<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-20T01:31:37Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>phantomics/april</title>
    <updated>2022-11-20T01:31:37Z</updated>
    <id>tag:github.com,2022-11-20:/phantomics/april</id>
    <link href="https://github.com/phantomics/april" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The APL programming language (a subset thereof) compiling to Common Lisp.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;April&lt;/h1&gt; &#xA;&lt;!-- /TITLE --&gt; &#xA;&lt;h4&gt;Array Programming Re-Imagined in Lisp&lt;/h4&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Ken Iverson&#39;s masterpiece reflected in the medium of Lisp.&lt;/p&gt; &#xA;&lt;p&gt;April compiles a subset of the APL programming language into Common Lisp. Leveraging Lisp&#39;s powerful macros and numeric processing faculties, it brings APL&#39;s expressive potential to bear for Lisp developers. Replace hundreds of lines of number-crunching code with a single line of APL.&lt;/p&gt; &#xA;&lt;h2&gt;Why April?&lt;/h2&gt; &#xA;&lt;p&gt;APL veritably hums with algorithmic power. As a handful of characters run past the lexer, vast fields of data grow, morph and distil to reveal their secrets. However, APL has hitherto dwelt in an ivory tower, secluded inside monolithic runtime environments. If you have a store of data you&#39;d like to process with APL, getting it there can be an ordeal akin to hauling tons of cargo on donkeys&#39; backs through a narrow mountain pass. The original APL interpreters ran on mainframes whose only input was the keyboard and only output was the printer and the legacy of that implementation approach has persisted to this day, limiting the reach of the language.&lt;/p&gt; &#xA;&lt;p&gt;But no longer. Lisp is the great connector of the software world, digesting and transforming semantic patterns in much the same way that APL works upon numeric patterns. With APL inside of Lisp, databases, streams, binary files and other media are just a few lines of code away from processing with APL.&lt;/p&gt; &#xA;&lt;h3&gt;Discussion&lt;/h3&gt; &#xA;&lt;p&gt;For the time being, discussion of April and its development is happening on the &lt;code&gt;##phantomics&lt;/code&gt; channel on irc.libera.chat.&lt;/p&gt; &#xA;&lt;h2&gt;Support April&#39;s Development&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;d like to help provide for continuing work on April, you can &lt;a href=&#34;https://www.patreon.com/lisp&#34;&gt;contribute through Patreon&lt;/a&gt;. April is making fast and steady progress toward the goal of being a powerful, full-featured and professional APL implementation, whose ease of extension and integration with other software offers game-changing advantages in the vector language field. Did you know that April&#39;s code at the beginning of December 2021 was over 95% different from its code at the beginning of September 2020?&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility with Common Lisp Implementations&lt;/h2&gt; &#xA;&lt;p&gt;April puts the numeric and array processing capabilities of Common Lisp to the test. It has been verified to work with SBCL, CCL, ECL, ABCL, Clasp, Allegro CL and LispWorks but SBCL and CCL are the only implementations that are completely free of compatibility problems. &lt;a href=&#34;https://raw.githubusercontent.com/phantomics/april/master/compatibility-notes.md&#34;&gt;See this document for a list of all differences in functionality between implementations.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Automatic Installation&lt;/h2&gt; &#xA;&lt;p&gt;April is supplied by the Quicklisp library manager, so the easiest way to install April is through Quicklisp. To install April with Quicklisp, evaluate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(ql:quickload &#39;april)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Manual Installation&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;d like to install April manually from this repository, you can follow these instructions.&lt;/p&gt; &#xA;&lt;h3&gt;Cloning the Repository&lt;/h3&gt; &#xA;&lt;p&gt;First, clone the repository to a location on your system. For this example, let&#39;s say you cloned it to the directory ~/mystuff/april.&lt;/p&gt; &#xA;&lt;h3&gt;Preparing Quicklisp&lt;/h3&gt; &#xA;&lt;p&gt;Enter your Quicklisp local-projects directory (usually ~/quicklisp/local-projects) and create a symbolic link to the directory where you cloned the April repository. For example, if you cloned the repo to ~/mystuff/april and your Quicklisp directory is ~/quicklisp/, enter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ~/quicklisp/local-projects&#xA;ln -s ~/mystuff/april&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Installing Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;To complete the installation, just start a Common Lisp REPL and enter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(ql:quickload &#39;april)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will download and install April&#39;s dependencies, and with that the package will be built and ready.&lt;/p&gt; &#xA;&lt;h2&gt;APL Functions and Operators&lt;/h2&gt; &#xA;&lt;p&gt;The APL language uses single characters to represent its primitive functions and operators. Most of these symbols are not part of the standard ASCII character set but are unique to APL. To see a list of the glyphs that are supported by April, visit the link below.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/phantomics/april/master/lexicon.md&#34;&gt;See the complete April APL lexicon here.&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Some APL functions and operators won&#39;t be added to April since they don&#39;t make sense for April&#39;s design as a compiler from APL to Lisp. Others may be added in the future. &lt;a href=&#34;https://raw.githubusercontent.com/phantomics/april/master/#whats-not-planned-for-implementation&#34;&gt;See the list of features not implemented here.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting to Know APL&lt;/h2&gt; &#xA;&lt;p&gt;A full guide to the APL language is far beyond the scope of this file, but here are links to some good sources.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://archive.vector.org.uk/art10011550&#34;&gt;A high-level introduction to APL.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://microapl.com/APL/tutorial_contents.html&#34;&gt;This is a detailed language tutorial covering most of the functions and operators in April.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.jsoftware.com/papers/tot.htm&#34;&gt;The original paper by Ken Iverson, creator of APL, detailing the language&#39;s underlying philosophy.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you would like a quick tour of the language, April includes a function that will print demos of all the commands and many APL syntax features. To see the demos, enter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (demo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The * indicates a REPL prompt. Prepare for a long read. The demo content that gets printed will tell you the name(s) of the operations that correspond to each symbol and will hopefully give you some idea of what each one does.&lt;/p&gt; &#xA;&lt;h3&gt;How to Enter APL Characters&lt;/h3&gt; &#xA;&lt;p&gt;In order to write APL programs you&#39;ll need a way to use the language&#39;s special character set.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/phantomics/april/master/#enabling-apl-input-in-emacs&#34;&gt;Click here for information on enabling APL input within Emacs.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/phantomics/april/master/#enabling-apl-input-in-vim&#34;&gt;Click here for information on enabling APL input within Vim.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/phantomics/april/master/#enabling-apl-input-universally-in-gnulinux&#34;&gt;Click here for information on enabling APL input universally within GNU/Linux.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Basic Evaluation: (april) and (april-f)&lt;/h2&gt; &#xA;&lt;p&gt;Evaluating an APL expression is as simple as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f &#34;1+2 3 4&#34;)&#xA;3 4 5&#xA;#(3 4 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As above, the * indicates a REPL prompt and the text below is the expression&#39;s output.&lt;/p&gt; &#xA;&lt;p&gt;The macro &lt;code&gt;(april-f)&lt;/code&gt; (short for april-format) will evaluate any APL string passed to it as the sole argument, returning the final result. Using &lt;code&gt;(april-f)&lt;/code&gt; will also produce a printout of the output in APL&#39;s traditional array printing style, which appears before the actual output value. You can see above how the &lt;code&gt;3 4 5&lt;/code&gt; is printed out before the value &lt;code&gt;#(3 4 5)&lt;/code&gt;. APL-style printed arrays are easier to read than Lisp&#39;s style of printing arrays; APL can use a simpler style to express its output because it doesn&#39;t have as many different data types and structures as Lisp.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t need to see the printout, you can use the plain &lt;code&gt;(april)&lt;/code&gt; macro. Like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april &#34;1+2 3 4&#34;)&#xA;#(3 4 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should use &lt;code&gt;(april)&lt;/code&gt; if you&#39;re using April to do calculations inside of a larger program and don&#39;t need the printout. Otherwise, especially if you&#39;re working with large data sets, the system may consume significant resources printing out the results of calculations.&lt;/p&gt; &#xA;&lt;p&gt;Setting state properties for the APL instance can be done like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f (with (:state :count-from 0)) &#34;⍳9&#34;)&#xA;0 1 2 3 4 5 6 7 8&#xA;#(0 1 2 3 4 5 6 7 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of an APL string, the first argument to &lt;code&gt;(april)&lt;/code&gt; or &lt;code&gt;(april-f)&lt;/code&gt; may be a list of parameters for the APL environment. The APL expression is then passed in the second argument.&lt;/p&gt; &#xA;&lt;p&gt;For example, you can use the &lt;code&gt;:count-from&lt;/code&gt; parameter to determine whether functions in the evaluated APL code will start counting from 0 or 1. We&#39;ll get into more detail on how these parameters work later.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f (with (:state :count-from 1)) &#34;⍳9&#34;)&#xA;1 2 3 4 5 6 7 8 9&#xA;#(1 2 3 4 5 6 7 8 9)&#xA;&#xA;* (april-f (with (:state :count-from 0)) &#34;⍳9&#34;)&#xA;0 1 2 3 4 5 6 7 8&#xA;#(0 1 2 3 4 5 6 7 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More APL expressions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f &#34;⍳12&#34;)&#xA;1 2 3 4 5 6 7 8 9 10 11 12&#xA;#(1 2 3 4 5 6 7 8 9 10 11 12)&#xA;&#xA;* (april-f &#34;3 4⍴⍳12&#34;)&#xA;1  2  3  4&#xA;5  6  7  8&#xA;9 10 11 12&#xA;#2A((1 2 3 4) (5 6 7 8) (9 10 11 12))&#xA;&#xA;* (april-f &#34;+/3 4⍴⍳12&#34;)&#xA;10 26 42&#xA;#(10 26 42)&#xA;&#xA;* (april-f &#34;+⌿3 4⍴⍳12&#34;)&#xA;15 18 21 24&#xA;#(15 18 21 24)&#xA;&#xA;* (april-f &#34;+/[1]3 4⍴⍳12&#34;)&#xA;15 18 21 24&#xA;#(15 18 21 24)&#xA;&#xA;* (april-f &#34;⌽3 4⍴⍳12&#34;)&#xA; 4  3  2 1&#xA; 8  7  6 5&#xA;12 11 10 9&#xA;#2A((4 3 2 1) (8 7 6 5) (12 11 10 9))&#xA;&#xA;* (april-f &#34;1⌽3 4⍴⍳12&#34;)&#xA; 2  3  4 1&#xA; 6  7  8 5&#xA;10 11 12 9&#xA;#2A((2 3 4 1) (6 7 8 5) (10 11 12 9))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;A note on escaping characters&lt;/h3&gt; &#xA;&lt;p&gt;April uses the backslash character &lt;code&gt;\&lt;/code&gt; to implement the expand function and the scan operator. Because of the way Lisp strings work, this character must be escaped with a second &lt;code&gt;\&lt;/code&gt; before it in order to enter APL code containing backslashes. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f &#34;+\\⍳5&#34;)&#xA;1 3 6 10 15&#xA;#(1 3 6 10 15)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inside the &lt;code&gt;&#34;string&#34;&lt;/code&gt;, the two backslashes evaluate to a single backslash. If you forget about this, you can run into confusing errors.&lt;/p&gt; &#xA;&lt;h2&gt;Unique Language Features in April&lt;/h2&gt; &#xA;&lt;p&gt;For the most part, April&#39;s syntax and functions follow standard APL conventions. But there are a few areas where April differs from typical APL implementations along with some unique language features. Most notably:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;; k-style if-statements&#xA;* (april &#34;x←5 ⋄ $[x&amp;gt;3;8;12]&#34;)&#xA;8&#xA;&#xA;;; k-style functions with any number of named arguments&#xA;* (april &#34;monthlyPayment←{[amt;int;len] (len÷⍨amt×int×0.1)+amt÷len} ⋄ monthlyPayment[5000;0.8;12]&#34;)&#xA;450.0&#xA;&#xA;;; numbered branch points instantiated with →⎕ syntax&#xA;* (april &#34;x←1 ⋄ →1+1 ⋄ x×←11 ⋄ 1→⎕ ⋄ x×←3 ⋄ 2→⎕ ⋄ x×←5 ⋄ 3→⎕ ⋄ x×←7&#34;)&#xA;35&#xA;&#xA;;; symbol-referenced branch points and a branch function with expression-determined branch symbol choice&#xA;* (april &#34;x←1 ⋄ (5-3)→two three ⋄ x×←11 ⋄ one→⎕ ⋄ x×←3 ⋄ two→⎕ ⋄ x×←5 ⋄ three→⎕ ⋄ x×←7&#34;)&#xA;7&#xA;&#xA;;; ⍶ and ⍹ are used to reference values passed as operands to a user-defined operator&#xA;* (april &#34;&#39;*&#39; {⍶,⍵} &#39; b c d&#39;&#34;)&#xA;&#34;* b c d&#34;&#xA;&#xA;;; if the operands passed to a user-defined operator are to be functions,&#xA;;; ⍺⍺ and ⍵⍵ are used as in other APLs&#xA;* (april &#34;(2∘|) {(⍺⍺¨⍵)/⍵} ⍳20&#34;)&#xA;#(1 3 5 7 9 11 13 15 17 19)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The biggest difference between April and other APLs lies in its implementation of the &lt;code&gt;→ branch&lt;/code&gt; function, as shown in the third and fourth examples above. April also allows you to use if-statements and functions with any number of named arguments in the style of Arthur Whitney&#39;s k programming language.&lt;/p&gt; &#xA;&lt;p&gt;Because of April&#39;s nature as a compiler, user-defined operators use different symbols to refer to operands depending whether the operands are values or functions. The underlined characters &lt;code&gt;⍶&lt;/code&gt; and &lt;code&gt;⍹&lt;/code&gt; are used to refer to the operands as values, while the doubled characters &lt;code&gt;⍺⍺&lt;/code&gt; and &lt;code&gt;⍵⍵&lt;/code&gt; refer to the operands as functions. The presence of both &lt;code&gt;⍶&lt;/code&gt; and &lt;code&gt;⍺⍺&lt;/code&gt; or both &lt;code&gt;⍹&lt;/code&gt; and &lt;code&gt;⍵⍵&lt;/code&gt; in a defined operator will cause an error.&lt;/p&gt; &#xA;&lt;h3&gt;Using rational numbers&lt;/h3&gt; &#xA;&lt;p&gt;April is one of a few APL implementations to include rational numbers. They are printed with a lowercase &lt;code&gt;r&lt;/code&gt; separating the numerator and denominator. Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f &#34;÷⍳5&#34;)&#xA;1 1r2 1r3 1r4 1r5&#xA;#(1 1/2 1/3 1/4 1/5)&#xA;&#xA;* (april-f &#34;2r3×⍳4&#34;)&#xA;2r3 4r3 2 8r3&#xA;#(2/3 4/3 2 8/3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rational numbers can also be used as parts of complex numbers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f &#34;3r4J9r5×⍳4&#34;)&#xA;3r4J9r5 3r2J18r5 9r4J27r5 3J36r5&#xA;#(#C(3/4 9/5) #C(3/2 18/5) #C(9/4 27/5) #C(3 36/5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Underscores within numbers&lt;/h3&gt; &#xA;&lt;p&gt;In April, you can use underscores to separate parts of a number:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april &#34;1_000_000+5&#34;)&#xA;1000005&#xA;&#xA;* (april &#34;1__000_000__000_000+5&#34;)&#xA;1000000000005&#xA;&#xA;* (april &#34;1_00___0_0__00_0+5&#34;)&#xA;10000005&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As shown above, you can use any number of underscores anywhere within a number, they are simply ignored by the reader. Underscores are also used by the printer when printing columns of mixed complex floats and rationals:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f &#34;⍪12.2J99.11 3J8 19r13J5r2&#34;)&#xA;12.20J99.11&#xA; 3___J_8   &#xA;19r13J_5r_2&#xA;#2A((#C(12.2 99.11)) (#C(3 8)) (#C(19/13 5/2)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using the underscores as filler keeps the decimal points, rs and Js properly aligned for printing.&lt;/p&gt; &#xA;&lt;h3&gt;Strings and escaped quotes&lt;/h3&gt; &#xA;&lt;p&gt;In April, either single or double quotes can be used to enclose character strings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april &#34;&#39;abc&#39;,&#39;def&#39;&#34;)&#xA;&#34;abcdef&#34;&#xA;&#xA;* (april &#34;\&#34;ghi\&#34;,\&#34;jkl\&#34;&#34;)&#xA;&#34;ghijkl&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that you must use backslashes to escape double quotes used within Lisp strings, making double quotes a less desirable choice unless you&#39;re loading April code from files using &lt;code&gt;(april-load)&lt;/code&gt;. In order to escape quote characters within an April string, enter the quote character twice. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april &#34;&#39;\&#39;abc&#39;\&#39;&#34;)&#xA;&#34;&#39;abc&#39;&#34;&#xA;&#xA;* (april &#34;&#39;&#39;&#39;abc&#39;&#39;&#39;&#34;)&#xA;&#34;&#39;abc&#39;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compact Function Calls: The (april-c) Macro&lt;/h2&gt; &#xA;&lt;p&gt;Want to invoke April functions on some variables with less code? You can use the &lt;code&gt;(april-c)&lt;/code&gt; macro. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-c &#34;{⍺×⍵}&#34; 2 8)&#xA;16&#xA;&#xA;* (april-c &#34;{[a;b;c;d] d↑c⍴a+b}&#34; 3 5 6 10)&#xA;#(8 8 8 8 8 8 0 0 0 0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After the string where the April function is written, pass the variables that will be input to the function and you&#39;ll receive the result with no need for a long &lt;code&gt;(with (:state ...))&lt;/code&gt; clause. If you wish to pass parameters in a &lt;code&gt;(with)&lt;/code&gt; clause, you can still do it with &lt;code&gt;(april-c)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-c (with (:state :count-from 0)) &#34;{⍳⍵}&#34; 7)&#xA;#(0 1 2 3 4 5 6)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The arguments passed to &lt;code&gt;(april-c)&lt;/code&gt; are in the order &lt;code&gt;⍵ ⍺&lt;/code&gt;. This may seem counterintuitive:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-c &#34;{⍵-⍺}&#34; 10 5)&#xA;5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But keep in mind that a function must always have a right argument, but may or may not have a left argument. Therefore it&#39;s easier to remember that the first argument after the function string is always the right argument, and the second argument, if present, is the left argument.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;(april-c)&lt;/code&gt; macro can also be used to compose inline operators with functions. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-c &#34;{⍺⍺/⍵}&#34; #&#39;+ #(1 2 3 4 5))&#xA;15&#xA;&#xA;* (april-c &#34;{⍵⍵ ⍺⍺/⍵}&#34; #&#39;+ #&#39;- #(1 2 3 4 5))&#xA;-15&#xA;&#xA;* (april-c &#34;{⍵⍵ ⍺ ⍺⍺/⍵}&#34; #&#39;+ (scalar-function -) #(1 2 3 4 5) 3)&#xA;#(-6 -9 -12) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that in operators where a right operand is expected (i.e. those that contain a &lt;code&gt;⍵⍵&lt;/code&gt; or &lt;code&gt;⍹&lt;/code&gt; symbol), two operands are expected following the code string. In an operator taking only a left operand, whose code doesn&#39;t include &lt;code&gt;⍵⍵&lt;/code&gt; or &lt;code&gt;⍹&lt;/code&gt;, one operand is expected following the code string. The arguments to &lt;code&gt;(april-c)&lt;/code&gt; for an operator are in the order &lt;code&gt;⍺⍺/⍶ (⍵⍵/⍹ if present) ⍵ (⍺ if present)&lt;/code&gt;. The left operand comes first in the arguments because all operators must have a left operand, but they may or may not have a right operand.&lt;/p&gt; &#xA;&lt;p&gt;Keep in mind that standard Common Lisp functions like &lt;code&gt;(+)&lt;/code&gt; do not operate on entire arrays like APL functions do. In order to pass scalar functions into April via &lt;code&gt;(april-c)&lt;/code&gt; that can be composed with operators and work as you expect scalar functions to when doing operations like &lt;code&gt;- 3 +/⍳5&lt;/code&gt;, you must pass those functions&#39; symbols through the &lt;code&gt;(scalar-function)&lt;/code&gt; macro as seen above with &lt;code&gt;(scalar-function -)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Parameter reference&lt;/h2&gt; &#xA;&lt;p&gt;When &lt;code&gt;(april)&lt;/code&gt; or &lt;code&gt;(april-f)&lt;/code&gt; is called, you may pass it either a single text string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f &#34;1+1 2 3&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or a parameter object followed by a text string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f (with (:state :count-from 0)) &#34;⍳9&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This section details the parameters you can pass to April.&lt;/p&gt; &#xA;&lt;h3&gt;(test)&lt;/h3&gt; &#xA;&lt;p&gt;To run April&#39;s test suite, just enter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (test))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;(demo)&lt;/h3&gt; &#xA;&lt;p&gt;As mentioned before, you can see demos of April&#39;s functions with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (demo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;(with)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;(with)&lt;/code&gt; is the workhorse of April parameters, allowing you to specify many options for an April invocation. The most common sub-parameter passed via &lt;code&gt;(with)&lt;/code&gt; is &lt;code&gt;(:state)&lt;/code&gt;. To wit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (with (:state :count-from 0&#xA;                       :in ((a 3) (b 5))&#xA;                       :out (a c)))&#xA;         &#34;c←a+⍳b&#34;)&#xA;3&#xA;#(3 4 5 6 7)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;(:state) sub-parameters&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s learn some more about what&#39;s going on in that code. The sub-parameters of &lt;code&gt;(:state)&lt;/code&gt; are:&lt;/p&gt; &#xA;&lt;h4&gt;:count-from&lt;/h4&gt; &#xA;&lt;p&gt;Sets the index from which April counts. Almost always set to 0 or 1. The default value is 1. In the code above, &lt;code&gt;⍳b&lt;/code&gt; with &lt;code&gt;b&lt;/code&gt; equal to 5 counts from 0 to 4, whereas with the default &lt;code&gt;:count-from&lt;/code&gt; value of 1, &lt;code&gt;⍳b&lt;/code&gt; would count from 1 to 5. When you set :count-from, it only affects the APL code evaluated in the expression to which the :count-from option is passed. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;&#xA;* (april (with (:state :count-from 0)) &#34;⍳9&#34;)&#xA;#(0 1 2 3 4 5 6 7 8)&#xA;&#xA;* (april &#34;⍳9&#34;)&#xA;#(1 2 3 4 5 6 7 8 9)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;:in&lt;/h4&gt; &#xA;&lt;p&gt;Passes variables into the April instance that may be used when evaluating the subsequent expressions. In the example above, the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are set in the code, with values 1 and 2 respectively. You can use &lt;code&gt;:in&lt;/code&gt; to pass values from Lisp into the April instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f (with (:state :in ((a 5) (b 10))))&#xA;           &#34;1+2+a×b&#34;)&#xA;53&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that April variables follow a stricter naming convention than Lisp variables. When naming the input variables, only alphanumeric characters, underscores and dashes may be used. In keeping with APL tradition, the delta/triangle characters ∆ and ⍙ can be used in variable names as well. Punctuation marks like ?, &amp;gt;, . and ! may not be used as they have separate meanings in April.&lt;/p&gt; &#xA;&lt;p&gt;These characters are allowed in variable names within April:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_∆⍙&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These variable names are ok for use with the &lt;code&gt;:in&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a var my_var another-var&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These are not ok:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;true! this-&amp;gt;that pass/fail? var.name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you use dashes in the names of Lisp variables you pass into April, note that inside April they will be converted to camel case. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f (with (:state :in ((one-var 2)&#xA;                              (other-var 5))))&#xA;           &#34;oneVar×otherVar+5&#34;)&#xA;20&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The dash character &lt;code&gt;-&lt;/code&gt; is used to denote the subtraction function inside April, so you may not use dashes in variable names within the language.&lt;/p&gt; &#xA;&lt;p&gt;One more caveat: it&#39;s best to avoid using input variable names with a dash before a number or other non-letter symbol. The dash will be removed and the character following it will cannot be capitalized so information will have been lost. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;my-var-2 → myVar2&#xA;my-var-∆ → myVar∆&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;strong&gt;An important note about modifying arrays passed to April&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;When passing array values into April via &lt;code&gt;:in&lt;/code&gt; or direct function calls using &lt;code&gt;(april-c)&lt;/code&gt;, be advised that assinging new values to their elements &lt;em&gt;may or may not&lt;/em&gt; destructively modify the original arrays. Whether destructive modification happens depends on whether the values assigned are compatible with the element type of the original arrays. Here is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(let ((a #(1 2 3)) (b #(2 3 4))&#xA;      (c (make-array 3 :element-type &#39;(unsigned-byte 4)&#xA;                       :initial-contents &#39;(7 8 9)))&#xA;      (d (make-array 3 :element-type &#39;(unsigned-byte 4)&#xA;                       :initial-contents &#39;(10 11 12))))&#xA;  (april (with (:state :in ((a a) (b b) (c c) (d d))))&#xA;         &#34;a[1]←20 ⋄ (⊃b)←30 ⋄ c[1]←40 ⋄ (⊃d)←50&#34;)&#xA;  (vector a b c d))&#xA;&#xA;#(#(20 2 3) #(30 3 4) #(7 8 9) #(10 11 12))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first two T-type vectors are destructively modified since they are compatible with the elements being assigned. The second two vectors of 4-bit integers are copied and reassigned within the April invocation because they are not compatible with the values being assigned, and those the original arrays are left intact.&lt;/p&gt; &#xA;&lt;h4&gt;:out&lt;/h4&gt; &#xA;&lt;p&gt;Lists variables to be output when the code has finished evaluating. By default, the value of the last evaluated expression is passed back after an April evaluation is finished. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f &#34;1+2&#xA;            2+3&#xA;            3+4&#34;)&#xA;7&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The last value calculated is displayed. The &lt;code&gt;:out&lt;/code&gt; sub-parameter allows you to list a set of variables that whose values will be returned once evaluation is complete. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f (with (:state :out (a b c)))&#xA;           &#34;a←9+2&#xA;            b←5+3&#xA;            c←2×9&#34;)&#xA;11&#xA;8&#xA;18&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;:index-origin&lt;/h4&gt; &#xA;&lt;p&gt;This is another, more technical name for the &lt;code&gt;:count-from&lt;/code&gt; sub-parameter. You can use it instead of &lt;code&gt;:count-from&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f (with (:state :index-origin 0)) &#34;⍳9&#34;)&#xA;0 1 2 3 4 5 6 7 8&#xA;#(0 1 2 3 4 5 6 7 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;:print-precision&lt;/h4&gt; &#xA;&lt;p&gt;This controls the maximal precision at which April prints floating point numbers. Its default value is 10. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f &#34;○1 2 3&#34;)&#xA;3.141592654 6.283185307 9.424777961&#x9;&#xA;#(3.141592653589793d0 6.283185307179586d0 9.42477796076938d0)&#xA;&#xA;* (april-f (with (:state :print-precision 6)) &#34;○1 2 3&#34;)&#xA;3.14159 6.28319 9.42478&#xA;#(3.141592653589793d0 6.283185307179586d0 9.42477796076938d0)&#xA;&#xA;* (april-f (with (:state :print-precision 3)) &#34;○1 2 3&#34;)&#xA;3.14 6.28 9.42&#xA;#(3.141592653589793d0 6.283185307179586d0 9.42477796076938d0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;:print-precision&lt;/code&gt; doesn&#39;t affect the Lisp values output by April, only the printed output.&lt;/p&gt; &#xA;&lt;h4&gt;:print-to&lt;/h4&gt; &#xA;&lt;p&gt;When using &lt;code&gt;(april-f)&lt;/code&gt;, the formatted array content is output to the &lt;code&gt;*standard-output*&lt;/code&gt; stream. When using &lt;code&gt;(april)&lt;/code&gt;, no formatted output is printed. You can change this using the &lt;code&gt;:print-to&lt;/code&gt; sub-parameter. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (with (:state :print-to *standard-output*)) &#34;2 3⍴⍳9&#34;)&#xA;1 2 3&#xA;4 5 6&#xA;#2A((1 2 3) (4 5 6))&#xA;&#xA;* (april-f (with (:state :print-to nil)) &#34;2 3⍴⍳9&#34;)&#xA;#2A((1 2 3) (4 5 6))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using the &lt;code&gt;:print-to&lt;/code&gt; parameter effectively erases the distinction between &lt;code&gt;(april)&lt;/code&gt; and &lt;code&gt;(april-f)&lt;/code&gt;. The two different macros are provided as a courtesy so you don&#39;t need to pass a &lt;code&gt;:print-to&lt;/code&gt; parameter to get printed output. You can also pass a different stream than &lt;code&gt;*standard-output*&lt;/code&gt; to &lt;code&gt;:print-to&lt;/code&gt; to have the printed output directed there.&lt;/p&gt; &#xA;&lt;h4&gt;:output-printed&lt;/h4&gt; &#xA;&lt;p&gt;When the &lt;code&gt;:output-printed&lt;/code&gt; sub-parameter is passed, the string of APL-formatted data that gets printed will also be returned as the last output value by the April invocation. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (with (:state :output-printed t)) &#34;2 3⍴⍳9&#34;)&#xA;#2A((1 2 3) (4 5 6))&#xA;&#34;1 2 3&#xA;4 5 6&#xA;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t want to receive the Lisp value output by April and only want the formatted string as output, you can pass the &lt;code&gt;:only&lt;/code&gt; option to &lt;code&gt;:output-printed&lt;/code&gt;, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (with (:state :output-printed :only)) &#34;2 3⍴⍳9&#34;)&#xA;&#34;1 2 3&#xA;4 5 6&#xA;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This way, the formatted string will be the only returned value.&lt;/p&gt; &#xA;&lt;h3&gt;(:space) parameter&lt;/h3&gt; &#xA;&lt;p&gt;If you want to create a persistent workspace where the functions and variables you&#39;ve created are stored and can be used in multiple calls to April, you must first create the workspace. Here&#39;s how:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;* (april-create-workspace space1)&#xA;&#34;Successfully created workspace ｢SPACE1｣.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, to evaluate April code within use the &lt;code&gt;(:space)&lt;/code&gt; parameter. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-f (with (:space space1)) &#34;a←5+2 ⋄ b←3×9&#34;)&#xA;27&#xA;&#xA;* (april-f (with (:space space1)) &#34;c←{⍵+2}&#34;)&#xA;#&amp;lt;FUNCTION ... &amp;gt;&#xA;&#xA;* (april-f (with (:space space1)) &#34;c a+b&#34;)&#xA;36&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, a workspace called &lt;code&gt;space1&lt;/code&gt; is created, two variables and a function are stored within it, and then the function is called on the sum of the variables.&lt;/p&gt; &#xA;&lt;p&gt;When you invoke &lt;code&gt;(april)&lt;/code&gt; without naming a workspace, a workspace called &lt;code&gt;common&lt;/code&gt; is used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (with (:space common)) &#34;a←5&#34;)&#xA;5&#xA;&#xA;* (april &#34;a+5&#34;)&#xA;10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;(:store-val) and (:store-fun) parameters&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;d like to add values and functions from the Lisp instance into an April workspace, you can use the &lt;code&gt;(:store-val)&lt;/code&gt; and &lt;code&gt;(:store-fun)&lt;/code&gt; parameters. Here is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (with (:store-val (a 12) (b 45))) &#34;a+b+10&#34;)&#xA;67&#xA;&#xA;* (april &#34;3×a&#34;)&#xA;36&#xA;&#xA;* (april (with (:store-fun (add-ten (lambda (x) (+ x 10))))) &#34;&#34;)&#xA;NIL ;; the result of not running code after the function is stored&#xA;&#xA;* (april &#34;addTen 20&#34;)&#xA;30&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As shown above, dash-separated variable and function names are converted to camel case, just as when passing input values with the &lt;code&gt;:in&lt;/code&gt; sub-parameter of &lt;code&gt;(:state)&lt;/code&gt;. Note also that functions passed into April this way are not adapted for use with arrays the way that functions created within April are. For instance, if you enter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (with (:store-fun (add-ten (lambda (x) (+ x 10))))) &#34;&#34;)&#xA;NIL&#xA;&#xA;* (april &#34;addTen 1 2 3 4 5&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will get an error stating something like &lt;code&gt;The value #(1 2 3 4 5) is not of type NUMBER ...&lt;/code&gt;. That&#39;s because in Lisp, you can&#39;t add 10 to the vector &lt;code&gt;#(1 2 3 4 5)&lt;/code&gt;, which is what the function is attempting to do. Use caution when adding arbitrary Lisp functions into an April workspace.&lt;/p&gt; &#xA;&lt;p&gt;If you want to store functions or variables with names that are read literally rather than being converted to camel case, you can do this by passing strings as the variable names. If a dash is found in such a string-expressed variable name it will cause an error. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(april (with (:store-fun (&#34;aBcDe&#34; (lambda (x) (+ x 10))))) &#34;aBcDe 5&#34;)&#xA;15&#xA;&#xA;;; the presence of a dash causes an error&#xA;(april (with (:store-fun (&#34;ab-cd&#34; (lambda (x) (+ x 10))))) &#34;abcd 6&#34;)&#xA;Error: Invalid characters present in symbol aBC-deF passed to :STORE-FUN.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;(:compile-only) parameter&lt;/h3&gt; &#xA;&lt;p&gt;If you just want to compile the code you enter into April without running it, use this option. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (with (:compile-only)) &#34;1+1 2 3&#34;)&#xA;(IN-APRIL-WORKSPACE COMMON&#xA;  (LET ((OUTPUT-STREAM *STANDARD-OUTPUT*))&#xA;    (DECLARE (IGNORABLE OUTPUT-STREAM))&#xA;    (SYMBOL-MACROLET ((INDEX-ORIGIN ⊑*INDEX-ORIGIN*)&#xA;                      (PRINT-PRECISION ⊑*PRINT-PRECISION*)&#xA;                      (COMPARISON-TOLERANCE ⊑*COMPARISON-TOLERANCE*)&#xA;                      (DIVISION-METHOD ⊑*DIVISION-METHOD*)&#xA;                      (RNGS ⊑*RNGS*))&#xA;      (A-OUT (A-CALL (APL-FN-S +) (AVEC 1 2 3) 1) :PRINT-PRECISION&#xA;             PRINT-PRECISION))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;(:print-tokens) parameter&lt;/h3&gt; &#xA;&lt;p&gt;April compiles code in two stages: first, the lexer converts the string of characters into lists of tokens, then the compiler takes those tokens and uses them to generate Common Lisp code based on grammar elements and patterns. You can see the implementation of April&#39;s grammar in &lt;a href=&#34;https://raw.githubusercontent.com/phantomics/april/master/grammar.lisp&#34;&gt;the grammar source file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like to see the lists of tokens the lexer generates for a given APL expression, you can see them by passing the &lt;code&gt;(:print-tokens)&lt;/code&gt; parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (with (:print-tokens)) &#34;(⍳4)+⍤1⊢3 4⍴⍳9&#34;)&#xA;(9 (:FN #\APL_FUNCTIONAL_SYMBOL_IOTA) (:FN #\APL_FUNCTIONAL_SYMBOL_RHO) 4 3&#xA; (:FN #\RIGHT_TACK) 1 (:OP :PIVOTAL #\APL_FUNCTIONAL_SYMBOL_JOT_DIAERESIS)&#xA; (:FN #\+) (4 (:FN #\APL_FUNCTIONAL_SYMBOL_IOTA)))&#xA;#2A((2 4 6 8) (6 8 10 12) (10 3 5 7))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Clearing Workspaces: The (april-clear-workspace) Macro&lt;/h2&gt; &#xA;&lt;p&gt;You can use this macro to clear a workspace, removing all user-created variables within it and returning it to its default state. For example, to clear a workspace called &lt;code&gt;space1&lt;/code&gt;, enter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-clear-workspace space1)&#xA;&#34;The workspace ｢SPACE1｣ has been cleared.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;References to April Workspace Contents: The (april-ref) Function&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;d like to easily fetch a value or function from an April workspace within Common Lisp code, you can use the &lt;code&gt;(april-ref)&lt;/code&gt; function. It works like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april &#34;v←⍳3&#34;)&#xA;#(1 2 3)&#xA;&#xA;* (length (april-ref &#39;|v|))&#xA;3&#xA;&#xA;* (april &#34;fn←{⍵+5}&#34;)&#xA;#&amp;lt;FUNCTION ...&amp;gt;&#xA;&#xA;* (funcall (april-ref &#34;fn&#34;) 10)&#xA;15&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The arguments to &lt;code&gt;(april-ref)&lt;/code&gt; can be strings or symbols (which will be converted to strings). Since &lt;code&gt;(april-ref)&lt;/code&gt; is a function and not a macro you can construct strings to pass to it as arguments like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april &#34;abcdef←×&#34;)&#xA;#&amp;lt;FUNCTION ...&amp;gt;&#xA;&#xA;* (funcall (april-ref (format nil &#34;~a~a&#34; &#34;abc&#34; :|def|)) 2 5)&#xA;10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default &lt;code&gt;(april-ref)&lt;/code&gt; fetches items from the default &lt;code&gt;common&lt;/code&gt; workspace. By passing two arguments you can choose the workspace to use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-create-workspace space1)&#xA;&#34;Successfully created workspace ｢SPACE1｣.&#34;&#xA;&#xA;* (april (with (:space space1)) &#34;v←25&#34;)&#xA;25&#xA;&#xA;* (* 3 (april-ref (format nil &#34;SPACE~a&#34; 1) :|v|))&#xA;75&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sharing Scope: The (with-april-context) Macro&lt;/h2&gt; &#xA;&lt;p&gt;Perhaps you&#39;d like to make multiple calls to April using the same workspace and other parameters and you don&#39;t want to have to enter the same parameters over and over again. The &lt;code&gt;(with-april-context)&lt;/code&gt; macro can help. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-create-workspace space1)&#xA;&#34;Successfully created workspace ｢SPACE1｣.&#34;&#xA;&#xA;* (with-april-context ((:space space1) (:state :index-origin 0))&#xA;    (april &#34;g←5&#34;)&#xA;    (april &#34;g×3+⍳9&#34;))&#xA;#(15 20 25 30 35 40 45 50 55)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inside the body of the &lt;code&gt;(with-april-context)&lt;/code&gt; macro, each of the &lt;code&gt;(april)&lt;/code&gt; invocations act as if they were passed the options &lt;code&gt;(with (:space space1) (:state :index-origin 0))&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-create-workspace space1)&#xA;&#34;Successfully created workspace ｢SPACE1｣.&#34;&#xA;&#xA;* (with-april-context ((:space space1) (:state :index-origin 0))&#xA;    (april &#34;x←⍳3&#34;)&#xA;    (april (with (:state :index-origin 1)) &#34;x,⍳5&#34;))&#xA;#(0 1 2 1 2 3 4 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Options passed for one of the &lt;code&gt;(april)&lt;/code&gt; invocations inside the context will override the options for the context. Here, the second &lt;code&gt;(april)&lt;/code&gt; invocation has its index origin set to 1 which overrides the context&#39;s 0 value.&lt;/p&gt; &#xA;&lt;h2&gt;Console Output Using the Quad Character&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;(april-f)&lt;/code&gt; macro is one way to view the printed output of APL expressions. What if you want to see the result of an evaluation that occurs in the middle of your code instead of the end, or if you want to print the contents of multiple arrays within a single expression? At times like these, you can use the &lt;code&gt;⎕&lt;/code&gt; character, also called &#34;quad.&#34; In APL, console output can be produced by &#34;assigning&#34; values to &lt;code&gt;⎕&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april &#34;a←1 2 3 ⋄ b←3+⎕←2+a ⋄ ⎕←c←4+b ⋄ c+5&#34;)&#xA;3 4 5&#xA;10 11 12&#xA;#(15 16 17)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both of the values assigned to &lt;code&gt;⎕&lt;/code&gt; are printed in order before the expression&#39;s final result is output. Because &lt;code&gt;(april)&lt;/code&gt; is used instead of &lt;code&gt;(april-f)&lt;/code&gt;, no formatted values are printed by default; only the values assigned to &lt;code&gt;⎕&lt;/code&gt; are printed. Using &lt;code&gt;⎕&lt;/code&gt;, it&#39;s easy to debug complex functions.&lt;/p&gt; &#xA;&lt;h2&gt;Loading Code Directly From Files&lt;/h2&gt; &#xA;&lt;p&gt;Perhaps you&#39;d like to write files containing pure APL code rather than passing strings to &lt;code&gt;(april)&lt;/code&gt; within Lisp code. The &lt;code&gt;(april-load)&lt;/code&gt; macro has you covered. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-apl&#34;&gt;⍝ contents of file test.apl&#xA;&#xA;v  ← ⍳9&#xA;fn ← {⍵+10}&#xA;⎕  ← fn v&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-load #P&#34;/path/to/test.apl&#34;)&#xA;11 12 13 14 15 16 17 18 19&#xA;#(11 12 13 14 15 16 17 18 19)&#xA;&#xA;* (april &#34;fn 3 4 5&#34;)&#xA;#(13 14 15)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The variable &lt;code&gt;v&lt;/code&gt; and the function &lt;code&gt;fn&lt;/code&gt; have been loaded into the default workspace.&lt;/p&gt; &#xA;&lt;p&gt;Note that the argument to &lt;code&gt;(april-load)&lt;/code&gt; must be a pathname, not merely a string. The argument to &lt;code&gt;(april-load)&lt;/code&gt; may also be an expression that evaluates to a pathname. For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-load (pathname (format nil &#34;~a/test.apl&#34; &#34;/test/directory&#34;)))&#xA;11 12 13 14 15 16 17 18 19&#xA;#(11 12 13 14 15 16 17 18 19)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;(april-load)&lt;/code&gt; macro may take a first argument containing the same parameters that can be passed to &lt;code&gt;(april)&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-create-workspace space1)&#xA;&#34;Successfully created workspace ｢SPACE1｣.&#34;&#xA;&#xA;* (april-load (with (:space space1) (:state :index-origin 0)) #P&#34;/path/to/test.apl&#34;)&#xA;10 11 12 13 14 15 16 17 18&#xA;#(10 11 12 13 14 15 16 17 18)&#xA;&#xA;* (april (with (:space space1)) &#34;fn 9 8 7&#34;)&#xA;#(19 18 17)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Source code from files can thus be loaded into any workspace.&lt;/p&gt; &#xA;&lt;h2&gt;APL System Variables and Functions in April&lt;/h2&gt; &#xA;&lt;p&gt;April makes available the following APL system variables, constants and functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;⎕IO ⎕CT ⎕PP ⎕DIV ⎕RL ⎕A ⎕D ⎕TS ⎕NS ⎕CS ⎕UCS ⎕FMT&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, April exposes this special system variable not found in other APL implementations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;⎕OST ⎕DT ⎕XWV ⎕XWF ⎕XWO&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/phantomics/april/master/environmental-symbols.md&#34;&gt;Click here to read the names and descriptions of these symbols.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About Workspace Variables: Index Origin and Print Precision&lt;/h2&gt; &#xA;&lt;p&gt;Above, you learned how to use the &lt;code&gt;:count-from&lt;/code&gt;/&lt;code&gt;:index-origin&lt;/code&gt; and &lt;code&gt;:print-precision&lt;/code&gt; sub-parameters to control how April counts and prints. Using these parameters with an April invocation will affect &lt;em&gt;only&lt;/em&gt; the code passed to that particular April invocation. What if you want to create a change in these parameters that will persist in a given workspace until it&#39;s changed again?&lt;/p&gt; &#xA;&lt;p&gt;Traditional APL dialects use the &lt;code&gt;⎕IO&lt;/code&gt; and &lt;code&gt;⎕PP&lt;/code&gt; system variables to set the index origin and print precision in a workspace, and using them in April will make a change that persists in the workspace. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-create-workspace space1)&#xA;&#34;Successfully created workspace ｢SPACE1｣.&#34;&#xA;&#xA;* (april-create-workspace space2)&#xA;&#34;Successfully created workspace ｢SPACE2｣.&#34;&#xA;&#xA;* (april-f (with (:space space1)) &#34;⎕IO←0 ⋄ ⍳9&#34;)&#xA;0 1 2 3 4 5 6 7 8&#xA;#(0 1 2 3 4 5 6 7 8)&#xA;&#xA;* (april-f (with (:space space1)) &#34;⍳9&#34;)&#xA;0 1 2 3 4 5 6 7 8&#xA;#(0 1 2 3 4 5 6 7 8)&#xA;&#xA;* (april-f (with (:space space2)) &#34;⍳9&#34;)&#xA;1 2 3 4 5 6 7 8 9&#xA;#(1 2 3 4 5 6 7 8 9)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Switching to the workspace &lt;code&gt;space2&lt;/code&gt;, the default index origin of 1 is used again.&lt;/p&gt; &#xA;&lt;p&gt;If you pass an &lt;code&gt;:index-origin&lt;/code&gt;, &lt;code&gt;:count-from&lt;/code&gt; or &lt;code&gt;:print-precision&lt;/code&gt; sub-parameter to an APL invocation, it will override whatever value is present in the active workspace. However, it will only affect the code passed to the individual &lt;code&gt;(april)&lt;/code&gt; invocation that has the sub-parameter(s) passed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april-create-workspace space1)&#xA;&#34;Successfully created workspace ｢SPACE1｣.&#34;&#xA;&#xA;* (april-f (with (:space space1)) &#34;⎕IO←0 ⋄ ⍳9&#34;)&#xA;0 1 2 3 4 5 6 7 8&#xA;#(0 1 2 3 4 5 6 7 8)&#xA;&#xA;* (april-f (with (:state :count-from 1)) &#34;⍳9&#34;)&#xA;1 2 3 4 5 6 7 8 9&#xA;#(1 2 3 4 5 6 7 8 9)&#xA;&#xA;* (april-f (with (:space space1)) &#34;⍳9&#34;)&#xA;0 1 2 3 4 5 6 7 8&#xA;#(0 1 2 3 4 5 6 7 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Setting a Custom Output Stream&lt;/h2&gt; &#xA;&lt;p&gt;April has a system variable called &lt;code&gt;⎕ost&lt;/code&gt; that you can use to set a custom destination for printed output. Normally, data output using &lt;code&gt;(april-f)&lt;/code&gt; or values assigned to the quad character like &lt;code&gt;⎕←1 2 3&lt;/code&gt; are sent to the &lt;code&gt;*standard-output*&lt;/code&gt; stream. You can change this as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (let* ((out-str (make-string-output-stream))&#xA;&#x9; (vector (april-f &#34;a←1 2 3 ⋄ ⎕ost←&#39;OUT-STR&#39; ⋄ ⎕←a+5 ⋄ ⎕←3 4 5 ⋄ ⎕ost←&#39;*STANDARD-OUTPUT*&#39; ⋄ 3+a&#34;)))&#xA;    (princ (get-output-stream-string out-str))&#xA;    vector)&#xA;4 5 6&#xA;6 7 8&#xA;3 4 5&#xA;#(4 5 6)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Within the APL expression, the output stream is set to &lt;code&gt;OUT-STR&lt;/code&gt;, two vectors are output to that stream, and then the stream is reset to &lt;code&gt;*STANDARD-OUTPUT*&lt;/code&gt; before the expression ends and prints its final output. When the code runs, first the APL-formatted output from the &lt;code&gt;(april-f)&lt;/code&gt; expression is printed. Then, the two APL-formatted strings output to the &lt;code&gt;out-str&lt;/code&gt; stream are printed. Finally, the Lisp vector that resulted from the &lt;code&gt;(april-f)&lt;/code&gt; expression is printed.&lt;/p&gt; &#xA;&lt;p&gt;Remember to use all caps when setting the &lt;code&gt;⎕ost&lt;/code&gt; variable, unless your desired output stream is referenced by a literal lowercase symbol like &lt;code&gt;|output-stream|&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The syntax above assumes that the symbol representing the output stream is internal to the current package. For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package #:pkg-one)&#xA;&#xA;(defvar out-str (make-string-output-stream))&#xA;&#xA;(april-f &#34;⎕ost←&#39;OUT-STR&#39; ⋄ 5+10&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this code, the &lt;code&gt;OUT-STR&lt;/code&gt; output stream is interned in the package &lt;code&gt;PKG-ONE&lt;/code&gt;. What if you want to use an output stream whose symbol belongs to a package other than the current one?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(in-package #:pkg-one)&#xA;&#xA;(defvar out-str (make-string-output-stream))&#xA;&#xA;(in-package #:pkg-two)&#xA;&#xA;(april-f &#34;⎕ost←(&#39;PKG-ONE&#39; &#39;OUT-STR&#39;) ⋄ 5+10&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you assign to &lt;code&gt;⎕ost&lt;/code&gt; a vector of two strings, the first string is the name of a package and the second string is the name of a symbol belonging to that package. In this way, you can reference an output stream whose symbol is interned in a package other than the current one.&lt;/p&gt; &#xA;&lt;h2&gt;Referencing Variables, Functions and Operators in Another Workspace&lt;/h2&gt; &#xA;&lt;p&gt;A difference between April and other APLs is the way in which workspaces are handled. Because April workspaces are modeled as Lisp software packages, it&#39;s possible to include things from one workspace in another in much the same way you do with Common Lisp&#39;s &lt;code&gt;(defpackage)&lt;/code&gt; macro. In other APLs, a workspace is more akin to the complete application state of an APL interpreter, so sharing items between them is more complicated to implement.&lt;/p&gt; &#xA;&lt;p&gt;Below is an example of items shared between workspaces.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (with (:space first-space))&#xA;         &#34;V1←10 ⋄ V2←20 ⋄ F←{10×⍺÷⍵} ⋄ G←⍴∘,&#34;)&#xA;...&#xA;&#xA;* (april (with (:space second-space) (:compile-onl))&#xA;         &#34;A B ← &#39;FIRST-SPACE&#39; ⎕XWV &#39;V1&#39; &#39;V2&#39;&#xA;          H I ← &#39;FIRST-SPACE&#39; ⎕XWF &#39;F&#39; &#39;G&#39;&#xA;          A B H I A B&#34;)&#xA;#(5 5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;V1&lt;/code&gt; and &lt;code&gt;V2&lt;/code&gt; variables from &lt;code&gt;first-space&lt;/code&gt; are referenced as &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; while the &lt;code&gt;Fn1&lt;/code&gt; and &lt;code&gt;Fn2&lt;/code&gt; variables are referenced as &lt;code&gt;H&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; respectively. Operators can also be referenced with &lt;code&gt;⎕XWO&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s Not Planned for Implementation&lt;/h2&gt; &#xA;&lt;h4&gt;Functions:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;⍇ File read&#xA;⍈ File write&#xA;⍐ File hold&#xA;⍗ File drop&#xA;⎕ Evaluated input&#xA;⎕ Output with newline&#xA;⍞ Character input&#xA;⍞ Bare output&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Operators:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;amp; Spawn&#xA;⌶ I-Beam&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/phantomics/april/master/lexicon.md&#34;&gt;(Click here to see the functions and operators that have been implemented.)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;See a pattern? The functions not planned for implentation are all those that manifest low-level interactions between the APL instance and the underlying computer system. Common Lisp already has powerful tools for system interaction, so it&#39;s presumed that developers will do things like this outside of April.&lt;/p&gt; &#xA;&lt;h2&gt;Also Not Implemented&lt;/h2&gt; &#xA;&lt;p&gt;APL&#39;s function editor system and control statements are not implemented; this type of functionality is also readily accessible through standard Common Lisp. Also, rather than using control statements like &lt;code&gt;:If&lt;/code&gt;, April approaches the need for such structures with lexical statements like &lt;code&gt;$[]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;April&#39;s Lexicon Compared to Other APLs&lt;/h2&gt; &#xA;&lt;p&gt;APL has multiple implementations, and there are subtle but significant variations between the lexical functions they offer. April&#39;s set of functions is closest to those offered by Dyalog APL in its default mode. For instance, in April, dyadic &lt;code&gt;⊂&lt;/code&gt; implements the partitioned enclose function while dyadic &lt;code&gt;⊆&lt;/code&gt; implements the partition function, as in Dyalog. In IBM APL2, however, there is no partitioned enclose function and dyadic &lt;code&gt;⊂&lt;/code&gt; implements the partition function. The same is true in GNU APL, whose design primarily follows APL2.&lt;/p&gt; &#xA;&lt;p&gt;The other major lexical difference between APL2-family languages and April is that in April, monadic &lt;code&gt;⊃&lt;/code&gt; implements the disclose function and monadic &lt;code&gt;↑&lt;/code&gt; implements the mix function; the converse is true in APL2.&lt;/p&gt; &#xA;&lt;p&gt;Dyalog APL offers users the option of using multiple lexical modes, some of which are more similar to APL2. The variable controlling these modes is referred to as the &#34;migration level.&#34; The implementation of migration levels in April is not planned at this time.&lt;/p&gt; &#xA;&lt;h2&gt;Tests, Demo and the Extended Demo Suite&lt;/h2&gt; &#xA;&lt;p&gt;If you missed it earlier, you can run tests for the implemented APL functions and operators by entering:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (test))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And you can see a demonstration of April language features by entering:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;* (april (demo))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;April comes with a set of standard libraries and demo packages implementing useful APL functions. The libraries are located in (this repository&#39;s &lt;code&gt;/libaries&lt;/code&gt; folder)[/libraries], and the demo packages are located in (the &lt;code&gt;/demos&lt;/code&gt; folder)[/demos], and each library package has its own set of tests. You can load the libraries by evaluating &lt;code&gt;(load-libs)&lt;/code&gt; and run the tests for each demo by evaluating &lt;code&gt;(run-lib-tests)&lt;/code&gt; within the &lt;code&gt;april&lt;/code&gt; package. The library tests contain many complex functions that generate large arrays, giving the computer a workout. On slower systems these tests may take some time to complete.&lt;/p&gt; &#xA;&lt;h2&gt;Enabling APL Input in Emacs&lt;/h2&gt; &#xA;&lt;p&gt;Most Lisp developers interact with the language through Emacs, so Emacs is also the most convenient tool to write April programs. The best way to input APL characters in Emacs is using the gnu-apl-mode Emacs plugin. You can get it &lt;a href=&#34;https://github.com/lokedhs/gnu-apl-mode&#34;&gt;from the repository here&lt;/a&gt; or install it directly via the MELPA Emacs package repository.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://ergoemacs.org/emacs/emacs_package_system.html&#34;&gt;Click here for information on using MELPA.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once gnu-apl-mode is installed, you can switch to the APL input mode by typing &lt;code&gt;M-x toggle-input-method&lt;/code&gt; or &lt;code&gt;C-\&lt;/code&gt;. You will be prompted to enter the input mode to use, so enter &lt;code&gt;APL-Z&lt;/code&gt; and then you&#39;ll be able to toggle APL input on and off by typing &lt;code&gt;C-\&lt;/code&gt;. While in APL-Z input mode, you can enter APL characters by prefixing the key with a &lt;code&gt;.&lt;/code&gt; period character.&lt;/p&gt; &#xA;&lt;h2&gt;Enabling APL Input in Vim&lt;/h2&gt; &#xA;&lt;p&gt;For Lisp developers who interact with the language through Vim, a plugin called &#34;vim-apl&#34; allows one to input APL characters. You can get it &lt;a href=&#34;https://github.com/justin2004/vim-apl&#34;&gt;from this git repository&lt;/a&gt;. Using a Vim plugin manager called &lt;a href=&#34;https://github.com/VundleVim/Vundle.vim&#34;&gt;Vundle&lt;/a&gt; it is easy to add this plugin by adding the single line &lt;code&gt;Plugin &#39;justin2004/vim-apl&#39;&lt;/code&gt; to your .vimrc and following the Vundle instructions. With vim-apl installed, while editing an .apl file you can enter the iota character &lt;code&gt;⍳&lt;/code&gt; by typing &lt;code&gt;`i&lt;/code&gt; (backtick and i), enter the rho character &lt;code&gt;⍴&lt;/code&gt; by typing &lt;code&gt; `r&lt;/code&gt;, and so on.&lt;/p&gt; &#xA;&lt;h2&gt;Enabling APL Input Universally in GNU/Linux&lt;/h2&gt; &#xA;&lt;p&gt;For GNU/Linux users who&#39;d like use APL characters outside of a customized editor, refer to &lt;a href=&#34;https://aplwiki.com/wiki/Typing_glyphs_on_Linux&#34;&gt;this page&lt;/a&gt; on the APL Wiki. After following the instructions there you&#39;ll be able to use your keyboard&#39;s right Alt key as a modifier to enter APL characters. For instance, you enter can the iota character &lt;code&gt;⍳&lt;/code&gt; by pressing the &lt;code&gt;right Alt + i&lt;/code&gt;, the rho character &lt;code&gt;⍴&lt;/code&gt; by pressing the &lt;code&gt;right Alt + r&lt;/code&gt; and so on.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks to:&lt;/h2&gt; &#xA;&lt;p&gt;Tamas K. Papp, creator of &lt;a href=&#34;https://github.com/tpapp/array-operations&#34;&gt;array-operations&lt;/a&gt;, the basis for some of April&#39;s early function implementations.&lt;/p&gt; &#xA;&lt;p&gt;Max Rottenkolber, creator of &lt;a href=&#34;https://github.com/eugeneia/maxpc&#34;&gt;MaxPC&lt;/a&gt;, the heart of April&#39;s parsing engine.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/justin2004&#34;&gt;justin2004&lt;/a&gt; and &lt;a href=&#34;https://github.com/egao1980&#34;&gt;Nikolai Matiushev&lt;/a&gt;, contributors of many bug reports and suggestions.&lt;/p&gt;</summary>
  </entry>
</feed>