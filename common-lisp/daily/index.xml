<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-20T01:31:55Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>quil-lang/qvm</title>
    <updated>2023-07-20T01:31:55Z</updated>
    <id>tag:github.com,2023-07-20:/quil-lang/qvm</id>
    <link href="https://github.com/quil-lang/qvm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The high-performance and featureful Quil simulator.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;qvm: A High-Performance Quantum Virtual Machine&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rigetti/qvm/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/rigetti/qvm.svg?sanitize=true&#34; alt=&#34;github release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hub.docker.com/r/rigetti/qvm&#34;&gt;&lt;img src=&#34;https://img.shields.io/docker/pulls/rigetti/qvm.svg?sanitize=true&#34; alt=&#34;docker pulls&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://doi.org/10.5281/zenodo.3677538&#34;&gt;&lt;img src=&#34;https://zenodo.org/badge/DOI/10.5281/zenodo.3677538.svg?sanitize=true&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is the official Quil-Lang &lt;em&gt;Quantum Virtual Machine&lt;/em&gt; (QVM), a flexible and efficient simulator for &lt;a href=&#34;https://github.com/quil-lang/quil&#34;&gt;Quil&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This directory contains two projects. The first, &lt;code&gt;qvm&lt;/code&gt;, is a classical implementation of the Quantum Abstract Machine (QAM), called a &#34;Quantum Virtual Machine&#34; (QVM). The second, &lt;code&gt;qvm-app&lt;/code&gt;, is the application interface to interacting with the QVM, either directly through the &lt;code&gt;qvm&lt;/code&gt; binary or via its server interface.&lt;/p&gt; &#xA;&lt;p&gt;The definition of the QAM was developed at Rigetti in a paper titled &lt;a href=&#34;https://arxiv.org/pdf/1608.03355.pdf&#34;&gt;A Practical Quantum Instruction Set Architecture&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;QVM, the library&lt;/h2&gt; &#xA;&lt;p&gt;The QVM library is contained within &lt;code&gt;./src/&lt;/code&gt;, and provides the implementation of the Quantum Abstract Machine. It evaluates Quil programs (parsed and compiled by &lt;a href=&#34;https://github.com/rigetti/quilc&#34;&gt;quilc&lt;/a&gt;) on a virtual machine that can model various characteristics of (though without needing access to) a true quantum computer.&lt;/p&gt; &#xA;&lt;p&gt;The library is released under the &lt;a href=&#34;https://raw.githubusercontent.com/quil-lang/qvm/master/LICENSE.txt&#34;&gt;Apache license 2.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;The QVM library is available on Quicklisp, but of course may not have the latest features. It can be loaded simply with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;* (ql:quickload :qvm)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, one can download and load it manually. Please read and follow the instructions in &lt;a href=&#34;https://raw.githubusercontent.com/quil-lang/qvm/master/doc/lisp-setup.md&#34;&gt;&lt;code&gt;lisp-setup.md#install-quicklisp&lt;/code&gt;&lt;/a&gt; to get Quicklisp installed. Pay particular attention to the section &#34;Telling Quicklisp Where Your Code Is&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Download both this repository &lt;em&gt;and&lt;/em&gt; &lt;a href=&#34;http://github.com/rigetti/quilc&#34;&gt;quilc&lt;/a&gt; into the &lt;code&gt;ql:*local-project-directories*&lt;/code&gt; location. If all is correct, the &lt;code&gt;qvm&lt;/code&gt; library can be loaded with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sbcl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;* (ql:quickload :qvm)&#xA;(:QVM)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;QVM objects are created with &lt;code&gt;(qvm:make-qvm n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of qubits the QVM should support; a program can then be loaded into the QVM object with &lt;code&gt;(qvm:load-program *qvm* *program*)&lt;/code&gt; where &lt;code&gt;*qvm*&lt;/code&gt; is a QVM object and &lt;code&gt;*program*&lt;/code&gt; is a &lt;code&gt;cl-quil:parsed-program&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, the &lt;code&gt;qvm:run-program&lt;/code&gt; function will handle QVM object creation. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;* (setq *qvm* (qvm:run-program 2 (cl-quil:parse-quil &#34;H 0&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;creates a 2-qubit QVM object and on it runs the Quil program &lt;code&gt;H 0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The qubit amplitudes can be inspected&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;* (qvm::amplitudes *qvm*)&#xA;#(#C(0.7071067811865475d0 0.0d0) #C(0.7071067811865475d0 0.0d0)&#xA;  #C(0.0d0 0.0d0) #C(0.0d0 0.0d0))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which shows, as expected, that &lt;code&gt;H 0&lt;/code&gt; has put qubit-0 (the first two complex numbers above) into an equal superposition of states &lt;code&gt;|0&amp;gt;&lt;/code&gt; and &lt;code&gt;|1&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Measurement of a quantum state causes it to collapse into one of its basis states (&lt;code&gt;|0&amp;gt;&lt;/code&gt; or &lt;code&gt;|1&amp;gt;&lt;/code&gt;). This can be simulated with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;* (qvm:measure-all *qvm*)&#xA;#&amp;lt;PURE-STATE-QVM {1004039753}&amp;gt;&#xA;(0 0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inspecting the QVM object&#39;s state shows that this effect mutates the information stored on the QVM; i.e. the previous state information is lost&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;* (qvm::amplitudes *qvm*)&#xA;#(#C(1.0d0 0.0d0) #C(0.0d0 0.0d0)&#xA;  #C(0.0d0 0.0d0) #C(0.0d0 0.0d0))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Qubit zero&#39;s state has collapsed into the state &lt;code&gt;|0&amp;gt;&lt;/code&gt;. Repeating this process (from creating the QVM object to measuring qubits) would show that both states would each come up with probability 0.5.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;* (loop :with results := (vector 0 0)&#xA;        :with program := (cl-quil:parse-quil &#34;H 0&#34;)&#xA;        :repeat 100&#xA;        :for (qvm state) := (multiple-value-list (qvm:measure (qvm:run-program 1 program) 0))&#xA;        :do (incf (aref results state))&#xA;        :finally (return results))&#xA;#(54 46)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;p&gt;The QVM comes with some example code to illustrate usage of the QVM. The example code can be found under &lt;code&gt;./examples/&lt;/code&gt;. To run the example code, first load &lt;code&gt;qvm-examples&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;* (ql:quickload :qvm-examples)&#xA;(:QVM-EXAMPLES)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function &lt;code&gt;bit-reversal-circuit&lt;/code&gt; takes a list of qubit indices and returns a list of instructions that will reverse the qubit amplitudes in &#34;bit-reversal order&#34; (e.g., the coefficient of &lt;code&gt;|1110&amp;gt;&lt;/code&gt; gets mapped to &lt;code&gt;|0111&amp;gt;&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(qvm-examples:bit-reversal-circuit &#39;(1 2 3 4))&#xA;(#&amp;lt;SWAP 1 4&amp;gt; #&amp;lt;SWAP 2 3&amp;gt;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a given list of qubit indices, the function &lt;code&gt;qft-circuit&lt;/code&gt; returns a &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_Fourier_transform&#34;&gt;Quantum Fourier transform&lt;/a&gt; Quil program ready to be passed to quilc for compilation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;* (qvm-examples:qft-circuit &#39;(1 2 3 4))&#xA;#&amp;lt;CL-QUIL:PARSED-PROGRAM {10040ABEE3}&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To inspect the object, we can use the &lt;code&gt;cl-quil::print-parsed-program&lt;/code&gt; function&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;* (cl-quil::print-parsed-program (qvm-examples:qft-circuit &#39;(1 2 3 4)))&#xA;H 4&#xA;CPHASE(pi/2) 3 4&#xA;H 3&#xA;CPHASE(pi/4) 2 4&#xA;CPHASE(pi/2) 2 3&#xA;H 2&#xA;CPHASE(pi/8) 1 4&#xA;CPHASE(pi/4) 1 3&#xA;CPHASE(pi/2) 1 2&#xA;H 1&#xA;SWAP 1 4&#xA;SWAP 2 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;QVM, the application&lt;/h2&gt; &#xA;&lt;p&gt;The QVM application is contained with &lt;code&gt;./app/src/&lt;/code&gt;, and provides a stand-alone interface to the QVM library. It can be invoked directly with the binary executable, or alternatively it can provide a server that can be used over the network. Each has their benefits: the former permits a simplified interface using the command-line switches (see output of &lt;code&gt;qvm --help&lt;/code&gt;), while the latter allows many remote connections to a single in-memory QVM.&lt;/p&gt; &#xA;&lt;p&gt;The application is released under the &lt;a href=&#34;https://raw.githubusercontent.com/quil-lang/qvm/master/app/LICENSE.txt&#34;&gt;GNU Affero General Public License v3.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;To build the QVM application follow instructions in &lt;a href=&#34;https://raw.githubusercontent.com/quil-lang/qvm/master/doc/lisp-setup.md&#34;&gt;&lt;code&gt;lisp-setup.md&lt;/code&gt;&lt;/a&gt;. In the top-level directory, run the &lt;code&gt;Makefile&lt;/code&gt; with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make qvm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will produce a binary executable &lt;code&gt;qvm&lt;/code&gt; in the same directory.&lt;/p&gt; &#xA;&lt;p&gt;In some situtations, using a large number of qubits may cause heap exhaustion. There are two options to ameliorate this.&lt;/p&gt; &#xA;&lt;p&gt;The first is to increase the memory available for the QVM, recompile and specify the workspace size (in MB)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make QVM_WORKSPACE=4096 qvm&#xA;$ make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The second is to use a different allocator when running the QVM, by using the &lt;code&gt;--default-allocator&lt;/code&gt; argument with &lt;code&gt;&#34;foreign&#34;&lt;/code&gt;. For example, to run a 30 qubit benchmark on a QVM configured for far less memory, one can do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ qvm --default-allocator &#34;foreign&#34; --benchmark 30 -c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is &lt;em&gt;not&lt;/em&gt; the default since this memory is not fully managed by the application.&lt;/p&gt; &#xA;&lt;p&gt;The QVM application has a few command-line switches used to configure the QVM. To explore those options, see the output of the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ qvm --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the QVM accepts programs from stdin and writes results to stdout. Log messages are written to stderr.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: If you&#39;re on Windows and using the Command Prompt, the echo command is slightly different to the examples shown below: do not wrap your quil code in quotes. For example, in Command Prompt, you would do &lt;code&gt;echo H 0 | qvm&lt;/code&gt; &lt;em&gt;not&lt;/em&gt; &lt;code&gt;echo &#34;H 0&#34; | qvm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;H 0&#39; | qvm&#xA;******************************&#xA;* Welcome to the Rigetti QVM *&#xA;******************************&#xA;Copyright (c) 2016-2019 Rigetti Computing.&#xA;&#xA;(Configured with 8192 MiB of workspace and 8 workers.)&#xA;&#xA;&amp;lt;134&amp;gt;1 2019-03-07T22:56:55Z workstation.local qvm 21177 - - Selected simulation method: pure-state&#xA;&amp;lt;134&amp;gt;1 2019-03-07T22:56:55Z workstation.local qvm 21177 - - Reading program.&#xA;&amp;lt;134&amp;gt;1 2019-03-07T22:56:55Z workstation.local qvm 21177 - - Allocating memory for QVM of 1 qubits.&#xA;&amp;lt;134&amp;gt;1 2019-03-07T22:56:55Z workstation.local qvm 21177 - - Allocation completed in 7 ms.&#xA;&amp;lt;134&amp;gt;1 2019-03-07T22:56:55Z workstation.local qvm 21177 - - Loading quantum program.&#xA;&amp;lt;134&amp;gt;1 2019-03-07T22:56:55Z workstation.local qvm 21177 - - Executing quantum program.&#xA;&amp;lt;134&amp;gt;1 2019-03-07T22:56:55Z workstation.local qvm 21177 - - Execution completed in 4 ms.&#xA;&amp;lt;134&amp;gt;1 2019-03-07T22:56:55Z workstation.local qvm 21177 - - Printing classical memory and 1-qubit state.&#xA;Classical memory (low -&amp;gt; high indexes):&#xA;    No memory.&#xA;Amplitudes:&#xA;    |0&amp;gt;: 0.7071067811865475,                                    P= 50.0%&#xA;    |1&amp;gt;: 0.7071067811865475,                                    P= 50.0%&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively the QVM can be started as a server that will accept instructions over a network connection&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ qvm -S&#xA;******************************&#xA;* Welcome to the Rigetti QVM *&#xA;******************************&#xA;Copyright (c) 2016-2019 Rigetti Computing.&#xA;&#xA;(Configured with 2048 MiB of workspace and 8 workers.)&#xA;&#xA;&amp;lt;134&amp;gt;1 2019-01-28T19:06:07Z workstation.local qvm 3118 - - Selected simulation method: pure-state&#xA;&amp;lt;134&amp;gt;1 2019-01-28T19:06:07Z workstation.local qvm 3118 - - Starting server on port 5000.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is how the &lt;a href=&#34;https://github.com/rigetti/pyquil&#34;&gt;pyQuil&lt;/a&gt; Python library communicates with a QVM.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;Tests can be run from the &lt;code&gt;Makefile&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or from within SBCL&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;* (asdf:test-system :qvm)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any contribution to this project should foremost not break any current tests (run tests before making a pull request), and should be accompanied by relevant &lt;em&gt;new&lt;/em&gt; tests.&lt;/p&gt; &#xA;&lt;h2&gt;Clearing the Cache&lt;/h2&gt; &#xA;&lt;p&gt;Lisp caches a lot of builds so that not every single file needs to be recompiled. In rare instances, there&#39;s confusion and the cache doesn&#39;t get properly invalidated. (This can happen when moving files across machines, for example.) Lisp&#39;s cache and Quicklisp&#39;s system index can be cleaned by doing the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make cleanall&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will delete any built executables as well.&lt;/p&gt; &#xA;&lt;h2&gt;Automated Build, Test, and Release with Docker&lt;/h2&gt; &#xA;&lt;p&gt;The CI pipeline for &lt;code&gt;qvm&lt;/code&gt; produces a Docker image, available at &lt;a href=&#34;https://hub.docker.com/r/rigetti/qvm&#34;&gt;&lt;code&gt;rigetti/qvm&lt;/code&gt;&lt;/a&gt;. To get the latest stable version of &lt;code&gt;qvm&lt;/code&gt;, run &lt;code&gt;docker pull rigetti/qvm&lt;/code&gt;. To instead pull a specific version of the QVM, run &lt;code&gt;docker pull rigetti/qvm:VERSION&lt;/code&gt;, where &lt;code&gt;VERSION&lt;/code&gt; is something like &lt;code&gt;1.10.0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, all branches and commits for the QVM repository have corresponding image tags. For example, the image that contains the HEAD of branch &#34;qvm-fixes&#34; can be pulled with &lt;code&gt;docker pull rigetti/qvm:qvm-fixes&lt;/code&gt; (NOTE: some characters are invalid in Docker image tags, and are rewritten according to the description of &lt;a href=&#34;https://docs.gitlab.com/ee/ci/variables/predefined_variables.html&#34;&gt;&lt;code&gt;CI_COMMIT_REF_SLUG&lt;/code&gt;&lt;/a&gt;). The image built from the commit with first eight characters &lt;code&gt;abcd1234&lt;/code&gt; can be pulled with &lt;code&gt;docker pull rigetti/qvm:abcd1234&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The Dockerfile for qvm builds from two parent Docker images:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/rigetti/lisp&#34;&gt;&lt;code&gt;rigetti/lisp&lt;/code&gt;&lt;/a&gt;: Contains SBCL, Quicklisp, and third-party libraries.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/rigetti/quilc&#34;&gt;&lt;code&gt;rigetti/quilc&lt;/code&gt;&lt;/a&gt;: Contains the Quil Compiler.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The Dockerfile for qvm intentionally pins the versions of these two images, which means that the version numbers must be actively incremented as necessary. If the build for qvm is failing, this is probably the place to look, because the unit tests are run inside of a freshly-built qvm Docker image as part of the GitLab CI pipeline.&lt;/p&gt; &#xA;&lt;p&gt;However, because the development workflow for the QVM often involves having a locally cloned copy of quilc master, there are two additional CI jobs that override the version of quilc and instead build off of &lt;code&gt;rigetti/quilc:edge&lt;/code&gt;, which corresponds to the HEAD of master. These jobs are optional, meaning that if they fail the overall CI pipeline will not be marked as a failure, but they provide additional useful information to those that develop quilc and the QVM in unison.&lt;/p&gt; &#xA;&lt;h2&gt;Running the QVM with Docker&lt;/h2&gt; &#xA;&lt;p&gt;As outlined above, the QVM supports two modes of operation: stdin and server.&lt;/p&gt; &#xA;&lt;p&gt;To run the &lt;code&gt;qvm&lt;/code&gt; in stdin mode, do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &#34;H 0&#34; | docker run --rm -i rigetti/qvm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the &lt;code&gt;qvm&lt;/code&gt; in server mode, do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run --rm -it -p 5000:5000 rigetti/qvm -S&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you would like to change the port of the server to &lt;code&gt;PORT&lt;/code&gt;, you can alter the command as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run --rm -it -p PORT:PORT rigetti/qvm -S -p PORT&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Port 5000 is exposed using the EXPOSE directive in the &lt;code&gt;rigetti/qvm&lt;/code&gt; image, so you can additionally use the &lt;code&gt;-P&lt;/code&gt; option to automatically bind this container port to a randomly assigned host port. You can then inspect the mapping using &lt;code&gt;docker port CONTAINER [PORT]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Release Process&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Update &lt;code&gt;VERSION.txt&lt;/code&gt; and push the commit to &lt;code&gt;master&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Push a git tag &lt;code&gt;vX.Y.Z&lt;/code&gt; that contains the same version number as in &lt;code&gt;VERSION.txt&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Verify that the resulting build (triggered by pushing the tag) completes successfully.&lt;/li&gt; &#xA; &lt;li&gt;Publish a &lt;a href=&#34;https://github.com/rigetti/qvm/releases&#34;&gt;release&lt;/a&gt; using the tag as the name.&lt;/li&gt; &#xA; &lt;li&gt;Close the &lt;a href=&#34;https://github.com/rigetti/qvm/milestones&#34;&gt;milestone&lt;/a&gt; associated with this release, and migrate incomplete issues to the next one.&lt;/li&gt; &#xA; &lt;li&gt;Update the qvm version of downstream dependencies (if applicable, see next section).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Downstream Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;Currently, there are a couple different components of the Forest SDK that depend on the QVM:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rigetti/pyquil&#34;&gt;pyquil&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rigetti/forest-benchmarking&#34;&gt;forest-benchmarking&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;It is the responsibility of the releaser to verify that the latest QVM release does not break the test suites of these downstream dependencies. All of these repositories pull the latest released version of the QVM as part of their CI pipelines.&lt;/p&gt; &#xA;&lt;h1&gt;Feature Flags&lt;/h1&gt; &#xA;&lt;p&gt;The QVM library and application can be built with support for optional features specified by the &lt;code&gt;*features*&lt;/code&gt; flag in lisp.&lt;/p&gt; &#xA;&lt;h2&gt;Available Flags&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Feature Flag&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;qvm-intrinsics&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enable assembly intrinsics in the build, enabling optimized functions based on processor support. Currently supports AVX2 matrix multiplication.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Building QVM with Feature Flags&lt;/h2&gt; &#xA;&lt;p&gt;To build with specific flags enabled, set the &lt;code&gt;QVM_FEATURES&lt;/code&gt; variable while building:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make QVM_FEATURES=&#39;FEATURES&#39; qvm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: Cache needs to be cleaned when adding new feature flags to ensure libraries compile with correct flags.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>snmsts/github-install</title>
    <updated>2023-07-20T01:31:55Z</updated>
    <id>tag:github.com,2023-07-20:/snmsts/github-install</id>
    <link href="https://github.com/snmsts/github-install" rel="alternate"></link>
    <summary type="html">&lt;p&gt;not maintained. use ql-checkout&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;github-install&lt;/h1&gt; &#xA;&lt;p&gt;This is a simple utility function just download tarball from github and extract it if possible.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;see example below&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(github-install:github-install &#34;snmsts&#34; &#34;aoeu&#34; :branch &#34;master&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then you can find archive somewhere under &lt;code&gt;~/quicklisp/local-projects&lt;/code&gt; by default.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks to&lt;/h2&gt; &#xA;&lt;p&gt;This project idea comes from g000001. He introduced snippet at &lt;a href=&#34;http://g000001.cddddr.org/1277731696&#34;&gt;http://g000001.cddddr.org/1277731696&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>