<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-28T01:36:22Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ruricolist/serapeum</title>
    <updated>2023-06-28T01:36:22Z</updated>
    <id>tag:github.com,2023-06-28:/ruricolist/serapeum</id>
    <link href="https://github.com/ruricolist/serapeum" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Utilities beyond Alexandria&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#commentary&#34;&gt;Commentary&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#a-note-about-strings&#34;&gt;A note about strings&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#dividing-sequences&#34;&gt;Dividing sequences&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#binding-values-in-the-function-namespace&#34;&gt;Binding values in the function namespace&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#internal-definitions&#34;&gt;Internal definitions&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#example-macros-that-work-locally-and-globally&#34;&gt;Example: macros that work locally and globally&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#example-block-compiling&#34;&gt;Example: block compiling&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#compile-time-exhaustiveness-checking&#34;&gt;Compile-time exhaustiveness checking&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#example-enums&#34;&gt;Example: enums&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#example-union-types&#34;&gt;Example: union types&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#clos&#34;&gt;CLOS&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#method-combination-standard-with-context&#34;&gt;Method combination: standard with context&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#metaclass-topmost-object-class&#34;&gt;Metaclass: topmost-object-class&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#contributions&#34;&gt;Contributions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#hooks&#34;&gt;Hooks&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#function-reference&#34;&gt;Function reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ruricolist/serapeum/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/ruricolist/serapeum/actions/workflows/ci.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Serapeum is a conservative library of Common Lisp utilities. It is a supplement, not a competitor, to &lt;a href=&#34;http://common-lisp.net/project/alexandria/&#34;&gt;Alexandria&lt;/a&gt;. That means it is safe to do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defpackage ... (:use #:cl #:alexandria #:serapeum),&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;without package conflicts.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, now that package-local nicknames are generally available, the &lt;code&gt;serapeum/bundle&lt;/code&gt; package reexports the symbols of both (along with other utilities used by Serapeum itself):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defpackage ... (:local-nicknames (:util :serapeum/bundle)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There may already be too many utility libraries for Common Lisp. Releasing another has become something to apologize for, not celebrate. But I would rather make my apologies than have to maintain copy-pasted versions of the same utilities across a dozen systems. And, though Serapeum is justified even if only I ever use it, the best way to ensure its quality is to write it as if for general use.&lt;/p&gt; &#xA;&lt;p&gt;Serapeum is conservative: its goal is to fill in gaps in Common Lisp, not to redesign it. But it is less conservative than Alexandria. Alexandria limits itself to utilities with a Common Lisp pedigree. Serapeum casts a wider net: other dialects of Lisp, and other languages in the functional and array families, have been drafted.&lt;/p&gt; &#xA;&lt;p&gt;Alexandria is self-contained. It exists in splendid isolation, without depending on, or even acknowledging, other libraries. Serapeum tries to be a good citizen of the Quicklisp era: whenever possible, it avoids duplicating functionality that can be had elsewhere.&lt;/p&gt; &#xA;&lt;p&gt;Many of the utilities in Serapeum are original ideas; many ideas are borrowed from other languages, or from other Lispers. I try to give credit in the docstrings, but sometimes I have forgotten where I got an idea or a name. I regard missing credits as bugs: please report them.&lt;/p&gt; &#xA;&lt;p&gt;Serapeum is intended to be portable, but it is principally tested where it is developed, on &lt;a href=&#34;http://sbcl.org&#34;&gt;SBCL&lt;/a&gt; and &lt;a href=&#34;http://clozure.com&#34;&gt;Clozure CL&lt;/a&gt;. Patches and bug reports for other Lisps are always welcome, however, including implementation-specific optimizations.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;The preferred way to install Serapeum by using &lt;a href=&#34;https://www.quicklisp.org/beta/&#34;&gt;Quicklisp&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ql:quickload &#34;serapeum&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want the very latest version of Serapeum, you can check out the repository into your &lt;code&gt;~/quicklisp/local-projects&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h1&gt;Commentary&lt;/h1&gt; &#xA;&lt;p&gt;One goal of Serapeum is to have excellent documentation. A utility library is a fork of its language; it deserves documentation of the same quality as a language reference. If a utility is not worth documenting, it is not worth having.&lt;/p&gt; &#xA;&lt;p&gt;The full function reference will be found &lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/REFERENCE.md&#34;&gt;here&lt;/a&gt;. (It is in a separate file in deference to documentation browsers, which often print the README as a preamble to their own function reference).&lt;/p&gt; &#xA;&lt;p&gt;Most utilities in Serapeum stand alone, but there are some families that deserve separate introduction.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#dividing-sequences&#34;&gt;Dividing sequences&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#binding-values-in-the-function-namespace&#34;&gt;Binding values in the function namespace&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#internal-definitions&#34;&gt;Internal definitions&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#block-compiling&#34;&gt;block compilation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/#compile-time-exhaustiveness-checking&#34;&gt;Compile-time exhaustiveness checking&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;A note about strings&lt;/h2&gt; &#xA;&lt;p&gt;Beginning Lispers often ask about Lisp: “Where are the string utilities?” Since strings in Lisp are a kind of vector, which is in turn a kind of sequence, the right place to look is under the documentation for sequences (and vectors).&lt;/p&gt; &#xA;&lt;p&gt;This is also true for Serapeum: there are many &lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/REFERENCE.md#sequences&#34;&gt;sequence utilities&lt;/a&gt;, and a few &lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/REFERENCE.md#vectors&#34;&gt;vector utilities&lt;/a&gt;, that work equally well on strings. But there are also many &lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/REFERENCE.md#strings&#34;&gt;string-specific utilities&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Dividing sequences&lt;/h2&gt; &#xA;&lt;p&gt;All recent functional programming languages share a family of useful sequence-related functions with terrible names. All of them are called something like “split”, “divide”, or “group”, more or less at random.&lt;/p&gt; &#xA;&lt;p&gt;For each function, we ensure:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It is efficient.&lt;/li&gt; &#xA; &lt;li&gt;It returns like sequences for like (lists for lists, strings for strings, &amp;amp;c.).&lt;/li&gt; &#xA; &lt;li&gt;It accommodates generic sequences (&lt;code&gt;list&lt;/code&gt; and &lt;code&gt;vector&lt;/code&gt; are not necessarily an exhaustive partition of &lt;code&gt;sequence&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;It has a distinctive name which does not use any of the weasel words “split,” “divide,” or “group.”&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The function that returns &lt;em&gt;runs&lt;/em&gt; of like elements in a sequence is called &lt;code&gt;runs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(runs &#39;(head tail head head tail))&#xA;=&amp;gt; &#39;((head) (tail) (head head) (tail))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function that returns a sequence in &lt;em&gt;batches&lt;/em&gt; of a certain maximum size is called &lt;code&gt;batches&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(batches (iota 11) 2)&#xA;=&amp;gt; ((0 1) (2 3) (4 5) (6 7) (8 9) (10))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function which groups the like elements of a sequence is called &lt;code&gt;assort&lt;/code&gt; (because it returns a sequence &lt;em&gt;assorted by&lt;/em&gt; some property).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(assort (iota 10)&#xA;        :key (lambda (n) (mod n 3)))&#xA;=&amp;gt; &#39;((0 3 6 9) (1 4 7) (2 5 8))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function that takes a predicate and a sequence, and returns two sequences – one sequence of the elements for which the function returns true, and one sequence of the elements for which it returns false – is (still) called &lt;code&gt;partition&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(partition #&#39;oddp (iota 10))&#xA;=&amp;gt; (1 3 5 7 9), (0 2 4 6 8)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The generalized version of &lt;code&gt;partition&lt;/code&gt;, which takes a number of functions and returns the items that satisfy each condition, is called &lt;code&gt;partitions&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(partitions (list #&#39;primep #&#39;evenp) (iota 10))&#xA;=&amp;gt; ((2 3 5 7) (0 4 6 8)), (1 9)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Items that do not belong in any partition are returned as a second value.&lt;/p&gt; &#xA;&lt;p&gt;Serapeum simply re-exports &lt;code&gt;split-sequence&lt;/code&gt;, which seems to be firmly rooted under its present name.&lt;/p&gt; &#xA;&lt;h2&gt;Binding values in the function namespace&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;fbind&lt;/code&gt;, &lt;code&gt;fbind*&lt;/code&gt;, &lt;code&gt;fbindrec&lt;/code&gt;, and &lt;code&gt;fbindrec*&lt;/code&gt; bind values in the function namespace.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;fbind&lt;/code&gt; and &lt;code&gt;fbindrec&lt;/code&gt; are like &lt;code&gt;flet&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;, respectively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(fbind ((fn (lambda ....))) ...)&#xA;≡ (flet ((fn ...)) ...)&#xA;&#xA;(fbindrec ((fn (lambda ...))) ...)&#xA;≡ (labels ((fn ...)) ...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;fbind*&lt;/code&gt; and &lt;code&gt;fbindrec*&lt;/code&gt; have no exact parallels: they bind functions in sequence, so that each can be used in the construction (not just the definition, as with &lt;code&gt;fbindrec&lt;/code&gt;) of the next.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(fbind* ((flip2 (lambda (fn)&#xA;                 (lambda (x y)&#xA;                   (funcall fn y x))))&#xA;         (xcons (flip2 #&#39;cons)))&#xA;  (xcons 2 1))&#xA;=&amp;gt; (1 . 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These are non-trivial implementations. In many cases, &lt;code&gt;fbind&lt;/code&gt; can produce code that is more efficient than using &lt;code&gt;funcall&lt;/code&gt;, and even eliminate the overhead of higher-order functions like &lt;code&gt;compose&lt;/code&gt; and &lt;code&gt;curry&lt;/code&gt;. And &lt;code&gt;fbindrec&lt;/code&gt;, which builds on &lt;code&gt;fbind&lt;/code&gt;, further implements the optimizing transformation from Waddell et. al., &lt;em&gt;Fixing Letrec&lt;/em&gt;. (Note that the macroexpansion of &lt;code&gt;fbind&lt;/code&gt; may sometimes appear simplistic, using &lt;code&gt;macroexpand&lt;/code&gt;; this is the happy case when we can prove that the function is never used as a value.)&lt;/p&gt; &#xA;&lt;p&gt;For binding values in the function namespace at the top level, Serapeum provides &lt;code&gt;defalias&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defalias xcons (flip #&#39;cons))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is equivalent to &lt;code&gt;(setf (fdefinition ...))&lt;/code&gt;, but also gives the function a compile-time definition so compilers don’t complain about its being undefined.&lt;/p&gt; &#xA;&lt;h2&gt;Internal definitions&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;local&lt;/code&gt; form lets you use top-level definition forms to create local bindings. You can use &lt;code&gt;defun&lt;/code&gt; instead of &lt;code&gt;labels&lt;/code&gt;, &lt;code&gt;defmacro&lt;/code&gt; instead of &lt;code&gt;macrolet&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt; (which is Serapeum’s macro for top-level lexical bindings) instead of &lt;code&gt;let&lt;/code&gt;, and so forth.&lt;/p&gt; &#xA;&lt;p&gt;This has three advantages:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Given a set of variable, function, and macro bindings, you can leave it to the compiler to figure out how to nest them. (This could be because you are porting a function from a language that uses flat bindings, or just because you are writing a very complicated function.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can use macro-defining macros (macros that expand into &lt;code&gt;defmacro&lt;/code&gt;), as well as macros that expand into &lt;code&gt;defun&lt;/code&gt; forms, to create local bindings.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can (using &lt;code&gt;local*&lt;/code&gt; or &lt;code&gt;block-compile&lt;/code&gt;) easily switch to block compilation of top-level functions.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Serapeum’s implementation of internal definitions is as complete as it can be while remaining portable. That means full support for variables, functions, and symbol macros, but restricted support for macros.&lt;/p&gt; &#xA;&lt;h3&gt;Example: macros that work locally and globally&lt;/h3&gt; &#xA;&lt;p&gt;For example, memoizing local functions is usually clumsy; given &lt;code&gt;local&lt;/code&gt; you can define a single &lt;code&gt;defmemo&lt;/code&gt; form that supports both &lt;code&gt;defun&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defmacro defmemo (name params &amp;amp;body body)&#xA;  (with-gensyms (memo-table args result result?)&#xA;    `(let ((,memo-table (make-hash-table :test &#39;equal)))&#xA;       (defun ,name (&amp;amp;rest ,args)&#xA;         (multiple-value-bind (,result ,result?)&#xA;             (gethash ,args ,memo-table)&#xA;           (if ,result?&#xA;               ,result&#xA;               (setf (gethash ,args ,memo-table)&#xA;                     (apply (lambda ,params&#xA;                              ,@body)&#xA;                              ,args))))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At the top level, this expands into an example of “let over defun” (gensyms elided for readability):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;;; This source form&#xA;(defmemo fibonacci (n)&#xA;    (if (&amp;lt;= n 1)&#xA;        1&#xA;        (+ (fibonacci (- n 1))&#xA;           (fibonacci (- n 2)))))&#xA;           &#xA;;; Expands into...&#xA;(let ((memo-table (make-hash-table :test &#39;equal)))&#xA;  (defun fibonacci (&amp;amp;rest args)&#xA;    (multiple-value-bind (result result?)&#xA;        (gethash args memo-table)&#xA;      (if result? result&#xA;          (setf (gethash args memo-table)&#xA;                (apply (lambda (n)&#xA;                         (if (&amp;lt;= n 1)&#xA;                             1&#xA;                             (+ (fibonacci (- n 1))&#xA;                                (fibonacci (- n 2)))))&#xA;                       args))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But within a &lt;code&gt;local&lt;/code&gt; form, it expands differently. This nearly identical source form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(local&#xA;  (defmemo fibonacci (n)&#xA;    (if (&amp;lt;= n 1)&#xA;        1&#xA;        (+ (fibonacci (- n 1))&#xA;           (fibonacci (- n 2)))))&#xA;&#xA;  (fibonacci 100))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Expands into this very different code (simplified for readability):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(let (fn)&#xA;  (labels ((fibonacci (&amp;amp;rest args)&#xA;             (apply fn args)))&#xA;    (let ((memo-table (make-hash-table :test &#39;equal)))&#xA;      (setf fn&#xA;            (named-lambda fibonacci (&amp;amp;rest args)&#xA;              (multiple-value-bind (result result?)&#xA;                  (gethash args memo-table)&#xA;                (if result? result&#xA;                    (setf (gethash args memo-table)&#xA;                          (apply&#xA;                           (lambda (n)&#xA;                             (if (&amp;lt;= n 1) 1&#xA;                                 (+ (fibonacci (- n 1))&#xA;                                    (fibonacci (- n 2)))))&#xA;                           args))))))&#xA;      &#xA;      (fibonacci 100))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example: block compiling&lt;/h3&gt; &#xA;&lt;p&gt;The macro &lt;code&gt;local*&lt;/code&gt; is almost the same as &lt;code&gt;local&lt;/code&gt;, except that it leaves the last form in the body intact. This is useful for obtaining block compilation in Lisps that don’t have a syntax for it.&lt;/p&gt; &#xA;&lt;p&gt;During development, you define functions at the top level inside a &lt;code&gt;progn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (progn&#xA;   (defun aux-fn-1 ...)&#xA;   (defun aux-fn-2 ...)&#xA;   (defun entry-point ...))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, when you decide you want block compilation, simply switch the &lt;code&gt;progn&lt;/code&gt; to a &lt;code&gt;local*&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; (local*&#xA;   (defun aux-fn-1 ...)&#xA;   (defun aux-fn-2 ...)&#xA;   (defun entry-point ...))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which expands into something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(labels ((aux-fn-2 ...)&#xA;         (aux-fn-1 ...))&#xA;  (defun entry-point ...))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This has the slight disadvantage that calls to the entry points, including self calls, will still be compiled as global calls. If you want calls to the entry points to be compiled as local calls, you can use the &lt;code&gt;block-compile&lt;/code&gt; macro instead.&lt;/p&gt; &#xA;&lt;p&gt;Using &lt;code&gt;block-compile&lt;/code&gt;, you can write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(block-compile (:entry-points (entry-point))&#xA;  (defun aux-fn-1 ...)&#xA;  (defun aux-fn-2 ...)&#xA;  (defun entry-point ...))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And have it expand into something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(labels ((aux-fn-2 ...)&#xA;     (aux-fn-1 ...)&#xA;     (entry-point ...))&#xA;  (defalias entry-point #&#39;entry-point))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compile-time exhaustiveness checking&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;etypecase-of&lt;/code&gt; is just like &lt;code&gt;etypecase&lt;/code&gt;, except that it takes an additional argument – the type to be matched against – and warns, at compile time, if the clauses in its body are not an exhaustive partition of that type.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ecase-of&lt;/code&gt; is a succint variant of &lt;code&gt;etypecase&lt;/code&gt; with the same syntax as &lt;code&gt;ecase&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;typecase-of&lt;/code&gt; and &lt;code&gt;case-of&lt;/code&gt; are &lt;code&gt;etypecase-of&lt;/code&gt; and &lt;code&gt;ecase-of&lt;/code&gt;, respectively, except that they expect, and enforce, the presence of an &lt;code&gt;otherwise&lt;/code&gt; clause.&lt;/p&gt; &#xA;&lt;p&gt;There are also continuable versions of these macros – &lt;code&gt;ctypecase-of&lt;/code&gt; and &lt;code&gt;ccase-of&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Example: enums&lt;/h3&gt; &#xA;&lt;p&gt;We may call a type defined using &lt;code&gt;member&lt;/code&gt; an &lt;em&gt;enumeration&lt;/em&gt;. Take an enumeration like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(deftype switch-state ()&#xA;  &#39;(member :on :off :stuck :broken))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can use &lt;code&gt;ecase-of&lt;/code&gt; to take all the states of the switch into account.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defun flick (switch)&#xA;  (ecase-of switch-state (state switch)&#xA;    (:on (switch-off switch))&#xA;    (:off (switch-on switch))))&#xA;=&amp;gt; Warning&#xA;&#xA;(defun flick (switch)&#xA;  (ecase-of switch-state (state switch)&#xA;    (:on (switch-off switch))&#xA;    (:off (switch-on switch))&#xA;    ((:stuck :broken) (error &#34;Sorry, can&#39;t flick ~a&#34; switch))))&#xA;=&amp;gt; No warning&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Even more usefully, we don’t have to worry about bugs caused by misspellings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun flick (switch)&#xA;  (ecase-of switch-state (state switch)&#xA;    (:on (switch-off switch))&#xA;    (:offf (switch-on switch))          ;Gotcha!&#xA;    ((:stuck :broken) (error &#34;Sorry, can&#39;t flick ~a&#34; switch))))&#xA;=&amp;gt; Warning&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example: union types&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defun negative-integer? (n)&#xA;  (etypecase-of t n&#xA;    ((not integer) nil)&#xA;    ((integer * -1) t)&#xA;    ((integer 1 *) nil)))&#xA;=&amp;gt; Warning&#xA;&#xA;(defun negative-integer? (n)&#xA;  (etypecase-of t n&#xA;    ((not integer) nil)&#xA;    ((integer * -1) t)&#xA;    ((integer 1 *) nil)&#xA;    ((integer 0) nil)))&#xA;=&amp;gt; No warning&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;CLOS&lt;/h2&gt; &#xA;&lt;p&gt;Serapeum includes some utilities for CLOS. These utilities do nothing earthshaking, but since the function reference does not include them, they should be documented somewhere.&lt;/p&gt; &#xA;&lt;h3&gt;Method combination: standard with context&lt;/h3&gt; &#xA;&lt;p&gt;Serapeum exports a method combination, &lt;code&gt;serapeum:standard/context&lt;/code&gt;. You may recognize it as the &lt;code&gt;wrapping-standard&lt;/code&gt; method combination due to &lt;a href=&#34;https://github.com/tfeb&#34;&gt;Tim Bradshaw&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Generic functions defined with &lt;code&gt;standard/context&lt;/code&gt; behave the same as ordinary generic functions, except that they allow an extra qualifier, &lt;code&gt;:context&lt;/code&gt;. This extra qualifier works almost like &lt;code&gt;:around&lt;/code&gt;, except instead of being run in most-specific-first order, like methods defined with &lt;code&gt;:around&lt;/code&gt;, methods defined with &lt;code&gt;:context&lt;/code&gt; are run in most-specific-last order. Furthermore, &lt;code&gt;:context&lt;/code&gt; methods take priority over any other methods, including &lt;code&gt;:around&lt;/code&gt; methods.&lt;/p&gt; &#xA;&lt;p&gt;The big idea is that a class can use &lt;code&gt;:context&lt;/code&gt; methods to make sure that any methods defined by subclasses – even &lt;code&gt;:around&lt;/code&gt; methods – run in a certain dynamic context.&lt;/p&gt; &#xA;&lt;h3&gt;Metaclass: topmost-object-class&lt;/h3&gt; &#xA;&lt;p&gt;In most cases, when I write a metaclass, I want all of the classes defined using that metaclass to inherit from a specific class. Injecting a topmost class is not difficult to do, but it involves a certain amount of boilerplate.&lt;/p&gt; &#xA;&lt;p&gt;To eliminate that boilerplate, Serapeum exports a metaclass, &lt;code&gt;topmost-object-class&lt;/code&gt;, to use as a base class for your metaclasses. When you define a metaclass, all you have to do to ensure that classes defined using your metaclass inherit from a specific class is to supply the name of the class to inherit from in the definition of the metaclass. This is much better demonstrated than explained:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;;; The class to inherit from.&#xA;(defclass my-topmost-object ()&#xA;  ())&#xA;&#xA;;;; The metaclass.&#xA;(defclass my-metaclass (serapeum:topmost-object-class)&#xA;  ()&#xA;  (:default-initargs&#xA;   :topmost-class &#39;my-topmost-object))&#xA;&#xA;(defclass my-class ()&#xA;  ()&#xA;  (:metaclass my-metaclass))&#xA;&#xA;(typep (make-instance &#39;my-class) &#39;my-topmost-object) =&amp;gt; t&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that, since the topmost object is usually a standard class, there is a &lt;code&gt;validate-superclass&lt;/code&gt; method which allows an instance of &lt;code&gt;topmost-object-class&lt;/code&gt; to inherit from a standard class.&lt;/p&gt; &#xA;&lt;h1&gt;Contributions&lt;/h1&gt; &#xA;&lt;p&gt;The contrib/ directory holds large contributions to Serapeum (ones that add a lot of new exports).&lt;/p&gt; &#xA;&lt;h2&gt;Hooks&lt;/h2&gt; &#xA;&lt;p&gt;The package &lt;code&gt;:serapeum/contrib/hooks&lt;/code&gt; holds an enhanced implementation of hooks (extension points) contributed by the maintainers of the &lt;a href=&#34;https://nyxt.atlas.engineer/&#34;&gt;Nyxt&lt;/a&gt; web browser. This is fully compatible with the existing Serapeum functions for hooks (&lt;code&gt;add-hook&lt;/code&gt;, &lt;code&gt;run-hook&lt;/code&gt;, etc.).&lt;/p&gt; &#xA;&lt;p&gt;NB This hook implementation is deprecated; consider &lt;a href=&#34;https://github.com/atlas-engineer/nhooks&#34;&gt;nhooks&lt;/a&gt; instead.&lt;/p&gt; &#xA;&lt;h1&gt;Function reference&lt;/h1&gt; &#xA;&lt;p&gt;The complete reference is in a &lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/serapeum/master/REFERENCE.md&#34;&gt;separate file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;(Note that the reference is generated from docstrings, and should not be edited by hand.)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>sharplispers/ironclad</title>
    <updated>2023-06-28T01:36:22Z</updated>
    <id>tag:github.com,2023-06-28:/sharplispers/ironclad</id>
    <link href="https://github.com/sharplispers/ironclad" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A cryptographic toolkit written in Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Ironclad #+AUTHOR: The Ironclad developers #+DATE: #+EMAIL: #+LANGUAGE: en #+OPTIONS: num:nil toc:nil html-style:nil html-postamble:nil html-scripts:nil #+HTML_DOCTYPE: html5 #+HTML_HEAD: &amp;lt;style type=&#34;text/css&#34;&amp;gt; #+HTML_HEAD: body { margin: 1em 5% 1em 5%; } #+HTML_HEAD: p { margin-top: 0.5em; margin-bottom: 0.5em; } #+HTML_HEAD: pre { padding: 0; margin: 0; } #+HTML_HEAD: h1, h2 { border-bottom: 2px solid #449977; } #+HTML_HEAD: h1, h2, h3, h4, h5, h6 { font-family: sans-serif; line-height: 1.3; } #+HTML_HEAD: a:link { color: #449977; } #+HTML_HEAD: a:visited { color: purple; } #+HTML_HEAD: a { text-decoration: none; padding: 1px 2px; } #+HTML_HEAD: a:hover { text-decoration: none; padding: 1px; border: 1px solid #000000; } #+HTML_HEAD: pre.src-lisp { margin-right: 10%; margin-top: 1.5em; margin-bottom: 1.5em; border: 1px solid #449977; background: #eeeeee; padding: 1em; } #+HTML_HEAD: pre.example { margin-right: 10%; margin-top: 1.5em; margin-bottom: 1.5em; border: 1px solid black; padding: 1em; } #+HTML_HEAD: .underline { margin-top: 1.5em; margin-bottom: 1.5em; font-family: sans-serif; font-size: 1.1em; font-weight: bold; text-decoration: underline; } #+HTML_HEAD: &amp;lt;/style&amp;gt;&lt;/p&gt; &#xA;&lt;p&gt;#+ATTR_HTML: :style width: 0; height: 0; padding: 0; margin: 0; border: 0; overflow: hidden; [[https://github.com/sharplispers/ironclad/workflows/CI/badge.svg?branch=master][file:https://github.com/sharplispers/ironclad/workflows/CI/badge.svg?branch=master]]&lt;/p&gt; &#xA;&lt;p&gt;Ironclad is a cryptography library written entirely in Common Lisp. It includes support for several popular [[#ciphers][ciphers]], [[#digests][digests]], [[#message-authentication-codes][MACs]] and [[#public-key-cryptography][public key cryptography]] algorithms. For several implementations that support Gray streams, support is included for convenient [[#gray-streams][stream wrappers]].&lt;/p&gt; &#xA;&lt;p&gt;Most of the algorithms were written with efficiency for specific Common Lisp implementations in mind, although portable code is provided as an alternative in nearly all instances. The framework should be flexible enough to accommodate implementation-specific optimizations when possible.&lt;/p&gt; &#xA;&lt;p&gt;Test vectors for many of the algorithms are included to provide a level of confidence in the correctness of the implementations.&lt;/p&gt; &#xA;&lt;p&gt;#+TOC: headlines 1&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Warnings :PROPERTIES: :CUSTOM_ID: warning :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Ironclad should not be considered safe against side channel attacks.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Some algorithms can be safe against side channel attacks on some architectures using some Common Lisp implementations, but in the general case it can&#39;t be guaranteed. This is due to the fact that integers and arithmetic functions of Common Lisp implementations are usually not safe against side channel attacks.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Ironclad&#39;s digest, MAC and cipher objects should not be considered thread safe.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Creating a digest, a MAC or a cipher object and using it in several threads at the same time can lead to an undefined result. If you need to do that, you must put locks in your application where necessary.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Ironclad&#39;s pseudo random number generation should only be considered thread safe with bordeaux-threads.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you have a multi-threaded application in which you want to use functions requiring some random numbers (key derivation, key generation, public key encryption, signature, etc.) in several threads, each of these threads must have its own PRNG, or they might generate the same &#34;random&#34; numbers. If the threads are created using the &lt;em&gt;bordeaux-threads&lt;/em&gt; library (or by a library using &lt;em&gt;bordeaux-threads&lt;/em&gt;, like &lt;em&gt;lparallel&lt;/em&gt;), this is done automatically. However, if you are using the threading functions of your Common Lisp implementation directly, you have to bind the &lt;del&gt;&lt;em&gt;prng&lt;/em&gt;&lt;/del&gt; special variable to a new PRNG in each thread. There is an example showing how it can be done in the section about [[make-prng][make-prng]].&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Installation :PROPERTIES: :CUSTOM_ID: installation :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The current version of Ironclad is 0.58. It can be downloaded at [[https://github.com/sharplispers/ironclad/archive/v0.58.tar.gz]]. If you are feeling adventurous, you can download a bleeding-edge version at [[https://github.com/sharplispers/ironclad]].&lt;/p&gt; &#xA;&lt;p&gt;It comes with an ASDF system definition, so &lt;del&gt;(asdf:load-system &#34;ironclad&#34;)&lt;/del&gt; should be all that you need to get started. The testsuite can be run by substituting &lt;del&gt;asdf:test-system&lt;/del&gt; for &lt;del&gt;asdf:load-system&lt;/del&gt; in the form above.&lt;/p&gt; &#xA;&lt;p&gt;If you are using [[https://www.quicklisp.org][Quicklisp]] to manage your libraries, just use &lt;del&gt;(ql:quickload &#34;ironclad&#34;)&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When Ironclad is loaded, its functions are in the &lt;del&gt;ironclad&lt;/del&gt; package (e.g. &lt;del&gt;(ironclad:make-cipher ...)&lt;/del&gt;). If you prefer, you can also use the &lt;del&gt;crypto&lt;/del&gt; nickname (e.g. &lt;del&gt;(crypto:make-cipher ...)&lt;/del&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Ironclad has been tested in the following implementations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SBCL x86/linux, x86-64/linux (primary development platforms)&lt;/li&gt; &#xA; &lt;li&gt;SBCL x86-64/solaris, x86/darwin&lt;/li&gt; &#xA; &lt;li&gt;CMUCL x86/linux&lt;/li&gt; &#xA; &lt;li&gt;ABCL with Sun&#39;s 1.5.0 JVM&lt;/li&gt; &#xA; &lt;li&gt;Lispworks 5.0.1 x86/linux&lt;/li&gt; &#xA; &lt;li&gt;Lispworks 5.1.2 x86-64/darwin x86/windows&lt;/li&gt; &#xA; &lt;li&gt;Allegro 8.0 x86/linux&lt;/li&gt; &#xA; &lt;li&gt;Allegro 8.1 x86/linux, x86-64/linux, sparc/solaris&lt;/li&gt; &#xA; &lt;li&gt;CLISP 2.41 x86/linux, x86/cygwin&lt;/li&gt; &#xA; &lt;li&gt;Clozure Common Lisp 1.11 x86-64/Linux&lt;/li&gt; &#xA; &lt;li&gt;Clozure Common Lisp 1.10 x86-64/darwin&lt;/li&gt; &#xA; &lt;li&gt;ECL 16.1.3 x86-64/linux&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All included tests should pass successfully. If you use a platform not listed above, please send your platform information so that it can be added to the above list. If the tests do not all pass, you have found a bug; please report it.&lt;/p&gt; &#xA;&lt;p&gt;By default, Ironclad uses some implementation dependent low-level code to make some functions run much faster (currently, some assembly for SBCL and CCL, some C code for ECL). If for some reason you want to disable these optimisations and use the generic Lisp code, it can be achieved by commenting out the &lt;del&gt;(pushnew :ironclad-assembly &lt;em&gt;features&lt;/em&gt;)&lt;/del&gt; line in the /src/package.lisp/ file.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;License :PROPERTIES: :CUSTOM_ID: license :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Ironclad is released under a MIT-like license; you can do pretty much anything you want to with the code except claim that you wrote it.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ciphers :PROPERTIES: :CUSTOM_ID: ciphers :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+NAME: make-cipher #+BEGIN_SRC lisp (make-cipher name &amp;amp;key key mode initialization-vector padding tweak) =&amp;gt; cipher #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return a cipher object suitable for use for both encryption and decryption.&lt;/p&gt; &#xA;&lt;p&gt;/name/ denotes the encryption algorithm to use. [[list-all-ciphers][list-all-ciphers]] will tell you the names of all supported ciphers. They are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;3des&lt;/li&gt; &#xA; &lt;li&gt;aes&lt;/li&gt; &#xA; &lt;li&gt;arcfour (rc4)&lt;/li&gt; &#xA; &lt;li&gt;aria&lt;/li&gt; &#xA; &lt;li&gt;blowfish&lt;/li&gt; &#xA; &lt;li&gt;camellia&lt;/li&gt; &#xA; &lt;li&gt;cast5&lt;/li&gt; &#xA; &lt;li&gt;chacha&lt;/li&gt; &#xA; &lt;li&gt;chacha/12&lt;/li&gt; &#xA; &lt;li&gt;chacha/8&lt;/li&gt; &#xA; &lt;li&gt;des&lt;/li&gt; &#xA; &lt;li&gt;idea&lt;/li&gt; &#xA; &lt;li&gt;kalyna128&lt;/li&gt; &#xA; &lt;li&gt;kalyna256&lt;/li&gt; &#xA; &lt;li&gt;kalyna512&lt;/li&gt; &#xA; &lt;li&gt;kuznyechik&lt;/li&gt; &#xA; &lt;li&gt;misty1&lt;/li&gt; &#xA; &lt;li&gt;rc2&lt;/li&gt; &#xA; &lt;li&gt;rc5&lt;/li&gt; &#xA; &lt;li&gt;rc6&lt;/li&gt; &#xA; &lt;li&gt;salsa20&lt;/li&gt; &#xA; &lt;li&gt;salsa20/12&lt;/li&gt; &#xA; &lt;li&gt;salsa20/8&lt;/li&gt; &#xA; &lt;li&gt;seed&lt;/li&gt; &#xA; &lt;li&gt;serpent&lt;/li&gt; &#xA; &lt;li&gt;sm4&lt;/li&gt; &#xA; &lt;li&gt;sosemanuk&lt;/li&gt; &#xA; &lt;li&gt;square&lt;/li&gt; &#xA; &lt;li&gt;tea&lt;/li&gt; &#xA; &lt;li&gt;threefish1024&lt;/li&gt; &#xA; &lt;li&gt;threefish256&lt;/li&gt; &#xA; &lt;li&gt;threefish512&lt;/li&gt; &#xA; &lt;li&gt;twofish&lt;/li&gt; &#xA; &lt;li&gt;xchacha&lt;/li&gt; &#xA; &lt;li&gt;xchacha/12&lt;/li&gt; &#xA; &lt;li&gt;xchacha/8&lt;/li&gt; &#xA; &lt;li&gt;xor (not a real cipher, use only for testing)&lt;/li&gt; &#xA; &lt;li&gt;xsalsa20&lt;/li&gt; &#xA; &lt;li&gt;xsalsa20/12&lt;/li&gt; &#xA; &lt;li&gt;xsalsa20/8&lt;/li&gt; &#xA; &lt;li&gt;xtea&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;/name/ can be a symbol in the &lt;del&gt;keyword&lt;/del&gt; package or in the &lt;del&gt;ironclad&lt;/del&gt; package; &lt;del&gt;:aes&lt;/del&gt; for AES, &lt;del&gt;ironclad:arcfour&lt;/del&gt; for RC4, and so forth.&lt;/p&gt; &#xA;&lt;p&gt;/mode/ describes the mode of operation for the cipher. Stream ciphers such as Arcfour can operate in only one mode, &lt;del&gt;stream&lt;/del&gt;. Block ciphers such as AES and DES can operate in several different modes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ecb&lt;/li&gt; &#xA; &lt;li&gt;cbc&lt;/li&gt; &#xA; &lt;li&gt;ofb&lt;/li&gt; &#xA; &lt;li&gt;cfb (note that Ironclad&#39;s CFB mode is /n/-bit CFB, where /n/ is the [[block-length][block-length]] of the cipher)&lt;/li&gt; &#xA; &lt;li&gt;cfb8 (this seems to be the mode other crypto packages call CFB)&lt;/li&gt; &#xA; &lt;li&gt;ctr&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;/mode/ should be a symbol in the &lt;del&gt;keyword&lt;/del&gt; or &lt;del&gt;ironclad&lt;/del&gt; packages; &lt;del&gt;:stream&lt;/del&gt;, &lt;del&gt;ironclad:ofb&lt;/del&gt;, and so forth. An error will be signaled if /mode/ is not appropriate for the cipher /name/.&lt;/p&gt; &#xA;&lt;p&gt;/initialization-vector/ (IV) should be supplied only if /mode/ requires one. /initialization-vector/ should be a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;. The supplied IV should be the same length as the [[block-length][block-length]] of /name/. The Chacha and Salsa20 stream ciphers also use an initialization vector (nonce). It should be 8 or 12 bytes long for Chacha, 8 bytes long for Salsa20, and 24 bytes long for XChacha and XSalsa20.&lt;/p&gt; &#xA;&lt;p&gt;/key/ is, of course, the key for the cipher. /key/ should be a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If /padding/ is supplied, the specified padding method will be used by [[encrypt][encrypt]] and [[decrypt][decrypt]] to handle short blocks when the &lt;del&gt;:handle-final-block&lt;/del&gt; argument is supplied. /padding/ will only be used if the mode is ECB or CBC. The possible values for /padding/ are &lt;del&gt;:pkcs7&lt;/del&gt;, &lt;del&gt;:ansi-x923&lt;/del&gt; and &lt;del&gt;:iso-7816-4&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If the cipher can use a tweak (e.g. threefish), it can be specified with the /tweak/ key parameter.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: encrypt #+BEGIN_SRC lisp (encrypt cipher plaintext ciphertext &amp;amp;key plaintext-start plaintext-end ciphertext-start handle-final-block) =&amp;gt; n-bytes-consumed, n-bytes-produced #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Encrypts data according to /cipher/ from /plaintext/ starting at /plaintext-start/ and continuing until /plaintext-end/. The encrypted data is placed in /ciphertext/ starting at /ciphertext-start/.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: decrypt #+BEGIN_SRC lisp (decrypt cipher ciphertext plaintext &amp;amp;key ciphertext-start ciphertext-end plaintext-start handle-final-block) =&amp;gt; n-bytes-consumed, n-bytes-produced #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Decrypts data according to /cipher/ from /ciphertext/ starting at /ciphertext-start/ and continuing until /ciphertext-end/. The decrypted data is placed in /plaintext/ starting at /plaintext-start/.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: encrypt-in-place #+BEGIN_SRC lisp (encrypt-in-place cipher text &amp;amp;key start end) =&amp;gt; n-bytes-consumed, n-bytes-produced #+END_SRC #+NAME: decrypt-in-place #+BEGIN_SRC lisp (decrypt-in-place cipher text &amp;amp;key start end) =&amp;gt; n-bytes-consumed, n-bytes-produced #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Encrypts or decrypts data in /text/ between /start/ and /end/ &#34;in-place&#34; according to /cipher/. These functions are shorthand for: #+BEGIN_EXAMPLE (encrypt cipher text text :plaintext-start start :plaintext-end end :ciphertext-start start) (decrypt cipher text text :ciphertext-start start :ciphertext-end end :plaintext-start start) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; [[encrypt-in-place][encrypt-in-place]] and [[decrypt-in-place][decrypt-in-place]] do not support a /handle-final-block/ parameter as [[encrypt][encrypt]] and [[decrypt][decrypt]] do. If you need the functionality that /handle-final-block/ provides, then you need to use [[encrypt][encrypt]] and [[decrypt][decrypt]].&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; /n-bytes-consumed/ and /n-bytes-produced/ may not always be equal to the length of the data specified in the call to [[encrypt-in-place][encrypt-in-place]] or [[decrypt-in-place][decrypt-in-place]]. This subtlely is also present in [[encrypt][encrypt]] or [[decrypt][decrypt]].&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (encrypt-message cipher message &amp;amp;key start end &amp;amp;allow-other-keys) =&amp;gt; encrypted-message #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the /message/ between /start/ and /end/ encrypted with the /cipher/; the class of /cipher/ determines the algorithm used to encrypt the message.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (decrypt-message cipher message &amp;amp;key start end &amp;amp;allow-other-keys) =&amp;gt; decrypted-message #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the /message/ between /start/ and /end/ decrypted by the /cipher/; the class of /cipher/ determines the algorithm used to decrypt the message.&lt;/p&gt; &#xA;&lt;p&gt;** Inquiry functions&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: list-all-ciphers #+BEGIN_SRC lisp (list-all-ciphers) =&amp;gt; list #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns a list of cipher-names that may be validly passed to [[make-cipher][make-cipher]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: cipher-supported-p #+BEGIN_SRC lisp (cipher-supported-p name) =&amp;gt; boolean #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns &lt;del&gt;t&lt;/del&gt; if /name/ would be in the list returned by [[list-all-ciphers][list-all-ciphers]], &lt;del&gt;nil&lt;/del&gt; otherwise.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: key-lengths #+BEGIN_SRC lisp (key-lengths cipher) =&amp;gt; list #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return a list of valid key lengths for /cipher/.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: block-length #+BEGIN_SRC lisp (block-length cipher) =&amp;gt; number #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the number of octets /cipher/ processes at a time. This function always returns 1 for stream ciphers.&lt;/p&gt; &#xA;&lt;p&gt;** Key stream position&lt;/p&gt; &#xA;&lt;p&gt;Block ciphers in CTR mode and some stream ciphers have the ability to change the current position within the key stream in constant time instead of having to consume all the bytes until the desired position is reached.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: keystream-position #+BEGIN_SRC lisp (keystream-position cipher &amp;amp;optional position) =&amp;gt; number or boolean #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return or change the current /position/ within the key stream of a /cipher/. When /position/ is not supplied, [[keystream-position][keystream-position]] returns the current position in the key stream, or /nil/ if it can&#39;t be determined. When /position/ is supplied, the key stream position of the /cipher/ is set to that /position/ if possible. [[keystream-position][keystream-position]] returns /t/ if the repositioning is performed successfully, or /nil/ otherwise.&lt;/p&gt; &#xA;&lt;p&gt;[[keystream-position][keystream-position]] can be used with the following ciphers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;all the block ciphers (aes, twofish, etc.) in CTR mode&lt;/li&gt; &#xA; &lt;li&gt;chacha&lt;/li&gt; &#xA; &lt;li&gt;chacha/12&lt;/li&gt; &#xA; &lt;li&gt;chacha/8&lt;/li&gt; &#xA; &lt;li&gt;salsa20&lt;/li&gt; &#xA; &lt;li&gt;salsa20/12&lt;/li&gt; &#xA; &lt;li&gt;salsa20/8&lt;/li&gt; &#xA; &lt;li&gt;xchacha&lt;/li&gt; &#xA; &lt;li&gt;xchacha/12&lt;/li&gt; &#xA; &lt;li&gt;xchacha/8&lt;/li&gt; &#xA; &lt;li&gt;xsalsa20&lt;/li&gt; &#xA; &lt;li&gt;xsalsa20/12&lt;/li&gt; &#xA; &lt;li&gt;xsalsa20/8&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Digests :PROPERTIES: :CUSTOM_ID: digests :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Digest functions, also known as hash functions, produce fixed-length output (a /digest/ or /hash/) from a variable-length message. The simplest example of a digest function is one that adds up all the bytes in the message modulo 256. This digest function fails one test of a cryptographically secure hash function: it must be difficult to find a message with a given digest. It also fails the other test: it must be difficult to find two messages with the same digest.&lt;/p&gt; &#xA;&lt;p&gt;Ironclad provides several cryptographically secure digest functions and several non-cryptographically secure digest functions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; In the functions below, messages or parts thereof are provided as octet vectors; Ironclad has no facilities for producing digests of strings. If you need to obtain the digest of a string, then you need to figure out how to convert it to an octet vector first. This is a deliberate design decision. Characters are not equivalent to bytes. See your local Unicode guru for more details.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-digest #+BEGIN_SRC lisp (make-digest digest-name &amp;amp;rest keys &amp;amp;key &amp;amp;allow-other-keys) =&amp;gt; digester #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns a digest object. /digest-name/ is a keyword naming the algorithm you wish /digester/ to use. The supported digest names can be found by calling [[list-all-digests][list-all-digests]]. They are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;adler32&lt;/li&gt; &#xA; &lt;li&gt;blake2&lt;/li&gt; &#xA; &lt;li&gt;blake2/160&lt;/li&gt; &#xA; &lt;li&gt;blake2/256&lt;/li&gt; &#xA; &lt;li&gt;blake2/384&lt;/li&gt; &#xA; &lt;li&gt;blake2s&lt;/li&gt; &#xA; &lt;li&gt;blake2s/128&lt;/li&gt; &#xA; &lt;li&gt;blake2s/160&lt;/li&gt; &#xA; &lt;li&gt;blake2s/224&lt;/li&gt; &#xA; &lt;li&gt;crc24&lt;/li&gt; &#xA; &lt;li&gt;crc32&lt;/li&gt; &#xA; &lt;li&gt;groestl&lt;/li&gt; &#xA; &lt;li&gt;groestl/224&lt;/li&gt; &#xA; &lt;li&gt;groestl/256&lt;/li&gt; &#xA; &lt;li&gt;groestl/384&lt;/li&gt; &#xA; &lt;li&gt;jh&lt;/li&gt; &#xA; &lt;li&gt;jh/224&lt;/li&gt; &#xA; &lt;li&gt;jh/256&lt;/li&gt; &#xA; &lt;li&gt;jh/384&lt;/li&gt; &#xA; &lt;li&gt;keccak&lt;/li&gt; &#xA; &lt;li&gt;keccak/224&lt;/li&gt; &#xA; &lt;li&gt;keccak/256&lt;/li&gt; &#xA; &lt;li&gt;keccak/384&lt;/li&gt; &#xA; &lt;li&gt;kupyna&lt;/li&gt; &#xA; &lt;li&gt;kupyna/256&lt;/li&gt; &#xA; &lt;li&gt;md2&lt;/li&gt; &#xA; &lt;li&gt;md4&lt;/li&gt; &#xA; &lt;li&gt;md5&lt;/li&gt; &#xA; &lt;li&gt;ripemd-128&lt;/li&gt; &#xA; &lt;li&gt;ripemd-160&lt;/li&gt; &#xA; &lt;li&gt;sha1&lt;/li&gt; &#xA; &lt;li&gt;sha224&lt;/li&gt; &#xA; &lt;li&gt;sha256&lt;/li&gt; &#xA; &lt;li&gt;sha3&lt;/li&gt; &#xA; &lt;li&gt;sha3/224&lt;/li&gt; &#xA; &lt;li&gt;sha3/256&lt;/li&gt; &#xA; &lt;li&gt;sha3/384&lt;/li&gt; &#xA; &lt;li&gt;sha384&lt;/li&gt; &#xA; &lt;li&gt;sha512&lt;/li&gt; &#xA; &lt;li&gt;shake128&lt;/li&gt; &#xA; &lt;li&gt;shake256&lt;/li&gt; &#xA; &lt;li&gt;skein1024&lt;/li&gt; &#xA; &lt;li&gt;skein1024/384&lt;/li&gt; &#xA; &lt;li&gt;skein1024/512&lt;/li&gt; &#xA; &lt;li&gt;skein256&lt;/li&gt; &#xA; &lt;li&gt;skein256/128&lt;/li&gt; &#xA; &lt;li&gt;skein256/160&lt;/li&gt; &#xA; &lt;li&gt;skein256/224&lt;/li&gt; &#xA; &lt;li&gt;skein512&lt;/li&gt; &#xA; &lt;li&gt;skein512/128&lt;/li&gt; &#xA; &lt;li&gt;skein512/160&lt;/li&gt; &#xA; &lt;li&gt;skein512/224&lt;/li&gt; &#xA; &lt;li&gt;skein512/256&lt;/li&gt; &#xA; &lt;li&gt;skein512/384&lt;/li&gt; &#xA; &lt;li&gt;sm3&lt;/li&gt; &#xA; &lt;li&gt;streebog&lt;/li&gt; &#xA; &lt;li&gt;streebog/256&lt;/li&gt; &#xA; &lt;li&gt;tiger&lt;/li&gt; &#xA; &lt;li&gt;tree-hash&lt;/li&gt; &#xA; &lt;li&gt;whirlpool&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Like for [[make-cipher][make-cipher]], /digest-name/ should be a symbol in the &lt;del&gt;keyword&lt;/del&gt; or &lt;del&gt;ironclad&lt;/del&gt; packages.&lt;/p&gt; &#xA;&lt;p&gt;Some algorithms (e.g. shake128 and shake256) can produce digests of any size. The size of the digest in bytes can be specified with the /output-length/ key parameter:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (make-digest :shake256 :output-length 123) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: update-digest #+BEGIN_SRC lisp (update-digest digester thing &amp;amp;key &amp;amp;allow-other-keys) =&amp;gt; (values) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Updates the internal state of /digester/ with the contents of /thing/. The exact method is determined by the type of /thing/.&lt;/p&gt; &#xA;&lt;p&gt;There are several methods defined on this generic function that take a particular digester and a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt; as well as the usual /start/ and /end/ keyword arguments. These methods update the state of /digester/ with the subsequence of the array denoted by /start/ and /end/. They are not listed here because there&#39;s one method for every type of digest that Ironclad provides, and listing them would get very tedious for no benefit. An example should suffice.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (let ((digester (ironclad:make-digest :sha1)) (array (make-array 16 :element-type &#39;(unsigned-byte 8) :initial-element 0))) ;; Update with 16 zeroes. (ironclad:update-digest digester array) ;; Update with 8 ones. (fill array 1 :start 2 :end 10) (ironclad:update-digest digester array :start 2 :end 10)) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (update-digest digester (stream stream) &amp;amp;key buffer start end &amp;amp;allow-other-keys) =&amp;gt; digester #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Update the internal state of /digester/ with the contents of /stream/, which must respond to &lt;del&gt;read-byte&lt;/del&gt; or &lt;del&gt;read-sequence&lt;/del&gt; with a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt; and return /digester/. It differs from [[digest-stream][digest-stream]], below, in that you may need to digest data before or after the contents of /stream/ (this happens, for instance, when signing the contents of some file).&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: produce-digest #+BEGIN_SRC lisp (produce-digest digester &amp;amp;key digest digest-start) =&amp;gt; digest #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the digest of the data processed by /digester/ so far.&lt;/p&gt; &#xA;&lt;p&gt;If /digest/ is provided, the computed digest will be placed into /digest/ starting at /digest-start/. /digest/ must be a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;. An [[insufficient-buffer-space][insufficient-buffer-space]] error will be signaled if there is insufficient space in /digest/.&lt;/p&gt; &#xA;&lt;p&gt;** High-level convenience functions&lt;/p&gt; &#xA;&lt;p&gt;Several high-level convenience functions that encapsulate common sequences of [[make-digest][make-digest]], [[update-digest][update-digest]] and [[produce-digest][produce-digest]] are provided by Ironclad as well. They come in two flavors: the first takes a digest name as would be provided to [[make-digest][make-digest]]. The second way to call these functions is to provide an actual digest object as the first argument. So one can say:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (ironclad:digest-sequence :md5 &lt;em&gt;buffer&lt;/em&gt;) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;or, equivalently:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (let ((digester (ironclad:make-digest :md5))) (ironclad:digest-sequence digester &lt;em&gt;buffer&lt;/em&gt;)) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;The second form comes in handy if you plan on [[*Miscellaneous][reusing the digest object]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: digest-sequence #+BEGIN_SRC lisp (digest-sequence digest-spec sequence &amp;amp;rest args &amp;amp;key start end digest digest-start) =&amp;gt; digest #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns the digest of the subsequence of /sequence/ bounded by /start/ and /end/, according to /digest-name/. /sequence/ must be a &lt;del&gt;(vector (unsigned-byte 8))&lt;/del&gt;. /digest/ and /digest-start/ are as in [[produce-digest][produce-digest]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: digest-stream #+BEGIN_SRC lisp (digest-stream digest-spec stream &amp;amp;rest args &amp;amp;key buffer start end digest digest-start) =&amp;gt; digest #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns the digest of the contents of the stream specified by /stream/. &lt;del&gt;read-byte&lt;/del&gt; must be a legal operation on /stream/ and return an &lt;del&gt;(unsigned-byte 8)&lt;/del&gt;. In a similar fashion, &lt;del&gt;read-sequence&lt;/del&gt; on /stream/ must support reading into a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;. /digest/ and /digest-start/ are as in [[produce-digest][produce-digest]].&lt;/p&gt; &#xA;&lt;p&gt;If /buffer/ is provided, it must be a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;; the portion of /buffer/ between /start/ and /end/ will be used to read the data from the stream.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: digest-file #+BEGIN_SRC lisp (digest-file digest-spec pathname &amp;amp;rest args &amp;amp;key buffer start end digest digest-start) =&amp;gt; digest #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns the digest of the contents of the file named by /pathname/. /digest/ and /digest-start/ are as in [[produce-digest][produce-digest]].&lt;/p&gt; &#xA;&lt;p&gt;If /buffer/ is provided, it must be a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;; the portion of /buffer/ between /start/ and /end/ will be used to read the data from the stream.&lt;/p&gt; &#xA;&lt;p&gt;** Inquiry functions&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: list-all-digests #+BEGIN_SRC lisp (list-all-digests) =&amp;gt; list #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns a list whose elements may be validly passed to [[make-digest][make-digest]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: digest-supported-p #+BEGIN_SRC lisp (digest-supported-p name) =&amp;gt; boolean #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns &lt;del&gt;t&lt;/del&gt; if /name/ would be in the list returned by [[list-all-digests][list-all-digests]], &lt;del&gt;nil&lt;/del&gt; otherwise.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: digest-length #+BEGIN_SRC lisp (digest-length digest) =&amp;gt; number #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns the length of the digest computed by /digest/, which may be a digest-name or a digest instance.&lt;/p&gt; &#xA;&lt;p&gt;** Miscellaneous&lt;/p&gt; &#xA;&lt;p&gt;Ironclad digests are CLOS objects; the interesting thing about this for most purposes is that functions like &lt;del&gt;reinitialize-instance&lt;/del&gt; are supported. This means one can write a fairly efficient clone of the =md5sum= program like so:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (defun digest-sum-files (digest-name &amp;amp;rest files) (unless files (error &#34;no files given to digest&#34;)) (loop with buffer = (make-array 8192 :element-type &#39;(unsigned-byte 8)) with digest = (make-array (ironclad:digest-length digest-name) :element-type &#39;(unsigned-byte 8)) for file in files for digester = (ironclad:make-digest digest-name) then (reinitialize-instance digester) do (ironclad:digest-file digester file :buffer buffer :digest digest) (format t &#34;~A &lt;del&gt;A&lt;/del&gt;%&#34; (file-namestring file) (ironclad:byte-array-to-hex-string digest)))) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** Tree hashes&lt;/p&gt; &#xA;&lt;p&gt;Ironclad supports tree hashes, as described in [[http://web.archive.org/web/20080316033726/http://www.open-content.net/specs/draft-jchapweske-thex-02.html][Tree Hash EXchange format]]. You create tree hashes as if you were creating a digest:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (ironclad:make-digest :tree-hash) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;By default, this creates a tree hash that uses the Tiger digest algorithm internally and a segment size of 1024. Since using the Tiger digest algorithm is so common, a convenience function that makes your intent obvious has also been provided:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (ironclad:make-tiger-tree-hash) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;You may indicate that you wish to use a different algorithm than Tiger:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (ironclad:make-digest &#39;(:treehash :digest :sha256)) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;Or you might wish to use a different segment size:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (ironclad:make-digest &#39;(:tree-hash :block-length 16384)) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;There is currently no interface for obtaining the intermediate hashes computed while computing the final tree hash.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Message authentication codes :PROPERTIES: :CUSTOM_ID: message-authentication-codes :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A message authentication code is a cryptographic function of some data and a user-specified key. Only a person knowing the key can recompute the MAC for the given message. A MAC is useful where maintaining data integrity is required, but the secrecy of the data is not paramount.&lt;/p&gt; &#xA;&lt;p&gt;Ironclad provides different kinds of MACs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;HMAC, specified in [[http://www.ietf.org/rfc/rfc2104.txt][RFC 2104]]&lt;/li&gt; &#xA; &lt;li&gt;CMAC, specified in [[http://www.ietf.org/rfc/rfc4493.txt][RFC 4493]] and NIST document 800-38B&lt;/li&gt; &#xA; &lt;li&gt;GMAC, specified in NIST document 800-38D&lt;/li&gt; &#xA; &lt;li&gt;Blake2 and Blake2s MAC&lt;/li&gt; &#xA; &lt;li&gt;Poly1305&lt;/li&gt; &#xA; &lt;li&gt;SipHash&lt;/li&gt; &#xA; &lt;li&gt;Skein MAC&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+NAME: make-mac #+BEGIN_SRC lisp (make-mac mac-name key &amp;amp;rest args) =&amp;gt; mac #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return a MAC object initialized with a secret /key/. /mac-name/ is a keyword naming the algorithm you wish /mac/ to use. The supported MACs can be found by calling [[list-all-macs][list-all-macs]]. They are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;blake2-mac&lt;/li&gt; &#xA; &lt;li&gt;blake2s-mac&lt;/li&gt; &#xA; &lt;li&gt;cmac&lt;/li&gt; &#xA; &lt;li&gt;gmac&lt;/li&gt; &#xA; &lt;li&gt;hmac&lt;/li&gt; &#xA; &lt;li&gt;poly1305&lt;/li&gt; &#xA; &lt;li&gt;siphash&lt;/li&gt; &#xA; &lt;li&gt;skein-mac&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Like for [[make-digest][make-digest]], /mac-name/ should be a symbol in the &lt;del&gt;keyword&lt;/del&gt; or &lt;del&gt;ironclad&lt;/del&gt; packages.&lt;/p&gt; &#xA;&lt;p&gt;Some MACs take extra arguments that can be specified in /args/.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (make-mac :blake2-mac key &amp;amp;key digest-length) (make-mac :blake2s-mac key &amp;amp;key digest-length) (make-mac :cmac key cipher-name) (make-mac :gmac key cipher-name initialization-vector) (make-mac :hmac key digest-name) (make-mac :poly1305 key) (make-mac :siphash key &amp;amp;key compression-rounds finalization-rounds digest-length) (make-mac :skein-mac key &amp;amp;key block-length digest-length) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;When making a Blake2 MAC, the length of the /key/ passed to [[make-mac][make-mac]] must be 64 bytes.&lt;/p&gt; &#xA;&lt;p&gt;When making a Blake2s MAC, the length of the /key/ passed to [[make-mac][make-mac]] must be 32 bytes.&lt;/p&gt; &#xA;&lt;p&gt;When making a CMAC, /cipher-name/ must have a [[block-length][block-length]] of either 8, 16, 32, 64 or 128; this restriction is satisfied by many ciphers in Ironclad with the notable exception of stream ciphers. /key/ must be an acceptable key for /cipher-name/.&lt;/p&gt; &#xA;&lt;p&gt;When making a GMAC, /cipher-name/ must have a [[block-length][block-length]] of 16. /key/ must be an acceptable key for /cipher-name/.&lt;/p&gt; &#xA;&lt;p&gt;When making a Poly1305 MAC, the length of the /key/ passed to [[make-mac][make-mac]] must be 32 bytes.&lt;/p&gt; &#xA;&lt;p&gt;When making a SipHash MAC, the length of the /key/ passed to [[make-mac][make-mac]] must be 16 bytes. /digest-length/ is 8 by default, but it can also be set to 16. By default, /compression-rounds/ is 2 and /finalization-rounds/ is 4.&lt;/p&gt; &#xA;&lt;p&gt;When making a Skein MAC, /block-length/ can be 32 (to use the Skein256 hash function internally), 64 (to use Skein512) or 128 (to use Skein1024). /digest-length/ can be any length you want the computed digest to be. By default, /block-length/ is 64 and /digest-length/ is 64.&lt;/p&gt; &#xA;&lt;p&gt;MAC objects support &lt;del&gt;reinitialize-instance&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (reinitialize-instance mac &amp;amp;rest initargs &amp;amp;key key &amp;amp;allow-other-keys) =&amp;gt; mac #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;The /:key/ argument is the secret key, as provided to [[make-mac][make-mac]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: update-mac #+BEGIN_SRC lisp (update-mac mac thing &amp;amp;key &amp;amp;allow-other-keys) =&amp;gt; (values) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Updates the internal state of /mac/ with the contents of /thing/. The exact method is determined by the type of /thing/.&lt;/p&gt; &#xA;&lt;p&gt;There are several methods defined on this generic function that take a particular MAC and a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt; as well as the usual /start/ and /end/ keyword arguments. These methods update the state of /mac/ with the subsequence of the array denoted by /start/ and /end/. They are not listed here because there&#39;s one method for every type of MAC that Ironclad provides, and listing them would get very tedious for no benefit. An example should suffice.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (let* ((key (random-data 32)) (mac (ironclad:make-mac :hmac key :sha256)) (array (make-array 16 :element-type &#39;(unsigned-byte 8) :initial-element 0))) ;; Update with 16 zeroes. (ironclad:update-mac mac array) ;; Update with 8 ones. (fill array 1 :start 2 :end 10) (ironclad:update-mac mac array :start 2 :end 10)) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: produce-mac #+BEGIN_SRC lisp (produce-mac mac &amp;amp;key digest digest-start) =&amp;gt; digest #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the digest of the data processed by /mac/ so far. The internal state of /mac/ is not modified; this feature makes it possible to compute a &#34;rolling MAC&#34; of a document.&lt;/p&gt; &#xA;&lt;p&gt;If /digest/ is provided, the computed digest will be placed into /digest/ starting at /digest-start/. /digest/ must be a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;. An [[insufficient-buffer-space][insufficient-buffer-space]] error will be signaled if there is insufficient space in /digest/.&lt;/p&gt; &#xA;&lt;p&gt;The length of the digest returned by [[produce-mac][produce-mac]] is determined by the kind of MAC and the extra arguments passed to [[make-mac][make-mac]]:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;blake2-mac: from 1 to 64 bytes (64 by default)&lt;/li&gt; &#xA; &lt;li&gt;blake2s-mac: from 1 to 32 bytes (32 by default)&lt;/li&gt; &#xA; &lt;li&gt;cmac: [[block-length][block-length]] of the /cipher-name/ passed to [[make-mac][make-mac]]&lt;/li&gt; &#xA; &lt;li&gt;gmac: 16 bytes&lt;/li&gt; &#xA; &lt;li&gt;hmac: [[digest-length][digest-length]] of the /digest-name/ passed to [[make-mac][make-mac]]&lt;/li&gt; &#xA; &lt;li&gt;poly1305: 16 bytes&lt;/li&gt; &#xA; &lt;li&gt;siphash: /digest-length/ passed to [[make-mac][make-mac]] (8 by default)&lt;/li&gt; &#xA; &lt;li&gt;skein-mac: /digest-length/ passed to [[make-mac][make-mac]] (64 by default)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Inquiry functions&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: list-all-macs #+BEGIN_SRC lisp (list-all-macs) =&amp;gt; list #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns a list whose elements may be validly passed to [[make-mac][make-mac]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: mac-supported-p #+BEGIN_SRC lisp (mac-supported-p name) =&amp;gt; boolean #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns &lt;del&gt;t&lt;/del&gt; if /name/ would be in the list returned by [[list-all-macs][list-all-macs]], &lt;del&gt;nil&lt;/del&gt; otherwise.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Authenticated encryption :PROPERTIES: :CUSTOM_ID: authenticated-encryption :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+NAME: make-authenticated-encryption-mode #+BEGIN_SRC lisp (make-authenticated-encryption-mode name &amp;amp;rest args) =&amp;gt; mode #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return an authenticated encryption object suitable for use for both encryption and decryption.&lt;/p&gt; &#xA;&lt;p&gt;/name/ denotes the mode to use. [[list-all-authenticated-encryption-modes][list-all-authenticated-encryption-modes]] will tell you the names of all the supported modes. They are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;eax (Encrypt then authenticate then translate)&lt;/li&gt; &#xA; &lt;li&gt;etm (Encrypt then MAC)&lt;/li&gt; &#xA; &lt;li&gt;gcm (Galois counter mode)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;/name/ can be a symbol in the &lt;del&gt;keyword&lt;/del&gt; or &lt;del&gt;ironclad&lt;/del&gt; packages.&lt;/p&gt; &#xA;&lt;p&gt;/args/ depends on the chosen authenticated encryption mode.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (make-authenticated-encryption-mode :eax &amp;amp;key tag cipher-name key initialization-vector) (make-authenticated-encryption-mode :etm &amp;amp;key tag cipher mac) (make-authenticated-encryption-mode :gcm &amp;amp;key tag cipher-name key initialization-vector) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;If /tag/ is specified, it will be used at the end of decryption (when the /handle-final-block/ flag is &lt;del&gt;t&lt;/del&gt;) to check the authenticity of the data. A &lt;del&gt;bad-authentication-tag&lt;/del&gt; error will be signaled if the data is not authentic. If you don&#39;t specify it, you will have to call [[produce-tag][produce-tag]] after decryption and check that the tags match (e.g. using [[constant-time-equal][constant-time-equal]]).&lt;/p&gt; &#xA;&lt;p&gt;When using EAX, /key/ must be a suitable key for the chosen /cipher-name/.&lt;/p&gt; &#xA;&lt;p&gt;When using ETM, /cipher/ must be a cipher object created by [[make-cipher][make-cipher]]. /mac/ must be a mac object created by [[make-mac][make-mac]].&lt;/p&gt; &#xA;&lt;p&gt;When using GCM, /cipher-name/ must have a [[block-length][block-length]] of 16 bytes. /key/ must be a suitable key for the chosen cipher.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: process-associated-data #+BEGIN_SRC lisp (process-associated-data mode data &amp;amp;key start end) =&amp;gt; (values) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Update the internal state of /mode/ with the contents of /data/ between /start/ and /end/ so that they are taken into consideration in the authentication tag.&lt;/p&gt; &#xA;&lt;p&gt;An authenticated encryption object can be used with the [[encrypt][encrypt]], [[decrypt][decrypt]], [[encrypt-message][encrypt-message]] and [[decrypt-message][decrypt-message]] functions.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (encrypt mode plaintext ciphertext &amp;amp;key plaintext-start plaintext-end ciphertext-start handle-final-block) (decrypt mode ciphertext plaintext &amp;amp;key ciphertext-start ciphertext-end plaintext-start handle-final-block) (encrypt-message mode message &amp;amp;key start end associated-data associated-data-start associated-data-end) (decrypt-message mode message &amp;amp;key start end associated-data associated-data-start associated-data-end) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: produce-tag #+BEGIN_SRC lisp (produce-tag mode &amp;amp;key tag tag-start) =&amp;gt; tag #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the authentication tag of the data processed by /mode/ so far. If /tag/ is provided, the computed tag will be placed into /tag/ starting at /tag-start/. /tag/ must be a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;. An [[insufficient-buffer-space][insufficient-buffer-space]] error will be signaled if there is insufficient space in /tag/.&lt;/p&gt; &#xA;&lt;p&gt;** Inquiry functions&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: list-all-authenticated-encryption-modes #+BEGIN_SRC lisp (list-all-authenticated-encryption-modes) =&amp;gt; list #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns a list whose elements may be validly passed to [[make-authenticated-encryption-mode][make-authenticated-encryption-mode]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: authenticated-encryption-mode-supported-p #+BEGIN_SRC lisp (authenticated-encryption-mode-supported-p name) =&amp;gt; boolean #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns &lt;del&gt;t&lt;/del&gt; if /name/ would be in the list returned by [[list-all-authenticated-encryption-modes][list-all-authenticated-encryption-modes]] &lt;del&gt;nil&lt;/del&gt; otherwise.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Key derivation functions :PROPERTIES: :CUSTOM_ID: key-derivation-functions :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Ironclad comes with a few key derivation functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Argon2 (only Argon2d and Argon2i without parallelism are implemented)&lt;/li&gt; &#xA; &lt;li&gt;Bcrypt&lt;/li&gt; &#xA; &lt;li&gt;Bcrypt-pbkdf&lt;/li&gt; &#xA; &lt;li&gt;PBKDF1&lt;/li&gt; &#xA; &lt;li&gt;PBKDF2&lt;/li&gt; &#xA; &lt;li&gt;Scrypt&lt;/li&gt; &#xA; &lt;li&gt;HMAC&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+NAME: derive-key #+BEGIN_SRC lisp (derive-key kdf passphrase salt iteration-count key-length) =&amp;gt; digest #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Given a key derivation function object (produced by [[make-kdf][make-kdf]]), a password and salt (both must be of type &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;), and number of iterations, returns the password digest as a byte array of length /key-length/.&lt;/p&gt; &#xA;&lt;p&gt;For bcrypt, the /salt/ must be 16 bytes long, the /iteration-count/ must be a power of 2 between 2^4 and 2^31, and the /key-length/ must be 24. Scrypt and HMAC ignore the /iteration-count/ parameter.&lt;/p&gt; &#xA;&lt;p&gt;For bcrypt-pbkdf, the /key-length/ must be between 1 and 1024.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-kdf #+BEGIN_SRC lisp (make-kdf kind &amp;amp;key digest n r p block-count additional-key additional-data) =&amp;gt; kdf #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns a key derivation function instance.&lt;/p&gt; &#xA;&lt;p&gt;/kind/ denotes the key derivation function to use. They are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;argon2d&lt;/li&gt; &#xA; &lt;li&gt;argon2i&lt;/li&gt; &#xA; &lt;li&gt;bcrypt&lt;/li&gt; &#xA; &lt;li&gt;bcrypt-pbkdf&lt;/li&gt; &#xA; &lt;li&gt;pbkdf1&lt;/li&gt; &#xA; &lt;li&gt;pbkdf2&lt;/li&gt; &#xA; &lt;li&gt;scrypt-kdf&lt;/li&gt; &#xA; &lt;li&gt;hmac-kdf&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;/kind/ can be a symbol in the &lt;del&gt;keyword&lt;/del&gt; or &lt;del&gt;ironclad&lt;/del&gt; packages.&lt;/p&gt; &#xA;&lt;p&gt;The Argon2 key derivations use the /block-count/, /additional-key/ and /additional-data/ parameters (/block-count/ is the number of 1 KiB memory blocks used by the function and it must be at least 8, /additional-key/ and /additional-data/ are optional). The PBKDF algorithms use /digest/. The Scrypt key derivation uses cost parameters /N/, /r/ and /p/ (/N/ is a CPU cost parameter that must be a power of 2, /r/ and /p/ are memory cost parameters that must be defined such that /r/ * /p/ &amp;lt;= 2^30).&lt;/p&gt; &#xA;&lt;p&gt;The default Scrypt parameters are /N/ = 4096, /r/ = 8, and /p/ = 2. Please note that depending on the values of /N/ and /r/, [[derive-key][derive-key]] may not be able to allocate sufficient space for its temporary arrays.&lt;/p&gt; &#xA;&lt;p&gt;The HMAC-KDF algorithm uses the /digest/ parameter to precise what hash function is used. It also optionally uses the /additional-data/ to precise the &lt;del&gt;info&lt;/del&gt; vector from the [[https://tools.ietf.org/html/rfc5869][RFC]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: list-all-kdfs #+BEGIN_SRC lisp (list-all-kdfs) =&amp;gt; list #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns a list of KDF kinds that may be validly passed to [[make-kdf][make-kdf]].&lt;/p&gt; &#xA;&lt;p&gt;** PBKDF convenience functions&lt;/p&gt; &#xA;&lt;p&gt;Ironclad comes with convenience functions for using PBKDF1 and PBKDF2 to store passwords.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: pbkdf2-hash-password #+BEGIN_SRC lisp (pbkdf2-hash-password password &amp;amp;key salt digest iterations) =&amp;gt; password #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Convenience function for hashing passwords using the PBKDF2 algorithm. Returns the derived hash of the password, and the original salt, as byte vectors.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: pbkdf2-hash-password-to-combined-string #+BEGIN_SRC lisp (pbkdf2-hash-password-to-combined-string password &amp;amp;key salt digest iterations) =&amp;gt; password #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Convenience function for hashing passwords using the PBKDF2 algorithm. Returns the derived hash of the password as a single string that encodes the given salt and PBKDF2 algorithm parameters.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: pbkdf2-check-password #+BEGIN_SRC lisp (pbkdf2-check-password password combined-salt-and-digest) =&amp;gt; boolean #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Given a /password/ byte vector and a combined salt and digest string produced by [[pbkdf2-hash-password-to-combined-string][pbkdf2-hash-password-to-combined-string]], checks whether the password is valid.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Public key cryptography :PROPERTIES: :CUSTOM_ID: public-key-cryptography :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Ironclad includes support for a few public key cryptography algorithms.&lt;/p&gt; &#xA;&lt;p&gt;Encryption algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Elgamal&lt;/li&gt; &#xA; &lt;li&gt;RSA&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Signature algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;DSA&lt;/li&gt; &#xA; &lt;li&gt;Ed25519&lt;/li&gt; &#xA; &lt;li&gt;Ed448&lt;/li&gt; &#xA; &lt;li&gt;Elgamal&lt;/li&gt; &#xA; &lt;li&gt;RSA&lt;/li&gt; &#xA; &lt;li&gt;Secp256k1&lt;/li&gt; &#xA; &lt;li&gt;Secp256r1 (a.k.a. NIST P-256)&lt;/li&gt; &#xA; &lt;li&gt;Secp384r1 (a.k.a. NIST P-384)&lt;/li&gt; &#xA; &lt;li&gt;Secp521r1 (a.k.a. NIST P-521)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Diffie-Hellman key exchange:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Curve25519&lt;/li&gt; &#xA; &lt;li&gt;Curve448&lt;/li&gt; &#xA; &lt;li&gt;Elgamal&lt;/li&gt; &#xA; &lt;li&gt;Secp256k1&lt;/li&gt; &#xA; &lt;li&gt;Secp256r1 (a.k.a. NIST P-256)&lt;/li&gt; &#xA; &lt;li&gt;Secp384r1 (a.k.a. NIST P-384)&lt;/li&gt; &#xA; &lt;li&gt;Secp521r1 (a.k.a. NIST P-521)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Key pair generation&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: generate-key-pair #+BEGIN_SRC lisp (generate-key-pair kind &amp;amp;key num-bits &amp;amp;allow-other-keys) =&amp;gt; private-key, public-key #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return a key pair according to /kind/. The generation of DSA, Elgamal and RSA key pairs can take some time. If /kind/ is &lt;del&gt;:dsa&lt;/del&gt; or &lt;del&gt;:rsa&lt;/del&gt;, the /num-bits/ key argument indicating the size of the keys to generate must be specified. If /kind/ is &lt;del&gt;:elgamal&lt;/del&gt;, /num-bits/ must be specified unless /compatible-with-key/ is specified, in which case the group parameters are taken from the specified key instead of being generated.&lt;/p&gt; &#xA;&lt;p&gt;For example, if Alice wants to generate a key pair for a Diffie-Hellman exchange with Bob&#39;s Elgamal key pair: #+BEGIN_EXAMPLE (generate-key-pair :elgamal :compatible-with-key bob-public-key) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: list-all-key-pair-kinds #+BEGIN_SRC lisp (list-all-key-pair-kinds) =&amp;gt; list #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Returns a list of key pair kinds that may be validly passed to [[generate-key-pair][generate-key-pair]].&lt;/p&gt; &#xA;&lt;p&gt;*** Key construction&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-public-key #+BEGIN_SRC lisp (make-public-key kind &amp;amp;key &amp;amp;allow-other-keys) =&amp;gt; public-key #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return a public key according to /kind/. The /&amp;amp;key/ arguments vary according to /kind/. The interesting bits are in the methods that specialize on /kind/, below.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (make-public-key :curve25519 &amp;amp;key y) =&amp;gt; public-key (make-public-key :curve448 &amp;amp;key y) =&amp;gt; public-key (make-public-key :dsa &amp;amp;key p q g y) =&amp;gt; public-key (make-public-key :ed25519 &amp;amp;key y) =&amp;gt; public-key (make-public-key :ed448 &amp;amp;key y) =&amp;gt; public-key (make-public-key :elgamal &amp;amp;key p g y) =&amp;gt; public-key (make-public-key :rsa &amp;amp;key e n) =&amp;gt; public-key (make-public-key :secp256k1 &amp;amp;key y) =&amp;gt; public-key (make-public-key :secp256r1 &amp;amp;key y) =&amp;gt; public-key (make-public-key :secp384r1 &amp;amp;key y) =&amp;gt; public-key (make-public-key :secp521r1 &amp;amp;key y) =&amp;gt; public-key #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-private-key #+BEGIN_SRC lisp (make-private-key kind &amp;amp;key &amp;amp;allow-other-keys) =&amp;gt; private-key #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return a private key according to /kind/. The /&amp;amp;key/ arguments vary according to /kind/. The interesting bits are in the methods that specialize on /kind/, below.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (make-private-key :curve25519 &amp;amp;key x y) =&amp;gt; private-key (make-private-key :curve448 &amp;amp;key x y) =&amp;gt; private-key (make-private-key :dsa &amp;amp;key p q g y x) =&amp;gt; private-key (make-private-key :ed25519 &amp;amp;key x y) =&amp;gt; private-key (make-private-key :ed448 &amp;amp;key x y) =&amp;gt; private-key (make-private-key :elgamal &amp;amp;key p g y x) =&amp;gt; private-key (make-private-key :rsa &amp;amp;key d n p q) =&amp;gt; private-key (make-private-key :secp256k1 &amp;amp;key x y) =&amp;gt; private-key (make-private-key :secp256r1 &amp;amp;key x y) =&amp;gt; private-key (make-private-key :secp384r1 &amp;amp;key x y) =&amp;gt; private-key (make-private-key :secp521r1 &amp;amp;key x y) =&amp;gt; private-key #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;For Curve25519, Curve448, Ed25519, Ed448 keys, Secp256k1, Secp256r1, Secp384r1 and Secp521r1, the type of the parameters is &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;/x/, the secret key&lt;/li&gt; &#xA; &lt;li&gt;/y/, the public key&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For DSA and Elgamal keys, the type of the parameters is &lt;del&gt;integer&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;/p/, the prime number defining the DL group&lt;/li&gt; &#xA; &lt;li&gt;/q/, the prime number defining the DL sub-group&lt;/li&gt; &#xA; &lt;li&gt;/g/, the generator&lt;/li&gt; &#xA; &lt;li&gt;/y/, the public key&lt;/li&gt; &#xA; &lt;li&gt;/x/, the private key&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For RSA keys, the type of the parameters is &lt;del&gt;integer&lt;/del&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;/n/, the modulus&lt;/li&gt; &#xA; &lt;li&gt;/e/, the public key&lt;/li&gt; &#xA; &lt;li&gt;/d/, the private key&lt;/li&gt; &#xA; &lt;li&gt;/p/, the first prime factor of /n/&lt;/li&gt; &#xA; &lt;li&gt;/q/, the second prime factor of /n/&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;*** Key destructuring&lt;/p&gt; &#xA;&lt;p&gt;The [[destructure-public-key][destructure-public-key]] and [[destructure-private-key][destructure-private-key]] functions can be useful if you need to store keys somewhere for future use.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: destructure-public-key #+BEGIN_SRC lisp (destructure-public-key public-key) =&amp;gt; plist #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the elements of a public key in a plist. The indicators of the plist match the /&amp;amp;key/ arguments of the [[make-public-key][make-public-key]] method.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: destructure-private-key #+BEGIN_SRC lisp (destructure-private-key private-key) =&amp;gt; plist #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the elements of a private key in a plist. The indicators of the plist match the /&amp;amp;key/ arguments of the [[make-private-key][make-private-key]] method.&lt;/p&gt; &#xA;&lt;p&gt;** Digital signatures&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: sign-message #+BEGIN_SRC lisp (sign-message key message &amp;amp;key start end &amp;amp;allow-other-keys) =&amp;gt; signature #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return a signature of /message/ between /start/ and /end/ signed with /key/; the class of /key/ determines the algorithm used to create the /signature/.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; The [[sign-message][sign-message]] does not perform the hashing of the data. You should hash your data using your favorite hash function, and then use this hash as the /message/ passed to [[sign-message][sign-message]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: verify-signature #+BEGIN_SRC lisp (verify-signature key message signature &amp;amp;key start end &amp;amp;allow-other-keys) =&amp;gt; boolean #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Verify whether /signature/ is a valid signature of /message/ between /start/ and /end/ using /key/. Return &lt;del&gt;t&lt;/del&gt; is the signature is valid and &lt;del&gt;nil&lt;/del&gt; otherwise.&lt;/p&gt; &#xA;&lt;p&gt;*** Padding&lt;/p&gt; &#xA;&lt;p&gt;To be secure, RSA signature requires the message to be padded. The /pss/ key parameter is provided to pad (or unpad) the message during signature (or verification) with the PSS scheme of PKCS-1. The value of the /pss/ key parameter can be either a digest name or &lt;del&gt;t&lt;/del&gt; (which will use the sha1 digest).&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (sign-message rsa-private-key message :pss t) =&amp;gt; signature (verify-signature rsa-public-key message signature :pss t) =&amp;gt; boolean #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;The functions /pss-encode/ and /pss-decode/ can also be used by hand if necessary.&lt;/p&gt; &#xA;&lt;p&gt;*** Signature nonce&lt;/p&gt; &#xA;&lt;p&gt;DSA, Elgamal and ECDSA (Secp256k1, Secp256r1, Secp384r1 and Secp521r1) signatures require the generation of a nonce. You must never sign two different messages with the same key and the same nonce, or anyone having these two signatures will be able compute your private key. Ironclad uses the [[generate-signature-nonce][generate-signature-nonce]] method which by default generates random nonces.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: generate-signature-nonce #+BEGIN_SRC lisp (generate-signature-nonce (key message &amp;amp;optional parameters)) =&amp;gt; nonce #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;For DSA, /parameters/ is /q/. For Elgamal, /parameters/ is /p/. For ECDSA, /parameters/ is &lt;del&gt;nil&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If instead of random nonces, you want to have deterministic nonces (e.g. like in RFC 6979), you will have to redefine [[generate-signature-nonce][generate-signature-nonce]]. For example, to have deterministic nonces for Secp256k1 ECDSA signatures, you could do something like:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (defmethod generate-signature-nonce ((key secp256k1-private-key) message &amp;amp;optional parameters) (declare (ignore parameters)) (compute-deterministic-nonce key message)) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;*** Format of signatures&lt;/p&gt; &#xA;&lt;p&gt;[[sign-message][sign-message]] returns signatures as octet vectors. When the signature contains several values (e.g. the R and S values of DSA signatures), the octet vector is the concatenation of these values (e.g. the first half of the vector is the R value, the second half is the S value). You can use the [[make-signature][make-signature]] and [[destructure-signature][destructure-signature]] functions if you need access to the elements of a signature (e.g. to use a different kind of serialization).&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-signature #+BEGIN_SRC lisp (make-signature kind &amp;amp;key &amp;amp;allow-other-keys) =&amp;gt; signature #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return an octet vector representing a signature. The /&amp;amp;key/ arguments vary according to /kind/. The interesting bits are in the methods that specialize on /kind/, below.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (make-signature :dsa &amp;amp;key r s n-bits) =&amp;gt; signature (make-signature :ed25519 &amp;amp;key r s) =&amp;gt; signature (make-signature :ed448 &amp;amp;key r s) =&amp;gt; signature (make-signature :elgamal &amp;amp;key r s n-bits) =&amp;gt; signature (make-signature :rsa &amp;amp;key s n-bits) =&amp;gt; signature (make-signature :secp256k1 &amp;amp;key r s) =&amp;gt; signature (make-signature :secp256r1 &amp;amp;key r s) =&amp;gt; signature (make-signature :secp384r1 &amp;amp;key r s) =&amp;gt; signature (make-signature :secp521r1 &amp;amp;key r s) =&amp;gt; signature #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;For Ed25519, Ed448, Secp256k1, Secp256r1, Secp384r1 and Secp521r1 signatures, the type of the parameters /r/ and /s/ is &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For DSA and Elgamal signatures, the type of the parameters /r/, /s/ and /n-bits/ is &lt;del&gt;integer&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For RSA signatures, the type of the parameters /s/ and /n-bits/ is &lt;del&gt;integer&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: destructure-signature #+BEGIN_SRC lisp (destructure-signature kind signature) =&amp;gt; plist #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the elements of a signature in a plist. The indicators of the plist match the /&amp;amp;key/ arguments of the [[make-signature][make-signature]] method.&lt;/p&gt; &#xA;&lt;p&gt;** Encryption and decryption&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: encrypt-message #+BEGIN_SRC lisp (encrypt-message key message &amp;amp;key start end &amp;amp;allow-other-keys) =&amp;gt; encrypted-message #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the /message/ between /start/ and /end/ encrypted with the /key/; the class of /key/ determines the algorithm used to encrypt the message.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: decrypt-message #+BEGIN_SRC lisp (decrypt-message key message &amp;amp;key start end n-bits &amp;amp;allow-other-keys) =&amp;gt; decrypted-message #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the /message/ between /start/ and /end/ decrypted by the /key/; the class of /key/ determines the algorithm used to decrypt the message. /n-bits/ can be used to indicate the expected size of the decrypted message (e.g. a small byte vector starting with zeros encrypted without padding, which is probably a bad idea, c.f. Padding section).&lt;/p&gt; &#xA;&lt;p&gt;*** Padding&lt;/p&gt; &#xA;&lt;p&gt;To be secure, RSA encryption requires the message to be padded. The /oaep/ key parameter is provided to pad (or unpad) the message during encryption (or decryption) with the OAEP scheme of PKCS-1. The value of the /oaep/ key parameter can be either a digest name or &lt;del&gt;t&lt;/del&gt; (which will use the sha1 digest).&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (encrypt-message rsa-public-key message :oaep t) =&amp;gt; encrypted-message (decrypt-message rsa-private-key message :oaep t) =&amp;gt; decrypted-message #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;The functions /oaep-encode/ and /oaep-decode/ can also be used by hand if necessary.&lt;/p&gt; &#xA;&lt;p&gt;*** Format of messages&lt;/p&gt; &#xA;&lt;p&gt;[[encrypt-message][encrypt-message]] returns encrypted messages as octet vectors. When the message contains several values (e.g. the C1 and C2 values of Elgamal messages), the octet vector is the concatenation of these values (e.g. the first half of the vector is the big-endian representation of the C1 value, the second half is the C2 value). You can use the [[make-message][make-message]] and [[destructure-message][destructure-message]] functions if you need access to the elements of a message (e.g. to use a different kind of serialization).&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-message #+BEGIN_SRC lisp (make-message kind &amp;amp;key &amp;amp;allow-other-keys) =&amp;gt; message #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return an octet vector representing a message. The /&amp;amp;key/ arguments vary according to /kind/. The interesting bits are in the methods that specialize on /kind/, below.&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (make-message :elgamal &amp;amp;key c1 c2 n-bits) =&amp;gt; message (make-message :rsa &amp;amp;key m n-bits) =&amp;gt; message #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;For Elgamal messages, the type of the parameters /c1/, /c2/ and /n-bits/ is &lt;del&gt;integer&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For RSA signatures, the type of the parameters /m/ and /n-bits/ is &lt;del&gt;integer&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: destructure-message #+BEGIN_SRC lisp (destructure-message kind message) =&amp;gt; plist #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return the elements of a message in a plist. The indicators of the plist match the /&amp;amp;key/ arguments of the [[make-message][make-message]] method.&lt;/p&gt; &#xA;&lt;p&gt;** Diffie-Hellman key exchange&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: diffie-hellman #+BEGIN_SRC lisp (diffie-hellman private-key public-key) =&amp;gt; bytes #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Return a secret shared by two users Alice and Bob, computed from Alice&#39;s private key and Bob&#39;s public key (these keys must be compatible, i.e. have the same group parameters).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pseudo-random number generation :PROPERTIES: :CUSTOM_ID: pseudo-random-number-generation :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The =&lt;em&gt;prng&lt;/em&gt;= special variable indicates which pseudo-random number generator is used by default by functions that need to generate some random data. It defaults to a sensible OS-specific value.&lt;/p&gt; &#xA;&lt;p&gt;The vast, vast vast number of users should just use the default &lt;del&gt;os-prng&lt;/del&gt; (which uses =/dev/urandom= on Unix and &lt;del&gt;CryptGenRandom&lt;/del&gt; on Windows). For users who need /deterministic/, high-quality-random-seeming numbers (e.g. for Monte Carlo simulations), &lt;del&gt;fortuna-generator&lt;/del&gt; is provided. Finally, if you&#39;re running on a platform without a decent PRNG (these are few and far between now), you may require the full &lt;del&gt;fortuna-prng&lt;/del&gt;. When in doubt, use &lt;del&gt;os-prng&lt;/del&gt;, which is the default.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME:make-prng #+BEGIN_SRC lisp (make-prng name &amp;amp;key seed) =&amp;gt; prng #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Create a pseudo-random number generator.&lt;/p&gt; &#xA;&lt;p&gt;/name/ denotes the style of PRNG to use. [[list-all-prngs][list-all-prngs]] will tell you the names of all supported PRNGs. Currently supported PRNGs are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OS&lt;/li&gt; &#xA; &lt;li&gt;Fortuna&lt;/li&gt; &#xA; &lt;li&gt;Fortuna-generator&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;/name/ can be a symbol in the &lt;del&gt;keyword&lt;/del&gt; package or in the &lt;del&gt;ironclad&lt;/del&gt; package.&lt;/p&gt; &#xA;&lt;p&gt;/seed/ is a &lt;em&gt;seed descriptor&lt;/em&gt;. If &lt;del&gt;nil&lt;/del&gt;, the PRNG will not be seeded (which may prevent it from generating output until it is seeded, depending on the PRNG in question). If &lt;del&gt;:random&lt;/del&gt; then the PRNG will be seeded with the OS&#39;s cryptographically-secure PRNG. If &lt;del&gt;:urandom&lt;/del&gt; then the PRNG will be seeded with the OS&#39;s fast-but-potentially-less-secure PRNG, if available (if not, will fallback to &lt;del&gt;:random&lt;/del&gt;). If it is a pathname indicator, a seed will be read from the indicated file, then a new seed will be generated and written back to the file (over-writing the old seed). Finally, if it is a byte vector, it will be used to seed the PRNG.&lt;/p&gt; &#xA;&lt;p&gt;In single-threaded applications, you should very rarely need to call [[make-prng][make-prng]]; the default OS-provided PRNG should be appropriate in nearly all cases.&lt;/p&gt; &#xA;&lt;p&gt;In multi-threaded applications, each thread that will use functions requiring random data must have its own PRNG, or several threads might generate the same &#34;random&#34; data. If the threads are created using the &lt;em&gt;bordeaux-threads&lt;/em&gt; library (or by a library using &lt;em&gt;bordeaux-threads&lt;/em&gt;, like &lt;em&gt;lparallel&lt;/em&gt;), this is done automatically. However, if you are using the threading functions of your Common Lisp implementation directly, you have to bind the &lt;del&gt;&lt;em&gt;prng&lt;/em&gt;&lt;/del&gt; special variable to a new PRNG in each thread. For example:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (make-thread (lambda () (let ((crypto:&lt;em&gt;prng&lt;/em&gt; (crypto:make-prng :os))) (forms-for-thread-1))))&lt;/p&gt; &#xA;&lt;p&gt;(make-thread (lambda () (let ((crypto:&lt;em&gt;prng&lt;/em&gt; (crypto:make-prng :os))) (forms-for-thread-2)))) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: list-all-prngs #+BEGIN_SRC lisp (list-all-prngs) =&amp;gt; list #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;List all known PRNG types.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: random-data #+BEGIN_SRC lisp (random-data num-bytes &amp;amp;optional prng) =&amp;gt; bytes #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Generate /num-bytes/ bytes of random data from /prng/. Updates the state of the generator.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: random-bits #+BEGIN_SRC lisp (random-bits num-bits &amp;amp;optional prng) =&amp;gt; integer #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Generate an integer with /num-bits/ bits.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: strong-random #+BEGIN_SRC lisp (strong-random limit &amp;amp;optional prng) =&amp;gt; number #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;A drop-in replacement for &lt;del&gt;common-lisp:random&lt;/del&gt;, [[strong-random][strong-random]] generates a number (an integer if /limit/ is an integer and a float if it is a float) between 0 and /limit/ - 1 in an unbiased fashion.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: read-os-random-seed #+BEGIN_SRC lisp (read-os-random-seed source &amp;amp;optional prng) =&amp;gt; reseed-count #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Read an OS-provided random seed (from =/dev/urandom= or =/dev/random= on Unix; &lt;del&gt;CryptGenRandom&lt;/del&gt; on Windows) and reseed /prng/.&lt;/p&gt; &#xA;&lt;p&gt;/source/ may be &lt;del&gt;:random&lt;/del&gt;, which indicates =/dev/random= or &lt;del&gt;:urandom&lt;/del&gt;, which indicates =/dev/urandom=. On Windows, &lt;del&gt;CryptGenRandom&lt;/del&gt; is always used.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: read-seed #+BEGIN_SRC lisp (read-seed path &amp;amp;optional prng) =&amp;gt; t #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Read enough bytes from /path/ to reseed /prng/, then generate a pseudo-random seed and write it back to /path/. If /path/ doesn&#39;t exist, calls [[read-os-random-seed][read-os-random-seed]] to get a truly random seed from the OS. Note that reseeding does &lt;em&gt;not&lt;/em&gt; reset the generator&#39;s state to the seed value; rather, it &lt;em&gt;combines&lt;/em&gt; the generator&#39;s state with the seed to form a new state.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: write-seed #+BEGIN_SRC lisp (write-seed path &amp;amp;optional prng) =&amp;gt; t #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Generate enough random data to reseed /prng/, then write it to /path/.&lt;/p&gt; &#xA;&lt;p&gt;** Example&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_EXAMPLE (crypto:random-data 16) =&amp;gt; #(61 145 133 130 220 200 90 86 0 101 62 169 0 40 101 78)&lt;/p&gt; &#xA;&lt;p&gt;(crypto:strong-random 16) =&amp;gt; 3&lt;/p&gt; &#xA;&lt;p&gt;(crypto:random-bits 16) =&amp;gt; 41546 #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** Fortuna&lt;/p&gt; &#xA;&lt;p&gt;You should only use the Fortuna PRNG if your OS does not provided a sufficiently-good PRNG. If you use a Unix or Unix-like OS (e.g. Linux), macOS or Windows, it does. Only use the Fortuna PRNG if you know for certain that you need it.&lt;/p&gt; &#xA;&lt;p&gt;Fortuna is a cryptographically-secure random number presented by Ferguson, Schneier and Kohno in /Cryptography Engineering/. It is built around 32 entropy pools, which are used with decreasing frequency for each reseed (e.g. pool 0 is used in each reseed, pool 1 in every other reseed, pool 2 in every fourth reseed and so forth). Pools are seeded with data from up to 256 sources.&lt;/p&gt; &#xA;&lt;p&gt;Each application should have one or more entropy sources (say, one for each OS random number source, one for the low bits of the current time, one for the output of a particular command or group of commands and so forth). A source should be used to add randomness to each pool in order, so source 0 should top up pool 0, then pool 1, and so forth up to pool 31, then loop back to pool 1 again. Be very careful to spread entropy across all 32 pools.&lt;/p&gt; &#xA;&lt;p&gt;Fortuna automatically feeds entropy from the pools back into its random state when [[random-data][random-data]] is called, using a method designed to make it resistant to various avenues of attack; even in case of generator compromise it will return to a safe state within a bounded time.&lt;/p&gt; &#xA;&lt;p&gt;For purposes of reseeding, Fortuna will not reseed until the first pool contains 128 bits of entropy; &lt;del&gt;+min-pool-size+&lt;/del&gt; sets the number of bytes this is; it defaults to a very conservative 128, meaning that by default each byte of event is assumed to contain a single bit of randomness.&lt;/p&gt; &#xA;&lt;p&gt;It also will not reseed more than ten times per second.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: add-random-event #+BEGIN_SRC lisp (add-random-event source pool-id event &amp;amp;optional prng) =&amp;gt; pool-length #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Add entropy to /prng/.&lt;/p&gt; &#xA;&lt;p&gt;/source/ is an integer in the range 0-255 specifiying the event&#39;s application-defined source.&lt;/p&gt; &#xA;&lt;p&gt;/pool-id/ is an integer in the range 0-31 specifying the pool to top up.&lt;/p&gt; &#xA;&lt;p&gt;/event/ is up to 32 bytes of data (for longer events, hash them down or break them up into chunks).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Gray streams :PROPERTIES: :CUSTOM_ID: gray-streams :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Ironclad includes support for several convenient stream abstractions based on Gray streams. Gray streams support in Ironclad is included for SBCL, CMUCL, OpenMCL/CCL, Lispworks, ABCL, ECL, Clisp and Allegro.&lt;/p&gt; &#xA;&lt;p&gt;** Octet streams&lt;/p&gt; &#xA;&lt;p&gt;Octet streams are very similar to Common Lisp&#39;s &lt;del&gt;string-stream&lt;/del&gt; except they deal in octets instead of characters.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-octet-input-stream #+BEGIN_SRC lisp (make-octet-input-stream buffer &amp;amp;optional start end) =&amp;gt; octet-input-stream #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;As &lt;del&gt;make-string-input-stream&lt;/del&gt;, only with octets instead of characters.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-octet-output-stream #+BEGIN_SRC lisp (make-octet-output-stream) =&amp;gt; octet-output-stream #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;As &lt;del&gt;make-string-output-stream&lt;/del&gt;, only with octets instead of characters.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: get-output-stream-octets #+BEGIN_SRC lisp (get-output-stream-octets stream) =&amp;gt; octet-vector #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;As &lt;del&gt;get-output-stream-string&lt;/del&gt;, only with an octet output-steam instead of a string output-stream.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: with-octet-input-stream #+BEGIN_SRC lisp (with-octet-input-stream ((var buffer &amp;amp;optional (start 0) end) &amp;amp;body body)) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Within /body/, /var/ is bound to an octet input stream. Reading from /var/ gives the bytes between the indexes /start/ and /end/ of /buffer/. The result of the last form of /body/ is returned.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: with-octet-output-stream #+BEGIN_SRC lisp (with-octet-output-stream ((var) &amp;amp;body body)) =&amp;gt; bytes #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Within /body/, /var/ is bound to an octet output stream. After all the forms in /body/ have been executed, the data that has been written to /var/ (and that hasn&#39;t been consumed by a call to [[get-output-stream-octets][get-output-stream-octets]] within /body/) is returned.&lt;/p&gt; &#xA;&lt;p&gt;** Digest streams&lt;/p&gt; &#xA;&lt;p&gt;Digest streams compute a digest of the data written to them according to a specific digest algorithm.&lt;/p&gt; &#xA;&lt;p&gt;Example: #+BEGIN_EXAMPLE (defun frobbing-function (stream) ;; We want to compute a digest of the data being written to STREAM ;; without involving our callees in the process. (let* ((digesting-stream (crypto:make-digesting-stream :sha1)) (stream (make-broadcast-stream stream digesting-stream))) ;; Feed data to STREAM. (frob-guts stream) ;; Do something with the digest computed. (... (crypto:produce-digest digesting-stream) ...) ...)) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-digesting-stream #+BEGIN_SRC lisp (make-digesting-stream digest &amp;amp;rest args) =&amp;gt; stream #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Make a stream that computes a digest of the data written to it according to the algorithm /digest/. The parameters that can be used by some algorithms can be specified as /args/. [[produce-digest][produce-digest]] may be used to obtain a digest of all the data written to the stream.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Calling [[produce-digest][produce-digest]] on a digest stream does not alter the internal state of the digest.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: with-digesting-stream #+BEGIN_SRC lisp (with-digesting-stream (var digest-name &amp;amp;rest args) &amp;amp;body body) =&amp;gt; digest #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Within /body/, /var/ is bound to a digesting stream for the /digest-name/ algorithm. After all the forms in /body/ have been executed, the digest of the data that has been written to /var/ is returned.&lt;/p&gt; &#xA;&lt;p&gt;** Cipher streams&lt;/p&gt; &#xA;&lt;p&gt;Cipher streams encrypt or decrypt the data written to or read from them according to a specific cipher algorithm.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-encrypting-stream #+BEGIN_SRC lisp (make-encrypting-stream stream cipher mode key &amp;amp;key initialization-vector direction) =&amp;gt; stream #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Make a stream wrapped around the binary stream /stream/ that encrypts data according to the algorithm /cipher/ initialized with a /mode/, a /key/ and an /initialization-vector/. If /direction/ is &lt;del&gt;:input&lt;/del&gt;, the data read from the created input stream is the encryption of the data coming from /stream/. If /direction/ is &lt;del&gt;:output&lt;/del&gt;, the data written to the created output stream is encrypted before being sent to /stream/.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-decrypting-stream #+BEGIN_SRC lisp (make-decrypting-stream stream cipher mode key &amp;amp;key initialization-vector direction) =&amp;gt; stream #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Make a stream wrapped around the binary stream /stream/ that decrypts data according to the algorithm /cipher/ initialized with a /mode/, a /key/ and an /initialization-vector/. If /direction/ is &lt;del&gt;:input&lt;/del&gt;, the data read from the created input stream is the decryption of the data coming from /stream/. If /direction/ is &lt;del&gt;:output&lt;/del&gt;, the data written to the created output stream is decrypted before being sent to /stream/.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Only stream ciphers and block ciphers in CTR, CFB, CFB8 or OFB mode are supported by [[make-encrypting-stream][make-encrypting-stream]] and [[make-decrypting-stream][make-decrypting-stream]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: with-encrypting-stream #+BEGIN_SRC lisp (with-encrypting-stream ((var stream cipher mode key &amp;amp;key initialization-vector direction) &amp;amp;body body)) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Within /body/, /var/ is bound to an encrypting stream. The result of the last form of /body/ is returned.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: with-decrypting-stream #+BEGIN_SRC lisp (with-decrypting-stream ((var stream cipher mode key &amp;amp;key initialization-vector direction) &amp;amp;body body)) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Within /body/, /var/ is bound to a decrypting stream. The result of the last form of /body/ is returned.&lt;/p&gt; &#xA;&lt;p&gt;** MAC streams&lt;/p&gt; &#xA;&lt;p&gt;MAC streams compute a message authentication code of the data written to them according to a specific MAC algorithm.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-authenticating-stream #+BEGIN_SRC lisp (make-authenticating-stream mac key &amp;amp;rest args) =&amp;gt; stream #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Make a stream that computes a MAC of the data written to it according to the algorithm /mac/ initialized with a /key/. The parameters used to create the MAC can be specified as /args/. [[produce-mac][produce-mac]] may be used to obtain a MAC of all the data written to the stream.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Calling [[produce-mac][produce-mac]] on a MAC stream does not alter the internal state of the MAC.&lt;/p&gt; &#xA;&lt;p&gt;Example: encrypt some data and compute a MAC of the ciphertext #+BEGIN_EXAMPLE (let* ((data ...) (output-stream ...) (encryption-key ...) (authentication-key ...) (iv ...) (mac-stream (make-authenticating-stream :hmac authentication-key :sha3)) (stream (make-broadcast-stream output-stream mac-stream)) (cipher-stream (make-encrypting-stream stream :chacha :stream encryption-key :initialization-vector iv))) (write-sequence data cipher-stream) ... (let ((mac (produce-mac mac-stream))) ...)) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: with-authenticating-stream #+BEGIN_SRC lisp (with-authenticating-stream (var mac-name key &amp;amp;rest args) &amp;amp;body body) =&amp;gt; mac #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Within /body/, /var/ is bound to an authenticating stream for the /mac-name/ algorithm. After all the forms in /body/ have been executed, the message authentication code of the data that has been written to /var/ is returned.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Utility functions :PROPERTIES: :CUSTOM_ID: utility-functions :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+NAME: ub-ref-le #+BEGIN_SRC lisp (ub16ref/le vector index) =&amp;gt; value (ub32ref/le vector index) =&amp;gt; value (ub64ref/le vector index) =&amp;gt; value #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This family of functions accesses an unsigned 16-bit, 32-bit or 64-bit value stored in little-endian order starting at /index/ in /vector/. /vector/ must be a &lt;del&gt;(simple-array (unsigned-byte 8) (*))&lt;/del&gt;. These functions are SETFable.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: ub-ref-be #+BEGIN_SRC lisp (ub16ref/be vector index) =&amp;gt; value (ub32ref/be vector index) =&amp;gt; value (ub64ref/be vector index) =&amp;gt; value #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;As the above, only the value is stored in big-endian order.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: array-hex-string #+BEGIN_SRC lisp (byte-array-to-hex-string vector &amp;amp;key start end element-type) =&amp;gt; string (hex-string-to-byte-array string &amp;amp;key start end) =&amp;gt; string (ascii-string-to-byte-array string &amp;amp;key start end) =&amp;gt; vector #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;[[array-hex-string][byte-array-to-hex-string]] converts the bytes of /vector/ between /start/ and /end/ into a hexadecimal string. It is useful for converting digests to a more readable form. /element-type/ indicates the element-type of the returned string.&lt;/p&gt; &#xA;&lt;p&gt;[[array-hex-string][hex-string-to-byte-array]] parses a substring of /string/ delimited /start/ and /end/ of hexadecimal digits into a byte array.&lt;/p&gt; &#xA;&lt;p&gt;[[array-hex-string][ascii-string-to-byte-array]] is provided as a quick and dirty way to convert a string to a byte array suitable for feeding to [[update-digest][update-digest]] or [[encrypt][encrypt]]. Care should be taken to ensure that the provided string is actually an ASCII string. /start/ and /end/ have their usual interpretations.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: octets-integer #+BEGIN_SRC lisp (octets-to-integer octet-vec &amp;amp;key start end big-endian n-bits) =&amp;gt; number (integer-to-octets bignum &amp;amp;key n-bits big-endian) =&amp;gt; vector #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;[[octets-integer][octets-to-integer]] converts the bytes of /octet-vec/ between /start/ and /end/ to an integer as though the bytes denoted a number in base 256. /big-endian/ is a boolean indicating whether the bytes are to be read in big-endian or little-endian order. /n-bits/ specifies how many bits should be considered as significant in the resulting number.&lt;/p&gt; &#xA;&lt;p&gt;[[octets-integer][integer-to-octets]] is the reverse operation.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: expt-mod #+BEGIN_SRC lisp (expt-mod n exponent modulus) =&amp;gt; number (expt-mod/unsafe n exponent modulus) =&amp;gt; number #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Raises /n/ to the /exponent/ power modulo /modulus/ in a more efficient fashion than &lt;del&gt;(mod (expt n exponent) modulus)&lt;/del&gt;. [[expt-mod][expt-mod]] is using the Montgomery ladder algorithm to be more robust against timing attacks. [[expt-mod][expt-mod/unsafe]] runs faster than [[expt-mod][expt-mod]] but is not safe against timing attacks; don&#39;t use it on secret data.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: prime-p #+BEGIN_SRC lisp (prime-p n &amp;amp;optional prng) =&amp;gt; boolean #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;[[prime-p][prime-p]] returns &lt;del&gt;t&lt;/del&gt; if /n/ has a high probability of being a prime number, and &lt;del&gt;nil&lt;/del&gt; if it is a composite number. The probable primality is determined by first doing trial divisions with small primes, then running several Miller-Rabin tests with random bases, and finally doing a Lucas test. The number of Miller-Rabin tests can be configured using the &lt;del&gt;&lt;em&gt;number-of-miller-rabin-tests&lt;/em&gt;&lt;/del&gt; variable. It is 64 by default, which makes the probability of returning &lt;del&gt;t&lt;/del&gt; for a composite number to be at most 1/2^128.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: make-random-salt #+BEGIN_SRC lisp make-random-salt &amp;amp;optional size =&amp;gt; bytes #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Generate a byte vector of /size/ (default 16) random bytes, suitable for use as a password salt.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: constant-time-equal #+BEGIN_SRC lisp constant-time-equal data1 data2 =&amp;gt; boolean #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Check whether the contents of the byte arrays /data1/ and /data2/ are the same. This function runs in constant time (for a given array length) to prevent timing attacks. It can be used to compare passwords or MACs.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Conditions :PROPERTIES: :CUSTOM_ID: conditions :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+NAME: ironclad-error #+BEGIN_SRC lisp ironclad-error #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;All errors signaled by Ironclad are of this type. This type is a direct subtype of &lt;del&gt;simple-error&lt;/del&gt; without any extra slots or options.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: initialization-vector-not-supplied #+BEGIN_SRC lisp initialization-vector-not-supplied #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled by [[make-cipher][make-cipher]] when an initialization vector is not provided and the requested mode requires an initialization vector.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: invalid-initialization-vector #+BEGIN_SRC lisp invalid-initialization-vector #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when an invalid initialization vector is supplied to [[make-cipher][make-cipher]] (e.g. when the length of the initialization vector does not match the block length of the cipher).&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: invalid-key-length #+BEGIN_SRC lisp invalid-key-length #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when the key provided to [[make-cipher][make-cipher]] is not of an acceptable length for the requested cipher.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: unsupported-cipher #+BEGIN_SRC lisp unsupported-cipher #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when the /cipher-name/ provided to [[make-cipher][make-cipher]] is not [[cipher-supported-p][cipher-supported-p]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: unsupported-mode #+BEGIN_SRC lisp unsupported-mode #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when the /mode/ provided to [[make-cipher][make-cipher]] is not /mode-supported-p/.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: unsupported-padding #+BEGIN_SRC lisp unsupported-padding #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when the /padding/ provided to [[make-cipher][make-cipher]] is not supported.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: unsupported-digest #+BEGIN_SRC lisp unsupported-digest #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when the /digest-name/ provided to [[make-digest][make-digest]] is not [[digest-supported-p][digest-supported-p]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: unsupported-mac #+BEGIN_SRC lisp unsupported-mac #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when the /mac-name/ provided to [[make-mac][make-mac]] is not [[mac-supported-p][mac-supported-p]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: insufficient-buffer-space #+BEGIN_SRC lisp insufficient-buffer-space #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when Ironclad needs to stuff some data into a buffer (e.g. when the user provides /digest/ to [[produce-digest][produce-digest]] and there is insufficient space).&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: key-not-supplied #+BEGIN_SRC lisp key-not-supplied #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when a /:key/ argument is not provided to [[make-cipher][make-cipher]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: unsupported-kdf #+BEGIN_SRC lisp unsupported-kdf #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when an invalid KDF name is provided to [[make-kdf][make-kdf]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: unsupported-scrypt-cost-factors #+BEGIN_SRC lisp unsupported-scrypt-cost-factors #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when invalid Scrypt cost factors are provided to [[make-kdf][make-kdf]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: unsupported-argon2-cost-factors #+BEGIN_SRC lisp unsupported-argon2-cost-factors #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when invalid Argon2 parameters are provided to [[make-kdf][make-kdf]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: invalid-padding #+BEGIN_SRC lisp invalid-padding #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when padding in a block is determined to be invalid.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: invalid-mac-parameter #+BEGIN_SRC lisp invalid-mac-parameter #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when an invalid parameter is provided to [[make-mac][make-mac]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: invalid-signature-length #+BEGIN_SRC lisp invalid-signature-length #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when a signature with an invalid length is provided to [[verify-signature][verify-signature]] or [[destructure-signature][destructure-signature]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: invalid-message-length #+BEGIN_SRC lisp invalid-message-length #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when a message with an invalid length is provided to [[encrypt-message][encrypt-message]], [[decrypt-message][decrypt-message]] or [[destructure-message][destructure-message]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: missing-key-parameter #+BEGIN_SRC lisp missing-key-parameter #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when it is determined that a parameter is missing in a call to [[make-public-key][make-public-key]] or [[make-private-key][make-private-key]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: missing-message-parameter #+BEGIN_SRC lisp missing-message-parameter #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when it is determined that a parameter is missing in a call to [[make-message][make-message]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: missing-signature-parameter #+BEGIN_SRC lisp missing-signature-parameter #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when it is determined that a parameter is missing in a call to [[make-signature][make-signature]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: incompatible-keys #+BEGIN_SRC lisp incompatible-keys #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when incompatible keys are provided to [[diffie-hellman][diffie-hellman]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: invalid-curve-point #+BEGIN_SRC lisp invalid-curve-point #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when trying to use an invalid curve point.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: invalid-public-key-length #+BEGIN_SRC lisp invalid-public-key-length #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when a public key with an invalid length is provided to [[verify-signature][verify-signature]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: oaep-decoding-error #+BEGIN_SRC lisp oaep-decoding-error #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when the OAEP decoding of a message fails.&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: unsupported-authenticated-encryption-mode #+BEGIN_SRC lisp unsupported-authenticated-encryption-mode #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when an invalid mode name is provided to [[make-authenticated-encryption-mode][make-authenticated-encryption-mode]].&lt;/p&gt; &#xA;&lt;p&gt;#+NAME: bad-authentication-tag #+BEGIN_SRC lisp bad-authentication-tag #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;This error is signaled when the verification of authenticity of a message fails.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Subsystems (experimental) :PROPERTIES: :CUSTOM_ID: subsystems :END:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Instead of loading the complete Ironclad system, you can load only the subsystems of the algorithms you need.&lt;/p&gt; &#xA;&lt;p&gt;For example if you need only AES and SHA256: #+BEGIN_EXAMPLE (asdf:load-system &#34;ironclad/cipher/aes&#34;) (asdf:load-system &#34;ironclad/digest/sha256&#34;) #+END_EXAMPLE&lt;/p&gt; &#xA;&lt;p&gt;** Available subsystems&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ironclad &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;ironclad/core&lt;/li&gt; &#xA;   &lt;li&gt;ironclad/ciphers &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;ironclad/cipher/aes&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/arcfour&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/aria&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/blowfish&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/camellia&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/cast5&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/chacha&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/des&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/idea&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/kalyna&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/keystream&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/kuznyechik&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/misty1&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/rc2&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/rc5&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/rc6&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/salsa20&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/seed&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/serpent&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/sm4&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/sosemanuk&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/square&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/tea&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/threefish&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/twofish&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/xchacha&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/xor&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/xsalsa20&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/cipher/xtea&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;ironclad/digests &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;ironclad/digest/adler32&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/blake2&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/blake2s&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/crc24&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/crc32&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/groestl&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/jh&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/kupyna&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/md2&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/md4&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/md5&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/ripemd-128&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/ripemd-160&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/sha1&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/sha256&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/sha3&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/sha512&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/skein&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/sm3&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/streebog&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/toger&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/tree-hash&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/digest/whirlpool&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;ironclad/macs &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;ironclad/mac/blake2-mac&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/mac/blake2s-mac&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/mac/cmac&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/mac/gmac&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/mac/hmac&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/mac/poly1305&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/mac/siphash&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/mac/skein-mac&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;ironclad/prngs &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;ironclad/prng/fortuna&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;ironclad/aeads &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;ironclad/aead/eax&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/aead/etm&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/aead/gcm&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;ironclad/kdfs &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;ironclad/kdf/argon2&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/kdf/bcrypt&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/kdf/hmac&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/kdf/password-hash&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/kdf/pkcs5&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/kdf/scrypt&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;ironclad/public-keys &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;ironclad/public-key/curve25519&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/public-key/curve448&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/public-key/dsa&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/public-key/ed25519&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/public-key/ed448&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/public-key/elgamal&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/public-key/rsa&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/public-key/secp256k1&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/public-key/secp256r1&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/public-key/secp384r1&lt;/li&gt; &#xA;     &lt;li&gt;ironclad/public-key/secp521r1&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>