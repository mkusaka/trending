<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-22T01:32:18Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>marcoheisig/Typo</title>
    <updated>2022-11-22T01:32:18Z</updated>
    <id>tag:github.com,2022-11-22:/marcoheisig/Typo</id>
    <link href="https://github.com/marcoheisig/Typo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A portable type inference library for Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: Typo - A portable type inference library for Common Lisp #+AUTHOR: Marco Heisig&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Notable Features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Blazingly fast (approximate) handling of types&lt;/p&gt; &#xA;&lt;p&gt;Typo has its own representation of types, called ntypes. Conversion of type specifiers is fast and mostly non-consing:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (dolist (type &#39;((function) (cons * function) (eql 42) (array bit (1 2 3 * 4)))) (time (loop repeat (expt 10 6) do (type-specifier-ntype type)))) ;;; Evaluation took: ;;; 0.031 seconds of real time ;;; 0 bytes consed ;;; ;;; Evaluation took: ;;; 0.059 seconds of real time ;;; 0 bytes consed ;;; ;;; Evaluation took: ;;; 0.155 seconds of real time ;;; 0 bytes consed ;;; ;;; Evaluation took: ;;; 0.539 seconds of real time ;;; 0 bytes consed #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Also, reasoning about ntypes is much faster than reasoning about type specifiers. The only downside is that both the conversion from type specifiers to ntypes and most operations on ntypes aren&#39;t always precise. Each function that may or may not be precise will return a second value that is true when its result is precise, and false if it isn&#39;t.&lt;/p&gt; &#xA;&lt;p&gt;** Handles almost all functions in the Common Lisp package&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (infer-ntypes &#39;+ (list (type-specifier-ntype &#39;(complex single-float)) (type-specifier-ntype &#39;integer) (type-specifier-ntype &#39;double-float))) ;; =&amp;gt; (#&amp;lt;TYPO.NTYPE::PRIMITIVE-NTYPE (COMPLEX DOUBLE-FLOAT)&amp;gt;) ;; =&amp;gt; NIL ;; =&amp;gt; NIL&lt;/p&gt; &#xA;&lt;p&gt;(infer-ntypes &#39;apply (list (type-specifier-ntype &#39;(eql coerce)) (type-specifier-ntype &#39;integer) (type-specifier-ntype &#39;(eql single-float)) (type-specifier-ntype &#39;null))) ;; =&amp;gt; (#&amp;lt;TYPO.NTYPE::PRIMITIVE-NTYPE SINGLE-FLOAT&amp;gt;) ;; =&amp;gt; NIL ;; =&amp;gt; NIL #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;** Extensible&lt;/p&gt; &#xA;&lt;p&gt;Typo uses a convenient syntax for specifying function information, by means of the =define-fndb-record= macro. This way, programmers can describe how a particular function can be specialized or differentiated, or whether it can be subjected to constant folding. Fore example, here is the function information for the function =cl:cos=:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (define-fndb-record cos (x) (:properties :foldable :movable) (:differentiator _ (wrap (- (sin x)))) (:specializer (ntype-subtypecase (wrapper-ntype x) ((not number) (abort-specialization)) (short-float (wrap (short-float-cos x))) (single-float (wrap (single-float-cos x))) (double-float (wrap (double-float-cos x))) (long-float (wrap (long-float-cos x))) (complex-short-float (wrap (complex-short-float-cos x))) (complex-single-float (wrap (complex-single-float-cos x))) (complex-double-float (wrap (complex-double-float-cos x))) (complex-long-float (wrap (complex-long-float-cos x))) (t (wrap-default (type-specifier-ntype &#39;number)))))) #+END_SRC&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bonus Features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Function Specialization The cool thing about Typo is that it can (portably!) convert s-expressions to the most applicable specialized version applicable to its target types. For example, it can replace&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (cl:+ a b c) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;where a is an integer, b is a double-float, and c is a single-float with&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (typo:two-arg-double-float+ (typo:coerce-to-double-float a) (typo:two-arg-double-float+ b (typo:double-float-from-short-float c))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;The inferface for this machinery is the function =typo:specialize=. The call to generate the example would be&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (typo:specialize #&#39;cl:+ (list (list &#39;a (list (typo:type-specifier-ntype &#39;integer)) nil nil) (list &#39;b (list (typo:type-specifier-ntype &#39;double-float)) nil nil) (list &#39;c (list (typo:type-specifier-ntype &#39;single-float)) nil nil)) :wrap-constant (lambda (x) (list x (list (typo:ntype-of x)) nil nil)) :wrap-function (lambda (fnrecord wrappers required optional rest) (list `(,(typo:fnrecord-name fnrecord) ,@(mapcar #&#39;first wrappers)) required optional rest)) :wrapper-nth-value-ntype (lambda (index wrapper) (destructuring-bind (form required optional rest) wrapper (declare (ignore form)) (let ((n-required (length required))) (if (&amp;lt; index n-required) (nth index required) (let ((n-optional (length optional))) (if (&amp;lt; index (+ n-required n-optional)) (nth (- index n-required) optional) (if (null rest) (typo:type-specifier-ntype &#39;null) rest)))))))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;** Automatic Differentiation&lt;/p&gt; &#xA;&lt;p&gt;Typo can also compute expressions for computing the derivative of a supplied function with respect to a particular argument. The inferface for this machinery is the function =typo:differentiate=.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;FAQ ** What&#39;s the difference betwen NTYPE from this implementation and &lt;a href=&#34;https://github.com/s-expressionists/ctype&#34;&gt;https://github.com/s-expressionists/ctype&lt;/a&gt;?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;CTYPE is a full-fledged, precise implementation of CL types, with its own versions of typep and subtypep. It requires some amount of implementation specific hooks to be useful.&lt;/p&gt; &#xA;&lt;p&gt;NTYPE is only does approximate reasoning about types, but is really fast and doesn&#39;t cons. It relies on the host&#39;s versions of typep and subtypep to do the heavy lifting. But it is faster (which matters for Petalisp), and fully portable. The main goal of NTYPE is to narrow down the type of each value in a program enough to choose a specialized representation.&lt;/p&gt; &#xA;&lt;p&gt;So the main difference between NTYPE and CTYPE is that the former is mostly about fast type inference and not so much about answering type queries.&lt;/p&gt;</summary>
  </entry>
</feed>