<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-10T01:32:43Z</updated>
  <subtitle>Daily Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bohonghuang/cffi-ops</title>
    <updated>2023-06-10T01:32:43Z</updated>
    <id>tag:github.com,2023-06-10:/bohonghuang/cffi-ops</id>
    <link href="https://github.com/bohonghuang/cffi-ops" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library that helps write concise CFFI-related code.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: cffi-ops Write CFFI stuff quickly without runtime overhead.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Introduction CFFI is powerful, but using its API to write C-style code can sometimes be cumbersome because it requires you to repeatedly pass in types, unlike the dot operator in C that has some type inference capabilities.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This library provides CFFI with dot operator-like functionality at compile time, allowing you to write CFFI-related code as simple as C with just a small amount of FFI type declarations.&lt;/p&gt; &#xA;&lt;p&gt;This library has been tested to work on SBCL, CCL, ECL, ABCL, and CLISP, and theoretically is portable across implementations that provide &lt;del&gt;macroexpand-all&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Rules Here is a comparison table between C syntax:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;| C | &lt;del&gt;cffi-ops&lt;/del&gt; | |--------------------------+--------------------------------------------------------------------------------| | &lt;del&gt;x-&amp;gt;y.z&lt;/del&gt; or &lt;del&gt;x-&amp;gt;y-&amp;gt;z&lt;/del&gt; | &lt;del&gt;(-&amp;gt; x y z)&lt;/del&gt; (Note that &lt;del&gt;x&lt;/del&gt;, &lt;del&gt;y&lt;/del&gt;, and &lt;del&gt;z&lt;/del&gt; must be the same symbols used in &lt;del&gt;defcstruct&lt;/del&gt;) | | &lt;del&gt;&amp;amp;x.y&lt;/del&gt; | &lt;del&gt;(&amp;amp; (-&amp;gt; x y))&lt;/del&gt; | | &lt;del&gt;*x&lt;/del&gt; | &lt;del&gt;([] x)&lt;/del&gt; | | &lt;del&gt;x[n]&lt;/del&gt; | &lt;del&gt;([] x n)&lt;/del&gt; | | &lt;del&gt;x.y = z&lt;/del&gt; | &lt;del&gt;(setf (-&amp;gt; x y) z)&lt;/del&gt; if &lt;del&gt;z&lt;/del&gt; is a variable | | | &lt;del&gt;(csetf (-&amp;gt; x y) z)&lt;/del&gt; if &lt;del&gt;z&lt;/del&gt; is a CFFI pointer | | &lt;del&gt;A _a, *a = &amp;amp;_a&lt;/del&gt; | &lt;del&gt;(clet ((a (:struct A))) ...)&lt;/del&gt; | | &lt;del&gt;A *a = malloc(sizeof(A))&lt;/del&gt; | &lt;del&gt;(clet ((a (cffi:foreign-alloc &#39;(:struct A)))) ...)&lt;/del&gt; | | &lt;del&gt;A _a = *b, *a = &amp;amp;_a&lt;/del&gt; | &lt;del&gt;(clet ((a ([] b))) ...)&lt;/del&gt; | | &lt;del&gt;A *a = b&lt;/del&gt; | &lt;del&gt;(clet ((a b)) ...)&lt;/del&gt; |&lt;/p&gt; &#xA;&lt;p&gt;Please note that since it is not possible to directly manipulate C compound types in Lisp, binding and assignment of composite types require the use of &lt;del&gt;clet&lt;/del&gt; (or &lt;del&gt;clet*&lt;/del&gt;) and &lt;del&gt;csetf&lt;/del&gt;, which bind and operate on variables that are CFFI pointers.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example For the following C code:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_SRC c #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;assert.h&amp;gt;&lt;/p&gt; &#xA;&lt;p&gt;typedef struct { float x; float y; float z; } Vector3;&lt;/p&gt; &#xA;&lt;p&gt;typedef struct { Vector3 v1; Vector3 v2; Vector3 v3;&lt;br&gt; } Matrix3;&lt;/p&gt; &#xA;&lt;p&gt;void Vector3Add(Vector3 *output, const Vector3 *v1, const Vector3 *v2) { output-&amp;gt;x = v1-&amp;gt;x + v2-&amp;gt;x; output-&amp;gt;y = v1-&amp;gt;y + v2-&amp;gt;y; output-&amp;gt;z = v1-&amp;gt;z + v2-&amp;gt;z; }&lt;/p&gt; &#xA;&lt;p&gt;int main(int argc, char *argv[]) { Matrix3 m1[3]; m1[0].v1.x = 1.0; m1[0].v1.y = 2.0; m1[0].v1.z = 3.0; Matrix3 m2 = *m1; Vector3 *v1 = &amp;amp;m2.v1; Vector3 *v2 = malloc(sizeof(Vector3)); ,*v2 = *v1; v2-&amp;gt;x = 3.0; v2-&amp;gt;z = 1.0; Vector3Add(v1, v1, v2); assert(v1-&amp;gt;x == 4.0); assert(v1-&amp;gt;y == 4.0); assert(v1-&amp;gt;z == 4.0); free(v2); return 0; } #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;The equivalent Lisp code (written using &lt;del&gt;cffi-ops&lt;/del&gt;) is:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (defpackage cffi-ops-example (:use #:cl #:cffi #:cffi-ops))&lt;/p&gt; &#xA;&lt;p&gt;(in-package #:cffi-ops-example)&lt;/p&gt; &#xA;&lt;p&gt;(defcstruct vector3 (x :float) (y :float) (z :float))&lt;/p&gt; &#xA;&lt;p&gt;(defcstruct matrix3 (v1 (:struct vector3)) (v2 (:struct vector3)) (v3 (:struct vector3)))&lt;/p&gt; &#xA;&lt;p&gt;(defun vector3-add (output v1 v2) (clocally (declare (ctype (:pointer (:struct vector3)) output v1 v2)) (setf (-&amp;gt; output x) (+ (-&amp;gt; v1 x) (-&amp;gt; v2 x)) (-&amp;gt; output y) (+ (-&amp;gt; v1 y) (-&amp;gt; v2 y)) (-&amp;gt; output z) (+ (-&amp;gt; v1 z) (-&amp;gt; v2 z)))))&lt;/p&gt; &#xA;&lt;p&gt;(defun main () (clet ((m1 (:array (:struct matrix3) 3))) (setf (-&amp;gt; ([] m1 0) v1 x) 1.0 (-&amp;gt; ([] m1 0) v1 y) 2.0 (-&amp;gt; ([] m1 0) v1 z) 3.0) (clet* ((m2 ([] m1)) (v1 (&amp;amp; (-&amp;gt; m2 v1))) (v2 (foreign-alloc &#39;(:struct vector3)))) (csetf ([] v2) ([] v1)) (setf (-&amp;gt; v2 x) 3.0 (-&amp;gt; v2 z) 1.0) (vector3-add v1 v1 v2) (assert (= (-&amp;gt; v1 x) 4.0)) (assert (= (-&amp;gt; v1 y) 4.0)) (assert (= (-&amp;gt; v1 z) 4.0)) (foreign-free v2)))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;And the equivalent Lisp code (written without using &lt;del&gt;cffi-ops&lt;/del&gt;) is:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (defpackage cffi-example (:use #:cl #:cffi))&lt;/p&gt; &#xA;&lt;p&gt;(in-package #:cffi-example)&lt;/p&gt; &#xA;&lt;p&gt;(defcstruct vector3 (x :float) (y :float) (z :float))&lt;/p&gt; &#xA;&lt;p&gt;(defcstruct matrix3 (v1 (:struct vector3)) (v2 (:struct vector3)) (v3 (:struct vector3)))&lt;/p&gt; &#xA;&lt;p&gt;(declaim (inline memcpy)) (defcfun &#34;memcpy&#34; :void (dest :pointer) (src :pointer) (n :size))&lt;/p&gt; &#xA;&lt;p&gt;(defun vector3-add (output v1 v2) (with-foreign-slots (((xout x) (yout y) (zout z)) output (:struct vector3)) (with-foreign-slots (((x1 x) (y1 y) (z1 z)) v1 (:struct vector3)) (with-foreign-slots (((x2 x) (y2 y) (z2 z)) v2 (:struct vector3)) (setf xout (+ x1 x2) yout (+ y1 y2) zout (+ z1 z2))))))&lt;/p&gt; &#xA;&lt;p&gt;(defun main () (with-foreign-object (m1 &#39;(:struct matrix3) 3) (with-foreign-slots ((x y z) (foreign-slot-pointer (mem-aptr m1 &#39;(:struct matrix3) 0) &#39;(:struct matrix3) &#39;v1) (:struct vector3)) (setf x 1.0 y 2.0 z 3.0)) (with-foreign-object (m2 &#39;(:struct matrix3)) (memcpy m2 m1 (foreign-type-size &#39;(:struct matrix3))) (let ((v1 (foreign-slot-pointer m2 &#39;(:struct matrix3) &#39;v1)) (v2 (foreign-alloc &#39;(:struct vector3)))) (memcpy v2 v1 (foreign-type-size &#39;(:struct vector3))) (with-foreign-slots ((x z) v2 (:struct vector3)) (setf x 3.0 z 1.0)) (vector3-add v1 v1 v2) (with-foreign-slots ((x y z) v1 (:struct vector3)) (assert (= x 4.0)) (assert (= y 4.0)) (assert (= z 4.0))) (foreign-free v2))))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Both of them should generate almost equivalent machine code in SBCL and have very similar performance.&lt;/p&gt;</summary>
  </entry>
</feed>