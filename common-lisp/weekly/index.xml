<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-25T01:39:20Z</updated>
  <subtitle>Weekly Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sellout/NCLB</title>
    <updated>2022-12-25T01:39:20Z</updated>
    <id>tag:github.com,2022-12-25:/sellout/NCLB</id>
    <link href="https://github.com/sellout/NCLB" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A new(?) and simple kind of literate programming system.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;p&gt;This is &lt;em&gt;NCLB&lt;/em&gt; (No Coder Left Behind), a literate programming system. It is less like &lt;em&gt;CWEB&lt;/em&gt; than anything I&#39;ve seen. The &lt;em&gt;CWEB&lt;/em&gt; manual says “[w]riting CWEB programs is something like writing TEX documents, but with an additional ‘C mode’ that is added to TEX’s horizontal mode, vertical mode, and math mode.” In contrast, &lt;em&gt;NCLB&lt;/em&gt; removes the idea of a “web” and all files are either valid documentation files or valid code files, with the operations &lt;code&gt;tangle&lt;/code&gt; and &lt;code&gt;weave&lt;/code&gt; simply converting one to the other. In a code file, the documentation is contained in specially-marked comments and in a documentation file, the code is in designated code sections. There are a few reasons for this:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;with the documentation in comments, there is no need for the &lt;code&gt;tangle&lt;/code&gt; operation, since the original file is executable (this is especially useful for interpreted and interactive languages, where &lt;code&gt;tangle&lt;/code&gt; can not easily be hidden inside some existing build process);&lt;/li&gt; &#xA; &lt;li&gt;code that is written in a literate style does not need to be handled differently from code written without literate sections; and&lt;/li&gt; &#xA; &lt;li&gt;literate programming, in practice, is mostly used for things like tutorials, manuals, and books, with most other code having little or no use for it.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To dive more into that third point, it has become apparent that over-documenting code (although a noble attempt to explain things) invariably results in documentation that does not describe the code. There are of course still comments, but they are never written in a literate style. Part of the goal with this system is to encourage all developer documentation to be written in a literate style by removing a few of the friction points that prevent developers from using most literate systems:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;all users are required to install your literate toolset in addition to the usual language toolset,&lt;/li&gt; &#xA; &lt;li&gt;LaTeχ can be hard to read in source format – for those users who don’t or can’t weave the web into a document (especially when the LaTeχ sections are little more than short comments), and&lt;/li&gt; &#xA; &lt;li&gt;managing sections requires a new set of syntaxes and ones that are more verbose than commenting usually is.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Point two is addressed by using Markdown &lt;em&gt;by default&lt;/em&gt; instead of LaTeχ. LaTeχ is useful when writing a book, but less so for Web tutorials or comments. If you are going to add the verbosity of LaTeχ, adding &lt;code&gt;;@latex&lt;/code&gt; to your file should hardly be an obstacle.&lt;/p&gt; &#xA;&lt;p&gt;The one tradeoff that occurs to me with this approach is that macros can not rearrange code, since there is no tangling process. The code needs to be written in an order the compiler can process. However, macros can rearrange sections during the weaving process, so it is hopefully not too big of a problem to overcome.&lt;/p&gt; &#xA;&lt;!-- merge this in somewhere earlier --&gt; &#xA;&lt;p&gt;Literate programming is useful to people who are reading the code – either developers working on it or users learning from it. In the former case, less is better, because those who change the code often ignore the docs while those who try to understand the system often ignore the code – if the two aren&#39;t in sync, trouble brews.&lt;/p&gt; &#xA;&lt;p&gt;Documentation for users of a system belong in a combination of docstrings and literate tutorials &amp;amp; test cases. E.g., this literate document is part of a tutorial on &lt;em&gt;NCLB&lt;/em&gt;, not part of the &lt;em&gt;NCLB&lt;/em&gt; source code. Tutorials and the like benefit from literate programming because the code sections can be compiled and tested and the text sections will be consumed as the primary content and potentially checked by editors.&lt;/p&gt; &#xA;&lt;p&gt;Okay, so there &lt;em&gt;is&lt;/em&gt; a &lt;code&gt;tangle&lt;/code&gt;, but it’s not used on the same original file. &lt;code&gt;tangle&lt;/code&gt; converts valid documentation to valid code. There is still no “web” file, there are only code and documentation files. &lt;code&gt;weave&lt;/code&gt; converts from code to documentation and &lt;code&gt;tangle&lt;/code&gt; converts from documentation to code. At least in their current state, they are not isomorphic, but it does seem desirable that&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tangle(weave(x)) = x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, there is some normalization that happens, so it is better to expect&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tangle(weave(tangle(x))) = tangle(x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to compensate for that.&lt;/p&gt; &#xA;&lt;p&gt;I lied about there being no “web” file, but you use them very rarely. They are used for document files that aggregate other files in cases where the document format doesn’t support inlining subdocuments. IE, Markdown needs a web file for aggregating, but LaTeχ does not.&lt;/p&gt; &#xA;&lt;p&gt;The syntax is very simple – it uses the same formatting as the subdocuments, with an added &lt;code&gt;&amp;lt;&amp;lt;foo/bar.md&amp;gt;&amp;gt;&lt;/code&gt; syntax to include a file at a particular location. With LaTeχ, you would use &lt;code&gt;\input{foo/bar.tex}&lt;/code&gt; or &lt;code&gt;\include{foo/bar.tex}&lt;/code&gt; as appropriate, so no web file is necessary there. Even in formats like Markdown, I would recommend using links instead of embedding when possible.&lt;/p&gt; &#xA;&lt;p&gt;In fact, this file is generated from a web file, so it can pull in documentation from across the system to make a comprehensive README. The reasons for this are&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/&#34;&gt;Github&lt;/a&gt;’s README processing breaks relative links and&lt;/li&gt; &#xA; &lt;li&gt;it avoids having to keep generated versions of all files in the repo, just to have the README work.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Please also check out &lt;a href=&#34;https://raw.githubusercontent.com/sellout/NCLB/master/tutorial/tutorial.md&#34;&gt;the tutorial&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>