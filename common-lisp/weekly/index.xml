<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-01-19T01:38:03Z</updated>
  <subtitle>Weekly Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ruricolist/spinneret</title>
    <updated>2025-01-19T01:38:03Z</updated>
    <id>tag:github.com,2025-01-19:/ruricolist/spinneret</id>
    <link href="https://github.com/ruricolist/spinneret" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Common Lisp HTML5 generator&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#spinneret&#34;&gt;Spinneret&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#printing-style&#34;&gt;Printing style&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#inserted-spaces&#34;&gt;Inserted spaces&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#line-wrapping&#34;&gt;Line wrapping&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#syntax&#34;&gt;Syntax&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#dynamic-output&#34;&gt;Dynamic output&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#interpreting-trees&#34;&gt;Interpreting trees&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#markdown&#34;&gt;Markdown&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#get-html-path&#34;&gt;&lt;code&gt;get-html-path&lt;/code&gt;&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#html-path&#34;&gt;&lt;code&gt;*html-path*&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#deftag&#34;&gt;&lt;code&gt;deftag&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#parenscript&#34;&gt;Parenscript&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ruricolist/spinneret/master/#validation&#34;&gt;Validation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdown-toc end --&gt; &#xA;&lt;h1&gt;Spinneret&lt;/h1&gt; &#xA;&lt;p&gt;In the crowded space of Common Lisp HTML generators, Spinneret occupies the following coordinates:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Modern. Targets HTML5. Does not treat XML and HTML as the same problem. Assumes you will be serving your documents as UTF-8.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Composable. Makes it easy to refactor HTML generation into separate functions and macros.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Pretty. Treats HTML as a document format, not a serialization. Output is idiomatic and readable, following the coding style of the HTML5 specification.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Aggressive. If something can be interpreted as HTML, then it will be, meaning that some Lisp forms can&#39;t be mixed with HTML syntax. In the trade-off between 90% convenience and 10% correctness Spinneret is on the side of convenience.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Bilingual. Spinneret (after loading &lt;code&gt;spinneret/ps&lt;/code&gt;) has the same semantics in Lisp and &lt;a href=&#34;https://parenscript.common-lisp.dev/&#34;&gt;Parenscript&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;HTML generation with Spinneret looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;     (in-package #:spinneret)&#xA;&#xA;     (defparameter *shopping-list*&#xA;       &#39;(&#34;Atmospheric ponds&#34;&#xA;         &#34;Electric gumption socks&#34;&#xA;         &#34;Mrs. Leland&#39;s embyronic television combustion&#34;&#xA;         &#34;Savage gymnatic aggressors&#34;&#xA;         &#34;Pharmaceutical pianos&#34;&#xA;         &#34;Intravenous retribution champions&#34;))&#xA;&#xA;     (defparameter *user-name* &#34;John Q. Lisper&#34;)&#xA;&#xA;     (defparameter *last-login* &#34;12th Never&#34;)&#xA;&#xA;     (defmacro with-page ((&amp;amp;key title) &amp;amp;body body)&#xA;       `(with-html&#xA;          (:doctype)&#xA;          (:html&#xA;            (:head&#xA;             (:title ,title))&#xA;            (:body ,@body))))&#xA;&#xA;     (defun shopping-list ()&#xA;       (with-page (:title &#34;Home page&#34;)&#xA;         (:header&#xA;          (:h1 &#34;Home page&#34;))&#xA;         (:section&#xA;          (&#34;~A, here is *your* shopping list: &#34; *user-name*)&#xA;          (:ol (dolist (item *shopping-list*)&#xA;                 (:li (1+ (random 10)) item))))&#xA;         (:footer (&#34;Last login: ~A&#34; *last-login*))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which produces:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;     &amp;lt;!DOCTYPE html&amp;gt;&#xA;     &amp;lt;html lang=en&amp;gt;&#xA;      &amp;lt;head&amp;gt;&#xA;       &amp;lt;meta charset=UTF-8&amp;gt;&#xA;       &amp;lt;title&amp;gt;Home page&amp;lt;/title&amp;gt;&#xA;      &amp;lt;/head&amp;gt;&#xA;      &amp;lt;body&amp;gt;&#xA;       &amp;lt;header&amp;gt;&#xA;        &amp;lt;h1&amp;gt;Home page&amp;lt;/h1&amp;gt;&#xA;       &amp;lt;/header&amp;gt;&#xA;       &amp;lt;section&amp;gt;&#xA;        John Q. Lisper, here is &amp;lt;em&amp;gt;your&amp;lt;/em&amp;gt; shopping list:&#xA;        &amp;lt;ol&amp;gt;&#xA;         &amp;lt;li&amp;gt;10 Atmospheric ponds&#xA;         &amp;lt;li&amp;gt;6 Electric gumption socks&#xA;         &amp;lt;li&amp;gt;4 Mrs. Leland&#39;s embyronic television combustion&#xA;         &amp;lt;li&amp;gt;9 Savage gymnatic aggressors&#xA;         &amp;lt;li&amp;gt;6 Pharmaceutical pianos&#xA;         &amp;lt;li&amp;gt;9 Intravenous retribution champions&#xA;        &amp;lt;/ol&amp;gt;&#xA;       &amp;lt;/section&amp;gt;&#xA;       &amp;lt;footer&amp;gt;&#xA;        Last login: 12th Never&#xA;       &amp;lt;/footer&amp;gt;&#xA;      &amp;lt;/body&amp;gt;&#xA;     &amp;lt;/html&amp;gt;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Pretty-printing is pretty fast, but Spinneret obeys &lt;code&gt;*print-pretty*&lt;/code&gt; should you want to turn it off.)&lt;/p&gt; &#xA;&lt;h3&gt;Printing style&lt;/h3&gt; &#xA;&lt;p&gt;Spinneret tries hard to produce human-writable output – output that looks like a human being wrote it. Sometimes, however, you may have markup to render that there is no human-writable way to render, because no human being would ever write it.&lt;/p&gt; &#xA;&lt;p&gt;In these cases you can set or bind the &lt;code&gt;*html-style*&lt;/code&gt; variable to control Spinneret’s print style. The default is &lt;code&gt;:human&lt;/code&gt;, which means to attempt to produce human-writable output. It can also be set to &lt;code&gt;:tree&lt;/code&gt;, which simply prints every element as if it were a block element, and every run of text on a new line.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (let ((*html-style* :human))&#xA;      (with-html&#xA;        (:div&#xA;          (:p &#34;Text &#34; (:a &#34;link text&#34;) &#34; more text&#34;))))&#xA;    =&amp;gt; &amp;lt;div&amp;gt;&#xA;        &amp;lt;p&amp;gt;Text &amp;lt;a&amp;gt;link text&amp;lt;/a&amp;gt; more text&#xA;       &amp;lt;/div&amp;gt;&#34;&#xA;&#xA;    (let ((*html-style* :tree))&#xA;      (with-html-string&#xA;        (:div&#xA;          (:p &#34;Text &#34; (:a &#34;link text&#34;) &#34; more text&#34;))))&#xA;    =&amp;gt; &amp;lt;div&amp;gt;&#xA;        &amp;lt;p&amp;gt;&#xA;         Text&#xA;         &amp;lt;a&amp;gt;&#xA;          link text&#xA;         &amp;lt;/a&amp;gt;&#xA;          more text&#xA;        &amp;lt;/p&amp;gt;&#xA;       &amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;code&gt;*html-style*&lt;/code&gt; bound to &lt;code&gt;:tree&lt;/code&gt;, and &lt;code&gt;*print-pretty*&lt;/code&gt; bound to nil, output is verbose but predictable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (let ((*html-style* :tree)&#xA;          (*print-pretty* nil))&#xA;      (with-html-string&#xA;        (:div&#xA;          (:p &#34;Text &#34; (:a &#34;link text&#34;) &#34; more text&#34;))))&#xA;    =&amp;gt; &#34;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;Text &amp;lt;a&amp;gt;link text&amp;lt;/a&amp;gt;  more text&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that binding &lt;code&gt;*html-style*&lt;/code&gt; to &lt;code&gt;:tree&lt;/code&gt; ensures that all tags are closed.&lt;/p&gt; &#xA;&lt;h3&gt;Inserted spaces&lt;/h3&gt; &#xA;&lt;p&gt;By default, when objects are output to HTML, spaces are inserted betweeen them. This is nearly always the right thing to do, but in some special cases, the spaces may be a problem. They can be turned off by setting the flag &lt;code&gt;*suppress-inserted-spaces*&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Line wrapping&lt;/h3&gt; &#xA;&lt;p&gt;When pretty-printing, Spinneret makes the best decisions about line wrapping that it can, given the information it has about how to get the print length of various types. But, in the case of user-defined types, it has no way to tell in advance how long they will be when printed. If you find Spinneret is making bad line-breaking decisions with your types, you can help it out by specializing &lt;code&gt;html-length&lt;/code&gt;. For example, if you use PURI, you could help Spinneret pretty-print PURI URIs by teaching it how to get their length:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (defmethod html-length ((uri puri:uri))&#xA;      ;; Doesn&#39;t cons.&#xA;      (length (puri:render-uri uri nil)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Syntax&lt;/h2&gt; &#xA;&lt;p&gt;The rules for WITH-HTML are these:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;All generated forms write to &lt;code&gt;*html*&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A keyword in function position is interpreted as a tag name. If the name is not valid as a tag, it is ignored.&lt;/p&gt; &lt;p&gt;Certain keywords are recognized as pseudo-tags and given special treatment:&lt;/p&gt; &lt;p&gt;:RAW :DOCTYPE :!DOCTYPE :CDATA :!-- :COMMENT :HTML :HEAD :H* :TAG&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;The pseudotag :RAW can be used to bypass Spinneret’s implicit escaping for raw output. This allows inserting HTML literals, and bypasses pretty printing.&lt;/p&gt; &lt;p&gt;Note that you need :RAW for inline stylesheets and scripts, otherwise angle brackets will be escaped as if they were HTML:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(with-html-string (:style &#34;a &amp;gt; p{color: white;}&#34;))&#xA;=&amp;gt; &#34;&amp;lt;style&amp;gt;a &amp;amp;gt; p{color: white;}&amp;lt;/style&amp;gt;&#34;&#xA;&#xA;(with-html-string (:style (:raw &#34;a &amp;gt; p{color: white;}&#34;)))&#xA;=&amp;gt; &#34;&amp;lt;style&amp;gt;a &amp;gt; p{color: white;}&amp;lt;/style&amp;gt;&#34;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;The pseudotags :!– and :COMMENT insert comments into the output.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;The pseudotag :H* renders as one of :H1 through :H6 depending on how many :SECTION elements it is dynamically nested inside. At the top level, :H* is equivalent to :H1. Inside the dynamic extent of one :SECTION tag, it is equivalent to :H2; inside two section tags, it is equivalent to :H3; and so forth up to :H6.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;The pseudotag :TAG allows dynamic selection of a tag.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;The value of the LANG attribute of HTML is controlled by &lt;code&gt;*html-lang*&lt;/code&gt;; the value of the meta charset attribute is controlled by &lt;code&gt;*html-charset*&lt;/code&gt;. These are defaults; passing an explicit attribute takes precedence.&lt;/p&gt; &lt;p&gt;Constant classes and ids can be specified with a selector-like syntax. E.g.:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;        (:div#wrapper (:div.section ...))&#xA;        ≡ (:div :id &#34;wrapper&#34; (:div :class &#34;section&#34; ...))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Keyword-value pairs following a tag are interpreted as attributes. HTML syntax may not be used in attribute values. Attributes with nil values are omitted from the output. Boolean attributes with non-nil values are minimized.&lt;/p&gt; &lt;p&gt;Duplicate attributes are handled like duplicate keyword arguments: all values are evaluated, but only the leftmost value is used. The exception is the handling of tokenized attributes, such as :CLASS or :REL. The class of a tag is the union of all its :CLASS arguments.&lt;/p&gt; &lt;p&gt;The argument :DATASET introduces a list of :DATA-FOO arguments:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;        (:p :dataset (:duck (dolomphious) :fish &#39;fizzgigious&#xA;                            :spoon &#34;runcible&#34;))&#xA;        ≡ (:p :data-duck (dolomphious) :data-fish &#39;fizzgigious&#xA;              :data-spoon &#34;runcible&#34;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For flexibility, even at the cost of efficiency, the argument :ATTRS introduces a form to evaluate at run time for a plist of extra attributes and values.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Forms after the attributes are treated as arguments. Each non-nil (primary) value returned by an argument to a tag is written to the stream by HTML, a generic function on which you can define your own methods. By default only literal arguments are printed. Literal arguments are strings, characters, numbers and symbols beside NIL.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;WITH-HTML-STRING is like WITH-HTML, but intercepts the generated HTML at run time and returns a string.&lt;/p&gt; &#xA;&lt;h3&gt;Dynamic output&lt;/h3&gt; &#xA;&lt;p&gt;For flexibility, even at the cost of efficiency, the pseudo-attribute :ATTRS introduces a form to evaluate at run time for a plist of extra attributes and values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (:p :attrs (list :id &#34;dynamic!&#34;))&#xA;    =&amp;gt; &amp;lt;p id=&#34;dynamic!&#34;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, the pseudo-tag :TAG allows you to select a tag at run time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (:tag :name &#34;div&#34;&#xA;     (:tag :name &#34;p&#34;&#xA;      (:tag :name &#34;span&#34;&#xA;        &#34;Hello.&#34;)))&#xA;    ≡ (:div (:p (:span &#34;Hello&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that :TAG only allows you to &lt;em&gt;select&lt;/em&gt; a tag, not &lt;em&gt;create&lt;/em&gt; one. The tag must still be one that is known to Spinneret to be valid. (That is, either defined as part of HTML or matching the requirements for a custom element.)&lt;/p&gt; &#xA;&lt;p&gt;For maximum dynamicity, you can combine :TAG and :ATTRS:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (:tag :name &#34;div&#34; :attrs (list :id &#34;dynamic!&#34;))&#xA;    =&amp;gt; &amp;lt;div id=dynamic!&amp;gt;&amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Interpreting trees&lt;/h3&gt; &#xA;&lt;p&gt;For the &lt;em&gt;ne plus ultra&lt;/em&gt; of flexibility, you can interpret trees at runtime using a subset of Spinneret syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (interpret-html-tree `(:div :id &#34;dynamic!&#34;))&#xA;    =&amp;gt; &amp;lt;div id=dynamic!&amp;gt;&amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The interpreter is still under development; it supports most but not yet all Spinneret syntax.&lt;/p&gt; &#xA;&lt;h3&gt;Markdown&lt;/h3&gt; &#xA;&lt;p&gt;If the additional system &lt;code&gt;spinneret/cl-markdown&lt;/code&gt; is loaded, then a string in function position is first compiled as Markdown (using &lt;a href=&#34;https://github.com/gwkkwg/cl-markdown&#34;&gt;CL-MARKDOWN&lt;/a&gt;), then passed to &lt;code&gt;format&lt;/code&gt; as a control string and applied to its arguments.&lt;/p&gt; &#xA;&lt;p&gt;This is useful for inline formatting, like links, where sexps would be clumsy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (with-html&#xA;     (&#34;Here is some copy, with [a link](~a)&#34; link))&#xA;&#xA;    (with-html&#xA;      (:span &#34;Here is some copy, with &#34;&#xA;        (:a :href link &#34;a link.&#34;)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;get-html-path&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes it is useful for a piece of HTML-generating code to know where in the document it appears. You might, for example, want to define a &lt;code&gt;tabulate&lt;/code&gt; function that prints list-of-lists as rows of cells, but only prints the surrounding &lt;code&gt;&amp;lt;table&amp;gt;&amp;lt;/table&amp;gt;&lt;/code&gt; if it is not already within a table. The function &lt;code&gt;get-html-path&lt;/code&gt; returns a list of open tags, from latest to earliest. Usually it will look something like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;      (get-html-path) ;-&amp;gt; &#39;(:table :section :body :html)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Thus `tabulate&#39; could be written&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;     (defun tabulate (&amp;amp;rest rows)&#xA;       (with-html&#xA;         (flet ((tabulate ()&#xA;                  (loop for row in rows do&#xA;                    (:tr (loop for cell in row do&#xA;                      (:td cell))))))&#xA;           (if (find :table (get-html-path))&#xA;               (tabulate)&#xA;               (:table (:tbody (tabulate)))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;get-html-path&lt;/code&gt; returns a freshly-consed list each time it is called.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;*html-path*&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The variable underneath &lt;code&gt;get-html-path&lt;/code&gt; is &lt;code&gt;*html-path*&lt;/code&gt;, and it can be let-bound to manipulate the nested tags (like &lt;code&gt;:h*&lt;/code&gt; and &lt;code&gt;tabulate&lt;/code&gt; from the example above).&lt;/p&gt; &#xA;&lt;p&gt;WARNING: Spinneret binds &lt;code&gt;*html-path*&lt;/code&gt; with &lt;a href=&#34;http://clhs.lisp.se/Body/d_dynami.htm&#34;&gt;dynamic extent&lt;/a&gt;. If you need to inspect the binding, use &lt;code&gt;get-html-path&lt;/code&gt; instead to get a value you can safely store.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;*html-path*&lt;/code&gt; is most useful if the document generated by Spinneret is split into several functions. Binding &lt;code&gt;*html-path*&lt;/code&gt; allows to preserve the structure of the document there.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(defun inner-section ()&#xA;  &#34;Binds *HTML-PATH* to replicate the depth the output is used in.&#34;&#xA;  (with-html-string&#xA;    (let ((*html-path* (append *html-path* &#39;(:section :section))))&#xA;      (:h* &#34;Heading three levels deep&#34;))))&#xA;&#xA;(defun outer-section (html)&#xA;  &#34;Uses HTML from elsewhere and embed it into a section&#34;&#xA;  (with-html-string&#xA;    (:section&#xA;     (:h* &#34;Heading two levels deep&#34;)&#xA;     (:section&#xA;      (:raw html)))))&#xA;&#xA;(outer-section (inner-section))&#xA;;; &amp;lt;section&amp;gt;&#xA;;; &amp;lt;h2&amp;gt;Heading two levels deep&amp;lt;/h2&amp;gt;&#xA;;; &amp;lt;section&amp;gt;&amp;lt;h3&amp;gt;Heading three levels deep&amp;lt;/h3&amp;gt;&#xA;;; &amp;lt;/section&amp;gt;&#xA;;;&amp;lt;/section&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;deftag&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The stumbling block for all sexp-based HTML generators is order of evaluation. It&#39;s tempting to write something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;     ;; Doesn&#39;t work&#xA;     (defun field (control)&#xA;       (with-html (:p control)))&#xA;&#xA;     (defun input (default &amp;amp;key name label (type &#34;text&#34;))&#xA;       (with-html&#xA;         (:label :for name label)&#xA;         (:input :name name :id name :type type :value default)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But it won&#39;t work: in &lt;code&gt;(field (input &#34;Default&#34; :name &#34;why&#34; :label &#34;Reason&#34;))&lt;/code&gt;, &lt;code&gt;(input)&lt;/code&gt; gets evaluated before &lt;code&gt;(field)&lt;/code&gt;, and the HTML is printed inside-out.&lt;/p&gt; &#xA;&lt;p&gt;Macros do work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;     (defmacro field (control)&#xA;       `(with-html (:p ,control)))&#xA;&#xA;     (defmacro input (name label &amp;amp;key (type &#34;text&#34;))&#xA;       `(with-html&#xA;          (:label :for ,name ,label)&#xA;          (:input :name ,name :id ,name :type ,type)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But we can do better than this. Spinneret provides a macro-writing macro, &lt;code&gt;deftag&lt;/code&gt;, which lets you &lt;em&gt;refactor&lt;/em&gt; HTML without &lt;em&gt;hiding&lt;/em&gt; it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;     (deftag field (control attrs)&#xA;      `(:p ,@attrs ,@control))&#xA;&#xA;     (deftag input (default attrs &amp;amp;key name label (type &#34;text&#34;))&#xA;       (once-only (name)&#xA;         `(progn&#xA;            (:label :for ,name ,label)&#xA;            (:input :name ,name :id ,name :type ,type&#xA;              ,@attrs&#xA;              :value (progn ,@default)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A macro defined using &lt;code&gt;deftag&lt;/code&gt; takes its arguments just like an HTML element. Instead of&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (input &#34;Default&#34; :name &#34;why&#34; :label &#34;Reason&#34;) ; defmacro&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You write&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (input :name &#34;why&#34; :label &#34;Reason&#34; &#34;Default&#34;) ; deftag&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The macro re-arranges the arguments so they can be bound to an ordinary lambda list, like the one above: the body of the tag is bound to the first argument, and matching attributes are bound to keywords. Multiple &lt;code&gt;:class&lt;/code&gt; arguments, &lt;code&gt;:dataset&lt;/code&gt;, and other shorthands are handled exactly as in the usual HTML syntax.&lt;/p&gt; &#xA;&lt;p&gt;But the great advantage of &lt;code&gt;deftag&lt;/code&gt; is how it handles attributes which are &lt;em&gt;not&lt;/em&gt; bound to keywords. In the definition of &lt;code&gt;input&lt;/code&gt; using &lt;code&gt;deftag&lt;/code&gt;, you see that the &lt;code&gt;attrs&lt;/code&gt; catch-all argument is spliced into the call to &lt;code&gt;:input&lt;/code&gt;. This means that any unhandled attributes pass through to the actual input element.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (input :name &#34;why&#34; :label &#34;Reason&#34; :required t :class &#34;special&#34; &#34;Default&#34;)&#xA;    =&amp;gt; &amp;lt;label for=why&amp;gt;Reason&amp;lt;/label&amp;gt;&#xA;       &amp;lt;input class=special name=why id=why type=text required value=Default&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In effect, &lt;code&gt;input&lt;/code&gt; &lt;em&gt;extends&lt;/em&gt; the &lt;code&gt;:input&lt;/code&gt; tag, almost like a subclass. This is a very idiomatic and expressive way of building abstractions over HTML.&lt;/p&gt; &#xA;&lt;p&gt;(Note that when the name &lt;code&gt;deftag&lt;/code&gt; is a keyword, then no macro is defined, and it can only be used within a &lt;code&gt;with-html&lt;/code&gt; form.)&lt;/p&gt; &#xA;&lt;h2&gt;Spinneret in Parenscript&lt;/h2&gt; &#xA;&lt;p&gt;To use Spinneret with Parenscript, load the system &lt;code&gt;spinneret/ps&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The semantics of Spinneret in Parenscript are almost the same. There is no &lt;code&gt;with-html-string&lt;/code&gt;, and &lt;code&gt;with-html&lt;/code&gt; returns a &lt;code&gt;DocumentFragment&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If Markdown support is enabled, strings in function position are still parsed as Markdown, but supplying arguments triggers an error (since Parenscript does not have &lt;code&gt;format&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;get-html-path&lt;/code&gt; is not implemented for Parenscript.&lt;/p&gt; &#xA;&lt;p&gt;Neither :ATTRS nor :TAG is available in Parenscript.&lt;/p&gt; &#xA;&lt;h2&gt;Parenscript in Spinneret&lt;/h2&gt; &#xA;&lt;p&gt;To use Parenscript in Spinneret, remember to wrap the &lt;code&gt;ps&lt;/code&gt; macro with &lt;code&gt;:raw&lt;/code&gt;, otherwise the generated JavaScript will be escaped.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(with-html-string&#xA;  (:script&#xA;    (:raw (ps&#xA;            (defun greeting ()&#xA;              (alert &#34;Hello&#34;))))))&#xA;=&amp;gt;&#xA;&#34;&amp;lt;script&amp;gt;function greeting() {&#xA;    __PS_MV_REG = [];&#xA;    return alert(&#39;Hello&#39;);&#xA;};&amp;lt;/script&amp;gt;&#34;&#xA;&#xA;(with-html-string&#xA;  (:div :onclick (:raw (ps (alert &#34;Hello&#34;)))))&#xA;&#34;&amp;lt;div onclick=\&#34;alert(&#39;Hello&#39;);\&#34;&amp;gt;&amp;lt;/div&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Validation&lt;/h2&gt; &#xA;&lt;p&gt;Spinneret does not do document validation, but it does warn, at compile time, about invalid tags and attributes.&lt;/p&gt; &#xA;&lt;p&gt;Although HTML5 does include a mechanism for application-specific attributes (the &lt;code&gt;data-&lt;/code&gt; prefix), some client-side frameworks choose to employ their own prefixes instead. You can disable validation for a given prefix by adding it to &lt;code&gt;*unvalidated-attribute-prefixes*&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    (pushnew &#34;ng-&#34; *unvalidated-attribute-prefixes* :test #’equal)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can disable attribute validation altogether by adding the empty string to the list:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;    ;; Disable attribute validation.&#xA;    (setf *unvalidated-attribute-prefixes* &#39;(&#34;&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Tags are considered valid if they are defined as part of the HTML standard, or if they match the rules for the name of a &lt;a href=&#34;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&#34;&gt;custom element&lt;/a&gt; – basically, start with an ASCII alphabetic character and include a hyphen. For custom elements, attributes are not validated.&lt;/p&gt;</summary>
  </entry>
</feed>