<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-01T01:41:21Z</updated>
  <subtitle>Weekly Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Ferada/cl-tuples-old</title>
    <updated>2023-01-01T01:41:21Z</updated>
    <id>tag:github.com,2023-01-01:/Ferada/cl-tuples-old</id>
    <link href="https://github.com/Ferada/cl-tuples-old" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Libray for writing optimised vector math in Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This is CL-TUPLES, an experimental &#34;type facade&#34; which appears to give you configurable homogenous vectors based on defstruct, and allow for free conversion between multiple values and vectors. As such it is to be hoped that it will be of most use when writing code for raytracers, games, and the like, which use simple linear algebra primitives intensely.&lt;/p&gt; &#xA;&lt;p&gt;The rule is that if a symbol ends in an asterisk the function or macro bound to it will operate on or return multiple values, and the unadorned symbols will work with vectors.&lt;/p&gt; &#xA;&lt;h1&gt;HOWTO&lt;/h1&gt; &#xA;&lt;p&gt;A two-dimensional vector value is created by &lt;code&gt;MAKE-VECTOR2D&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (make-vector2d 1f0 1f0)&#xA;#(1.0 1.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The type &lt;code&gt;FAST-FLOAT&lt;/code&gt;, which is used for all float values, is actually a subtype of &lt;code&gt;SINGLE-FLOAT&lt;/code&gt;, so make sure to only use values that fit into that type.&lt;/p&gt; &#xA;&lt;p&gt;To calculate the length of this vector &lt;code&gt;VECTOR2D-LENGTH*&lt;/code&gt; can now be used like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (let ((v (make-vector2d 1f0 1f0)))&#xA;    (vector2d-length* (vector2d* v)))&#xA;1.4142135&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By converting the object into a bunch of variables, the macro pipeline keeps transient objects and function calls away. The above form thus expands to something like the following (type declarations and some other code omitted for clarity):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(LET ((V (MAKE-VECTOR2D 1.0 1.0)))&#xA;  (MULTIPLE-VALUE-BIND (#:G1764 #:G1765)&#xA;      (VALUES (AREF V 0) (AREF V 1))&#xA;    (SYMBOL-MACROLET ((X #:G1764) (Y #:G1765))&#xA;      (SQRT (+ (* X X) (* Y Y))))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The coordinates of the vector are bound and made available to the length calculation code. If we skip the object creation and go straight the &lt;code&gt;VALUES&lt;/code&gt; route, the following is approximately the same as above, without ever creating a vector object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (vector2d-length* (vector2d-values 1.0 1.0))&#xA;1.4142135&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reader syntax may be used to the same effect:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (enable-tuples-syntax)&#xA;&amp;gt; #{1.0 1.0}&#xA;1.0&#xA;1.0&#xA;&amp;gt; (vector2d-length* #{1.0 1.0})&#xA;1.4142135&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Since the reader syntax and &lt;code&gt;VECTOR2D-VALUES&lt;/code&gt; expand directly into a &lt;code&gt;VALUES&lt;/code&gt; call, nothing prevents you from using that as well.)&lt;/p&gt; &#xA;&lt;p&gt;Based on this design more operations are implemented. See the API and the tests for details on vectors, vertexes, matrixes and quaternions.&lt;/p&gt; &#xA;&lt;p&gt;Defining new operators is done via &lt;code&gt;DEF-TUPLE-OP&lt;/code&gt;, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(def-tuple-op scaling-matrix44*&#xA;    ((sx fast-float)&#xA;     (sy fast-float)&#xA;     (sz fast-float))&#xA;  (:return matrix44&#xA;           (matrix44-values*&#xA;            sx    0.0f0 0.0f0 0.0f0&#xA;            0.0f0 sy    0.0f0 0.0f0&#xA;            0.0f0 0.0f0 sz    0.0f0&#xA;            0.0f0 0.0f0 0.0f0 1.0f0)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This operator accepts three arguments and creates the obvious matrix from them. So lets say, a function has as a conventional argument a vector of three elements. Binding each element to a name and applying the above operator to them gives us the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (let ((v (make-vector3d* #{1f0 1f0 1f0))))&#xA;    (with-vector3d v (sx sy sz)&#xA;      (make-matrix44* (scaling-matrix44* sx sy sz)))&#xA;#(1.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The calculated matrix is converted to an actual object to be returned.&lt;/p&gt; &#xA;&lt;h1&gt;ASSORTED EXAMPLES&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (let ((v (make-vector2d 1f0 1f0))&#xA;        (s 2f0))&#xA;    (vector2d-length* (vector2d-scale* (vector2d* v) s)))&#xA;2.828427&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;QUATERNIONS&lt;/h1&gt; &#xA;&lt;p&gt;(Adapted from the documentation of cl-quaternion to this API.)&lt;/p&gt; &#xA;&lt;p&gt;Creating a quaternion from real and imaginary components. The first argument is the real part, and the rest are the imaginary components.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (make-quaternion* (quaternion-values* 10f0 3f0 0f0 0f0))&#xA;#(10.0 3.0 0.0 0.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Quaternions can be normalized and magnitudes may be computed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (make-quaternion* (quaternion-normalize* (quaternion* *)))&#xA;#(0.9578263 0.28734788 0.0 0.0)&#xA;&amp;gt; (quaternion-mag* (quaternion* *))&#xA;1.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Quaternion addition and multiplication are supported.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (make-quaternion*&#xA;   (quaternion-sum* (quaternion-values* 3f0 0f0 0f0 0f0)&#xA;                    (quaternion-values* 1f0 1f0 0f0 1f0)))&#xA;#(4.0 1.0 0.0 1.0)&#xA;&amp;gt; (make-quaternion*&#xA;   (quaternion-product* (quaternion-values* 3f0 0f0 0f0 0f0)&#xA;                        (quaternion-values* 1f0 1f0 0f0 1f0)))&#xA;#(3.0 0.0 3.0 -3.0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unit quaternions may be used to represent rotations. Functions are provided for working with quaternions for this purpose.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (values fast-pi (type-of fast-pi))&#xA;3.1415927&#xA;SINGLE-FLOAT&#xA;&amp;gt; (make-quaternion*&#xA;   (angle-axis-quaternion*&#xA;    (angle-axis-values* 0f0 0f0 1f0 (/ single-pi 2f0))))&#xA;#(0.0 0.0 0.70710677 0.70710677)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Vectors can then be transformed using these quaternions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (quaternion-transform-vector3d*&#xA;   (vector3d-values* 0.0 1.0 0.0)&#xA;   (angle-axis-quaternion*&#xA;    (angle-axis-values* 0.0 0.0 1.0 (/ fast-pi 2))))&#xA;-0.99999994&#xA;0.0&#xA;0.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At the moment you have still to convert an angle-axis representation to either a matrix or a quaternion by yourself to rotate a vector by it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; (quaternion-transform-vector3d*&#xA;   (vector3d-values* 0.0 1.0 0.0)&#xA;   (angle-axis-quaternion*&#xA;    (angle-axis-values* 0.0 0.0 1.0 fast-pi)))&#xA;8.742278e-8&#xA;-1.0&#xA;0.0&#xA;&amp;gt; (transform-vector3d*&#xA;   (angle-axis-matrix33*&#xA;    (angle-axis-values* 0.0 0.0 1.0 fast-pi))&#xA;   (vector3d-values* 0.0 1.0 0.0))&#xA;8.742278e-8&#xA;-1.0&#xA;0.0&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>