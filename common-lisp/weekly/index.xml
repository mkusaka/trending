<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-16T01:41:32Z</updated>
  <subtitle>Weekly Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>stumpwm/stumpwm</title>
    <updated>2022-10-16T01:41:32Z</updated>
    <id>tag:github.com,2022-10-16:/stumpwm/stumpwm</id>
    <link href="https://github.com/stumpwm/stumpwm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Stump Window Manager&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://stumpwm.github.io/images/stumpwm-logo-stripe.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;The Stump Window Manager&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://travis-ci.org/stumpwm/stumpwm.svg?sanitize=true&#34; alt=&#34;&#34;&gt; &lt;a href=&#34;https://gitter.im/stumpwm/community?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/stumpwm/community.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;StumpWM is a window manager written entirely in Common Lisp. It attempts to be highly customizable while relying entirely on the keyboard for input. You will not find buttons, icons, title bars, tool bars, or any of the other conventional GUI widgets.&lt;/p&gt; &#xA;&lt;p&gt;These design decisions reflect the growing popularity of productive, customizable lisp based systems.&lt;/p&gt; &#xA;&lt;h2&gt;Philosophy&lt;/h2&gt; &#xA;&lt;p&gt;StumpWM is a &#34;everything-and-the-kitchen-sink WM&#34; or &#34;the Emacs of WMs.&#34;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;StumpWM:Windows::Emacs:Text&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;StumpWM is &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Hackable&lt;/li&gt; &#xA;   &lt;li&gt;Written in Common Lisp&lt;/li&gt; &#xA;   &lt;li&gt;A multi paradigm window manager&lt;/li&gt; &#xA;   &lt;li&gt;A Superior window managing experience&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;StumpWM is &lt;em&gt;not&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Minimalist&lt;/li&gt; &#xA;   &lt;li&gt;Narrow scope&lt;/li&gt; &#xA;   &lt;li&gt;Configured by editing the source directly&lt;/li&gt; &#xA;   &lt;li&gt;A full blown desktop environment&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want a minimalist tiling window manager, then StumpWM is &lt;em&gt;not&lt;/em&gt; what you&#39;re looking for. The code base is ~15k lines, the binaries produced are ~60mb.&lt;/p&gt; &#xA;&lt;p&gt;StumpWM manages windows the way emacs manages buffers, or the way screen manages terminals. If you want a flexible, customizable, hackable desktop experience, look no further.&lt;/p&gt; &#xA;&lt;h1&gt;Build &amp;amp; Start Stumpwm&lt;/h1&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://sbcl.org&#34;&gt;SBCL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;quicklisp (for obtaining the following dependencies; not needed if you use your distribution&#39;s package manager.)&lt;/li&gt; &#xA; &lt;li&gt;clx&lt;/li&gt; &#xA; &lt;li&gt;cl-ppcre&lt;/li&gt; &#xA; &lt;li&gt;alexandria&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The recommended way to install the dependencies is using Quicklisp. Follow the instructions at &lt;a href=&#34;http://www.quicklisp.org/&#34;&gt;http://www.quicklisp.org/&lt;/a&gt; to install it. In short:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ curl -O https://beta.quicklisp.org/quicklisp.lisp&#xA;$ sbcl --load quicklisp.lisp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then at the REPL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(quicklisp-quickstart:install)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure you have added it to your lisp init file using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt; (ql:add-to-init-file)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, in a repl:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt; (ql:quickload &#34;clx&#34;)&#xA; (ql:quickload &#34;cl-ppcre&#34;)&#xA; (ql:quickload &#34;alexandria&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: The recommended way to install SBCL is by downloading one of their pre-built binaries available in their &lt;a href=&#34;http://sbcl.org/platform-table.html&#34;&gt;web page&lt;/a&gt; or build it from source. Please do &lt;em&gt;not&lt;/em&gt; install SBCL using your distributions package manager, especially Ubuntu. If you do so it is likely that you&#39;ll run into problems when building StumpWM due to using obsolete versions of the dependencies.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Building stumpwm from git requires that you build the configure script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; ./autogen.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; ./configure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now build it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If all goes well, you should have a stumpwm binary now. You can run the binary from where it is (starting it with X) or install it, along with the .info documentation, with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that you have a binary, call it from your ~/.xinitrc file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; # The default path is /usr/local/bin/stumpwm&#xA; echo /path/to/stumpwm &amp;gt;&amp;gt; ~/.xinitrc&#xA; startx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hopefully that will put you in X running stumpwm! See &lt;a href=&#34;https://github.com/sabetts/stumpwm/wiki/StartUp&#34;&gt;StartUp on the wiki&lt;/a&gt; for more examples.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;Pull requests are always welcome! Here are some guidelines to ensure that your contribution gets merged in a timely manner:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Do&#39;s &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Add your name to the list of AUTHORS with your pull request.&lt;/li&gt; &#xA;   &lt;li&gt;Preserve comments or docstrings explaining what code does, and update them if your patch changes them in a significant way&lt;/li&gt; &#xA;   &lt;li&gt;Try to follow an &#34;80 column rule.&#34; The current code base does not follow this all the time, so don&#39;t use it as an example&lt;/li&gt; &#xA;   &lt;li&gt;If you export a symbol, you &lt;em&gt;must&lt;/em&gt; add it to the manual.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stumpwm/stumpwm/master/(http://web.archive.org/web/20160101153032/http://people.ace.ed.ac.uk/staff/medward2/class/moz/cm/doc/contrib/lispstyle.html)&#34;&gt;Use lisp idioms&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;If you are working on a major change to the internals, keep us informed on stumpwm-devel! Also, it will probably help if the changes are made and then incrementally applied to the codebase in order to avoid introducing show-stopping bugs.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Do not&#39;s &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Include Emacs local variables&lt;/li&gt; &#xA;   &lt;li&gt;Change whitespace&lt;/li&gt; &#xA;   &lt;li&gt;Write lots of code without supporting comments/documentation&lt;/li&gt; &#xA;   &lt;li&gt;Delete comments or docstrings (yes this is a duplicate of above!)&lt;/li&gt; &#xA;   &lt;li&gt;Export symbols from packages that aren&#39;t widely useful (many times a little more thought will reveal how to implement your internal change without having to export/break encapsulation)&lt;/li&gt; &#xA;   &lt;li&gt;Make stylistic changes that suit your coding style/way of thinking&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you aren&#39;t a lisp hacker, you can contribute in the form of documenting and organizing the wiki. There&#39;s a lot of information floating around; if you find it where you didn&#39;t expect it, move or link to it in a more logical place.&lt;/p&gt; &#xA;&lt;h1&gt;Wishlist&lt;/h1&gt; &#xA;&lt;p&gt;Fancy yourself a lisp hacker? Here&#39;s a wishlist of features for the StumpWM universe (in no particular order):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;float-splits (ie allow floating windows over tiled ones)&lt;/li&gt; &#xA; &lt;li&gt;Float windows within parent applications (specifically dialogs in gimp or firefox).&lt;/li&gt; &#xA; &lt;li&gt;tab-list showing the contents of the current frame at the side, top, or bottom of the frame&lt;/li&gt; &#xA; &lt;li&gt;Emacs&#39; iswitchb function implemented in emacs &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Re-arranging windows between groups&lt;/li&gt; &#xA;   &lt;li&gt;Killing windows&lt;/li&gt; &#xA;   &lt;li&gt;Marking windows for batch operations&lt;/li&gt; &#xA;   &lt;li&gt;Deleting/adding groups&lt;/li&gt; &#xA;   &lt;li&gt;Import data from stumpwm to emacs, use an emacs minor mode to implement the above features, then export the data back to stumpwm and let stumpwm perform the appropriate actions&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Emacs&#39; completing-read-multiple function&lt;/li&gt; &#xA; &lt;li&gt;Dynamic tiling&lt;/li&gt; &#xA; &lt;li&gt;Lock Screen (with support for leaving notes, bonus points if emacs is involved)&lt;/li&gt; &#xA; &lt;li&gt;Wallpapers! (support pulling from remote sources, changing based on timers, and other hacky features)&lt;/li&gt; &#xA; &lt;li&gt;Shutdown, restart, suspend, and hibernate functions that don&#39;t require root access&lt;/li&gt; &#xA; &lt;li&gt;Revamped, mouse-friendly mode-line. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Support fixed number of chars for window titles&lt;/li&gt; &#xA;   &lt;li&gt;Dynamically trim window titles to fit them all on the mode-line&lt;/li&gt; &#xA;   &lt;li&gt;Split the mode-line into multiple cells for containing different information&lt;/li&gt; &#xA;   &lt;li&gt;Implement widget icons to indicate system status (new mail, low battery, network etc)&lt;/li&gt; &#xA;   &lt;li&gt;Support raising windows when left-clicked, closing/killing when right-clicked&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Help&lt;/h1&gt; &#xA;&lt;p&gt;There&#39;s a texinfo manual, stumpwm.texi. The build scripts generate an info file you can read in emacs or with the `info&#39; program. The manual for the latest git version (may be slightly out of date) is available to read online at: &lt;a href=&#34;https://stumpwm.github.io/&#34;&gt;The Manual&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;And, as in Emacs, you can always get documentation with:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Key&lt;/th&gt; &#xA;   &lt;th&gt;Help&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-t h v&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Variables&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-t h f&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Functions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-t h k&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Key sequences&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-t h c&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Commands&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;kbd&gt;C-t h w&lt;/kbd&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Find key sequences for a command&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For other stuff (tips tricks and examples) visit the &lt;a href=&#34;https://github.com/stumpwm/stumpwm/wiki&#34;&gt;stumpwm wiki&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s a &lt;strong&gt;#stumpwm&lt;/strong&gt; channel on &lt;a href=&#34;https://libera.chat&#34;&gt;irc.libera.chat&lt;/a&gt;, too.&lt;/p&gt; &#xA;&lt;p&gt;Finally, there&#39;s our mailing list (click to sign up) &lt;a href=&#34;https://lists.nongnu.org/mailman/listinfo/stumpwm-devel&#34;&gt;stumpwm-devel@nongnu.org&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>woodrush/lambda-8cc</title>
    <updated>2022-10-16T01:41:32Z</updated>
    <id>tag:github.com,2022-10-16:/woodrush/lambda-8cc</id>
    <link href="https://github.com/woodrush/lambda-8cc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;x86 C compiler written in untyped lambda calculus&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lambda-8cc - An x86 C Compiler Written in Untyped Lambda Calculus&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/bin/lambdavm-diagram.png&#34; alt=&#34;Lambda calculus diagram for LambdaVM.&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/woodrush/lambda-8cc/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/woodrush/lambda-8cc/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;lambda-8cc is an x86 C compiler written as a monolithic closed untyped lambda calculus term.&lt;/p&gt; &#xA;&lt;p&gt;When printed on letter-sized paper, it becomes 18,506 pages long on a 22 MB PDF without any figures. The PDF can be seen on my GitHub Pages &lt;a href=&#34;https://woodrush.github.io/lambda-8cc.pdf&#34;&gt;here&lt;/a&gt;. The LaTeX source is 448 MB, and the LaTeX compilation log file &lt;code&gt;main.log&lt;/code&gt; is 284 MB. I couldn&#39;t believe LaTeX was able to do that.&lt;/p&gt; &#xA;&lt;p&gt;This gigantic lambda calculus term is a C compiler. Here is &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/rot13.c&#34;&gt;rot13.c&lt;/a&gt;, a program that compiles on GCC with no errors. The same program can be compiled using lambda-8cc producing the x86 executable &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/out/rot13.bin&#34;&gt;rot13.bin&lt;/a&gt;, runnable on x86/x86-64 Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ echo &#39;Hello, world!&#39; | ./rot13.bin&#xA;Uryyb, jbeyq!&#xA;$ echo &#39;Uryyb, jbeyq!&#39; | ./rot13.bin&#xA;Hello, world!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Despite its massive size, compiling rot13.c finishes in 8 minutes on my machine using a lambda calculus interpreter. You can try it out on your own PC by cloning this repo. Running time stats are summarized in the &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/#running-times-and-memory-usage&#34;&gt;Running Times and Memory Usage&lt;/a&gt; section. Note that although the compilation takes time, the compiled binary runs instantaneously.&lt;/p&gt; &#xA;&lt;!-- A zipped plaintext file is also available in this repo [here](./bin/lambda-8cc.lam.zip). --&gt; &#xA;&lt;h3&gt;Additional Feature: C to Lambda Calculus&lt;/h3&gt; &#xA;&lt;p&gt;As an additional feature, not only can lambda-8cc compile C to x86, but it can also compile C to lambda calculus terms, producing something like &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/out/rot13.lam&#34;&gt;rot13.lam&lt;/a&gt;. Compiled lambda terms run on the same lambda calculus interpreter used to run lambda-8cc itself.&lt;/p&gt; &#xA;&lt;p&gt;Using its &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/#compilation-options&#34;&gt;compilation options&lt;/a&gt;, lambda-8cc can compile C to 5 different formats. Here is a full list of its features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compile C to: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;x86 executable (a.out)&lt;/li&gt; &#xA;   &lt;li&gt;Lambda calculus term (runs on the same interpreter as lambda-8cc)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tromp.github.io/cl/Binary_lambda_calculus.html&#34;&gt;Binary lambda calculus&lt;/a&gt; program&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/SKI_combinator_calculus&#34;&gt;SKI combinator calculus&lt;/a&gt; term (runnable as a &lt;a href=&#34;https://tromp.github.io/cl/lazy-k.html&#34;&gt;Lazy K&lt;/a&gt; program)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/shinh/elvm&#34;&gt;ELVM&lt;/a&gt; assembly listing (example: &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/out/rot13.s&#34;&gt;rot13.s&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Compile ELVM assembly to: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;x86/lambda calculus/BLC/SKI combinator calculus (all of the above)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Among the list is &lt;a href=&#34;https://tromp.github.io/cl/lazy-k.html&#34;&gt;Lazy K&lt;/a&gt;, a minimal purely functional language with only 4 built-in operators, similar to the minimal imperative language &lt;a href=&#34;https://en.wikipedia.org/wiki/Brainfuck&#34;&gt;BF&lt;/a&gt; which only has 8 instructions. I have covered a little bit about it in &lt;a href=&#34;https://woodrush.github.io/blog/lambdalisp.html#lazy-k&#34;&gt;my blog post&lt;/a&gt; as well.&lt;/p&gt; &#xA;&lt;p&gt;lambda-8cc is based on the following 3 projects: The first one is &lt;a href=&#34;https://github.com/woodrush/lambdavm&#34;&gt;LambdaVM&lt;/a&gt; written by the author of this repo &lt;a href=&#34;https://github.com/woodrush&#34;&gt;Hikaru Ikuta&lt;/a&gt;, a programmable virtual CPU written as an untyped lambda calculus term. This is combined with &lt;a href=&#34;https://github.com/rui314/8cc&#34;&gt;8cc&lt;/a&gt; by &lt;a href=&#34;https://github.com/rui314&#34;&gt;Rui Ueyama&lt;/a&gt;, and a modified version of &lt;a href=&#34;https://github.com/shinh/elvm&#34;&gt;ELVM&lt;/a&gt; by &lt;a href=&#34;https://github.com/shinh&#34;&gt;Shinichiro Hamaji&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Gallery&lt;/h2&gt; &#xA;&lt;p&gt;The first page of the PDF looks like this. Notice the page count on the top left:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/bin/lambda-8cc-page1.png&#34; alt=&#34;The first page of a PDF showing lambda-8cc&#39;s lambda term&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Its grand finale is a round of applause by a page full of right parentheses:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/bin/lambda-8cc-page18506.png&#34; alt=&#34;The last page of a PDF showing lambda-8cc&#39;s lambda term&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;h3&gt;Lambdas All the Way Down&lt;/h3&gt; &#xA;&lt;p&gt;lambda-8cc is written as a closed untyped lambda calculus term ${\rm lambda8cc} = \lambda x. \cdots$ which takes an input string $x$ representing a C program and outputs an x86 Linux ELF executable expressed as a list of bytes.&lt;/p&gt; &#xA;&lt;p&gt;Here, even strings are encoded as lambda terms. Characters and bytes are encoded as a list of bits with $0 = \lambda x. \lambda y.x$, $1 = \lambda x. \lambda y.y$, and lists are encoded in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding&#34;&gt;Scott encoding&lt;/a&gt; with ${\rm cons} = \lambda x.\lambda y.\lambda f.(f x y)$, ${\rm nil} = \lambda x.\lambda y.y$.&lt;/p&gt; &#xA;&lt;p&gt;Therefore, &lt;em&gt;everything&lt;/em&gt; in the computation process, even including integers, is closed in the world of pure lambda terms, without the need of introducing any non-lambda type object whatsoever. It doesn&#39;t use any primitive types other than lambdas. lambda-8cc makes &lt;a href=&#34;https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B2-reduction&#34;&gt;beta reduction&lt;/a&gt; the sole requirement for compiling C to x86. Note that the process doesn&#39;t depend on the choice of variable names as well. Instead of encoding the character &lt;code&gt;A&lt;/code&gt; as a variable with the name $A$, &lt;code&gt;A&lt;/code&gt; is encoded as a list of bits of its ASCII encoding &lt;code&gt;01000001&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The encoding process is a little cumbersome to say at the least to do by hand. This can be solved by using a lambda calculus interpreter. Various lambda calculus interpreters automatically handle this I/O format so that it runs on the terminal - standard input is encoded into lambda terms, and the output lambda term is decoded and shown on the terminal. Using these interpreters, lambda-8cc can be run on the terminal to compile C programs just like GCC.&lt;/p&gt; &#xA;&lt;p&gt;For further details on how I/O is handled and how programs are written in lambda calculus, please see the implementation details of my other project &lt;a href=&#34;https://github.com/woodrush/lambdalisp&#34;&gt;LambdaLisp&lt;/a&gt;, a Lisp interpreter written as an untyped lambda calculus term.&lt;/p&gt; &#xA;&lt;h3&gt;C to Lambda Calculus&lt;/h3&gt; &#xA;&lt;p&gt;In addition to x86, lambda-8cc can compile C to lambda calculus as well. The output program runs on the same lambda calculus interpreter used to run lambda-8cc itself. Compiled lambda terms also run on minimal interpreters such as the 521-byte lambda calculus interpreter &lt;a href=&#34;https://justine.lol/lambda/&#34;&gt;SectorLambda&lt;/a&gt; written by &lt;a href=&#34;https://github.com/jart&#34;&gt;Justine Tunney&lt;/a&gt;, and the &lt;a href=&#34;https://www.ioccc.org/&#34;&gt;IOCCC&lt;/a&gt; 2012 &lt;a href=&#34;https://www.ioccc.org/2012/tromp/hint.html&#34;&gt;&#34;Most functional&#34;&lt;/a&gt; interpreter written by &lt;a href=&#34;https://github.com/tromp&#34;&gt;John Tromp&lt;/a&gt; (its &lt;a href=&#34;https://www.ioccc.org/2012/tromp/tromp.c&#34;&gt;source&lt;/a&gt; is in the shape of a λ). This makes lambda-8cc self-contained in the realm of lambda calculus.&lt;/p&gt; &#xA;&lt;p&gt;It has long been known in computer science that lambda calculus is Turing-complete. lambda-8cc demonstrates this in a rather straightforward way by showing that C programs can directly be compiled into lambda calculus terms.&lt;/p&gt; &#xA;&lt;p&gt;The nice thing about lambda calculus is that the language specs are extremely simple. With lambda-8cc, we are preserving knowledge about how to compile C in a timeless method. Even if humanity loses knowledge about the x86 instruction set, as long as we remember the rules for lambda calculus and have &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/bin/lambda-8cc.lam.zip&#34;&gt;the lambda term for lambda-8cc&lt;/a&gt;, we can still use the entire C language through lambda-8cc and build everything on top of it again.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Usage Example&lt;/h2&gt; &#xA;&lt;p&gt;Here is a program &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/rot13.c&#34;&gt;rot13.c&lt;/a&gt; that encodes/decodes standard input to/from the &lt;a href=&#34;https://en.wikipedia.org/wiki/ROT13&#34;&gt;ROT13&lt;/a&gt; cipher. It compiles without errors using GCC:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// rot13.c: Encodes/decodes standard input to/from the ROT13 cipher&#xA;&#xA;#define EOF -1&#xA;&#xA;int putchar(int c);&#xA;char getchar(void);&#xA;&#xA;char c;&#xA;int offset;&#xA;&#xA;int main (void) {&#xA;    for (;;) {&#xA;        c = getchar();&#xA;        if (c == EOF) {&#xA;            break;&#xA;        }&#xA;&#xA;        offset = 0;&#xA;        if ((&#39;a&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt; &#39;n&#39;) || (&#39;A&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt; &#39;N&#39;)) {&#xA;            offset = 13;&#xA;        } else if ((&#39;n&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &#39;z&#39;) || (&#39;N&#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &#39;Z&#39;)) {&#xA;            offset = -13;&#xA;        }&#xA;        putchar(c + offset);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same program can be compiled by lambda-8cc out of the box as follows.&lt;/p&gt; &#xA;&lt;h3&gt;Build the Tools&lt;/h3&gt; &#xA;&lt;p&gt;First build the tools and prepare lambda-8cc:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make tools  # Build the interpreter uni++ and the tools lam2bin, asc2bin&#xA;$ unzip bin/lambda-8cc.lam.zip&#xA;$ cat lambda-8cc.lam | bin/lam2bin | bin/asc2bin &amp;gt; lambda-8cc.Blc  # Prepare format for uni++&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The requirements are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;clang++&lt;/code&gt; for building &lt;code&gt;uni++&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; for building &lt;code&gt;lam2bin&lt;/code&gt; and &lt;code&gt;asc2bin&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The tools built here are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;uni++&lt;/code&gt;: A very fast &lt;a href=&#34;https://github.com/melvinzhang/binary-lambda-calculus&#34;&gt;lambda calculus interpreter&lt;/a&gt; written by &lt;a href=&#34;https://github.com/melvinzhang&#34;&gt;Melvin Zhang&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lam2bin&lt;/code&gt;: A utility written by &lt;a href=&#34;https://github.com/jart&#34;&gt;Justine Tunney&lt;/a&gt; (available at &lt;a href=&#34;https://justine.lol/lambda/&#34;&gt;https://justine.lol/lambda/&lt;/a&gt;), that converts plaintext lambda calculus notation such as &lt;code&gt;\x.x&lt;/code&gt; to &lt;a href=&#34;https://tromp.github.io/cl/Binary_lambda_calculus.html#Lambda_encoding&#34;&gt;binary lambda calculus&lt;/a&gt; notation, the format accepted by uni++.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;asc2bin&lt;/code&gt;: A utility that packs the 0/1 ASCII bitstream to bytes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The tools are build via the &lt;a href=&#34;https://github.com/woodrush/lambda-calculus-devkit&#34;&gt;lambda calculus development kit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The conversion from lambda-8cc.lam to lambda-8cc.Blc is simply a transformation of notation for a format that&#39;s accepted by the interpreter uni++. Details are described in &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/details.md#what-is-lambda-8ccblc&#34;&gt;details.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Compile the Program Using lambda-8cc&lt;/h3&gt; &#xA;&lt;p&gt;Then rot13.c can be compiled as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cat lambda-8cc.Blc examples/rot13.c | bin/uni++ -o &amp;gt; a.out&#xA;$ chmod 755 a.out&#xA;&#xA;$ echo &#39;Hello, world!&#39; | ./a.out&#xA;Uryyb, jbeyq!&#xA;$ echo &#39;Uryyb, jbeyq!&#39; | ./a.out&#xA;Hello, world!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This runs in about 8 minutes on my machine. But be careful - it takes 145 GB of memory to run it! If you have free storage space or a USB drive, you can use a &lt;a href=&#34;https://askubuntu.com/questions/178712/how-to-increase-swap-space&#34;&gt;swap file&lt;/a&gt; with &lt;code&gt;mkswap&lt;/code&gt; and &lt;code&gt;swapon&lt;/code&gt; to extend the swap without configuring the partition settings. Also, by compiling the assembly and x86 executable separately, you can halve the RAM usage to 65 GB, as shown in the &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/#detailed-usage&#34;&gt;Detailed Usage&lt;/a&gt; section. Small programs such as &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/putchar.c&#34;&gt;putchar.c&lt;/a&gt; only take about 40 GB of memory. I suspect that the RAM usage can be decreased by introducing a mark-and-sweep GC to the interpreter, although I haven&#39;t confirmed it yet.&lt;/p&gt; &#xA;&lt;p&gt;More running time stats are available in the &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/#running-times-and-memory-usage&#34;&gt;Running Times and Memory Usage&lt;/a&gt; section. More example C programs compilable by lambda-8cc can be found under &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples&#34;&gt;./examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Other compilation options are described in the &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/#detailed-usage&#34;&gt;Detailed Usage&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;Detailed Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Compilation Options&lt;/h3&gt; &#xA;&lt;p&gt;Being written in lambda calculus, naturally, lambda-8cc&#39;s compilation options are expressed as lambda calculus terms as well. These options can be used to unlock the full features of lambda-8cc.&lt;/p&gt; &#xA;&lt;p&gt;Compilation options are used by applying an optional term as &lt;code&gt;(lambda-8cc option)&lt;/code&gt; beforehand of the input. This changes the behavior of the lambda term &lt;code&gt;lambda-8cc&lt;/code&gt; so that it accepts/produces a different input/output format.&lt;/p&gt; &#xA;&lt;p&gt;Here are all of lambda-8cc&#39;s compilation options:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Input&lt;/th&gt; &#xA;   &lt;th&gt;Output&lt;/th&gt; &#xA;   &lt;th&gt;Compilation Option&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;x86 executable&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. x) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.x) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;Plaintext lambda calculus term&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. x) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.y) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;Binary lambda calculus notation (BLC program)&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. x) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.z) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;SKI combinator calculus (Lazy K program)&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. x) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.a) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;   &lt;td&gt;ELVM assembly&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. x) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.b) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ELVM assembly&lt;/td&gt; &#xA;   &lt;td&gt;x86 executable&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. y) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.x) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ELVM assembly&lt;/td&gt; &#xA;   &lt;td&gt;Plaintext lambda calculus term&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. y) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.y) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ELVM assembly&lt;/td&gt; &#xA;   &lt;td&gt;Binary lambda calculus notation (BLC program)&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. y) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.z) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ELVM assembly&lt;/td&gt; &#xA;   &lt;td&gt;SKI combinator calculus (Lazy K program)&lt;/td&gt; &#xA;   &lt;td&gt;$\lambda f. (f ~ (\lambda x. \lambda y. y) ~ (\lambda x.\lambda y.\lambda z.\lambda a.\lambda b.a) ~ (\lambda x.x))$&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Each option is in the format of a 3-tuple ${\rm cons3} ~ {\rm input} ~ {\rm output} ~ X$ where ${\rm cons 3} = \lambda x. \lambda y. \lambda z. \lambda f. (f x y z)$. The first element ${\rm input}$ is a selector of a 2-tuple specifying the input format. The second element ${\rm output}$ is a selector of a 5-tuple specifying the output format. The third element $X = \lambda x.x$ is a placeholder used to distinguish the data structure from the standard input, also existing for backward portability in the case when more options are added in the future.&lt;/p&gt; &#xA;&lt;h3&gt;Applying Compilation Options&lt;/h3&gt; &#xA;&lt;p&gt;The compilation options shown before can be used in the terminal as follows.&lt;/p&gt; &#xA;&lt;p&gt;To compile C to an ELVM assembly listing &lt;code&gt;a.s&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;( ( cat lambda-8cc.lam; printf &#39;(\\f.(f (\\x.\\y.x) (\\x.\\y.\\z.\\a.\\b.b) (\\x.x)))&#39; ) \&#xA;  | bin/lam2bin | bin/asc2bin; cat input.c ) | bin/uni++ -o &amp;gt; a.s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To compile an ELVM assembly listing &lt;code&gt;a.s&lt;/code&gt; to x86 executable &lt;code&gt;a.out&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;( ( cat lambda-8cc.lam; printf &#39;(\\f.(f (\\x.\\y.y) (\\x.\\y.\\z.\\a.\\b.x) (\\x.x)))&#39; ) \&#xA;  | bin/lam2bin | bin/asc2bin; cat a.s ) | bin/uni++ -o &amp;gt; a.out&#xA;chmod 755 a.out&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As described before, by separately compiling &lt;code&gt;a.s&lt;/code&gt; and &lt;code&gt;a.out&lt;/code&gt; using these commands, the maximum RAM usage can be cut in half since the memory is freed when each process finishes.&lt;/p&gt; &#xA;&lt;p&gt;By running lambda-8cc without any input or options, you can see a usage message showing the full set of options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ cat lambda-8cc.lam | bin/lam2bin | bin/asc2bin | bin/uni++ -o&#xA;lambda-8cc v1.0.0&#xA;&#xA;Usage:&#xA;    apply lambda-8cc.lam [input-file]&#xA;    apply lambda-8cc.lam [option] [input-file]&#xA;&#xA;Options:&#xA;    (\f.(f [input] [output] (\x.x)))&#xA;    (\f.(f (\x.\y.x) (\x.\y.\z.\a.\b.x) (\x.x))) : C to x86 (defualt)&#xA;    (\f.(f (\x.\y.x) (\x.\y.\z.\a.\b.y) (\x.x))) : C to *.lam (plaintext lambda calculus program)&#xA;    (\f.(f (\x.\y.x) (\x.\y.\z.\a.\b.z) (\x.x))) : C to *.blc (binary lambda calculus program)&#xA;    (\f.(f (\x.\y.x) (\x.\y.\z.\a.\b.a) (\x.x))) : C to *.lazy (SKI combinator calculus, as a Lazy K program)&#xA;    (\f.(f (\x.\y.x) (\x.\y.\z.\a.\b.b) (\x.x))) : C to ELVM assembly&#xA;    (\f.(f (\x.\y.y) (\x.\y.\z.\a.\b.x) (\x.x))) : ELVM assembly to x86&#xA;    (\f.(f (\x.\y.y) (\x.\y.\z.\a.\b.y) (\x.x))) : ELVM assembly to *.lam&#xA;    (\f.(f (\x.\y.y) (\x.\y.\z.\a.\b.z) (\x.x))) : ELVM assembly to *.blc&#xA;    (\f.(f (\x.\y.y) (\x.\y.\z.\a.\b.a) (\x.x))) : ELVM assembly to *.lazy&#xA;&#xA;lambda-8cc includes the following projects. All of the following projects&#xA;are released under the MIT license. See the LICENSE in each location for details.&#xA;    8cc: By Rui Ueyama - https://github.com/rui314/8cc&#xA;    ELVM: By Shinichiro Hamaji - https://github.com/shinh/elvm&#xA;    LambdaVM: By Hikaru Ikuta - https://github.com/woodrush/lambdavm&#xA;    lambda-8cc: By Hikaru Ikuta - https://github.com/woodrush/lambda-8cc&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running Times and Memory Usage&lt;/h2&gt; &#xA;&lt;p&gt;The following table shows the compilation time and memory usage on &lt;a href=&#34;https://github.com/melvinzhang&#34;&gt;Melvin Zhang&lt;/a&gt;&#39;s &lt;a href=&#34;https://github.com/melvinzhang/binary-lambda-calculus&#34;&gt;lambda calculus interpreter&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Program&lt;/th&gt; &#xA;   &lt;th&gt;Compilation Time&lt;/th&gt; &#xA;   &lt;th&gt;Max. RAM Usage at Compilation Time&lt;/th&gt; &#xA;   &lt;th&gt;x86 Binary Size&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/putchar.c&#34;&gt;putchar.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1.8 min&lt;/td&gt; &#xA;   &lt;td&gt;31 GB&lt;/td&gt; &#xA;   &lt;td&gt;342 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Prints &lt;code&gt;A&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/hello.c&#34;&gt;hello.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;2.4 min&lt;/td&gt; &#xA;   &lt;td&gt;42 GB&lt;/td&gt; &#xA;   &lt;td&gt;802 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Prints &lt;code&gt;Hello, world!&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/echo.c&#34;&gt;echo.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;2.5 min&lt;/td&gt; &#xA;   &lt;td&gt;46 GB&lt;/td&gt; &#xA;   &lt;td&gt;663 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Echoes standard input&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/rot13.c&#34;&gt;rot13.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;7.7 min&lt;/td&gt; &#xA;   &lt;td&gt;84 GB&lt;/td&gt; &#xA;   &lt;td&gt;2,118 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Encodes/decodes stdin to/from &lt;a href=&#34;https://en.wikipedia.org/wiki/ROT13&#34;&gt;ROT13&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/fizzbuzz.c&#34;&gt;fizzbuzz.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;49.7 min&lt;/td&gt; &#xA;   &lt;td&gt;240 GB&lt;/td&gt; &#xA;   &lt;td&gt;5,512 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Prints FizzBuzz sequence up to 30&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/examples/primes.c&#34;&gt;primes.c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;53.0 min&lt;/td&gt; &#xA;   &lt;td&gt;241 GB&lt;/td&gt; &#xA;   &lt;td&gt;5,500 bytes&lt;/td&gt; &#xA;   &lt;td&gt;Prints primes up to 100&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Now that is a lot of memory! To compile programs that require a huge RAM, you can extend your swap region without changing the partition settings by using a swap file. If you run Linux and have any free storage or a USB drive, you can use that storage to easily and dynamically extend your swap region using &lt;code&gt;mkswap&lt;/code&gt; and &lt;code&gt;swapon&lt;/code&gt;. The stats on this table are run with an extended swap region this way. Instructions are explained in this &lt;a href=&#34;https://askubuntu.com/questions/178712/how-to-increase-swap-space&#34;&gt;askubuntu thread&lt;/a&gt;. I suspect that the RAM usage can be decreased by introducing a mark-and-sweep GC to the interpreter, although I haven&#39;t confirmed it yet.&lt;/p&gt; &#xA;&lt;p&gt;Note that these are the compilation times - the running times for the compiled x86 binary are instantaneous. This even holds when compiling C to lambda calculus terms. Compiled lambda terms also run instantaneously and only use a few gigabytes of memory when run on a lambda calculus interpreter.&lt;/p&gt; &#xA;&lt;p&gt;The compilations for these stats were run on an Ubuntu 22.04.1 machine with 48 GB RAM, 16GB SSD swap (default partition), and 274GB (256GiB) HDD swap (dynamically added with &lt;code&gt;mkswap&lt;/code&gt; and &lt;code&gt;swapon&lt;/code&gt;). The running time shown here is the wall clock running time including memory operations. For swap-heavy programs, the running time could be decreased by using a device with a faster I/O speed.&lt;/p&gt; &#xA;&lt;p&gt;The stats were measured by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cp examples/[program].c ./input.c&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which compiles &lt;code&gt;a.s&lt;/code&gt; and &lt;code&gt;a.out&lt;/code&gt; for &lt;code&gt;input.c&lt;/code&gt; separately to save the total memory usage. A more detailed table of stats for each pass is shown in &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/details.md&#34;&gt;details.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How is it done?&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/details.md&#34;&gt;details.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building From Source&lt;/h2&gt; &#xA;&lt;p&gt;For details on building from source, please see &lt;a href=&#34;https://raw.githubusercontent.com/woodrush/lambda-8cc/main/details.md&#34;&gt;details.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;lambda-8cc is a combination of 3 projects, &lt;a href=&#34;https://github.com/woodrush/lambdavm&#34;&gt;LambdaVM&lt;/a&gt;, &lt;a href=&#34;https://github.com/shinh/elvm&#34;&gt;ELVM&lt;/a&gt;, and &lt;a href=&#34;https://github.com/rui314/8cc&#34;&gt;8cc&lt;/a&gt;. &lt;a href=&#34;https://github.com/woodrush/lambdavm&#34;&gt;LambdaVM&lt;/a&gt; was written by &lt;a href=&#34;https://github.com/woodrush&#34;&gt;Hikaru Ikuta&lt;/a&gt;, the author of this repository (lambda-8cc). The &lt;a href=&#34;https://github.com/shinh/elvm&#34;&gt;ELVM&lt;/a&gt; architecture was written by &lt;a href=&#34;https://github.com/shinh&#34;&gt;Shinichiro Hamaji&lt;/a&gt;. &lt;a href=&#34;https://github.com/rui314/8cc&#34;&gt;8cc&lt;/a&gt; was written by &lt;a href=&#34;https://github.com/rui314&#34;&gt;Rui Ueyama&lt;/a&gt;. The version of 8cc used in lambda-8cc is a modified version of 8cc included as a part of ELVM, modified by Shinichiro Hamaji and others. lambda-8cc also includes elc, a part of ELVM written by Shinichiro Hamaji, modified by Hikaru Ikuta so that it can compile ELVM assembly to lambda calculus. The lambda calculus backend for ELVM was written by Hikaru Ikuta, by integrating LambdaVM into ELVM. The running time and memory usage statistics were measured using a &lt;a href=&#34;https://github.com/melvinzhang/binary-lambda-calculus&#34;&gt;lambda calculus interpreter&lt;/a&gt; written by &lt;a href=&#34;https://github.com/melvinzhang&#34;&gt;Melvin Zhang&lt;/a&gt;. lam2bin was written by &lt;a href=&#34;https://github.com/jart&#34;&gt;Justine Tunney&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>