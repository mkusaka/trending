<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-18T01:50:11Z</updated>
  <subtitle>Weekly Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>helmutkian/cl-wasm-runtime</title>
    <updated>2023-06-18T01:50:11Z</updated>
    <id>tag:github.com,2023-06-18:/helmutkian/cl-wasm-runtime</id>
    <link href="https://github.com/helmutkian/cl-wasm-runtime" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Embedded WebAssembly runtime for Common Lisp&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>bohonghuang/cffi-ops</title>
    <updated>2023-06-18T01:50:11Z</updated>
    <id>tag:github.com,2023-06-18:/bohonghuang/cffi-ops</id>
    <link href="https://github.com/bohonghuang/cffi-ops" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Common Lisp library that helps write concise CFFI-related code.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+TITLE: cffi-ops Write CFFI stuff quickly without runtime overhead.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Introduction CFFI is powerful, but using its API to write C-style code can sometimes be cumbersome because it requires you to repeatedly pass in types, unlike the dot operator in C that has some type inference capabilities.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This library provides CFFI with dot operator-like functionality at compile time, allowing you to write CFFI-related code as simple as C with just a small amount of FFI type declarations.&lt;/p&gt; &#xA;&lt;p&gt;This library has been tested to work on SBCL, CCL, ECL, ABCL, and CLISP, and theoretically is portable across implementations that provide &lt;del&gt;macroexpand-all&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Rules Here is a comparison table between C syntax:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;| C | &lt;del&gt;cffi-ops&lt;/del&gt; | |--------------------------+--------------------------------------------------------------------------------| | &lt;del&gt;x-&amp;gt;y.z&lt;/del&gt; or &lt;del&gt;x-&amp;gt;y-&amp;gt;z&lt;/del&gt; | &lt;del&gt;(-&amp;gt; x y z)&lt;/del&gt; (Note that &lt;del&gt;x&lt;/del&gt;, &lt;del&gt;y&lt;/del&gt;, and &lt;del&gt;z&lt;/del&gt; must be the same symbols used in &lt;del&gt;defcstruct&lt;/del&gt;) | | &lt;del&gt;&amp;amp;x-&amp;gt;y&lt;/del&gt; | &lt;del&gt;(&amp;amp; (-&amp;gt; x y))&lt;/del&gt; | | &lt;del&gt;*x&lt;/del&gt; | &lt;del&gt;([] x)&lt;/del&gt; | | &lt;del&gt;x[n]&lt;/del&gt; | &lt;del&gt;([] x n)&lt;/del&gt; | | &lt;del&gt;&amp;amp;x[n]&lt;/del&gt; or &lt;del&gt;x + n&lt;/del&gt; | &lt;del&gt;(&amp;amp; ([] x n))&lt;/del&gt; | | &lt;del&gt;x.y = z&lt;/del&gt; | &lt;del&gt;(setf (-&amp;gt; x y) z)&lt;/del&gt; if &lt;del&gt;z&lt;/del&gt; is a variable | | | &lt;del&gt;(csetf (-&amp;gt; x y) z)&lt;/del&gt; if &lt;del&gt;z&lt;/del&gt; is a CFFI pointer | | &lt;del&gt;A _a, *a = &amp;amp;_a&lt;/del&gt; | &lt;del&gt;(clet ((a (:struct A))) ...)&lt;/del&gt; | | &lt;del&gt;A *a = malloc(sizeof(A))&lt;/del&gt; | &lt;del&gt;(clet ((a (cffi:foreign-alloc &#39;(:struct A)))) ...)&lt;/del&gt; | | &lt;del&gt;A _a = *b, *a = &amp;amp;_a&lt;/del&gt; | &lt;del&gt;(clet ((a ([] b))) ...)&lt;/del&gt; | | &lt;del&gt;A *a = b&lt;/del&gt; | &lt;del&gt;(clet ((a b)) ...)&lt;/del&gt; |&lt;/p&gt; &#xA;&lt;p&gt;Please note that since it is not possible to directly manipulate C compound types in Lisp, binding and assignment of compound types require the use of &lt;del&gt;clet&lt;/del&gt; (or &lt;del&gt;clet*&lt;/del&gt;) and &lt;del&gt;csetf&lt;/del&gt;, which bind and operate on variables that are CFFI pointers.&lt;/p&gt; &#xA;&lt;p&gt;And the symbol &lt;del&gt;-&amp;gt;&lt;/del&gt; is directly exported from the [[https://github.com/hipeta/arrow-macros][arrow-macros]] package, so this library is fully compatible with &lt;del&gt;arrow-macros&lt;/del&gt;, which means you can freely use all the macros (including &lt;del&gt;-&amp;gt;&lt;/del&gt;) provided by &lt;del&gt;arrow-macros&lt;/del&gt; inside or outside of &lt;del&gt;clocally&lt;/del&gt;, &lt;del&gt;clet&lt;/del&gt;, &lt;del&gt;clet*&lt;/del&gt;, or &lt;del&gt;csetf&lt;/del&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Example For the following C code:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;#+BEGIN_SRC c #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;assert.h&amp;gt;&lt;/p&gt; &#xA;&lt;p&gt;typedef struct { float x; float y; float z; } Vector3;&lt;/p&gt; &#xA;&lt;p&gt;typedef struct { Vector3 v1; Vector3 v2; Vector3 v3;&lt;br&gt; } Matrix3;&lt;/p&gt; &#xA;&lt;p&gt;void Vector3Add(Vector3 *output, const Vector3 *v1, const Vector3 *v2) { output-&amp;gt;x = v1-&amp;gt;x + v2-&amp;gt;x; output-&amp;gt;y = v1-&amp;gt;y + v2-&amp;gt;y; output-&amp;gt;z = v1-&amp;gt;z + v2-&amp;gt;z; }&lt;/p&gt; &#xA;&lt;p&gt;int main(int argc, char *argv[]) { Matrix3 m1[3]; m1[0].v1.x = 1.0; m1[0].v1.y = 2.0; m1[0].v1.z = 3.0; Matrix3 m2 = *m1; Vector3 *v1 = &amp;amp;m2.v1; Vector3 *v2 = malloc(sizeof(Vector3)); ,*v2 = *v1; v2-&amp;gt;x = 3.0; v2-&amp;gt;z = 1.0; Vector3Add(v1, v1, v2); assert(v1-&amp;gt;x == 4.0); assert(v1-&amp;gt;y == 4.0); assert(v1-&amp;gt;z == 4.0); free(v2); return 0; } #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;The equivalent Lisp code (written using &lt;del&gt;cffi-ops&lt;/del&gt;) is:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (defpackage cffi-ops-example (:use #:cl #:cffi #:cffi-ops))&lt;/p&gt; &#xA;&lt;p&gt;(in-package #:cffi-ops-example)&lt;/p&gt; &#xA;&lt;p&gt;(defcstruct vector3 (x :float) (y :float) (z :float))&lt;/p&gt; &#xA;&lt;p&gt;(defcstruct matrix3 (v1 (:struct vector3)) (v2 (:struct vector3)) (v3 (:struct vector3)))&lt;/p&gt; &#xA;&lt;p&gt;(defun vector3-add (output v1 v2) (clocally (declare (ctype (:pointer (:struct vector3)) output v1 v2)) (setf (-&amp;gt; output x) (+ (-&amp;gt; v1 x) (-&amp;gt; v2 x)) (-&amp;gt; output y) (+ (-&amp;gt; v1 y) (-&amp;gt; v2 y)) (-&amp;gt; output z) (+ (-&amp;gt; v1 z) (-&amp;gt; v2 z)))))&lt;/p&gt; &#xA;&lt;p&gt;(defun main () (clet ((m1 (:array (:struct matrix3) 3))) (setf (-&amp;gt; ([] m1 0) v1 x) 1.0 (-&amp;gt; ([] m1 0) v1 y) 2.0 (-&amp;gt; ([] m1 0) v1 z) 3.0) (clet* ((m2 ([] m1)) (v1 (&amp;amp; (-&amp;gt; m2 v1))) (v2 (foreign-alloc &#39;(:struct vector3)))) (csetf ([] v2) ([] v1)) (setf (-&amp;gt; v2 x) 3.0 (-&amp;gt; v2 z) 1.0) (vector3-add v1 v1 v2) (assert (= (-&amp;gt; v1 x) 4.0)) (assert (= (-&amp;gt; v1 y) 4.0)) (assert (= (-&amp;gt; v1 z) 4.0)) (foreign-free v2)))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;And the equivalent Lisp code (written without using &lt;del&gt;cffi-ops&lt;/del&gt;) is:&lt;/p&gt; &#xA;&lt;p&gt;#+BEGIN_SRC lisp (defpackage cffi-example (:use #:cl #:cffi))&lt;/p&gt; &#xA;&lt;p&gt;(in-package #:cffi-example)&lt;/p&gt; &#xA;&lt;p&gt;(defcstruct vector3 (x :float) (y :float) (z :float))&lt;/p&gt; &#xA;&lt;p&gt;(defcstruct matrix3 (v1 (:struct vector3)) (v2 (:struct vector3)) (v3 (:struct vector3)))&lt;/p&gt; &#xA;&lt;p&gt;(declaim (inline memcpy)) (defcfun &#34;memcpy&#34; :void (dest :pointer) (src :pointer) (n :size))&lt;/p&gt; &#xA;&lt;p&gt;(defun vector3-add (output v1 v2) (with-foreign-slots (((xout x) (yout y) (zout z)) output (:struct vector3)) (with-foreign-slots (((x1 x) (y1 y) (z1 z)) v1 (:struct vector3)) (with-foreign-slots (((x2 x) (y2 y) (z2 z)) v2 (:struct vector3)) (setf xout (+ x1 x2) yout (+ y1 y2) zout (+ z1 z2))))))&lt;/p&gt; &#xA;&lt;p&gt;(defun main () (with-foreign-object (m1 &#39;(:struct matrix3) 3) (with-foreign-slots ((x y z) (foreign-slot-pointer (mem-aptr m1 &#39;(:struct matrix3) 0) &#39;(:struct matrix3) &#39;v1) (:struct vector3)) (setf x 1.0 y 2.0 z 3.0)) (with-foreign-object (m2 &#39;(:struct matrix3)) (memcpy m2 m1 (foreign-type-size &#39;(:struct matrix3))) (let ((v1 (foreign-slot-pointer m2 &#39;(:struct matrix3) &#39;v1)) (v2 (foreign-alloc &#39;(:struct vector3)))) (memcpy v2 v1 (foreign-type-size &#39;(:struct vector3))) (with-foreign-slots ((x z) v2 (:struct vector3)) (setf x 3.0 z 1.0)) (vector3-add v1 v1 v2) (with-foreign-slots ((x y z) v1 (:struct vector3)) (assert (= x 4.0)) (assert (= y 4.0)) (assert (= z 4.0))) (foreign-free v2))))) #+END_SRC&lt;/p&gt; &#xA;&lt;p&gt;Both of them should generate almost equivalent machine code in SBCL and have very similar performance.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>projectured/projectured</title>
    <updated>2023-06-18T01:50:11Z</updated>
    <id>tag:github.com,2023-06-18:/projectured/projectured</id>
    <link href="https://github.com/projectured/projectured" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ProjecturEd is a generic purpose projectional editor.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;http://s9.postimage.org/mxnmsv4en/projectured.png&#34; alt=&#34;My image&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;ProjecturEd is a general purpose projectional editor written in Common Lisp.&lt;/p&gt; &#xA;&lt;p&gt;It supports the integrated presentation and editing of arbitrary problem domains. These domains potentially include but not limited to: word processing, spreadsheets, markup languages, programming languages, modelling, graphs, graphics, etc. and any combination of them. The edited data is represented in their natural, domain specific data structures (as opposed to a flat string of characters), which accommodates for the implementation of many interesting, but yet to be explored features of structured editing.&lt;/p&gt; &#xA;&lt;p&gt;It also supports multiple projections of the same data, and thus it can simultaneously provide different notations, potentially all of them editable. These views can be textual, fully graphical, or in between, and because of the internal architecture of the editor, the various projections combine well. It is expected that users would not only add new documents, but also new projections as needed.&lt;/p&gt; &#xA;&lt;h1&gt;Running the Editor&lt;/h1&gt; &#xA;&lt;p&gt;The easiest way to run the editor is to install it using &lt;a href=&#34;http://quicklisp.org&#34;&gt;Quicklisp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;1. Get a reasonably fresh SBCL&lt;/h3&gt; &#xA;&lt;p&gt;For example, on Debian Stretch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install sbcl rlwrap git libsdl2-2.0-0 libsdl2-image-2.0-0 libsdl2-ttf-2.0-0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise visit the &lt;a href=&#34;http://sbcl.org/platform-table.html&#34;&gt;SBCL website&lt;/a&gt; for instructions, and make sure you have the right version of libSDL2 libraries installed for the SDL backend.&lt;/p&gt; &#xA;&lt;h3&gt;2. Install Quicklisp&lt;/h3&gt; &#xA;&lt;p&gt;Once you have SBCL installed, you can continue with &lt;a href=&#34;http://www.quicklisp.org/beta/#installation&#34;&gt;installing Quicklisp&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ~&#xA;wget http://beta.quicklisp.org/quicklisp.lisp&#xA;&#xA;sbcl --load quicklisp.lisp --eval &#34;(quicklisp-quickstart:install)&#34; --eval &#34;(ql:add-to-init-file)&#34; --eval &#34;(exit)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To finish the installation of Quicklisp approve the prompted question.&lt;/p&gt; &#xA;&lt;h3&gt;3. Get ProjecturEd&lt;/h3&gt; &#xA;&lt;h4&gt;Get the latest from git (recommended)&lt;/h4&gt; &#xA;&lt;p&gt;If you want to play with the latest (and potentially less stable) version of ProjecturEd:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ~/quicklisp/local-projects/&#xA;git clone https://github.com/projectured/projectured.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Or get it from Quicklisp&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;sbcl --eval &#34;(ql-dist:ensure-installed (ql-dist:find-system :projectured.executable))&#34; --eval &#34;(exit)&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4. Build a standalone executable of ProjecturEd&lt;/h3&gt; &#xA;&lt;p&gt;Depending on how you got ProjecturEd, run one of the following shell scripts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;~/quicklisp/local-projects/projectured/bin/build.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sh ~/quicklisp/dists/quicklisp/software/projectured*/bin/build.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: The build log will be saved next to the build.sh script.&lt;/p&gt; &#xA;&lt;h3&gt;5. Run the editor executable&lt;/h3&gt; &#xA;&lt;p&gt;After the build has been completed you can run the editor from the command line with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ~/quicklisp/local-projects/projectured/&#xA;bin/projectured -h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a few small example documents that you can promptly start editing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ~/quicklisp/local-projects/projectured/&#xA;bin/projectured example/contact-list.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can run the editor by loading the project in your lisp. This allows experimentation with the code, changing this and that. Start SBCL with &lt;code&gt;rlwrap sbcl&lt;/code&gt;, and copy these into its REPL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ql:quickload :projectured.executable)&#xA;(projectured::executable-toplevel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If everything went fine, then you should see a window presenting an empty generic document.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ql:quickload :projectured.executable)&#xA;(projectured::executable-toplevel &#34;~/quicklisp/local-projects/projectured/example/contact-list.json&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This last example will show a window presenting an example JSON document. You can always press Control + H to get context sensitive help in the editor.&lt;/p&gt; &#xA;&lt;h3&gt;Run some of the tests&lt;/h3&gt; &#xA;&lt;p&gt;Start SBCL with &lt;code&gt;rlwrap sbcl&lt;/code&gt;, and copy these into its REPL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ql:quickload :projectured.sdl.test)&#xA;(projectured.test::test)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will run the automated test suite and print the result in the REPL.&lt;/p&gt; &#xA;&lt;h3&gt;Troubleshooting&lt;/h3&gt; &#xA;&lt;h4&gt;Isolate locally installed libraries&lt;/h4&gt; &#xA;&lt;p&gt;If you have some Common Lisp libraries installed somewhere on your system, then try to make sure that nothing besides what&#39;s in quicklisp gets loaded. You can achieve that by adding the following to the beginning of your .sbclrc:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(require :asdf)&#xA;(funcall (read-from-string &#34;asdf:initialize-source-registry&#34;)&#xA;         &#39;(:source-registry :ignore-inherited-configuration))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Too old ASDF&lt;/h4&gt; &#xA;&lt;p&gt;If you get ASDF realted errors then try to clone the latest ASDF release:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ~/quicklisp/local-projects/&#xA;git clone https://gitlab.common-lisp.net/asdf/asdf.git --branch release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Loading without building an executable&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ql:quickload &#39;(:projectured.executable :hu.dwim.def+swank))&#xA;(projectured::executable-toplevel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Collaboration&lt;/h1&gt; &#xA;&lt;p&gt;It&#39;s an unfunded opensource project, under much slower development than we would like it to be. If you want to help us, either financially or with your patches, then feel free to get in touch at &lt;a href=&#34;mailto:projectured@gmail.com&#34;&gt;projectured@gmail.com&lt;/a&gt; or the &lt;a href=&#34;http://groups.google.com/d/forum/projectured&#34;&gt;google group&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Donation&lt;/h3&gt; &#xA;&lt;p&gt;The less we need to work to pay our bills, the more we can work on ProjecturEd. Bitcoin donations are welcome to the following address: 15XjRQUnSy8U7j2EFZyGFAi2KFnDnTEwqZ&lt;/p&gt; &#xA;&lt;h3&gt;Wiki&lt;/h3&gt; &#xA;&lt;p&gt;There&#39;s a separate &lt;a href=&#34;https://github.com/projectured/projectured/wiki&#34;&gt;&lt;strong&gt;wiki&lt;/strong&gt;&lt;/a&gt; with an increasing number of pages. It gives an overview of the whole idea, and it also allows contributing documentation to the project.&lt;/p&gt; &#xA;&lt;h3&gt;Documentation&lt;/h3&gt; &#xA;&lt;p&gt;Currently the best thing to do is to look at the source code. Luckily the codebase is relatively small (around 20k LoC).&lt;/p&gt; &#xA;&lt;h3&gt;Check out the latest version&lt;/h3&gt; &#xA;&lt;p&gt;If you want to try the latest version, then you should git clone the repository into &lt;code&gt;~/quicklisp/local-projects/&lt;/code&gt; and Quicklisp will automatically use that version instead of the snapshot from its archives.&lt;/p&gt; &#xA;&lt;h1&gt;Status&lt;/h1&gt; &#xA;&lt;p&gt;ProjecturEd is work in progress, and at this stage it&#39;s interesting primarily for programmers who are ready to experiment with it.&lt;/p&gt; &#xA;&lt;h3&gt;Screenshots&lt;/h3&gt; &#xA;&lt;p&gt;If you would like to take a look at the editor in action, then look at this &lt;a href=&#34;https://github.com/projectured/projectured/wiki/Screenshots&#34;&gt;&lt;strong&gt;page&lt;/strong&gt;&lt;/a&gt;. It contains a couple of screenshots showing various problem domains using different projections. Please note that these screenshots are somewhat outdated.&lt;/p&gt; &#xA;&lt;h3&gt;Videos&lt;/h3&gt; &#xA;&lt;p&gt;There are some &lt;a href=&#34;http://www.youtube.com/user/projectured&#34;&gt;screencasts on youtube&lt;/a&gt; that shows the editor in action and demonstrate certain features.&lt;/p&gt; &#xA;&lt;h3&gt;Performance&lt;/h3&gt; &#xA;&lt;p&gt;The printer and the reader are written using a &#34;purely functional&#34; constraint based change propagation algorithm that allows lazy and incremental computation of results. So, the infrastructure is in place to be fast enough to be useful one day...&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/projectured/projectured/wiki/License&#34;&gt;BSD License&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Happy hacking!&lt;/p&gt;</summary>
  </entry>
</feed>