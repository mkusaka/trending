<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Common Lisp Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-07T01:45:45Z</updated>
  <subtitle>Weekly Trending of Common Lisp in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jetmonk/cl-pigpio</title>
    <updated>2024-01-07T01:45:45Z</updated>
    <id>tag:github.com,2024-01-07:/jetmonk/cl-pigpio</id>
    <link href="https://github.com/jetmonk/cl-pigpio" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Common Lisp interface to the pigpio Raspberry Pi hardware library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CL-PIGPIO&lt;/h1&gt; &#xA;&lt;p&gt;A Common Lisp interface to the Rapsberry Pi &lt;a href=&#34;https://abyz.me.uk/rpi/pigpio/&#34;&gt;pigpio&lt;/a&gt; library (&lt;a href=&#34;https://github.com/joan2937/pigpio&#34;&gt;pigpio on github&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://abyz.me.uk/rpi/pigpio/&#34;&gt;&lt;em&gt;pigpio&lt;/em&gt;&lt;/a&gt; is a library to provide a simplified interface to the Raspberry Pi&#39;s hardware devices, like SPI, I2C, Serial, and GPIO.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;pigpio&lt;/em&gt; has 1) a direct hardware version (linking with &lt;em&gt;libpigpio.so&lt;/em&gt;) that requires the program using it to run as root; and 2) a &lt;em&gt;pigpiod&lt;/em&gt; daemon (linked with &lt;em&gt;libpigpiod_if2.so&lt;/em&gt;) that allows user-land programs to accesss hardware via network calls to the daemon.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;CL-PIGPIO&lt;/em&gt; links with both libraries, and allows the user to select whether the hardware or the daemon form is called. If the hardware version is activated but the user&#39;s program is not running with root privileges, an error is generated.&lt;/p&gt; &#xA;&lt;p&gt;Only one of the two (hardware or daemon) can be run on the same RPi, but the daemon on other RPis can be accessed remotely.&lt;/p&gt; &#xA;&lt;h3&gt;Installing&lt;/h3&gt; &#xA;&lt;p&gt;Install in your usual Lisp package tree and run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(asdf:load-system &#34;cl-pigpio&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or, for just the low level FFI, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(asdf:load-system &#34;pigpio-ffi-universal&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Low level FFI interface&lt;/h2&gt; &#xA;&lt;p&gt;The unified &lt;em&gt;pigpio/pigpiod&lt;/em&gt; interface is in the &lt;em&gt;pigpio-ffi-universal&lt;/em&gt; package.&lt;/p&gt; &#xA;&lt;p&gt;Here, the routines are generally the same as &lt;a href=&#34;https://abyz.me.uk/rpi/pigpio/cif.html&#34;&gt;documented in the C pigpio interface&lt;/a&gt; but with an additional keyword device specifier.&lt;/p&gt; &#xA;&lt;p&gt;For example, if the C library has&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  int i2cOpen(unsigned i2cBus, unsigned i2cAddr, unsigned i2cFlags);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then the Lisp version has&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  (pigpio-ffi-universal:pigpio-i2copen&#xA;         i2cbus i2caddr i2cflags&#xA;         &amp;amp;key (pidev pigpio-ffi-unversal:*default-pidev*))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;em&gt;pidev&lt;/em&gt; keyword argument can be set as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  ;; daemon form, setting *default-pidev* to this device&#xA;  (pigpio-ffi-universal:open-pidev/daemon :host &#34;localhost&#34; :port &#34;8888&#34;&#xA;                                          :set-default t)&#xA;  ;; OR open hardware device, this time not setting the default variable&#xA;  (defparameter *my-pidev*&#xA;     (pigpio-ffi-universal:open-pidev/hardware :set-default nil))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is necessary to open a device before making any pigpio/pigpiod calls.&lt;/p&gt; &#xA;&lt;h2&gt;Higher level interface&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;em&gt;cl-pigpio&lt;/em&gt; package contains a higher level interface to SPI, I2C, and GPIO.&lt;/p&gt; &#xA;&lt;p&gt;This interface is not documented in detail, but the exported functions are visible in &lt;em&gt;cl-pigpio-package.lisp&lt;/em&gt;, and the functions generally have good documentation strings. I2C, SPI, and GPIO have separate source files.&lt;/p&gt; &#xA;&lt;p&gt;The purpose of the higher level interface is to translate opaque data like I2C flags into more easily understable Lisp keywords, and to perform FFI calls using Lisp buffers rather than using CFFI foreign pointers.&lt;/p&gt; &#xA;&lt;p&gt;The high level routines also throw a descriptive Lisp error if the pigpio library returns an error.&lt;/p&gt; &#xA;&lt;h2&gt;Glitches and gotchas&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;pigpio does not work for RPi5 (yet?) because hardware interface is not documented&lt;/li&gt; &#xA; &lt;li&gt;signals are turned off in the hardware version using &lt;code&gt;gpioCfgGetInternals()&lt;/code&gt; to prevent clashes with any Lisp use of signals.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;Tested with 64 bit SBCL, on Bookworm.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cffi/cffi&#34;&gt;&lt;em&gt;cffi&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/joan2937/pigpio&#34;&gt;&lt;em&gt;pigpio&lt;/em&gt;&lt;/a&gt;, which can be installed as a standard RPi Linux package.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>rotatef/gettext</title>
    <updated>2024-01-07T01:45:45Z</updated>
    <id>tag:github.com,2024-01-07:/rotatef/gettext</id>
    <link href="https://github.com/rotatef/gettext" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A port of gettext runtime to Common Lisp&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;gettext for Common Lisp&lt;/h1&gt; &#xA;&lt;p&gt;This is a port of the GNU gettext runtime to Common Lisp. For more information about GNU gettext see &lt;a href=&#34;http://www.gnu.org/software/gettext/&#34;&gt;http://www.gnu.org/software/gettext/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Highlights&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Implemented in Common Lisp. No need for any C libraries.&lt;/li&gt; &#xA; &lt;li&gt;Use GNU gettext tools during development.&lt;/li&gt; &#xA; &lt;li&gt;Supports multithreaded applications with different langauge in each thread.&lt;/li&gt; &#xA; &lt;li&gt;Translations can be embedded into compiled applications.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Download and installation&lt;/h2&gt; &#xA;&lt;p&gt;The libarary has some dependencies, so the easiest way is to use Quicklisp, see &lt;a href=&#34;http://www.quicklisp.org/&#34;&gt;http://www.quicklisp.org/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Get the gettext sources from GitHub:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd quicklisp/local-projects&#xA;git clone git://github.com/copyleft/gettext.git&#xA;ln -s gettext/gettext-example .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then load it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(ql:quickload &#34;gettext&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Eventually gettext will become part of quicklisp, and only the last step will be neccary (unless you need the latest version).&lt;/p&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;p&gt;This library reimplements only the runtime part of GNU gettext in Common Lisp. In order to successfully use this library you need to install the GNU gettext tools. No GNU gettext tools or library are needed at runtime.&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to get started is to look at the sample application located in the subdirectory gettext-example.&lt;/p&gt; &#xA;&lt;p&gt;Step 1: Add gettext as a dependency to your system definition (gettext-example.asd):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:depends-on (:gettext)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Step 2: Add the GETTEXT package to the use list of you applications package. Setup gettext in your applications package (package.lisp):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(gettext:setup-gettext #:example &#34;gettext-example&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first parameter is the name of the package. The second parameter is the textdomain. Textdomains are namespaces for the translated text. For most application a single textdomain (with the same name as the asdf system) will suffice.&lt;/p&gt; &#xA;&lt;p&gt;Step 3: Load the translated messages (example.lisp):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(preload-catalogs #.(asdf:system-relative-pathname :gettext-example &#34;locale/&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This macro takes a single parameter, the pathname of a directory tree containing translation catalogs in MO format. The texts are loaded at compile time and become part of the compiled file, thus the the MO files are not need at runtime. An alternative approch is to load the MO files at runtime, see the section &#34;Loading catalogs at runtime&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Step 4: Make sure the current locale is set by binding the special variable GETTEXT:&lt;em&gt;CURRENT-LOCALE&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setf *current-locale* &#34;nn&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here the locale is hardcoded to &#34;nn&#34;. In a real world application it would be set to the current users preferred language. If the application is a multithreaded multiuser application (like most web applications), dynamically bind GETTEXT:&lt;em&gt;CURRENT-LOCALE&lt;/em&gt; to the logged in users preferred language.&lt;/p&gt; &#xA;&lt;p&gt;Step 5: Mark texts for translation, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(write-line (_ &#34;This is an example gettext program.&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Extract the texts for translations using the xgettext program from GNU gettext. This step will have to be repeated whenver the texts are updated in the source code. See update-translations.sh for a script that automates this job.&lt;/p&gt; &#xA;&lt;p&gt;Step 6: Translate the texts. First create a PO file for the langauge, using the msginit tool. Then you edit this file using e.g. Emacs with po-mode. The PO file can easly be updated with new texts with the help of the msgmerge tool. See update-translations.sh.&lt;/p&gt; &#xA;&lt;p&gt;Step 7: Finally convert the PO files into MO files using msgfmt. See update-translations.sh for details.&lt;/p&gt; &#xA;&lt;h2&gt;Loading catalogs at runtime&lt;/h2&gt; &#xA;&lt;p&gt;Replace GETTEXT:PRELOAD-CATALOGS with a SETF of the place GETTEXT:TEXTDOMAINDIR:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(setf (textdomaindir &#34;gettext-example&#34;)&#xA;      (asdf:system-relative-pathname :gettext-example &#34;locale/&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The catalogs will be loaded as needed and cached until the appliciatons quits.&lt;/p&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;p&gt;Special variable GETTEXT:&lt;em&gt;CURRENT-LOCALE&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;This variable must be bound to a string denoting the current locale. The library does not try to decode this string any way, it simply uses it to look for message catalogs in the file system. It&#39;s recommended to use the two letter language codes defined in ISO 639-1. A list can be found here: &lt;a href=&#34;http://www.gnu.org/software/gettext/manual/gettext.html#Language-Codes&#34;&gt;http://www.gnu.org/software/gettext/manual/gettext.html#Language-Codes&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Macro GETTEXT:SETUP-GETTEXT package default-domain&lt;/p&gt; &#xA;&lt;p&gt;Defines gettext lookup functions in the provided package. _ and GETTEXT is as shortcut for GETTEXT:GETTEXT* and NGETTEXT is a shortcut for GETTEXT:NGETTEXT*, but with default-domain as the default domain. N_ is simply a shortcut for GETTEXT:GETTEXT-NOOP.&lt;/p&gt; &#xA;&lt;p&gt;Place GETTEXT:TEXTDOMAINDIR domain (SETF (GETTEXT:TEXTDOMAINDIR domain) directory)&lt;/p&gt; &#xA;&lt;p&gt;Specifies where to find translation catalogs for the given domain. The directory is the base directory used for lookup. The actual name of message catalog will be TEXTDOMAINDIR/l/LC_MESSAGES/domain.mo, where TEXTDOMAINDIR is the directory given setf to GETTEXT:TEXTDOMAINDIR, l is the current locale, LC_MESSAGES is the category and domain is the text domain.&lt;/p&gt; &#xA;&lt;p&gt;Place GETTEXT:TEXTDOMAIN (SETF (GETTEXT:TEXTDOMAIN) domain)&lt;/p&gt; &#xA;&lt;p&gt;Returns or sets the default text domain used by GETTEXT:GETTEXT* and GETTEXT:NGETTEXT*. Shortcut lookup functions defined by GETTEXT:SETUP-GETTEXT ignores this place.&lt;/p&gt; &#xA;&lt;p&gt;Function GETTEXT:GETTEXT* msgid &amp;amp;optional domain category locale&lt;/p&gt; &#xA;&lt;p&gt;Lookup a translated using the provided msgid. Domain defaults to (GETTEXT:TEXTDOMAIN). Category defaults to :LC_MESSAGES, and locale defaults to GETTEXT:&lt;em&gt;CURRENT-LOCALE&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Function GETTEXT:NGETTEXT* msgid1 msgid2 n &amp;amp;optional domain category locale&lt;/p&gt; &#xA;&lt;p&gt;Lookup a plural translated text. msgid1 is the singular form, msgid2 is the plural form and n is the number used to decide which plural form to use. See GETTEXT:GETTEXT* for description of the optional parameters.&lt;/p&gt; &#xA;&lt;p&gt;Function GETTEXT:GETTEXT-NOOP msgid&lt;/p&gt; &#xA;&lt;p&gt;This function simply returns its msgid parameter untranslated. It&#39;s only used to mark texts that shall be translated, but where the text occurs in an expression that will be executed at compile time. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(defparameter *greeting* (gettext-noop &#34;Hello world&#34;))&#xA;;; In some function:&#xA;   (write-line (gettext* *greeting*))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Macro GETTEXT:PRELOAD-CATALOGS textdomaindir&lt;/p&gt; &#xA;&lt;p&gt;Loads all message catalogs (in every category, in every locale and every domain) in the textdomaindir directory tree. This loading is done at macro expantion time. The effects is as if the translated text where part of the source code. Thus, the message catalogs are not needed at runtime.&lt;/p&gt; &#xA;&lt;p&gt;Type GETTEXT:LC-CATEGORY&lt;/p&gt; &#xA;&lt;p&gt;The allowed type of the locale parameter. One of the keyword symbols L:LC_ADDRESS, :LC_ALL, :LC_COLLATE, :LC_CTYPE, :LC_IDENTIFICATION, :LC_MEASUREMENT, :LC_MESSAGES, :LC_MONETARY, :LC_NAME, :LC_NUMERIC, :LC_PAPER, :LC_TELEPHONE and :LC_TIME.&lt;/p&gt; &#xA;&lt;p&gt;Function GETTEXT:CATALOG-META* &amp;amp;optional domain category locale&lt;/p&gt; &#xA;&lt;p&gt;Returns meta data about catalog as an assoc list. See &lt;a href=&#34;https://www.gnu.org/software/gettext/manual/gettext.html#Header-Entry&#34;&gt;https://www.gnu.org/software/gettext/manual/gettext.html#Header-Entry&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;p&gt;The pgettext function of GNU gettext is not implemented. Implementing this should be fairly stright forward, but apparently the xgettext tool doesn&#39;t support this function when extracting texts form Lisp code.&lt;/p&gt; &#xA;&lt;p&gt;Encoding in MO files is hardcoded to UTF-8. Is this really a problem? Is there really a good reason for using anything else these days?&lt;/p&gt;</summary>
  </entry>
</feed>