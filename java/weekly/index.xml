<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-01T01:40:42Z</updated>
  <subtitle>Weekly Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>PaperMC/Folia</title>
    <updated>2025-06-01T01:40:42Z</updated>
    <id>tag:github.com,2025-06-01:/PaperMC/Folia</id>
    <link href="https://github.com/PaperMC/Folia" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fork of Paper which adds regionised multithreading to the dedicated server.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/PaperMC/Folia/ver/1.21.5/folia.png&#34;&gt; &#xA; &lt;br&gt;&#xA; &lt;br&gt; &#xA; &lt;p&gt;Fork of &lt;a href=&#34;https://github.com/PaperMC/Paper&#34;&gt;Paper&lt;/a&gt; which adds regionised multithreading to the dedicated server.&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Folia groups nearby loaded chunks to form an &#34;independent region.&#34; See &lt;a href=&#34;https://docs.papermc.io/folia/reference/region-logic&#34;&gt;the PaperMC documentation&lt;/a&gt; for exact details on how Folia will group nearby chunks. Each independent region has its own tick loop, which is ticked at the regular Minecraft tickrate (20TPS). The tick loops are executed on a thread pool in parallel. There is no main thread anymore, as each region effectively has its own &#34;main thread&#34; that executes the entire tick loop.&lt;/p&gt; &#xA;&lt;p&gt;For a server with many spread out players, Folia will create many spread out regions and tick them all in parallel on a configurable sized threadpool. Thus, Folia should scale well for servers like this.&lt;/p&gt; &#xA;&lt;p&gt;Folia is also its own project, this will not be merged into Paper for the foreseeable future.&lt;/p&gt; &#xA;&lt;p&gt;A more detailed but abstract overview: &lt;a href=&#34;https://docs.papermc.io/folia/reference/overview&#34;&gt;Project overview&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;What server types can benefit from Folia?&lt;/h3&gt; &#xA;&lt;p&gt;Server types that naturally spread players out, like skyblock or SMP, will benefit the most from Folia. The server should have a sizeable player count, too.&lt;/p&gt; &#xA;&lt;h3&gt;What hardware will Folia run best on?&lt;/h3&gt; &#xA;&lt;p&gt;Ideally, at least 16 &lt;em&gt;cores&lt;/em&gt; (not threads).&lt;/p&gt; &#xA;&lt;h3&gt;How to best configure Folia?&lt;/h3&gt; &#xA;&lt;p&gt;First, it is recommended that the world is pre-generated so that the number of chunk system worker threads required is reduced greatly.&lt;/p&gt; &#xA;&lt;p&gt;The following is a &lt;em&gt;very rough&lt;/em&gt; estimation based off of the testing done before Folia was released on the test server we ran that had ~330 players peak. So, it is not exact and will require further tuning - just take it as a starting point.&lt;/p&gt; &#xA;&lt;p&gt;The total number of cores on the machine available should be taken into account. Then, allocate threads for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;netty IO :~4 per 200-300 players&lt;/li&gt; &#xA; &lt;li&gt;chunk system io threads: ~3 per 200-300 players&lt;/li&gt; &#xA; &lt;li&gt;chunk system workers if pre-generated, ~2 per 200-300 players&lt;/li&gt; &#xA; &lt;li&gt;There is no best guess for chunk system workers if not pre-generated, as on the test server we ran we gave 16 threads but chunk generation was still slow at ~300 players.&lt;/li&gt; &#xA; &lt;li&gt;GC Settings: ???? But, GC settings &lt;em&gt;do&lt;/em&gt; allocate concurrent threads, and you need to know exactly how many. This is typically through the &lt;code&gt;-XX:ConcGCThreads=n&lt;/code&gt; flag. Do not confuse this flag with &lt;code&gt;-XX:ParallelGCThreads=n&lt;/code&gt;, as parallel GC threads only run when the application is paused by GC and as such should not be taken into account.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After all of that allocation, the remaining cores on the system until 80% allocation (total threads allocated &amp;lt; 80% of cpus available) can be allocated to tickthreads (under global config, threaded-regions.threads).&lt;/p&gt; &#xA;&lt;p&gt;The reason you should not allocate more than 80% of the cores is due to the fact that plugins or even the server may make use of additional threads that you cannot configure or even predict.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, the above is all a rough guess based on player count, but it is very likely that the thread allocation will not be ideal, and you will need to tune it based on usage of the threads that you end up seeing.&lt;/p&gt; &#xA;&lt;h2&gt;Plugin compatibility&lt;/h2&gt; &#xA;&lt;p&gt;There is no more main thread. I expect &lt;em&gt;every&lt;/em&gt; single plugin that exists to require &lt;em&gt;some&lt;/em&gt; level of modification to function in Folia. Additionally, multithreading of &lt;em&gt;any kind&lt;/em&gt; introduces possible race conditions in plugin held data - so, there are bound to be changes that need to be made.&lt;/p&gt; &#xA;&lt;p&gt;So, have your expectations for compatibility at 0.&lt;/p&gt; &#xA;&lt;h2&gt;API plans&lt;/h2&gt; &#xA;&lt;p&gt;Currently, there is a lot of API that relies on the main thread. I expect basically zero plugins that are compatible with Paper to be compatible with Folia. However, there are plans to add API that would allow Folia plugins to be compatible with Paper.&lt;/p&gt; &#xA;&lt;p&gt;For example, the Bukkit Scheduler. The Bukkit Scheduler inherently relies on a single main thread. Folia&#39;s RegionScheduler and Folia&#39;s EntityScheduler allow scheduling of tasks to the &#34;next tick&#34; of whatever region &#34;owns&#34; either a location or an entity. These could be implemented on regular Paper, except they schedule to the main thread - in both cases, the execution of the task will occur on the thread that &#34;owns&#34; the location or entity. This concept applies in general, as the current Paper (single threaded) can be viewed as one giant &#34;region&#34; that encompasses all chunks in all worlds.&lt;/p&gt; &#xA;&lt;p&gt;It is not yet decided whether to add this API to Paper itself directly or to Paperlib.&lt;/p&gt; &#xA;&lt;h3&gt;The new rules&lt;/h3&gt; &#xA;&lt;p&gt;First, Folia breaks many plugins. To aid users in figuring out which plugins work, only plugins that have been explicitly marked by the author(s) to work with Folia will be loaded. By placing &#34;folia-supported: true&#34; into the plugin&#39;s plugin.yml, plugin authors can mark their plugin as compatible with regionised multithreading.&lt;/p&gt; &#xA;&lt;p&gt;The other important rule is that the regions tick in &lt;em&gt;parallel&lt;/em&gt;, and not &lt;em&gt;concurrently&lt;/em&gt;. They do not share data, they do not expect to share data, and sharing of data &lt;em&gt;will&lt;/em&gt; cause data corruption. Code that is running in one region under no circumstance can be accessing or modifying data that is in another region. Just because multithreading is in the name, it doesn&#39;t mean that everything is now thread-safe. In fact, there are only a &lt;em&gt;few&lt;/em&gt; things that were made thread-safe to make this happen. As time goes on, the number of thread context checks will only grow, even &lt;em&gt;if&lt;/em&gt; it comes at a performance penalty - &lt;em&gt;nobody&lt;/em&gt; is going to use or develop for a server platform that is buggy as hell, and the only way to prevent and find these bugs is to make bad accesses fail &lt;em&gt;hard&lt;/em&gt; at the source of the bad access.&lt;/p&gt; &#xA;&lt;p&gt;This means that Folia compatible plugins need to take advantage of API like the RegionScheduler and the EntityScheduler to ensure their code is running on the correct thread context.&lt;/p&gt; &#xA;&lt;p&gt;In general, it is safe to assume that a region owns chunk data in an approximate 8 chunks from the source of an event (i.e. player breaks block, can probably access 8 chunks around that block). But, this is not guaranteed - plugins should take advantage of upcoming thread-check API to ensure correct behavior.&lt;/p&gt; &#xA;&lt;p&gt;The only guarantee of thread-safety comes from the fact that a single region owns data in certain chunks - and if that region is ticking, then it has full access to that data. This data is specifically entity/chunk/poi data, and is entirely unrelated to &lt;strong&gt;ANY&lt;/strong&gt; plugin data.&lt;/p&gt; &#xA;&lt;p&gt;Normal multithreading rules apply to data that plugins store/access their own data or another plugin&#39;s - events/commands/etc. are called in &lt;em&gt;parallel&lt;/em&gt; because regions are ticking in &lt;em&gt;parallel&lt;/em&gt; (we CANNOT call them in a synchronous fashion, as this opens up deadlock issues and would handicap performance). There are no easy ways out of this, it depends solely on what data is being accessed. Sometimes a concurrent collection (like ConcurrentHashMap) is enough, and often a concurrent collection used carelessly will only &lt;em&gt;hide&lt;/em&gt; threading issues, which then become near impossible to debug.&lt;/p&gt; &#xA;&lt;h3&gt;Current API additions&lt;/h3&gt; &#xA;&lt;p&gt;To properly understand API additions, please read &lt;a href=&#34;https://docs.papermc.io/folia/reference/overview&#34;&gt;Project overview&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RegionScheduler, AsyncScheduler, GlobalRegionScheduler, and EntityScheduler acting as a replacement for the BukkitScheduler. The entity scheduler is retrieved via Entity#getScheduler, and the rest of the schedulers can be retrieved from the Bukkit/Server classes.&lt;/li&gt; &#xA; &lt;li&gt;Bukkit#isOwnedByCurrentRegion to test if the current ticking region owns positions/entities&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Thread contexts for API&lt;/h3&gt; &#xA;&lt;p&gt;To properly understand API additions, please read &lt;a href=&#34;https://docs.papermc.io/folia/reference/overview&#34;&gt;Project overview&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;General rules of thumb:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Commands for entities/players are called on the region which owns the entity/player. Console commands are executed on the global region.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Events involving a single entity (i.e player breaks/places block) are called on the region owning entity. Events involving actions on an entity (such as entity damage) are invoked on the region owning the target entity.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The async modifier for events is deprecated - all events fired from regions or the global region are considered &lt;em&gt;synchronous&lt;/em&gt;, even though there is no main thread anymore.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Current broken API&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Most API that interacts with portals / respawning players / some player login API is broken.&lt;/li&gt; &#xA; &lt;li&gt;ALL scoreboard API is considered broken (this is global state that I&#39;ve not figured out how to properly implement yet)&lt;/li&gt; &#xA; &lt;li&gt;World loading/unloading&lt;/li&gt; &#xA; &lt;li&gt;Entity#teleport. This will NEVER UNDER ANY CIRCUMSTANCE come back, use teleportAsync&lt;/li&gt; &#xA; &lt;li&gt;Could be more&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Planned API additions&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Proper asynchronous events. This would allow the result of an event to be completed later, on a different thread context. This is required to implement some things like spawn position select, as asynchronous chunk loads are required when accessing chunk data out-of-region.&lt;/li&gt; &#xA; &lt;li&gt;World loading/unloading&lt;/li&gt; &#xA; &lt;li&gt;More to come here&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Planned API changes&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Super aggressive thread checks across the board. This is absolutely required to prevent plugin devs from shipping code that may randomly break random parts of the server in entirely &lt;em&gt;undiagnosable&lt;/em&gt; manners.&lt;/li&gt; &#xA; &lt;li&gt;More to come here&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Maven information&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Maven Repo (for folia-api):&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;repository&amp;gt;&#xA;    &amp;lt;id&amp;gt;papermc&amp;lt;/id&amp;gt;&#xA;    &amp;lt;url&amp;gt;https://repo.papermc.io/repository/maven-public/&amp;lt;/url&amp;gt;&#xA;&amp;lt;/repository&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Artifact Information:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;dev.folia&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;folia-api&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;1.20.1-R0.1-SNAPSHOT&amp;lt;/version&amp;gt;&#xA;    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The PATCHES-LICENSE file describes the license for api &amp;amp; server patches, found in &lt;code&gt;./patches&lt;/code&gt; and its subdirectories except when noted otherwise.&lt;/p&gt; &#xA;&lt;p&gt;The fork is based off of PaperMC&#39;s fork example found &lt;a href=&#34;https://github.com/PaperMC/paperweight-examples&#34;&gt;here&lt;/a&gt;. As such, it contains modifications to it in this project, please see the repository for license information of modified files.&lt;/p&gt;</summary>
  </entry>
</feed>