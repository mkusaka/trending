<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-05-11T01:39:51Z</updated>
  <subtitle>Weekly Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jhy/jsoup</title>
    <updated>2025-05-11T01:39:51Z</updated>
    <id>tag:github.com,2025-05-11:/jhy/jsoup</id>
    <link href="https://github.com/jhy/jsoup" rel="alternate"></link>
    <summary type="html">&lt;p&gt;jsoup: the Java HTML parser, built for HTML editing, cleaning, scraping, and XSS safety.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;jsoup: Java HTML Parser&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;jsoup&lt;/strong&gt; is a Java library that makes it easy to work with real-world HTML and XML. It offers an easy-to-use API for URL fetching, data parsing, extraction, and manipulation using DOM API methods, CSS, and xpath selectors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;jsoup&lt;/strong&gt; implements the &lt;a href=&#34;https://html.spec.whatwg.org/multipage/&#34;&gt;WHATWG HTML5&lt;/a&gt; specification, and parses HTML to the same DOM as modern browsers.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;scrape and &lt;a href=&#34;https://jsoup.org/cookbook/input/parse-document-from-string&#34;&gt;parse&lt;/a&gt; HTML from a URL, file, or string&lt;/li&gt; &#xA; &lt;li&gt;find and &lt;a href=&#34;https://jsoup.org/cookbook/extracting-data/selector-syntax&#34;&gt;extract data&lt;/a&gt;, using DOM traversal or CSS selectors&lt;/li&gt; &#xA; &lt;li&gt;manipulate the &lt;a href=&#34;https://jsoup.org/cookbook/modifying-data/set-html&#34;&gt;HTML elements&lt;/a&gt;, attributes, and text&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jsoup.org/cookbook/cleaning-html/safelist-sanitizer&#34;&gt;clean&lt;/a&gt; user-submitted content against a safe-list, to prevent XSS attacks&lt;/li&gt; &#xA; &lt;li&gt;output tidy HTML&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;jsoup is designed to deal with all varieties of HTML found in the wild; from pristine and validating, to invalid tag-soup; jsoup will create a sensible parse tree.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://jsoup.org/&#34;&gt;&lt;strong&gt;jsoup.org&lt;/strong&gt;&lt;/a&gt; for downloads and the full &lt;a href=&#34;https://jsoup.org/apidocs/&#34;&gt;API documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jhy/jsoup/actions?query=workflow%3ABuild&#34;&gt;&lt;img src=&#34;https://github.com/jhy/jsoup/workflows/Build/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Fetch the &lt;a href=&#34;https://en.wikipedia.org/wiki/Main_Page&#34;&gt;Wikipedia&lt;/a&gt; homepage, parse it to a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction&#34;&gt;DOM&lt;/a&gt;, and select the headlines from the &lt;em&gt;In the News&lt;/em&gt; section into a list of &lt;a href=&#34;https://jsoup.org/apidocs/org/jsoup/select/Elements.html&#34;&gt;Elements&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Document doc = Jsoup.connect(&#34;https://en.wikipedia.org/&#34;).get();&#xA;log(doc.title());&#xA;Elements newsHeadlines = doc.select(&#34;#mp-itn b a&#34;);&#xA;for (Element headline : newsHeadlines) {&#xA;  log(&#34;%s\n\t%s&#34;, &#xA;    headline.attr(&#34;title&#34;), headline.absUrl(&#34;href&#34;));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://try.jsoup.org/~LGB7rk_atM2roavV0d-czMt3J_g&#34;&gt;Online sample&lt;/a&gt;, &lt;a href=&#34;https://github.com/jhy/jsoup/raw/master/src/main/java/org/jsoup/examples/Wikipedia.java&#34;&gt;full source&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Open source&lt;/h2&gt; &#xA;&lt;p&gt;jsoup is an open source project distributed under the liberal &lt;a href=&#34;https://jsoup.org/license&#34;&gt;MIT license&lt;/a&gt;. The source code is available on &lt;a href=&#34;https://github.com/jhy/jsoup&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jsoup.org/download&#34;&gt;Download&lt;/a&gt; the latest jsoup jar (or add it to your Maven/Gradle build)&lt;/li&gt; &#xA; &lt;li&gt;Read the &lt;a href=&#34;https://jsoup.org/cookbook/&#34;&gt;cookbook&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Enjoy!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Android support&lt;/h3&gt; &#xA;&lt;p&gt;When used in Android projects, &lt;a href=&#34;https://developer.android.com/studio/write/java8-support#library-desugaring&#34;&gt;core library desugaring&lt;/a&gt; with the &lt;a href=&#34;https://developer.android.com/studio/write/java11-nio-support-table&#34;&gt;NIO specification&lt;/a&gt; should be enabled to support Java 8+ features.&lt;/p&gt; &#xA;&lt;h2&gt;Development and support&lt;/h2&gt; &#xA;&lt;p&gt;If you have any questions on how to use jsoup, or have ideas for future development, please get in touch via &lt;a href=&#34;https://github.com/jhy/jsoup/discussions&#34;&gt;jsoup Discussions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you find any issues, please file a &lt;a href=&#34;https://jsoup.org/bugs&#34;&gt;bug&lt;/a&gt; after checking for duplicates.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://jsoup.org/colophon&#34;&gt;colophon&lt;/a&gt; talks about the history of and tools used to build jsoup.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;jsoup is in general, stable release.&lt;/p&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;jsoup was created and is maintained by &lt;a href=&#34;https://raw.githubusercontent.com/jhedley.com&#34;&gt;Jonathan Hedley&lt;/a&gt;, its primary author.&lt;/p&gt; &#xA;&lt;p&gt;jsoup is an open-source project, and many contributors have helped improve it over the years. You can see their contributions and join the development on &lt;a href=&#34;https://github.com/jhy/jsoup/graphs/contributors&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Citing jsoup&lt;/h2&gt; &#xA;&lt;p&gt;If you use jsoup in research or technical documentation, you can cite it as:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Jonathan Hedley &amp;amp; jsoup contributors. jsoup: Java HTML Parser (2009â€“present).&lt;/strong&gt; Available at: &lt;a href=&#34;https://jsoup.org&#34;&gt;https://jsoup.org&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;@misc{jsoup,&#xA;  author = {Jonathan Hedley and jsoup contributors},&#xA;  title = {jsoup: Java HTML Parser},&#xA;  year = {2025},&#xA;  url = {https://jsoup.org}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>RikkaApps/Shizuku-API</title>
    <updated>2025-05-11T01:39:51Z</updated>
    <id>tag:github.com,2025-05-11:/RikkaApps/Shizuku-API</id>
    <link href="https://github.com/RikkaApps/Shizuku-API" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The API and the developer guide for Shizuku and Sui.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Shizuku-API&lt;/h1&gt; &#xA;&lt;p&gt;Shizuku API is the API provided by &lt;a href=&#34;https://github.com/RikkaApps/Shizuku&#34;&gt;Shizuku&lt;/a&gt; and &lt;a href=&#34;https://github.com/RikkaApps/Sui&#34;&gt;Sui&lt;/a&gt;. With Shizuku API, you can call your Java/JNI code with root/shell (ADB) identity.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;To use Shizuku APIs, you need to guide the user to install Shizuku or Sui first. Both of them require Android 6.0+.&lt;/p&gt; &#xA;&lt;h3&gt;Shizuku&lt;/h3&gt; &#xA;&lt;p&gt;Shizuku is a standard Android application. You can guide the users to download Shizuku from &lt;a href=&#34;https://shizuku.rikka.app/download/&#34;&gt;https://shizuku.rikka.app/download/&lt;/a&gt;. Shizuku works for both rooted and non-rooted devices.&lt;/p&gt; &#xA;&lt;p&gt;On non-rooted devices, Shizuku needs to be manually restarted with adb every time on boot. Before Android 11, a computer is required to run adb. Android 11 and above have built-in wireless debugging support, and users can start Shizuku directly on the device.&lt;/p&gt; &#xA;&lt;h3&gt;Sui&lt;/h3&gt; &#xA;&lt;p&gt;Sui is a &lt;a href=&#34;https://github.com/topjohnwu/Magisk&#34;&gt;Magisk&lt;/a&gt; module. Magisk requires an unlocked bootloader.&lt;/p&gt; &#xA;&lt;p&gt;No additional setup is required except for the installation. You can guide the rooted users (searching &lt;code&gt;su&lt;/code&gt; in &lt;code&gt;PATH&lt;/code&gt; is enough) to download Sui from Magisk or &lt;a href=&#34;https://github.com/RikkaApps/Sui&#34;&gt;https://github.com/RikkaApps/Sui&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;A demo project is provided. See &lt;a href=&#34;https://github.com/RikkaApps/Shizuku-API/tree/master/demo&#34;&gt;demo&lt;/a&gt; for more.&lt;/p&gt; &#xA;&lt;h2&gt;Guide&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;ll say the difficult words first, using Shizuku APIs is similar to framework or system app development, some experience in developing common applications may not be enough. You have to get used to digging into Android source code to find out how things work, &lt;a href=&#34;https://cs.android.com&#34;&gt;cs.android.com&lt;/a&gt; and AndroidXref sites will be your best friend.&lt;/p&gt; &#xA;&lt;h3&gt;Add dependency&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/dev.rikka.shizuku/api&#34; alt=&#34;Maven Central&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;def shizuku_version = (the version above)&#xA;implementation &#34;dev.rikka.shizuku:api:$shizuku_version&#34;&#xA;&#xA;// Add this line if you want to support Shizuku&#xA;implementation &#34;dev.rikka.shizuku:provider:$shizuku_version&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Acquire the Binder&lt;/h3&gt; &#xA;&lt;p&gt;The first step is to acquire the Binder from Shizuku or Sui.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Shizuku&lt;/code&gt; class provides listeners, &lt;code&gt;Shizuku#addBinderReceivedListener()&lt;/code&gt; and &lt;code&gt;Shizuku.addBinderDeadListener()&lt;/code&gt;, that allows you to track the life of the binder. You should call methods in &lt;code&gt;Shizuku&lt;/code&gt; class when the binder is alive or you will get an &lt;code&gt;IllegalStateException&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The steps to get a Binder from Sui and Shizuku are different.&lt;/p&gt; &#xA;&lt;h4&gt;Sui&lt;/h4&gt; &#xA;&lt;p&gt;Call &lt;code&gt;Sui.init(packageName)&lt;/code&gt; before using &lt;code&gt;Shizuku&lt;/code&gt; class. This method only needs to be called once. If this method returns true, means Sui is installed and available.&lt;/p&gt; &#xA;&lt;p&gt;For multi-process applications, call this method in every process that needs to use Shizuku API.&lt;/p&gt; &#xA;&lt;p&gt;Note, request the binder for Sui only requires two times of binder IPC, this is significantly cheaper than initialize Shizuku which uses &lt;code&gt;ContentProvider&lt;/code&gt;. &lt;code&gt;Sui.init(packageName)&lt;/code&gt; can be used in main thread, you don&#39;t need to worry about performance.&lt;/p&gt; &#xA;&lt;h4&gt;Shizuku&lt;/h4&gt; &#xA;&lt;p&gt;Add &lt;code&gt;ShizukuProvider&lt;/code&gt; to &lt;code&gt;AndroidManifest.xml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;provider&#xA;    android:name=&#34;rikka.shizuku.ShizukuProvider&#34;&#xA;    android:authorities=&#34;${applicationId}.shizuku&#34;&#xA;    android:multiprocess=&#34;false&#34;&#xA;    android:enabled=&#34;true&#34;&#xA;    android:exported=&#34;true&#34;&#xA;    android:permission=&#34;android.permission.INTERACT_ACROSS_USERS_FULL&#34; /&amp;gt;&#xA;&#xA;&amp;lt;!-- android:permission=&#34;android.permission.INTERACT_ACROSS_USERS_FULL&#34; is to protect this provider from accessing by normal apps --&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For multi-process applications, you need to call &lt;code&gt;ShizukuProvider.enableMultiProcessSupport()&lt;/code&gt; in every process which needs to use Shizuku API.&lt;/p&gt; &#xA;&lt;p&gt;Starting from v12.1.0, Sui is initialized automatically in &lt;code&gt;ShizukuProvider&lt;/code&gt;. You can opt-out this behavior by calling &lt;code&gt;ShizukuProvider#disableAutomaticSuiInitialization()&lt;/code&gt; before &lt;code&gt;ShizukuProvider#onCreate()&lt;/code&gt; is called. Unless there are special reasons, apps that support Shizuku should also support Sui, otherwise it will cause user confusion.&lt;/p&gt; &#xA;&lt;h3&gt;Request permission&lt;/h3&gt; &#xA;&lt;p&gt;Requesting permission is similar to &lt;a href=&#34;https://developer.android.com/training/permissions/requesting&#34;&gt;requesting runtime permissions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A simple example of requesting permission:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void onRequestPermissionsResult(int requestCode, int grantResult) {&#xA;    boolean granted = grantResult == PackageManager.PERMISSION_GRANTED;&#xA;    // Do stuff based on the result and the request code&#xA;}&#xA;&#xA;private final Shizuku.OnRequestPermissionResultListener REQUEST_PERMISSION_RESULT_LISTENER = this::onRequestPermissionsResult;&#xA;&#xA;@Override&#xA;protected void onCreate(Bundle savedInstanceState) {&#xA;    // ...&#xA;    Shizuku.addRequestPermissionResultListener(REQUEST_PERMISSION_RESULT_LISTENER);&#xA;    // ...&#xA;}&#xA;&#xA;@Override&#xA;protected void onDestroy() {&#xA;    // ...&#xA;    Shizuku.removeRequestPermissionResultListener(REQUEST_PERMISSION_RESULT_LISTENER);&#xA;    // ...&#xA;}&#xA;&#xA;private boolean checkPermission(int code) {&#xA;  if (Shizuku.isPreV11()) {&#xA;    // Pre-v11 is unsupported&#xA;    return false;&#xA;  }&#xA;&#xA;  if (Shizuku.checkSelfPermission() == PackageManager.PERMISSION_GRANTED) {&#xA;    // Granted&#xA;    return true;&#xA;  } else if (Shizuku.shouldShowRequestPermissionRationale()) {&#xA;    // Users choose &#34;Deny and don&#39;t ask again&#34;&#xA;    return false;&#xA;  } else {&#xA;    // Request the permission&#xA;    Shizuku.requestPermission(code);&#xA;    return false;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Differents of the privilege betweent ADB and ROOT&lt;/h3&gt; &#xA;&lt;p&gt;Shizuku can be started with ADB or ROOT, and Sui is a Magisk module, so the privilege could be ADB or ROOT. You can use &lt;code&gt;Shizuku#getUid()&lt;/code&gt; to check your privilege, for ROOT it returns &lt;code&gt;0&lt;/code&gt;, for ADB is &lt;code&gt;2000&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;What ADB can do is significantly different from ROOT:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;In the Android world, the privilege is determined by Android permissions. See &lt;a href=&#34;https://cs.android.com/android/platform/superproject/+/master:frameworks/base/packages/Shell/AndroidManifest.xml&#34;&gt;AndroidManifest of Shell&lt;/a&gt;, all the permission granted to Shell (ADB) are listed here. Be aware, the permission changes under different Android versions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In Linux world, the privilege is determined by Shell&#39;s uid, capabilities, SELinux context, etc. For example, Shell (ADB) cannot access other apps&#39; data files &lt;code&gt;/data/user/0/&amp;lt;package&amp;gt;&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Remote binder call&lt;/h3&gt; &#xA;&lt;p&gt;This is a relatively simple way, but what you can do is limited to Binder calls. Therefore, this is only suitable for simple applications.&lt;/p&gt; &#xA;&lt;p&gt;Shizuku API provides &lt;code&gt;rikka.shizuku.ShizukuBinderWrapper&lt;/code&gt; class which forward Binder calls to Shizuku service which has ADB or ROOT privilege.&lt;/p&gt; &#xA;&lt;h3&gt;UserService&lt;/h3&gt; &#xA;&lt;p&gt;User Service is like &lt;a href=&#34;https://developer.android.com/guide/components/bound-services&#34;&gt;Bound services&lt;/a&gt; which allows you to run Java or native codes (through JNI). The difference is that the service runs in a different process and as the identity (Linux UID) of root (UID 0) or shell (UID 2000, if the backend is Shizuku and user starts Shizuku with adb).&lt;/p&gt; &#xA;&lt;p&gt;There are no restrictions on non-SDK APIs in the user service process. However, the User Service process is not a valid Android application process. Therefore, even if you can acquire a &lt;code&gt;Context&lt;/code&gt; instance, many APIs, such as &lt;code&gt;Context#registerReceiver&lt;/code&gt; and &lt;code&gt;Context#getContentResolver&lt;/code&gt; will not work. You will need to dig into Android source code to find out how things work.&lt;/p&gt; &#xA;&lt;p&gt;Be aware that, to let the service to use the latest code, &#34;Run/Debug configurations&#34; - &#34;Always install with package manager&#34; in Android Studio should be checked.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Start the User Service&lt;/p&gt; &lt;p&gt;Use &lt;code&gt;bindUserService&lt;/code&gt; method. This method has two parameters, &lt;code&gt;UserServiceArgs&lt;/code&gt; and &lt;code&gt;ServiceConnection&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;&lt;code&gt;UserServiceArgs&lt;/code&gt; is like &lt;code&gt;Intent&lt;/code&gt; in Bound services, which decides which service will be started and some options.&lt;/p&gt; &lt;p&gt;&lt;code&gt;ServiceConnection&lt;/code&gt; is same as Bound services, but only &lt;code&gt;onServiceConnected&lt;/code&gt; and &lt;code&gt;onServiceDisconnected&lt;/code&gt; are used.&lt;/p&gt; &lt;p&gt;Unlike Bound service, the service class must implement &lt;code&gt;IBinder&lt;/code&gt; interface. The usual usage is &lt;code&gt;public class YourService extends IYouAidlInterface.Stub&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The service class can have two constructors, one is default constructor, another is with &lt;code&gt;Context&lt;/code&gt; parameter available from Shizuku v13. Shizuku v13 will try the constructor with &lt;code&gt;Context&lt;/code&gt; parameter first. Older Shizuku will always use the default constructor. Beaware that the &lt;code&gt;Context&lt;/code&gt; does not work as same as &lt;code&gt;Context&lt;/code&gt; in normal Android application. See &#34;Use Android APIs in user service&#34; below.&lt;/p&gt; &lt;p&gt;Shizuku uses &lt;code&gt;tag&lt;/code&gt; from &lt;code&gt;UserServiceArgs&lt;/code&gt; to determine if the User Service is same. If &lt;code&gt;tag&lt;/code&gt; is not set, class name will be uses, but class name is unstable after ProGuard/R8. If &lt;code&gt;version&lt;/code&gt; from &lt;code&gt;UserServiceArgs&lt;/code&gt; mismatches, a new User Service will be start and &#34;destroy&#34; method (see below) will be called for the old.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Stop the User Service&lt;/p&gt; &lt;p&gt;Use &lt;code&gt;unbindUserService&lt;/code&gt; method. However, the user service process will &lt;strong&gt;NOT&lt;/strong&gt; be killed automatically. You need to implement a &#34;destroy&#34; method in your service. The transaction code for that method is &lt;code&gt;16777115&lt;/code&gt; (use &lt;code&gt;16777114&lt;/code&gt; in aidl). In this method, you can do some cleanup jobs and call &lt;code&gt;System.exit()&lt;/code&gt; in the end.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;The use of non-SDK interfaces&lt;/h3&gt; &#xA;&lt;p&gt;For &#34;Remote binder call&#34;, as the APIs are accessed from the app&#39;s process, you may need to use &lt;a href=&#34;https://github.com/LSPosed/AndroidHiddenApiBypass&#34;&gt;AndroidHiddenApiBypass&lt;/a&gt; or any ways you want to bypass restrictions on non-SDK interfaces.&lt;/p&gt; &#xA;&lt;p&gt;We also provides &lt;a href=&#34;https://github.com/RikkaApps/HiddenApiRefinePlugin&#34;&gt;HiddenApiRefinePlugin&lt;/a&gt; to help you to programing with hidden APIs conveniently.&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;h3&gt;13.1.5&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix &lt;code&gt;ShizukuProvider#requestBinderForNonProviderProcess&lt;/code&gt; crash on Android 14 (for apps targeting Android 14)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;13.1.4&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ask the server to remove &lt;code&gt;ShizukuServiceConnection&lt;/code&gt; if the server is new enough&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;13.1.3&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix the problem that &lt;code&gt;Shizuku#unbindUserService(remove=false)&lt;/code&gt; does not actually remove the callback&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;13.1.2&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Avoid the use of &lt;code&gt;CopyOnWriteArrayList#removeIf&lt;/code&gt;, as using it with &lt;code&gt;coreLibraryDesugaring&lt;/code&gt; enabled will crash on Android 8+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;13.1.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Fix &lt;code&gt;Shizuku#removeXXXListener&lt;/code&gt; will crash on Android 7.1 and earlier versions&lt;/p&gt; &lt;p&gt;This is caused by &lt;code&gt;CopyOnWriteArrayList#removeIf&lt;/code&gt; is not supported (throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;) before Android 8.0. Please note, using &lt;code&gt;coreLibraryDesugaring&lt;/code&gt; will NOT fix this issue at least in version &lt;code&gt;2.0.3&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Prepare to remove &lt;code&gt;Shizuku#newProcess&lt;/code&gt;, developers should have to use &lt;code&gt;UserService&lt;/code&gt; instead&lt;/p&gt; &lt;p&gt;First, this is already announced two years ago.&lt;/p&gt; &lt;p&gt;For those who don&#39;t understand, &lt;code&gt;UserService&lt;/code&gt; gives the developer the ability to run their own codes in a different process with root or shell privilege. This is much more powerful than just executing a command. &lt;code&gt;UserService&lt;/code&gt; can replace &lt;code&gt;newProcess&lt;/code&gt; in all cases.&lt;/p&gt; &lt;p&gt;Also, &lt;code&gt;newProcess&lt;/code&gt; uses texts to communicate , which is not efficient and unreliable. If there are apps that only uses &lt;code&gt;newProcess&lt;/code&gt; to implement its functions, it loses most of the advantage of using Shizuku.&lt;/p&gt; &lt;p&gt;Finally, &lt;code&gt;newProcess&lt;/code&gt; lacks tty support, it is not possible to implement an interactive shell with it. And we already has &lt;code&gt;rish&lt;/code&gt; that allows users to run an interactive shell with privilege in any terminal app they like.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;13.1.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Breaking change: &lt;a href=&#34;https://developer.android.com/studio/write/java8-support#library-desugaring&#34;&gt;desugaring&lt;/a&gt; is required if min API of your app is 23&lt;/li&gt; &#xA; &lt;li&gt;Listeners now has an optional &lt;code&gt;Handler&lt;/code&gt; parameter that determines which thread will the listener be called from&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;13.0.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The constructor of &lt;code&gt;UserService&lt;/code&gt; can have a &lt;code&gt;Context&lt;/code&gt; parameter which value is the &lt;code&gt;Context&lt;/code&gt; used to create the instance of &lt;code&gt;UserService&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;12.2.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix &lt;code&gt;onServiceDisconnected&lt;/code&gt; is not called if the UserService is stopped by &lt;code&gt;Shizuku#unbindUserService&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;12.1.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatically initialize Sui if you are using Shizuku&lt;/p&gt; &lt;p&gt;You can opt-out this behavior by calling &lt;code&gt;ShizukuProvider#disableAutomaticSuiInitialization()&lt;/code&gt; before &lt;code&gt;ShizukuProvider#onCreate()&lt;/code&gt; is called&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Added a lot more detailed document for most APIs&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Drop pre-v11 support&lt;/p&gt; &lt;p&gt;You don&#39;t need to worry about this problem, just show a &#34;not supported&#34; message if the user really uses pre-v11.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Sui was born after API v11, Sui users are not affected at all.&lt;/li&gt; &#xA;   &lt;li&gt;For Shizuku, according to Google Play statistics, more than 95% of users are on v11+. Shizuku drops Android 5 support from v5, many of the remaining 5% are such people who are stuck at super old versions.&lt;/li&gt; &#xA;   &lt;li&gt;A useful API, UserService, is added from v11 and stable on v12. I believe that many Shizuku apps already have a &#34;version &amp;gt; 11&#34; check.&lt;/li&gt; &#xA;   &lt;li&gt;I really want to drop pre-v11 support since &lt;a href=&#34;https://github.com/RikkaApps/Shizuku/issues/83&#34;&gt;a possible system issue that may cause system soft reboot (system server crash) on uninstalling Shizuku&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;12.0.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add &lt;code&gt;Shizuku#peekUserService&lt;/code&gt; that allows you to check if a specific user service is running&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;Shizuku.UserServiceArgs#daemon&lt;/code&gt; that allows you to control if the user service should be run in the &#34;Daemon mode&#34;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Migration guide for existing applications use Shizuku pre-v11&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Click to expand&lt;/summary&gt; &#xA; &lt;h3&gt;Changes&lt;/h3&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Dependency changed (see Guide below)&lt;/li&gt; &#xA;  &lt;li&gt;Self-implemented permission is used from v11, the API is the same to runtime permission (see the demo, and existing runtime permission still works)&lt;/li&gt; &#xA;  &lt;li&gt;Package name was renamed to &lt;code&gt;rikka.shizuku&lt;/code&gt; (replace all &lt;code&gt;moe.shizuku.api.&lt;/code&gt; to &lt;code&gt;rikka.shizuku.&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;ShizukuService&lt;/code&gt; class is renamed to &lt;code&gt;Shizuku&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;Methods in &lt;code&gt;Shizuku&lt;/code&gt; class now throw &lt;code&gt;RuntimeException&lt;/code&gt; on failure rather than &lt;code&gt;RemoteException&lt;/code&gt; like other Android APIs&lt;/li&gt; &#xA;  &lt;li&gt;Listeners are moved from &lt;code&gt;ShizukuProvider&lt;/code&gt; class to &lt;code&gt;Shizuku&lt;/code&gt; class&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;h3&gt;Add support for Sui&lt;/h3&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Call &lt;code&gt;Sui#init()&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;It&#39;s better to use check Sui with &lt;code&gt;Sui#isSui&lt;/code&gt; before using Shizuku only methods in &lt;code&gt;ShizukuProvider&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt;</summary>
  </entry>
</feed>