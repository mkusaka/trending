<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-21T01:55:02Z</updated>
  <subtitle>Weekly Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>wechatpay-apiv3/wechatpay-java</title>
    <updated>2023-05-21T01:55:02Z</updated>
    <id>tag:github.com,2023-05-21:/wechatpay-apiv3/wechatpay-java</id>
    <link href="https://github.com/wechatpay-apiv3/wechatpay-java" rel="alternate"></link>
    <summary type="html">&lt;p&gt;微信支付 APIv3 的官方 Java Library&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://www.javadoc.io/doc/com.github.wechatpay-apiv3/wechatpay-java/latest/index.html&#34;&gt;&lt;img src=&#34;http://img.shields.io/badge/javadoc-reference-blue.svg?sanitize=true&#34; alt=&#34;JavaDoc&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/maven-central/v/com.github.wechatpay-apiv3/wechatpay-java?versionPrefix=0.2.7&#34; alt=&#34;Maven Central&#34;&gt; &lt;a href=&#34;https://sonarcloud.io/summary/overall?id=wechatpay-apiv3_wechatpay-java&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=wechatpay-apiv3_wechatpay-java&amp;amp;metric=security_rating&#34; alt=&#34;Security Rating&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/overall?id=wechatpay-apiv3_wechatpay-java&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=wechatpay-apiv3_wechatpay-java&amp;amp;metric=sqale_rating&#34; alt=&#34;Maintainability Rating&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/overall?id=wechatpay-apiv3_wechatpay-java&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=wechatpay-apiv3_wechatpay-java&amp;amp;metric=coverage&#34; alt=&#34;Coverage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;微信支付 APIv3 Java SDK&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/&#34;&gt;微信支付 APIv3&lt;/a&gt; 官方 Java 语言客户端开发库。&lt;/p&gt; &#xA;&lt;p&gt;开发库由 &lt;code&gt;core&lt;/code&gt; 和 &lt;code&gt;service&lt;/code&gt; 组成：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;core 为基础库，包含自动签名和验签的 HTTP 客户端、回调处理、加解密库。&lt;/li&gt; &#xA; &lt;li&gt;service 为业务服务，包含&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/main/java/com/wechat/pay/java/service&#34;&gt;业务接口&lt;/a&gt;和&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/example/java/com/wechat/pay/java/service&#34;&gt;使用示例&lt;/a&gt;。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;帮助微信支付改进&lt;/h2&gt; &#xA;&lt;p&gt;为了向广大开发者提供更好的使用体验，微信支付诚挚邀请您反馈使用微信支付 Java SDK 中的感受。您的反馈将对改进 SDK 大有帮助，点击参与&lt;a href=&#34;https://wj.qq.com/s2/11503706/aa9a/&#34;&gt;问卷调查&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;前置条件&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Java 1.8+。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pay.weixin.qq.com/index.php/apply/applyment_home/guide_normal&#34;&gt;成为微信支付商户&lt;/a&gt;。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/ren-zheng/zheng-shu#shang-hu-api-zheng-shu&#34;&gt;商户 API 证书&lt;/a&gt;：指由商户申请的，包含商户的商户号、公司名称、公钥信息的证书。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/ren-zheng/zheng-shu#shang-hu-api-si-yao&#34;&gt;商户 API 私钥&lt;/a&gt;：商户申请商户API证书时，会生成商户私钥，并保存在本地证书文件夹的文件 apiclient_key.pem 中。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/ren-zheng/api-v3-mi-yao&#34;&gt;APIv3 密钥&lt;/a&gt;：为了保证安全性，微信支付在回调通知和平台证书下载接口中，对关键信息进行了 AES-256-GCM 加密。APIv3 密钥是加密时使用的对称密钥。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;快速开始&lt;/h2&gt; &#xA;&lt;h3&gt;安装&lt;/h3&gt; &#xA;&lt;p&gt;最新版本已经在 &lt;a href=&#34;https://search.maven.org/artifact/com.github.wechatpay-apiv3/wechatpay-java&#34;&gt;Maven Central&lt;/a&gt; 发布。&lt;/p&gt; &#xA;&lt;h4&gt;Gradle&lt;/h4&gt; &#xA;&lt;p&gt;在你的 build.gradle 文件中加入如下的依赖&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;implementation &#39;com.github.wechatpay-apiv3:wechatpay-java:0.2.7&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Maven&lt;/h4&gt; &#xA;&lt;p&gt;加入以下依赖&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;com.github.wechatpay-apiv3&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;wechatpay-java&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;0.2.7&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;调用业务请求接口&lt;/h3&gt; &#xA;&lt;p&gt;以 Native 支付下单为例，先补充商户号等必要参数以构建 &lt;code&gt;config&lt;/code&gt;，再构建 &lt;code&gt;service&lt;/code&gt; 即可调用 &lt;code&gt;prepay()&lt;/code&gt; 发送请求。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.wechat.pay.java.service;&#xA;&#xA;import com.wechat.pay.java.core.Config;&#xA;import com.wechat.pay.java.core.RSAAutoCertificateConfig;&#xA;import com.wechat.pay.java.service.payments.nativepay.NativePayService;&#xA;import com.wechat.pay.java.service.payments.nativepay.model.Amount;&#xA;import com.wechat.pay.java.service.payments.nativepay.model.PrepayRequest;&#xA;import com.wechat.pay.java.service.payments.nativepay.model.PrepayResponse;&#xA;&#xA;/** Native 支付下单为例 */&#xA;public class QuickStart {&#xA;&#xA;    /** 商户号 */&#xA;    public static String merchantId = &#34;&#34;;&#xA;    /** 商户API私钥路径 */&#xA;    public static String privateKeyPath = &#34;&#34;;&#xA;    /** 商户证书序列号 */&#xA;    public static String merchantSerialNumber = &#34;&#34;;&#xA;    /** 商户APIV3密钥 */&#xA;    public static String apiV3key = &#34;&#34;;&#xA;&#xA;    public static void main(String[] args) {&#xA;        // 使用自动更新平台证书的RSA配置&#xA;        // 一个商户号只能初始化一个配置，否则会因为重复的下载任务报错&#xA;        Config config =&#xA;                new RSAAutoCertificateConfig.Builder()&#xA;                        .merchantId(merchantId)&#xA;                        .privateKeyFromPath(privateKeyPath)&#xA;                        .merchantSerialNumber(merchantSerialNumber)&#xA;                        .apiV3Key(apiV3key)&#xA;                        .build();&#xA;        // 构建service&#xA;        NativePayService service = new NativePayService.Builder().config(config).build();&#xA;        // request.setXxx(val)设置所需参数，具体参数可见Request定义&#xA;        PrepayRequest request = new PrepayRequest();&#xA;        Amount amount = new Amount();&#xA;        amount.setTotal(100);&#xA;        request.setAmount(amount);&#xA;        request.setAppid(&#34;wxa9d9651ae******&#34;);&#xA;        request.setMchid(&#34;190000****&#34;);&#xA;        request.setDescription(&#34;测试商品标题&#34;);&#xA;        request.setNotifyUrl(&#34;https://notify_url&#34;);&#xA;        request.setOutTradeNo(&#34;out_trade_no_001&#34;);&#xA;        // 调用下单方法，得到应答&#xA;        PrepayResponse response = service.prepay(request);&#xA;        // 使用微信扫描 code_url 对应的二维码，即可体验Native支付&#xA;        System.out.println(response.getCodeUrl());&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;从示例可见，使用 SDK 不需要计算请求签名和验证应答签名。详细代码可从 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/example/java/com/wechat/pay/java/service/QuickStart.java&#34;&gt;QuickStart&lt;/a&gt; 获得。&lt;/p&gt; &#xA;&lt;h2&gt;示例&lt;/h2&gt; &#xA;&lt;h3&gt;查询支付订单&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;QueryOrderByIdRequest queryRequest = new QueryOrderByIdRequest();&#xA;queryRequest.setMchid(&#34;190000****&#34;);&#xA;queryRequest.setTransactionId(&#34;4200001569202208304701234567&#34;);&#xA;&#xA;try {&#xA;  Transaction result = service.queryOrderById(queryRequest);&#xA;  System.out.println(result.getTradeState());&#xA;} catch (ServiceException e) {&#xA;  // API返回失败, 例如ORDER_NOT_EXISTS&#xA;  System.out.printf(&#34;code=[%s], message=[%s]\n&#34;, e.getErrorCode(), e.getErrorMessage());&#xA;  System.out.printf(&#34;reponse body=[%s]\n&#34;, e.getResponseBody());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;关闭订单&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CloseOrderRequest closeRequest = new CloseOrderRequest();&#xA;closeRequest.setMchid(&#34;190000****&#34;);&#xA;closeRequest.setOutTradeNo(&#34;out_trade_no_001&#34;);&#xA;// 方法没有返回值，意味着成功时API返回204 No Content&#xA;service.closeOrder(closeRequest);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;下单并生成调起支付的参数&lt;/h3&gt; &#xA;&lt;p&gt;JSAPI 支付和 APP 支付推荐使用服务拓展类 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/raw/main/service/src/main/java/com/wechat/pay/java/service/payments/jsapi/JsapiServiceExtension.java&#34;&gt;JsapiServiceExtension&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/raw/main/service/src/main/java/com/wechat/pay/java/service/payments/app/AppServiceExtension.java&#34;&gt;AppServiceExtension&lt;/a&gt;，两者包含了下单并返回调起支付参数方法。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;JsapiServiceExtension service = new JsapiServiceExtension.Builder().config(config).build();&#xA;&#xA;// 跟之前下单示例一样，填充预下单参数&#xA;PrepayRequest request = new PrepayRequest();&#xA;&#xA;// response包含了调起支付所需的所有参数，可直接用于前端调起支付&#xA;PrepayWithRequestPaymentResponse response = service.prepayWithRequestPayment(request);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;更多示例&lt;/h3&gt; &#xA;&lt;p&gt;为了方便开发者快速上手，微信支付给每个服务生成了示例代码 &lt;code&gt;XxxServiceExample.java&lt;/code&gt;，可以在 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/example&#34;&gt;example&lt;/a&gt; 中查看。 例如：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/example/java/com/wechat/pay/java/service/payments/jsapi/JsapiServiceExtensionExample.java&#34;&gt;JsapiServiceExtensionExample.java&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/example/java/com/wechat/pay/java/service/file/FileUploadServiceExample.java&#34;&gt;FileServiceExample.java&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;错误处理&lt;/h2&gt; &#xA;&lt;p&gt;SDK 使用的是 unchecked exception，会抛出四种自定义异常。每种异常发生的场景及推荐的处理方式如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/exception/HttpException.java&#34;&gt;HttpException&lt;/a&gt;：调用微信支付服务，当发生 HTTP 请求异常时抛出该异常。 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;构建请求参数失败、发送请求失败、I/O错误：推荐上报监控和打印日志，并获取异常中的 HTTP 请求信息以定位问题。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/exception/ValidationException.java&#34;&gt;ValidationException&lt;/a&gt; ：当验证微信支付签名失败时抛出该异常。 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;验证微信支付返回签名失败：上报监控和日志打印。&lt;/li&gt; &#xA;   &lt;li&gt;验证微信支付回调通知签名失败：确认输入参数与 HTTP 请求信息是否一致，若一致，说明该回调通知参数被篡改导致验签失败。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/exception/ServiceException.java&#34;&gt;ServiceException&lt;/a&gt;：调用微信支付服务，发送 HTTP 请求成功，HTTP 状态码小于200或大于等于300。 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;状态码为5xx：主动重试。&lt;/li&gt; &#xA;   &lt;li&gt;状态码为其他：获取错误中的 &lt;code&gt;errorCode&lt;/code&gt; 、&lt;code&gt;errorMessage&lt;/code&gt;，上报监控和日志打印。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/exception/MalformedMessageException.java&#34;&gt;MalformedMessageException&lt;/a&gt;：服务返回成功，返回内容异常。 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;HTTP 返回 &lt;code&gt;Content-Type&lt;/code&gt; 不为 &lt;code&gt;application/json&lt;/code&gt;：不支持其他类型的返回体，&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/#%E4%B8%8B%E8%BD%BD%E8%B4%A6%E5%8D%95&#34;&gt;下载账单&lt;/a&gt; 应使用 &lt;code&gt;download()&lt;/code&gt; 方法。&lt;/li&gt; &#xA;   &lt;li&gt;解析 HTTP 返回体失败：上报监控和日志打印。&lt;/li&gt; &#xA;   &lt;li&gt;回调通知参数不正确：确认传入参数是否与 HTTP 请求信息一致，传入参数是否存在编码或者 HTML 转码问题。&lt;/li&gt; &#xA;   &lt;li&gt;解析回调请求体为 JSON 字符串失败：上报监控和日志打印。&lt;/li&gt; &#xA;   &lt;li&gt;解密回调通知内容失败：确认传入的 apiV3 密钥是否正确。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;自动更新微信支付平台证书&lt;/h2&gt; &#xA;&lt;p&gt;在 API 请求过程中，客户端需使用微信支付平台证书，验证服务器应答的真实性和完整性。 在 v0.2.3 版本，我们加入了自动更新平台证书的配置类 &lt;code&gt;RSAAutoCertificateConfig&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Config config =&#xA;    new RSAAutoCertificateConfig.Builder()&#xA;        .merchantId(merchantId)&#xA;        .privateKeyFromPath(privateKeyPath)&#xA;        .merchantSerialNumber(merchantSerialNumber)&#xA;        .apiV3Key(apiV3key)&#xA;        .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;RSAAutoCertificateConfig&lt;/code&gt; 通过 &lt;code&gt;RSAAutoCertificateProvider&lt;/code&gt; 自动下载微信支付平台证书。 同时，&lt;code&gt;RSAAutoCertificateProvider&lt;/code&gt; 会启动一个后台线程，定时更新证书（目前设计为60分钟），以实现证书过期时的新老证书平滑切换。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;每个商户号只能创建一个 &lt;code&gt;RSAAutoCertificateConfig&lt;/code&gt;。同一个商户号构造多个实例，会抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常。&lt;/p&gt; &#xA; &lt;p&gt;我们建议你将配置类作为全局变量。如果你的程序是多线程，建议使用&lt;strong&gt;多线程安全&lt;/strong&gt;的单例模式。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;使用本地的微信支付平台证书&lt;/h3&gt; &#xA;&lt;p&gt;如果你不想使用 SDK 提供的定时更新平台证书，你可以使用配置类 &lt;code&gt;RSAConfig&lt;/code&gt; 加载本地证书。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Config config =&#xA;    new RSAConfig.Builder()&#xA;        .merchantId(merchantId)&#xA;        .privateKeyFromPath(privateKeyPath)&#xA;        .merchantSerialNumber(merchantSerialNumber)&#xA;        .wechatPayCertificatesFromPath(wechatPayCertificatePath)&#xA;        .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;回调通知验签和解密&lt;/h2&gt; &#xA;&lt;p&gt;首先，你需要在你的服务器上创建一个公开的 HTTP 端点，接受来自微信支付的回调通知。 当接收到回调通知，使用 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/notification&#34;&gt;notification&lt;/a&gt; 中的 &lt;code&gt;NotificationParser&lt;/code&gt; 解析回调通知。&lt;/p&gt; &#xA;&lt;p&gt;具体步骤如下：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;使用回调通知请求的数据，构建 &lt;code&gt;RequestParam&lt;/code&gt;。 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;HTTP 头 &lt;code&gt;Wechatpay-Signature&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;HTTP 头 &lt;code&gt;Wechatpay-Nonce&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;HTTP 头 &lt;code&gt;Wechatpay-Timestamp&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;HTTP 头 &lt;code&gt;Wechatpay-Serial&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;HTTP 头 &lt;code&gt;Wechatpay-Signature-Type&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;HTTP 请求体 body。切记使用原始报文，不要用 JSON 对象序列化后的字符串，避免验签的 body 和原文不一致。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;初始化 &lt;code&gt;RSAAutoCertificateConfig&lt;/code&gt;。微信支付平台证书由 SDK 的自动更新平台能力提供，也可以使用本地证书。&lt;/li&gt; &#xA; &lt;li&gt;初始化 &lt;code&gt;NotificationParser&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;调用 &lt;code&gt;NotificationParser.parse()&lt;/code&gt; 验签、解密并将 JSON 转换成具体的通知回调对象。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造 RequestParam&#xA;RequestParam requestParam = new RequestParam.Builder()&#xA;        .serialNumber(wechatPayCertificateSerialNumber)&#xA;        .nonce(nonce)&#xA;        .signature(signature)&#xA;        .timestamp(timestamp)&#xA;        .body(requestBody)&#xA;        .build();&#xA;&#xA;// 如果已经初始化了 RSAAutoCertificateConfig，可直接使用&#xA;// 没有的话，则构造一个&#xA;NotificationConfig config = new RSAAutoCertificateConfig.Builder()&#xA;        .merchantId(merchantId)&#xA;        .privateKeyFromPath(privateKeyPath)&#xA;        .merchantSerialNumber(merchantSerialNumber)&#xA;        .apiV3Key(apiV3key)&#xA;        .build();&#xA;&#xA;// 初始化 NotificationParser&#xA;NotificationParser parser = new NotificationParser(config);&#xA;&#xA;// 以支付通知回调为例，验签、解密并转换成 Transaction&#xA;Transaction transaction = parser.parse(requestParam, Transaction.class);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;常用的通知回调对象类型：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;支付 &lt;code&gt;Transaction&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;退款 &lt;code&gt;RefundNotification&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;若 SDK 暂不支持的类型，请使用 &lt;code&gt;Map.class&lt;/code&gt;，嵌套的 Json 对象将被转换成 &lt;code&gt;LinkedTreeMap&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;你既可以为每个通知回调使用不同的 HTTP 端点，也可以使用一个端点根据 &lt;code&gt;event_type&lt;/code&gt; 处理不同的通知回调。 我们建议，不同的通知回调使用不同的端点，直接调用 SDK 处理通知回调，避免商户自己解析报文。因为 SDK 会先验证通知回调的有效性，可有效防止&#34;坏人&#34;的报文攻击。&lt;/p&gt; &#xA;&lt;h2&gt;发送 HTTP 请求&lt;/h2&gt; &#xA;&lt;p&gt;如果 SDK 未支持你需要的接口，你可以使用 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/http/okhttp/OkHttpClientAdapter.java&#34;&gt;OkHttpClientAdapter&lt;/a&gt; 的实现类发送 HTTP 请求，它会自动生成签名和验证签名。&lt;/p&gt; &#xA;&lt;p&gt;发送请求步骤如下：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;初始化 &lt;code&gt;OkHttpClientAdapter&lt;/code&gt;，建议使用 &lt;code&gt;DefaultHttpClientBuilder&lt;/code&gt; 构建。&lt;/li&gt; &#xA; &lt;li&gt;构建请求 &lt;code&gt;HttpRequest&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;调用 &lt;code&gt;httpClient.execute&lt;/code&gt; 或者 &lt;code&gt;httpClient.get&lt;/code&gt; 等方法来发送 HTTP 请求。&lt;code&gt;httpClient.execute&lt;/code&gt; 支持发送 GET、PUT、POST、PATCH、DELETE 请求，也可以调用指定的 HTTP 方法发送请求。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/test/java/com/wechat/pay/java/core/http/OkHttpClientAdapterTest.java&#34;&gt;OkHttpClientAdapterTest&lt;/a&gt; 中演示了如何构造和发送 HTTP 请求。如果现有的 &lt;code&gt;OkHttpClientAdapter&lt;/code&gt; 实现类不满足你的需求，可以继承 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/http/AbstractHttpClient.java&#34;&gt;AbstractHttpClient&lt;/a&gt; 拓展实现。&lt;/p&gt; &#xA;&lt;h3&gt;下载账单&lt;/h3&gt; &#xA;&lt;p&gt;因为下载的账单文件可能会很大，为了平衡系统性能和签名验签的实现成本，&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_8.shtml&#34;&gt;账单下载API&lt;/a&gt; 被分成了两个步骤：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;/v3/bill/tradebill&lt;/code&gt; 申请账单下载链接，并获取账单摘要。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/v3/billdownload/file&lt;/code&gt; 账单文件下载，请求需签名但应答不签名。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;SDK 提供了 &lt;code&gt;HttpClient.download()&lt;/code&gt; 方法。它返回账单的输入流。开发者使用完输入流后，应自主关闭流。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;InputStream inputStream = httpClient.download(downloadUrl);&#xA;&#xA;// 非压缩的账单可使用 core.util.IOUtil 从流读入内存字符串，大账单请慎用&#xA;String respBody = IOUtil.toString(inputStream);&#xA;inputStream.close();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;开发者在下载文件之后，应使用第一步获取的账单摘要校验文件的完整性。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;敏感信息加解密&lt;/h2&gt; &#xA;&lt;p&gt;为了保证通信过程中敏感信息字段（如用户的住址、银行卡号、手机号码等）的机密性，&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;微信支付要求加密上送的敏感信息&lt;/li&gt; &#xA; &lt;li&gt;微信支付会加密下行的敏感信息&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;详见 &lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/qian-ming-zhi-nan-1/min-gan-xin-xi-jia-mi&#34;&gt;接口规则 - 敏感信息加解密&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h3&gt;自动加解密&lt;/h3&gt; &#xA;&lt;p&gt;如果是 SDK 已支持的接口，例如商家转账，SDK 将根据契约自动对敏感信息做加解密：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;发起请求时，开发者设置原文。SDK 自动加密敏感信息，并设置 &lt;code&gt;Wechatpay-Serial&lt;/code&gt; 请求头&lt;/li&gt; &#xA; &lt;li&gt;收到应答时，解密器自动解密敏感信息，开发者得到原文&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;手动加解密&lt;/h3&gt; &#xA;&lt;p&gt;如果是 SDK 尚未支持的接口，你可以使用 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/cipher&#34;&gt;cipher&lt;/a&gt; 中的 &lt;code&gt;RSAPrivacyEncryptor&lt;/code&gt; 和 &lt;code&gt;RSAPrivacyDecryptor&lt;/code&gt; ，手动对敏感信息加解密。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 微信支付平台证书中的公钥&#xA;PublicKey wechatPayPublicKey = null;&#xA;String plaintext = &#34;&#34;;&#xA;PrivacyEncryptor encryptor = new RSAPrivacyEncryptor(wechatPayPublicKey);&#xA;String ciphertext = encryptor.encryptToString(plaintext);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 商户私钥&#xA;PrivateKey merchantPrivateKey = null;&#xA;String ciphertext = &#34;&#34;;&#xA;PrivacyDecryptor decryptor = new RSAPrivacyDecryptor(merchantPrivateKey);&#xA;String plaintext = decryptor.decryptToString(ciphertext);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/test/java/com/wechat/pay/java/core/cipher/RSAPrivacyEncryptorTest.java&#34;&gt;RSAPrivacyEncryptorTest&lt;/a&gt; 和 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/test/java/com/wechat/pay/java/core/cipher/RSAPrivacyDecryptorTest.java&#34;&gt;RSAPrivacyDecryptorTest&lt;/a&gt; 中演示了如何使用以上函数做敏感信息加解密。&lt;/p&gt; &#xA;&lt;h2&gt;日志&lt;/h2&gt; &#xA;&lt;p&gt;SDK 使用了 &lt;a href=&#34;http://www.slf4j.org/&#34;&gt;SLF4j&lt;/a&gt; 作为日志框架的接口。这样，你可以使用你熟悉的日志框架，例如 &lt;a href=&#34;https://logback.qos.ch/documentation.html&#34;&gt;Logback&lt;/a&gt;、&lt;a href=&#34;https://github.com/apache/logging-log4j2&#34;&gt;Log4j2&lt;/a&gt; 或者 &lt;a href=&#34;https://www.slf4j.org/manual.html&#34;&gt;SLF4j-simple&lt;/a&gt;。 SDK 的日志会跟你的日志记录在一起。&lt;/p&gt; &#xA;&lt;p&gt;为了启用日志，你应在你的构建脚本中添加日志框架的依赖。如果不配置日志框架，默认是使用 SLF4j 提供的 空（NOP）日志实现，它不会记录任何日志。&lt;/p&gt; &#xA;&lt;h2&gt;使用国密&lt;/h2&gt; &#xA;&lt;p&gt;我们提供基于 &lt;a href=&#34;https://github.com/Tencent/TencentKonaSMSuite&#34;&gt;腾讯 Kona 国密套件&lt;/a&gt; 的国密扩展。文档请参考 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/shangmi/README.md&#34;&gt;shangmi/README.md&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;常见问题&lt;/h2&gt; &#xA;&lt;h3&gt;为什么收到应答中的证书序列号和发起请求的证书序列号不一致？&lt;/h3&gt; &#xA;&lt;p&gt;请求和应答使用 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0&#34;&gt;数字签名&lt;/a&gt; ，保证数据传递的真实、完整和不可否认。为了验签方能识别数字签名使用的密钥（特别是密钥和证书更换期间），微信支付 APIv3 要求签名和相应的证书序列号一起传输。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;商户请求使用&lt;strong&gt;商户API私钥&lt;/strong&gt;签名。商户应上送商户证书序列号。&lt;/li&gt; &#xA; &lt;li&gt;微信支付应答使用&lt;strong&gt;微信支付平台私钥&lt;/strong&gt;签名。微信支付应答返回微信支付平台证书序列号。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;综上所述，请求和应答的证书序列号是不一致的。&lt;/p&gt; &#xA;&lt;h3&gt;证书和回调解密需要的 AesGcm 解密在哪里？&lt;/h3&gt; &#xA;&lt;p&gt;请参考 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/cipher/AeadAesCipher.java&#34;&gt;AeadAesCipher&lt;/a&gt; 和 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/test/java/com/wechat/pay/java/core/cipher/AeadAesCipherTest.java&#34;&gt;AeadAesCipherTest&lt;/a&gt; 。&lt;/p&gt; &#xA;&lt;p&gt;由于 SDK 已经提供了微信支付平台证书下载服务 &lt;code&gt;CertificateService&lt;/code&gt; 以及回调通知解析器 &lt;code&gt;NotificationParser&lt;/code&gt; ，这两者会完成所有的解析与解密工作。因此除非你想要自定义实现，否则你应该不需要用到 &lt;code&gt;AeadXxxCipher&lt;/code&gt; 中提供的方法。&lt;/p&gt; &#xA;&lt;h3&gt;为什么我使用 &lt;code&gt;NotificationHandler&lt;/code&gt; 验证回调通知失败，抛出 &lt;code&gt;ValidationException&lt;/code&gt;？&lt;/h3&gt; &#xA;&lt;p&gt;如果你使用的是 SDK 自动更新的微信支付平台证书，验证失败原因是：参与验证的参数不正确。从开发者反馈来看，大部分失败案例没有使用回调原始 body，而是用 body 反序列化得到的对象再做 JSON 序列化得到的 body。很遗憾，这样的 body 几乎一定跟原始报文&lt;strong&gt;不一致&lt;/strong&gt;，所以签名验证不通过。具体案例可参考 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/issues/112&#34;&gt;#112&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;如果你使用的是本地的微信支付平台证书，请检查微信支付平台证书是否正确，不要把商户证书和微信支付平台证书搞混了。&lt;/p&gt; &#xA;&lt;h3&gt;如何计算前端签名？&lt;/h3&gt; &#xA;&lt;p&gt;有一部分 API 需要计算前端签名，例如调起支付、调起支付分小程序等。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;调起支付签名，SDK 提供了下单并生成调起支付参数的方法，请参考 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/#%E4%B8%8B%E5%8D%95%E5%B9%B6%E7%94%9F%E6%88%90%E8%B0%83%E8%B5%B7%E6%94%AF%E4%BB%98%E7%9A%84%E5%8F%82%E6%95%B0&#34;&gt;示例&lt;/a&gt;。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;其他场景计算签名，请参考 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/raw/968a2ff8fb35c808f82827342abb100e30691a98/service/src/main/java/com/wechat/pay/java/service/payments/jsapi/JsapiServiceExtension.java#L59&#34;&gt;JsapiServiceExtension&lt;/a&gt; 使用 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/raw/main/core/src/main/java/com/wechat/pay/java/core/cipher/Signer.java&#34;&gt;Signer&lt;/a&gt; 计算签名的例子。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;为什么快速开始的示例程序执行后，程序不会退出？&lt;/h3&gt; &#xA;&lt;p&gt;是的，因为示例使用了自动更新微信支付平台证书，它会启动一个背景线程以定时更新证书。这个线程不会自动退出。&lt;/p&gt; &#xA;&lt;p&gt;你可以主动终止程序，退出不会有副作用。 我们也在考虑如何提供优雅的退出方式。&lt;/p&gt; &#xA;&lt;h2&gt;如何参与开发&lt;/h2&gt; &#xA;&lt;p&gt;微信支付欢迎来自社区的开发者贡献你们的想法和代码。请你在提交 PR 之前，先提一个对应的 issue 说明以下内容：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;背景（如，遇到的问题）和目的。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;着重&lt;/strong&gt;说明你的想法。&lt;/li&gt; &#xA; &lt;li&gt;通过代码或者其他方式，简要的说明是如何实现的，或者它会是如何使用。&lt;/li&gt; &#xA; &lt;li&gt;是否影响现有的接口。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;联系微信支付&lt;/h2&gt; &#xA;&lt;p&gt;如果你发现了 BUG，或者需要的功能还未支持，或者有任何疑问、建议，欢迎通过 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/issues&#34;&gt;issue&lt;/a&gt; 反馈。&lt;/p&gt; &#xA;&lt;p&gt;也欢迎访问微信支付的 &lt;a href=&#34;https://developers.weixin.qq.com/community/pay&#34;&gt;开发者社区&lt;/a&gt;。&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>novicezk/midjourney-proxy</title>
    <updated>2023-05-21T01:55:02Z</updated>
    <id>tag:github.com,2023-05-21:/novicezk/midjourney-proxy</id>
    <link href="https://github.com/novicezk/midjourney-proxy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;代理 MidJourney 的discord频道，实现api形式调用AI绘图&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;midjourney-proxy&lt;/h1&gt; &#xA;&lt;p&gt;代理 MidJourney 的discord频道，实现api形式调用AI绘图&lt;/p&gt; &#xA;&lt;h2&gt;现有功能&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 支持 Imagine、U、V 指令，绘图完成后回调&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 支持 Describe 指令，根据图片生成 prompt&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 支持中文 prompt 翻译，需配置百度翻译或 gpt&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; prompt 敏感词判断，支持覆盖调整&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;后续计划&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; 任务队列 &lt;a href=&#34;https://github.com/novicezk/midjourney-proxy/issues/45&#34;&gt;Issue&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; 支持mysql存储，优化任务的查询方式&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; 支持配置账号池，分发绘图任务&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Imagine 时支持上传图片，作为垫图&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;使用前提&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;科学上网&lt;/li&gt; &#xA; &lt;li&gt;docker环境&lt;/li&gt; &#xA; &lt;li&gt;注册 MidJourney，创建自己的频道，参考 &lt;a href=&#34;https://docs.midjourney.com/docs/quick-start&#34;&gt;https://docs.midjourney.com/docs/quick-start&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;添加自己的机器人: &lt;a href=&#34;https://raw.githubusercontent.com/novicezk/midjourney-proxy/main/docs/discord-bot.md&#34;&gt;流程说明&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;快速启动&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;下载镜像&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull novicezk/midjourney-proxy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;启动容器，并设置参数&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# /xxx/xxx/config目录下创建 application.yml(配置项)、banned-words.txt(可选，覆盖默认的敏感词文件)&#xA;# 参考src/main/resources下的文件&#xA;docker run -d --name midjourney-proxy \&#xA; -p 8080:8080 \&#xA; -v /xxx/xxx/config:/home/spring/config \&#xA; --restart=always \&#xA; novicezk/midjourney-proxy&#xA;&#xA;# 或者直接在启动命令中设置参数&#xA;docker run -d --name midjourney-proxy \&#xA; -p 8080:8080 \&#xA; -e mj.discord.guild-id=xxx \&#xA; -e mj.discord.channel-id=xxx \&#xA; -e mj.discord.user-token=xxx \&#xA; -e mj.discord.bot-token=xxx \&#xA; --restart=always \&#xA; novicezk/midjourney-proxy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;访问 &lt;a href=&#34;http://localhost:8080/mj&#34;&gt;http://localhost:8080/mj&lt;/a&gt; 提示 &#34;项目启动成功&#34;&lt;/li&gt; &#xA; &lt;li&gt;检查discord频道中新创建的机器人是否在线&lt;/li&gt; &#xA; &lt;li&gt;调用api接口的根路径为 &lt;code&gt;http://ip:port/mj&lt;/code&gt;，接口测试地址：&lt;code&gt;http://ip:port/mj/doc.html&lt;/code&gt;，具体API接口见下文&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;注意事项&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;启动失败请检查全局代理或HTTP代理，排查 &lt;a href=&#34;https://github.com/DV8FromTheWorld/JDA&#34;&gt;JDA&lt;/a&gt; 连接问题&lt;/li&gt; &#xA; &lt;li&gt;若回调通知接口失败，请检查网络设置，容器中的宿主机IP通常为172.17.0.1&lt;/li&gt; &#xA; &lt;li&gt;在 &lt;a href=&#34;https://github.com/novicezk/midjourney-proxy/issues&#34;&gt;Issues&lt;/a&gt; 中提出其他问题或建议&lt;/li&gt; &#xA; &lt;li&gt;感兴趣的朋友也欢迎加入交流群讨论一下&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/novicezk/midjourney-proxy/main/docs/wechat-qrcode.png&#34; width=&#34;330&#34; height=&#34;350&#34; alt=&#34;交流群二维码&#34; align=&#34;center&#34;&gt; &#xA;&lt;h2&gt;配置项&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;变量名&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;非空&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.discord.guild-id&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;是&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;discord服务器ID&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.discord.channel-id&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;是&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;discord频道ID&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.discord.user-token&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;是&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;discord用户Token&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.discord.bot-token&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;是&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;自定义机器人Token&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.discord.mj-bot-name&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj机器人名称，默认 &#34;Midjourney Bot&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.notify-hook&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;任务状态变更回调地址&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.task-store.type&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;任务存储方式，默认in_memory(内存\重启后丢失)，可选redis&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.task-store.timeout&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;任务过期时间，过期后删除，默认30天&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.translate-way&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;中文prompt翻译方式，可选null(默认)、baidu、gpt&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.baidu-translate.appid&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;百度翻译的appid&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.baidu-translate.app-secret&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;百度翻译的app-secret&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.openai.gpt-api-key&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;gpt的api-key&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.openai.timeout&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;openai调用的超时时间，默认30秒&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.openai.model&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;openai的模型，默认gpt-3.5-turbo&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.openai.max-tokens&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;返回结果的最大分词数，默认2048&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mj.openai.temperature&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;相似度(0-2.0)，默认0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;spring.redis&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;否&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;任务存储方式设置为redis，需配置redis相关属性&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;API接口说明&lt;/h2&gt; &#xA;&lt;h3&gt;1. &lt;code&gt;http://ip:port/mj/trigger/submit&lt;/code&gt; 提交任务&lt;/h3&gt; &#xA;&lt;p&gt;POST application/json&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    // 动作: 必传，IMAGINE（绘图）、UPSCALE（选中放大）、VARIATION（选中变换）&#xA;    &#34;action&#34;:&#34;IMAGINE&#34;,&#xA;    // 绘图参数: IMAGINE时必传&#xA;    &#34;prompt&#34;: &#34;猫猫&#34;,&#xA;    // 任务ID: UPSCALE、VARIATION时必传&#xA;    &#34;taskId&#34;: &#34;1320098173412546&#34;,&#xA;    // 图序号: 1～4，UPSCALE、VARIATION时必传，表示第几张图&#xA;    &#34;index&#34;: 3,&#xA;    // 自定义字符串: 非必传，供回调到业务系统里使用&#xA;    &#34;state&#34;: &#34;test:22&#34;,&#xA;    // 支持每个任务配置不同回调地址，非必传&#xA;    &#34;notifyHook&#34;: &#34;http://localhost:8113/notify&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;返回 &lt;code&gt;Message&lt;/code&gt;，code=1表示提交成功，其他时description为错误描述&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;code&#34;: 1,&#xA;  &#34;description&#34;: &#34;成功&#34;,&#xA;  &#34;result&#34;: &#34;8498455807619990&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;result: 任务ID，用于后续查询任务或提交变换任务&lt;/p&gt; &#xA;&lt;h3&gt;2. &lt;code&gt;http://ip:port/mj/trigger/submit-uv&lt;/code&gt; 提交选中放大或变换任务&lt;/h3&gt; &#xA;&lt;p&gt;POST application/json&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    // 自定义参数，非必传&#xA;    &#34;state&#34;: &#34;test:22&#34;,&#xA;    // 任务描述: 选中ID为1320098173412546的第2张图片放大&#xA;    // 放大 U1～U4 ，变换 V1～V4&#xA;    &#34;content&#34;: &#34;1320098173412546 U2&#34;,&#xA;    // 支持每个任务配置不同回调地址，非必传&#xA;    &#34;notifyHook&#34;: &#34;http://localhost:8113/notify&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;返回结果同 &lt;code&gt;/trigger/submit&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;3. &lt;code&gt;http://ip:port/mj/trigger/describe&lt;/code&gt; 提交describe任务&lt;/h3&gt; &#xA;&lt;p&gt;POST application/json&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    // 自定义参数，非必传&#xA;    &#34;state&#34;: &#34;test:22&#34;,&#xA;    // 图片的base64字符串&#xA;    &#34;base64&#34;: &#34;data:image/png;base64,xxx&#34;,&#xA;    // 支持每个任务配置不同回调地址，非必传&#xA;    &#34;notifyHook&#34;: &#34;http://localhost:8113/notify&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;返回结果同 &lt;code&gt;/trigger/submit&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;后续任务完成后，task中prompt即为图片生成的prompt&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;action&#34;:&#34;DESCRIBE&#34;,&#xA;  &#34;id&#34;:&#34;3856553004865376&#34;,&#xA;  &#34;prompt&#34;:&#34;1️⃣ xxx1 --ar 5:4\n\n2️⃣ xxx2 --ar 5:4\n\n3️⃣ xxx3 --ar 5:4\n\n4️⃣ xxx4 --ar 5:4&#34;,&#xA;  &#34;promptEn&#34;:&#34;1️⃣ xxx1 --ar 5:4\n\n2️⃣ xxx2 --ar 5:4\n\n3️⃣ xxx3 --ar 5:4\n\n4️⃣ xxx4 --ar 5:4&#34;,&#xA;  &#34;description&#34;:&#34;/describe 3856553004865376.png&#34;,&#xA;  &#34;state&#34;:&#34;test:22&#34;,&#xA;  &#34;submitTime&#34;:1683779732983,&#xA;  &#34;finishTime&#34;:1683779741711,&#xA;  &#34;imageUrl&#34;:&#34;https://cdn.discordapp.com/ephemeral-attachments/xxxx/xxxx/3856553004865376.png&#34;,&#xA;  &#34;status&#34;:&#34;SUCCESS&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;4. &lt;code&gt;http://ip:port/mj/task/{id}/fetch&lt;/code&gt; GET 查询单个任务&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    // 动作: IMAGINE（绘图）、UPSCALE（选中放大）、VARIATION（选中变换）&#xA;    &#34;action&#34;:&#34;IMAGINE&#34;,&#xA;    // 任务ID&#xA;    &#34;id&#34;:&#34;8498455807628990&#34;,&#xA;    // 绘图参数&#xA;    &#34;prompt&#34;:&#34;猫猫&#34;,&#xA;    // 翻译后的绘图参数&#xA;    &#34;promptEn&#34;: &#34;Cat&#34;,&#xA;    // 执行的命令&#xA;    &#34;description&#34;:&#34;/imagine 猫猫&#34;,&#xA;    // 自定义参数&#xA;    &#34;state&#34;:&#34;test:22&#34;,&#xA;    // 提交时间&#xA;    &#34;submitTime&#34;:1682473784826,&#xA;    // 结束时间&#xA;    &#34;finishTime&#34;:null,&#xA;    // 生成图片的url, 成功时有值&#xA;    &#34;imageUrl&#34;:&#34;https://cdn.discordapp.com/attachments/xxx/xxx/xxxx_xxxx.png&#34;,&#xA;    // 任务状态: NOT_START（未启动）、IN_PROGRESS（执行中）、FAILURE（失败）、SUCCESS（成功）&#xA;    &#34;status&#34;:&#34;IN_PROGRESS&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;5. &lt;code&gt;http://ip:port/mj/task/list&lt;/code&gt; GET 查询所有任务&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[&#xA;  {&#xA;    &#34;action&#34;:&#34;IMAGINE&#34;,&#xA;    &#34;id&#34;:&#34;8498455807628990&#34;,&#xA;    &#34;prompt&#34;:&#34;猫猫&#34;,&#xA;    &#34;promptEn&#34;: &#34;Cat&#34;,&#xA;    &#34;description&#34;:&#34;/imagine 猫猫&#34;,&#xA;    &#34;state&#34;:&#34;test:22&#34;,&#xA;    &#34;submitTime&#34;:1682473784826,&#xA;    &#34;finishTime&#34;:null,&#xA;    &#34;imageUrl&#34;:null,&#xA;    &#34;status&#34;:&#34;IN_PROGRESS&#34;&#xA;  }&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;mj.notify-hook&lt;/code&gt; 任务变更回调&lt;/h2&gt; &#xA;&lt;p&gt;POST application/json&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;action&#34;:&#34;IMAGINE&#34;,&#xA;    &#34;id&#34;:&#34;8498455807628990&#34;,&#xA;    &#34;prompt&#34;:&#34;猫猫&#34;,&#xA;    &#34;promptEn&#34;: &#34;Cat&#34;,&#xA;    &#34;description&#34;:&#34;/imagine 猫猫&#34;,&#xA;    &#34;state&#34;:&#34;test:22&#34;,&#xA;    &#34;submitTime&#34;:1682473784826,&#xA;    &#34;finishTime&#34;:null,&#xA;    &#34;imageUrl&#34;:null,&#xA;    &#34;status&#34;:&#34;IN_PROGRESS&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;应用项目&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/novicezk/wechat-midjourney&#34;&gt;wechat-midjourney&lt;/a&gt; : 代理微信客户端，接入MidJourney&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>opengoofy/hippo4j</title>
    <updated>2023-05-21T01:55:02Z</updated>
    <id>tag:github.com,2023-05-21:/opengoofy/hippo4j</id>
    <link href="https://github.com/opengoofy/hippo4j" rel="alternate"></link>
    <summary type="html">&lt;p&gt;📌 异步线程池框架，支持线程池动态变更&amp;监控&amp;报警，无需修改代码轻松引入。Asynchronous thread pool framework, support Thread Pool Dynamic Change &amp; monitoring &amp; Alarm, no need to modify the code easily introduced.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;动态可观测线程池，提高系统运行保障能力&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-Apache--2.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/opengoofy/hippo4j&#34;&gt;&lt;img src=&#34;https://github.com/opengoofy/hippo4j/actions/workflows/ci.yml/badge.svg?event=push&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/stars/opengoofy/hippo4j?color=5470c6&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/forks/opengoofy/hippo4j?color=3ba272&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/contributors/opengoofy/hippo4j&#34; alt=&#34;&#34;&gt; &lt;a href=&#34;https://store.docker.com/community/images/hippo4j/hippo4j-server&#34;&gt;&lt;img src=&#34;https://img.shields.io/docker/pulls/hippo4j/hippo4j-server.svg?label=docker%20pulls&amp;amp;color=fac858&#34; alt=&#34;Docker Pulls&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/opengoofy/hippo4j&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/opengoofy/hippo4j/branch/develop/graph/badge.svg?token=WBUVJN107I&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/opengoofy/hippo4j/raw/develop/README-EN.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/readme-English-orange.svg?sanitize=true&#34; alt=&#34;EN doc&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;strong&gt;Stargazers Over Time&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;strong&gt;Contributors Over Time&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://api.star-history.com/svg?repos=opengoofy/hippo4j&amp;amp;type=Date&#34;&gt;&lt;img src=&#34;https://api.star-history.com/svg?repos=opengoofy/hippo4j&amp;amp;type=Date&#34; alt=&#34;Stargazers over time&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.apiseven.com/en/contributor-graph?chart=contributorOverTime&amp;amp;repo=opengoofy/hippo4j&#34;&gt;&lt;img src=&#34;https://contributor-graph-api.apiseven.com/contributors-svg?chart=contributorOverTime&amp;amp;repo=opengoofy/hippo4j&#34; alt=&#34;Contributor over time&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;开源地址&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;GitHub：&lt;a href=&#34;https://github.com/opengoofy/hippo4j&#34;&gt;opengoofy/hippo4j&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Gitee：&lt;a href=&#34;https://gitee.com/magestack/hippo4j&#34;&gt;opengoofy/hippo4j&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For full documentation &amp;amp; more details, visit: &lt;a href=&#34;https://www.hippo4j.cn&#34;&gt;Docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;线程池痛点&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;线程池是一种基于池化思想管理线程的工具，使用线程池可以减少创建销毁线程的开销，避免线程过多导致系统资源耗尽。在高并发以及大批量的任务处理场景，线程池的使用是必不可少的。&lt;/p&gt; &#xA;&lt;p&gt;如果有在项目中实际使用线程池，相信你可能会遇到以下痛点：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;线程池随便定义，线程资源过多，造成服务器高负载。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;线程池参数不易评估，随着业务的并发提升，业务面临出现故障的风险。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;线程池任务执行时间超过平均执行周期，开发人员无法感知。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;线程池任务堆积，触发拒绝策略，影响既有业务正常运行。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;当业务出现超时、熔断等问题时，因为没有监控，无法确定是不是线程池引起。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;原生线程池不支持运行时变量的传递，比如 MDC 上下文遇到线程池就 GG。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;无法执行优雅关闭，当项目关闭时，大量正在运行的线程池任务被丢弃。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;线程池运行中，任务执行停止，怀疑发生死锁或执行耗时操作，但是无从下手。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;什么是 Hippo4j&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;提供以下功能支持：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;全局管控 - 管理应用线程池实例。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;动态变更 - 应用运行时动态变更线程池参数，包括但不限于：核心、最大线程数、阻塞队列容量、拒绝策略等。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;通知报警 - 内置四种报警通知策略，线程池活跃度、容量水位、拒绝策略以及任务执行时间超长。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;数据采集 - 支持多种方式采集线程池数据，包括但不限于：日志、内置采集、Prometheus、InfluxDB、ElasticSearch 等。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;运行监控 - 实时查看线程池运行时数据，自定义时间内线程池运行数据图表展示。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;功能扩展 - 支持线程池任务传递上下文；项目关闭时，支持等待线程池在指定时间内完成任务。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;多种模式 - 内置两种使用模式：&lt;a href=&#34;https://hippo4j.cn/docs/user_docs/getting_started/config/hippo4j-config-start&#34;&gt;依赖配置中心&lt;/a&gt; 和 &lt;a href=&#34;https://hippo4j.cn/docs/user_docs/getting_started/server/hippo4j-server-start&#34;&gt;无中间件依赖&lt;/a&gt;。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;容器管理 - Tomcat、Jetty、Undertow 容器线程池运行时查看和线程数变更。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;框架适配 - Dubbo、Hystrix、RabbitMQ、RocketMQ 等消费线程池运行时数据查看和线程数变更。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;变更审核 - 提供多种用户角色，普通用户变更线程池参数需要 Admin 用户审核方可生效。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;动态化插件 - 内置多种线程池插件，支持用户自定义插件以及运行时扩展。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;多版本适配 - 经过实际测试，已支持客户端 SpringBoot 1.5.x =&amp;gt; 2.7.5 版本（更高版本未测试）。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;架构设计&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;img width=&#34;1307&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/106363931/233792824-f879500f-fea1-4872-be15-957236f6bf2b.png&#34;&gt; &#xA;&lt;h3&gt;快速开始&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;对于本地演示目的，请参阅 &lt;a href=&#34;https://hippo4j.cn/docs/user_docs/user_guide/quick-start&#34;&gt;Quick start&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;演示环境： &lt;a href=&#34;http://console.hippo4j.cn/index.html&#34;&gt;http://console.hippo4j.cn/index.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;接入登记&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;更多接入的公司，欢迎在 &lt;a href=&#34;https://github.com/opengoofy/hippo4j/issues/13&#34;&gt;登记地址&lt;/a&gt; 登记，登记仅仅为了产品推广。&lt;/p&gt; &#xA;&lt;h3&gt;联系我&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;开源不易，右上角点个 Star 鼓励一下吧！&lt;/p&gt; &#xA;&lt;p&gt;如果大家想要实时关注 Hippo4j 更新的文章以及分享的干货的话，可以关注我的公众号。&lt;/p&gt; &#xA;&lt;p&gt;使用过程中有任何问题，或者对项目有什么建议，关注公众号回复：加群，和 &lt;code&gt;1000+&lt;/code&gt; 志同道合的朋友交流讨论。&lt;/p&gt; &#xA;&lt;img width=&#34;586&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/77398366/225888779-367f42a6-8401-4867-8e80-44214e1d17c1.png&#34;&gt; &#xA;&lt;h3&gt;深入原理&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;如果您公司没有使用 Hippo4j 场景的话，我也建议去阅读下项目的底层原理，主要有以下几个原因：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;为了提高代码质量以及后续的扩展行为，运用多种设计模式实现高内聚、低耦合。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;框架底层依赖 Spring 框架运行，并在源码中大量使用 Spring 相关功能。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;运用 JUC 并发包下多种工具保障多线程运行安全，通过实际场景理解并发编程。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;借鉴主流开源框架 Nacos、Eureka 实现轻量级配置中心和注册中心功能。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;自定义 RPC 框架实现，封装 Netty 完成客户端/服务端网络通信优化。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;通过 CheckStyle、Spotless 等插件规范代码编写，保障高质量代码行为和代码样式。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;友情链接&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/dromara/sa-token&#34;&gt;[ Sa-Token ]&lt;/a&gt;：一个轻量级 java 权限认证框架，让鉴权变得简单、优雅！&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/dromara/hertzbeat&#34;&gt;[ HertzBeat ]&lt;/a&gt;：易用友好的云监控系统, 无需 Agent, 强大自定义监控能力。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/Snailclimb/JavaGuide&#34;&gt;[ JavaGuide ]&lt;/a&gt;：一份涵盖大部分 Java 程序员所需要掌握的核心知识。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/itwanger/toBeBetterJavaer&#34;&gt;[ toBeBetterJavaer ]&lt;/a&gt;：一份通俗易懂、风趣幽默的 Java 学习指南。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://gitee.com/dromara/Jpom&#34;&gt;[ Jpom ]&lt;/a&gt;：简而轻的低侵入式在线构建、自动部署、日常运维、项目监控软件。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://gitee.com/opengoofy/congomall&#34;&gt;[ CongoMall ]&lt;/a&gt;：作者的另一个开源项目刚果商城，包含了商城业务和基础架构两大模块。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;贡献者&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;感谢所有为项目作出贡献的开发者。如果有意贡献，参考 &lt;a href=&#34;https://github.com/opengoofy/hippo4j/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22&#34;&gt;good first issue&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;!-- readme: contributors -start --&gt; &#xA;&lt;!-- readme: contributors -end --&gt; &#xA;&lt;h3&gt;鸣谢&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Hippo4j 社区收到 Jetbrains 多份 Licenses，并已分配项目 &lt;a href=&#34;https://hippo4j.cn/community/team/&#34;&gt;活跃开发者&lt;/a&gt;，非常感谢 Jetbrains 对开源社区的支持。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://resources.jetbrains.com/storage/products/company/brand/logos/jb_beam.svg?sanitize=true&#34; alt=&#34;JetBrains Logo (Main) logo&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>