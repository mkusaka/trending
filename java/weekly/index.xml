<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-11T01:47:24Z</updated>
  <subtitle>Weekly Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ReactiveX/RxJava</title>
    <updated>2024-02-11T01:47:24Z</updated>
    <id>tag:github.com,2024-02-11:/ReactiveX/RxJava</id>
    <link href="https://github.com/ReactiveX/RxJava" rel="alternate"></link>
    <summary type="html">&lt;p&gt;RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RxJava: Reactive Extensions for the JVM&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxJava/actions?query=workflow%3ASnapshot&#34;&gt;&lt;img src=&#34;https://github.com/ReactiveX/RxJava/workflows/Snapshot/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/ReactiveX/RxJava/branch/3.x&#34;&gt;&lt;img src=&#34;http://codecov.io/github/ReactiveX/RxJava/coverage.svg?branch=3.x&#34; alt=&#34;codecov.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/io.reactivex.rxjava3/rxjava&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/io.reactivex.rxjava3/rxjava/badge.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitpod.io/#https://github.com/ReactiveX/RxJava&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Contribute%20with-Gitpod-908a85?logo=gitpod&#34; alt=&#34;Contribute with Gitpod&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://securityscorecards.dev/viewer/?uri=github.com/ReactiveX/RxJava&#34;&gt;&lt;img src=&#34;https://api.securityscorecards.dev/projects/github.com/ReactiveX/RxJava/badge&#34; alt=&#34;OpenSSF Scorecard&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;RxJava is a Java VM implementation of &lt;a href=&#34;http://reactivex.io&#34;&gt;Reactive Extensions&lt;/a&gt;: a library for composing asynchronous and event-based programs by using observable sequences.&lt;/p&gt; &#xA;&lt;p&gt;It extends the &lt;a href=&#34;http://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;observer pattern&lt;/a&gt; to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures.&lt;/p&gt; &#xA;&lt;h4&gt;Version 3.x (&lt;a href=&#34;http://reactivex.io/RxJava/3.x/javadoc/&#34;&gt;Javadoc&lt;/a&gt;)&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Single dependency: &lt;a href=&#34;https://github.com/reactive-streams/reactive-streams-jvm&#34;&gt;Reactive-Streams&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Java 8+ or Android API 21+ required.&lt;/li&gt; &#xA; &lt;li&gt;Java 8 lambda-friendly API.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxAndroid&#34;&gt;Android&lt;/a&gt; desugar friendly.&lt;/li&gt; &#xA; &lt;li&gt;Fixed API mistakes and many limits of RxJava 2.&lt;/li&gt; &#xA; &lt;li&gt;Intended to be a replacement for RxJava 2 with relatively few binary incompatible changes.&lt;/li&gt; &#xA; &lt;li&gt;Non-opinionated about the source of concurrency (threads, pools, event loops, fibers, actors, etc.).&lt;/li&gt; &#xA; &lt;li&gt;Async or synchronous execution.&lt;/li&gt; &#xA; &lt;li&gt;Virtual time and schedulers for parameterized concurrency.&lt;/li&gt; &#xA; &lt;li&gt;Test and diagnostic support via test schedulers, test consumers and plugin hooks.&lt;/li&gt; &#xA; &lt;li&gt;Interop with newer JDK versions via 3rd party libraries, such as &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/akarnokd/RxJavaJdk9Interop#rxjavajdk9interop&#34;&gt;Java 9 Flow API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/akarnokd/RxJavaFiberInterop#rxjavafiberinterop&#34;&gt;Java 21 Virtual Threads&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Learn more about RxJava in general on the &lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki&#34;&gt;Wiki Home&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;ℹ&lt;/span&gt; Please read the &lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-3.0&#34;&gt;What&#39;s different in 3.0&lt;/a&gt; for details on the changes and migration information when upgrading from 2.x.&lt;/p&gt; &#xA;&lt;h4&gt;Version 2.x&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/ReactiveX/RxJava/tree/2.x&#34;&gt;2.x version&lt;/a&gt; is end-of-life as of &lt;strong&gt;February 28, 2021&lt;/strong&gt;. No further development, support, maintenance, PRs and updates will happen. The &lt;a href=&#34;https://raw.githubusercontent.com/ReactiveX/RxJava/3.x/%5BJavadoc%5D(http://reactivex.io/RxJava/2.x/javadoc/)&#34;&gt;Javadoc&lt;/a&gt; of the very last version, &lt;strong&gt;2.2.21&lt;/strong&gt;, will remain accessible.&lt;/p&gt; &#xA;&lt;h4&gt;Version 1.x&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/ReactiveX/RxJava/tree/1.x&#34;&gt;1.x version&lt;/a&gt; is end-of-life as of &lt;strong&gt;March 31, 2018&lt;/strong&gt;. No further development, support, maintenance, PRs and updates will happen. The &lt;a href=&#34;https://raw.githubusercontent.com/ReactiveX/RxJava/3.x/%5BJavadoc%5D(http://reactivex.io/RxJava/1.x/javadoc/)&#34;&gt;Javadoc&lt;/a&gt; of the very last version, &lt;strong&gt;1.3.8&lt;/strong&gt;, will remain accessible.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;h3&gt;Setting up the dependency&lt;/h3&gt; &#xA;&lt;p&gt;The first step is to include RxJava 3 into your project, for example, as a Gradle compile dependency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;implementation &#34;io.reactivex.rxjava3:rxjava:3.x.y&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Please replace &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; with the latest version numbers: &lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/io.reactivex.rxjava3/rxjava&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/io.reactivex.rxjava3/rxjava/badge.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt; )&lt;/p&gt; &#xA;&lt;h3&gt;Hello World&lt;/h3&gt; &#xA;&lt;p&gt;The second is to write the &lt;strong&gt;Hello World&lt;/strong&gt; program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package rxjava.examples;&#xA;&#xA;import io.reactivex.rxjava3.core.*;&#xA;&#xA;public class HelloWorld {&#xA;    public static void main(String[] args) {&#xA;        Flowable.just(&#34;Hello world&#34;).subscribe(System.out::println);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that RxJava 3 components now live under &lt;code&gt;io.reactivex.rxjava3&lt;/code&gt; and the base classes and interfaces live under &lt;code&gt;io.reactivex.rxjava3.core&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Base classes&lt;/h3&gt; &#xA;&lt;p&gt;RxJava 3 features several base classes you can discover operators on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html&#34;&gt;&lt;code&gt;io.reactivex.rxjava3.core.Flowable&lt;/code&gt;&lt;/a&gt;: 0..N flows, supporting Reactive-Streams and backpressure&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Observable.html&#34;&gt;&lt;code&gt;io.reactivex.rxjava3.core.Observable&lt;/code&gt;&lt;/a&gt;: 0..N flows, no backpressure,&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Single.html&#34;&gt;&lt;code&gt;io.reactivex.rxjava3.core.Single&lt;/code&gt;&lt;/a&gt;: a flow of exactly 1 item or an error,&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Completable.html&#34;&gt;&lt;code&gt;io.reactivex.rxjava3.core.Completable&lt;/code&gt;&lt;/a&gt;: a flow without items but only a completion or error signal,&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Maybe.html&#34;&gt;&lt;code&gt;io.reactivex.rxjava3.core.Maybe&lt;/code&gt;&lt;/a&gt;: a flow with no items, exactly one item or an error.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Some terminology&lt;/h3&gt; &#xA;&lt;h4&gt;Upstream, downstream&lt;/h4&gt; &#xA;&lt;p&gt;The dataflows in RxJava consist of a source, zero or more intermediate steps followed by a data consumer or combinator step (where the step is responsible to consume the dataflow by some means):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;source.operator1().operator2().operator3().subscribe(consumer);&#xA;&#xA;source.flatMap(value -&amp;gt; source.operator1().operator2().operator3());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, if we imagine ourselves on &lt;code&gt;operator2&lt;/code&gt;, looking to the left towards the source is called the &lt;strong&gt;upstream&lt;/strong&gt;. Looking to the right towards the subscriber/consumer is called the &lt;strong&gt;downstream&lt;/strong&gt;. This is often more apparent when each element is written on a separate line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;source&#xA;  .operator1()&#xA;  .operator2()&#xA;  .operator3()&#xA;  .subscribe(consumer)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Objects in motion&lt;/h4&gt; &#xA;&lt;p&gt;In RxJava&#39;s documentation, &lt;strong&gt;emission&lt;/strong&gt;, &lt;strong&gt;emits&lt;/strong&gt;, &lt;strong&gt;item&lt;/strong&gt;, &lt;strong&gt;event&lt;/strong&gt;, &lt;strong&gt;signal&lt;/strong&gt;, &lt;strong&gt;data&lt;/strong&gt; and &lt;strong&gt;message&lt;/strong&gt; are considered synonyms and represent the object traveling along the dataflow.&lt;/p&gt; &#xA;&lt;h4&gt;Backpressure&lt;/h4&gt; &#xA;&lt;p&gt;When the dataflow runs through asynchronous steps, each step may perform different things with different speed. To avoid overwhelming such steps, which usually would manifest itself as increased memory usage due to temporary buffering or the need for skipping/dropping data, so-called backpressure is applied, which is a form of flow control where the steps can express how many items are they ready to process. This allows constraining the memory usage of the dataflows in situations where there is generally no way for a step to know how many items the upstream will send to it.&lt;/p&gt; &#xA;&lt;p&gt;In RxJava, the dedicated &lt;code&gt;Flowable&lt;/code&gt; class is designated to support backpressure and &lt;code&gt;Observable&lt;/code&gt; is dedicated to the non-backpressured operations (short sequences, GUI interactions, etc.). The other types, &lt;code&gt;Single&lt;/code&gt;, &lt;code&gt;Maybe&lt;/code&gt; and &lt;code&gt;Completable&lt;/code&gt; don&#39;t support backpressure nor should they; there is always room to store one item temporarily.&lt;/p&gt; &#xA;&lt;h4&gt;Assembly time&lt;/h4&gt; &#xA;&lt;p&gt;The preparation of dataflows by applying various intermediate operators happens in the so-called &lt;strong&gt;assembly time&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable&amp;lt;Integer&amp;gt; flow = Flowable.range(1, 5)&#xA;.map(v -&amp;gt; v * v)&#xA;.filter(v -&amp;gt; v % 3 == 0)&#xA;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At this point, the data is not flowing yet and no side-effects are happening.&lt;/p&gt; &#xA;&lt;h4&gt;Subscription time&lt;/h4&gt; &#xA;&lt;p&gt;This is a temporary state when &lt;code&gt;subscribe()&lt;/code&gt; is called on a flow that establishes the chain of processing steps internally:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;flow.subscribe(System.out::println)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is when the &lt;strong&gt;subscription side-effects&lt;/strong&gt; are triggered (see &lt;code&gt;doOnSubscribe&lt;/code&gt;). Some sources block or start emitting items right away in this state.&lt;/p&gt; &#xA;&lt;h4&gt;Runtime&lt;/h4&gt; &#xA;&lt;p&gt;This is the state when the flows are actively emitting items, errors or completion signals:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&#xA;Observable.create(emitter -&amp;gt; {&#xA;     while (!emitter.isDisposed()) {&#xA;         long time = System.currentTimeMillis();&#xA;         emitter.onNext(time);&#xA;         if (time % 2 != 0) {&#xA;             emitter.onError(new IllegalStateException(&#34;Odd millisecond!&#34;));&#xA;             break;&#xA;         }&#xA;     }&#xA;})&#xA;.subscribe(System.out::println, Throwable::printStackTrace);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Practically, this is when the body of the given example above executes.&lt;/p&gt; &#xA;&lt;h3&gt;Simple background computation&lt;/h3&gt; &#xA;&lt;p&gt;One of the common use cases for RxJava is to run some computation, network request on a background thread and show the results (or error) on the UI thread:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import io.reactivex.rxjava3.schedulers.Schedulers;&#xA;&#xA;Flowable.fromCallable(() -&amp;gt; {&#xA;    Thread.sleep(1000); //  imitate expensive computation&#xA;    return &#34;Done&#34;;&#xA;})&#xA;  .subscribeOn(Schedulers.io())&#xA;  .observeOn(Schedulers.single())&#xA;  .subscribe(System.out::println, Throwable::printStackTrace);&#xA;&#xA;Thread.sleep(2000); // &amp;lt;--- wait for the flow to finish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This style of chaining methods is called a &lt;strong&gt;fluent API&lt;/strong&gt; which resembles the &lt;strong&gt;builder pattern&lt;/strong&gt;. However, RxJava&#39;s reactive types are immutable; each of the method calls returns a new &lt;code&gt;Flowable&lt;/code&gt; with added behavior. To illustrate, the example can be rewritten as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable&amp;lt;String&amp;gt; source = Flowable.fromCallable(() -&amp;gt; {&#xA;    Thread.sleep(1000); //  imitate expensive computation&#xA;    return &#34;Done&#34;;&#xA;});&#xA;&#xA;Flowable&amp;lt;String&amp;gt; runBackground = source.subscribeOn(Schedulers.io());&#xA;&#xA;Flowable&amp;lt;String&amp;gt; showForeground = runBackground.observeOn(Schedulers.single());&#xA;&#xA;showForeground.subscribe(System.out::println, Throwable::printStackTrace);&#xA;&#xA;Thread.sleep(2000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Typically, you can move computations or blocking IO to some other thread via &lt;code&gt;subscribeOn&lt;/code&gt;. Once the data is ready, you can make sure they get processed on the foreground or GUI thread via &lt;code&gt;observeOn&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Schedulers&lt;/h3&gt; &#xA;&lt;p&gt;RxJava operators don&#39;t work with &lt;code&gt;Thread&lt;/code&gt;s or &lt;code&gt;ExecutorService&lt;/code&gt;s directly but with so-called &lt;code&gt;Scheduler&lt;/code&gt;s that abstract away sources of concurrency behind a uniform API. RxJava 3 features several standard schedulers accessible via &lt;code&gt;Schedulers&lt;/code&gt; utility class.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Schedulers.computation()&lt;/code&gt;: Run computation intensive work on a fixed number of dedicated threads in the background. Most asynchronous operators use this as their default &lt;code&gt;Scheduler&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Schedulers.io()&lt;/code&gt;: Run I/O-like or blocking operations on a dynamically changing set of threads.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Schedulers.single()&lt;/code&gt;: Run work on a single thread in a sequential and FIFO manner.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Schedulers.trampoline()&lt;/code&gt;: Run work in a sequential and FIFO manner in one of the participating threads, usually for testing purposes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These are available on all JVM platforms but some specific platforms, such as Android, have their own typical &lt;code&gt;Scheduler&lt;/code&gt;s defined: &lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt;, &lt;code&gt;SwingScheduler.instance()&lt;/code&gt; or &lt;code&gt;JavaFXScheduler.platform()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In addition, there is an option to wrap an existing &lt;code&gt;Executor&lt;/code&gt; (and its subtypes such as &lt;code&gt;ExecutorService&lt;/code&gt;) into a &lt;code&gt;Scheduler&lt;/code&gt; via &lt;code&gt;Schedulers.from(Executor)&lt;/code&gt;. This can be used, for example, to have a larger but still fixed pool of threads (unlike &lt;code&gt;computation()&lt;/code&gt; and &lt;code&gt;io()&lt;/code&gt; respectively).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Thread.sleep(2000);&lt;/code&gt; at the end is no accident. In RxJava the default &lt;code&gt;Scheduler&lt;/code&gt;s run on daemon threads, which means once the Java main thread exits, they all get stopped and background computations may never happen. Sleeping for some time in this example situations lets you see the output of the flow on the console with time to spare.&lt;/p&gt; &#xA;&lt;h3&gt;Concurrency within a flow&lt;/h3&gt; &#xA;&lt;p&gt;Flows in RxJava are sequential in nature split into processing stages that may run &lt;strong&gt;concurrently&lt;/strong&gt; with each other:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable.range(1, 10)&#xA;  .observeOn(Schedulers.computation())&#xA;  .map(v -&amp;gt; v * v)&#xA;  .blockingSubscribe(System.out::println);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example flow squares the numbers from 1 to 10 on the &lt;strong&gt;computation&lt;/strong&gt; &lt;code&gt;Scheduler&lt;/code&gt; and consumes the results on the &#34;main&#34; thread (more precisely, the caller thread of &lt;code&gt;blockingSubscribe&lt;/code&gt;). However, the lambda &lt;code&gt;v -&amp;gt; v * v&lt;/code&gt; doesn&#39;t run in parallel for this flow; it receives the values 1 to 10 on the same computation thread one after the other.&lt;/p&gt; &#xA;&lt;h3&gt;Parallel processing&lt;/h3&gt; &#xA;&lt;p&gt;Processing the numbers 1 to 10 in parallel is a bit more involved:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable.range(1, 10)&#xA;  .flatMap(v -&amp;gt;&#xA;      Flowable.just(v)&#xA;        .subscribeOn(Schedulers.computation())&#xA;        .map(w -&amp;gt; w * w)&#xA;  )&#xA;  .blockingSubscribe(System.out::println);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Practically, parallelism in RxJava means running independent flows and merging their results back into a single flow. The operator &lt;code&gt;flatMap&lt;/code&gt; does this by first mapping each number from 1 to 10 into its own individual &lt;code&gt;Flowable&lt;/code&gt;, runs them and merges the computed squares.&lt;/p&gt; &#xA;&lt;p&gt;Note, however, that &lt;code&gt;flatMap&lt;/code&gt; doesn&#39;t guarantee any order and the items from the inner flows may end up interleaved. There are alternative operators:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;concatMap&lt;/code&gt; that maps and runs one inner flow at a time and&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;concatMapEager&lt;/code&gt; which runs all inner flows &#34;at once&#34; but the output flow will be in the order those inner flows were created.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Alternatively, the &lt;code&gt;Flowable.parallel()&lt;/code&gt; operator and the &lt;code&gt;ParallelFlowable&lt;/code&gt; type help achieve the same parallel processing pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable.range(1, 10)&#xA;  .parallel()&#xA;  .runOn(Schedulers.computation())&#xA;  .map(v -&amp;gt; v * v)&#xA;  .sequential()&#xA;  .blockingSubscribe(System.out::println);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dependent sub-flows&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; is a powerful operator and helps in a lot of situations. For example, given a service that returns a &lt;code&gt;Flowable&lt;/code&gt;, we&#39;d like to call another service with values emitted by the first service:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable&amp;lt;Inventory&amp;gt; inventorySource = warehouse.getInventoryAsync();&#xA;&#xA;inventorySource&#xA;    .flatMap(inventoryItem -&amp;gt; erp.getDemandAsync(inventoryItem.getId())&#xA;            .map(demand -&amp;gt; &#34;Item &#34; + inventoryItem.getName() + &#34; has demand &#34; + demand))&#xA;    .subscribe(System.out::println);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Continuations&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes, when an item has become available, one would like to perform some dependent computations on it. This is sometimes called &lt;strong&gt;continuations&lt;/strong&gt; and, depending on what should happen and what types are involved, may involve various operators to accomplish.&lt;/p&gt; &#xA;&lt;h4&gt;Dependent&lt;/h4&gt; &#xA;&lt;p&gt;The most typical scenario is to given a value, invoke another service, await and continue with its result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;service.apiCall()&#xA;.flatMap(value -&amp;gt; service.anotherApiCall(value))&#xA;.flatMap(next -&amp;gt; service.finalCall(next))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is often the case also that later sequences would require values from earlier mappings. This can be achieved by moving the outer &lt;code&gt;flatMap&lt;/code&gt; into the inner parts of the previous &lt;code&gt;flatMap&lt;/code&gt; for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;service.apiCall()&#xA;.flatMap(value -&amp;gt;&#xA;    service.anotherApiCall(value)&#xA;    .flatMap(next -&amp;gt; service.finalCallBoth(value, next))&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, the original &lt;code&gt;value&lt;/code&gt; will be available inside the inner &lt;code&gt;flatMap&lt;/code&gt;, courtesy of lambda variable capture.&lt;/p&gt; &#xA;&lt;h4&gt;Non-dependent&lt;/h4&gt; &#xA;&lt;p&gt;In other scenarios, the result(s) of the first source/dataflow is irrelevant and one would like to continue with a quasi independent another source. Here, &lt;code&gt;flatMap&lt;/code&gt; works as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Observable continued = sourceObservable.flatMapSingle(ignored -&amp;gt; someSingleSource)&#xA;continued.map(v -&amp;gt; v.toString())&#xA;  .subscribe(System.out::println, Throwable::printStackTrace);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;however, the continuation in this case stays &lt;code&gt;Observable&lt;/code&gt; instead of the likely more appropriate &lt;code&gt;Single&lt;/code&gt;. (This is understandable because from the perspective of &lt;code&gt;flatMapSingle&lt;/code&gt;, &lt;code&gt;sourceObservable&lt;/code&gt; is a multi-valued source and thus the mapping may result in multiple values as well).&lt;/p&gt; &#xA;&lt;p&gt;Often though there is a way that is somewhat more expressive (and also lower overhead) by using &lt;code&gt;Completable&lt;/code&gt; as the mediator and its operator &lt;code&gt;andThen&lt;/code&gt; to resume with something else:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;sourceObservable&#xA;  .ignoreElements()           // returns Completable&#xA;  .andThen(someSingleSource)&#xA;  .map(v -&amp;gt; v.toString())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The only dependency between the &lt;code&gt;sourceObservable&lt;/code&gt; and the &lt;code&gt;someSingleSource&lt;/code&gt; is that the former should complete normally in order for the latter to be consumed.&lt;/p&gt; &#xA;&lt;h4&gt;Deferred-dependent&lt;/h4&gt; &#xA;&lt;p&gt;Sometimes, there is an implicit data dependency between the previous sequence and the new sequence that, for some reason, was not flowing through the &#34;regular channels&#34;. One would be inclined to write such continuations as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AtomicInteger count = new AtomicInteger();&#xA;&#xA;Observable.range(1, 10)&#xA;  .doOnNext(ignored -&amp;gt; count.incrementAndGet())&#xA;  .ignoreElements()&#xA;  .andThen(Single.just(count.get()))&#xA;  .subscribe(System.out::println);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unfortunately, this prints &lt;code&gt;0&lt;/code&gt; because &lt;code&gt;Single.just(count.get())&lt;/code&gt; is evaluated at &lt;strong&gt;assembly time&lt;/strong&gt; when the dataflow hasn&#39;t even run yet. We need something that defers the evaluation of this &lt;code&gt;Single&lt;/code&gt; source until &lt;strong&gt;runtime&lt;/strong&gt; when the main source completes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AtomicInteger count = new AtomicInteger();&#xA;&#xA;Observable.range(1, 10)&#xA;  .doOnNext(ignored -&amp;gt; count.incrementAndGet())&#xA;  .ignoreElements()&#xA;  .andThen(Single.defer(() -&amp;gt; Single.just(count.get())))&#xA;  .subscribe(System.out::println);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AtomicInteger count = new AtomicInteger();&#xA;&#xA;Observable.range(1, 10)&#xA;  .doOnNext(ignored -&amp;gt; count.incrementAndGet())&#xA;  .ignoreElements()&#xA;  .andThen(Single.fromCallable(() -&amp;gt; count.get()))&#xA;  .subscribe(System.out::println);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Type conversions&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes, a source or service returns a different type than the flow that is supposed to work with it. For example, in the inventory example above, &lt;code&gt;getDemandAsync&lt;/code&gt; could return a &lt;code&gt;Single&amp;lt;DemandRecord&amp;gt;&lt;/code&gt;. If the code example is left unchanged, this will result in a compile-time error (however, often with a misleading error message about lack of overload).&lt;/p&gt; &#xA;&lt;p&gt;In such situations, there are usually two options to fix the transformation: 1) convert to the desired type or 2) find and use an overload of the specific operator supporting the different type.&lt;/p&gt; &#xA;&lt;h4&gt;Converting to the desired type&lt;/h4&gt; &#xA;&lt;p&gt;Each reactive base class features operators that can perform such conversions, including the protocol conversions, to match some other type. The following matrix shows the available conversion options:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Flowable&lt;/th&gt; &#xA;   &lt;th&gt;Observable&lt;/th&gt; &#xA;   &lt;th&gt;Single&lt;/th&gt; &#xA;   &lt;th&gt;Maybe&lt;/th&gt; &#xA;   &lt;th&gt;Completable&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Flowable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toObservable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrError&lt;/code&gt;, &lt;code&gt;single&lt;/code&gt;, &lt;code&gt;singleOrError&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;lastOrError&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;firstElement&lt;/code&gt;, &lt;code&gt;singleElement&lt;/code&gt;, &lt;code&gt;lastElement&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ignoreElements&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Observable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toFlowable&lt;/code&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrError&lt;/code&gt;, &lt;code&gt;single&lt;/code&gt;, &lt;code&gt;singleOrError&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;lastOrError&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;firstElement&lt;/code&gt;, &lt;code&gt;singleElement&lt;/code&gt;, &lt;code&gt;lastElement&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ignoreElements&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Single&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toFlowable&lt;/code&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toObservable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toMaybe&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ignoreElement&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Maybe&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toFlowable&lt;/code&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toObservable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toSingle&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ignoreElement&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Completable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toFlowable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toObservable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toSingle&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;toMaybe&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt;: When turning a multi-valued source into a single-valued source, one should decide which of the many source values should be considered as the result.&lt;/p&gt; &#xA;&lt;p&gt;&lt;sup&gt;2&lt;/sup&gt;: Turning an &lt;code&gt;Observable&lt;/code&gt; into &lt;code&gt;Flowable&lt;/code&gt; requires an additional decision: what to do with the potential unconstrained flow of the source &lt;code&gt;Observable&lt;/code&gt;? There are several strategies available (such as buffering, dropping, keeping the latest) via the &lt;code&gt;BackpressureStrategy&lt;/code&gt; parameter or via standard &lt;code&gt;Flowable&lt;/code&gt; operators such as &lt;code&gt;onBackpressureBuffer&lt;/code&gt;, &lt;code&gt;onBackpressureDrop&lt;/code&gt;, &lt;code&gt;onBackpressureLatest&lt;/code&gt; which also allow further customization of the backpressure behavior.&lt;/p&gt; &#xA;&lt;p&gt;&lt;sup&gt;3&lt;/sup&gt;: When there is only (at most) one source item, there is no problem with backpressure as it can be always stored until the downstream is ready to consume.&lt;/p&gt; &#xA;&lt;h4&gt;Using an overload with the desired type&lt;/h4&gt; &#xA;&lt;p&gt;Many frequently used operator has overloads that can deal with the other types. These are usually named with the suffix of the target type:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Operator&lt;/th&gt; &#xA;   &lt;th&gt;Overloads&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;flatMap&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;flatMapSingle&lt;/code&gt;, &lt;code&gt;flatMapMaybe&lt;/code&gt;, &lt;code&gt;flatMapCompletable&lt;/code&gt;, &lt;code&gt;flatMapIterable&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;concatMap&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;concatMapSingle&lt;/code&gt;, &lt;code&gt;concatMapMaybe&lt;/code&gt;, &lt;code&gt;concatMapCompletable&lt;/code&gt;, &lt;code&gt;concatMapIterable&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;switchMap&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;switchMapSingle&lt;/code&gt;, &lt;code&gt;switchMapMaybe&lt;/code&gt;, &lt;code&gt;switchMapCompletable&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The reason these operators have a suffix instead of simply having the same name with different signature is type erasure. Java doesn&#39;t consider signatures such as &lt;code&gt;operator(Function&amp;lt;T, Single&amp;lt;R&amp;gt;&amp;gt;)&lt;/code&gt; and &lt;code&gt;operator(Function&amp;lt;T, Maybe&amp;lt;R&amp;gt;&amp;gt;)&lt;/code&gt; different (unlike C#) and due to erasure, the two &lt;code&gt;operator&lt;/code&gt;s would end up as duplicate methods with the same signature.&lt;/p&gt; &#xA;&lt;h3&gt;Operator naming conventions&lt;/h3&gt; &#xA;&lt;p&gt;Naming in programming is one of the hardest things as names are expected to be not long, expressive, capturing and easily memorable. Unfortunately, the target language (and pre-existing conventions) may not give too much help in this regard (unusable keywords, type erasure, type ambiguities, etc.).&lt;/p&gt; &#xA;&lt;h4&gt;Unusable keywords&lt;/h4&gt; &#xA;&lt;p&gt;In the original Rx.NET, the operator that emits a single item and then completes is called &lt;code&gt;Return(T)&lt;/code&gt;. Since the Java convention is to have a lowercase letter start a method name, this would have been &lt;code&gt;return(T)&lt;/code&gt; which is a keyword in Java and thus not available. Therefore, RxJava chose to name this operator &lt;code&gt;just(T)&lt;/code&gt;. The same limitation exists for the operator &lt;code&gt;Switch&lt;/code&gt;, which had to be named &lt;code&gt;switchOnNext&lt;/code&gt;. Yet another example is &lt;code&gt;Catch&lt;/code&gt; which was named &lt;code&gt;onErrorResumeNext&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Type erasure&lt;/h4&gt; &#xA;&lt;p&gt;Many operators that expect the user to provide some function returning a reactive type can&#39;t be overloaded because the type erasure around a &lt;code&gt;Function&amp;lt;T, X&amp;gt;&lt;/code&gt; turns such method signatures into duplicates. RxJava chose to name such operators by appending the type as suffix as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? super T, ? extends Publisher&amp;lt;? extends R&amp;gt;&amp;gt; mapper)&#xA;&#xA;Flowable&amp;lt;R&amp;gt; flatMapMaybe(Function&amp;lt;? super T, ? extends MaybeSource&amp;lt;? extends R&amp;gt;&amp;gt; mapper)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Type ambiguities&lt;/h4&gt; &#xA;&lt;p&gt;Even though certain operators have no problems from type erasure, their signature may turn up being ambiguous, especially if one uses Java 8 and lambdas. For example, there are several overloads of &lt;code&gt;concatWith&lt;/code&gt; taking the various other reactive base types as arguments (for providing convenience and performance benefits in the underlying implementation):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable&amp;lt;T&amp;gt; concatWith(Publisher&amp;lt;? extends T&amp;gt; other);&#xA;&#xA;Flowable&amp;lt;T&amp;gt; concatWith(SingleSource&amp;lt;? extends T&amp;gt; other);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both &lt;code&gt;Publisher&lt;/code&gt; and &lt;code&gt;SingleSource&lt;/code&gt; appear as functional interfaces (types with one abstract method) and may encourage users to try to provide a lambda expression:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;someSource.concatWith(s -&amp;gt; Single.just(2))&#xA;.subscribe(System.out::println, Throwable::printStackTrace);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unfortunately, this approach doesn&#39;t work and the example does not print &lt;code&gt;2&lt;/code&gt; at all. In fact, since version 2.1.10, it doesn&#39;t even compile because at least 4 &lt;code&gt;concatWith&lt;/code&gt; overloads exist and the compiler finds the code above ambiguous.&lt;/p&gt; &#xA;&lt;p&gt;The user in such situations probably wanted to defer some computation until the &lt;code&gt;someSource&lt;/code&gt; has completed, thus the correct unambiguous operator should have been &lt;code&gt;defer&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;someSource.concatWith(Single.defer(() -&amp;gt; Single.just(2)))&#xA;.subscribe(System.out::println, Throwable::printStackTrace);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometimes, a suffix is added to avoid logical ambiguities that may compile but produce the wrong type in a flow:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable&amp;lt;T&amp;gt; merge(Publisher&amp;lt;? extends Publisher&amp;lt;? extends T&amp;gt;&amp;gt; sources);&#xA;&#xA;Flowable&amp;lt;T&amp;gt; mergeArray(Publisher&amp;lt;? extends T&amp;gt;... sources);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can get also ambiguous when functional interface types get involved as the type argument &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Error handling&lt;/h4&gt; &#xA;&lt;p&gt;Dataflows can fail, at which point the error is emitted to the consumer(s). Sometimes though, multiple sources may fail at which point there is a choice whether or not wait for all of them to complete or fail. To indicate this opportunity, many operator names are suffixed with the &lt;code&gt;DelayError&lt;/code&gt; words (while others feature a &lt;code&gt;delayError&lt;/code&gt; or &lt;code&gt;delayErrors&lt;/code&gt; boolean flag in one of their overloads):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable&amp;lt;T&amp;gt; concat(Publisher&amp;lt;? extends Publisher&amp;lt;? extends T&amp;gt;&amp;gt; sources);&#xA;&#xA;Flowable&amp;lt;T&amp;gt; concatDelayError(Publisher&amp;lt;? extends Publisher&amp;lt;? extends T&amp;gt;&amp;gt; sources);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, suffixes of various kinds may appear together:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Flowable&amp;lt;T&amp;gt; concatArrayEagerDelayError(Publisher&amp;lt;? extends T&amp;gt;... sources);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Base class vs base type&lt;/h4&gt; &#xA;&lt;p&gt;The base classes can be considered heavy due to the sheer number of static and instance methods on them. RxJava 3&#39;s design was heavily influenced by the &lt;a href=&#34;https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams&#34;&gt;Reactive Streams&lt;/a&gt; specification, therefore, the library features a class and an interface per each reactive type:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Class&lt;/th&gt; &#xA;   &lt;th&gt;Interface&lt;/th&gt; &#xA;   &lt;th&gt;Consumer&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0..N backpressured&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Flowable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Publisher&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Subscriber&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0..N unbounded&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;ObservableSource&lt;/code&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1 element or error&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Single&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;SingleSource&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;SingleObserver&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0..1 element or error&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;MaybeSource&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;MaybeObserver&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0 element or error&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Completable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CompletableSource&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CompletableObserver&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt;The &lt;code&gt;org.reactivestreams.Publisher&lt;/code&gt; is part of the external Reactive Streams library. It is the main type to interact with other reactive libraries through a standardized mechanism governed by the &lt;a href=&#34;https://github.com/reactive-streams/reactive-streams-jvm#specification&#34;&gt;Reactive Streams specification&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;sup&gt;2&lt;/sup&gt;The naming convention of the interface was to append &lt;code&gt;Source&lt;/code&gt; to the semi-traditional class name. There is no &lt;code&gt;FlowableSource&lt;/code&gt; since &lt;code&gt;Publisher&lt;/code&gt; is provided by the Reactive Streams library (and subtyping it wouldn&#39;t have helped with interoperation either). These interfaces are, however, not standard in the sense of the Reactive Streams specification and are currently RxJava specific only.&lt;/p&gt; &#xA;&lt;h3&gt;R8 and ProGuard settings&lt;/h3&gt; &#xA;&lt;p&gt;By default, RxJava itself doesn&#39;t require any ProGuard/R8 settings and should work without problems. Unfortunately, the Reactive Streams dependency since version 1.0.3 has embedded Java 9 class files in its JAR that can cause warnings with the plain ProGuard:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Warning: org.reactivestreams.FlowAdapters$FlowPublisherFromReactive: can&#39;t find superclass or interface java.util.concurrent.Flow$Publisher&#xA;Warning: org.reactivestreams.FlowAdapters$FlowToReactiveProcessor: can&#39;t find superclass or interface java.util.concurrent.Flow$Processor&#xA;Warning: org.reactivestreams.FlowAdapters$FlowToReactiveSubscriber: can&#39;t find superclass or interface java.util.concurrent.Flow$Subscriber&#xA;Warning: org.reactivestreams.FlowAdapters$FlowToReactiveSubscription: can&#39;t find superclass or interface java.util.concurrent.Flow$Subscription&#xA;Warning: org.reactivestreams.FlowAdapters: can&#39;t find referenced class java.util.concurrent.Flow$Publisher&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is recommended one sets up the following &lt;code&gt;-dontwarn&lt;/code&gt; entry in the application&#39;s &lt;code&gt;proguard-ruleset&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-dontwarn java.util.concurrent.Flow*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For R8, the RxJava jar includes the &lt;code&gt;META-INF/proguard/rxjava3.pro&lt;/code&gt; with the same no-warning clause and should apply automatically.&lt;/p&gt; &#xA;&lt;h3&gt;Further reading&lt;/h3&gt; &#xA;&lt;p&gt;For further details, consult the &lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Communication&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Google Group: &lt;a href=&#34;http://groups.google.com/d/forum/rxjava&#34;&gt;RxJava&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Twitter: &lt;a href=&#34;http://twitter.com/RxJava&#34;&gt;@RxJava&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxJava/issues&#34;&gt;GitHub Issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;StackOverflow: &lt;a href=&#34;http://stackoverflow.com/questions/tagged/rx-java&#34;&gt;rx-java&lt;/a&gt; and &lt;a href=&#34;http://stackoverflow.com/questions/tagged/rx-java2&#34;&gt;rx-java2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gitter.im/ReactiveX/RxJava&#34;&gt;Gitter.im&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Versioning&lt;/h2&gt; &#xA;&lt;p&gt;Version 3.x is in development. Bugfixes will be applied to both 2.x and 3.x branches, but new features will only be added to 3.x.&lt;/p&gt; &#xA;&lt;p&gt;Minor 3.x increments (such as 3.1, 3.2, etc) will occur when non-trivial new functionality is added or significant enhancements or bug fixes occur that may have behavioral changes that may affect some edge cases (such as dependence on behavior resulting from a bug). An example of an enhancement that would classify as this is adding reactive pull backpressure support to an operator that previously did not support it. This should be backwards compatible but does behave differently.&lt;/p&gt; &#xA;&lt;p&gt;Patch 3.x.y increments (such as 3.0.0 -&amp;gt; 3.0.1, 3.3.1 -&amp;gt; 3.3.2, etc) will occur for bug fixes and trivial functionality (like adding a method overload). New functionality marked with an &lt;a href=&#34;https://github.com/ReactiveX/RxJava/raw/3.x/src/main/java/io/reactivex/rxjava3/annotations/Beta.java&#34;&gt;&lt;code&gt;@Beta&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://github.com/ReactiveX/RxJava/raw/3.x/src/main/java/io/reactivex/rxjava3/annotations/Experimental.java&#34;&gt;&lt;code&gt;@Experimental&lt;/code&gt;&lt;/a&gt; annotation can also be added in the patch releases to allow rapid exploration and iteration of unstable new functionality.&lt;/p&gt; &#xA;&lt;h4&gt;@Beta&lt;/h4&gt; &#xA;&lt;p&gt;APIs marked with the &lt;a href=&#34;https://github.com/ReactiveX/RxJava/raw/3.x/src/main/java/io/reactivex/rxjava3/annotations/Beta.java&#34;&gt;&lt;code&gt;@Beta&lt;/code&gt;&lt;/a&gt; annotation at the class or method level are subject to change. They can be modified in any way, or even removed, at any time. If your code is a library itself (i.e. it is used on the CLASSPATH of users outside your control), you should not use beta APIs, unless you repackage them (e.g. using ProGuard, shading, etc).&lt;/p&gt; &#xA;&lt;h4&gt;@Experimental&lt;/h4&gt; &#xA;&lt;p&gt;APIs marked with the &lt;a href=&#34;https://github.com/ReactiveX/RxJava/raw/3.x/src/main/java/io/reactivex/rxjava3/annotations/Experimental.java&#34;&gt;&lt;code&gt;@Experimental&lt;/code&gt;&lt;/a&gt; annotation at the class or method level will almost certainly change. They can be modified in any way, or even removed, at any time. You should not use or rely on them in any production code. They are purely to allow broad testing and feedback.&lt;/p&gt; &#xA;&lt;h4&gt;@Deprecated&lt;/h4&gt; &#xA;&lt;p&gt;APIs marked with the &lt;code&gt;@Deprecated&lt;/code&gt; annotation at the class or method level will remain supported until the next major release, but it is recommended to stop using them.&lt;/p&gt; &#xA;&lt;h4&gt;io.reactivex.rxjava3.internal.*&lt;/h4&gt; &#xA;&lt;p&gt;All code inside the &lt;code&gt;io.reactivex.rxjava3.internal.*&lt;/code&gt; packages are considered private API and should not be relied upon at all. It can change at any time.&lt;/p&gt; &#xA;&lt;h2&gt;Full Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki&#34;&gt;Wiki&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://reactivex.io/RxJava/3.x/javadoc/&#34;&gt;Javadoc&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://reactivex.io/RxJava/3.x/javadoc/snapshot/&#34;&gt;Latest snaphot Javadoc&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Javadoc of a specific &lt;a href=&#34;https://github.com/ReactiveX/RxJava/tags&#34;&gt;release version&lt;/a&gt;: &lt;code&gt;http://reactivex.io/RxJava/3.x/javadoc/3.x.y/&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Binaries&lt;/h2&gt; &#xA;&lt;p&gt;Binaries and dependency information for Maven, Ivy, Gradle and others can be found at &lt;a href=&#34;http://search.maven.org/#search%7Cga%7C1%7Cio.reactivex.rxjava3&#34;&gt;http://search.maven.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Example for Gradle:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;implementation &#39;io.reactivex.rxjava3:rxjava:x.y.z&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and for Maven:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;io.reactivex.rxjava3&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;rxjava&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;x.y.z&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and for Ivy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency org=&#34;io.reactivex.rxjava3&#34; name=&#34;rxjava&#34; rev=&#34;x.y.z&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Snapshots&lt;/h3&gt; &#xA;&lt;p&gt;Snapshots after May 1st, 2021 are available via &lt;a href=&#34;https://oss.sonatype.org/content/repositories/snapshots/io/reactivex/rxjava3/rxjava/&#34;&gt;https://oss.sonatype.org/content/repositories/snapshots/io/reactivex/rxjava3/rxjava/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;repositories {&#xA;  maven { url &#39;https://oss.sonatype.org/content/repositories/snapshots&#39; }&#xA;}&#xA;&#xA;dependencies {&#xA;  implementation &#39;io.reactivex.rxjava3:rxjava:3.0.0-SNAPSHOT&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JavaDoc snapshots are available at &lt;a href=&#34;http://reactivex.io/RxJava/3.x/javadoc/snapshot&#34;&gt;http://reactivex.io/RxJava/3.x/javadoc/snapshot&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;To build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:ReactiveX/RxJava.git&#xA;$ cd RxJava/&#xA;$ ./gradlew build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Further details on building can be found on the &lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki/Getting-Started&#34;&gt;Getting Started&lt;/a&gt; page of the wiki.&lt;/p&gt; &#xA;&lt;h2&gt;Bugs and Feedback&lt;/h2&gt; &#xA;&lt;p&gt;For bugs, questions and discussions please use the &lt;a href=&#34;https://github.com/ReactiveX/RxJava/issues&#34;&gt;Github Issues&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;LICENSE&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright (c) 2016-present, RxJava Contributors.&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;http://www.apache.org/licenses/LICENSE-2.0&#xA;&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>HuanCheng65/TiebaLite</title>
    <updated>2024-02-11T01:47:24Z</updated>
    <id>tag:github.com,2024-02-11:/HuanCheng65/TiebaLite</id>
    <link href="https://github.com/HuanCheng65/TiebaLite" rel="alternate"></link>
    <summary type="html">&lt;p&gt;贴吧 Lite&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;p align=&#34;center&#34;&gt;Tieba Lite&lt;/p&gt;&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://circleci.com/gh/HuanCheng65/TiebaLite&#34;&gt; &lt;img alt=&#34;CircleCI&#34; src=&#34;https://circleci.com/gh/HuanCheng65/TiebaLite.svg?style=svg&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/HuanCheng65/TiebaLite/master/#&#34;&gt; &lt;img alt=&#34;Status&#34; src=&#34;https://img.shields.io/badge/%E7%8A%B6%E6%80%81-%E5%92%95%E5%92%95%E5%92%95-gray?style=flat&amp;amp;labelColor=gray&amp;amp;color=gray&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;贴吧 Lite 是一个&lt;strong&gt;非官方&lt;/strong&gt;的贴吧客户端。&lt;/p&gt; &#xA;&lt;h2&gt;说明&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;本软件及源码仅供学习交流使用，严禁用于商业用途。&lt;/strong&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>HMCL-dev/HMCL</title>
    <updated>2024-02-11T01:47:24Z</updated>
    <id>tag:github.com,2024-02-11:/HMCL-dev/HMCL</id>
    <link href="https://github.com/HMCL-dev/HMCL" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Minecraft Launcher which is multi-functional, cross-platform and popular&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;⛏ Hello Minecraft! Launcher 💎&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ci.huangyuhui.net/job/HMCL&#34;&gt;&lt;img src=&#34;https://ci.huangyuhui.net/job/HMCL/badge/icon?.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/downloads/huanghongxun/HMCL/total&#34; alt=&#34;Downloads&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/stars/huanghongxun/HMCL&#34; alt=&#34;Stars&#34;&gt; &lt;a href=&#34;https://discord.gg/jVvC7HfM6U&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/995291757799538688.svg?label=&amp;amp;logo=discord&amp;amp;logoColor=ffffff&amp;amp;color=7389D8&amp;amp;labelColor=6A7EC2&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://kook.top/Kx7n3t&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/KOOK-HMCL-brightgreen&#34; alt=&#34;KOOK&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/HMCL-dev/HMCL/main/README_cn.md&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;HMCL is a cross-platform Minecraft launcher which supports Mod Management, Game Customizing, Auto Installing (Forge, Fabric, Quilt, LiteLoader and OptiFine), Modpack Creating, UI Customization, and more.&lt;/p&gt; &#xA;&lt;p&gt;HMCL has amazing cross-platform capabilities. It can not only run on different operating systems such as Windows, Linux, and macOS, but also supports multiple CPU architectures such as x86, arm, mips, and loongarch. You can easily play Minecraft on different platforms through HMCL.&lt;/p&gt; &#xA;&lt;p&gt;For systems and CPU architectures supported by HMCL, see &lt;a href=&#34;https://raw.githubusercontent.com/HMCL-dev/HMCL/main/PLATFORM.md&#34;&gt;this table&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;Download the latest version from &lt;a href=&#34;https://hmcl.huangyuhui.net/download&#34;&gt;the official website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also download the latest version of HMCL in &lt;a href=&#34;https://github.com/HMCL-dev/HMCL/releases&#34;&gt;GitHub Releases&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Although not necessary, it is recommended to download the ones from the official website.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The software is distributed under &lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0.html&#34;&gt;GPLv3&lt;/a&gt; with additional terms.&lt;/p&gt; &#xA;&lt;h3&gt;Additional terms under GPLv3 Section 7&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;When you distribute a modified version of the software, you must change the software name or the version number in a reasonable way in order to distinguish it from the original version. (Under &lt;a href=&#34;https://github.com/HMCL-dev/HMCL/raw/11820e31a85d8989e41d97476712b07e7094b190/LICENSE#L372-L374&#34;&gt;GPLv3, 7(c)&lt;/a&gt;)&lt;/p&gt; &lt;p&gt;The software name and the version number can be edited &lt;a href=&#34;https://github.com/HMCL-dev/HMCL/raw/javafx/HMCL/src/main/java/org/jackhuang/hmcl/Metadata.java#L33-L35&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You must not remove the copyright declaration displayed in the software. (Under &lt;a href=&#34;https://github.com/HMCL-dev/HMCL/raw/11820e31a85d8989e41d97476712b07e7094b190/LICENSE#L368-L370&#34;&gt;GPLv3, 7(b)&lt;/a&gt;)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;If you want to submit a pull request, there are some requirements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;IDE: Intellij IDEA&lt;/li&gt; &#xA; &lt;li&gt;Compiler: Java 1.8&lt;/li&gt; &#xA; &lt;li&gt;Do NOT modify &lt;code&gt;gradle&lt;/code&gt; files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Compilation&lt;/h3&gt; &#xA;&lt;p&gt;Simply execute the following command in project root directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./gradlew clean build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure you have Java installed with JavaFX 8 at least. Liberica Full JDK 8 or later is recommended.&lt;/p&gt; &#xA;&lt;h2&gt;JVM Options (for debugging)&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Parameter&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.home=&amp;lt;path&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Override HMCL directory.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.self_integrity_check.disable=true&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Bypass the self integrity check when checking for update.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.bmclapi.override=&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Override API Root of BMCLAPI download provider, defaults to &lt;code&gt;https://bmclapi2.bangbang93.com&lt;/code&gt;. e.g. &lt;code&gt;https://download.mcbbs.net&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.font.override=&amp;lt;font family&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Override font family.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.version.override=&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Override the version number.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.update_source.override=&amp;lt;url&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Override the update source for HMCL itself.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.authlibinjector.location=&amp;lt;path&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use specified authlib-injector (instead of downloading one).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.openjfx.repo=&amp;lt;maven repository url&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Add custom Maven repository for download OpenJFX.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.native.encoding=&amp;lt;encoding&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Override the native encoding.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.microsoft.auth.id=&amp;lt;App ID&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Override Microsoft OAuth App ID.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;-Dhmcl.microsoft.auth.secret=&amp;lt;App Secret&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Override Microsoft OAuth App secret.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>