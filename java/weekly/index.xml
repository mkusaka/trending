<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-04T01:52:33Z</updated>
  <subtitle>Weekly Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Eanya-Tonic/CCTV_Viewer</title>
    <updated>2024-02-04T01:52:33Z</updated>
    <id>tag:github.com,2024-02-04:/Eanya-Tonic/CCTV_Viewer</id>
    <link href="https://github.com/Eanya-Tonic/CCTV_Viewer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;电视浏览器，一款基于tv.cctv.com和央视频的简易电视直播收看软件，用于方便的在机顶盒上收看电视节目&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/Eanya-Tonic/CCTV_Viewer/raw/master/app/src/main/res/drawable/icon.png&#34; style=&#34;width:200px;&#34;&gt; &lt;/p&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt;电视浏览器&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt;一个电视机顶盒及Android TV收看电视直播的浏览器 &lt;/p&gt; &#xA;&lt;h2&gt;下载安装包&lt;/h2&gt; &#xA;&lt;p&gt;从Github Release下载：&lt;a href=&#34;https://github.com/Eanya-Tonic/CCTV_Viewer/releases/latest&#34;&gt;https://github.com/Eanya-Tonic/CCTV_Viewer/releases/latest&lt;/a&gt; &lt;br&gt; 从百度网盘下载：&lt;a href=&#34;https://pan.baidu.com/s/1e5wMCorJIp9oi5yN8mJ1KA?pwd=qozp&#34;&gt;https://pan.baidu.com/s/1e5wMCorJIp9oi5yN8mJ1KA?pwd=qozp&lt;/a&gt; 提取码：qozp&lt;/p&gt; &#xA;&lt;h2&gt;演示视频&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;B站：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Gc41187D6&#34;&gt;央视浏览器v1.2更新——支持遥控器的电视直播观看软件&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Cg4y1r7Hv&#34;&gt;央视浏览器——一款支持遥控器的便捷电视直播观看软件&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;使用方法&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;电视盒子：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Eanya-Tonic/CCTV_Viewer/assets/74545593/13e1c752-15e0-40bc-9a58-4138bc93dd8f#pic_center&#34; alt=&#34;Screenshot_20240127-213312&#34;&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;p&gt;频道切换列表界面&lt;/p&gt;&#xA;&lt;/div&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Eanya-Tonic/CCTV_Viewer/assets/74545593/4624aa07-503d-4cbf-b274-2efa5516d63c#pic_center&#34; alt=&#34;Screenshot_20240127-213326&#34;&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;p&gt;菜单键功能菜单&lt;/p&gt;&#xA;&lt;/div&gt; &#xA;&lt;p&gt;使用上下键切换频道，使用确认键显示当前频道和节目信息、并打开频道切换列表，单击菜单键打开功能菜单，输入数字键换到指定台，双击返回键退出程序。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;其他设备：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;使用键盘方向键上下控制切换频道，使用Enter键显示当前频道和节目信息、并打开频道切换列表，单击键盘M键打开功能菜单，输入数字键换到指定台。&lt;/p&gt; &#xA;&lt;h2&gt;目前可看频道&lt;/h2&gt; &#xA;&lt;p&gt;1 CCTV-1 综合&lt;/p&gt; &#xA;&lt;p&gt;2 CCTV-2 财经&lt;/p&gt; &#xA;&lt;p&gt;3 CCTV-3 综艺&lt;/p&gt; &#xA;&lt;p&gt;4 CCTV-4 中文国际&lt;/p&gt; &#xA;&lt;p&gt;5 CCTV-5 体育&lt;/p&gt; &#xA;&lt;p&gt;6 CCTV-6 电影&lt;/p&gt; &#xA;&lt;p&gt;7 CCTV-7 军事农业&lt;/p&gt; &#xA;&lt;p&gt;8 CCTV-8 电视剧&lt;/p&gt; &#xA;&lt;p&gt;9 CCTV-9 纪录&lt;/p&gt; &#xA;&lt;p&gt;10 CCTV-10 科教&lt;/p&gt; &#xA;&lt;p&gt;11 CCTV-11 戏曲&lt;/p&gt; &#xA;&lt;p&gt;12 CCTV-12 社会与法&lt;/p&gt; &#xA;&lt;p&gt;13 CCTV-13 新闻&lt;/p&gt; &#xA;&lt;p&gt;14 CCTV-14 少儿&lt;/p&gt; &#xA;&lt;p&gt;15 CCTV-15 音乐&lt;/p&gt; &#xA;&lt;p&gt;16 CCTV-16 奥林匹克&lt;/p&gt; &#xA;&lt;p&gt;17 CCTV-17 农业农村&lt;/p&gt; &#xA;&lt;p&gt;18 CCTV-5+ 体育赛事&lt;/p&gt; &#xA;&lt;p&gt;19 CCTV Europe&lt;/p&gt; &#xA;&lt;p&gt;20 CCTV America&lt;/p&gt; &#xA;&lt;p&gt;21 北京卫视&lt;/p&gt; &#xA;&lt;p&gt;22 江苏卫视&lt;/p&gt; &#xA;&lt;p&gt;23 东方卫视&lt;/p&gt; &#xA;&lt;p&gt;24 浙江卫视&lt;/p&gt; &#xA;&lt;p&gt;25 湖南卫视&lt;/p&gt; &#xA;&lt;p&gt;26 湖北卫视&lt;/p&gt; &#xA;&lt;p&gt;27 广东卫视&lt;/p&gt; &#xA;&lt;p&gt;28 广西卫视&lt;/p&gt; &#xA;&lt;p&gt;29 黑龙江卫视&lt;/p&gt; &#xA;&lt;p&gt;30 海南卫视&lt;/p&gt; &#xA;&lt;p&gt;31 重庆卫视&lt;/p&gt; &#xA;&lt;p&gt;32 深圳卫视&lt;/p&gt; &#xA;&lt;p&gt;33 四川卫视&lt;/p&gt; &#xA;&lt;p&gt;34 河南卫视&lt;/p&gt; &#xA;&lt;p&gt;35 福建东南卫视&lt;/p&gt; &#xA;&lt;p&gt;36 贵州卫视&lt;/p&gt; &#xA;&lt;p&gt;37 江西卫视&lt;/p&gt; &#xA;&lt;p&gt;38 辽宁卫视&lt;/p&gt; &#xA;&lt;p&gt;39 安徽卫视&lt;/p&gt; &#xA;&lt;p&gt;40 河北卫视&lt;/p&gt; &#xA;&lt;p&gt;41 山东卫视&lt;/p&gt; &#xA;&lt;h2&gt;更新日志&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;v1.5 更新日志（2024.01.27）&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;1.更新菜单键事件逻辑，加入一个底部菜单，并取消原本复杂的双击、单击等机制，使程序更加易用。&lt;/p&gt; &#xA;&lt;p&gt;2.修改换台菜单逻辑，将原本的弹出界面调整为二级抽屉式菜单，同时改为按确认键触发，更加符合用户的使用习惯；在打开换台界面时，自动切换到目前正在播放的频道。&lt;/p&gt; &#xA;&lt;p&gt;3.增加一个提示，在换台时会提示目前调用的是系统Webview内核还是腾讯X5内核。&lt;/p&gt; &#xA;&lt;p&gt;4.修复偶发性的卫视频道播放静音问题。&lt;/p&gt; &#xA;&lt;p&gt;5.额外更新一个调用系统WebView的版本&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;v1.4 更新日志（2024.01.21）&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;1.增加央视频的北京卫视、江苏卫视等21个地方卫视频道。&lt;/p&gt; &#xA;&lt;p&gt;2.尝试修复视频播放暂停的问题，暂时恢复确认键的暂停功能，但是暂停后会自动重新开始播放，仅用于增强兼容性。&lt;/p&gt; &#xA;&lt;p&gt;3.增加双击确认键可以调整全屏/退出全屏的功能。&lt;/p&gt; &#xA;&lt;p&gt;4.遥控器左右键可以缩放网页，增强应用兼容性。&lt;/p&gt; &#xA;&lt;p&gt;5.修改图标、应用名称、增加leanback设置，在原生Android TV启动器上也可以正常显示图标。&lt;/p&gt; &#xA;&lt;p&gt;6.增加频道选择界面的台号显示，方便数字键换台使用。&lt;/p&gt; &#xA;&lt;p&gt;7.最低安装限制调整为安卓4.4，API 19。&lt;/p&gt; &#xA;&lt;p&gt;8.本次更新中，出现了偶发性的卫视频道缩放不正常问题，经测试退出应用再重新打开后可以解决；由于较难复现，我目前不知道问题产生的原因。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;v1.3 更新日志（2024.01.20）&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;1.调用本地x5内核，将x5内核集成到安装包中，提高x5内核调用的成功率。&lt;/p&gt; &#xA;&lt;p&gt;2.自动播放视频，并且禁用确认键暂停功能。&lt;/p&gt; &#xA;&lt;p&gt;3.修复清晰度选择导致的无法全屏和播放的问题，解决CCTV-6、CCTV-3两个频道由于没有超清清晰度无法选择导致不能全屏和正常播放的问题。&lt;/p&gt; &#xA;&lt;p&gt;4.增加频道选择菜单，按菜单键激活后可直接选择需要切换的频道。&lt;/p&gt; &#xA;&lt;p&gt;5.修改操作逻辑，按确定键显示当前频道信息、单击菜单键显示频道列表、双击菜单键刷新当前网页。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;v1.2 更新日志（2024.01.05）&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;1.在换台时显示一个“正在切换频道”覆盖层，优化使用体验&lt;/p&gt; &#xA;&lt;p&gt;2.增加换台后当前频道和当前频道节目预告提示&lt;/p&gt; &#xA;&lt;p&gt;3.修改按键逻辑，单击菜单键改为显示当前频道和节目信息，长按菜单键改为刷新当前页面&lt;/p&gt; &#xA;&lt;p&gt;4.改为使用腾讯x5内核，提高程序兼容性&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;下载并安装本软件，即代表您已阅读并同意&lt;a href=&#34;https://rule.tencent.com/rule/preview/1c4e2b4b-d0f6-4a75-a5c6-1cfce00a390d&#34;&gt;腾讯浏览服务X5网页引擎隐私保护规则&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;v1.1 更新日志（2024.01.04）&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;1.优化返回退出逻辑，需要按两次返回键才会退出，避免误触&lt;/p&gt; &#xA;&lt;p&gt;2.增加数字键换台功能，用户可以通过遥控器上的数字键直接输入台号换台。备注：18号 CCTV-5+ 体育赛事、19号 CCTV-4 中文国际（欧）、20号 CCTV-4 中文国际（美）&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>maxiaof/github-hosts</title>
    <updated>2024-02-04T01:52:33Z</updated>
    <id>tag:github.com,2024-02-04:/maxiaof/github-hosts</id>
    <link href="https://github.com/maxiaof/github-hosts" rel="alternate"></link>
    <summary type="html">&lt;p&gt;通过修改Hosts解决国内Github经常抽风访问不到,每日更新&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GitHub-Hosts&lt;/h1&gt; &#xA;&lt;h2&gt;一、介绍&lt;/h2&gt; &#xA;&lt;p&gt;通过修改Hosts解决国内Github经常抽风访问不到&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;二、使用方法&lt;/h2&gt; &#xA;&lt;h3&gt;2.1 复制下面的内容&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#Github Hosts Start&#xA;#Update Time: 2024-02-04&#xA;#Project Address: https://github.com/maxiaof/github-hosts&#xA;#Update URL: https://raw.githubusercontent.com/maxiaof/github-hosts/master/hosts&#xA;140.82.112.26 alive.github.com&#xA;140.82.113.26 live.github.com&#xA;185.199.111.154 github.githubassets.com&#xA;140.82.112.21 central.github.com&#xA;185.199.111.133 desktop.githubusercontent.com&#xA;185.199.108.153 assets-cdn.github.com&#xA;185.199.109.133 camo.githubusercontent.com&#xA;185.199.109.133 github.map.fastly.net&#xA;146.75.121.194 github.global.ssl.fastly.net&#xA;140.82.121.4 gist.github.com&#xA;185.199.111.153 github.io&#xA;140.82.121.3 github.com&#xA;192.0.66.2 github.blog&#xA;140.82.121.6 api.github.com&#xA;185.199.109.133 raw.githubusercontent.com&#xA;185.199.110.133 user-images.githubusercontent.com&#xA;185.199.110.133 favicons.githubusercontent.com&#xA;185.199.110.133 avatars5.githubusercontent.com&#xA;185.199.109.133 avatars4.githubusercontent.com&#xA;185.199.111.133 avatars3.githubusercontent.com&#xA;185.199.109.133 avatars2.githubusercontent.com&#xA;185.199.110.133 avatars1.githubusercontent.com&#xA;185.199.108.133 avatars0.githubusercontent.com&#xA;185.199.110.133 avatars.githubusercontent.com&#xA;140.82.121.9 codeload.github.com&#xA;52.216.240.100 github-cloud.s3.amazonaws.com&#xA;3.5.29.135 github-com.s3.amazonaws.com&#xA;52.216.42.233 github-production-release-asset-2e65be.s3.amazonaws.com&#xA;3.5.21.195 github-production-user-asset-6210df.s3.amazonaws.com&#xA;52.217.227.233 github-production-repository-file-5c1aeb.s3.amazonaws.com&#xA;185.199.111.153 githubstatus.com&#xA;140.82.113.17 github.community&#xA;51.137.3.17 github.dev&#xA;140.82.112.21 collector.github.com&#xA;13.107.42.16 pipelines.actions.githubusercontent.com&#xA;185.199.111.133 media.githubusercontent.com&#xA;185.199.109.133 cloud.githubusercontent.com&#xA;185.199.108.133 objects.githubusercontent.com&#xA;#Github Hosts End&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;最后更新时间：&lt;code&gt;2024-02-04&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;2.2 修改 hosts 文件&lt;/h2&gt; &#xA;&lt;p&gt;hosts 文件在不同系统位置不一，详情如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows 系统：&lt;code&gt;C:\Windows\System32\drivers\etc\hosts&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;Mac（苹果电脑）系统：&lt;code&gt;/etc/hosts&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;Linux 系统：&lt;code&gt;/etc/hosts&lt;/code&gt;。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;修改方法，把2.1的内容复制到文本末尾：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Windows 使用记事本。&lt;/li&gt; &#xA; &lt;li&gt;Linux、Mac 使用 Root 权限：&lt;code&gt;sudo vi /etc/hosts&lt;/code&gt;。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;2.3 激活生效&lt;/h4&gt; &#xA;&lt;p&gt;大部分情况下是直接生效，如未生效可尝试下面的办法，刷新 DNS：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Windows：在 CMD 窗口输入：&lt;code&gt;ipconfig /flushdns&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Mac 命令：&lt;code&gt;sudo killall -HUP mDNSResponder&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Linux 命令：&lt;code&gt;sudo nscd restart&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt; 如以上刷新不好使，请重启尝试&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>GaoSSR/OnePRO</title>
    <updated>2024-02-04T01:52:33Z</updated>
    <id>tag:github.com,2024-02-04:/GaoSSR/OnePRO</id>
    <link href="https://github.com/GaoSSR/OnePRO" rel="alternate"></link>
    <summary type="html">&lt;p&gt;轻量级算法驱动优惠叠加器&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img width=&#34;365&#34; src=&#34;https://raw.githubusercontent.com/GaoSSR/OnePRO/main/READMEIMG/Project-Name.png&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;javascript:;&#34;&gt;&lt;img src=&#34;https://img.shields.io/appveyor/build/gruntjs/grunt?label=%E6%9E%84%E5%BB%BA&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;javascript:;&#34;&gt;&lt;img src=&#34;https://img.shields.io/appveyor/build/gruntjs/grunt?label=%E6%B5%8B%E8%AF%95&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;javascript:;&#34;&gt;&lt;img src=&#34;https://img.shields.io/appveyor/build/gruntjs/grunt?label=%E6%96%87%E6%A1%A3&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;javascript:;&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE-Apache-brightgreen&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;轻量级算法驱动优惠叠加器&lt;/h2&gt; &#xA;&lt;h4&gt;RT：&lt;/h4&gt; &#xA;&lt;img width=&#34;1000&#34; src=&#34;https://raw.githubusercontent.com/GaoSSR/OnePRO/main/READMEIMG/211690962797_.pic.jpg&#34;&gt; &#xA;&lt;h4&gt;背景：&lt;/h4&gt; &#xA;&lt;p&gt;优惠是推动消费者转化的关键因素，它在激发用户消费行为上起着核心作用。目前市场上的优惠策略主要涵盖了各种活动（例如拼多多的“砍一刀”，天猫农场的互动，新用户的首次购买，复购，积分等）和优惠券（如折扣券，代金券，商品券，买一赠一等）。然而，这些复杂的优惠规则使得用户在计算优惠叠加的顺序时感到困扰。这可能导致用户在面对多重优惠时降低购买商品的欲望，尤其是当他们参与了多个活动并持有多个优惠券时，这种情况更为明显。&lt;/p&gt; &#xA;&lt;p&gt;优惠的计算顺序可以分为平行式和渐进式，其中平行式优惠之间没有相互依赖关系，而渐进式优惠之间则存在依赖关系，即下一个优惠的触发取决于上一个优惠的实施结果。&lt;/p&gt; &#xA;&lt;p&gt;设想小晴消费了100元，她手头有一张7折优惠券和一张满100元减30元的优惠券。这两个优惠券的使用顺序可能会产生不同的效果，则这2个优惠券的使用顺序有以下两种情况：&lt;/p&gt; &#xA;&lt;img src=&#34;./READMEIMG/image（1）.png&#34; width=&#34;75%&#34;&gt; &#xA;&lt;p&gt;&lt;code&gt;OnePRO&lt;/code&gt;采用了一系列新颖的算法，实现了高效求解优惠排列的最优解。&lt;/p&gt; &#xA;&lt;img src=&#34;./READMEIMG/image（2）.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;h4&gt;核心计算类 Permutation&amp;lt;T extends GoodsItem&amp;gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Permutation&lt;/code&gt;是一个重要的抽象类，作为&lt;code&gt;OnePRO&lt;/code&gt;的核心，它采用了多种优化策略来确保高性能，这些策略的运用旨在提升计算效率和降低资源消耗，这些策略包括：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;预存的排列数结果集&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;之所以采用这种设计，是因为在业务场景中，我们需要频繁进行排列计算。对于给定长度的序列，其排列结果是固定的。在&lt;code&gt;Permutation&lt;/code&gt;类中，&lt;code&gt;PERMUTATIONS&lt;/code&gt;属性存储了7以内的排列数结果集。由于这里使用了&lt;code&gt;Byte&lt;/code&gt;来存储数据，因此占用的内存空间非常小，这有助于提高性能并降低内存消耗。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;private final static Map&amp;lt;Integer,Collection&amp;lt;List&amp;lt;Byte&amp;gt;&amp;gt;&amp;gt; PERMUTATIONS = Maps.newHashMap();&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;这个动作在类加载完成时执行，如果觉得7不合适，对7不满意，可以通过调整&lt;code&gt;SUPPORTEDSIZE&lt;/code&gt;的大小来满足业务和性能的需求。&lt;/p&gt; &#xA;&lt;p&gt;我们在实现中经过测试和调整，确定了7是一个相对平衡的参数，它兼顾了业务与性能，当然，根据实际需求，大家可以根据自己的情况来调整这个参数。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public final static int SUPPORTEDSIZE = 7;&#xA;&#xA;static{&#xA;      //前置计算 1-SUPPORTEDSIZE 之间所有排列组合&#xA;    for(byte i=1;i&amp;lt;=SUPPORTEDSIZE;i++){&#xA;       PERMUTATIONS.put((int)i,Collections2.permutations(IntStream.range(0,i).boxed().map(x-&amp;gt;(byte)x.intValue()).collect(Collectors.toList())));&#xA;      }&#xA;  }&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;A**n&lt;/em&gt;3 级别缓存&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;相对于传统的&lt;code&gt;Key-Value&lt;/code&gt;结构，解决&lt;em&gt;A&lt;strong&gt;n&lt;/strong&gt;n&lt;/em&gt;问题的缓存需要进行特殊设计，对于一个优惠集合而言，&lt;em&gt;A**n&lt;/em&gt;3意味着需要缓存&lt;em&gt;n&lt;/em&gt;×(&lt;em&gt;n&lt;/em&gt;−1)×(&lt;em&gt;n&lt;/em&gt;−2)条数据。当&lt;em&gt;n&lt;/em&gt;=7时，需要缓存210条数据。为了在内存大小和缓存带来的性能收益之间取得平衡，&lt;em&gt;A**n&lt;/em&gt;3是最合适的级别。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Permutation&lt;/code&gt;类通过其成员变量&lt;code&gt;cache&lt;/code&gt;实现了高性能缓存。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;private final Map&amp;lt;Integer, CalcState&amp;lt;T&amp;gt;&amp;gt; cache = Maps.newHashMap();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;你或许已经注意到，&lt;code&gt;cache&lt;/code&gt;的键值使用的是&lt;code&gt;Integer&lt;/code&gt;类型。在大多数情况下，我们更倾向于使用&lt;code&gt;String&lt;/code&gt;类型，但在需要进行大量计算的场景中，比如在万次计算的场景下，String字符串的拼接却成了性能瓶颈。&lt;/p&gt; &#xA;&lt;p&gt;为了实现高性能的键生成，&lt;code&gt;Permutation&lt;/code&gt;采用了独特的方法。它通过位移对&lt;code&gt;Byte&lt;/code&gt;数组的前三个字节进行扰动，以确保每个键的唯一性，同时提升性能。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;private static Integer calcKey(List&amp;lt;Byte&amp;gt; a){&#xA;       return  a.size()&amp;gt;=3?(a.get(0) &amp;lt;&amp;lt; 6)+ (a.get(1) &amp;lt;&amp;lt; 3) + a.get(2):0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Permutation&lt;/code&gt;提供了保存点来实现 $A_n^3$ 级别缓存，&lt;code&gt;CalcState&lt;/code&gt; 记录了计算到第3步的状态，包括当前订单优惠金额和计算过程、已享用优惠的商品等，这些属性的保存和回放&lt;code&gt;Permutation&lt;/code&gt;已经帮你做好了，&lt;code&gt;Permutation&lt;/code&gt;额外提供了抽象的保存和回放方法来满足你的个性化诉求。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;   /**&#xA;     * 业务将状态记录到保存点&#xA;     * @param state 保存点对象&#xA;     */&#xA;    protected abstract void makeSnapshot(CalcState&amp;lt;T&amp;gt; state,DiscountContext&amp;lt;T&amp;gt; context);&#xA;&#xA;    /**&#xA;     * 业务返回保存点状态&#xA;     * @param state 保存点对象&#xA;     */&#xA;    protected abstract void backToSnapshot(CalcState&amp;lt;T&amp;gt; state,DiscountContext&amp;lt;T&amp;gt; context);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;在优惠计算中，存在一个优先级规则，即优惠计算是有优先级的，需要确保属性&lt;code&gt;calculateGroup&lt;/code&gt;值较小的优惠先行计算。当发生&lt;code&gt;backToSnapshot&lt;/code&gt;时，我们需要额外检查缓存中最后一个优惠与当前正准备要计算的优惠之间的关系，如果不满足特定条件，则直接终止计算，直接跳出。而&lt;code&gt;checkIfWakeUpJump&lt;/code&gt;方法会在缓存被使用后立即判断是否需要继续下去。&lt;/p&gt; &#xA;&lt;h4&gt;上下文类 DiscountContext&amp;lt;T extends GoodsItem&amp;gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;DiscountContext&lt;/code&gt;是上下文，也是&lt;code&gt;Permutation&lt;/code&gt;的成员变量，&lt;code&gt;DiscountContext&lt;/code&gt;同样包含很多优化策略：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CalcStage数组&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;在变更最频繁也是最重要的计算步骤对象&lt;code&gt;CalcStage&lt;/code&gt;使用数组存储，该数组随着上下文创建而创建，在&lt;code&gt;Permutation&lt;/code&gt;中使用&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;Arrays.fill(arr,null);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;将该数组清空并让它投入下一次计算，这样一次全排列过程中，数组只会被创建一次，避免了频繁创建数组带来的性能损耗。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;预计算&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;DiscountContext&lt;/code&gt;的初始化是通过静态的&lt;code&gt;create&lt;/code&gt;方法完成的，该方法将商品与优惠绑定在一起，同时执行一些用户自定义的逻辑，我们称之为“预计算”，预计算的结果被保存在&lt;code&gt;DiscountContext&lt;/code&gt;的&lt;code&gt;preCompute&lt;/code&gt;属性中，以便在后续的计算中直接取用，这种方法避免了在后续的高速迭代中重复执行相同的操作，如商品分组和、求和等，从而提高了计算效率。&lt;/p&gt; &#xA;&lt;h4&gt;预计算 PreCompute&amp;lt;T extends GoodsItem&amp;gt;&lt;/h4&gt; &#xA;&lt;p&gt;预计算提供了接口，要使用预计算首先需要实现PreCompute接口&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public interface PreCompute&amp;lt;T extends GoodsItem&amp;gt; {&#xA;    /**&#xA;     * 判断符合条件的活动类型，符合才会执行preComputeItems&#xA;     */&#xA;    Set&amp;lt;String&amp;gt; matchTypes();&#xA;&#xA;    /**&#xA;     * 对商品做一些复杂集合操作&#xA;     * @param items 当前参与优惠的商品&#xA;     * @param discount 当前优惠&#xA;     * @param preCompute 存储计算的结果&#xA;     */&#xA;     void preComputeItems(List&amp;lt;T&amp;gt; items, DiscountWrapper discount, Map&amp;lt;String,Object&amp;gt; preCompute);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;此外需要在资源目录下建立&lt;code&gt;calculator-core.properties&lt;/code&gt;文件，配置内容如下&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;precompute.path=你要扫描的包&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;PreComputeHolder&lt;/code&gt;将处理所有的&lt;code&gt;PreCompute&lt;/code&gt;实现类，只有&lt;code&gt;matchTypes&lt;/code&gt;匹配的情况下，才会执行&lt;code&gt;preComputeItems&lt;/code&gt;方法。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class PreComputeHolder {&#xA;    public static Set&amp;lt;PreCompute&amp;gt; COMPUTES= Sets.newHashSet();&#xA;    private final static String PATH = &#34;precompute.path&#34;;&#xA;&#xA;    static{&#xA;        Properties properties = new Properties();&#xA;        try {&#xA;              properties = PropertiesLoaderUtils.loadProperties(new FileSystemResource(Objects.requireNonNull(PreComputeHolder.class.getClassLoader().getResource(&#34;calculator-core.properties&#34;)).getPath()));&#xA;        } catch (Exception ignore) {&#xA;        }&#xA;        String path = properties.getProperty(PATH);&#xA;        if(StringUtils.isNotBlank(path)){&#xA;            Reflections reflections = new Reflections(path);&#xA;            Set&amp;lt;Class&amp;lt;? extends PreCompute&amp;gt;&amp;gt; subTypes = reflections.getSubTypesOf(PreCompute.class);&#xA;            for(Class&amp;lt;? extends PreCompute&amp;gt; clazz:subTypes){&#xA;                try {&#xA;                    COMPUTES.add(clazz.newInstance());&#xA;                } catch (Exception ignore) {&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;计算器 Calculator&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Calculator&lt;/code&gt;是单个优惠的计算接口（即用于优惠计算的接口），它其中定义了一个&lt;code&gt;calcWarp&lt;/code&gt;方法，负责具体的优惠计算逻辑，但由于&lt;code&gt;calcWarp&lt;/code&gt;需要承担一些内部的事情，需要处理一些内部细节，因此为了简化使用者的开发工作，我们提供了一个抽象类&lt;code&gt;AbstractCalculator&lt;/code&gt;，它实现了&lt;code&gt;calcWarp&lt;/code&gt;方法，并最终暴露了一个更简单更直观的&lt;code&gt;calc&lt;/code&gt;方法供使用者使用。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;AbstractCalculator&lt;/code&gt;的内容如下，在&lt;code&gt;AbstractCalculator&lt;/code&gt;中，&lt;code&gt;calcWarp&lt;/code&gt;方法负责创建&lt;code&gt;CalcStage&lt;/code&gt;对象，维护&lt;code&gt;CalcStage&lt;/code&gt;数组等内部工作，这些细节对于使用者来说是透明的，他们只需要关注并实现&lt;code&gt;calc&lt;/code&gt;方法即可。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public abstract class AbstractCalculator&amp;lt;T extends GoodsItem&amp;gt; implements Calculator&amp;lt;T&amp;gt; {&#xA;    public long calcWarp(DiscountContext&amp;lt;T&amp;gt; context, DiscountWrapper discountWrapper, Map&amp;lt;Long, T&amp;gt; records, byte idx, int i) {&#xA;        CalcStage stage = new CalcStage();&#xA;        CalcResult cr = context.getCalcResult();&#xA;        long price= cr.getCurPrice();&#xA;        stage.setBeforeCalcPrice(price);&#xA;        price = calc(context, discountWrapper,records, price, stage);&#xA;        if(price&amp;lt;0){&#xA;            return price;&#xA;        }&#xA;        stage.setAfterCalcPrice(price);&#xA;        stage.setIndex(idx);&#xA;        stage.setStageType(discountWrapper.getType());&#xA;        cr.setCurPrice(price);&#xA;        if(stage.getBeforeCalcPrice()&amp;gt;stage.getAfterCalcPrice()) {&#xA;            cr.getCurStages()[i] = stage;&#xA;        }&#xA;        return price;&#xA;    }&#xA;&#xA;    /**&#xA;     * 返回该优惠下的最终要支付的金额,若不符合则返回 prevStagePrice&#xA;     * @param context 上下文&#xA;     * @param discountWrapper 优惠信息&#xA;     * @param records 记录享受过优惠的单品，key是calculateId，这里只提供容器，添加和判断规则由使用者自行决定&#xA;     * @param prevStagePrice 上一步计算的订单的价格&#xA;     * @param curStage 当前stage&#xA;     * @return&#xA;     */&#xA;    public abstract  long calc(DiscountContext&amp;lt;T&amp;gt; context, DiscountWrapper discountWrapper, Map&amp;lt;Long,T&amp;gt; records, long prevStagePrice, CalcStage curStage);&#xA;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;最终用户通过继承&lt;code&gt;AbstractCalculator&lt;/code&gt;类，并在&lt;code&gt;Component&lt;/code&gt;注解中指定一个值，而&lt;code&gt;CalculatorRouter&lt;/code&gt;则通过这个值将请求路由到相应的优惠计算器，这个值与&lt;code&gt;DiscountWrapper&lt;/code&gt;中的&lt;code&gt;type&lt;/code&gt;属性相对应。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;@Component(&#34;manjian&#34;)&#xA;public class ManjianCalc extends AbstractCalculator&amp;lt;GoodsItem&amp;gt; {&#xA;......&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;共享互斥协议 DiscountGroup&lt;/h4&gt; &#xA;&lt;p&gt;共享互斥协议是一个数据结构，它是一个数组，数组中最多可以包含两个对象，最少包含一个对象。如果数组中只有一个对象，那么该对象必然为共享组，即组内的优惠可以叠加使用。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;[&#xA;    {&#xA;        &#34;relation&#34;: &#34;share&#34;,&#xA;        &#34;items&#34;:&#xA;        [&#xA;            {&#xA;                &#34;type&#34;: &#34;activity0&#34;,&#xA;                &#34;id&#34;: &#34;11&#34;&#xA;            }&#xA;            ,&#xA;            {&#xA;                &#34;type&#34;: &#34;activity4&#34;,&#xA;                &#34;id&#34;: &#34;13&#34;&#xA;            } &#xA;            ,&#xA;            {&#xA;                &#34;type&#34;: &#34;coupon1&#34;,&#xA;                 &#34;id&#34;: &#34;14&#34;&#xA;            }&#xA;        ]&#xA;    }]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;相应的，当数组中包含两个对象时，第一个对象的&lt;code&gt;relation&lt;/code&gt;属性可以为&lt;code&gt;share&lt;/code&gt;或&lt;code&gt;exclude&lt;/code&gt;，而第二个对象的&lt;code&gt;relation&lt;/code&gt;属性必须为&lt;code&gt;exclude&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;[&#xA;    {&#xA;        &#34;relation&#34;: &#34;share&#34;,&#xA;        &#34;items&#34;:&#xA;        [&#xA;            {&#xA;                &#34;type&#34;: &#34;activity0&#34;,&#xA;                &#34;id&#34;: &#34;11&#34;&#xA;            },&#xA;            {&#xA;                &#34;type&#34;: &#34;card3&#34;,&#xA;                &#34;id&#34;:&#34;12&#34;&#xA;            }&#xA;        ]&#xA;    },&#xA;    {&#xA;        &#34;relation&#34;: &#34;exclude&#34;,&#xA;        &#34;items&#34;:&#xA;        [&#xA;            {&#xA;                &#34;type&#34;: &#34;card1&#34;,&#xA;                &#34;id&#34;: &#34;18&#34;&#xA;            },&#xA;            {&#xA;                &#34;type&#34;: &#34;coupon1&#34;,&#xA;                &#34;id&#34;: &#34;22&#34;&#xA;            }&#xA;        ]&#xA;    }&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;最终，上述协议将转化为如下两个共享组：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;activity0-card3-card1&lt;/code&gt; 和 &lt;code&gt;activity0-card3-coupon1&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;工具类 &lt;code&gt;DiscountGroupUtil&lt;/code&gt; 提供了一个方法，用于将协议转换为共享组。由于共享组可能包含大量优惠，为了提高过滤性能，我们将当前可用的优惠转换为二级&lt;code&gt;Map&lt;/code&gt;。这个&lt;code&gt;Map&lt;/code&gt;的外层键是协议中的&lt;code&gt;type&lt;/code&gt;，而第二层键是协议中的&lt;code&gt;id&lt;/code&gt;。通过这种方式，我们可以快速地进行交叉过滤，从而提升性能。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public static List&amp;lt;Pair&amp;lt;Set&amp;lt;DiscountWrapper&amp;gt;,Set&amp;lt;DiscountWrapper&amp;gt;&amp;gt;&amp;gt; transform(List&amp;lt;List&amp;lt;DiscountGroup&amp;gt;&amp;gt; groups, Map&amp;lt;String, Map&amp;lt;String,DiscountWrapper&amp;gt;&amp;gt; inMap);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;为了确保计算性能，我们将用户在当前订单中可享受的优惠分为两个集合。左侧集合的大小限制为&lt;code&gt;SUPPORTEDSIZE&lt;/code&gt;，即我们重点保障的、在计算能力范围内的优惠。而右侧集合则尽可能地进行叠加。&lt;/p&gt; &#xA;&lt;p&gt;从稳定性角度考虑，我们需要对计算次数进行统计。在压力测试中，我们通过&lt;code&gt;LimitingUtil.count&lt;/code&gt;方法来统计进入&lt;code&gt;calc&lt;/code&gt;方法的次数。显然，在没有开启缓存的情况下，计算次数为&lt;em&gt;A&lt;strong&gt;n&lt;/strong&gt;n&lt;/em&gt;×&lt;em&gt;n&lt;/em&gt;，而当开启缓存时，计算次数为&lt;em&gt;A&lt;strong&gt;n&lt;/strong&gt;n&lt;/em&gt;×(&lt;em&gt;n&lt;/em&gt;−3)+&lt;em&gt;A**n&lt;/em&gt;3。&lt;/p&gt; &#xA;&lt;h4&gt;CASE&lt;/h4&gt; &#xA;&lt;p&gt;看了这么多概念，我们可以在&lt;code&gt;com.gch.discount.demo&lt;/code&gt;包中找到实际调用的具体case：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;@Controller&#xA;public class TestController {&#xA;&#xA;    private final CalculatorRouter calculatorRouter;&#xA;&#xA;    public TestController(CalculatorRouter calculatorRouter) {&#xA;        this.calculatorRouter = calculatorRouter;&#xA;    }&#xA;&#xA;    @RequestMapping(&#34;test&#34;)&#xA;    @ResponseBody&#xA;    public Object test() {&#xA;        //mock商品&#xA;        List&amp;lt;GoodsItem&amp;gt; items = mockItems();&#xA;        //mock组关系并转化为共享组&#xA;        List&amp;lt;Pair&amp;lt;Set&amp;lt;DiscountWrapper&amp;gt;,Set&amp;lt;DiscountWrapper&amp;gt;&amp;gt;&amp;gt; pairs = transform(mockGroups());&#xA;        //全局最优计算过程&#xA;        List&amp;lt;CalcStage&amp;gt; globalStages=Lists.newArrayList();&#xA;        int count = 0;&#xA;        //订单总金额&#xA;        long totalPrice = items.stream().mapToLong(GoodsInfo::getSalePrice).sum();&#xA;        long globalPrice = totalPrice;&#xA;        //构建计算流&#xA;        Flowable flowable = (Flowable) new Flowable().build(calculatorRouter);&#xA;        for(Pair&amp;lt;Set&amp;lt;DiscountWrapper&amp;gt;,Set&amp;lt;DiscountWrapper&amp;gt;&amp;gt; set:pairs) {&#xA;            //统计算力&#xA;            count += LimitingUtil.count(set.getLeft().size());&#xA;            if(count&amp;gt;N){&#xA;                break;&#xA;            }&#xA;            List&amp;lt;DiscountWrapper&amp;gt; wrappers = Lists.newArrayList(set.getLeft());&#xA;            DiscountContext&amp;lt;GoodsItem&amp;gt; ctx = DiscountContext.create(totalPrice, Lists.newArrayList(items), wrappers);&#xA;            flowable.perm(ctx);&#xA;            if(ctx.getCalcResult().getFinalPrice() &amp;lt; globalPrice) {&#xA;                globalStages = Arrays.asList(ctx.getCalcResult().getStages());&#xA;                globalPrice = ctx.getCalcResult().getFinalPrice();&#xA;            }&#xA;        }&#xA;        return Pair.of(globalPrice,globalStages);&#xA;    }&#xA;&#xA;    private List&amp;lt;List&amp;lt;DiscountGroup&amp;gt;&amp;gt; mockGroups(){&#xA;        List&amp;lt;List&amp;lt;DiscountGroup&amp;gt;&amp;gt; groups = Lists.newArrayList();&#xA;        DiscountGroup group = new DiscountGroup();&#xA;        group.setRelation(GroupRelation.SHARE.getType());&#xA;        group.setItems(Lists.newArrayList(new Item(&#34;zhekou&#34;,&#34;1&#34;),new Item(&#34;manjian&#34;,&#34;2&#34;),new Item(&#34;manzeng&#34;,&#34;3&#34;)));&#xA;        groups.add(Lists.newArrayList(group));&#xA;        return groups;&#xA;    }&#xA;&#xA;    private List&amp;lt;GoodsItem&amp;gt; mockItems(){&#xA;        IdGenerator idGenerator = IdGenerator.getInstance();&#xA;        GoodsInfo goodsInfo = GoodsInfo.of(1001L,2001L,null,4,20 * 100,&#34;产品1&#34;,null);&#xA;        GoodsInfo goodsInfo2 = GoodsInfo.of(1001L,2002L,null,2,10 * 100,&#34;产品1&#34;,null);&#xA;        List&amp;lt;GoodsItem&amp;gt; items = GoodsItem.generateItems(goodsInfo,idGenerator,x-&amp;gt;x.getExtra().put(Constant.UPDATEABLEPRICE,x.getSalePrice()));&#xA;        items.addAll(GoodsItem.generateItems(goodsInfo2,idGenerator,x-&amp;gt;x.getExtra().put(Constant.UPDATEABLEPRICE,x.getSalePrice())));&#xA;        return items;&#xA;    }&#xA;&#xA;    private List&amp;lt;Pair&amp;lt;Set&amp;lt;DiscountWrapper&amp;gt;,Set&amp;lt;DiscountWrapper&amp;gt;&amp;gt;&amp;gt; transform(List&amp;lt;List&amp;lt;DiscountGroup&amp;gt;&amp;gt; groups){&#xA;        List&amp;lt;DiscountWrapper&amp;gt; wrapperList = Lists.newArrayList(&#xA;                DiscountWrapper.of(&#34;zhekou&#34;, &#34;1&#34;, &#34;折扣&#34;, false, new DiscountConfig()),&#xA;                DiscountWrapper.of(&#34;manjian&#34;, &#34;2&#34;, &#34;满减&#34;, false, new DiscountConfig())&#xA;        );&#xA;        Map&amp;lt;String, Map&amp;lt;String,DiscountWrapper&amp;gt;&amp;gt; inMap = wrapperList.stream().collect(Collectors.toMap(DiscountWrapper::getType, x-&amp;gt;ImmutableMap.of(x.getId(),x)));&#xA;        return DiscountGroupUtil.transform(groups,inMap);&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>