<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-14T01:31:27Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>patrickfav/bcrypt</title>
    <updated>2023-10-14T01:31:27Z</updated>
    <id>tag:github.com,2023-10-14:/patrickfav/bcrypt</id>
    <link href="https://github.com/patrickfav/bcrypt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Java standalone implementation of the bcrypt password hash function. Based on the Blowfish cipher it is the default password hash algorithm for OpenBSD and other systems including some Linux distributions. Includes a CLI Tool.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Bcrypt Java Library and CLI Tool&lt;/h1&gt; &#xA;&lt;p&gt;This is an implementation of the OpenBSD Blowfish password hashing algorithm, as described in &#34;&lt;a href=&#34;http://www.openbsd.org/papers/bcrypt-paper.ps&#34;&gt;A Future-Adaptable Password Scheme&lt;/a&gt;&#34; by Niels Provos and David Mazieres. It&#39;s core is based on &lt;a href=&#34;https://github.com/djmdjm/jBCrypt&#34;&gt;jBcrypt&lt;/a&gt;, but heavily refactored, modernized and with a lot of updates and enhancements. It supports all common &lt;a href=&#34;https://en.wikipedia.org/wiki/Bcrypt#Versioning_history&#34;&gt;versions&lt;/a&gt;, has a security sensitive API and is fully tested against a range of test vectors and reference implementations.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://mvnrepository.com/artifact/at.favre.lib/bcrypt&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/at.favre.lib/bcrypt&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/patrickfav/bcrypt/actions&#34;&gt;&lt;img src=&#34;https://github.com/patrickfav/bcrypt/actions/workflows/build_deploy.yml/badge.svg?sanitize=true&#34; alt=&#34;Github Actions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.javadoc.io/doc/at.favre.lib/bcrypt&#34;&gt;&lt;img src=&#34;https://www.javadoc.io/badge/at.favre.lib/bcrypt.svg?sanitize=true&#34; alt=&#34;Javadocs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/new_code?id=patrickfav_bcrypt&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=patrickfav_bcrypt&amp;amp;metric=coverage&#34; alt=&#34;Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/new_code?id=patrickfav_bcrypt&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=patrickfav_bcrypt&amp;amp;metric=security_rating&#34; alt=&#34;Security Rating&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/new_code?id=patrickfav_bcrypt&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=patrickfav_bcrypt&amp;amp;metric=sqale_rating&#34; alt=&#34;Maintainability Rating&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The code is compiled with target &lt;a href=&#34;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_7&#34;&gt;Java 7&lt;/a&gt; to be compatible with most &lt;a href=&#34;https://www.android.com/&#34;&gt;&lt;em&gt;Android&lt;/em&gt;&lt;/a&gt; versions as well as normal Java applications.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Add the dependency of the &lt;a href=&#34;https://github.com/patrickfav/bcrypt/releases/latest&#34;&gt;latest version&lt;/a&gt; to your &lt;code&gt;pom.xml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;at.favre.lib&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;bcrypt&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;{latest-version}&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A simple example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String password = &#34;1234&#34;;&#xA;String bcryptHashString = BCrypt.withDefaults().hashToString(12, password.toCharArray());&#xA;// $2a$12$US00g/uMhoSBm.HiuieBjeMtoN69SN.GE25fCpldebzkryUyopws6&#xA;    ...&#xA;BCrypt.Result result = BCrypt.verifyer().verify(password.toCharArray(), bcryptHashString);&#xA;// result.verified == true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API Description for the Java Library&lt;/h2&gt; &#xA;&lt;p&gt;The following APIs are for advanced use-cases and require the developer to be familiar with the material. If you are not sure, just stick to the quick start example.&lt;/p&gt; &#xA;&lt;h3&gt;Bcrypt Versions&lt;/h3&gt; &#xA;&lt;p&gt;This implementation supports the various versions, which basically only differ through their identifier:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;char[] bcryptChars = BCrypt.with(BCrypt.Version.VERSION_2Y).hashToChar(6, password.toCharArray());&#xA;// $2y$06$doGnefu9cbLkJTn8sef7U.dynHJFe5hS6xp7vLWb2Zu7e8cOuMVmS&#xA;&#xA;char[] bcryptChars = BCrypt.with(BCrypt.Version.VERSION_2B).hashToChar(6, password.toCharArray());&#xA;// $2b$06$GskjDDM9oejRN8pxNhiSZuIw/cnjbsNb8IfWGd3TFQXtRfKTN95r.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example the &lt;a href=&#34;http://php.net/manual/en/function.password-hash.php&#34;&gt;PHP implementation of bcrypt&lt;/a&gt; will return hashes with version &lt;code&gt;$2y$&lt;/code&gt;. By using &lt;code&gt;BCrypt.withDefaults()&lt;/code&gt; it will default to version &lt;code&gt;$2a$&lt;/code&gt;. The older &lt;code&gt;$2$&lt;/code&gt; version is not supported. For advanced use cases you may add your own version by providing a version identifier and a custom message formatter as well as parser.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Version customVersion2f = new Version(new byte[]{0x32, 0x66} /* 2f */, true, true, myCustomFormatter, myCustomParser);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;byte[] vs char[] API&lt;/h3&gt; &#xA;&lt;p&gt;You can use either &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;byte[]&lt;/code&gt; as input or output parameter. The reason &lt;code&gt;String&lt;/code&gt; is usually omitted in security relevant APIs is, that a primitive array can usually be overwritten, as to discard it immediately after use. It is however not possible to wipe the content of the immutable &lt;code&gt;String&lt;/code&gt;. The encoding always defaults to &lt;code&gt;UTF-8&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] bcryptHashBytes = BCrypt.withDefaults().hash(6, password.getBytes(StandardCharsets.UTF_8));&#xA;    ...&#xA;BCrypt.Result result = BCrypt.verifyer().verify(password.getBytes(StandardCharsets.UTF_8), bcryptHashBytes);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;char[] bcryptChars = BCrypt.withDefaults().hashToChar(12, password.toCharArray());&#xA;    ...&#xA;BCrypt.Result result = BCrypt.verifyer().verify(password.toCharArray(), bcryptChars);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note, that there are APIs that return &lt;code&gt;String&lt;/code&gt; type hash and can verify it directly. This is done out of convenience and to present easy to understand API for all audiences. Usually the hash is not as critical as the raw password, so it might be ok to not be able to wipe it immediately. But usually you should prefer &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;byte[]&lt;/code&gt; APIs.&lt;/p&gt; &#xA;&lt;h3&gt;Strict Verification&lt;/h3&gt; &#xA;&lt;p&gt;If you want the hash verification to only verify for a specific version you can use &lt;code&gt;verifyStrict()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] hash2y = BCrypt.with(BCrypt.Version.VERSION_2Y).hash(6, password.getBytes(StandardCharsets.UTF_8));&#xA;BCrypt.Result resultStrict = BCrypt.verifyer(BCrypt.Version.VERSION_2A).verifyStrict(password.getBytes(StandardCharsets.UTF_8), hash2y);&#xA;// resultStrict.verified == false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Handling for Overlong passwords&lt;/h3&gt; &#xA;&lt;p&gt;Due to the limitation in the Blowfish cipher, the maximum password length is 72 bytes (note that UTF-8 encoded, a character can be as much as 4 bytes). Per default, the &lt;code&gt;hash()&lt;/code&gt; method will throw an exception if the provided password is too long.&lt;/p&gt; &#xA;&lt;p&gt;The API supports passing a custom handling in that case, to mimic the behaviour of some popular implementations to just truncate the password.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BCrypt.with(LongPasswordStrategies.truncate(Version.VERSION_2A)).hash(6, pw);&#xA;BCrypt.with(LongPasswordStrategies.hashSha512(Version.VERSION_2A)).hash(6, pw); //allows to honour all pw bytes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Don&#39;t forget to use the same strategy when verifying:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BCrypt.verifyer(LongPasswordStrategies.truncate(Version.VERSION_2A)).verify(pw, hash);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The password will only be transformed if it is longer than 72 bytes. &lt;em&gt;It is important to note, however, that using any of these techniques will essentially create a custom flavor of Bcrypt, possibly not compatible with other implementations.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;However, you can also disable this warning by using the &lt;code&gt;LongPasswordStrategies.none&lt;/code&gt; strategy. It will pass the raw data to the internal cryptographic primitive (which in turn will ignore anything longer than 72 bytes). This is the standard behaviour of BCrypt.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Salt or SecureRandom&lt;/h3&gt; &#xA;&lt;p&gt;The caller may provide their own salt (which must be exactly 16 bytes) with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BCrypt.withDefaults().hash(6, salt16Bytes, password.getBytes(StandardCharsets.UTF_8));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or provide a custom instance of a cryptographically secure pseudorandom number generator (&lt;a href=&#34;https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator&#34;&gt;CPRNG&lt;/a&gt;) which is used for the internal secure creation of the salt if none is passed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BCrypt.with(new SecureRandom()).hash(6, password.getBytes(StandardCharsets.UTF_8));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieve and Verify the Raw Hash&lt;/h3&gt; &#xA;&lt;p&gt;Per default the result of &lt;code&gt;hash()&lt;/code&gt; methods will return in the &lt;a href=&#34;https://passlib.readthedocs.io/en/stable/modular_crypt_format.html&#34;&gt;Modular Crypt Format&lt;/a&gt; (e.g. &lt;code&gt;$2y$06$doGnefu9cbLkJTn8sef7U.dynHJFe5hS6xp7vLWb2Zu7e8cOuMVmS&lt;/code&gt;), but if you prefer encoding the hash yourself you can just use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BCrypt.HashData hashData = BCrypt.withDefaults().hashRaw(6, salt, password.getBytes(StandardCharsets.UTF_8));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;there is even a verify method optimized for this use-case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BCrypt.Result result = BCrypt.verifyer().verify(pw, hashData);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You could even use the default formatter later on:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byet[] hashMsg = Version.VERSION_2A.formatter.createHashMessage(hashData);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Command Line Interface (CLI) Tool&lt;/h2&gt; &#xA;&lt;p&gt;In addition to the Java library there is a companion command line interface (CLI) tool (found in the &lt;code&gt;bcrypt-cli&lt;/code&gt; sub-module) which uses this bcrypt library. It features creating bcrypt password hashes with chosen cost factor and optionally passed salt value as well as verifying given hash against given password.&lt;/p&gt; &#xA;&lt;p&gt;This command will create a bcrypt hash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;java -jar bcrypt-cli.jar &#39;mySecretPw&#39; -b 12&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command will verify given bcrypt hash (returns &lt;code&gt;!= 0&lt;/code&gt; if could not be verified):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;java -jar bcrypt-cli.jar &#39;mySecretPw&#39; -c &#39;$2a$08$hgaLWQl7PdKIkx9iQyoLkeuIqizWtPErpyC7aDBasi2Pav97wwW9G&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The full API can be read in the doc by passing &lt;code&gt;-h&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-b,--bhash &amp;lt;cost&amp;gt; &amp;lt;[16-hex-byte-salt]&amp;gt;   Use this flag if you want to compute the bcrypt hash. Pass the&#xA;                                         logarithm cost factor (4-31) and optionally the used salt as hex&#xA;                                         encoded byte array (must be exactly 16 bytes/32 characters hex).&#xA;                                         Example: &#39;--bhash 12 8e270d6129fd45f30a9b3fe44b4a8d9a&#39;&#xA;-c,--check &amp;lt;bcrypt-hash&amp;gt;                 Use this flag if you want to verify a hash against a given&#xA;                                         password. Example: &#39;--check&#xA;                                         $2a$06$If6bvum7DFjUnE9p2uDeDu0YHzrHM6tf.iqN8.yx.jNN1ILEf7h0i&#39;&#xA;-h,--help                                Prints help docs.&#xA;-v,--version                             Prints current version.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;The artifacts are deployed to &lt;a href=&#34;https://search.maven.org/&#34;&gt;Maven Central&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Maven&lt;/h3&gt; &#xA;&lt;p&gt;Add the dependency of the &lt;a href=&#34;https://github.com/patrickfav/bcrypt/releases&#34;&gt;latest version&lt;/a&gt; to your &lt;code&gt;pom.xml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;at.favre.lib&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;bcrypt&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;{latest-version}&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Gradle&lt;/h3&gt; &#xA;&lt;p&gt;Add to your &lt;code&gt;build.gradle&lt;/code&gt; module dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;implementation group: &#39;at.favre.lib&#39;, name: &#39;bcrypt&#39;, version: &#39;{latest-version}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Local Jar Library&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/patrickfav/bcrypt/releases/latest&#34;&gt;Grab jar from latest release.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;OSGi&lt;/h3&gt; &#xA;&lt;p&gt;The library should be prepared to be used with the OSGi framework with the help of the &lt;a href=&#34;http://felix.apache.org/documentation/subprojects/apache-felix-maven-bundle-plugin-bnd.html&#34;&gt;bundle plugin&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;CLI Tool&lt;/h3&gt; &#xA;&lt;p&gt;Get the binary from the &lt;a href=&#34;https://github.com/patrickfav/bcrypt/releases/latest&#34;&gt;release page&lt;/a&gt; or build it yourself by with mvn (see below). The &lt;code&gt;jar&lt;/code&gt; will be in the &lt;code&gt;bcrypt-cli/target&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;h3&gt;Security Analysis&lt;/h3&gt; &#xA;&lt;p&gt;I&#39;ll quote security expert &lt;a href=&#34;http://www.bolet.org/~pornin/&#34;&gt;Thomas Pornin&lt;/a&gt; on this (an excerpt &lt;a href=&#34;https://security.stackexchange.com/a/6415/60108&#34;&gt;from this post&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;tl;dr bcrypt is better than PBKDF2 because PBKDF2 can be better accelerated with GPUs. As such, PBKDF2 is easier to brute force offline with consumer hardware. &lt;a href=&#34;https://security.stackexchange.com/a/26253/60108&#34;&gt;srcypt tried to address bcrypt&#39;s shortcommings, but didn&#39;t succeed all the way.&lt;/a&gt; &lt;a href=&#34;https://security.stackexchange.com/a/119784/60108&#34;&gt;Argon2 is too new to tell.&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Bcrypt has the best kind of repute that can be achieved for a cryptographic algorithm: it has been around for quite some time, used quite widely, &#34;attracted attention&#34;, and yet remains unbroken to date.&lt;/p&gt; &#xA; &lt;h4&gt;Why bcrypt is somewhat better than PBKDF2&lt;/h4&gt; &#xA; &lt;p&gt;If you look at the situation in details, you can actually see some points where bcrypt is better than, say, PBKDF2. Bcrypt is a password hashing function which aims at being slow. To be precise, we want the password hashing function to be as slow as possible for the attacker while not being intolerably slow for the honest systems. (...) What we want to avoid is that an attacker might use some non-PC hardware which would allow him to suffer less than us from the extra work implied by bcrypt or PBKDF2. In particular, an industrious attacker may want to use a GPU or a FPGA. SHA-256, for instance, can be very efficiently implemented on a GPU, since it uses only 32-bit logic and arithmetic operations that GPU are very good at. (...) Bcrypt happens to heavily rely on accesses to a table which is constantly altered throughout the algorithm execution. This is very fast on a PC, much less so on a GPU, where memory is shared and all cores compete for control of the internal memory bus. Thus, the boost that an attacker can get from using GPU is quite reduced, compared to what the attacker gets with PBKDF2 or similar designs.&lt;/p&gt; &#xA; &lt;h4&gt;Why bcrypt is not optimally secure&lt;/h4&gt; &#xA; &lt;p&gt;Bcrypt needs only 4 kB of fast RAM. While bcrypt does a decent job at making life difficult for a GPU-enhanced attacker, it does little against a FPGA-wielding attacker.&lt;/p&gt; &#xA; &lt;h4&gt;What NIST recommends&lt;/h4&gt; &#xA; &lt;p&gt;NIST has issued Special Publication SP 800-132 on the subject of storing hashed passwords. Basically they recommend PBKDF2. This does not mean that they deem bcrypt insecure; they say nothing at all about bcrypt. It just means that NIST deems PBKDF2 &#34;secure enough&#34; (and it certainly is much better than a simple hash !). Also, NIST is an administrative organization, so they are bound to just love anything which builds on already &#34;Approved&#34; algorithms like SHA-256. On the other hand, bcrypt comes from Blowfish which has never received any kind of NIST blessing (or curse).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;What Cost Factor should I use?&lt;/h4&gt; &#xA;&lt;p&gt;Again, quote from Thomas Pornin &lt;a href=&#34;https://security.stackexchange.com/a/31846/60108&#34;&gt;from this post&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;As much as possible! This salted-and-slow hashing is an arms race between the attacker and the defender. You use many iterations to make the hashing of a password harder for everybody. To improve security, you should set that number as high as you can tolerate on your server, given the tasks that your server must otherwise fulfill. Higher is better.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;So find your tolerable slowest performance (for some this is 3 sec, for some 250 ms, for some 1 minute) and try it out on an average lower end device your user-base would use (if the client has to calculate the hash) and/or benchmark your server.&lt;/p&gt; &#xA;&lt;p&gt;Note, that it is unfortunately &lt;a href=&#34;https://security.stackexchange.com/a/23308/60108&#34;&gt;NOT possible to increase the cost-factor&lt;/a&gt; of a calculated bcrypt hash without knowing the original password. A possible solution is to persist hashes with multiple work factors for different use cases/migration.&lt;/p&gt; &#xA;&lt;h3&gt;Performance&lt;/h3&gt; &#xA;&lt;p&gt;Compared to two other implementations in Java they all share similar performance characteristics. Using the simple micro benchmark in this repo (see &lt;code&gt;BcryptMicroBenchmark&lt;/code&gt;), I got the following results with a Intel Core &lt;a href=&#34;https://ark.intel.com/products/97129/Intel-Core-i7-7700K-Processor-8M-Cache-up-to-4_50-GHz&#34;&gt;i7-7700K&lt;/a&gt;, Win 10, Java 8 (172):&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;cost 6&lt;/th&gt; &#xA;   &lt;th&gt;cost 8&lt;/th&gt; &#xA;   &lt;th&gt;cost 10&lt;/th&gt; &#xA;   &lt;th&gt;cost 12&lt;/th&gt; &#xA;   &lt;th&gt;cost 14&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;favreBcrypt&lt;/td&gt; &#xA;   &lt;td&gt;3.38 ms&lt;/td&gt; &#xA;   &lt;td&gt;13.54 ms&lt;/td&gt; &#xA;   &lt;td&gt;53.91 ms&lt;/td&gt; &#xA;   &lt;td&gt;216.01 ms&lt;/td&gt; &#xA;   &lt;td&gt;873.93 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;jBcrypt&lt;/td&gt; &#xA;   &lt;td&gt;3.43 ms&lt;/td&gt; &#xA;   &lt;td&gt;13.75 ms&lt;/td&gt; &#xA;   &lt;td&gt;54.76 ms&lt;/td&gt; &#xA;   &lt;td&gt;218.62 ms&lt;/td&gt; &#xA;   &lt;td&gt;883.55 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BouncyCastle&lt;/td&gt; &#xA;   &lt;td&gt;3.14 ms&lt;/td&gt; &#xA;   &lt;td&gt;12.5 ms&lt;/td&gt; &#xA;   &lt;td&gt;49.8 ms&lt;/td&gt; &#xA;   &lt;td&gt;199.09 ms&lt;/td&gt; &#xA;   &lt;td&gt;799.71 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;compare that with a 2017 flag ship Android phone Samsung Galaxy S8+ (&lt;a href=&#34;https://www.gsmarena.com/samsung_galaxy_s8+-8523.php&#34;&gt;SM-G955F&lt;/a&gt;) with Android 8:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;cost 6&lt;/th&gt; &#xA;   &lt;th&gt;cost 8&lt;/th&gt; &#xA;   &lt;th&gt;cost 10&lt;/th&gt; &#xA;   &lt;th&gt;cost 12&lt;/th&gt; &#xA;   &lt;th&gt;cost 14&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;favreBcrypt&lt;/td&gt; &#xA;   &lt;td&gt;8.13 ms&lt;/td&gt; &#xA;   &lt;td&gt;29.05 ms&lt;/td&gt; &#xA;   &lt;td&gt;110.62 ms&lt;/td&gt; &#xA;   &lt;td&gt;438.45 ms&lt;/td&gt; &#xA;   &lt;td&gt;1768.44 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;jBcrypt&lt;/td&gt; &#xA;   &lt;td&gt;7.91 ms&lt;/td&gt; &#xA;   &lt;td&gt;30.91 ms&lt;/td&gt; &#xA;   &lt;td&gt;116.45 ms&lt;/td&gt; &#xA;   &lt;td&gt;462.93 ms&lt;/td&gt; &#xA;   &lt;td&gt;1855.36 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BouncyCastle&lt;/td&gt; &#xA;   &lt;td&gt;10.41 ms&lt;/td&gt; &#xA;   &lt;td&gt;38.03 ms&lt;/td&gt; &#xA;   &lt;td&gt;149.09 ms&lt;/td&gt; &#xA;   &lt;td&gt;595.19 ms&lt;/td&gt; &#xA;   &lt;td&gt;2383.72 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;More benchmarks can be found in the &lt;a href=&#34;https://github.com/patrickfav/bcrypt/wiki/Benchmark&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;So it makes sense that this implementation and jBcrypt&#39;s has the same performance as it is the same core implementation. Bouncy Castle is &lt;em&gt;slightly&lt;/em&gt; faster (on the JVM, not on Android interestingly), but keep in mind that they do a little less work (only generating the hash, not the whole out message).&lt;/p&gt; &#xA;&lt;p&gt;Compare this to other benchmarks, &lt;a href=&#34;https://github.com/dcodeIO/bcrypt.js/wiki/Benchmark&#34;&gt;like this one in node.js&lt;/a&gt; where a bcrypt hash with cost factor 12 is between 300-400ms.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; Micro benchmarks are &lt;a href=&#34;https://mrale.ph/blog/2012/12/15/microbenchmarks-fairy-tale.html&#34;&gt;usually a really bad way to measure performance&lt;/a&gt;. These numbers are only informal tests and should not be used to derive any security relevant decisions.&lt;/p&gt; &#xA;&lt;h4&gt;JMH Benchmark&lt;/h4&gt; &#xA;&lt;p&gt;Additionally there is JMH benchmark module, which is probably better than my home-brew micro benchmark. Build it with maven &lt;code&gt;./mvnw clean install&lt;/code&gt; (you may want to disable jar signing with &lt;code&gt;&amp;lt;project.skipJarSign&amp;gt;&lt;/code&gt; property) and execute it with &lt;code&gt;java -jar modules/benchmark-jmh/target/benchmark-jmh-x.y.z-full.jar&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Test Vectors and Reference Implementations&lt;/h3&gt; &#xA;&lt;p&gt;This implementation is tested against the bcrypt implementation jBcrypt and Bouncy Castle. It includes test vectors found in the test cases of bcrypt and &lt;a href=&#34;https://stackoverflow.com/a/12761326/774398&#34;&gt;various&lt;/a&gt; &lt;a href=&#34;http://openwall.info/wiki/john/sample-hashes&#34;&gt;places&lt;/a&gt; &lt;a href=&#34;http://cvsweb.openwall.com/cgi/cvsweb.cgi/Owl/packages/glibc/crypt_blowfish/wrapper.c?rev=HEAD&#34;&gt;on&lt;/a&gt; &lt;a href=&#34;https://github.com/BcryptNet/bcrypt.net/raw/main/src/BCrypt.Net.UnitTests/BCryptTests.cs&#34;&gt;the web&lt;/a&gt;. Additionally I &lt;a href=&#34;https://github.com/patrickfav/bcrypt/wiki/Published-Test-Vectors&#34;&gt;created a reference test suite&lt;/a&gt; for regression tests and to check compatibility with other libraries.&lt;/p&gt; &#xA;&lt;h3&gt;The Modular Crypt Format for bcrypt&lt;/h3&gt; &#xA;&lt;p&gt;Since bcrypt evolved from OpenBSD most implementations output the hash in the modular crypt format (MCF). In contrast to e.g. normal &lt;code&gt;sha&lt;/code&gt; hash it includes the used hash function, cost factor, salt and hash itself. This makes it specifically convenient for password storage use. Formally the &lt;a href=&#34;http://passlib.readthedocs.io/en/stable/modular_crypt_format.html&#34;&gt;format&lt;/a&gt; is:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;(...) a standard for encoding password hash strings, which requires hashes have the format &lt;code&gt;${identifier}${content}&lt;/code&gt;; where &lt;code&gt;{identifier}&lt;/code&gt; is an short alphanumeric string uniquely identifying a particular scheme, and &lt;code&gt;{content}&lt;/code&gt; is the contents of the scheme, using only the characters in the regexp range &lt;code&gt;[a-zA-Z0-9./]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Analyzing the bcrypt format in detail we get:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; ${identifier}${cost-factor}${16-bytes-salt-radix64}{23-bytes-hash-radix64}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With bcrypt the version identifier was &lt;code&gt;$2$&lt;/code&gt;, but unfortunately early implementations &lt;a href=&#34;http://undeadly.org/cgi?action=article&amp;amp;sid=20140224132743&#34;&gt;did not define how to handle non-ASCII characters&lt;/a&gt;, so to tag the old hashes, a new minor version was introduced which was not compatible with the earlier one: &lt;code&gt;$2a$&lt;/code&gt;. This is the default version used by most implementations. There are other minor versions which are only used to tag various non-backwards compatible bugs in different implementations (namely &lt;code&gt;$2x$&lt;/code&gt; and &lt;code&gt;$2y$&lt;/code&gt; used by &lt;code&gt;crypt_blowfish&lt;/code&gt; (PHP) and &lt;code&gt;$2b$&lt;/code&gt; by OpenBSD). These are usually irrelevant for implementations that did not have these bugs, so there is no advantage in setting the version to e.g. &lt;code&gt;$2y$&lt;/code&gt; apart from making it compatible with different systems. The actual format is the same as &lt;code&gt;$2a$&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The cost factor is the logarithmic work factor value as defined (4-30) printed as normal ASCII characters &lt;code&gt;[0-9]&lt;/code&gt;. After that the 16 byte salt encoded with a base64 dialect follows (22 characters) as well as the actual bcrypt hash (23 bytes / 31 characters encoded with the base64 dialect).&lt;/p&gt; &#xA;&lt;p&gt;Here is a full example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$2a$08$cfcvVd2aQ8CMvoMpP2EBfeodLEkkFJ9umNEfPD18.hUF62qqlC/V.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here &lt;code&gt;$2a$&lt;/code&gt; is the version, the cost factor is &lt;code&gt;8&lt;/code&gt;, the salt is &lt;code&gt;cfcvVd2aQ8CMvoMpP2EBfe&lt;/code&gt; and the bcrypt hash is &lt;code&gt;odLEkkFJ9umNEfPD18.hUF62qqlC/V.&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The used encoding is similar to the RFC * base64 encoding schema, but &lt;a href=&#34;https://en.wikipedia.org/wiki/Base64#Radix-64_applications_not_compatible_with_Base64&#34;&gt;with different mappings&lt;/a&gt; (&lt;code&gt;./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&lt;/code&gt; vs. &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&lt;/code&gt;) only used by OpenBSD. In the code base this encoding is usually referenced as &#34;Radix64&#34; (see &lt;code&gt;Radix64Encoder&lt;/code&gt;). The usual padding with &lt;code&gt;=&lt;/code&gt; is omitted.&lt;/p&gt; &#xA;&lt;h3&gt;Enhancements over jBcrypt&lt;/h3&gt; &#xA;&lt;p&gt;The core of this implementation is based on the popular jBcrypt. Many things around if have been heavily refactored and various new features and APIs have been added:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Optimized and fixed implementation&lt;/li&gt; &#xA; &lt;li&gt;Support of most &lt;a href=&#34;https://en.wikipedia.org/wiki/Bcrypt#Versioning_history&#34;&gt;version&lt;/a&gt; variations (&lt;code&gt;$2a$&lt;/code&gt;, &lt;code&gt;$2b$&lt;/code&gt;, &lt;code&gt;$2x$&lt;/code&gt;, &lt;code&gt;$2y$&lt;/code&gt;) with support of custom versions&lt;/li&gt; &#xA; &lt;li&gt;Customizable handling for passwords over 72 bytes&lt;/li&gt; &#xA; &lt;li&gt;Only uses byte and char arrays which can be wiped after use&lt;/li&gt; &#xA; &lt;li&gt;Faster Radix64 implementation&lt;/li&gt; &#xA; &lt;li&gt;Allow a cost factor of 31 (jBcrypt only allows up to 30)&lt;/li&gt; &#xA; &lt;li&gt;Easily get the raw hash&lt;/li&gt; &#xA; &lt;li&gt;Provide your own salt or &lt;code&gt;SecureRandom&lt;/code&gt; for salt generation&lt;/li&gt; &#xA; &lt;li&gt;Clearer and easier API&lt;/li&gt; &#xA; &lt;li&gt;Signed Jar and signed commits&lt;/li&gt; &#xA; &lt;li&gt;More tests (and probably higher coverage)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Security Relevant Information&lt;/h2&gt; &#xA;&lt;h3&gt;OWASP Dependency Check&lt;/h3&gt; &#xA;&lt;p&gt;This project uses the &lt;a href=&#34;https://www.owasp.org/index.php/OWASP_Dependency_Check&#34;&gt;OWASP Dependency-Check&lt;/a&gt; which is a utility that identifies project dependencies and checks if there are any known, publicly disclosed, vulnerabilities against a &lt;a href=&#34;https://nvd.nist.gov/vuln/data-feeds&#34;&gt;NIST database&lt;/a&gt;. The build will fail if any issue is found.&lt;/p&gt; &#xA;&lt;h3&gt;Digital Signatures&lt;/h3&gt; &#xA;&lt;h4&gt;Signed Jar&lt;/h4&gt; &#xA;&lt;p&gt;The provided JARs in the Github release page are signed with my private key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;CN=Patrick Favre-Bulle, OU=Private, O=PF Github Open Source, L=Vienna, ST=Vienna, C=AT&#xA;Validity: Thu Sep 07 16:40:57 SGT 2017 to: Fri Feb 10 16:40:57 SGT 2034&#xA;SHA1: 06:DE:F2:C5:F7:BC:0C:11:ED:35:E2:0F:B1:9F:78:99:0F:BE:43:C4&#xA;SHA256: 2B:65:33:B0:1C:0D:2A:69:4E:2D:53:8F:29:D5:6C:D6:87:AF:06:42:1F:1A:EE:B3:3C:E0:6D:0B:65:A1:AA:88&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use the jarsigner tool (found in your &lt;code&gt;$JAVA_HOME/bin&lt;/code&gt; folder) folder to verify.&lt;/p&gt; &#xA;&lt;h4&gt;Signed Commits&lt;/h4&gt; &#xA;&lt;p&gt;All tags and commits by me are signed with git with my private key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;GPG key ID: 4FDF85343912A3AB&#xA;Fingerprint: 2FB392FB05158589B767960C4FDF85343912A3AB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;h3&gt;Jar Sign&lt;/h3&gt; &#xA;&lt;p&gt;If you want to jar sign you need to provide a file &lt;code&gt;keystore.jks&lt;/code&gt; in the root folder with the correct credentials set in environment variables ( &lt;code&gt;OPENSOURCE_PROJECTS_KS_PW&lt;/code&gt; and &lt;code&gt;OPENSOURCE_PROJECTS_KEY_PW&lt;/code&gt;); alias is set as &lt;code&gt;pfopensource&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to skip jar signing just change the skip configuration in the &lt;code&gt;pom.xml&lt;/code&gt; jar sign plugin to true:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;project.skipJarSign&amp;gt;true&amp;lt;/project.skipJarSign&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build with Maven&lt;/h3&gt; &#xA;&lt;p&gt;Use the Maven wrapper to create a jar including all dependencies&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./mvnw clean install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Checkstyle Config File&lt;/h3&gt; &#xA;&lt;p&gt;This project uses my &lt;a href=&#34;https://github.com/patrickfav/mvn-common-parent&#34;&gt;&lt;code&gt;common-parent&lt;/code&gt;&lt;/a&gt; which centralized a lot of the plugin versions aswell as providing the checkstyle config rules. Specifically they are maintained in &lt;a href=&#34;https://github.com/patrickfav/checkstyle-config&#34;&gt;&lt;code&gt;checkstyle-config&lt;/code&gt;&lt;/a&gt;. Locally the files will be copied after you &lt;code&gt;mvnw install&lt;/code&gt; into your &lt;code&gt;target&lt;/code&gt; folder and is called &lt;code&gt;target/checkstyle-checker.xml&lt;/code&gt;. So if you use a plugin for your IDE, use this file as your local configuration.&lt;/p&gt; &#xA;&lt;h2&gt;Tech Stack&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Java 7 Source, JDK 11 required to build (not yet JDK17 compatible)&lt;/li&gt; &#xA; &lt;li&gt;Maven 3&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Libraries &amp;amp; Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/djmdjm/jBCrypt&#34;&gt;jBcrypt&lt;/a&gt; (derived the &#34;Blowfish Expensive key setup&#34;) (under BSD licence)&lt;/li&gt; &#xA; &lt;li&gt;Radix64 implementation derived from &lt;a href=&#34;https://github.com/square/okio&#34;&gt;Square&#39;s Okio Base64&lt;/a&gt; (under Apache v2)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/patrickfav/bytes-java&#34;&gt;Bytes&lt;/a&gt; (byte array utility library) (under Apache v2)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;BCrypt Implementations in Java&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/djmdjm/jBCrypt&#34;&gt;jBcrypt&lt;/a&gt; - the below implementations are based on jBcrypt &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-security/site/docs/4.2.5.RELEASE/apidocs/org/springframework/security/crypto/bcrypt/BCrypt.html&#34;&gt;Spring Bcrypt&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://directory.apache.org/api/gen-docs/latest/apidocs/org/apache/directory/api/ldap/model/password/BCrypt.html&#34;&gt;Apache Ldap&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/andreacomo/tomcat-bcrypt&#34;&gt;Tomcat Bcrypt&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bcgit/bc-java/raw/master/core/src/main/java/org/bouncycastle/crypto/generators/BCrypt.java&#34;&gt;Bouncy Castle&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Further Reading&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hackernoon.com/the-bcrypt-protocol-is-kind-of-a-mess-4aace5eb31bd&#34;&gt;The Bcrypt Protocolâ€¦ is kind of a mess&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Related Libraries&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/patrickfav/singlestep-kdf&#34;&gt;Single Step KDF [NIST SP 800-56C] (Java)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/patrickfav/hkdf&#34;&gt;HKDF [RFC5869] Two-Step KDF (Java)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Copyright 2018 Patrick Favre-Bulle&lt;/p&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://www.apache.org/licenses/LICENSE-2.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.&lt;/p&gt;</summary>
  </entry>
</feed>