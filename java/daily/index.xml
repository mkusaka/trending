<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-26T01:29:53Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jar-analyzer/jar-analyzer</title>
    <updated>2023-10-26T01:29:53Z</updated>
    <id>tag:github.com,2023-10-26:/jar-analyzer/jar-analyzer</id>
    <link href="https://github.com/jar-analyzer/jar-analyzer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Jar Analyzer Project&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Jar-Analyzer V2&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/build-passing-brightgreen&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/build-Java%208-orange&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/downloads/jar-analyzer/jar-analyzer/total&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/jar-analyzer/jar-analyzer&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Jar Analyzer&lt;/code&gt; 是一个分析 &lt;code&gt;Jar&lt;/code&gt; 文件的 &lt;code&gt;GUI&lt;/code&gt; 工具：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;方便地搜索方法之间的调用关系&lt;/li&gt; &#xA; &lt;li&gt;方便地搜索 &lt;code&gt;Jar&lt;/code&gt; 文件中的字符串&lt;/li&gt; &#xA; &lt;li&gt;一键分析 &lt;code&gt;Spring Controller/Mapping&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;对于方法字节码/指令等高级分析&lt;/li&gt; &#xA; &lt;li&gt;一键反编译&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;相比 &lt;code&gt;Jar-Analyzer V1&lt;/code&gt; 在 &lt;code&gt;V2&lt;/code&gt; 版本中解决了很多重要问题：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;中文不再乱码，代码 &lt;code&gt;GUI&lt;/code&gt; 部分更美观&lt;/li&gt; &#xA; &lt;li&gt;支持大 &lt;code&gt;Jar&lt;/code&gt; 文件以及批量分析&lt;/li&gt; &#xA; &lt;li&gt;支持保存状态，重启还原上次分析内容&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;另外有很多改进功能：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;更好的 &lt;code&gt;GUI&lt;/code&gt; 界面，代码高亮改进&lt;/li&gt; &#xA; &lt;li&gt;文件树改进，按照文件夹以及字母排序&lt;/li&gt; &#xA; &lt;li&gt;反编译改进，优化对内部类的处理&lt;/li&gt; &#xA; &lt;li&gt;自动搜索 &lt;code&gt;rt.jar&lt;/code&gt; 并加入分析&lt;/li&gt; &#xA; &lt;li&gt;一键查看任意方法的 &lt;code&gt;Control Flow Gragh&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;一键查看任意方法的 &lt;code&gt;Stack Frame&lt;/code&gt; 分析&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;更多的功能正在开发中&lt;/p&gt; &#xA;&lt;p&gt;有问题和建议欢迎提 &lt;code&gt;issue&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jar-analyzer/jar-analyzer/releases/latest&#34;&gt;前往下载&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;一些截图&lt;/h2&gt; &#xA;&lt;p&gt;指令分析&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0006.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CFG&lt;/code&gt; 分析&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0007.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;JVM Stack Frame&lt;/code&gt; 分析&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0008.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;分析 &lt;code&gt;Spring Framework&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0009.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;首页&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0002.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;方法调用搜索&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0003.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;方法调用关系&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0004.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;高级分析：正在开发中&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0005.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;注意事项&lt;/h2&gt; &#xA;&lt;p&gt;本工具已经根据 &lt;code&gt;1080P&lt;/code&gt; 适配 （考虑到绝大多数机器应该大于等于这个分辨率）&lt;/p&gt; &#xA;&lt;p&gt;如果你的电脑在 &lt;code&gt;1080P&lt;/code&gt; 下无法正常显示，请调整缩放到 &lt;code&gt;100%&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;以 &lt;code&gt;Windows 11&lt;/code&gt; 为例：右键显示设置&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0010.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;本工具的基本原理：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;解压所有 &lt;code&gt;Jar&lt;/code&gt; 文件到 &lt;code&gt;jar-analyzer-temp&lt;/code&gt; 目录&lt;/li&gt; &#xA; &lt;li&gt;在当前目录构建数据库 &lt;code&gt;jar-analyzer.db&lt;/code&gt; 文件&lt;/li&gt; &#xA; &lt;li&gt;在当前目录新建文件 &lt;code&gt;.jar-analyzer&lt;/code&gt; 记录状态&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0001.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;注意：当 &lt;code&gt;Jar&lt;/code&gt; 数量较多或巨大时&lt;strong&gt;可能导致临时目录和数据库文件巨大&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Release 说明&lt;/h2&gt; &#xA;&lt;p&gt;在 &lt;code&gt;release&lt;/code&gt; 中提供四种下载：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;system&lt;/code&gt; 使用系统 &lt;code&gt;JDK/JRE&lt;/code&gt; 的启动脚本 (需要自行安装 &lt;code&gt;JRE&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;embed&lt;/code&gt; 内置安全 &lt;code&gt;Y4 JRE&lt;/code&gt; 的启动脚本 (无需另外安装一键启动)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;linux&lt;/code&gt; 内置 &lt;code&gt;shell&lt;/code&gt; 启动脚本 (需要自行安装 &lt;code&gt;JRE&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;简单的 &lt;code&gt;Jar&lt;/code&gt; 文件，不提供启动脚本&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;由于本工具仅在 &lt;code&gt;Windows&lt;/code&gt; 中测试，其他操作系统可能会有未知的问题&lt;/p&gt; &#xA;&lt;p&gt;一般情况下，推荐使用内置 &lt;code&gt;Y4 JRE&lt;/code&gt; 的 &lt;code&gt;embed&lt;/code&gt; 版本启动&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://y4sec-team.github.io/jdk8u/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jar-analyzer/jar-analyzer/master/img/0000.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;关于 &lt;code&gt;Y4 JDK/JRE&lt;/code&gt; 项目: &lt;a href=&#34;https://y4sec-team.github.io/jdk8u/&#34;&gt;https://y4sec-team.github.io/jdk8u/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;如何构建&lt;/h2&gt; &#xA;&lt;p&gt;项目主要基于 &lt;code&gt;Java 8&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;下载 &lt;code&gt;JDK 8&lt;/code&gt; (推荐 &lt;a href=&#34;https://github.com/Y4Sec-Team/jdk8u&#34;&gt;https://github.com/Y4Sec-Team/jdk8u&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;使用 &lt;code&gt;Maven&lt;/code&gt; (&lt;a href=&#34;https://maven.apache.org/download.cgi&#34;&gt;https://maven.apache.org/download.cgi&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;使用 &lt;code&gt;Python 3&lt;/code&gt; 辅助 (&lt;a href=&#34;https://www.python.org/downloads/&#34;&gt;https://www.python.org/downloads/&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;步骤：&lt;/p&gt; &#xA;&lt;p&gt;(1) mvn -B package -Dmaven.test.skip=true --file pom.xml&lt;/p&gt; &#xA;&lt;p&gt;(2) python build.py&lt;/p&gt; &#xA;&lt;p&gt;(3) 复制 JRE 到 embed 版&lt;/p&gt; &#xA;&lt;h2&gt;其他&lt;/h2&gt; &#xA;&lt;p&gt;如果你希望体验老版本 (不再维护) 的 &lt;code&gt;Jar Analyzer&lt;/code&gt; 可以访问：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/4ra1n/jar-analyzer-cli&#34;&gt;https://github.com/4ra1n/jar-analyzer-cli&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/4ra1n/jar-analyzer-gui&#34;&gt;https://github.com/4ra1n/jar-analyzer-gui&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;为什么我不选择 &lt;code&gt;IDEA&lt;/code&gt; 而要选择 &lt;code&gt;Jar Analyzer V2&lt;/code&gt; 工具：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;因为 &lt;code&gt;IDEA&lt;/code&gt; 不支持分析无源码的 &lt;code&gt;Jar&lt;/code&gt; 包&lt;/li&gt; &#xA; &lt;li&gt;本工具有一些进阶功能是 &lt;code&gt;IDEA&lt;/code&gt; 不支持的 (指令/CFG/Stack分析)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(1) 什么是方法之间的关系&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Test{&#xA;    void a(){&#xA;        new Test().b();&#xA;    }&#xA;    &#xA;    void b(){&#xA;        Test.c();&#xA;    }&#xA;    &#xA;    static void c(){&#xA;        // code&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;如果当前方法是 &lt;code&gt;b&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;对于 &lt;code&gt;a&lt;/code&gt; 来说，它的 &lt;code&gt;callee&lt;/code&gt; 是 &lt;code&gt;b&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;对于 &lt;code&gt;b&lt;/code&gt; 来说，它的 &lt;code&gt;caller&lt;/code&gt; 是 &lt;code&gt;a&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;(2) 如何解决接口实现的问题&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Demo{&#xA;    void demo(){&#xA;        new Test().test();&#xA;    }&#xA;}&#xA;&#xA;interface Test {&#xA;    void test();&#xA;}&#xA;&#xA;class Test1Impl implements Test {&#xA;    @Override&#xA;    public void test() {&#xA;        // code&#xA;    }&#xA;}&#xA;&#xA;class Test2Impl implements Test {&#xA;    @Override&#xA;    public void test() {&#xA;        // code&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;现在我们有 &lt;code&gt;Demo.demo -&amp;gt; Test.test&lt;/code&gt; 数据, 但实际上它是 &lt;code&gt;Demo.demo -&amp;gt; TestImpl.test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;因此我们添加了新的规则： &lt;code&gt;Test.test -&amp;gt; Test1Impl.test&lt;/code&gt; 和 &lt;code&gt;Test.test -&amp;gt; Test2Impl.test&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;首先确保数据不会丢失，然后我们可以自行手动分析反编译的代码&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Demo.demo -&amp;gt; Test.test&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Test.test -&amp;gt; Test1Impl.test&lt;/code&gt;/&lt;code&gt;Test.test -&amp;gt; Test2Impl.test&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(3) 如何解决继承关系&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Zoo{&#xA;    void run(){&#xA;        Animal dog = new Dog();&#xA;        dog.eat();&#xA;    }&#xA;}&#xA;&#xA;class Animal {&#xA;    void eat() {&#xA;        // code&#xA;    }&#xA;}&#xA;&#xA;class Dog extends Animal {&#xA;    @Override&#xA;    void eat() {&#xA;        // code&#xA;    }&#xA;}&#xA;&#xA;class Cat extends Animal {&#xA;    @Override&#xA;    void eat() {&#xA;        // code&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Zoo.run -&amp;gt; dog.cat&lt;/code&gt; 的字节码是 &lt;code&gt;INVOKEVIRTUAL Animal.eat ()V&lt;/code&gt;, 但我们只有这条规则 &lt;code&gt;Zoo.run -&amp;gt; Animal.eat&lt;/code&gt;, 丢失了 &lt;code&gt;Zoo.run -&amp;gt; Dog.eat&lt;/code&gt; 规则&lt;/p&gt; &#xA;&lt;p&gt;这种情况下我们添加了新规则： &lt;code&gt;Animal.eat -&amp;gt; Dog.eat&lt;/code&gt; 和 &lt;code&gt;Animal.eat -&amp;gt; Cat.eat&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;首先确保数据不会丢失，然后我们可以自行手动分析反编译的代码&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Zoo.run -&amp;gt; Animal.eat&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Animal.eat -&amp;gt; Dog.eat&lt;/code&gt;/&lt;code&gt;Animal.eat -&amp;gt; Cat.eat&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;致谢&lt;/h2&gt; &#xA;&lt;p&gt;感谢以下项目提供的思路和代码&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/FabricMC/intellij-fernflower&#34;&gt;https://github.com/FabricMC/intellij-fernflower&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bobbylight/RSyntaxTextArea&#34;&gt;https://github.com/bobbylight/RSyntaxTextArea&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JackOfMostTrades/gadgetinspector&#34;&gt;https://github.com/JackOfMostTrades/gadgetinspector&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lsieun/learn-java-asm&#34;&gt;https://github.com/lsieun/learn-java-asm&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>