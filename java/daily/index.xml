<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-26T01:36:37Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Mirror0oo0/im</title>
    <updated>2023-07-26T01:36:37Z</updated>
    <id>tag:github.com,2023-07-26:/Mirror0oo0/im</id>
    <link href="https://github.com/Mirror0oo0/im" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h4&gt;项目介绍&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;IM是一个分布式聊天系统，目前完全开源，仅用于学习和交流。&lt;/li&gt; &#xA; &lt;li&gt;支持私聊、群聊、离线消息、发送图片、文件、好友在线状态显示等功能。&lt;/li&gt; &#xA; &lt;li&gt;后端采用springboot+netty实现，前端使用vue。&lt;/li&gt; &#xA; &lt;li&gt;服务器支持集群化部署，每个im-server仅处理自身连接用户的消息&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;项目结构&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;模块&lt;/th&gt; &#xA;   &lt;th&gt;功能&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;im-platform&lt;/td&gt; &#xA;   &lt;td&gt;与页面进行交互，处理业务请求&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;im-server&lt;/td&gt; &#xA;   &lt;td&gt;推送聊天消息&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;im-client&lt;/td&gt; &#xA;   &lt;td&gt;消息推送sdk&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;im-common&lt;/td&gt; &#xA;   &lt;td&gt;公共包&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;消息推送方案&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Mirror0oo0/im/master/%E6%88%AA%E5%9B%BE/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E9%9B%86%E7%BE%A4%E5%8C%96.jpg&#34; alt=&#34;输入图片说明&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;当消息的发送者和接收者连的不是同一个server时，消息是无法直接推送的，所以我们需要设计出能够支持跨节点推送的方案&lt;/li&gt; &#xA; &lt;li&gt;利用了redis的list数据实现消息推送，其中key为im:unread:${serverid},每个key的数据可以看做一个queue,每个im-server根据自身的id只消费属于自己的queue&lt;/li&gt; &#xA; &lt;li&gt;redis记录了每个用户的websocket连接的是哪个im-server,当用户发送消息时，im-platform将根据所连接的im-server的id,决定将消息推向哪个queue&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;本地快速部署&lt;/h4&gt; &#xA;&lt;p&gt;1.安装运行环境&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;安装node:v14.16.0&lt;/li&gt; &#xA; &lt;li&gt;安装jdk:1.8&lt;/li&gt; &#xA; &lt;li&gt;安装maven:3.6.3&lt;/li&gt; &#xA; &lt;li&gt;安装mysql:5.7,密码分别为root/root,运行sql脚本(脚本在im-platfrom的resources/db目录)&lt;/li&gt; &#xA; &lt;li&gt;安装redis:4.0&lt;/li&gt; &#xA; &lt;li&gt;安装minio，命令端口使用9001，并创建一个名为&#34;box-im&#34;的bucket，并设置访问权限为公开&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;2.启动后端服务&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mvn clean package&#xA;java -jar ./im-platform/target/im-platform.jar&#xA;java -jar ./im-server/target/im-server.jar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;3.启动前端ui&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd im-ui&#xA;npm install&#xA;npm run serve&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;4.访问localhost:8080&lt;/p&gt; &#xA;&lt;h4&gt;快速接入&lt;/h4&gt; &#xA;&lt;p&gt;消息推送的请求代码已经封装在im-client包中，对于需要接入im-server的小伙伴，可以按照下面的教程快速的将IM功能集成到自己的项目中。&lt;/p&gt; &#xA;&lt;p&gt;注意服务器端和网页端都需要接入，服务器端发送消息，网页端接收消息。&lt;/p&gt; &#xA;&lt;p&gt;4.1 服务器端接入&lt;/p&gt; &#xA;&lt;p&gt;引入pom文件&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;com.bx&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;im-client&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;1.1.0&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;内容使用了redis进行通信,所以要配置redis地址：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;spring:&#xA;  redis:&#xA;    host: 127.0.0.1&#xA;    port: 6379&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;直接把IMClient通过@Autowire导进来就可以发送消息了，IMClient 只有2个接口：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;public class IMClient {&#xA;&#xA;    /**&#xA;     * 发送私聊消息&#xA;     *&#xA;     * @param recvId 接收用户id&#xA;     * @param messageInfo 消息体，将转成json发送到客户端&#xA;     */&#xA;    void sendPrivateMessage(Long recvId, PrivateMessageInfo... messageInfo)；&#xA;     &#xA;&#xA;    /**&#xA;     * 发送群聊消息&#xA;     *&#xA;     * @param recvIds 群聊用户id列表&#xA;     * @param messageInfo 消息体，将转成json发送到客户端&#xA;     */&#xA;    void sendGroupMessage(List&amp;lt;Long&amp;gt; recvIds, GroupMessageInfo... messageInfo)；&#xA;      &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;发送私聊消息(群聊也是类似的方式)：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; @Autowired&#xA; private IMClient imClient;&#xA;&#xA; public void sendMessage(){&#xA;    PrivateMessageInfo messageInfo = new PrivateMessageInfo();&#xA;    Long recvId = 1L;&#xA;    messageInfo.setId(123L);&#xA;    messageInfo.setContent(&#34;你好呀&#34;);&#xA;    messageInfo.setType(MessageType.TEXT.getCode());&#xA;    messageInfo.setSendId(userId);&#xA;    messageInfo.setRecvId(recvId);&#xA;    messageInfo.setSendTime(new Date());&#xA;    imClient.sendPrivateMessage(recvId,messageInfo);&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;如果需要对消息发送的结果进行监听的话，实现MessageListener,并加上@IMListener即可&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@Slf4j&#xA;@IMListener(type = IMListenerType.ALL)&#xA;public class PrivateMessageListener implements MessageListener {&#xA;    &#xA;    @Override&#xA;    public void process(SendResult result){&#xA;        PrivateMessageInfo messageInfo = (PrivateMessageInfo) result.getMessageInfo();&#xA;        if(result.getStatus().equals(IMSendStatus.SUCCESS)){&#xA;            // 消息发送成功&#xA;            log.info(&#34;消息已读，消息id:{}，发送者:{},接收者:{}&#34;,messageInfo.getId(),messageInfo.getSendId(),messageInfo.getRecvId());&#xA;        }&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;4.2 网页端接入 首先将im-ui/src/api/wssocket.js拷贝到自己的项目。&lt;/p&gt; &#xA;&lt;p&gt;接入代码如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import * as wsApi from &#39;./api/wssocket&#39;;&#xA;&#xA;let wsUrl = &#39;ws://localhost:8878/im&#39;&#xA;let userId = 1;&#xA;wsApi.createWebSocket(wsUrl , userId);&#xA;wsApi.onopen(() =&amp;gt; {&#xA;    // 连接打开&#xA;    console.log(&#34;连接成功&#34;);&#xA;});&#xA;wsApi.onmessage((cmd,messageInfo) =&amp;gt; {&#xA;    if (cmd == 2) {&#xA;    &#x9;// 异地登录，强制下线&#xA;    &#x9;console.log(&#34;您已在其他地方登陆，将被强制下线&#34;);&#xA;    } else if (cmd == 3) {&#xA;    &#x9;// 私聊消息&#xA;    &#x9;console.log(messageInfo);&#xA;    } else if (cmd == 4) {&#xA;    &#x9;// 群聊消息&#xA;    &#x9;console.log(messageInfo);&#xA;    }&#xA;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;联系方式&lt;/h4&gt; &#xA;&lt;h4&gt;点下star吧&lt;/h4&gt; &#xA;&lt;p&gt;喜欢的朋友麻烦点个star，鼓励一下作者吧！&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>spotbugs/spotbugs</title>
    <updated>2023-07-26T01:36:37Z</updated>
    <id>tag:github.com,2023-07-26:/spotbugs/spotbugs</id>
    <link href="https://github.com/spotbugs/spotbugs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SpotBugs is FindBugs&#39; successor. A tool for static analysis to look for bugs in Java code.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img src=&#34;https://spotbugs.github.io/images/logos/spotbugs_logo_300px.png&#34; alt=&#34;SpotBugs&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/spotbugs/spotbugs/actions&#34;&gt;&lt;img src=&#34;https://github.com/spotbugs/spotbugs/workflows/build/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://spotbugs.readthedocs.io/en/latest/?badge=latest&#34;&gt;&lt;img src=&#34;https://readthedocs.org/projects/spotbugs/badge/?version=latest&#34; alt=&#34;Documentation Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/component_measures?id=com.github.spotbugs.spotbugs&amp;amp;metric=coverage&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?branch=release-3.1&amp;amp;project=com.github.spotbugs.spotbugs&amp;amp;metric=coverage&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/com.github.spotbugs/spotbugs&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/com.github.spotbugs/spotbugs/badge.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://javadoc.io/doc/com.github.spotbugs/spotbugs&#34;&gt;&lt;img src=&#34;http://javadoc.io/badge/com.github.spotbugs/spotbugs.svg?sanitize=true&#34; alt=&#34;Javadocs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://spotbugs.github.io/&#34;&gt;SpotBugs&lt;/a&gt; is the spiritual successor of &lt;a href=&#34;https://github.com/findbugsproject/findbugs&#34;&gt;FindBugs&lt;/a&gt;, carrying on from the point where it left off with support of its community.&lt;/p&gt; &#xA;&lt;p&gt;SpotBugs is licensed under the &lt;a href=&#34;https://github.com/spotbugs/spotbugs/raw/master/spotbugs/licenses/LICENSE.txt&#34;&gt;GNU LESSER GENERAL PUBLIC LICENSE&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;More information at the &lt;a href=&#34;https://spotbugs.github.io/&#34;&gt;official website&lt;/a&gt;. A lot of things can still be found at the &lt;a href=&#34;http://findbugs.sourceforge.net&#34;&gt;old FindBugs website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Build&lt;/h1&gt; &#xA;&lt;p&gt;SpotBugs is built using &lt;a href=&#34;https://gradle.org&#34;&gt;Gradle&lt;/a&gt;. The recommended way to obtain it is to simply run the &lt;code&gt;gradlew&lt;/code&gt; (or &lt;code&gt;gradlew.bat&lt;/code&gt;) wrapper, which will automatically download and run the correct version as needed (using the settings in &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;To see a list of build options, run &lt;code&gt;gradle tasks&lt;/code&gt; (or &lt;code&gt;gradlew tasks&lt;/code&gt;). The &lt;code&gt;build&lt;/code&gt; task will perform a full build and test.&lt;/p&gt; &#xA;&lt;p&gt;To build the SpotBugs plugin for Eclipse, you&#39;ll need to create the file &lt;code&gt;eclipsePlugin/local.properties&lt;/code&gt;, containing a property &lt;code&gt;eclipseRoot.dir&lt;/code&gt; that points to an Eclipse installation&#39;s root directory (see &lt;code&gt;.travis.yml&lt;/code&gt; for an example), then run the build. To prepare Eclipse environment only, run &lt;code&gt;./gradlew eclipse&lt;/code&gt;. See also &lt;a href=&#34;https://github.com/spotbugs/spotbugs/raw/release-3.1/eclipsePlugin/doc/building_spotbugs_plugin.txt&#34;&gt;detailed steps&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Using SpotBugs&lt;/h1&gt; &#xA;&lt;p&gt;SpotBugs can be used standalone and through several integrations, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://spotbugs.readthedocs.io/en/latest/ant.html&#34;&gt;Ant&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://spotbugs.readthedocs.io/en/latest/maven.html&#34;&gt;Maven&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://spotbugs.readthedocs.io/en/latest/gradle.html&#34;&gt;Gradle&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://spotbugs.readthedocs.io/en/latest/eclipse.html&#34;&gt;Eclipse&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JetBrains/spotbugs-intellij-plugin&#34;&gt;IntelliJ IDEA&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Questions?&lt;/h1&gt; &#xA;&lt;p&gt;You can contact us using &lt;a href=&#34;https://github.com/spotbugs/spotbugs/discussions&#34;&gt;GitHub Discussions&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>linyimin0812/spring-startup-analyzer</title>
    <updated>2023-07-26T01:36:37Z</updated>
    <id>tag:github.com,2023-07-26:/linyimin0812/spring-startup-analyzer</id>
    <link href="https://github.com/linyimin0812/spring-startup-analyzer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Spring Startup Analyzer generates an interactive Spring application startup report that lets you understand what contributes to the application startup time and helps to optimize it.🚀&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/linyimin0812/spring-startup-analyzer&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/linyimin0812/spring-startup-analyzer&#34; alt=&#34;license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://search.maven.org/search?q=g:io.github.linyimin0812&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/io.github.linyimin0812/spring-profiler-starter.svg?sanitize=true&#34; alt=&#34;maven&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/project/overview?id=linyimin0812_spring-startup-analyzer&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=linyimin0812_spring-startup-analyzer&amp;amp;metric=alert_status&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/new_code?id=linyimin0812_spring-startup-analyzer&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=linyimin0812_spring-startup-analyzer&amp;amp;metric=bugs&#34; alt=&#34;Bugs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/new_code?id=linyimin0812_spring-startup-analyzer&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=linyimin0812_spring-startup-analyzer&amp;amp;metric=code_smells&#34; alt=&#34;Code Smells&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/new_code?id=linyimin0812_spring-startup-analyzer&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=linyimin0812_spring-startup-analyzer&amp;amp;metric=ncloc&#34; alt=&#34;Lines of Code&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/new_code?id=linyimin0812_spring-startup-analyzer&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=linyimin0812_spring-startup-analyzer&amp;amp;metric=coverage&#34; alt=&#34;Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/new_code?id=linyimin0812_spring-startup-analyzer&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=linyimin0812_spring-startup-analyzer&amp;amp;metric=reliability_rating&#34; alt=&#34;Reliability Rating&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/README.md&#34;&gt;ENGLISH&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/README_ZH.md&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#highlight&#34;&gt;🤩Highlight&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#spring-startup-analysis-report&#34;&gt;📈Spring Startup Analysis Report&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#optimization-of-spring-startup&#34;&gt;🚀Optimization of Spring Startup&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#spring-startup-data-collection&#34;&gt;📈Spring Startup Data Collection&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#configuration&#34;&gt;Configuration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#application-startup&#34;&gt;Application Startup&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#custom-extension&#34;&gt;Custom extension&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#optimization-of-spring-startup-1&#34;&gt;🚀Optimization of Spring Startup&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#types-of-bean-for-async&#34;&gt;Types of Bean for Async&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Spring Startup Ananlyzer&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Spring Startup Analyzer&lt;/strong&gt; generates an interactive Spring application startup report that lets you understand what contributes to the application startup time and helps to optimize it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://linyimin-blog.oss-cn-beijing.aliyuncs.com/spring-satrtup-analyzer/hokage-20230618000928-192.168.0.101-analyzer.html&#34;&gt;analyzer report demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;🤩Highlight&lt;/h1&gt; &#xA;&lt;h2&gt;📈Spring Startup Analysis Report&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Spring Bean Initialization Details&lt;/strong&gt; support for initialization time/beanName search, &lt;strong&gt;Spring Bean Initialization Timeline&lt;/strong&gt;, &lt;strong&gt;Method Invocation Count and Time Statistics&lt;/strong&gt;(support for custom methods), &lt;strong&gt;Unused Jars&lt;/strong&gt;(to help optimize fat jars), and &lt;strong&gt;Application Startup Thread Wall Clock Profile&lt;/strong&gt;, helping developers quickly analyze and locate application startup bottlenecks.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Spring Bean Initialization Details&lt;/strong&gt; &lt;img src=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/docs/spring-bean-initialization.png&#34; alt=&#34;Spring Bean Initialization&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Spring Bean Initialization Timeline&lt;/strong&gt; &lt;img src=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/docs/spring-bean-timeline.png&#34; alt=&#34;Spring Bean Timeline&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Method Invocation Count and Time Statistics&lt;/strong&gt; &lt;img src=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/docs/details-of-method-invoke.png&#34; alt=&#34;Details of Method Invoke&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Unused Jars&lt;/strong&gt; &lt;img src=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/docs/unused-jars.png&#34; alt=&#34;Unused Jars&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Application Startup Thread Wall Clock Profile&lt;/strong&gt; &lt;img src=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/docs/full-flame-graph.png&#34; alt=&#34;Flame Gragh&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;🚀Optimization of Spring Startup&lt;/h2&gt; &#xA;&lt;p&gt;Provide a Spring Bean asynchronous initialization jar package, which asynchronously executes the &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;@PostConstruct&lt;/code&gt; methods for beans with longer initialization time to improve application startup speed.&lt;/p&gt; &#xA;&lt;h1&gt;📈Spring Startup Data Collection&lt;/h1&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Provides two installation methods: &lt;strong&gt;manual installation&lt;/strong&gt; and &lt;strong&gt;one-click script installation&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;1. Manual Installation&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Click &lt;a href=&#34;https://github.com/linyimin0812/spring-startup-analyzer/releases/download/v2.0.4/spring-startup-analyzer.tar.gz&#34;&gt;realease&lt;/a&gt; to download the latest version tar.gz package&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a new folder and extract the files&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir -p ${HOME}/spring-startup-analyzer&#xA;cd download_path&#xA;tar -zxvf spring-startup-analyzer.tar.gz ${HOME}/spring-startup-analyzer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;2. Shell script installation&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -sS https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/bin/install.sh | sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Configure the startup parameters, for example, to set the timeout to 30 minutes: &lt;code&gt;-Dspring-startup-analyzer.app.health.check.timeout=30&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Please make sure to configure the &lt;code&gt;spring-startup-analyzer.app.health.check.endpoints option&lt;/code&gt;. Otherwise, the data collection will continue until the application startup check times out (default is 20 minutes). It will make a request to the endpoint every 1 second, and if the response header status code is 200, it will consider the application startup as completed.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;configuration option&lt;/th&gt; &#xA;   &lt;th&gt;description&lt;/th&gt; &#xA;   &lt;th&gt;default value&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;spring-startup-analyzer.app.health.check.timeout&lt;/td&gt; &#xA;   &lt;td&gt;application startup check timeout time in minutes&lt;/td&gt; &#xA;   &lt;td&gt;20&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;spring-startup-analyzer.app.health.check.endpoints&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;application startup success check URL(s), multiple URLs can be configured, separated by commas&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;http://127.0.0.1:7002/actuator/health&#34;&gt;http://127.0.0.1:7002/actuator/health&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;spring-startup-analyzer.admin.http.server.port&lt;/td&gt; &#xA;   &lt;td&gt;management port&lt;/td&gt; &#xA;   &lt;td&gt;8065&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;spring-startup-analyzer.async.profiler.sample.thread.names&lt;/td&gt; &#xA;   &lt;td&gt;thread names collected by Async Profiler, supports multiple configurations separated by commas&lt;/td&gt; &#xA;   &lt;td&gt;main&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;spring-startup-analyzer.async.profiler.interval.millis&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;async profiler sample interval (ms)&lt;/td&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Application Startup&lt;/h2&gt; &#xA;&lt;p&gt;This project is started as an agent, so you can add the parameter -javaagent:$HOME/spring-startup-analyzer/lib/spring-profiler-agent.jar to the startup command. If you are starting the application using the java command line, add it to the command line. If you are starting it in IntelliJ IDEA, you need to add it to the VM options in the settings.&lt;/p&gt; &#xA;&lt;p&gt;Path of logs：&lt;code&gt;$HOME/spring-startup-analyzer/logs&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;startup.log: log of startup&lt;/li&gt; &#xA; &lt;li&gt;transform.log: log of re-transform class&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After the application has finished starting, the message &lt;code&gt;======= spring-startup-analyzer finished, click http://localhost:8065 to visit details. ======&lt;/code&gt; will be printed in the console and startup.log file. You can use this output to determine if the profiling has completed successfully&lt;/p&gt; &#xA;&lt;h2&gt;Custom extension&lt;/h2&gt; &#xA;&lt;p&gt;Translation: If you want to customize the profiling capabilities, you need to include the &lt;code&gt;spring-profiler-starter&lt;/code&gt; pom as the parent pom for your extension project. Then, you can use the interfaces exposed by the project for extension purposes. For more details, you can refer to the implementation of&lt;a href=&#34;https://github.com/linyimin-bupt/spring-startup-analyzer/tree/main/spring-profiler-extension&#34;&gt;spring-profiler-extension&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;parent&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;io.github.linyimin0812&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;spring-profiler-starter&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;latest_version&amp;lt;/version&amp;gt;&#xA;&amp;lt;/parent&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Extension Interfaces&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary style=&#34;cursor: pointer&#34;&gt;io.github.linyimin0812.profiler.api.EventListener&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface EventListener extends Startable {&#xA;&#xA;    /**&#xA;     * Invocation during application startup&#xA;     */&#xA;    void start();&#xA;&#xA;    /**&#xA;     * Invocation after application startup completion&#xA;     */&#xA;    void stop();&#xA;    &#xA;    /**&#xA;     * class need to be enhance&#xA;     * @param className&#xA;&#xA;     * @return true: enhance, false: not enhance&#xA;     */&#xA;    boolean filter(String className);&#xA;&#xA;    /**&#xA;     * Methods to be enhanced (This method relies on the filter(className) condition. It will only be executed if filter(className) returns true.)&#xA;     * @param methodName&#xA;     * @param methodTypes&#xA;     * @return true: enhance, false: not enhance&#xA;     */&#xA;    default boolean filter(String methodName, String[] methodTypes) {&#xA;        return true;&#xA;    }&#xA;&#xA;    /**&#xA;     * Event response processing logic&#xA;     * @param event fire  event&#xA;     */&#xA;    void onEvent(Event event);&#xA;&#xA;    /**&#xA;     * events to listen&#xA;     * @return events need to be listened&#xA;     */&#xA;    List&amp;lt;Event.Type&amp;gt; listen();&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;The &lt;code&gt;start()&lt;/code&gt; and &lt;code&gt;stop()&lt;/code&gt; methods represent the lifecycle of the system, called respectively at the beginning and completion of application startup. The &lt;code&gt;filter()&lt;/code&gt; method specifies the classes/methods that need to be enhanced. The &lt;code&gt;listen()&lt;/code&gt; method specifies the events to listen for, including &lt;code&gt;method enter&lt;/code&gt; and &lt;code&gt;method return&lt;/code&gt; events. The &lt;code&gt;onEvent()&lt;/code&gt; method is called when the listened events occur.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following is an extension that counts the number of invocations of the java.net.URLClassLoader.findResource(String) method during the application startup process:&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary style=&#34;cursor: pointer&#34;&gt;FindResourceCounter demo&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@MetaInfServices&#xA;public class FindResourceCounter implements EventListener {&#xA;&#xA;    private final AtomicLong COUNT = new AtomicLong(0);&#xA;&#xA;    @Override&#xA;    public boolean filter(String className) {&#xA;        return &#34;java.net.URLClassLoader&#34;.equals(className);&#xA;    }&#xA;&#xA;    @Override&#xA;    public boolean filter(String methodName, String[] methodTypes) {&#xA;       if (!&#34;findResource&#34;.equals(methodName)) {&#xA;           return false;&#xA;       }&#xA;&#xA;       return methodTypes != null &amp;amp;&amp;amp; methodTypes.length == 1 &amp;amp;&amp;amp; &#34;java.lang.String&#34;.equals(methodTypes[0]);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onEvent(Event event) {&#xA;        if (event instanceof AtEnterEvent) {&#xA;            // enter findResource method&#xA;        } else if (event instanceof AtExitEvent) {&#xA;            // findResource return&#xA;        }&#xA;&#xA;        //  counts the number of invocations&#xA;        COUNT.incrementAndGet();&#xA;&#xA;    }&#xA;&#xA;    @Override&#xA;    public List&amp;lt;Event.Type&amp;gt; listen() {&#xA;        return Arrays.asList(Event.Type.AT_ENTER, Event.Type.AT_EXIT);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void start() {&#xA;        System.out.println(&#34;============== my extension start =============&#34;);&#xA;    }&#xA;&#xA;    @Override&#xA;    public void stop() {&#xA;        System.out.println(&#34;============== my extension end =============&#34;);&#xA;        System.out.println(&#34;findResource count: &#34; + COUNT.get());&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;It is important to note that &lt;strong&gt;the implementation of the EventListener interface should be annotated with @MetaInfServices&lt;/strong&gt;. This is because the extension interface is loaded through the Service Provider Interface (SPI). When you use the &lt;code&gt;@MetaInfServices&lt;/code&gt; annotation, the implementation class will be automatically written to the &lt;code&gt;META-INF/services/io.github.linyimin0812.profiler.api.EventListener&lt;/code&gt; file during the code compilation process. If you don&#39;t use the &lt;code&gt;@MetaInfServices&lt;/code&gt; annotation, you need to manually write the fully qualified name of the implementation class into the META-INF/services/io.github.linyimin0812.profiler.api.EventListener file`. Otherwise, the extension implementation will not be loaded.&lt;/p&gt; &#xA;&lt;h3&gt;Package &amp;amp; Run&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;spring-profiler-starter&lt;/code&gt; pom already defines a packaging plugin that will by default copy the generated JAR file to the &lt;code&gt;$HOME/spring-startup-analyzer/extension&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mvn clean package&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you have installed this project by following the steps in the &lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#22-Installation&#34;&gt;Installation&lt;/a&gt; section, you can execute the packaging command mentioned above. After the packaging is complete, you can start the application as described in the &lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#24-application-startup&#34;&gt;Application Startup&lt;/a&gt; section to load the extension JAR file.&lt;/p&gt; &#xA;&lt;h1&gt;🚀Optimization of Spring Startup&lt;/h1&gt; &#xA;&lt;p&gt;From the &lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#spring-startup-analysis-report&#34;&gt;Application startup data collection&lt;/a&gt;section, you can obtain the Beans that have long initialization time. Since the Spring startup process is single-threaded, to optimize the application startup time, you can consider making the initialization methods of these time-consuming Beans asynchronous.&lt;/p&gt; &#xA;&lt;p&gt;NOTE:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;It is advisable to prioritize optimizing the code of Beans to fundamentally address the issue of long initialization time&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;For Beans with long initialization time in second-party or third-party packages (where code optimization is not possible), consider asynchronous initialization of those Beans.&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;For Beans that are not dependent on other Beans, you can confidently proceed with asynchronous initialization&lt;/strong&gt;，You can determine if a Bean is dependent on other Beans by examining the &lt;code&gt;Root Bean&lt;/code&gt; in &lt;a href=&#34;https://raw.githubusercontent.com/linyimin0812/spring-startup-analyzer/main/#11-application-startup-data-collection&#34;&gt;Loading time of Beans&lt;/a&gt; session&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Careful analysis is required for Beans that are dependent on other Beans. They should not be called by other Beans during the application startup process, as it may lead to issues&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Types of Bean for Async&lt;/h2&gt; &#xA;&lt;p&gt;Supports initialization of beans through @Bean, @PostConstruct, and @ImportResource. demo: &lt;a href=&#34;https://github.com/linyimin0812/spring-boot-async-bean-demo&#34;&gt;spring-boot-async-bean-demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Bean annotated with &lt;code&gt;@Bean(initMethod = &#34;init&#34;)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean(initMethod = &#34;init&#34;)&#xA;public TestBean testBean() {&#xA;    return new TestBean();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Bean annotated with &lt;code&gt;@PostConstruct&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component&#xA;public class TestComponent {&#xA;    @PostConstruct&#xA;    public void init() throws InterruptedException {&#xA;        Thread.sleep(20 * 1000);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Import Dependency&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;io.github.linyimin0812&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;spring-async-bean-starter&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;${latest_version}&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Configuration&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;# Asynchronous beans may be at the end of the Spring bean initialization order, which may result in suboptimal effects of asynchronous optimization. Open the configuration to prioritize loading asynchronous beans.&#xA;spring-startup-analyzer.boost.spring.async.bean-priority-load-enable=true&#xA;# name of bean to async init&#xA;spring-startup-analyzer.boost.spring.async.bean-names=testBean,testComponent&#xA;# init bean thread pool core size&#xA;spring-startup-analyzer.boost.spring.async.init-bean-thread-pool-core-size=8&#xA;# init bean thread pool max size&#xA;spring-startup-analyzer.boost.spring.async.init-bean-thread-pool-max-size=8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Check if the bean is initialized asynchronously&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;View the log in the $HOME/spring-startup-analyzer/logs/startup.log file. For asynchronously initialized methods, a log entry will be written in the following format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;async-init-bean, beanName: ${beanName}, async init method: ${initMethodName}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>