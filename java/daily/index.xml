<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-03T01:33:07Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>openid/AppAuth-Android</title>
    <updated>2022-12-03T01:33:07Z</updated>
    <id>tag:github.com,2022-12-03:/openid/AppAuth-Android</id>
    <link href="https://github.com/openid/AppAuth-Android" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Android client SDK for communicating with OAuth 2.0 and OpenID Connect providers.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://rawgit.com/openid/AppAuth-Android/master/appauth_lockup.svg?sanitize=true&#34; alt=&#34;AppAuth for Android&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://search.maven.org/search?q=g:net.openid%20appauth&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/net.openid/appauth&#34; alt=&#34;Download&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://javadoc.io/doc/net.openid/appauth&#34;&gt;&lt;img src=&#34;http://javadoc.io/badge/net.openid/appauth.svg?sanitize=true&#34; alt=&#34;Javadocs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/openid/AppAuth-Android/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/openid/AppAuth-Android/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/github/openid/AppAuth-Android?branch=master&#34;&gt;&lt;img src=&#34;https://codecov.io/github/openid/AppAuth-Android/coverage.svg?branch=master&#34; alt=&#34;codecov.io&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;AppAuth for Android is a client SDK for communicating with &lt;a href=&#34;https://tools.ietf.org/html/rfc6749&#34;&gt;OAuth 2.0&lt;/a&gt; and &lt;a href=&#34;http://openid.net/specs/openid-connect-core-1_0.html&#34;&gt;OpenID Connect&lt;/a&gt; providers. It strives to directly map the requests and responses of those specifications, while following the idiomatic style of the implementation language. In addition to mapping the raw protocol flows, convenience methods are available to assist with common tasks like performing an action with fresh tokens.&lt;/p&gt; &#xA;&lt;p&gt;The library follows the best practices set out in &lt;a href=&#34;https://tools.ietf.org/html/rfc8252&#34;&gt;RFC 8252 - OAuth 2.0 for Native Apps&lt;/a&gt;, including using &lt;a href=&#34;https://developer.chrome.com/multidevice/android/customtabs&#34;&gt;Custom Tabs&lt;/a&gt; for authorization requests. For this reason, &lt;code&gt;WebView&lt;/code&gt; is explicitly &lt;em&gt;not&lt;/em&gt; supported due to usability and security reasons.&lt;/p&gt; &#xA;&lt;p&gt;The library also supports the &lt;a href=&#34;https://tools.ietf.org/html/rfc7636&#34;&gt;PKCE&lt;/a&gt; extension to OAuth which was created to secure authorization codes in public clients when custom URI scheme redirects are used. The library is friendly to other extensions (standard or otherwise) with the ability to handle additional parameters in all protocol requests and responses.&lt;/p&gt; &#xA;&lt;p&gt;A talk providing an overview of using the library for enterprise single sign-on (produced by Google) can be found here: &lt;a href=&#34;https://www.youtube.com/watch?v=DdQTXrk6YTk&#34;&gt;Enterprise SSO with Chrome Custom Tabs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;AppAuth for Android is available on &lt;a href=&#34;https://search.maven.org/search?q=g:net.openid%20appauth&#34;&gt;MavenCentral&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;implementation &#39;net.openid:appauth:&amp;lt;version&amp;gt;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;AppAuth supports Android API 16 (Jellybean) and above. Browsers which provide a custom tabs implementation are preferred by the library, but not required. Both Custom URI Schemes (all supported versions of Android) and App Links (Android M / API 23+) can be used with the library.&lt;/p&gt; &#xA;&lt;p&gt;In general, AppAuth can work with any Authorization Server (AS) that supports native apps as documented in &lt;a href=&#34;https://tools.ietf.org/html/rfc8252&#34;&gt;RFC 8252&lt;/a&gt;, either through custom URI scheme redirects, or App Links. AS&#39;s that assume all clients are web-based or require clients to maintain confidentiality of the client secrets may not work well.&lt;/p&gt; &#xA;&lt;h2&gt;Demo app&lt;/h2&gt; &#xA;&lt;p&gt;A demo app is contained within this repository. For instructions on how to build and configure this app, see the &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/app/README.md&#34;&gt;demo app readme&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Conceptual overview&lt;/h2&gt; &#xA;&lt;p&gt;AppAuth encapsulates the authorization state of the user in the &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthState.java&#34;&gt;net.openid.appauth.AuthState&lt;/a&gt; class, and communicates with an authorization server through the use of the &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthorizationService.java&#34;&gt;net.openid.appauth.AuthorizationService&lt;/a&gt; class. AuthState is designed to be easily persistable as a JSON string, using the storage mechanism of your choice (e.g. &lt;a href=&#34;https://developer.android.com/training/basics/data-storage/shared-preferences.html&#34;&gt;SharedPreferences&lt;/a&gt;, &lt;a href=&#34;https://developer.android.com/training/basics/data-storage/databases.html&#34;&gt;sqlite&lt;/a&gt;, or even just &lt;a href=&#34;https://developer.android.com/training/basics/data-storage/files.html&#34;&gt;in a file&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;AppAuth provides data classes which are intended to model the OAuth2 specification as closely as possible; this provides the greatest flexibility in interacting with a wide variety of OAuth2 and OpenID Connect implementations.&lt;/p&gt; &#xA;&lt;p&gt;Authorizing the user occurs via the user&#39;s web browser, and the request is described using instances of &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthorizationRequest.java&#34;&gt;AuthorizationRequest&lt;/a&gt;. The request is dispatched using &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthorizationService.java#L159&#34;&gt;performAuthorizationRequest()&lt;/a&gt; on an AuthorizationService instance, and the response (an &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthorizationResponse.java&#34;&gt;AuthorizationResponse&lt;/a&gt; instance) will be dispatched to the activity of your choice, expressed via an Intent.&lt;/p&gt; &#xA;&lt;p&gt;Token requests, such as obtaining a new access token using a refresh token, follow a similar pattern: &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/TokenRequest.java&#34;&gt;TokenRequest&lt;/a&gt; instances are dispatched using &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthorizationService.java#L252&#34;&gt;performTokenRequest()&lt;/a&gt; on an AuthorizationService instance, and a &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/TokenResponse.java&#34;&gt;TokenResponse&lt;/a&gt; instance is returned via a callback.&lt;/p&gt; &#xA;&lt;p&gt;Responses can be provided to the &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthState.java#L367&#34;&gt;update()&lt;/a&gt; methods on AuthState in order to track and persist changes to the authorization state. Once in an authorized state, the &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthState.java#L449&#34;&gt;performActionWithFreshTokens()&lt;/a&gt; method on AuthState can be used to automatically refresh access tokens as necessary before performing actions that require valid tokens.&lt;/p&gt; &#xA;&lt;h2&gt;Implementing the authorization code flow&lt;/h2&gt; &#xA;&lt;p&gt;It is recommended that native apps use the &lt;a href=&#34;https://tools.ietf.org/html/rfc6749#section-1.3.1&#34;&gt;authorization code&lt;/a&gt; flow with a public client to gain authorization to access user data. This has the primary advantage for native clients that the authorization flow, which must occur in a browser, only needs to be performed once.&lt;/p&gt; &#xA;&lt;p&gt;This flow is effectively composed of four stages:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Discovering or specifying the endpoints to interact with the provider.&lt;/li&gt; &#xA; &lt;li&gt;Authorizing the user, via a browser, in order to obtain an authorization code.&lt;/li&gt; &#xA; &lt;li&gt;Exchanging the authorization code with the authorization server, to obtain a refresh token and/or ID token.&lt;/li&gt; &#xA; &lt;li&gt;Using access tokens derived from the refresh token to interact with a resource server for further access to user data.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;At each step of the process, an AuthState instance can (optionally) be updated with the result to help with tracking the state of the flow.&lt;/p&gt; &#xA;&lt;h3&gt;Authorization service configuration&lt;/h3&gt; &#xA;&lt;p&gt;First, AppAuth must be instructed how to interact with the authorization service. This can be done either by directly creating an &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthorizationServiceConfiguration.java#L102&#34;&gt;AuthorizationServiceConfiguration&lt;/a&gt; instance, or by retrieving an OpenID Connect discovery document.&lt;/p&gt; &#xA;&lt;p&gt;Directly specifying an AuthorizationServiceConfiguration involves providing the URIs of the authorization endpoint and token endpoint, and optionally a dynamic client registration endpoint (see &#34;Dynamic client registration&#34; for more info):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AuthorizationServiceConfiguration serviceConfig =&#xA;    new AuthorizationServiceConfiguration(&#xA;        Uri.parse(&#34;https://idp.example.com/auth&#34;), // authorization endpoint&#xA;        Uri.parse(&#34;https://idp.example.com/token&#34;)); // token endpoint&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where available, using an OpenID Connect discovery document is preferable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AuthorizationServiceConfiguration.fetchFromIssuer(&#xA;    Uri.parse(&#34;https://idp.example.com&#34;),&#xA;    new AuthorizationServiceConfiguration.RetrieveConfigurationCallback() {&#xA;      public void onFetchConfigurationCompleted(&#xA;          @Nullable AuthorizationServiceConfiguration serviceConfiguration,&#xA;          @Nullable AuthorizationException ex) {&#xA;        if (ex != null) {&#xA;          Log.e(TAG, &#34;failed to fetch configuration&#34;);&#xA;          return;&#xA;        }&#xA;&#xA;        // use serviceConfiguration as needed&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will attempt to download a discovery document from the standard location under this base URI, &lt;code&gt;https://idp.example.com/.well-known/openid-configuration&lt;/code&gt;. If the discovery document for your IDP is in some other non-standard location, you can instead provide the full URI as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AuthorizationServiceConfiguration.fetchFromUrl(&#xA;    Uri.parse(&#34;https://idp.example.com/exampletenant/openid-config&#34;),&#xA;    new AuthorizationServiceConfiguration.RetrieveConfigurationCallback() {&#xA;        ...&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If desired, this configuration can be used to seed an AuthState instance, to persist the configuration easily:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AuthState authState = new AuthState(serviceConfig);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Obtaining an authorization code&lt;/h3&gt; &#xA;&lt;p&gt;An authorization code can now be acquired by constructing an AuthorizationRequest, using its Builder. In AppAuth, the builders for each data class accept the mandatory parameters via the builder constructor:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AuthorizationRequest.Builder authRequestBuilder =&#xA;    new AuthorizationRequest.Builder(&#xA;        serviceConfig, // the authorization service configuration&#xA;        MY_CLIENT_ID, // the client ID, typically pre-registered and static&#xA;        ResponseTypeValues.CODE, // the response_type value: we want a code&#xA;        MY_REDIRECT_URI); // the redirect URI to which the auth response is sent&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other optional parameters, such as the OAuth2 &lt;a href=&#34;https://tools.ietf.org/html/rfc6749#section-3.3&#34;&gt;scope string&lt;/a&gt; or OpenID Connect &lt;a href=&#34;http://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.1&#34;&gt;login hint&lt;/a&gt; are specified through set methods on the builder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AuthorizationRequest authRequest = authRequestBuilder&#xA;    .setScope(&#34;openid email profile https://idp.example.com/custom-scope&#34;)&#xA;    .setLoginHint(&#34;jdoe@user.example.com&#34;)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This request can then be dispatched using one of two approaches.&lt;/p&gt; &#xA;&lt;p&gt;a &lt;code&gt;startActivityForResult&lt;/code&gt; call using an Intent returned from the &lt;code&gt;AuthorizationService&lt;/code&gt;, or by calling &lt;code&gt;performAuthorizationRequest&lt;/code&gt; and providing pending intent for completion and cancelation handling activities.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;startActivityForResult&lt;/code&gt; approach is simpler to use but may require more processing of the result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void doAuthorization() {&#xA;  AuthorizationService authService = new AuthorizationService(this);&#xA;  Intent authIntent = authService.getAuthorizationRequestIntent(authRequest);&#xA;  startActivityForResult(authIntent, RC_AUTH);&#xA;}&#xA;&#xA;@Override&#xA;protected void onActivityResult(int requestCode, int resultCode, Intent data) {&#xA;  if (requestCode == RC_AUTH) {&#xA;    AuthorizationResponse resp = AuthorizationResponse.fromIntent(data);&#xA;    AuthorizationException ex = AuthorizationException.fromIntent(data);&#xA;    // ... process the response or exception ...&#xA;  } else {&#xA;    // ...&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If instead you wish to directly transition to another activity on completion or cancelation, you can use &lt;code&gt;performAuthorizationRequest&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AuthorizationService authService = new AuthorizationService(this);&#xA;&#xA;authService.performAuthorizationRequest(&#xA;    authRequest,&#xA;    PendingIntent.getActivity(this, 0, new Intent(this, MyAuthCompleteActivity.class), 0),&#xA;    PendingIntent.getActivity(this, 0, new Intent(this, MyAuthCanceledActivity.class), 0));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The intents may be customized to carry any additional data or flags required for the correct handling of the authorization response.&lt;/p&gt; &#xA;&lt;h4&gt;Capturing the authorization redirect&lt;/h4&gt; &#xA;&lt;p&gt;Once the authorization flow is completed in the browser, the authorization service will redirect to a URI specified as part of the authorization request, providing the response via query parameters. In order for your app to capture this response, it must register with the Android OS as a handler for this redirect URI.&lt;/p&gt; &#xA;&lt;p&gt;We recommend using a custom scheme based redirect URI (i.e. those of form &lt;code&gt;my.scheme:/path&lt;/code&gt;), as this is the most widely supported across all versions of Android. To avoid conflicts with other apps, it is recommended to configure a distinct scheme using &#34;reverse domain name notation&#34;. This can either match your service web domain (in reverse) e.g. &lt;code&gt;com.example.service&lt;/code&gt; or your package name &lt;code&gt;com.example.app&lt;/code&gt; or be something completely new as long as it&#39;s distinct enough. Using the package name of your app is quite common but it&#39;s not always possible if it contains illegal characters for URI schemes (like underscores) or if you already have another handler for that scheme - so just use something else.&lt;/p&gt; &#xA;&lt;p&gt;When a custom scheme is used, AppAuth can be easily configured to capture all redirects using this custom scheme through a manifest placeholder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;android.defaultConfig.manifestPlaceholders = [&#xA;  &#39;appAuthRedirectScheme&#39;: &#39;com.example.app&#39;&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, the redirect URI can be directly configured by adding an intent-filter for AppAuth&#39;s RedirectUriReceiverActivity to your AndroidManifest.xml:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;activity&#xA;        android:name=&#34;net.openid.appauth.RedirectUriReceiverActivity&#34;&#xA;        tools:node=&#34;replace&#34;&amp;gt;&#xA;    &amp;lt;intent-filter&amp;gt;&#xA;        &amp;lt;action android:name=&#34;android.intent.action.VIEW&#34;/&amp;gt;&#xA;        &amp;lt;category android:name=&#34;android.intent.category.DEFAULT&#34;/&amp;gt;&#xA;        &amp;lt;category android:name=&#34;android.intent.category.BROWSABLE&#34;/&amp;gt;&#xA;        &amp;lt;data android:scheme=&#34;com.example.app&#34;/&amp;gt;&#xA;    &amp;lt;/intent-filter&amp;gt;&#xA;&amp;lt;/activity&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If an HTTPS redirect URI is required instead of a custom scheme, the same approach (modifying your AndroidManifest.xml) is used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;activity&#xA;        android:name=&#34;net.openid.appauth.RedirectUriReceiverActivity&#34;&#xA;        tools:node=&#34;replace&#34;&amp;gt;&#xA;    &amp;lt;intent-filter&amp;gt;&#xA;        &amp;lt;action android:name=&#34;android.intent.action.VIEW&#34;/&amp;gt;&#xA;        &amp;lt;category android:name=&#34;android.intent.category.DEFAULT&#34;/&amp;gt;&#xA;        &amp;lt;category android:name=&#34;android.intent.category.BROWSABLE&#34;/&amp;gt;&#xA;        &amp;lt;data android:scheme=&#34;https&#34;&#xA;              android:host=&#34;app.example.com&#34;&#xA;              android:path=&#34;/oauth2redirect&#34;/&amp;gt;&#xA;    &amp;lt;/intent-filter&amp;gt;&#xA;&amp;lt;/activity&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;HTTPS redirects can be secured by configuring the redirect URI as an &lt;a href=&#34;https://developer.android.com/training/app-links/index.html&#34;&gt;app link&lt;/a&gt; in Android M and above. We recommend that a fallback page be configured at the same address to forward authorization responses to your app via a custom scheme, for older Android devices.&lt;/p&gt; &#xA;&lt;h4&gt;Handling the authorization response&lt;/h4&gt; &#xA;&lt;p&gt;Upon completion of the authorization flow, the completion Intent provided to performAuthorizationRequest will be triggered. The authorization response is provided to this activity via Intent extra data, which can be extracted using the &lt;code&gt;fromIntent()&lt;/code&gt; methods on AuthorizationResponse and AuthorizationException respectively:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onCreate(Bundle b) {&#xA;  AuthorizationResponse resp = AuthorizationResponse.fromIntent(getIntent());&#xA;  AuthorizationException ex = AuthorizationException.fromIntent(getIntent());&#xA;  if (resp != null) {&#xA;    // authorization completed&#xA;  } else {&#xA;    // authorization failed, check ex for more details&#xA;  }&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The response can be provided to the AuthState instance for easy persistence and further processing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;authState.update(resp, ex);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the full redirect URI is required in order to extract additional information that AppAuth does not provide, this is also provided to your activity:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onCreate(Bundle b) {&#xA;  // ...&#xA;  Uri redirectUri = getIntent().getData();&#xA;  // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Exchanging the authorization code&lt;/h3&gt; &#xA;&lt;p&gt;Given a successful authorization response carrying an authorization code, a token request can be made to exchange the code for a refresh token:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;authService.performTokenRequest(&#xA;    resp.createTokenExchangeRequest(),&#xA;    new AuthorizationService.TokenResponseCallback() {&#xA;      @Override public void onTokenRequestCompleted(&#xA;            TokenResponse resp, AuthorizationException ex) {&#xA;          if (resp != null) {&#xA;            // exchange succeeded&#xA;          } else {&#xA;            // authorization failed, check ex for more details&#xA;          }&#xA;        }&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The token response can also be used to update an AuthState instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;authState.update(resp, ex);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using access tokens&lt;/h3&gt; &#xA;&lt;p&gt;Finally, the retrieved access token can be used to interact with a resource server. This can be done directly, by extracting the access token from a token response. However, in most cases, it is simpler to use the &lt;code&gt;performActionWithFreshTokens&lt;/code&gt; utility method provided by AuthState:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;authState.performActionWithFreshTokens(service, new AuthStateAction() {&#xA;  @Override public void execute(&#xA;      String accessToken,&#xA;      String idToken,&#xA;      AuthorizationException ex) {&#xA;    if (ex != null) {&#xA;      // negotiation for fresh tokens failed, check ex for more details&#xA;      return;&#xA;    }&#xA;&#xA;    // use the access token to do something ...&#xA;  }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This also updates the AuthState object with current access, id, and refresh tokens. If you are storing your AuthState in persistent storage, you should write the updated copy in the callback to this method.&lt;/p&gt; &#xA;&lt;h3&gt;Ending current session&lt;/h3&gt; &#xA;&lt;p&gt;Given you have a logged in session and you want to end it. In that case you need to get:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AuthorizationServiceConfiguration&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;valid Open Id Token that you should get after authentication&lt;/li&gt; &#xA; &lt;li&gt;End of session URI that should be provided within you OpenId service config&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;First you have to build EndSessionRequest&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;EndSessionRequest endSessionRequest =&#xA;    new EndSessionRequest.Builder(authorizationServiceConfiguration)&#xA;        .setIdTokenHint(idToken)&#xA;        .setPostLogoutRedirectUri(endSessionRedirectUri)&#xA;        .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This request can then be dispatched using one of two approaches.&lt;/p&gt; &#xA;&lt;p&gt;a &lt;code&gt;startActivityForResult&lt;/code&gt; call using an Intent returned from the &lt;code&gt;AuthorizationService&lt;/code&gt;, or by calling &lt;code&gt;performEndSessionRequest&lt;/code&gt; and providing pending intent for completion and cancelation handling activities.&lt;/p&gt; &#xA;&lt;p&gt;The startActivityForResult approach is simpler to use but may require more processing of the result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void endSession() {&#xA;  AuthorizationService authService = new AuthorizationService(this);&#xA;  Intent endSessionItent = authService.getEndSessionRequestIntent(endSessionRequest);&#xA;  startActivityForResult(endSessionItent, RC_END_SESSION);&#xA;}&#xA;&#xA;@Override&#xA;protected void onActivityResult(int requestCode, int resultCode, Intent data) {&#xA;  if (requestCode == RC_END_SESSION) {&#xA;    EndSessionResonse resp = EndSessionResonse.fromIntent(data);&#xA;    AuthorizationException ex = AuthorizationException.fromIntent(data);&#xA;    // ... process the response or exception ...&#xA;  } else {&#xA;    // ...&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If instead you wish to directly transition to another activity on completion or cancelation, you can use &lt;code&gt;performEndSessionRequest&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AuthorizationService authService = new AuthorizationService(this);&#xA;&#xA;authService.performEndSessionRequest(&#xA;    endSessionRequest,&#xA;    PendingIntent.getActivity(this, 0, new Intent(this, MyAuthCompleteActivity.class), 0),&#xA;    PendingIntent.getActivity(this, 0, new Intent(this, MyAuthCanceledActivity.class), 0));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;End session flow will also work involving browser mechanism that is described in authorization mechanism session. Handling response mechanism with transition to another activity should be as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void onCreate(Bundle b) {&#xA; EndSessionResponse resp = EndSessionResponse.fromIntent(getIntent());&#xA; AuthorizationException ex = AuthorizationException.fromIntent(getIntent());&#xA; if (resp != null) {&#xA;   // authorization completed&#xA; } else {&#xA;   // authorization failed, check ex for more details&#xA; }&#xA; // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;AuthState persistence&lt;/h3&gt; &#xA;&lt;p&gt;Instances of &lt;code&gt;AuthState&lt;/code&gt; keep track of the authorization and token requests and responses. This is the only object that you need to persist to retain the authorization state of the session. Typically, one would do this by storing the authorization state in SharedPreferences or some other persistent store private to the app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NonNull public AuthState readAuthState() {&#xA;  SharedPreferences authPrefs = getSharedPreferences(&#34;auth&#34;, MODE_PRIVATE);&#xA;  String stateJson = authPrefs.getString(&#34;stateJson&#34;, null);&#xA;  if (stateJson != null) {&#xA;    return AuthState.jsonDeserialize(stateJson);&#xA;  } else {&#xA;    return new AuthState();&#xA;  }&#xA;}&#xA;&#xA;public void writeAuthState(@NonNull AuthState state) {&#xA;  SharedPreferences authPrefs = getSharedPreferences(&#34;auth&#34;, MODE_PRIVATE);&#xA;  authPrefs.edit()&#xA;      .putString(&#34;stateJson&#34;, state.jsonSerializeString())&#xA;      .apply();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The demo app has an &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/app/java/net/openid/appauthdemo/AuthStateManager.java&#34;&gt;AuthStateManager&lt;/a&gt; type which demonstrates this in more detail.&lt;/p&gt; &#xA;&lt;h2&gt;Advanced configuration&lt;/h2&gt; &#xA;&lt;p&gt;AppAuth provides some advanced configuration options via &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AppAuthConfiguration.java&#34;&gt;AppAuthConfiguration&lt;/a&gt; instances, which can be provided to &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthorizationService.java&#34;&gt;AuthorizationService&lt;/a&gt; during construction.&lt;/p&gt; &#xA;&lt;h3&gt;Controlling which browser is used for authorization&lt;/h3&gt; &#xA;&lt;p&gt;Some applications require explicit control over which browsers can be used for authorization - for example, to require that Chrome be used for second factor authentication to work, or require that some custom browser is used for authentication in an enterprise environment.&lt;/p&gt; &#xA;&lt;p&gt;Control over which browsers can be used can be achieved by defining a &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/browser/BrowserMatcher.java&#34;&gt;BrowserMatcher&lt;/a&gt;, and supplying this to the builder of AppAuthConfiguration. A BrowserMatcher is suppled with a &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/browser/BrowserDescriptor.java&#34;&gt;BrowserDescriptor&lt;/a&gt; instance, and must decide whether this browser is permitted for the authorization flow.&lt;/p&gt; &#xA;&lt;p&gt;By default, &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/browser/AnyBrowserMatcher.java&#34;&gt;AnyBrowserMatcher&lt;/a&gt; is used.&lt;/p&gt; &#xA;&lt;p&gt;For your convenience, utility classes to help define a browser matcher are provided, such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/browser/Browsers.java&#34;&gt;Browsers&lt;/a&gt;: contains a set of constants for the official package names and signatures of Chrome, Firefox and Samsung SBrowser.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/browser/VersionedBrowserMatcher.java&#34;&gt;VersionedBrowserMatcher&lt;/a&gt;: will match a browser if it has a matching package name and signature, and a version number within a defined &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/browser/VersionRange.java&#34;&gt;VersionRange&lt;/a&gt;. This class also provides some static instances for matching Chrome, Firefox and Samsung SBrowser.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/browser/BrowserAllowList.java&#34;&gt;BrowserAllowList&lt;/a&gt;: takes a list of BrowserMatcher instances, and will match a browser if any of these child BrowserMatcher instances signals a match.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/browser/BrowserDenyList.java&#34;&gt;BrowserDenyList&lt;/a&gt;: the inverse of BrowserAllowList - takes a list of browser matcher instances, and will match a browser if it &lt;em&gt;does not&lt;/em&gt; match any of these child BrowserMatcher instances.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For instance, in order to restrict the authorization flow to using Chrome or SBrowser as a custom tab:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AppAuthConfiguration appAuthConfig = new AppAuthConfiguration.Builder()&#xA;    .setBrowserMatcher(new BrowserAllowList(&#xA;        VersionedBrowserMatcher.CHROME_CUSTOM_TAB,&#xA;        VersionedBrowserMatcher.SAMSUNG_CUSTOM_TAB))&#xA;    .build();&#xA;AuthorizationService authService =&#xA;        new AuthorizationService(context, appAuthConfig);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, to prevent the use of a buggy version of the custom tabs in Samsung SBrowser:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AppAuthConfiguration appAuthConfig = new AppAuthConfiguration.Builder()&#xA;    .setBrowserMatcher(new BrowserDenyList(&#xA;        new VersionedBrowserMatcher(&#xA;            Browsers.SBrowser.PACKAGE_NAME,&#xA;            Browsers.SBrowser.SIGNATURE_SET,&#xA;            true, // when this browser is used via a custom tab&#xA;            VersionRange.atMost(&#34;5.3&#34;)&#xA;        )))&#xA;    .build();&#xA;AuthorizationService authService =&#xA;        new AuthorizationService(context, appAuthConfig);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Customizing the connection builder for HTTP requests&lt;/h3&gt; &#xA;&lt;p&gt;It can be desirable to customize how HTTP connections are made when performing token requests, for instance to use &lt;a href=&#34;https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning&#34;&gt;certificate pinning&lt;/a&gt; or to add additional trusted certificate authorities for an enterprise environment. This can be achieved in AppAuth by providing a custom &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/connectivity/ConnectionBuilder.java&#34;&gt;ConnectionBuilder&lt;/a&gt; instance.&lt;/p&gt; &#xA;&lt;p&gt;For example, to custom the SSL socket factory used, one could do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AppAuthConfiguration appAuthConfig = new AppAuthConfiguration.Builder()&#xA;    .setConnectionBuilder(new ConnectionBuilder() {&#xA;      public HttpURLConnection openConnect(Uri uri) throws IOException {&#xA;        URL url = new URL(uri.toString());&#xA;        HttpURLConnection connection =&#xA;            (HttpURLConnection) url.openConnection();&#xA;        if (connection instanceof HttpsUrlConnection) {&#xA;          HttpsURLConnection connection = (HttpsURLConnection) connection;&#xA;          connection.setSSLSocketFactory(MySocketFactory.getInstance());&#xA;        }&#xA;      }&#xA;    })&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Issues with &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/IdToken.java#L118&#34;&gt;ID Token&lt;/a&gt; validation&lt;/h3&gt; &#xA;&lt;p&gt;ID Token validation was introduced in &lt;code&gt;0.8.0&lt;/code&gt; but not all authorization servers or configurations support it correctly.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For testing environments &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AppAuthConfiguration.java#L129&#34;&gt;setSkipIssuerHttpsCheck&lt;/a&gt; can be used to bypass the fact the issuer needs to be HTTPS.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AppAuthConfiguration appAuthConfig = new AppAuthConfiguration.Builder()&#xA;    .setSkipIssuerHttpsCheck(true)&#xA;    .build()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For services that don&#39;t support nonce[s] resulting in &lt;strong&gt;IdTokenException&lt;/strong&gt; &lt;code&gt;Nonce mismatch&lt;/code&gt; just set nonce to &lt;code&gt;null&lt;/code&gt; on the &lt;code&gt;AuthorizationRequest&lt;/code&gt;. Please consider &lt;strong&gt;raising an issue&lt;/strong&gt; with your Identity Provider and removing this once it is fixed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AuthorizationRequest authRequest = authRequestBuilder&#xA;    .setNonce(null)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Dynamic client registration&lt;/h2&gt; &#xA;&lt;p&gt;AppAuth supports the &lt;a href=&#34;https://tools.ietf.org/html/rfc7591&#34;&gt;OAuth2 dynamic client registration protocol&lt;/a&gt;. In order to dynamically register a client, create a &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/RegistrationRequest.java&#34;&gt;RegistrationRequest&lt;/a&gt; and dispatch it using &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthorizationService.java#L278&#34;&gt;performRegistrationRequest&lt;/a&gt; on your AuthorizationService instance.&lt;/p&gt; &#xA;&lt;p&gt;The registration endpoint can either be defined directly as part of your &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/AuthorizationServiceConfiguration.java&#34;&gt;AuthorizationServiceConfiguration&lt;/a&gt;, or discovered from an OpenID Connect discovery document.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RegistrationRequest registrationRequest = new RegistrationRequest.Builder(&#xA;    serviceConfig,&#xA;    Arrays.asList(redirectUri))&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Requests are dispatched with the help of &lt;code&gt;AuthorizationService&lt;/code&gt;. As this request is asynchronous the response is passed to a callback:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;service.performRegistrationRequest(&#xA;    registrationRequest,&#xA;    new AuthorizationService.RegistrationResponseCallback() {&#xA;        @Override public void onRegistrationRequestCompleted(&#xA;            @Nullable RegistrationResponse resp,&#xA;            @Nullable AuthorizationException ex) {&#xA;            if (resp != null) {&#xA;                // registration succeeded, store the registration response&#xA;                AuthState state = new AuthState(resp);&#xA;                //proceed to authorization...&#xA;            } else {&#xA;              // registration failed, check ex for more details&#xA;            }&#xA;         }&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Utilizing client secrets (DANGEROUS)&lt;/h2&gt; &#xA;&lt;p&gt;We &lt;em&gt;strongly recommend&lt;/em&gt; you avoid using static client secrets in your native applications whenever possible. Client secrets derived via a dynamic client registration are safe to use, but static client secrets can be easily extracted from your apps and allow others to impersonate your app and steal user data. If client secrets must be used by the OAuth2 provider you are integrating with, we strongly recommend performing the code exchange step on your backend, where the client secret can be kept hidden.&lt;/p&gt; &#xA;&lt;p&gt;Having said this, in some cases using client secrets is unavoidable. In these cases, a &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/ClientAuthentication.java&#34;&gt;ClientAuthentication&lt;/a&gt; instance can be provided to AppAuth when performing a token request. This allows additional parameters (both HTTP headers and request body parameters) to be added to token requests. Two standard implementations of ClientAuthentication are provided:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/ClientSecretBasic.java&#34;&gt;ClientSecretBasic&lt;/a&gt;: includes a client ID and client secret as an HTTP Basic Authorization header.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/library/java/net/openid/appauth/ClientSecretPost.java&#34;&gt;ClientSecretPost&lt;/a&gt;: includes a client ID and client secret as additional request parameters.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;So, in order to send a token request using HTTP basic authorization, one would write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ClientAuthentication clientAuth = new ClientSecretBasic(MY_CLIENT_SECRET);&#xA;TokenRequest req = ...;&#xA;authService.performTokenRequest(req, clientAuth, callback);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can also be done when using &lt;code&gt;performActionWithFreshTokens&lt;/code&gt; on AuthState:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ClientAuthentication clientAuth = new ClientSecretPost(MY_CLIENT_SECRET);&#xA;authState.performActionWithFreshTokens(&#xA;    authService,&#xA;    clientAuth,&#xA;    action);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Modifying or contributing to AppAuth&lt;/h2&gt; &#xA;&lt;p&gt;This project requires the Android SDK for API level 25 (Nougat) to build, though the produced binaries only require API level 16 (Jellybean) to be used. We recommend that you fork and/or clone this repository to make modifications; downloading the source has been known to cause some developers problems.&lt;/p&gt; &#xA;&lt;p&gt;For contributors, see the additional instructions in &lt;a href=&#34;https://github.com/openid/AppAuth-Android/raw/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Building from the Command line&lt;/h3&gt; &#xA;&lt;p&gt;AppAuth for Android uses Gradle as its build system. In order to build the library and app binaries, run &lt;code&gt;./gradlew assemble&lt;/code&gt;. The library AAR files are output to &lt;code&gt;library/build/outputs/aar&lt;/code&gt;, while the demo app is output to &lt;code&gt;app/build/outputs/apk&lt;/code&gt;. In order to run the tests and code analysis, run &lt;code&gt;./gradlew check&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Building from Android Studio&lt;/h3&gt; &#xA;&lt;p&gt;In AndroidStudio, File -&amp;gt; New -&amp;gt; Import project. Select the root folder (the one with the &lt;code&gt;build.gradle&lt;/code&gt; file).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>yidongnan/grpc-spring-boot-starter</title>
    <updated>2022-12-03T01:33:07Z</updated>
    <id>tag:github.com,2022-12-03:/yidongnan/grpc-spring-boot-starter</id>
    <link href="https://github.com/yidongnan/grpc-spring-boot-starter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Spring Boot starter module for gRPC framework.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;gRPC Spring Boot Starter&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/yidongnan/grpc-spring-boot-starter/actions&#34;&gt;&lt;img src=&#34;https://github.com/yidongnan/grpc-spring-boot-starter/workflows/Build%20master%20branch/badge.svg?sanitize=true&#34; alt=&#34;Build master branch&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22net.devh%22%20grpc&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/net.devh/grpc-spring-boot-starter.svg?sanitize=true&#34; alt=&#34;Maven Central with version prefix filter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/yidongnan/grpc-spring-boot-starter/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/mashape/apistatus.svg?sanitize=true&#34; alt=&#34;MIT License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crowdin.com/project/grpc-spring-boot-starter&#34;&gt;&lt;img src=&#34;https://badges.crowdin.net/grpc-spring-boot-starter/localized.svg?sanitize=true&#34; alt=&#34;Crowdin&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.javadoc.io/doc/net.devh/grpc-client-spring-boot-autoconfigure&#34;&gt;&lt;img src=&#34;https://www.javadoc.io/badge/net.devh/grpc-client-spring-boot-autoconfigure.svg?label=Client-Javadoc&#34; alt=&#34;Client-Javadoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.javadoc.io/doc/net.devh/grpc-server-spring-boot-autoconfigure&#34;&gt;&lt;img src=&#34;https://www.javadoc.io/badge/net.devh/grpc-server-spring-boot-autoconfigure.svg?label=Server-Javadoc&#34; alt=&#34;Server-Javadoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.javadoc.io/doc/net.devh/grpc-common-spring-boot&#34;&gt;&lt;img src=&#34;https://www.javadoc.io/badge/net.devh/grpc-common-spring-boot.svg?label=Common-Javadoc&#34; alt=&#34;Common-Javadoc&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;README: &lt;a href=&#34;https://raw.githubusercontent.com/yidongnan/grpc-spring-boot-starter/master/README.md&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/yidongnan/grpc-spring-boot-starter/master/README-zh-CN.md&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Documentation:&lt;/strong&gt; &lt;a href=&#34;https://yidongnan.github.io/grpc-spring-boot-starter/en/&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://yidongnan.github.io/grpc-spring-boot-starter/zh-CN/&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatically configures and runs the gRPC server with your &lt;code&gt;@GrpcService&lt;/code&gt; implementations&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatically creates and manages your grpc channels and stubs with &lt;code&gt;@GrpcClient&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Supports other grpc-java flavors (e.g. &lt;a href=&#34;https://github.com/salesforce/reactive-grpc/tree/master/rx-java&#34;&gt;Reactive gRPC (RxJava)&lt;/a&gt;, &lt;a href=&#34;https://github.com/grpc/grpc-kotlin&#34;&gt;grpc-kotlin&lt;/a&gt;, ...)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Server-side: Should work for all grpc-java flavors (&lt;code&gt;io.grpc.BindableService&lt;/code&gt; based)&lt;/li&gt; &#xA;   &lt;li&gt;Client-side: Requires custom &lt;code&gt;StubFactory&lt;/code&gt;s&lt;br&gt; Currently build-in support: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;grpc-java&lt;/li&gt; &#xA;     &lt;li&gt;(Please report missing ones, so we can add support for them)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Supports &lt;a href=&#34;https://github.com/spring-projects/spring-security&#34;&gt;Spring-Security&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Supports &lt;a href=&#34;https://spring.io/projects/spring-cloud&#34;&gt;Spring Cloud&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Server-side: Adds grpc-port information to the service registration details&lt;br&gt; Currently natively supported: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://github.com/spring-cloud/spring-cloud-consul&#34;&gt;Consul&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://github.com/spring-cloud/spring-cloud-netflix&#34;&gt;Eureka&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://github.com/spring-cloud-incubator/spring-cloud-alibaba&#34;&gt;Nacos&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;(Please report missing ones, so we can add support for them)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Client-side: Reads the service&#39;s target addresses from spring&#39;s &lt;code&gt;DiscoveryClient&lt;/code&gt; (all flavors)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Supports &lt;a href=&#34;https://github.com/spring-cloud/spring-cloud-sleuth&#34;&gt;Spring Sleuth&lt;/a&gt; as distributed tracing solution&lt;br&gt; (If &lt;a href=&#34;https://mvnrepository.com/artifact/io.zipkin.brave/brave-instrumentation-grpc&#34;&gt;brave-instrumentation-grpc&lt;/a&gt; is present)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Supports global and custom gRPC server/client interceptors&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatic metric support (&lt;a href=&#34;https://micrometer.io/&#34;&gt;micrometer&lt;/a&gt;/&lt;a href=&#34;https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-actuator&#34;&gt;actuator&lt;/a&gt; based)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Also works with (non-shaded) grpc-netty&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Versions&lt;/h2&gt; &#xA;&lt;p&gt;The latest version is &lt;code&gt;2.14.0.RELEASE&lt;/code&gt; it was compiled with spring-boot &lt;code&gt;2.6.13&lt;/code&gt; and spring-cloud &lt;code&gt;2021.0.5&lt;/code&gt; but it is also compatible with a large variety of other versions. An overview of all versions and their respective library versions can be found in our &lt;a href=&#34;https://yidongnan.github.io/grpc-spring-boot-starter/en/versions.html&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This project can also be used without Spring-Boot, however that requires some manual bean configuration.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;gRPC Server + Client&lt;/h3&gt; &#xA;&lt;p&gt;To add a dependency using Maven, use the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;net.devh&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;grpc-spring-boot-starter&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;2.14.0.RELEASE&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To add a dependency using Gradle:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {&#xA;  implementation &#39;net.devh:grpc-spring-boot-starter:2.14.0.RELEASE&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;gRPC Server&lt;/h3&gt; &#xA;&lt;p&gt;To add a dependency using Maven, use the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;net.devh&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;grpc-server-spring-boot-starter&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;2.14.0.RELEASE&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To add a dependency using Gradle:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {&#xA;  implementation &#39;net.devh:grpc-server-spring-boot-starter:2.14.0.RELEASE&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Annotate your server interface implementation(s) with &lt;code&gt;@GrpcService&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GrpcService&#xA;public class GrpcServerService extends GreeterGrpc.GreeterImplBase {&#xA;&#xA;    @Override&#xA;    public void sayHello(HelloRequest req, StreamObserver&amp;lt;HelloReply&amp;gt; responseObserver) {&#xA;        HelloReply reply = HelloReply.newBuilder().setMessage(&#34;Hello ==&amp;gt; &#34; + req.getName()).build();&#xA;        responseObserver.onNext(reply);&#xA;        responseObserver.onCompleted();&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the grpc server will listen to port &lt;code&gt;9090&lt;/code&gt;. These and other &lt;a href=&#34;https://raw.githubusercontent.com/yidongnan/grpc-spring-boot-starter/master/grpc-server-spring-boot-autoconfigure/src/main/java/net/devh/boot/grpc/server/config/GrpcServerProperties.java&#34;&gt;settings&lt;/a&gt; can be changed via Spring&#39;s property mechanism. The server uses the &lt;code&gt;grpc.server.&lt;/code&gt; prefix.&lt;/p&gt; &#xA;&lt;p&gt;Refer to our &lt;a href=&#34;https://yidongnan.github.io/grpc-spring-boot-starter/&#34;&gt;documentation&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;gRPC Client&lt;/h3&gt; &#xA;&lt;p&gt;To add a dependency using Maven, use the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;net.devh&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;grpc-client-spring-boot-starter&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;2.14.0.RELEASE&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To add a dependency using Gradle:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {&#xA;  compile &#39;net.devh:grpc-client-spring-boot-starter:2.14.0.RELEASE&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Annotate a field of your grpc client stub with &lt;code&gt;@GrpcClient(serverName)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Do not use in conjunction with &lt;code&gt;@Autowired&lt;/code&gt; or &lt;code&gt;@Inject&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GrpcClient(&#34;gRPC server name&#34;)&#xA;private GreeterGrpc.GreeterBlockingStub greeterStub;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You can use the same grpc server name for multiple channels and also different stubs (even with different interceptors).&lt;/p&gt; &#xA;&lt;p&gt;Then you can send queries to your server just like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;HelloReply response = stub.sayHello(HelloRequest.newBuilder().setName(name).build());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is possible to configure the target address for each client individually. However in some cases, you can just rely on the default configuration. You can customize the default url mapping via &lt;code&gt;NameResolver.Factory&lt;/code&gt; beans. If you don&#39;t configure that bean, then the default uri will be guessed using the default scheme and the name (e.g.: &lt;code&gt;dns:/&amp;lt;name&amp;gt;&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;p&gt;These and other &lt;a href=&#34;https://raw.githubusercontent.com/yidongnan/grpc-spring-boot-starter/master/grpc-client-spring-boot-autoconfigure/src/main/java/net/devh/boot/grpc/client/config/GrpcChannelProperties.java&#34;&gt;settings&lt;/a&gt; can be changed via Spring&#39;s property mechanism. The clients use the &lt;code&gt;grpc.client.(serverName).&lt;/code&gt; prefix.&lt;/p&gt; &#xA;&lt;p&gt;Refer to our &lt;a href=&#34;https://yidongnan.github.io/grpc-spring-boot-starter/&#34;&gt;documentation&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Running with (non-shaded) grpc-netty&lt;/h2&gt; &#xA;&lt;p&gt;This library supports both &lt;code&gt;grpc-netty&lt;/code&gt; and &lt;code&gt;grpc-netty-shaded&lt;/code&gt;. The later one might prevent conflicts with incompatible grpc-versions or conflicts between libraries that require different versions of netty.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If the shaded netty is present on the classpath, then this library will always favor it over the non-shaded grpc-netty one.&lt;/p&gt; &#xA;&lt;p&gt;You can use it with Maven like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;grpc-netty&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;${grpcVersion}&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&#xA;&amp;lt;!-- For both --&amp;gt;&#xA;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;net.devh&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;grpc-spring-boot-starter&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;...&amp;lt;/version&amp;gt;&#xA;    &amp;lt;exclusions&amp;gt;&#xA;        &amp;lt;exclusion&amp;gt;&#xA;            &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&#xA;            &amp;lt;artifactId&amp;gt;grpc-netty-shaded&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;/exclusion&amp;gt;&#xA;    &amp;lt;/exclusions&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&amp;lt;!-- For the server (only) --&amp;gt;&#xA;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;net.devh&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;grpc-server-spring-boot-starter&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;...&amp;lt;/version&amp;gt;&#xA;    &amp;lt;exclusions&amp;gt;&#xA;        &amp;lt;exclusion&amp;gt;&#xA;            &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&#xA;            &amp;lt;artifactId&amp;gt;grpc-netty-shaded&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;/exclusion&amp;gt;&#xA;    &amp;lt;/exclusions&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&amp;lt;!-- For the client (only) --&amp;gt;&#xA;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;net.devh&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;grpc-client-spring-boot-starter&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;...&amp;lt;/version&amp;gt;&#xA;    &amp;lt;exclusions&amp;gt;&#xA;        &amp;lt;exclusion&amp;gt;&#xA;            &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&#xA;            &amp;lt;artifactId&amp;gt;grpc-netty-shaded&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;/exclusion&amp;gt;&#xA;    &amp;lt;/exclusions&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and like this when using Gradle:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;implementation &#34;io.grpc:grpc-netty:${grpcVersion}&#34;&#xA;&#xA;implementation &#39;net.devh:grpc-spring-boot-starter:...&#39; exclude group: &#39;io.grpc&#39;, module: &#39;grpc-netty-shaded&#39; // For both&#xA;implementation &#39;net.devh:grpc-client-spring-boot-starter:...&#39; exclude group: &#39;io.grpc&#39;, module: &#39;grpc-netty-shaded&#39; // For the client (only)&#xA;implementation &#39;net.devh:grpc-server-spring-boot-starter:...&#39; exclude group: &#39;io.grpc&#39;, module: &#39;grpc-netty-shaded&#39; // For the server (only)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example-Projects&lt;/h2&gt; &#xA;&lt;p&gt;Read more about our example projects &lt;a href=&#34;https://raw.githubusercontent.com/yidongnan/grpc-spring-boot-starter/master/examples&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;Refer to our &lt;a href=&#34;https://yidongnan.github.io/grpc-spring-boot-starter/en/trouble-shooting&#34;&gt;documentation&lt;/a&gt; for help.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are always welcomed! Please see &lt;a href=&#34;https://raw.githubusercontent.com/yidongnan/grpc-spring-boot-starter/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for detailed guidelines.&lt;/p&gt;</summary>
  </entry>
</feed>