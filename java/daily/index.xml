<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-05T01:31:42Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>alura-es-cursos/1952-spring-boot-3-rest-api</title>
    <updated>2023-10-05T01:31:42Z</updated>
    <id>tag:github.com,2023-10-05:/alura-es-cursos/1952-spring-boot-3-rest-api</id>
    <link href="https://github.com/alura-es-cursos/1952-spring-boot-3-rest-api" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Spring Boot 3 : Rest API - Alura&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>Alquimistas-AluraLatam/ESP-hotel-alura</title>
    <updated>2023-10-05T01:31:42Z</updated>
    <id>tag:github.com,2023-10-05:/Alquimistas-AluraLatam/ESP-hotel-alura</id>
    <link href="https://github.com/Alquimistas-AluraLatam/ESP-hotel-alura" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Challenge ONE | Java | Back-end | Hotel Alura&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;600&#34; heigth=&#34;600&#34; src=&#34;https://user-images.githubusercontent.com/91544872/189419249-06b539da-7cf2-4d40-a711-618a5c872096.png&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Este repositorio contiene el c√≥digo fuente para la soluci√≥n del desaf√≠o de crear una aplicaci√≥n CRUD utilizando JDBC y Swing. El objetivo del desaf√≠o es desarrollar una aplicaci√≥n que permita realizar operaciones CRUD en una base de datos relacional.&lt;/h2&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;üñ•Ô∏è Tecnolog√≠as Utilizadas:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Java&lt;/li&gt; &#xA; &lt;li&gt;Eclipse&lt;/li&gt; &#xA; &lt;li&gt;Biblioteca JCalendar&lt;/li&gt; &#xA; &lt;li&gt;MySql&lt;/li&gt; &#xA; &lt;li&gt;Plugin WindowBuilder&lt;/li&gt; &#xA; &lt;li&gt;Biblioteca C3PO para crear Pool de conexiones&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;‚ö†Ô∏è Importante! ‚ö†Ô∏è&lt;/h2&gt; &#xA;&lt;p&gt;‚òï Use Java versi√≥n 8 o superior para compatibilidad. &lt;br&gt;&lt;br&gt; üìù Recomendamos usar el editor de Eclipse para compatibilidad con la Interfaz Gr√°fica. &lt;br&gt;&lt;br&gt; üé® La interfaz contiene dos m√©todos importantes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;setResizable(false): determina el tama√±o de la ventana, y a trav√©s del par√°metro &lt;strong&gt;false&lt;/strong&gt;, la pantalla no se puede maximizar;&lt;/li&gt; &#xA; &lt;li&gt;setLocationRelativeTo(null): determina la ubicaci√≥n de la ventana, y a trav√©s del par√°metro &lt;strong&gt;null&lt;/strong&gt; la mantiene centrada en la pantalla.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Para este desaf√≠o, conc√©ntrate en la parte l√≥gica y la conexi√≥n con la base de datos, despu√©s de completar el desaf√≠o, si√©ntate libre de agregar nuevas funciones y modificar la interfaz gr√°fica.&lt;/h4&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Videos de soluci√≥n&lt;/h2&gt; &#xA;&lt;p&gt;Para ayudarte a√∫n m√°s en esta jornada de aprendizaje hemos creado estos videos de soluci√≥n con las partes estrat√©gicas para la realizaci√≥n de este desaf√≠o. Recuerda que esta es solo una de las infinitas formas de llevar a cabo el desaf√≠o, aprovechen para estudiar los c√≥digos y tambi√©n compartan entre ustedes sus resoluciones y opiniones acerca de su proyecto.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=1luEBNCweG4&#34;&gt;Realiza una conexi√≥n a la base de datos e guarda tus registros&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/8y5fqKVfDWU&#34;&gt;Muestra los registros a trav√©s de la aplicaci√≥n&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üì¨ Entrega&lt;/h2&gt; &#xA;&lt;h3&gt;¬øC√≥mo incluir mi proyecto con el &#34;#&#34; del desaf√≠o?&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Ten el &lt;strong&gt;Fork&lt;/strong&gt; del proyecto en tu repositorio en Github.&lt;/li&gt; &#xA; &lt;li&gt;Utilize el topico &lt;strong&gt;#challengeonehotelaluralatam4&lt;/strong&gt; &lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;Ve a la pesta√±a derecha de tu proyecto y haz clic en el engranaje de configuraci√≥n en la secci√≥n &lt;em&gt;About&lt;/em&gt;, seleccione el campo &lt;strong&gt;topics&lt;/strong&gt; e inserte la etiqueta &lt;strong&gt;challengeonehotelaluralatam4&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;¬øC√≥mo hago la entrega final de mi Proyecto?&lt;/h3&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Rellena el siguiente formulario con tus datos personales, junto con el enlace de tu repositorio. üîπ &lt;a href=&#34;https://lp.alura.com.br/alura-latam-entrega-challenge-one-esp-back-end&#34;&gt;Link para o formul√°rio&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;700&#34; heigth=&#34;700&#34; src=&#34;https://user-images.githubusercontent.com/53662778/225654748-b9ee1a2c-5b9d-4723-a787-192c65f296ae.png&#34;&gt; &lt;/p&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Ve a tu correo electr√≥nico y canjea tu insignia obtenida al completar otro desaf√≠o del Proyecto ONE! üèÜ&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;¬°No olvides poner un enlace o video de tu proyecto en Linkedin! Etiqueta a #Oracle y #AluraLatam üèÅ&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;üß° &lt;strong&gt;Oracle&lt;/strong&gt;&lt;br&gt; &lt;a href=&#34;https://www.linkedin.com/company/oracle/&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/-LinkedIn-%230077B5?style=for-the-badge&amp;amp;logo=linkedin&amp;amp;logoColor=white&#34; target=&#34;_blank&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;üíô &lt;strong&gt;Alura Latam&lt;/strong&gt;&lt;br&gt; &lt;a href=&#34;https://www.linkedin.com/company/alura-latam/mycompany/&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/-LinkedIn-%230077B5?style=for-the-badge&amp;amp;logo=linkedin&amp;amp;logoColor=white&#34; target=&#34;_blank&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jbellis/jvector</title>
    <updated>2023-10-05T01:31:42Z</updated>
    <id>tag:github.com,2023-10-05:/jbellis/jvector</id>
    <link href="https://github.com/jbellis/jvector" rel="alternate"></link>
    <summary type="html">&lt;p&gt;JVector: the most advanced embedded vector search engine&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;JVector&lt;/h1&gt; &#xA;&lt;p&gt;JVector is a pure Java, zero dependency, embedded vector search engine, used by DataStax Astra DB and (soon) Apache Cassandra.&lt;/p&gt; &#xA;&lt;p&gt;What is JVector?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Algorithmic-fast. JVector uses state of the art graph algorithms inspired by DiskANN and related research that offer high recall and low latency.&lt;/li&gt; &#xA; &lt;li&gt;Implementation-fast. JVector uses the Panama SIMD API to accelerate index build and queries.&lt;/li&gt; &#xA; &lt;li&gt;Memory efficient. JVector compresses vectors using product quantization so they can stay in memory during searches. (As part of our PQ implementation, our SIMD-accelerated kmeans class is 5x faster than the one in Apache Commons Math.)&lt;/li&gt; &#xA; &lt;li&gt;Disk-aware. JVector‚Äôs disk layout is designed to do the minimum necessary iops at query time.&lt;/li&gt; &#xA; &lt;li&gt;Concurrent. Index builds scale linearly to at least 32 threads. Double the threads, half the build time.&lt;/li&gt; &#xA; &lt;li&gt;Incremental. Query your index as you build it. No delay between adding a vector and being able to find it in search results.&lt;/li&gt; &#xA; &lt;li&gt;Easy to embed. API designed for easy embedding, by people using it in production.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;JVector performance, visualized&lt;/h2&gt; &#xA;&lt;p&gt;JVector vs Lucene searching the Deep100M dataset (about 35GB of vectors and 25GB index): &lt;img src=&#34;https://github.com/jbellis/jvector/assets/42158/7710f33d-ff6a-4282-9e31-4a5eaacd796f&#34; alt=&#34;Screenshot from 2023-09-29 16-39-33&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;JVector scales updates linearly to at least 32 threads: &lt;img src=&#34;https://github.com/jbellis/jvector/assets/42158/f0127bfc-6c45-48b9-96ea-95b2120da0d9&#34; alt=&#34;Screenshot from 2023-09-14 18-05-15&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;JVector basics&lt;/h2&gt; &#xA;&lt;p&gt;Adding to your project. Replace &lt;code&gt;${latest-version}&lt;/code&gt; with &lt;img src=&#34;https://img.shields.io/maven-central/v/io.github.jbellis/jvector?color=green&#34; alt=&#34;Maven Central&#34;&gt;. Example &lt;code&gt;&amp;lt;version&amp;gt;1.0.1&amp;lt;/version&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;        &#xA;    &amp;lt;groupId&amp;gt;io.github.jbellis&amp;lt;/groupId&amp;gt;          &#xA;    &amp;lt;artifactId&amp;gt;jvector&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;!-- Use the latest version from https://central.sonatype.com/artifact/io.github.jbellis/jvector --&amp;gt;&#xA;    &amp;lt;version&amp;gt;${latest-version}&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Building the index:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphIndexBuilder.java&#34;&gt;&lt;code&gt;GraphIndexBuilder&lt;/code&gt;&lt;/a&gt; is the entry point for building a graph. You will need to implement &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/graph/RandomAccessVectorValues.java&#34;&gt;&lt;code&gt;RandomAccessVectorValues&lt;/code&gt;&lt;/a&gt; to provide vectors to the builder; &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/graph/ListRandomAccessVectorValues.java&#34;&gt;&lt;code&gt;ListRandomAccessVectorValues&lt;/code&gt;&lt;/a&gt; is a good starting point.&lt;/li&gt; &#xA; &lt;li&gt;If all your vectors are in the provider up front, you can just call &lt;code&gt;build()&lt;/code&gt; and it will parallelize the build across all available cores. Otherwise you can call &lt;code&gt;addGraphNode&lt;/code&gt; as you add vectors; this is non-blocking and can be called concurrently from multiple threads.&lt;/li&gt; &#xA; &lt;li&gt;Call &lt;code&gt;GraphIndexBuilder.complete&lt;/code&gt; when you are done adding vectors. This will optimize the index and make it ready to write to disk. (Graphs that are in the process of being built can be searched at any time; you do not have to call &lt;em&gt;complete&lt;/em&gt; first.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Searching the index:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphSearcher.java&#34;&gt;&lt;code&gt;GraphSearcher&lt;/code&gt;&lt;/a&gt; is the entry point for searching. Results come back as a &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/graph/SearchResult.java&#34;&gt;&lt;code&gt;SearchResult&lt;/code&gt;&lt;/a&gt; object that contains node IDs and scores, in descending order of similarity to the query vector. &lt;code&gt;GraphSearcher&lt;/code&gt; objects are re-usable, so unless you have a very simple use case you should use &lt;code&gt;GraphSearcher.Builder&lt;/code&gt; to create them; &lt;code&gt;GraphSearcher::search&lt;/code&gt; is also available with simple defaults, but calling it will instantiate a new &lt;code&gt;GraphSearcher&lt;/code&gt; every time so performance will be worse.&lt;/li&gt; &#xA; &lt;li&gt;JVector represents vectors in the index as the ordinal (int) corresponding to their index in the &lt;code&gt;RandomAccessVectorValues&lt;/code&gt; you provided. You can get the original vector back with &lt;code&gt;GraphIndex.getVector&lt;/code&gt;, if necessary, but since this is a disk-backed index you should design your application to avoid doing so if possible.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;DiskANN and Product Quantization&lt;/h2&gt; &#xA;&lt;p&gt;JVector implements &lt;a href=&#34;https://suhasjs.github.io/files/diskann_neurips19.pdf&#34;&gt;DiskANN&lt;/a&gt;-style search, meaning that vectors can be compressed using product quantization so that searches can be performed using the compressed representation that is kept in memory. You can enable this with the following steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create a &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java&#34;&gt;&lt;code&gt;ProductQuantization&lt;/code&gt;&lt;/a&gt; object with your vectors using &lt;code&gt;ProductQuantization.compute&lt;/code&gt;. This will take some time to compute the codebooks.&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;ProductQuantization::encode&lt;/code&gt; or &lt;code&gt;encodeAll&lt;/code&gt; to encode your vectors.&lt;/li&gt; &#xA; &lt;li&gt;Create a &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/disk/CompressedVectors.java&#34;&gt;&lt;code&gt;CompressedVectors&lt;/code&gt;&lt;/a&gt; object from the encoded vectors.&lt;/li&gt; &#xA; &lt;li&gt;Create a &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/graph/NeighborSimilarity.java&#34;&gt;&lt;code&gt;NeighborSimilarity.ApproximateScoreFunction&lt;/code&gt;&lt;/a&gt; for your query that uses the &lt;code&gt;ProductQuantization&lt;/code&gt; object and &lt;code&gt;CompressedVectors&lt;/code&gt; to compute scores, and pass this to the &lt;code&gt;GraphSearcher.search&lt;/code&gt; method.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Saving and loading indexes&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/disk/OnDiskGraphIndex.java&#34;&gt;&lt;code&gt;OnDiskGraphIndex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/disk/CompressedVectors.java&#34;&gt;&lt;code&gt;CompressedVectors&lt;/code&gt;&lt;/a&gt; have &lt;code&gt;write()&lt;/code&gt; methods to save state to disk. They initialize from disk using their constructor and &lt;code&gt;load()&lt;/code&gt; methods, respectively. Writing just requires a DataOutput, but reading requires an implementation of &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/disk/RandomAccessReader.java&#34;&gt;&lt;code&gt;RandomAccessReader&lt;/code&gt;&lt;/a&gt; and the related &lt;code&gt;ReaderSupplier&lt;/code&gt; to wrap your preferred i/o class for best performance. See &lt;code&gt;SimpleMappedReader&lt;/code&gt; and &lt;code&gt;SimpleMappedReaderSupplier&lt;/code&gt; for an example.&lt;/li&gt; &#xA; &lt;li&gt;Building a graph does not technically require your RandomAccessVectorValues object to live in memory, but it will perform much better if it does. OnDiskGraphIndex, by contrast, is designed to live on disk and use minimal memory otherwise.&lt;/li&gt; &#xA; &lt;li&gt;You can optionally wrap &lt;code&gt;OnDiskGraphIndex&lt;/code&gt; in a &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base/src/main/java/io/github/jbellis/jvector/disk/CachingGraphIndex.java&#34;&gt;&lt;code&gt;CachingGraphIndex&lt;/code&gt;&lt;/a&gt; to keep the most commonly accessed nodes (the ones nearest to the graph entry point) in memory.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Sample code&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-examples/src/main/java/io/github/jbellis/jvector/example/SiftSmall.java&#34;&gt;&lt;code&gt;SiftSmall&lt;/code&gt;&lt;/a&gt; class demonstrates how to put all of the above together to index and search the &#34;small&#34; SIFT dataset of 10,000 vectors.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-examples/src/main/java/io/github/jbellis/jvector/example/Bench.java&#34;&gt;&lt;code&gt;Bench&lt;/code&gt;&lt;/a&gt; class performs grid search across the &lt;code&gt;GraphIndexBuilder&lt;/code&gt; parameter space to find the best tradeoffs between recall and throughput. You can use &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/plot_output.py&#34;&gt;&lt;code&gt;plot_output.py&lt;/code&gt;&lt;/a&gt; to graph the &lt;a href=&#34;https://en.wikipedia.org/wiki/Pareto_efficiency&#34;&gt;pareto-optimal points&lt;/a&gt; found by &lt;code&gt;Bench&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some sample KNN datasets for testing based on ada-002 embeddings generated on wikipedia data are available in ivec/fvec format for testing at:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aws s3 ls s3://astra-vector/wikipedia/ --no-sign-request &#xA;                           PRE 100k/&#xA;                           PRE 1M/&#xA;                           PRE 4M/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;download them with the aws s3 cli as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aws s3 sync s3://astra-vector/wikipedia/100k ./ --no-sign-request&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Developing and Testing&lt;/h2&gt; &#xA;&lt;p&gt;This project is organized as a &lt;a href=&#34;https://maven.apache.org/guides/mini/guide-multiple-modules.html&#34;&gt;multimodule Maven build&lt;/a&gt;. The intent is to produce a multirelease jar suitable for use as a dependency from any Java 11 code. When run on a Java 20+ JVM with the Vector module enabled, optimized vector providers will be used. In general, the project is structured to be built with JDK 20+, but when &lt;code&gt;JAVA_HOME&lt;/code&gt; is set to Java 11 -&amp;gt; Java 19, certain build features will still be available.&lt;/p&gt; &#xA;&lt;p&gt;Base code is in &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base&#34;&gt;jvector-base&lt;/a&gt; and will be built for Java 11 releases, restricting language features and APIs appropriately. Code in &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-twenty&#34;&gt;jvector-twenty&lt;/a&gt; will be compiled for Java 20 language features/APIs and included in the final multirelease jar targetting supported JVMs. &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-multirelease&#34;&gt;jvector-multirelease&lt;/a&gt; packages &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-base&#34;&gt;jvector-base&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-twenty&#34;&gt;jvector-twenty&lt;/a&gt; as a multirelease jar for release. &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/jvector-examples&#34;&gt;jvector-examples&lt;/a&gt; is an additional sibling module that uses the reactor-representation of jvector-base/jvector-twenty to run example code.&lt;/p&gt; &#xA;&lt;p&gt;You can run &lt;code&gt;SiftSmall&lt;/code&gt; and &lt;code&gt;Bench&lt;/code&gt; directly to get an idea of what all is going on here. &lt;code&gt;Bench&lt;/code&gt; requires some datasets to be downloaded from &lt;a href=&#34;https://github.com/erikbern/ann-benchmarks&#34;&gt;https://github.com/erikbern/ann-benchmarks&lt;/a&gt;. The files used by &lt;code&gt;SiftSmall&lt;/code&gt; can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/jbellis/jvector/main/siftsmall&#34;&gt;siftsmall directory&lt;/a&gt; in the project root.&lt;/p&gt; &#xA;&lt;p&gt;To run either class, you can use the Maven exec-plugin via the following incantations:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;mvn compile exec:exec@bench&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;or for Sift:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;mvn compile exec:exec@sift&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To run Sift/Bench without the JVM vector module available, you can use the following invocations:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;mvn -Pjdk11 compile exec:exec@bench&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;mvn -Pjdk11 compile exec:exec@sift&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The &lt;code&gt;... -Pjdk11&lt;/code&gt; invocations will also work with &lt;code&gt;JAVA_HOME&lt;/code&gt; pointing at a Java 11 installation.&lt;/p&gt; &#xA;&lt;p&gt;To release, configure &lt;code&gt;~/.m2/settings.xml&lt;/code&gt; to point to OSSRH and run &lt;code&gt;mvn -Prelease clean deploy&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt;</summary>
  </entry>
</feed>