<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-20T01:29:19Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>CodingGay/BlackShadow</title>
    <updated>2024-03-20T01:29:19Z</updated>
    <id>tag:github.com,2024-03-20:/CodingGay/BlackShadow</id>
    <link href="https://github.com/CodingGay/BlackShadow" rel="alternate"></link>
    <summary type="html">&lt;p&gt;腾讯(Tencent)Shadow的二次封装项目，开袋即食版。&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BlackShadow&lt;/h1&gt; &#xA;&lt;p&gt;接入shadow需要大量的二次开发工作，其实一般小型项目其实并不想关心太多的逻辑和管理，只想开袋即食，奈何Shadow也并没有提供这方面的能力，所有开发者接入都需要二次开发才可以使用，所以花了点时间在Shadow的基础上包装了一层，几乎不需要任何二次开发，即可通过几个简单的接口使用与管理Shadow，屏蔽了Shadow所有的技术细节。&lt;/p&gt; &#xA;&lt;h2&gt;相关&lt;/h2&gt; &#xA;&lt;p&gt;博客文章： &lt;a href=&#34;https://blog.niunaijun.top/index.php/archives/blackshadow.html&#34;&gt;腾讯Shadow浅析及应用及BlackShadow&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Tencent Shadow： &lt;a href=&#34;https://github.com/Tencent/Shadow&#34;&gt;https://github.com/Tencent/Shadow&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;基于Shadow的技术方案&lt;/h2&gt; &#xA;&lt;p&gt;BlackShadow使用的是非动态方案，支持同时最多10个插件运行，分别都是各自单独的进程。install与launch都有boolean返回值，可反馈出插件是否安装/启动成功。&lt;/p&gt; &#xA;&lt;h2&gt;未实现&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Activity栈的管理，目前统一打开standard Activity&lt;/li&gt; &#xA; &lt;li&gt;多个插件共用一个进程&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;如何使用？&lt;/h2&gt; &#xA;&lt;p&gt;建议直接clone本项目查看项目结构。&lt;/p&gt; &#xA;&lt;h3&gt;1. clone Shadow&lt;/h3&gt; &#xA;&lt;p&gt;nnjun仓库与Tencent仓库没有技术性差异。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/Tencent/Shadow.git&#xA;或者&#xA;git clone https://github.com/nnjun/Shadow.git (建议使用这个)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2. 编译本地仓库&lt;/h3&gt; &#xA;&lt;p&gt;拉下仓库后，进入Shadow目录，将Shadow发布到本地maven仓库&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./gradlew publish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3. 修改项目Shadow版本&lt;/h3&gt; &#xA;&lt;p&gt;修改Shadow版本为本地的版本，如果是拉取nnjun仓库则不需要改&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/CodingGay/BlackShadow/raw/main/build.gradle#L3&#34;&gt;https://github.com/CodingGay/BlackShadow/blob/main/build.gradle#L3&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;BlackShadow使用方法&lt;/h2&gt; &#xA;&lt;p&gt;在Application#attachBaseContext中初始化&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Override&#xA;    protected void attachBaseContext(Context base) {&#xA;        super.attachBaseContext(base);&#xA;        BlackShadow.get().init(this);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;安装与启动&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    InstallResult installResult = BlackShadow.get().installPlugin(&#34;plugin-key&#34;, new File(pluginAPk));&#xA;    if (installResult.isSuccess()) {&#xA;        Intent intent = new Intent();&#xA;        intent.xxxxxxxxxxxxx&#xA;        BlackShadow.get().launchPlugin(&#34;plugin-key&#34;, intent);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;其余接口&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    // 仅启动application&#xA;    public boolean callApplication(String pluginKey)&#xA;&#xA;    // 获取所有已安装的plugin&#xA;    public List&amp;lt;InstalledPlugin&amp;gt; getInstalledPlugins()&#xA;&#xA;    // 获取某个已安装的plugin&#xA;    public InstalledPlugin getInstalledPlugin(String pluginKey)；&#xA;&#xA;    // 卸载某个plugin&#xA;    public void uninstallPlugin(String pluginKey)&#xA;&#xA;    // 停止某个plugin&#xA;    public void stopPlugin(String pluginKey)&#xA;&#xA;    // 停止所有plugin&#xA;    public void stopAllPlugin()&#xA;&#xA;    // 获取正在运行的plugin&#xA;    public List&amp;lt;RunningPlugin&amp;gt; getRunningPlugins()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;插件包名与宿主包名不相同的需求&lt;/h2&gt; &#xA;&lt;p&gt;由于Shadow内核要求，plugin与宿主的包名必须一致，否则会出现问题，然而我方产品可能会存在不同的渠道包不同的包名，但是插件没有必要分开很多份，所以BlackShadow是支持插件与宿主不同的包名，处理的方法是在install时如果不一样，BlackShaodw会自动将插件的包名改成与宿主相同，不需要额外开发，直接进行install即可，BlackShadow会自动处理该问题。&lt;/p&gt; &#xA;&lt;p&gt;假如你也有这个需求，则需要自行修改Shaodw内核，或者直接使用nnjun仓库&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/nnjun/Shadow/commit/32636d2759bae1d1f241c8f43ffb769ff2ce5ef5&#34;&gt;https://github.com/nnjun/Shadow/commit/32636d2759bae1d1f241c8f43ffb769ff2ce5ef5&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;不是修改了包名了吗？为什么还需要修改内核？&lt;/h3&gt; &#xA;&lt;p&gt;因为Shadow的包名基准是由Shadow编译时生成的com.tencent.shadow.core.manifest_parser.PluginManifest文件来确定，BlackShadow只会修改Manifest中的包名，并不会修改PluginManifest.class内的硬编码包名，所以需要修改编译插件，否则无法运行。&lt;/p&gt; &#xA;&lt;p&gt;如果你没有以上的场景，那么请无视上面这一段内容，直接使用即可。&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>smilexizheng/coco-boot</title>
    <updated>2024-03-20T01:29:19Z</updated>
    <id>tag:github.com,2024-03-20:/smilexizheng/coco-boot</id>
    <link href="https://github.com/smilexizheng/coco-boot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;test-coco-springboot&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;coco-boot 测试项目 基于springboot&lt;/h2&gt; &#xA;&lt;p&gt;请根据实际情况 继续完善 api 接口的对接和响应。只是敲出来，未测试。&lt;/p&gt;</summary>
  </entry>
</feed>