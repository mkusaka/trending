<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-04T01:36:28Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>twitter/Serial</title>
    <updated>2023-04-04T01:36:28Z</updated>
    <id>tag:github.com,2023-04-04:/twitter/Serial</id>
    <link href="https://github.com/twitter/Serial" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Light-weight, fast framework for object serialization in Java, with Android support.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;|badge1| |badge2| |badge3|&lt;/p&gt; &#xA;&lt;p&gt;.. |badge1| image:: &lt;a href=&#34;https://travis-ci.org/twitter/Serial.svg?branch=master&#34;&gt;https://travis-ci.org/twitter/Serial.svg?branch=master&lt;/a&gt; :target: &lt;a href=&#34;https://travis-ci.org/twitter/Serial&#34;&gt;https://travis-ci.org/twitter/Serial&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. |badge2| image:: &lt;a href=&#34;https://img.shields.io/maven-central/v/com.twitter.serial/serial.svg&#34;&gt;https://img.shields.io/maven-central/v/com.twitter.serial/serial.svg&lt;/a&gt; :target: &lt;a href=&#34;https://repo1.maven.org/maven2/com/twitter/serial/serial/&#34;&gt;https://repo1.maven.org/maven2/com/twitter/serial/serial/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. |badge3| image:: &lt;a href=&#34;https://img.shields.io/badge/license-Apache%20License%202.0-blue.svg?style=flat&#34;&gt;https://img.shields.io/badge/license-Apache%20License%202.0-blue.svg?style=flat&lt;/a&gt; :target: &lt;a href=&#34;https://raw.githubusercontent.com/twitter/Serial/master/LICENSE.txt&#34;&gt;https://raw.githubusercontent.com/twitter/Serial/master/LICENSE.txt&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Twitter Serial&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;中文文档 &amp;lt;https://github.com/twitter/Serial/blob/master/README-CHINESE.rst/&amp;gt;&lt;/code&gt;_&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;Grab the latest version via Gradle from Maven Central:&lt;/p&gt; &#xA;&lt;p&gt;.. code-block:: java&lt;/p&gt; &#xA;&lt;p&gt;repositories { mavenCentral() }&lt;/p&gt; &#xA;&lt;p&gt;dependencies { implementation &#39;com.twitter.serial:serial:0.1.6&#39; }&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Twitter Serial is a custom serialization implementation that&#39;s intended to improve performance and increase developer visibility into and control over an object&#39;s serialization.&lt;/p&gt; &#xA;&lt;p&gt;This framework uses Serializers to explicitly define how a class should be serialized. Some of the major advantages of this approach include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;more efficient serialization avoiding reflection - preliminary metrics for a large object showed&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;more than 3x faster for roundtrip serialization (5x faster to serialize, 2.5x to deserialize)&lt;/li&gt; &#xA;   &lt;li&gt;around 5x smaller in byte array size&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;greater control over what&#39;s serialized for an object - all serialization is defined explicitly&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;better debugging capabilities (see &lt;code&gt;debugging&lt;/code&gt;_)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Basic Structure&lt;/h2&gt; &#xA;&lt;p&gt;To serialize an object to a byte array, use:&lt;/p&gt; &#xA;&lt;p&gt;.. code-block:: java&lt;/p&gt; &#xA;&lt;p&gt;final Serial serial = new ByteBufferSerial(); final byte[] serializedData = serial.toByteArray(object, ExampleObject.SERIALIZER)&lt;/p&gt; &#xA;&lt;p&gt;To deserialize from a byte array back to an object, use:&lt;/p&gt; &#xA;&lt;p&gt;.. code-block:: java&lt;/p&gt; &#xA;&lt;p&gt;final ExampleObject object = serial.fromByteArray(ExampleObject.SERIALIZER)&lt;/p&gt; &#xA;&lt;h2&gt;Defining Serializers&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Instead of implementing Serializable, define a serializer for every object that needs to be serialized&lt;/li&gt; &#xA; &lt;li&gt;Serializers explicitly write and read each field of the object by using read/write for primitives or recursively calling serializers for other objects&lt;/li&gt; &#xA; &lt;li&gt;Serializers handle null objects for you, as does read/writeString; primitive read/write methods do not&lt;/li&gt; &#xA; &lt;li&gt;Serializers are stateless, so they are written as static inner classes of the object and accessed as a static instance variable &lt;code&gt;SERIALIZER&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For most classes, you can create a subclass of &lt;code&gt;ObjectSerializer&lt;/code&gt; and implement &lt;code&gt;serializeObject&lt;/code&gt; and &lt;code&gt;deserializeObject&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. code-block:: java&lt;/p&gt; &#xA;&lt;p&gt;public static class ExampleObject { public static final ObjectSerializer&#xA; &lt;exampleobject&gt;&#xA;   SERIALIZER = new ExampleObjectSerializer();&#xA; &lt;/exampleobject&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  public final int num;&#xA;  public final SubObject obj;&#xA;&#xA;  public ExampleObject(int num, @NotNull SubObject obj) {&#xA;      this.num = num;&#xA;      this.obj = obj;&#xA;  }&#xA;&#xA;  ...&#xA;&#xA;  private static final class ExampleObjectSerializer extends ObjectSerializer&amp;lt;ExampleObject&amp;gt; {&#xA;      @Override&#xA;      protected void serializeObject(@NotNull SerializationContext context, @NotNull SerializerOutput output,&#xA;              @NotNull ExampleObject object) throws IOException {&#xA;          output&#xA;              .writeInt(object.num) // first field&#xA;              .writeObject(object.obj, SubObject.SERIALIZER); // second field&#xA;      }&#xA;&#xA;      @Override&#xA;      @NotNull&#xA;      protected ExampleObject deserializeObject(@NotNull SerializationContext context, @NotNull SerializerInput input,&#xA;              int versionNumber) throws IOException, ClassNotFoundException {&#xA;          final int num = input.readInt(); // first field&#xA;          final SubObject obj = input.readObject(SubObject.SERIALIZER); // second field&#xA;          return new ExampleObject(num, obj);&#xA;      }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;p&gt;For classes that are constructed using builders, or have optional fields added (see &lt;code&gt;updating-serializers&lt;/code&gt;_), you can use a &lt;code&gt;BuilderSerializer&lt;/code&gt;, in which you implement the methods &lt;code&gt;createBuilder&lt;/code&gt; (which just returns a new builder object for that class) and &lt;code&gt;deserializeToBuilder&lt;/code&gt; (where you populate the builder with the deserialized fields)&lt;/p&gt; &#xA;&lt;p&gt;.. code-block:: java&lt;/p&gt; &#xA;&lt;p&gt;public static class ExampleObject { ...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  public ExampleObject(@NotNull Builder builder) {&#xA;      this.num = builder.mNum;&#xA;      this.obj = builder.mObj;&#xA;  }&#xA;&#xA;  ...&#xA;&#xA;  public static class Builder extends ModelBuilder&amp;lt;ExampleObject&amp;gt; {&#xA;      ...&#xA;  }&#xA;&#xA;  private static final class ExampleObjectSerializer extends BuilderSerializer&amp;lt;ExampleObject, Builder&amp;gt; {&#xA;      @Override&#xA;      @NotNull&#xA;      protected Builder createBuilder() {&#xA;          return new Builder();&#xA;      }&#xA;&#xA;      @Override&#xA;      protected void serializeObject(@NotNull SerializationContext context, @NotNull SerializerOutput output,&#xA;              @NotNull ExampleObject object) throws IOException {&#xA;          output.writeInt(object.num)&#xA;              .writeObject(object.obj, SubObject.SERIALIZER);&#xA;      }&#xA;&#xA;       @Override&#xA;      protected void deserializeToBuilder(@NotNull SerializationContext context, @NotNull SerializerInput input,&#xA;              @NotNull Builder builder, int versionNumber) throws IOException, ClassNotFoundException {&#xA;          builder.setNum(input.readInt())&#xA;              .setObj(input.readObject(SubObject.SERIALIZER));&#xA;      }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;h2&gt;Serialization Utility Methods&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;CoreSerializers&lt;/code&gt; and &lt;code&gt;CollectionSerializers&lt;/code&gt; contain serializers for boxed primitives and have helper methods to serialize objects like collections, enums and comparators.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;For example, to serialize a list of Strings, you can use:&lt;/p&gt; &lt;p&gt;.. code-block:: java&lt;/p&gt; &lt;p&gt;CollectionSerializers.getListSerializer(Serializers.STRING);&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In order to serialize an object as its base class, you can construct a base class serializer from the subclass&#39;s serializers using the getBaseClassSerializer in &lt;code&gt;Serializers&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;For example, if you have ClassA and ClassB that both extend ClassC, and you want to serialize the objects as ClassC objects, you can create a serializer in ClassC using the serializers of the subclasses:&lt;/p&gt; &lt;p&gt;.. code-block:: java&lt;/p&gt; &lt;p&gt;final Serializer&#xA;     &lt;classc&gt;&#xA;       SERIALIZER = Serializers.getBaseClassSerializer( SerializableClass.create(ClassA.class, new ClassA.ClassASerializer()), SerializableClass.create(ClassB.class, new ClassB.ClassBSerializer()));&#xA;     &lt;/classc&gt;&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;.. note:: You must create new instances of ClassA and B serializers rather than using the static object defined in those classes. Since ClassC is initialized as part of its subclasses, using static objects of its subclasses in its initialization will create a cyclic dependency that will likely lead to a cryptic NPE.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;.. _updating-serializers:&lt;/p&gt; &#xA;&lt;h2&gt;Updating Serializers&lt;/h2&gt; &#xA;&lt;p&gt;If you add or remove a field for an object that&#39;s being stored as serialized data, there are a few ways to handle it:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;OptionalFieldException&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;If you add a field to the end of an object, your new serializer will reach the end of an old object when trying to&#xA;read the new field, which will cause it to throw an ``OptionalFieldException``.&#xA;&#xA;``BuilderSerializer`` handles ``OptionalFieldExceptions`` for you by just ignoring that field in the builder,&#xA;stopping deserialization, and building the rest of the object as is. If you&#39;re using a regular Serializer instead,&#xA;you can explicitly catch the OptionalFieldException and set the remaining field(s) to default values as appropriate.&#xA;&#xA;- Say, for example, you wanted to add a String &#39;name&#39; to the end of the ExampleObject above&#xA;&#xA;  - For both serializer types, you could simply add ``.writeString(obj.name)`` to ``serializeObject``&#xA;  - For the BuilderSerializer, to deserialize you would add ``.setName(input.readString())`` to the end of&#xA;    ``deserializeToBuilder``. In the case where an older object without the name field is being deserialized, an&#xA;    ``OptionalFieldException`` would be thrown and caught when reading the String, causing the object to be built&#xA;    as is without the name field explicitly set.&#xA;  - For the regular Serializer, you would change ``deserializeObject`` as follows:&#xA;&#xA;    .. code-block:: java&#xA;&#xA;      @Override&#xA;      @NotNull&#xA;      protected ExampleObject deserializeObject(@NotNull SerializationContext context, @NotNull SerializerInput input,&#xA;              int versionNumber) throws IOException, ClassNotFoundException {&#xA;          final int num = input.readInt();&#xA;          final SubObject obj = input.readObject(SubObject.SERIALIZER);&#xA;          final String name;&#xA;          try {&#xA;              name = input.readString();&#xA;          } catch (OptionalFieldException e) {&#xA;              name = DEFAULT_NAME;&#xA;          }&#xA;          return new ExampleObject(num, obj, name);&#xA;      }&#xA;&#xA;Version numbers&#xA;~~~~~~~~~~~~~~~&#xA;Another option is to increase the version number of the serializer, and define the deserialization behavior for&#xA;older versions. To do this, pass the version number into the constructor of the ``SERIALIZER`` object, and then&#xA;in the deserialize method you can specify what to do differently for previous versions.&#xA;&#xA;- To change the above example to use version numbers, do the following:&#xA;&#xA;  .. code-block:: java&#xA;&#xA;    final Serializer&amp;lt;ExampleObject&amp;gt; SERIALIZER = new ExampleObjectSerializer(1);&#xA;    ...&#xA;&#xA;    @Override&#xA;    @NotNull&#xA;    protected ExampleObject deserializeObject(@NotNull SerializationContext context, @NotNull SerializerInput input, int versionNumber)&#xA;            throws IOException, ClassNotFoundException {&#xA;        final int num = input.readInt();&#xA;        final SubObject obj = input.readObject(SubObject.SERIALIZER);&#xA;        final String name;&#xA;        if (versionNumber &amp;lt; 1) {&#xA;            name = DEFAULT_NAME;&#xA;        } else {&#xA;            name = input.readString();&#xA;        }&#xA;        return new ExampleObject(num, obj, name);&#xA;    }&#xA;&#xA;If you remove a field from the middle of an object, you need to ignore the whole object during deserialization by&#xA;using the ``skipObject`` method in ``SerializationUtils``. This way you don&#39;t need to keep the serializer if you&#xA;are removing the object all together.&#xA;&#xA;- Say in the above example you also wanted to remove the obj field and delete ``SubObject``:&#xA;&#xA;  .. code-block:: java&#xA;&#xA;    @Override&#xA;    @NotNull&#xA;    protected ExampleObject deserializeObject(@NotNull SerializationContext context, @NotNull SerializerInput input, int versionNumber)&#xA;            throws IOException, ClassNotFoundException {&#xA;        final int num = input.readInt();&#xA;        if (versionNumber &amp;lt; 1) {&#xA;            SerializationUtils.skipObject()&#xA;            name = DEFAULT_NAME;&#xA;        } else {&#xA;            name = input.readString();&#xA;        }&#xA;        return new ExampleObject(num, name);&#xA;    }&#xA;&#xA;Another option is to call input.peekType(), which allows you to check the type of the next field before reading the object.&#xA;This is especially helpful if you hadn&#39;t updated the version before making a change and don&#39;t want to wipe the database,&#xA;since it allows you to differentiate between the two versions without a version number. Note that this only works if the&#xA;two types are different.&#xA;&#xA;.. code-block:: java&#xA;&#xA;    @Override&#xA;    @NotNull&#xA;    protected ExampleObject deserializeObject(@NotNull SerializationContext context, @NotNull SerializerInput input, int versionNumber)&#xA;            throws IOException, ClassNotFoundException {&#xA;        final int num = input.readInt();&#xA;        if (input.peekType() == SerializerDefs.TYPE_START_OBJECT) {&#xA;            SerializationUtils.skipObject();&#xA;            name = DEFAULT_NAME;&#xA;        } else {&#xA;            name = input.readString();&#xA;        }&#xA;        return new ExampleObject(num, name);&#xA;    }&#xA;&#xA;Value Serializers&#xA;-----------------&#xA;Some objects are so simple that do not require support for versioning: ``Integer``, ``String``, ``Size``, ``Rect``...&#xA;Using an ``ObjectSerializer`` with these objects adds an envelope of 2-3 bytes around the serialized data, which can&#xA;add significant overhead. When versioning is not required, ``ValueSerializer`` is a better choice:&#xA;&#xA;.. code-block:: java&#xA;&#xA;  public static final Serializer&amp;lt;Boolean&amp;gt; BOOLEAN = new ValueSerializer&amp;lt;Boolean&amp;gt;() {&#xA;      @Override&#xA;      protected void serializeValue(@NotNull SerializationContext context, @NotNull SerializerOutput output, @NotNull Boolean object) throws IOException {&#xA;          output.writeBoolean(object);&#xA;      }&#xA;&#xA;      @NotNull&#xA;      @Override&#xA;      protected Boolean deserializeValue(@NotNull SerializationContext context, @NotNull SerializerInput input) throws IOException {&#xA;          return input.readBoolean();&#xA;      }&#xA;  };&#xA;&#xA;This is just a simpler version of ``ObjectSerializer`` that handles ``null``, otherwise, just writes the values into&#xA;the stream.&#xA;&#xA;.. note::&#xA;  ``ValueSerializer`` writes ``null`` to the stream when given a ``null`` value. As a result, the first field written&#xA;  into the stream by ``serializeValue`` can&#39;t be ``null``, since it would be ambiguous. ``ValueSerializer`` detects&#xA;  this as an error and throws an exception.&#xA;&#xA;.. caution::&#xA;  Value serializers should *only* be used when their format is known to be fixed, since they do not support any form&#xA;  of backwards compatibility.&#xA;&#xA;Debugging&#xA;---------&#xA;``serial`` also contains methods to help with debugging:&#xA;&#xA;- ``dumpSerializedData`` will create a string log of the data in the serialized byte array&#xA;- ``validateSerializedData`` ensures that the serialized object has a valid structure (e.g. every object start header&#xA;  has a matching end header)&#xA;&#xA;Exceptions now contain more information about the serialization failure, specifically information about the expected&#xA;type to be deserialized and the type that was found, based on headers written for each value.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>bigintpro/csdn_downloader</title>
    <updated>2023-04-04T01:36:28Z</updated>
    <id>tag:github.com,2023-04-04:/bigintpro/csdn_downloader</id>
    <link href="https://github.com/bigintpro/csdn_downloader" rel="alternate"></link>
    <summary type="html">&lt;p&gt;csdn下载，csdn免积分下载，csdn免会员下载，csdn付费内容下载 免费资源 体验地址:http://servicedev.tpddns.cn:8181/#/login?c=12&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;csdn资源下载工具&lt;/h1&gt; &#xA;&lt;h4&gt;介绍&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;csdn免积分下载工具&lt;/li&gt; &#xA; &lt;li&gt;csdn免会员下载工具&lt;/li&gt; &#xA; &lt;li&gt;csdnvip资源下载工具&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;软件架构&lt;/h4&gt; &#xA;&lt;p&gt;采用spingboot + dubbo 架构设计&lt;/p&gt; &#xA;&lt;h4&gt;安装教程&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;体验地址 &lt;a href=&#34;http://servicedev.tpddns.cn:8181/#/login?c=12&#34;&gt;http://servicedev.tpddns.cn:8181/#/login?c=12&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;需要注册 并拥有qq,163等邮箱&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;使用说明&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;复制需要下载页面的url(也即是浏览器地址栏的地址) &lt;img src=&#34;https://raw.githubusercontent.com/bigintpro/csdn_downloader/master/public/download1.png&#34; alt=&#34;看看&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;张贴到下载输入框的 &lt;img src=&#34;https://raw.githubusercontent.com/bigintpro/csdn_downloader/master/public/download3.png&#34; alt=&#34;看看&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;点击下载 &lt;img src=&#34;https://raw.githubusercontent.com/bigintpro/csdn_downloader/master/public/download4.png&#34; alt=&#34;看看&#34;&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;参与贡献&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork 本仓库&lt;/li&gt; &#xA; &lt;li&gt;新建 Feat_xxx 分支&lt;/li&gt; &#xA; &lt;li&gt;提交代码&lt;/li&gt; &#xA; &lt;li&gt;新建 Pull Request&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>