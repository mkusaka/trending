<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-23T01:37:27Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>oddfar/campus-imaotai</title>
    <updated>2023-07-23T01:37:27Z</updated>
    <id>tag:github.com,2023-07-23:/oddfar/campus-imaotai</id>
    <link href="https://github.com/oddfar/campus-imaotai" rel="alternate"></link>
    <summary type="html">&lt;p&gt;i茅台app自动预约，每日自动预约，支持docker一键部署&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;https://oddfar.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;img width=&#34;180&#34; src=&#34;https://note.oddfar.com/img/web.png&#34; alt=&#34;logo&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/oddfar/campus-imaotai/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/oddfar/campus-imaotai.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/oddfar/campus-imaotai/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/oddfar/campus-imaotai.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; i茅台app自动预约，每日自动预约，支持docker一键部署&lt;/p&gt; &#xA;&lt;h2 align=&#34;center&#34;&gt;Campus-imaotai&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/oddfar/notes&#34;&gt;笔记仓库&lt;/a&gt; | &lt;a href=&#34;https://oddfar.com&#34;&gt;我的博客&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;项目介绍&lt;/h2&gt; &#xA;&lt;p&gt;i茅台app，每日自动预约茅台，可添加多个用户，可选本市出货量最大的门店，或预约你的位置附近门店&lt;/p&gt; &#xA;&lt;p&gt;软件会在每日9点05开始批量预约，并 &lt;a href=&#34;https://www.pushplus.plus/&#34;&gt;pushplus&lt;/a&gt; 推送消息&lt;/p&gt; &#xA;&lt;p&gt;此项目使用 &lt;strong&gt;Campus&lt;/strong&gt; 进行编写：&lt;a href=&#34;https://github.com/oddfar/campus&#34;&gt;https://github.com/oddfar/campus&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;使用教程&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;部署项目：&lt;a href=&#34;https://github.com/oddfar/campus-imaotai/wiki/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8#%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE&#34;&gt;点击此处&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;使用项目：&lt;a href=&#34;https://github.com/oddfar/campus-imaotai/wiki/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8#%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8&#34;&gt;点击此处&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;常见问题：&lt;a href=&#34;https://github.com/oddfar/campus-imaotai/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98&#34;&gt;点击此处&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;有问题请查看文档，查找 &lt;a href=&#34;https://github.com/oddfar/campus-imaotai/issues&#34;&gt;issues&lt;/a&gt; 上是否有相同问题！&lt;/p&gt; &#xA;&lt;p&gt;若没有则提交 &lt;a href=&#34;https://github.com/oddfar/campus-imaotai/issues&#34;&gt;issues&lt;/a&gt; ，附带详细的错误原因&lt;/p&gt; &#xA;&lt;h2&gt;关注&amp;amp;交流&lt;/h2&gt; &#xA;&lt;p&gt;欢迎各位老哥进群进行&lt;strong&gt;技术交流&lt;/strong&gt;（只交流技术，不谈茅台），为了防止广告进入，请添加我微信（备注：&lt;strong&gt;Campus&lt;/strong&gt;），我会直接将你拉进&lt;strong&gt;Campus交流群&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;私信不解决项目使用问题，请提交 issues！&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://note.oddfar.com/img/my-wechat.jpg&#34; alt=&#34;wechat&#34; style=&#34;height:280px;&#34;&gt; &#xA;&lt;h2&gt;贡献代码&lt;/h2&gt; &#xA;&lt;p&gt;若您有好的想法，发现一些 &lt;strong&gt;BUG&lt;/strong&gt; 并修复了，欢迎提交 &lt;strong&gt;Pull Request&lt;/strong&gt; 参与开源贡献&lt;/p&gt; &#xA;&lt;p&gt;发起 pull request 请求，提交到 master 分支，等待作者合并&lt;/p&gt; &#xA;&lt;h2&gt;演示图&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;i茅台预约&lt;/th&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/oddfar/campus-imaotai/master/.github/image-20230707144241399.png&#34; alt=&#34;image-20230707144241399&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/oddfar/campus-imaotai/master/.github/image-20230707144404638.png&#34; alt=&#34;image-20230707144404638&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/oddfar/campus-imaotai/master/.github/image-20230707144703842.png&#34; alt=&#34;image-20230707144703842&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/oddfar/campus-imaotai/master/.github/image-20230707145525709.png&#34; alt=&#34;image-20230707145525709&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;鸣谢&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh-hans/IntelliJ_IDEA&#34;&gt;IntelliJ IDEA&lt;/a&gt; 是一个在各个方面都最大程度地提高开发人员的生产力的 IDE，适用于 JVM 平台语言。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;特别感谢 &lt;a href=&#34;https://www.jetbrains.com/?from=campus&#34;&gt;JetBrains&lt;/a&gt; 为开源项目提供免费的 &lt;a href=&#34;https://www.jetbrains.com/idea/?from=campus&#34;&gt;IntelliJ IDEA&lt;/a&gt; 等 IDE 的授权&lt;br&gt; &lt;a href=&#34;https://www.jetbrains.com/?from=campus&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/oddfar/campus-imaotai/master/.github/jetbrains-variant.png&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>AliyunContainerService/scaler</title>
    <updated>2023-07-23T01:37:27Z</updated>
    <id>tag:github.com,2023-07-23:/AliyunContainerService/scaler</id>
    <link href="https://github.com/AliyunContainerService/scaler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;scaler实现指南&lt;/h1&gt; &#xA;&lt;p&gt;本赛题需要选手实现一个 Scaler 模块的功能。在实际生产环境中一个 Scaler 模块为了实现弹性伸缩的功能，需要解决很多工程问题，而具体的工程问题往往和实际的环境和技术栈相关。所以本赛题通过仿真框架屏蔽了这些因环境而异的繁琐工程细节，选手只聚焦在 Scaler 核心逻辑即可。 本赛题提供了go和java语言的参考实现，选手可以参考其中的任意一种语言实现，也可以自行选择其他语言实现。 这里以go语言为例，选手实现的代码需要实现Scaler接口(go/pkg/scaler/interface.go)，确保实现的函数可以完成下述功能: 在go/pkg/scheduler/simple.go 基础上实现&lt;code&gt;Scheduler&lt;/code&gt;接口(go/pkg/scheduler/interface.go)，确保实现的函数可以完成下述功能:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Assign:为请求分配一个应用实例，一个应用实例只能被分配给一个请求，如果无应用实例存在则需要冷启动，重新创建一个实例。无论是Kubernetes中Pod 还是 FaaS 函数，应用实例的启动过程都包括两个部分：实例的分配（CreateSlot）以及应用环境初始化（Init）。然后，实例才可以正常的处理请求 &lt;img src=&#34;https://raw.githubusercontent.com/AliyunContainerService/scaler/main/images/img.png&#34; alt=&#34;img.png&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Idle:释放请求占用的应用实例，这个实例如果没有被回收， 可以被下次调用请求复用 &lt;img src=&#34;https://raw.githubusercontent.com/AliyunContainerService/scaler/main/images/img_1.png&#34; alt=&#34;img_1.png&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;选手可以基于赛题方给出的数据集(data/data_training.tar.gz),解压后进行本地调试。 赛题方同时提供了用于测试选手代码实现效果的镜像(registry.cn-beijing.aliyuncs.com/cloudnative-challenge/simulator:v1.0.0)，已经嵌入了以上训练数据集，选手可以通过以下本地测试方式进行调试。&lt;/p&gt; &#xA;&lt;h2&gt;数据集字段说明&lt;/h2&gt; &#xA;&lt;h3&gt;requests 数据集&lt;/h3&gt; &#xA;&lt;p&gt;requests 数据集包含了一系列的请求记录，每条记录对应一个已经完成的任务。每条记录包含以下字段：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;startTime: 这是一个以毫秒为单位的时间戳，代表任务开始的时间。&lt;/li&gt; &#xA; &lt;li&gt;metaKey: 用来标识与任务相关联的元数据，它与元数据数据集中的key字段相对应。&lt;/li&gt; &#xA; &lt;li&gt;durationsInMs: 表示任务的执行时间，单位为毫秒。&lt;/li&gt; &#xA; &lt;li&gt;statusCode: 表示任务的执行结果。一般来说，200代表任务成功完成，其他值则可能代表有错误或异常情况，模拟的是云计算场景下后端实例偶发性的异常。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;metas 数据集&lt;/h3&gt; &#xA;&lt;p&gt;metas 数据集包含了一系列的元数据记录，每条记录包含一项任务的配置信息。每条记录包含以下字段：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;key: 用来唯一标识一项元数据,可以理解为任务的类型或者特征。它与requests数据集中的metaKey字段相对应。&lt;/li&gt; &#xA; &lt;li&gt;runtime: 代表任务需要运行的环境，如python、nodejs、go等。&lt;/li&gt; &#xA; &lt;li&gt;memoryInMb: 表示任务需要的内存数量，单位为MB。&lt;/li&gt; &#xA; &lt;li&gt;timeoutInSecs: 表示任务的超时时间，单位为秒。&lt;/li&gt; &#xA; &lt;li&gt;initDurationInMs: 表示任务初始化的时间，单位为毫秒。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;接口文档&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;注意：以下说明以go语言为例，其他语言请参考对应语言的数据结构定义。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Assign 方法&lt;/h3&gt; &#xA;&lt;p&gt;Assign 方法是一个核心接口，其主要目的是分配资源实例以满足任务请求。 Assign方法的核心逻辑可能如下：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;解析输入的AssignRequest，提取出元数据信息以及请求时间等。&lt;/li&gt; &#xA; &lt;li&gt;根据元数据信息以及当前系统的资源状态，决定是否可以分配一个资源实例来执行任务，或者是否需要等待。&lt;/li&gt; &#xA; &lt;li&gt;如果可以分配，那么创建一个资源实例，记录其创建的时间、类型等信息，并将其标记为已占用状态。&lt;/li&gt; &#xA; &lt;li&gt;返回创建的资源实例的信息，包括其唯一ID等。 需要注意的是，你也可以在一个AssignRequest到来时创建多个资源实例，如果你预测到后面会有大量同类型的任务到来，这样可以提前创建好资源实例，以便后续的任务可以更快的被分配到资源实例上，减少冷启动时间。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;输入&lt;/h4&gt; &#xA;&lt;p&gt;Assign方法接收context和AssignRequest对象作为输入参数。其结构和对应的数据集字段如下： ctx: context对象，用于跨多个API请求或goroutines之间共享deadline，取消信号，和其他请求范围的值 request: AssignRequest对象，定义了分配请求的所有信息&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type AssignRequest struct {&#xA;&#x9;...&#xA;&#x9;&#xA;    RequestId string `protobuf:&#34;bytes,1,opt,name=request_id,json=requestId,proto3&#34; json:&#34;request_id,omitempty&#34;`&#xA;    Timestamp uint64 `protobuf:&#34;varint,2,opt,name=timestamp,proto3&#34; json:&#34;timestamp,omitempty&#34;`&#xA;    MetaData  *Meta  `protobuf:&#34;bytes,3,opt,name=meta_data,json=metaData,proto3&#34; json:&#34;meta_data,omitempty&#34;`&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RequestId: 唯一的请求 ID。&lt;/li&gt; &#xA; &lt;li&gt;Timestamp: 时间戳，表示请求发起的时间，对应requests数据集中的startTime 字段。&lt;/li&gt; &#xA; &lt;li&gt;MetaData: Meta 对象，包含任务运行所需的元数据信息，对应数据集matas中的字段。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;输出&lt;/h4&gt; &#xA;&lt;p&gt;Assign 方法返回一个 AssignReply 对象，包含分配的资源实例的唯一标识。其结构如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type AssignReply struct {&#xA;    ...&#xA;&#xA;    Status       Status      `protobuf:&#34;varint,1,opt,name=status,proto3,enum=serverless.simulator.Status&#34; json:&#34;status,omitempty&#34;`&#xA;    Assigment    *Assignment `protobuf:&#34;bytes,2,opt,name=assigment,proto3&#34; json:&#34;assigment,omitempty&#34;`&#xA;    ErrorMessage *string     `protobuf:&#34;bytes,3,opt,name=error_message,json=errorMessage,proto3,oneof&#34; json:&#34;error_message,omitempty&#34;`&#xA;}&#xA;&#xA;type Assignment struct {&#xA;&#x9;...&#xA;&#x9;&#xA;    RequestId  string `protobuf:&#34;bytes,1,opt,name=request_id,json=requestId,proto3&#34; json:&#34;request_id,omitempty&#34;`&#xA;    MetaKey    string `protobuf:&#34;bytes,2,opt,name=meta_key,json=metaKey,proto3&#34; json:&#34;meta_key,omitempty&#34;`&#xA;    InstanceId string `protobuf:&#34;bytes,3,opt,name=instance_id,json=instanceId,proto3&#34; json:&#34;instance_id,omitempty&#34;`&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RequestId: 唯一的请求 ID，与输入的 AssignRequest 对象中的 RequestId 字段相同。&lt;/li&gt; &#xA; &lt;li&gt;MetaKey: 与输入的 AssignRequest 对象中的 MetaData.Key 字段相同。&lt;/li&gt; &#xA; &lt;li&gt;InstanceId: 资源实例的唯一标识，用于后续的 Idle 方法 以及 gc的资源回收。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Idle 方法&lt;/h3&gt; &#xA;&lt;p&gt;方法用于处理释放实例。你可以设计自己的策略，决定是否删除相应的资源实例。例如，如果短时间内可能会有大量同类型的请求到来，可以保留实例，资源实例将继续用于其他任务，降低冷启动时间；反之，则可能选择将资源实例释放，以节约资源。&lt;/p&gt; &#xA;&lt;h4&gt;输入&lt;/h4&gt; &#xA;&lt;p&gt;Idle 方法接收 context 和 IdleRequest 对象作为输入参数。其结构和对应的数据集字段如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type IdleRequest struct {&#xA;&#x9;...&#xA;    Assigment *Assignment `protobuf:&#34;bytes,1,opt,name=assigment,proto3&#34; json:&#34;assigment,omitempty&#34;`&#xA;    Result    *Result     `protobuf:&#34;bytes,2,opt,name=result,proto3&#34; json:&#34;result,omitempty&#34;`&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Assigment: Assignment对象，包含任务的分配信息，对应Assign方法的输出。&lt;/li&gt; &#xA; &lt;li&gt;Result: Result 对象，包含任务的结果信息，对应requests数据集中的statusCode和durationsInMs字段&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Result struct {&#xA;    ...&#xA;&#xA;&#x9;StatusCode   int32   `protobuf:&#34;varint,1,opt,name=status_code,json=statusCode,proto3&#34; json:&#34;status_code,omitempty&#34;`&#xA;&#x9;DurationInMs uint64  `protobuf:&#34;varint,2,opt,name=duration_in_ms,json=durationInMs,proto3&#34; json:&#34;duration_in_ms,omitempty&#34;`&#xA;&#x9;NeedDestroy  *bool   `protobuf:&#34;varint,3,opt,name=need_destroy,json=needDestroy,proto3,oneof&#34; json:&#34;need_destroy,omitempty&#34;`&#xA;&#x9;Reason       *string `protobuf:&#34;bytes,4,opt,name=reason,proto3,oneof&#34; json:&#34;reason,omitempty&#34;`&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;StatusCode: 任务的执行状态码，对应数据集requests中的statusCode字段。&lt;/li&gt; &#xA; &lt;li&gt;DurationInMs: 任务的执行时间，对应数据集requests中的durationsInMs字段。&lt;/li&gt; &#xA; &lt;li&gt;NeedDestroy: 一个布尔值，表示是否需要释放资源实例。如果为true，则需要释放资源实例；如果为false，则不需要释放资源实例。&lt;/li&gt; &#xA; &lt;li&gt;Reason: 释放资源实例的原因。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;输出&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type IdleReply struct {&#xA;    ...&#xA;&#xA;&#x9;Status       Status  `protobuf:&#34;varint,1,opt,name=status,proto3,enum=serverless.simulator.Status&#34; json:&#34;status,omitempty&#34;`&#xA;&#x9;ErrorMessage *string `protobuf:&#34;bytes,3,opt,name=error_message,json=errorMessage,proto3,oneof&#34; json:&#34;error_message,omitempty&#34;`&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Status: 状态码，表示Idle方法的执行结果。&lt;/li&gt; &#xA; &lt;li&gt;ErrorMessage: 错误信息，如果Status不为OK，则ErrorMessage不为空，表示错误信息。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;gcLoop方法&lt;/h3&gt; &#xA;&lt;p&gt;除了上述两个API之外，还有一个gcLoop方法，这个方法是由scaler内部定期调用的，用于回收空闲的资源实例。 gcLoop方法会定期运行，每次运行时，会遍历idleInstances列表，检查每个实例的空闲时间，如果有实例的空闲时间超过了配置的时间IdleDurationBeforeGC，那么这个实例就会被销毁。&lt;/p&gt; &#xA;&lt;p&gt;在销毁实例时，会调用platformClient的DeleteSlot方法删除这个slot，然后从instances映射和idleInstances列表中删除这个实例，最后会更新实例的状态为deleted。&lt;/p&gt; &#xA;&lt;p&gt;这个方法的运行时间间隔由Config对象的GcInterval字段控制。 选手可以通过配置GcInterval 和 IdleDurationBeforeGC来控制gcLoop方法的运行频率和空闲实例的回收时间。&lt;/p&gt; &#xA;&lt;h1&gt;scaler本地开发&lt;/h1&gt; &#xA;&lt;h2&gt;运行环境&lt;/h2&gt; &#xA;&lt;p&gt;linux 运行环境&lt;/p&gt; &#xA;&lt;h2&gt;构建二进制&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;# make binary&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;make build 命令会生成一个二进制:scaler, 存放在项目根目录&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;scaler 是本次比赛的框架代码，选手可以通过实现根据assign/idle API来实现alloc/release实例的的功能。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;如何本地测试&lt;/h2&gt; &#xA;&lt;h3&gt;申请测试集群&lt;/h3&gt; &#xA;&lt;p&gt;选手可以通过登录&lt;a href=&#34;https://free.aliyun.com/?product=9596839&amp;amp;crowd=personal&#34;&gt;阿里云官网&lt;/a&gt;领取免费的ASK体验集群，选手可以在此集群上进行本地调试。 成功申请集群后，选手需要将集群的kubeconfig文件下载到本地， 并放置在&lt;code&gt;~/.kube/config&lt;/code&gt;目录下， 以便后续使用kubectl命令进行调试。&lt;/p&gt; &#xA;&lt;h3&gt;本地安装kubectl&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/&#34;&gt;安装文档&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;版本要求： v1.26&lt;/p&gt; &#xA;&lt;p&gt;后续的调试请使用 &lt;code&gt;kubectl &lt;/code&gt; 命令进行测试， 例如：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;kubectl get pod&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;构建docker镜像并推送到镜像仓库&lt;/h3&gt; &#xA;&lt;h4&gt;使用阿里云ACR服务&lt;/h4&gt; &#xA;&lt;p&gt;阿里云容器镜像服务（简称 ACR）是面向容器镜像、Helm Chart 等符合 OCI 标准的云原生制品安全托管及高效分发平台。 ACR 产品页 ：&lt;a href=&#34;https://www.aliyun.com/product/acr&#34;&gt;https://www.aliyun.com/product/acr&lt;/a&gt; 。 当前可以免费使用容器镜像服务 ACR 个人版，点击进入 ACR 控制台 &lt;a href=&#34;https://cr.console.aliyun.com%E3%80%82&#34;&gt;https://cr.console.aliyun.com。&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;生成镜像并推送至镜像仓库&lt;/h4&gt; &#xA;&lt;p&gt;登录ACR镜像仓库&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker login --username=xxx registry.cn-shanghai.aliyuncs.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;构建镜像并推送至ACR镜像仓库&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker buildx build --platform linux/amd64 -t $IMAGE_REPO:$IMAGE_TAG . --push&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;IMAGE_REPO指定镜像repo&lt;/li&gt; &#xA; &lt;li&gt;IMAGE_TAG指定镜像tag&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;比如: 生成镜像registry.cn-shanghai.aliyuncs.com/cloudnative-challenge/scaler:v1.0， 命令如下:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker buildx build --platform linux/amd64 -t registry.cn-shanghai.aliyuncs.com/cloudnative-challenge/scaler:v1.0 . --push&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;部署测试job&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;kubectl apply -f hack/serverless-simulation.yaml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;执行后， 会在对应命名空间下生成名为serverless-simulation 的job对象，该job的pod中包含两个容器， 一个是scaler 的容器， 一个是serverless-simulator 的容器， 可以使用kubectl命令查看:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;kubectl get jobs serverless-simulation -o yaml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;可以通过 &lt;code&gt;kubectl logs -f &lt;/code&gt; 命令查看pod 里两个容器产生的日志，进而进行问题的排查：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#查看scaler 容器日志: &#xA;kubectl logs jobs/serverless-simulation scaler&#xA;&#xA;# 查看simulator 容器日志:&#xA;kubectl logs jobs/serverless-simulation serverless-simulator&#xA;&#xA;# 查看当前的数据统计&#xA;kubectl exec jobs/serverless-simulation -c scaler -- curl http://127.0.0.1:9000/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;赛题提交说明&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://tianchi.aliyun.com/forum/post/558730&#34;&gt;https://tianchi.aliyun.com/forum/post/558730&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;注意&lt;/h1&gt; &#xA;&lt;p&gt;项目中的run.sh将作为容器的脚本，选手提交时请不要修改run.sh的内容，否则可能会导致评测失败。&lt;/p&gt;</summary>
  </entry>
</feed>