<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-22T01:36:09Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>wechatpay-apiv3/wechatpay-java</title>
    <updated>2023-04-22T01:36:09Z</updated>
    <id>tag:github.com,2023-04-22:/wechatpay-apiv3/wechatpay-java</id>
    <link href="https://github.com/wechatpay-apiv3/wechatpay-java" rel="alternate"></link>
    <summary type="html">&lt;p&gt;微信支付 APIv3 的官方 Java Library&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://www.javadoc.io/doc/com.github.wechatpay-apiv3/wechatpay-java/latest/index.html&#34;&gt;&lt;img src=&#34;http://img.shields.io/badge/javadoc-reference-blue.svg?sanitize=true&#34; alt=&#34;JavaDoc&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/maven-central/v/com.github.wechatpay-apiv3/wechatpay-java?versionPrefix=0.2.7&#34; alt=&#34;Maven Central&#34;&gt; &lt;a href=&#34;https://sonarcloud.io/summary/overall?id=wechatpay-apiv3_wechatpay-java&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=wechatpay-apiv3_wechatpay-java&amp;amp;metric=security_rating&#34; alt=&#34;Security Rating&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/overall?id=wechatpay-apiv3_wechatpay-java&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=wechatpay-apiv3_wechatpay-java&amp;amp;metric=sqale_rating&#34; alt=&#34;Maintainability Rating&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/overall?id=wechatpay-apiv3_wechatpay-java&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=wechatpay-apiv3_wechatpay-java&amp;amp;metric=coverage&#34; alt=&#34;Coverage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;微信支付 APIv3 Java SDK&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/&#34;&gt;微信支付 APIv3&lt;/a&gt; 官方 Java 语言客户端开发库。&lt;/p&gt; &#xA;&lt;p&gt;开发库由 &lt;code&gt;core&lt;/code&gt; 和 &lt;code&gt;service&lt;/code&gt; 组成：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;core 为基础库，包含自动签名和验签的 HTTP 客户端、回调处理、加解密库。&lt;/li&gt; &#xA; &lt;li&gt;service 为业务服务，包含&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/main/java/com/wechat/pay/java/service&#34;&gt;业务接口&lt;/a&gt;和&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/example/java/com/wechat/pay/java/service&#34;&gt;使用示例&lt;/a&gt;。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;帮助微信支付改进&lt;/h2&gt; &#xA;&lt;p&gt;为了向广大开发者提供更好的使用体验，微信支付诚挚邀请您反馈使用微信支付 Java SDK 中的感受。您的反馈将对改进 SDK 大有帮助，点击参与&lt;a href=&#34;https://wj.qq.com/s2/11503706/aa9a/&#34;&gt;问卷调查&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;前置条件&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Java 1.8+。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pay.weixin.qq.com/index.php/apply/applyment_home/guide_normal&#34;&gt;成为微信支付商户&lt;/a&gt;。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/ren-zheng/zheng-shu#shang-hu-api-zheng-shu&#34;&gt;商户 API 证书&lt;/a&gt;：指由商户申请的，包含商户的商户号、公司名称、公钥信息的证书。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/ren-zheng/zheng-shu#shang-hu-api-si-yao&#34;&gt;商户 API 私钥&lt;/a&gt;：商户申请商户API证书时，会生成商户私钥，并保存在本地证书文件夹的文件 apiclient_key.pem 中。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/ren-zheng/api-v3-mi-yao&#34;&gt;APIv3 密钥&lt;/a&gt;：为了保证安全性，微信支付在回调通知和平台证书下载接口中，对关键信息进行了 AES-256-GCM 加密。APIv3 密钥是加密时使用的对称密钥。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;快速开始&lt;/h2&gt; &#xA;&lt;h3&gt;安装&lt;/h3&gt; &#xA;&lt;p&gt;最新版本已经在 &lt;a href=&#34;https://search.maven.org/artifact/com.github.wechatpay-apiv3/wechatpay-java&#34;&gt;Maven Central&lt;/a&gt; 发布。&lt;/p&gt; &#xA;&lt;h4&gt;Gradle&lt;/h4&gt; &#xA;&lt;p&gt;在你的 build.gradle 文件中加入如下的依赖&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;implementation &#39;com.github.wechatpay-apiv3:wechatpay-java:0.2.7&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Maven&lt;/h4&gt; &#xA;&lt;p&gt;加入以下依赖&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;com.github.wechatpay-apiv3&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;wechatpay-java&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;0.2.7&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;调用业务请求接口&lt;/h3&gt; &#xA;&lt;p&gt;以 Native 支付下单为例，先补充商户号等必要参数以构建 &lt;code&gt;config&lt;/code&gt;，再构建 &lt;code&gt;service&lt;/code&gt; 即可调用 &lt;code&gt;prepay()&lt;/code&gt; 发送请求。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.wechat.pay.java.service;&#xA;&#xA;import com.wechat.pay.java.core.Config;&#xA;import com.wechat.pay.java.core.RSAAutoCertificateConfig;&#xA;import com.wechat.pay.java.service.payments.nativepay.NativePayService;&#xA;import com.wechat.pay.java.service.payments.nativepay.model.Amount;&#xA;import com.wechat.pay.java.service.payments.nativepay.model.PrepayRequest;&#xA;import com.wechat.pay.java.service.payments.nativepay.model.PrepayResponse;&#xA;&#xA;/** Native 支付下单为例 */&#xA;public class QuickStart {&#xA;&#xA;    /** 商户号 */&#xA;    public static String merchantId = &#34;&#34;;&#xA;    /** 商户API私钥路径 */&#xA;    public static String privateKeyPath = &#34;&#34;;&#xA;    /** 商户证书序列号 */&#xA;    public static String merchantSerialNumber = &#34;&#34;;&#xA;    /** 商户APIV3密钥 */&#xA;    public static String apiV3key = &#34;&#34;;&#xA;&#xA;    public static void main(String[] args) {&#xA;        // 使用自动更新平台证书的RSA配置&#xA;        // 一个商户号只能初始化一个配置，否则会因为重复的下载任务报错&#xA;        Config config =&#xA;                new RSAAutoCertificateConfig.Builder()&#xA;                        .merchantId(merchantId)&#xA;                        .privateKeyFromPath(privateKeyPath)&#xA;                        .merchantSerialNumber(merchantSerialNumber)&#xA;                        .apiV3Key(apiV3key)&#xA;                        .build();&#xA;        // 构建service&#xA;        NativePayService service = new NativePayService.Builder().config(config).build();&#xA;        // request.setXxx(val)设置所需参数，具体参数可见Request定义&#xA;        PrepayRequest request = new PrepayRequest();&#xA;        Amount amount = new Amount();&#xA;        amount.setTotal(100);&#xA;        request.setAmount(amount);&#xA;        request.setAppid(&#34;wxa9d9651ae******&#34;);&#xA;        request.setMchid(&#34;190000****&#34;);&#xA;        request.setDescription(&#34;测试商品标题&#34;);&#xA;        request.setNotifyUrl(&#34;https://notify_url&#34;);&#xA;        request.setOutTradeNo(&#34;out_trade_no_001&#34;);&#xA;        // 调用下单方法，得到应答&#xA;        PrepayResponse response = service.prepay(request);&#xA;        // 使用微信扫描 code_url 对应的二维码，即可体验Native支付&#xA;        System.out.println(response.getCodeUrl());&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;从示例可见，使用 SDK 不需要计算请求签名和验证应答签名。详细代码可从 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/example/java/com/wechat/pay/java/service/QuickStart.java&#34;&gt;QuickStart&lt;/a&gt; 获得。&lt;/p&gt; &#xA;&lt;h2&gt;示例&lt;/h2&gt; &#xA;&lt;h3&gt;查询支付订单&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;QueryOrderByIdRequest queryRequest = new QueryOrderByIdRequest();&#xA;queryRequest.setMchid(&#34;190000****&#34;);&#xA;queryRequest.setTransactionId(&#34;4200001569202208304701234567&#34;);&#xA;&#xA;try {&#xA;  Transaction result = service.queryOrderById(queryRequest);&#xA;  System.out.println(result.getTradeState());&#xA;} catch (ServiceException e) {&#xA;  // API返回失败, 例如ORDER_NOT_EXISTS&#xA;  System.out.printf(&#34;code=[%s], message=[%s]\n&#34;, e.getErrorCode(), e.getErrorMessage());&#xA;  System.out.printf(&#34;reponse body=[%s]\n&#34;, e.getResponseBody());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;关闭订单&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CloseOrderRequest closeRequest = new CloseOrderRequest();&#xA;closeRequest.setMchid(&#34;190000****&#34;);&#xA;closeRequest.setOutTradeNo(&#34;out_trade_no_001&#34;);&#xA;// 方法没有返回值，意味着成功时API返回204 No Content&#xA;service.closeOrder(closeRequest);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;下单并生成调起支付的参数&lt;/h3&gt; &#xA;&lt;p&gt;JSAPI 支付和 APP 支付推荐使用服务拓展类 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/raw/main/service/src/main/java/com/wechat/pay/java/service/payments/jsapi/JsapiServiceExtension.java&#34;&gt;JsapiServiceExtension&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/raw/main/service/src/main/java/com/wechat/pay/java/service/payments/app/AppServiceExtension.java&#34;&gt;AppServiceExtension&lt;/a&gt;，两者包含了下单并返回调起支付参数方法。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;JsapiServiceExtension service = new JsapiServiceExtension.Builder().config(config).build();&#xA;&#xA;// 跟之前下单示例一样，填充预下单参数&#xA;PrepayRequest request = new PrepayRequest();&#xA;&#xA;// response包含了调起支付所需的所有参数，可直接用于前端调起支付&#xA;PrepayWithRequestPaymentResponse response = service.prepayWithRequestPayment(request);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;更多示例&lt;/h3&gt; &#xA;&lt;p&gt;为了方便开发者快速上手，微信支付给每个服务生成了示例代码 &lt;code&gt;XxxServiceExample.java&lt;/code&gt;，可以在 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/example&#34;&gt;example&lt;/a&gt; 中查看。 例如：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/example/java/com/wechat/pay/java/service/payments/jsapi/JsapiServiceExtensionExample.java&#34;&gt;JsapiServiceExtensionExample.java&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/service/src/example/java/com/wechat/pay/java/service/file/FileUploadServiceExample.java&#34;&gt;FileServiceExample.java&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;错误处理&lt;/h2&gt; &#xA;&lt;p&gt;SDK 使用的是 unchecked exception，会抛出四种自定义异常。每种异常发生的场景及推荐的处理方式如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/exception/HttpException.java&#34;&gt;HttpException&lt;/a&gt;：调用微信支付服务，当发生 HTTP 请求异常时抛出该异常。 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;构建请求参数失败、发送请求失败、I/O错误：推荐上报监控和打印日志，并获取异常中的 HTTP 请求信息以定位问题。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/exception/ValidationException.java&#34;&gt;ValidationException&lt;/a&gt; ：当验证微信支付签名失败时抛出该异常。 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;验证微信支付返回签名失败：上报监控和日志打印。&lt;/li&gt; &#xA;   &lt;li&gt;验证微信支付回调通知签名失败：确认输入参数与 HTTP 请求信息是否一致，若一致，说明该回调通知参数被篡改导致验签失败。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/exception/ServiceException.java&#34;&gt;ServiceException&lt;/a&gt;：调用微信支付服务，发送 HTTP 请求成功，HTTP 状态码小于200或大于等于300。 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;状态码为5xx：主动重试。&lt;/li&gt; &#xA;   &lt;li&gt;状态码为其他：获取错误中的 &lt;code&gt;errorCode&lt;/code&gt; 、&lt;code&gt;errorMessage&lt;/code&gt;，上报监控和日志打印。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/exception/MalformedMessageException.java&#34;&gt;MalformedMessageException&lt;/a&gt;：服务返回成功，返回内容异常。 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;HTTP 返回 &lt;code&gt;Content-Type&lt;/code&gt; 不为 &lt;code&gt;application/json&lt;/code&gt;：不支持其他类型的返回体，&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/#%E4%B8%8B%E8%BD%BD%E8%B4%A6%E5%8D%95&#34;&gt;下载账单&lt;/a&gt; 应使用 &lt;code&gt;download()&lt;/code&gt; 方法。&lt;/li&gt; &#xA;   &lt;li&gt;解析 HTTP 返回体失败：上报监控和日志打印。&lt;/li&gt; &#xA;   &lt;li&gt;回调通知参数不正确：确认传入参数是否与 HTTP 请求信息一致，传入参数是否存在编码或者 HTML 转码问题。&lt;/li&gt; &#xA;   &lt;li&gt;解析回调请求体为 JSON 字符串失败：上报监控和日志打印。&lt;/li&gt; &#xA;   &lt;li&gt;解密回调通知内容失败：确认传入的 apiV3 密钥是否正确。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;自动更新微信支付平台证书&lt;/h2&gt; &#xA;&lt;p&gt;在 API 请求过程中，客户端需使用微信支付平台证书，验证服务器应答的真实性和完整性。 在 v0.2.3 版本，我们加入了自动更新平台证书的配置类 &lt;code&gt;RSAAutoCertificateConfig&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Config config =&#xA;    new RSAAutoCertificateConfig.Builder()&#xA;        .merchantId(merchantId)&#xA;        .privateKeyFromPath(privateKeyPath)&#xA;        .merchantSerialNumber(merchantSerialNumber)&#xA;        .apiV3Key(apiV3key)&#xA;        .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;RSAAutoCertificateConfig&lt;/code&gt; 通过 &lt;code&gt;RSAAutoCertificateProvider&lt;/code&gt; 自动下载微信支付平台证书。 同时，&lt;code&gt;RSAAutoCertificateProvider&lt;/code&gt; 会启动一个后台线程，定时更新证书（目前设计为60分钟），以实现证书过期时的新老证书平滑切换。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;每个商户号只能创建一个 &lt;code&gt;RSAAutoCertificateConfig&lt;/code&gt;。同一个商户号构造多个实例，会抛出 &lt;code&gt;IllegalStateException&lt;/code&gt; 异常。&lt;/p&gt; &#xA; &lt;p&gt;我们建议你将配置类作为全局变量。如果你的程序是多线程，建议使用&lt;strong&gt;多线程安全&lt;/strong&gt;的单例模式。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;使用本地的微信支付平台证书&lt;/h3&gt; &#xA;&lt;p&gt;如果你不想使用 SDK 提供的定时更新平台证书，你可以使用配置类 &lt;code&gt;RSAConfig&lt;/code&gt; 加载本地证书。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Config config =&#xA;    new RSAConfig.Builder()&#xA;        .merchantId(merchantId)&#xA;        .privateKeyFromPath(privateKeyPath)&#xA;        .merchantSerialNumber(merchantSerialNumber)&#xA;        .wechatPayCertificatesFromPath(wechatPayCertificatePath)&#xA;        .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;回调通知验签和解密&lt;/h2&gt; &#xA;&lt;p&gt;首先，你需要在你的服务器上创建一个公开的 HTTP 端点，接受来自微信支付的回调通知。 当接收到回调通知，使用 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/notification&#34;&gt;notification&lt;/a&gt; 中的 &lt;code&gt;NotificationParser&lt;/code&gt; 解析回调通知。&lt;/p&gt; &#xA;&lt;p&gt;具体步骤如下：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;使用回调通知请求的数据，构建 &lt;code&gt;RequestParam&lt;/code&gt;。 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;HTTP 头 &lt;code&gt;Wechatpay-Signature&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;HTTP 头 &lt;code&gt;Wechatpay-Nonce&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;HTTP 头 &lt;code&gt;Wechatpay-Timestamp&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;HTTP 头 &lt;code&gt;Wechatpay-Serial&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;HTTP 头 &lt;code&gt;Wechatpay-Signature-Type&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;HTTP 请求体 body。切记使用原始报文，不要用 JSON 对象序列化后的字符串，避免验签的 body 和原文不一致。&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;初始化 &lt;code&gt;RSAAutoCertificateConfig&lt;/code&gt;。微信支付平台证书由 SDK 的自动更新平台能力提供，也可以使用本地证书。&lt;/li&gt; &#xA; &lt;li&gt;初始化 &lt;code&gt;NotificationParser&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;调用 &lt;code&gt;NotificationParser.parse()&lt;/code&gt; 验签、解密并将 JSON 转换成具体的通知回调对象。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 构造 RequestParam&#xA;RequestParam requestParam = new RequestParam.Builder()&#xA;        .serialNumber(wechatPayCertificateSerialNumber)&#xA;        .nonce(nonce)&#xA;        .signature(signature)&#xA;        .timestamp(timestamp)&#xA;        .body(requestBody)&#xA;        .build();&#xA;&#xA;// 如果已经初始化了 RSAAutoCertificateConfig，可直接使用&#xA;// 没有的话，则构造一个&#xA;NotificationConfig config = new RSAAutoCertificateConfig.Builder()&#xA;        .merchantId(merchantId)&#xA;        .privateKeyFromPath(privateKeyPath)&#xA;        .merchantSerialNumber(merchantSerialNumber)&#xA;        .apiV3Key(apiV3key)&#xA;        .build();&#xA;&#xA;// 初始化 NotificationParser&#xA;NotificationParser parser = new NotificationParser(config);&#xA;&#xA;// 以支付通知回调为例，验签、解密并转换成 Transaction&#xA;Transaction transaction = parser.parse(requestParam, Transaction.class);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;常用的通知回调对象类型：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;支付 &lt;code&gt;Transaction&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;退款 &lt;code&gt;RefundNotification&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;若 SDK 暂不支持的类型，请使用 &lt;code&gt;Map.class&lt;/code&gt;，嵌套的 Json 对象将被转换成 &lt;code&gt;LinkedTreeMap&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;你既可以为每个通知回调使用不同的 HTTP 端点，也可以使用一个端点根据 &lt;code&gt;event_type&lt;/code&gt; 处理不同的通知回调。 我们建议，不同的通知回调使用不同的端点，直接调用 SDK 处理通知回调，避免商户自己解析报文。因为 SDK 会先验证通知回调的有效性，可有效防止&#34;坏人&#34;的报文攻击。&lt;/p&gt; &#xA;&lt;h2&gt;发送 HTTP 请求&lt;/h2&gt; &#xA;&lt;p&gt;如果 SDK 未支持你需要的接口，你可以使用 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/http/okhttp/OkHttpClientAdapter.java&#34;&gt;OkHttpClientAdapter&lt;/a&gt; 的实现类发送 HTTP 请求，它会自动生成签名和验证签名。&lt;/p&gt; &#xA;&lt;p&gt;发送请求步骤如下：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;初始化 &lt;code&gt;OkHttpClientAdapter&lt;/code&gt;，建议使用 &lt;code&gt;DefaultHttpClientBuilder&lt;/code&gt; 构建。&lt;/li&gt; &#xA; &lt;li&gt;构建请求 &lt;code&gt;HttpRequest&lt;/code&gt;。&lt;/li&gt; &#xA; &lt;li&gt;调用 &lt;code&gt;httpClient.execute&lt;/code&gt; 或者 &lt;code&gt;httpClient.get&lt;/code&gt; 等方法来发送 HTTP 请求。&lt;code&gt;httpClient.execute&lt;/code&gt; 支持发送 GET、PUT、POST、PATCH、DELETE 请求，也可以调用指定的 HTTP 方法发送请求。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/test/java/com/wechat/pay/java/core/http/OkHttpClientAdapterTest.java&#34;&gt;OkHttpClientAdapterTest&lt;/a&gt; 中演示了如何构造和发送 HTTP 请求。如果现有的 &lt;code&gt;OkHttpClientAdapter&lt;/code&gt; 实现类不满足你的需求，可以继承 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/http/AbstractHttpClient.java&#34;&gt;AbstractHttpClient&lt;/a&gt; 拓展实现。&lt;/p&gt; &#xA;&lt;h3&gt;下载账单&lt;/h3&gt; &#xA;&lt;p&gt;因为下载的账单文件可能会很大，为了平衡系统性能和签名验签的实现成本，&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_8.shtml&#34;&gt;账单下载API&lt;/a&gt; 被分成了两个步骤：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;/v3/bill/tradebill&lt;/code&gt; 申请账单下载链接，并获取账单摘要。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/v3/billdownload/file&lt;/code&gt; 账单文件下载，请求需签名但应答不签名。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;SDK 提供了 &lt;code&gt;HttpClient.download()&lt;/code&gt; 方法。它返回账单的输入流。开发者使用完输入流后，应自主关闭流。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;InputStream inputStream = httpClient.download(downloadUrl);&#xA;&#xA;// 非压缩的账单可使用 core.util.IOUtil 从流读入内存字符串，大账单请慎用&#xA;String respBody = IOUtil.toString(inputStream);&#xA;inputStream.close();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;开发者在下载文件之后，应使用第一步获取的账单摘要校验文件的完整性。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;敏感信息加解密&lt;/h2&gt; &#xA;&lt;p&gt;为了保证通信过程中敏感信息字段（如用户的住址、银行卡号、手机号码等）的机密性，&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;微信支付要求加密上送的敏感信息&lt;/li&gt; &#xA; &lt;li&gt;微信支付会加密下行的敏感信息&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;详见 &lt;a href=&#34;https://wechatpay-api.gitbook.io/wechatpay-api-v3/qian-ming-zhi-nan-1/min-gan-xin-xi-jia-mi&#34;&gt;接口规则 - 敏感信息加解密&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h3&gt;自动加解密&lt;/h3&gt; &#xA;&lt;p&gt;如果是 SDK 已支持的接口，例如商家转账，SDK 将根据契约自动对敏感信息做加解密：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;发起请求时，开发者设置原文。SDK 自动加密敏感信息，并设置 &lt;code&gt;Wechatpay-Serial&lt;/code&gt; 请求头&lt;/li&gt; &#xA; &lt;li&gt;收到应答时，解密器自动解密敏感信息，开发者得到原文&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;手动加解密&lt;/h3&gt; &#xA;&lt;p&gt;如果是 SDK 尚未支持的接口，你可以使用 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/cipher&#34;&gt;cipher&lt;/a&gt; 中的 &lt;code&gt;RSAPrivacyEncryptor&lt;/code&gt; 和 &lt;code&gt;RSAPrivacyDecryptor&lt;/code&gt; ，手动对敏感信息加解密。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 微信支付平台证书中的公钥&#xA;PublicKey wechatPayPublicKey = null;&#xA;String plaintext = &#34;&#34;;&#xA;PrivacyEncryptor encryptor = new RSAPrivacyEncryptor(wechatPayPublicKey);&#xA;String ciphertext = encryptor.encryptToString(plaintext);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 商户私钥&#xA;PrivateKey merchantPrivateKey = null;&#xA;String ciphertext = &#34;&#34;;&#xA;PrivacyDecryptor decryptor = new RSAPrivacyDecryptor(merchantPrivateKey);&#xA;String plaintext = decryptor.decryptToString(ciphertext);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/test/java/com/wechat/pay/java/core/cipher/RSAPrivacyEncryptorTest.java&#34;&gt;RSAPrivacyEncryptorTest&lt;/a&gt; 和 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/test/java/com/wechat/pay/java/core/cipher/RSAPrivacyDecryptorTest.java&#34;&gt;RSAPrivacyDecryptorTest&lt;/a&gt; 中演示了如何使用以上函数做敏感信息加解密。&lt;/p&gt; &#xA;&lt;h2&gt;日志&lt;/h2&gt; &#xA;&lt;p&gt;SDK 使用了 &lt;a href=&#34;http://www.slf4j.org/&#34;&gt;SLF4j&lt;/a&gt; 作为日志框架的接口。这样，你可以使用你熟悉的日志框架，例如 &lt;a href=&#34;https://logback.qos.ch/documentation.html&#34;&gt;Logback&lt;/a&gt;、&lt;a href=&#34;https://github.com/apache/logging-log4j2&#34;&gt;Log4j2&lt;/a&gt; 或者 &lt;a href=&#34;https://www.slf4j.org/manual.html&#34;&gt;SLF4j-simple&lt;/a&gt;。 SDK 的日志会跟你的日志记录在一起。&lt;/p&gt; &#xA;&lt;p&gt;为了启用日志，你应在你的构建脚本中添加日志框架的依赖。如果不配置日志框架，默认是使用 SLF4j 提供的 空（NOP）日志实现，它不会记录任何日志。&lt;/p&gt; &#xA;&lt;h2&gt;使用国密&lt;/h2&gt; &#xA;&lt;p&gt;我们提供基于 &lt;a href=&#34;https://github.com/Tencent/TencentKonaSMSuite&#34;&gt;腾讯 Kona 国密套件&lt;/a&gt; 的国密扩展。文档请参考 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/shangmi/README.md&#34;&gt;shangmi/README.md&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;常见问题&lt;/h2&gt; &#xA;&lt;h3&gt;为什么收到应答中的证书序列号和发起请求的证书序列号不一致？&lt;/h3&gt; &#xA;&lt;p&gt;请求和应答使用 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0&#34;&gt;数字签名&lt;/a&gt; ，保证数据传递的真实、完整和不可否认。为了验签方能识别数字签名使用的密钥（特别是密钥和证书更换期间），微信支付 APIv3 要求签名和相应的证书序列号一起传输。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;商户请求使用&lt;strong&gt;商户API私钥&lt;/strong&gt;签名。商户应上送商户证书序列号。&lt;/li&gt; &#xA; &lt;li&gt;微信支付应答使用&lt;strong&gt;微信支付平台私钥&lt;/strong&gt;签名。微信支付应答返回微信支付平台证书序列号。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;综上所述，请求和应答的证书序列号是不一致的。&lt;/p&gt; &#xA;&lt;h3&gt;证书和回调解密需要的 AesGcm 解密在哪里？&lt;/h3&gt; &#xA;&lt;p&gt;请参考 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/main/java/com/wechat/pay/java/core/cipher/AeadAesCipher.java&#34;&gt;AeadAesCipher&lt;/a&gt; 和 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/core/src/test/java/com/wechat/pay/java/core/cipher/AeadAesCipherTest.java&#34;&gt;AeadAesCipherTest&lt;/a&gt; 。&lt;/p&gt; &#xA;&lt;p&gt;由于 SDK 已经提供了微信支付平台证书下载服务 &lt;code&gt;CertificateService&lt;/code&gt; 以及回调通知解析器 &lt;code&gt;NotificationParser&lt;/code&gt; ，这两者会完成所有的解析与解密工作。因此除非你想要自定义实现，否则你应该不需要用到 &lt;code&gt;AeadXxxCipher&lt;/code&gt; 中提供的方法。&lt;/p&gt; &#xA;&lt;h3&gt;为什么我使用 &lt;code&gt;NotificationHandler&lt;/code&gt; 验证回调通知失败，抛出 &lt;code&gt;ValidationException&lt;/code&gt;？&lt;/h3&gt; &#xA;&lt;p&gt;如果你使用的是 SDK 自动更新的微信支付平台证书，验证失败原因是：参与验证的参数不正确。从开发者反馈来看，大部分失败案例没有使用回调原始 body，而是用 body 反序列化得到的对象再做 JSON 序列化得到的 body。很遗憾，这样的 body 几乎一定跟原始报文&lt;strong&gt;不一致&lt;/strong&gt;，所以签名验证不通过。具体案例可参考 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/issues/112&#34;&gt;#112&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;如果你使用的是本地的微信支付平台证书，请检查微信支付平台证书是否正确，不要把商户证书和微信支付平台证书搞混了。&lt;/p&gt; &#xA;&lt;h3&gt;如何计算前端签名？&lt;/h3&gt; &#xA;&lt;p&gt;有一部分 API 需要计算前端签名，例如调起支付、调起支付分小程序等。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;调起支付签名，SDK 提供了下单并生成调起支付参数的方法，请参考 &lt;a href=&#34;https://raw.githubusercontent.com/wechatpay-apiv3/wechatpay-java/main/#%E4%B8%8B%E5%8D%95%E5%B9%B6%E7%94%9F%E6%88%90%E8%B0%83%E8%B5%B7%E6%94%AF%E4%BB%98%E7%9A%84%E5%8F%82%E6%95%B0&#34;&gt;示例&lt;/a&gt;。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;其他场景计算签名，请参考 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/raw/968a2ff8fb35c808f82827342abb100e30691a98/service/src/main/java/com/wechat/pay/java/service/payments/jsapi/JsapiServiceExtension.java#L59&#34;&gt;JsapiServiceExtension&lt;/a&gt; 使用 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/raw/main/core/src/main/java/com/wechat/pay/java/core/cipher/Signer.java&#34;&gt;Signer&lt;/a&gt; 计算签名的例子。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;为什么快速开始的示例程序执行后，程序不会退出？&lt;/h3&gt; &#xA;&lt;p&gt;是的，因为示例使用了自动更新微信支付平台证书，它会启动一个背景线程以定时更新证书。这个线程不会自动退出。&lt;/p&gt; &#xA;&lt;p&gt;你可以主动终止程序，退出不会有副作用。 我们也在考虑如何提供优雅的退出方式。&lt;/p&gt; &#xA;&lt;h2&gt;如何参与开发&lt;/h2&gt; &#xA;&lt;p&gt;微信支付欢迎来自社区的开发者贡献你们的想法和代码。请你在提交 PR 之前，先提一个对应的 issue 说明以下内容：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;背景（如，遇到的问题）和目的。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;着重&lt;/strong&gt;说明你的想法。&lt;/li&gt; &#xA; &lt;li&gt;通过代码或者其他方式，简要的说明是如何实现的，或者它会是如何使用。&lt;/li&gt; &#xA; &lt;li&gt;是否影响现有的接口。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;联系微信支付&lt;/h2&gt; &#xA;&lt;p&gt;如果你发现了 BUG，或者需要的功能还未支持，或者有任何疑问、建议，欢迎通过 &lt;a href=&#34;https://github.com/wechatpay-apiv3/wechatpay-java/issues&#34;&gt;issue&lt;/a&gt; 反馈。&lt;/p&gt; &#xA;&lt;p&gt;也欢迎访问微信支付的 &lt;a href=&#34;https://developers.weixin.qq.com/community/pay&#34;&gt;开发者社区&lt;/a&gt;。&lt;/p&gt;</summary>
  </entry>
</feed>