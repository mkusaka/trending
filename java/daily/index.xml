<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-03T01:31:57Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>eugene-khyst/postgresql-event-sourcing</title>
    <updated>2023-11-03T01:31:57Z</updated>
    <id>tag:github.com,2023-11-03:/eugene-khyst/postgresql-event-sourcing</id>
    <link href="https://github.com/eugene-khyst/postgresql-event-sourcing" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A reference implementation of an event-sourced system that uses PostgreSQL as an event store built with Spring Boot. Fork the repository and use it as a template for your projects. Or clone the repository and run end-to-end tests to see how everything works together.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a id=&#34;0&#34;&gt;&lt;/a&gt;Event Sourcing with PostgreSQL&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#1&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#2&#34;&gt;Example domain&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#3&#34;&gt;Event sourcing and CQRS basics&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#3-1&#34;&gt;State-oriented persistence&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#3-2&#34;&gt;Event sourcing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#3-3&#34;&gt;Snapshotting&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#3-4&#34;&gt;Querying the data&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#3-5&#34;&gt;CQRS&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#3-6&#34;&gt;Event handlers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#3-7&#34;&gt;Domain events vs Integration events&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#3-8&#34;&gt;Advantages of CQRS&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#3-9&#34;&gt;Advantages of event sourcing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4&#34;&gt;Solution architecture&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-1&#34;&gt;Component diagram&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-2&#34;&gt;ER diagram&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-3&#34;&gt;Optimistic concurrency control&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-4&#34;&gt;Snapshotting&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-5&#34;&gt;Loading any revision of the aggregate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-6&#34;&gt;Synchronously updating projections&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-7&#34;&gt;Asynchronously sending integration events to a message broker&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-7-1&#34;&gt;Reliable transactional outbox with PostgreSQL&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-7-2&#34;&gt;Database polling&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-7-3&#34;&gt;Database polling alternative&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-8&#34;&gt;Adding new asynchronous event handlers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#4-9&#34;&gt;Drawbacks&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#5&#34;&gt;Project structure&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#5-1&#34;&gt;Gradle subprojects&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#5-2&#34;&gt;Database schema migrations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#5-3&#34;&gt;Class diagrams&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#5-3-1&#34;&gt;Class diagram of the domain model&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#5-3-2&#34;&gt;Class diagram of the projections&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#5-3-3&#34;&gt;Class diagram of the service layer&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#6&#34;&gt;How to adapt it to your domain?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/#7&#34;&gt;How to run the sample?&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- Table of contents is made with https://github.com/eugene-khyst/md-toc-cli --&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;1&#34;&gt;&lt;/a&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Usually, our applications operate with the current state of a domain object. But sometimes, we need to know the entire history of the domain object changes. For example, we want to know how an order got into its current state.&lt;/p&gt; &#xA;&lt;p&gt;The audit trail (also called the audit log) is a chronological record of the history and details of the actions that affected the system. An audit trail may be a regulatory or business requirement.&lt;/p&gt; &#xA;&lt;p&gt;We can store all changes to the domain object state as a sequence of events in an append-only event stream. Thus, event streams will contain an entire history of changes. But how can we be sure that this history is authentic and error-free? We can use event streams as a primary source of truth in a system. To get the current state of an object, we have to replay all events in the order of occurrence. This pattern is called event sourcing. The database for storing event streams is called an event store. Event sourcing provides a complete and accurate record of all changes made to a system. Event sourcing is an industry standard for implementing audit trail.&lt;/p&gt; &#xA;&lt;p&gt;There are specialized databases for event sourcing. Developer Advocates working for the companies behind these specialized databases said you shouldn&#39;t implement event sourcing with traditional relational or document-oriented databases. Is this true or just a marketing ploy?&lt;/p&gt; &#xA;&lt;p&gt;Specialized databases for event sourcing are convenient and provide the necessary functionality out of the box. But PostgreSQL, the world&#39;s most advanced open-source database, is also suitable for event sourcing. You can use PostgreSQL as an event store without additional frameworks or extensions instead of setting up and maintaining a separate specialized database for event sourcing.&lt;/p&gt; &#xA;&lt;p&gt;This repository provides a reference implementation of an event-sourced system that uses PostgreSQL as an event store built with Spring Boot. &lt;a href=&#34;https://github.com/eugene-khyst/postgresql-event-sourcing/fork&#34;&gt;Fork&lt;/a&gt; the repository and use it as a template for your projects. Or clone the repository and run end-to-end tests to see how everything works together.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/potgresql-logo.png&#34; alt=&#34;PostgreSQL Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;See also&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/eugene-khyst/eventstoredb-event-sourcing&#34;&gt;Event Sourcing with EventStoreDB&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/eugene-khyst/ksqldb-event-souring&#34;&gt;Event Sourcing with Kafka and ksqlDB&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;2&#34;&gt;&lt;/a&gt;Example domain&lt;/h2&gt; &#xA;&lt;p&gt;This sample uses a simplified domain model of the ride-hailing system.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A rider can place an order for a ride along a route specifying a price.&lt;/li&gt; &#xA; &lt;li&gt;A rider can edit an order price to pay more instead of waiting in cases of very high demand.&lt;/li&gt; &#xA; &lt;li&gt;A driver can accept an order.&lt;/li&gt; &#xA; &lt;li&gt;A driver can complete previously accepted order.&lt;/li&gt; &#xA; &lt;li&gt;An order can be canceled before completion.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/domain-1.svg?sanitize=true&#34; alt=&#34;Domain use case diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/domain-2.svg?sanitize=true&#34; alt=&#34;Domain state diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;3&#34;&gt;&lt;/a&gt;Event sourcing and CQRS basics&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;3-1&#34;&gt;&lt;/a&gt;State-oriented persistence&lt;/h3&gt; &#xA;&lt;p&gt;State-oriented persistence (CRUD) applications store only the latest version of an entity. Database records present entities. When an entity is updated, the corresponding database record gets updated too. SQL &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements are used.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/state-oriented-persistence.svg?sanitize=true&#34; alt=&#34;State-oriented persistence&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;3-2&#34;&gt;&lt;/a&gt;Event sourcing&lt;/h3&gt; &#xA;&lt;p&gt;Event sourcing applications persist the state of an entity as a sequence of immutable state-changing events.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/event-sourcing-1.svg?sanitize=true&#34; alt=&#34;Event sourcing&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Whenever the state of an entity changes, a new event is appended to the list of events. Only SQL &lt;code&gt;INSERT&lt;/code&gt; statements are used. Events are immutables, so SQL &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements are not used.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/event-sourcing-2.svg?sanitize=true&#34; alt=&#34;Event sourcing&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The current state of an entity can be restored by replaying all its events.&lt;/p&gt; &#xA;&lt;p&gt;Event sourcing is closely related to domain-driven design (DDD) and shares some terminology.&lt;/p&gt; &#xA;&lt;p&gt;An entity in event sourcing is called an &lt;strong&gt;aggregate&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A sequence of events for the same aggregate is called a &lt;strong&gt;stream&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Event sourcing is best suited for short-living entities with a small total number of events (e.g., orders).&lt;/p&gt; &#xA;&lt;p&gt;Restoring the state of the short-living entity by replaying all its events doesn&#39;t have any performance impact. Thus, no optimizations for restoring state are required for short-living entities.&lt;/p&gt; &#xA;&lt;p&gt;For endlessly stored entities (e.g., users, bank accounts) with thousands of events restoring state by replaying all events is not optimal, and snapshotting should be considered.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;3-3&#34;&gt;&lt;/a&gt;Snapshotting&lt;/h3&gt; &#xA;&lt;p&gt;Snapshotting is an optimization technique where a snapshot of the aggregate&#39;s state is also saved, so an application can restore the current state of the aggregate from the snapshot rather than from all the events (potentially thousands).&lt;/p&gt; &#xA;&lt;p&gt;On every &lt;em&gt;nth&lt;/em&gt; event, make an aggregate snapshot by storing an aggregate state and its version.&lt;/p&gt; &#xA;&lt;p&gt;To restore an aggregate state:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;first read the latest snapshot,&lt;/li&gt; &#xA; &lt;li&gt;then read events forward from the original stream starting from the version pointed by the snapshot.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/event-sourcing-snapshotting.svg?sanitize=true&#34; alt=&#34;Snapshotting in event souring&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;3-4&#34;&gt;&lt;/a&gt;Querying the data&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s easy to find an aggregate by ID, but other queries are difficult. Since aggregates are stored as append-only lists of immutable events, querying the data using SQL, as we used to, is impossible. To find an aggregate by some field, we need to first read all the events and replay them to restore all the aggregates.&lt;/p&gt; &#xA;&lt;p&gt;To bring back all the querying power a relational database has to offer, we can create a dedicated read model derived from the event stream.&lt;/p&gt; &#xA;&lt;p&gt;The event stream is the write model and the primary source of truth.&lt;/p&gt; &#xA;&lt;p&gt;The read model is a &#34;denormalized&#34; view of the write model, allowing faster and more convenient querying. Read models are projections of the system state. Therefore, read models are also known as &lt;strong&gt;projections&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Projections provide a view of data for a single aggregate type or perform aggregations and combine data from multiple aggregate types.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s where CQRS comes in handy.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;3-5&#34;&gt;&lt;/a&gt;CQRS&lt;/h3&gt; &#xA;&lt;p&gt;Command-query responsibility segregation (CQRS) stands for segregating the responsibility between commands (write requests) and queries (read requests). The write requests and the read requests are processed by different handlers.&lt;/p&gt; &#xA;&lt;p&gt;A command generates zero or more events or results in an error.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/cqrs-1.svg?sanitize=true&#34; alt=&#34;CQRS&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;CQRS is a self-sufficient architectural pattern and doesn&#39;t require event sourcing. But in practice, event sourcing is usually used in conjunction with CQRS. Event store is used as a write database, and SQL or NoSQL database as a read database.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/cqrs-2.svg?sanitize=true&#34; alt=&#34;CQRS with event sourcing&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;3-6&#34;&gt;&lt;/a&gt;Event handlers&lt;/h3&gt; &#xA;&lt;p&gt;Commands generate events. Event processing is done by &lt;strong&gt;event handlers&lt;/strong&gt;. As a part of event processing, we may need to update projections, send a message to a message broker, or make an API call.&lt;/p&gt; &#xA;&lt;p&gt;There are two types of event handlers: &lt;strong&gt;synchronous&lt;/strong&gt; and &lt;strong&gt;asynchronous&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Storing the write model and read model in the same database allows for transactional updates of the read model. Each time we append a new event, the projection is updated &lt;strong&gt;synchronously&lt;/strong&gt; in the same transaction. The projection is &lt;strong&gt;consistent&lt;/strong&gt; with the event stream.&lt;/p&gt; &#xA;&lt;p&gt;When an event handler communicates with an external system or middleware (e.g., sends a message to Kafka), it should run &lt;strong&gt;asynchronously&lt;/strong&gt; after the transaction updating the write model. Asynchronous execution leads to &lt;strong&gt;eventual consistency&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Communication with external systems should not occur in the same transaction updating the write model. The external system call may succeed, but the transaction will later be rolled back, resulting in an inconsistency.&lt;/p&gt; &#xA;&lt;p&gt;Anyway, distributed systems should be designed with eventual consistency in mind.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;3-7&#34;&gt;&lt;/a&gt;Domain events vs Integration events&lt;/h3&gt; &#xA;&lt;p&gt;Events in event sourcing are &lt;strong&gt;domain events&lt;/strong&gt;. The domain event is a part of a bounded context and should not be used &#34;as-is&#34; for integration with other bounded contexts.&lt;/p&gt; &#xA;&lt;p&gt;For communication between bounded contexts &lt;strong&gt;integration events&lt;/strong&gt; are used. The integration event represents the current state of an aggregate, not just changes to the aggregate as a domain event.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;3-8&#34;&gt;&lt;/a&gt;Advantages of CQRS&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Independent scaling of the read and write databases.&lt;/li&gt; &#xA; &lt;li&gt;Optimized data schema for the read database (e.g. the read databases can be denormalized).&lt;/li&gt; &#xA; &lt;li&gt;Simpler queries (e.g. complex &lt;code&gt;JOIN&lt;/code&gt; operations can be avoided).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;3-9&#34;&gt;&lt;/a&gt;Advantages of event sourcing&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A true history of the system (audit and traceability). An industry standard for implementing audit trail.&lt;/li&gt; &#xA; &lt;li&gt;Ability to put the system in any prior state (e.g. for debugging).&lt;/li&gt; &#xA; &lt;li&gt;New read-side projections can be created as needed (later) from events. It allows responding to future needs and new requirements.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;4&#34;&gt;&lt;/a&gt;Solution architecture&lt;/h2&gt; &#xA;&lt;p&gt;PostgreSQL can be used as an event store. It will natively support appending events, concurrency control and reading events. Subscribing on events requires additional implementation.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;4-1&#34;&gt;&lt;/a&gt;Component diagram&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/postgresql-event-sourcing.svg?sanitize=true&#34; alt=&#34;PostgreSQL event store component diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;4-2&#34;&gt;&lt;/a&gt;ER diagram&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/er-diagram.svg?sanitize=true&#34; alt=&#34;PostgreSQL event store ER diagram&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Events are stored in the &lt;code&gt;ES_EVENT&lt;/code&gt; table.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;4-3&#34;&gt;&lt;/a&gt;Optimistic concurrency control&lt;/h3&gt; &#xA;&lt;p&gt;Latest aggregate version is stored in the &lt;code&gt;ES_AGGREGATE&lt;/code&gt; table. Version checking is used for optimistic concurrency control. Version checking uses version numbers to detect conflicting updates (and to prevent lost updates).&lt;/p&gt; &#xA;&lt;p&gt;Appending an event operation consists of 2 SQL statements in a single transaction:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;check the actual and expected version match and increment the version &lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE ES_AGGREGATE&#xA;   SET VERSION = :newVersion&#xA; WHERE ID = :aggregateId&#xA;   AND VERSION = :expectedVersion&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;insert new event &lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO ES_EVENT (TRANSACTION_ID, AGGREGATE_ID, VERSION, EVENT_TYPE, JSON_DATA)&#xA;VALUES(pg_current_xact_id(), :aggregateId, :version, :eventType, :jsonObj::json)&#xA;RETURNING ID, TRANSACTION_ID::text, EVENT_TYPE, JSON_DATA&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;code&gt;pg_current_xact_id()&lt;/code&gt; returns the current transaction&#39;s ID. The need for this will be explained later.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/event-sourcing-concurrency.svg?sanitize=true&#34; alt=&#34;Optimistic Concurrency Control&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;4-4&#34;&gt;&lt;/a&gt;Snapshotting&lt;/h3&gt; &#xA;&lt;p&gt;On every &lt;em&gt;nth&lt;/em&gt; event insert an aggregate state (snapshot) to the &lt;code&gt;ES_AGGREGATE_SNAPSHOT&lt;/code&gt; table specifying the version&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO ES_AGGREGATE_SNAPSHOT (AGGREGATE_ID, VERSION, JSON_DATA)&#xA;VALUES (:aggregateId, :version, :jsonObj::json)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Snapshotting for an aggregate type can be disabled and configured in the &lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/src/main/resources/application.yml&#34;&gt;&lt;code&gt;application.yml&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;event-sourcing:&#xA;  snapshotting:&#xA;    # com.example.eventsourcing.domain.AggregateType&#xA;    ORDER:&#xA;      enabled: true&#xA;      # Create a snapshot on every nth event&#xA;      nth-event: 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;4-5&#34;&gt;&lt;/a&gt;Loading any revision of the aggregate&lt;/h3&gt; &#xA;&lt;p&gt;To restore any revision of the aggregate:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;first read the latest value of the snapshot &lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT a.AGGREGATE_TYPE,&#xA;       s.JSON_DATA&#xA;  FROM ES_AGGREGATE_SNAPSHOT s&#xA;  JOIN ES_AGGREGATE a ON a.ID = s.AGGREGATE_ID&#xA; WHERE s.AGGREGATE_ID = :aggregateId&#xA;   AND (:version IS NULL OR s.VERSION &amp;lt;= :version)&#xA; ORDER BY s.VERSION DESC&#xA; LIMIT 1&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;then read forward from the event stream from the revision the snapshot points to &lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT ID,&#xA;       TRANSACTION_ID::text,&#xA;       EVENT_TYPE,&#xA;       JSON_DATA&#xA;  FROM ES_EVENT&#xA; WHERE AGGREGATE_ID = :aggregateId&#xA;   AND (:fromVersion IS NULL OR VERSION &amp;gt; :fromVersion)&#xA;   AND (:toVersion IS NULL OR VERSION &amp;lt;= :toVersion)&#xA; ORDER BY VERSION ASC&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;4-6&#34;&gt;&lt;/a&gt;Synchronously updating projections&lt;/h3&gt; &#xA;&lt;p&gt;Using PostgreSQL as an event store and a read database allows for transactional updates of the read model. Each time we append a new event, the projection is updated synchronously in the same transaction. It&#39;s a big advantage because sometimes consistency is not so easy to achieve.&lt;/p&gt; &#xA;&lt;p&gt;You can&#39;t get consistent projections when a separate database is used as an event store.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;4-7&#34;&gt;&lt;/a&gt;Asynchronously sending integration events to a message broker&lt;/h3&gt; &#xA;&lt;p&gt;Integration events should be sent asynchronously after the transaction updating the write model.&lt;/p&gt; &#xA;&lt;p&gt;PostgreSQL doesn&#39;t allow subscribing on changes, so the solution is a Transactional Outbox pattern. A service that uses a database inserts events into an outbox table as part of the local transaction. A separate process publishes the events inserted into database to a message broker.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/transactional-outbox-1.svg?sanitize=true&#34; alt=&#34;Transactional outbox pattern&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;We may have multiple asynchronous event handlers or so-called subscriptions. The subscription concept is required to keep track of delivered events separately for different event handlers. The last event processed by the event handler (subscription) is stored in the separate table &lt;code&gt;ES_EVENT_SUBSCRIPTION&lt;/code&gt;. New events are processed by polling the &lt;code&gt;ES_EVENT&lt;/code&gt; table.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/transactional-outbox-2.svg?sanitize=true&#34; alt=&#34;Transactional outbox pattern with subscriptions&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Since multiple instances of this application can run in parallel, we need to ensure that any processing only affects the event once. We don&#39;t want more than one event handler instance to handle the same event.&lt;/p&gt; &#xA;&lt;p&gt;This is achieved by acquiring locks on the rows of the &lt;code&gt;ES_EVENT_SUBSCRIPTION&lt;/code&gt; table. We lock the row (&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;) of the currently processed subscription.&lt;/p&gt; &#xA;&lt;p&gt;To not hang other backend instances, we want to skip already locked rows (&lt;code&gt;SELECT FOR UPDATE SKIP LOCKED&lt;/code&gt;) and lock the &#34;next&#34; subscription. It allows multiple backend instances to select different subscriptions that do not overlap. This way, we improve availability and scalability.&lt;/p&gt; &#xA;&lt;p&gt;The event subscription processor polls &lt;code&gt;ES_EVENT_SUBSCRIPTION&lt;/code&gt; table every second (interval is configurable) for new events and processes them:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;read the last transaction ID and event ID processed by the subscription and acquire lock &lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT LAST_TRANSACTION_ID::text,&#xA;       LAST_EVENT_ID&#xA;  FROM ES_EVENT_SUBSCRIPTION&#xA; WHERE SUBSCRIPTION_NAME = :subscriptionName&#xA;   FOR UPDATE SKIP LOCKED&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;read new events &lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT e.ID,&#xA;       e.TRANSACTION_ID::text,&#xA;       e.EVENT_TYPE,&#xA;       e.JSON_DATA&#xA;  FROM ES_EVENT e&#xA;  JOIN ES_AGGREGATE a on a.ID = e.AGGREGATE_ID&#xA; WHERE a.AGGREGATE_TYPE = :aggregateType&#xA;   AND (e.TRANSACTION_ID, e.ID) &amp;gt; (:lastProcessedTransactionId::xid8, :lastProcessedEventId)&#xA;   AND e.TRANSACTION_ID &amp;lt; pg_snapshot_xmin(pg_current_snapshot())&#xA; ORDER BY e.TRANSACTION_ID ASC, e.ID ASC&#xA;&lt;/code&gt;&lt;/pre&gt; A comparison like &lt;code&gt;(a, b) &amp;gt; (c, d)&lt;/code&gt; is a row comparison and is equivalent to &lt;code&gt;a &amp;gt; c OR (a = c AND b &amp;gt; d)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;update the last transaction ID and event ID processed by the subscription &lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE ES_EVENT_SUBSCRIPTION&#xA;   SET LAST_TRANSACTION_ID = :lastProcessedTransactionId::xid8,&#xA;       LAST_EVENT_ID = :lastProcessedEventId&#xA; WHERE SUBSCRIPTION_NAME = :subscriptionName&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;4-7-1&#34;&gt;&lt;/a&gt;Reliable transactional outbox with PostgreSQL&lt;/h4&gt; &#xA;&lt;p&gt;Using only the event ID to track events processed by the subscription is unreliable and can result in lost events.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;ID&lt;/code&gt; column of the &lt;code&gt;ES_EVENT&lt;/code&gt; table is of type &lt;code&gt;BIGSERIAL&lt;/code&gt;. It&#39;s a notational convenience for creating ID columns having their default values assigned from a &lt;code&gt;SEQUENCE&lt;/code&gt; generator.&lt;/p&gt; &#xA;&lt;p&gt;PostgreSQL sequences can&#39;t be rolled back. &lt;code&gt;SELECT nextval(&#39;ES_EVENT_ID_SEQ&#39;)&lt;/code&gt; increments and returns the sequence value. Even if the transaction is not yet committed, the new sequence value becomes visible to other transactions.&lt;/p&gt; &#xA;&lt;p&gt;If transaction #2 started after transaction #1 but committed first, the event subscription processor can read the events created by transaction #2, update the last processed event ID, and thus lose the events created by transaction #1.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/postgresql-naive-outbox.svg?sanitize=true&#34; alt=&#34;PostgreSQL naive transactional outbox&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;We use transaction ID with event ID to build a reliable PostgreSQL polling mechanism that doesn&#39;t lose events.&lt;/p&gt; &#xA;&lt;p&gt;Each event is supplemented with the current transaction ID. &lt;code&gt;pg_current_xact_id()&lt;/code&gt; returns the current transaction&#39;s ID of type &lt;code&gt;xid8&lt;/code&gt;. &lt;code&gt;xid8&lt;/code&gt; values increase strictly monotonically and cannot be reused in the lifetime of a database cluster.&lt;/p&gt; &#xA;&lt;p&gt;The latest event that is &#34;safe&#34; to process is right before the &lt;code&gt;xmin&lt;/code&gt; of the current snapshot. &lt;code&gt;pg_current_snapshot()&lt;/code&gt; returns a current snapshot, a data structure showing which transaction IDs are now in-progress. &lt;code&gt;pg_snapshot_xmin(pg_snapshot)&lt;/code&gt; returns the &lt;code&gt;xmin&lt;/code&gt; of a snapshot. &lt;code&gt;xmin&lt;/code&gt; is the lowest transaction ID that was still active. All transaction IDs less than &lt;code&gt;xmin&lt;/code&gt; are either committed and visible, or rolled back.&lt;/p&gt; &#xA;&lt;p&gt;Even if transaction #2 started after transaction #1 and committed first, the events it created won&#39;t be read by the event subscription processor until transaction #1 is committed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/postgresql-reliable-outbox.svg?sanitize=true&#34; alt=&#34;PostgreSQL reliable transactional outbox&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;4-7-2&#34;&gt;&lt;/a&gt;Database polling&lt;/h4&gt; &#xA;&lt;p&gt;To get new events from the &lt;code&gt;ES_EVENT&lt;/code&gt; table, the application has to poll the database. The shorter the polling period, the shorter the delay between persisting a new event and processing it by the subscription. But the lag is inevitable. If the polling period is 1 second, then the lag is at most 1 second.&lt;/p&gt; &#xA;&lt;p&gt;The polling mechanism implementation &lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/src/main/java/com/example/eventsourcing/service/ScheduledEventSubscriptionProcessor.java&#34;&gt;ScheduledEventSubscriptionProcessor&lt;/a&gt; uses a Spring annotation &lt;a href=&#34;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html&#34;&gt;@Scheduled&lt;/a&gt; to poll database with a fixed period.&lt;/p&gt; &#xA;&lt;p&gt;The polling event subscription processing can be enabled and configured in the &lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/src/main/resources/application.yml&#34;&gt;&lt;code&gt;application.yml&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;event-sourcing:&#xA;  subscriptions: polling # Enable database polling subscription processing&#xA;  polling-subscriptions:&#xA;    polling-initial-delay: PT1S&#xA;    polling-interval: PT1S&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;4-7-3&#34;&gt;&lt;/a&gt;Database polling alternative&lt;/h4&gt; &#xA;&lt;p&gt;To reduce the lag associated with database polling, the polling period can be set to a very low value, such as 1 second. But this means that there will be 3600 database queries per hour and 86400 per day, even if there are no new events.&lt;/p&gt; &#xA;&lt;p&gt;PostgreSQL &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt; feature can be used instead of polling. This mechanism allows for sending asynchronous notifications across database connections. Notifications are not sent directly from the application, but via the database &lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/src/main/resources/db/migration/V2__notify_trigger.sql&#34;&gt;trigger&lt;/a&gt; on a table.&lt;/p&gt; &#xA;&lt;p&gt;To use this functionality an unshared &lt;a href=&#34;https://jdbc.postgresql.org/documentation/publicapi/org/postgresql/jdbc/PgConnection.html&#34;&gt;PgConnection&lt;/a&gt; which remains open is required. The long-lived dedicated JDBC &lt;code&gt;Connection&lt;/code&gt; for receiving notifications has to be created using the &lt;code&gt;DriverManager&lt;/code&gt; API, instead of getting from a pooled &lt;code&gt;DataSource&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;PostgreSQL JDBC driver can&#39;t receive asynchronous notifications and must poll the backend to check if any notifications were issued. A timeout can be given to the poll function &lt;code&gt;getNotifications(int timeoutMillis)&lt;/code&gt;, but then the execution of statements from other threads will block. When &lt;code&gt;timeoutMillis&lt;/code&gt; = 0, blocks forever or until at least one notification has been received. It means that notification is delivered almost immediately, without a lag. If more than one notification is about to be received, these will be returned in one batch.&lt;/p&gt; &#xA;&lt;p&gt;This solution significantly reduces the number of issued queries and also solves the lag problem that the polling solution suffers from.&lt;/p&gt; &#xA;&lt;p&gt;The Listen/Notify mechanism implementation &lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/src/main/java/com/example/eventsourcing/service/PostgresChannelEventSubscriptionProcessor.java&#34;&gt;PostgresChannelEventSubscriptionProcessor&lt;/a&gt; is inspired by the Spring Integration class &lt;a href=&#34;https://github.com/spring-projects/spring-integration/raw/v6.0.0/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java&#34;&gt;PostgresChannelMessageTableSubscriber&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The Listen/Notify event subscription processing can be enabled in the &lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/src/main/resources/application.yml&#34;&gt;&lt;code&gt;application.yml&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;event-sourcing:&#xA;  subscriptions: postgres-channel # Enable Listen/Notify event subscription processing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This mechanism is used by default as more efficient.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;4-8&#34;&gt;&lt;/a&gt;Adding new asynchronous event handlers&lt;/h3&gt; &#xA;&lt;p&gt;After restarting the backend, existing subscriptions will only process new events after the last processed event and not everything from the first one.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;&lt;br&gt; Critical content demanding immediate user attention due to potential risks. New subscriptions (event handlers) in the first poll will read and process all events. Be careful, if there are too many events, they may take a long time to process.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;4-9&#34;&gt;&lt;/a&gt;Drawbacks&lt;/h3&gt; &#xA;&lt;p&gt;Using PostgreSQL as an event store has a lot of advantages, but there are also drawbacks.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Asynchronous event handlers can process the same event more than once.&lt;/strong&gt; It might crash after processing an event but before recording the fact that it has done so. When it restarts, it will then process the same event again (e.g., send an integration event). Integration events are delivered with &lt;strong&gt;at-least-once&lt;/strong&gt; delivery guarantee. The exactly-once delivery guarantee is hard to achieve due to a dual-write. A dual-write describes a situation when you need to atomically update the database and publish messages without two-phase commit (2PC). Consumers of integration events should be idempotent and filter duplicates and unordered events.&lt;/li&gt; &#xA; &lt;li&gt;The asynchronous event handling results in the &lt;strong&gt;eventual consistency between the write model and sent integration events&lt;/strong&gt;. The polling database table for new events with a fixed delay introduces a full consistency lag greater than or equal to the interval between polls (1 second by default).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;A long-running transaction in the same database will effectively &#34;pause&#34; all event handlers.&lt;/strong&gt; &lt;code&gt;pg_snapshot_xmin(pg_snapshot)&lt;/code&gt; will return the ID of this long-running transaction and events created by all later transactions will be read by the event subscription processor only after this long-running transaction is committed.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;5&#34;&gt;&lt;/a&gt;Project structure&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;5-1&#34;&gt;&lt;/a&gt;Gradle subprojects&lt;/h3&gt; &#xA;&lt;p&gt;This reference implementation can be easily extended to comply with your domain model.&lt;/p&gt; &#xA;&lt;p&gt;Event sourcing related code and application specific code are located in separate Gradle subprojects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/postgresql-event-sourcing-core&#34;&gt;&lt;code&gt;postgresql-event-sourcing-core&lt;/code&gt;&lt;/a&gt;: event sourcing and PostgreSQL related code, a shared library, &lt;code&gt;eventsourcing.postgresql&lt;/code&gt; package,&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/event-sourcing-app&#34;&gt;&lt;code&gt;event-sourcing-app&lt;/code&gt;&lt;/a&gt;: application specific code, a simplified ride-hailing sample, &lt;code&gt;com.example.eventsourcing&lt;/code&gt; package.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;event-sourcing-app&lt;/code&gt; depends on &lt;code&gt;postgresql-event-sourcing-core&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {&#xA;    implementation project(&#39;:postgresql-event-sourcing-core&#39;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;5-2&#34;&gt;&lt;/a&gt;Database schema migrations&lt;/h3&gt; &#xA;&lt;p&gt;Event sourcing related database schema migrations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/event-sourcing-app/src/main/resources/db/migration/V1__eventsourcing_tables.sql&#34;&gt;V1__eventsourcing_tables.sql&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/event-sourcing-app/src/main/resources/db/migration/V2__notify_trigger.sql&#34;&gt;V2__notify_trigger.sql&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Application specific projections database schema migration:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/event-sourcing-app/src/main/resources/db/migration/V3__projection_tables.sql&#34;&gt;V3__projection_tables.sql&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;a id=&#34;5-3&#34;&gt;&lt;/a&gt;Class diagrams&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;5-3-1&#34;&gt;&lt;/a&gt;Class diagram of the domain model&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/class-domain.svg?sanitize=true&#34; alt=&#34;Class diagram of the domain model&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;5-3-2&#34;&gt;&lt;/a&gt;Class diagram of the projections&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/class-projection.svg?sanitize=true&#34; alt=&#34;Class diagram of the projections&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a id=&#34;5-3-3&#34;&gt;&lt;/a&gt;Class diagram of the service layer&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/img/class-service.svg?sanitize=true&#34; alt=&#34;Class diagram of the service layer&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;6&#34;&gt;&lt;/a&gt;How to adapt it to your domain?&lt;/h2&gt; &#xA;&lt;p&gt;To adapt this sample to your domain model, make changes to &lt;code&gt;event-sourcing-app&lt;/code&gt; subproject. No changes to &lt;code&gt;postgresql-event-sourcing-core&lt;/code&gt; subproject are required.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a id=&#34;7&#34;&gt;&lt;/a&gt;How to run the sample?&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Download &amp;amp; install &lt;a href=&#34;https://sdkman.io/install&#34;&gt;SDKMAN!&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install JDK 21&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sdk list java&#xA;sdk install java 21-tem&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install &lt;a href=&#34;https://docs.docker.com/engine/install/&#34;&gt;Docker&lt;/a&gt; and &lt;a href=&#34;https://docs.docker.com/compose/install/&#34;&gt;Docker Compose&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build Java project and Docker image&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./gradlew clean build jibDockerBuild -i&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run PostgreSQL, Kafka and event-sourcing-app&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker compose --env-file gradle.properties up -d --scale event-sourcing-app=2&#xA;# wait a few minutes&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Follow the logs of the application&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker compose logs -f event-sourcing-app&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run E2E tests and see the output&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;E2E_TESTING=true ./gradlew clean test -i&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Explore the database using the Adminer database management tool at &lt;a href=&#34;http://localhost:8181&#34;&gt;http://localhost:8181&lt;/a&gt;. Find the database name, user, and password in the &lt;a href=&#34;https://raw.githubusercontent.com/eugene-khyst/postgresql-event-sourcing/main/docker-compose.yml&#34;&gt;docker-compose.yml&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You can also manually call the REST API endpoints.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install &lt;a href=&#34;https://curl.se/&#34;&gt;curl&lt;/a&gt; and &lt;a href=&#34;https://stedolan.github.io/jq/&#34;&gt;jq&lt;/a&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install curl jq&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Place new order&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ORDER_ID=$(curl -s -X POST http://localhost:8080/orders -d &#39;{&#34;riderId&#34;:&#34;63770803-38f4-4594-aec2-4c74918f7165&#34;,&#34;price&#34;:&#34;123.45&#34;,&#34;route&#34;:[{&#34;address&#34;:&#34;Kyiv, 17A Polyarna Street&#34;,&#34;lat&#34;:50.51980052414157,&#34;lon&#34;:30.467197278948536},{&#34;address&#34;:&#34;Kyiv, 18V Novokostyantynivska Street&#34;,&#34;lat&#34;:50.48509161169076,&#34;lon&#34;:30.485170724431292}]}&#39; -H &#39;Content-Type: application/json&#39; | jq -r .orderId)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Get the placed order&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -s -X GET http://localhost:8080/orders/$ORDER_ID | jq&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Accept the order&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -s -X PUT http://localhost:8080/orders/$ORDER_ID -d &#39;{&#34;status&#34;:&#34;ACCEPTED&#34;,&#34;driverId&#34;:&#34;2c068a1a-9263-433f-a70b-067d51b98378&#34;}&#39; -H &#39;Content-Type: application/json&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Get the accepted order&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -s -X GET http://localhost:8080/orders/$ORDER_ID | jq&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Complete the order&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -s -X PUT http://localhost:8080/orders/$ORDER_ID -d &#39;{&#34;status&#34;:&#34;COMPLETED&#34;}&#39; -H &#39;Content-Type: application/json&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Get the completed order&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -s -X GET http://localhost:8080/orders/$ORDER_ID | jq&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Try to cancel a completed order to simulate business rule violation&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -s -X PUT http://localhost:8080/orders/$ORDER_ID -d &#39;{&#34;status&#34;:&#34;CANCELLED&#34;}&#39; -H &#39;Content-Type: application/json&#39; | jq&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Print integration events&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker compose exec kafka /bin/kafka-console-consumer --bootstrap-server localhost:9092 --topic order-events --from-beginning --property print.key=true --timeout-ms 10000&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>cybertheye/evolution-from-netty-to-springboot</title>
    <updated>2023-11-03T01:31:57Z</updated>
    <id>tag:github.com,2023-11-03:/cybertheye/evolution-from-netty-to-springboot</id>
    <link href="https://github.com/cybertheye/evolution-from-netty-to-springboot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;学习开源项目，模拟实现netty，tomcat，springmvc，springboot等核心功能。可以作为提升编码能力的实践项目。欢迎各位一起参与，提交代码，相互学习&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/cybertheye/evolution-from-netty-to-springboot/raw/main/poster.png&#34; alt=&#34;主题海报&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;项目介绍&lt;/h1&gt; &#xA;&lt;p&gt;学习开源项目，模拟实现netty，tomcat，springmvc，springboot等核心功能。可以作为提升编码能力的实践项目。欢迎各位一起参与，提交代码，相互学习&lt;/p&gt; &#xA;&lt;h1&gt;目标&lt;/h1&gt; &#xA;&lt;p&gt;最终需要能 mimic-springboot 依赖 mimic-springmvc 依赖 mimic-tomcat 依赖 mimic-netty&lt;/p&gt; &#xA;&lt;h1&gt;参与项目方法&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;首先fork一下仓库&lt;/li&gt; &#xA; &lt;li&gt;git clone 仓库 到本地&lt;/li&gt; &#xA; &lt;li&gt;git remote add origin 你的仓库地址&lt;/li&gt; &#xA; &lt;li&gt;git remote add upstream &lt;a href=&#34;https://github.com/cybertheye/evolution-from-netty-to-springboot.git&#34;&gt;https://github.com/cybertheye/evolution-from-netty-to-springboot.git&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;写代码，push，到远程仓库，在Pull Requests 中 点击新建 Pull Request&lt;/li&gt; &#xA; &lt;li&gt;同步项目（目的同步其他人的提交）&lt;/li&gt; &#xA; &lt;li&gt;git fetch upstream&lt;/li&gt; &#xA; &lt;li&gt;git rebase upstream/master （冲突合并 git rebase continue)&lt;/li&gt; &#xA; &lt;li&gt;git push -u origin master:dev (注意远程仓库的分支)&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>saraSakuHj/HyperCeiler</title>
    <updated>2023-11-03T01:31:57Z</updated>
    <id>tag:github.com,2023-11-03:/saraSakuHj/HyperCeiler</id>
    <link href="https://github.com/saraSakuHj/HyperCeiler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Make HyperOS Great Again!&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img width=&#34;160&#34; src=&#34;https://raw.githubusercontent.com/saraSakuHj/HyperCeiler/main/imgs/icon.png&#34; height=&#34;160&#34; align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;HyperCeiler&lt;/h1&gt; &#xA; &lt;h3&gt;Make HyperOS Great Again!&lt;/h3&gt; &#xA; &lt;p&gt;简体中文&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://raw.githubusercontent.com/saraSakuHj/HyperCeiler/main/README_en-US.md&#34;&gt;English&lt;/a&gt; |&amp;nbsp;&amp;nbsp;&lt;a href=&#34;https://raw.githubusercontent.com/saraSakuHj/HyperCeiler/main/README_pt-BR.md&#34;&gt;Português (Brasil)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;支持的版本&lt;/h2&gt; &#xA;&lt;p&gt;Android 11 ~ 13 的 MIUI 12.5 ~ 14&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;不支持 修改较多的第三方 MIUI Rom、修改较多的系统软件，以及部分国外 MIUI Rom，&lt;/p&gt; &#xA; &lt;p&gt;目前 HyperCeiler 是基于 Android 13 的 MIUI 14 的手机端设备进行适配，覆盖不是很完整，需要不断测试和改进，&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;作用域包含的应用&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;点击展开折叠的内容&lt;/summary&gt; &#xA; &lt;table&gt; &#xA;  &lt;thead&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;th align=&#34;left&#34;&gt;应用名&lt;/th&gt; &#xA;    &lt;th align=&#34;left&#34;&gt;包名&lt;/th&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/thead&gt; &#xA;  &lt;tbody&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;系统框架&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;system&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;系统界面&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.systemui&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;系统桌面&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.home&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;系统更新&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.updater&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;Joyose&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.joyose&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;小米设置&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.misettings&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;手机管家&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.securitycenter&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;笔记&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.notes&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;壁纸&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.miwallpaper&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;传送门&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.contentextension&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;弹幕通知&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.barrage&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;百度输入法小米版&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.baidu.input_mi&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;电话&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.incallui&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;电话服务&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.phone&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;电量与性能&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.powerkeeper&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;短信&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.mms&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;截屏&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.screenshot&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;垃圾清理&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.cleanmaster&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;浏览器&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.browser&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;鲁班（MTB）&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.mtb&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;屏幕录制&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.screenrecorder&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;权限管理服务&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.lbe.security.miui&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;设置&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.settings&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;搜狗输入法小米版&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.sohu.inputmethod.sogou.xiaomi&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;天气&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.weather2&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;投屏&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.milink.service&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;外部存储设备&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.externalstorage&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;万象息屏&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.aod&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;文件管理&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.fileexplorer&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;系统服务组件&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.securityadd&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;下载管理&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.providers.downloads.ui&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;下载管理程序&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.providers.downloads&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;相册&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.gallery&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;小米创作&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.creation&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;小米互传&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.mishare.connectivity&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;小米相册 - 编辑&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.mediaeditor&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;小米云服务&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.cloudservice&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;小米智能卡&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.tsmclient&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;讯飞输入法小米版&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.iflytek.inputmethod.miui&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;应用包管理组件&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.packageinstaller&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;应用商店&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.market&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;智能助理&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.personalassistant&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;主题壁纸&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.thememanager&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.rom&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.rom&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;MIUI 安全组件&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.guardprovider&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;时钟&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.deskclock&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;相机&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.camera&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;小爱翻译&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.aiasst.vision&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;小爱建议&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.aireco&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;小爱视觉&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.scanner&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;小爱同学&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.voiceassist&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;音乐&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.miui.player&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;MIUI+ Beta 版&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.mirror&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.NetworkBoost&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.xiaomi.NetworkBoost&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;   &lt;tr&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;NFC 服务&lt;/td&gt; &#xA;    &lt;td align=&#34;left&#34;&gt;com.android.nfc&lt;/td&gt; &#xA;   &lt;/tr&gt; &#xA;  &lt;/tbody&gt; &#xA; &lt;/table&gt; &#xA;&lt;/details&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;与 LSPosed 中推荐的作用域相同&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;交流 &amp;amp; 反馈群组&lt;/h2&gt; &#xA;&lt;p&gt;加入我们所创建的群组以反馈问题或是了解最新情况。&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://jq.qq.com/?_wv=1027&amp;amp;k=TedCJq8V&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/QQ-%E7%BE%A4%E7%BB%84-4DB8FF?style=for-the-badge&amp;amp;logo=tencentqq&#34; alt=&#34;badge_qgroup&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pd.qq.com/s/35ooe0ssj&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/QQ-%E9%A2%91%E9%81%93-4991D3?style=for-the-badge&amp;amp;logo=tencentqq&#34; alt=&#34;badge_qguild&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://t.me/hyperceiler&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/dynamic/json?style=for-the-badge&amp;amp;color=2CA5E0&amp;amp;label=Telegram&amp;amp;logo=telegram&amp;amp;query=%24.data.totalSubs&amp;amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dtelegram%26queryKey%3Dhyperceiler&#34; alt=&#34;badge_telegram&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;为 HyperCeiler 贡献翻译&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crowdin.com/project/hyperceiler&#34;&gt;&lt;img src=&#34;https://badges.crowdin.net/hyperceiler/localized.svg?sanitize=true&#34; alt=&#34;Crowdin&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;您可以在&lt;a href=&#34;https://crwd.in/hyperceiler&#34;&gt;这里&lt;/a&gt;为 HyperCeiler 项目贡献翻译。&lt;/p&gt; &#xA;&lt;h2&gt;感谢&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;HyperCeiler 使用了以下开源项目的部分或全部内容，感谢这些项目的开发者提供的大力支持（排名顺序不分先后）。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://google.github.io/accompanist&#34;&gt;「Accompanist」 by Android Open Source Project, Google Inc.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://source.android.google.cn/license&#34;&gt;「Android」 by Android Open Source Project, Google Inc.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/LSPosed/AndroidHiddenApiBypass&#34;&gt;「AndroidHiddenApiBypass」 by LSPosed&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/androidx/androidx&#34;&gt;「AndroidX」 by Android Open Source Project, Google Inc.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/MinaMichita/AntiAntiDefraud&#34;&gt;「AntiAntiDefraud」 by MinaMichita&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/GSWXXN/AutoNFC&#34;&gt;「Auto NFC」 by GSWXXN&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Weverses/BypassSignCheck&#34;&gt;「BypassSignCheck」 by Weverses&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/LSPosed/CorePatch&#34;&gt;「CorePatch」 by LSPosed&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/MonwF/customiuizer&#34;&gt;「CustoMIUIzer」 by MonwF&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/liyafe1997/CustoMIUIzerMod&#34;&gt;「CustoMIUIzerMod」 by liyafe1997&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/LuckyPray/DexKit&#34;&gt;「DexKit」 by LuckyPray&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Xposed-Modules-Repo/io.github.tehcneko.applinkverify&#34;&gt;「Disable app link verify」 by tehcneko&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/LSPosed/DisableFlagSecure&#34;&gt;「DisableFlagSecure」 by LSPosed&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/QueallyTech/DisableLogRequest&#34;&gt;「DisableLogRequest」 by QueallyTech&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/KyuubiRan/EzXHelper&#34;&gt;「EzXHelper」 by KyuubiRan&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/qqlittleice/FixMiuiMediaControlPanel&#34;&gt;「FixMiuiMediaControlPanel」 by qqlittleice&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xiaowine/FuckNFC&#34;&gt;「FuckNFC」 by xiaowine&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/google/gson&#34;&gt;「Gson」 by Android Open Source Project, Google Inc.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/zerorooot/HideMiuiClipboardDialog&#34;&gt;「HideMiuiClipboardDialog」 by zerorooot&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JetBrains/kotlin&#34;&gt;「Kotlin」 by JetBrains&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/YifePlayte/MaxFreeForm&#34;&gt;「MaxFreeForm」 by YifePlayte&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/moralnorm/miui_feature&#34;&gt;「Miui Feature」 by MoralNorm&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/qqlittleice/MiuiHome_R&#34;&gt;「MiuiHomeR」 by qqlittleice&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/RC1844/MIUI_IME_Unlock&#34;&gt;「MIUI IME Unlock」 by RC1844&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chsbuffer/MIUIQOL&#34;&gt;「MIUI QOL」 by chsbuffer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Wine-Network/Miui_XXL&#34;&gt;「Miui XXL」 by Wine-Network&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/YuKongA/Miui_XXL&#34;&gt;「Miui XXL」 by YuKongA&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Xposed-Modules-Repo/io.github.tehcneko.miuinotificationfix&#34;&gt;「MIUI 通知修复」 by tehcneko&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Weverses/ModemPro&#34;&gt;「ModemPro」 by Weverse&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Xposed-Modules-Repo/com.github.dan.nostoragerestrict&#34;&gt;「NoStorageRestrict」 by DanGLES3&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Haocen2004/PortalHook&#34;&gt;「Portal Hook」 by Haocen2004&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gfbjngjibn/RemoveMiuiSystemSelfProtection&#34;&gt;「RemoveMiuiSystemSelfProtection」 by gfbjngjibn&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/weixiansen574/settingsdontthroughthelist&#34;&gt;「SettingsDontThroughTheList」 by weixiansen574&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hosizoraru/StarVoyager&#34;&gt;「StarVoyager」 by hosizoraru&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ouhoukyo/WINI&#34;&gt;「WINI」 by ouhoukyo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/YifePlayte/WOMMO&#34;&gt;「WOMMO」 by YifePlayte&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hosizoraru/WooBoxForMIUI&#34;&gt;「Woobox For MIUI」 by hosizoraru&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Simplicity-Team/WooBoxForMIUI&#34;&gt;「Woobox For MIUI」 by Simplicity-Team&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rovo89/XposedBridge&#34;&gt;「Xposed」 by rovo89, Tungstwenty&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rovo89/XposedBridge&#34;&gt;「XposedBridge」 by rovo89&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Kr328/.xlDownload&#34;&gt;「.xlDownload」 by Kr328&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>