<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-05-27T01:32:53Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>boricj/ghidra-delinker-extension</title>
    <updated>2025-05-27T01:32:53Z</updated>
    <id>tag:github.com,2025-05-27:/boricj/ghidra-delinker-extension</id>
    <link href="https://github.com/boricj/ghidra-delinker-extension" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ghidra extension for exporting relocatable object files&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Object file exporter extension for Ghidra&lt;/h1&gt; &#xA;&lt;p&gt;This Ghidra extension enables exporting parts of a program as object files. These object files have valid metadata (symbols, relocation tables…) and as such can be reused directly by a toolchain for further processing.&lt;/p&gt; &#xA;&lt;p&gt;Use-cases include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://boricj.net/tenchu1/2024/05/31/part-11.html&#34;&gt;Advanced binary patching&lt;/a&gt;, by leveraging the linker to mend both original and modified parts together instead of doing this work by hand&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://boricj.net/atari-jaguar-sdk/2024/01/02/part-5.html&#34;&gt;Software ports&lt;/a&gt;, by isolating system-independent code from a program and replacing the rest&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;Converting &lt;a href=&#34;https://boricj.net/atari-jaguar-sdk/2023/12/18/part-3.html&#34;&gt;programs&lt;/a&gt; or object files from one file format to another&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://boricj.net/tenchu1/2024/03/11/part-5.html&#34;&gt;Creating&lt;/a&gt; &lt;a href=&#34;https://boricj.net/tenchu1/2024/03/18/part-6.html&#34;&gt;libraries&lt;/a&gt;, by extracting parts of a program and reusing them in another context&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;Decompilation projects, by splitting a program into multiple object files and reimplementing these &lt;em&gt;Ship of Theseus&lt;/em&gt;-style&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;…&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Matrix of supported instruction set architectures and object files:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;x86&lt;/th&gt; &#xA;   &lt;th&gt;MIPS&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;COFF&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ELF&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Building (CLI)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone this repository&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;Define the &lt;code&gt;GHIDRA_INSTALL_DIR&lt;/code&gt; environment variable to point to your Ghidra installation directory&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;gradle buildExtension&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The Ghidra extension archive will be created inside the &lt;code&gt;dist/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download the extension from the &lt;a href=&#34;https://github.com/boricj/ghidra-delinker-extension/releases&#34;&gt;releases page&lt;/a&gt; or build it locally&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;Install the extension in your Ghidra instance with &lt;code&gt;File &amp;gt; Install Extensions…&lt;/code&gt;&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;Enable the &lt;code&gt;RelocationTableSynthesizedPlugin&lt;/code&gt; plugin with &lt;code&gt;File &amp;gt; Configure&lt;/code&gt; inside a CodeBrowser window.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Select a set of addresses in the Listing view&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;Run the &lt;code&gt;Relocation table synthesizer&lt;/code&gt; analyzer (available in one-shot mode)&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;Invoke a relocatable object file exporter with &lt;code&gt;File &amp;gt; Export Program…&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The reconstructed relocations can be viewed with &lt;code&gt;Window &amp;gt; Relocation table (synthesized)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;⚠️ The &lt;em&gt;relocation table synthesizer&lt;/em&gt; analyzer relies on a fully populated Ghidra database (with correctly declared symbols, data types and references) in order to work. &lt;strong&gt;Incorrect or missing information may lead to broken or undiscovered relocations&lt;/strong&gt; during the analysis.&lt;/li&gt; &#xA; &lt;li&gt;⚠️ The object file exporters rely on the results of the &lt;em&gt;relocation table synthesizer&lt;/em&gt; analyzer in order to work. When in doubt, &lt;strong&gt;run this analyzer right before exporting an object file&lt;/strong&gt; to make sure the relocation table contents are up-to-date with the current state of the program.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How does it work?&lt;/h2&gt; &#xA;&lt;p&gt;Object files are made of three parts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Relocatable section bytes&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;A symbol table&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;A relocation table.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When a linker is invoked to generate an executable from a bunch of object files, it will:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lay out their sections in memory&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;Compute the addresses of the symbols in the virtual address space&amp;nbsp;;&lt;/li&gt; &#xA; &lt;li&gt;Apply the relocations based on the final addresses of the symbols onto the section bytes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Normally the relocation table is discarded after this process, as well as the symbol table if debugging symbols aren&#39;t kept, leaving only the un-relocatable section bytes. However, through careful analysis this data can be recreated, which allows us to then effectively &lt;em&gt;delink&lt;/em&gt; the program back into object files.&lt;/p&gt;</summary>
  </entry>
</feed>