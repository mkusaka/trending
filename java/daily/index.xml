<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-16T01:32:07Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Hafthor/zsvutil</title>
    <updated>2024-04-16T01:32:07Z</updated>
    <id>tag:github.com,2024-04-16:/Hafthor/zsvutil</id>
    <link href="https://github.com/Hafthor/zsvutil" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ZSV Utility for converting csv/tsv to/from zip-separated-values&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;zsvutil&lt;/h1&gt; &#xA;&lt;p&gt;A utility for converting TSV files from/to ZSV files.&lt;/p&gt; &#xA;&lt;h1&gt;Introducing ZSV - ZIP Separated Values&lt;/h1&gt; &#xA;&lt;h2&gt;TL;DR&lt;/h2&gt; &#xA;&lt;p&gt;ZSV (ZIP Separated Values) is a columnar data storage format with features similar to &lt;a href=&#34;https://parquet.apache.org&#34;&gt;Parquet&lt;/a&gt; or &lt;a href=&#34;https://orc.apache.org&#34;&gt;ORC&lt;/a&gt;, however, it is built upon the simple technologies of &lt;a href=&#34;https://en.wikipedia.org/wiki/Tab-separated_values&#34;&gt;TSV (tab separated values)&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/ZIP_(file_format)&#34;&gt;ZIP&lt;/a&gt;, making it easy to understand, create and consume, but still provide the query performance characteristics of a modern columnar store format.&lt;/p&gt; &#xA;&lt;h2&gt;Tenets&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Be simple&lt;/li&gt; &#xA; &lt;li&gt;Prefer mature, widely available technologies&lt;/li&gt; &#xA; &lt;li&gt;Favor human readability&lt;/li&gt; &#xA; &lt;li&gt;Be easy to parse and generate&lt;/li&gt; &#xA; &lt;li&gt;Be efficient for simple tabular data&lt;/li&gt; &#xA; &lt;li&gt;Prefer longevity over novelty&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;Given an original source, &lt;strong&gt;products.tsv&lt;/strong&gt;, zsvutil import creates a &lt;strong&gt;products.zsv&lt;/strong&gt; file that is just a .zip file with a file inside for each column, for example, SKU, Description and Price. Inside those files is just the TSV for that column, compressed.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Why is ZSV built on ZIP file format? Why not use .targz?&lt;/h3&gt; &#xA;&lt;p&gt;ZIP is a widely available, mature technology that is easy to use and has built-in support in many languages and platforms. .targz is a single gzip stream of a tar file, which is a collection of files. This makes it effectively impossible to seek to a specific file without reading and decompressing the whole stream up to that file. ZIP files are a collection of individually compressed files, with a directory as a footer to the file, which makes it easy to seek to a specific file without reading the whole file.&lt;/p&gt; &#xA;&lt;h3&gt;Why is ZSV built on TSV format? Why not CSV? Why not JSON?&lt;/h3&gt; &#xA;&lt;p&gt;TSV is a simple, human-readable format that is easy to understand and manipulate. It is also trivial to parse and generate. CSV is also a good choice, but it is more complex than TSV, with quoting and escaping rules that can be confusing, ambiguous and inconsistent. JSON is a good format for nested data, but it is not as easy to read or write as TSV. JSON is also not as efficient as TSV for simple tabular data.&lt;/p&gt; &#xA;&lt;h3&gt;Why not use a binary format like Parquet or ORC does?&lt;/h3&gt; &#xA;&lt;p&gt;Binary formats like Parquet or ORC are more read-time efficient than ZSV, but they are also more complex and are not human-readable. They are also not as easy to parse or generate as plain text. Plain text formats are more future-proof and expressive than binary formats. For example, it is easier to specify a numeric column as having a certain precision in a text format than in a binary format. Likewise, a date time, where you may wish to capture the time and the precision in the field. Binary formats would require specification of the schema of the data, which we are trying to avoid. Binary formats are also more resistant to standard compression algorithms.&lt;/p&gt; &#xA;&lt;h3&gt;What are some key shortcomings of ZSV?&lt;/h3&gt; &#xA;&lt;p&gt;ZSV is not a good choice for binary or unstructured textual data. The main limitation is that the data in the columns must not include the tab character &lt;code&gt;⇥&lt;/code&gt; or newline character &lt;code&gt;⮐&lt;/code&gt;. This is a limitation of the TSV format. Any escaping or encoding of these characters would make the format less human-readable, harder to parse and could introduce ambiguity and consistency problems. If you need to store binary data, you can store it in a nested ZIP column, or you can use the CSV or JSON alternative inner formats.&lt;/p&gt; &#xA;&lt;h3&gt;How well is ZSV supported by tools and platforms?&lt;/h3&gt; &#xA;&lt;p&gt;Today ZSV is not widely supported by tools and platforms, but it is easy to convert between TSV and ZSV using zsvutil. It should be relatively easy to add support for ZSV to any tool that supports columnar data formats.&lt;/p&gt; &#xA;&lt;h3&gt;What is an ideal use case for ZSV?&lt;/h3&gt; &#xA;&lt;p&gt;If you are currently using TSV files and want to improve query performance without changing your data format, ZSV is a good choice.&lt;/p&gt; &#xA;&lt;h2&gt;Simple Columnar Storage Example&lt;/h2&gt; &#xA;&lt;p&gt;Given &lt;strong&gt;products.tsv&lt;/strong&gt; with a header line&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;SKU⇥&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;Description⇥&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;Price⇥&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;Region⮐&lt;/code&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;AA⇥&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Item AA⇥&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;111.11⇥&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;US⮐&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;BB⇥&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Item BB⇥&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;222.22⇥&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;US⮐&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;CC⇥&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Item CC⇥&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;333.33⇥&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;US⮐&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;we would have a ZIP file products.zsv with the files SKU, Description and Price inside. Each file would have just that column&#39;s data.&lt;/p&gt; &#xA;&lt;p&gt;Note that column names MUST be allowed by .zip format as entry names. Also, the tab character &lt;code&gt;⇥&lt;/code&gt; MUST NOT be used in the name.&lt;/p&gt; &#xA;&lt;h3&gt;products.zsv&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SKU &lt;code&gt;AA⮐BB⮐CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description &lt;code&gt;Item AA⮐Item BB⮐Item CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Price &lt;code&gt;111.11⮐222.22⮐333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Region &lt;code&gt;US⮐US⮐US⮐&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note the number of rows in each column MUST be the same, except for Constant Columns (see below). The nature of .zip files makes it possible to seek and read just the columns required without having to read/decode the other columns. Note that newline &lt;code&gt;⮐&lt;/code&gt; MUST NOT appear in the actual column data since it is used to separate rows. Note that each column row MUST end with a &lt;code&gt;⮐&lt;/code&gt; including the last one.&lt;/p&gt; &#xA;&lt;h1&gt;Additional features&lt;/h1&gt; &#xA;&lt;p&gt;These are features that are not required, but may be useful in some cases. They are somewhat counter to our tenet of being simple, but they may be useful enough to warrant the additional complexity. These features are mostly independent of each other, so you can use one or more of them without using the others.&lt;/p&gt; &#xA;&lt;h2&gt;Constant Columns&lt;/h2&gt; &#xA;&lt;p&gt;Constant Columns allow us to add an invariant column, which is useful for partition keys. Note that the field has no trailing newline &lt;code&gt;⮐&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;products.zsv&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SKU &lt;code&gt;AA⮐BB⮐CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description &lt;code&gt;Item AA⮐Item BB⮐Item CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Price &lt;code&gt;111.11⮐222.22⮐333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Region &lt;code&gt;US&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Compound Columns&lt;/h2&gt; &#xA;&lt;p&gt;If a collection of columns are always accessed together, it may make sense to combine them, for example if SKU and Description were never accessed independently, we could make &lt;strong&gt;products.zsv&lt;/strong&gt; look like this:&lt;/p&gt; &#xA;&lt;h3&gt;products.zsv&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SKU &lt;code&gt;AA⮐BB⮐CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥Price &lt;code&gt;Item AA⇥111.11⮐Item BB⇥222.22⮐Item CC⇥333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Region &lt;code&gt;US&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that Constant Columns MUST NOT participate in Compound Columns. Note that along with newline &lt;code&gt;⮐&lt;/code&gt;, the tab &lt;code&gt;⇥&lt;/code&gt; character MUST NOT appear in the column data in a Compound Column. Each row in any column MUST include the same number of columns as its entry name.&lt;/p&gt; &#xA;&lt;h2&gt;Repeated Columns&lt;/h2&gt; &#xA;&lt;p&gt;Data may be repeated using Compound Columns, if desired, for example:&lt;/p&gt; &#xA;&lt;h3&gt;products.zsv&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SKU &lt;code&gt;AA⮐BB⮐CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥Price &lt;code&gt;Item AA⇥111.11⮐Item BB⇥222.22⮐Item CC⇥333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Price &lt;code&gt;111.11⮐222.22⮐333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Region &lt;code&gt;US&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is up to the reader to decide the optimal combination of ZIP entries to read to meet the requirements and avoid reading unnecessary data. The same combination of columns may appear in a different order, especially when the data is sorted.&lt;/p&gt; &#xA;&lt;h2&gt;Nested/Binary Data&lt;/h2&gt; &#xA;&lt;p&gt;Data may be nested by storing a ZIP of compressed row blob files inside the ZSV.&lt;/p&gt; &#xA;&lt;h3&gt;products.zsv&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SKU &lt;code&gt;AA⮐BB⮐CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥Price &lt;code&gt;Item AA⇥111.11⮐Item BB⇥222.22⮐Item CC⇥333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;⇥Images (inner stored ZIP) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;0 &lt;code&gt;&amp;lt;&amp;lt;Image data for AA&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;1 &lt;code&gt;&amp;lt;&amp;lt;Image data for BB&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;2 &lt;code&gt;&amp;lt;&amp;lt;Image data for CC&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Data stored inside, Image data for BB, for example, is directly seekable and fetchable without reading through any of the other data. The image data itself may be compressed, but Images ZIP itself would not be compressed inside products.zsv.&lt;/p&gt; &#xA;&lt;p&gt;Note the column name is prefixed with a tab &lt;code&gt;⇥&lt;/code&gt; character to indicate to the reader that this is a nested column.&lt;/p&gt; &#xA;&lt;h2&gt;Row Groups&lt;/h2&gt; &#xA;&lt;p&gt;Row Groups may be used to split up longer data sets inside a bigger .zsv. This is done by repeating the column file names followed by a double tab &lt;code&gt;⇥⇥&lt;/code&gt; and a unique number for each rowgroup.&lt;/p&gt; &#xA;&lt;h3&gt;products.zsv&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SKU⇥⇥0 &lt;code&gt;AA⮐BB⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥Price⇥⇥0 &lt;code&gt;Item AA⇥111.11⮐Item BB⇥222.22⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Region⇥⇥0 &lt;code&gt;US&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;SKU⇥⇥1 &lt;code&gt;CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥Price⇥⇥1 &lt;code&gt;Item CC⇥333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Region⇥⇥1 &lt;code&gt;US&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note the number of rows in each column of the row group MUST be equal. The columns referenced in each row group MUST be equal. Columns referenced in each row group SHOULD be in the same order and grouped together, however, this is not a strict requirement and readers MUST NOT assume an order of files. Constant columns may be different in each row group when named with the double tab or there can be a single constant column as though there were no rowgroups.&lt;/p&gt; &#xA;&lt;h3&gt;products.zsv&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SKU⇥⇥0 &lt;code&gt;AA⮐BB⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥Price⇥⇥0 &lt;code&gt;Item AA⇥111.11⮐Item BB⇥222.22⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;SKU⇥⇥1 &lt;code&gt;CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥Price⇥⇥1 &lt;code&gt;Item CC⇥333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Region &lt;code&gt;US&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Metadata&lt;/h2&gt; &#xA;&lt;p&gt;ZIP files support having comments on file entries inside. This may be used to hold metadata about the contents that are otherwise unavailable, such as row counts, partition information, sorting, distinct values, min/max text or values, all in a bare keyname JSON format.&lt;/p&gt; &#xA;&lt;h3&gt;products.zsv&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SKU⇥⇥0 &lt;em&gt;{rows:2, distinct:2, maxlength:2, min:&#34;AA&#34;, max:&#34;BB&#34;}&lt;/em&gt; &lt;code&gt;AA⮐BB⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥⇥0 &lt;em&gt;{rows:2, distinct:2, maxlength:7}&lt;/em&gt; &lt;code&gt;Item AA⮐Item BB⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Price⇥⇥0 &lt;em&gt;{rows:2, distinct:2, minvalue:111.11, maxvalue:222.22}&lt;/em&gt; &lt;code&gt;111.11⮐222.22⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;SKU⇥⇥1 &lt;em&gt;{rows:1, distinct:1, maxlength:2, min:&#34;CC&#34;, max:&#34;CC&#34;}&lt;/em&gt; &lt;code&gt;CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥⇥1 &lt;em&gt;{rows:1, distinct:1, maxlength:7}&lt;/em&gt; &lt;code&gt;Item CC⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Price⇥⇥1 &lt;em&gt;{rows:1, distinct:1, minvalue:333.33, maxvalue:333.33}&lt;/em&gt; &lt;code&gt;333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Region &lt;em&gt;{}&lt;/em&gt; &lt;code&gt;US&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Alternative CSV Inner Format&lt;/h2&gt; &#xA;&lt;p&gt;While TSV is the preferred inner format for ZSV, a form using &lt;a href=&#34;https://en.wikipedia.org/wiki/Comma-separated_values&#34;&gt;CSV&lt;/a&gt; is also possible. Each line has comma separated values and each value is either a quoted string with JSON escapes possible, a number, or a bare string, but with no escapes or forbidden characters.&lt;/p&gt; &#xA;&lt;h3&gt;products.zsv&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SKU &lt;code&gt;&#34;AA&#34;⮐&#34;BB&#34;⮐&#34;CC&#34;⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥Price &lt;code&gt;&#34;Item AA&#34;,111.11⮐&#34;Item BB&#34;,222.22⮐&#34;Item CC&#34;,333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Price &lt;code&gt;111.11⮐ 222.22⮐ 333.33⮐&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Region &lt;code&gt;&#34;US&#34;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that the numbers are not ints or floats, but are just unquoted strings that represent a number of arbitrary scale and precision.&lt;/p&gt; &#xA;&lt;h2&gt;Alternative JSON Inner Format&lt;/h2&gt; &#xA;&lt;p&gt;While TSV is the preferred inner format for ZSV, a form using &lt;a href=&#34;https://www.json.org/json-en.html&#34;&gt;JSON&lt;/a&gt; is also possible. Each column is represented by an array of JSON strings or numbers. Compound columns are represented by an array of arrays of JSON strings or numbers. The JSON strings are quoted strings with JSON escapes possible. Repeated columns are represented by a JSON string or number.&lt;/p&gt; &#xA;&lt;h3&gt;products.zsv&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SKU &lt;code&gt;[&#34;AA&#34;,&#34;BB&#34;,&#34;CC&#34;]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Description⇥Price &lt;code&gt;[[&#34;Item AA&#34;,111.11],[&#34;Item BB&#34;,222.22],[&#34;Item CC&#34;,333.33]]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Price &lt;code&gt;[111.11,222.22,333.33]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Region &lt;code&gt;&#34;US&#34;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that the JSON numbers are not ints or floats, but are strings that represent a number of arbitrary scale and precision.&lt;/p&gt;</summary>
  </entry>
</feed>