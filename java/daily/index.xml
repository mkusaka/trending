<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-19T01:38:49Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cucumber/cucumber-java-skeleton</title>
    <updated>2023-03-19T01:38:49Z</updated>
    <id>tag:github.com,2023-03-19:/cucumber/cucumber-java-skeleton</id>
    <link href="https://github.com/cucumber/cucumber-java-skeleton" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This is the simplest possible setup for Cucumber-JVM using Java.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cucumber-Java Skeleton&lt;/h1&gt; &#xA;&lt;p&gt;This is the simplest possible build script setup for Cucumber using Java. There is nothing fancy like a webapp or browser testing. All this does is to show you how to install and run Cucumber!&lt;/p&gt; &#xA;&lt;p&gt;There is a single feature file with one scenario. The scenario has three steps, two of them pending. See if you can make them all pass!&lt;/p&gt; &#xA;&lt;h2&gt;Get the code&lt;/h2&gt; &#xA;&lt;p&gt;Git:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/cucumber/cucumber-java-skeleton.git&#xA;cd cucumber-java-skeleton&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Subversion:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;svn checkout https://github.com/cucumber/cucumber-java-skeleton/trunk cucumber-java-skeleton&#xA;cd cucumber-java-skeleton&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or &lt;a href=&#34;https://github.com/cucumber/cucumber-java-skeleton/archive/main.zip&#34;&gt;download a zip&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;h2&gt;Use Maven&lt;/h2&gt; &#xA;&lt;p&gt;Open a command window and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd maven&#xA;./mvnw test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This runs Cucumber features using Cucumber&#39;s JUnit Platform Engine. The &lt;code&gt;Suite&lt;/code&gt; annotation on the &lt;code&gt;RunCucumberTest&lt;/code&gt; class tells JUnit to kick off Cucumber.&lt;/p&gt; &#xA;&lt;h2&gt;Use Gradle&lt;/h2&gt; &#xA;&lt;p&gt;Open a command window and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd gradle&#xA;./gradlew test --rerun-tasks --info&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This runs Cucumber features using Cucumber&#39;s JUnit Platform Engine. The &lt;code&gt;Suite&lt;/code&gt; annotation on the &lt;code&gt;RunCucumberTest&lt;/code&gt; class tells JUnit to kick off Cucumber.&lt;/p&gt; &#xA;&lt;h2&gt;Overriding options&lt;/h2&gt; &#xA;&lt;p&gt;The Cucumber runtime uses configuration parameters to know what features to run, where the glue code lives, what plugins to use etc. When using JUnit, these configuration parameters are provided through the &lt;code&gt;@ConfigurationParameter&lt;/code&gt; annotation on your test.&lt;/p&gt; &#xA;&lt;p&gt;For available parameters see: &lt;code&gt;io.cucumber.junit.platform.engine.Constants&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Run a subset of Features or Scenarios&lt;/h3&gt; &#xA;&lt;p&gt;Specify a particular scenario by &lt;em&gt;line&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@SelectClasspathResource(value = &#34;io/cucumber/skeleton/belly.feature&#34;, line = 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case you have multiple feature files or scenarios to run against repeat the annotation.&lt;/p&gt; &#xA;&lt;p&gt;You can also specify what to run by &lt;em&gt;tag&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@IncludeTags(&#34;zucchini&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>alibaba/QLExpress</title>
    <updated>2023-03-19T01:38:49Z</updated>
    <id>tag:github.com,2023-03-19:/alibaba/QLExpress</id>
    <link href="https://github.com/alibaba/QLExpress" rel="alternate"></link>
    <summary type="html">&lt;p&gt;QLExpress is a powerful, lightweight, dynamic language for the Java platform aimed at improving developers’ productivity in different business scenes.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;QLExpress基本语法&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/QLExpress/Lobby?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/QLExpress/Lobby.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/QLExpress/Lobby&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;一、背景介绍&lt;/h1&gt; &#xA;&lt;p&gt;由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。 在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。&lt;/p&gt; &#xA;&lt;p&gt;QLExpress脚本引擎被广泛应用在阿里的电商业务场景，具有以下的一些特性:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;1、线程安全，引擎运算过程中的产生的临时变量都是threadlocal类型。&lt;/li&gt; &#xA; &lt;li&gt;2、高效执行，比较耗时的脚本编译过程可以缓存在本地机器，运行时的临时变量创建采用了缓冲池的技术，和groovy性能相当。&lt;/li&gt; &#xA; &lt;li&gt;3、弱类型脚本语言，和groovy，javascript语法类似，虽然比强类型脚本语言要慢一些，但是使业务的灵活度大大增强。&lt;/li&gt; &#xA; &lt;li&gt;4、安全控制,可以通过设置相关运行参数，预防死循环、高危系统api调用等情况。&lt;/li&gt; &#xA; &lt;li&gt;5、代码精简，依赖最小，250k的jar包适合所有java的运行环境，在android系统的低端pos机也得到广泛运用。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;二、依赖和调用说明&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;QLExpress&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;3.3.1&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ExpressRunner runner = new ExpressRunner();&#xA;DefaultContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;String, Object&amp;gt;();&#xA;context.put(&#34;a&#34;, 1);&#xA;context.put(&#34;b&#34;, 2);&#xA;context.put(&#34;c&#34;, 3);&#xA;String express = &#34;a + b * c&#34;;&#xA;Object r = runner.execute(express, context, null, true, false);&#xA;System.out.println(r);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;如果应用有让终端用户输入与执行 QLExpress 的功能，务必关注 &lt;a href=&#34;https://raw.githubusercontent.com/alibaba/QLExpress/master/#4-%E5%A4%9A%E7%BA%A7%E5%88%AB%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6&#34;&gt;多级别安全控制&lt;/a&gt;，将 QLExpress 的安全级别配置在 2 或以上。&lt;/p&gt; &#xA;&lt;h1&gt;三、语法介绍&lt;/h1&gt; &#xA;&lt;h2&gt;1、操作符和java对象操作&lt;/h2&gt; &#xA;&lt;h3&gt;普通java语法&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//支持 +,-,*,/,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=,==,!=,&amp;lt;&amp;gt;【等同于!=】,%,mod【取模等同于%】,++,--,&#xA;//in【类似sql】,like【sql语法】,&amp;amp;&amp;amp;,||,!,等操作符&#xA;//支持for，break、continue、if then else 等标准的程序控制逻辑&#xA;n = 10;&#xA;sum = 0;&#xA;for(i = 0; i &amp;lt; n; i++) {&#xA;   sum = sum + i;&#xA;}&#xA;return sum;&#xA;&#xA;//逻辑三元操作&#xA;a = 1;&#xA;b = 2;&#xA;maxnum = a &amp;gt; b ? a : b;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;和java语法相比，要避免的一些ql写法错误&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;不支持try{}catch{}&lt;/li&gt; &#xA; &lt;li&gt;注释目前只支持 /** **/，不支持单行注释 //&lt;/li&gt; &#xA; &lt;li&gt;不支持java8的lambda表达式&lt;/li&gt; &#xA; &lt;li&gt;不支持for循环集合操作for (Item item : list)&lt;/li&gt; &#xA; &lt;li&gt;弱类型语言，请不要定义类型声明,更不要用Template（Map&amp;lt;String, List&amp;gt;之类的）&lt;/li&gt; &#xA; &lt;li&gt;array的声明不一样&lt;/li&gt; &#xA; &lt;li&gt;min,max,round,print,println,like,in 都是系统默认函数的关键字，请不要作为变量名&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;//java语法：使用泛型来提醒开发者检查类型&#xA;keys = new ArrayList&amp;lt;String&amp;gt;();&#xA;deviceName2Value = new HashMap&amp;lt;String, String&amp;gt;(7);&#xA;String[] deviceNames = {&#34;ng&#34;, &#34;si&#34;, &#34;umid&#34;, &#34;ut&#34;, &#34;mac&#34;, &#34;imsi&#34;, &#34;imei&#34;};&#xA;int[] mins = {5, 30};&#xA;&#xA;//ql写法：&#xA;keys = new ArrayList();&#xA;deviceName2Value = new HashMap();&#xA;deviceNames = [&#34;ng&#34;, &#34;si&#34;, &#34;umid&#34;, &#34;ut&#34;, &#34;mac&#34;, &#34;imsi&#34;, &#34;imei&#34;];&#xA;mins = [5, 30];&#xA;&#xA;//java语法：对象类型声明&#xA;FocFulfillDecisionReqDTO reqDTO = param.getReqDTO();&#xA;//ql写法：&#xA;reqDTO = param.getReqDTO();&#xA;&#xA;//java语法：数组遍历&#xA;for(Item item : list) {&#xA;}&#xA;//ql写法：&#xA;for(i = 0; i &amp;lt; list.size(); i++){&#xA;    item = list.get(i);&#xA;}&#xA;&#xA;//java语法：map遍历&#xA;for(String key : map.keySet()) {&#xA;    System.out.println(map.get(key));&#xA;}&#xA;//ql写法：&#xA;keySet = map.keySet();&#xA;objArr = keySet.toArray();&#xA;for (i = 0; i &amp;lt; objArr.length; i++) {&#xA;    key = objArr[i];&#xA;    System.out.println(map.get(key));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;java的对象操作&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.ql.util.express.test.OrderQuery;&#xA;//系统自动会import java.lang.*,import java.util.*;&#xA;&#xA;query = new OrderQuery();           // 创建class实例，自动补全类路径&#xA;query.setCreateDate(new Date());    // 设置属性&#xA;query.buyer = &#34;张三&#34;;                // 调用属性，默认会转化为setBuyer(&#34;张三&#34;)&#xA;result = bizOrderDAO.query(query);  // 调用bean对象的方法&#xA;System.out.println(result.getId()); // 调用静态方法&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;2、脚本中定义function&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;function add(int a, int b){&#xA;    return a + b;&#xA;};&#xA;&#xA;function sub(int a, int b){&#xA;    return a - b;&#xA;};&#xA;&#xA;a = 10;&#xA;return add(a, 4) + sub(a, 9);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;3、扩展操作符：Operator&lt;/h2&gt; &#xA;&lt;h3&gt;替换 if then else 等关键字&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;runner.addOperatorWithAlias(&#34;如果&#34;, &#34;if&#34;, null);&#xA;runner.addOperatorWithAlias(&#34;则&#34;, &#34;then&#34;, null);&#xA;runner.addOperatorWithAlias(&#34;否则&#34;, &#34;else&#34;, null);&#xA;&#xA;express = &#34;如果 (语文 + 数学 + 英语 &amp;gt; 270) 则 {return 1;} 否则 {return 0;}&#34;;&#xA;DefaultContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;String, Object&amp;gt;();&#xA;runner.execute(express, context, null, false, false, null);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;如何自定义Operator&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.ArrayList;&#xA;import java.util.List;&#xA;&#xA;/**&#xA; * 定义一个继承自com.ql.util.express.Operator的操作符&#xA; */&#xA;public class JoinOperator extends Operator {&#xA;    public Object executeInner(Object[] list) throws Exception {&#xA;        Object opdata1 = list[0];&#xA;        Object opdata2 = list[1];&#xA;        if (opdata1 instanceof List) {&#xA;            ((List)opdata1).add(opdata2);&#xA;            return opdata1;&#xA;        } else {&#xA;            List result = new ArrayList();&#xA;            for (Object opdata : list) {&#xA;                result.add(opdata);&#xA;            }&#xA;            return result;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;如何使用Operator&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//(1)addOperator&#xA;ExpressRunner runner = new ExpressRunner();&#xA;DefaultContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;String, Object&amp;gt;();&#xA;runner.addOperator(&#34;join&#34;, new JoinOperator());&#xA;Object r = runner.execute(&#34;1 join 2 join 3&#34;, context, null, false, false);&#xA;System.out.println(r); // 返回结果 [1, 2, 3]&#xA;&#xA;//(2)replaceOperator&#xA;ExpressRunner runner = new ExpressRunner();&#xA;DefaultContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;String, Object&amp;gt;();&#xA;runner.replaceOperator(&#34;+&#34;, new JoinOperator());&#xA;Object r = runner.execute(&#34;1 + 2 + 3&#34;, context, null, false, false);&#xA;System.out.println(r); // 返回结果 [1, 2, 3]&#xA;&#xA;//(3)addFunction&#xA;ExpressRunner runner = new ExpressRunner();&#xA;DefaultContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;String, Object&amp;gt;();&#xA;runner.addFunction(&#34;join&#34;, new JoinOperator());&#xA;Object r = runner.execute(&#34;join(1, 2, 3)&#34;, context, null, false, false);&#xA;System.out.println(r); // 返回结果 [1, 2, 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;4、绑定java类或者对象的method&lt;/h2&gt; &#xA;&lt;p&gt;addFunctionOfClassMethod + addFunctionOfServiceMethod&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BeanExample {&#xA;    public static String upper(String abc) {&#xA;        return abc.toUpperCase();&#xA;    }&#xA;    public boolean anyContains(String str, String searchStr) {&#xA;        char[] s = str.toCharArray();&#xA;        for (char c : s) {&#xA;            if (searchStr.contains(c+&#34;&#34;)) {&#xA;                return true;&#xA;            }&#xA;        }&#xA;        return false;&#xA;    }&#xA;}&#xA;&#xA;runner.addFunctionOfClassMethod(&#34;取绝对值&#34;, Math.class.getName(), &#34;abs&#34;, new String[] {&#34;double&#34;}, null);&#xA;runner.addFunctionOfClassMethod(&#34;转换为大写&#34;, BeanExample.class.getName(), &#34;upper&#34;, new String[] {&#34;String&#34;}, null);&#xA;&#xA;runner.addFunctionOfServiceMethod(&#34;打印&#34;, System.out, &#34;println&#34;, new String[] { &#34;String&#34; }, null);&#xA;runner.addFunctionOfServiceMethod(&#34;contains&#34;, new BeanExample(), &#34;anyContains&#34;, new Class[] {String.class, String.class}, null);&#xA;&#xA;String express = &#34;取绝对值(-100); 转换为大写(\&#34;hello world\&#34;); 打印(\&#34;你好吗？\&#34;); contains(&#34;helloworld&#34;,\&#34;aeiou\&#34;)&#34;;&#xA;runner.execute(express, context, null, false, false);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;5、macro 宏定义&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;runner.addMacro(&#34;计算平均成绩&#34;, &#34;(语文+数学+英语)/3.0&#34;);&#xA;runner.addMacro(&#34;是否优秀&#34;, &#34;计算平均成绩&amp;gt;90&#34;);&#xA;IExpressContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;String, Object&amp;gt;();&#xA;context.put(&#34;语文&#34;, 88);&#xA;context.put(&#34;数学&#34;, 99);&#xA;context.put(&#34;英语&#34;, 95);&#xA;Object result = runner.execute(&#34;是否优秀&#34;, context, null, false, false);&#xA;System.out.println(r);&#xA;//返回结果true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;6、编译脚本，查询外部需要定义的变量和函数。&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;注意以下脚本int和没有int的区别&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String express = &#34;int 平均分 = (语文 + 数学 + 英语 + 综合考试.科目2) / 4.0; return 平均分&#34;;&#xA;ExpressRunner runner = new ExpressRunner(true, true);&#xA;String[] names = runner.getOutVarNames(express);&#xA;for(String s:names){&#xA;    System.out.println(&#34;var : &#34; + s);&#xA;}&#xA;&#xA;//输出结果：&#xA;var : 数学&#xA;var : 综合考试&#xA;var : 英语&#xA;var : 语文&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;7、关于不定参数的使用&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test&#xA;public void testMethodReplace() throws Exception {&#xA;    ExpressRunner runner = new ExpressRunner();&#xA;    IExpressContext&amp;lt;String, Object&amp;gt; expressContext = new DefaultContext&amp;lt;String, Object&amp;gt;();&#xA;    runner.addFunctionOfServiceMethod(&#34;getTemplate&#34;, this, &#34;getTemplate&#34;, new Class[]{Object[].class}, null);&#xA;&#xA;    //(1)默认的不定参数可以使用数组来代替&#xA;    Object r = runner.execute(&#34;getTemplate([11,&#39;22&#39;, 33L, true])&#34;, expressContext, null, false, false);&#xA;    System.out.println(r);&#xA;    //(2)像java一样,支持函数动态参数调用,需要打开以下全局开关,否则以下调用会失败&#xA;    DynamicParamsUtil.supportDynamicParams = true;&#xA;    r = runner.execute(&#34;getTemplate(11, &#39;22&#39;, 33L, true)&#34;, expressContext, null, false, false);&#xA;    System.out.println(r);&#xA;}&#xA;&#xA;//等价于getTemplate(Object[] params)&#xA;public Object getTemplate(Object... params) throws Exception{&#xA;    String result = &#34;&#34;;&#xA;    for(Object obj:params){&#xA;        result = result + obj + &#34;,&#34;;&#xA;    }&#xA;    return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;8、关于集合的快捷写法&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test&#xA;public void testSet() throws Exception {&#xA;    ExpressRunner runner = new ExpressRunner(false, false);&#xA;    DefaultContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;String, Object&amp;gt;();&#xA;    String express = &#34;abc = NewMap(1:1, 2:2); return abc.get(1) + abc.get(2);&#34;;&#xA;    Object r = runner.execute(express, context, null, false, false);&#xA;    System.out.println(r);&#xA;    express = &#34;abc = NewList(1, 2, 3); return abc.get(1) + abc.get(2)&#34;;&#xA;    r = runner.execute(express, context, null, false, false);&#xA;    System.out.println(r);&#xA;    express = &#34;abc = [1, 2, 3]; return abc[1] + abc[2];&#34;;&#xA;    r = runner.execute(express, context, null, false, false);&#xA;    System.out.println(r);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;9、集合的遍历&lt;/h2&gt; &#xA;&lt;p&gt;其实类似java的语法，只是ql不支持for(obj:list){}的语法，只能通过下标访问。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//遍历map&#xA;map = new HashMap();&#xA;map.put(&#34;a&#34;, &#34;a_value&#34;);&#xA;map.put(&#34;b&#34;, &#34;b_value&#34;);&#xA;keySet = map.keySet();&#xA;objArr = keySet.toArray();&#xA;for (i = 0; i &amp;lt; objArr.length; i++) {&#xA;    key = objArr[i];&#xA;    System.out.println(map.get(key));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;四、运行参数和API列表介绍&lt;/h1&gt; &#xA;&lt;p&gt;QLExpressRunner如下图所示，从语法树分析、上下文、执行过程三个方面提供二次定制的功能扩展。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/dec904b003aba15cbf1af2726914ddee.jpg&#34; alt=&#34;QlExpress-detail.jpg&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;1、属性开关&lt;/h2&gt; &#xA;&lt;h3&gt;isPrecise&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**&#xA; * 是否需要高精度计算&#xA; */&#xA;private boolean isPrecise = false;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;高精度计算在会计财务中非常重要，java的float、double、int、long存在很多隐式转换，做四则运算和比较的时候其实存在非常多的安全隐患。 所以类似汇金的系统中，会有很多BigDecimal转换代码。而使用QLExpress，你只要关注数学公式本身 &lt;em&gt;订单总价 = 单价 * 数量 + 首重价格 + （ 总重量 - 首重） * 续重单价&lt;/em&gt; ，然后设置这个属性即可，所有的中间运算过程都会保证不丢失精度。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;isShortCircuit&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**&#xA; * 是否使用逻辑短路特性&#xA; */&#xA;private boolean isShortCircuit = true;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;在很多业务决策系统中，往往需要对布尔条件表达式进行分析输出，普通的java运算一般会通过逻辑短路来减少性能的消耗。例如规则公式： &lt;em&gt;star &amp;gt; 10000 and shopType in (&#39;tmall&#39;, &#39;juhuasuan&#39;) and price between (100, 900)&lt;/em&gt; 假设第一个条件 &lt;em&gt;star&amp;gt;10000&lt;/em&gt; 不满足就停止运算。但业务系统却还是希望把后面的逻辑都能够运算一遍，并且输出中间过程，保证更快更好的做出决策。&lt;/p&gt; &#xA;&lt;p&gt;参照单元测试:&lt;a href=&#34;https://github.com/alibaba/QLExpress/raw/master/src/test/java/com/ql/util/express/test/logic/ShortCircuitLogicTest.java&#34;&gt;ShortCircuitLogicTest.java&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;isTrace&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**&#xA; * 是否输出所有的跟踪信息，同时还需要log级别是DEBUG级别&#xA; */&#xA;private boolean isTrace = false;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;这个主要是是否输出脚本的编译解析过程，一般对于业务系统来说关闭之后会提高性能。&lt;/p&gt; &#xA;&lt;h2&gt;2、调用入参&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**&#xA; * 执行一段文本&#xA; * @param expressString 程序文本&#xA; * @param context 执行上下文，可以扩展为包含ApplicationContext&#xA; * @param errorList 输出的错误信息List&#xA; * @param isCache 是否使用Cache中的指令集,建议为true&#xA; * @param isTrace 是否输出详细的执行指令信息，建议为false&#xA; * @param aLog 输出的log&#xA; * @return&#xA; * @throws Exception&#xA; */&#xA;Object execute(String expressString, IExpressContext&amp;lt;String, Object&amp;gt; context, List&amp;lt;String&amp;gt; errorList, boolean isCache, boolean isTrace);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;3、功能扩展API列表&lt;/h2&gt; &#xA;&lt;p&gt;QLExpress主要通过子类实现Operator.java提供的以下方法来最简单的操作符定义，然后可以被通过addFunction或者addOperator的方式注入到ExpressRunner中。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract Object executeInner(Object[] list) throws Exception;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;比如我们几行代码就可以实现一个功能超级强大、非常好用的join操作符:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;_list = 1 join 2 join 3;_         -&amp;gt; [1,2,3]&#xA;_list = join(list, 4, 5, 6);_     -&amp;gt; [1,2,3,4,5,6]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.ArrayList;&#xA;import java.util.List;&#xA;&#xA;public class JoinOperator extends Operator {&#xA;    public Object executeInner(Object[] list) throws Exception {&#xA;        List result = new ArrayList();&#xA;        Object opdata1 = list[0];&#xA;        if (opdata1 instanceof List) {&#xA;            result.addAll((List)opdata1);&#xA;        } else {&#xA;            result.add(opdata1);&#xA;        }&#xA;        for (int i = 1; i &amp;lt; list.length; i++) {&#xA;            result.add(list[i]);&#xA;        }&#xA;        return result;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;如果你使用Operator的基类OperatorBase.java将获得更强大的能力，基本能够满足所有的要求。&lt;/p&gt; &#xA;&lt;h3&gt;（1）function相关API&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//通过name获取function的定义&#xA;OperatorBase getFunciton(String name);&#xA;&#xA;//通过自定义的Operator来实现类似：fun(a, b, c)&#xA;void addFunction(String name, OperatorBase op);&#xA;&#xA;//fun(a, b, c) 绑定 object.function(a, b, c)对象方法&#xA;void addFunctionOfServiceMethod(String name, Object aServiceObject, String aFunctionName, Class&amp;lt;?&amp;gt;[] aParameterClassTypes, String errorInfo);&#xA;&#xA;//fun(a, b, c) 绑定 Class.function(a, b, c)类方法&#xA;void addFunctionOfClassMethod(String name, String aClassName, String aFunctionName, Class&amp;lt;?&amp;gt;[] aParameterClassTypes, String errorInfo);&#xA;&#xA;//给Class增加或者替换method，同时支持 a.fun(b), fun(a, b) 两种方法调用&#xA;//比如扩展String.class的isBlank方法:&#34;abc&#34;.isBlank()和isBlank(&#34;abc&#34;)都可以调用&#xA;void addFunctionAndClassMethod(String name, Class&amp;lt;?&amp;gt; bindingClass, OperatorBase op);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;（2）Operator相关API&lt;/h3&gt; &#xA;&lt;p&gt;提到脚本语言的操作符，优先级、运算的目数、覆盖原始的操作符(+,-,*,/等等)都是需要考虑的问题，QLExpress统统帮你搞定了。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//添加操作符号,可以设置优先级&#xA;void addOperator(String name, Operator op);&#xA;void addOperator(String name, String aRefOpername, Operator op);&#xA;&#xA;//替换操作符处理&#xA;OperatorBase replaceOperator(String name, OperatorBase op);&#xA;&#xA;//添加操作符和关键字的别名，比如 if..then..else -&amp;gt; 如果。。那么。。否则。。&#xA;void addOperatorWithAlias(String keyWordName, String realKeyWordName, String errorInfo);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;（3）宏定义相关API&lt;/h3&gt; &#xA;&lt;p&gt;QLExpress的宏定义比较简单，就是简单的用一个变量替换一段文本，和传统的函数替换有所区别。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//比如addMacro(&#34;天猫卖家&#34;, &#34;userDO.userTag &amp;amp;1024 == 1024&#34;)&#xA;void addMacro(String macroName, String express);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;（4）java class的相关api&lt;/h3&gt; &#xA;&lt;p&gt;QLExpress可以通过给java类增加或者改写一些method和field，比如 链式调用：&#34;list.join(&#34;1&#34;).join(&#34;2&#34;)&#34;，比如中文属性：&#34;list.长度&#34;。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//添加类的属性字段&#xA;void addClassField(String field, Class&amp;lt;?&amp;gt;bindingClass, Class&amp;lt;?&amp;gt;returnType, Operator op);&#xA;&#xA;//添加类的方法&#xA;void addClassMethod(String name, Class&amp;lt;?&amp;gt;bindingClass, OperatorBase op);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;注意，这些类的字段和方法是执行器通过解析语法执行的，而不是通过字节码增强等技术，所以只在脚本运行期间生效，不会对jvm整体的运行产生任何影响，所以是绝对安全的。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;（4）语法树解析变量、函数的API&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;这些接口主要是对一个脚本内容的静态分析，可以作为上下文创建的依据，也可以用于系统的业务处理。 比如：计算 &#34;a + fun1(a) + fun2(a + b) + c.getName()&#34; 包含的变量:a,b,c 包含的函数:fun1,fun2&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//获取一个表达式需要的外部变量名称列表&#xA;String[] getOutVarNames(String express);&#xA;String[] getOutFunctionNames(String express);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;（5）语法解析校验api&lt;/h3&gt; &#xA;&lt;p&gt;脚本语法是否正确，可以通过ExpressRunner编译指令集的接口来完成。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String expressString = &#34;for(i = 0; i &amp;lt; 10; i++) {sum = i + 1;} return sum;&#34;;&#xA;InstructionSet instructionSet = expressRunner.parseInstructionSet(expressString);&#xA;//如果调用过程不出现异常，指令集instructionSet就是可以被加载运行（execute）了！&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;（6）指令集缓存相关的api&lt;/h3&gt; &#xA;&lt;p&gt;因为QLExpress对文本到指令集做了一个本地HashMap缓存，通常情况下一个设计合理的应用脚本数量应该是有限的，缓存是安全稳定的，但是也提供了一些接口进行管理。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//优先从本地指令集缓存获取指令集，没有的话生成并且缓存在本地&#xA;InstructionSet getInstructionSetFromLocalCache(String expressString);&#xA;//清除缓存&#xA;void clearExpressCache();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;（7）安全风险控制&lt;/h3&gt; &#xA;&lt;h4&gt;7.1 防止死循环&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try {&#xA;    express = &#34;sum = 0; for(i = 0; i &amp;lt; 1000000000; i++) {sum = sum + i;} return sum;&#34;;&#xA;    //可通过timeoutMillis参数设置脚本的运行超时时间:1000ms&#xA;    Object r = runner.execute(express, context, null, true, false, 1000);&#xA;    System.out.println(r);&#xA;    throw new Exception(&#34;没有捕获到超时异常&#34;);&#xA;} catch (QLTimeOutException e) {&#xA;    System.out.println(e);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;7.1 防止调用不安全的系统api&lt;/h4&gt; &#xA;&lt;p&gt;更加详细多级安全控制见 &lt;a href=&#34;https://raw.githubusercontent.com/alibaba/QLExpress/master/#4-%E5%A4%9A%E7%BA%A7%E5%88%AB%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6&#34;&gt;多级别安全控制&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ExpressRunner runner = new ExpressRunner();&#xA;QLExpressRunStrategy.setForbiddenInvokeSecurityRiskMethods(true);&#xA;&#xA;DefaultContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;String, Object&amp;gt;();&#xA;try {&#xA;    express = &#34;System.exit(1);&#34;;&#xA;    Object r = runner.execute(express, context, null, true, false);&#xA;    System.out.println(r);&#xA;    throw new Exception(&#34;没有捕获到不安全的方法&#34;);&#xA;} catch (QLException e) {&#xA;    System.out.println(e);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;（8）增强上下文参数Context相关的api&lt;/h3&gt; &#xA;&lt;h4&gt;8.1 与spring框架的无缝集成&lt;/h4&gt; &#xA;&lt;p&gt;上下文参数 IExpressContext context 非常有用，它允许put任何变量，然后在脚本中识别出来。&lt;/p&gt; &#xA;&lt;p&gt;在实际中我们很希望能够无缝的集成到spring框架中，可以仿照下面的例子使用一个子类。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class QLExpressContext extends HashMap&amp;lt;String, Object&amp;gt; implements IExpressContext&amp;lt;String, Object&amp;gt; {&#xA;    private final ApplicationContext context;&#xA;&#xA;    // 构造函数，传入context 和 ApplicationContext&#xA;    public QLExpressContext(Map&amp;lt;String, Object&amp;gt; map, ApplicationContext aContext) {&#xA;        super(map);&#xA;        this.context = aContext;&#xA;    }&#xA;&#xA;    /**&#xA;     * 抽象方法：根据名称从属性列表中提取属性值&#xA;     */&#xA;    public Object get(Object name) {&#xA;        Object result;&#xA;        result = super.get(name);&#xA;        try {&#xA;            if (result == null &amp;amp;&amp;amp; this.context != null &amp;amp;&amp;amp; this.context.containsBean((String)name)) {&#xA;                // 如果在Spring容器中包含bean，则返回String的Bean&#xA;                result = this.context.getBean((String)name);&#xA;            }&#xA;        } catch (Exception e) {&#xA;            throw new RuntimeException(e);&#xA;        }&#xA;        return result;&#xA;    }&#xA;&#xA;    public Object put(String name, Object object) {&#xA;        return super.put(name, object);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;完整的demo参照 &lt;a href=&#34;https://github.com/alibaba/QLExpress/raw/master/src/test/java/com/ql/util/express/test/spring/SpringDemoTest.java&#34;&gt;SpringDemoTest.java&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;8.2 自定义函数操作符获取原始的context控制上下文&lt;/h4&gt; &#xA;&lt;p&gt;自定义的Operator需要直接继承OperatorBase，获取到parent即可，可以用于在运行一组脚本的时候，直接编辑上下文信息，业务逻辑处理上也非常有用。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ContextMessagePutTest {&#xA;    class OperatorContextPut extends OperatorBase {&#xA;        public OperatorContextPut(String aName) {&#xA;            this.name = aName;&#xA;        }&#xA;&#xA;        @Override&#xA;        public OperateData executeInner(InstructionSetContext parent, ArraySwap list) throws Exception {&#xA;            String key = list.get(0).toString();&#xA;            Object value = list.get(1);&#xA;            parent.put(key, value);&#xA;            return null;&#xA;        }&#xA;    }&#xA;&#xA;    @Test&#xA;    public void test() throws Exception {&#xA;        ExpressRunner runner = new ExpressRunner();&#xA;        OperatorBase op = new OperatorContextPut(&#34;contextPut&#34;);&#xA;        runner.addFunction(&#34;contextPut&#34;, op);&#xA;        String express = &#34;contextPut(&#39;success&#39;, &#39;false&#39;); contextPut(&#39;error&#39;, &#39;错误信息&#39;); contextPut(&#39;warning&#39;, &#39;提醒信息&#39;)&#34;;&#xA;        IExpressContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;String, Object&amp;gt;();&#xA;        context.put(&#34;success&#34;, &#34;true&#34;);&#xA;        Object result = runner.execute(express, context, null, false, true);&#xA;        System.out.println(result);&#xA;        System.out.println(context);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;4. 多级别安全控制&lt;/h2&gt; &#xA;&lt;p&gt;QLExpress 与本地 JVM 交互的方式有：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;应用中的自定义函数/操作符/宏: 该部分不在 QLExpress 运行时的管控范围，属于应用开放给脚本的业务功能，不受安全控制，应用需要自行确保这部分是安全的&lt;/li&gt; &#xA; &lt;li&gt;在 QLExpress 运行时中发生的交互: 安全控制可以对这一部分进行管理, QLExpress 会开放相关的配置给应用 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;通过 &lt;code&gt;.&lt;/code&gt; 操作符获取 Java 对象的属性或者调用 Java 对象中的方法&lt;/li&gt; &#xA;   &lt;li&gt;通过 &lt;code&gt;import&lt;/code&gt; 可以导入 JVM 中存在的任何类并且使用, 默认情况下会导入 &lt;code&gt;java.lang&lt;/code&gt;, &lt;code&gt;java.util&lt;/code&gt; 以及 &lt;code&gt;java.util.stream&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;在不同的场景下，应用可以配置不同的安全级别，安全级别由低到高：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;黑名单控制：QLExpress 默认会阻断一些高危的系统 API, 用户也可以自行添加, 但是开放对 JVM 中其他所有类与方法的访问, 最灵活, 但是很容易被反射工具类绕过，只适用于脚本安全性有其他严格控制的场景，禁止直接运行终端用户输入&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;白名单控制：QLExpress 支持编译时白名单和运行时白名单机制, 编译时白名单设置到类级别, 能够在语法检查阶段就暴露出不安全类的使用, 但是无法阻断运行时动态生成的类(比如通过反射), 运行时白名单能够确保运行时只可以直接调用有限的 Java 方法, 必须设置了运行时白名单, 才算是达到了这个级别&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;沙箱模式：QLExpress 作为一个语言沙箱, 只允许通过自定义函数/操作符/宏与应用交互, 不允许与 JVM 中的类产生交互&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;（1） 黑名单控制&lt;/h3&gt; &#xA;&lt;p&gt;QLExpess 目前默认添加的黑名单有：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;java.lang.System.exit&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;java.lang.Runtime.exec&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;java.lang.ProcessBuilder.start&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;java.lang.reflect.Class.forName&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;java.lang.reflect.ClassLoader.loadClass&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;java.lang.reflect.ClassLoader.findClass&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;同时支持通过 &lt;code&gt;QLExpressRunStrategy.addSecurityRiskMethod&lt;/code&gt; 额外添加&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;com.ql.util.express.example.MultiLevelSecurityTest#blockWhiteListControlTest&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 必须将该选项设置为 true&#xA;QLExpressRunStrategy.setForbidInvokeSecurityRiskMethods(true);&#xA;// 这里不区分静态方法与成员方法, 写法一致&#xA;// 不支持重载, riskMethod 的所有重载方法都会被禁止&#xA;QLExpressRunStrategy.addSecurityRiskMethod(RiskBean.class, &#34;riskMethod&#34;);&#xA;ExpressRunner expressRunner = new ExpressRunner();&#xA;DefaultContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;&amp;gt;();&#xA;try {&#xA;    expressRunner.execute(&#34;import com.ql.util.express.example.RiskBean;&#34; +&#xA;                          &#34;RiskBean.riskMethod()&#34;, context, null, true, false);&#xA;    fail(&#34;没有捕获到不安全的方法&#34;);&#xA;} catch (Exception e) {&#xA;    assertTrue(e.getCause() instanceof QLSecurityRiskException);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;（2）白名单控制&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;编译期白名单：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;编译期白名单是类维度的，脚本中只允许显式引用符合白名单条件的类，支持两种设置方式，精确设置某个类，以及设置某个类的全部子类。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;com.ql.util.express.example.MultiLevelSecurityTest#compileWhiteListTest&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 设置编译期白名单&#xA;QLExpressRunStrategy.setCompileWhiteCheckerList(Arrays.asList(&#xA;    // 精确设置&#xA;    CheckerFactory.must(Date.class),&#xA;    // 子类设置&#xA;    CheckerFactory.assignable(List.class)&#xA;));&#xA;ExpressRunner expressRunner = new ExpressRunner();&#xA;// Date 在编译期白名单中, 可以显示引用&#xA;expressRunner.execute(&#34;new Date()&#34;, new DefaultContext&amp;lt;&amp;gt;(), null,&#xA;                      false, true);&#xA;// LinkedList 是 List 的子类, 符合白名单要求&#xA;expressRunner.execute(&#34;LinkedList ll = new LinkedList; ll.add(1); ll.add(2); ll&#34;,&#xA;                      new DefaultContext&amp;lt;&amp;gt;(), null, false, true);&#xA;try {&#xA;    // String 不在白名单中, 不可以显示引用&#xA;    // 但是隐式引用, a = &#39;mmm&#39;, 或者定义字符串常量 &#39;mmm&#39; 都是可以的&#xA;    expressRunner.execute(&#34;String a = &#39;mmm&#39;&#34;, new DefaultContext&amp;lt;&amp;gt;(), null,&#xA;                          false, true);&#xA;} catch (Exception e) {&#xA;    assertTrue(e.getCause() instanceof QLSecurityRiskException);&#xA;}&#xA;&#xA;// Math 不在白名单中&#xA;// 对于不满足编译期类型白名单的脚本无需运行, 即可通过 checkSyntax 检测出&#xA;assertFalse(expressRunner.checkSyntax(&#34;Math.abs(-1)&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;编译期白名单只能检测出脚本编译时能够确认的类型，任何运行时出现的类型都是无法检测的，诸如各种反射&lt;code&gt;Class.forName&lt;/code&gt;, &lt;code&gt;ClassLoader.loadClass&lt;/code&gt;，或者没有声明类型的变量等等，因为编译期白名单只能增加黑客的作案成本，是容易被绕过。因此建议编译期白名单只用来帮助脚本校验，如果需要接收终端用户输入，运行期白名单是务必要配置的。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;运行期白名单：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;如果有白名单设置，所有的黑名单设置就都会无效，以白名单为准。默认没有白名单设置。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;com.ql.util.express.example.MultiLevelSecurityTest#blockWhiteListControlTest&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 必须将该选项设置为 true&#xA;QLExpressRunStrategy.setForbidInvokeSecurityRiskMethods(true);&#xA;// 有白名单设置时, 则黑名单失效&#xA;QLExpressRunStrategy.addSecureMethod(RiskBean.class, &#34;secureMethod&#34;);&#xA;// 白名单中的方法, 允许正常调用&#xA;expressRunner.execute(&#34;import com.ql.util.express.example.RiskBean;&#34; +&#xA;                      &#34;RiskBean.secureMethod()&#34;, context, null, true, false);&#xA;try {&#xA;    // java.lang.String.length 不在白名单中, 不允许调用&#xA;    expressRunner.execute(&#34;&#39;abcd&#39;.length()&#34;, context,&#xA;                          null, true, false);&#xA;    fail(&#34;没有捕获到不安全的方法&#34;);&#xA;} catch (Exception e) {&#xA;    assertTrue(e.getCause() instanceof QLSecurityRiskException);&#xA;}&#xA;&#xA;// setSecureMethods 设置方式&#xA;Set&amp;lt;String&amp;gt; secureMethods = new HashSet&amp;lt;&amp;gt;();&#xA;secureMethods.add(&#34;java.lang.String.length&#34;);&#xA;secureMethods.add(&#34;java.lang.Integer.valueOf&#34;);&#xA;QLExpressRunStrategy.setSecureMethods(secureMethods);&#xA;// 白名单中的方法, 允许正常调用&#xA;Object res = expressRunner.execute(&#34;Integer.valueOf(&#39;abcd&#39;.length())&#34;, context,&#xA;                                   null, true, false);&#xA;assertEquals(4, res);&#xA;try {&#xA;    // java.lang.Long.valueOf 不在白名单中, 不允许调用&#xA;    expressRunner.execute(&#34;Long.valueOf(&#39;abcd&#39;.length())&#34;, context,&#xA;                          null, true, false);&#xA;    fail(&#34;没有捕获到不安全的方法&#34;);&#xA;} catch (Exception e) {&#xA;    assertTrue(e.getCause() instanceof QLSecurityRiskException);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;从上图中可以看出白名单有两种设置方式：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;添加：&lt;code&gt;QLExpressRunStrategy.addSecureMethod&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;置换：&lt;code&gt;QLExpressRunStrategy.setSecureMethods&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;在应用中使用的时，推荐将白名单配置在诸如 &lt;code&gt;etcd&lt;/code&gt;,&lt;code&gt;configServer&lt;/code&gt; 等配置服务中，根据需求随时调整。&lt;/p&gt; &#xA;&lt;h3&gt;（3）沙箱模式&lt;/h3&gt; &#xA;&lt;p&gt;如果你厌烦上述复杂的配置，只是想完全关闭 QLExpress 和 Java 应用的自由交互，那么推荐使用沙箱模式。&lt;/p&gt; &#xA;&lt;p&gt;在沙箱模式中，脚本&lt;strong&gt;不可以&lt;/strong&gt;：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;import Java 类&lt;/li&gt; &#xA; &lt;li&gt;显式引用 Java 类，比如 &lt;code&gt;String a = &#39;mmm&#39;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;取 Java 类中的字段：&lt;code&gt;a = new Integer(11); a.value&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;调用 Java 类中的方法：&lt;code&gt;Math.abs(12)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;脚本&lt;strong&gt;可以&lt;/strong&gt;：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;使用 QLExpress 的自定义操作符/宏/函数，以此实现与应用的受控交互&lt;/li&gt; &#xA; &lt;li&gt;使用 &lt;code&gt;.&lt;/code&gt; 操作符获取 &lt;code&gt;Map&lt;/code&gt; 的 &lt;code&gt;key&lt;/code&gt; 对应的 &lt;code&gt;value&lt;/code&gt;，比如 &lt;code&gt;a&lt;/code&gt; 在应用传入的表达式中是一个 &lt;code&gt;Map&lt;/code&gt;，那么可以通过 &lt;code&gt;a.b&lt;/code&gt; 获取&lt;/li&gt; &#xA; &lt;li&gt;所有不涉及应用 Java 类的操作&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;com.ql.util.express.example.MultiLevelSecurityTest#sandboxModeTest&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 开启沙箱模式&#xA;QLExpressRunStrategy.setSandBoxMode(true);&#xA;ExpressRunner expressRunner = new ExpressRunner();&#xA;// 沙箱模式下不支持 import 语句&#xA;assertFalse(expressRunner.checkSyntax(&#34;import com.ql.util.express.example.RiskBean;&#34;));&#xA;// 沙箱模式下不支持显式的类型引用&#xA;assertFalse(expressRunner.checkSyntax(&#34;String a = &#39;abc&#39;&#34;));&#xA;assertTrue(expressRunner.checkSyntax(&#34;a = &#39;abc&#39;&#34;));&#xA;// 无法用 . 获取 Java 类属性或者 Java 类方法&#xA;try {&#xA;    expressRunner.execute(&#34;&#39;abc&#39;.length()&#34;, new DefaultContext&amp;lt;&amp;gt;(),&#xA;                          null, false, true);&#xA;    fail();&#xA;} catch (QLException e) {&#xA;    // 没有找到方法:length&#xA;}&#xA;try {&#xA;    DefaultContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;&amp;gt;();&#xA;    context.put(&#34;test&#34;, new CustBean(12));&#xA;    expressRunner.execute(&#34;test.id&#34;, context,&#xA;                          null, false, true);&#xA;    fail();&#xA;} catch (RuntimeException e) {&#xA;    // 无法获取属性:id&#xA;}&#xA;&#xA;// 沙箱模式下可以使用 自定义操作符/宏/函数 和应用进行交互&#xA;expressRunner.addFunction(&#34;add&#34;, new Operator() {&#xA;    @Override&#xA;    public Object executeInner(Object[] list) throws Exception {&#xA;        return (Integer) list[0] + (Integer) list[1];&#xA;    }&#xA;});&#xA;assertEquals(3, expressRunner.execute(&#34;add(1,2)&#34;, new DefaultContext&amp;lt;&amp;gt;(),&#xA;                                      null, false, true));&#xA;// 可以用 . 获取 map 的属性&#xA;DefaultContext&amp;lt;String, Object&amp;gt; context = new DefaultContext&amp;lt;&amp;gt;();&#xA;HashMap&amp;lt;Object, Object&amp;gt; testMap = new HashMap&amp;lt;&amp;gt;();&#xA;testMap.put(&#34;a&#34;, &#34;t&#34;);&#xA;context.put(&#34;test&#34;, testMap);&#xA;assertEquals(&#34;t&#34;, expressRunner.execute(&#34;test.a&#34;, context,&#xA;                                        null, false, true));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;在沙箱模式下，为了进一步保障内存的安全，建议同时限制脚本能够申请的最大数组长度以及超时时间，设置方法如下：&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;com.ql.util.express.test.ArrayLenCheckTest&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 限制最大申请数组长度为10, 默认没有限制&#xA;QLExpressRunStrategy.setMaxArrLength(10);&#xA;ExpressRunner runner = new ExpressRunner();&#xA;String code = &#34;byte[] a = new byte[11];&#34;;&#xA;try {&#xA;    // 20ms 超时时间&#xA;    runner.execute(code, new DefaultContext&amp;lt;&amp;gt;(), null, false, false, 20);&#xA;    Assert.fail();&#xA;} catch (QLException e) {&#xA;}&#xA;&#xA;QLExpressRunStrategy.setMaxArrLength(-1);&#xA;// 20ms 超时时间&#xA;runner.execute(code, new DefaultContext&amp;lt;&amp;gt;(), null, false, false, 20);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;附录： &lt;a href=&#34;https://raw.githubusercontent.com/alibaba/QLExpress/master/VERSIONS.md&#34;&gt;版本更新列表&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;links for us&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Gitter channel - Online chat room with QLExpress developers. &lt;a href=&#34;https://gitter.im/QLExpress/Lobby&#34;&gt;Gitter channel &lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;email:&lt;a href=&#34;mailto:tianqiao@alibaba-inc.com&#34;&gt;tianqiao@alibaba-inc.com&lt;/a&gt;,&lt;a href=&#34;mailto:baoxingjie@126.com&#34;&gt;baoxingjie@126.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;wechart:371754252&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>