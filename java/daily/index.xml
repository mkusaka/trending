<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-20T01:31:23Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jwtk/jjwt</title>
    <updated>2023-08-20T01:31:23Z</updated>
    <id>tag:github.com,2023-08-20:/jwtk/jjwt</id>
    <link href="https://github.com/jwtk/jjwt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Java JWT: JSON Web Token for Java and Android&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/jwtk/jjwt/actions/workflows/ci.yml?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/jwtk/jjwt/actions/workflows/ci.yml/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/jwtk/jjwt?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/jwtk/jjwt/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/jwtk/jjwt?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/jwtk/jjwt.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Java JWT: JSON Web Token for Java and Android&lt;/h1&gt; &#xA;&lt;p&gt;JJWT aims to be the easiest to use and understand library for creating and verifying JSON Web Tokens (JWTs) on the JVM and Android.&lt;/p&gt; &#xA;&lt;p&gt;JJWT is a pure Java implementation based exclusively on the &lt;a href=&#34;https://tools.ietf.org/html/rfc7519&#34;&gt;JWT&lt;/a&gt;, &lt;a href=&#34;https://tools.ietf.org/html/rfc7515&#34;&gt;JWS&lt;/a&gt;, &lt;a href=&#34;https://tools.ietf.org/html/rfc7516&#34;&gt;JWE&lt;/a&gt;, &lt;a href=&#34;https://tools.ietf.org/html/rfc7518&#34;&gt;JWA&lt;/a&gt;, &lt;a href=&#34;https://tools.ietf.org/html/rfc7517&#34;&gt;JWK&lt;/a&gt;, &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8037&#34;&gt;Octet JWK&lt;/a&gt;, &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7638.html&#34;&gt;JWK Thumbprint&lt;/a&gt;, and &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc9278.html&#34;&gt;JWK Thumbprint URI&lt;/a&gt; RFC specifications and open source under the terms of the &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache 2.0 License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The library was created by &lt;a href=&#34;https://github.com/lhazlewood&#34;&gt;Les Hazlewood&lt;/a&gt; and is supported and maintained by a &lt;a href=&#34;https://github.com/jwtk/jjwt/graphs/contributors&#34;&gt;community&lt;/a&gt; of contributors.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ve also added some convenience extensions that are not part of the specification, such as JWS compression and claim enforcement.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#features&#34;&gt;Features&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#features-unsupported&#34;&gt;Currently Unsupported Features&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#community&#34;&gt;Community&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#help&#34;&gt;Getting Help&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#help-questions&#34;&gt;Questions&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#help-issues&#34;&gt;Bugs and Feature Requests&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#contributing&#34;&gt;Contributing&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#contributing-pull-requests&#34;&gt;Pull Requests&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#contributing-help-wanted&#34;&gt;Help Wanted&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#overview&#34;&gt;What is a JSON Web Token?&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#overview-example-jwt&#34;&gt;JWT Example&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#overview-example-jws&#34;&gt;JWS Example&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#overview-example-jwe&#34;&gt;JWE Example&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-jdk&#34;&gt;JDK Projects&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-jdk-maven&#34;&gt;Maven&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-jdk-gradle&#34;&gt;Gradle&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-android&#34;&gt;Android Projects&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-android-dependencies&#34;&gt;Dependencies&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-android-proguard&#34;&gt;Proguard Exclusions&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-android-bc&#34;&gt;Bouncy Castle&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-understandingdependencies&#34;&gt;Understanding JJWT Dependencies&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#quickstart&#34;&gt;Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-create&#34;&gt;Create a JWT&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-header&#34;&gt;Header&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-header-builder&#34;&gt;Header Builder&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-header-params&#34;&gt;Header Parameters&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-header-map&#34;&gt;Header Map&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-payload&#34;&gt;Payload&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-content&#34;&gt;Arbitrary Content&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-claims&#34;&gt;Claims&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-claims-standard&#34;&gt;Standard Claims&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-claims-custom&#34;&gt;Custom Claims&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-claims-instance&#34;&gt;Claims Instance&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-claims-map&#34;&gt;Claims Map&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-compression&#34;&gt;Compression&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-read&#34;&gt;Read a JWT&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-read-key&#34;&gt;Static Parsing Key&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#key-locator&#34;&gt;Dynamic Parsing Key Lookup&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#key-locator-custom&#34;&gt;Custom Key Locator&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#key-locator-strategy&#34;&gt;Key Locator Strategy&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#key-locator-retvals&#34;&gt;Key Locator Return Values&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-read-claims&#34;&gt;Claim Assertions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-read-clock&#34;&gt;Accounting for Clock Skew&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-read-clock-custom&#34;&gt;Custom Clock Support&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-read-decompression&#34;&gt;Decompression&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws&#34;&gt;Signed JWTs&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-alg&#34;&gt;Standard Signature Algorithms&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-key&#34;&gt;Signature Algorithm Keys&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-key-hmacsha&#34;&gt;HMAC-SHA&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-key-rsa&#34;&gt;RSA&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-key-ecdsa&#34;&gt;Elliptic Curve&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-key-create&#34;&gt;Creating Safe Keys&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-key-create-secret&#34;&gt;Secret Keys&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-key-create-asym&#34;&gt;Asymetric Keys&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-create&#34;&gt;Create a JWS&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-create-key&#34;&gt;Signing Key&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-create-key-secret&#34;&gt;SecretKey Formats&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-create-key-algoverride&#34;&gt;Signature Algorithm Override&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-create-compression&#34;&gt;Compression&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-read&#34;&gt;Read a JWS&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-read-key&#34;&gt;Verification Key&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-read-key-locator&#34;&gt;Verification Key Locator&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-read-decompression&#34;&gt;Decompression&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &#xA;    &lt;!-- * [Error Handling](#jws-read-errors) --&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe&#34;&gt;Encrypted JWTs&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;JWE Encryption Algorithms&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc-symmetric&#34;&gt;JWE Symmetric Encryption&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-alg&#34;&gt;JWE Key Management Algorithms&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-alg-standard&#34;&gt;JWE Standard Key Management Algorithms&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-alg-rsa&#34;&gt;JWE RSA Key Encryption&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-alg-aes&#34;&gt;JWE AES Key Encryption&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-alg-dir&#34;&gt;JWE Direct Key Encryption&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-alg-pbes2&#34;&gt;JWE Password-based Key Encryption&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-alg-ecdhes&#34;&gt;JWE Elliptic Curve Diffie-Hellman Ephemeral Static Key Agreement&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-create&#34;&gt;Create a JWE&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-compression&#34;&gt;JWE Compression&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-read&#34;&gt;Read a JWE&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-read-key&#34;&gt;JWE Decryption Key&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-key-locator&#34;&gt;JWE Decryption Key Locator&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-read-decompression&#34;&gt;JWE Decompression&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk&#34;&gt;JSON Web Keys (JWKs)&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk-create&#34;&gt;Create a JWK&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk-read&#34;&gt;Read a JWK&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk-private&#34;&gt;PrivateKey JWKs&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk-private-public&#34;&gt;Private JWK &lt;code&gt;PublicKey&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk-private-keypair&#34;&gt;Private JWK from &lt;code&gt;KeyPair&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk-private-topub&#34;&gt;Private JWK Public Conversion&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk-thumbprint&#34;&gt;JWK Thumbprints&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/jwk-thumbprint-kid&#34;&gt;JWK Thumbprint as Key ID&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk-thumbprint-uri&#34;&gt;JWK Thumbprint URI&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk-security&#34;&gt;JWK Security Considerations&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwk-tostring&#34;&gt;JWK &lt;code&gt;toString()&lt;/code&gt; Safety&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#compression&#34;&gt;Compression&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#compression-custom&#34;&gt;Custom Compression Codec&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#compression-custom-locator&#34;&gt;Custom Compression Codec Locator&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#json&#34;&gt;JSON Processor&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#json-custom&#34;&gt;Custom JSON Processor&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#json-jackson&#34;&gt;Jackson ObjectMapper&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#json-jackson-custom-types&#34;&gt;Custom Claim Types&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#json-gson&#34;&gt;Gson&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#base64&#34;&gt;Base64 Support&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#base64-security&#34;&gt;Base64 in Security Contexts&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#base64-not-encryption&#34;&gt;Base64 is not Encryption&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#base64-changing-characters&#34;&gt;Changing Base64 Characters&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#base64-custom&#34;&gt;Custom Base64 Codec&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#examples&#34;&gt;Examples&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jws-hs&#34;&gt;JWS Signed with HMAC&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jws-rsa&#34;&gt;JWS Signed with RSA&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jws-ecdsa&#34;&gt;JWS Signed with ECDSA&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwe-dir&#34;&gt;JWE Encrypted Directly with a SecretKey&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwe-rsa&#34;&gt;JWE Encrypted with RSA&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwe-aeskw&#34;&gt;JWE Encrypted with AES Key Wrap&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwe-ecdhes&#34;&gt;JWE Encrypted with ECDH-ES&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwe-password&#34;&gt;JWE Encrypted with a Password&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-secret&#34;&gt;SecretKey JWK&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-rsapub&#34;&gt;RSA Public JWK&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-rsapriv&#34;&gt;RSA Private JWK&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-ecpub&#34;&gt;Elliptic Curve Public JWK&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-ecpriv&#34;&gt;Elliptic Curve Private JWK&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-edpub&#34;&gt;Edwards Elliptic Curve Public JWK&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-edpriv&#34;&gt;Edwards Elliptic Curve Private JWK&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;features&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Fully functional on all Java 7+ JDKs and Android&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatic security best practices and assertions&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Easy to learn and read API&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Convenient and readable &lt;a href=&#34;http://en.wikipedia.org/wiki/Fluent_interface&#34;&gt;fluent&lt;/a&gt; interfaces, great for IDE auto-completion to write code quickly&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fully RFC specification compliant on all implemented functionality, tested against RFC-specified test vectors&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Stable implementation with over 1,100+ tests and enforced 100% test code coverage. Every single method, statement and conditional branch variant in the entire codebase is tested and required to pass on every build.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Creating, parsing and verifying digitally signed compact JWTs (aka JWSs) with all standard JWS algorithms:&lt;/p&gt; &#xA;  &lt;table&gt; &#xA;   &lt;thead&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;th&gt;Identifier&lt;/th&gt; &#xA;     &lt;th&gt;Signature Algorithm&lt;/th&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/thead&gt; &#xA;   &lt;tbody&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;HS256&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;HMAC using SHA-256&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;HS384&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;HMAC using SHA-384&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;HS512&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;HMAC using SHA-512&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;ES256&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;ECDSA using P-256 and SHA-256&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;ES384&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;ECDSA using P-384 and SHA-384&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;ES512&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;ECDSA using P-521 and SHA-512&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;RS256&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;RSASSA-PKCS-v1_5 using SHA-256&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;RS384&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;RSASSA-PKCS-v1_5 using SHA-384&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;RS512&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;RSASSA-PKCS-v1_5 using SHA-512&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;PS256&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;RSASSA-PSS using SHA-256 and MGF1 with SHA-256&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;PS384&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;RSASSA-PSS using SHA-384 and MGF1 with SHA-384&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;PS512&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;RSASSA-PSS using SHA-512 and MGF1 with SHA-512&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;EdDSA&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;Edwards-curve Digital Signature Algorithm&lt;sup&gt;&lt;b&gt;2&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/tbody&gt; &#xA;  &lt;/table&gt; &lt;p&gt;&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;. Requires Java 11 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/sup&gt;&lt;/p&gt; &lt;p&gt;&lt;sup&gt;&lt;b&gt;2&lt;/b&gt;. Requires Java 15 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/sup&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Creating, parsing and decrypting encrypted compact JWTs (aka JWEs) with all standard JWE encryption algorithms:&lt;/p&gt; &#xA;  &lt;table&gt; &#xA;   &lt;thead&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;th&gt;Identifier&lt;/th&gt; &#xA;     &lt;th&gt;Encryption Algorithm&lt;/th&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/thead&gt; &#xA;   &lt;tbody&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A128CBC‑HS256&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.3&#34;&gt;AES_128_CBC_HMAC_SHA_256&lt;/a&gt; authenticated encryption algorithm&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A192CBC-HS384&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.4&#34;&gt;AES_192_CBC_HMAC_SHA_384&lt;/a&gt; authenticated encryption algorithm&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A256CBC-HS512&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.5&#34;&gt;AES_256_CBC_HMAC_SHA_512&lt;/a&gt; authenticated encryption algorithm&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A128GCM&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;AES GCM using 128-bit key&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A192GCM&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;AES GCM using 192-bit key&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A256GCM&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;AES GCM using 256-bit key&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/tbody&gt; &#xA;  &lt;/table&gt; &lt;p&gt;&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;. Requires Java 8 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/sup&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;All Key Management Algorithms for obtaining JWE encryption and decryption keys:&lt;/p&gt; &#xA;  &lt;table&gt; &#xA;   &lt;thead&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;th&gt;Identifier&lt;/th&gt; &#xA;     &lt;th&gt;Key Management Algorithm&lt;/th&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/thead&gt; &#xA;   &lt;tbody&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;RSA1_5&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;RSAES-PKCS1-v1_5&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;RSA-OAEP&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;RSAES OAEP using default parameters&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;RSA-OAEP-256&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;RSAES OAEP using SHA-256 and MGF1 with SHA-256&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A128KW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;AES Key Wrap with default initial value using 128-bit key&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A192KW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;AES Key Wrap with default initial value using 192-bit key&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A256KW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;AES Key Wrap with default initial value using 256-bit key&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;Direct use of a shared symmetric key as the CEK&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;ECDH-ES&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;ECDH-ES+A128KW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;ECDH-ES using Concat KDF and CEK wrapped with &#34;A128KW&#34;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;ECDH-ES+A192KW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;ECDH-ES using Concat KDF and CEK wrapped with &#34;A192KW&#34;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;ECDH-ES+A256KW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;ECDH-ES using Concat KDF and CEK wrapped with &#34;A256KW&#34;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A128GCMKW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;Key wrapping with AES GCM using 128-bit key&lt;sup&gt;&lt;b&gt;4&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A192GCMKW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;Key wrapping with AES GCM using 192-bit key&lt;sup&gt;&lt;b&gt;4&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;A256GCMKW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;Key wrapping with AES GCM using 256-bit key&lt;sup&gt;&lt;b&gt;4&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;PBES2-HS256+A128KW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;PBES2 with HMAC SHA-256 and &#34;A128KW&#34; wrapping&lt;sup&gt;&lt;b&gt;4&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;PBES2-HS384+A192KW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;PBES2 with HMAC SHA-384 and &#34;A192KW&#34; wrapping&lt;sup&gt;&lt;b&gt;4&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;&lt;code&gt;PBES2‑HS512+A256KW&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;PBES2 with HMAC SHA-512 and &#34;A256KW&#34; wrapping&lt;sup&gt;&lt;b&gt;4&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/tbody&gt; &#xA;  &lt;/table&gt; &lt;p&gt;&lt;sup&gt;&lt;b&gt;4&lt;/b&gt;. Requires Java 8 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/sup&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Creating, parsing and verifying JSON Web Keys (JWKs) in all standard JWA key formats using native Java &lt;code&gt;Key&lt;/code&gt; types:&lt;/p&gt; &#xA;  &lt;table&gt; &#xA;   &lt;thead&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;th&gt;JWK Key Format&lt;/th&gt; &#xA;     &lt;th&gt;Java &lt;code&gt;Key&lt;/code&gt; Type&lt;/th&gt; &#xA;     &lt;th&gt;JJWT &lt;code&gt;Jwk&lt;/code&gt; Type&lt;/th&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/thead&gt; &#xA;   &lt;tbody&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;Symmetric Key&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;SecretKey&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;SecretJwk&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;Elliptic Curve Public Key&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;ECPublicKey&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;EcPublicJwk&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;Elliptic Curve Private Key&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;ECPrivateKey&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;EcPrivateJwk&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;RSA Public Key&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;RSAPublicKey&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;RsaPublicJwk&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;RSA Private Key&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;RSAPrivateKey&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;RsaPrivateJwk&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;XDH Private Key&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;XECPublicKey&lt;/code&gt;&lt;sup&gt;&lt;b&gt;5&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;OctetPublicJwk&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;XDH Private Key&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;XECPrivateKey&lt;/code&gt;&lt;sup&gt;&lt;b&gt;5&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;OctetPrivateJwk&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;EdDSA Public Key&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;EdECPublicKey&lt;/code&gt;&lt;sup&gt;&lt;b&gt;6&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;OctetPublicJwk&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td&gt;EdDSA Private Key&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;EdECPublicKey&lt;/code&gt;&lt;sup&gt;&lt;b&gt;6&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;     &lt;td&gt;&lt;code&gt;OctetPrivateJwk&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/tbody&gt; &#xA;  &lt;/table&gt; &lt;p&gt;&lt;sup&gt;&lt;b&gt;5&lt;/b&gt;. Requires Java 11 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/sup&gt;&lt;/p&gt; &lt;p&gt;&lt;sup&gt;&lt;b&gt;6&lt;/b&gt;. Requires Java 15 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/sup&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Convenience enhancements beyond the specification such as&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Payload compression for any large JWT, not just JWEs&lt;/li&gt; &#xA;   &lt;li&gt;Claims assertions (requiring specific values)&lt;/li&gt; &#xA;   &lt;li&gt;Claim POJO marshaling and unmarshalling when using a compatible JSON parser (e.g. Jackson)&lt;/li&gt; &#xA;   &lt;li&gt;Secure Key generation based on desired JWA algorithms&lt;/li&gt; &#xA;   &lt;li&gt;and more...&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;features-unsupported&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Currently Unsupported Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7515#section-7.2&#34;&gt;Non-compact&lt;/a&gt; serialization and parsing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This feature may be implemented in a future release. Community contributions are welcome!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;community&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a name=&#34;help&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Getting Help&lt;/h3&gt; &#xA;&lt;p&gt;If you have trouble using JJWT, please first read the documentation on this page before asking questions. We try very hard to ensure JJWT&#39;s documentation is robust, categorized with a table of contents, and up to date for each release.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;help-questions&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Questions&lt;/h4&gt; &#xA;&lt;p&gt;If the documentation or the API JavaDoc isn&#39;t sufficient, and you either have usability questions or are confused about something, please &lt;a href=&#34;https://stackoverflow.com/questions/ask?tags=jjwt&amp;amp;guided=false&#34;&gt;ask your question here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;After asking your question, you may wish to join our &lt;a href=&#34;https://jwtk.slack.com/messages/CBNACTN3A&#34;&gt;Slack&lt;/a&gt; or &lt;a href=&#34;https://gitter.im/jwtk/jjwt&#34;&gt;Gittr&lt;/a&gt; chat rooms, but note that they may not always be attended. You will usually have a better chance of having your question answered by &lt;a href=&#34;https://stackoverflow.com/questions/ask?tags=jjwt&amp;amp;guided=false&#34;&gt;asking your question here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you believe you have found a bug or would like to suggest a feature enhancement, please create a new GitHub issue, however:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Please do not create a GitHub issue to ask a question.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;We use GitHub Issues to track actionable work that requires changes to JJWT&#39;s design and/or codebase. If you have a usability question, instead please &lt;a href=&#34;https://stackoverflow.com/questions/ask?tags=jjwt&amp;amp;guided=false&#34;&gt;ask your question here&lt;/a&gt;, or try Slack or Gittr as described above.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;If a GitHub Issue is created that does not represent actionable work for JJWT&#39;s codebase, it will be promptly closed.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;help-issues&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Bugs and Feature Requests&lt;/h4&gt; &#xA;&lt;p&gt;If you do not have a usability question and believe you have a legitimate bug or feature request, please do &lt;a href=&#34;https://github.com/jwtk/jjwt/issues/new&#34;&gt;create a new JJWT issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you feel like you&#39;d like to help fix a bug or implement the new feature yourself, please read the Contributing section next before starting any work.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;contributing&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a name=&#34;contributing-pull-requests&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Pull Requests&lt;/h4&gt; &#xA;&lt;p&gt;Simple Pull Requests that fix anything other than JJWT core code (documentation, JavaDoc, typos, test cases, etc) are always appreciated and have a high likelihood of being merged quickly. Please send them!&lt;/p&gt; &#xA;&lt;p&gt;However, if you want or feel the need to change JJWT&#39;s functionality or core code, please do not issue a pull request without &lt;a href=&#34;https://github.com/jwtk/jjwt/issues/new&#34;&gt;creating a new JJWT issue&lt;/a&gt; and discussing your desired changes &lt;strong&gt;first&lt;/strong&gt;, &lt;em&gt;before you start working on it&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It would be a shame to reject your earnest and genuinely-appreciated pull request if it might not align with the project&#39;s goals, design expectations or planned functionality. We&#39;ve sadly had to reject large PRs in the past because they were out of sync with project or design expectations - all because the PR author didn&#39;t first check in with the team first before working on a solution.&lt;/p&gt; &#xA;&lt;p&gt;So, please &lt;a href=&#34;https://github.com/jwtk/jjwt/issues/new&#34;&gt;create a new JJWT issue&lt;/a&gt; first to discuss, and then we can see if (or how) a PR is warranted. Thank you!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;contributing-help-wanted&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Help Wanted&lt;/h4&gt; &#xA;&lt;p&gt;If you would like to help, but don&#39;t know where to start, please visit the &lt;a href=&#34;https://github.com/jwtk/jjwt/labels/help%20wanted&#34;&gt;Help Wanted Issues&lt;/a&gt; page and pick any of the ones there, and we&#39;ll be happy to discuss and answer questions in the issue comments.&lt;/p&gt; &#xA;&lt;p&gt;If any of those don&#39;t appeal to you, no worries! Any help you would like to offer would be appreciated based on the above caveats concerning &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#contributing-pull-requests&#34;&gt;contributing pull reqeuests&lt;/a&gt;. Feel free to discuss or ask questions first if you&#39;re not sure. :)&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;overview&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is a JSON Web Token?&lt;/h2&gt; &#xA;&lt;p&gt;JSON Web Token (JWT) is a &lt;em&gt;general-purpose&lt;/em&gt; text-based messaging format for transmitting information in a compact and secure way. Contrary to popular belief, JWT is not just useful for sending and receiving identity tokens on the web - even if that is the most common use case. JWTs can be used as messages for &lt;em&gt;any&lt;/em&gt; type of data.&lt;/p&gt; &#xA;&lt;p&gt;A JWT in its simplest form contains two parts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The primary data within the JWT, called the &lt;code&gt;payload&lt;/code&gt;, and&lt;/li&gt; &#xA; &lt;li&gt;A JSON &lt;code&gt;Object&lt;/code&gt; with name/value pairs that represent metadata about the &lt;code&gt;payload&lt;/code&gt; and the message itself, called the &lt;code&gt;header&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;A JWT &lt;code&gt;payload&lt;/code&gt; can be absolutely anything at all - anything that can be represented as a byte array, such as Strings, images, documents, etc.&lt;/p&gt; &#xA;&lt;p&gt;But because a JWT &lt;code&gt;header&lt;/code&gt; is a JSON &lt;code&gt;Object&lt;/code&gt;, it would make sense that a JWT &lt;code&gt;payload&lt;/code&gt; could also be a JSON &lt;code&gt;Object&lt;/code&gt; as well. In many cases, developers like the &lt;code&gt;payload&lt;/code&gt; to be JSON that represents data about a user or computer or similar identity concept. When used this way, the &lt;code&gt;payload&lt;/code&gt; is called a JSON &lt;code&gt;Claims&lt;/code&gt; object, and each name/value pair within that object is called a &lt;code&gt;claim&lt;/code&gt; - each piece of information within &#39;claims&#39; something about an identity.&lt;/p&gt; &#xA;&lt;p&gt;And while it is useful to &#39;claim&#39; something about an identity, really anyone can do that. What&#39;s important is that you &lt;em&gt;trust&lt;/em&gt; the claims by verifying they come from a person or computer you trust.&lt;/p&gt; &#xA;&lt;p&gt;A nice feature of JWTs is that they can be secured in various ways. A JWT can be cryptographically signed (making it what we call a &lt;a href=&#34;https://tools.ietf.org/html/rfc7515&#34;&gt;JWS&lt;/a&gt;) or encrypted (making it a &lt;a href=&#34;https://tools.ietf.org/html/rfc7516&#34;&gt;JWE&lt;/a&gt;). This adds a powerful layer of verifiability to the JWT - a JWS or JWE recipient can have a high degree of confidence it comes from someone they trust by verifying a signature or decrypting it. It is this feature of verifiability that makes JWT a good choice for sending and receiving secure information, like identity claims.&lt;/p&gt; &#xA;&lt;p&gt;Finally, JSON with whitespace for human readability is nice, but it doesn&#39;t make for a very efficient message format. Therefore, JWTs can be &lt;em&gt;compacted&lt;/em&gt; (and even compressed) to a minimal representation - basically Base64URL-encoded strings - so they can be transmitted around the web more efficiently, such as in HTTP headers or URLs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;overview-example-jwt&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Example&lt;/h3&gt; &#xA;&lt;p&gt;Once you have a &lt;code&gt;payload&lt;/code&gt; and &lt;code&gt;header&lt;/code&gt;, how are they compacted for web transmission, and what does the final JWT actually look like? Let&#39;s walk through a simplified version of the process with some pseudocode:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Assume we have a JWT with a JSON &lt;code&gt;header&lt;/code&gt; and a simple text message payload:&lt;/p&gt; &lt;p&gt;&lt;strong&gt;header&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;{&#xA;  &#34;alg&#34;: &#34;none&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;payload&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;The true sign of intelligence is not knowledge but imagination.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Remove all unnecessary whitespace in the JSON:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;String header = &#39;{&#34;alg&#34;:&#34;none&#34;}&#39;&#xA;String payload = &#39;The true sign of intelligence is not knowledge but imagination.&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Get the UTF-8 bytes and Base64URL-encode each:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;String encodedHeader = base64URLEncode( header.getBytes(&#34;UTF-8&#34;) )&#xA;String encodedPayload = base64URLEncode( payload.getBytes(&#34;UTF-8&#34;) )&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Join the encoded header and claims with period (&#39;.&#39;) characters:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;String compact = encodedHeader + &#39;.&#39; + encodedPayload + &#39;.&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The final concatenated &lt;code&gt;compact&lt;/code&gt; JWT String looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;eyJhbGciOiJub25lIn0.VGhlIHRydWUgc2lnbiBvZiBpbnRlbGxpZ2VuY2UgaXMgbm90IGtub3dsZWRnZSBidXQgaW1hZ2luYXRpb24u.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is called an &#39;unprotected&#39; JWT because no security was involved - no digital signatures or encryption to &#39;protect&#39; the JWT to ensure it cannot be changed by 3rd parties.&lt;/p&gt; &#xA;&lt;p&gt;If we wanted to digitally sign the compact form so that we could at least guarantee that no-one changes the data without us detecting it, we&#39;d have to perform a few more steps, shown next.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;overview-example-jws&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWS Example&lt;/h3&gt; &#xA;&lt;p&gt;Instead of a plain text payload, the next example will use probably the most common type of payload - a JSON claims &lt;code&gt;Object&lt;/code&gt; containing information about a particular identity. We&#39;ll also digitally sign the JWT to ensure it cannot be changed by a 3rd party without us knowing.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Assume we have a JSON &lt;code&gt;header&lt;/code&gt; and a claims &lt;code&gt;payload&lt;/code&gt;:&lt;/p&gt; &lt;p&gt;&lt;strong&gt;header&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;alg&#34;: &#34;HS256&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;payload&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;sub&#34;: &#34;Joe&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In this case, the &lt;code&gt;header&lt;/code&gt; indicates that the &lt;code&gt;HS256&lt;/code&gt; (HMAC using SHA-256) algorithm will be used to cryptographically sign the JWT. Also, the &lt;code&gt;payload&lt;/code&gt; JSON object has a single claim, &lt;code&gt;sub&lt;/code&gt; with value &lt;code&gt;Joe&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;There are a number of standard claims, called &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1&#34;&gt;Registered Claims&lt;/a&gt;, in the specification and &lt;code&gt;sub&lt;/code&gt; (for &#39;Subject&#39;) is one of them.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Remove all unnecessary whitespace in both JSON objects:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;String header = &#39;{&#34;alg&#34;:&#34;HS256&#34;}&#39;&#xA;String claims = &#39;{&#34;sub&#34;:&#34;Joe&#34;}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Get their UTF-8 bytes and Base64URL-encode each:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;String encodedHeader = base64URLEncode( header.getBytes(&#34;UTF-8&#34;) )&#xA;String encodedClaims = base64URLEncode( claims.getBytes(&#34;UTF-8&#34;) )&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Concatenate the encoded header and claims with a period character &#39;.&#39; delimiter:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;String concatenated = encodedHeader + &#39;.&#39; + encodedClaims&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use a sufficiently-strong cryptographic secret or private key, along with a signing algorithm of your choice (we&#39;ll use HMAC-SHA-256 here), and sign the concatenated string:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;SecretKey key = getMySecretKey()&#xA;byte[] signature = hmacSha256( concatenated, key )&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Because signatures are always byte arrays, Base64URL-encode the signature and join it to the &lt;code&gt;concatenated&lt;/code&gt; string with a period character &#39;.&#39; delimiter:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;String compact = concatenated + &#39;.&#39; + base64URLEncode( signature )&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;And there you have it, the final &lt;code&gt;compact&lt;/code&gt; String looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJKb2UifQ.1KP0SsvENi7Uz1oQc07aXTL7kpQG5jBNIybqr60AlD4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is called a &#39;JWS&#39; - short for &lt;em&gt;signed&lt;/em&gt; JWT.&lt;/p&gt; &#xA;&lt;p&gt;Of course, no one would want to do this manually in code, and worse, if you get anything wrong, you could introduce serious security problems and weaknesses. As a result, JJWT was created to handle all of this for you: JJWT completely automates both the creation of JWSs and the parsing and verification of JWSs for you.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;overview-example-jwe&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWE Example&lt;/h3&gt; &#xA;&lt;p&gt;So far we have seen an unprotected JWT and a cryptographically signed JWT (called a &#39;JWS&#39;). One of the things that is inherent to both of these two is that all the information within them can be seen by anyone - all the data in both the header and the payload is publicly visible. JWS just ensures the data hasn&#39;t been changed by anyone - it doesn&#39;t prevent anyone from seeing it. Many times, this is just fine because the data within them is not sensitive information.&lt;/p&gt; &#xA;&lt;p&gt;But what if you needed to represent information in a JWT that &lt;em&gt;is&lt;/em&gt; considered sensitive information - maybe someone&#39;s postal address or social security number or bank account number?&lt;/p&gt; &#xA;&lt;p&gt;In these cases, we&#39;d want a fully-encrypted JWT, called a &#39;JWE&#39; for short. A JWE uses cryptography to ensure that the payload remains fully encrypted &lt;em&gt;and&lt;/em&gt; authenticated so unauthorized parties cannot see data within, nor change the data without being detected. Specifically, the JWE specification requires that &lt;a href=&#34;https://en.wikipedia.org/wiki/Authenticated_encryption#Authenticated_encryption_with_associated_data_(AEAD)&#34;&gt;Authenticated Encryption with Associated Data&lt;/a&gt; algorithms are used to fully encrypt and protect data.&lt;/p&gt; &#xA;&lt;p&gt;A full overview of AEAD algorithms are out of scope for this documentation, but here&#39;s an example of a final compact JWE that utilizes these algorithms (line breaks are for readability only):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.&#xA;6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.&#xA;AxY8DCtDaGlsbGljb3RoZQ.&#xA;KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.&#xA;U0m_YmjN04DJvceFICbCVQ&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next we&#39;ll cover how to install JJWT in your project, and then we&#39;ll see how to use JJWT&#39;s nice fluent API instead of risky string manipulation to quickly and safely build JWTs, JWSs, and JWEs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;install&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Use your favorite Maven-compatible build tool to pull the dependencies from Maven Central.&lt;/p&gt; &#xA;&lt;p&gt;The dependencies could differ slightly if you are working with a &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-jdk&#34;&gt;JDK project&lt;/a&gt; or an &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-android&#34;&gt;Android project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;install-jdk&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JDK Projects&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re building a (non-Android) JDK project, you will want to define the following dependencies:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;install-jdk-maven&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Maven&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;jjwt-api&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;JJWT_RELEASE_VERSION&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;jjwt-impl&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;JJWT_RELEASE_VERSION&amp;lt;/version&amp;gt;&#xA;    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;jjwt-jackson&amp;lt;/artifactId&amp;gt; &amp;lt;!-- or jjwt-gson if Gson is preferred --&amp;gt;&#xA;    &amp;lt;version&amp;gt;JJWT_RELEASE_VERSION&amp;lt;/version&amp;gt;&#xA;    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&amp;lt;!-- Uncomment this next dependency if you are using:&#xA;     - JDK 10 or earlier, and you want to use RSASSA-PSS (PS256, PS384, PS512) signature algorithms.  &#xA;     - JDK 10 or earlier, and you want to use EdECDH (X25519 or X448) Elliptic Curve Diffie-Hellman encryption.&#xA;     - JDK 14 or earlier, and you want to use EdDSA (Ed25519 or Ed448) Elliptic Curve signature algorithms.    &#xA;     It is unnecessary for these algorithms on JDK 15 or later.&#xA;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;org.bouncycastle&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;bcprov-jdk15on&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;1.70&amp;lt;/version&amp;gt;&#xA;    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;--&amp;gt;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;install-jdk-gradle&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Gradle&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {&#xA;    implementation &#39;io.jsonwebtoken:jjwt-api:JJWT_RELEASE_VERSION&#39;&#xA;    runtimeOnly &#39;io.jsonwebtoken:jjwt-impl:JJWT_RELEASE_VERSION&#39;&#xA;    runtimeOnly &#39;io.jsonwebtoken:jjwt-jackson:JJWT_RELEASE_VERSION&#39; // or &#39;io.jsonwebtoken:jjwt-gson:JJWT_RELEASE_VERSION&#39; for gson&#xA;    /* &#xA;      Uncomment this next dependency if you are using:&#xA;       - JDK 10 or earlier, and you want to use RSASSA-PSS (PS256, PS384, PS512) signature algorithms.&#xA;       - JDK 10 or earlier, and you want to use EdECDH (X25519 or X448) Elliptic Curve Diffie-Hellman encryption.&#xA;       - JDK 14 or earlier, and you want to use EdDSA (Ed25519 or Ed448) Elliptic Curve signature algorithms.&#xA;      It is unnecessary for these algorithms on JDK 15 or later.&#xA;    */&#xA;    // runtimeOnly &#39;org.bouncycastle:bcprov-jdk15on:1.70&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;install-android&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Android Projects&lt;/h3&gt; &#xA;&lt;p&gt;Android projects will want to define the following dependencies and Proguard exclusions, and optional BouncyCastle &lt;code&gt;Provider&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;install-android-dependencies&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Dependencies&lt;/h4&gt; &#xA;&lt;p&gt;Add the dependencies to your project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {&#xA;    api(&#39;io.jsonwebtoken:jjwt-api:JJWT_RELEASE_VERSION&#39;)&#xA;    runtimeOnly(&#39;io.jsonwebtoken:jjwt-impl:JJWT_RELEASE_VERSION&#39;) &#xA;    runtimeOnly(&#39;io.jsonwebtoken:jjwt-orgjson:JJWT_RELEASE_VERSION&#39;) {&#xA;        exclude(group: &#39;org.json&#39;, module: &#39;json&#39;) //provided by Android natively&#xA;    }&#xA;    /* &#xA;      Uncomment this next dependency if you want to use:&#xA;       - RSASSA-PSS (PS256, PS384, PS512) signature algorithms.&#xA;       - EdECDH (X25519 or X448) Elliptic Curve Diffie-Hellman encryption.&#xA;       - EdDSA (Ed25519 or Ed448) Elliptic Curve signature algorithms.&#xA;      ** AND ALSO ensure you enable the BouncyCastle provider as shown below **&#xA;    */&#xA;    //implementation(&#39;org.bouncycastle:bcprov-jdk15on:1.70&#39;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;install-android-proguard&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Proguard&lt;/h4&gt; &#xA;&lt;p&gt;You can use the following &lt;a href=&#34;https://developer.android.com/studio/build/shrink-code&#34;&gt;Android Proguard&lt;/a&gt; exclusion rules:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-keepattributes InnerClasses&#xA;&#xA;-keep class io.jsonwebtoken.** { *; }&#xA;-keepnames class io.jsonwebtoken.* { *; }&#xA;-keepnames interface io.jsonwebtoken.* { *; }&#xA;&#xA;-keep class org.bouncycastle.** { *; }&#xA;-keepnames class org.bouncycastle.** { *; }&#xA;-dontwarn org.bouncycastle.**&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;install-android-bc&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Bouncy Castle&lt;/h4&gt; &#xA;&lt;p&gt;If you want to use JWT RSASSA-PSS algorithms (i.e. &lt;code&gt;PS256&lt;/code&gt;, &lt;code&gt;PS384&lt;/code&gt;, and &lt;code&gt;PS512&lt;/code&gt;), EdECDH (&lt;code&gt;X25512&lt;/code&gt; or &lt;code&gt;X448&lt;/code&gt;) Elliptic Curve Diffie-Hellman encryption, EdDSA (&lt;code&gt;Ed25519&lt;/code&gt; or &lt;code&gt;Ed448&lt;/code&gt;) signature algorithms, or you just want to ensure your Android application is running an updated version of BouncyCastle, you will need to:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Uncomment the BouncyCastle dependency as commented above in the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#install-android-dependencies&#34;&gt;dependencies&lt;/a&gt; section.&lt;/li&gt; &#xA; &lt;li&gt;Replace the legacy Android custom &lt;code&gt;BC&lt;/code&gt; provider with the updated one.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Provider registration needs to be done &lt;em&gt;early&lt;/em&gt; in the application&#39;s lifecycle, preferably in your application&#39;s main &lt;code&gt;Activity&lt;/code&gt; class as a static initialization block. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainActivity : AppCompatActivity() {&#xA;&#xA;    companion object {&#xA;        init {&#xA;            Security.removeProvider(&#34;BC&#34;) //remove old/legacy Android-provided BC provider&#xA;            Security.addProvider(BouncyCastleProvider()) // add &#39;real&#39;/correct BC provider&#xA;        }&#xA;    }&#xA;&#xA;    // ... etc ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;install-understandingdependencies&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Understanding JJWT Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;Notice the above JJWT dependency declarations all have only one compile-time dependency and the rest are declared as &lt;em&gt;runtime&lt;/em&gt; dependencies.&lt;/p&gt; &#xA;&lt;p&gt;This is because JJWT is designed so you only depend on the APIs that are explicitly designed for you to use in your applications and all other internal implementation details - that can change without warning - are relegated to runtime-only dependencies. This is an extremely important point if you want to ensure stable JJWT usage and upgrades over time:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;JJWT guarantees semantic versioning compatibility for all of its artifacts &lt;em&gt;except&lt;/em&gt; the &lt;code&gt;jjwt-impl&lt;/code&gt; .jar. No such guarantee is made for the &lt;code&gt;jjwt-impl&lt;/code&gt; .jar and internal changes in that .jar can happen at any time. Never add the &lt;code&gt;jjwt-impl&lt;/code&gt; .jar to your project with &lt;code&gt;compile&lt;/code&gt; scope - always declare it with &lt;code&gt;runtime&lt;/code&gt; scope.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This is done to benefit you: great care goes into curating the &lt;code&gt;jjwt-api&lt;/code&gt; .jar and ensuring it contains what you need and remains backwards compatible as much as is possible so you can depend on that safely with compile scope. The runtime &lt;code&gt;jjwt-impl&lt;/code&gt; .jar strategy affords the JJWT developers the flexibility to change the internal packages and implementations whenever and however necessary. This helps us implement features, fix bugs, and ship new releases to you more quickly and efficiently.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;quickstart&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Most complexity is hidden behind a convenient and readable builder-based &lt;a href=&#34;http://en.wikipedia.org/wiki/Fluent_interface&#34;&gt;fluent interface&lt;/a&gt;, great for relying on IDE auto-completion to write code quickly. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import io.jsonwebtoken.Jwts;&#xA;import io.jsonwebtoken.security.Keys;&#xA;import java.security.Key;&#xA;&#xA;// We need a signing key, so we&#39;ll create one just for this example. Usually&#xA;// the key would be read from your application configuration instead.&#xA;SecretKey key = Jwts.SIG.HS256.key().build();&#xA;&#xA;String jws = Jwts.builder().subject(&#34;Joe&#34;).signWith(key).compact();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;How easy was that!?&lt;/p&gt; &#xA;&lt;p&gt;In this case, we are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;em&gt;building&lt;/em&gt; a JWT that will have the &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1&#34;&gt;registered claim&lt;/a&gt; &lt;code&gt;sub&lt;/code&gt; (Subject) set to &lt;code&gt;Joe&lt;/code&gt;. We are then&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;signing&lt;/em&gt; the JWT using a key suitable for the HMAC-SHA-256 algorithm. Finally, we are&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;compacting&lt;/em&gt; it into its final &lt;code&gt;String&lt;/code&gt; form. A signed JWT is called a &#39;JWS&#39;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The resultant &lt;code&gt;jws&lt;/code&gt; String looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJKb2UifQ.1KP0SsvENi7Uz1oQc07aXTL7kpQG5jBNIybqr60AlD4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now let&#39;s verify the JWT (you should always discard JWTs that don&#39;t match an expected signature):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;assert Jwts.parser().verifyWith(key).build().parseClaimsJws(jws).getPayload().getSubject().equals(&#34;Joe&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are two things going on here. The &lt;code&gt;key&lt;/code&gt; from before is being used to verify the signature of the JWT. If it fails to verify the JWT, a &lt;code&gt;SignatureException&lt;/code&gt; (which extends &lt;code&gt;JwtException&lt;/code&gt;) is thrown. Assuming the JWT is verified, we parse the claims and assert that that subject is set to &lt;code&gt;Joe&lt;/code&gt;. You have to love code one-liners that pack a punch!&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type-safe JWTs:&lt;/strong&gt; To get a type-safe &lt;code&gt;Claims&lt;/code&gt; JWT result, call the &lt;code&gt;parseClaimsJws&lt;/code&gt; method (since there are many similar methods available). You will get an &lt;code&gt;UnsupportedJwtException&lt;/code&gt; if you parse your JWT with wrong method.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;But what if parsing or signature validation failed? You can catch &lt;code&gt;JwtException&lt;/code&gt; and react accordingly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try {&#xA;&#xA;    Jwts.parser().verifyWith(key).build().parseClaimsJws(compactJws);&#xA;&#xA;    //OK, we can trust this JWT&#xA;&#xA;} catch (JwtException e) {&#xA;&#xA;    //don&#39;t trust the JWT!&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that we&#39;ve had a quickstart &#39;taste&#39; of how to create and parse JWTs, let&#39;s cover JJWT&#39;s API in-depth.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-create&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Creating a JWT&lt;/h2&gt; &#xA;&lt;p&gt;You create a JWT as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;Jwts.builder()&lt;/code&gt; method to create a &lt;code&gt;JwtBuilder&lt;/code&gt; instance.&lt;/li&gt; &#xA; &lt;li&gt;Optionally set any &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-header&#34;&gt;&lt;code&gt;header&lt;/code&gt; parameters&lt;/a&gt; as desired.&lt;/li&gt; &#xA; &lt;li&gt;Call builder methods to set the payload &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-content&#34;&gt;content&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwt-claims&#34;&gt;claims&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Optionally call &lt;code&gt;signWith&lt;/code&gt; or &lt;code&gt;encryptWith&lt;/code&gt; methods if you want to digitally sign or encrypt the JWT.&lt;/li&gt; &#xA; &lt;li&gt;Call the &lt;code&gt;compact()&lt;/code&gt; method to produce the resulting compact JWT string.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String jwt = Jwts.builder()                     // (1)&#xA;        &#xA;    .header()                                   // (2) optional&#xA;        .keyId(&#34;aKeyId&#34;)&#xA;        .and()&#xA;        &#xA;    .subject(&#34;Bob&#34;)                             // (3) JSON Claims, or&#xA;    //.content(aByteArray, &#34;text/plain&#34;)        //     any byte[] content, with media type&#xA;        &#xA;    .signWith(signingKey)                       // (4) if signing, or&#xA;    //.encryptWith(key, keyAlg, encryptionAlg)  //     if encrypting&#xA;        &#xA;    .compact();                                 // (5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The JWT &lt;code&gt;payload&lt;/code&gt; may be either &lt;code&gt;byte[]&lt;/code&gt; content (via &lt;code&gt;content&lt;/code&gt;) &lt;em&gt;or&lt;/em&gt; JSON Claims (such as &lt;code&gt;subject&lt;/code&gt;, &lt;code&gt;claims&lt;/code&gt;, etc), but not both.&lt;/li&gt; &#xA; &lt;li&gt;Either digital signatures (&lt;code&gt;signWith&lt;/code&gt;) or encryption (&lt;code&gt;encryptWith&lt;/code&gt;) may be used, but not both.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Unprotected JWTs&lt;/strong&gt;: If you do not use the &lt;code&gt;signWith&lt;/code&gt; or &lt;code&gt;encryptWith&lt;/code&gt; builder methods, &lt;strong&gt;an Unprotected JWT will be created, which offers no security protection at all&lt;/strong&gt;. If you need security protection, consider either &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws&#34;&gt;digitally signing&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe&#34;&gt;encrypting&lt;/a&gt; the JWT before calling the &lt;code&gt;compact()&lt;/code&gt; builder method.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-header&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-create-header&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchors for old links --&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Header&lt;/h3&gt; &#xA;&lt;p&gt;A JWT header is a JSON &lt;code&gt;Object&lt;/code&gt; that provides metadata about the contents, format, and any cryptographic operations relevant to the JWT &lt;code&gt;payload&lt;/code&gt;. JJWT provides a number of ways of setting the entire header and/or multiple individual header parameters (name/value pairs).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-header-builder&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-create-header-instance&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchors for old links --&gt;&lt;/p&gt; &#xA;&lt;h4&gt;JwtBuilder Header&lt;/h4&gt; &#xA;&lt;p&gt;The easiest and recommended way to set one or more JWT header parameters (name/value pairs) is to use the &lt;code&gt;JwtBuilder&lt;/code&gt;&#39;s &lt;code&gt;header()&lt;/code&gt; builder as desired, and then call its &lt;code&gt;and()&lt;/code&gt; method to return back to the &lt;code&gt;JwtBuilder&lt;/code&gt; for further configuration. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String jwt = Jwts.builder()&#xA;        &#xA;    .header()                        // &amp;lt;----&#xA;        .keyId(&#34;aKeyId&#34;)&#xA;        .x509Url(aUri)&#xA;        .add(&#34;someName&#34;, anyValue)&#xA;        .add(mapValues)&#xA;        // ... etc ...&#xA;        .and()                      // go back to the JwtBuilder&#xA;        &#xA;    .subject(&#34;Joe&#34;)                 // resume JwtBuilder calls...&#xA;    // ... etc ...    &#xA;    .compact();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;JwtBuilder&lt;/code&gt; &lt;code&gt;header()&lt;/code&gt; builder also supports automatically calculating X.509 thumbprints and other builder-style benefits that a simple property getter/setter object would not do.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Automatic Headers&lt;/strong&gt;: You do not need to set the &lt;code&gt;alg&lt;/code&gt;, &lt;code&gt;enc&lt;/code&gt; or &lt;code&gt;zip&lt;/code&gt; headers - JJWT will always set them automatically as needed.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-header-params&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Custom Header Parameters&lt;/h5&gt; &#xA;&lt;p&gt;In addition to type-safe builder methods for standard header parameters, &lt;code&gt;JwtBuilder.header()&lt;/code&gt; can also support arbitrary name/value pairs via the &lt;code&gt;add&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.builder()&#xA;        &#xA;    .header()&#xA;        .add(&#34;aHeaderName&#34;, aValue)&#xA;        // ... etc ...&#xA;        .and() // return to the JwtBuilder&#xA;   &#xA;// ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-header-map&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-create-header-map&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchors for old links --&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Header Parameter Map&lt;/h5&gt; &#xA;&lt;p&gt;The &lt;code&gt;add&lt;/code&gt; method is also overloaded to support multiple parameters in a &lt;code&gt;Map&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.builder()&#xA;        &#xA;    .header()&#xA;        .add(multipleHeaderParamsMap)&#xA;        // ... etc ...&#xA;        .and() // return to the JwtBuilder&#xA;   &#xA;// ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Jwts HeaderBuilder&lt;/h4&gt; &#xA;&lt;p&gt;Using &lt;code&gt;Jwts.builder().header()&lt;/code&gt; shown above is the preferred way to modify a header when using the &lt;code&gt;JwtBuilder&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, if you would like to create a &#39;standalone&#39; &lt;code&gt;Header&lt;/code&gt; outside of the context of using the &lt;code&gt;JwtBuilder&lt;/code&gt;, you can use &lt;code&gt;Jwts.header()&lt;/code&gt; instead to return an independent &lt;code&gt;Header&lt;/code&gt; builder. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Header header = Jwts.header() &#xA;&#xA;        .keyId(&#34;aKeyId&#34;)&#xA;        .x509Url(aUri)&#xA;        .add(&#34;someName&#34;, anyValue)&#xA;        .add(mapValues)&#xA;        // ... etc ...&#xA;        &#xA;        .build()  // &amp;lt;---- not &#39;and()&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are only two differences between &lt;code&gt;Jwts.header()&lt;/code&gt; and &lt;code&gt;Jwts.builder().header()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Jwts.header()&lt;/code&gt; builds a &#39;detached&#39; &lt;code&gt;Header&lt;/code&gt; that is not associated with any particular JWT, whereas &lt;code&gt;Jwts.builder().header()&lt;/code&gt; always modifies the header of the immediate JWT being constructed by its parent &lt;code&gt;JwtBuilder&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Jwts.header()&lt;/code&gt; has a &lt;code&gt;build()&lt;/code&gt; method to produce an explicit &lt;code&gt;Header&lt;/code&gt; instance and &lt;code&gt;Jwts.builder().header()&lt;/code&gt; does not (it has an &lt;code&gt;and()&lt;/code&gt; method instead) because its parent &lt;code&gt;JwtBuilder&lt;/code&gt; will implicitly create the header instance when necessary.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;A standalone header might be useful if you want to aggregate common header parameters in a single &#39;template&#39; instance so you don&#39;t have to repeat them for each &lt;code&gt;JwtBuilder&lt;/code&gt; usage. Then this &#39;template&#39; &lt;code&gt;Header&lt;/code&gt; can be used to populate &lt;code&gt;JwtBuilder&lt;/code&gt; usages by just appending it to the &lt;code&gt;JwtBuilder&lt;/code&gt; header, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// perhaps somewhere in application configuration:&#xA;Header commonHeaders = Jwts.header()&#xA;    .issuer(&#34;My Company&#34;)&#xA;    // ... etc ...&#xA;    .build();&#xA;&#xA;// --------------------------------&#xA;&#xA;// somewhere else during actual Jwt construction:&#xA;String jwt = Jwts.builder()&#xA;&#xA;    .header()&#xA;        .add(commonHeaders)                   // &amp;lt;----&#xA;        .add(&#34;specificHeader&#34;, specificValue) // jwt-specific headers...&#xA;        .and()&#xA;&#xA;    .subject(&#34;whatever&#34;)&#xA;    // ... etc ...&#xA;    .compact();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-payload&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Payload&lt;/h3&gt; &#xA;&lt;p&gt;A JWT &lt;code&gt;payload&lt;/code&gt; can be anything at all - anything that can be represented as a byte array, such as text, images, documents, and more. But since a JWT &lt;code&gt;header&lt;/code&gt; is always JSON, it makes sense that the &lt;code&gt;payload&lt;/code&gt; could also be JSON, especially for representing identity claims.&lt;/p&gt; &#xA;&lt;p&gt;As a result, the &lt;code&gt;JwtBuilder&lt;/code&gt; supports two distinct payload options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;content&lt;/code&gt; if you would like the payload to be arbitrary byte array content, or&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;claims&lt;/code&gt; (and supporting helper methods) if you would like the payload to be a JSON Claims &lt;code&gt;Object&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Either option may be used, but not both. Using both will cause &lt;code&gt;compact()&lt;/code&gt; to throw an exception.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-content&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Arbitrary Content&lt;/h4&gt; &#xA;&lt;p&gt;You can set the JWT payload to be any arbitrary byte array content by using the &lt;code&gt;JwtBuilder&lt;/code&gt; &lt;code&gt;content&lt;/code&gt; method. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] content = &#34;Hello World&#34;.getBytes(StandardCharsets.UTF_8);&#xA;&#xA;String jwt = Jwts.builder()&#xA;&#xA;    .content(content, &#34;text/plain&#34;) // &amp;lt;---&#xA;    &#xA;    // ... etc ...&#xA;        &#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice this particular example of &lt;code&gt;content&lt;/code&gt; uses the two-argument convenience variant:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The first argument is the actual byte content to set as the JWT payload&lt;/li&gt; &#xA; &lt;li&gt;The second argument is a String identifier of an IANA Media Type.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The second argument will cause the &lt;code&gt;JwtBuilder&lt;/code&gt; to automatically set the &lt;code&gt;cty&lt;/code&gt; (Content Type) header according to the JWT specification&#39;s &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7515.html#section-4.1.10&#34;&gt;recommended compact format&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This two-argument variant is typically recommended over the single-argument &lt;code&gt;content(byte[])&lt;/code&gt; method because it guarantees the JWT recipient can inspect the &lt;code&gt;cty&lt;/code&gt; header to determine how to convert the &lt;code&gt;payload&lt;/code&gt; byte array into a final form that the application can use.&lt;/p&gt; &#xA;&lt;p&gt;Without setting the &lt;code&gt;cty&lt;/code&gt; header, the JWT recipient &lt;em&gt;must&lt;/em&gt; know via out-of-band (external) information how to process the byte array, which is usually less convenient and always requires code changes if the content format ever changes. For these reasons, it is strongly recommended to use the two-argument &lt;code&gt;content&lt;/code&gt; method variant.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-claims&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-create-claims&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchors for old links --&gt;&lt;/p&gt; &#xA;&lt;h4&gt;JWT Claims&lt;/h4&gt; &#xA;&lt;p&gt;Instead of a content byte array, a JWT payload may contain assertions or claims for a JWT recipient. In this case, the payload is a &lt;code&gt;Claims&lt;/code&gt; JSON &lt;code&gt;Object&lt;/code&gt;, and JJWT supports claims creation with type-safe builder methods.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-claims-standard&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-create-claims-standard&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchors for old links --&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Standard Claims&lt;/h5&gt; &#xA;&lt;p&gt;The &lt;code&gt;JwtBuilder&lt;/code&gt; provides convenient builder methods for standard registered Claim names defined in the JWT specification. They are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;issuer&lt;/code&gt;: sets the &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.1&#34;&gt;&lt;code&gt;iss&lt;/code&gt; (Issuer) Claim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;subject&lt;/code&gt;: sets the &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.2&#34;&gt;&lt;code&gt;sub&lt;/code&gt; (Subject) Claim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;audience&lt;/code&gt;: sets the &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.3&#34;&gt;&lt;code&gt;aud&lt;/code&gt; (Audience) Claim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;expiration&lt;/code&gt;: sets the &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.4&#34;&gt;&lt;code&gt;exp&lt;/code&gt; (Expiration Time) Claim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;notBefore&lt;/code&gt;: sets the &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.5&#34;&gt;&lt;code&gt;nbf&lt;/code&gt; (Not Before) Claim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;issuedAt&lt;/code&gt;: sets the &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.6&#34;&gt;&lt;code&gt;iat&lt;/code&gt; (Issued At) Claim&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;id&lt;/code&gt;: sets the &lt;a href=&#34;https://tools.ietf.org/html/rfc7519#section-4.1.7&#34;&gt;&lt;code&gt;jti&lt;/code&gt; (JWT ID) Claim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&#xA;String jws = Jwts.builder()&#xA;&#xA;    .issuer(&#34;me&#34;)&#xA;    .subject(&#34;Bob&#34;)&#xA;    .audience(&#34;you&#34;)&#xA;    .expiration(expiration) //a java.util.Date&#xA;    .notBefore(notBefore) //a java.util.Date &#xA;    .issuedAt(new Date()) // for example, now&#xA;    .id(UUID.randomUUID().toString()) //just an example id&#xA;    &#xA;    /// ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-claims-custom&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-create-claims-custom&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchors for old links --&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Custom Claims&lt;/h5&gt; &#xA;&lt;p&gt;If you need to set one or more custom claims that don&#39;t match the standard setter method claims shown above, you can simply call the &lt;code&gt;JwtBuilder&lt;/code&gt; &lt;code&gt;claim&lt;/code&gt; method one or more times as needed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String jws = Jwts.builder()&#xA;&#xA;    .claim(&#34;hello&#34;, &#34;world&#34;)&#xA;    &#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each time &lt;code&gt;claim&lt;/code&gt; is called, it simply appends the key-value pair to an internal &lt;code&gt;Claims&lt;/code&gt; builder, potentially overwriting any existing identically-named key/value pair.&lt;/p&gt; &#xA;&lt;p&gt;Obviously, you do not need to call &lt;code&gt;claim&lt;/code&gt; for any &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-create-claims-standard&#34;&gt;standard claim name&lt;/a&gt;, and it is recommended instead to call the standard respective type-safe named builder method as this enhances readability.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-create-claims-instance&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchors for old links --&gt; &lt;a name=&#34;jwt-claims-instance&#34;&gt;&lt;/a&gt; &lt;a name=&#34;jwt-claims-map&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-create-claims-map&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchors for old links --&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Claims Map&lt;/h5&gt; &#xA;&lt;p&gt;If you want to add multiple claims at once, you can use &lt;code&gt;JwtBuilder&lt;/code&gt; &lt;code&gt;claims(Map)&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&#xA;Map&amp;lt;String,?&amp;gt; claims = getMyClaimsMap(); //implement me&#xA;&#xA;String jws = Jwts.builder()&#xA;&#xA;    .claims(claims)&#xA;    &#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-compression&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-create-compression&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchors for old links --&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Compression&lt;/h3&gt; &#xA;&lt;p&gt;If your JWT payload is large (contains a lot of data), you might want to compress the JWT to reduce its size. Note that this is &lt;em&gt;not&lt;/em&gt; a standard feature for all JWTs - only JWEs - and is not likely to be supported by other JWT libraries for non-JWE tokens. JJWT supports compression for both JWSs and JWEs, however.&lt;/p&gt; &#xA;&lt;p&gt;Please see the main &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#compression&#34;&gt;Compression&lt;/a&gt; section to see how to compress and decompress JWTs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-read&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Reading a JWT&lt;/h2&gt; &#xA;&lt;p&gt;You read (parse) a JWT as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;Jwts.parser()&lt;/code&gt; method to create a &lt;code&gt;JwtParserBuilder&lt;/code&gt; instance.&lt;/li&gt; &#xA; &lt;li&gt;Optionally call &lt;code&gt;keyLocator&lt;/code&gt;, &lt;code&gt;verifyWith&lt;/code&gt; or &lt;code&gt;decryptWith&lt;/code&gt; methods if you expect to parse &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws&#34;&gt;signed&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe&#34;&gt;encrypted&lt;/a&gt; JWTs.&lt;/li&gt; &#xA; &lt;li&gt;Call the &lt;code&gt;build()&lt;/code&gt; method on the &lt;code&gt;JwtParserBuilder&lt;/code&gt; to create and return a thread-safe &lt;code&gt;JwtParser&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Call one of the various &lt;code&gt;parse*&lt;/code&gt; methods with your compact JWT string, depending on the type of JWT you expect.&lt;/li&gt; &#xA; &lt;li&gt;Wrap the &lt;code&gt;parse*&lt;/code&gt; call in a try/catch block in case parsing, signature verification, or decryption fails.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwt&amp;lt;?,?&amp;gt; jwt;&#xA;&#xA;try {&#xA;    jwt = Jwts.parser()     // (1)&#xA;        &#xA;    .keyLocator(keyLocator) // (2) dynamically locate signing or encryption keys    &#xA;    //.verifyWith(key)      //     or a static key used to verify all signed JWTs&#xA;    //.decryptWith(key)     //     or a static key used to decrypt all encrypted JWTs&#xA;        &#xA;    .build()                // (3)&#xA;        &#xA;    .parse(compact);        // (4) or parseClaimsJws, parseClaimsJwe, parseContentJws, etc&#xA;    &#xA;    // we can safely trust the JWT&#xA;     &#xA;catch (JwtException ex) {   // (5)&#xA;    &#xA;    // we *cannot* use the JWT as intended by its creator&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type-safe JWTs:&lt;/strong&gt; If you are certain your parser will only ever encounter a specific kind of JWT (for example, you only ever use signed JWTs with &lt;code&gt;Claims&lt;/code&gt; payloads, or encrypted JWTs with &lt;code&gt;byte[]&lt;/code&gt; content payloads, etc), you can call the associated type-safe &lt;code&gt;parseClaimsJws&lt;/code&gt;, &lt;code&gt;parseClaimsJwe&lt;/code&gt;, (etc) method variant instead of the generic &lt;code&gt;parse&lt;/code&gt; method.&lt;/p&gt; &#xA; &lt;p&gt;These &lt;code&gt;parse*&lt;/code&gt; methods will return the type-safe JWT you are expecting, for example, a &lt;code&gt;Jws&amp;lt;Claims&amp;gt;&lt;/code&gt; or &lt;code&gt;Jwe&amp;lt;byte[]&amp;gt;&lt;/code&gt; instead of a generic &lt;code&gt;Jwt&amp;lt;?,?&amp;gt;&lt;/code&gt; instance.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-read-key&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Static Parsing Key&lt;/h3&gt; &#xA;&lt;p&gt;If the JWT parsed is a JWS or JWE, a key will be necessary to verify the signature or decrypt it. If a JWS and signature verification fails, or if a JWE and decryption fails, the JWT cannot be safely trusted and should be discarded.&lt;/p&gt; &#xA;&lt;p&gt;So which key do we use?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If parsing a JWS and the JWS was signed with a &lt;code&gt;SecretKey&lt;/code&gt;, the same &lt;code&gt;SecretKey&lt;/code&gt; should be specified on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.parser()&#xA;    &#xA;  .verifyWith(secretKey) // &amp;lt;----&#xA;  &#xA;  .build()&#xA;  .parseClaimsJws(jwsString);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If parsing a JWS and the JWS was signed with a &lt;code&gt;PrivateKey&lt;/code&gt;, that key&#39;s corresponding &lt;code&gt;PublicKey&lt;/code&gt; (not the &lt;code&gt;PrivateKey&lt;/code&gt;) should be specified on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.parser()&#xA;    &#xA;  .verifyWith(publicKey) // &amp;lt;---- publicKey, not privateKey&#xA;  &#xA;  .build()&#xA;  .parseClaimsJws(jwsString);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If parsing a JWE and the JWE was encrypted with direct encryption using a &lt;code&gt;SecretKey&lt;/code&gt;, the same &lt;code&gt;SecretKey&lt;/code&gt; should be specified on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.parser()&#xA;    &#xA;  .decryptWith(secretKey) // &amp;lt;----&#xA;  &#xA;  .build()&#xA;  .parseClaimsJwe(jweString);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If parsing a JWE and the JWE was encrypted with a key algorithm using with a &lt;code&gt;PublicKey&lt;/code&gt;, that key&#39;s corresponding &lt;code&gt;PrivateKey&lt;/code&gt; (not the &lt;code&gt;PublicKey&lt;/code&gt;) should be specified on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.parser()&#xA;    &#xA;  .decryptWith(privateKey) // &amp;lt;---- privateKey, not publicKey&#xA;  &#xA;  .build()&#xA;  .parseClaimsJwe(jweString);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Multiple Keys?&lt;/h4&gt; &#xA;&lt;p&gt;But you might have noticed something - what if your application doesn&#39;t use just a single &lt;code&gt;SecretKey&lt;/code&gt; or &lt;code&gt;KeyPair&lt;/code&gt;? What if JWSs and JWEs can be created with different &lt;code&gt;SecretKey&lt;/code&gt;s or public/private keys, or a combination of both? How do you know which key to specify if you don&#39;t inspect the JWT first?&lt;/p&gt; &#xA;&lt;p&gt;In these cases, you can&#39;t call the &lt;code&gt;JwtParserBuilder&lt;/code&gt;&#39;s &lt;code&gt;verifyWith&lt;/code&gt; or &lt;code&gt;decryptWith&lt;/code&gt; methods with a single key - instead, you&#39;ll need to configure a parsing Key Locator, discussed next.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;key-locator&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Dynamic Key Lookup&lt;/h3&gt; &#xA;&lt;p&gt;It is common in many applications to receive JWTs that can be encrypted or signed by different cryptographic keys. For example, maybe a JWT created to assert a specific user identity uses a Key specific to that exact user. Or perhaps JWTs specific to a particular customer all use that customer&#39;s Key. Or maybe your application creates JWTs that are encrypted with a key specific to your application for your own use (e.g. a user session token).&lt;/p&gt; &#xA;&lt;p&gt;In all of these and similar scenarios, you won&#39;t know which key was used to sign or encrypt a JWT until the JWT is received, at parse time, so you can&#39;t &#39;hard code&#39; any verification or decryption key using the &lt;code&gt;JwtParserBuilder&lt;/code&gt;&#39;s &lt;code&gt;verifyWith&lt;/code&gt; or &lt;code&gt;decryptWith&lt;/code&gt; methods. Those are only to be used when the same key is used to verify or decrypt &lt;em&gt;all&lt;/em&gt; JWSs or JWEs, which won&#39;t work for dynamically signed or encrypted JWTs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;key-locator-custom&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Key Locator&lt;/h4&gt; &#xA;&lt;p&gt;If you need to support dynamic key lookup when encountering JWTs, you&#39;ll need to implement the &lt;code&gt;Locator&amp;lt;Key&amp;gt;&lt;/code&gt; interface and specify an instance on the &lt;code&gt;JwtParserBuilder&lt;/code&gt; via the &lt;code&gt;keyLocator&lt;/code&gt; method. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Locator&amp;lt;Key&amp;gt; keyLocator = getMyKeyLocator();&#xA;&#xA;Jwts.parser()&#xA;&#xA;    .keyLocator(keyLocator) // &amp;lt;----&#xA;    &#xA;    .build()&#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;Locator&amp;lt;Key&amp;gt;&lt;/code&gt; is used to lookup &lt;em&gt;both&lt;/em&gt; JWS signature verification keys &lt;em&gt;and&lt;/em&gt; JWE decryption keys. You need to determine which key to return based on information in the JWT &lt;code&gt;header&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyKeyLocator extends LocatorAdapter&amp;lt;Key&amp;gt; {&#xA;    &#xA;    @Override&#xA;    public Key locate(ProtectedHeader&amp;lt;?&amp;gt; header) { // a JwsHeader or JweHeader&#xA;        // implement me&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;JwtParser&lt;/code&gt; will invoke the &lt;code&gt;locate&lt;/code&gt; method after parsing the JWT &lt;code&gt;header&lt;/code&gt;, but &lt;em&gt;before parsing the &lt;code&gt;payload&lt;/code&gt;, or verifying any JWS signature or decrypting any JWE ciphertext&lt;/em&gt;. This allows you to inspect the &lt;code&gt;header&lt;/code&gt; argument for any information that can help you look up the &lt;code&gt;Key&lt;/code&gt; to use for verifying &lt;em&gt;that specific jwt&lt;/em&gt;. This is very powerful for applications with more complex security models that might use different keys at different times or for different users or customers.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;key-locator-strategy&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Key Locator Strategy&lt;/h4&gt; &#xA;&lt;p&gt;What data might you inspect to determine how to lookup a signature verification or decryption key?&lt;/p&gt; &#xA;&lt;p&gt;The JWT specifications&#39; preferred approach is to set a &lt;code&gt;kid&lt;/code&gt; (Key ID) header value when the JWT is being created, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Key key = getSigningKey(); // or getEncryptionKey() for JWE&#xA;&#xA;String keyId = getKeyId(key); //any mechanism you have to associate a key with an ID is fine&#xA;&#xA;String jws = Jwts.builder()&#xA;        &#xA;    .header().keyId(keyId).and()               // &amp;lt;--- add `kid` header&#xA;    &#xA;    .signWith(key)                             // for JWS&#xA;    //.encryptWith(key, keyAlg, encryptionAlg) // for JWE&#xA;    .compact();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then during parsing, your &lt;code&gt;Locator&amp;lt;Key&amp;gt;&lt;/code&gt; implementation can inspect the &lt;code&gt;header&lt;/code&gt; to get the &lt;code&gt;kid&lt;/code&gt; value and then use it to look up the verification or decryption key from somewhere, like a database, keystore or Hardware Security Module (HSM). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyKeyLocator extends LocatorAdapter&amp;lt;Key&amp;gt; {&#xA;    &#xA;    @Override&#xA;    public Key locate(ProtectedHeader&amp;lt;?&amp;gt; header) { // both JwsHeader and JweHeader extend ProtectedHeader&#xA;        &#xA;        //inspect the header, lookup and return the verification key&#xA;        String keyId = header.getKeyId(); //or any other field that you need to inspect&#xA;&#xA;        Key key = lookupKey(keyId); //implement me&#xA;&#xA;        return key;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that inspecting the &lt;code&gt;header.getKeyId()&lt;/code&gt; is just the most common approach to look up a key - you could inspect any number of header fields to determine how to lookup the verification or decryption key. It is all based on how the JWT was created.&lt;/p&gt; &#xA;&lt;p&gt;If you extend &lt;code&gt;LocatorAdapter&amp;lt;Key&amp;gt;&lt;/code&gt; as shown above, but for some reason have different lookup strategies for signature verification keys versus decryption keys, you can forego overriding the &lt;code&gt;locate(ProtectedHeader&amp;lt;?&amp;gt;)&lt;/code&gt; method in favor of two respective &lt;code&gt;locate(JwsHeader)&lt;/code&gt; and &lt;code&gt;locate(JweHeader)&lt;/code&gt; methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyKeyLocator extends LocatorAdapter&amp;lt;Key&amp;gt; {&#xA;    &#xA;    @Override&#xA;    public Key locate(JwsHeader header) {&#xA;        String keyId = header.getKeyId(); //or any other field that you need to inspect&#xA;        return lookupSignatureVerificationKey(keyId); //implement me&#xA;    }&#xA;    &#xA;    @Override&#xA;    public Key locate(JweHeader header) {&#xA;        String keyId = header.getKeyId(); //or any other field that you need to inspect&#xA;        return lookupDecryptionKey(keyId); //implement me&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Simpler Lookup&lt;/strong&gt;: If possible, try to keep the key lookup strategy the same between JWSs and JWEs (i.e. using only &lt;code&gt;locate(ProtectedHeader&amp;lt;?&amp;gt;)&lt;/code&gt;), preferably using only the &lt;code&gt;kid&lt;/code&gt; (Key ID) header value or perhaps a public key thumbprint. You will find the implementation is much simpler and easier to maintain over time, and also creates smaller headers for compact transmission.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;key-locator-retvals&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Key Locator Return Values&lt;/h4&gt; &#xA;&lt;p&gt;Regardless of which implementation strategy you choose, remember to return the appropriate type of key depending on the type of JWS or JWE algorithm used. That is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For JWS: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;For HMAC-based signature algorithms, the returned verification key should be a &lt;code&gt;SecretKey&lt;/code&gt;, and,&lt;/li&gt; &#xA;   &lt;li&gt;For asymmetric signature algorithms, the returned verification key should be a &lt;code&gt;PublicKey&lt;/code&gt; (not a &lt;code&gt;PrivateKey&lt;/code&gt;).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;For JWE: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;For JWE direct encryption, the returned decryption key should be a &lt;code&gt;SecretKey&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;For password-based key derivation algorithms, the returned decryption key should be a &lt;code&gt;io.jsonwebtoken.security.Password&lt;/code&gt;. You can create a &lt;code&gt;Password&lt;/code&gt; instance by calling &lt;code&gt;Keys.password(char[] passwordCharacters)&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;For asymmetric key management algorithms, the returned decryption key should be a &lt;code&gt;PrivateKey&lt;/code&gt; (not a &lt;code&gt;PublicKey&lt;/code&gt;).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-read-claims&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-read-claims&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchor for old links --&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Claim Assertions&lt;/h3&gt; &#xA;&lt;p&gt;You can enforce that the JWT you are parsing conforms to expectations that you require and are important for your application.&lt;/p&gt; &#xA;&lt;p&gt;For example, let&#39;s say that you require that the JWT you are parsing has a specific &lt;code&gt;sub&lt;/code&gt; (subject) value, otherwise you may not trust the token. You can do that by using one of the various &lt;code&gt;require&lt;/code&gt;* methods on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try {&#xA;    Jwts.parser().requireSubject(&#34;jsmith&#34;)/* etc... */.build().parse(s);&#xA;} catch (InvalidClaimException ice) {&#xA;    // the sub field was missing or did not have a &#39;jsmith&#39; value&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If it is important to react to a missing vs an incorrect value, instead of catching &lt;code&gt;InvalidClaimException&lt;/code&gt;, you can catch either &lt;code&gt;MissingClaimException&lt;/code&gt; or &lt;code&gt;IncorrectClaimException&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try {&#xA;    Jwts.parser().requireSubject(&#34;jsmith&#34;)/* etc... */.build().parse(s);&#xA;} catch(MissingClaimException mce) {&#xA;    // the parsed JWT did not have the sub field&#xA;} catch(IncorrectClaimException ice) {&#xA;    // the parsed JWT had a sub field, but its value was not equal to &#39;jsmith&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also require custom fields by using the &lt;code&gt;require(fieldName, requiredFieldValue)&lt;/code&gt; method - for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try {&#xA;    Jwts.parser().require(&#34;myfield&#34;, &#34;myRequiredValue&#34;)/* etc... */.build().parse(s);&#xA;} catch(InvalidClaimException ice) {&#xA;    // the &#39;myfield&#39; field was missing or did not have a &#39;myRequiredValue&#39; value&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(or, again, you could catch either &lt;code&gt;MissingClaimException&lt;/code&gt; or &lt;code&gt;IncorrectClaimException&lt;/code&gt; instead).&lt;/p&gt; &#xA;&lt;p&gt;Please see the &lt;code&gt;JwtParserBuilder&lt;/code&gt; class and/or JavaDoc for a full list of the various &lt;code&gt;require&lt;/code&gt;* methods you may use for claims assertions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-read-clock&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-read-clock&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchor for old links --&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Accounting for Clock Skew&lt;/h3&gt; &#xA;&lt;p&gt;When parsing a JWT, you might find that &lt;code&gt;exp&lt;/code&gt; or &lt;code&gt;nbf&lt;/code&gt; claim assertions fail (throw exceptions) because the clock on the parsing machine is not perfectly in sync with the clock on the machine that created the JWT. This can cause obvious problems since &lt;code&gt;exp&lt;/code&gt; and &lt;code&gt;nbf&lt;/code&gt; are time-based assertions, and clock times need to be reliably in sync for shared assertions.&lt;/p&gt; &#xA;&lt;p&gt;You can account for these differences (usually no more than a few minutes) when parsing using the &lt;code&gt;JwtParserBuilder&lt;/code&gt;&#39;s &lt;code&gt;clockSkewSeconds&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;long seconds = 3 * 60; //3 minutes&#xA;&#xA;Jwts.parser()&#xA;    &#xA;    .clockSkewSeconds(seconds) // &amp;lt;----&#xA;    &#xA;    // ... etc ...&#xA;    .build()&#xA;    .parse(jwt);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This ensures that clock differences between the machines can be ignored. Two or three minutes should be more than enough; it would be fairly strange if a production machine&#39;s clock was more than 5 minutes difference from most atomic clocks around the world.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-read-clock-custom&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-read-clock-custom&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchor for old links --&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Custom Clock Support&lt;/h4&gt; &#xA;&lt;p&gt;If the above &lt;code&gt;clockSkewSeconds&lt;/code&gt; isn&#39;t sufficient for your needs, the timestamps created during parsing for timestamp comparisons can be obtained via a custom time source. Call the &lt;code&gt;JwtParserBuilder&lt;/code&gt;&#39;s &lt;code&gt;clock&lt;/code&gt; method with an implementation of the &lt;code&gt;io.jsonwebtoken.Clock&lt;/code&gt; interface. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Clock clock = new MyClock();&#xA;&#xA;Jwts.parser().clock(myClock) //... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;JwtParser&lt;/code&gt;&#39;s default &lt;code&gt;Clock&lt;/code&gt; implementation simply returns &lt;code&gt;new Date()&lt;/code&gt; to reflect the time when parsing occurs, as most would expect. However, supplying your own clock could be useful, especially when writing test cases to guarantee deterministic behavior.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwt-read-decompression&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Decompression&lt;/h3&gt; &#xA;&lt;p&gt;If you used JJWT to compress a JWT and you used a custom compression algorithm, you will need to tell the &lt;code&gt;JwtParserBuilder&lt;/code&gt; how to resolve your &lt;code&gt;CompressionCodec&lt;/code&gt; to decompress the JWT.&lt;/p&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#compression&#34;&gt;Compression&lt;/a&gt; section below to see how to decompress JWTs during parsing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Signed JWTs&lt;/h2&gt; &#xA;&lt;p&gt;The JWT specification provides for the ability to &lt;a href=&#34;https://en.wikipedia.org/wiki/Digital_signature&#34;&gt;cryptographically &lt;em&gt;sign&lt;/em&gt;&lt;/a&gt; a JWT. Signing a JWT:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;guarantees the JWT was created by someone we know (it is authentic) as well as&lt;/li&gt; &#xA; &lt;li&gt;guarantees that no-one has manipulated or changed the JWT after it was created (its integrity is maintained).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;These two properties - authenticity and integrity - assure us that a JWT contains information we can trust. If a JWT fails authenticity or integrity checks, we should always reject that JWT because we can&#39;t trust it.&lt;/p&gt; &#xA;&lt;p&gt;But before we dig in to showing you how to create a JWS using JJWT, let&#39;s briefly discuss Signature Algorithms and Keys, specifically as they relate to the JWT specifications. Understanding them is critical to being able to create a JWS properly.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-alg&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Standard Signature Algorithms&lt;/h3&gt; &#xA;&lt;p&gt;The JWT specifications identify 13 standard signature algorithms - 3 secret key algorithms and 10 asymmetric key algorithms:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Identifier&lt;/th&gt; &#xA;   &lt;th&gt;Signature Algorithm&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;HS256&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;HMAC using SHA-256&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;HS384&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;HMAC using SHA-384&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;HS512&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;HMAC using SHA-512&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ES256&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ECDSA using P-256 and SHA-256&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ES384&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ECDSA using P-384 and SHA-384&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ES512&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ECDSA using P-521 and SHA-512&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;RS256&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RSASSA-PKCS-v1_5 using SHA-256&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;RS384&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RSASSA-PKCS-v1_5 using SHA-384&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;RS512&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RSASSA-PKCS-v1_5 using SHA-512&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PS256&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RSASSA-PSS using SHA-256 and MGF1 with SHA-256&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PS384&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RSASSA-PSS using SHA-384 and MGF1 with SHA-384&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PS512&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RSASSA-PSS using SHA-512 and MGF1 with SHA-512&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;EdDSA&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Edwards-Curve Digital Signature Algorithm (EdDSA)&lt;sup&gt;&lt;b&gt;2&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;. Requires Java 11 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;b&gt;2&lt;/b&gt;. Requires Java 15 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;These are all represented as constants in the &lt;code&gt;io.jsonwebtoken.Jwts.SIG&lt;/code&gt; convenience class.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-key&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Signature Algorithms Keys&lt;/h3&gt; &#xA;&lt;p&gt;What&#39;s really important about the above standard signature algorithms - other than their security properties - is that the JWT specification &lt;a href=&#34;https://tools.ietf.org/html/rfc7518#section-3&#34;&gt;RFC 7518, Sections 3.2 through 3.5&lt;/a&gt; &lt;em&gt;requires&lt;/em&gt; (mandates) that you MUST use keys that are sufficiently strong for a chosen algorithm.&lt;/p&gt; &#xA;&lt;p&gt;This means that JJWT - a specification-compliant library - will also enforce that you use sufficiently strong keys for the algorithms you choose. If you provide a weak key for a given algorithm, JJWT will reject it and throw an exception.&lt;/p&gt; &#xA;&lt;p&gt;This is not because we want to make your life difficult, we promise! The reason why the JWT specification, and consequently JJWT, mandates key lengths is that the security model of a particular algorithm can completely break down if you don&#39;t adhere to the mandatory key properties of the algorithm, effectively having no security at all. No one wants completely insecure JWTs, right? Right!&lt;/p&gt; &#xA;&lt;p&gt;So what are the key strength requirements?&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-key-hmacsha&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;HMAC-SHA&lt;/h4&gt; &#xA;&lt;p&gt;JWT HMAC-SHA signature algorithms &lt;code&gt;HS256&lt;/code&gt;, &lt;code&gt;HS384&lt;/code&gt;, and &lt;code&gt;HS512&lt;/code&gt; require a secret key that is &lt;em&gt;at least&lt;/em&gt; as many bits as the algorithm&#39;s signature (digest) length per &lt;a href=&#34;https://tools.ietf.org/html/rfc7518#section-3.2&#34;&gt;RFC 7512 Section 3.2&lt;/a&gt;. This means:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;HS256&lt;/code&gt; is HMAC-SHA-256, and that produces digests that are 256 bits (32 bytes) long, so &lt;code&gt;HS256&lt;/code&gt; &lt;em&gt;requires&lt;/em&gt; that you use a secret key that is at least 32 bytes long.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;HS384&lt;/code&gt; is HMAC-SHA-384, and that produces digests that are 384 bits (48 bytes) long, so &lt;code&gt;HS384&lt;/code&gt; &lt;em&gt;requires&lt;/em&gt; that you use a secret key that is at least 48 bytes long.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;HS512&lt;/code&gt; is HMAC-SHA-512, and that produces digests that are 512 bits (64 bytes) long, so &lt;code&gt;HS512&lt;/code&gt; &lt;em&gt;requires&lt;/em&gt; that you use a secret key that is at least 64 bytes long.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-key-rsa&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;RSA&lt;/h4&gt; &#xA;&lt;p&gt;JWT RSA signature algorithms &lt;code&gt;RS256&lt;/code&gt;, &lt;code&gt;RS384&lt;/code&gt;, &lt;code&gt;RS512&lt;/code&gt;, &lt;code&gt;PS256&lt;/code&gt;, &lt;code&gt;PS384&lt;/code&gt; and &lt;code&gt;PS512&lt;/code&gt; all require a minimum key length (aka an RSA modulus bit length) of &lt;code&gt;2048&lt;/code&gt; bits per RFC 7512 Sections &lt;a href=&#34;https://tools.ietf.org/html/rfc7518#section-3.3&#34;&gt;3.3&lt;/a&gt; and &lt;a href=&#34;https://tools.ietf.org/html/rfc7518#section-3.5&#34;&gt;3.5&lt;/a&gt;. Anything smaller than this (such as 1024 bits) will be rejected with an &lt;code&gt;WeakKeyException&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;That said, in keeping with best practices and increasing key lengths for security longevity, JJWT recommends that you use:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;at least 2048 bit keys with &lt;code&gt;RS256&lt;/code&gt; and &lt;code&gt;PS256&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;at least 3072 bit keys with &lt;code&gt;RS384&lt;/code&gt; and &lt;code&gt;PS384&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;at least 4096 bit keys with &lt;code&gt;RS512&lt;/code&gt; and &lt;code&gt;PS512&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These are only JJWT suggestions and not requirements. JJWT only enforces JWT specification requirements and for any RSA key, the requirement is the RSA key (modulus) length in bits MUST be &amp;gt;= 2048 bits.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-key-ecdsa&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Elliptic Curve&lt;/h4&gt; &#xA;&lt;p&gt;JWT Elliptic Curve signature algorithms &lt;code&gt;ES256&lt;/code&gt;, &lt;code&gt;ES384&lt;/code&gt;, and &lt;code&gt;ES512&lt;/code&gt; all require a key length (aka an Elliptic Curve order bit length) equal to the algorithm signature&#39;s individual &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt; components per &lt;a href=&#34;https://tools.ietf.org/html/rfc7518#section-3.4&#34;&gt;RFC 7512 Section 3.4&lt;/a&gt;. This means:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ES256&lt;/code&gt; requires that you use a private key that is exactly 256 bits (32 bytes) long.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ES384&lt;/code&gt; requires that you use a private key that is exactly 384 bits (48 bytes) long.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;ES512&lt;/code&gt; requires that you use a private key that is exactly 521 bits (65 or 66 bytes) long (depending on format).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-key-eddsa&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Edwards Curve&lt;/h4&gt; &#xA;&lt;p&gt;The JWT Edwards Curve signature algorithm &lt;code&gt;EdDSA&lt;/code&gt; supports two sizes of private and public &lt;code&gt;EdECKey&lt;/code&gt;s (these types were introduced in Java 15):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Ed25519&lt;/code&gt; algorithm keys must be 256 bits (32 bytes) long and produce signatures 512 bits (64 bytes) long.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Ed448&lt;/code&gt; algorithm keys must be 456 bits (57 bytes) long and produce signatures 912 bits (114 bytes) long.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-key-create&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Creating Safe Keys&lt;/h4&gt; &#xA;&lt;p&gt;If you don&#39;t want to think about bit length requirements or just want to make your life easier, JJWT has provided convenient builder classes that can generate sufficiently secure keys for any given JWT signature algorithm you might want to use.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-key-create-secret&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Secret Keys&lt;/h5&gt; &#xA;&lt;p&gt;If you want to generate a sufficiently strong &lt;code&gt;SecretKey&lt;/code&gt; for use with the JWT HMAC-SHA algorithms, use the respective algorithm&#39;s &lt;code&gt;key()&lt;/code&gt; builder method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SecretKey key = Jwts.SIG.HS256.key().build(); //or HS384.key() or HS512.key()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Under the hood, JJWT uses the JCA default provider&#39;s &lt;code&gt;KeyGenerator&lt;/code&gt; to create a secure-random key with the correct minimum length for the given algorithm.&lt;/p&gt; &#xA;&lt;p&gt;If you want to specify a specific JCA &lt;code&gt;Provider&lt;/code&gt; or &lt;code&gt;SecureRandom&lt;/code&gt; to use during key generation, you may specify those as builder arguments. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SecretKey key = Jwts.SIG.HS256.key().provider(aProvider).random(aSecureRandom).build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to save this new &lt;code&gt;SecretKey&lt;/code&gt;, you can Base64 (or Base64URL) encode it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String secretString = Encoders.BASE64.encode(key.getEncoded());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Ensure you save the resulting &lt;code&gt;secretString&lt;/code&gt; somewhere safe - &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#base64-not-encryption&#34;&gt;Base64-encoding is not encryption&lt;/a&gt;, so it&#39;s still considered sensitive information. You can further encrypt it, etc, before saving to disk (for example).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-key-create-asym&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Asymmetric Keys&lt;/h5&gt; &#xA;&lt;p&gt;If you want to generate sufficiently strong Elliptic Curve or RSA asymmetric key pairs for use with JWT ECDSA or RSA algorithms, use an algorithm&#39;s respective &lt;code&gt;keyPair()&lt;/code&gt; builder method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;KeyPair keyPair = Jwts.SIG.RS256.keyPair().build(); //or RS384, RS512, PS256, etc...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you&#39;ve generated a &lt;code&gt;KeyPair&lt;/code&gt;, you can use the private key (&lt;code&gt;keyPair.getPrivate()&lt;/code&gt;) to create a JWS and the public key (&lt;code&gt;keyPair.getPublic()&lt;/code&gt;) to parse/verify a JWS.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;The &lt;code&gt;PS256&lt;/code&gt;, &lt;code&gt;PS384&lt;/code&gt;, and &lt;code&gt;PS512&lt;/code&gt; algorithms require JDK 11 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;The &lt;code&gt;EdDSA&lt;/code&gt; algorithms requires JDK 15 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/strong&gt; If you want to use either set of algorithms, and you are on an earlier JDK that does not support them, see the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#Installation&#34;&gt;Installation&lt;/a&gt; section to see how to enable BouncyCastle. All other algorithms are natively supported by the JDK.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-create&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Creating a JWS&lt;/h3&gt; &#xA;&lt;p&gt;You create a JWS as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;Jwts.builder()&lt;/code&gt; method to create a &lt;code&gt;JwtBuilder&lt;/code&gt; instance.&lt;/li&gt; &#xA; &lt;li&gt;Call &lt;code&gt;JwtBuilder&lt;/code&gt; methods to set the &lt;code&gt;payload&lt;/code&gt; content or claims and any header parameters as desired.&lt;/li&gt; &#xA; &lt;li&gt;Specify the &lt;code&gt;SecretKey&lt;/code&gt; or asymmetric &lt;code&gt;PrivateKey&lt;/code&gt; you want to use to sign the JWT.&lt;/li&gt; &#xA; &lt;li&gt;Finally, call the &lt;code&gt;compact()&lt;/code&gt; method to compact and sign, producing the final jws.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String jws = Jwts.builder() // (1)&#xA;&#xA;    .subject(&#34;Bob&#34;)         // (2) &#xA;&#xA;    .signWith(key)          // (3) &amp;lt;---&#xA;     &#xA;    .compact();             // (4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-create-key&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Signing Key&lt;/h4&gt; &#xA;&lt;p&gt;It is usually recommended to specify the signing key by calling the &lt;code&gt;JwtBuilder&lt;/code&gt;&#39;s &lt;code&gt;signWith&lt;/code&gt; method and let JJWT determine the most secure algorithm allowed for the specified key.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String jws = Jwts.builder()&#xA;&#xA;   // ... etc ...&#xA;   &#xA;   .signWith(key) // &amp;lt;---&#xA;   &#xA;   .compact();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, if you call &lt;code&gt;signWith&lt;/code&gt; with a &lt;code&gt;SecretKey&lt;/code&gt; that is 256 bits (32 bytes) long, it is not strong enough for &lt;code&gt;HS384&lt;/code&gt; or &lt;code&gt;HS512&lt;/code&gt;, so JJWT will automatically sign the JWT using &lt;code&gt;HS256&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When using &lt;code&gt;signWith&lt;/code&gt; JJWT will also automatically set the required &lt;code&gt;alg&lt;/code&gt; header with the associated algorithm identifier.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, if you called &lt;code&gt;signWith&lt;/code&gt; with an RSA &lt;code&gt;PrivateKey&lt;/code&gt; that was 4096 bits long, JJWT will use the &lt;code&gt;RS512&lt;/code&gt; algorithm and automatically set the &lt;code&gt;alg&lt;/code&gt; header to &lt;code&gt;RS512&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The same selection logic applies for Elliptic Curve &lt;code&gt;PrivateKey&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;You cannot sign JWTs with &lt;code&gt;PublicKey&lt;/code&gt;s as this is always insecure.&lt;/strong&gt; JJWT will reject any specified &lt;code&gt;PublicKey&lt;/code&gt; for signing with an &lt;code&gt;InvalidKeyException&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-create-key-secret&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;SecretKey Formats&lt;/h5&gt; &#xA;&lt;p&gt;If you want to sign a JWS using HMAC-SHA algorithms, and you have a secret key &lt;code&gt;String&lt;/code&gt; or &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/security/Key.html#getEncoded--&#34;&gt;encoded byte array&lt;/a&gt;, you will need to convert it into a &lt;code&gt;SecretKey&lt;/code&gt; instance to use as the &lt;code&gt;signWith&lt;/code&gt; method argument.&lt;/p&gt; &#xA;&lt;p&gt;If your secret key is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;An &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/security/Key.html#getEncoded--&#34;&gt;encoded byte array&lt;/a&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SecretKey key = Keys.hmacShaKeyFor(encodedKeyBytes);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A Base64-encoded string:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SecretKey key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretString));&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A Base64URL-encoded string:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SecretKey key = Keys.hmacShaKeyFor(Decoders.BASE64URL.decode(secretString));&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A raw (non-encoded) string (e.g. a password String):&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SecretKey key = Keys.hmacShaKeyFor(secretString.getBytes(StandardCharsets.UTF_8));&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;It is always incorrect to call &lt;code&gt;secretString.getBytes()&lt;/code&gt; (without providing a charset).&lt;/p&gt; &lt;p&gt;However, raw password strings like this, e.g. &lt;code&gt;correcthorsebatterystaple&lt;/code&gt; should be avoided whenever possible because they can inevitably result in weak or susceptible keys. Secure-random keys are almost always stronger. If you are able, prefer creating a &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-key-create-secret&#34;&gt;new secure-random secret key&lt;/a&gt; instead.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-create-key-algoverride&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;SignatureAlgorithm Override&lt;/h5&gt; &#xA;&lt;p&gt;In some specific cases, you might want to override JJWT&#39;s default selected signature algorithm for a given key.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you have an RSA &lt;code&gt;PrivateKey&lt;/code&gt; that is 2048 bits, JJWT would automatically choose the &lt;code&gt;RS256&lt;/code&gt; algorithm. If you wanted to use &lt;code&gt;RS384&lt;/code&gt; or &lt;code&gt;RS512&lt;/code&gt; instead, you could manually specify it with the overloaded &lt;code&gt;signWith&lt;/code&gt; method that accepts the &lt;code&gt;SignatureAlgorithm&lt;/code&gt; as an additional parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&#xA;   .signWith(privateKey, Jwts.SIG.RS512) // &amp;lt;---&#xA;   &#xA;   .compact();&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is allowed because the JWT specification allows any RSA algorithm strength for any RSA key &amp;gt;= 2048 bits. JJWT just prefers &lt;code&gt;RS512&lt;/code&gt; for keys &amp;gt;= 4096 bits, followed by &lt;code&gt;RS384&lt;/code&gt; for keys &amp;gt;= 3072 bits and finally &lt;code&gt;RS256&lt;/code&gt; for keys &amp;gt;= 2048 bits.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;In all cases however, regardless of your chosen algorithms, JJWT will assert that the specified key is allowed to be used for that algorithm when possible according to the JWT specification requirements.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-create-compression&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;JWS Compression&lt;/h4&gt; &#xA;&lt;p&gt;If your JWT payload is large (contains a lot of data), and you are certain that JJWT will also be the same library that reads/parses your JWS, you might want to compress the JWS to reduce its size.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Not Standard for JWS&lt;/strong&gt;: JJWT supports compression for JWS, but it is not a standard feature for JWS. The JWT RFC specifications standardize this &lt;em&gt;only&lt;/em&gt; for JWEs, and it is not likely to be supported by other JWT libraries for JWS. Use JWS compression only if you are certain that JJWT (or another library that supports JWS compression) will be parsing the JWS&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Please see the main &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#compression&#34;&gt;Compression&lt;/a&gt; section to see how to compress and decompress JWTs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-read&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Reading a JWS&lt;/h3&gt; &#xA;&lt;p&gt;You read (parse) a JWS as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;Jwts.parser()&lt;/code&gt; method to create a &lt;code&gt;JwtParserBuilder&lt;/code&gt; instance.&lt;/li&gt; &#xA; &lt;li&gt;Call either &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#key-locator&#34;&gt;keyLocator&lt;/a&gt; or &lt;code&gt;verifyWith&lt;/code&gt; methods to determine the key used to verify the JWS signature.&lt;/li&gt; &#xA; &lt;li&gt;Call the &lt;code&gt;build()&lt;/code&gt; method on the &lt;code&gt;JwtParserBuilder&lt;/code&gt; to return a thread-safe &lt;code&gt;JwtParser&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Finally, call the &lt;code&gt;parseClaimsJws(String)&lt;/code&gt; method with your jws &lt;code&gt;String&lt;/code&gt;, producing the original JWS.&lt;/li&gt; &#xA; &lt;li&gt;The entire call is wrapped in a try/catch block in case parsing or signature validation fails. We&#39;ll cover exceptions and causes for failure later.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jws&amp;lt;Claims&amp;gt; jws;&#xA;&#xA;try {&#xA;    jws = Jwts.parser()         // (1)&#xA;        &#xA;    .keyLocator(keyLocator)     // (2) dynamically lookup verification keys based on each JWS    &#xA;    //.verifyWith(key)          //     or a static key used to verify all encountered JWSs&#xA;        &#xA;    .build()                    // (3)&#xA;    .parseClaimsJws(jwsString); // (4) or parseContentJws(jwsString)&#xA;    &#xA;    // we can safely trust the JWT&#xA;     &#xA;catch (JwtException ex) {       // (5)&#xA;    &#xA;    // we *cannot* use the JWT as intended by its creator&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type-safe JWSs:&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;If you are expecting a JWS with a Claims &lt;code&gt;payload&lt;/code&gt;, call the &lt;code&gt;JwtParser&lt;/code&gt;&#39;s &lt;code&gt;parseClaimsJws&lt;/code&gt; method.&lt;/li&gt; &#xA;  &lt;li&gt;If you are expecting a JWS with a content &lt;code&gt;payload&lt;/code&gt;, call the &lt;code&gt;JwtParser&lt;/code&gt;&#39;s &lt;code&gt;parseContentJws&lt;/code&gt; method.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-read-key&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Verification Key&lt;/h4&gt; &#xA;&lt;p&gt;The most important thing to do when reading a JWS is to specify the key used to verify the JWS&#39;s cryptographic signature. If signature verification fails, the JWT cannot be safely trusted and should be discarded.&lt;/p&gt; &#xA;&lt;p&gt;So which key do we use for verification?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If the jws was signed with a &lt;code&gt;SecretKey&lt;/code&gt;, the same &lt;code&gt;SecretKey&lt;/code&gt; should be specified on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;.&lt;br&gt; For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.parser()&#xA;    &#xA;  .verifyWith(secretKey) // &amp;lt;----&#xA;  &#xA;  .build()&#xA;  .parseClaimsJws(jwsString);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If the jws was signed with a &lt;code&gt;PrivateKey&lt;/code&gt;, that key&#39;s corresponding &lt;code&gt;PublicKey&lt;/code&gt; (not the &lt;code&gt;PrivateKey&lt;/code&gt;) should be specified on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.parser()&#xA;    &#xA;  .verifyWith(publicKey) // &amp;lt;---- publicKey, not privateKey&#xA;  &#xA;  .build()&#xA;  .parseClaimsJws(jwsString);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-read-key-locator&#34;&gt;&lt;/a&gt;&lt;a name=&#34;jws-read-key-resolver&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- legacy anchors for old links --&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Verification Key Locator&lt;/h4&gt; &#xA;&lt;p&gt;But you might have noticed something - what if your application doesn&#39;t use just a single &lt;code&gt;SecretKey&lt;/code&gt; or &lt;code&gt;KeyPair&lt;/code&gt;? What if JWSs can be created with different &lt;code&gt;SecretKey&lt;/code&gt;s or public/private keys, or a combination of both? How do you know which key to specify if you can&#39;t inspect the JWT first?&lt;/p&gt; &#xA;&lt;p&gt;In these cases, you can&#39;t call the &lt;code&gt;JwtParserBuilder&lt;/code&gt;&#39;s &lt;code&gt;verifyWith&lt;/code&gt; method with a single key - instead, you&#39;ll need a Key Locator. Please see the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#key-locator&#34;&gt;Key Lookup&lt;/a&gt; section to see how to dynamically obtain different keys when parsing JWSs or JWEs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jws-read-decompression&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;JWS Decompression&lt;/h4&gt; &#xA;&lt;p&gt;If you used JJWT to compress a JWS and you used a custom compression algorithm, you will need to tell the &lt;code&gt;JwtParserBuilder&lt;/code&gt; how to resolve your &lt;code&gt;CompressionCodec&lt;/code&gt; to decompress the JWT.&lt;/p&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#compression&#34;&gt;Compression&lt;/a&gt; section below to see how to decompress JWTs during parsing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Encrypted JWTs&lt;/h2&gt; &#xA;&lt;p&gt;The JWT specification also provides for the ability to encrypt and decrypt a JWT. Encrypting a JWT:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;guarantees that no-one other than the intended JWT recipient can see the JWT &lt;code&gt;payload&lt;/code&gt; (it is confidential), and&lt;/li&gt; &#xA; &lt;li&gt;guarantees that no-one has manipulated or changed the JWT after it was created (its integrity is maintained).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;These two properties - confidentiality and integrity - assure us that an encrypted JWT contains a &lt;code&gt;payload&lt;/code&gt; that no-one else can see, &lt;em&gt;nor&lt;/em&gt; has anyone changed or altered the data in transit.&lt;/p&gt; &#xA;&lt;p&gt;Encryption and confidentiality seem somewhat obvious: if you encrypt a message, it is confidential by the notion that random 3rd parties cannot make sense of the encrypted message. But some might be surprised to know that &lt;strong&gt;&lt;em&gt;general encryption does &lt;em&gt;not&lt;/em&gt; guarantee that someone hasn&#39;t tampered/altered an encrypted message in transit&lt;/em&gt;&lt;/strong&gt;. Most of us assume that if a message can be decrypted, then the message would be authentic and unchanged - after all, if you can decrypt it, it must not have been tampered with, right? Because if it was changed, decryption would surely fail, right?&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, this is not actually guaranteed in all cryptographic ciphers. There are certain attack vectors where it is possible to change an encrypted payload (called &#39;ciphertext&#39;), and the message recipient is still able to successfully decrypt the (modified) payload. In these cases, the ciphertext integrity was not maintained - a malicious 3rd party could intercept a message and change the payload content, even if they don&#39;t understand what is inside the payload, and the message recipient could never know.&lt;/p&gt; &#xA;&lt;p&gt;To combat this, there is a category of encryption algorithms that ensures both confidentiality &lt;em&gt;and&lt;/em&gt; integrity of the ciphertext data. These types of algorithms are called &lt;a href=&#34;https://en.wikipedia.org/wiki/Authenticated_encryption&#34;&gt;Authenticated Encryption&lt;/a&gt; algorithms.&lt;/p&gt; &#xA;&lt;p&gt;As a result, to ensure JWTs do not suffer from this problem, the JWE RFC specifications require that any encryption algorithm used to encrypt a JWT &lt;em&gt;MUST&lt;/em&gt; be an Authenticated Encryption algorithm. JWT users can be sufficiently confident their encrypted JWTs maintain the properties of both confidentiality and integrity.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-enc&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWE Encryption Algorithms&lt;/h3&gt; &#xA;&lt;p&gt;The JWT specification defines 6 standard Authenticated Encryption algorithms used to encrypt a JWT &lt;code&gt;payload&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Identifier&lt;/th&gt; &#xA;   &lt;th&gt;Required Key Bit Length&lt;/th&gt; &#xA;   &lt;th&gt;Encryption Algorithm&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A128CBC‑HS256&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;256&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.3&#34;&gt;AES_128_CBC_HMAC_SHA_256&lt;/a&gt; authenticated encryption algorithm&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A192CBC-HS384&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;384&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.4&#34;&gt;AES_192_CBC_HMAC_SHA_384&lt;/a&gt; authenticated encryption algorithm&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A256CBC-HS512&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;512&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.5&#34;&gt;AES_256_CBC_HMAC_SHA_512&lt;/a&gt; authenticated encryption algorithm&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A128GCM&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;128&lt;/td&gt; &#xA;   &lt;td&gt;AES GCM using 128-bit key&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A192GCM&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;192&lt;/td&gt; &#xA;   &lt;td&gt;AES GCM using 192-bit key&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A256GCM&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;256&lt;/td&gt; &#xA;   &lt;td&gt;AES GCM using 256-bit key&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;b&gt;1. &lt;/b&gt;Requires Java 8+ or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;These are all represented as constants in the &lt;code&gt;io.jsonwebtoken.Jwts.ENC&lt;/code&gt; registry singleton as implementations of the &lt;code&gt;io.jsonwebtoken.security.AeadAlgorithm&lt;/code&gt; interface.&lt;/p&gt; &#xA;&lt;p&gt;As shown in the table above, each algorithm requires a key of sufficient length. The JWT specification &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.3&#34;&gt;RFC 7518, Sections 5.2.3 through 5.3&lt;/a&gt; &lt;em&gt;requires&lt;/em&gt; (mandates) that you MUST use keys that are sufficiently strong for a chosen algorithm. This means that JJWT - a specification-compliant library - will also enforce that you use sufficiently strong keys for the algorithms you choose. If you provide a weak key for a given algorithm, JJWT will reject it and throw an exception.&lt;/p&gt; &#xA;&lt;p&gt;The reason why the JWT specification, and consequently JJWT, mandates key lengths is that the security model of a particular algorithm can completely break down if you don&#39;t adhere to the mandatory key properties of the algorithm, effectively having no security at all.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-enc-symmetric&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Symmetric Ciphers&lt;/h4&gt; &#xA;&lt;p&gt;You might have noticed something about the above Authenticated Encryption algorithms: they&#39;re all variants of the AES algorithm, and AES always uses a symmetric (secret) key to perform encryption and decryption. That&#39;s kind of strange, isn&#39;t it?&lt;/p&gt; &#xA;&lt;p&gt;What about RSA and Elliptic Curve asymmetric key cryptography? And Diffie-Hellman key exchange? What about password-based key derivation algorithms? Surely any of those could be desirable depending on the use case, no?&lt;/p&gt; &#xA;&lt;p&gt;Yes, they definitely can, and the JWT specifications do support them, albeit indirectly: those other algorithms &lt;em&gt;are&lt;/em&gt; indeed supported and used, but they aren&#39;t used to encrypt the JWT &lt;code&gt;payload&lt;/code&gt; directly. They are used to &lt;em&gt;produce&lt;/em&gt; the actual key used to encrypt the &lt;code&gt;JWT&lt;/code&gt; payload.&lt;/p&gt; &#xA;&lt;p&gt;This is all done via the JWT specification&#39;s concept of a Key Management Algorithm, covered next. After we cover that, we&#39;ll show you how to encrypt and parse your own JWTs with the &lt;code&gt;JwtBuilder&lt;/code&gt; and &lt;code&gt;JwtParserBuilder&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-alg&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWE Key Management Algorithms&lt;/h3&gt; &#xA;&lt;p&gt;As stated above, all standard JWA Encryption Algorithms are AES-based authenticated encryption algorithms. So what about RSA and Elliptic Curve cryptography? And password-based key derivation, or Diffie-Hellman exchange?&lt;/p&gt; &#xA;&lt;p&gt;All of those are supported as well, but they are not used directly for encryption. They are used to &lt;em&gt;produce&lt;/em&gt; the key that will be used to directly encrypt the JWT &lt;code&gt;payload&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;That is, JWT encryption can be thought of as a two-step process, shown in the following pseudocode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;Key algorithmKey = getKeyManagementAlgorithmKey(); // PublicKey, SecretKey, or Password&#xA;&#xA;SecretKey contentEncryptionKey = keyManagementAlgorithm.produceEncryptionKey(algorithmKey); // 1&#xA;&#xA;byte[] ciphertext = encryptionAlgorithm.encrypt(payload, contentEncryptionKey);             // 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;algorithmKey&lt;/code&gt; to produce the actual key that will be used to encrypt the payload. The JWT specifications call this result the &#39;Content Encryption Key&#39;.&lt;/li&gt; &#xA; &lt;li&gt;Take the resulting Content Encryption Key and use it directly with the Authenticated Encryption algorithm to actually encrypt the JWT &lt;code&gt;payload&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;So why the indirection? Why not just use any &lt;code&gt;PublicKey&lt;/code&gt;, &lt;code&gt;SecretKey&lt;/code&gt; or &lt;code&gt;Password&lt;/code&gt; to encrypt the &lt;code&gt;payload&lt;/code&gt; &lt;em&gt;directly&lt;/em&gt; ?&lt;/p&gt; &#xA;&lt;p&gt;There are quite a few reasons for this.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Asymmetric key encryption (like RSA and Elliptic Curve) tends to be slow. Like &lt;em&gt;really&lt;/em&gt; slow. Symmetric key cipher algorithms in contrast are &lt;em&gt;really fast&lt;/em&gt;. This matters a lot in production applications that could be handling a JWT on every HTTP request, which could be thousands per second.&lt;/li&gt; &#xA; &lt;li&gt;RSA encryption (for example) can only encrypt a relatively small amount of data. A 2048-bit RSA key can only encrypt up to a maximum of 245 bytes. A 4096-bit RSA key can only encrypt up to a maximum of 501 bytes. There are plenty of JWTs that can exceed 245 bytes, and that would make RSA unusable.&lt;/li&gt; &#xA; &lt;li&gt;Passwords usually make for very poor encryption keys - they often have poor entropy, or they themselves are often too short to be used directly with algorithms that mandate minimum key lengths to help ensure safety.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For these reasons and more, using one secure algorithm to generate or encrypt a key used for another (very fast) secure algorithm has been proven to be a great way to increase security through many more secure algorithms while also still resulting in very fast and secure output. This is after all how TLS (for https encryption) works - two parties can use more complex cryptography (like RSA or Elliptic Curve) to negotiate a small, fast encryption key. This fast encryption key is produced during the &#39;TLS handshake&#39; and is called the TLS &#39;session key&#39;.&lt;/p&gt; &#xA;&lt;p&gt;So the JWT specifications work much in the same way: one key from any number of various algorithm types can be used to produce a final symmetric key, and that symmetric key is used to encrypt the JWT &lt;code&gt;payload&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-alg-standard&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;JWE Standard Key Management Algorithms&lt;/h4&gt; &#xA;&lt;p&gt;The JWT specification defines 17 standard Key Management Algorithms used to produce the JWE Content Encryption Key (CEK):&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Identifier&lt;/th&gt; &#xA;   &lt;th&gt;Key Management Algorithm&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;RSA1_5&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RSAES-PKCS1-v1_5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;RSA-OAEP&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RSAES OAEP using default parameters&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;RSA-OAEP-256&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RSAES OAEP using SHA-256 and MGF1 with SHA-256&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A128KW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;AES Key Wrap with default initial value using 128-bit key&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A192KW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;AES Key Wrap with default initial value using 192-bit key&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A256KW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;AES Key Wrap with default initial value using 256-bit key&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Direct use of a shared symmetric key as the Content Encryption Key&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ECDH-ES&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ECDH-ES+A128KW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ECDH-ES using Concat KDF and CEK wrapped with &#34;A128KW&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ECDH-ES+A192KW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ECDH-ES using Concat KDF and CEK wrapped with &#34;A192KW&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ECDH-ES+A256KW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ECDH-ES using Concat KDF and CEK wrapped with &#34;A256KW&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A128GCMKW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Key wrapping with AES GCM using 128-bit key&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A192GCMKW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Key wrapping with AES GCM using 192-bit key&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;A256GCMKW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Key wrapping with AES GCM using 256-bit key&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PBES2-HS256+A128KW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;PBES2 with HMAC SHA-256 and &#34;A128KW&#34; wrapping&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PBES2-HS384+A192KW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;PBES2 with HMAC SHA-384 and &#34;A192KW&#34; wrapping&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PBES2‑HS512+A256KW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;PBES2 with HMAC SHA-512 and &#34;A256KW&#34; wrapping&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;&lt;/sup&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sup&gt;&lt;b&gt;3&lt;/b&gt;. Requires Java 8 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/sup&gt;&lt;/p&gt; &#xA;&lt;p&gt;These are all represented as constants in the &lt;code&gt;io.jsonwebtoken.Jwts.KEY&lt;/code&gt; registry singleton as implementations of the &lt;code&gt;io.jsonwebtoken.security.KeyAlgorithm&lt;/code&gt; interface.&lt;/p&gt; &#xA;&lt;p&gt;But 17 algorithms are a lot to choose from. When would you use them? The sections below describe when you might choose each category of algorithms and how they behave.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-alg-rsa&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;RSA Key Encryption&lt;/h5&gt; &#xA;&lt;p&gt;The JWT RSA key management algorithms &lt;code&gt;RSA1_5&lt;/code&gt;, &lt;code&gt;RSA-OAEP&lt;/code&gt;, and &lt;code&gt;RSA-OAEP-256&lt;/code&gt; are used when you want to use the JWE recipient&#39;s RSA &lt;em&gt;public&lt;/em&gt; key during encryption. This ensures that only the JWE recipient can decrypt and read the JWE (using their RSA &lt;code&gt;private&lt;/code&gt; key).&lt;/p&gt; &#xA;&lt;p&gt;During JWE creation, these algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Generate a new secure-random Content Encryption Key (CEK) suitable for the desired &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;encryption algorithm&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Encrypt the JWE payload with the desired encryption algorithm using the new CEK, producing the JWE payload ciphertext.&lt;/li&gt; &#xA; &lt;li&gt;Encrypt the CEK itself with the specified RSA key wrap algorithm using the JWE recipient&#39;s RSA public key.&lt;/li&gt; &#xA; &lt;li&gt;Embed the payload ciphertext and encrypted CEK in the resulting JWE.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;During JWE decryption, these algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Retrieve the encrypted Content Encryption Key (CEK) embedded in the JWE.&lt;/li&gt; &#xA; &lt;li&gt;Decrypt the encrypted CEK with the discovered RSA key unwrap algorithm using the JWE recipient&#39;s RSA private key, producing the decrypted Content Encryption Key (CEK).&lt;/li&gt; &#xA; &lt;li&gt;Decrypt the JWE ciphertext payload with the JWE&#39;s identified &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;encryption algorithm&lt;/a&gt; using the decrypted CEK.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;RFC 7518 Sections &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.2&#34;&gt;4.2&lt;/a&gt; and &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.3&#34;&gt;4.3&lt;/a&gt; &lt;em&gt;require&lt;/em&gt; (mandate) that RSA keys &amp;gt;= 2048 bits MUST be used with these algorithms. JJWT will throw an exception if it detects weaker keys being used.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-alg-aes&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;AES Key Encryption&lt;/h5&gt; &#xA;&lt;p&gt;The JWT AES key management algorithms &lt;code&gt;A128KW&lt;/code&gt;, &lt;code&gt;A192KW&lt;/code&gt;, &lt;code&gt;A256KW&lt;/code&gt;, &lt;code&gt;A128GCMKW&lt;/code&gt;, &lt;code&gt;A192GCMKW&lt;/code&gt;, and &lt;code&gt;A256GCMKW&lt;/code&gt; are used when you have a symmetric secret key, but you don&#39;t want to use that secret key to directly encrypt/decrypt the JWT.&lt;/p&gt; &#xA;&lt;p&gt;Instead, a new secure-random key is generated each time a JWE is created, and that new/random key is used to directly encrypt/decrypt the JWT payload. The secure-random key is itself encrypted with your symmetric secret key using the AES Wrap algorithm, and the encrypted key is embedded in the resulting JWE.&lt;/p&gt; &#xA;&lt;p&gt;This allows the JWE to be encrypted with a random short-lived key, reducing material exposure of the potentially longer-lived symmetric secret key.&lt;/p&gt; &#xA;&lt;p&gt;Because these particular algorithms use a symmetric secret key, they are best suited when the JWE creator and receiver are the same, ensuring the secret key does not need to be shared with multiple parties.&lt;/p&gt; &#xA;&lt;p&gt;During JWE creation, these algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Generate a new secure-random Content Encryption Key (CEK) suitable for the desired &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;encryption algorithm&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Encrypt the JWE payload with the desired encryption algorithm using the new CEK, producing the JWE payload ciphertext.&lt;/li&gt; &#xA; &lt;li&gt;Encrypt the CEK itself with the specified AES key algorithm (either AES Key Wrap or AES with GCM encryption), producing the encrypted CEK.&lt;/li&gt; &#xA; &lt;li&gt;Embed the payload ciphertext and encrypted CEK in the resulting JWE.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;During JWE decryption, these algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Retrieve the encrypted Content Encryption Key (CEK) embedded in the JWE.&lt;/li&gt; &#xA; &lt;li&gt;Decrypt the encrypted CEK with the discovered AES key algorithm using the symmetric secret key.&lt;/li&gt; &#xA; &lt;li&gt;Decrypt the JWE ciphertext payload with the JWE&#39;s identified &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;encryption algorithm&lt;/a&gt; using the decrypted CEK.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;The symmetric key used for the AES key algorithms MUST be 128, 192 or 256 bits as required by the specific AES key algorithm. JJWT will throw an exception if it detects weaker keys than what is required.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-alg-dir&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Direct Key Encryption&lt;/h5&gt; &#xA;&lt;p&gt;The JWT &lt;code&gt;dir&lt;/code&gt; (direct) key management algorithm is used when you have a symmetric secret key, and you want to use it to directly encrypt the JWT payload.&lt;/p&gt; &#xA;&lt;p&gt;Because this algorithm uses a symmetric secret key, it is best suited when the JWE creator and receiver are the same, ensuring the secret key does not need to be shared with multiple parties.&lt;/p&gt; &#xA;&lt;p&gt;This is the simplest key algorithm for direct encryption that does not perform any key encryption. It is essentially a &#39;no op&#39; key algorithm, allowing the shared key to be used to directly encrypt the JWT payload.&lt;/p&gt; &#xA;&lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Encrypts the JWE payload with the desired encryption algorithm directly using the symmetric secret key, producing the JWE payload ciphertext.&lt;/li&gt; &#xA; &lt;li&gt;Embeds the payload ciphertext in the resulting JWE.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that because this algorithm does not produce an encrypted key value, an encrypted CEK is &lt;em&gt;not&lt;/em&gt; embedded in the resulting JWE.&lt;/p&gt; &#xA;&lt;p&gt;During JWE decryption, this algorithm decrypts the JWE ciphertext payload with the JWE&#39;s identified &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;encryption algorithm&lt;/a&gt; directly using the symmetric secret key. No encrypted CEK is used.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;The symmetric secret key MUST be 128, 192 or 256 bits as required by the associated &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;AEAD encryption algorithm&lt;/a&gt; used to encrypt the payload. JJWT will throw an exception if it detects weaker keys than what is required.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-alg-pbes2&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Password-Based Key Encryption&lt;/h5&gt; &#xA;&lt;p&gt;The JWT password-based key encryption algorithms &lt;code&gt;PBES2-HS256+A128KW&lt;/code&gt;, &lt;code&gt;PBES2-HS384+A192KW&lt;/code&gt;, and &lt;code&gt;PBES2-HS512+A256KW&lt;/code&gt; are used when you want to use a password (character array) to encrypt and decrypt a JWT.&lt;/p&gt; &#xA;&lt;p&gt;However, because passwords are usually too weak or problematic to use directly in cryptographic contexts, these algorithms utilize key derivation techniques with work factors (e.g. computation iterations) and secure-random salts to produce stronger cryptographic keys suitable for cryptographic operations.&lt;/p&gt; &#xA;&lt;p&gt;This allows the payload to be encrypted with a random short-lived cryptographically-stronger key, reducing the need to expose the longer-lived (and potentially weaker) password.&lt;/p&gt; &#xA;&lt;p&gt;Because these algorithms use a secret password, they are best suited when the JWE creator and receiver are the same, ensuring the secret password does not need to be shared with multiple parties.&lt;/p&gt; &#xA;&lt;p&gt;During JWE creation, these algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Generate a new secure-random Content Encryption Key (CEK) suitable for the desired &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;encryption algorithm&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Encrypt the JWE payload with the desired encryption algorithm using the new CEK, producing the JWE payload ciphertext.&lt;/li&gt; &#xA; &lt;li&gt;Derive a &#39;key encryption key&#39; (KEK) with the desired &#34;PBES2 with HMAC SHA&#34; algorithm using the password, a suitable number of computational iterations, and a secure-random salt value.&lt;/li&gt; &#xA; &lt;li&gt;Encrypt the generated CEK with the corresponding AES Key Wrap algorithm using the password-derived KEK.&lt;/li&gt; &#xA; &lt;li&gt;Embed the payload ciphertext and encrypted CEK in the resulting JWE.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Secure defaults&lt;/strong&gt;: When using these algorithms, if you do not specify a work factor (i.e. number of computational iterations), JJWT will automatically use an &lt;a href=&#34;https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2&#34;&gt;OWASP PBKDF2 recommended&lt;/a&gt; default appropriate for the specified &lt;code&gt;PBES2&lt;/code&gt; algorithm.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;During JWE decryption, these algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Retrieve the encrypted Content Encryption Key (CEK) embedded in the JWE.&lt;/li&gt; &#xA; &lt;li&gt;Derive the &#39;key encryption key&#39; (KEK) with the discovered &#34;PBES2 with HMAC SHA&#34; algorithm using the password and the number of computational iterations and secure-random salt value discovered in the JWE header.&lt;/li&gt; &#xA; &lt;li&gt;Decrypt the encrypted CEK with the corresponding AES Key Unwrap algorithm using the password-derived KEK.&lt;/li&gt; &#xA; &lt;li&gt;Decrypt the JWE ciphertext payload with the JWE&#39;s identified &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;encryption algorithm&lt;/a&gt; using the decrypted CEK.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-alg-ecdhes&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Elliptic Curve Diffie-Hellman Ephemeral Static Key Agreement&lt;/h5&gt; &#xA;&lt;p&gt;The JWT Elliptic Curve Diffie-Hellman Ephemeral Static key agreement algorithms &lt;code&gt;ECDH-ES&lt;/code&gt;, &lt;code&gt;ECDH-ES+A128KW&lt;/code&gt;, &lt;code&gt;ECDH-ES+A192KW&lt;/code&gt;, and &lt;code&gt;ECDH-ES+A256KW&lt;/code&gt; are used when you want to use the JWE recipient&#39;s Elliptic Curve &lt;em&gt;public&lt;/em&gt; key during encryption. This ensures that only the JWE recipient can decrypt and read the JWE (using their Elliptic Curve &lt;em&gt;private&lt;/em&gt; key).&lt;/p&gt; &#xA;&lt;p&gt;During JWE creation, these algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Obtain the Content Encryption Key (CEK) used to encrypt the JWE payload as follows: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Inspect the JWE recipient&#39;s Elliptic Curve public key and determine its Curve.&lt;/li&gt; &#xA;   &lt;li&gt;Generate a new secure-random ephemeral Ellipic Curve public/private key pair on this same Curve.&lt;/li&gt; &#xA;   &lt;li&gt;Add the ephemeral EC public key to the JWE &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1&#34;&gt;epk header&lt;/a&gt; for inclusion in the final JWE.&lt;/li&gt; &#xA;   &lt;li&gt;Produce an ECDH shared secret with the ECDH Key Agreement algorithm using the JWE recipient&#39;s EC public key and the ephemeral EC private key.&lt;/li&gt; &#xA;   &lt;li&gt;Derive a symmetric secret key with the Concat Key Derivation Function (&lt;a href=&#34;https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf&#34;&gt;NIST.800-56A&lt;/a&gt;, Section 5.8.1) using this ECDH shared secret and any provided &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.2&#34;&gt;PartyUInfo&lt;/a&gt; and/or &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.3&#34;&gt;PartyVInfo&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;If the key algorithm is &lt;code&gt;ECDH-ES&lt;/code&gt;: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Use the Concat KDF-derived symmetric secret key directly as the Content Encryption Key (CEK). No encrypted key is created, nor embedded in the resulting JWE.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Otherwise, if the key algorithm is &lt;code&gt;ECDH-ES+A128KW&lt;/code&gt;, &lt;code&gt;ECDH-ES+A192KW&lt;/code&gt;, or &lt;code&gt;ECDH-ES+A256KW&lt;/code&gt;: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Generate a new secure-random Content Encryption Key (CEK) suitable for the desired &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;encryption algorithm&lt;/a&gt;.&lt;/li&gt; &#xA;     &lt;li&gt;Encrypt this new CEK with the corresponding AES Key Wrap algorithm using the Concat KDF-derived secret key, producing the encrypted CEK.&lt;/li&gt; &#xA;     &lt;li&gt;Embed the encrypted CEK in the resulting JWE.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Encrypt the JWE payload with the desired encryption algorithm using the obtained CEK, producing the JWE payload ciphertext.&lt;/li&gt; &#xA; &lt;li&gt;Embed the payload ciphertext in the resulting JWE.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;During JWE decryption, these algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Obtain the Content Encryption Key (CEK) used to decrypt the JWE payload as follows: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Retrieve the required ephemeral Elliptic Curve public key from the JWE&#39;s &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1&#34;&gt;epk header&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Ensure the ephemeral EC public key exists on the same curve as the JWE recipient&#39;s EC private key.&lt;/li&gt; &#xA;   &lt;li&gt;Produce the ECDH shared secret with the ECDH Key Agreement algorithm using the JWE recipient&#39;s EC private key and the ephemeral EC public key.&lt;/li&gt; &#xA;   &lt;li&gt;Derive a symmetric secret key with the Concat Key Derivation Function (&lt;a href=&#34;https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf&#34;&gt;NIST.800-56A&lt;/a&gt;, Section 5.8.1) using this ECDH shared secret and any &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.2&#34;&gt;PartyUInfo&lt;/a&gt; and/or &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.3&#34;&gt;PartyVInfo&lt;/a&gt; found in the JWE header.&lt;/li&gt; &#xA;   &lt;li&gt;If the key algorithm is &lt;code&gt;ECDH-ES&lt;/code&gt;: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Use the Concat KDF-derived secret key directly as the Content Encryption Key (CEK). No encrypted key is used.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Otherwise, if the key algorithm is &lt;code&gt;ECDH-ES+A128KW&lt;/code&gt;, &lt;code&gt;ECDH-ES+A192KW&lt;/code&gt;, or &lt;code&gt;ECDH-ES+A256KW&lt;/code&gt;: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Obtain the encrypted key ciphertext embedded in the JWE.&lt;/li&gt; &#xA;     &lt;li&gt;Decrypt the encrypted key ciphertext with the associated AES Key Unwrap algorithm using the Concat KDF-derived secret key, producing the unencrypted Content Encryption Key (CEK).&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Decrypt the JWE payload ciphertext with the JWE&#39;s discovered encryption algorithm using the obtained CEK.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-create&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Creating a JWE&lt;/h3&gt; &#xA;&lt;p&gt;Now that we know the difference between a JWE Encryption Algorithm and a JWE Key Management Algorithm, how do we use them to encrypt a JWT?&lt;/p&gt; &#xA;&lt;p&gt;You create an encrypted JWT (called a &#39;JWE&#39;) as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;Jwts.builder()&lt;/code&gt; method to create a &lt;code&gt;JwtBuilder&lt;/code&gt; instance.&lt;/li&gt; &#xA; &lt;li&gt;Call &lt;code&gt;JwtBuilder&lt;/code&gt; methods to set the &lt;code&gt;payload&lt;/code&gt; content or claims and any &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-create-header&#34;&gt;header&lt;/a&gt; parameters as desired.&lt;/li&gt; &#xA; &lt;li&gt;Call the &lt;code&gt;encryptWith&lt;/code&gt; method, specifying the Key, Key Algorithm, and Encryption Algorithm you want to use.&lt;/li&gt; &#xA; &lt;li&gt;Finally, call the &lt;code&gt;compact()&lt;/code&gt; method to compact and encrypt, producing the final jwe.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String jwe = Jwts.builder()                              // (1)&#xA;&#xA;    .subject(&#34;Bob&#34;)                                      // (2) &#xA;&#xA;    .encryptWith(key, keyAlgorithm, encryptionAlgorithm) // (3)&#xA;     &#xA;    .compact();                                          // (4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Before calling &lt;code&gt;compact()&lt;/code&gt;, you may set any &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-create-header&#34;&gt;header&lt;/a&gt; parameters and &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-create-claims&#34;&gt;claims&lt;/a&gt; exactly the same way as described for JWS.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-compression&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;JWE Compression&lt;/h4&gt; &#xA;&lt;p&gt;If your JWT payload or Claims set is large (contains a lot of data), you might want to compress the JWE to reduce its size. Please see the main &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#compression&#34;&gt;Compression&lt;/a&gt; section to see how to compress and decompress JWTs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-read&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Reading a JWE&lt;/h3&gt; &#xA;&lt;p&gt;You read (parse) a JWE as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;Jwts.parser()&lt;/code&gt; method to create a &lt;code&gt;JwtParserBuilder&lt;/code&gt; instance.&lt;/li&gt; &#xA; &lt;li&gt;Call either &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#key-locator&#34;&gt;keyLocator&lt;/a&gt; or &lt;code&gt;decryptWith&lt;/code&gt; methods to determine the key used to decrypt the JWE.&lt;/li&gt; &#xA; &lt;li&gt;Call the &lt;code&gt;JwtParserBuilder&lt;/code&gt;&#39;s &lt;code&gt;build()&lt;/code&gt; method to create a thread-safe &lt;code&gt;JwtParser&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Parse the jwe string with the &lt;code&gt;JwtParser&lt;/code&gt;&#39;s &lt;code&gt;parseClaimsJwe&lt;/code&gt; or &lt;code&gt;parseContentJwe&lt;/code&gt; method.&lt;/li&gt; &#xA; &lt;li&gt;Wrap the entire call is in a try/catch block in case decryption or integrity verification fails.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwe&amp;lt;Claims&amp;gt; jwe;&#xA;&#xA;try {&#xA;    jwe = Jwts.parser()         // (1)&#xA;&#xA;    .keyLocator(keyLocator)     // (2) dynamically lookup decryption keys based on each JWE    &#xA;    //.decryptWith(key)         //     or a static key used to decrypt all encountered JWEs&#xA;        &#xA;    .build()                    // (3)&#xA;    .parseClaimsJwe(jweString); // (4) or parseContentJwe(jweString);&#xA;    &#xA;    // we can safely trust the JWT&#xA;     &#xA;catch (JwtException ex) {       // (5)&#xA;    &#xA;    // we *cannot* use the JWT as intended by its creator&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Type-safe JWEs:&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;If you are expecting a JWE with a Claims &lt;code&gt;payload&lt;/code&gt;, call the &lt;code&gt;JwtParser&lt;/code&gt;&#39;s &lt;code&gt;parseClaimsJwe&lt;/code&gt; method.&lt;/li&gt; &#xA;  &lt;li&gt;If you are expecting a JWE with a content &lt;code&gt;payload&lt;/code&gt;, call the &lt;code&gt;JwtParser&lt;/code&gt;&#39;s &lt;code&gt;parseContentJwe&lt;/code&gt; method.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-read-key&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Decryption Key&lt;/h4&gt; &#xA;&lt;p&gt;The most important thing to do when reading a JWE is to specify the key used during decryption. If decryption or integrity protection checks fail, the JWT cannot be safely trusted and should be discarded.&lt;/p&gt; &#xA;&lt;p&gt;So which key do we use for decryption?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If the jwe was encrypted &lt;em&gt;directly&lt;/em&gt; with a &lt;code&gt;SecretKey&lt;/code&gt;, the same &lt;code&gt;SecretKey&lt;/code&gt; must be specified on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.parser()&#xA;    &#xA;  .decryptWith(secretKey) // &amp;lt;----&#xA;  &#xA;  .build()&#xA;  .parseClaimsJws(jwsString);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If the jwe was encrypted using a key produced by a Password-based key derivation &lt;code&gt;KeyAlgorithm&lt;/code&gt;, the same &lt;code&gt;Password&lt;/code&gt; must be specified on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.parser()&#xA;    &#xA;  .decryptWith(password) // &amp;lt;---- an `io.jsonwebtoken.security.Password` instance&#xA;  &#xA;  .build()&#xA;  .parseClaimsJws(jwsString);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If the jwe was encrypted with a key produced by an asymmetric &lt;code&gt;KeyAlgorithm&lt;/code&gt;, the corresponding &lt;code&gt;PrivateKey&lt;/code&gt; (not the &lt;code&gt;PublicKey&lt;/code&gt;) must be specified on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;. For example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.parser()&#xA;    &#xA;  .decryptWith(privateKey) // &amp;lt;---- a `PrivateKey`, not a `PublicKey`&#xA;  &#xA;  .build()&#xA;  .parseClaimsJws(jwsString);&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-key-locator&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Decryption Key Locator&lt;/h4&gt; &#xA;&lt;p&gt;What if your application doesn&#39;t use just a single &lt;code&gt;SecretKey&lt;/code&gt; or &lt;code&gt;KeyPair&lt;/code&gt;? What if JWEs can be created with different &lt;code&gt;SecretKey&lt;/code&gt;s, &lt;code&gt;Password&lt;/code&gt;s or public/private keys, or a combination of all of them? How do you know which key to specify if you can&#39;t inspect the JWT first?&lt;/p&gt; &#xA;&lt;p&gt;In these cases, you can&#39;t call the &lt;code&gt;JwtParserBuilder&lt;/code&gt;&#39;s &lt;code&gt;decryptWith&lt;/code&gt; method with a single key - instead, you&#39;ll need to use a Key &lt;code&gt;Locator&lt;/code&gt;. Please see the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#key-locator&#34;&gt;Key Lookup&lt;/a&gt; section to see how to dynamically obtain different keys when parsing JWSs or JWEs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwe-read-decompression&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;JWE Decompression&lt;/h4&gt; &#xA;&lt;p&gt;If a JWE is compressed using the &lt;code&gt;DEF&lt;/code&gt; (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc1951&#34;&gt;DEFLATE&lt;/a&gt;) or &lt;code&gt;GZIP&lt;/code&gt; (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc1952.html&#34;&gt;GZIP&lt;/a&gt;) compression algorithms, it will automatically be decompressed after decryption, and there is nothing you need to configure.&lt;/p&gt; &#xA;&lt;p&gt;If, however, a custom compression algorithm was used to compress the JWE, you will need to tell the &lt;code&gt;JwtParserBuilder&lt;/code&gt; how to resolve your &lt;code&gt;CompressionAlgorithm&lt;/code&gt; to decompress the JWT.&lt;/p&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#compression&#34;&gt;Compression&lt;/a&gt; section below to see how to decompress JWTs during parsing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;JSON Web Keys (JWKs)&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7517.html&#34;&gt;JSON Web Keys&lt;/a&gt; (JWKs) are JSON serializations of cryptographic keys, allowing key material to be embedded in JWTs or transmitted between parties in a standard JSON-based text format. They are essentially a JSON-based alternative to other text-based key formats, such as the &lt;a href=&#34;https://serverfault.com/a/9717&#34;&gt;DER, PEM and PKCS12&lt;/a&gt; text strings or files commonly used when configuring TLS on web servers, for example.&lt;/p&gt; &#xA;&lt;p&gt;For example, an identity web service may expose its RSA or Elliptic Curve Public Keys to 3rd parties in the JWK format. A client may then parse the public key JWKs to verify the service&#39;s &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws&#34;&gt;JWS&lt;/a&gt; tokens, as well as send encrypted information to the service using &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe&#34;&gt;JWE&lt;/a&gt;s.&lt;/p&gt; &#xA;&lt;p&gt;JWKs can be converted to and from standard Java &lt;code&gt;Key&lt;/code&gt; types as expected using the same builder/parser patterns we&#39;ve seen for JWTs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-create&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Create a JWK&lt;/h3&gt; &#xA;&lt;p&gt;You create a JWK as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;Jwks.builder()&lt;/code&gt; method to create a &lt;code&gt;JwkBuilder&lt;/code&gt; instance.&lt;/li&gt; &#xA; &lt;li&gt;Call the &lt;code&gt;key&lt;/code&gt; method with the Java key you wish to represent as a JWK.&lt;/li&gt; &#xA; &lt;li&gt;Call builder methods to set any additional key fields or metadata, such as a &lt;code&gt;kid&lt;/code&gt; (Key ID), X509 Certificates, etc as desired.&lt;/li&gt; &#xA; &lt;li&gt;Call the &lt;code&gt;build()&lt;/code&gt; method to produce the resulting JWK.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SecretKey key = getSecretKey();     // or RSA or EC PublicKey or PrivateKey&#xA;SecretJwk = Jwks.builder().key(key) // (1) and (2)&#xA;        &#xA;    .id(&#34;mySecretKeyId&#34;)            // (3)&#xA;    // ... etc ...    &#xA;    &#xA;    .build();                       // (4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;JWK from a Map&lt;/h4&gt; &#xA;&lt;p&gt;If you have a &lt;code&gt;Map&amp;lt;String,?&amp;gt;&lt;/code&gt; of name/value pairs that reflect an existing JWK, you add them and build a type-safe &lt;code&gt;Jwk&lt;/code&gt; instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String,?&amp;gt; jwkValues = getMyJwkMap();&#xA;&#xA;Jwk&amp;lt;?&amp;gt; jwk = Jwks.builder().add(jwkValues).build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-read&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Read a JWK&lt;/h3&gt; &#xA;&lt;p&gt;You can read/parse a JWK by building a &lt;code&gt;JwkParser&lt;/code&gt; and parsing the JWK JSON string with its &lt;code&gt;parse&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String json = getJwkJsonString();&#xA;Jwk&amp;lt;?&amp;gt; jwk = Jwks.parser()&#xA;    //.provider(aJcaProvider)     // optional&#xA;    //.deserializer(deserializer) // optional&#xA;    .build()                      // create the parser&#xA;    .parse(json);                 // actually parse the JSON&#xA;&#xA;Key key = jwk.toKey();            // convert to a Java Key instance&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As shown above you can specify a custom JCA Provider or &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#json&#34;&gt;JSON deserializer&lt;/a&gt; in the same way as the &lt;code&gt;JwtBuilder&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-private&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;PrivateKey JWKs&lt;/h3&gt; &#xA;&lt;p&gt;Unlike Java, the JWA specification requires a private JWKs to contain &lt;em&gt;both&lt;/em&gt; public key &lt;em&gt;and&lt;/em&gt; private key material (see &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-6.2.2&#34;&gt;RFC 7518, Section 6.1.1&lt;/a&gt; and &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-6.3.2&#34;&gt;RFC 7518, Section 6.3.2&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;In this sense, a private JWK (represented as a &lt;code&gt;PrivateJwk&lt;/code&gt; or a subtype, such as &lt;code&gt;RsaPrivateJwk&lt;/code&gt;, &lt;code&gt;EcPrivateJwk&lt;/code&gt;, etc) can be thought of more like a Java &lt;code&gt;KeyPair&lt;/code&gt; instance. Consequently, when creating a &lt;code&gt;PrivateJwk&lt;/code&gt; instance, the &lt;code&gt;PrivateKey&lt;/code&gt;&#39;s corresponding &lt;code&gt;PublicKey&lt;/code&gt; is required.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-private-public&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Private JWK &lt;code&gt;PublicKey&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;If you do not provide a &lt;code&gt;PublicKey&lt;/code&gt; when creating a &lt;code&gt;PrivateJwk&lt;/code&gt;, JJWT will automatically derive the &lt;code&gt;PublicKey&lt;/code&gt; from the &lt;code&gt;PrivateKey&lt;/code&gt; instance if possible. However, because this can add some computing time, it is typically recommended to provide the &lt;code&gt;PublicKey&lt;/code&gt; when possible to avoid this extra work.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RSAPrivateKey rsaPrivateKey = getRSAPrivateKey(); // or ECPrivateKey&#xA;&#xA;RsaPrivateJwk jwk = Jwks.builder().key(rsaPrivateKey)&#xA;&#xA;        //.publicKey(rsaPublicKey)  // optional, but recommended to avoid extra computation work&#xA;        &#xA;        .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-private-keypair&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Private JWK from KeyPair&lt;/h4&gt; &#xA;&lt;p&gt;If you have a Java &lt;code&gt;KeyPair&lt;/code&gt; instance, then you have both the public and private key material necessary to create a &lt;code&gt;PrivateJwk&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;KeyPair rsaKeyPair = getRSAKeyPair();&#xA;RsaPrivateJwk rsaPrivJwk = Jwks.builder().rsaKeyPair(rsaKeyPair).build();&#xA;&#xA;KeyPair ecKeyPair = getECKeyPair();&#xA;EcPrivateJwk ecPrivJwk = Jwks.builder().ecKeyPair(ecKeyPair).build();&#xA;&#xA;KeyPair edEcKeyPair = getEdECKeyPair();&#xA;OctetPrivateJwk edEcPrivJwk = Jwks.builder().octetKeyPair(edEcKeyPair).build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An exception will thrown when calling &lt;code&gt;rsaKeyPair&lt;/code&gt; if the specified &lt;code&gt;KeyPair&lt;/code&gt; instance does not contain &lt;code&gt;RSAPublicKey&lt;/code&gt; and &lt;code&gt;RSAPrivateKey&lt;/code&gt; instances.&lt;/li&gt; &#xA; &lt;li&gt;Similarly, an exception will be thrown when calling &lt;code&gt;ecKeyPair&lt;/code&gt; if the &lt;code&gt;KeyPair&lt;/code&gt; instance does not contain &lt;code&gt;ECPublicKey&lt;/code&gt; and &lt;code&gt;ECPrivateKey&lt;/code&gt; instances.&lt;/li&gt; &#xA; &lt;li&gt;Finally, an exception will be thrown when calling &lt;code&gt;octetKeyPair&lt;/code&gt; if the &lt;code&gt;KeyPair&lt;/code&gt; instance does not contain X25519, X448, Ed25519, or Ed448 keys (introduced in JDK 11 and 15 or when using BouncyCastle).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-private-topub&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Private JWK Public Conversion&lt;/h4&gt; &#xA;&lt;p&gt;Because private JWKs contain public key material, you can always obtain the private JWK&#39;s corresponding public JWK and Java &lt;code&gt;PublicKey&lt;/code&gt; or &lt;code&gt;KeyPair&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RsaPrivateJwk privateJwk = Jwks.builder().key(rsaPrivateKey).build(); // or ecPrivateKey or edEcPrivateKey&#xA;&#xA;// Get the matching public JWK and/or PublicKey:&#xA;RsaPublicJwk pubJwk = privateJwk.toPublicJwk();       // JWK instance&#xA;RSAPublicKey pubKey = pubJwk.toKey();                 // Java PublicKey instance&#xA;KeyPair pair = privateJwk.toKeyPair();                // io.jsonwebtoken.security.KeyPair retains key types&#xA;java.security.KeyPair jdkPair = pair.toJavaKeyPair(); // does not retain pub/private key types&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-thumbprint&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWK Thumbprints&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7638.html&#34;&gt;JWK Thumbprint&lt;/a&gt; is a digest (aka hash) of a canonical JSON representation of a JWK&#39;s public properties. &#39;Canonical&#39; in this case means that only RFC-specified values in any JWK are used in an exact order thumbprint calculation. This ensures that anyone can calculate a JWK&#39;s same exact thumbprint, regardless of custom fields or JSON key/value ordering differences in a JWK.&lt;/p&gt; &#xA;&lt;p&gt;All &lt;code&gt;Jwk&lt;/code&gt; instances support &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7638.html&#34;&gt;JWK Thumbprint&lt;/a&gt;s via the &lt;code&gt;thumbprint()&lt;/code&gt; and &lt;code&gt;thumbprint(HashAlgorithm)&lt;/code&gt; methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;HashAlgorithm hashAlg = Jwks.HASH.SHA256; // or SHA384, SHA512, etc.&#xA;&#xA;Jwk&amp;lt;?&amp;gt; jwk = Jwks.builder(). /* ... */ .build();&#xA;&#xA;JwkThumbprint sha256Thumbprint = jwk.thumbprint(); // SHA-256 thumbprint by default&#xA;&#xA;JwkThumbprint anotherThumbprint = jwk.thumbprint(Jwks.HASH.SHA512); // or a specified hash algorithm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting &lt;code&gt;JwkThumbprint&lt;/code&gt; instance provides some useful methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;jwkThumbprint.toByteArray()&lt;/code&gt;: the thumbprint&#39;s actual digest bytes - i.e. the raw output from the hash algorithm&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;jwkThumbprint.toString()&lt;/code&gt;: the digest bytes as a Base64URL-encoded string&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;jwkThumbprint.getHashAlgorithm()&lt;/code&gt;: the specific &lt;code&gt;HashAlgorithm&lt;/code&gt; used to compute the thumbprint. Many standard IANA hash algorithms are available as constants in the &lt;code&gt;Jwts.HASH&lt;/code&gt; utility class.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;jwkThumbprint.toURI()&lt;/code&gt;: the thumbprint&#39;s canonical URI as defined by the &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc9278.html&#34;&gt;JWK Thumbprint URI&lt;/a&gt; specification&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-thumbprint-kid&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;JWK Thumbprint as a Key ID&lt;/h4&gt; &#xA;&lt;p&gt;Because a thumbprint is an order-guaranteed unique digest of a JWK, JWK thumbprints are often used as convenient unique identifiers for a JWK (e.g. the JWK&#39;s &lt;code&gt;kid&lt;/code&gt; (Key ID) value). These identifiers can be useful when &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#key-locator&#34;&gt;locating keys&lt;/a&gt; for JWS signature verification or JWE decryption, for example.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String kid = jwk.thumbprint().toString(); // Thumbprint bytes as a Base64URL-encoded string&#xA;Key key = findKey(kid);&#xA;assert jwk.toKey().equals(key);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, because &lt;code&gt;Jwk&lt;/code&gt; instances are immutable, you can&#39;t set the key id after the JWK is created. For example, the following is not possible:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String kid = jwk.thumbprint().toString();&#xA;jwk.setId(kid) // Jwks are immutable - there is no `setId` method&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead, you may use the &lt;code&gt;idFromThumbprint&lt;/code&gt; methods on the &lt;code&gt;JwkBuilder&lt;/code&gt; when creating a &lt;code&gt;Jwk&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwk&amp;lt;?&amp;gt; jwk = Jwks.builder().key(aKey)&#xA;&#xA;    .idFromThumbprint() // or idFromThumbprint(HashAlgorithm)&#xA;&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Calling either &lt;code&gt;idFromThumbprint&lt;/code&gt; method will ensure that calling &lt;code&gt;jwk.getId()&lt;/code&gt; equals &lt;code&gt;thumbprint.toString()&lt;/code&gt; (which is &lt;code&gt;Encoders.BASE64URL.encode(thumbprint.toByteArray())&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-thumbprint-uri&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;JWK Thumbprint URI&lt;/h4&gt; &#xA;&lt;p&gt;A JWK&#39;s thumbprint&#39;s canonical URI as defined by the &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc9278.html&#34;&gt;JWK Thumbprint URI&lt;/a&gt; specification may be obtained by calling the thumbprint&#39;s &lt;code&gt;toURI()&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;URI canonicalThumbprintURI = jwk.thumbprint().toURI();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Per the RFC specification, if you call &lt;code&gt;canonicalThumbprintURI.toString()&lt;/code&gt;, you would see a string that looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;urn:ietf:params:oauth:jwk-thumbprint:HASH_ALG_ID:BASE64URL_DIGEST&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;urn:ietf:params:oauth:jwk-thumbprint:&lt;/code&gt; is the URI scheme+prefix&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HASH_ALG_ID&lt;/code&gt; is the standard identifier used to compute the thumbprint as defined in the &lt;a href=&#34;https://www.iana.org/assignments/named-information/named-information.xhtml&#34;&gt;IANA Named Information Hash Algorithm Registry&lt;/a&gt;. This is the same as &lt;code&gt;thumbprint.getHashAlgorithm().getId()&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BASE64URL_DIGEST&lt;/code&gt; is the Base64URL-encoded thumbprint bytes, equal to &lt;code&gt;jwkThumbprint.toString()&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-security&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWK Security Considerations&lt;/h3&gt; &#xA;&lt;p&gt;Because they contain secret or private key material, &lt;code&gt;SecretJwk&lt;/code&gt; and &lt;code&gt;PrivateJwk&lt;/code&gt; (e.g. &lt;code&gt;RsaPrivateJwk&lt;/code&gt;,&lt;br&gt; &lt;code&gt;EcPrivateJwk&lt;/code&gt;, etc) instances should be used with great care and never accidentally transmitted to 3rd parties.&lt;/p&gt; &#xA;&lt;p&gt;Even so, JJWT&#39;s &lt;code&gt;Jwk&lt;/code&gt; implementations will suppress certain values in &lt;code&gt;toString()&lt;/code&gt; output for safety as described next.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;jwk-tostring&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;JWK &lt;code&gt;toString()&lt;/code&gt; Safety&lt;/h4&gt; &#xA;&lt;p&gt;Because it would be incredibly easy to accidentally print key material to &lt;code&gt;System.out.println()&lt;/code&gt; or application logs, all &lt;code&gt;Jwk&lt;/code&gt; implementations will print redacted values instead of actual secret or private key material.&lt;/p&gt; &#xA;&lt;p&gt;For example, consider the following Secret JWK JSON example from &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7515#appendix-A.1.1&#34;&gt;RFC 7515, Appendix A.1.1&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;kty&#34;: &#34;oct&#34;,&#xA;  &#34;k&#34;: &#34;AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow&#34;,&#xA;  &#34;kid&#34;: &#34;HMAC key used in https://www.rfc-editor.org/rfc/rfc7515#appendix-A.1.1 example.&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;k&lt;/code&gt; value (&lt;code&gt;AyAyM1SysPpby...&lt;/code&gt;) reflects secure key material and should never be accidentially exposed.&lt;/p&gt; &#xA;&lt;p&gt;If you were to parse this JSON as a &lt;code&gt;Jwk&lt;/code&gt;, calling &lt;code&gt;toString()&lt;/code&gt; will &lt;em&gt;NOT&lt;/em&gt; print this value. It will instead print the string literal &lt;code&gt;&amp;lt;redacted&amp;gt;&lt;/code&gt; for any secret or private key data field. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String json = getExampleSecretKeyJson();&#xA;Jwk&amp;lt;?&amp;gt; jwk = Jwks.parser().build().parse(json);&#xA;&#xA;System.out.printn(jwk);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code would print the following string literal to the System console:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;{kty=oct, k=&amp;lt;redacted&amp;gt;, kid=HMAC key used in https://www.rfc-editor.org/rfc/rfc7515#appendix-A.1.1 example.}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is true for all secret or private key members in &lt;code&gt;SecretJwk&lt;/code&gt; and &lt;code&gt;PrivateJwk&lt;/code&gt; (e.g. &lt;code&gt;RsaPrivateJwk&lt;/code&gt;, &lt;code&gt;EcPrivateJwk&lt;/code&gt;, etc) instances.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;compression&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Compression&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;The JWT specifications tandardizes compression for JWEs (Encrypted JWTs) ONLY, however JJWT supports it for JWS (Signed JWTs) as well&lt;/strong&gt;.&lt;/p&gt; &#xA; &lt;p&gt;If you are positive that a JWT you create with JJWT will &lt;em&gt;also&lt;/em&gt; be parsed with JJWT, you can use this feature with both JWEs and JWSs, otherwise it is best to only use it for JWEs.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If a JWT&#39;s &lt;code&gt;payload&lt;/code&gt; is sufficiently large - that is, it is a large content byte array or JSON with a lot of name/value pairs (or individual values are very large or verbose) - you can reduce the size of the compact JWT by compressing the payload.&lt;/p&gt; &#xA;&lt;p&gt;This might be important to you if the resulting JWT is used in a URL for example, since URLs are best kept under 4096 characters due to browser, user mail agent, or HTTP gateway compatibility issues. Smaller JWTs also help reduce bandwidth utilization, which may or may not be important depending on your application&#39;s volume or needs.&lt;/p&gt; &#xA;&lt;p&gt;If you want to compress your JWT, you can use the &lt;code&gt;JwtBuilder&lt;/code&gt;&#39;s &lt;code&gt;compressWith(CompressionAlgorithm)&lt;/code&gt; method. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.builder()&#xA;   &#xA;   .compressWith(Jwts.ZIP.DEF) // DEFLATE compression algorithm&#xA;   &#xA;   // .. etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you use any of the algorithm constants in the &lt;code&gt;Jwts.ZIP&lt;/code&gt; class, that&#39;s it, you&#39;re done. You don&#39;t have to do anything during parsing or configure the &lt;code&gt;JwtParserBuilder&lt;/code&gt; for compression - JJWT will automatically decompress the payload as expected.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;compression-custom&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Custom Compression Algorithm&lt;/h3&gt; &#xA;&lt;p&gt;If the default &lt;code&gt;Jwts.ZIP&lt;/code&gt; compression algorithms are not suitable for your needs, you can create your own &lt;code&gt;CompressionAlgorithm&lt;/code&gt; implementation(s).&lt;/p&gt; &#xA;&lt;p&gt;Just as you would with the default algorithms, you may specify that you want a JWT compressed by calling the &lt;code&gt;JwtBuilder&lt;/code&gt;&#39;s &lt;code&gt;compressWith&lt;/code&gt; method, supplying your custom implementation instance. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CompressionAlgorithm myAlg = new MyCompressionAlgorithm();&#xA;&#xA;Jwts.builder()&#xA;   &#xA;   .compressWith(myAlg) // &amp;lt;----&#xA;   &#xA;   // .. etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you call &lt;code&gt;compressWith&lt;/code&gt;, the JWT &lt;code&gt;payload&lt;/code&gt; will be compressed with your algorithm, and the &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7516.html#section-4.1.3&#34;&gt;&lt;code&gt;zip&lt;/code&gt; (Compression Algorithm)&lt;/a&gt; header will automatically be set to the value returned by your algorithm&#39;s &lt;code&gt;algorithm.getId()&lt;/code&gt; method as required by the JWT specification.&lt;/p&gt; &#xA;&lt;p&gt;However, the &lt;code&gt;JwtParser&lt;/code&gt; needs to be aware of this custom algorithm as well, so it can use it while parsing. You do this by calling the &lt;code&gt;JwtParserBuilder&lt;/code&gt;&#39;s &lt;code&gt;addCompressionAlgorithms&lt;/code&gt; method. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CompressionAlgorithm myAlg = new MyCompressionAlgorithm();&#xA;&#xA;Jwts.parser()&#xA;&#xA;    .addCompressionAlgorithms(Collections.of(myAlg)) // &amp;lt;----&#xA;    &#xA;    // .. etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This adds additional &lt;code&gt;CompressionAlgorithm&lt;/code&gt; implementations to the parser&#39;s overall total set of supported compression algorithms (which already includes all of the &lt;code&gt;Jwts.ZIP&lt;/code&gt; algorithms by default).&lt;/p&gt; &#xA;&lt;p&gt;The parser will then automatically check to see if the JWT &lt;code&gt;zip&lt;/code&gt; header has been set to see if a compression algorithm has been used to compress the JWT. If set, the parser will automatically look up your &lt;code&gt;CompressionAlgorithm&lt;/code&gt; by its &lt;code&gt;getId()&lt;/code&gt; value, and use it to decompress the JWT.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;json&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;JSON Support&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;code&gt;JwtBuilder&lt;/code&gt; will serialize the &lt;code&gt;Header&lt;/code&gt; and &lt;code&gt;Claims&lt;/code&gt; maps (and potentially any Java objects they contain) to JSON with a &lt;code&gt;Serializer&amp;lt;Map&amp;lt;String, ?&amp;gt;&amp;gt;&lt;/code&gt; instance. Similarly, a &lt;code&gt;JwtParser&lt;/code&gt; will deserialize JSON into the &lt;code&gt;Header&lt;/code&gt; and &lt;code&gt;Claims&lt;/code&gt; using a &lt;code&gt;Deserializer&amp;lt;Map&amp;lt;String, ?&amp;gt;&amp;gt;&lt;/code&gt; instance.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t explicitly configure a &lt;code&gt;JwtBuilder&lt;/code&gt;&#39;s &lt;code&gt;Serializer&lt;/code&gt; or a &lt;code&gt;JwtParserBuilder&lt;/code&gt;&#39;s &lt;code&gt;Deserializer&lt;/code&gt;, JJWT will automatically attempt to discover and use the following JSON implementations if found in the runtime classpath.&lt;br&gt; They are checked in order, and the first one found is used:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Jackson: This will automatically be used if you specify &lt;code&gt;io.jsonwebtoken:jjwt-jackson&lt;/code&gt; as a project runtime dependency. Jackson supports POJOs as claims with full marshaling/unmarshaling as necessary.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Gson: This will automatically be used if you specify &lt;code&gt;io.jsonwebtoken:jjwt-gson&lt;/code&gt; as a project runtime dependency. Gson also supports POJOs as claims with full marshaling/unmarshaling as necessary.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;JSON-Java (&lt;code&gt;org.json&lt;/code&gt;): This will be used automatically if you specify &lt;code&gt;io.jsonwebtoken:jjwt-orgjson&lt;/code&gt; as a project runtime dependency.&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA;   &lt;p&gt;&lt;code&gt;org.json&lt;/code&gt; APIs are natively enabled in Android environments so this is the recommended JSON processor for Android applications &lt;em&gt;unless&lt;/em&gt; you want to use POJOs as claims. The &lt;code&gt;org.json&lt;/code&gt; library supports simple Object-to-JSON marshaling, but it &lt;em&gt;does not&lt;/em&gt; support JSON-to-Object unmarshalling.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;If you want to use POJOs as claim values, use either the &lt;code&gt;io.jsonwebtoken:jjwt-jackson&lt;/code&gt; or &lt;code&gt;io.jsonwebtoken:jjwt-gson&lt;/code&gt; dependency&lt;/strong&gt; (or implement your own Serializer and Deserializer if desired). &lt;strong&gt;But beware&lt;/strong&gt;, Jackson will force a sizable (&amp;gt; 1 MB) dependency to an Android application thus increasing the app download size for mobile users.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;json-custom&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Custom JSON Processor&lt;/h3&gt; &#xA;&lt;p&gt;If you don&#39;t want to use JJWT&#39;s runtime dependency approach, or just want to customize how JSON serialization and deserialization works, you can implement the &lt;code&gt;Serializer&lt;/code&gt; and &lt;code&gt;Deserializer&lt;/code&gt; interfaces and specify instances of them on the &lt;code&gt;JwtBuilder&lt;/code&gt; and &lt;code&gt;JwtParserBuilder&lt;/code&gt; respectively. For example:&lt;/p&gt; &#xA;&lt;p&gt;When creating a JWT:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Serializer&amp;lt;Map&amp;lt;String,?&amp;gt;&amp;gt; serializer = getMySerializer(); //implement me&#xA;&#xA;Jwts.builder()&#xA;&#xA;    .serializer(serializer)&#xA;    &#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When reading a JWT:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Deserializer&amp;lt;Map&amp;lt;String,?&amp;gt;&amp;gt; deserializer = getMyDeserializer(); //implement me&#xA;&#xA;Jwts.parser()&#xA;&#xA;    .deserializer(deserializer)&#xA;    &#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;json-jackson&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Jackson JSON Processor&lt;/h3&gt; &#xA;&lt;p&gt;If you want to use Jackson for JSON processing, just including the &lt;code&gt;io.jsonwebtoken:jjwt-jackson&lt;/code&gt; dependency as a runtime dependency is all that is necessary in most projects, since Gradle and Maven will automatically pull in the necessary Jackson dependencies as well.&lt;/p&gt; &#xA;&lt;p&gt;After including this dependency, JJWT will automatically find the Jackson implementation on the runtime classpath and use it internally for JSON parsing. There is nothing else you need to do - JJWT will automatically create a new Jackson ObjectMapper for its needs as required.&lt;/p&gt; &#xA;&lt;p&gt;However, if you have an application-wide Jackson &lt;code&gt;ObjectMapper&lt;/code&gt; (as is typically recommended for most applications), you can configure JJWT to use your own &lt;code&gt;ObjectMapper&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;p&gt;You do this by declaring the &lt;code&gt;io.jsonwebtoken:jjwt-jackson&lt;/code&gt; dependency with &lt;strong&gt;compile&lt;/strong&gt; scope (not runtime scope which is the typical JJWT default). That is:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Maven&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;jjwt-jackson&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;JJWT_RELEASE_VERSION&amp;lt;/version&amp;gt;&#xA;    &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;!-- Not runtime --&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Gradle or Android&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {&#xA;    implementation &#39;io.jsonwebtoken:jjwt-jackson:JJWT_RELEASE_VERSION&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then you can specify the &lt;code&gt;JacksonSerializer&lt;/code&gt; using your own &lt;code&gt;ObjectMapper&lt;/code&gt; on the &lt;code&gt;JwtBuilder&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ObjectMapper objectMapper = getMyObjectMapper(); //implement me&#xA;&#xA;String jws = Jwts.builder()&#xA;&#xA;    .serializer(new JacksonSerializer(objectMapper))&#xA;    &#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and the &lt;code&gt;JacksonDeserializer&lt;/code&gt; using your &lt;code&gt;ObjectMapper&lt;/code&gt; on the &lt;code&gt;JwtParserBuilder&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ObjectMapper objectMapper = getMyObjectMapper(); //implement me&#xA;&#xA;Jwts.parser()&#xA;&#xA;    .deserializer(new JacksonDeserializer(objectMapper))&#xA;    &#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;json-jackson-custom-types&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Parsing of Custom Claim Types&lt;/h4&gt; &#xA;&lt;p&gt;By default JJWT will only convert simple claim types: String, Date, Long, Integer, Short and Byte. If you need to deserialize other types you can configure the &lt;code&gt;JacksonDeserializer&lt;/code&gt; by passing a &lt;code&gt;Map&lt;/code&gt; of claim names to types in through a constructor. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new JacksonDeserializer(Maps.of(&#34;user&#34;, User.class).build())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This would trigger the value in the &lt;code&gt;user&lt;/code&gt; claim to be deserialized into the custom type of &lt;code&gt;User&lt;/code&gt;. Given the claims payload of:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;issuer&#34;: &#34;https://example.com/issuer&#34;,&#xA;    &#34;user&#34;: {&#xA;      &#34;firstName&#34;: &#34;Jill&#34;,&#xA;      &#34;lastName&#34;: &#34;Coder&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;User&lt;/code&gt; object could be retrieved from the &lt;code&gt;user&lt;/code&gt; claim with the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Jwts.parser()&#xA;&#xA;    .deserializer(new JacksonDeserializer(Maps.of(&#34;user&#34;, User.class).build())) // &amp;lt;-----&#xA;&#xA;    .build()&#xA;&#xA;    .parseClaimsJwt(aJwtString)&#xA;&#xA;    .getPayload()&#xA;    &#xA;    .get(&#34;user&#34;, User.class) // &amp;lt;-----&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;Using this constructor is mutually exclusive with the &lt;code&gt;JacksonDeserializer(ObjectMapper)&lt;/code&gt; constructor &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#json-jackson&#34;&gt;described above&lt;/a&gt;. This is because JJWT configures an &lt;code&gt;ObjectMapper&lt;/code&gt; directly and could have negative consequences for a shared &lt;code&gt;ObjectMapper&lt;/code&gt; instance. This should work for most applications, if you need a more advanced parsing options, &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#json-jackson&#34;&gt;configure the mapper directly&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a name=&#34;json-gson&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Gson JSON Processor&lt;/h3&gt; &#xA;&lt;p&gt;If you want to use Gson for JSON processing, just including the &lt;code&gt;io.jsonwebtoken:jjwt-gson&lt;/code&gt; dependency as a runtime dependency is all that is necessary in most projects, since Gradle and Maven will automatically pull in the necessary Gson dependencies as well.&lt;/p&gt; &#xA;&lt;p&gt;After including this dependency, JJWT will automatically find the Gson implementation on the runtime classpath and use it internally for JSON parsing. There is nothing else you need to do - just declaring the dependency is all that is required, no code or config is necessary.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re curious, JJWT will automatically create an internal default Gson instance for its own needs as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new GsonBuilder()&#xA;    .registerTypeHierarchyAdapter(io.jsonwebtoken.lang.Supplier.class, GsonSupplierSerializer.INSTANCE)    &#xA;    .disableHtmlEscaping().create();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;registerTypeHierarchyAdapter&lt;/code&gt; builder call is required to serialize JWKs with secret or private values.&lt;/p&gt; &#xA;&lt;p&gt;However, if you prefer to use a different Gson instance instead of JJWT&#39;s default, you can configure JJWT to use your own - just don&#39;t forget to register the necessary JJWT type hierarchy adapter.&lt;/p&gt; &#xA;&lt;p&gt;You do this by declaring the &lt;code&gt;io.jsonwebtoken:jjwt-gson&lt;/code&gt; dependency with &lt;strong&gt;compile&lt;/strong&gt; scope (not runtime scope which is the typical JJWT default). That is:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Maven&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;jjwt-gson&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;JJWT_RELEASE_VERSION&amp;lt;/version&amp;gt;&#xA;    &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;!-- Not runtime --&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Gradle or Android&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {&#xA;    implementation &#39;io.jsonwebtoken:jjwt-gson:JJWT_RELEASE_VERSION&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then you can specify the &lt;code&gt;GsonSerializer&lt;/code&gt; using your own &lt;code&gt;Gson&lt;/code&gt; instance on the &lt;code&gt;JwtBuilder&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&#xA;Gson gson = new GsonBuilder()&#xA;    // don&#39;t forget this line!:    &#xA;    .registerTypeHierarchyAdapter(io.jsonwebtoken.lang.Supplier.class, GsonSupplierSerializer.INSTANCE)&#xA;    .disableHtmlEscaping().create();&#xA;&#xA;String jws = Jwts.builder()&#xA;&#xA;    .serializer(new GsonSerializer(gson))&#xA;    &#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and the &lt;code&gt;GsonDeserializer&lt;/code&gt; using your &lt;code&gt;Gson&lt;/code&gt; instance on the &lt;code&gt;JwtParser&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Gson gson = getGson(); //implement me&#xA;&#xA;Jwts.parser()&#xA;&#xA;    .deserializer(new GsonDeserializer(gson))&#xA;    &#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Again, as shown above, it is critical to create your &lt;code&gt;Gson&lt;/code&gt; instance using the &lt;code&gt;GsonBuilder&lt;/code&gt; and include the line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;.registerTypeHierarchyAdapter(io.jsonwebtoken.lang.Supplier.class, GsonSupplierSerializer.INSTANCE)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to ensure JWK serialization works as expected.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;base64&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Base64 Support&lt;/h2&gt; &#xA;&lt;p&gt;JJWT uses a very fast pure-Java &lt;a href=&#34;https://tools.ietf.org/html/rfc4648&#34;&gt;Base64&lt;/a&gt; codec for Base64 and Base64Url encoding and decoding that is guaranteed to work deterministically in all JDK and Android environments.&lt;/p&gt; &#xA;&lt;p&gt;You can access JJWT&#39;s encoders and decoders using the &lt;code&gt;io.jsonwebtoken.io.Encoders&lt;/code&gt; and &lt;code&gt;io.jsonwebtoken.io.Decoders&lt;/code&gt; utility classes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;io.jsonwebtoken.io.Encoders&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;BASE64&lt;/code&gt; is an RFC 4648 &lt;a href=&#34;https://tools.ietf.org/html/rfc4648#section-4&#34;&gt;Base64&lt;/a&gt; encoder&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BASE64URL&lt;/code&gt; is an RFC 4648 &lt;a href=&#34;https://tools.ietf.org/html/rfc4648#section-5&#34;&gt;Base64URL&lt;/a&gt; encoder&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;io.jsonwebtoken.io.Decoders&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;BASE64&lt;/code&gt; is an RFC 4648 &lt;a href=&#34;https://tools.ietf.org/html/rfc4648#section-4&#34;&gt;Base64&lt;/a&gt; decoder&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BASE64URL&lt;/code&gt; is an RFC 4648 &lt;a href=&#34;https://tools.ietf.org/html/rfc4648#section-5&#34;&gt;Base64URL&lt;/a&gt; decoder&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;base64-security&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Understanding Base64 in Security Contexts&lt;/h3&gt; &#xA;&lt;p&gt;All cryptographic operations, like encryption and message digest calculations, result in binary data - raw byte arrays.&lt;/p&gt; &#xA;&lt;p&gt;Because raw byte arrays cannot be represented natively in JSON, the JWT specifications employ the Base64URL encoding scheme to represent these raw byte values in JSON documents or compound structures like a JWT.&lt;/p&gt; &#xA;&lt;p&gt;This means that the Base64 and Base64URL algorithms take a raw byte array and converts the bytes into a string suitable to use in text documents and protocols like HTTP. These algorithms can also convert these strings back into the original raw byte arrays for decryption or signature verification as necessary.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s nice and convenient, but there are two very important properties of Base64 (and Base64URL) text strings that are critical to remember when they are used in security scenarios like with JWTs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#base64-not-encryption&#34;&gt;Base64 is not encryption&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#base64-changing-characters&#34;&gt;Changing Base64 characters&lt;/a&gt; &lt;strong&gt;does not automatically invalidate data&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;base64-not-encryption&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Base64 is not encryption&lt;/h4&gt; &#xA;&lt;p&gt;Base64-encoded text is &lt;em&gt;not&lt;/em&gt; encrypted.&lt;/p&gt; &#xA;&lt;p&gt;While a byte array representation can be converted to text with the Base64 algorithms, anyone in the world can take Base64-encoded text, decode it with any standard Base64 decoder, and obtain the underlying raw byte array data. No key or secret is required to decode Base64 text - anyone can do it.&lt;/p&gt; &#xA;&lt;p&gt;Based on this, when encoding sensitive byte data with Base64 - like a shared or private key - &lt;strong&gt;the resulting string is NOT safe to expose publicly&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A base64-encoded key is still sensitive information and must be kept as secret and as safe as the original source of the bytes (e.g. a Java &lt;code&gt;PrivateKey&lt;/code&gt; or &lt;code&gt;SecretKey&lt;/code&gt; instance).&lt;/p&gt; &#xA;&lt;p&gt;After Base64-encoding data into a string, it is possible to then encrypt the string to keep it safe from prying eyes if desired, but this is different. Encryption is not encoding. They are separate concepts.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;base64-changing-characters&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Changing Base64 Characters&lt;/h4&gt; &#xA;&lt;p&gt;In an effort to see if signatures or encryption is truly validated correctly, some try to edit a JWT string - particularly the Base64-encoded signature part - to see if the edited string fails security validations.&lt;/p&gt; &#xA;&lt;p&gt;This conceptually makes sense: change the signature string, you would assume that signature validation would fail.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;But this doesn&#39;t always work. Changing base64 characters is an invalid test&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Why?&lt;/p&gt; &#xA;&lt;p&gt;Because of the way the Base64 algorithm works, there are multiple Base64 strings that can represent the same raw byte array.&lt;/p&gt; &#xA;&lt;p&gt;Going into the details of the Base64 algorithm is out of scope for this documentation, but there are many good Stackoverflow &lt;a href=&#34;https://stackoverflow.com/questions/33663113/multiple-strings-base64-decoded-to-same-byte-array?noredirect=1&amp;amp;lq=1&#34;&gt;answers&lt;/a&gt; and &lt;a href=&#34;https://github.com/jwtk/jjwt/issues/211#issuecomment-283076269&#34;&gt;JJWT issue comments&lt;/a&gt; that explain this in detail. Here&#39;s one &lt;a href=&#34;https://stackoverflow.com/questions/29941270/why-do-base64-decode-produce-same-byte-array-for-different-strings&#34;&gt;good answer&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Remember that Base64 encodes each 8 bit entity into 6 bit chars. The resulting string then needs exactly 11 * 8 / 6 bytes, or 14 2/3 chars. But you can&#39;t write partial characters. Only the first 4 bits (or 2/3 of the last char) are significant. The last two bits are not decoded. Thus all of:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;dGVzdCBzdHJpbmo&#xA;dGVzdCBzdHJpbmp&#xA;dGVzdCBzdHJpbmq&#xA;dGVzdCBzdHJpbmr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;All decode to the same 11 bytes (116, 101, 115, 116, 32, 115, 116, 114, 105, 110, 106).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;As you can see by the above 4 examples, they all decode to the same exact 11 bytes. So just changing one or two characters at the end of a Base64 string may not work and can often result in an invalid test.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;base64-invalid-characters&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Adding Invalid Characters&lt;/h5&gt; &#xA;&lt;p&gt;JJWT&#39;s default Base64/Base64URL decoders automatically ignore illegal Base64 characters located in the beginning and end of an encoded string. Therefore prepending or appending invalid characters like &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt; or similar will also not fail JJWT&#39;s signature checks either. Why?&lt;/p&gt; &#xA;&lt;p&gt;Because such edits - whether changing a trailing character or two, or appending invalid characters - do not actually change the &lt;em&gt;real&lt;/em&gt; signature, which in cryptographic contexts, is always a byte array. Instead, tests like these change a text encoding of the byte array, and as we covered above, they are different things.&lt;/p&gt; &#xA;&lt;p&gt;So JJWT &#39;cares&#39; more about the real byte array and less about its text encoding because that is what actually matters in cryptographic operations. In this sense, JJWT follows the &lt;a href=&#34;https://en.wikipedia.org/wiki/Robustness_principle&#34;&gt;Robustness Principle&lt;/a&gt; in being &lt;em&gt;slightly&lt;/em&gt; lenient on what is accepted per the rules of Base64, but if anything in the real underlying byte array is changed, then yes, JJWT&#39;s cryptographic assertions will definitely fail.&lt;/p&gt; &#xA;&lt;p&gt;To help understand JJWT&#39;s approach, we have to remember why signatures exist. From our documentation above on &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws&#34;&gt;signing JWTs&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;guarantees it was created by someone we know (it is authentic), as well as&lt;/li&gt; &#xA;  &lt;li&gt;guarantees that no-one has manipulated or changed it after it was created (its integrity is maintained).&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Just prepending or appending invalid text to try to &#39;trick&#39; the algorithm doesn&#39;t change the integrity of the underlying claims or signature byte arrays, nor the authenticity of the claims byte array, because those byte arrays are still obtained intact.&lt;/p&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/jwtk/jjwt/issues/518&#34;&gt;JJWT Issue #518&lt;/a&gt; and its referenced issues and links for more information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;base64-custom&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Custom Base64&lt;/h3&gt; &#xA;&lt;p&gt;If for some reason you want to specify your own Base64Url encoder and decoder, you can use the &lt;code&gt;JwtBuilder&lt;/code&gt; &lt;code&gt;encoder&lt;/code&gt; method to set the encoder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Encoder&amp;lt;byte[], String&amp;gt; encoder = getMyBase64UrlEncoder(); //implement me&#xA;&#xA;String jws = Jwts.builder()&#xA;&#xA;    .encoder(encoder)&#xA;    &#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and the &lt;code&gt;JwtParserBuilder&lt;/code&gt;&#39;s &lt;code&gt;decoder&lt;/code&gt; method to set the decoder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Decoder&amp;lt;String, byte[]&amp;gt; decoder = getMyBase64UrlDecoder(); //implement me&#xA;&#xA;Jwts.parser()&#xA;&#xA;    .decoder(decoder)&#xA;    &#xA;    // ... etc ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;examples&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jws-hs&#34;&gt;JWS Signed with HMAC&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jws-rsa&#34;&gt;JWS Signed with RSA&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jws-ecdsa&#34;&gt;JWS Signed with ECDSA&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jws-eddsa&#34;&gt;JWS Signed with EdDSA&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwe-dir&#34;&gt;JWE Encrypted Directly with a SecretKey&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwe-rsa&#34;&gt;JWE Encrypted with RSA&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwe-aeskw&#34;&gt;JWE Encrypted with AES Key Wrap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwe-ecdhes&#34;&gt;JWE Encrypted with ECDH-ES&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwe-password&#34;&gt;JWE Encrypted with a Password&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-secret&#34;&gt;SecretKey JWK&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-rsapub&#34;&gt;RSA Public JWK&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-rsapriv&#34;&gt;RSA Private JWK&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-ecpub&#34;&gt;Elliptic Curve Public JWK&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-ecpriv&#34;&gt;Elliptic Curve Private JWK&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-edpub&#34;&gt;Edwards Elliptic Curve Public JWK&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#example-jwk-edpriv&#34;&gt;Edwards Elliptic Curve Private JWK&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jws-hs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Signed with HMAC&lt;/h3&gt; &#xA;&lt;p&gt;This is an example showing how to digitally sign a JWT using an &lt;a href=&#34;https://en.wikipedia.org/wiki/HMAC&#34;&gt;HMAC&lt;/a&gt; (hash-based message authentication code). The JWT specifications define 3 standard HMAC signing algorithms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;HS256&lt;/code&gt;: HMAC with SHA-256. This requires a 256-bit (32 byte) &lt;code&gt;SecretKey&lt;/code&gt; or larger.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HS384&lt;/code&gt;: HMAC with SHA-384. This requires a 384-bit (48 byte) &lt;code&gt;SecretKey&lt;/code&gt; or larger.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;HS512&lt;/code&gt;: HMAC with SHA-512. This requires a 512-bit (64 byte) &lt;code&gt;SecretKey&lt;/code&gt; or larger.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Create a test key suitable for the desired HMAC-SHA algorithm:&#xA;MacAlgorithm alg = Jwts.SIG.HS512; //or HS384 or HS256&#xA;SecretKey key = alg.key().build();&#xA;&#xA;String message = &#34;Hello World!&#34;;&#xA;byte[] content = message.getBytes(StandardCharsets.UTF_8);&#xA;&#xA;// Create the compact JWS:&#xA;String jws = Jwts.builder().content(content, &#34;text/plain&#34;).signWith(key, alg).compact();&#xA;&#xA;// Parse the compact JWS:&#xA;content = Jwts.parser().verifyWith(key).build().parseContentJws(jws).getPayload();&#xA;&#xA;assert message.equals(new String(content, StandardCharsets.UTF_8));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jws-rsa&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Signed with RSA&lt;/h3&gt; &#xA;&lt;p&gt;This is an example showing how to digitally sign and verify a JWT using RSA cryptography. The JWT specifications define &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-alg&#34;&gt;6 standard RSA signing algorithms&lt;/a&gt;. All 6 require that &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-key-rsa&#34;&gt;RSA keys 2048-bits or larger&lt;/a&gt; must be used.&lt;/p&gt; &#xA;&lt;p&gt;In this example, Bob will sign a JWT using his RSA private key, and Alice can verify it came from Bob using Bob&#39;s RSA public key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Create a test key suitable for the desired RSA signature algorithm:&#xA;SignatureAlgorithm alg = Jwts.SIG.RS512; //or PS512, RS256, etc...&#xA;KeyPair pair = alg.keyPair().build();&#xA;&#xA;// Bob creates the compact JWS with his RSA private key:&#xA;String jws = Jwts.builder().subject(&#34;Alice&#34;)&#xA;    .signWith(pair.getPrivate(), alg) // &amp;lt;-- Bob&#39;s RSA private key&#xA;    .compact();&#xA;&#xA;// Alice receives and verifies the compact JWS came from Bob:&#xA;String subject = Jwts.parser()&#xA;    .verifyWith(pair.getPublic()) // &amp;lt;-- Bob&#39;s RSA public key&#xA;    .build().parseClaimsJws(jws).getPayload().getSubject();&#xA;&#xA;assert &#34;Alice&#34;.equals(subject);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jws-ecdsa&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Signed with ECDSA&lt;/h3&gt; &#xA;&lt;p&gt;This is an example showing how to digitally sign and verify a JWT using the Elliptic Curve Digital Signature Algorithm. The JWT specifications define &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jws-alg&#34;&gt;3 standard ECDSA signing algorithms&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ES256&lt;/code&gt;: ECDSA using P-256 and SHA-256. This requires an EC Key exactly 256 bits (32 bytes) long.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ES384&lt;/code&gt;: ECDSA using P-384 and SHA-384. This requires an EC Key exactly 384 bits (48 bytes) long.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ES512&lt;/code&gt;: ECDSA using P-521 and SHA-512. This requires an EC Key exactly 521 bits (65 or 66 bytes depending on format) long.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In this example, Bob will sign a JWT using his EC private key, and Alice can verify it came from Bob using Bob&#39;s EC public key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Create a test key suitable for the desired ECDSA signature algorithm:&#xA;SignatureAlgorithm alg = Jwts.SIG.ES512; //or ES256 or ES384&#xA;KeyPair pair = alg.keyPair().build();&#xA;&#xA;// Bob creates the compact JWS with his EC private key:&#xA;String jws = Jwts.builder().subject(&#34;Alice&#34;)&#xA;    .signWith(pair.getPrivate(), alg) // &amp;lt;-- Bob&#39;s EC private key&#xA;    .compact();&#xA;&#xA;// Alice receives and verifies the compact JWS came from Bob:&#xA;String subject = Jwts.parser()&#xA;    .verifyWith(pair.getPublic()) // &amp;lt;-- Bob&#39;s EC public key&#xA;    .build().parseClaimsJws(jws).getPayload().getSubject();&#xA;&#xA;assert &#34;Alice&#34;.equals(subject);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jws-eddsa&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Signed with EdDSA&lt;/h3&gt; &#xA;&lt;p&gt;This is an example showing how to digitally sign and verify a JWT using the &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8032&#34;&gt;Edwards Curve Digital Signature Algorithm&lt;/a&gt; using &lt;code&gt;Ed25519&lt;/code&gt; or &lt;code&gt;Ed448&lt;/code&gt; keys.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;The &lt;code&gt;Ed25519&lt;/code&gt; and &lt;code&gt;Ed448&lt;/code&gt; algorithms require JDK 15 or a compatible JCA Provider (like BouncyCastle) in the runtime classpath.&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;If you are using JDK 14 or earlier and you want to use them, see the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#Installation&#34;&gt;Installation&lt;/a&gt; section to see how to enable BouncyCastle.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The &lt;code&gt;EdDSA&lt;/code&gt; signature algorithm is defined for JWS in &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8037#section-3.1&#34;&gt;RFC 8037, Section 3.1&lt;/a&gt; using keys for two Edwards curves:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Ed25519&lt;/code&gt;: &lt;code&gt;EdDSA&lt;/code&gt; using curve &lt;code&gt;Ed25519&lt;/code&gt;. &lt;code&gt;Ed25519&lt;/code&gt; algorithm keys must be 256 bits (32 bytes) long and produce signatures 512 bits (64 bytes) long.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Ed448&lt;/code&gt;: &lt;code&gt;EdDSA&lt;/code&gt; using curve &lt;code&gt;Ed448&lt;/code&gt;. &lt;code&gt;Ed448&lt;/code&gt; algorithm keys must be 456 bits (57 bytes) long and produce signatures 912 bits (114 bytes) long.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In this example, Bob will sign a JWT using his Edwards Curve private key, and Alice can verify it came from Bob using Bob&#39;s Edwards Curve public key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Create a test key suitable for the EdDSA signature algorithm using Ed25519 or Ed448 keys:&#xA;Curve curve = Jwks.CRV.Ed25519; //or Ed448&#xA;KeyPair pair = curve.keyPair().build();&#xA;&#xA;// Bob creates the compact JWS with his Edwards Curve private key:&#xA;String jws = Jwts.builder().subject(&#34;Alice&#34;)&#xA;    .signWith(pair.getPrivate(), Jwts.SIG.EdDSA) // &amp;lt;-- Bob&#39;s Edwards Curve private key w/ EdDSA&#xA;    .compact();&#xA;&#xA;// Alice receives and verifies the compact JWS came from Bob:&#xA;String subject = Jwts.parser()&#xA;    .verifyWith(pair.getPublic()) // &amp;lt;-- Bob&#39;s Edwards Curve public key&#xA;    .build().parseClaimsJws(jws).getPayload().getSubject();&#xA;&#xA;assert &#34;Alice&#34;.equals(subject);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwe-dir&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Encrypted Directly with a SecretKey&lt;/h3&gt; &#xA;&lt;p&gt;This is an example showing how to encrypt a JWT &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-alg-dir&#34;&gt;directly using a symmetric secret key&lt;/a&gt;. The JWT specifications define &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/#jwe-enc&#34;&gt;6 standard AEAD Encryption algorithms&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;A128GCM&lt;/code&gt;: AES GCM using a 128-bit (16 byte) &lt;code&gt;SecretKey&lt;/code&gt; or larger.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;A192GCM&lt;/code&gt;: AES GCM using a 192-bit (24 byte) &lt;code&gt;SecretKey&lt;/code&gt; or larger.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;A256GCM&lt;/code&gt;: AES GCM using a 256-bit (32 byte) &lt;code&gt;SecretKey&lt;/code&gt; or larger.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;A128CBC-HS256&lt;/code&gt;: &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.3&#34;&gt;AES_128_CBC_HMAC_SHA_256&lt;/a&gt; using a 256-bit (32 byte) &lt;code&gt;SecretKey&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;A192CBC-HS384&lt;/code&gt;: &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.4&#34;&gt;AES_192_CBC_HMAC_SHA_384&lt;/a&gt; using a 384-bit (48 byte) &lt;code&gt;SecretKey&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;A256CBC-HS512&lt;/code&gt;: &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.5&#34;&gt;AES_256_CBC_HMAC_SHA_512&lt;/a&gt; using a 512-bit (64 byte) &lt;code&gt;SecretKey&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The AES GCM (&lt;code&gt;A128GCM&lt;/code&gt;, &lt;code&gt;A192GCM&lt;/code&gt; and &lt;code&gt;A256GCM&lt;/code&gt;) algorithms are strongly recommended - they are faster and more efficient than the &lt;code&gt;A*CBC-HS*&lt;/code&gt; variants, but they do require JDK 8 or later (or JDK 7 + BouncyCastle).&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Create a test key suitable for the desired payload encryption algorithm:&#xA;// (A*GCM algorithms are recommended, but require JDK &amp;gt;= 8 or BouncyCastle)&#xA;AeadAlgorithm enc = Jwts.ENC.A256GCM; //or A128GCM, A192GCM, A256CBC-HS512, etc...&#xA;SecretKey key = enc.key().build();&#xA;&#xA;String message = &#34;Live long and prosper.&#34;;&#xA;byte[] content = message.getBytes(StandardCharsets.UTF_8);&#xA;&#xA;// Create the compact JWE:&#xA;String jwe = Jwts.builder().content(content, &#34;text/plain&#34;).encryptWith(key, enc).compact();&#xA;&#xA;// Parse the compact JWE:&#xA;content = Jwts.parser().decryptWith(key).build().parseContentJwe(jwe).getPayload();&#xA;&#xA;assert message.equals(new String(content, StandardCharsets.UTF_8));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwe-rsa&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Encrypted with RSA&lt;/h3&gt; &#xA;&lt;p&gt;This is an example showing how to encrypt and decrypt a JWT using RSA cryptography.&lt;/p&gt; &#xA;&lt;p&gt;Because RSA cannot encrypt much data, RSA is used to encrypt and decrypt a secure-random key, and that generated key in turn is used to actually encrypt the payload as described in the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/jwe-alg-rsa&#34;&gt;RSA Key Encryption&lt;/a&gt; section above. As such, RSA Key Algorithms must be paired with an AEAD Encryption Algorithm, as shown below.&lt;/p&gt; &#xA;&lt;p&gt;In this example, Bob will encrypt a JWT using Alice&#39;s RSA public key to ensure only she may read it. Alice can then decrypt the JWT using her RSA private key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Create a test KeyPair suitable for the desired RSA key algorithm:&#xA;KeyPair pair = Jwts.SIG.RS512.keyPair().build();&#xA;&#xA;// Choose the key algorithm used encrypt the payload key:&#xA;KeyAlgorithm&amp;lt;PublicKey, PrivateKey&amp;gt; alg = Jwts.KEY.RSA_OAEP_256; //or RSA_OAEP or RSA1_5&#xA;// Choose the Encryption Algorithm to encrypt the payload:&#xA;AeadAlgorithm enc = Jwts.ENC.A256GCM; //or A192GCM, A128GCM, A256CBC-HS512, etc...&#xA;&#xA;// Bob creates the compact JWE with Alice&#39;s RSA public key so only she may read it:&#xA;String jwe = Jwts.builder().audience(&#34;Alice&#34;)&#xA;    .encryptWith(pair.getPublic(), alg, enc) // &amp;lt;-- Alice&#39;s RSA public key&#xA;    .compact();&#xA;&#xA;// Alice receives and decrypts the compact JWE:&#xA;String audience = Jwts.parser()&#xA;    .decryptWith(pair.getPrivate()) // &amp;lt;-- Alice&#39;s RSA private key&#xA;    .build().parseClaimsJwe(jwe).getPayload().getAudience();&#xA;&#xA;assert &#34;Alice&#34;.equals(audience);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwe-aeskw&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Encrypted with AES Key Wrap&lt;/h3&gt; &#xA;&lt;p&gt;This is an example showing how to encrypt and decrypt a JWT using AES Key Wrap algorithms.&lt;/p&gt; &#xA;&lt;p&gt;These algorithms use AES to encrypt and decrypt a secure-random key, and that generated key in turn is used to actually encrypt the payload as described in the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/jwe-alg-aes&#34;&gt;AES Key Encryption&lt;/a&gt; section above. This allows the payload to be encrypted with a random short-lived key, reducing material exposure of the potentially longer-lived symmetric secret key. This approach requires the AES Key Wrap algorithms to be paired with an AEAD content encryption algorithm, as shown below.&lt;/p&gt; &#xA;&lt;p&gt;The AES GCM Key Wrap algorithms (&lt;code&gt;A128GCMKW&lt;/code&gt;, &lt;code&gt;A192GCMKW&lt;/code&gt; and &lt;code&gt;A256GCMKW&lt;/code&gt;) are preferred - they are faster and more efficient than the &lt;code&gt;A*KW&lt;/code&gt; variants, but they do require JDK 8 or later (or JDK 7 + BouncyCastle).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Create a test SecretKey suitable for the desired AES Key Wrap algorithm:&#xA;SecretKeyAlgorithm alg = Jwts.KEY.A256GCMKW; //or A192GCMKW, A128GCMKW, A256KW, etc...&#xA;SecretKey key = alg.key().build();&#xA;&#xA;// Chooose the Encryption Algorithm used to encrypt the payload:&#xA;AeadAlgorithm enc = Jwts.ENC.A256GCM; //or A192GCM, A128GCM, A256CBC-HS512, etc...&#xA;&#xA;// Create the compact JWE:&#xA;String jwe = Jwts.builder().issuer(&#34;me&#34;).encryptWith(key, alg, enc).compact();&#xA;&#xA;// Parse the compact JWE:&#xA;String issuer = Jwts.parser().decryptWith(key).build()&#xA;    .parseClaimsJwe(jwe).getPayload().getIssuer();&#xA;&#xA;assert &#34;me&#34;.equals(issuer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwe-ecdhes&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Encrypted with ECDH-ES&lt;/h3&gt; &#xA;&lt;p&gt;This is an example showing how to encrypt and decrypt a JWT using Elliptic Curve Diffie-Hellman Ephmeral Static Key Agreement (ECDH-ES) algorithms.&lt;/p&gt; &#xA;&lt;p&gt;These algorithms use ECDH-ES to encrypt and decrypt a secure-random key, and that generated key in turn is used to actually encrypt the payload as described in the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/jwe-alg-ecdhes&#34;&gt;Elliptic Curve Diffie-Hellman Ephemeral Static Key Agreement&lt;/a&gt; section above. Because of this, ECDH-ES Key Algorithms must be paired with an AEAD Encryption Algorithm, as shown below.&lt;/p&gt; &#xA;&lt;p&gt;In this example, Bob will encrypt a JWT using Alice&#39;s Elliptic Curve public key to ensure only she may read it.&lt;br&gt; Alice can then decrypt the JWT using her Elliptic Curve private key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Create a test KeyPair suitable for the desired EC key algorithm:&#xA;KeyPair pair = Jwts.SIG.ES512.keyPair().build();&#xA;&#xA;// Choose the key algorithm used encrypt the payload key:&#xA;KeyAlgorithm&amp;lt;PublicKey, PrivateKey&amp;gt; alg = Jwts.KEY.ECDH_ES_A256KW; //ECDH_ES_A192KW, etc.&#xA;// Choose the Encryption Algorithm to encrypt the payload:&#xA;AeadAlgorithm enc = Jwts.ENC.A256GCM; //or A192GCM, A128GCM, A256CBC-HS512, etc...&#xA;&#xA;// Bob creates the compact JWE with Alice&#39;s EC public key so only she may read it:&#xA;String jwe = Jwts.builder().audience(&#34;Alice&#34;)&#xA;    .encryptWith(pair.getPublic(), alg, enc) // &amp;lt;-- Alice&#39;s EC public key&#xA;    .compact();&#xA;&#xA;// Alice receives and decrypts the compact JWE:&#xA;String audience = Jwts.parser()&#xA;    .decryptWith(pair.getPrivate()) // &amp;lt;-- Alice&#39;s EC private key&#xA;    .build().parseClaimsJwe(jwe).getPayload().getAudience();&#xA;&#xA;assert &#34;Alice&#34;.equals(audience);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwe-password&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;JWT Encrypted with a Password&lt;/h3&gt; &#xA;&lt;p&gt;This is an example showing how to encrypt and decrypt a JWT using Password-based key-derivation algorithms.&lt;/p&gt; &#xA;&lt;p&gt;These algorithms use a password to securely derive a random key, and that derived random key in turn is used to actually encrypt the payload as described in the &lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/jwe-alg-pbes2&#34;&gt;Password-based Key Encryption&lt;/a&gt; section above. This allows the payload to be encrypted with a random short-lived cryptographically-stronger key, reducing the need to expose the longer-lived (and potentially weaker) password.&lt;/p&gt; &#xA;&lt;p&gt;This approach requires the Password-based Key Wrap algorithms to be paired with an AEAD content encryption algorithm, as shown below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//DO NOT use this example password in a real app, it is well-known to password crackers:&#xA;String pw = &#34;correct horse battery staple&#34;;&#xA;Password password = Keys.password(pw.toCharArray());&#xA;&#xA;// Choose the desired PBES2 key derivation algorithm:&#xA;KeyAlgorithm&amp;lt;Password, Password&amp;gt; alg = Jwts.KEY.PBES2_HS512_A256KW; //or PBES2_HS384_A192KW or PBES2_HS256_A128KW&#xA;&#xA;// Optionally choose the number of PBES2 computational iterations to use to derive the key.&#xA;// This is optional - if you do not specify a value, JJWT will automatically choose a value &#xA;// based on your chosen PBES2 algorithm and OWASP PBKDF2 recommendations here: &#xA;// https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2&#xA;// &#xA;// If you do specify a value, ensure the iterations are large enough for your desired alg&#xA;//int pbkdf2Iterations = 120000; //for HS512. Needs to be much higher for smaller hash algs.&#xA;&#xA;// Choose the Encryption Algorithm used to encrypt the payload:&#xA;AeadAlgorithm enc = Jwts.ENC.A256GCM; //or A192GCM, A128GCM, A256CBC-HS512, etc...&#xA;&#xA;// Create the compact JWE:&#xA;String jwe = Jwts.builder().issuer(&#34;me&#34;)&#xA;    // Optional work factor is specified in the header:&#xA;    //.header().pbes2Count(pbkdf2Iterations)).and()&#xA;    .encryptWith(password, alg, enc)&#xA;    .compact();&#xA;&#xA;// Parse the compact JWE:&#xA;String issuer = Jwts.parser().decryptWith(password)&#xA;    .build().parseClaimsJwe(jwe).getPayload().getIssuer();&#xA;&#xA;assert &#34;me&#34;.equals(issuer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwk-secret&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;SecretKey JWK&lt;/h3&gt; &#xA;&lt;p&gt;Example creating and parsing a secret JWK:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SecretKey key = Jwts.SIG.HS512.key().build(); // or HS384 or HS256&#xA;SecretJwk jwk = Jwks.builder().key(key).idFromThumbprint().build();&#xA;&#xA;assert jwk.getId().equals(jwk.thumbprint().toString());&#xA;assert key.equals(jwk.toKey());&#xA;&#xA;byte[] utf8Bytes = new JacksonSerializer().serialize(jwk); // or GsonSerializer(), etc&#xA;String jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);&#xA;Jwk&amp;lt;?&amp;gt; parsed = Jwks.parser().build().parse(jwkJson);&#xA;&#xA;assert parsed instanceof SecretJwk;&#xA;assert jwk.equals(parsed);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwk-rsapub&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;RSA Public JWK&lt;/h3&gt; &#xA;&lt;p&gt;Example creating and parsing an RSA Public JWK:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RSAPublicKey key = (RSAPublicKey)Jwts.SIG.RS512.keyPair().build().getPublic();&#xA;RsaPublicJwk jwk = Jwks.builder().key(key).idFromThumbprint().build();&#xA;&#xA;assert jwk.getId().equals(jwk.thumbprint().toString());&#xA;assert key.equals(jwk.toKey());&#xA;&#xA;byte[] utf8Bytes = new JacksonSerializer().serialize(jwk); // or GsonSerializer(), etc&#xA;String jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);&#xA;Jwk&amp;lt;?&amp;gt; parsed = Jwks.parser().build().parse(jwkJson);&#xA;&#xA;assert parsed instanceof RsaPublicJwk;&#xA;assert jwk.equals(parsed);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwk-rsapriv&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;RSA Private JWK&lt;/h3&gt; &#xA;&lt;p&gt;Example creating and parsing an RSA Private JWK:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;KeyPair pair = Jwts.SIG.RS512.keyPair().build();&#xA;RSAPublicKey pubKey = (RSAPublicKey) pair.getPublic();&#xA;RSAPrivateKey privKey = (RSAPrivateKey) pair.getPrivate();&#xA;&#xA;RsaPrivateJwk privJwk = Jwks.builder().key(privKey).idFromThumbprint().build();&#xA;RsaPublicJwk pubJwk = privJwk.toPublicJwk();&#xA;&#xA;assert privJwk.getId().equals(privJwk.thumbprint().toString());&#xA;assert pubJwk.getId().equals(pubJwk.thumbprint().toString());&#xA;assert privKey.equals(privJwk.toKey());&#xA;assert pubKey.equals(pubJwk.toKey());&#xA;&#xA;byte[] utf8Bytes = new JacksonSerializer().serialize(privJwk); // or GsonSerializer(), etc&#xA;String jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);&#xA;Jwk&amp;lt;?&amp;gt; parsed = Jwks.parser().build().parse(jwkJson);&#xA;&#xA;assert parsed instanceof RsaPrivateJwk;&#xA;assert privJwk.equals(parsed);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwk-ecpub&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Elliptic Curve Public JWK&lt;/h3&gt; &#xA;&lt;p&gt;Example creating and parsing an Elliptic Curve Public JWK:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ECPublicKey key = (ECPublicKey) Jwts.SIG.ES512.keyPair().build().getPublic();&#xA;EcPublicJwk jwk = Jwks.builder().key(key).idFromThumbprint().build();&#xA;&#xA;assert jwk.getId().equals(jwk.thumbprint().toString());&#xA;assert key.equals(jwk.toKey());&#xA;&#xA;byte[] utf8Bytes = new JacksonSerializer().serialize(jwk); // or GsonSerializer(), etc&#xA;String jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);&#xA;Jwk&amp;lt;?&amp;gt; parsed = Jwks.parser().build().parse(jwkJson);&#xA;&#xA;assert parsed instanceof EcPublicJwk;&#xA;assert jwk.equals(parsed);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwk-ecpriv&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Elliptic Curve Private JWK&lt;/h3&gt; &#xA;&lt;p&gt;Example creating and parsing an Elliptic Curve Private JWK:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;KeyPair pair = Jwts.SIG.ES512.keyPair().build();&#xA;ECPublicKey pubKey = (ECPublicKey) pair.getPublic();&#xA;ECPrivateKey privKey = (ECPrivateKey) pair.getPrivate();&#xA;&#xA;EcPrivateJwk privJwk = Jwks.builder().key(privKey).idFromThumbprint().build();&#xA;EcPublicJwk pubJwk = privJwk.toPublicJwk();&#xA;&#xA;assert privJwk.getId().equals(privJwk.thumbprint().toString());&#xA;assert pubJwk.getId().equals(pubJwk.thumbprint().toString());&#xA;assert privKey.equals(privJwk.toKey());&#xA;assert pubKey.equals(pubJwk.toKey());&#xA;&#xA;byte[] utf8Bytes = new JacksonSerializer().serialize(privJwk); // or GsonSerializer(), etc&#xA;String jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);&#xA;Jwk&amp;lt;?&amp;gt; parsed = Jwks.parser().build().parse(jwkJson);&#xA;&#xA;assert parsed instanceof EcPrivateJwk;&#xA;assert privJwk.equals(parsed);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwk-edpub&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Edwards Elliptic Curve Public JWK&lt;/h3&gt; &#xA;&lt;p&gt;Example creating and parsing an Edwards Elliptic Curve (Ed25519, Ed448, X25519, X448) Public JWK (the JWT &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8037&#34;&gt;RFC 8037&lt;/a&gt; specification calls these &lt;code&gt;Octet&lt;/code&gt; keys, hence the &lt;code&gt;OctetPublicJwk&lt;/code&gt; interface names):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;PublicKey key = Jwks.CRV.Ed25519.keyPair().build().getPublic(); // or Ed448, X25519, X448&#xA;OctetPublicJwk&amp;lt;PublicKey&amp;gt; jwk = builder().octetKey(key).idFromThumbprint().build();&#xA;&#xA;assert jwk.getId().equals(jwk.thumbprint().toString());&#xA;assert key.equals(jwk.toKey());&#xA;&#xA;byte[] utf8Bytes = new JacksonSerializer().serialize(jwk); // or GsonSerializer(), etc&#xA;String jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);&#xA;Jwk&amp;lt;?&amp;gt; parsed = Jwks.parser().build().parse(jwkJson);&#xA;&#xA;assert parsed instanceof OctetPublicJwk;&#xA;assert jwk.equals(parsed);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a name=&#34;example-jwk-edpriv&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Edwards Elliptic Curve Private JWK&lt;/h3&gt; &#xA;&lt;p&gt;Example creating and parsing an Edwards Elliptic Curve (Ed25519, Ed448, X25519, X448) Private JWK (the JWT &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8037&#34;&gt;RFC 8037&lt;/a&gt; specification calls these &lt;code&gt;Octet&lt;/code&gt; keys, hence the &lt;code&gt;OctetPrivateJwk&lt;/code&gt; and &lt;code&gt;OctetPublicJwk&lt;/code&gt; interface names):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;KeyPair pair = Jwks.CRV.Ed448.keyPair().build(); // or Ed25519, X25519, X448&#xA;PublicKey pubKey = pair.getPublic();&#xA;PrivateKey privKey = pair.getPrivate();&#xA;&#xA;OctetPrivateJwk&amp;lt;PrivateKey, PublicKey&amp;gt; privJwk = builder().octetKey(privKey).idFromThumbprint().build();&#xA;OctetPublicJwk&amp;lt;PublicKey&amp;gt; pubJwk = privJwk.toPublicJwk();&#xA;&#xA;assert privJwk.getId().equals(privJwk.thumbprint().toString());&#xA;assert pubJwk.getId().equals(pubJwk.thumbprint().toString());&#xA;assert privKey.equals(privJwk.toKey());&#xA;assert pubKey.equals(pubJwk.toKey());&#xA;&#xA;byte[] utf8Bytes = new JacksonSerializer().serialize(privJwk); // or GsonSerializer(), etc&#xA;String jwkJson = new String(utf8Bytes, StandardCharsets.UTF_8);&#xA;Jwk&amp;lt;?&amp;gt; parsed = Jwks.parser().build().parse(jwkJson);&#xA;&#xA;assert parsed instanceof OctetPrivateJwk;&#xA;assert privJwk.equals(parsed);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Learn More&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stormpath.com/blog/jjwt-how-it-works-why/&#34;&gt;JSON Web Token for Java and Android&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stormpath.com/blog/jwt-java-create-verify/&#34;&gt;How to Create and Verify JWTs in Java&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage/&#34;&gt;Where to Store Your JWTs - Cookies vs HTML5 Web Storage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stormpath.com/blog/jwt-the-right-way/&#34;&gt;Use JWT the Right Way!&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stormpath.com/blog/token-auth-for-java/&#34;&gt;Token Authentication for Java Applications&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jwtk/jjwt/master/CHANGELOG.md&#34;&gt;JJWT Changelog&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Maintained by Les Hazlewood &amp;amp; the extended Java community &lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is open-source via the &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache 2.0 License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>