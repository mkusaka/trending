<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-21T01:29:13Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>01-ai/Descartes</title>
    <updated>2024-03-21T01:29:13Z</updated>
    <id>tag:github.com,2024-03-21:/01-ai/Descartes</id>
    <link href="https://github.com/01-ai/Descartes" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;div id=&#34;top&#34;&gt;&lt;/div&gt; &#xA;&lt;h1&gt;Descartes（笛卡尔向量数据库）&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E9%87%8D%E8%A6%81%E8%AF%B4%E6%98%8E&#34;&gt;重要说明&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B&#34;&gt;项目简介&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E4%BC%98%E5%8A%BF&#34;&gt;优势&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E5%8A%9F%E8%83%BD&#34;&gt;功能&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B&#34;&gt;快速上手&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82&#34;&gt;系统要求&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E7%B4%A2%E5%BC%95%E9%85%8D%E7%BD%AE&#34;&gt;索引配置&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E&#34;&gt;接口说明&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B&#34;&gt;使用示例&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B&#34;&gt;性能评测&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E5%8F%AC%E5%9B%9E%E4%B8%8E-qps-%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94&#34;&gt;召回与 QPS 结果对比&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#qps-%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94&#34;&gt;QPS 结果对比&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E6%8A%80%E6%9C%AF%E7%89%B9%E6%80%A7&#34;&gt;技术特性&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E5%85%A8%E5%AF%BC%E8%88%AA%E5%9B%BE&#34;&gt;全导航图&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E8%87%AA%E9%80%82%E5%BA%94%E9%82%BB%E5%B1%85%E9%80%89%E6%8B%A9&#34;&gt;自适应邻居选择&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E8%BF%9E%E9%80%9A%E6%80%A7%E4%BF%9D%E9%9A%9C&#34;&gt;连通性保障&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E5%86%97%E4%BD%99%E9%82%BB%E5%B1%85%E6%B6%88%E9%99%A4&#34;&gt;冗余邻居消除&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96&#34;&gt;索引结构优化&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E4%B8%A4%E7%BA%A7%E9%87%8F%E5%8C%96&#34;&gt;两级量化&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E4%BC%98%E5%8C%96&#34;&gt;索引构建优化&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E9%80%89%E5%9E%8B%E8%80%83%E9%87%8F&#34;&gt;选型考量&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%BA%90&#34;&gt;更多资源&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;重要说明&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/01-ai/Descartes&#34;&gt;笛卡尔（Descartes）&lt;/a&gt;是&lt;a href=&#34;https://www.lingyiwanwu.com/&#34;&gt;零一万物（01.AI）&lt;/a&gt;基于 RAG 的初步尝试。为了让各界关注 Descartes 的朋友尽早体验它的能力，零一万物即日起开放搜索内核 Binary 给大家使用，并提供免费商用。如需申请免费商用授权，请填写&lt;a href=&#34;https://www.lingyiwanwu.com/vector-descartes&#34;&gt;表单&lt;/a&gt;。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;开放搜索内核 Binary 和发布现有 README 是第一阶段工作，近期会按序发布更多相关工具和技术内容，敬请期待。同时，零一万物会持续专注研发和分享，为开发者带来更好的技术和体验。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Descartes 将用在近期即将正式亮相的 AI 产品中，未来也会基于需求情况，以友好地方式提供体验服务。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;right&#34;&gt; [ &lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#top&#34;&gt;返回顶部 ⬆️ &lt;/a&gt; ] &lt;/p&gt; &#xA;&lt;h1&gt;项目简介&lt;/h1&gt; &#xA;&lt;p&gt;Descartes 是零一万物自研的向量数据库，其搜索内核通过全导航图、自适应邻居选择、两级量化等技术，既能保证&lt;strong&gt;超高精度（大于 99%）&lt;/strong&gt;，又能实现&lt;strong&gt;超高性能（千万数据量毫秒级响应）&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;优势&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;超高精度：基于多层缩略图和坐标系实现层间导航和图上方位导航，以及图连通性保障，实现精度大于 99%。相同性能下，精度大幅领先业内水平。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;超高性能：高效的边选择和裁剪技术，千万数据量毫秒级响应。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;功能&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;支持原始图和量化图。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;支持流式构建，纯内存模式。后续将根据使用需求，可能考虑开放全量构建。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;支持单精度浮点数。近期会开放支持更多数据类型（例如，双精度浮点数、int16 和 int8 向量类型）。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;支持欧式和 Angular。近期会开放支持更多度量（例如，点积和汉明距离）。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;right&#34;&gt; [ &lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#top&#34;&gt;返回顶部 ⬆️ &lt;/a&gt; ] &lt;/p&gt; &#xA;&lt;h1&gt;快速上手&lt;/h1&gt; &#xA;&lt;h2&gt;系统要求&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Linux：Ubuntu 22.04 或更高版本&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;gcc: 11.4.0&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;cpuinfo flags：avx512f、mfma 和 mavx512bw&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;索引配置&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt; &lt;p&gt;由于涉及性能调优的参数较多，本次暂时开放部分参数。后续将根据使用需求，考虑开放更多参数或支持自动调参。&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;li&gt; &lt;p&gt;如果不太熟悉参数配置，性能表现可能无法达到最优。如需获取快速技术支持，欢迎联系 &lt;a href=&#34;mailto:yi@01.ai&#34;&gt;yi@01.ai&lt;/a&gt;。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code&gt;# vector type: float&#xA;vector.global.vector_type = float&#xA;&#xA;# dimension of vector:must less than maximum value of uint16_t&#xA;vector.global.dimension = 128&#xA;&#xA;# metric type: l2, square_l2, ip&#xA;vector.global.metric_type = square_l2&#xA;&#xA;# maximum document count&#xA;vector.global.max_doc_cnt = 1000000&#xA;&#xA;# index directory&#xA;vector.global.index_dir = /home/ubuntu/indexes&#xA;&#xA;# build result count:optional, default is 400&#xA;vector.fng.build.build_res_cnt = 500&#xA;&#xA;# maximum neighbor count:optional, default is 64, can&#39;t bigger than 255&#xA;vector.fng.build.max_neighbor_cnt = 32&#xA;&#xA;# search result count:optional, default is 400&#xA;vector.fng.search.search_res_cnt = 40&#xA;&#xA;vector.pqg.pq.subquantizer_cnt = 128&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;接口说明&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class GraphIndex {&#xA;public:&#xA;    GraphIndex() = default;&#xA;    virtual ~GraphIndex() = default;&#xA;&#xA;public:&#xA;    // index init from config file&#xA;    virtual int Init(const std::string &amp;amp;configFilePath) = 0;&#xA;    &#xA;    // add vector to index&#xA;    virtual int AddVector(const void *vector, size_t bytes, uint64_t key) = 0;&#xA;    &#xA;    // search vector in index with context&#xA;    virtual int Search(const void *vector, size_t bytes, SearchContext &amp;amp;context) = 0;&#xA;    &#xA;    // refine the index. Will quantize the index if  quantize is true&#xA;    virtual int RefineIndex(bool quantize) = 0;&#xA;    &#xA;    // dump index&#xA;    virtual int Dump() = 0;&#xA;    &#xA;    virtual uint32_t GetCurrentDocCnt() const = 0;&#xA;};&#xA;&#xA;// create index&#xA;std::shared_ptr&amp;lt;GraphIndex&amp;gt; CreateGraphIndex();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;使用示例&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;vector&amp;gt;&#xA;#include &amp;lt;string&amp;gt;&#xA;#include &amp;lt;assert.h&amp;gt;&#xA;&#xA;#include &#34;descartes_index.h&#34;&#xA;&#xA;using namespace descartes;&#xA;&#xA;int main()&#xA;{&#xA;    auto index = CreateGraphIndex();&#xA;    std::string file(&#34;./cfg&#34;);&#xA;    assert(index-&amp;gt;Init(file) == 0);&#xA;    int dims = 128;&#xA;    int cnt = 100000;&#xA;    std::vector&amp;lt;float&amp;gt; vecs(dims * cnt);&#xA;    for (size_t i = 0; i &amp;lt; vecs.size(); ++i) {&#xA;        vecs[i] = i;&#xA;    }&#xA;&#xA;&#xA;    for (int i = 0; i &amp;lt;cnt; ++i) {&#xA;        int ret = index-&amp;gt;AddVector(vecs.data() + i * dims, sizeof(float) * dims, i);&#xA;        assert(ret == 0);&#xA;    }&#xA;    assert(index-&amp;gt;RefineIndex(false) == 0);&#xA;&#xA;    SearchContext ctx;&#xA;    ctx.topk = 10;&#xA;    ctx.searchResCnt = 20;&#xA;    for (size_t i = 0; i &amp;lt; 100; ++i) {&#xA;        int ret = index-&amp;gt;Search(vecs.data() + i * dims, sizeof(float) * dims, ctx);&#xA;        assert(ret == 0);         &#xA;    }&#xA;    assert(index-&amp;gt;Dump() == 0);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p align=&#34;right&#34;&gt; [ &lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#top&#34;&gt;返回顶部 ⬆️ &lt;/a&gt; ] &lt;/p&gt; &#xA;&lt;h1&gt;性能评测&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;当前，ANN-Benchmarks 是全球范围内最权威和常用的向量检索技术性能评测榜单之一。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;本次测试零一万物严格还原 ANN-Benchmarks 官方测试条件，包括使用了相同的硬件（AWS 的 r6i.16xlarge）及参数（并发为 31 且禁用了超线程 ），在离线状态下完成。如需还原 ANN-Benchmarks 测试，参阅&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/ann-algo/ann-benchmarks.md&#34;&gt;还原步骤&lt;/a&gt;。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;本次测试时间为 2024 年 3 月 1 日。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;召回与 QPS 结果对比&lt;/h2&gt; &#xA;&lt;p&gt;从 ANN-Benchmarks 测试结果可以看出，Descartes 登顶 6 份数据集评测第一名，比之前榜单上同业第一名有显著性能提升，部分数据集上的性能提升甚至超过 2 倍以上。&lt;/p&gt; &#xA;&lt;p&gt;本次测试 6 份评测数据集涵盖 6 大数据集：glove-25-angular、glove-100-angular、sift-128-euclidean、nytimes-256-angular、fashion-mnist-784-euclidean、gist-960-euclidean。&lt;/p&gt; &#xA;&lt;p&gt;其中，横坐标代表召回，纵坐标代表 QPS（每秒内处理的请求数）。&lt;strong&gt;曲线位置越偏右上角意味着算法性能越好&lt;/strong&gt;。可以看出，Descartes 在 6 项数据集评测中都处于最高位。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;glove-25-angular 数据集&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/docs/assets/glove-25-angular.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;glove-100-angular 数据集&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/docs/assets/glove-100-angular.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;sift-128-euclidean 数据集&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/docs/assets/sift-128-euclidean.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;nytimes-256-angular 数据集&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/docs/assets/nytimes-256-angular.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;fashion-mnist-784-euclidean 数据集&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/docs/assets/fashion-mnist-784-euclidean.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;gist-960-euclidean 数据集&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/docs/assets/gist-960-euclidean.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;QPS 结果对比&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;QPS 是衡量信息检索系统（例如，搜索引擎或数据库）查询处理能力的重要指标。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;在原榜单 TOP1 基础上，Descartes 搜索内核实现了显著性能提升，部分数据集上的性能提升超过 2 倍以上，在 gist-960-euclidean 数据集维度更大幅领先榜单原 TOP1 286%。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;下图是 90% 召回时 QPS 对比。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/docs/assets/qps.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;right&#34;&gt; [ &lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#top&#34;&gt;返回顶部 ⬆️ &lt;/a&gt; ] &lt;/p&gt; &#xA;&lt;h1&gt;技术特性&lt;/h1&gt; &#xA;&lt;p&gt;Descartes 搜索内核在处理复杂查询、提高检索效率以及优化数据存储方面相比业界拥有显著的比较优势。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;RAG 向量检索主要解决的问题&lt;/th&gt; &#xA;   &lt;th&gt;Descartes 技术特性&lt;/th&gt; &#xA;   &lt;th&gt;业界现状&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;减少检索考察的候选集&lt;br&gt;（通过建立某种索引结构）&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E5%85%A8%E5%AF%BC%E8%88%AA%E5%9B%BE&#34;&gt;全导航图&lt;/a&gt; &lt;br&gt;&lt;br&gt;自研图上坐标系导航，既能保证&lt;strong&gt;超高精度（大于 99%）&lt;/strong&gt;，又能实现&lt;strong&gt;超高性能（千万数据量下毫秒级响应）&lt;/strong&gt;。&lt;/td&gt; &#xA;   &lt;td&gt;通过哈希、KD-Tree、VP-Tree 或随机等方式，导航效果不够精确，裁剪力度不够。&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;（同上）&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E8%87%AA%E9%80%82%E5%BA%94%E9%82%BB%E5%B1%85%E9%80%89%E6%8B%A9&#34;&gt;自适应邻居选择&lt;/a&gt; &lt;br&gt;&lt;br&gt;首创自适应邻居选择策略，较大提升了 RAG &lt;strong&gt;向量检索性能&lt;/strong&gt;。&lt;/td&gt; &#xA;   &lt;td&gt;没有或者简单的边选择，容易陷入局部最优，潜力挖掘不充分。&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;降低单个向量计算的复杂度&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#%E4%B8%A4%E7%BA%A7%E9%87%8F%E5%8C%96&#34;&gt;两级量化&lt;/a&gt;&lt;br&gt;&lt;br&gt;相比于传统 PQ 查表，&lt;strong&gt;性能大幅提升 2-3 倍&lt;/strong&gt;。&lt;/td&gt; &#xA;   &lt;td&gt;简单 PQ 量化，在量化本身，以及索引存储上没有特别处理，无法更进一步发挥硬件能力。&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;全导航图&lt;/h2&gt; &#xA;&lt;p&gt;向量数据库中最核心的技术是「向量检索技术」。随着向量检索技术的不断发展，实践已经证明「基于图的最近邻算法」在检索的精度和性能上脱颖而出，成为了向量检索的主流技术。&lt;/p&gt; &#xA;&lt;p&gt;因此，零一万物自研了「全导航图」，其本质也是图算法的一种。全局多层缩略图导航技术，图上坐标系导航，既能保证超高精度，又能实现超高性能。&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/docs/assets/navigation.png&#34; width=&#34;400&#34; height=&#34;400&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;如上图所示，「全导航图」由 2 层次导航组成：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;第 1 层次导航：与 HNSW 一样，类似传统的跳表思想，通过逐层缩略全局图来实现导航效果。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;第 2 层次导航：体现在每一层图上，通过以每个节点为坐标原点，其邻居通过坐标系来分组存储，考虑不同的数据分布情况，根据配置可以有不同的分组方式。例如：&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Layer 2：检索时从 Layer 2 的红色点作为入口点开始检索，查询向量 q 参照红色节点建立的坐标系可以快速定位需要考察的邻居组，从而过滤掉大量不必要的计算。&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Layer 1：在当前层没有更近的节点时，检索进入下一层（Layer 1）继续遍历。&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Layer 0：在进入到 Layer 0 后，检索逻辑和上层图稍有不同。上层图的目标是找好 Layer 0 上的入口点，加速检索的收敛，而在 Layer 0 的目标是找到真实的最近邻。考虑到一些特殊情况（例如，和你不在一个组内的节点也可能是你最终的最近邻），因此需要做一些额外处理。所以，先在全局最近的节点周边探测，往外扩后可以继续参考坐标系来定位需要计算的邻居组。&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;自适应邻居选择&lt;/h2&gt; &#xA;&lt;p&gt;零一万物自研的「自适应邻居选择策略」，突破了以往全依赖真实 topk 或固定边选择策略的局限，使每个节点可以根据自身及邻居的分布特征，动态地选取最佳邻居边，更快收敛接近目标向量。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;通常图构建好以后，我们用一个节点其邻居边与这个节点真实的 topk 的重合度来描述图的质量。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;但实践表明，如果我们以真实 topk 作为邻居边，不仅构建的时间代价巨大，而且检索效果也不是很理想，反而 RNG 类算法具有更好的检索性能，这是因为他们普遍加入了「邻居边选择策略」。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;目前主流的「邻居边选择策略」有两类：基于「边长短」来决定边保留（例如，HNSW、NSG、NGT 等）或根据「角度」来决定是否保留边（例如，NSSG）。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;从本质上讲，这两种方法都是让图的延展性更好，从而获得更佳的检索性能，但他们普遍的一个问题是没有考虑每个节点及其邻居的分布，一刀切地采用相同策略。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;在实践中，向量空间必然存在各种不同的空间分布。例如，有的密集分布在一起，这时需要加大边间隔选择；有的偏向明显，这时不能只选择某个集中方向的邻居边。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;因此，零一万物自研「自适应邻居边选择」策略，让每个节点能够根据自身和邻居的相对分布，来决策应该选择哪些邻居作为最终的邻居边，既能保证足够延展性，避免陷入局部最优；又能根据边强度裁剪多余边，避免向量被反复探测。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;right&#34;&gt; [ &lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#top&#34;&gt;返回顶部 ⬆️ &lt;/a&gt; ] &lt;/p&gt; &#xA;&lt;h2&gt;连通性保障&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;通常而言，在较大向量数据集上，构建好的图难免会有孤立的节点。例如，整个向量空间被切分为了很多互相不联通的子图，甚至很多节点根本没有入边，成为真正的孤点。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;如果不对图做任何处理，相互割裂的子图，必然导致检索性能很差，检索精度也无法保障。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;因此，零一万物开发了图的连通性保障策略，从全局入口点开始，遍历所有节点。当发现有孤立点时，会从图上建立一条边到孤立点，同时保障被替换的点的入度必须满足一定的阈值，否则容易导致按下葫芦浮起瓢，最终无法实现连通性保障。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;冗余邻居消除&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;在连通性保障措施后，图相对就比较完整了，但还存在一个问题：里面存在较多的冗余信息，即对一个节点而言，「它的邻居边」和「它邻居的邻居边」有大量重合。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;在检索的过程中，如果检索路径遍历这个节点和它的一个邻居节点，由于这两个节点的邻居边存在较大重复，因此，最终遍历两个节点考察的向量数其实没有太多扩展。此时，为了更高的召回，需要考察更多的节点，会导致性能恶化。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;为了消除冗余邻居，零一万物根据邻居边相对于当前节点的强度，来裁剪冗余边。例如，假设有 V1、V2 和 V3 三个节点，通过 V1 的邻居表能遍历到 V2。&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;如果 V3 同时是 V1 和 V2 的邻居，那么没有必要让 V1 和 V2 都保留作为 V3 的邻居。&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;如果 V3 离 V2 更近，由于通过 V2 可以遍历到 V3，那么在 V1 邻居表中，可以直接裁剪 V3，而裁掉的 V3 空缺可以填入更有用的邻居边。这样既不会破坏连通性，也能降低 V1 和 V2 的信息冗余度。&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;索引结构优化&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;传统图方法在索引结构上都没有特意布局，大多算法只是简单利用 prefetch 指令来提升性能。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;为了充分利用硬件特性，零一万物根据检索过程的 workload，按照访问的顺序排列索引结构，尽可能让缓存命中率提升，让消耗的内存带宽都能物尽其用。各种数据结构的大小都贴近 2 的指数幂大小，从而让乘法操作转化为移位操作。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;内存尽可能按缓存行大小对齐，防止跨越缓存行导致多余的访问。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;多层图的全局入口点使用全局向量空间的质心，减少随机选择可能造成的过度偏离，避免增加无谓的计算量。以入口点为基础重新排列向量布局，使得经常访问的向量能够在缓存中命中，从而进一步提升缓存命中率。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;两级量化&lt;/h2&gt; &#xA;&lt;p&gt;零一万物通过两层量化，将 float 类型量化到 int8，大幅减少检索过程中需要的带宽和计算量。&lt;/p&gt; &#xA;&lt;p&gt;同时，列式存储充分利用 avx512 的单指令多数据特性，进一步发挥硬件能力。相比传统 PQ 查表，性能得到大幅提升到 2-3 倍。&lt;/p&gt; &#xA;&lt;h2&gt;索引构建优化&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;当前，业内有 2 类常见索引构建方法：&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;第 1 类：类似 HNSW 的传统流式构建向量索引。每次构建相当于一次查找过程，随着图中向量不断增加，索引构建会越来越慢，根本原因是每次向量的加入都是一次全新的独立过程，导致了很多重复计算。&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;第 2 类：nn-descent 方法。通过不断地迭代，较好地共享了之前的计算结果，但在多线程的并发度上有些瑕疵，大量的上锁和内存拷贝导致效率没有充分发挥。&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;为了加快构建速度，零一万物研发了全量迭代方法来构建索引，通过标记邻居边状态，并充分利用好局部性原理，大幅提高了索引的并发构建效率。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;right&#34;&gt; [ &lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#top&#34;&gt;返回顶部 ⬆️ &lt;/a&gt; ] &lt;/p&gt; &#xA;&lt;h1&gt;选型考量&lt;/h1&gt; &#xA;&lt;p&gt;零一万物在研发 Descartes 搜索内核时，学习和参考了多种经典思路。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;HNSW。在设计全导航图的第一层时，零一万物参考了 HNSW 的思路。为了更好地提升导航效果，Descartes 同时在「入口点选择节点图层的投影」和「邻居边选择」采用了不同的策略，并增加了连通性保障、冗余邻居消除等方法，大幅提高了检索效果。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NGT。在早期研究阶段，零一万物参考过 NGT 的思路，但在实际测试过程中，但发现它有不少问题。例如，由于它是树 + 图的组合方式，邻居表可能无限膨胀，这会造成建索引时对内存需求过大、且构建十分耗时，导致 gist-960-euclidean 数据集无法在 ANN-Benchmarks 运行环境上稳定地建出索引。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;ScaNN。Google 推出 ScaNN 时，它的关键词是一种新的量化方式（各项特异量化），擅长解决 MIPS 问题。考虑到工程实现的有效性，零一万物选择了更高效的两级量化方式。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;right&#34;&gt; [ &lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#top&#34;&gt;返回顶部 ⬆️ &lt;/a&gt; ] &lt;/p&gt; &#xA;&lt;h1&gt;更多资源&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/3-_KUz7JCTwDbpr1-B5sdA&#34;&gt;零一万物开放笛卡尔向量数据库搜索内核，免费商用&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;right&#34;&gt; [ &lt;a href=&#34;https://raw.githubusercontent.com/01-ai/Descartes/main/#top&#34;&gt;返回顶部 ⬆️ &lt;/a&gt; ] &lt;/p&gt;</summary>
  </entry>
</feed>