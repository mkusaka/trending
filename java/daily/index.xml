<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Java Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-30T01:37:29Z</updated>
  <subtitle>Daily Trending of Java in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zongzibinbin/MallChat</title>
    <updated>2023-05-30T01:37:29Z</updated>
    <id>tag:github.com,2023-05-30:/zongzibinbin/MallChat</id>
    <link href="https://github.com/zongzibinbin/MallChat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;mallchat的后端项目，是一个既能购物又能聊天的电商系统。以互联网企业级开发规范的要求来实现它，电商该有的购物车，订单，支付，推荐，搜索，拉新，促活，推送，物流，客服，它都必须有。持续更新ing。。（点个star，不迷路）&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/05/04/p9NC50f.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;MallChat的后端项目，是一个既能购物又能即时聊天的电商系统。致力于打造互联网企业级项目的最佳实践。电商该有的购物车，订单，支付，推荐，搜索，拉新，促活，推送，物流，客服，它都必须有。持续更新ing~~(记得star啊喂！)&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;#公众号&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/公众号-程序员阿斌-blue.svg?style=plasticr&#34;&gt;&lt;/a&gt; &lt;a href=&#34;#公众号&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/交流群-加入开发-green.svg?style=plasticr&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/zongzibinbin/MallChat&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/github-项目地址-yellow.svg?style=plasticr&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitee.com/zhongzhibinbin/MallChat&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/码云-项目地址-orange.svg?style=plasticr&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Evansy/MallChatWeb&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/前端-项目地址-blueviolet.svg?style=plasticr&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;项目导航&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;快速体验地址&lt;/strong&gt;：&lt;a href=&#34;https://mallchat.cn&#34;&gt;抹茶聊天首页&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;前端项目仓库&lt;/strong&gt;：&lt;a href=&#34;https://github.com/Evansy/MallChatWeb&#34;&gt;MallChatWeb&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;项目视频记录&lt;/strong&gt;：&lt;a href=&#34;https://space.bilibili.com/146719540&#34;&gt;Bilibili地址&lt;/a&gt; 全程分享项目进度，功能选型的思考，同时征集迭代建议。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;项目学习文档&lt;/strong&gt;：10w+字，保姆级教学路线，环境搭建、核心功能、基建轮子、接口压测、问题记录、一个不落。可点击&lt;a href=&#34;https://www.yuque.com/snab/planet/cef1mcko4fve0ur3&#34;&gt;抹茶项目文档&lt;/a&gt;查看（内含500人交流大群）&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;项目交流群&lt;/strong&gt;：对抹茶感兴趣的，可以加入&lt;a href=&#34;https://raw.githubusercontent.com/zongzibinbin/MallChat/main/#%E5%85%AC%E4%BC%97%E5%8F%B7&#34;&gt;交流群&lt;/a&gt;。你的每一个举动，都会决定项目未来的方向。无论是提意见做产品经理，还是找bug做个测试人员，又或者加入开发小模块成为contributer，都欢迎你的加入。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;码云仓库&lt;/strong&gt;：&lt;a href=&#34;https://gitee.com/zhongzhibinbin/MallChat&#34;&gt;https://gitee.com/zhongzhibinbin/MallChat&lt;/a&gt; （国内访问速度更快）&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;项目介绍&lt;/h2&gt; &#xA;&lt;p&gt;抹茶聊天是一个IM项目，通过netty实现和前端的websocket连接。内含微信扫描登录，成员列表，上下线动画，消息列表，消息互动，还有很多实用的小轮子列如aop日志，分布式锁注解，频控注解，ip解析归属地等，持续更新中。。。&lt;/p&gt; &#xA;&lt;h3&gt;项目演示&lt;/h3&gt; &#xA;&lt;h4&gt;C端项目&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;前端项目地址：&lt;a href=&#34;https://github.com/Evansy/MallChatWeb&#34;&gt;https://github.com/Evansy/MallChatWeb&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;项目演示地址：&lt;a href=&#34;https://mallchat.cn&#34;&gt;https://mallchat.cn&lt;/a&gt; (记住抹茶.cn，下次工作摸鱼可直接打开)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/05/15/p92nKne.png&#34; alt=&#34;p92nKne.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;技术选型&lt;/h3&gt; &#xA;&lt;h4&gt;后端技术&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;技术&lt;/th&gt; &#xA;   &lt;th&gt;说明&lt;/th&gt; &#xA;   &lt;th&gt;官网&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;SpringBoot&lt;/td&gt; &#xA;   &lt;td&gt;web开发必备框架&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://spring.io/projects/spring-boot&#34;&gt;https://spring.io/projects/spring-boot&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;MyBatis&lt;/td&gt; &#xA;   &lt;td&gt;ORM框架&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;http://www.mybatis.org/mybatis-3/zh/index.html&#34;&gt;http://www.mybatis.org/mybatis-3/zh/index.html&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;MyBatisPlus&lt;/td&gt; &#xA;   &lt;td&gt;零sql，简化数据库操作，分页插件&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://baomidou.com/&#34;&gt;https://baomidou.com/&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Redis&lt;/td&gt; &#xA;   &lt;td&gt;缓存加速，多数据结构支持业务功能&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://redis.io&#34;&gt;https://redis.io&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Caffeine&lt;/td&gt; &#xA;   &lt;td&gt;本地缓存&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;http://caffe.berkeleyvision.org/&#34;&gt;http://caffe.berkeleyvision.org/&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Nginx&lt;/td&gt; &#xA;   &lt;td&gt;负载均衡，https配置，websocket升级，ip频控&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://nginx.org&#34;&gt;https://nginx.org&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Docker&lt;/td&gt; &#xA;   &lt;td&gt;应用容器引擎&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.docker.com&#34;&gt;https://www.docker.com&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Oss&lt;/td&gt; &#xA;   &lt;td&gt;对象存储&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://letsencrypt.org/&#34;&gt;https://letsencrypt.org/&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Jwt&lt;/td&gt; &#xA;   &lt;td&gt;用户登录，认证方案&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://jwt.io&#34;&gt;https://jwt.io&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Lombok&lt;/td&gt; &#xA;   &lt;td&gt;简化代码&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://projectlombok.org&#34;&gt;https://projectlombok.org&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Hutool&lt;/td&gt; &#xA;   &lt;td&gt;Java工具类库&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/looly/hutool&#34;&gt;https://github.com/looly/hutool&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Swagger-UI&lt;/td&gt; &#xA;   &lt;td&gt;API文档生成工具&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/swagger-api/swagger-ui&#34;&gt;https://github.com/swagger-api/swagger-ui&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Hibernate-validator&lt;/td&gt; &#xA;   &lt;td&gt;接口校验框架&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zongzibinbin/MallChat/main/hibernate.org/validator/&#34;&gt;hibernate.org/validator/&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;前端技术&lt;/h4&gt; &#xA;&lt;p&gt;见&lt;a href=&#34;https://github.com/Evansy/MallChatWeb&#34;&gt;MallChatWeb&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;环境搭建&lt;/h3&gt; &#xA;&lt;p&gt;在项目目录下的&lt;code&gt;application.yml&lt;/code&gt;修改自己的启动环境&lt;code&gt;spring.profiles.active&lt;/code&gt; = &lt;code&gt;test&lt;/code&gt;然后找到同级文件&lt;code&gt;application-test.properties&lt;/code&gt;，填写自己的环境配置。&lt;a href=&#34;https://www.yuque.com/snab/planet/cne0nel2hny8eu4i&#34;&gt;星球成员&lt;/a&gt;提供一套测试环境配置，可直连&lt;/p&gt; &#xA;&lt;h3&gt;项目文档&lt;/h3&gt; &#xA;&lt;p&gt;保姆级教学路线，环境搭建、核心功能、基建轮子、接口压测、问题记录、项目亮点一个不落。点击&lt;a href=&#34;https://www.yuque.com/snab/planet/cef1mcko4fve0ur3&#34;&gt;项目文档&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;更多有趣功能在持续更新中。。。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/05/15/p92Qa2q.png&#34; alt=&#34;p92Qa2q.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;star 趋势图&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://starchart.cc/zongzibinbin/MallChat.svg?sanitize=true&#34; alt=&#34;Stargazers over time&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;贡献者&lt;/h2&gt; &#xA;&lt;a href=&#34;https://github.com/zongzibinbin/MallChat/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=zongzibinbin/MallChat&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;公众号&lt;/h2&gt; &#xA;&lt;p&gt;微信搜索 &lt;strong&gt;阿斌Java之路&lt;/strong&gt; 关注我的原创公众号，后台回复「&lt;strong&gt;抹茶&lt;/strong&gt;」即可加入抹茶交流群，一些做过公司万人群聊，高并发的小伙伴都在里面讨论方案。公众号也会经常更新项目相关的文档，等你来撩~~&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2023/05/15/p9211Ag.png&#34; alt=&#34;p9211Ag.png&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>amnesica/KryptEY</title>
    <updated>2023-05-30T01:37:29Z</updated>
    <id>tag:github.com,2023-05-30:/amnesica/KryptEY</id>
    <link href="https://github.com/amnesica/KryptEY" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Android keyboard for secure E2EE communication through the signal protocol in any messenger. Communicate securely and independent, regardless of the legal situation or whether messengers use E2EE&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/static/logo/logo.png&#34; height=&#34;150&#34; title=&#34;KryptEY Logo&#34;&gt; &lt;/p&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt;KryptEY - Secure E2EE communication&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/version-v0.1.5-brightgreen&#34; alt=&#34;GitHub version&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/chatkontrolle-stoppen-blueviolet&#34; alt=&#34;Chatkontrolle stoppen&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/stop-scanning%20me-blueviolet&#34; alt=&#34;Stop scanning me&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;An Android keyboard for secure end-to-end-encrypted messages through the signal protocol in any messenger. Communicate securely and independent, regardless of the legal situation or whether messengers use E2EE. No server needed.&lt;/p&gt; &#xA;&lt;p&gt;KryptEY was created by &lt;a href=&#34;https://github.com/mellitopia&#34;&gt;mellitopia&lt;/a&gt; and &lt;a href=&#34;https://github.com/amnesica&#34;&gt;amnesica&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Breaking of end-to-end encryption (E2EE) by laws such as the planned EU chat control is an ongoing issue. Content in messengers that use E2EE, such as Whatsapp or Signal, could thus be monitored by third parties. E2EE is often, but not always, standard in messengers. There are proven methods for E2EE such as PGP. However, these methods are sometimes cumbersomely integrated and require a lot of effort to use.&lt;/p&gt; &#xA;&lt;p&gt;KryptEY is an Android keyboard that implements the Signal protocol. The keyboard works messenger-independently and both the X3DH Key Agreement Protocol and the Double Ratchet Algorithm work without a server, thus it enables a highly independent use of the protocol.&lt;/p&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;div style=&#34;display:flex&#34; align=&#34;center&#34;&gt; &#xA; &lt;img alt=&#34;App image&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/fastlane/metadata/android/en-US/images/phoneScreenshots/01.jpg&#34; width=&#34;10.5%&#34;&gt; &#xA; &lt;img alt=&#34;App image&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/fastlane/metadata/android/en-US/images/phoneScreenshots/02.jpg&#34; width=&#34;10.5%&#34;&gt; &#xA; &lt;img alt=&#34;App image&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/fastlane/metadata/android/en-US/images/phoneScreenshots/03.jpg&#34; width=&#34;10.5%&#34;&gt; &#xA; &lt;img alt=&#34;App image&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/fastlane/metadata/android/en-US/images/phoneScreenshots/04.jpg&#34; width=&#34;10.5%&#34;&gt; &#xA; &lt;img alt=&#34;App image&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/fastlane/metadata/android/en-US/images/phoneScreenshots/05.jpg&#34; width=&#34;10.5%&#34;&gt; &#xA; &lt;img alt=&#34;App image&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/fastlane/metadata/android/en-US/images/phoneScreenshots/06.jpg&#34; width=&#34;10.5%&#34;&gt; &#xA; &lt;img alt=&#34;App image&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/fastlane/metadata/android/en-US/images/phoneScreenshots/07.jpg&#34; width=&#34;10.5%&#34;&gt; &#xA; &lt;img alt=&#34;App image&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/fastlane/metadata/android/en-US/images/phoneScreenshots/08.jpg&#34; width=&#34;10.5%&#34;&gt; &#xA; &lt;img alt=&#34;App image&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/fastlane/metadata/android/en-US/images/phoneScreenshots/09.jpg&#34; width=&#34;10.5%&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Based upon the &lt;a href=&#34;https://github.com/rkkr/simple-keyboard&#34;&gt;Simple Keyboard&lt;/a&gt; KryptEY adds a view above the Keyboard for the E2EE functionality.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;use E2EE through Signal Protocol in any messenger&lt;/li&gt; &#xA; &lt;li&gt;encryption/decryption of messages&lt;/li&gt; &#xA; &lt;li&gt;enter message through separate text field in keyboard&lt;/li&gt; &#xA; &lt;li&gt;use clipboard to read messages&lt;/li&gt; &#xA; &lt;li&gt;manage contacts in own contact list in keyboard&lt;/li&gt; &#xA; &lt;li&gt;message log to view sent/received messages&lt;/li&gt; &#xA; &lt;li&gt;send messages as plain JSON (raw mode) or hidden in a decoy text (fairytale mode)&lt;/li&gt; &#xA; &lt;li&gt;verification of E2EE functionality via fingerprint&lt;/li&gt; &#xA; &lt;li&gt;Q&amp;amp;A view helps with questions&lt;/li&gt; &#xA; &lt;li&gt;dark &amp;amp; light theme&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/KRYPTEY.md&#34;&gt;this&lt;/a&gt; document for further information on how KryptEY is working.&lt;/p&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;Conversation between Alice (left) and Bob (right) in the Signal Messenger using KryptEY.&lt;/p&gt; &#xA;&lt;div style=&#34;display:flex;&#34; align=&#34;center&#34;&gt; &#xA; &lt;img alt=&#34;App image&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/static/screenshots/demo.gif&#34; width=&#34;80%&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://f-droid.org/en/packages/com.amnesica.kryptey/&#34;&gt;&lt;img alt=&#34;Get it on F-Droid&#34; src=&#34;https://gitlab.com/fdroid/artwork/-/raw/master/badge/get-it-on-en.png&#34; height=&#34;60&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://android.izzysoft.de/repo/apk/com.amnesica.kryptey&#34;&gt;&lt;img alt=&#34;Get it on IzzyOnDroid&#34; src=&#34;https://gitlab.com/IzzyOnDroid/repo/-/raw/master/assets/IzzyOnDroid.png&#34; height=&#34;60&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/amnesica/KryptEY/releases&#34;&gt;&lt;img alt=&#34;Get it on Github&#34; src=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/static/github/get-it-on-github.png&#34; height=&#34;60&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;KryptEY requires Android 8.0 or newer. If you need instructions on how to use the app, see our help &lt;a href=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/HELP.md&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Privacy&lt;/h2&gt; &#xA;&lt;p&gt;Read our privacy statement &lt;a href=&#34;https://raw.githubusercontent.com/amnesica/KryptEY/master/PRIVACY.md&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Permissions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;VIBRATE: Required for vibrations on key press&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;The existing security properties for the Signal Protocol are also valid for the keyboard.&lt;/p&gt; &#xA;&lt;p&gt;The elliptic curve X25519 with SHA-512 is used in the X3DH Key Agreement Protocol from the applied Signal library. The hash function SHA-256 is used for the various chains and AES-256 with CBC ( Pkcs#7) is used for the encryption of the messages. SHA-512 is also used to generate the fingerprint, the representation of the public key used for encryption.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;The keyboard was designed as a POC and only allows 1-to-1 conversations. However, the application can also be used in a group chat to a limited extent. Here, a message can be directed to a specific chat partner and not to all people. Other participants of the group chat cannot decrypt the message.&lt;/p&gt; &#xA;&lt;p&gt;Text messages in Telegram are getting copied as HTML and not as plain text. When decoding the message with the fairytale mode the copied message is compromised and can&#39;t be read properly. Therefore, it can&#39;t be decoded at all. However, the raw mode works properly. When using KryptEY with Telegram we recommend the raw mode.&lt;/p&gt; &#xA;&lt;p&gt;Some messengers like Threema only allows up to 3500 bytes per message. Therefore, different character input limitations apply. To stay under the 3500 bytes limit, only 500 characters are allowed for raw and fairytale mode. For convenience these limitation applies for all messengers.&lt;/p&gt; &#xA;&lt;h2&gt;Used libraries&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/signalapp/libsignal&#34;&gt;Signal Protocol (android)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/FasterXML/jackson&#34;&gt;Jackson&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/protocolbuffers/protobuf/tree/main/java&#34;&gt;Protobuf (lite)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/junit-team/junit4&#34;&gt;JUnit4&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://android.googlesource.com/platform/packages/inputmethods/LatinIME/&#34;&gt;AOSP Keyboard&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rkkr/simple-keyboard&#34;&gt;Simple Keyboard&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/openboard-team/openboard&#34;&gt;OpenBoard&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/florisboard/florisboard&#34;&gt;FlorisBoard&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>square/javapoet</title>
    <updated>2023-05-30T01:37:29Z</updated>
    <id>tag:github.com,2023-05-30:/square/javapoet</id>
    <link href="https://github.com/square/javapoet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Java API for generating .java source files.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;JavaPoet&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;JavaPoet&lt;/code&gt; is a Java API for generating &lt;code&gt;.java&lt;/code&gt; source files.&lt;/p&gt; &#xA;&lt;p&gt;Source file generation can be useful when doing things such as annotation processing or interacting with metadata files (e.g., database schemas, protocol formats). By generating code, you eliminate the need to write boilerplate while also keeping a single source of truth for the metadata.&lt;/p&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;p&gt;Here&#39;s a (boring) &lt;code&gt;HelloWorld&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.example.helloworld;&#xA;&#xA;public final class HelloWorld {&#xA;  public static void main(String[] args) {&#xA;    System.out.println(&#34;Hello, JavaPoet!&#34;);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And this is the (exciting) code to generate it with JavaPoet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec main = MethodSpec.methodBuilder(&#34;main&#34;)&#xA;    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)&#xA;    .returns(void.class)&#xA;    .addParameter(String[].class, &#34;args&#34;)&#xA;    .addStatement(&#34;$T.out.println($S)&#34;, System.class, &#34;Hello, JavaPoet!&#34;)&#xA;    .build();&#xA;&#xA;TypeSpec helloWorld = TypeSpec.classBuilder(&#34;HelloWorld&#34;)&#xA;    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)&#xA;    .addMethod(main)&#xA;    .build();&#xA;&#xA;JavaFile javaFile = JavaFile.builder(&#34;com.example.helloworld&#34;, helloWorld)&#xA;    .build();&#xA;&#xA;javaFile.writeTo(System.out);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To declare the main method, we&#39;ve created a &lt;code&gt;MethodSpec&lt;/code&gt; &#34;main&#34; configured with modifiers, return type, parameters and code statements. We add the main method to a &lt;code&gt;HelloWorld&lt;/code&gt; class, and then add that to a &lt;code&gt;HelloWorld.java&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;In this case we write the file to &lt;code&gt;System.out&lt;/code&gt;, but we could also get it as a string (&lt;code&gt;JavaFile.toString()&lt;/code&gt;) or write it to the file system (&lt;code&gt;JavaFile.writeTo()&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://square.github.io/javapoet/1.x/javapoet/&#34;&gt;Javadoc&lt;/a&gt; catalogs the complete JavaPoet API, which we explore below.&lt;/p&gt; &#xA;&lt;h3&gt;Code &amp;amp; Control Flow&lt;/h3&gt; &#xA;&lt;p&gt;Most of JavaPoet&#39;s API uses plain old immutable Java objects. There&#39;s also builders, method chaining and varargs to make the API friendly. JavaPoet offers models for classes &amp;amp; interfaces (&lt;code&gt;TypeSpec&lt;/code&gt;), fields (&lt;code&gt;FieldSpec&lt;/code&gt;), methods &amp;amp; constructors (&lt;code&gt;MethodSpec&lt;/code&gt;), parameters (&lt;code&gt;ParameterSpec&lt;/code&gt;) and annotations (&lt;code&gt;AnnotationSpec&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;But the &lt;em&gt;body&lt;/em&gt; of methods and constructors is not modeled. There&#39;s no expression class, no statement class or syntax tree nodes. Instead, JavaPoet uses strings for code blocks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec main = MethodSpec.methodBuilder(&#34;main&#34;)&#xA;    .addCode(&#34;&#34;&#xA;        + &#34;int total = 0;\n&#34;&#xA;        + &#34;for (int i = 0; i &amp;lt; 10; i++) {\n&#34;&#xA;        + &#34;  total += i;\n&#34;&#xA;        + &#34;}\n&#34;)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void main() {&#xA;  int total = 0;&#xA;  for (int i = 0; i &amp;lt; 10; i++) {&#xA;    total += i;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The manual semicolons, line wrapping, and indentation are tedious and so JavaPoet offers APIs to make it easier. There&#39;s &lt;code&gt;addStatement()&lt;/code&gt; which takes care of semicolons and newline, and &lt;code&gt;beginControlFlow()&lt;/code&gt; + &lt;code&gt;endControlFlow()&lt;/code&gt; which are used together for braces, newlines, and indentation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec main = MethodSpec.methodBuilder(&#34;main&#34;)&#xA;    .addStatement(&#34;int total = 0&#34;)&#xA;    .beginControlFlow(&#34;for (int i = 0; i &amp;lt; 10; i++)&#34;)&#xA;    .addStatement(&#34;total += i&#34;)&#xA;    .endControlFlow()&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example is lame because the generated code is constant! Suppose instead of just adding 0 to 10, we want to make the operation and range configurable. Here&#39;s a method that generates a method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private MethodSpec computeRange(String name, int from, int to, String op) {&#xA;  return MethodSpec.methodBuilder(name)&#xA;      .returns(int.class)&#xA;      .addStatement(&#34;int result = 1&#34;)&#xA;      .beginControlFlow(&#34;for (int i = &#34; + from + &#34;; i &amp;lt; &#34; + to + &#34;; i++)&#34;)&#xA;      .addStatement(&#34;result = result &#34; + op + &#34; i&#34;)&#xA;      .endControlFlow()&#xA;      .addStatement(&#34;return result&#34;)&#xA;      .build();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And here&#39;s what we get when we call &lt;code&gt;computeRange(&#34;multiply10to20&#34;, 10, 20, &#34;*&#34;)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int multiply10to20() {&#xA;  int result = 1;&#xA;  for (int i = 10; i &amp;lt; 20; i++) {&#xA;    result = result * i;&#xA;  }&#xA;  return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Methods generating methods! And since JavaPoet generates source instead of bytecode, you can read through it to make sure it&#39;s right.&lt;/p&gt; &#xA;&lt;p&gt;Some control flow statements, such as &lt;code&gt;if/else&lt;/code&gt;, can have unlimited control flow possibilities. You can handle those options using &lt;code&gt;nextControlFlow()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec main = MethodSpec.methodBuilder(&#34;main&#34;)&#xA;    .addStatement(&#34;long now = $T.currentTimeMillis()&#34;, System.class)&#xA;    .beginControlFlow(&#34;if ($T.currentTimeMillis() &amp;lt; now)&#34;, System.class)&#xA;    .addStatement(&#34;$T.out.println($S)&#34;, System.class, &#34;Time travelling, woo hoo!&#34;)&#xA;    .nextControlFlow(&#34;else if ($T.currentTimeMillis() == now)&#34;, System.class)&#xA;    .addStatement(&#34;$T.out.println($S)&#34;, System.class, &#34;Time stood still!&#34;)&#xA;    .nextControlFlow(&#34;else&#34;)&#xA;    .addStatement(&#34;$T.out.println($S)&#34;, System.class, &#34;Ok, time still moving forward&#34;)&#xA;    .endControlFlow()&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void main() {&#xA;  long now = System.currentTimeMillis();&#xA;  if (System.currentTimeMillis() &amp;lt; now)  {&#xA;    System.out.println(&#34;Time travelling, woo hoo!&#34;);&#xA;  } else if (System.currentTimeMillis() == now) {&#xA;    System.out.println(&#34;Time stood still!&#34;);&#xA;  } else {&#xA;    System.out.println(&#34;Ok, time still moving forward&#34;);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Catching exceptions using &lt;code&gt;try/catch&lt;/code&gt; is also a use case for &lt;code&gt;nextControlFlow()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec main = MethodSpec.methodBuilder(&#34;main&#34;)&#xA;    .beginControlFlow(&#34;try&#34;)&#xA;    .addStatement(&#34;throw new Exception($S)&#34;, &#34;Failed&#34;)&#xA;    .nextControlFlow(&#34;catch ($T e)&#34;, Exception.class)&#xA;    .addStatement(&#34;throw new $T(e)&#34;, RuntimeException.class)&#xA;    .endControlFlow()&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which produces:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void main() {&#xA;  try {&#xA;    throw new Exception(&#34;Failed&#34;);&#xA;  } catch (Exception e) {&#xA;    throw new RuntimeException(e);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;$L for Literals&lt;/h3&gt; &#xA;&lt;p&gt;The string-concatenation in calls to &lt;code&gt;beginControlFlow()&lt;/code&gt; and &lt;code&gt;addStatement&lt;/code&gt; is distracting. Too many operators. To address this, JavaPoet offers a syntax inspired-by but incompatible-with &lt;a href=&#34;https://developer.android.com/reference/java/util/Formatter.html&#34;&gt;&lt;code&gt;String.format()&lt;/code&gt;&lt;/a&gt;. It accepts &lt;strong&gt;&lt;code&gt;$L&lt;/code&gt;&lt;/strong&gt; to emit a &lt;strong&gt;literal&lt;/strong&gt; value in the output. This works just like &lt;code&gt;Formatter&lt;/code&gt;&#39;s &lt;code&gt;%s&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private MethodSpec computeRange(String name, int from, int to, String op) {&#xA;  return MethodSpec.methodBuilder(name)&#xA;      .returns(int.class)&#xA;      .addStatement(&#34;int result = 0&#34;)&#xA;      .beginControlFlow(&#34;for (int i = $L; i &amp;lt; $L; i++)&#34;, from, to)&#xA;      .addStatement(&#34;result = result $L i&#34;, op)&#xA;      .endControlFlow()&#xA;      .addStatement(&#34;return result&#34;)&#xA;      .build();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Literals are emitted directly to the output code with no escaping. Arguments for literals may be strings, primitives, and a few JavaPoet types described below.&lt;/p&gt; &#xA;&lt;h3&gt;$S for Strings&lt;/h3&gt; &#xA;&lt;p&gt;When emitting code that includes string literals, we can use &lt;strong&gt;&lt;code&gt;$S&lt;/code&gt;&lt;/strong&gt; to emit a &lt;strong&gt;string&lt;/strong&gt;, complete with wrapping quotation marks and escaping. Here&#39;s a program that emits 3 methods, each of which returns its own name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws Exception {&#xA;  TypeSpec helloWorld = TypeSpec.classBuilder(&#34;HelloWorld&#34;)&#xA;      .addModifiers(Modifier.PUBLIC, Modifier.FINAL)&#xA;      .addMethod(whatsMyName(&#34;slimShady&#34;))&#xA;      .addMethod(whatsMyName(&#34;eminem&#34;))&#xA;      .addMethod(whatsMyName(&#34;marshallMathers&#34;))&#xA;      .build();&#xA;&#xA;  JavaFile javaFile = JavaFile.builder(&#34;com.example.helloworld&#34;, helloWorld)&#xA;      .build();&#xA;&#xA;  javaFile.writeTo(System.out);&#xA;}&#xA;&#xA;private static MethodSpec whatsMyName(String name) {&#xA;  return MethodSpec.methodBuilder(name)&#xA;      .returns(String.class)&#xA;      .addStatement(&#34;return $S&#34;, name)&#xA;      .build();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, using &lt;code&gt;$S&lt;/code&gt; gives us quotation marks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class HelloWorld {&#xA;  String slimShady() {&#xA;    return &#34;slimShady&#34;;&#xA;  }&#xA;&#xA;  String eminem() {&#xA;    return &#34;eminem&#34;;&#xA;  }&#xA;&#xA;  String marshallMathers() {&#xA;    return &#34;marshallMathers&#34;;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;$T for Types&lt;/h3&gt; &#xA;&lt;p&gt;We Java programmers love our types: they make our code easier to understand. And JavaPoet is on board. It has rich built-in support for types, including automatic generation of &lt;code&gt;import&lt;/code&gt; statements. Just use &lt;strong&gt;&lt;code&gt;$T&lt;/code&gt;&lt;/strong&gt; to reference &lt;strong&gt;types&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec today = MethodSpec.methodBuilder(&#34;today&#34;)&#xA;    .returns(Date.class)&#xA;    .addStatement(&#34;return new $T()&#34;, Date.class)&#xA;    .build();&#xA;&#xA;TypeSpec helloWorld = TypeSpec.classBuilder(&#34;HelloWorld&#34;)&#xA;    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)&#xA;    .addMethod(today)&#xA;    .build();&#xA;&#xA;JavaFile javaFile = JavaFile.builder(&#34;com.example.helloworld&#34;, helloWorld)&#xA;    .build();&#xA;&#xA;javaFile.writeTo(System.out);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That generates the following &lt;code&gt;.java&lt;/code&gt; file, complete with the necessary &lt;code&gt;import&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.example.helloworld;&#xA;&#xA;import java.util.Date;&#xA;&#xA;public final class HelloWorld {&#xA;  Date today() {&#xA;    return new Date();&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We passed &lt;code&gt;Date.class&lt;/code&gt; to reference a class that just-so-happens to be available when we&#39;re generating code. This doesn&#39;t need to be the case. Here&#39;s a similar example, but this one references a class that doesn&#39;t exist (yet):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ClassName hoverboard = ClassName.get(&#34;com.mattel&#34;, &#34;Hoverboard&#34;);&#xA;&#xA;MethodSpec today = MethodSpec.methodBuilder(&#34;tomorrow&#34;)&#xA;    .returns(hoverboard)&#xA;    .addStatement(&#34;return new $T()&#34;, hoverboard)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And that not-yet-existent class is imported as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.example.helloworld;&#xA;&#xA;import com.mattel.Hoverboard;&#xA;&#xA;public final class HelloWorld {&#xA;  Hoverboard tomorrow() {&#xA;    return new Hoverboard();&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;ClassName&lt;/code&gt; type is very important, and you&#39;ll need it frequently when you&#39;re using JavaPoet. It can identify any &lt;em&gt;declared&lt;/em&gt; class. Declared types are just the beginning of Java&#39;s rich type system: we also have arrays, parameterized types, wildcard types, and type variables. JavaPoet has classes for building each of these:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ClassName hoverboard = ClassName.get(&#34;com.mattel&#34;, &#34;Hoverboard&#34;);&#xA;ClassName list = ClassName.get(&#34;java.util&#34;, &#34;List&#34;);&#xA;ClassName arrayList = ClassName.get(&#34;java.util&#34;, &#34;ArrayList&#34;);&#xA;TypeName listOfHoverboards = ParameterizedTypeName.get(list, hoverboard);&#xA;&#xA;MethodSpec beyond = MethodSpec.methodBuilder(&#34;beyond&#34;)&#xA;    .returns(listOfHoverboards)&#xA;    .addStatement(&#34;$T result = new $T&amp;lt;&amp;gt;()&#34;, listOfHoverboards, arrayList)&#xA;    .addStatement(&#34;result.add(new $T())&#34;, hoverboard)&#xA;    .addStatement(&#34;result.add(new $T())&#34;, hoverboard)&#xA;    .addStatement(&#34;result.add(new $T())&#34;, hoverboard)&#xA;    .addStatement(&#34;return result&#34;)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JavaPoet will decompose each type and import its components where possible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.example.helloworld;&#xA;&#xA;import com.mattel.Hoverboard;&#xA;import java.util.ArrayList;&#xA;import java.util.List;&#xA;&#xA;public final class HelloWorld {&#xA;  List&amp;lt;Hoverboard&amp;gt; beyond() {&#xA;    List&amp;lt;Hoverboard&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();&#xA;    result.add(new Hoverboard());&#xA;    result.add(new Hoverboard());&#xA;    result.add(new Hoverboard());&#xA;    return result;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Import static&lt;/h4&gt; &#xA;&lt;p&gt;JavaPoet supports &lt;code&gt;import static&lt;/code&gt;. It does it via explicitly collecting type member names. Let&#39;s enhance the previous example with some static sugar:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...&#xA;ClassName namedBoards = ClassName.get(&#34;com.mattel&#34;, &#34;Hoverboard&#34;, &#34;Boards&#34;);&#xA;&#xA;MethodSpec beyond = MethodSpec.methodBuilder(&#34;beyond&#34;)&#xA;    .returns(listOfHoverboards)&#xA;    .addStatement(&#34;$T result = new $T&amp;lt;&amp;gt;()&#34;, listOfHoverboards, arrayList)&#xA;    .addStatement(&#34;result.add($T.createNimbus(2000))&#34;, hoverboard)&#xA;    .addStatement(&#34;result.add($T.createNimbus(\&#34;2001\&#34;))&#34;, hoverboard)&#xA;    .addStatement(&#34;result.add($T.createNimbus($T.THUNDERBOLT))&#34;, hoverboard, namedBoards)&#xA;    .addStatement(&#34;$T.sort(result)&#34;, Collections.class)&#xA;    .addStatement(&#34;return result.isEmpty() ? $T.emptyList() : result&#34;, Collections.class)&#xA;    .build();&#xA;&#xA;TypeSpec hello = TypeSpec.classBuilder(&#34;HelloWorld&#34;)&#xA;    .addMethod(beyond)&#xA;    .build();&#xA;&#xA;JavaFile.builder(&#34;com.example.helloworld&#34;, hello)&#xA;    .addStaticImport(hoverboard, &#34;createNimbus&#34;)&#xA;    .addStaticImport(namedBoards, &#34;*&#34;)&#xA;    .addStaticImport(Collections.class, &#34;*&#34;)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JavaPoet will first add your &lt;code&gt;import static&lt;/code&gt; block to the file as configured, match and mangle all calls accordingly and also import all other types as needed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.example.helloworld;&#xA;&#xA;import static com.mattel.Hoverboard.Boards.*;&#xA;import static com.mattel.Hoverboard.createNimbus;&#xA;import static java.util.Collections.*;&#xA;&#xA;import com.mattel.Hoverboard;&#xA;import java.util.ArrayList;&#xA;import java.util.List;&#xA;&#xA;class HelloWorld {&#xA;  List&amp;lt;Hoverboard&amp;gt; beyond() {&#xA;    List&amp;lt;Hoverboard&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();&#xA;    result.add(createNimbus(2000));&#xA;    result.add(createNimbus(&#34;2001&#34;));&#xA;    result.add(createNimbus(THUNDERBOLT));&#xA;    sort(result);&#xA;    return result.isEmpty() ? emptyList() : result;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;$N for Names&lt;/h3&gt; &#xA;&lt;p&gt;Generated code is often self-referential. Use &lt;strong&gt;&lt;code&gt;$N&lt;/code&gt;&lt;/strong&gt; to refer to another generated declaration by its name. Here&#39;s a method that calls another:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String byteToHex(int b) {&#xA;  char[] result = new char[2];&#xA;  result[0] = hexDigit((b &amp;gt;&amp;gt;&amp;gt; 4) &amp;amp; 0xf);&#xA;  result[1] = hexDigit(b &amp;amp; 0xf);&#xA;  return new String(result);&#xA;}&#xA;&#xA;public char hexDigit(int i) {&#xA;  return (char) (i &amp;lt; 10 ? i + &#39;0&#39; : i - 10 + &#39;a&#39;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When generating the code above, we pass the &lt;code&gt;hexDigit()&lt;/code&gt; method as an argument to the &lt;code&gt;byteToHex()&lt;/code&gt; method using &lt;code&gt;$N&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec hexDigit = MethodSpec.methodBuilder(&#34;hexDigit&#34;)&#xA;    .addParameter(int.class, &#34;i&#34;)&#xA;    .returns(char.class)&#xA;    .addStatement(&#34;return (char) (i &amp;lt; 10 ? i + &#39;0&#39; : i - 10 + &#39;a&#39;)&#34;)&#xA;    .build();&#xA;&#xA;MethodSpec byteToHex = MethodSpec.methodBuilder(&#34;byteToHex&#34;)&#xA;    .addParameter(int.class, &#34;b&#34;)&#xA;    .returns(String.class)&#xA;    .addStatement(&#34;char[] result = new char[2]&#34;)&#xA;    .addStatement(&#34;result[0] = $N((b &amp;gt;&amp;gt;&amp;gt; 4) &amp;amp; 0xf)&#34;, hexDigit)&#xA;    .addStatement(&#34;result[1] = $N(b &amp;amp; 0xf)&#34;, hexDigit)&#xA;    .addStatement(&#34;return new String(result)&#34;)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Code block format strings&lt;/h3&gt; &#xA;&lt;p&gt;Code blocks may specify the values for their placeholders in a few ways. Only one style may be used for each operation on a code block.&lt;/p&gt; &#xA;&lt;h4&gt;Relative Arguments&lt;/h4&gt; &#xA;&lt;p&gt;Pass an argument value for each placeholder in the format string to &lt;code&gt;CodeBlock.add()&lt;/code&gt;. In each example, we generate code to say &#34;I ate 3 tacos&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CodeBlock.builder().add(&#34;I ate $L $L&#34;, 3, &#34;tacos&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Positional Arguments&lt;/h4&gt; &#xA;&lt;p&gt;Place an integer index (1-based) before the placeholder in the format string to specify which argument to use.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CodeBlock.builder().add(&#34;I ate $2L $1L&#34;, &#34;tacos&#34;, 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Named Arguments&lt;/h4&gt; &#xA;&lt;p&gt;Use the syntax &lt;code&gt;$argumentName:X&lt;/code&gt; where &lt;code&gt;X&lt;/code&gt; is the format character and call &lt;code&gt;CodeBlock.addNamed()&lt;/code&gt; with a map containing all argument keys in the format string. Argument names use characters in &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;, and &lt;code&gt;_&lt;/code&gt;, and must start with a lowercase character.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Map&amp;lt;String, Object&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;();&#xA;map.put(&#34;food&#34;, &#34;tacos&#34;);&#xA;map.put(&#34;count&#34;, 3);&#xA;CodeBlock.builder().addNamed(&#34;I ate $count:L $food:L&#34;, map)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Methods&lt;/h3&gt; &#xA;&lt;p&gt;All of the above methods have a code body. Use &lt;code&gt;Modifiers.ABSTRACT&lt;/code&gt; to get a method without any body. This is only legal if the enclosing class is either abstract or an interface.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec flux = MethodSpec.methodBuilder(&#34;flux&#34;)&#xA;    .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)&#xA;    .build();&#xA;&#xA;TypeSpec helloWorld = TypeSpec.classBuilder(&#34;HelloWorld&#34;)&#xA;    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)&#xA;    .addMethod(flux)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class HelloWorld {&#xA;  protected abstract void flux();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The other modifiers work where permitted. Note that when specifying modifiers, JavaPoet uses &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/Modifier.html&#34;&gt;&lt;code&gt;javax.lang.model.element.Modifier&lt;/code&gt;&lt;/a&gt;, a class that is not available on Android. This limitation applies to code-generating-code only; the output code runs everywhere: JVMs, Android, and GWT.&lt;/p&gt; &#xA;&lt;p&gt;Methods also have parameters, exceptions, varargs, Javadoc, annotations, type variables, and a return type. All of these are configured with &lt;code&gt;MethodSpec.Builder&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Constructors&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;MethodSpec&lt;/code&gt; is a slight misnomer; it can also be used for constructors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec flux = MethodSpec.constructorBuilder()&#xA;    .addModifiers(Modifier.PUBLIC)&#xA;    .addParameter(String.class, &#34;greeting&#34;)&#xA;    .addStatement(&#34;this.$N = $N&#34;, &#34;greeting&#34;, &#34;greeting&#34;)&#xA;    .build();&#xA;&#xA;TypeSpec helloWorld = TypeSpec.classBuilder(&#34;HelloWorld&#34;)&#xA;    .addModifiers(Modifier.PUBLIC)&#xA;    .addField(String.class, &#34;greeting&#34;, Modifier.PRIVATE, Modifier.FINAL)&#xA;    .addMethod(flux)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorld {&#xA;  private final String greeting;&#xA;&#xA;  public HelloWorld(String greeting) {&#xA;    this.greeting = greeting;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the most part, constructors work just like methods. When emitting code, JavaPoet will place constructors before methods in the output file.&lt;/p&gt; &#xA;&lt;h3&gt;Parameters&lt;/h3&gt; &#xA;&lt;p&gt;Declare parameters on methods and constructors with either &lt;code&gt;ParameterSpec.builder()&lt;/code&gt; or &lt;code&gt;MethodSpec&lt;/code&gt;&#39;s convenient &lt;code&gt;addParameter()&lt;/code&gt; API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ParameterSpec android = ParameterSpec.builder(String.class, &#34;android&#34;)&#xA;    .addModifiers(Modifier.FINAL)&#xA;    .build();&#xA;&#xA;MethodSpec welcomeOverlords = MethodSpec.methodBuilder(&#34;welcomeOverlords&#34;)&#xA;    .addParameter(android)&#xA;    .addParameter(String.class, &#34;robot&#34;, Modifier.FINAL)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Though the code above to generate &lt;code&gt;android&lt;/code&gt; and &lt;code&gt;robot&lt;/code&gt; parameters is different, the output is the same:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void welcomeOverlords(final String android, final String robot) {&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The extended &lt;code&gt;Builder&lt;/code&gt; form is necessary when the parameter has annotations (such as &lt;code&gt;@Nullable&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Fields&lt;/h3&gt; &#xA;&lt;p&gt;Like parameters, fields can be created either with builders or by using convenient helper methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;FieldSpec android = FieldSpec.builder(String.class, &#34;android&#34;)&#xA;    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)&#xA;    .build();&#xA;&#xA;TypeSpec helloWorld = TypeSpec.classBuilder(&#34;HelloWorld&#34;)&#xA;    .addModifiers(Modifier.PUBLIC)&#xA;    .addField(android)&#xA;    .addField(String.class, &#34;robot&#34;, Modifier.PRIVATE, Modifier.FINAL)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloWorld {&#xA;  private final String android;&#xA;&#xA;  private final String robot;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The extended &lt;code&gt;Builder&lt;/code&gt; form is necessary when a field has Javadoc, annotations, or a field initializer. Field initializers use the same &lt;a href=&#34;https://developer.android.com/reference/java/util/Formatter.html&#34;&gt;&lt;code&gt;String.format()&lt;/code&gt;&lt;/a&gt;-like syntax as the code blocks above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;FieldSpec android = FieldSpec.builder(String.class, &#34;android&#34;)&#xA;    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)&#xA;    .initializer(&#34;$S + $L&#34;, &#34;Lollipop v.&#34;, 5.0d)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final String android = &#34;Lollipop v.&#34; + 5.0;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Interfaces&lt;/h3&gt; &#xA;&lt;p&gt;JavaPoet has no trouble with interfaces. Note that interface methods must always be &lt;code&gt;PUBLIC ABSTRACT&lt;/code&gt; and interface fields must always be &lt;code&gt;PUBLIC STATIC FINAL&lt;/code&gt;. These modifiers are necessary when defining the interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TypeSpec helloWorld = TypeSpec.interfaceBuilder(&#34;HelloWorld&#34;)&#xA;    .addModifiers(Modifier.PUBLIC)&#xA;    .addField(FieldSpec.builder(String.class, &#34;ONLY_THING_THAT_IS_CONSTANT&#34;)&#xA;        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)&#xA;        .initializer(&#34;$S&#34;, &#34;change&#34;)&#xA;        .build())&#xA;    .addMethod(MethodSpec.methodBuilder(&#34;beep&#34;)&#xA;        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)&#xA;        .build())&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But these modifiers are omitted when the code is generated. These are the defaults so we don&#39;t need to include them for &lt;code&gt;javac&lt;/code&gt;&#39;s benefit!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface HelloWorld {&#xA;  String ONLY_THING_THAT_IS_CONSTANT = &#34;change&#34;;&#xA;&#xA;  void beep();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Enums&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;enumBuilder&lt;/code&gt; to create the enum type, and &lt;code&gt;addEnumConstant()&lt;/code&gt; for each value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TypeSpec helloWorld = TypeSpec.enumBuilder(&#34;Roshambo&#34;)&#xA;    .addModifiers(Modifier.PUBLIC)&#xA;    .addEnumConstant(&#34;ROCK&#34;)&#xA;    .addEnumConstant(&#34;SCISSORS&#34;)&#xA;    .addEnumConstant(&#34;PAPER&#34;)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To generate this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Roshambo {&#xA;  ROCK,&#xA;&#xA;  SCISSORS,&#xA;&#xA;  PAPER&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fancy enums are supported, where the enum values override methods or call a superclass constructor. Here&#39;s a comprehensive example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TypeSpec helloWorld = TypeSpec.enumBuilder(&#34;Roshambo&#34;)&#xA;    .addModifiers(Modifier.PUBLIC)&#xA;    .addEnumConstant(&#34;ROCK&#34;, TypeSpec.anonymousClassBuilder(&#34;$S&#34;, &#34;fist&#34;)&#xA;        .addMethod(MethodSpec.methodBuilder(&#34;toString&#34;)&#xA;            .addAnnotation(Override.class)&#xA;            .addModifiers(Modifier.PUBLIC)&#xA;            .addStatement(&#34;return $S&#34;, &#34;avalanche!&#34;)&#xA;            .returns(String.class)&#xA;            .build())&#xA;        .build())&#xA;    .addEnumConstant(&#34;SCISSORS&#34;, TypeSpec.anonymousClassBuilder(&#34;$S&#34;, &#34;peace&#34;)&#xA;        .build())&#xA;    .addEnumConstant(&#34;PAPER&#34;, TypeSpec.anonymousClassBuilder(&#34;$S&#34;, &#34;flat&#34;)&#xA;        .build())&#xA;    .addField(String.class, &#34;handsign&#34;, Modifier.PRIVATE, Modifier.FINAL)&#xA;    .addMethod(MethodSpec.constructorBuilder()&#xA;        .addParameter(String.class, &#34;handsign&#34;)&#xA;        .addStatement(&#34;this.$N = $N&#34;, &#34;handsign&#34;, &#34;handsign&#34;)&#xA;        .build())&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Roshambo {&#xA;  ROCK(&#34;fist&#34;) {&#xA;    @Override&#xA;    public String toString() {&#xA;      return &#34;avalanche!&#34;;&#xA;    }&#xA;  },&#xA;&#xA;  SCISSORS(&#34;peace&#34;),&#xA;&#xA;  PAPER(&#34;flat&#34;);&#xA;&#xA;  private final String handsign;&#xA;&#xA;  Roshambo(String handsign) {&#xA;    this.handsign = handsign;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Anonymous Inner Classes&lt;/h3&gt; &#xA;&lt;p&gt;In the enum code, we used &lt;code&gt;TypeSpec.anonymousInnerClass()&lt;/code&gt;. Anonymous inner classes can also be used in code blocks. They are values that can be referenced with &lt;code&gt;$L&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TypeSpec comparator = TypeSpec.anonymousClassBuilder(&#34;&#34;)&#xA;    .addSuperinterface(ParameterizedTypeName.get(Comparator.class, String.class))&#xA;    .addMethod(MethodSpec.methodBuilder(&#34;compare&#34;)&#xA;        .addAnnotation(Override.class)&#xA;        .addModifiers(Modifier.PUBLIC)&#xA;        .addParameter(String.class, &#34;a&#34;)&#xA;        .addParameter(String.class, &#34;b&#34;)&#xA;        .returns(int.class)&#xA;        .addStatement(&#34;return $N.length() - $N.length()&#34;, &#34;a&#34;, &#34;b&#34;)&#xA;        .build())&#xA;    .build();&#xA;&#xA;TypeSpec helloWorld = TypeSpec.classBuilder(&#34;HelloWorld&#34;)&#xA;    .addMethod(MethodSpec.methodBuilder(&#34;sortByLength&#34;)&#xA;        .addParameter(ParameterizedTypeName.get(List.class, String.class), &#34;strings&#34;)&#xA;        .addStatement(&#34;$T.sort($N, $L)&#34;, Collections.class, &#34;strings&#34;, comparator)&#xA;        .build())&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This generates a method that contains a class that contains a method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void sortByLength(List&amp;lt;String&amp;gt; strings) {&#xA;  Collections.sort(strings, new Comparator&amp;lt;String&amp;gt;() {&#xA;    @Override&#xA;    public int compare(String a, String b) {&#xA;      return a.length() - b.length();&#xA;    }&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One particularly tricky part of defining anonymous inner classes is the arguments to the superclass constructor. In the above code we&#39;re passing the empty string for no arguments: &lt;code&gt;TypeSpec.anonymousClassBuilder(&#34;&#34;)&lt;/code&gt;. To pass different parameters use JavaPoet&#39;s code block syntax with commas to separate arguments.&lt;/p&gt; &#xA;&lt;h3&gt;Annotations&lt;/h3&gt; &#xA;&lt;p&gt;Simple annotations are easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec toString = MethodSpec.methodBuilder(&#34;toString&#34;)&#xA;    .addAnnotation(Override.class)&#xA;    .returns(String.class)&#xA;    .addModifiers(Modifier.PUBLIC)&#xA;    .addStatement(&#34;return $S&#34;, &#34;Hoverboard&#34;)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates this method with an &lt;code&gt;@Override&lt;/code&gt; annotation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  @Override&#xA;  public String toString() {&#xA;    return &#34;Hoverboard&#34;;&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;AnnotationSpec.builder()&lt;/code&gt; to set properties on annotations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec logRecord = MethodSpec.methodBuilder(&#34;recordEvent&#34;)&#xA;    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)&#xA;    .addAnnotation(AnnotationSpec.builder(Headers.class)&#xA;        .addMember(&#34;accept&#34;, &#34;$S&#34;, &#34;application/json; charset=utf-8&#34;)&#xA;        .addMember(&#34;userAgent&#34;, &#34;$S&#34;, &#34;Square Cash&#34;)&#xA;        .build())&#xA;    .addParameter(LogRecord.class, &#34;logRecord&#34;)&#xA;    .returns(LogReceipt.class)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates this annotation with &lt;code&gt;accept&lt;/code&gt; and &lt;code&gt;userAgent&lt;/code&gt; properties:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Headers(&#xA;    accept = &#34;application/json; charset=utf-8&#34;,&#xA;    userAgent = &#34;Square Cash&#34;&#xA;)&#xA;LogReceipt recordEvent(LogRecord logRecord);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you get fancy, annotation values can be annotations themselves. Use &lt;code&gt;$L&lt;/code&gt; for embedded annotations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec logRecord = MethodSpec.methodBuilder(&#34;recordEvent&#34;)&#xA;    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)&#xA;    .addAnnotation(AnnotationSpec.builder(HeaderList.class)&#xA;        .addMember(&#34;value&#34;, &#34;$L&#34;, AnnotationSpec.builder(Header.class)&#xA;            .addMember(&#34;name&#34;, &#34;$S&#34;, &#34;Accept&#34;)&#xA;            .addMember(&#34;value&#34;, &#34;$S&#34;, &#34;application/json; charset=utf-8&#34;)&#xA;            .build())&#xA;        .addMember(&#34;value&#34;, &#34;$L&#34;, AnnotationSpec.builder(Header.class)&#xA;            .addMember(&#34;name&#34;, &#34;$S&#34;, &#34;User-Agent&#34;)&#xA;            .addMember(&#34;value&#34;, &#34;$S&#34;, &#34;Square Cash&#34;)&#xA;            .build())&#xA;        .build())&#xA;    .addParameter(LogRecord.class, &#34;logRecord&#34;)&#xA;    .returns(LogReceipt.class)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@HeaderList({&#xA;    @Header(name = &#34;Accept&#34;, value = &#34;application/json; charset=utf-8&#34;),&#xA;    @Header(name = &#34;User-Agent&#34;, value = &#34;Square Cash&#34;)&#xA;})&#xA;LogReceipt recordEvent(LogRecord logRecord);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that you can call &lt;code&gt;addMember()&lt;/code&gt; multiple times with the same property name to populate a list of values for that property.&lt;/p&gt; &#xA;&lt;h3&gt;Javadoc&lt;/h3&gt; &#xA;&lt;p&gt;Fields, methods and types can be documented with Javadoc:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MethodSpec dismiss = MethodSpec.methodBuilder(&#34;dismiss&#34;)&#xA;    .addJavadoc(&#34;Hides {@code message} from the caller&#39;s history. Other\n&#34;&#xA;        + &#34;participants in the conversation will continue to see the\n&#34;&#xA;        + &#34;message in their own history unless they also delete it.\n&#34;)&#xA;    .addJavadoc(&#34;\n&#34;)&#xA;    .addJavadoc(&#34;&amp;lt;p&amp;gt;Use {@link #delete($T)} to delete the entire\n&#34;&#xA;        + &#34;conversation for all participants.\n&#34;, Conversation.class)&#xA;    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)&#xA;    .addParameter(Message.class, &#34;message&#34;)&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which generates this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  /**&#xA;   * Hides {@code message} from the caller&#39;s history. Other&#xA;   * participants in the conversation will continue to see the&#xA;   * message in their own history unless they also delete it.&#xA;   *&#xA;   * &amp;lt;p&amp;gt;Use {@link #delete(Conversation)} to delete the entire&#xA;   * conversation for all participants.&#xA;   */&#xA;  void dismiss(Message message);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;$T&lt;/code&gt; when referencing types in Javadoc to get automatic imports.&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;Download &lt;a href=&#34;https://search.maven.org/remote_content?g=com.squareup&amp;amp;a=javapoet&amp;amp;v=LATEST&#34;&gt;the latest .jar&lt;/a&gt; or depend via Maven:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;com.squareup&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;javapoet&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;1.13.0&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or Gradle:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;compile &#39;com.squareup:javapoet:1.13.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Snapshots of the development version are available in &lt;a href=&#34;https://oss.sonatype.org/content/repositories/snapshots/com/squareup/javapoet/&#34;&gt;Sonatype&#39;s &lt;code&gt;snapshots&lt;/code&gt; repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright 2015 Square, Inc.&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;   http://www.apache.org/licenses/LICENSE-2.0&#xA;&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;JavaWriter&lt;/h1&gt; &#xA;&lt;p&gt;JavaPoet is the successor to &lt;a href=&#34;https://github.com/square/javapoet/tree/javawriter_2&#34;&gt;JavaWriter&lt;/a&gt;. New projects should prefer JavaPoet because it has a stronger code model: it understands types and can manage imports automatically. JavaPoet is also better suited to composition: rather than streaming the contents of a &lt;code&gt;.java&lt;/code&gt; file top-to-bottom in a single pass, a file can be assembled as a tree of declarations.&lt;/p&gt; &#xA;&lt;p&gt;JavaWriter continues to be available in &lt;a href=&#34;https://github.com/square/javapoet/tree/javawriter_2&#34;&gt;GitHub&lt;/a&gt; and &lt;a href=&#34;https://search.maven.org/#artifactdetails%7Ccom.squareup%7Cjavawriter%7C2.5.1%7Cjar&#34;&gt;Maven Central&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>