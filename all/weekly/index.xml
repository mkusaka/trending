<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-26T01:46:22Z</updated>
  <subtitle>Weekly Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SillyTavern/SillyTavern</title>
    <updated>2023-11-26T01:46:22Z</updated>
    <id>tag:github.com,2023-11-26:/SillyTavern/SillyTavern</id>
    <link href="https://github.com/SillyTavern/SillyTavern" rel="alternate"></link>
    <summary type="html">&lt;p&gt;LLM Frontend for Power Users.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/SillyTavern/SillyTavern/release/readme-zh_cn.md&#34;&gt;‰∏≠Êñá&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/SillyTavern/SillyTavern/assets/18619528/c2be4c3f-aada-4f64-87a3-ae35a68b61a4&#34; alt=&#34;SillyTavern-Banner&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Mobile-friendly layout, Multi-API (KoboldAI/CPP, Horde, NovelAI, Ooba, OpenAI, OpenRouter, Claude, Scale), VN-like Waifu Mode, Stable Diffusion, TTS, WorldInfo (lorebooks), customizable UI, auto-translate, and more prompt options than you&#39;d ever want or need + ability to install third-party extensions.&lt;/p&gt; &#xA;&lt;p&gt;Based on a fork of &lt;a href=&#34;https://github.com/TavernAI/TavernAI&#34;&gt;TavernAI&lt;/a&gt; 1.2.8&lt;/p&gt; &#xA;&lt;h2&gt;Important news!&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;We have created a &lt;a href=&#34;https://docs.sillytavern.app/&#34;&gt;Documentation website&lt;/a&gt; to answer most of your questions and help you get started.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Missing extensions after the update? Since the 1.10.6 release version, most of the previously built-in extensions have been converted to downloadable add-ons. You can download them via the built-in &#34;Download Extensions and Assets&#34; menu in the extensions panel (stacked blocks icon in the top bar).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Brought to you by Cohee, RossAscends, and the SillyTavern community&lt;/h3&gt; &#xA;&lt;h3&gt;What is SillyTavern or TavernAI?&lt;/h3&gt; &#xA;&lt;p&gt;SillyTavern is a user interface you can install on your computer (and Android phones) that allows you to interact with text generation AIs and chat/roleplay with characters you or the community create.&lt;/p&gt; &#xA;&lt;p&gt;SillyTavern is a fork of TavernAI 1.2.8 which is under more active development and has added many major features. At this point, they can be thought of as completely independent programs.&lt;/p&gt; &#xA;&lt;h3&gt;Branches&lt;/h3&gt; &#xA;&lt;p&gt;SillyTavern is being developed using a two-branch system to ensure a smooth experience for all users.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;release -üåü &lt;strong&gt;Recommended for most users.&lt;/strong&gt; This is the most stable and recommended branch, updated only when major releases are pushed. It&#39;s suitable for the majority of users.&lt;/li&gt; &#xA; &lt;li&gt;staging - ‚ö†Ô∏è &lt;strong&gt;Not recommended for casual use.&lt;/strong&gt; This branch has the latest features, but be cautious as it may break at any time. Only for power users and enthusiasts.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you&#39;re not familiar with using the git CLI or don&#39;t understand what a branch is, don&#39;t worry! The release branch is always the preferable option for you.&lt;/p&gt; &#xA;&lt;h3&gt;What do I need other than Tavern?&lt;/h3&gt; &#xA;&lt;p&gt;On its own Tavern is useless, as it&#39;s just a user interface. You have to have access to an AI system backend that can act as the roleplay character. There are various supported backends: OpenAPI API (GPT), KoboldAI (either running locally or on Google Colab), and more. You can read more about this in &lt;a href=&#34;https://docs.sillytavern.app/usage/faq/&#34;&gt;the FAQ&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Do I need a powerful PC to run Tavern?&lt;/h3&gt; &#xA;&lt;p&gt;Since Tavern is only a user interface, it has tiny hardware requirements, it will run on anything. It&#39;s the AI system backend that needs to be powerful.&lt;/p&gt; &#xA;&lt;h2&gt;Mobile support&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;This fork can be run natively on Android phones using Termux. Please refer to this guide by ArroganceComplex#2659:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rentry.org/STAI-Termux&#34;&gt;https://rentry.org/STAI-Termux&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Questions or suggestions?&lt;/h2&gt; &#xA;&lt;h3&gt;We now have a community Discord server&lt;/h3&gt; &#xA;&lt;p&gt;Get support, share favorite characters and prompts:&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://discord.gg/RZdyAEUPvj&#34;&gt;Join&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Get in touch with the developers directly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Discord: cohee or rossascends&lt;/li&gt; &#xA; &lt;li&gt;Reddit: /u/RossAscends or /u/sillylossy&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/SillyTavern/SillyTavern/issues&#34;&gt;Post a GitHub issue&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;This version includes&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A heavily modified TavernAI 1.2.8 (more than 50% of code rewritten or optimized)&lt;/li&gt; &#xA; &lt;li&gt;Swipes&lt;/li&gt; &#xA; &lt;li&gt;Group chats: multi-bot rooms for characters to talk to you or each other&lt;/li&gt; &#xA; &lt;li&gt;Chat bookmarks / branching (duplicates the dialogue in its current state)&lt;/li&gt; &#xA; &lt;li&gt;Advanced KoboldAI / TextGen generation settings with a lot of community-made presets&lt;/li&gt; &#xA; &lt;li&gt;World Info support: create rich lore or save tokens on your character card&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://openrouter.ai&#34;&gt;OpenRouter&lt;/a&gt; connection for various APIs (Claude, GPT-4/3.5 and more)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oobabooga/text-generation-webui&#34;&gt;Oobabooga&#39;s TextGen WebUI&lt;/a&gt; API connection&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://horde.koboldai.net/&#34;&gt;AI Horde&lt;/a&gt; connection&lt;/li&gt; &#xA; &lt;li&gt;Prompt generation formatting tweaking&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Extensions&lt;/h2&gt; &#xA;&lt;p&gt;SillyTavern has extensibility support, with some additional AI modules hosted via &lt;a href=&#34;https://github.com/SillyTavern/SillyTavern-extras&#34;&gt;SillyTavern Extras API&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Author&#39;s Note / Character Bias&lt;/li&gt; &#xA; &lt;li&gt;Character emotional expressions (sprites)&lt;/li&gt; &#xA; &lt;li&gt;Auto-Summary of the chat history&lt;/li&gt; &#xA; &lt;li&gt;Sending images to chat, and the AI interpreting the content&lt;/li&gt; &#xA; &lt;li&gt;Stable Diffusion image generation (5 chat-related presets plus &#39;free mode&#39;)&lt;/li&gt; &#xA; &lt;li&gt;Text-to-speech for AI response messages (via ElevenLabs, Silero, or the OS&#39;s System TTS)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A full list of included extensions and tutorials on how to use them can be found in the &lt;a href=&#34;https://docs.sillytavern.app/extras/extensions/&#34;&gt;Docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;UI/CSS/Quality of Life tweaks by RossAscends&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Mobile UI optimized for iOS, and supports saving a shortcut to the home screen and opening in fullscreen mode.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;HotKeys&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Up = Edit last message in chat&lt;/li&gt; &#xA;   &lt;li&gt;Ctrl+Up = Edit last USER message in chat&lt;/li&gt; &#xA;   &lt;li&gt;Left = swipe left&lt;/li&gt; &#xA;   &lt;li&gt;Right = swipe right (NOTE: swipe hotkeys are disabled when the chat bar has something typed into it)&lt;/li&gt; &#xA;   &lt;li&gt;Ctrl+Left = view locally stored variables (in the browser console window)&lt;/li&gt; &#xA;   &lt;li&gt;Enter (with chat bar selected) = send your message to AI&lt;/li&gt; &#xA;   &lt;li&gt;Ctrl+Enter = Regenerate the last AI response&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;User Name Changes and Character Deletion no longer force the page to refresh.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Toggle option to automatically connect to API on page load.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Toggle option to automatically load the most recently viewed character on page load.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Better Token Counter - works on unsaved characters, and shows both permanent and temporary tokens.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Better Past Chats View&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;New Chat filenames are saved in a readable format of &#34;(character) - (when it was created)&#34;&lt;/li&gt; &#xA;   &lt;li&gt;Chat preview increased from 40 characters to 300.&lt;/li&gt; &#xA;   &lt;li&gt;Multiple options for characters list sorting (by name, creation date, chat sizes).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;By default the left and right settings panel will close when you click away from it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Clicking the Lock on the nav panel will hold the panel open, and this setting be remembered across sessions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Nav panel status of open or closed will also be saved across sessions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Customizable chat UI:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Play a sound when a new message arrives&lt;/li&gt; &#xA;   &lt;li&gt;Switch between round or rectangle avatar styles&lt;/li&gt; &#xA;   &lt;li&gt;Have a wider chat window on the desktop&lt;/li&gt; &#xA;   &lt;li&gt;Optional semi-transparent glass-like panels&lt;/li&gt; &#xA;   &lt;li&gt;Customizable page colors for &#39;main text&#39;, &#39;quoted text&#39;, and &#39;italics text&#39;.&lt;/li&gt; &#xA;   &lt;li&gt;Customizable UI background color and blur amount&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE: This software is intended for local install purposes, and has not been thoroughly tested on a colab or other cloud notebook service.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;DO NOT INSTALL INTO ANY WINDOWS CONTROLLED FOLDER (Program Files, System32, etc).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;DO NOT RUN START.BAT WITH ADMIN PERMISSIONS&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;p&gt;Installing via Git (recommended for easy updating)&lt;/p&gt; &#xA;&lt;p&gt;An easy-to-follow guide with pretty pictures: &lt;a href=&#34;https://docs.sillytavern.app/installation/windows/&#34;&gt;https://docs.sillytavern.app/installation/windows/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://nodejs.org/en&#34;&gt;NodeJS&lt;/a&gt; (latest LTS version is recommended)&lt;/li&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://central.github.com/deployments/desktop/desktop/latest/win32&#34;&gt;GitHub Desktop&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Open Windows Explorer (&lt;code&gt;Win+E&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Browse to or Create a folder that is not controlled or monitored by Windows. (ex: C:\MySpecialFolder)&lt;/li&gt; &#xA; &lt;li&gt;Open a Command Prompt inside that folder by clicking in the &#39;Address Bar&#39; at the top, typing &lt;code&gt;cmd&lt;/code&gt;, and pressing Enter.&lt;/li&gt; &#xA; &lt;li&gt;Once the black box (Command Prompt) pops up, type ONE of the following into it and press Enter:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;for Release Branch: &lt;code&gt;git clone https://github.com/SillyTavern/SillyTavern -b release&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;for Staging Branch: &lt;code&gt;git clone https://github.com/SillyTavern/SillyTavern -b staging&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ol start=&#34;7&#34;&gt; &#xA;   &lt;li&gt;Once everything is cloned, double-click &lt;code&gt;Start.bat&lt;/code&gt; to make NodeJS install its requirements.&lt;/li&gt; &#xA;   &lt;li&gt;The server will then start, and SillyTavern will pop up in your browser.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Installing via ZIP download (discouraged)&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://nodejs.org/en&#34;&gt;NodeJS&lt;/a&gt; (latest LTS version is recommended)&lt;/li&gt; &#xA; &lt;li&gt;Download the zip from this GitHub repo. (Get the &lt;code&gt;Source code (zip)&lt;/code&gt; from &lt;a href=&#34;https://github.com/SillyTavern/SillyTavern/releases/latest&#34;&gt;Releases&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Unzip it into a folder of your choice&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;Start.bat&lt;/code&gt; by double-clicking or in a command line.&lt;/li&gt; &#xA; &lt;li&gt;Once the server has prepared everything for you, it will open a tab in your browser.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Linux&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Ensure you have Node.js v18 or higher (the latest &lt;a href=&#34;https://nodejs.org/en/download/&#34;&gt;LTS version&lt;/a&gt; is recommended) installed by running &lt;code&gt;node -v&lt;/code&gt;. Alternatively, use the &lt;a href=&#34;https://github.com/nvm-sh/nvm#installing-and-updating&#34;&gt;Node Version Manager&lt;/a&gt; script to quickly and easily manage your Node installations.&lt;/li&gt; &#xA; &lt;li&gt;Run the &lt;code&gt;start.sh&lt;/code&gt; script.&lt;/li&gt; &#xA; &lt;li&gt;Enjoy.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;API keys management&lt;/h2&gt; &#xA;&lt;p&gt;SillyTavern saves your API keys to a &lt;code&gt;secrets.json&lt;/code&gt; file in the server directory.&lt;/p&gt; &#xA;&lt;p&gt;By default, they will not be exposed to a frontend after you enter them and reload the page.&lt;/p&gt; &#xA;&lt;p&gt;In order to enable viewing your keys by clicking a button in the API block:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Set the value of &lt;code&gt;allowKeysExposure&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;config.conf&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;Restart the SillyTavern server.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Remote connections&lt;/h2&gt; &#xA;&lt;p&gt;Most often this is for people who want to use SillyTavern on their mobile phones while their PC runs the ST server on the same wifi network.&lt;/p&gt; &#xA;&lt;p&gt;However, it can be used to allow remote connections from anywhere as well.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;IMPORTANT: SillyTavern is a single-user program, so anyone who logs in will be able to see all characters and chats, and be able to change any settings inside the UI.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;1. Managing whitelisted IPs&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create a new text file inside your SillyTavern base install folder called &lt;code&gt;whitelist.txt&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Open the file in a text editor, and add a list of IPs you want to be allowed to connect.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Both individual IPs and wildcard IP ranges are accepted. Examples:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;192.168.0.1&#xA;192.168.0.20&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;192.168.0.*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(the above wildcard IP range will allow any device on the local network to connect)&lt;/p&gt; &#xA;&lt;p&gt;CIDR masks are also accepted (eg. 10.0.0.0/24).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Save the &lt;code&gt;whitelist.txt&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;Restart your TAI server.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Now devices which have the IP specified in the file will be able to connect.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: &lt;code&gt;config.conf&lt;/code&gt; also has a &lt;code&gt;whitelist&lt;/code&gt; array, which you can use in the same way, but this array will be ignored if &lt;code&gt;whitelist.txt&lt;/code&gt; exists.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;2. Getting the IP for the ST host machine&lt;/h3&gt; &#xA;&lt;p&gt;After the whitelist has been setup, you&#39;ll need the IP of the ST-hosting device.&lt;/p&gt; &#xA;&lt;p&gt;If the ST-hosting device is on the same wifi network, you will use the ST-host&#39;s internal wifi IP:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For Windows: windows button &amp;gt; type &lt;code&gt;cmd.exe&lt;/code&gt; in the search bar &amp;gt; type &lt;code&gt;ipconfig&lt;/code&gt; in the console, hit Enter &amp;gt; look for &lt;code&gt;IPv4&lt;/code&gt; listing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you (or someone else) want to connect to your hosted ST while not being on the same network, you will need the public IP of your ST-hosting device.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;While using the ST-hosting device, access &lt;a href=&#34;https://whatismyipaddress.com/&#34;&gt;this page&lt;/a&gt; and look for &lt;code&gt;IPv4&lt;/code&gt;. This is what you would use to connect from the remote device.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;3. Connect the remote device to the ST host machine&lt;/h3&gt; &#xA;&lt;p&gt;Whatever IP you ended up with for your situation, you will put that IP address and port number into the remote device&#39;s web browser.&lt;/p&gt; &#xA;&lt;p&gt;A typical address for an ST host on the same wifi network would look like this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;http://192.168.0.5:8000&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Use http:// NOT https://&lt;/p&gt; &#xA;&lt;h3&gt;Opening your ST to all IPs&lt;/h3&gt; &#xA;&lt;p&gt;We do not recommend doing this, but you can open &lt;code&gt;config.conf&lt;/code&gt; and change &lt;code&gt;whitelist&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You must remove (or rename) &lt;code&gt;whitelist.txt&lt;/code&gt; in the SillyTavern base install folder if it exists.&lt;/p&gt; &#xA;&lt;p&gt;This is usually an insecure practice, so we require you to set a username and password when you do this.&lt;/p&gt; &#xA;&lt;p&gt;The username and password are set in &lt;code&gt;config.conf&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;After restarting your ST server, any device will be able to connect to it, regardless of their IP as long as they know the username and password.&lt;/p&gt; &#xA;&lt;h3&gt;Still Unable To Connect?&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create an inbound/outbound firewall rule for the port found in &lt;code&gt;config.conf&lt;/code&gt;. Do NOT mistake this for port-forwarding on your router, otherwise, someone could find your chat logs and that&#39;s a big no-no.&lt;/li&gt; &#xA; &lt;li&gt;Enable the Private Network profile type in Settings &amp;gt; Network and Internet &amp;gt; Ethernet. This is VERY important for Windows 11, otherwise, you would be unable to connect even with the aforementioned firewall rules.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Performance issues?&lt;/h2&gt; &#xA;&lt;p&gt;Try enabling the No Blur Effect (Fast UI) mode on the User settings panel.&lt;/p&gt; &#xA;&lt;h2&gt;I like your project! How do I contribute?&lt;/h2&gt; &#xA;&lt;h3&gt;DO&#39;s&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Send pull requests&lt;/li&gt; &#xA; &lt;li&gt;Send feature suggestions and issue reports using established templates&lt;/li&gt; &#xA; &lt;li&gt;Read the readme file and built-in documentation before asking anything&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;DONT&#39;s&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Offer monetary donations&lt;/li&gt; &#xA; &lt;li&gt;Send bug reports without providing any context&lt;/li&gt; &#xA; &lt;li&gt;Ask the questions that were already answered numerous times&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Where can I find the old backgrounds?&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re moving to a 100% original content only policy, so old background images have been removed from this repository.&lt;/p&gt; &#xA;&lt;p&gt;You can find them archived here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://files.catbox.moe/1xevnc.zip&#34;&gt;https://files.catbox.moe/1xevnc.zip&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;img width=&#34;400&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/18619528/228649245-8061c60f-63dc-488e-9325-f151b7a3ec2d.png&#34;&gt; &#xA;&lt;img width=&#34;400&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/18619528/228649856-fbdeef05-d727-4d5a-be80-266cbbc6b811.png&#34;&gt; &#xA;&lt;h2&gt;License and credits&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;TAI Base by Humi: Unknown license&lt;/li&gt; &#xA; &lt;li&gt;Cohee&#39;s modifications and derived code: AGPL v3&lt;/li&gt; &#xA; &lt;li&gt;RossAscends&#39; additions: AGPL v3&lt;/li&gt; &#xA; &lt;li&gt;Portions of CncAnon&#39;s TavernAITurbo mod: Unknown license&lt;/li&gt; &#xA; &lt;li&gt;kingbri&#39;s various commits and suggestions (&lt;a href=&#34;https://github.com/bdashore3&#34;&gt;https://github.com/bdashore3&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;city_unit&#39;s extensions and various QoL features (&lt;a href=&#34;https://github.com/city-unit&#34;&gt;https://github.com/city-unit&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;StefanDanielSchwarz&#39;s various commits and bug reports (&lt;a href=&#34;https://github.com/StefanDanielSchwarz&#34;&gt;https://github.com/StefanDanielSchwarz&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Waifu mode inspired by the work of PepperTaco (&lt;a href=&#34;https://github.com/peppertaco/Tavern/&#34;&gt;https://github.com/peppertaco/Tavern/&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Thanks Pygmalion University for being awesome testers and suggesting cool features!&lt;/li&gt; &#xA; &lt;li&gt;Thanks oobabooga for compiling presets for TextGen&lt;/li&gt; &#xA; &lt;li&gt;KoboldAI Presets from KAI Lite: &lt;a href=&#34;https://lite.koboldai.net/&#34;&gt;https://lite.koboldai.net/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Noto Sans font by Google (OFL license)&lt;/li&gt; &#xA; &lt;li&gt;Icon theme by Font Awesome &lt;a href=&#34;https://fontawesome.com&#34;&gt;https://fontawesome.com&lt;/a&gt; (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)&lt;/li&gt; &#xA; &lt;li&gt;AI Horde client library by ZeldaFan0225: &lt;a href=&#34;https://github.com/ZeldaFan0225/ai_horde&#34;&gt;https://github.com/ZeldaFan0225/ai_horde&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Linux startup script by AlpinDale&lt;/li&gt; &#xA; &lt;li&gt;Thanks paniphons for providing a FAQ document&lt;/li&gt; &#xA; &lt;li&gt;10K Discord Users Celebratory Background by @kallmeflocc&lt;/li&gt; &#xA; &lt;li&gt;Default content (characters and lore books) provided by @OtisAlejandro, @RossAscends and @kallmeflocc&lt;/li&gt; &#xA; &lt;li&gt;Korean translation by @doloroushyeonse&lt;/li&gt; &#xA; &lt;li&gt;k_euler_a support for Horde by &lt;a href=&#34;https://github.com/Teashrock&#34;&gt;https://github.com/Teashrock&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Chinese translation by &lt;a href=&#34;https://github.com/XXpE3&#34;&gt;@XXpE3&lt;/a&gt;, ‰∏≠Êñá ISSUES ÂèØ‰ª•ËÅîÁ≥ª @XXpE3&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>twostraws/Inferno</title>
    <updated>2023-11-26T01:46:22Z</updated>
    <id>tag:github.com,2023-11-26:/twostraws/Inferno</id>
    <link href="https://github.com/twostraws/Inferno" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Metal shaders for SwiftUI.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://www.hackingwithswift.com/files/inferno/inferno-logo.png&#34; alt=&#34;Inferno logo&#34; width=&#34;272&#34; height=&#34;272&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/iOS-17.0+-blue.svg?sanitize=true&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/macOS-14.0+-brightgreen.svg?sanitize=true&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/MSL-3.1-orange.svg?sanitize=true&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Swift-5.9-ff69b4.svg?sanitize=true&#34;&gt; &lt;a href=&#34;https://twitter.com/twostraws&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Contact-@twostraws-lightgrey.svg?style=flat&#34; alt=&#34;Twitter: @twostraws&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;Inferno is an open-source collection of fragment shaders designed for SwiftUI apps. The shaders are designed to be easy to read and understand, even for relative beginners, so you‚Äôll find each line of code rephrased in plain English as well as an overall explanation of the algorithm used at the top of each file.&lt;/p&gt; &#xA;&lt;p&gt;If you‚Äôre already comfortable with shaders then please download one or more that interest you and get going. If not, most of the remainder of this README acts as a primer for using shaders in SwiftUI.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#see-it-in-action&#34;&gt;See it in action&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#how-to-use-inferno-in-your-project&#34;&gt;How to use Inferno in your project&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#what-are-shaders&#34;&gt;What are shaders?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#how-are-shaders-written&#34;&gt;How are shaders written?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#sending-values-to-shaders&#34;&gt;Sending values to shaders&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#reading-the-shader-code&#34;&gt;Reading the shader code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#shaders-included-in-inferno&#34;&gt;Shaders included in Inferno&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#animated-gradient-fill&#34;&gt;Animated Gradient Fill&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#checkerboard&#34;&gt;Checkerboard&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#circle-wave&#34;&gt;Circle Wave&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#color-lanes&#34;&gt;Color Planes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#emboss&#34;&gt;Emboss&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#gradient-fill&#34;&gt;Gradient Fill&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#infrared&#34;&gt;Infrared&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#interlace&#34;&gt;Interlace&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#invert-alpha&#34;&gt;Invert Alpha&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#light-grid&#34;&gt;Light Grid&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#passthrough&#34;&gt;Passthrough&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#rainbow-noise&#34;&gt;Rainbow Noise&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#recolor&#34;&gt;Recolor&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#relative-wave&#34;&gt;Relative Wave&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#simple-loupe&#34;&gt;Simple Loupe&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#sinebow&#34;&gt;Sinebow&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#warping-loupe&#34;&gt;Warping Loupe&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#water&#34;&gt;Water&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#wave&#34;&gt;Wave&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#white-noise&#34;&gt;White Noise&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#transitions-included-in-inferno&#34;&gt;Transitions included in Inferno&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#circle&#34;&gt;Circle&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#circle-wave&#34;&gt;Circle Wave&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#crosswarp-ltr&#34;&gt;Crosswarp LTR&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#crosswarp-rtl&#34;&gt;Crosswarp RTL&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#diamond&#34;&gt;Diamond&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#diamond-wave&#34;&gt;Diamond Wave&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#pixellate&#34;&gt;Pixellate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#radial&#34;&gt;Radial&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#swirl&#34;&gt;Swirl&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#inferno-sandbox&#34;&gt;Inferno Sandbox&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#where-to-learn-more&#34;&gt;Where to learn more&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;See it in action&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains a cross-platform sample project demonstrating all the shaders in action. The sample project is built using SwiftUI and requires iOS 17 and macOS 14.&lt;/p&gt; &#xA;&lt;p&gt;The sample project contains a lot of extra helper code to demonstrate all the shaders in various ways. To use the shaders in your own project, you just need to copy the relevant Metal files across, and optionally also Transitions.swift if you&#39;re using a transition shader.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/sandbox-screenshot.png&#34; alt=&#34;The Inferno Sandbox app demonstrating the simple loupe shader.&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to use Inferno in your project&lt;/h2&gt; &#xA;&lt;p&gt;If you use SwiftUI, you can add special effects from Inferno to add water ripples, spinning black holes, flashing lights, embossing, noise, gradients, and more ‚Äì&amp;nbsp;all done on the GPU for maximum speed.&lt;/p&gt; &#xA;&lt;p&gt;To use a shader from here, copy the appropriate .metal file into your project, then start with sample code for that shader shown below. If you&#39;re using an Inferno transition, you should also copy Transitions.swift to your project.&lt;/p&gt; &#xA;&lt;p&gt;To find out more, click below to watch my YouTube video about building shaders for use with SwiftUI.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/EgzWwgRpUuw&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/EgzWwgRpUuw/maxresdefault.jpg&#34; alt=&#34;Video: SwiftUI + Metal ‚Äì Learn to build your own shaders&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What are shaders?&lt;/h2&gt; &#xA;&lt;p&gt;Fragment shaders are tiny programs that operate on individual elements of a SwiftUI layer. They are sometimes called ‚Äúpixel shaders‚Äù ‚Äì&amp;nbsp;it‚Äôs not a wholly accurate name, but it does make them easier to understand.&lt;/p&gt; &#xA;&lt;p&gt;Effectively, a fragment shader gets run on every pixel in a SwiftUI view, and can transform that pixel however it wants. That might sound slow, but it isn‚Äôt ‚Äì&amp;nbsp;all the fragment shaders here run at 60fps on all phones that support iOS 17, and 120fps on all ProMotion devices.&lt;/p&gt; &#xA;&lt;p&gt;The transformation process can recolor the pixel however it wants. Users can customize the process by passing various parameters into each shader, and SwiftUI also provides some values for us to work with, such as the coordinate for the pixel being modified and its current color.&lt;/p&gt; &#xA;&lt;h2&gt;How are shaders written?&lt;/h2&gt; &#xA;&lt;p&gt;Shaders are written in the Metal Shading Language (MSL), which is a simple, fast, and extremely efficient language based on C++ that is optimized for high-performance GPU operations. Metal shaders are compiled at build-time and linked into a &lt;code&gt;.metallib&lt;/code&gt; file. When you activate a shader in your app, the corresponding Metal function is loaded from the &lt;code&gt;metallib&lt;/code&gt; and is then used to create a program to be executed on the GPU.&lt;/p&gt; &#xA;&lt;p&gt;SwiftUI is able to work with a variety of Metal shaders, depending on what kind of effect you&#39;re trying to create.&lt;/p&gt; &#xA;&lt;p&gt;MSL comes with a wide variety of built-in data types and functions, many of which operate on more than one data types. The data types used in Inferno are nice and simple:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;bool&lt;/code&gt;: A Boolean, i.e. true or false.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;float&lt;/code&gt;: A floating-point number.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;float2&lt;/code&gt;: A two-component floating-point vector, used to hold things like X and Y coordinates or width and height.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;half&lt;/code&gt;: A half-precision floating-point number.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;half2&lt;/code&gt;: A two-component half-precision floating-point number.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;half3&lt;/code&gt;: A three-component floating-point vector, used to hold RGB values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;half4&lt;/code&gt;: A four-component floating-point vector, used to hold RGBA values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;uint2&lt;/code&gt;: A two-component integer vector, used to hold X and Y coordinates or width and height.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Shaders commonly move fluidly between &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;float2&lt;/code&gt;, &lt;code&gt;half3&lt;/code&gt;, and &lt;code&gt;half4&lt;/code&gt; as needed. For example, if you create a &lt;code&gt;half4&lt;/code&gt; from a &lt;code&gt;float&lt;/code&gt; then the number will just get repeated for each component in the vector. You‚Äôll also frequently see code to create a &lt;code&gt;half4&lt;/code&gt; by using a &lt;code&gt;half3&lt;/code&gt; for the first three values (usually RGB) and specifying a fourth value as a &lt;code&gt;float&lt;/code&gt;. Converting between &lt;code&gt;half&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; is free.&lt;/p&gt; &#xA;&lt;p&gt;Be mindful when choosing the type of your variables: the GPU is heavily optimized for performing floating-point operations, and (especially on iOS), half-precision floating-point operations. That means you should prefer to use the &lt;code&gt;half&lt;/code&gt; data types whenever the precision requirements allow it. This will also save register space and increase the so-called &#34;occupancy&#34; of the shader program, effectively letting more GPU cores run your shader simultaneously. Check out the &lt;a href=&#34;https://developer.apple.com/videos/play/tech-talks/111373?time=778&#34;&gt;Learn performance best practices for Metal shaders&lt;/a&gt; tech talk for more details.&lt;/p&gt; &#xA;&lt;p&gt;Also, be careful with scalar numbers in your shader code. Make sure to use the correct type of number for an operation. For example, &lt;code&gt;float y = (x - 1) / 2&lt;/code&gt; works, but &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; are &lt;code&gt;int&lt;/code&gt; here and are needlessly converted to &lt;code&gt;float&lt;/code&gt; at runtime. Instead, write &lt;code&gt;float y = (x - 1.0) / 2.0&lt;/code&gt;. Number literals for the corresponding types look like this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;float&lt;/code&gt;: &lt;code&gt;0.5&lt;/code&gt;, &lt;code&gt;0.5f&lt;/code&gt;, or &lt;code&gt;0.5F&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;half&lt;/code&gt;: &lt;code&gt;0.5h&lt;/code&gt; or &lt;code&gt;0.5H&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;int&lt;/code&gt;: &lt;code&gt;42&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;uint&lt;/code&gt;: &lt;code&gt;42u&lt;/code&gt; or &lt;code&gt;42U&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here are the functions used in Inferno:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;abs()&lt;/code&gt; calculates the absolute value of a number, which is its non-negative value. So, positive values such as 1, 5, and 500 remain as they are, but negative values such as -3 or -3000 have their signs removed, making them 3 or 3000. If you pass it a vector (e.g. &lt;code&gt;float2&lt;/code&gt;) this will be done for each component.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ceil()&lt;/code&gt; rounds a number up to its nearest integer. If you pass it a vector (e.g. &lt;code&gt;float2&lt;/code&gt;) this will be done for each component.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cos()&lt;/code&gt; calculates the cosine of a value in radians. The cosine will always fall between -1 and 1. If you provide &lt;code&gt;cos()&lt;/code&gt; with a vector (e.g. &lt;code&gt;vec3&lt;/code&gt;) it will calculate the cosine of each component in the vector and return a vector of the same size containing the results.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;distance()&lt;/code&gt; calculates the distance between two values. For example, if you provide it with a pair &lt;code&gt;vec2&lt;/code&gt; you‚Äôll get the length of the vector created by subtracting one from the other. This always returns a single number no matter what data type you give it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dot()&lt;/code&gt; calculates the dot product of two values. This means multiplying each component of the first value by the respective component in the second value, then adding the result.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;floor()&lt;/code&gt; rounds a number down to its nearest integer. If you pass it a vector (e.g. &lt;code&gt;float2&lt;/code&gt;) this will be done for each component.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fract()&lt;/code&gt; returns the fractional component of a value. For example, &lt;code&gt;fract(12.5)&lt;/code&gt; is 0.5. If you pass this a vector then the operation will be performed component-wise, and a new vector will be returned containing the results.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;min()&lt;/code&gt; is used to find the lower of two values. If you pass vectors, this is done component-wise, meaning that the resulting vector will evaluate each component in the vector and place the lowest in the resulting vector.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max()&lt;/code&gt; is used to find the higher of two values. If you pass vectors, this is done component-wise, meaning that the resulting vector will evaluate each component in the vector and place the highest in the resulting vector.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mix()&lt;/code&gt; smooth interpolates between two values based on a third value that‚Äôs specified between 0 and 1, providing a linear curve.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pow()&lt;/code&gt; calculates one value raised to the power of another, for example &lt;code&gt;pow(2.0, 3.0)&lt;/code&gt; evaluates to 2 * 2 * 2, giving 8. As well as operating on a &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;pow()&lt;/code&gt; can also calculate component-wise exponents ‚Äì&amp;nbsp;it raises the first item in the first vector to the power of the first item in the second vector, and so on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sin()&lt;/code&gt; calculates the sine of a value in radians. The sine will always fall between -1 and 1. If you provide &lt;code&gt;sin()&lt;/code&gt; with a vector (e.g. &lt;code&gt;float2&lt;/code&gt;) it will calculate the sine of each component in the vector and return a vector of the same size containing the results.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;smoothstep()&lt;/code&gt; interpolates between two values based on a third value that‚Äôs specified between 0 and 1, providing an S-curve shape. That is, the interpolation starts slow (values near 0.0), picks up speed (values near 0.5), then slows down towards the end (values near 1.0).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sample()&lt;/code&gt; provides the color value of a SwiftUI layer at a specific location. This is most commonly used to read the current pixel‚Äôs color.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More about all of this can be found in the &lt;a href=&#34;https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf&#34;&gt;Metal Shading Language Specification&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Sending values to shaders&lt;/h2&gt; &#xA;&lt;p&gt;Many shaders can operate without any special input from the user ‚Äì&amp;nbsp;it can manipulate the data it was sent by SwiftUI, then send back new data.&lt;/p&gt; &#xA;&lt;p&gt;Because SwiftUI uses dynamic member lookup to find shader functions at runtime, this means a simple shader can be applied like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Image(systemName: &#34;figure.walk.circle&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.yourShaderFunction()&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, often you‚Äôll want to customize the way shaders work, a bit like passing in parameters to a function. Shaders are a little more complicated because these values need to be uploaded to the GPU, but the principle is the same.&lt;/p&gt; &#xA;&lt;p&gt;SwiftUI handles this data transfer using helper methods that convert common Swift and SwiftUI data types to their Metal equivalents. For example, if you want to pass a &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;CGFloat&lt;/code&gt;, or &lt;code&gt;Double&lt;/code&gt; from Swift to Metal, you&#39;d do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Image(systemName: &#34;figure.walk.circle&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.yourShaderFunction(&#xA;            .float(someNumber)&#xA;        )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SwiftUI provides three modifiers that let us apply Metal shaders to view hierarchies. Each one provides different input to your shader function, but each can also accept any number of further values to customize the way your shader works.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;colorEffect()&lt;/code&gt; modifier passes in the current pixel&#39;s position in user space (i.e., based on the actual size of your layer, measured in points), and its current color.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;distortionEffect()&lt;/code&gt; modifier passes in just the current pixel&#39;s position in user space.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;layerEffect()&lt;/code&gt; modifier passes in the current pixel&#39;s position in user space, and also the SwiftUI layer itself so you can read values from there freely.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In the documentation below, shader parameters are listed &lt;em&gt;without&lt;/em&gt; the ones SwiftUI passes in automatically ‚Äì&amp;nbsp;you just see the ones you actually need to pass yourself.&lt;/p&gt; &#xA;&lt;h2&gt;Reading the shader code&lt;/h2&gt; &#xA;&lt;p&gt;All the shaders in Inferno were specifically written for readability. Specifically, they:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Start with a brief comment outlining what each shader does.&lt;/li&gt; &#xA; &lt;li&gt;List all input parameters (where they are used), along with ranges and a suggested starting point.&lt;/li&gt; &#xA; &lt;li&gt;Have an explanation of the algorithm used.&lt;/li&gt; &#xA; &lt;li&gt;Provide detailed line-by-line English translations of what the code means.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The combination of what the code &lt;em&gt;does&lt;/em&gt; (the interlinear comments) and what the code &lt;em&gt;means&lt;/em&gt; (the algorithm introduction) should hopefully make these shaders comprehensible to everyone.&lt;/p&gt; &#xA;&lt;p&gt;One small note: you will commonly see final color values multiplied by the original color‚Äôs alpha, just to make sure we get very smooth edges where this is transparency.&lt;/p&gt; &#xA;&lt;h2&gt;Shaders included in Inferno&lt;/h2&gt; &#xA;&lt;p&gt;Inferno provides a selection of shaders, most of which allow some customization using input parameters.&lt;/p&gt; &#xA;&lt;h3&gt;Animated Gradient Fill&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates a constantly cycling color gradient, centered on the input view.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .colorEffect(&#xA;                            ShaderLibrary.animatedGradientFill(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime)&#xA;                        )&#xA;                    )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Checkerboard&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that replaces the current image with a checkerboard pattern, flipping between the original color and a replacement.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;replacement&lt;/code&gt;: The replacement color to be used for checkered squares.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the checker squares.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &#34;figure.walk.circle&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.checkerboard(&#xA;            .color(.red),&#xA;            .float(50)&#xA;        )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Circle Wave&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates circular waves moving out or in, with varying size, brightness, speed, strength, and more.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;brightness&lt;/code&gt;: How bright the colors should be. Ranges from 0 to 5 work best; try starting with 0.5 and experiment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;speed&lt;/code&gt;: How fast the wave should travel. Ranges from -2 to 2 work best, where negative numbers cause waves to come inwards; try starting with 1.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How intense the waves should be. Ranges from 0.02 to 5 work best; try starting with 2.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;density&lt;/code&gt;: How large each wave should be. Ranges from 20 to 500 work best; try starting with 100.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;center&lt;/code&gt;: The center of the effect, where 0.5/0.5 is dead center&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;circleColor&lt;/code&gt;: The color to use for the waves. Use darker colors to create a less intense core.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .padding()&#xA;                .drawingGroup()&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .colorEffect(&#xA;                            ShaderLibrary.circleWave(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime),&#xA;                                .float(0.5),&#xA;                                .float(1),&#xA;                                .float(2),&#xA;                                .float(100),&#xA;                                .float2(0.5, 0.5),&#xA;                                .color(.blue)&#xA;                            )&#xA;                        )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Color Planes&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;layerEffect()&lt;/code&gt; shader that separates the RGB values for a pixel and offsets them to create a glitch-style effect. This works particularly well on iOS when the &lt;code&gt;offset&lt;/code&gt; value is provided as through accelerometer data.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;offset&lt;/code&gt;: How much to offset colors by.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var touchLocation = CGSize.zero&#xA;&#xA;    var body: some View {&#xA;        Image(systemName: &#34;figure.walk.circle&#34;)&#xA;            .font(.system(size: 300))&#xA;            .foregroundStyle(.white)&#xA;            .frame(maxWidth: .infinity, maxHeight: .infinity)&#xA;            .background(.black)&#xA;            .drawingGroup()&#xA;            .layerEffect(&#xA;                ShaderLibrary.colorPlanes(&#xA;                    .float2(touchLocation)&#xA;                ),&#xA;                maxSampleOffset: .zero&#xA;            )&#xA;            .gesture(&#xA;                DragGesture(minimumDistance: 0)&#xA;                    .onChanged { touchLocation = $0.translation }&#xA;            )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Emboss&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;layerEffect()&lt;/code&gt; shader that creates an embossing effect by adding brightness from pixels in one direction, and subtracting brightness from pixels in the other direction.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How far we should we read pixels to create the effect.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var embossAmount = 0.0&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            Text(&#34;üè≥Ô∏è‚Äçüåà&#34;)&#xA;                .font(.system(size: 300))&#xA;                .layerEffect(&#xA;                    ShaderLibrary.emboss(&#xA;                        .float(embossAmount)&#xA;                    ),&#xA;                    maxSampleOffset: .zero&#xA;                )&#xA;&#xA;            Slider(value: $embossAmount, in: 0...20)&#xA;                .padding()&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Gradient Fill&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates a gradient fill&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &#34;figure.walk.circle&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.gradientFill()&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Infrared&lt;/h3&gt; &#xA;&lt;p&gt;Simulates an infrared camera by coloring brighter objects red and darker objects blue.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&#34;üë©‚Äçüíª&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.infrared()&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Interlace&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that applies an interlacing effect where horizontal lines of the original color are separated by lines of another color.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;width&lt;/code&gt;: The width of the interlacing lines. Ranges of 1 to 4 work best; try starting with 1.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;replacement&lt;/code&gt;: The color to use for interlacing lines. Try starting with black.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How much to blend interlaced lines with color. Specify 0 (not at all) up to 1 (fully).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &#34;figure.walk.circle&#34;)&#xA;    .font(.system(size: 300))&#xA;    .foregroundStyle(.red)&#xA;    .colorEffect(&#xA;        ShaderLibrary.interlace(&#xA;            .float(2),&#xA;            .color(.black),&#xA;            .float(1)&#xA;        )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Invert Alpha&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that inverts the alpha of an image, replacing transparent colors with a supplied color.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;replacement&lt;/code&gt;: The replacement color to use for pixels.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&#34;ü§∑‚Äç‚ôÇÔ∏è&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.invertAlpha(&#xA;            .color(.red)&#xA;        )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Light Grid&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates multiple twisting and turning lines that cycle through colors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;density&lt;/code&gt;: How many rows and columns to create. A range of 1 to 50 works well; try starting with 8.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;speed&lt;/code&gt;: How fast to make the lights vary their color. Higher values cause lights to flash faster and vary in color more. A range of 1 to 20 works well; try starting with 3.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;groupSize&lt;/code&gt;: How many lights to place in each group. A range of 1 to 8 works well depending on your density; starting with 1.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;brightness&lt;/code&gt;: How bright to make the lights. A range of 0.2 to 10 works well; try starting with 3.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .padding()&#xA;                .drawingGroup()&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .colorEffect(&#xA;                            ShaderLibrary.lightGrid(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime),&#xA;                                .float(8),&#xA;                                .float(3),&#xA;                                .float(1),&#xA;                                .float(3)&#xA;                            )&#xA;                        )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Passthrough&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that sends back the existing color data, changing nothing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&#34;üè≥Ô∏è‚Äçüåà&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.passthrough()&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rainbow Noise&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates dynamic, multi-colored noise.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .colorEffect(&#xA;                    ShaderLibrary.rainbowNoise(&#xA;                        .float(elapsedTime)&#xA;                    )&#xA;                )&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Recolor&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; that changes input colors to a replacement, while respecting the current alpha value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;replacement&lt;/code&gt;: The replacement color to use for pixels.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&#34;üí™&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.recolor(&#xA;            .color(.blue)&#xA;        )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Relative Wave&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;distortionEffect()&lt;/code&gt; shader that generates a wave effect, where no effect is applied on the left side of the input, and the full effect is applied on the right side.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;speed&lt;/code&gt;: How fast to make the waves ripple. Try starting with a value of 5.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;smoothing&lt;/code&gt;: How much to smooth out the ripples, where greater values produce a smoother effect. Try starting with a value of 20.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How pronounced to make the ripple effect. Try starting with a value of 5.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .padding()&#xA;                .background(.background)&#xA;                .drawingGroup()&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .distortionEffect(&#xA;                            ShaderLibrary.relativeWave(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime),&#xA;                                .float(5),&#xA;                                .float(20),&#xA;                                .float(5)&#xA;                            ),&#xA;                            maxSampleOffset: .zero&#xA;                        )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Simple Loupe&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;layerEffect()&lt;/code&gt; shader that creates a circular zoom effect over a precise location.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;touch&lt;/code&gt;: The location the user is touching, where the zoom should be centered.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;maxDistance&lt;/code&gt;: How big to make the zoomed area. Try starting with 0.05.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;zoomFactor&lt;/code&gt;: How much to zoom the contents of the loupe.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var touchLocation = CGPoint.zero&#xA;&#xA;    var body: some View {&#xA;        Image(systemName: &#34;figure.walk.circle&#34;)&#xA;            .font(.system(size: 300))&#xA;            .padding()&#xA;            .background(.background)&#xA;            .drawingGroup()&#xA;            .visualEffect { content, proxy in&#xA;                content&#xA;                    .layerEffect(&#xA;                        ShaderLibrary.simpleLoupe(&#xA;                            .float2(proxy.size),&#xA;                            .float2(touchLocation),&#xA;                            .float(0.05),&#xA;                            .float(2)&#xA;                        ),&#xA;                        maxSampleOffset: .zero&#xA;                    )&#xA;            }&#xA;            .gesture(&#xA;                DragGesture(minimumDistance: 0)&#xA;                    .onChanged { touchLocation = $0.location }&#xA;            )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sinebow&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates multiple twisting and turning lines that cycle through colors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Rectangle()&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .colorEffect(&#xA;                            ShaderLibrary.sinebow(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime)&#xA;                            )&#xA;                        )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Warping Loupe&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;layerEffect()&lt;/code&gt; shader that creates a circular zoom effect over a precise location, with variable zoom around the touch area to create a glass orb-like effect.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;touch&lt;/code&gt;: The location the user is touching, where the zoom should be centered.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;maxDistance&lt;/code&gt;: How big to make the zoomed area. Try starting with 0.05.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;zoomFactor&lt;/code&gt;: How much to zoom the contents of the loupe.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var touchLocation = CGPoint.zero&#xA;&#xA;    var body: some View {&#xA;        Image(systemName: &#34;figure.walk.circle&#34;)&#xA;            .font(.system(size: 300))&#xA;            .padding()&#xA;            .background(.background)&#xA;            .drawingGroup()&#xA;            .visualEffect { content, proxy in&#xA;                content&#xA;                    .layerEffect(&#xA;                        ShaderLibrary.warpingLoupe(&#xA;                            .float2(proxy.size),&#xA;                            .float2(touchLocation),&#xA;                            .float(0.05),&#xA;                            .float(2)&#xA;                        ),&#xA;                        maxSampleOffset: .zero&#xA;                    )&#xA;            }&#xA;            .gesture(&#xA;                DragGesture(minimumDistance: 0)&#xA;                    .onChanged { touchLocation = $0.location }&#xA;            )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Water&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;distortionEffect()&lt;/code&gt; shader that generates a water rippling effect.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;speed&lt;/code&gt;: How fast to make the water ripple. Ranges from 0.5 to 10 work best; try starting with 3.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How pronounced the rippling effect should be. Ranges from 1 to 5 work best; try starting with 3.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;frequency&lt;/code&gt;: How often ripples should be created. Ranges from 5 to 25 work best; try starting with 10.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .padding()&#xA;                .background(.background)&#xA;                .drawingGroup()&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .distortionEffect(&#xA;                            ShaderLibrary.water(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime),&#xA;                                .float(3),&#xA;                                .float(3),&#xA;                                .float(10)&#xA;                            ),&#xA;                            maxSampleOffset: .zero&#xA;                        )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Wave&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;distortionEffect()&lt;/code&gt; shader that generates a wave effect, where no effect is applied on the left side of the input, and the full effect is applied on the right side.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;speed&lt;/code&gt;: How fast to make the waves ripple. Try starting with a value of 5.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;smoothing&lt;/code&gt;: How much to smooth out the ripples, where greater values produce a smoother effect. Try starting with a value of 10.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How pronounced to make the ripple effect. Try starting with a value of 5.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .padding()&#xA;                .background(.background)&#xA;                .drawingGroup()&#xA;                .distortionEffect(&#xA;                    ShaderLibrary.wave(&#xA;                        .float(elapsedTime),&#xA;                        .float(5),&#xA;                        .float(10),&#xA;                        .float(5)&#xA;                    ),&#xA;                    maxSampleOffset: .zero&#xA;                )&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;White Noise&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates dynamic, grayscale noise.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .colorEffect(&#xA;                    ShaderLibrary.whiteNoise(&#xA;                        .float(elapsedTime)&#xA;                    )&#xA;                )&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Transitions included in Inferno&lt;/h2&gt; &#xA;&lt;p&gt;As well as the shaders listed above, Inferno provides a selection of shaders specifically designed to be used as transitions. Although these are still Metal shaders internally, you&#39;ll use them through &lt;code&gt;AnyTransition&lt;/code&gt; extensions that make the process seamless.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!Note] As well as copying one specific shader into your project, you should also add Transitions.swift to include the &lt;code&gt;AnyTransition&lt;/code&gt; extensions.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Circle&lt;/h3&gt; &#xA;&lt;p&gt;A transition where many circles grow upwards to reveal the new content.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: How big to make the circles.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.circles(size: 20))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.circles(size: 20))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Circle Wave&lt;/h3&gt; &#xA;&lt;p&gt;A transition where many circles grow upwards to reveal the new content, with the circles moving outwards from the top-left edge.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: How big to make the circles.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.circleWave(size: 20))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.circleWave(size: 20))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Crosswarp LTR&lt;/h3&gt; &#xA;&lt;p&gt;A transition that stretches and fades pixels starting from the left edge.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.crosswarpLTR)&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.crosswarpLTR)&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Crosswarp RTL&lt;/h3&gt; &#xA;&lt;p&gt;A transition that stretches and fades pixels starting from the right edge.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.crosswarpRTL)&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.crosswarpRTL)&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Diamond&lt;/h3&gt; &#xA;&lt;p&gt;A transition that makes a variety of diamonds simultaneously zoom up across the screen.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: How big to make the diamonds.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.diamonds(size: 20))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.diamonds(size: 20))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Diamond Wave&lt;/h3&gt; &#xA;&lt;p&gt;A transition that makes a variety of circles zoom up across the screen, based on their X/Y position.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: How big to make the diamonds. Defaults to 20.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.diamondWave(size: 20))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.diamondWave(size: 20))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Pixellate&lt;/h3&gt; &#xA;&lt;p&gt;A transition that causes the incoming and outgoing views to become increasingly pixellated, then return to their normal state. While this happens the old view fades out and the new one fades in.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;squares&lt;/code&gt;: How large the pixels should be. Defaults to 20.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;steps&lt;/code&gt;: How many steps to use for the animation. Lower values make the pixels jump in more noticeable size increments, which creates very interesting retro effects. Defaults to 60.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.pixellate(squares: 20, steps: 20))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.pixellate(squares: 20, steps: 20))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Radial&lt;/h3&gt; &#xA;&lt;p&gt;A transition that creates an old-school radial wipe, starting from straight up.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.radial)&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.radial)&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swirl&lt;/h3&gt; &#xA;&lt;p&gt;A transition that increasingly twists the contents of the incoming and outgoing views, then untwists them to complete the transition. As this happens the two views fade to move smoothly from one to the other.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;radius&lt;/code&gt;: How large the swirl should be relative to the view it&#39;s transitioning. Defaults to 0.5.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.swirl(radius: 0.5))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.swirl(radius: 0.5))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Wind&lt;/h3&gt; &#xA;&lt;p&gt;A transition that makes it look the pixels of one image are being blown away horizontally.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: How big the wind streaks should be, relative to the view&#39;s width. Defaults to 0.2.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.wind())&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.wind())&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Inferno Sandbox&lt;/h2&gt; &#xA;&lt;p&gt;Inside this repository is an example SwiftUI project for macOS that demonstrate each of the shaders with some example values ‚Äì try running them if you‚Äôre curious how each of the shaders look or perform.&lt;/p&gt; &#xA;&lt;p&gt;If you‚Äôve modified one of the shaders and want to see how it looks, the sandbox is the best place. If you click the &#34;Toggle Opacity&#34; toolbar button, preview content will alternate between opacity 0 and 1 so you can make sure your modifications blend correctly.&lt;/p&gt; &#xA;&lt;p&gt;All shaders here work great on all devices that support macOS Sonoma and coordinated releases, including iOS 17.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!Tip] Although the sandbox is helpful for previewing shaders, almost all its code isn&#39;t required in order to use Inferno shaders in your own projects ‚Äì you just need to copy the relevant Metal files across, and optionally also Transitions.swift if you&#39;re using a transition shader.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;I made Inferno because not enough people know that shaders are powerful, easy ways to add special effects to your apps. If you‚Äôd like to contribute your own shaders or modifications to existing shaders, that‚Äôs great! But first please read the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Inferno has a strong emphasis on readability. Beginners should be able to read most of these shaders and have a good idea of how they work. If you want to make one of the shaders faster, please don‚Äôt do so at the expensive of readability.&lt;/li&gt; &#xA; &lt;li&gt;You must comment your code thoroughly. Shaders are often extremely terse, so please write in English above every line what the code does ‚Äì&amp;nbsp;a transliteration, if you will ‚Äì&amp;nbsp;and also provide a description of how it all works to produce the final result.&lt;/li&gt; &#xA; &lt;li&gt;All code must be licensed under the MIT license so it can benefit the most people.&lt;/li&gt; &#xA; &lt;li&gt;Please add your code to the Inferno Sandbox app, so folks can try it out easily.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT License.&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2023 Paul Hudson and other authors.&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt; &#xA;&lt;p&gt;Inferno was made by &lt;a href=&#34;https://twitter.com/twostraws&#34;&gt;Paul Hudson&lt;/a&gt;, who writes &lt;a href=&#34;https://www.hackingwithswift.com&#34;&gt;free Swift tutorials over at Hacking with Swift&lt;/a&gt;. It‚Äôs available under the MIT license, which permits commercial use, modification, distribution, and private use.&lt;/p&gt; &#xA;&lt;p&gt;Some shaders were ported to Metal by me, from other open-source samples also released under the MIT license. All credit for their code goes to their original authors; all mistakes and similar are obviously my fault!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Circle, Circle Wave, Diamond, Diamond Wave are based on &lt;a href=&#34;https://gl-transitions.com/editor/PolkaDotsCurtain&#34;&gt;Polka Dots Curtain&lt;/a&gt; by bobylito.&lt;/li&gt; &#xA; &lt;li&gt;Crosswarp is based on &lt;a href=&#34;https://gl-transitions.com/editor/crosswarp&#34;&gt;Crosswarp&lt;/a&gt; by Eke P√©ter.&lt;/li&gt; &#xA; &lt;li&gt;Radial is based on &lt;a href=&#34;https://gl-transitions.com/editor/Radial&#34;&gt;Radial&lt;/a&gt; by Xaychru / gre.&lt;/li&gt; &#xA; &lt;li&gt;Swirl is based on &lt;a href=&#34;https://gl-transitions.com/editor/Swirl&#34;&gt;Swirl&lt;/a&gt; by Sergey Kosarevsky / gre.&lt;/li&gt; &#xA; &lt;li&gt;Wind is based on &lt;a href=&#34;https://gl-transitions.com/editor/wind&#34;&gt;Wind&lt;/a&gt; by gre.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Where to learn more&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re keen to learn more about Metal shaders, here are the resources I recommend:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.thebookofshaders.com&#34;&gt;The Book of Shaders&lt;/a&gt; has taught countless thousands of people how to build shaders, and contains comprehensive descriptions. Note: This is written for GLSL, but the concepts still apply to Metal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.shadertoy.com&#34;&gt;ShaderToy&lt;/a&gt; contains all sorts of fantastic shader ideas where you gain inspiration, plus all their code is there to learn from. Again this is written for GLSL, but you can transfer to Metal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.gl-transitions.com&#34;&gt;GL Transitions&lt;/a&gt; contains a variety of open-source GLSL transitions for inspiration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.apple.com/metal&#34;&gt;Apple&#39;s Metal documentation&lt;/a&gt; goes into great detail on the many other usages of Metal ‚Äì&amp;nbsp;we&#39;ve just covered fragment shaders here, but it can do so much more!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.hackingwithswift.com/plus&#34;&gt;Hacking with Swift+&lt;/a&gt; contains a tutorial series teaching how to build Metal shaders for use with SwiftUI, going into much more depth on how the shaders actually work.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.hackingwithswift.com/plus&#34;&gt; &lt;img src=&#34;https://www.hackingwithswift.com/img/hws-plus-banner@2x.jpg&#34; alt=&#34;Hacking with Swift+ logo&#34; style=&#34;max-width: 100%;&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&amp;nbsp;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.hackingwithswift.com&#34;&gt;&lt;img src=&#34;https://www.hackingwithswift.com/img/hws-button@2x.png&#34; alt=&#34;Hacking with Swift logo&#34; width=&#34;66&#34; height=&#34;75&#34;&gt;&lt;/a&gt;&lt;br&gt; A Hacking with Swift Project &lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>BuilderIO/gpt-crawler</title>
    <updated>2023-11-26T01:46:22Z</updated>
    <id>tag:github.com,2023-11-26:/BuilderIO/gpt-crawler</id>
    <link href="https://github.com/BuilderIO/gpt-crawler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Crawl a site to generate knowledge files to create your own custom GPT from a URL&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GPT Crawler &#xA; &lt;!-- omit from toc --&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Crawl a site to generate knowledge files to create your own custom GPT from one or multiple URLs&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/BuilderIO/gpt-crawler/assets/844291/feb8763a-152b-4708-9c92-013b5c70d2f2&#34; alt=&#34;Gif showing the crawl run&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#example&#34;&gt;Example&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#get-started&#34;&gt;Get started&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#running-locally&#34;&gt;Running locally&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#clone-the-repository&#34;&gt;Clone the repository&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#install-dependencies&#34;&gt;Install dependencies&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#configure-the-crawler&#34;&gt;Configure the crawler&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#run-your-crawler&#34;&gt;Run your crawler&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#alternative-methods&#34;&gt;Alternative methods&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#running-in-a-container-with-docker&#34;&gt;Running in a container with Docker&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#running-as-a-cli&#34;&gt;Running as a CLI&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#development&#34;&gt;Development&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#upload-your-data-to-openai&#34;&gt;Upload your data to OpenAI&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#create-a-custom-gpt&#34;&gt;Create a custom GPT&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#create-a-custom-assistant&#34;&gt;Create a custom assistant&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://chat.openai.com/g/g-kywiqipmR-builder-io-assistant&#34;&gt;Here is a custom GPT&lt;/a&gt; that I quickly made to help answer questions about how to use and integrate &lt;a href=&#34;https://www.builder.io&#34;&gt;Builder.io&lt;/a&gt; by simply providing the URL to the Builder docs.&lt;/p&gt; &#xA;&lt;p&gt;This project crawled the docs and generated the file that I uploaded as the basis for the custom GPT.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://chat.openai.com/g/g-kywiqipmR-builder-io-assistant&#34;&gt;Try it out yourself&lt;/a&gt; by asking questions about how to integrate Builder.io into a site.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note that you may need a paid ChatGPT plan to access this feature&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Get started&lt;/h2&gt; &#xA;&lt;h3&gt;Running locally&lt;/h3&gt; &#xA;&lt;h4&gt;Clone the repository&lt;/h4&gt; &#xA;&lt;p&gt;Be sure you have Node.js &amp;gt;= 16 installed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/builderio/gpt-crawler&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Install dependencies&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm i&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Configure the crawler&lt;/h4&gt; &#xA;&lt;p&gt;Open &lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/config.ts&#34;&gt;config.ts&lt;/a&gt; and edit the &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;selectors&lt;/code&gt; properties to match your needs.&lt;/p&gt; &#xA;&lt;p&gt;E.g. to crawl the Builder.io docs to make our custom GPT you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export const defaultConfig: Config = {&#xA;  url: &#34;https://www.builder.io/c/docs/developers&#34;,&#xA;  match: &#34;https://www.builder.io/c/docs/**&#34;,&#xA;  selector: `.docs-builder-container`,&#xA;  maxPagesToCrawl: 50,&#xA;  outputFileName: &#34;output.json&#34;,&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/src/config.ts&#34;&gt;config.ts&lt;/a&gt; for all available options. Here is a sample of the common configu options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;type Config = {&#xA;  /** URL to start the crawl */&#xA;  url: string;&#xA;  /** Pattern to match against for links on a page to subsequently crawl */&#xA;  match: string;&#xA;  /** Selector to grab the inner text from */&#xA;  selector: string;&#xA;  /** Don&#39;t crawl more than this many pages */&#xA;  maxPagesToCrawl: number;&#xA;  /** File name for the finished data */&#xA;  outputFileName: string;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Run your crawler&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Alternative methods&lt;/h3&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://raw.githubusercontent.com/BuilderIO/gpt-crawler/main/containerapp/README.md&#34;&gt;Running in a container with Docker&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;p&gt;To obtain the &lt;code&gt;output.json&lt;/code&gt; with a containerized execution. Go into the &lt;code&gt;containerapp&lt;/code&gt; directory. Modify the &lt;code&gt;config.ts&lt;/code&gt; same as above, the &lt;code&gt;output.json&lt;/code&gt;file should be generated in the data folder. Note : the &lt;code&gt;outputFileName&lt;/code&gt; property in the &lt;code&gt;config.ts&lt;/code&gt; file in containerapp folder is configured to work with the container.&lt;/p&gt; &#xA;&lt;h3&gt;Upload your data to OpenAI&lt;/h3&gt; &#xA;&lt;p&gt;The crawl will generate a file called &lt;code&gt;output.json&lt;/code&gt; at the root of this project. Upload that &lt;a href=&#34;https://platform.openai.com/docs/assistants/overview&#34;&gt;to OpenAI&lt;/a&gt; to create your custom assistant or custom GPT.&lt;/p&gt; &#xA;&lt;h4&gt;Create a custom GPT&lt;/h4&gt; &#xA;&lt;p&gt;Use this option for UI access to your generated knowledge that you can easily share with others&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: you may need a paid ChatGPT plan to create and use custom GPTs right now&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Go to &lt;a href=&#34;https://chat.openai.com/&#34;&gt;https://chat.openai.com/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Click your name in the bottom left corner&lt;/li&gt; &#xA; &lt;li&gt;Choose &#34;My GPTs&#34; in the menu&lt;/li&gt; &#xA; &lt;li&gt;Choose &#34;Create a GPT&#34;&lt;/li&gt; &#xA; &lt;li&gt;Choose &#34;Configure&#34;&lt;/li&gt; &#xA; &lt;li&gt;Under &#34;Knowledge&#34; choose &#34;Upload a file&#34; and upload the file you generated&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/BuilderIO/gpt-crawler/assets/844291/22f27fb5-6ca5-4748-9edd-6bcf00b408cf&#34; alt=&#34;Gif of how to upload a custom GPT&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Create a custom assistant&lt;/h4&gt; &#xA;&lt;p&gt;Use this option for API access to your generated knowledge that you can integrate into your product.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Go to &lt;a href=&#34;https://platform.openai.com/assistants&#34;&gt;https://platform.openai.com/assistants&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Click &#34;+ Create&#34;&lt;/li&gt; &#xA; &lt;li&gt;Choose &#34;upload&#34; and upload the file you generated&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/BuilderIO/gpt-crawler/assets/844291/06e6ad36-e2ba-4c6e-8d5a-bf329140de49&#34; alt=&#34;Gif of how to upload to an assistant&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Know how to make this project better? Send a PR!&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.builder.io/m/developers&#34;&gt; &#xA;  &lt;picture&gt; &#xA;   &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://user-images.githubusercontent.com/844291/230786554-eb225eeb-2f6b-4286-b8c2-535b1131744a.png&#34;&gt; &#xA;   &lt;img width=&#34;250&#34; alt=&#34;Made with love by Builder.io&#34; src=&#34;https://user-images.githubusercontent.com/844291/230786555-a58479e4-75f3-4222-a6eb-74c5af953eac.png&#34;&gt; &#xA;  &lt;/picture&gt; &lt;/a&gt; &lt;/p&gt;</summary>
  </entry>
</feed>