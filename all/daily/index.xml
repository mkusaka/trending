<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-27T01:27:34Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>felix-pb/kfd</title>
    <updated>2023-07-27T01:27:34Z</updated>
    <id>tag:github.com,2023-07-27:/felix-pb/kfd</id>
    <link href="https://github.com/felix-pb/kfd" rel="alternate"></link>
    <summary type="html">&lt;p&gt;kfd, short for kernel file descriptor, is a project to read and write kernel memory on Apple devices.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;kfd&lt;/h1&gt; &#xA;&lt;p&gt;kfd, short for kernel file descriptor, is a project to read and write kernel memory on Apple devices. It leverages various vulnerabilities that can be exploited to obtain dangling PTEs, which will be referred to as a PUAF primitive, short for &#34;physical use-after-free&#34;. Then, it reallocates certain kernel objects inside those physical pages and manipulates them directly from user space through the dangling PTEs in order to achieve a KRKW primitive, short for &#34;kernel read/write&#34;. The exploit code is fully contained in a library, &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/libkfd.h&#34;&gt;libkfd&lt;/a&gt;, but the project also contains simple executable wrappers for &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/ContentView.swift&#34;&gt;iOS&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/macos_kfd.c&#34;&gt;macOS&lt;/a&gt;. The public API of libkfd is quite small and intuitive:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;enum puaf_method {&#xA;    puaf_physpuppet,&#xA;    puaf_smith,&#xA;};&#xA;&#xA;enum kread_method {&#xA;    kread_kqueue_workloop_ctl,&#xA;    kread_sem_open,&#xA;};&#xA;&#xA;enum kwrite_method {&#xA;    kwrite_dup,&#xA;    kwrite_sem_open,&#xA;};&#xA;&#xA;u64 kopen(u64 puaf_pages, u64 puaf_method, u64 kread_method, u64 kwrite_method);&#xA;void kread(u64 kfd, u64 kaddr, void* uaddr, u64 size);&#xA;void kwrite(u64 kfd, void* uaddr, u64 kaddr, u64 size);&#xA;void kclose(u64 kfd);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;kopen()&lt;/code&gt; conceptually opens a &#34;kernel file descriptor&#34;. It takes the following 4 arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;puaf_pages&lt;/code&gt;: The target number of physical pages with dangling PTEs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;puaf_method&lt;/code&gt;: The method used to obtain the PUAF primitive, with the following options: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;puaf_physpuppet&lt;/code&gt;: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;This method exploits &lt;a href=&#34;https://support.apple.com/en-us/HT213676&#34;&gt;CVE-2023-23536&lt;/a&gt;.&lt;/li&gt; &#xA;     &lt;li&gt;Fixed in iOS 16.4 and macOS 13.3.&lt;/li&gt; &#xA;     &lt;li&gt;Reachable from the App Sandbox but not the WebContent sandbox.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;puaf_smith&lt;/code&gt;: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;This method exploits &lt;a href=&#34;https://support.apple.com/en-us/HT213814&#34;&gt;CVE-2023-32434&lt;/a&gt;.&lt;/li&gt; &#xA;     &lt;li&gt;Fixed in iOS 16.5.1 and macOS 13.4.1.&lt;/li&gt; &#xA;     &lt;li&gt;Reachable from the WebContent sandbox and might have been actively exploited.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;kread_method&lt;/code&gt;: The method used to obtain the initial &lt;code&gt;kread()&lt;/code&gt; primitive.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;kwrite_method&lt;/code&gt;: The method used to obtain the initial &lt;code&gt;kwrite()&lt;/code&gt; primitive.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If the exploit is successful, &lt;code&gt;kopen()&lt;/code&gt; returns a 64-bit opaque file descriptor. In practice, this is just a user space pointer to a structure needed by libkfd. However, since that structure should not be accessed outside of the library, it is returned as an opaque integer. If the exploit is unsuccessful, the library will print an error message, sleep for 30 seconds, then exit with a status code of 1. It sleeps for 30 seconds because the kernel might panic on exit for certain PUAF methods that require some cleanup post-KRKW (e.g. &lt;code&gt;puaf_smith&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;kread()&lt;/code&gt; and &lt;code&gt;kwrite()&lt;/code&gt; are the user space equivalent of &lt;code&gt;copyout()&lt;/code&gt; and &lt;code&gt;copyin()&lt;/code&gt;, respectively. Please note that the options for &lt;code&gt;kread_method&lt;/code&gt; and &lt;code&gt;kwrite_method&lt;/code&gt; are described in a separate &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/writeups/exploiting-puafs.md&#34;&gt;write-up&lt;/a&gt;. In addition, the initial primitives granted by those methods can be used to bootstrap a better KRKW primitive. Finally, &lt;code&gt;kclose()&lt;/code&gt; simply closes the kernel file descriptor. They all take the opaque integer returned by &lt;code&gt;kopen()&lt;/code&gt; as their first argument.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;What are the supported OS versions and devices?&lt;/h2&gt; &#xA;&lt;p&gt;The later stage of the exploit makes use of various offsets. For the structures that have identical offsets across all versions that I tested, I simply included their definitions under the &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/libkfd/info/static_types/&#34;&gt;static_types&lt;/a&gt; folder. For the structures that have different offsets, I built offset tables for them under the &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/libkfd/info/dynamic_types/&#34;&gt;dynamic_types&lt;/a&gt; folder. Then, I map the &#34;kern.osversion&#34; of the device to the appropriate index for those offset tables. Please check the function &lt;code&gt;info_init()&lt;/code&gt;, located in &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/libkfd/info.h&#34;&gt;info.h&lt;/a&gt;, for the list of currently supported iOS and macOS versions. However, please note that I only tested the exploits on an iPhone 14 Pro Max and a MacBook Air (M2 2022). Therefore, it is possible that the offsets are actually different on other devices, even for the same OS version. Keep this in mind if you get a &#34;Kernel data abort&#34; panic on a &#34;supported&#34; version. Fortunately, those offsets should all be easily retrievable from the XNU source code.&lt;/p&gt; &#xA;&lt;p&gt;On the other hand, in order to bootstrap the better KRKW primitive, the exploit makes use of certain static addresses which must be retrieved from the kernelcache. This is a tedious process, which I only carried out for the kernelcaches of certain iOS versions on the iPhone 14 Pro Max. Please check the function &lt;code&gt;perf_init()&lt;/code&gt;, located in &lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/kfd/libkfd/perf.h&#34;&gt;perf.h&lt;/a&gt;, for the list of currently supported versions. Note that none of the exploits require the better KRKW primitive in order to succeed. However, if you plan on doing research based on this project, then it is probably worthwhile to add support for the better KRKW primitive for your own device!&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;How to build and run kfd on an iPhone?&lt;/h2&gt; &#xA;&lt;p&gt;In Xcode, open the root folder of the project and connect your iOS device.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To build the project, select Product &amp;gt; Build (⌘B).&lt;/li&gt; &#xA; &lt;li&gt;To run the project, select Product &amp;gt; Run (⌘R), then click on the &#34;kopen&#34; button in the app.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;How to build and run kfd on a Mac?&lt;/h2&gt; &#xA;&lt;p&gt;In a terminal, navigate to the root folder of the project.&lt;/p&gt; &#xA;&lt;p&gt;Optionally, to increase the global and per-process file descriptor limits, which will improve the success rate especially on multiple consecutive runs, enter the command &lt;code&gt;make s&lt;/code&gt; and type in the sudo password.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To build the project, enter the command &lt;code&gt;make b&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To run the project, enter the command &lt;code&gt;make r&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To build and run the project at once, enter the command &lt;code&gt;make br&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Where to find detailed write-ups for the exploits?&lt;/h2&gt; &#xA;&lt;p&gt;This README presented a high-level overview of the kfd project. Once a PUAF primitive has been achieved, the rest of the exploit is generic. Therefore, I have hoisted the common part of the exploits in a dedicated write-up:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/writeups/exploiting-puafs.md&#34;&gt;Exploiting PUAFs&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition, I have split the vulnerability-specific part of the exploits used to achieve the PUAF primitive into distinct write-ups, listed below in chronological order of discovery:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/writeups/physpuppet.md&#34;&gt;PhysPuppet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/felix-pb/kfd/main/writeups/smith.md&#34;&gt;Smith&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;However, please note that these write-ups have been written for an audience that is already familiar with the XNU virtual memory system.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>liltom-eth/llama2-webui</title>
    <updated>2023-07-27T01:27:34Z</updated>
    <id>tag:github.com,2023-07-27:/liltom-eth/llama2-webui</id>
    <link href="https://github.com/liltom-eth/llama2-webui" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Run Llama 2 locally with gradio UI on GPU or CPU from anywhere (Linux/Windows/Mac). Supporting Llama-2-7B/13B/70B with 8-bit, 4-bit. Supporting GPU inference (6 GB VRAM) and CPU inference.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;llama2-webui&lt;/h1&gt; &#xA;&lt;p&gt;Running Llama 2 with gradio web UI on GPU or CPU from anywhere (Linux/Windows/Mac).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supporting all Llama 2 models (7B, 13B, 70B, GPTQ, GGML) with 8-bit, 4-bit mode.&lt;/li&gt; &#xA; &lt;li&gt;Supporting GPU inference with at least 6 GB VRAM, and CPU inference.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/static/screenshot.png&#34; alt=&#34;screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Supporting models: &lt;a href=&#34;https://huggingface.co/TheBloke/Llama-2-7B-Chat-GGML&#34;&gt;Llama-2-7b&lt;/a&gt;/&lt;a href=&#34;https://huggingface.co/llamaste/Llama-2-13b-chat-hf&#34;&gt;13b&lt;/a&gt;/&lt;a href=&#34;https://huggingface.co/llamaste/Llama-2-70b-chat-hf&#34;&gt;70b&lt;/a&gt;, all &lt;a href=&#34;https://huggingface.co/TheBloke/Llama-2-7b-Chat-GPTQ&#34;&gt;Llama-2-GPTQ&lt;/a&gt;, all &lt;a href=&#34;https://huggingface.co/TheBloke/Llama-2-7B-Chat-GGML&#34;&gt;Llama-2-GGML&lt;/a&gt; ...&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Supporting model backends&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Nvidia GPU: tranformers, &lt;a href=&#34;https://github.com/TimDettmers/bitsandbytes&#34;&gt;bitsandbytes(8-bit inference)&lt;/a&gt;, &lt;a href=&#34;https://github.com/PanQiWei/AutoGPTQ&#34;&gt;AutoGPTQ(4-bit inference)&lt;/a&gt;&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;GPU inference with at least 6 GB VRAM&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;CPU, Mac/AMD GPU: &lt;a href=&#34;https://github.com/ggerganov/llama.cpp&#34;&gt;llama.cpp&lt;/a&gt;&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;CPU inference &lt;a href=&#34;https://twitter.com/liltom_eth/status/1682791729207070720?s=20&#34;&gt;Demo&lt;/a&gt; on Macbook Air.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Web UI interface: gradio&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#install&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#download-llama-2-models&#34;&gt;Download Llama-2 Models&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#model-list&#34;&gt;Model List&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#download-script&#34;&gt;Download Script&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#config-examples&#34;&gt;Config Examples&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#start-web-ui&#34;&gt;Start Web UI&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#run-on-nvidia-gpu&#34;&gt;Run on Nvidia GPU&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#run-on-low-memory-gpu-with-8-bit&#34;&gt;Run on Low Memory GPU with 8 bit&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#run-on-low-memory-gpu-with-4-bit&#34;&gt;Run on Low Memory GPU with 4 bit&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#run-on-cpu&#34;&gt;Run on CPU&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#mac-gpu-and-amdnvidia-gpu-acceleration&#34;&gt;Mac GPU and AMD/Nvidia GPU Acceleration&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;bitsandbytes &amp;gt;= 0.39&lt;/code&gt; may not work on older NVIDIA GPUs. In that case, to use &lt;code&gt;LOAD_IN_8BIT&lt;/code&gt;, you may have to downgrade like this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pip install bitsandbytes==0.38.1&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;bitsandbytes&lt;/code&gt; also need a special install for Windows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip uninstall bitsandbytes&#xA;pip install https://github.com/jllllll/bitsandbytes-windows-webui/releases/download/wheels/bitsandbytes-0.41.0-py3-none-win_amd64.whl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If run on CPU, install llama.cpp additionally by &lt;code&gt;pip install llama-cpp-python&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Download Llama-2 Models&lt;/h2&gt; &#xA;&lt;p&gt;Llama 2 is a collection of pre-trained and fine-tuned generative text models ranging in scale from 7 billion to 70 billion parameters.&lt;/p&gt; &#xA;&lt;p&gt;Llama-2-7b-Chat-GPTQ is the GPTQ model files for &lt;a href=&#34;https://huggingface.co/meta-llama/Llama-2-7b-chat-hf&#34;&gt;Meta&#39;s Llama 2 7b Chat&lt;/a&gt;. GPTQ 4-bit Llama-2 model require less GPU VRAM to run it.&lt;/p&gt; &#xA;&lt;h3&gt;Model List&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Model Name&lt;/th&gt; &#xA;   &lt;th&gt;set MODEL_PATH in .env&lt;/th&gt; &#xA;   &lt;th&gt;Download URL&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;meta-llama/Llama-2-7b-chat-hf&lt;/td&gt; &#xA;   &lt;td&gt;/path-to/Llama-2-7b-chat-hf&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/llamaste/Llama-2-7b-chat-hf&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;meta-llama/Llama-2-13b-chat-hf&lt;/td&gt; &#xA;   &lt;td&gt;/path-to/Llama-2-13b-chat-hf&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/llamaste/Llama-2-13b-chat-hf&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;meta-llama/Llama-2-70b-chat-hf&lt;/td&gt; &#xA;   &lt;td&gt;/path-to/Llama-2-70b-chat-hf&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/llamaste/Llama-2-70b-chat-hf&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;meta-llama/Llama-2-7b-hf&lt;/td&gt; &#xA;   &lt;td&gt;/path-to/Llama-2-7b-hf&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/meta-llama/Llama-2-7b-hf&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;meta-llama/Llama-2-13b-hf&lt;/td&gt; &#xA;   &lt;td&gt;/path-to/Llama-2-13b-hf&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/meta-llama/Llama-2-13b-hf&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;meta-llama/Llama-2-70b-hf&lt;/td&gt; &#xA;   &lt;td&gt;/path-to/Llama-2-70b-hf&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/meta-llama/Llama-2-70b-hf&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TheBloke/Llama-2-7b-Chat-GPTQ&lt;/td&gt; &#xA;   &lt;td&gt;/path-to/Llama-2-7b-Chat-GPTQ&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/TheBloke/Llama-2-7b-Chat-GPTQ&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TheBloke/Llama-2-7B-Chat-GGML&lt;/td&gt; &#xA;   &lt;td&gt;/path-to/llama-2-7b-chat.ggmlv3.q4_0.bin&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/TheBloke/Llama-2-7B-Chat-GGML&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;...&lt;/td&gt; &#xA;   &lt;td&gt;...&lt;/td&gt; &#xA;   &lt;td&gt;...&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Running 4-bit model &lt;code&gt;Llama-2-7b-Chat-GPTQ&lt;/code&gt; needs GPU with 6GB VRAM.&lt;/p&gt; &#xA;&lt;p&gt;Running 4-bit model &lt;code&gt;llama-2-7b-chat.ggmlv3.q4_0.bin&lt;/code&gt; needs CPU with 6GB RAM. There is also a list of other 2, 3, 4, 5, 6, 8-bit GGML models that can be used from &lt;a href=&#34;https://huggingface.co/TheBloke/Llama-2-7B-Chat-GGML&#34;&gt;TheBloke/Llama-2-7B-Chat-GGML&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Download Script&lt;/h3&gt; &#xA;&lt;p&gt;These models can be downloaded from the link using CMD like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Make sure you have git-lfs installed (https://git-lfs.com)&#xA;git lfs install&#xA;git clone git@hf.co:meta-llama/Llama-2-7b-chat-hf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To download Llama 2 models, you need to request access from &lt;a href=&#34;https://ai.meta.com/llama/&#34;&gt;https://ai.meta.com/llama/&lt;/a&gt; and also enable access on repos like &lt;a href=&#34;https://huggingface.co/meta-llama/Llama-2-7b-chat-hf/tree/main&#34;&gt;meta-llama/Llama-2-7b-chat-hf&lt;/a&gt;. Requests will be processed in hours.&lt;/p&gt; &#xA;&lt;p&gt;For GPTQ models like &lt;a href=&#34;https://huggingface.co/TheBloke/Llama-2-7b-Chat-GPTQ&#34;&gt;TheBloke/Llama-2-7b-Chat-GPTQ&lt;/a&gt;, you can directly download without requesting access.&lt;/p&gt; &#xA;&lt;p&gt;For GGML models like &lt;a href=&#34;https://huggingface.co/TheBloke/Llama-2-7B-Chat-GGML&#34;&gt;TheBloke/Llama-2-7B-Chat-GGML&lt;/a&gt;, you can directly download without requesting access.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Config Examples&lt;/h3&gt; &#xA;&lt;p&gt;Setup your &lt;code&gt;MODEL_PATH&lt;/code&gt; and model configs in &lt;code&gt;.env&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;There are some examples in &lt;code&gt;./env_examples/&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Model Setup&lt;/th&gt; &#xA;   &lt;th&gt;Example .env&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Llama-2-7b-chat-hf 8-bit on GPU&lt;/td&gt; &#xA;   &lt;td&gt;.env.7b_8bit_example&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Llama-2-7b-Chat-GPTQ 4-bit on GPU&lt;/td&gt; &#xA;   &lt;td&gt;.env.7b_gptq_example&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Llama-2-7B-Chat-GGML 4bit on CPU&lt;/td&gt; &#xA;   &lt;td&gt;.env.7b_ggmlv3_q4_0_example&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Llama-2-13b-chat-hf on GPU&lt;/td&gt; &#xA;   &lt;td&gt;.env.13b_example&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;...&lt;/td&gt; &#xA;   &lt;td&gt;...&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Start Web UI&lt;/h3&gt; &#xA;&lt;p&gt;Run chatbot with web UI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python app.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run on Nvidia GPU&lt;/h3&gt; &#xA;&lt;p&gt;The running requires around 14GB of GPU VRAM for Llama-2-7b and 28GB of GPU VRAM for Llama-2-13b.&lt;/p&gt; &#xA;&lt;p&gt;If you are running on multiple GPUs, the model will be loaded automatically on GPUs and split the VRAM usage. That allows you to run Llama-2-7b (requires 14GB of GPU VRAM) on a setup like 2 GPUs (11GB VRAM each).&lt;/p&gt; &#xA;&lt;h4&gt;Run on Low Memory GPU with 8 bit&lt;/h4&gt; &#xA;&lt;p&gt;If you do not have enough memory, you can set up your &lt;code&gt;LOAD_IN_8BIT&lt;/code&gt; as &lt;code&gt;True&lt;/code&gt; in &lt;code&gt;.env&lt;/code&gt;. This can reduce memory usage by around half with slightly degraded model quality. It is compatible with the CPU, GPU, and Metal backend.&lt;/p&gt; &#xA;&lt;p&gt;Llama-2-7b with 8-bit compression can run on a single GPU with 8 GB of VRAM, like an Nvidia RTX 2080Ti, RTX 4080, T4, V100 (16GB).&lt;/p&gt; &#xA;&lt;h4&gt;Run on Low Memory GPU with 4 bit&lt;/h4&gt; &#xA;&lt;p&gt;If you want to run 4 bit Llama-2 model like &lt;code&gt;Llama-2-7b-Chat-GPTQ&lt;/code&gt;, you can set up your &lt;code&gt;LOAD_IN_4BIT&lt;/code&gt; as &lt;code&gt;True&lt;/code&gt; in &lt;code&gt;.env&lt;/code&gt; like example &lt;code&gt;.env.7b_gptq_example&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Make sure you have downloaded the 4-bit model from &lt;code&gt;Llama-2-7b-Chat-GPTQ&lt;/code&gt; and set the &lt;code&gt;MODEL_PATH&lt;/code&gt; and arguments in &lt;code&gt;.env&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Llama-2-7b-Chat-GPTQ&lt;/code&gt; can run on a single GPU with 6 GB of VRAM.&lt;/p&gt; &#xA;&lt;h3&gt;Run on CPU&lt;/h3&gt; &#xA;&lt;p&gt;Run Llama-2 model on CPU requires &lt;a href=&#34;https://github.com/ggerganov/llama.cpp&#34;&gt;llama.cpp&lt;/a&gt; dependency and &lt;a href=&#34;https://github.com/abetlen/llama-cpp-python&#34;&gt;llama.cpp Python Bindings&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install llama-cpp-python&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Download GGML models like &lt;code&gt;llama-2-7b-chat.ggmlv3.q4_0.bin&lt;/code&gt; following &lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/#download-llama-2-models&#34;&gt;Download Llama-2 Models&lt;/a&gt; section. &lt;code&gt;llama-2-7b-chat.ggmlv3.q4_0.bin&lt;/code&gt; model requires at least 6 GB RAM to run on CPU.&lt;/p&gt; &#xA;&lt;p&gt;Set up configs like &lt;code&gt;.env.7b_ggmlv3_q4_0_example&lt;/code&gt; from &lt;code&gt;env_examples&lt;/code&gt; as &lt;code&gt;.env&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Run web UI &lt;code&gt;python app.py&lt;/code&gt; .&lt;/p&gt; &#xA;&lt;h4&gt;Mac GPU and AMD/Nvidia GPU Acceleration&lt;/h4&gt; &#xA;&lt;p&gt;If you would like to use Mac GPU and AMD/Nvidia GPU for acceleration, check these:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/abetlen/llama-cpp-python#installation-with-openblas--cublas--clblast--metal&#34;&gt;Installation with OpenBLAS / cuBLAS / CLBlast / Metal&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/abetlen/llama-cpp-python/raw/main/docs/install/macos.md&#34;&gt;MacOS Install with Metal GPU&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Kindly read our &lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/CONTRIBUTING.md&#34;&gt;Contributing Guide&lt;/a&gt; to learn and understand about our development process.&lt;/p&gt; &#xA;&lt;h3&gt;All Contributors&lt;/h3&gt; &#xA;&lt;a href=&#34;https://github.com/liltom-eth/llama2-webui/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=liltom-eth/llama2-webui&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT - see &lt;a href=&#34;https://raw.githubusercontent.com/liltom-eth/llama2-webui/main/LICENSE&#34;&gt;MIT License&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This project enables users to adapt it freely for proprietary purposes without any restrictions.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://huggingface.co/meta-llama/Llama-2-7b-chat-hf&#34;&gt;https://huggingface.co/meta-llama/Llama-2-7b-chat-hf&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://huggingface.co/spaces/huggingface-projects/llama-2-7b-chat&#34;&gt;https://huggingface.co/spaces/huggingface-projects/llama-2-7b-chat&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://huggingface.co/TheBloke/Llama-2-7b-Chat-GPTQ&#34;&gt;https://huggingface.co/TheBloke/Llama-2-7b-Chat-GPTQ&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ggerganov/llama.cpp&#34;&gt;https://github.com/ggerganov/llama.cpp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/TimDettmers/bitsandbytes&#34;&gt;https://github.com/TimDettmers/bitsandbytes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/PanQiWei/AutoGPTQ&#34;&gt;https://github.com/PanQiWei/AutoGPTQ&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>karpathy/llama2.c</title>
    <updated>2023-07-27T01:27:34Z</updated>
    <id>tag:github.com,2023-07-27:/karpathy/llama2.c</id>
    <link href="https://github.com/karpathy/llama2.c" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Inference Llama 2 in one file of pure C&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;llama2.c&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/assets/llama_cute.jpg&#34; width=&#34;300&#34; height=&#34;300&#34;&gt; &#xA;&lt;p&gt;With the code in this repo you can train the Llama 2 LLM architecture from scratch in PyTorch, then export the weights to a binary file, and load that into one ~simple 500-line C file (&lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/run.c&#34;&gt;run.c&lt;/a&gt;) that inferences the model. Alternatively, you can load, finetune, and inference Meta&#39;s Llama 2 (but this is still being actively fleshed out). Hence, this repo is a &#34;fullstack&#34; train + inference solution for Llama 2 LLM, with a focus on minimalism and simplicity. You might think that you need many billion parameter LLMs to do anything useful, but in fact very small LLMs can have surprisingly strong performance if you make the domain narrow enough. I recommend looking at the &lt;a href=&#34;https://huggingface.co/datasets/roneneldan/TinyStories&#34;&gt;TinyStories&lt;/a&gt; paper for inspiration.&lt;/p&gt; &#xA;&lt;p&gt;Please note that this started recently as just a fun weekend project: I took my earlier &lt;a href=&#34;https://github.com/karpathy/nanoGPT&#34;&gt;nanoGPT&lt;/a&gt;, tuned it to implement the Llama-2 architecture instead of GPT-2, and the meat of it was writing the C inference engine in &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/run.c&#34;&gt;run.c&lt;/a&gt;. So the project is young and moving quickly. Hat tip to the awesome &lt;a href=&#34;https://github.com/ggerganov/llama.cpp&#34;&gt;llama.cpp&lt;/a&gt; for inspiring this project. I wanted something super minimal so I chose to hard-code the Llama 2 architecture, stick to fp32, and just roll one inference file of pure C with no dependencies.&lt;/p&gt; &#xA;&lt;h2&gt;feel the magic&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s just run a baby Llama 2 model in C. You need a model checkpoint. Download this 15M parameter model I trained on the &lt;a href=&#34;https://huggingface.co/datasets/roneneldan/TinyStories&#34;&gt;TinyStories&lt;/a&gt; dataset (~60MB download):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compile and run the C code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make run&#xA;./run stories15M.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll see the text stream a sample. On my M1 MacBook Air this runs at ~110 tokens/s. See &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/#performance&#34;&gt;performance&lt;/a&gt; or the Makefile for compile flags that can significantly speed this up. We can also try a bit bigger 42M parameter model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin&#xA;./run stories42M.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This still runs at interactive rates and samples more coherent and diverse stories:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Once upon a time, there was a little girl named Lily. She loved playing with her toys on top of her bed. One day, she decided to have a tea party with her stuffed animals. She poured some tea into a tiny teapot and put it on top of the teapot. Suddenly, her little brother Max came into the room and wanted to join the tea party too. Lily didn&#39;t want to share her tea and she told Max to go away. Max started to cry and Lily felt bad. She decided to yield her tea party to Max and they both shared the teapot. But then, something unexpected happened. The teapot started to shake and wiggle. Lily and Max were scared and didn&#39;t know what to do. Suddenly, the teapot started to fly towards the ceiling and landed on the top of the bed. Lily and Max were amazed and they hugged each other. They realized that sharing was much more fun than being selfish. From that day on, they always shared their tea parties and toys.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;There is also an even better 110M param model available, see &lt;a href=&#34;https://raw.githubusercontent.com/karpathy/llama2.c/master/#models&#34;&gt;models&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Meta&#39;s Llama 2 models&lt;/h2&gt; &#xA;&lt;p&gt;As the neural net architecture is identical, we can also inference the Llama 2 models released by Meta. Sadly there is a bit of friction here due to licensing (I can&#39;t directly upload the checkpoints, I think). So Step 1, get the Llama 2 checkpoints by following the &lt;a href=&#34;https://github.com/facebookresearch/llama&#34;&gt;Meta instructions&lt;/a&gt;. Once we have those checkpoints, we have to convert them into the llama2.c format. For this we use the &lt;code&gt;export_meta_llama_bin.py&lt;/code&gt; file, e.g. for 7B model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python export_meta_llama_bin.py path/to/llama/model/7B llama2_7b.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The export will take ~10 minutes or so and generate a 26GB file (the weights of the 7B model in float32) called &lt;code&gt;llama2_7b.bin&lt;/code&gt; in the current directory. It has been &lt;a href=&#34;https://github.com/karpathy/llama2.c/pull/85&#34;&gt;reported&lt;/a&gt; that despite efforts, the 13B export currently doesn&#39;t work for unknown reaons (accepting PRs for fix). We can run the model as normal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./run llama2_7b.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This ran at about 4 tokens/s compiled with OpenMP on 96 threads on my CPU Linux box in the cloud. (On my MacBook Air M1, currently it&#39;s closer to 30 seconds per token if you just build with &lt;code&gt;make runfast&lt;/code&gt;.) Example output:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The purpose of this document is to highlight the state-of-the-art of CoO generation technologies, both recent developments and those in commercial use. The focus is on the technologies with the highest merit to become the dominating processes of the future and therefore to be technologies of interest to S&amp;amp;T ... R&amp;amp;D. As such, CoO generation technologies developed in Russia, Japan and Europe are described in some depth. The document starts with an introduction to cobalt oxides as complex products and a short view on cobalt as an essential material. The document continues with the discussion of the available CoO generation processes with respect to energy and capital consumption as well as to environmental damage.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;base models... ¯\&lt;em&gt;(ツ)&lt;/em&gt;/¯. Since we can inference the base model, it should be possible to also inference the chat model quite easily, and have a conversation with it. And if we can find a way to run 7B more efficiently, we can start adding LoRA to our training script, and going wild with finetunes all within the repo!&lt;/p&gt; &#xA;&lt;h2&gt;models&lt;/h2&gt; &#xA;&lt;p&gt;For the sake of examples of smaller, from-scratch models, I trained a small model series on TinyStories. All of these trained in a few hours on my training setup (4X A100 40GB GPUs). The 110M took around 24 hours. I am hosting them on huggingface hub &lt;a href=&#34;https://huggingface.co/karpathy/tinyllamas&#34;&gt;tinyllamas&lt;/a&gt;, both in the original PyTorch .pt, and also in the llama2.c format .bin:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;model&lt;/th&gt; &#xA;   &lt;th&gt;dim&lt;/th&gt; &#xA;   &lt;th&gt;n_layers&lt;/th&gt; &#xA;   &lt;th&gt;n_heads&lt;/th&gt; &#xA;   &lt;th&gt;max context length&lt;/th&gt; &#xA;   &lt;th&gt;parameters&lt;/th&gt; &#xA;   &lt;th&gt;val loss&lt;/th&gt; &#xA;   &lt;th&gt;download&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OG&lt;/td&gt; &#xA;   &lt;td&gt;288&lt;/td&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;256&lt;/td&gt; &#xA;   &lt;td&gt;15M&lt;/td&gt; &#xA;   &lt;td&gt;1.072&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin&#34;&gt;stories15M.bin&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;42M&lt;/td&gt; &#xA;   &lt;td&gt;512&lt;/td&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;1024&lt;/td&gt; &#xA;   &lt;td&gt;42M&lt;/td&gt; &#xA;   &lt;td&gt;0.847&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin&#34;&gt;stories42M.bin&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;110M&lt;/td&gt; &#xA;   &lt;td&gt;768&lt;/td&gt; &#xA;   &lt;td&gt;12&lt;/td&gt; &#xA;   &lt;td&gt;12&lt;/td&gt; &#xA;   &lt;td&gt;1024&lt;/td&gt; &#xA;   &lt;td&gt;110M&lt;/td&gt; &#xA;   &lt;td&gt;0.760&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://huggingface.co/karpathy/tinyllamas/resolve/main/stories110M.bin&#34;&gt;stories110M.bin&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;You&#39;ll notice that the 110M model is equivalent to GPT-1 in size. Alternatively, this is also the smallest model in the GPT-2 series (&lt;code&gt;GPT-2 small&lt;/code&gt;), except the max context length is only 1024 instead of 2048. The only notable changes from GPT-1/2 architecture is that Llama uses RoPE relatively positional embeddings instead of absolute/learned positional embeddings, a bit more fancy SwiGLU non-linearity in the MLP, RMSNorm instead of LayerNorm, bias=False on all Linear layers, and is optionally multiquery (but this is not yet supported in llama2.c).&lt;/p&gt; &#xA;&lt;h2&gt;training&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s see how we can train a baby Llama 2 from scratch using the code in this repo. First let&#39;s download and pretokenize some source dataset, e.g. I like &lt;a href=&#34;https://huggingface.co/datasets/roneneldan/TinyStories&#34;&gt;TinyStories&lt;/a&gt; so this is the only example currently available in this repo. But it should be very easy to add datasets, see the code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python tinystories.py download&#xA;python tinystories.py pretokenize&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then train our model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python train.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;brief training guide&lt;/strong&gt;. See the train.py script for more exotic launches and hyperparameter overrides. Here is a brief guide to how to set the parameters. Look at the table at the very end of the &lt;a href=&#34;https://arxiv.org/abs/2203.15556&#34;&gt;Chinchilla paper&lt;/a&gt; to get a sense of how the Transformer parameters (dim, n_layers, n_heads) grow or shrink together. Extrapolate/interpolate this pattern to get bigger or smaller transformers. Set the max context length however you wish, depending on the problem: this should be the max number of tokens that matter to predict the next token. E.g. Llama 2 uses 2048. Next, you want the &lt;em&gt;total&lt;/em&gt; batch size per update (printed by the script as &#34;tokens per iteration will be:&#34;) to be somewhere around 100K tokens for medium-sized applications. For tiny applications it could be lower, for large training (e.g. GPTs/LLamas) it is usually ~0.5M, or even more. You get there by first maxing out the batch_size to whatever your system allows (e.g. mine was 16 in a recent run because after that my GPU runs out of memory), and then you want to increase gradient_accumulation_steps to be as high as necessary to reach the total batch size of ~100K. Finally, you want to tune your learning_rate (LR). You want this to be as high as your training allows. Very small networks can get away with a large LR (e.g. 1e-3 or even higher). Large networks need lower LRs. 3e-4 is a safe choice in most medium-sized applications, but can be too low for small networks, so try to increase it! Finally, max_iters is the length of training. Play with different settings. I mostly only ever tune these parameters and leave most of the others unchanged. Here is an example of how I trained the 110M model, which I don&#39;t think is anywhere near optimal, but looked sensible to me: dim 768, n_layers 12, n_heads 12 (so size of each head is 768 / 12 = 64 channels), seq len of 1024, batch size 16 (this is the most that fit my A100 40GB GPU), gradient_accumulation_steps = 8 was needed to get total tokens batch size to be 16 batch size * 1024 tokens in sequence * 8 grad_accum = 131,072 tokens per update. Good. Learning rate 4e-4 (probably a little too low). max_iters 200K (probably a bit too high). Dropout 0.1, as that usually helps a bit at medium size. That was it. I ran using Distributed Data Parallel (DDP) on 4 GPUs on my cloud machine, training took ~day or so.&lt;/p&gt; &#xA;&lt;p&gt;Totally understand if you want to skip model training, for simple demo just download my pretrained model and save it into the directory &lt;code&gt;out&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://karpathy.ai/llama2c/model.bin -P out&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once we have the model.bin file, we can inference in C. Compile the C code first:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -O3 -o run run.c -lm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now run it simply as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./run out/model.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Watch the tokens stream by, fun! We can also run the PyTorch inference script for comparison (to run, add &lt;a href=&#34;https://drive.google.com/file/d/1SM0rMxzy7babB-v4MfTg1GFqOCgWar5w/view?usp=share_link&#34;&gt;model.ckpt&lt;/a&gt; to /out if you haven&#39;t already):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python sample.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which gives the same results. More detailed testing will be done in &lt;code&gt;test_all.py&lt;/code&gt;, run as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pytest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Currently you will need two files to test or sample: the &lt;a href=&#34;https://drive.google.com/file/d/1aTimLdx3JktDXxcHySNrZJOOk8Vb1qBR/view?usp=share_link&#34;&gt;model.bin&lt;/a&gt; file and the &lt;a href=&#34;https://drive.google.com/file/d/1SM0rMxzy7babB-v4MfTg1GFqOCgWar5w/view?usp=share_link&#34;&gt;model.ckpt&lt;/a&gt; file from PyTorch training I ran earlier. I have to think through running the tests without having to download 200MB of data.&lt;/p&gt; &#xA;&lt;h2&gt;performance&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;(NOTE: this guide is not great because I personally spend a lot of my time in Python land and don&#39;t have an amazing understanding of a lot of these features and flags. If someone does and is willing to help document and briefly describe some of these and their tradeoffs, I&#39;d welcome a PR)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are many ways to potentially speed up this code depending on your system. Here we document a few together with a high-level guide on what they do. Here&#39;s again the default way to compile, but using -O3:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -O3 -o run run.c -lm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;-O3 includes optimizations that are expensive in terms of compile time and memory usage. Including vectorization, loop unrolling, and predicting branches. Here&#39;s a few more to try.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-Ofast&lt;/code&gt; Run additional optimizations which may break compliance with the C/IEEE specifications, in addition to &lt;code&gt;-O3&lt;/code&gt;. See &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&#34;&gt;the GCC docs&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;-march=native&lt;/code&gt; Compile the program to use the architecture of the machine you&#39;re compiling on rather than a more generic CPU. This may enable additional optimizations and hardware-specific tuning such as improved vector instructions/width.&lt;/p&gt; &#xA;&lt;p&gt;The fastest throughput I saw so far on my MacBook Air (M1) is with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -Ofast -o run run.c -lm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also experiment with replacing &lt;code&gt;gcc&lt;/code&gt; with &lt;code&gt;clang&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;OpenMP&lt;/strong&gt; Big improvements can also be achieved by compiling with OpenMP, which &#34;activates&#34; the &lt;code&gt;#pragma omp parallel for&lt;/code&gt; inside the matmul and attention. You can compile e.g. like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;clang -Ofast -fopenmp -march=native run.c  -lm  -o run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can try swapping clang/gcc, and may try to leave out -march=native. However, when you run inference make sure to use OpenMP flags to set the number of threads, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;OMP_NUM_THREADS=4 ./run out/model.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Depending on your system resources you may want to tweak these hyperparameters. (TODO: I am not intimately familiar with OpenMP and its configuration, if someone would like to flesh out this section I would welcome a PR).&lt;/p&gt; &#xA;&lt;h2&gt;unsorted todos&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;why is there a leading space in C sampling code when we &lt;code&gt;./run&lt;/code&gt;?&lt;/li&gt; &#xA; &lt;li&gt;support Llama 2 Chat models, and tune run.c to Chat UI/UX&lt;/li&gt; &#xA; &lt;li&gt;possibly include emscripten / web backend (as seen in @gg PR)&lt;/li&gt; &#xA; &lt;li&gt;currently the project only runs in fp32, want to explore more reduced precision inference.&lt;/li&gt; &#xA; &lt;li&gt;todo multiquery support? doesn&#39;t seem as useful for smaller models that run on CPU (?)&lt;/li&gt; &#xA; &lt;li&gt;todo support inferencing beyond max_seq_len steps, have to think through the kv cache&lt;/li&gt; &#xA; &lt;li&gt;why is MFU so low (~10%) on my A100 40GB for training?&lt;/li&gt; &#xA; &lt;li&gt;weird errors with torch.compile and wandb when using DDP&lt;/li&gt; &#xA; &lt;li&gt;(LoRA) finetuning of Llama 2 models&lt;/li&gt; &#xA; &lt;li&gt;make more better tests to decrease yolo&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;ack&lt;/h2&gt; &#xA;&lt;p&gt;I trained the llama2.c storyteller models on a 4X A100 40GB box graciously provided by the excellent &lt;a href=&#34;https://lambdalabs.com/service/gpu-cloud&#34;&gt;Lambda labs&lt;/a&gt;, thank you.&lt;/p&gt; &#xA;&lt;h2&gt;discord&lt;/h2&gt; &#xA;&lt;p&gt;Figured it&#39;s possible to reuse my existing discord channel (that I use for my &lt;a href=&#34;https://karpathy.ai/zero-to-hero.html&#34;&gt;zero to hero youtube series&lt;/a&gt;), see #llama2c channel on &lt;a href=&#34;https://discord.gg/3zy8kqD9Cp&#34;&gt;discord&lt;/a&gt;, for any quick questions, related discussions, etc.&lt;/p&gt; &#xA;&lt;h2&gt;contributing&lt;/h2&gt; &#xA;&lt;p&gt;A few words on this repo and the kinds of PRs that are likely to be accepted. What is the goal of this repo? Basically I think there will be a lot of interest in training or finetuning custom micro-LLMs (think ~100M - ~1B params, but let&#39;s say up to ~10B params) across a large diversity of applications, and deploying them in edge-adjacent environments (think MCUs, phones, web browsers, laptops, etc.). I&#39;d like this repo to be the simplest, smallest, most hackable repo to support this workflow, both training and inference. In particular, this repo is not a complex framework with a 1000 knobs controlling inscrutible code across a nested directory structure of hundreds of files. Instead, I expect most applications will wish to create a fork of this repo and hack it to their specific needs and deployment platforms.&lt;/p&gt; &#xA;&lt;p&gt;People who care about deployment efficiency above all else should look at &lt;a href=&#34;https://github.com/ggerganov/llama.cpp&#34;&gt;llama.cpp&lt;/a&gt;. This repo still cares about efficiency, but not at the cost of simplicity, readability or portability. Basically, I expect that a lot of people come to this repo because the training code is 2 readable .py files and the inference code is 500 lines of C. So I&#39;d like this to continue to be a kind of simplest &#34;reference implementation&#34; that can be easily hacked in a separate fork into whatever downstream application people are excited about. It shouldn&#39;t be full-featured. It shouldn&#39;t take 100 different options or settings. It shouldn&#39;t be the most efficient. A few examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;someone re-ordered two loops to improve data locality for a small efficieny win =&amp;gt; instant merge.&lt;/li&gt; &#xA; &lt;li&gt;someone added the one line &#34;pragma omp parallel for&#34;, which allows you to compile with OpenMP and dramatically speed up the code, or acts as just a comment if you don&#39;t compile it that way =&amp;gt; instant merge.&lt;/li&gt; &#xA; &lt;li&gt;bug fixes and touchups etc. =&amp;gt; happy to merge&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A few examples of PRs are that are not an excellent fit:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;adding more than several #ifdefs all over the place in code. If they are localized / few, might be okay.&lt;/li&gt; &#xA; &lt;li&gt;adding a lot of code that is very specific to some specific platform (e.g. MCUs, or some special version of linux or processor). These may be a better fit for forks of the project, and I am very happy to maintain a list of these forks in section below.&lt;/li&gt; &#xA; &lt;li&gt;adding hundreds of lines of code to run.c that are only active in specific scenarios or platforms.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If your candidate PRs have elements of these it doesn&#39;t mean they won&#39;t get merged, it just means they will make it into the gray territory. TLDR: I am eager to merge any mostly small, mostly localized, broadly applicable, clean changes that improve the efficiency and portability of the repo, while keep its hackability and readability. I appreciate all PRs seeking to help me improve the project, thank you! &amp;lt;3.&lt;/p&gt; &#xA;&lt;h2&gt;notable forks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gaxler/llama2.rs&#34;&gt;llama2.rs&lt;/a&gt; by @gaxler: a Rust port of this project&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT&lt;/p&gt;</summary>
  </entry>
</feed>