<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-21T01:27:23Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>xuchengsheng/spring-reading</title>
    <updated>2023-11-21T01:27:23Z</updated>
    <id>tag:github.com,2023-11-21:/xuchengsheng/spring-reading</id>
    <link href="https://github.com/xuchengsheng/spring-reading" rel="alternate"></link>
    <summary type="html">&lt;p&gt;涵盖了 Spring 框架的核心概念和关键功能，包括控制反转（IOC）容器的使用，面向切面编程（AOP）的原理与实践，事务管理的方式与实现，Spring MVC 的流程与控制器工作机制，以及 Spring 中数据访问、安全、Boot 自动配置等方面的深入研究。此外，它还包含了 Spring 事件机制的应用、高级主题如缓存抽象和响应式编程，以及对 Spring 源码的编程风格与设计模式的深入探讨。&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img alt=&#34;logo&#34; src=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/image/banner.png&#34; style=&#34;height: 80px&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h2&gt;深入Spring，从源码开始！&lt;/h2&gt; &#xA; &lt;h4&gt;探索Java最受欢迎的框架，理解它的内部机制，带大家从入门到精通。&lt;/h4&gt; &#xA;&lt;/div&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/xuchengsheng/spring-reading/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/xuchengsheng/spring-reading?logo=github&amp;amp;logoColor=%23EF2D5E&amp;amp;label=Stars&amp;amp;labelColor=%23000000&amp;amp;color=%23EF2D5E&amp;amp;cacheSeconds=3600&#34; alt=&#34;Stars Badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xuchengsheng&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/followers/xuchengsheng?label=Followers&amp;amp;logo=github&amp;amp;logoColor=%23FC521F&amp;amp;labelColor=%231A2477&amp;amp;color=%23FC521F&amp;amp;cacheSeconds=3600&#34; alt=&#34;Follow Badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xuchengsheng/spring-reading/fork&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/forks/xuchengsheng/spring-reading?label=Forks&amp;amp;logo=github&amp;amp;logoColor=%23F2BB13&amp;amp;labelColor=%23BE2323&amp;amp;color=%23F2BB13&#34; alt=&#34;Fork Badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xuchengsheng/spring-reading/watchers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/watchers/xuchengsheng/spring-reading?label=Watchers&amp;amp;logo=github&amp;amp;logoColor=%23FF4655&amp;amp;labelColor=%234169E1&amp;amp;color=%23FF4655&amp;amp;cacheSeconds=3600&#34; alt=&#34;Watchers Badge&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://visitor-badge.lithub.cc/badge?page_id=github.com/xuchengsheng&amp;amp;left_text=Visitors&#34; alt=&#34;Visitor Badge&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/WeChat-xcs19930428-%2307C160?logo=wechat&#34; alt=&#34;Wechat Badge&#34;&gt; &lt;a href=&#34;https://blog.csdn.net/duzhuang2399&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/dynamic/xml?url=https%3A%2F%2Fblog.csdn.net%2Fduzhuang2399&amp;amp;query=%2F%2F*%5B%40id%3D%22userSkin%22%5D%2Fdiv%5B1%5D%2Fdiv%5B2%5D%2Fdiv%5B1%5D%2Fdiv%2Fdiv%5B2%5D%2Fdiv%5B1%5D%2Fdiv%5B1%5D%2Fdiv%5B2%5D%2Fspan&amp;amp;logo=C&amp;amp;logoColor=red&amp;amp;label=CSDN&amp;amp;color=red&amp;amp;cacheSeconds=3600&#34; alt=&#34;CSDN Badge&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; ⚡ &lt;a href=&#34;#技术&#34;&gt;技术&lt;/a&gt; | 👋 &lt;a href=&#34;#简介&#34;&gt;简介&lt;/a&gt; | 🍵 &lt;a href=&#34;#为何做Spring源码分析&#34;&gt;Why&lt;/a&gt; | 🙏 &lt;a href=&#34;#顺手点个星&#34;&gt;点个星&lt;/a&gt; | 🌱 &lt;a href=&#34;#spring-源码阅读系列&#34;&gt;Spring源码&lt;/a&gt; | 💬 &lt;a href=&#34;#与我联系&#34;&gt;联系我&lt;/a&gt; | ⛵ &lt;a href=&#34;#欢迎贡献&#34;&gt;贡献&lt;/a&gt; | 🔄 &lt;a href=&#34;#持续更新中&#34;&gt;更新&lt;/a&gt; | 💻 &lt;a href=&#34;#我的-github-统计&#34;&gt;统计&lt;/a&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;⚡技术&lt;/h2&gt; &#xA;&lt;div align=&#34;left&#34;&gt; &#xA; &lt;img src=&#34;https://img.shields.io/badge/Java-1.8%2B-%23437291?logo=openjdk&amp;amp;logoColor=%23437291&#34;&gt; &#xA; &lt;img src=&#34;https://img.shields.io/badge/Spring-5.3.10-%23437291?logo=Spring&amp;amp;logoColor=%236DB33F&amp;amp;color=%236DB33F&#34;&gt; &#xA; &lt;img src=&#34;https://img.shields.io/badge/SpringBoot-2.5.5-%23437291?logo=SpringBoot&amp;amp;logoColor=%236DB33F&amp;amp;color=%236DB33F&#34;&gt; &#xA; &lt;img src=&#34;https://img.shields.io/badge/Maven-3.6.3-%23437291?logo=Apache%20Maven&amp;amp;logoColor=%23C71A36&amp;amp;color=%23C71A36&#34;&gt; &#xA; &lt;img src=&#34;https://img.shields.io/badge/JSR-330-%2366CCFF?logo=OpenJDK&amp;amp;logoColor=%2366CCFF&amp;amp;color=%2366CCFF&#34;&gt; &#xA; &lt;img src=&#34;https://img.shields.io/badge/JSR-250-%23FF9900?logo=OpenJDK&amp;amp;logoColor=%23FF9900&amp;amp;color=%23FF9900&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;👋简介&lt;/h2&gt; &#xA;&lt;p&gt;大家好呀，我是Lex👨‍💻。我是一名拥有8年经验的Java 后端开发人员👨‍💼，也是一个对 Spring 框架充满热情❤️的程序员。为了帮助那些希望深入了解 Spring 框架的程序员们🧑‍💻，我创建了这个 “Spring 源码阅读系列”📖。通过这个系列，我希望能够与你们共同探索 Spring 的内部工作机制⚙️。如果您有同样的兴趣或问题🤔，请联系我📩！&lt;/p&gt; &#xA;&lt;h2&gt;🍵&lt;strong&gt;为何做Spring源码分析&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;在我作为框架研发的开发者👨‍🔬的工作中，我经常遇到需要深入理解和调整框架行为的情况🔧。这些工作不只是简单地使用框架的API，更多地是需要对框架的内部工作方式有详细的了解🔍。虽然Github上有关于Spring的简化版本📦，这些对于入门学习确实有很大的帮助✅，但当涉及到真实的项目应用时，与真正的Spring框架还是有很大的差异❌。因此，我开始深入研究Spring的源码，希望能够更透彻地理解其内部的工作机制，以便更好地应用到我的实际工作中🧰。分享我的源码分析📝，也是为了给那些希望真正理解Spring，而不仅仅是使用它的开发者提供一些参考和帮助🙌。&lt;/p&gt; &#xA;&lt;h2&gt;🙏顺手点个星&lt;/h2&gt; &#xA;&lt;p&gt;亲爱的朋友们👥，我真的花了很多心思💭去研究和整理这个“Spring 源码阅读系列”📘。如果你觉得这东西还不错👍，或者给你带来了一点点帮助🤗，麻烦点一下星星吧🌟。这真的对我意义重大🎖，每一颗星✨都能让我觉得所有的努力都是值得的💪。我知道这是小事一桩，但你的那一下点击🖱，对我来说就是最好的鼓励🎉。无论如何，都要感谢你抽时间🕰阅读我的内容，真的很感激🙏！&lt;/p&gt; &#xA;&lt;h2&gt;🌱Spring 源码阅读系列&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h3&gt;👑 基础知识&lt;/h3&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;em&gt;Spring 框架中的资源加载与访问、元数据操作、Bean定义与注册，以及Bean定义的读取与扫描。&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-resources/spring-resource/README.md&#34;&gt;&lt;strong&gt;资源加载Resource&lt;/strong&gt;&lt;/a&gt; - 处理 Spring 框架中与资源加载相关的功能。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-resources/spring-resource-resourceLoader/README.md&#34;&gt;&lt;strong&gt;资源加载器ResourceLoader&lt;/strong&gt;&lt;/a&gt; - 实现资源加载器接口，用于获取应用程序的资源。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-resources/spring-resource-documentLoader/README.md&#34;&gt;&lt;strong&gt;文档加载器DocumentLoader&lt;/strong&gt;&lt;/a&gt; - 负责加载文档资源，支持不同文档格式的加载。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-metadata/spring-metadata-metadataReader/README.md&#34;&gt;&lt;strong&gt;元数据读取MetadataReader&lt;/strong&gt;&lt;/a&gt; - 提供对类元数据的访问和读取功能。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-metadata/spring-metadata-annotationMetadata/README.md&#34;&gt;&lt;strong&gt;注解元数据AnnotationMetadata&lt;/strong&gt;&lt;/a&gt; - 处理与注解相关的元数据，支持对注解属性的访问。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-beans/spring-bean-beanDefinition/README.md&#34;&gt;&lt;strong&gt;Bean定义BeanDefinition&lt;/strong&gt;&lt;/a&gt; - 定义 Spring 容器中的 Bean，包括属性、构造函数等信息。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-beans/spring-bean-beanDefinitionHolder/README.md&#34;&gt;&lt;strong&gt;Bean定义持有者BeanDefinitionHolder&lt;/strong&gt;&lt;/a&gt; - 持有 BeanDefinition 对象以及与之关联的名称和别名。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-beans/spring-bean-beanDefinitionRegistry/README.md&#34;&gt;&lt;strong&gt;Bean定义注册器BeanDefinitionRegistry&lt;/strong&gt;&lt;/a&gt; - 用于注册和管理 Bean 定义的接口。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-beans/spring-bean-xmlBeanDefinitionReader/README.md&#34;&gt;&lt;strong&gt;XML Bean定义读取器XmlBeanDefinitionReader&lt;/strong&gt;&lt;/a&gt; - 从 XML 文件中读取并注册 Bean 定义。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-beans/spring-bean-propertiesBeanDefinitionReader/README.md&#34;&gt;&lt;strong&gt;属性文件Bean定义读取器PropertiesBeanDefinitionReader&lt;/strong&gt;&lt;/a&gt; - 从属性文件中读取并注册 Bean 定义。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-beans/spring-bean-groovyBeanDefinitionReader/README.md&#34;&gt;&lt;strong&gt;Groovy脚本Bean定义读取器GroovyBeanDefinitionReader&lt;/strong&gt;&lt;/a&gt; - 从 Groovy 脚本中读取并注册 Bean 定义。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-beans/spring-bean-annotatedBeanDefinitionReader/README.md&#34;&gt;&lt;strong&gt;注解Bean定义读取器AnnotatedBeanDefinitionReader&lt;/strong&gt;&lt;/a&gt; - 从注解中读取并注册 Bean 定义。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-beans/spring-bean-classPathBeanDefinitionScanner/README.md&#34;&gt;&lt;strong&gt;类路径Bean定义扫描器ClassPathBeanDefinitionScanner&lt;/strong&gt;&lt;/a&gt; - 扫描类路径以注册 Bean 定义。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h3&gt;🔅 核心方法&lt;/h3&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;em&gt;Spring 框架背后的动力，这些核心方法确保了依赖注入、Bean 生命周期管理、配置解析和许多其他关键功能。&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-core/spring-core-getBean/README.md&#34;&gt;&lt;strong&gt;获取Bean实例getBean()&lt;/strong&gt;&lt;/a&gt; - 从Bean的定义到其实例化，全面揭示Spring如何管理Bean的生命周期。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-core/spring-core-resolveDependency/README.md&#34;&gt;&lt;strong&gt;解析依赖resolveDependency()&lt;/strong&gt;&lt;/a&gt; - 探索Spring如何优雅地解决Bean之间的依赖关系，确保应用稳定运行。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h3&gt;💡 后置处理器与初始化&lt;/h3&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;em&gt;深入 Spring 的后置处理技巧，揭示它如何优雅地初始化和管理 beans。&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-interface/spring-interface-beanDefinitionRegistryPostProcessor/README.md&#34;&gt;&lt;strong&gt;动态修改Bean定义BeanDefinitionRegistryPostProcessor&lt;/strong&gt;&lt;/a&gt; - 揭示如何修改应用的 bean 定义。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-interface/spring-interface-beanFactoryPostProcessor/README.md&#34;&gt;&lt;strong&gt;动态调整Bean配置BeanFactoryPostProcessor&lt;/strong&gt;&lt;/a&gt; - 理解 Spring 如何在 bean 初始化之前进行微调。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-interface/spring-interface-beanPostProcessor/README.md&#34;&gt;&lt;strong&gt;调整Bean属性BeanPostProcessor&lt;/strong&gt;&lt;/a&gt; - 探索如何在 bean 实例化后进行拦截。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-interface/spring-interface-instantiationAwareBeanPostProcessor/README.md&#34;&gt;&lt;strong&gt;Bean实例拦截InstantiationAwareBeanPostProcessor&lt;/strong&gt;&lt;/a&gt; - 理解它如何在实例化 bean 之前进行操作。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-interface/spring-interface-destructionAwareBeanPostProcessor/README.md&#34;&gt;&lt;strong&gt;管理Bean销毁周期DestructionAwareBeanPostProcessor&lt;/strong&gt;&lt;/a&gt; - 揭露它如何管理 bean 的销毁生命周期。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-interface/spring-interface-mergedBeanDefinitionPostProcessor/README.md&#34;&gt;&lt;strong&gt;Bean定义的动态处理MergedBeanDefinitionPostProcessor&lt;/strong&gt;&lt;/a&gt; - 理解如何合并 bean 的定义。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-interface/spring-interface-smartInstantiationAwareBeanPostProcessor/README.md&#34;&gt;&lt;strong&gt;调整Bean实例化策略SmartInstantiationAwareBeanPostProcessor&lt;/strong&gt;&lt;/a&gt; - 深入了解其智能实例化的策略。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-interface/spring-interface-initializingBean/README.md&#34;&gt;&lt;strong&gt;属性设置后的初始化操作InitializingBean&lt;/strong&gt;&lt;/a&gt; - 揭露如何在 bean 初始化后进行操作。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-interface/spring-interface-disposableBean/README.md&#34;&gt;&lt;strong&gt;资源清理与销毁DisposableBean&lt;/strong&gt;&lt;/a&gt; - 探查它如何确保 bean 的正确销毁。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-interface/spring-interface-smartInitializingSingleton/README.md&#34;&gt;&lt;strong&gt;All Beans完全初始化后SmartInitializingSingleton&lt;/strong&gt;&lt;/a&gt; - 理解它如何在所有单例 bean 初始化后进行操作。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h3&gt;🛠 Aware接口&lt;/h3&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;em&gt;探索 Spring 的自我感知能力，如何赋予 beans 更多的上下文感知特性。&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-beanNameAware/README.md&#34;&gt;&lt;strong&gt;获取Bean名称BeanNameAware&lt;/strong&gt;&lt;/a&gt; - 当一个 bean 需要知道其在容器中的名字时。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-beanClassLoaderAware/README.md&#34;&gt;&lt;strong&gt;获取类加载器BeanClassLoaderAware&lt;/strong&gt;&lt;/a&gt; - 揭示如何为 bean 提供类加载器的引用。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-beanFactoryAware/README.md&#34;&gt;&lt;strong&gt;与Bean工厂互动BeanFactoryAware&lt;/strong&gt;&lt;/a&gt; - 探索 bean 如何与其工厂互动。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-environmentAware/README.md&#34;&gt;&lt;strong&gt;感知运行环境EnvironmentAware&lt;/strong&gt;&lt;/a&gt; - 了解 bean 如何感知并与其运行的环境互动。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-embeddedValueResolverAware/README.md&#34;&gt;&lt;strong&gt;嵌入值解析EmbeddedValueResolverAware&lt;/strong&gt;&lt;/a&gt; - 探查如何提供字符串值解析策略给 bean。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-resourceLoaderAware/README.md&#34;&gt;&lt;strong&gt;资源加载策略ResourceLoaderAware&lt;/strong&gt;&lt;/a&gt; - 理解如何为 bean 提供一个资源加载器。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-applicationEventPublisherAware/README.md&#34;&gt;&lt;strong&gt;发布应用事件ApplicationEventPublisherAware&lt;/strong&gt;&lt;/a&gt; - 揭露 bean 如何发布事件到应用上下文。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-messageSourceAware/README.md&#34;&gt;&lt;strong&gt;访问消息源MessageSourceAware&lt;/strong&gt;&lt;/a&gt; - 深入了解 bean 如何访问消息源。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-applicationStartupAware/README.md&#34;&gt;&lt;strong&gt;感知应用启动过程ApplicationStartupAware&lt;/strong&gt;&lt;/a&gt; - 理解 bean 如何感知应用的启动过程。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-applicationContextAware/README.md&#34;&gt;&lt;strong&gt;访问应用上下文ApplicationContextAware&lt;/strong&gt;&lt;/a&gt; - 探索 bean 如何访问其运行的应用上下文。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-aware/spring-aware-importAware/README.md&#34;&gt;&lt;strong&gt;了解关联导入信息ImportAware&lt;/strong&gt;&lt;/a&gt; - 揭露 bean 如何知道与其关联的导入元数据。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h3&gt;🎖 核心注解&lt;/h3&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;em&gt;了解 Spring 如何通过注解驱动开发，简化和加强代码。&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-annotation/spring-annotation-configuration/README.md&#34;&gt;&lt;strong&gt;Java配置@Configuration&lt;/strong&gt;&lt;/a&gt; - 揭露如何使用 Java 配置定义 beans。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-annotation/spring-annotation-componentScan/README.md&#34;&gt;&lt;strong&gt;组件扫描@ComponentScan&lt;/strong&gt;&lt;/a&gt; - 探索如何自动检测和注册 beans。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-annotation/spring-annotation-bean/README.md&#34;&gt;&lt;strong&gt;Bean定义@Bean&lt;/strong&gt;&lt;/a&gt; - 理解如何通过 Java 方法定义 beans。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-annotation/spring-annotation-import/README.md&#34;&gt;&lt;strong&gt;导入配置@Import&lt;/strong&gt;&lt;/a&gt; - 揭示如何导入其他配置类或组件。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-annotation/spring-annotation-propertySource/README.md&#34;&gt;&lt;strong&gt;属性绑定@PropertySource&lt;/strong&gt;&lt;/a&gt; - 深入了解如何为应用上下文添加属性源。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-annotation/spring-annotation-dependsOn/README.md&#34;&gt;&lt;strong&gt;初始化顺序@DependsOn&lt;/strong&gt;&lt;/a&gt; - 精确控制 Spring Beans 的加载顺序。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-annotation/spring-annotation-conditional/README.md&#34;&gt;&lt;strong&gt;条件注册@Conditional&lt;/strong&gt;&lt;/a&gt; - 从基础使用到源码分析，全方位理解Spring的条件注册策略。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-annotation/spring-annotation-lazy/README.md&#34;&gt;&lt;strong&gt;延迟加载@Lazy&lt;/strong&gt;&lt;/a&gt; - 如何优雅地实现 Spring Beans 的延迟加载。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-annotation/spring-annotation-value/README.md&#34;&gt;&lt;strong&gt;属性注入@Value&lt;/strong&gt;&lt;/a&gt; - 如何在Spring中优雅地注入配置属性。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-annotation/spring-annotation-autowired/README.md&#34;&gt;&lt;strong&gt;依赖注入@Autowired&lt;/strong&gt;&lt;/a&gt; - 了解如何通过@Autowired实现依赖管理和连接组件。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h3&gt;📜 JSR 规范&lt;/h3&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;em&gt;理解 Spring 是如何实现和优化 JSR 规范中的注解，深入揭露其与 Java 标准化的紧密结合。&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-jsr/spring-jsr330-inject/README.md&#34;&gt;&lt;strong&gt;注入依赖@Inject&lt;/strong&gt;&lt;/a&gt; - Spring中如何通过&lt;code&gt;@Inject&lt;/code&gt;实现依赖注入。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-jsr/spring-jsr330-named/README.md&#34;&gt;&lt;strong&gt;具名组件@Named&lt;/strong&gt;&lt;/a&gt; - 使用&lt;code&gt;@Named&lt;/code&gt;为Spring Beans提供具体的标识。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-jsr/spring-jsr250-postConstruct/README.md&#34;&gt;&lt;strong&gt;初始化后操作@PostConstruct&lt;/strong&gt;&lt;/a&gt; - 如何利用&lt;code&gt;@PostConstruct&lt;/code&gt;在Bean初始化后执行特定操作。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-jsr/spring-jsr250-preDestroy/README.md&#34;&gt;&lt;strong&gt;销毁前操作@PreDestroy&lt;/strong&gt;&lt;/a&gt; - 揭示&lt;code&gt;@PreDestroy&lt;/code&gt;如何在Bean销毁前执行特定任务。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-jsr/spring-jsr250-resource/README.md&#34;&gt;&lt;strong&gt;资源绑定@Resource&lt;/strong&gt;&lt;/a&gt; - 如何优雅地使用&lt;code&gt;@Resource&lt;/code&gt;在Spring中注入资源。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-jsr/spring-jsr330-provider/README.md&#34;&gt;&lt;strong&gt;提供者机制Provider&lt;/strong&gt;&lt;/a&gt; - 探索Spring中Provider的作用和如何使用它来提供Bean实例。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-jsr/spring-jsr330-qualifier/README.md&#34;&gt;&lt;strong&gt;限定符@Qualifier&lt;/strong&gt;&lt;/a&gt; - 了解&lt;code&gt;@Qualifier&lt;/code&gt;的重要性及其在解决注入冲突中的作用。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-jsr/spring-jsr330-scope/README.md&#34;&gt;&lt;strong&gt;作用域定义@Scope&lt;/strong&gt;&lt;/a&gt; - 揭露如何使用&lt;code&gt;@Scope&lt;/code&gt;定义Bean的生命周期和作用域。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/spring-jsr/spring-jsr330-singleton/README.md&#34;&gt;&lt;strong&gt;单例模式@Singleton&lt;/strong&gt;&lt;/a&gt; - 深入理解&lt;code&gt;@Singleton&lt;/code&gt;注解，确保Spring Bean的单一实例化。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;💬与我联系&lt;/h2&gt; &#xA;&lt;p&gt;✉️ &lt;a href=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/xuchengshengsuper@163.com&#34;&gt;Email&lt;/a&gt; | 💬 &lt;a href=&#34;https://github.com/xuchengsheng/spring-reading/issues&#34;&gt;Issue&lt;/a&gt; | 🌐 &lt;a href=&#34;https://blog.csdn.net/duzhuang2399?type=blog&#34;&gt;CSDN&lt;/a&gt; Me about everything!&lt;/p&gt; &#xA;&lt;h2&gt;⛵欢迎贡献！&lt;/h2&gt; &#xA;&lt;p&gt;如果你发现任何错误🔍或者有改进建议🛠️，欢迎提交 issue 或者 pull request。你的反馈📢对于我非常宝贵💎！&lt;/p&gt; &#xA;&lt;h2&gt;🔄持续更新中&lt;/h2&gt; &#xA;&lt;p&gt;为了给大家提供最新🌱、最有价值的内容💼，我会坚持每天更新这个仓库⏳。每一天，你都可以期待看到一些新的内容或者对已有内容的改进✨。如果你有任何建议或反馈📣，欢迎随时联系我📞。我非常珍视每一个反馈💌，因为这是我持续改进的动力🚀。&lt;/p&gt; &#xA;&lt;h2&gt;💻我的 GitHub 统计&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://star-history.com/#xuchengsheng/spring-reading&amp;amp;Date&#34;&gt;&lt;img src=&#34;https://api.star-history.com/svg?repos=xuchengsheng/spring-reading&amp;amp;type=Date&#34; alt=&#34;Star History Chart&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;🍱请我吃盒饭？&lt;/h2&gt; &#xA;&lt;p&gt;作者晚上还要写博客✍️,平时还需要工作💼,如果帮到了你可以请作者吃个盒饭🥡&lt;/p&gt; &#xA;&lt;div&gt; &#xA; &lt;img alt=&#34;logo&#34; src=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/image/WeChatPay.png&#34; style=&#34;width: 370px;height: 400px&#34;&gt; &#xA; &lt;img alt=&#34;logo&#34; src=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/image/Alipay.png&#34; style=&#34;width: 370px;height: 400px&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;👥加入我们&lt;/h2&gt; &#xA;&lt;p&gt;欢迎加入我们的群聊！一起探讨、分享和学习吧！ 🌐&lt;/p&gt; &#xA;&lt;div&gt; &#xA; &lt;img alt=&#34;logo&#34; src=&#34;https://raw.githubusercontent.com/xuchengsheng/spring-reading/master/image/wechat-group.jpg&#34; style=&#34;width: 344px;height: 483px&#34;&gt; &#xA;&lt;/div&gt;</summary>
  </entry>
  <entry>
    <title>tldraw/make-real-starter</title>
    <updated>2023-11-21T01:27:23Z</updated>
    <id>tag:github.com,2023-11-21:/tldraw/make-real-starter</id>
    <link href="https://github.com/tldraw/make-real-starter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Make it real&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Make Real&lt;/h1&gt; &#xA;&lt;p&gt;Use this repo as a template to create Make Real style apps like &lt;a href=&#34;https://makereal.tldraw.com&#34;&gt;makereal.tldraw.com&lt;/a&gt;. To get started:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use the template and clone your new repo to your computer&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;npm install&lt;/code&gt; to install dependencies&lt;/li&gt; &#xA; &lt;li&gt;Get an OpenAI API key from &lt;a href=&#34;https://platform.openai.com/api-keys&#34;&gt;platform.openai.com/api-keys&lt;/a&gt;. Make sure you are at least a &lt;a href=&#34;https://platform.openai.com/docs/guides/rate-limits/usage-tiers&#34;&gt;Tier 1&lt;/a&gt; API user, which means you have access to GPT-4 Vision. You can check your tier on the &lt;a href=&#34;https://platform.openai.com/account/limits&#34;&gt;OpenAI API Limits&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Create a &lt;code&gt;.env.local&lt;/code&gt; file that contains &lt;code&gt;OPENAI_API_KEY=your api key here&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;npm run dev&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Open &lt;a href=&#34;http://localhost:3000&#34;&gt;localhost:3000&lt;/a&gt; and make some stuff real!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;Make Real is built with &lt;a href=&#34;https://raw.githubusercontent.com/tldraw/make-real-starter/main/tldraw.dev&#34;&gt;tldraw&lt;/a&gt;, a very good React library for creating whiteboards and other infinite canvas experiences.&lt;/p&gt; &#xA;&lt;p&gt;To use it, first draw a mockup for a piece of UI. When you&#39;re ready, select the drawing, and press the Make Real button. We&#39;ll capture an image of your selection, and send it to &lt;a href=&#34;https://platform.openai.com/docs/guides/vision&#34;&gt;OpenAI&#39;s GPT-4V&lt;/a&gt; along with instructions to turn it into a HTML file.&lt;/p&gt; &#xA;&lt;p&gt;We take the HTML response and add it to a tldraw &lt;a href=&#34;https://tldraw.dev/docs/shapes#Custom-shapes&#34;&gt;custom shape&lt;/a&gt;. The custom shape shows the response in an iframe so that you can interact with it on the canvas. If you want to iterate on the response, annotate the iframe, select it all, and press &#39;Make Real&#39; again.&lt;/p&gt; &#xA;&lt;h2&gt;To make changes&lt;/h2&gt; &#xA;&lt;p&gt;To change how Make Real works, start from the &lt;a href=&#34;https://raw.githubusercontent.com/tldraw/make-real-starter/main/app/makeReal.tsx&#34;&gt;&lt;code&gt;makeReal()&lt;/code&gt;&lt;/a&gt; function. From there, you can change the prompt that gets sent to gpt-4.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like Make Real to create something other than HTML, you&#39;ll need to either update the &lt;a href=&#34;https://raw.githubusercontent.com/tldraw/make-real-starter/main/app/ResponseShape/ResponseShape.tsx&#34;&gt;&lt;code&gt;ResponseShape&lt;/code&gt;&lt;/a&gt; to display something different, or use one of tldraw&#39;s built-in shapes like image or text.&lt;/p&gt; &#xA;&lt;h2&gt;The dangerous API key input method&lt;/h2&gt; &#xA;&lt;p&gt;For prototyping or at least until the vision APIs are able to support higher usage limits, we&#39;ve also included the &lt;code&gt;RiskyButCoolAPIKeyInput&lt;/code&gt;, similar to the one found on &lt;a href=&#34;https://makereal.tldraw.com&#34;&gt;makereal.tldraw.com&lt;/a&gt;. Please use this as carefully and ethically as you can, as users should be reluctant to add API keys to public sites.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>twostraws/Inferno</title>
    <updated>2023-11-21T01:27:23Z</updated>
    <id>tag:github.com,2023-11-21:/twostraws/Inferno</id>
    <link href="https://github.com/twostraws/Inferno" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Metal shaders for SwiftUI.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://www.hackingwithswift.com/files/inferno/inferno-logo.png&#34; alt=&#34;Inferno logo&#34; width=&#34;272&#34; height=&#34;272&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/iOS-17.0+-blue.svg?sanitize=true&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/macOS-14.0+-brightgreen.svg?sanitize=true&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/MSL-3.1-orange.svg?sanitize=true&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Swift-5.9-ff69b4.svg?sanitize=true&#34;&gt; &lt;a href=&#34;https://twitter.com/twostraws&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Contact-@twostraws-lightgrey.svg?style=flat&#34; alt=&#34;Twitter: @twostraws&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;Inferno is an open-source collection of fragment shaders designed for use in SwiftUI apps. The shaders are designed to be easy to read and understand, even for relative beginners, so you’ll find each line of code is rephrased in plain English as well as an overall explanation of the algorithm used at the top of each file.&lt;/p&gt; &#xA;&lt;p&gt;If you’re already comfortable with shaders then please download one or more that interest you and get going. If not, most of the the remainder of this README acts as a primer for using shaders in SwiftUI.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#see-it-in-action&#34;&gt;See it in action&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#how-to-use-inferno-in-your-project&#34;&gt;How to use Inferno in your project&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#what-are-shaders&#34;&gt;What are shaders?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#how-are-shaders-written&#34;&gt;How are shaders written?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#sending-values-to-shaders&#34;&gt;Sending values to shaders&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#reading-the-shader-code&#34;&gt;Reading the shader code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#shaders-included-in-inferno&#34;&gt;Shaders included in Inferno&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#animated-gradient-fill&#34;&gt;Animated Gradient Fill&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#checkerboard&#34;&gt;Checkerboard&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#circle-wave&#34;&gt;Circle Wave&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#color-lanes&#34;&gt;Color Planes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#emboss&#34;&gt;Emboss&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#gradient-fill&#34;&gt;Gradient Fill&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#infrared&#34;&gt;Infrared&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#interlace&#34;&gt;Interlace&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#invert-alpha&#34;&gt;Invert Alpha&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#light-grid&#34;&gt;Light Grid&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#passthrough&#34;&gt;Passthrough&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#rainbow-noise&#34;&gt;Rainbow Noise&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#recolor&#34;&gt;Recolor&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#relative-wave&#34;&gt;Relative Wave&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#simple-loupe&#34;&gt;Simple Loupe&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#sinebow&#34;&gt;Sinebow&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#warping-loupe&#34;&gt;Warping Loupe&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#water&#34;&gt;Water&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#wave&#34;&gt;Wave&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#white-noise&#34;&gt;White Noise&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#transitions-included-in-inferno&#34;&gt;Transitions included in Inferno&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#circle&#34;&gt;Circle&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#circle-wave&#34;&gt;Circle Wave&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#crosswarp-ltr&#34;&gt;Crosswarp LTR&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#crosswarp-rtl&#34;&gt;Crosswarp RTL&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#diamond&#34;&gt;Diamond&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#diamond-wave&#34;&gt;Diamond Wave&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#pixellate&#34;&gt;Pixellate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#radial&#34;&gt;Radial&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#swirl&#34;&gt;Swirl&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#inferno-sandbox&#34;&gt;Inferno Sandbox&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/#where-to-learn-more&#34;&gt;Where to learn more&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;See it in action&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains a cross-platform sample project demonstrating all the shaders in action. The sample project is built using SwiftUI and requires iOS 17 and macOS 14.&lt;/p&gt; &#xA;&lt;p&gt;The sample project contains a lot of extra helper code to demonstrate all the shaders in various ways. To use the shaders in your own project, you just need to copy the relevant Metal files across, and optionally also Transitions.swift if you&#39;re using a transition shader.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/twostraws/Inferno/main/sandbox-screenshot.png&#34; alt=&#34;The Inferno Sandbox app demonstrating the simple loupe shader.&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to use Inferno in your project&lt;/h2&gt; &#xA;&lt;p&gt;If you use SwiftUI, you can add special effects from Inferno to add water ripples, spinning black holes, flashing lights, embossing, noise, gradients, and more –&amp;nbsp;all done on the GPU for maximum speed.&lt;/p&gt; &#xA;&lt;p&gt;To use a shader from here, copy the appropriate .metal file into your project, then start with sample code for that shader shown below. If you&#39;re using an Inferno transition, you should also copy Transitions.swift to your project.&lt;/p&gt; &#xA;&lt;p&gt;To find out more, click below to watch my YouTube video about building shaders for use with SwiftUI.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/EgzWwgRpUuw&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/EgzWwgRpUuw/maxresdefault.jpg&#34; alt=&#34;Video: SwiftUI + Metal – Learn to build your own shaders&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What are shaders?&lt;/h2&gt; &#xA;&lt;p&gt;Fragment shaders are tiny programs that operate on individual elements of a SwiftUI layer. They are sometimes called “pixel shaders” –&amp;nbsp;it’s not a wholly accurate name, but it does make them easier to understand.&lt;/p&gt; &#xA;&lt;p&gt;Effectively, a fragment shader gets run on every pixel in a SwiftUI view, and can transform that pixel however it wants. That might sound slow, but it isn’t –&amp;nbsp;all the fragment shaders here run at 60fps on all phones that support iOS 17, and 120fps on all ProMotion devices.&lt;/p&gt; &#xA;&lt;p&gt;The transformation process can recolor the pixel however it wants. Users can customize the process by passing various parameters into each shader, and SwiftUI also provides some values for us to work with, such as the coordinate for the pixel being modified and its current color.&lt;/p&gt; &#xA;&lt;h2&gt;How are shaders written?&lt;/h2&gt; &#xA;&lt;p&gt;Shaders are written in the Metal Shading Language (MSL), which is a simple, fast, and extremely efficient language based on C++ that is optimized for high-performance GPU operations. Metal shaders are compiled at build-time and linked into a &lt;code&gt;.metallib&lt;/code&gt; file. When you activate a shader in your app, the corresponding Metal function is loaded from the &lt;code&gt;metallib&lt;/code&gt; and is then used to create a program to be executed on the GPU.&lt;/p&gt; &#xA;&lt;p&gt;SwiftUI is able to work with a variety of Metal shaders, depending on what kind of effect you&#39;re trying to create.&lt;/p&gt; &#xA;&lt;p&gt;MSL comes with a wide variety of built-in data types and functions, many of which operate on more than one data types. The data types used in Inferno are nice and simple:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;bool&lt;/code&gt;: A Boolean, i.e. true or false.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;float&lt;/code&gt;: A floating-point number.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;float2&lt;/code&gt;: A two-component floating-point vector, used to hold things like X and Y coordinates or width and height.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;half&lt;/code&gt;: A half-precision floating-point number.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;half2&lt;/code&gt;: A two-component half-precision floating-point number.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;half3&lt;/code&gt;: A three-component floating-point vector, used to hold RGB values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;half4&lt;/code&gt;: A four-component floating-point vector, used to hold RGBA values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;uint2&lt;/code&gt;: A two-component integer vector, used to hold X and Y coordinates or width and height.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Shaders commonly move fluidly between &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;float2&lt;/code&gt;, &lt;code&gt;half3&lt;/code&gt;, and &lt;code&gt;half4&lt;/code&gt; as needed. For example, if you create a &lt;code&gt;half4&lt;/code&gt; from a &lt;code&gt;float&lt;/code&gt; then the number will just get repeated for each component in the vector. You’ll also frequently see code to create a &lt;code&gt;half4&lt;/code&gt; by using a &lt;code&gt;half3&lt;/code&gt; for the first three values (usually RGB) and specifying a fourth value as a &lt;code&gt;float&lt;/code&gt;. Converting between &lt;code&gt;half&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; is free.&lt;/p&gt; &#xA;&lt;p&gt;Be mindful when choosing the type of your variables: the GPU is heavily optimized for performing floating-point operations, and (especially on iOS), half-precision floating-point operations. That means you should prefer to use the &lt;code&gt;half&lt;/code&gt; data types whenever the precision requirements allow it. This will also save register space and increase the so-called &#34;occupancy&#34; of the shader program, effectively letting more GPU cores run your shader simultaneously. Check out the &lt;a href=&#34;https://developer.apple.com/videos/play/tech-talks/111373?time=778&#34;&gt;Learn performance best practices for Metal shaders&lt;/a&gt; tech talk for more details.&lt;/p&gt; &#xA;&lt;p&gt;Also, be careful with scalar numbers in your shader code. Make sure to use the correct type of number for an operation. For example, &lt;code&gt;float y = (x - 1) / 2&lt;/code&gt; works, but &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; are &lt;code&gt;int&lt;/code&gt; here and are needlessly converted to &lt;code&gt;float&lt;/code&gt; at runtime. Instead, write &lt;code&gt;float y = (x - 1.0) / 2.0&lt;/code&gt;. Number literals for the corresponding types look like this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;float&lt;/code&gt;: &lt;code&gt;0.5&lt;/code&gt;, &lt;code&gt;0.5f&lt;/code&gt;, or &lt;code&gt;0.5F&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;half&lt;/code&gt;: &lt;code&gt;0.5h&lt;/code&gt; or &lt;code&gt;0.5H&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;int&lt;/code&gt;: &lt;code&gt;42&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;uint&lt;/code&gt;: &lt;code&gt;42u&lt;/code&gt; or &lt;code&gt;42U&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here are the functions used in Inferno:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;abs()&lt;/code&gt; calculates the absolute value of a number, which is its non-negative value. So, positive values such as 1, 5, and 500 remain as they are, but negative values such as -3 or -3000 have their signs removed, making them 3 or 3000. If you pass it a vector (e.g. &lt;code&gt;float2&lt;/code&gt;) this will be done for each component.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ceil()&lt;/code&gt; rounds a number up to its nearest integer. If you pass it a vector (e.g. &lt;code&gt;float2&lt;/code&gt;) this will be done for each component.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cos()&lt;/code&gt; calculates the cosine of a value in radians. The cosine will always fall between -1 and 1. If you provide &lt;code&gt;cos()&lt;/code&gt; with a vector (e.g. &lt;code&gt;vec3&lt;/code&gt;) it will calculate the cosine of each component in the vector and return a vector of the same size containing the results.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;distance()&lt;/code&gt; calculates the distance between two values. For example, if you provide it with a pair &lt;code&gt;vec2&lt;/code&gt; you’ll get the length of the vector created by subtracting one from the other. This always returns a single number no matter what data type you give it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dot()&lt;/code&gt; calculates the dot product of two values. This means multiplying each component of the first value by the respective component in the second value, then adding the result.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;floor()&lt;/code&gt; rounds a number down to its nearest integer. If you pass it a vector (e.g. &lt;code&gt;float2&lt;/code&gt;) this will be done for each component.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fract()&lt;/code&gt; returns the fractional component of a value. For example, &lt;code&gt;fract(12.5)&lt;/code&gt; is 0.5. If you pass this a vector then the operation will be performed component-wise, and a new vector will be returned containing the results.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;min()&lt;/code&gt; is used to find the lower of two values. If you pass vectors, this is done component-wise, meaning that the resulting vector will evaluate each component in the vector and place the lowest in the resulting vector.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;max()&lt;/code&gt; is used to find the higher of two values. If you pass vectors, this is done component-wise, meaning that the resulting vector will evaluate each component in the vector and place the highest in the resulting vector.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mix()&lt;/code&gt; smooth interpolates between two values based on a third value that’s specified between 0 and 1, providing a linear curve.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pow()&lt;/code&gt; calculates one value raised to the power of another, for example &lt;code&gt;pow(2.0, 3.0)&lt;/code&gt; evaluates to 2 * 2 * 2, giving 8. As well as operating on a &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;pow()&lt;/code&gt; can also calculate component-wise exponents –&amp;nbsp;it raises the first item in the first vector to the power of the first item in the second vector, and so on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sin()&lt;/code&gt; calculates the sine of a value in radians. The sine will always fall between -1 and 1. If you provide &lt;code&gt;sin()&lt;/code&gt; with a vector (e.g. &lt;code&gt;float2&lt;/code&gt;) it will calculate the sine of each component in the vector and return a vector of the same size containing the results.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;smoothstep()&lt;/code&gt; interpolates between two values based on a third value that’s specified between 0 and 1, providing an S-curve shape. That is, the interpolation starts slow (values near 0.0), picks up speed (values near 0.5), then slows down towards the end (values near 1.0).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sample()&lt;/code&gt; provides the color value of a SwiftUI layer at a specific location. This is most commonly used to read the current pixel’s color.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More about all of this can be found in the &lt;a href=&#34;https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf&#34;&gt;Metal Shading Language Specification&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Sending values to shaders&lt;/h2&gt; &#xA;&lt;p&gt;Many shaders can operate without any special input from the user –&amp;nbsp;it can manipulate the data it was sent by SwiftUI, then send back new data.&lt;/p&gt; &#xA;&lt;p&gt;Because SwiftUI uses dynamic member lookup to find shader functions at runtime, this means a simple shader can be applied like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Image(systemName: &#34;figure.walk.circle&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.yourShaderFunction()&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, often you’ll want to customize the way shaders work, a bit like passing in parameters to a function. Shaders are a little more complicated because these values need to be uploaded to the GPU, but the principle is the same.&lt;/p&gt; &#xA;&lt;p&gt;SwiftUI handles this data transfer using helper methods that convert common Swift and SwiftUI data types to their Metal equivalents. For example, if you want to pass a &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;CGFloat&lt;/code&gt;, or &lt;code&gt;Double&lt;/code&gt; from Swift to Metal, you&#39;d do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Image(systemName: &#34;figure.walk.circle&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.yourShaderFunction(&#xA;            .float(someNumber)&#xA;        )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SwiftUI provides three modifiers that let us apply Metal shaders to view hierarchies. Each one provides different input to your shader function, but each can also accept any number of further values to customize the way your shader works.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;colorEffect()&lt;/code&gt; modifier passes in the current pixel&#39;s position in user space (i.e., based on the actual size of your layer, measured in points), and its current color.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;distortionEffect()&lt;/code&gt; modifier passes in just the current pixel&#39;s position in user space.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;layerEffect()&lt;/code&gt; modifier passes in the current pixel&#39;s position in user space, and also the SwiftUI layer itself so you can read values from there freely.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In the documentation below, shader parameters are listed &lt;em&gt;without&lt;/em&gt; the ones SwiftUI passes in automatically –&amp;nbsp;you just see the ones you actually need to pass yourself.&lt;/p&gt; &#xA;&lt;h2&gt;Reading the shader code&lt;/h2&gt; &#xA;&lt;p&gt;All the shaders in Inferno were specifically written for readability. Specifically, they:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Start with a brief comment outlining what each shader does.&lt;/li&gt; &#xA; &lt;li&gt;List all input parameters (where they are used), along with ranges and a suggested starting point.&lt;/li&gt; &#xA; &lt;li&gt;Have an explanation of the algorithm used.&lt;/li&gt; &#xA; &lt;li&gt;Provide detailed line-by-line English translations of what the code means.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The combination of what the code &lt;em&gt;does&lt;/em&gt; (the interlinear comments) and what the code &lt;em&gt;means&lt;/em&gt; (the algorithm introduction) should hopefully make these shaders comprehensible to everyone.&lt;/p&gt; &#xA;&lt;p&gt;One small note: you will commonly see final color values multiplied by the original color’s alpha, just to make sure we get very smooth edges where this is transparency.&lt;/p&gt; &#xA;&lt;h2&gt;Shaders included in Inferno&lt;/h2&gt; &#xA;&lt;p&gt;Inferno provides a selection of shaders, most of which allow some customization using input parameters.&lt;/p&gt; &#xA;&lt;h3&gt;Animated Gradient Fill&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates generates a constantly cycling color gradient, centered on the input view.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .colorEffect(&#xA;                            ShaderLibrary.animatedGradientFill(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime)&#xA;                        )&#xA;                    )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Checkerboard&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that replaces the current image with a checkerboard pattern, flipping between the original color and a replacement.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;replacement&lt;/code&gt;: The replacement color to be used for checkered squares.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the checker squares.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &#34;figure.walk.circle&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.checkerboard(&#xA;            .color(.red),&#xA;            .float(50)&#xA;        )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Circle Wave&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates circular waves moving out or in, with varying size, brightness, speed, strength, and more.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;brightness&lt;/code&gt;: How bright the colors should be. Ranges from 0 to 5 work best; try starting with 0.5 and experiment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;speed&lt;/code&gt;: How fast the wave should travel. Ranges from -2 to 2 work best, where negative numbers cause waves to come inwards; try starting with 1.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How intense the waves should be. Ranges from 0.02 to 5 work best; try starting with 2.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;density&lt;/code&gt;: How large each wave should be. Ranges from 20 to 500 work best; try starting with 100.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;center&lt;/code&gt;: The center of the effect, where 0.5/0.5 is dead center&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;circleColor&lt;/code&gt;: The color to use for the waves. Use darker colors to create a less intense core.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .padding()&#xA;                .drawingGroup()&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .colorEffect(&#xA;                            ShaderLibrary.circleWave(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime),&#xA;                                .float(0.5),&#xA;                                .float(1),&#xA;                                .float(2),&#xA;                                .float(100),&#xA;                                .float2(0.5, 0.5),&#xA;                                .color(.blue)&#xA;                            )&#xA;                        )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Color Planes&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;layerEffect()&lt;/code&gt; shader that separates the RGB values for a pixel and offsets them to create a glitch-style effect. This works particularly well on iOS when the &lt;code&gt;offset&lt;/code&gt; value is provided as through accelerometer data.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;offset&lt;/code&gt;: How much to offset colors by.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var touchLocation = CGSize.zero&#xA;&#xA;    var body: some View {&#xA;        Image(systemName: &#34;figure.walk.circle&#34;)&#xA;            .font(.system(size: 300))&#xA;            .foregroundStyle(.white)&#xA;            .frame(maxWidth: .infinity, maxHeight: .infinity)&#xA;            .background(.black)&#xA;            .drawingGroup()&#xA;            .layerEffect(&#xA;                ShaderLibrary.colorPlanes(&#xA;                    .float2(touchLocation)&#xA;                ),&#xA;                maxSampleOffset: .zero&#xA;            )&#xA;            .gesture(&#xA;                DragGesture(minimumDistance: 0)&#xA;                    .onChanged { touchLocation = $0.translation }&#xA;            )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Emboss&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;layerEffect()&lt;/code&gt; shader that creates an embossing effect by adding brightness from pixels in one direction, and subtracting brightness from pixels in the other direction.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How far we should we read pixels to create the effect.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var embossAmount = 0.0&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            Text(&#34;🏳️‍🌈&#34;)&#xA;                .font(.system(size: 300))&#xA;                .layerEffect(&#xA;                    ShaderLibrary.emboss(&#xA;                        .float(embossAmount)&#xA;                    ),&#xA;                    maxSampleOffset: .zero&#xA;                )&#xA;&#xA;            Slider(value: $embossAmount, in: 0...20)&#xA;                .padding()&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Gradient Fill&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates a gradient fill&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &#34;figure.walk.circle&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.gradientFill()&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Infrared&lt;/h3&gt; &#xA;&lt;p&gt;Simulates an infrared camera by coloring brighter objects red and darker objects blue.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&#34;👩‍💻&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.infrared()&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Interlace&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that applies an interlacing effect where horizontal lines of the original color are separated by lines of another color.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;width&lt;/code&gt;: The width of the interlacing lines. Ranges of 1 to 4 work best; try starting with 1.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;replacement&lt;/code&gt;: The color to use for interlacing lines. Try starting with black.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How much to blend interlaced lines with color. Specify 0 (not at all) up to 1 (fully).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Image(systemName: &#34;figure.walk.circle&#34;)&#xA;    .font(.system(size: 300))&#xA;    .foregroundStyle(.red)&#xA;    .colorEffect(&#xA;        ShaderLibrary.interlace(&#xA;            .float(2),&#xA;            .color(.black),&#xA;            .float(1)&#xA;        )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Invert Alpha&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that inverts the alpha of an image, replacing transparent colors with a supplied color.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;replacement&lt;/code&gt;: The replacement color to use for pixels.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&#34;🤷‍♂️&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.invertAlpha(&#xA;            .color(.red)&#xA;        )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Light Grid&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates generates multiple twisting and turning lines that cycle through colors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;density&lt;/code&gt;: How many rows and columns to create. A range of 1 to 50 works well; try starting with 8.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;speed&lt;/code&gt;: How fast to make the lights vary their color. Higher values cause lights to flash faster and vary in color more. A range of 1 to 20 works well; try starting with 3.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;groupSize&lt;/code&gt;: How many lights to place in each group. A range of 1 to 8 works well depending on your density; starting with 1.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;brightness&lt;/code&gt;: How bright to make the lights. A range of 0.2 to 10 works well; try starting with 3.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .padding()&#xA;                .drawingGroup()&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .colorEffect(&#xA;                            ShaderLibrary.lightGrid(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime),&#xA;                                .float(8),&#xA;                                .float(3),&#xA;                                .float(1),&#xA;                                .float(3)&#xA;                            )&#xA;                        )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Passthrough&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that sends back the existing color data, changing nothing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&#34;🏳️‍🌈&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.passthrough()&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rainbow Noise&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates dynamic, multi-colored noise.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .colorEffect(&#xA;                    ShaderLibrary.rainbowNoise(&#xA;                        .float(elapsedTime)&#xA;                    )&#xA;                )&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Recolor&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; that changes input colors to a replacement, while respecting the current alpha value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;replacement&lt;/code&gt;: The replacement color to use for pixels.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Text(&#34;💪&#34;)&#xA;    .font(.system(size: 300))&#xA;    .colorEffect(&#xA;        ShaderLibrary.recolor(&#xA;            .color(.blue)&#xA;        )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Relative Wave&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;distortionEffect()&lt;/code&gt; shader that generates a wave effect, where no effect is applied on the left side of the input, and the full effect is applied on the right side.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;speed&lt;/code&gt;: How fast to make the waves ripple. Try starting with a value of 5.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;smoothing&lt;/code&gt;: How much to smooth out the ripples, where greater values produce a smoother effect. Try starting with a value of 20.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How pronounced to make the ripple effect. Try starting with a value of 5.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .padding()&#xA;                .background(.background)&#xA;                .drawingGroup()&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .distortionEffect(&#xA;                            ShaderLibrary.relativeWave(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime),&#xA;                                .float(5),&#xA;                                .float(20),&#xA;                                .float(5)&#xA;                            ),&#xA;                            maxSampleOffset: .zero&#xA;                        )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Simple Loupe&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;layerEffect()&lt;/code&gt; shader that creates a circular zoom effect over a precise location.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;touch&lt;/code&gt;: The location the user is touching, where the zoom should be centered.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;maxDistance&lt;/code&gt;: How big to make the zoomed area. Try starting with 0.05.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;zoomFactor&lt;/code&gt;: How much to zoom the contents of the loupe.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var touchLocation = CGPoint.zero&#xA;&#xA;    var body: some View {&#xA;        Image(systemName: &#34;figure.walk.circle&#34;)&#xA;            .font(.system(size: 300))&#xA;            .padding()&#xA;            .background(.background)&#xA;            .drawingGroup()&#xA;            .visualEffect { content, proxy in&#xA;                content&#xA;                    .layerEffect(&#xA;                        ShaderLibrary.simpleLoupe(&#xA;                            .float2(proxy.size),&#xA;                            .float2(touchLocation),&#xA;                            .float(0.05),&#xA;                            .float(2)&#xA;                        ),&#xA;                        maxSampleOffset: .zero&#xA;                    )&#xA;            }&#xA;            .gesture(&#xA;                DragGesture(minimumDistance: 0)&#xA;                    .onChanged { touchLocation = $0.location }&#xA;            )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sinebow&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates generates multiple twisting and turning lines that cycle through colors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Rectangle()&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .colorEffect(&#xA;                            ShaderLibrary.sinebow(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime)&#xA;                            )&#xA;                        )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Warping Loupe&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;layerEffect()&lt;/code&gt; shader that creates a circular zoom effect over a precise location, with variable zoom around the touch area to create a glass orb-like effect.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;touch&lt;/code&gt;: The location the user is touching, where the zoom should be centered.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;maxDistance&lt;/code&gt;: How big to make the zoomed area. Try starting with 0.05.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;zoomFactor&lt;/code&gt;: How much to zoom the contents of the loupe.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var touchLocation = CGPoint.zero&#xA;&#xA;    var body: some View {&#xA;        Image(systemName: &#34;figure.walk.circle&#34;)&#xA;            .font(.system(size: 300))&#xA;            .padding()&#xA;            .background(.background)&#xA;            .drawingGroup()&#xA;            .visualEffect { content, proxy in&#xA;                content&#xA;                    .layerEffect(&#xA;                        ShaderLibrary.warpingLoupe(&#xA;                            .float2(proxy.size),&#xA;                            .float2(touchLocation),&#xA;                            .float(0.05),&#xA;                            .float(2)&#xA;                        ),&#xA;                        maxSampleOffset: .zero&#xA;                    )&#xA;            }&#xA;            .gesture(&#xA;                DragGesture(minimumDistance: 0)&#xA;                    .onChanged { touchLocation = $0.location }&#xA;            )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Water&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;distortionEffect()&lt;/code&gt; shader that generates a water rippling effect.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: The size of the whole image, in user-space.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;speed&lt;/code&gt;: How fast to make the water ripple. Ranges from 0.5 to 10 work best; try starting with 3.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How pronounced the rippling effect should be. Ranges from 1 to 5 work best; try starting with 3.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;frequency&lt;/code&gt;: How often ripples should be created. Ranges from 5 to 25 work best; try starting with 10.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .padding()&#xA;                .background(.background)&#xA;                .drawingGroup()&#xA;                .visualEffect { content, proxy in&#xA;                    content&#xA;                        .distortionEffect(&#xA;                            ShaderLibrary.water(&#xA;                                .float2(proxy.size),&#xA;                                .float(elapsedTime),&#xA;                                .float(3),&#xA;                                .float(3),&#xA;                                .float(10)&#xA;                            ),&#xA;                            maxSampleOffset: .zero&#xA;                        )&#xA;                }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Wave&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;distortionEffect()&lt;/code&gt; shader that generates a wave effect, where no effect is applied on the left side of the input, and the full effect is applied on the right side.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;speed&lt;/code&gt;: How fast to make the waves ripple. Try starting with a value of 5.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;smoothing&lt;/code&gt;: How much to smooth out the ripples, where greater values produce a smoother effect. Try starting with a value of 10.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strength&lt;/code&gt;: How pronounced to make the ripple effect. Try starting with a value of 5.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .padding()&#xA;                .background(.background)&#xA;                .drawingGroup()&#xA;                .distortionEffect(&#xA;                    ShaderLibrary.wave(&#xA;                        .float(elapsedTime),&#xA;                        .float(5),&#xA;                        .float(10),&#xA;                        .float(5)&#xA;                    ),&#xA;                    maxSampleOffset: .zero&#xA;                )&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;White Noise&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;colorEffect()&lt;/code&gt; shader that generates dynamic, grayscale noise.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;time&lt;/code&gt;: The number of elapsed seconds since the shader was created.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var startTime = Date.now&#xA;&#xA;    var body: some View {&#xA;        TimelineView(.animation) { timeline in&#xA;            let elapsedTime = startTime.distance(to: timeline.date)&#xA;&#xA;            Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                .font(.system(size: 300))&#xA;                .colorEffect(&#xA;                    ShaderLibrary.whiteNoise(&#xA;                        .float(elapsedTime)&#xA;                    )&#xA;                )&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Transitions included in Inferno&lt;/h2&gt; &#xA;&lt;p&gt;As well as the shaders listed above, Inferno provides a selection of shaders specifically designed to be used as transitions. Although these are still Metal shaders internally, you&#39;ll use them through &lt;code&gt;AnyTransition&lt;/code&gt; extensions that make the process seamless.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!Note] As well as copying one specific shader into your project, you should also add Transitions.swift to include the &lt;code&gt;AnyTransition&lt;/code&gt; extensions.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Circle&lt;/h3&gt; &#xA;&lt;p&gt;A transition where many circles grow upwards to reveal the new content.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: How big to make the circles.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.circles(size: 20))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.circles(size: 20))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Circle Wave&lt;/h3&gt; &#xA;&lt;p&gt;A transition where many circles grow upwards to reveal the new content, with the circles moving outwards from the top-left edge.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: How big to make the circles.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.circleWave(size: 20))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.circleWave(size: 20))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Crosswarp LTR&lt;/h3&gt; &#xA;&lt;p&gt;A transition that stretches and fades pixels starting from the left edge.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.crosswarpLTR)&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.crosswarpLTR)&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Crosswarp RTL&lt;/h3&gt; &#xA;&lt;p&gt;A transition that stretches and fades pixels starting from the right edge.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.crosswarpRTL)&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.crosswarpRTL)&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Diamond&lt;/h3&gt; &#xA;&lt;p&gt;A transition that makes a variety of diamonds simultaneously zoom up across the screen.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: How big to make the diamonds.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.diamonds(size: 20))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.diamonds(size: 20))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Diamond Wave&lt;/h3&gt; &#xA;&lt;p&gt;A transition that makes a variety of circles zoom up across the screen, based on their X/Y position.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: How big to make the diamonds. Defaults to 20.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.diamondWave(size: 20))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.diamondWave(size: 20))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Pixellate&lt;/h3&gt; &#xA;&lt;p&gt;A transition that causes the incoming and outgoing views to become increasingly pixellated, then return to their normal state. While this happens the old view fades out and the new one fades in.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;squares&lt;/code&gt;: How large the pixels should be. Defaults to 20.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;steps&lt;/code&gt;: How many steps to use for the animation. Lower values make the pixels jump in more noticeable size increments, which creates very interesting retro effects. Defaults to 60.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.pixellate(squares: 20, steps: 20))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.pixellate(squares: 20, steps: 20))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Radial&lt;/h3&gt; &#xA;&lt;p&gt;A transition that creates an old-school radial wipe, starting from straight up.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;None.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.radial)&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.radial)&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Swirl&lt;/h3&gt; &#xA;&lt;p&gt;A transition that increasingly twists the contents of the incoming and outgoing views, then untwists them to complete the transition. As this happens the two views fade to move smoothly from one to the other.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;radius&lt;/code&gt;: How large the swirl should be relative to the view it&#39;s transitioning. Defaults to 0.5.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.swirl(radius: 0.5))&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.swirl(radius: 0.5))&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Wind&lt;/h3&gt; &#xA;&lt;p&gt;A transition that makes it look the pixels of one image are being blown away horizontally.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Parameters:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;: How big the wind streaks should be, relative to the view&#39;s width. Defaults to 0.2.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ContentView: View {&#xA;    @State private var showingFirstView = true&#xA;&#xA;    var body: some View {&#xA;        VStack {&#xA;            if showingFirstView {&#xA;                Image(systemName: &#34;figure.walk.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.blue)&#xA;                    .drawingGroup()&#xA;                    .transition(.wind())&#xA;            } else {&#xA;                Image(systemName: &#34;figure.run.circle&#34;)&#xA;                    .font(.system(size: 300))&#xA;                    .foregroundStyle(.white)&#xA;                    .padding()&#xA;                    .background(.indigo)&#xA;                    .drawingGroup()&#xA;                    .transition(.wind())&#xA;            }&#xA;&#xA;            Button(&#34;Toggle Views&#34;) {&#xA;                withAnimation(.easeIn(duration: 1.5)) {&#xA;                    showingFirstView.toggle()&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Inferno Sandbox&lt;/h2&gt; &#xA;&lt;p&gt;Inside this repository is an example SwiftUI project for macOS that demonstrate each of the shaders with some example values – try running them if you’re curious how each of the shaders look or perform.&lt;/p&gt; &#xA;&lt;p&gt;If you’ve modified one of the shaders and want to see how it looks, the sandbox is the best place. If you click the &#34;Toggle Opacity&#34; toolbar button, preview content will alternate between opacity 0 and 1 so you can make sure your modifications blend correctly.&lt;/p&gt; &#xA;&lt;p&gt;All shaders here work great on all devices that support macOS Sonoma and coordinated releases, including iOS 17.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!Tip] Although the sandbox is helpful for previewing shaders, almost all its code isn&#39;t required in order to use Inferno shaders in your own projects – you just need to copy the relevant Metal files across, and optionally also Transitions.swift if you&#39;re using a transition shader.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;I made Inferno because not enough people know that shaders are powerful, easy ways to add special effects to your apps. If you’d like to contribute your own shaders or modifications to existing shaders, that’s great! But first please read the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Inferno has a strong emphasis on readability. Beginners should be able to read most of these shaders and have a good idea of how they work. If you want to make one of the shaders faster, please don’t do so at the expensive of readability.&lt;/li&gt; &#xA; &lt;li&gt;You must comment your code thoroughly. Shaders are often extremely terse, so please write in English above every line what the code does –&amp;nbsp;a transliteration, if you will –&amp;nbsp;and also provide a description of how it all works to produce the final result.&lt;/li&gt; &#xA; &lt;li&gt;All code must be licensed under the MIT license so it can benefit the most people.&lt;/li&gt; &#xA; &lt;li&gt;Please add your code to the Inferno Sandbox app, so folks can try it out easily.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT License.&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2023 Paul Hudson and other authors.&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt; &#xA;&lt;p&gt;Inferno was made by &lt;a href=&#34;https://twitter.com/twostraws&#34;&gt;Paul Hudson&lt;/a&gt;, who writes &lt;a href=&#34;https://www.hackingwithswift.com&#34;&gt;free Swift tutorials over at Hacking with Swift&lt;/a&gt;. It’s available under the MIT license, which permits commercial use, modification, distribution, and private use.&lt;/p&gt; &#xA;&lt;p&gt;Some shaders were ported to Metal by me, from other open-source samples also released under the MIT license. All credit for their code goes to their original authors; all mistakes and similar are obviously my fault!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Circle, Circle Wave, Diamond, Diamond Wave are based on &lt;a href=&#34;https://gl-transitions.com/editor/PolkaDotsCurtain&#34;&gt;Polka Dots Curtain&lt;/a&gt; by bobylito.&lt;/li&gt; &#xA; &lt;li&gt;Crosswarp is based on &lt;a href=&#34;https://gl-transitions.com/editor/crosswarp&#34;&gt;Crosswarp&lt;/a&gt; by Eke Péter.&lt;/li&gt; &#xA; &lt;li&gt;Radial is based on &lt;a href=&#34;https://gl-transitions.com/editor/Radial&#34;&gt;Radial&lt;/a&gt; by Xaychru / gre.&lt;/li&gt; &#xA; &lt;li&gt;Swirl is based on &lt;a href=&#34;https://gl-transitions.com/editor/Swirl&#34;&gt;Swirl&lt;/a&gt; by Sergey Kosarevsky / gre.&lt;/li&gt; &#xA; &lt;li&gt;Wind is based on &lt;a href=&#34;https://gl-transitions.com/editor/wind&#34;&gt;Wind&lt;/a&gt; by gre.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Where to learn more&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re keen to learn more about Metal shaders, here are the resources I recommend:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.thebookofshaders.com&#34;&gt;The Book of Shaders&lt;/a&gt; has taught countless thousands of people how to build shaders, and contains comprehensive descriptions. Note: This is written for GLSL, but the concepts still apply to Metal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.shadertoy.com&#34;&gt;ShaderToy&lt;/a&gt; contains all sorts of fantastic shader ideas where you gain inspiration, plus all their code is there to learn from. Again this is written for GLSL, but you can transfer to Metal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.gl-transitions.com&#34;&gt;GL Transitions&lt;/a&gt; contains a variety of open-source GLSL transitions for inspiration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.apple.com/metal&#34;&gt;Apple&#39;s Metal documentation&lt;/a&gt; goes into great detail on the many other usages of Metal –&amp;nbsp;we&#39;ve just covered fragment shaders here, but it can do so much more!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.hackingwithswift.com/plus&#34;&gt;Hacking with Swift+&lt;/a&gt; contains a tutorial series teaching how to build Metal shaders for use with SwiftUI, going into much more depth on how the shaders actually work.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.hackingwithswift.com/plus&#34;&gt; &lt;img src=&#34;https://www.hackingwithswift.com/img/hws-plus-banner@2x.jpg&#34; alt=&#34;Hacking with Swift+ logo&#34; style=&#34;max-width: 100%;&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&amp;nbsp;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.hackingwithswift.com&#34;&gt;&lt;img src=&#34;https://www.hackingwithswift.com/img/hws-button@2x.png&#34; alt=&#34;Hacking with Swift logo&#34; width=&#34;66&#34; height=&#34;75&#34;&gt;&lt;/a&gt;&lt;br&gt; A Hacking with Swift Project &lt;/p&gt;</summary>
  </entry>
</feed>