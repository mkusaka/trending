<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-07-22T01:29:32Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Worklenz/worklenz</title>
    <updated>2025-07-22T01:29:32Z</updated>
    <id>tag:github.com,2025-07-22:/Worklenz/worklenz</id>
    <link href="https://github.com/Worklenz/worklenz" rel="alternate"></link>
    <summary type="html">&lt;p&gt;All in one project management tool for efficient teams&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; &lt;a href=&#34;https://worklenz.com&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt; &lt;img src=&#34;https://s3.us-west-2.amazonaws.com/worklenz.com/assets/icon-144x144.png&#34; alt=&#34;Worklenz Logo&#34; width=&#34;75&#34;&gt; &lt;/a&gt; &lt;br&gt; Worklenz &lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/Worklenz/worklenz/raw/main/LICENSE&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/license-AGPL--3.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/Worklenz/worklenz/releases&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/Worklenz/worklenz&#34; alt=&#34;Release&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/Worklenz/worklenz/stargazers&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/stars/Worklenz/worklenz&#34; alt=&#34;Stars&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/Worklenz/worklenz/network/members&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/forks/Worklenz/worklenz&#34; alt=&#34;Forks&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/Worklenz/worklenz/issues&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/issues/Worklenz/worklenz&#34; alt=&#34;Issues&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://worklenz.com/task-management/&#34;&gt;Task Management&lt;/a&gt; | &lt;a href=&#34;https://worklenz.com/time-tracking/&#34;&gt;Time Tracking&lt;/a&gt; | &lt;a href=&#34;https://worklenz.com/analytics/&#34;&gt;Analytics&lt;/a&gt; | &lt;a href=&#34;https://worklenz.com/resource-management/&#34;&gt;Resource Management&lt;/a&gt; | &lt;a href=&#34;https://worklenz.com/templates/&#34;&gt;Project Templates&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://worklenz.com&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://worklenz.s3.amazonaws.com/assets/screenshots/hero-view.png&#34; alt=&#34;Worklenz&#34; width=&#34;1200&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;Worklenz is a project management tool designed to help organizations improve their efficiency. It provides a comprehensive solution for managing projects, tasks, and collaboration within teams.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#tech-stack&#34;&gt;Tech Stack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#getting-started&#34;&gt;Getting Started&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#-quick-start-docker---recommended&#34;&gt;Quick Start (Docker)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#%EF%B8%8F-manual-installation-for-development&#34;&gt;Manual Installation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#deployment&#34;&gt;Deployment&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#local-development-with-docker&#34;&gt;Local Development&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#remote-server-deployment&#34;&gt;Remote Server Deployment&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#configuration&#34;&gt;Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#minio-integration&#34;&gt;MinIO Integration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#security&#34;&gt;Security&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#analytics&#34;&gt;Analytics&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#screenshots&#34;&gt;Screenshots&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Project Planning&lt;/strong&gt;: Create and organize projects, assign tasks to team members.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Task Management&lt;/strong&gt;: Break down projects into smaller tasks, set due dates, priorities, and track progress.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Collaboration&lt;/strong&gt;: Share files, leave comments, and communicate seamlessly with your team members.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Time Tracking&lt;/strong&gt;: Monitor time spent on tasks and projects for better resource allocation and billing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Reporting&lt;/strong&gt;: Generate detailed reports on project status, team workload, and performance metrics.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tech Stack&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains the frontend and backend code for Worklenz.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Frontend&lt;/strong&gt;: Built using React with Ant Design as the UI library.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Backend&lt;/strong&gt;: Built using TypeScript, Express.js, with PostgreSQL as the database.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Node.js version v18 or newer&lt;/li&gt; &#xA; &lt;li&gt;PostgreSQL version v15 or newer&lt;/li&gt; &#xA; &lt;li&gt;Docker and Docker Compose (for containerized setup)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Choose your preferred setup method below. Docker is recommended for quick setup and testing.&lt;/p&gt; &#xA;&lt;h3&gt;üöÄ Quick Start (Docker - Recommended)&lt;/h3&gt; &#xA;&lt;p&gt;The fastest way to get Worklenz running locally with all dependencies included.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Prerequisites:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker and Docker Compose installed on your system&lt;/li&gt; &#xA; &lt;li&gt;Git&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Steps:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone the repository:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/Worklenz/worklenz.git&#xA;cd worklenz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Start the Docker containers:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Access the application:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Frontend&lt;/strong&gt;: &lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Backend API&lt;/strong&gt;: &lt;a href=&#34;http://localhost:3000&#34;&gt;http://localhost:3000&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;MinIO Console&lt;/strong&gt;: &lt;a href=&#34;http://localhost:9001&#34;&gt;http://localhost:9001&lt;/a&gt; (login: minioadmin/minioadmin)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To stop the services:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose down&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Alternative startup methods:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Windows&lt;/strong&gt;: Run &lt;code&gt;start.bat&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Linux/macOS&lt;/strong&gt;: Run &lt;code&gt;./start.sh&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Video Guide&lt;/strong&gt;: For a visual walkthrough of the local Docker deployment process, check out our &lt;a href=&#34;https://www.youtube.com/watch?v=AfwAKxJbqLg&#34;&gt;step-by-step video guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;üõ†Ô∏è Manual Installation (For Development)&lt;/h3&gt; &#xA;&lt;p&gt;For developers who want to run the services individually or customize the setup.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Prerequisites:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Node.js (version 18 or higher)&lt;/li&gt; &#xA; &lt;li&gt;PostgreSQL (version 15 or higher)&lt;/li&gt; &#xA; &lt;li&gt;An S3-compatible storage service (like MinIO) or Azure Blob Storage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Steps:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone the repository:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/Worklenz/worklenz.git&#xA;cd worklenz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Set up environment variables:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp worklenz-backend/.env.template worklenz-backend/.env&#xA;# Update the environment variables with your configuration&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Install dependencies:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Backend dependencies&#xA;cd worklenz-backend&#xA;npm install&#xA;&#xA;# Frontend dependencies&#xA;cd ../worklenz-frontend&#xA;npm install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Set up the database:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Create a PostgreSQL database named worklenz_db&#xA;cd worklenz-backend&#xA;&#xA;# Execute the SQL setup files in the correct order&#xA;psql -U your_username -d worklenz_db -f database/sql/0_extensions.sql&#xA;psql -U your_username -d worklenz_db -f database/sql/1_tables.sql&#xA;psql -U your_username -d worklenz_db -f database/sql/indexes.sql&#xA;psql -U your_username -d worklenz_db -f database/sql/4_functions.sql&#xA;psql -U your_username -d worklenz_db -f database/sql/triggers.sql&#xA;psql -U your_username -d worklenz_db -f database/sql/3_views.sql&#xA;psql -U your_username -d worklenz_db -f database/sql/2_dml.sql&#xA;psql -U your_username -d worklenz_db -f database/sql/5_database_user.sql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;Start the development servers:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Terminal 1: Start the backend&#xA;cd worklenz-backend&#xA;npm run dev&#xA;&#xA;# Terminal 2: Start the frontend&#xA;cd worklenz-frontend&#xA;npm run dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;Access the application at &lt;a href=&#34;http://localhost:5000&#34;&gt;http://localhost:5000&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Deployment&lt;/h2&gt; &#xA;&lt;p&gt;For local development, follow the &lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/#-quick-start-docker---recommended&#34;&gt;Quick Start (Docker)&lt;/a&gt; section above.&lt;/p&gt; &#xA;&lt;h3&gt;Remote Server Deployment&lt;/h3&gt; &#xA;&lt;p&gt;When deploying to a remote server:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Set up the environment files with your server&#39;s hostname:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# For HTTP/WS&#xA;./update-docker-env.sh your-server-hostname&#xA;&#xA;# For HTTPS/WSS&#xA;./update-docker-env.sh your-server-hostname true&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Pull and run the latest Docker images:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose pull&#xA;docker-compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Access the application through your server&#39;s hostname:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Frontend: &lt;a href=&#34;http://your-server-hostname:5000&#34;&gt;http://your-server-hostname:5000&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Backend API: &lt;a href=&#34;http://your-server-hostname:3000&#34;&gt;http://your-server-hostname:3000&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Video Guide&lt;/strong&gt;: For a complete walkthrough of deploying Worklenz to a remote server, check out our &lt;a href=&#34;https://www.youtube.com/watch?v=CAZGu2iOXQs&amp;amp;t=10s&#34;&gt;deployment video guide&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Environment Variables&lt;/h3&gt; &#xA;&lt;p&gt;Worklenz requires several environment variables to be configured for proper operation. These include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Database credentials&lt;/li&gt; &#xA; &lt;li&gt;Session secrets&lt;/li&gt; &#xA; &lt;li&gt;Storage configuration (S3 or Azure)&lt;/li&gt; &#xA; &lt;li&gt;Authentication settings&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please refer to the &lt;code&gt;.env.example&lt;/code&gt; files for a full list of required variables.&lt;/p&gt; &#xA;&lt;p&gt;The Docker setup uses environment variables to configure the services:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Frontend:&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;VITE_API_URL&lt;/code&gt;: URL of the backend API (default: &lt;a href=&#34;http://backend:3000&#34;&gt;http://backend:3000&lt;/a&gt; for container networking)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;VITE_SOCKET_URL&lt;/code&gt;: WebSocket URL for real-time communication (default: ws://backend:3000)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Backend:&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Database connection parameters&lt;/li&gt; &#xA;   &lt;li&gt;Storage configuration&lt;/li&gt; &#xA;   &lt;li&gt;Other backend settings&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For custom configuration, edit the &lt;code&gt;.env&lt;/code&gt; file or the &lt;code&gt;update-docker-env.sh&lt;/code&gt; script.&lt;/p&gt; &#xA;&lt;h2&gt;MinIO Integration&lt;/h2&gt; &#xA;&lt;p&gt;The project uses MinIO as an S3-compatible object storage service, which provides an open-source alternative to AWS S3 for development and production.&lt;/p&gt; &#xA;&lt;h3&gt;Working with MinIO&lt;/h3&gt; &#xA;&lt;p&gt;MinIO provides an S3-compatible API, so any code that works with S3 will work with MinIO by simply changing the endpoint URL. The backend has been configured to use MinIO by default, with no additional configuration required.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;MinIO Console&lt;/strong&gt;: &lt;a href=&#34;http://localhost:9001&#34;&gt;http://localhost:9001&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Username: minioadmin&lt;/li&gt; &#xA;   &lt;li&gt;Password: minioadmin&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Default Bucket&lt;/strong&gt;: worklenz-bucket (created automatically when the containers start)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Backend Storage Configuration&lt;/h3&gt; &#xA;&lt;p&gt;The backend is pre-configured to use MinIO with the following settings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// S3 credentials with MinIO defaults&#xA;export const REGION = process.env.AWS_REGION || &#34;us-east-1&#34;;&#xA;export const BUCKET = process.env.AWS_BUCKET || &#34;worklenz-bucket&#34;;&#xA;export const S3_URL = process.env.S3_URL || &#34;http://minio:9000/worklenz-bucket&#34;;&#xA;export const S3_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID || &#34;minioadmin&#34;;&#xA;export const S3_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY || &#34;minioadmin&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Security Considerations&lt;/h3&gt; &#xA;&lt;p&gt;For production deployments:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use strong, unique passwords and keys for all services&lt;/li&gt; &#xA; &lt;li&gt;Do not commit &lt;code&gt;.env&lt;/code&gt; files to version control&lt;/li&gt; &#xA; &lt;li&gt;Use a production-grade PostgreSQL setup with proper backup procedures&lt;/li&gt; &#xA; &lt;li&gt;Enable HTTPS for all public endpoints&lt;/li&gt; &#xA; &lt;li&gt;Review and update dependencies regularly&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;If you believe you have found a security vulnerability in Worklenz, we encourage you to responsibly disclose this and not open a public issue. We will investigate all legitimate reports.&lt;/p&gt; &#xA;&lt;p&gt;Email &lt;a href=&#34;mailto:info@worklenz.com&#34;&gt;info@worklenz.com&lt;/a&gt; to disclose any security vulnerabilities.&lt;/p&gt; &#xA;&lt;h2&gt;Analytics&lt;/h2&gt; &#xA;&lt;p&gt;Worklenz uses Google Analytics to understand how the application is being used. This helps us improve the application and make better decisions about future development.&lt;/p&gt; &#xA;&lt;h3&gt;What We Track&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Anonymous usage statistics&lt;/li&gt; &#xA; &lt;li&gt;Page views and navigation patterns&lt;/li&gt; &#xA; &lt;li&gt;Feature usage&lt;/li&gt; &#xA; &lt;li&gt;Browser and device information&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Privacy&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Analytics is opt-in only&lt;/li&gt; &#xA; &lt;li&gt;No personal information is collected&lt;/li&gt; &#xA; &lt;li&gt;Users can opt-out at any time&lt;/li&gt; &#xA; &lt;li&gt;Data is stored according to Google&#39;s privacy policy&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How to Opt-Out&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;ve previously opted in and want to opt-out:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clear your browser&#39;s local storage for the Worklenz domain&lt;/li&gt; &#xA; &lt;li&gt;Or click the &#34;Decline&#34; button in the analytics notice if it appears&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://worklenz.com/features/task-management/&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://worklenz.s3.amazonaws.com/assets/screenshots/task-views-view.png&#34; alt=&#34;Worklenz task views&#34; width=&#34;1024&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://worklenz.com/features/time-tracking/&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://worklenz.s3.amazonaws.com/assets/screenshots/time-tracking-view.png&#34; alt=&#34;Worklenz time tracking&#34; width=&#34;1024&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://worklenz.com/features/analytics/&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://worklenz.s3.amazonaws.com/assets/screenshots/analytics-view.png&#34; alt=&#34;Worklenz analytics&#34; width=&#34;1024&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://worklenz.com/features/resource-management/&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://worklenz.s3.amazonaws.com/assets/screenshots/schedule-view.png&#34; alt=&#34;Worklenz scheduler&#34; width=&#34;1024&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://worklenz.com/features/templates/&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://worklenz.s3.amazonaws.com/assets/screenshots/templates-view.png&#34; alt=&#34;Worklenz templates&#34; width=&#34;1024&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We welcome contributions from the community! If you&#39;d like to contribute, please follow our &lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/CONTRIBUTING.md&#34;&gt;contributing guidelines&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Worklenz is open source and released under the &lt;a href=&#34;https://raw.githubusercontent.com/Worklenz/worklenz/main/LICENSE&#34;&gt;GNU Affero General Public License Version 3 (AGPLv3)&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By contributing to Worklenz, you agree that your contributions will be licensed under its AGPL.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>C4illin/ConvertX</title>
    <updated>2025-07-22T01:29:32Z</updated>
    <id>tag:github.com,2025-07-22:/C4illin/ConvertX</id>
    <link href="https://github.com/C4illin/ConvertX" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üíæ Self-hosted online file converter. Supports 1000+ formats ‚öôÔ∏è&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/C4illin/ConvertX/main/images/logo.png&#34; alt=&#34;ConvertX&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;ConvertX&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/C4illin/ConvertX/actions/workflows/docker-publish.yml&#34;&gt;&lt;img src=&#34;https://github.com/C4illin/ConvertX/actions/workflows/docker-publish.yml/badge.svg?branch=main&#34; alt=&#34;Docker&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/C4illin/ConvertX/pkgs/container/ConvertX&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/dynamic/json?logo=github&amp;amp;url=https%3A%2F%2Fipitio.github.io%2Fbackage%2FC4illin%2FConvertX%2Fconvertx.json&amp;amp;query=%24.downloads&amp;amp;label=ghcr.io%20pulls&amp;amp;cacheSeconds=14400&#34; alt=&#34;ghcr.io Pulls&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hub.docker.com/r/c4illin/convertx&#34;&gt;&lt;img src=&#34;https://img.shields.io/docker/pulls/c4illin/convertx?style=flat&amp;amp;logo=docker&amp;amp;label=dockerhub%20pulls&amp;amp;link=https%3A%2F%2Fhub.docker.com%2Frepository%2Fdocker%2Fc4illin%2Fconvertx%2Fgeneral&#34; alt=&#34;Docker Pulls&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/C4illin/ConvertX/pkgs/container/convertx&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/C4illin/ConvertX&#34; alt=&#34;GitHub Release&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/commits-since/C4illin/ConvertX/latest&#34; alt=&#34;GitHub commits since latest release&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/repo-size/C4illin/ConvertX&#34; alt=&#34;GitHub repo size&#34;&gt; &lt;img src=&#34;https://ghcr-badge.egpl.dev/c4illin/convertx/size?color=%230375b6&amp;amp;tag=latest&amp;amp;label=image+size&amp;amp;trim=&#34; alt=&#34;Docker container size&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://trendshift.io/repositories/13818&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://trendshift.io/api/badge/repositories/13818&#34; alt=&#34;C4illin%2FConvertX | Trendshift&#34; style=&#34;width: 250px; height: 55px;&#34; width=&#34;250&#34; height=&#34;55&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- ![Dev image size](https://ghcr-badge.egpl.dev/c4illin/convertx/size?color=%230375b6&amp;tag=main&amp;label=dev+image&amp;trim=) --&gt; &#xA;&lt;p&gt;A self-hosted online file converter. Supports over a thousand different formats. Written with TypeScript, Bun and Elysia.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Convert files to different formats&lt;/li&gt; &#xA; &lt;li&gt;Process multiple files at once&lt;/li&gt; &#xA; &lt;li&gt;Password protection&lt;/li&gt; &#xA; &lt;li&gt;Multiple accounts&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Converters supported&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Converter&lt;/th&gt; &#xA;   &lt;th&gt;Use case&lt;/th&gt; &#xA;   &lt;th&gt;Converts from&lt;/th&gt; &#xA;   &lt;th&gt;Converts to&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/libjxl/libjxl&#34;&gt;libjxl&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;JPEG XL&lt;/td&gt; &#xA;   &lt;td&gt;11&lt;/td&gt; &#xA;   &lt;td&gt;11&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/RazrFalcon/resvg&#34;&gt;resvg&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;SVG&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/libvips/libvips&#34;&gt;Vips&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Images&lt;/td&gt; &#xA;   &lt;td&gt;45&lt;/td&gt; &#xA;   &lt;td&gt;23&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/strukturag/libheif&#34;&gt;libheif&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;HEIF&lt;/td&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://tug.org/xetex/&#34;&gt;XeLaTeX&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;LaTeX&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://calibre-ebook.com/&#34;&gt;Calibre&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;E-books&lt;/td&gt; &#xA;   &lt;td&gt;26&lt;/td&gt; &#xA;   &lt;td&gt;19&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://pandoc.org/&#34;&gt;Pandoc&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Documents&lt;/td&gt; &#xA;   &lt;td&gt;43&lt;/td&gt; &#xA;   &lt;td&gt;65&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://dvisvgm.de/&#34;&gt;dvisvgm&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Vector images&lt;/td&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://imagemagick.org/&#34;&gt;ImageMagick&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Images&lt;/td&gt; &#xA;   &lt;td&gt;245&lt;/td&gt; &#xA;   &lt;td&gt;183&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;http://www.graphicsmagick.org/&#34;&gt;GraphicsMagick&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Images&lt;/td&gt; &#xA;   &lt;td&gt;167&lt;/td&gt; &#xA;   &lt;td&gt;130&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://inkscape.org/&#34;&gt;Inkscape&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Vector images&lt;/td&gt; &#xA;   &lt;td&gt;7&lt;/td&gt; &#xA;   &lt;td&gt;17&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/assimp/assimp&#34;&gt;Assimp&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;3D Assets&lt;/td&gt; &#xA;   &lt;td&gt;77&lt;/td&gt; &#xA;   &lt;td&gt;23&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://ffmpeg.org/&#34;&gt;FFmpeg&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Video&lt;/td&gt; &#xA;   &lt;td&gt;~472&lt;/td&gt; &#xA;   &lt;td&gt;~199&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://potrace.sourceforge.net/&#34;&gt;Potrace&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Raster to vector&lt;/td&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;11&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;!-- many ffmpeg fileformats are duplicates --&gt; &#xA;&lt;p&gt;Any missing converter? Open an issue or pull request!&lt;/p&gt; &#xA;&lt;h2&gt;Deployment&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!WARNING] If you can&#39;t login, make sure you are accessing the service over localhost or https otherwise set HTTP_ALLOWED=true&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# docker-compose.yml&#xA;services:&#xA;  convertx:&#xA;    image: ghcr.io/c4illin/convertx&#xA;    container_name: convertx&#xA;    restart: unless-stopped&#xA;    ports:&#xA;      - &#34;3000:3000&#34;&#xA;    environment:&#xA;      - JWT_SECRET=aLongAndSecretStringUsedToSignTheJSONWebToken1234 # will use randomUUID() if unset&#xA;    volumes:&#xA;      - ./data:/app/data&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -p 3000:3000 -v ./data:/app/data ghcr.io/c4illin/convertx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then visit &lt;code&gt;http://localhost:3000&lt;/code&gt; in your browser and create your account. Don&#39;t leave it unconfigured and open, as anyone can register the first account.&lt;/p&gt; &#xA;&lt;p&gt;If you get unable to open database file run &lt;code&gt;chown -R $USER:$USER path&lt;/code&gt; on the path you choose.&lt;/p&gt; &#xA;&lt;h3&gt;Environment variables&lt;/h3&gt; &#xA;&lt;p&gt;All are optional, JWT_SECRET is recommended to be set.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;JWT_SECRET&lt;/td&gt; &#xA;   &lt;td&gt;when unset it will use the value from randomUUID()&lt;/td&gt; &#xA;   &lt;td&gt;A long and secret string used to sign the JSON Web Token&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ACCOUNT_REGISTRATION&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;Allow users to register accounts&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;HTTP_ALLOWED&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;Allow HTTP connections, only set this to true locally&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ALLOW_UNAUTHENTICATED&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;Allow unauthenticated users to use the service, only set this to true locally&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;AUTO_DELETE_EVERY_N_HOURS&lt;/td&gt; &#xA;   &lt;td&gt;24&lt;/td&gt; &#xA;   &lt;td&gt;Checks every n hours for files older then n hours and deletes them, set to 0 to disable&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;WEBROOT&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The address to the root path setting this to &#34;/convert&#34; will serve the website on &#34;example.com/convert/&#34;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FFMPEG_ARGS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Arguments to pass to ffmpeg, e.g. &lt;code&gt;-preset veryfast&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;HIDE_HISTORY&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;Hide the history page&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;LANGUAGE&lt;/td&gt; &#xA;   &lt;td&gt;en&lt;/td&gt; &#xA;   &lt;td&gt;Language to format date strings in, specified as a &lt;a href=&#34;https://en.wikipedia.org/wiki/IETF_language_tag&#34;&gt;BCP 47 language tag&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Docker images&lt;/h3&gt; &#xA;&lt;p&gt;There is a &lt;code&gt;:latest&lt;/code&gt; tag that is updated with every release and a &lt;code&gt;:main&lt;/code&gt; tag that is updated with every push to the main branch. &lt;code&gt;:latest&lt;/code&gt; is recommended for normal use.&lt;/p&gt; &#xA;&lt;p&gt;The image is available on &lt;a href=&#34;https://github.com/C4illin/ConvertX/pkgs/container/ConvertX&#34;&gt;GitHub Container Registry&lt;/a&gt; and &lt;a href=&#34;https://hub.docker.com/r/c4illin/convertx&#34;&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Image&lt;/th&gt; &#xA;   &lt;th&gt;What it is&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;image: ghcr.io/c4illin/convertx&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The latest release on ghcr&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;image: ghcr.io/c4illin/convertx:main&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The latest commit on ghcr&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;image: c4illin/convertx&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The latest release on docker hub&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;image: c4illin/convertx:main&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The latest commit on docker hub&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://ghcr-badge.egpl.dev/c4illin/convertx/size?color=%230375b6&amp;amp;tag=latest&amp;amp;label=release+image&amp;amp;trim=&#34; alt=&#34;Release image size&#34;&gt; &lt;img src=&#34;https://ghcr-badge.egpl.dev/c4illin/convertx/size?color=%230375b6&amp;amp;tag=main&amp;amp;label=dev+image&amp;amp;trim=&#34; alt=&#34;Dev image size&#34;&gt;&lt;/p&gt; &#xA;&lt;!-- Dockerhub was introduced in 0.9.0 and older releases --&gt; &#xA;&lt;h3&gt;Tutorial&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] These are written by other people, and may be outdated, incorrect or wrong.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Tutorial in french: &lt;a href=&#34;https://belginux.com/installer-convertx-avec-docker/&#34;&gt;https://belginux.com/installer-convertx-avec-docker/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Tutorial in chinese: &lt;a href=&#34;https://xzllll.com/24092901/&#34;&gt;https://xzllll.com/24092901/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/C4illin/ConvertX/main/images/preview.png&#34; alt=&#34;ConvertX Preview&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://bun.sh/&#34;&gt;Bun&lt;/a&gt; and Git&lt;/li&gt; &#xA; &lt;li&gt;Clone the repository&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bun install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bun run dev&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Pull requests are welcome! See below and open issues for the list of todos.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://www.conventionalcommits.org/en/v1.0.0/#summary&#34;&gt;conventional commits&lt;/a&gt; for commit messages.&lt;/p&gt; &#xA;&lt;h2&gt;Todo&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add options for converters&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add tests&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Make errors logs visible from the web ui&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add more converters: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;a href=&#34;https://github.com/jsummers/deark&#34;&gt;deark&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; LibreOffice&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;a href=&#34;https://github.com/C4illin/ConvertX/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=C4illin/ConvertX&#34; alt=&#34;Image with all contributors&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;Star History&lt;/h2&gt; &#xA;&lt;a href=&#34;https://github.com/C4illin/ConvertX/stargazers&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://api.star-history.com/svg?repos=C4illin/ConvertX&amp;amp;type=Date&amp;amp;theme=dark&#34;&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;https://api.star-history.com/svg?repos=C4illin/ConvertX&amp;amp;type=Date&#34;&gt; &#xA;  &lt;img alt=&#34;Star History Chart&#34; src=&#34;https://api.star-history.com/svg?repos=C4illin/ConvertX&amp;amp;type=Date&#34;&gt; &#xA; &lt;/picture&gt; &lt;/a&gt;</summary>
  </entry>
  <entry>
    <title>bluenviron/mediamtx</title>
    <updated>2025-07-22T01:29:32Z</updated>
    <id>tag:github.com,2025-07-22:/bluenviron/mediamtx</id>
    <link href="https://github.com/bluenviron/mediamtx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ready-to-use SRT / WebRTC / RTSP / RTMP / LL-HLS media server and media proxy that allows to read, publish, proxy, record and playback video and audio streams.&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/logo.png&#34; alt=&#34;MediaMTX / rtsp-simple-server&#34;&gt; &lt;br&gt; &lt;br&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/bluenviron/mediamtx/actions/workflows/code_test.yml&#34;&gt;&lt;img src=&#34;https://github.com/bluenviron/mediamtx/actions/workflows/code_test.yml/badge.svg?sanitize=true&#34; alt=&#34;Test&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bluenviron/mediamtx/actions/workflows/code_lint.yml&#34;&gt;&lt;img src=&#34;https://github.com/bluenviron/mediamtx/actions/workflows/code_lint.yml/badge.svg?sanitize=true&#34; alt=&#34;Lint&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://app.codecov.io/gh/bluenviron/mediamtx/tree/main&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/bluenviron/mediamtx/branch/main/graph/badge.svg?sanitize=true&#34; alt=&#34;CodeCov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/bluenviron/mediamtx/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/bluenviron/mediamtx&#34; alt=&#34;Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hub.docker.com/r/bluenviron/mediamtx&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/docker-bluenviron/mediamtx-blue&#34; alt=&#34;Docker Hub&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://bluenviron.github.io/mediamtx&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/api-documentation-blue&#34; alt=&#34;API Documentation&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/h1&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;em&gt;MediaMTX&lt;/em&gt; is a ready-to-use and zero-dependency real-time media server and media proxy that allows to publish, read, proxy, record and playback video and audio streams. It has been conceived as a &#34;media router&#34; that routes media streams from one end to the other.&lt;/p&gt; &#xA;&lt;p&gt;Live streams can be published to the server with:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;protocol&lt;/th&gt; &#xA;   &lt;th&gt;variants&lt;/th&gt; &#xA;   &lt;th&gt;video codecs&lt;/th&gt; &#xA;   &lt;th&gt;audio codecs&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#srt-clients&#34;&gt;SRT clients&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;H265, H264, MPEG-4 Video (H263, Xvid), MPEG-1/2 Video&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#srt-cameras-and-servers&#34;&gt;SRT cameras and servers&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;H265, H264, MPEG-4 Video (H263, Xvid), MPEG-1/2 Video&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc-clients&#34;&gt;WebRTC clients&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WHIP&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, VP8, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#supported-browsers&#34;&gt;H265&lt;/a&gt;, H264&lt;/td&gt; &#xA;   &lt;td&gt;Opus, G722, G711 (PCMA, PCMU)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc-servers&#34;&gt;WebRTC servers&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WHEP&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, VP8, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#supported-browsers&#34;&gt;H265&lt;/a&gt;, H264&lt;/td&gt; &#xA;   &lt;td&gt;Opus, G722, G711 (PCMA, PCMU)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-clients&#34;&gt;RTSP clients&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;UDP, TCP, RTSPS&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, VP8, H265, H264, MPEG-4 Video (H263, Xvid), MPEG-1/2 Video, M-JPEG and any RTP-compatible codec&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3, G726, G722, G711 (PCMA, PCMU), LPCM and any RTP-compatible codec&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-cameras-and-servers&#34;&gt;RTSP cameras and servers&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;UDP, UDP-Multicast, TCP, RTSPS&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, VP8, H265, H264, MPEG-4 Video (H263, Xvid), MPEG-1/2 Video, M-JPEG and any RTP-compatible codec&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3, G726, G722, G711 (PCMA, PCMU), LPCM and any RTP-compatible codec&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtmp-clients&#34;&gt;RTMP clients&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RTMP, RTMPS, Enhanced RTMP&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, H265, H264&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3, G711 (PCMA, PCMU), LPCM&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtmp-cameras-and-servers&#34;&gt;RTMP cameras and servers&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RTMP, RTMPS, Enhanced RTMP&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, H265, H264&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3, G711 (PCMA, PCMU), LPCM&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#hls-cameras-and-servers&#34;&gt;HLS cameras and servers&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Low-Latency HLS, MP4-based HLS, legacy HLS&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#supported-browsers-1&#34;&gt;H265&lt;/a&gt;, H264&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#udpmpeg-ts&#34;&gt;UDP/MPEG-TS&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Unicast, broadcast, multicast&lt;/td&gt; &#xA;   &lt;td&gt;H265, H264, MPEG-4 Video (H263, Xvid), MPEG-1/2 Video&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#raspberry-pi-cameras&#34;&gt;Raspberry Pi Cameras&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;H264&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Live streams can be read from the server with:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;protocol&lt;/th&gt; &#xA;   &lt;th&gt;variants&lt;/th&gt; &#xA;   &lt;th&gt;video codecs&lt;/th&gt; &#xA;   &lt;th&gt;audio codecs&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#srt&#34;&gt;SRT&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;H265, H264, MPEG-4 Video (H263, Xvid), MPEG-1/2 Video&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc&#34;&gt;WebRTC&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WHEP&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, VP8, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#supported-browsers&#34;&gt;H265&lt;/a&gt;, H264&lt;/td&gt; &#xA;   &lt;td&gt;Opus, G722, G711 (PCMA, PCMU)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp&#34;&gt;RTSP&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;UDP, UDP-Multicast, TCP, RTSPS&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, VP8, H265, H264, MPEG-4 Video (H263, Xvid), MPEG-1/2 Video, M-JPEG and any RTP-compatible codec&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3, G726, G722, G711 (PCMA, PCMU), LPCM and any RTP-compatible codec&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtmp&#34;&gt;RTMP&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RTMP, RTMPS, Enhanced RTMP&lt;/td&gt; &#xA;   &lt;td&gt;H264&lt;/td&gt; &#xA;   &lt;td&gt;MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#hls&#34;&gt;HLS&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Low-Latency HLS, MP4-based HLS, legacy HLS&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#supported-browsers-1&#34;&gt;H265&lt;/a&gt;, H264&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Live streams be recorded and played back with:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;format&lt;/th&gt; &#xA;   &lt;th&gt;video codecs&lt;/th&gt; &#xA;   &lt;th&gt;audio codecs&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#record-streams-to-disk&#34;&gt;fMP4&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;AV1, VP9, H265, H264, MPEG-4 Video (H263, Xvid), MPEG-1/2 Video, M-JPEG&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3, G711 (PCMA, PCMU), LPCM&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#record-streams-to-disk&#34;&gt;MPEG-TS&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;H265, H264, MPEG-4 Video (H263, Xvid), MPEG-1/2 Video&lt;/td&gt; &#xA;   &lt;td&gt;Opus, MPEG-4 Audio (AAC), MPEG-1/2 Audio (MP3), AC-3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;Features&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Publish live streams to the server&lt;/li&gt; &#xA; &lt;li&gt;Read live streams from the server&lt;/li&gt; &#xA; &lt;li&gt;Streams are automatically converted from a protocol to another&lt;/li&gt; &#xA; &lt;li&gt;Serve multiple streams at once in separate paths&lt;/li&gt; &#xA; &lt;li&gt;Record streams to disk&lt;/li&gt; &#xA; &lt;li&gt;Playback recorded streams&lt;/li&gt; &#xA; &lt;li&gt;Authenticate users&lt;/li&gt; &#xA; &lt;li&gt;Redirect readers to other RTSP servers (load balancing)&lt;/li&gt; &#xA; &lt;li&gt;Control the server through the Control API&lt;/li&gt; &#xA; &lt;li&gt;Reload the configuration without disconnecting existing clients (hot reloading)&lt;/li&gt; &#xA; &lt;li&gt;Read Prometheus-compatible metrics&lt;/li&gt; &#xA; &lt;li&gt;Run hooks (external commands) when clients connect, disconnect, read or publish streams&lt;/li&gt; &#xA; &lt;li&gt;Compatible with Linux, Windows and macOS, does not require any dependency or interpreter, it&#39;s a single executable&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note about rtsp-simple-server&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;rtsp-simple-server&lt;/em&gt; has been rebranded as &lt;em&gt;MediaMTX&lt;/em&gt;. The reason is pretty obvious: this project started as a RTSP server but has evolved into a much more versatile product that is not tied to the RTSP protocol anymore. Nothing will change regarding license, features and backward compatibility.&lt;/p&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#standalone-binary&#34;&gt;Standalone binary&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#docker-image&#34;&gt;Docker image&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#arch-linux-package&#34;&gt;Arch Linux package&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#openwrt-binary&#34;&gt;OpenWrt binary&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#basic-usage&#34;&gt;Basic usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#publish-to-the-server&#34;&gt;Publish to the server&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#by-software&#34;&gt;By software&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg&#34;&gt;FFmpeg&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer&#34;&gt;GStreamer&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#obs-studio&#34;&gt;OBS Studio&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#opencv&#34;&gt;OpenCV&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#unity&#34;&gt;Unity&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#web-browsers&#34;&gt;Web browsers&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#by-device&#34;&gt;By device&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#generic-webcam&#34;&gt;Generic webcam&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#raspberry-pi-cameras&#34;&gt;Raspberry Pi Cameras&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#adding-audio&#34;&gt;Adding audio&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#secondary-stream&#34;&gt;Secondary stream&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#by-protocol&#34;&gt;By protocol&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#srt-clients&#34;&gt;SRT clients&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#srt-cameras-and-servers&#34;&gt;SRT cameras and servers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc-clients&#34;&gt;WebRTC clients&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc-servers&#34;&gt;WebRTC servers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-clients&#34;&gt;RTSP clients&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-cameras-and-servers&#34;&gt;RTSP cameras and servers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtmp-clients&#34;&gt;RTMP clients&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtmp-cameras-and-servers&#34;&gt;RTMP cameras and servers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#hls-cameras-and-servers&#34;&gt;HLS cameras and servers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#udpmpeg-ts&#34;&gt;UDP/MPEG-TS&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#read-from-the-server&#34;&gt;Read from the server&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#by-software-1&#34;&gt;By software&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg-1&#34;&gt;FFmpeg&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer-1&#34;&gt;GStreamer&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#vlc&#34;&gt;VLC&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#unity-1&#34;&gt;Unity&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#web-browsers-1&#34;&gt;Web browsers&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#by-protocol-1&#34;&gt;By protocol&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#srt&#34;&gt;SRT&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc&#34;&gt;WebRTC&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp&#34;&gt;RTSP&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtmp&#34;&gt;RTMP&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#hls&#34;&gt;HLS&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#other-features&#34;&gt;Other features&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#configuration&#34;&gt;Configuration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#authentication&#34;&gt;Authentication&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#internal&#34;&gt;Internal&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#http-based&#34;&gt;HTTP-based&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#jwt-based&#34;&gt;JWT-based&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#encrypt-the-configuration&#34;&gt;Encrypt the configuration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#remuxing-re-encoding-compression&#34;&gt;Remuxing, re-encoding, compression&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#record-streams-to-disk&#34;&gt;Record streams to disk&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#playback-recorded-streams&#34;&gt;Playback recorded streams&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#forward-streams-to-other-servers&#34;&gt;Forward streams to other servers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#proxy-requests-to-other-servers&#34;&gt;Proxy requests to other servers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#on-demand-publishing&#34;&gt;On-demand publishing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#route-absolute-timestamps&#34;&gt;Route absolute timestamps&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#expose-the-server-in-a-subfolder&#34;&gt;Expose the server in a subfolder&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#start-on-boot&#34;&gt;Start on boot&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#linux&#34;&gt;Linux&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#openwrt&#34;&gt;OpenWrt&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#windows&#34;&gt;Windows&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#hooks&#34;&gt;Hooks&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#control-api&#34;&gt;Control API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#metrics&#34;&gt;Metrics&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#pprof&#34;&gt;pprof&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#srt-specific-features&#34;&gt;SRT-specific features&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#standard-stream-id-syntax&#34;&gt;Standard stream ID syntax&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc-specific-features&#34;&gt;WebRTC-specific features&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#authenticating-with-whipwhep&#34;&gt;Authenticating with WHIP/WHEP&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#solving-webrtc-connectivity-issues&#34;&gt;Solving WebRTC connectivity issues&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#supported-browsers&#34;&gt;Supported browsers&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#hls-specific-features&#34;&gt;HLS-specific features&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#supported-browsers-1&#34;&gt;Supported browsers&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-specific-features&#34;&gt;RTSP-specific features&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#transport-protocols&#34;&gt;Transport protocols&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#encryption&#34;&gt;Encryption&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#corrupted-frames&#34;&gt;Corrupted frames&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtmp-specific-features&#34;&gt;RTMP-specific features&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#encryption-1&#34;&gt;Encryption&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#compile-from-source&#34;&gt;Compile from source&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#standard&#34;&gt;Standard&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#openwrt-1&#34;&gt;OpenWrt&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#custom-libcamera&#34;&gt;Custom libcamera&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#cross-compile&#34;&gt;Cross compile&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#compile-for-all-supported-platforms&#34;&gt;Compile for all supported platforms&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#docker-image-1&#34;&gt;Docker image&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#specifications&#34;&gt;Specifications&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#related-projects&#34;&gt;Related projects&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;There are several installation methods available: standalone binary, Docker image, Arch Linux package and OpenWrt binary.&lt;/p&gt; &#xA;&lt;h3&gt;Standalone binary&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Download and extract a standalone binary from the &lt;a href=&#34;https://github.com/bluenviron/mediamtx/releases&#34;&gt;release page&lt;/a&gt; that corresponds to your operating system and architecture.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Start the server:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Docker image&lt;/h3&gt; &#xA;&lt;p&gt;Download and launch the image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run --rm -it --network=host bluenviron/mediamtx:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Available images:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;FFmpeg included&lt;/th&gt; &#xA;   &lt;th&gt;RPI Camera support&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;bluenviron/mediamtx:latest&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;bluenviron/mediamtx:latest-ffmpeg&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úî&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;bluenviron/mediamtx:latest-rpi&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚ùå&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úî&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;bluenviron/mediamtx:latest-ffmpeg-rpi&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úî&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;‚úî&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The &lt;code&gt;--network=host&lt;/code&gt; flag is mandatory for RTSP to work, since Docker can change the source port of UDP packets for routing reasons, and this doesn&#39;t allow the server to identify the senders of the packets.&lt;/p&gt; &#xA;&lt;p&gt;If the &lt;code&gt;--network=host&lt;/code&gt; cannot be used (for instance, it is not compatible with Windows or Kubernetes), you can disable the RTSP UDP transport protocol, add the server IP to &lt;code&gt;MTX_WEBRTCADDITIONALHOSTS&lt;/code&gt; and expose ports manually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run --rm -it \&#xA;-e MTX_RTSPTRANSPORTS=tcp \&#xA;-e MTX_WEBRTCADDITIONALHOSTS=192.168.x.x \&#xA;-p 8554:8554 \&#xA;-p 1935:1935 \&#xA;-p 8888:8888 \&#xA;-p 8889:8889 \&#xA;-p 8890:8890/udp \&#xA;-p 8189:8189/udp \&#xA;bluenviron/mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Arch Linux package&lt;/h3&gt; &#xA;&lt;p&gt;If you are running the Arch Linux distribution, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://aur.archlinux.org/mediamtx.git&#xA;cd mediamtx&#xA;makepkg -si&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OpenWrt binary&lt;/h3&gt; &#xA;&lt;p&gt;If the architecture of the OpenWrt device is amd64, armv6, armv7 or arm64, use the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#standalone-binary&#34;&gt;standalone binary method&lt;/a&gt; and download a Linux binary that corresponds to your architecture.&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#openwrt-1&#34;&gt;compile the server from source&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Basic usage&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Publish a stream. For instance, you can publish a video/audio file with &lt;em&gt;FFmpeg&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ffmpeg -re -stream_loop -1 -i file.ts -c copy -f rtsp rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;or &lt;em&gt;GStreamer&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 rtspclientsink name=s location=rtsp://localhost:8554/mystream filesrc location=file.mp4 \&#xA;! qtdemux name=d d.video_0 ! queue ! s.sink_0 d.audio_0 ! queue ! s.sink_1&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open the stream. For instance, you can open the stream with &lt;em&gt;VLC&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vlc --network-caching=50 rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;or &lt;em&gt;GStreamer&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-play-1.0 rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;or &lt;em&gt;FFmpeg&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ffmpeg -i rtsp://localhost:8554/mystream -c copy output.mp4&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Publish to the server&lt;/h2&gt; &#xA;&lt;h3&gt;By software&lt;/h3&gt; &#xA;&lt;h4&gt;FFmpeg&lt;/h4&gt; &#xA;&lt;p&gt;FFmpeg can publish a stream to the server in multiple ways (SRT client, SRT server, RTSP client, RTMP client, UDP/MPEG-TS, WebRTC with WHIP). The recommended one consists in publishing as a &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-clients&#34;&gt;RTSP client&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ffmpeg -re -stream_loop -1 -i file.ts -c copy -f rtsp rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The RTSP protocol supports multiple underlying transport protocols, each with its own characteristics (see &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-specific-features&#34;&gt;RTSP-specific features&lt;/a&gt;). You can set the transport protocol by using the &lt;code&gt;rtsp_transport&lt;/code&gt; flag, for instance, in order to use TCP:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ffmpeg -re -stream_loop -1 -i file.ts -c copy -f rtsp -rtsp_transport tcp rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/mystream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;GStreamer&lt;/h4&gt; &#xA;&lt;p&gt;GStreamer can publish a stream to the server in multiple ways (SRT client, SRT server, RTSP client, RTMP client, UDP/MPEG-TS, WebRTC with WHIP). The recommended one consists in publishing as a &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-clients&#34;&gt;RTSP client&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 rtspclientsink name=s location=rtsp://localhost:8554/mystream \&#xA;filesrc location=file.mp4 ! qtdemux name=d \&#xA;d.video_0 ! queue ! s.sink_0 \&#xA;d.audio_0 ! queue ! s.sink_1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the stream is video only:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 filesrc location=file.mp4 ! qtdemux name=d \&#xA;d.video_0 ! rtspclientsink location=rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The RTSP protocol supports multiple underlying transport protocols, each with its own characteristics (see &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-specific-features&#34;&gt;RTSP-specific features&lt;/a&gt;). You can set the transport protocol by using the &lt;code&gt;protocols&lt;/code&gt; flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 filesrc location=file.mp4 ! qtdemux name=d \&#xA;d.video_0 ! rtspclientsink location=rtsp://localhost:8554/mystream protocols=tcp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If encryption is enabled, the &lt;code&gt;tls-validation-flags&lt;/code&gt; and &lt;code&gt;profiles&lt;/code&gt; options must be specified too:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 filesrc location=file.mp4 ! qtdemux name=d \&#xA;d.video_0 ! rtspclientsink location=rtsp://localhost:8554/mystream tls-validation-flags=0 profiles=GST_RTSP_PROFILE_SAVP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/mystream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;GStreamer can also publish a stream by using the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc&#34;&gt;WebRTC / WHIP protocol&lt;/a&gt;. Make sure that GStreamer version is at least 1.22, and that if the codec is H264, the profile is baseline. Use the &lt;code&gt;whipclientsink&lt;/code&gt; element:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gst-launch-1.0 videotestsrc \&#xA;! video/x-raw,width=1920,height=1080,format=I420 \&#xA;! x264enc speed-preset=ultrafast bitrate=2000 \&#xA;! video/x-h264,profile=baseline \&#xA;! whipclientsink signaller::whip-endpoint=http://localhost:8889/mystream/whip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;OBS Studio&lt;/h4&gt; &#xA;&lt;p&gt;OBS Studio can publish to the server in multiple ways (SRT client, RTMP client, WebRTC client). The recommended one consists in publishing as a &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtmp-clients&#34;&gt;RTMP client&lt;/a&gt;. In &lt;code&gt;Settings -&amp;gt; Stream&lt;/code&gt; (or in the Auto-configuration Wizard), use the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Service: &lt;code&gt;Custom...&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Server: &lt;code&gt;rtmp://localhost/mystream&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Stream key: (empty)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If credentials are in use, use the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Service: &lt;code&gt;Custom...&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Server: &lt;code&gt;rtmp://localhost/mystream?user=myuser&amp;amp;pass=mypass&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Stream key: (empty)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Save the configuration and click &lt;code&gt;Start streaming&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to generate a stream that can be read with WebRTC, open &lt;code&gt;Settings -&amp;gt; Output -&amp;gt; Recording&lt;/code&gt; and use the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;FFmpeg output type: &lt;code&gt;Output to URL&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;File path or URL: &lt;code&gt;rtsp://localhost:8554/mystream&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Container format: &lt;code&gt;rtsp&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Check &lt;code&gt;show all codecs (even if potentically incompatible)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Video encoder: &lt;code&gt;h264_nvenc (libx264)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Video encoder settings (if any): &lt;code&gt;bf=0&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Audio track: &lt;code&gt;1&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Audio encoder: &lt;code&gt;libopus&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Then use the button &lt;code&gt;Start Recording&lt;/code&gt; (instead of &lt;code&gt;Start Streaming&lt;/code&gt;) to start streaming.&lt;/p&gt; &#xA;&lt;p&gt;Recent versions of OBS Studio can also publish to the server with the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc&#34;&gt;WebRTC / WHIP protocol&lt;/a&gt;. Use the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Service: &lt;code&gt;WHIP&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Server: &lt;code&gt;http://localhost:8889/mystream/whip&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Bearer Token: &lt;code&gt;myuser:mypass&lt;/code&gt; (when internal authentication is enabled) or &lt;code&gt;JWT&lt;/code&gt; (when JWT-based authentication is enabled)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Save the configuration and click &lt;code&gt;Start streaming&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/mystream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;OpenCV&lt;/h4&gt; &#xA;&lt;p&gt;Software which uses the OpenCV library can publish to the server through its GStreamer plugin, as a &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-clients&#34;&gt;RTSP client&lt;/a&gt;. It must be compiled with GStreamer support, by following this procedure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt install -y libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev gstreamer1.0-plugins-ugly gstreamer1.0-rtsp python3-dev python3-numpy&#xA;git clone --depth=1 -b 4.5.4 https://github.com/opencv/opencv&#xA;cd opencv&#xA;mkdir build &amp;amp;&amp;amp; cd build&#xA;cmake -D CMAKE_INSTALL_PREFIX=/usr -D WITH_GSTREAMER=ON ..&#xA;make -j$(nproc)&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can check that OpenCV has been installed correctly by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;python3 -c &#39;import cv2; print(cv2.getBuildInformation())&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check that the output contains &lt;code&gt;GStreamer: YES&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Videos can be published with &lt;code&gt;cv2.VideoWriter&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime&#xA;from time import sleep, time&#xA;&#xA;import cv2&#xA;import numpy as np&#xA;&#xA;fps = 15&#xA;width = 800&#xA;height = 600&#xA;colors = [&#xA;    (0, 0, 255),&#xA;    (255, 0, 0),&#xA;    (0, 255, 0),&#xA;]&#xA;&#xA;out = cv2.VideoWriter(&#39;appsrc ! videoconvert&#39; + \&#xA;    &#39; ! video/x-raw,format=I420&#39; + \&#xA;    &#39; ! x264enc speed-preset=ultrafast bitrate=600 key-int-max=&#39; + str(fps * 2) + \&#xA;    &#39; ! video/x-h264,profile=baseline&#39; + \&#xA;    &#39; ! rtspclientsink location=rtsp://localhost:8554/mystream&#39;,&#xA;    cv2.CAP_GSTREAMER, 0, fps, (width, height), True)&#xA;if not out.isOpened():&#xA;    raise Exception(&#34;can&#39;t open video writer&#34;)&#xA;&#xA;curcolor = 0&#xA;start = time()&#xA;&#xA;while True:&#xA;    frame = np.zeros((height, width, 3), np.uint8)&#xA;&#xA;    # create a rectangle&#xA;    color = colors[curcolor]&#xA;    curcolor += 1&#xA;    curcolor %= len(colors)&#xA;    for y in range(0, int(frame.shape[0] / 2)):&#xA;        for x in range(0, int(frame.shape[1] / 2)):&#xA;            frame[y][x] = color&#xA;&#xA;    out.write(frame)&#xA;    print(&#34;%s frame written to the server&#34; % datetime.now())&#xA;&#xA;    now = time()&#xA;    diff = (1 / fps) - now - start&#xA;    if diff &amp;gt; 0:&#xA;        sleep(diff)&#xA;    start = now&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/mystream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Unity&lt;/h4&gt; &#xA;&lt;p&gt;Software written with the Unity Engine can publish a stream to the server by using the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc&#34;&gt;WebRTC protocol&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Create a new Unity project or open an existing open.&lt;/p&gt; &#xA;&lt;p&gt;Open &lt;em&gt;Window -&amp;gt; Package Manager&lt;/em&gt;, click on the plus sign, &lt;em&gt;Add Package by name...&lt;/em&gt; and insert &lt;code&gt;com.unity.webrtc&lt;/code&gt;. Wait for the package to be installed.&lt;/p&gt; &#xA;&lt;p&gt;In the &lt;em&gt;Project&lt;/em&gt; window, under &lt;code&gt;Assets&lt;/code&gt;, create a new C# Script called &lt;code&gt;WebRTCPublisher.cs&lt;/code&gt; with this content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;using System.Collections;&#xA;using UnityEngine;&#xA;using Unity.WebRTC;&#xA;using UnityEngine.Networking;&#xA;&#xA;public class WebRTCPublisher : MonoBehaviour&#xA;{&#xA;    public string url = &#34;http://localhost:8889/unity/whip&#34;;&#xA;    public int videoWidth = 1280;&#xA;    public int videoHeight = 720;&#xA;&#xA;    private RTCPeerConnection pc;&#xA;    private MediaStream videoStream;&#xA;&#xA;    void Start()&#xA;    {&#xA;        pc = new RTCPeerConnection();&#xA;        Camera sourceCamera = gameObject.GetComponent&amp;lt;Camera&amp;gt;();&#xA;        videoStream = sourceCamera.CaptureStream(videoWidth, videoHeight);&#xA;        foreach (var track in videoStream.GetTracks())&#xA;        {&#xA;            pc.AddTrack(track);&#xA;        }&#xA;&#xA;        StartCoroutine(WebRTC.Update());&#xA;        StartCoroutine(createOffer());&#xA;    }&#xA;&#xA;    private IEnumerator createOffer()&#xA;    {&#xA;        var op = pc.CreateOffer();&#xA;        yield return op;&#xA;        if (op.IsError) {&#xA;            Debug.LogError(&#34;CreateOffer() failed&#34;);&#xA;            yield break;&#xA;        }&#xA;&#xA;        yield return setLocalDescription(op.Desc);&#xA;    }&#xA;&#xA;    private IEnumerator setLocalDescription(RTCSessionDescription offer)&#xA;    {&#xA;        var op = pc.SetLocalDescription(ref offer);&#xA;        yield return op;&#xA;        if (op.IsError) {&#xA;            Debug.LogError(&#34;SetLocalDescription() failed&#34;);&#xA;            yield break;&#xA;        }&#xA;&#xA;        yield return postOffer(offer);&#xA;    }&#xA;&#xA;    private IEnumerator postOffer(RTCSessionDescription offer)&#xA;    {&#xA;        var content = new System.Net.Http.StringContent(offer.sdp);&#xA;        content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(&#34;application/sdp&#34;);&#xA;        var client = new System.Net.Http.HttpClient();&#xA;&#xA;        var task = System.Threading.Tasks.Task.Run(async () =&amp;gt; {&#xA;            var res = await client.PostAsync(new System.UriBuilder(url).Uri, content);&#xA;            res.EnsureSuccessStatusCode();&#xA;            return await res.Content.ReadAsStringAsync();&#xA;        });&#xA;        yield return new WaitUntil(() =&amp;gt; task.IsCompleted);&#xA;        if (task.Exception != null) {&#xA;            Debug.LogError(task.Exception);&#xA;            yield break;&#xA;        }&#xA;&#xA;        yield return setRemoteDescription(task.Result);&#xA;    }&#xA;&#xA;    private IEnumerator setRemoteDescription(string answer)&#xA;    {&#xA;        RTCSessionDescription desc = new RTCSessionDescription();&#xA;        desc.type = RTCSdpType.Answer;&#xA;        desc.sdp = answer;&#xA;        var op = pc.SetRemoteDescription(ref desc);&#xA;        yield return op;&#xA;        if (op.IsError) {&#xA;            Debug.LogError(&#34;SetRemoteDescription() failed&#34;);&#xA;            yield break;&#xA;        }&#xA;&#xA;        yield break;&#xA;    }&#xA;&#xA;    void OnDestroy()&#xA;    {&#xA;        pc?.Close();&#xA;        pc?.Dispose();&#xA;        videoStream?.Dispose();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the &lt;em&gt;Hierarchy&lt;/em&gt; window, find or create a scene and a camera, then add the &lt;code&gt;WebRTCPublisher.cs&lt;/code&gt; script as component of the camera, by dragging it inside the &lt;em&gt;Inspector&lt;/em&gt; window. then Press the &lt;em&gt;Play&lt;/em&gt; button at the top of the page.&lt;/p&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/unity&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Web browsers&lt;/h4&gt; &#xA;&lt;p&gt;Web browsers can publish a stream to the server by using the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc&#34;&gt;WebRTC protocol&lt;/a&gt;. Start the server and open the web page:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:8889/mystream/publish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/mystream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This web page can be embedded into another web page by using an iframe:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;iframe src=&#34;http://mediamtx-ip:8889/mystream/publish&#34; scrolling=&#34;no&#34;&amp;gt;&amp;lt;/iframe&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced setups, you can create and serve a custom web page by starting from the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/internal/servers/webrtc/publish_index.html&#34;&gt;source code of the WebRTC publish page&lt;/a&gt;. In particular, there&#39;s a ready-to-use, standalone JavaScript class for publishing streams with WebRTC, available in &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/internal/servers/webrtc/publisher.js&#34;&gt;publisher.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;By device&lt;/h3&gt; &#xA;&lt;h4&gt;Generic webcam&lt;/h4&gt; &#xA;&lt;p&gt;If the operating system is Linux-based, edit &lt;code&gt;mediamtx.yml&lt;/code&gt; and replace everything inside section &lt;code&gt;paths&lt;/code&gt; with the following content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  cam:&#xA;    runOnInit: ffmpeg -f v4l2 -i /dev/video0 -c:v libx264 -pix_fmt yuv420p -preset ultrafast -b:v 600k -f rtsp rtsp://localhost:$RTSP_PORT/$MTX_PATH&#xA;    runOnInitRestart: yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the operating system is Windows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  cam:&#xA;    runOnInit: ffmpeg -f dshow -i video=&#34;USB2.0 HD UVC WebCam&#34; -c:v libx264 -pix_fmt yuv420p -preset ultrafast -b:v 600k -f rtsp rtsp://localhost:$RTSP_PORT/$MTX_PATH&#xA;    runOnInitRestart: yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where &lt;code&gt;USB2.0 HD UVC WebCam&lt;/code&gt; is the name of a webcam, that can be obtained with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ffmpeg -list_devices true -f dshow -i dummy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/cam&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Raspberry Pi Cameras&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;MediaMTX&lt;/em&gt; natively supports most of the Raspberry Pi Camera models, enabling high-quality and low-latency video streaming from the camera to any user, for any purpose. There are a couple of requirements:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The server must run on a Raspberry Pi, with one of the following operating systems:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Raspberry Pi OS Bookworm&lt;/li&gt; &#xA;   &lt;li&gt;Raspberry Pi OS Bullseye&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Both 32 bit and 64 bit architectures are supported.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you are using Raspberry Pi OS Bullseye, make sure that the legacy camera stack is disabled. Type &lt;code&gt;sudo raspi-config&lt;/code&gt;, then go to &lt;code&gt;Interfacing options&lt;/code&gt;, &lt;code&gt;enable/disable legacy camera support&lt;/code&gt;, choose &lt;code&gt;no&lt;/code&gt;. Reboot the system.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you want to run the standard (non-Docker) version of the server:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Download the server executable. If you&#39;re using 64-bit version of the operative system, make sure to pick the &lt;code&gt;arm64&lt;/code&gt; variant.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Edit &lt;code&gt;mediamtx.yml&lt;/code&gt; and replace everything inside section &lt;code&gt;paths&lt;/code&gt; with the following content:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  cam:&#xA;    source: rpiCamera&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/cam&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to run the server inside Docker, you need to use the &lt;code&gt;latest-rpi&lt;/code&gt; image and launch the container with some additional flags:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run --rm -it \&#xA;--network=host \&#xA;--privileged \&#xA;--tmpfs /dev/shm:exec \&#xA;-v /run/udev:/run/udev:ro \&#xA;-e MTX_PATHS_CAM_SOURCE=rpiCamera \&#xA;bluenviron/mediamtx:latest-rpi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Be aware that precompiled binaries and Docker images are not compatible with cameras that require a custom &lt;code&gt;libcamera&lt;/code&gt; (like some ArduCam products), since they come with a bundled &lt;code&gt;libcamera&lt;/code&gt;. If you want to use a custom one, you can &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#custom-libcamera&#34;&gt;compile from source&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Camera settings can be changed by using the &lt;code&gt;rpiCamera*&lt;/code&gt; parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  cam:&#xA;    source: rpiCamera&#xA;    rpiCameraWidth: 1920&#xA;    rpiCameraHeight: 1080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All available parameters are listed in the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/mediamtx.yml&#34;&gt;sample configuration file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Adding audio&lt;/h5&gt; &#xA;&lt;p&gt;In order to add audio from a USB microfone, install GStreamer and alsa-utils:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt install -y gstreamer1.0-tools gstreamer1.0-rtsp gstreamer1.0-alsa alsa-utils&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;list available audio cards with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;arecord -L&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sample output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;surround51:CARD=ICH5,DEV=0&#xA;    Intel ICH5, Intel ICH5&#xA;    5.1 Surround output to Front, Center, Rear and Subwoofer speakers&#xA;default:CARD=U0x46d0x809&#xA;    USB Device 0x46d:0x809, USB Audio&#xA;    Default Audio Device&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Find the audio card of the microfone and take note of its name, for instance &lt;code&gt;default:CARD=U0x46d0x809&lt;/code&gt;. Then create a new path that takes the video stream from the camera and audio from the microphone:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  cam:&#xA;    source: rpiCamera&#xA;&#xA;  cam_with_audio:&#xA;    runOnInit: &amp;gt;&#xA;      gst-launch-1.0&#xA;      rtspclientsink name=s location=rtsp://localhost:$RTSP_PORT/cam_with_audio&#xA;      rtspsrc location=rtsp://127.0.0.1:$RTSP_PORT/cam latency=0 ! rtph264depay ! s.&#xA;      alsasrc device=default:CARD=U0x46d0x809 ! opusenc bitrate=16000 ! s.&#xA;    runOnInitRestart: yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/cam_with_audio&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Secondary stream&lt;/h5&gt; &#xA;&lt;p&gt;It is possible to enable a secondary stream from the same camera, with a different resolution, FPS and codec. Configuration is the same of a primary stream, with &lt;code&gt;rpiCameraSecondary&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; and parameters adjusted accordingly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  # primary stream&#xA;  rpi:&#xA;    source: rpiCamera&#xA;    # Width of frames.&#xA;    rpiCameraWidth: 1920&#xA;    # Height of frames.&#xA;    rpiCameraHeight: 1080&#xA;    # FPS.&#xA;    rpiCameraFPS: 30&#xA;&#xA;  # secondary stream&#xA;  secondary:&#xA;    source: rpiCamera&#xA;    # This is a secondary stream.&#xA;    rpiCameraSecondary: true&#xA;    # Width of frames.&#xA;    rpiCameraWidth: 640&#xA;    # Height of frames.&#xA;    rpiCameraHeight: 480&#xA;    # FPS.&#xA;    rpiCameraFPS: 10&#xA;    # Codec. in case of secondary streams, it defaults to M-JPEG.&#xA;    rpiCameraCodec: auto&#xA;    # JPEG quality.&#xA;    rpiCameraJPEGQuality: 60&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The secondary stream is available in path &lt;code&gt;/secondary&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;By protocol&lt;/h3&gt; &#xA;&lt;h4&gt;SRT clients&lt;/h4&gt; &#xA;&lt;p&gt;SRT is a protocol that allows to publish and read live data stream, providing encryption, integrity and a retransmission mechanism. It is usually used to transfer media streams encoded with MPEG-TS. In order to publish a stream to the server with the SRT protocol, use this URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;srt://localhost:8890?streamid=publish:mystream&amp;amp;pkt_size=1316&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replace &lt;code&gt;mystream&lt;/code&gt; with any name you want. The resulting stream is available in path &lt;code&gt;/mystream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If credentials are enabled, append username and password to &lt;code&gt;streamid&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;srt://localhost:8890?streamid=publish:mystream:user:pass&amp;amp;pkt_size=1316&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to use the standard stream ID syntax instead of the custom one in use by this server, see &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#standard-stream-id-syntax&#34;&gt;Standard stream ID syntax&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to publish a stream by using a client in listening mode (i.e. with &lt;code&gt;mode=listener&lt;/code&gt; appended to the URL), read the next section.&lt;/p&gt; &#xA;&lt;p&gt;Known clients that can publish with SRT are &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg&#34;&gt;FFmpeg&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer&#34;&gt;GStreamer&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#obs-studio&#34;&gt;OBS Studio&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SRT cameras and servers&lt;/h4&gt; &#xA;&lt;p&gt;In order to ingest into the server a SRT stream from an existing server, camera or client in listening mode (i.e. with &lt;code&gt;mode=listener&lt;/code&gt; appended to the URL), add the corresponding URL into the &lt;code&gt;source&lt;/code&gt; parameter of a path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  proxied:&#xA;    # url of the source stream, in the format srt://host:port?streamid=streamid&amp;amp;other_parameters&#xA;    source: srt://original-url&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;WebRTC clients&lt;/h4&gt; &#xA;&lt;p&gt;WebRTC is an API that makes use of a set of protocols and methods to connect two clients together and allow them to exchange real-time media or data streams. You can publish a stream with WebRTC and a web browser by visiting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:8889/mystream/publish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/mystream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;WHIP is a WebRTC extensions that allows to publish streams by using a URL, without passing through a web page. This allows to use WebRTC as a general purpose streaming protocol. If you are using a software that supports WHIP (for instance, latest versions of OBS Studio), you can publish a stream to the server by using this URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:8889/mystream/whip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Regarding authentication, read &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#authenticating-with-whipwhep&#34;&gt;Authenticating with WHIP/WHEP&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Depending on the network it may be difficult to establish a connection between server and clients, read &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#solving-webrtc-connectivity-issues&#34;&gt;Solving WebRTC connectivity issues&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Known clients that can publish with WebRTC and WHIP are &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg&#34;&gt;FFmpeg&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer&#34;&gt;GStreamer&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#obs-studio&#34;&gt;OBS Studio&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#unity&#34;&gt;Unity&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#web-browsers&#34;&gt;Web browsers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;WebRTC servers&lt;/h4&gt; &#xA;&lt;p&gt;In order to ingest into the server a WebRTC stream from an existing server, add the corresponding WHEP URL into the &lt;code&gt;source&lt;/code&gt; parameter of a path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  proxied:&#xA;    # url of the source stream, in the format whep://host:port/path (HTTP) or wheps:// (HTTPS)&#xA;    source: wheps://host:port/path&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;RTSP clients&lt;/h4&gt; &#xA;&lt;p&gt;RTSP is a protocol that allows to publish and read streams. It supports different underlying transport protocols and allows to encrypt streams in transit (see &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-specific-features&#34;&gt;RTSP-specific features&lt;/a&gt;). In order to publish a stream to the server with the RTSP protocol, use this URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/mystream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Known clients that can publish with RTSP are &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg&#34;&gt;FFmpeg&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer&#34;&gt;GStreamer&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#obs-studio&#34;&gt;OBS Studio&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;RTSP cameras and servers&lt;/h4&gt; &#xA;&lt;p&gt;Most IP cameras expose their video stream by using a RTSP server that is embedded into the camera itself. In particular, cameras that are compliant with ONVIF profile S or T meet this requirement. You can use &lt;em&gt;MediaMTX&lt;/em&gt; to connect to one or multiple existing RTSP servers and read their video streams:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  proxied:&#xA;    # url of the source stream, in the format rtsp://user:pass@host:port/path&#xA;    source: rtsp://original-url&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/proxied&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The server supports any number of source streams (count is just limited by available hardware resources) it&#39;s enough to add additional entries to the paths section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  proxied1:&#xA;    source: rtsp://url1&#xA;&#xA;  proxied2:&#xA;    source: rtsp://url1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;RTMP clients&lt;/h4&gt; &#xA;&lt;p&gt;RTMP is a protocol that allows to read and publish streams, but is less versatile and less efficient than RTSP and WebRTC (doesn&#39;t support UDP, doesn&#39;t support most RTSP codecs, doesn&#39;t support feedback mechanism). Streams can be published to the server by using the URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtmp://localhost/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/mystream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In case authentication is enabled, credentials can be passed to the server by using the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;pass&lt;/code&gt; query parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtmp://localhost/mystream?user=myuser&amp;amp;pass=mypass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Known clients that can publish with RTMP are &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg&#34;&gt;FFmpeg&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer&#34;&gt;GStreamer&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#obs-studio&#34;&gt;OBS Studio&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;RTMP cameras and servers&lt;/h4&gt; &#xA;&lt;p&gt;You can use &lt;em&gt;MediaMTX&lt;/em&gt; to connect to one or multiple existing RTMP servers and read their video streams:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  proxied:&#xA;    # url of the source stream, in the format rtmp://user:pass@host:port/path&#xA;    source: rtmp://original-url&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/proxied&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;HLS cameras and servers&lt;/h4&gt; &#xA;&lt;p&gt;HLS is a streaming protocol that works by splitting streams into segments, and by serving these segments and a playlist with the HTTP protocol. You can use &lt;em&gt;MediaMTX&lt;/em&gt; to connect to one or multiple existing HLS servers and read their video streams:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  proxied:&#xA;    # url of the playlist of the stream, in the format http://user:pass@host:port/path&#xA;    source: http://original-url/stream/index.m3u8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/proxied&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;UDP/MPEG-TS&lt;/h4&gt; &#xA;&lt;p&gt;The server supports ingesting UDP/MPEG-TS packets (i.e. MPEG-TS packets sent with UDP). Packets can be unicast, broadcast or multicast. For instance, you can generate a multicast UDP/MPEG-TS stream with GStreamer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 -v mpegtsmux name=mux alignment=1 ! udpsink host=238.0.0.1 port=1234 \&#xA;videotestsrc ! video/x-raw,width=1280,height=720,format=I420 ! x264enc speed-preset=ultrafast bitrate=3000 key-int-max=60 ! video/x-h264,profile=high ! mux. \&#xA;audiotestsrc ! audioconvert ! avenc_aac ! mux.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or FFmpeg:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ffmpeg -re -f lavfi -i testsrc=size=1280x720:rate=30 \&#xA;-c:v libx264 -pix_fmt yuv420p -preset ultrafast -b:v 600k \&#xA;-f mpegts udp://238.0.0.1:1234?pkt_size=1316&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Edit &lt;code&gt;mediamtx.yml&lt;/code&gt; and replace everything inside section &lt;code&gt;paths&lt;/code&gt; with the following content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  mypath:&#xA;    source: udp://238.0.0.1:1234&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream is available in path &lt;code&gt;/mypath&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If the listening IP is a multicast IP, &lt;em&gt;MediaMTX&lt;/em&gt; listens for incoming multicast packets on all network interfaces. It is possible to listen on a single interface only by using the &lt;code&gt;interface&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  mypath:&#xA;    source: udp://238.0.0.1:1234?interface=eth0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is possible to restrict who can send packets by using the &lt;code&gt;source&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  mypath:&#xA;    source: udp://0.0.0.0:1234?source=192.168.3.5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Known clients that can publish with UDP/MPEG-TS are &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg&#34;&gt;FFmpeg&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer&#34;&gt;GStreamer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Read from the server&lt;/h2&gt; &#xA;&lt;h3&gt;By software&lt;/h3&gt; &#xA;&lt;h4&gt;FFmpeg&lt;/h4&gt; &#xA;&lt;p&gt;FFmpeg can read a stream from the server in multiple ways (RTSP, RTMP, HLS, WebRTC with WHEP, SRT). The recommended one consists in reading with &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp&#34;&gt;RTSP&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ffmpeg -i rtsp://localhost:8554/mystream -c copy output.mp4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The RTSP protocol supports multiple underlying transport protocols, each with its own characteristics (see &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-specific-features&#34;&gt;RTSP-specific features&lt;/a&gt;). You can set the transport protocol by using the &lt;code&gt;rtsp_transport&lt;/code&gt; flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ffmpeg -rtsp_transport tcp -i rtsp://localhost:8554/mystream -c copy output.mp4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;GStreamer&lt;/h4&gt; &#xA;&lt;p&gt;GStreamer can read a stream from the server in multiple ways (RTSP, RTMP, HLS, WebRTC with WHEP, SRT). The recommended one consists in reading with &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp&#34;&gt;RTSP&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 rtspsrc location=rtsp://127.0.0.1:8554/mystream latency=0 ! decodebin ! autovideosink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The RTSP protocol supports multiple underlying transport protocols, each with its own characteristics (see &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-specific-features&#34;&gt;RTSP-specific features&lt;/a&gt;). You can change the transport protocol by using the &lt;code&gt;protocols&lt;/code&gt; flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 rtspsrc protocols=tcp location=rtsp://127.0.0.1:8554/mystream latency=0 ! decodebin ! autovideosink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If encryption is enabled, set &lt;code&gt;tls-validation-flags&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 rtspsrc tls-validation-flags=0 location=rtsps://ip:8322/...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;GStreamer also supports reading streams with WebRTC/WHEP, although track codecs must be specified in advance through the &lt;code&gt;video-caps&lt;/code&gt; and &lt;code&gt;audio-caps&lt;/code&gt; parameters. Furthermore, if audio is not present, &lt;code&gt;audio-caps&lt;/code&gt; must be set anyway and must point to a PCMU codec. For instance, the command for reading a video-only H264 stream is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 whepsrc whep-endpoint=http://127.0.0.1:8889/stream/whep use-link-headers=true \&#xA;video-caps=&#34;application/x-rtp,media=video,encoding-name=H264,payload=127,clock-rate=90000&#34; \&#xA;audio-caps=&#34;application/x-rtp,media=audio,encoding-name=PCMU,payload=0,clock-rate=8000&#34; \&#xA;! rtph264depay ! decodebin ! autovideosink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While the command for reading an audio-only Opus stream is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 whepsrc whep-endpoint=&#34;http://127.0.0.1:8889/stream/whep&#34; use-link-headers=true \&#xA;audio-caps=&#34;application/x-rtp,media=audio,encoding-name=OPUS,payload=111,clock-rate=48000,encoding-params=(string)2&#34; \&#xA;! rtpopusdepay ! decodebin ! autoaudiosink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While the command for reading a H264 and Opus stream is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gst-launch-1.0 whepsrc whep-endpoint=http://127.0.0.1:8889/stream/whep use-link-headers=true \&#xA;video-caps=&#34;application/x-rtp,media=video,encoding-name=H264,payload=127,clock-rate=90000&#34; \&#xA;audio-caps=&#34;application/x-rtp,media=audio,encoding-name=OPUS,payload=111,clock-rate=48000,encoding-params=(string)2&#34; \&#xA;! decodebin ! autovideosink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;VLC&lt;/h4&gt; &#xA;&lt;p&gt;VLC can read a stream from the server in multiple ways (RTSP, RTMP, HLS, SRT). The recommended one consists in reading with &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp&#34;&gt;RTSP&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vlc --network-caching=50 rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The RTSP protocol supports multiple underlying transport protocols, each with its own characteristics (see &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-specific-features&#34;&gt;RTSP-specific features&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;In order to use the TCP transport protocol, use the &lt;code&gt;--rtsp_tcp&lt;/code&gt; flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vlc --network-caching=50 --rtsp-tcp rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to use the UDP-multicast transport protocol, append &lt;code&gt;?vlcmulticast&lt;/code&gt; to the URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vlc --network-caching=50 rtsp://localhost:8554/mystream?vlcmulticast&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Ubuntu bug&lt;/h5&gt; &#xA;&lt;p&gt;The VLC shipped with Ubuntu 21.10 doesn&#39;t support playing RTSP due to a license issue (see &lt;a href=&#34;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=982299&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://stackoverflow.com/questions/69766748/cvlc-cannot-play-rtsp-omxplayer-instead-can&#34;&gt;here&lt;/a&gt;). To fix the issue, remove the default VLC instance and install the snap version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt purge -y vlc&#xA;snap install vlc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Encrypted streams&lt;/h5&gt; &#xA;&lt;p&gt;At the moment VLC doesn&#39;t support reading encrypted RTSP streams. However, you can use a proxy like &lt;a href=&#34;https://www.stunnel.org&#34;&gt;stunnel&lt;/a&gt; or &lt;a href=&#34;https://nginx.org/&#34;&gt;nginx&lt;/a&gt; or a local &lt;em&gt;MediaMTX&lt;/em&gt; instance to decrypt streams before reading them.&lt;/p&gt; &#xA;&lt;h4&gt;Unity&lt;/h4&gt; &#xA;&lt;p&gt;Software written with the Unity Engine can read a stream from the server by using the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc&#34;&gt;WebRTC protocol&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Create a new Unity project or open an existing open.&lt;/p&gt; &#xA;&lt;p&gt;Open &lt;em&gt;Window -&amp;gt; Package Manager&lt;/em&gt;, click on the plus sign, &lt;em&gt;Add Package by name...&lt;/em&gt; and insert &lt;code&gt;com.unity.webrtc&lt;/code&gt;. Wait for the package to be installed.&lt;/p&gt; &#xA;&lt;p&gt;In the &lt;em&gt;Project&lt;/em&gt; window, under &lt;code&gt;Assets&lt;/code&gt;, create a new C# Script called &lt;code&gt;WebRTCReader.cs&lt;/code&gt; with this content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;using System.Collections;&#xA;using UnityEngine;&#xA;using Unity.WebRTC;&#xA;&#xA;public class WebRTCReader : MonoBehaviour&#xA;{&#xA;    public string url = &#34;http://localhost:8889/stream/whep&#34;;&#xA;&#xA;    private RTCPeerConnection pc;&#xA;    private MediaStream receiveStream;&#xA;&#xA;    void Start()&#xA;    {&#xA;        UnityEngine.UI.RawImage rawImage = gameObject.GetComponentInChildren&amp;lt;UnityEngine.UI.RawImage&amp;gt;();&#xA;        AudioSource audioSource = gameObject.GetComponentInChildren&amp;lt;AudioSource&amp;gt;();&#xA;        pc = new RTCPeerConnection();&#xA;        receiveStream = new MediaStream();&#xA;&#xA;        pc.OnTrack = e =&amp;gt;&#xA;        {&#xA;            receiveStream.AddTrack(e.Track);&#xA;        };&#xA;&#xA;        receiveStream.OnAddTrack = e =&amp;gt;&#xA;        {&#xA;            if (e.Track is VideoStreamTrack videoTrack)&#xA;            {&#xA;                videoTrack.OnVideoReceived += (tex) =&amp;gt;&#xA;                {&#xA;                    rawImage.texture = tex;&#xA;                };&#xA;            }&#xA;            else if (e.Track is AudioStreamTrack audioTrack)&#xA;            {&#xA;                audioSource.SetTrack(audioTrack);&#xA;                audioSource.loop = true;&#xA;                audioSource.Play();&#xA;            }&#xA;        };&#xA;&#xA;        RTCRtpTransceiverInit init = new RTCRtpTransceiverInit();&#xA;        init.direction = RTCRtpTransceiverDirection.RecvOnly;&#xA;        pc.AddTransceiver(TrackKind.Audio, init);&#xA;        pc.AddTransceiver(TrackKind.Video, init);&#xA;&#xA;        StartCoroutine(WebRTC.Update());&#xA;        StartCoroutine(createOffer());&#xA;    }&#xA;&#xA;    private IEnumerator createOffer()&#xA;    {&#xA;        var op = pc.CreateOffer();&#xA;        yield return op;&#xA;        if (op.IsError) {&#xA;            Debug.LogError(&#34;CreateOffer() failed&#34;);&#xA;            yield break;&#xA;        }&#xA;&#xA;        yield return setLocalDescription(op.Desc);&#xA;    }&#xA;&#xA;    private IEnumerator setLocalDescription(RTCSessionDescription offer)&#xA;    {&#xA;        var op = pc.SetLocalDescription(ref offer);&#xA;        yield return op;&#xA;        if (op.IsError) {&#xA;            Debug.LogError(&#34;SetLocalDescription() failed&#34;);&#xA;            yield break;&#xA;        }&#xA;&#xA;        yield return postOffer(offer);&#xA;    }&#xA;&#xA;    private IEnumerator postOffer(RTCSessionDescription offer)&#xA;    {&#xA;        var content = new System.Net.Http.StringContent(offer.sdp);&#xA;        content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(&#34;application/sdp&#34;);&#xA;        var client = new System.Net.Http.HttpClient();&#xA;&#xA;        var task = System.Threading.Tasks.Task.Run(async () =&amp;gt; {&#xA;            var res = await client.PostAsync(new System.UriBuilder(url).Uri, content);&#xA;            res.EnsureSuccessStatusCode();&#xA;            return await res.Content.ReadAsStringAsync();&#xA;        });&#xA;        yield return new WaitUntil(() =&amp;gt; task.IsCompleted);&#xA;        if (task.Exception != null) {&#xA;            Debug.LogError(task.Exception);&#xA;            yield break;&#xA;        }&#xA;&#xA;        yield return setRemoteDescription(task.Result);&#xA;    }&#xA;&#xA;    private IEnumerator setRemoteDescription(string answer)&#xA;    {&#xA;        RTCSessionDescription desc = new RTCSessionDescription();&#xA;        desc.type = RTCSdpType.Answer;&#xA;        desc.sdp = answer;&#xA;        var op = pc.SetRemoteDescription(ref desc);&#xA;        yield return op;&#xA;        if (op.IsError) {&#xA;            Debug.LogError(&#34;SetRemoteDescription() failed&#34;);&#xA;            yield break;&#xA;        }&#xA;&#xA;        yield break;&#xA;    }&#xA;&#xA;    void OnDestroy()&#xA;    {&#xA;        pc?.Close();&#xA;        pc?.Dispose();&#xA;        receiveStream?.Dispose();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Edit the &lt;code&gt;url&lt;/code&gt; variable according to your needs.&lt;/p&gt; &#xA;&lt;p&gt;In the &lt;em&gt;Hierarchy&lt;/em&gt; window, find or create a scene. Inside the scene, add a &lt;em&gt;Canvas&lt;/em&gt;. Inside the Canvas, add a &lt;em&gt;Raw Image&lt;/em&gt; and an &lt;em&gt;Audio Source&lt;/em&gt;. Then add the &lt;code&gt;WebRTCReader.cs&lt;/code&gt; script as component of the canvas, by dragging it inside the &lt;em&gt;Inspector&lt;/em&gt; window. then Press the &lt;em&gt;Play&lt;/em&gt; button at the top of the page.&lt;/p&gt; &#xA;&lt;h4&gt;Web browsers&lt;/h4&gt; &#xA;&lt;p&gt;Web browsers can read a stream from the server in multiple ways (WebRTC or HLS).&lt;/p&gt; &#xA;&lt;p&gt;You can read a stream by using the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#webrtc-1&#34;&gt;WebRTC protocol&lt;/a&gt; by visiting the web page:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:8889/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This web page can be embedded into another web page by using an iframe:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;iframe src=&#34;http://mediamtx-ip:8889/mystream&#34; scrolling=&#34;no&#34;&amp;gt;&amp;lt;/iframe&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced setups, you can create and serve a custom web page by starting from the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/internal/servers/webrtc/read_index.html&#34;&gt;source code of the WebRTC read page&lt;/a&gt;. In particular, there&#39;s a ready-to-use, standalone JavaScript class for reading streams with WebRTC, available in &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/internal/servers/webrtc/reader.js&#34;&gt;reader.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Web browsers can also read a stream with the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#hls&#34;&gt;HLS protocol&lt;/a&gt;. Latency is higher but there are less problems related to connectivity between server and clients, furthermore the server load can be balanced by using a common HTTP CDN (like CloudFront or Cloudflare), and this allows to handle readers in the order of millions. Visit the web page:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:8888/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This web page can be embedded into another web page by using an iframe:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;iframe src=&#34;http://mediamtx-ip:8888/mystream&#34; scrolling=&#34;no&#34;&amp;gt;&amp;lt;/iframe&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced setups, you can create and serve a custom web page by starting from the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/internal/servers/hls/index.html&#34;&gt;source code of the HLS read page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;By protocol&lt;/h3&gt; &#xA;&lt;h4&gt;SRT&lt;/h4&gt; &#xA;&lt;p&gt;SRT is a protocol that allows to publish and read live data stream, providing encryption, integrity and a retransmission mechanism. It is usually used to transfer media streams encoded with MPEG-TS. In order to read a stream from the server with the SRT protocol, use this URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;srt://localhost:8890?streamid=read:mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replace &lt;code&gt;mystream&lt;/code&gt; with the path name.&lt;/p&gt; &#xA;&lt;p&gt;If credentials are enabled, append username and password to &lt;code&gt;streamid&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;srt://localhost:8890?streamid=read:mystream:user:pass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to use the standard stream ID syntax instead of the custom one in use by this server, see &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#standard-stream-id-syntax&#34;&gt;Standard stream ID syntax&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Known clients that can read with SRT are &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg-1&#34;&gt;FFmpeg&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer-1&#34;&gt;GStreamer&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#vlc&#34;&gt;VLC&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;WebRTC&lt;/h4&gt; &#xA;&lt;p&gt;WebRTC is an API that makes use of a set of protocols and methods to connect two clients together and allow them to exchange real-time media or data streams. You can read a stream with WebRTC and a web browser by visiting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:8889/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;WHEP is a WebRTC extensions that allows to read streams by using a URL, without passing through a web page. This allows to use WebRTC as a general purpose streaming protocol. If you are using a software that supports WHEP, you can read a stream from the server by using this URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:8889/mystream/whep&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Regarding authentication, read &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#authenticating-with-whipwhep&#34;&gt;Authenticating with WHIP/WHEP&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Depending on the network it may be difficult to establish a connection between server and clients, read &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#solving-webrtc-connectivity-issues&#34;&gt;Solving WebRTC connectivity issues&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Known clients that can read with WebRTC and WHEP are &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg-1&#34;&gt;FFmpeg&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer-1&#34;&gt;GStreamer&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#unity-1&#34;&gt;Unity&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#web-browsers-1&#34;&gt;web browsers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;RTSP&lt;/h4&gt; &#xA;&lt;p&gt;RTSP is a protocol that allows to publish and read streams. It supports different underlying transport protocols and allows to encrypt streams in transit (see &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#rtsp-specific-features&#34;&gt;RTSP-specific features&lt;/a&gt;). In order to read a stream with the RTSP protocol, use this URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Known clients that can read with RTSP are &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg-1&#34;&gt;FFmpeg&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer-1&#34;&gt;GStreamer&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#vlc&#34;&gt;VLC&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Latency&lt;/h5&gt; &#xA;&lt;p&gt;The RTSP protocol doesn&#39;t introduce any latency by itself. Latency is usually introduced by clients, that put frames in a buffer to compensate network fluctuations. In order to decrease latency, the best way consists in tuning the client. For instance, in VLC, latency can be decreased by decreasing the &lt;em&gt;Network caching&lt;/em&gt; parameter, that is available in the &lt;em&gt;Open network stream&lt;/em&gt; dialog or alternatively can be set with the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;vlc --network-caching=50 rtsp://...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;RTMP&lt;/h4&gt; &#xA;&lt;p&gt;RTMP is a protocol that allows to read and publish streams, but is less versatile and less efficient than RTSP and WebRTC (doesn&#39;t support UDP, doesn&#39;t support most RTSP codecs, doesn&#39;t support feedback mechanism). Streams can be read from the server by using the URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtmp://localhost/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case authentication is enabled, credentials can be passed to the server by using the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;pass&lt;/code&gt; query parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtmp://localhost/mystream?user=myuser&amp;amp;pass=mypass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Known clients that can read with RTMP are &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg-1&#34;&gt;FFmpeg&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer-1&#34;&gt;GStreamer&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#vlc&#34;&gt;VLC&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;HLS&lt;/h4&gt; &#xA;&lt;p&gt;HLS is a protocol that works by splitting streams into segments, and by serving these segments and a playlist with the HTTP protocol. You can use &lt;em&gt;MediaMTX&lt;/em&gt; to generate a HLS stream, that is accessible through a web page:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:8888/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and can also be accessed without using the browsers, by software that supports the HLS protocol (for instance VLC or &lt;em&gt;MediaMTX&lt;/em&gt; itself) by using this URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:8888/mystream/index.m3u8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Known clients that can read with HLS are &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#ffmpeg-1&#34;&gt;FFmpeg&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#gstreamer-1&#34;&gt;GStreamer&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#vlc&#34;&gt;VLC&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#web-browsers-1&#34;&gt;web browsers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;LL-HLS&lt;/h5&gt; &#xA;&lt;p&gt;Low-Latency HLS is a recently standardized variant of the protocol that allows to greatly reduce playback latency. It works by splitting segments into parts, that are served before the segment is complete. LL-HLS is enabled by default. If the stream is not shown correctly, try tuning the hlsPartDuration parameter, for instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;hlsPartDuration: 500ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Compatibility with Apple devices&lt;/h5&gt; &#xA;&lt;p&gt;In order to correctly display Low-Latency HLS streams in Safari running on Apple devices (iOS or macOS), a TLS certificate is needed and can be generated with OpenSSL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl genrsa -out server.key 2048&#xA;openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Set the &lt;code&gt;hlsEncryption&lt;/code&gt;, &lt;code&gt;hlsServerKey&lt;/code&gt; and &lt;code&gt;hlsServerCert&lt;/code&gt; parameters in the configuration file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;hlsEncryption: yes&#xA;hlsServerKey: server.key&#xA;hlsServerCert: server.crt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Keep also in mind that not all H264 video streams can be played on Apple Devices due to some intrinsic properties (distance between I-Frames, profile). If the video can&#39;t be played correctly, you can either:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;re-encode it by following instructions in this README&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;disable the Low-latency variant of HLS and go back to the legacy variant:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;  hlsVariant: mpegts&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Latency&lt;/h5&gt; &#xA;&lt;p&gt;in HLS, latency is introduced since a client must wait for the server to generate segments before downloading them. This latency amounts to 500ms-3s when the low-latency HLS variant is enabled (and it is by default), otherwise amounts to 1-15secs.&lt;/p&gt; &#xA;&lt;p&gt;To decrease the latency, you can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;try decreasing the hlsPartDuration parameter&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;try decreasing the hlsSegmentDuration parameter&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The segment duration is influenced by the interval between the IDR frames of the video track. An IDR frame is a frame that can be decoded independently from the others. The server changes the segment duration in order to include at least one IDR frame into each segment. Therefore, you need to decrease the interval between the IDR frames. This can be done in two ways:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;if the stream is being hardware-generated (i.e. by a camera), there&#39;s usually a setting called Key-Frame Interval in the camera configuration page&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;otherwise, the stream must be re-encoded. It&#39;s possible to tune the IDR frame interval by using ffmpeg&#39;s -g option:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ffmpeg -i rtsp://original-stream -c:v libx264 -pix_fmt yuv420p -preset ultrafast -b:v 600k -max_muxing_queue_size 1024 -g 30 -f rtsp rtsp://localhost:$RTSP_PORT/compressed&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other features&lt;/h2&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;All the configuration parameters are listed and commented in the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/mediamtx.yml&#34;&gt;configuration file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are 3 ways to change the configuration:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;By editing the &lt;code&gt;mediamtx.yml&lt;/code&gt; file, that is&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;included into the release bundle&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;available in the root folder of the Docker image (&lt;code&gt;/mediamtx.yml&lt;/code&gt;); it can be overridden in this way:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;docker run --rm -it --network=host -v &#34;$PWD/mediamtx.yml:/mediamtx.yml:ro&#34; bluenviron/mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;The configuration can be changed dynamically when the server is running (hot reloading) by writing to the configuration file. Changes are detected and applied without disconnecting existing clients, whenever it&#39;s possible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;By overriding configuration parameters with environment variables, in the format &lt;code&gt;MTX_PARAMNAME&lt;/code&gt;, where &lt;code&gt;PARAMNAME&lt;/code&gt; is the uppercase name of a parameter. For instance, the &lt;code&gt;rtspAddress&lt;/code&gt; parameter can be overridden in the following way:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;MTX_RTSPADDRESS=&#34;127.0.0.1:8554&#34; ./mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Parameters that have array as value can be overridden by setting a comma-separated list. For example:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;MTX_RTSPTRANSPORTS=&#34;tcp,udp&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Parameters in maps can be overridden by using underscores, in the following way:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;MTX_PATHS_TEST_SOURCE=rtsp://myurl ./mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This method is particularly useful when using Docker; any configuration parameter can be changed by passing environment variables with the &lt;code&gt;-e&lt;/code&gt; flag:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;docker run --rm -it --network=host -e MTX_PATHS_TEST_SOURCE=rtsp://myurl bluenviron/mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;By using the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#control-api&#34;&gt;Control API&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Authentication&lt;/h3&gt; &#xA;&lt;h4&gt;Internal&lt;/h4&gt; &#xA;&lt;p&gt;The server provides three methods to authenticate users:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Internal: users are stored in the configuration file&lt;/li&gt; &#xA; &lt;li&gt;HTTP-based: an external HTTP URL is contacted to perform authentication&lt;/li&gt; &#xA; &lt;li&gt;JWT: an external identity server provides authentication through JWTs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The internal authentication method is the default one. Users are stored inside the configuration file, in this format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;authInternalUsers:&#xA;  # Username. &#39;any&#39; means any user, including anonymous ones.&#xA;- user: any&#xA;  # Password. Not used in case of &#39;any&#39; user.&#xA;  pass:&#xA;  # IPs or networks allowed to use this user. An empty list means any IP.&#xA;  ips: []&#xA;  # List of permissions.&#xA;  permissions:&#xA;    # Available actions are: publish, read, playback, api, metrics, pprof.&#xA;  - action: publish&#xA;    # Paths can be set to further restrict access to a specific path.&#xA;    # An empty path means any path.&#xA;    # Regular expressions can be used by using a tilde as prefix.&#xA;    path:&#xA;  - action: read&#xA;    path:&#xA;  - action: playback&#xA;    path:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Only clients that provide username and passwords will be able to perform a certain action:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ffmpeg -re -stream_loop -1 -i file.ts -c copy -f rtsp rtsp://myuser:mypass@localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If storing plain credentials in the configuration file is a security problem, username and passwords can be stored as hashed strings. The Argon2 and SHA256 hashing algorithms are supported. To use Argon2, the string must be hashed using Argon2id (recommended) or Argon2i:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo -n &#34;mypass&#34; | argon2 saltItWithSalt -id -l 32 -e&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then stored with the &lt;code&gt;argon2:&lt;/code&gt; prefix:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;authInternalUsers:&#xA;- user: argon2:$argon2id$v=19$m=4096,t=3,p=1$MTIzNDU2Nzg$OGGO0eCMN0ievb4YGSzvS/H+Vajx1pcbUmtLp2tRqRU&#xA;  pass: argon2:$argon2i$v=19$m=4096,t=3,p=1$MTIzNDU2Nzg$oct3kOiFywTdDdt19kT07hdvmsPTvt9zxAUho2DLqZw&#xA;  permissions:&#xA;  - action: publish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use SHA256, the string must be hashed with SHA256 and encoded with base64:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo -n &#34;mypass&#34; | openssl dgst -binary -sha256 | openssl base64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then stored with the &lt;code&gt;sha256:&lt;/code&gt; prefix:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;authInternalUsers:&#xA;- user: sha256:j1tsRqDEw9xvq/D7/9tMx6Jh/jMhk3UfjwIB2f1zgMo=&#xA;  pass: sha256:BdSWkrdV+ZxFBLUQQY7+7uv9RmiSVA8nrPmjGjJtZQQ=&#xA;  permissions:&#xA;  - action: publish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: enable encryption or use a VPN to ensure that no one is intercepting the credentials in transit.&lt;/p&gt; &#xA;&lt;h4&gt;HTTP-based&lt;/h4&gt; &#xA;&lt;p&gt;Authentication can be delegated to an external HTTP server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;authMethod: http&#xA;authHTTPAddress: http://myauthserver/auth&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each time a user needs to be authenticated, the specified URL will be requested with the POST method and this payload:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;user&#34;: &#34;user&#34;,&#xA;  &#34;password&#34;: &#34;password&#34;,&#xA;  &#34;token&#34;: &#34;token&#34;,&#xA;  &#34;ip&#34;: &#34;ip&#34;,&#xA;  &#34;action&#34;: &#34;publish|read|playback|api|metrics|pprof&#34;,&#xA;  &#34;path&#34;: &#34;path&#34;,&#xA;  &#34;protocol&#34;: &#34;rtsp|rtmp|hls|webrtc|srt&#34;,&#xA;  &#34;id&#34;: &#34;id&#34;,&#xA;  &#34;query&#34;: &#34;query&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the URL returns a status code that begins with &lt;code&gt;20&lt;/code&gt; (i.e. &lt;code&gt;200&lt;/code&gt;), authentication is successful, otherwise it fails. Be aware that it&#39;s perfectly normal for the authentication server to receive requests with empty users and passwords, i.e.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;user&#34;: &#34;&#34;,&#xA;  &#34;password&#34;: &#34;&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This happens because RTSP clients don&#39;t provide credentials until they are asked to. In order to receive the credentials, the authentication server must reply with status code &lt;code&gt;401&lt;/code&gt;, then the client will send credentials.&lt;/p&gt; &#xA;&lt;p&gt;Some actions can be excluded from the process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# Actions to exclude from HTTP-based authentication.&#xA;# Format is the same as the one of user permissions.&#xA;authHTTPExclude:&#xA;- action: api&#xA;- action: metrics&#xA;- action: pprof&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;JWT-based&lt;/h4&gt; &#xA;&lt;p&gt;Authentication can be delegated to an external identity server, that is capable of generating JWTs and provides a JWKS endpoint. With respect to the HTTP-based method, this has the advantage that the external server is contacted once, and not for every request, greatly improving performance. In order to use the JWT-based authentication method, set &lt;code&gt;authMethod&lt;/code&gt; and &lt;code&gt;authJWTJWKS&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;authMethod: jwt&#xA;authJWTJWKS: http://my_identity_server/jwks_endpoint&#xA;authJWTClaimKey: mediamtx_permissions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The JWT is expected to contain a claim, with a list of permissions in the same format as the one of user permissions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA; &#34;mediamtx_permissions&#34;: [&#xA;    {&#xA;      &#34;action&#34;: &#34;publish&#34;,&#xA;      &#34;path&#34;: &#34;&#34;&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Clients are expected to pass the JWT in one of the following ways (from best to worst):&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Through the &lt;code&gt;Authorization: Bearer&lt;/code&gt; HTTP header. This is possible if the protocol or feature is based on HTTP, like HLS, WebRTC, API, Metrics, pprof.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;As password. Username is arbitrary.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;As query parameter in the URL, with the &lt;code&gt;jwt&lt;/code&gt; key. This method is discouraged since the JWT is publicly shared when the URL is shared, causing a security issue.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;These are the recommended methods for each client:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;client&lt;/th&gt; &#xA;   &lt;th&gt;protocol&lt;/th&gt; &#xA;   &lt;th&gt;method&lt;/th&gt; &#xA;   &lt;th&gt;notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Web browsers&lt;/td&gt; &#xA;   &lt;td&gt;HLS&lt;/td&gt; &#xA;   &lt;td&gt;Authorization: Bearer&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Web browsers&lt;/td&gt; &#xA;   &lt;td&gt;WebRTC&lt;/td&gt; &#xA;   &lt;td&gt;Authorization: Bearer&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OBS Studio&lt;/td&gt; &#xA;   &lt;td&gt;WebRTC&lt;/td&gt; &#xA;   &lt;td&gt;Authorization: Bearer&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OBS Studio&lt;/td&gt; &#xA;   &lt;td&gt;RTMP&lt;/td&gt; &#xA;   &lt;td&gt;Query parameter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FFmpeg&lt;/td&gt; &#xA;   &lt;td&gt;RTSP&lt;/td&gt; &#xA;   &lt;td&gt;Query parameter&lt;/td&gt; &#xA;   &lt;td&gt;password is truncated and cannot be used&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FFmpeg&lt;/td&gt; &#xA;   &lt;td&gt;RTMP&lt;/td&gt; &#xA;   &lt;td&gt;unsupported&lt;/td&gt; &#xA;   &lt;td&gt;Passwords and query parameters are currently truncated to 1024 characters by FFmpeg, so it&#39;s impossible to use FFMPEG+RTMP+JWT&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GStreamer&lt;/td&gt; &#xA;   &lt;td&gt;RTSP&lt;/td&gt; &#xA;   &lt;td&gt;Password&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GStreamer&lt;/td&gt; &#xA;   &lt;td&gt;RTMP&lt;/td&gt; &#xA;   &lt;td&gt;Query parameter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;any&lt;/td&gt; &#xA;   &lt;td&gt;SRT&lt;/td&gt; &#xA;   &lt;td&gt;unsupported&lt;/td&gt; &#xA;   &lt;td&gt;SRT truncates passwords and query parameters to 512 characters, so it&#39;s impossible to use SRT+JWT. See &lt;a href=&#34;https://github.com/bluenviron/mediamtx/issues/3430&#34;&gt;#3430&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Here&#39;s a tutorial on how to setup the &lt;a href=&#34;https://www.keycloak.org/&#34;&gt;Keycloak identity server&lt;/a&gt; in order to provide JWTs:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Start Keycloak:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;docker run --name=keycloak -p 8080:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:23.0.7 start-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open the Keycloak administration console on &lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt;, click on &lt;em&gt;master&lt;/em&gt; in the top left corner, &lt;em&gt;create realm&lt;/em&gt;, set realm name to &lt;code&gt;mediamtx&lt;/code&gt;, Save&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open page &lt;em&gt;Client scopes&lt;/em&gt;, &lt;em&gt;create client scope&lt;/em&gt;, set name to &lt;code&gt;mediamtx&lt;/code&gt;, Save&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open tab &lt;em&gt;Mappers&lt;/em&gt;, &lt;em&gt;Configure a new Mapper&lt;/em&gt;, &lt;em&gt;User Attribute&lt;/em&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Name: &lt;code&gt;mediamtx_permissions&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;User Attribute: &lt;code&gt;mediamtx_permissions&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Token Claim Name: &lt;code&gt;mediamtx_permissions&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Claim JSON Type: &lt;code&gt;JSON&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Multivalued: &lt;code&gt;On&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Save&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open page &lt;em&gt;Clients&lt;/em&gt;, &lt;em&gt;Create client&lt;/em&gt;, set Client ID to &lt;code&gt;mediamtx&lt;/code&gt;, Next, Client authentication &lt;code&gt;On&lt;/code&gt;, Next, Save&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open tab &lt;em&gt;Credentials&lt;/em&gt;, copy client secret somewhere&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open tab &lt;em&gt;Client scopes&lt;/em&gt;, &lt;em&gt;Add client scope&lt;/em&gt;, Select &lt;code&gt;mediamtx&lt;/code&gt;, Add, Default&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open page &lt;em&gt;Users&lt;/em&gt;, &lt;em&gt;Add user&lt;/em&gt;, Username &lt;code&gt;testuser&lt;/code&gt;, Tab credentials, &lt;em&gt;Set password&lt;/em&gt;, pick a password, Save&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open tab &lt;em&gt;Attributes&lt;/em&gt;, &lt;em&gt;Add an attribute&lt;/em&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Key: &lt;code&gt;mediamtx_permissions&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Value: &lt;code&gt;{&#34;action&#34;:&#34;publish&#34;, &#34;path&#34;: &#34;&#34;}&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;You can add as many attributes with key &lt;code&gt;mediamtx_permissions&lt;/code&gt; as you want, each with a single permission in it&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In MediaMTX, use the following URL:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;authJWTJWKS: http://localhost:8080/realms/mediamtx/protocol/openid-connect/certs&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Perform authentication on Keycloak:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;curl \&#xA;-d &#34;client_id=mediamtx&#34; \&#xA;-d &#34;client_secret=$CLIENT_SECRET&#34; \&#xA;-d &#34;username=$USER&#34; \&#xA;-d &#34;password=$PASS&#34; \&#xA;-d &#34;grant_type=password&#34; \&#xA;http://localhost:8080/realms/mediamtx/protocol/openid-connect/token&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The JWT is inside the &lt;code&gt;access_token&lt;/code&gt; key of the response:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;access_token&#34;:&#34;eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICIyNzVjX3ptOVlOdHQ0TkhwWVk4Und6ZndUclVGSzRBRmQwY3lsM2wtY3pzIn0.eyJleHAiOjE3MDk1NTUwOTIsImlhdCI6MTcwOTU1NDc5MiwianRpIjoiMzE3ZTQ1NGUtNzczMi00OTM1LWExNzAtOTNhYzQ2ODhhYWIxIiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwL3JlYWxtcy9tZWRpYW10eCIsImF1ZCI6ImFjY291bnQiLCJzdWIiOiI2NTBhZDA5Zi03MDgxLTQyNGItODI4Ni0xM2I3YTA3ZDI0MWEiLCJ0eXAiOiJCZWFyZXIiLCJhenAiOiJtZWRpYW10eCIsInNlc3Npb25fc3RhdGUiOiJjYzJkNDhjYy1kMmU5LTQ0YjAtODkzZS0wYTdhNjJiZDI1YmQiLCJhY3IiOiIxIiwiYWxsb3dlZC1vcmlnaW5zIjpbIi8qIl0sInJlYWxtX2FjY2VzcyI6eyJyb2xlcyI6WyJvZmZsaW5lX2FjY2VzcyIsInVtYV9hdXRob3JpemF0aW9uIiwiZGVmYXVsdC1yb2xlcy1tZWRpYW10eCJdfSwicmVzb3VyY2VfYWNjZXNzIjp7ImFjY291bnQiOnsicm9sZXMiOlsibWFuYWdlLWFjY291bnQiLCJtYW5hZ2UtYWNjb3VudC1saW5rcyIsInZpZXctcHJvZmlsZSJdfX0sInNjb3BlIjoibWVkaWFtdHggcHJvZmlsZSBlbWFpbCIsInNpZCI6ImNjMmQ0OGNjLWQyZTktNDRiMC04OTNlLTBhN2E2MmJkMjViZCIsImVtYWlsX3ZlcmlmaWVkIjpmYWxzZSwibWVkaWFtdHhfcGVybWlzc2lvbnMiOlt7ImFjdGlvbiI6InB1Ymxpc2giLCJwYXRocyI6ImFsbCJ9XSwicHJlZmVycmVkX3VzZXJuYW1lIjoidGVzdHVzZXIifQ.Gevz7rf1qHqFg7cqtSfSP31v_NS0VH7MYfwAdra1t6Yt5rTr9vJzqUeGfjYLQWR3fr4XC58DrPOhNnILCpo7jWRdimCnbPmuuCJ0AYM-Aoi3PAsWZNxgmtopq24_JokbFArY9Y1wSGFvF8puU64lt1jyOOyxf2M4cBHCs_EarCKOwuQmEZxSf8Z-QV9nlfkoTUszDCQTiKyeIkLRHL2Iy7Fw7_T3UI7sxJjVIt0c6HCNJhBBazGsYzmcSQ_GrmhbUteMTg00o6FicqkMBe99uZFnx9wIBm_QbO9hbAkkzF923I-DTAQrFLxT08ESMepDwmzFrmnwWYBLE3u8zuUlCA&#34;,&#34;expires_in&#34;:300,&#34;refresh_expires_in&#34;:1800,&#34;refresh_token&#34;:&#34;eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICI3OTI3Zjg4Zi05YWM4LTRlNmEtYWE1OC1kZmY0MDQzZDRhNGUifQ.eyJleHAiOjE3MDk1NTY1OTIsImlhdCI6MTcwOTU1NDc5MiwianRpIjoiMGVhZWFhMWItYzNhMC00M2YxLWJkZjAtZjI2NTRiODlkOTE3IiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwL3JlYWxtcy9tZWRpYW10eCIsImF1ZCI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9yZWFsbXMvbWVkaWFtdHgiLCJzdWIiOiI2NTBhZDA5Zi03MDgxLTQyNGItODI4Ni0xM2I3YTA3ZDI0MWEiLCJ0eXAiOiJSZWZyZXNoIiwiYXpwIjoibWVkaWFtdHgiLCJzZXNzaW9uX3N0YXRlIjoiY2MyZDQ4Y2MtZDJlOS00NGIwLTg5M2UtMGE3YTYyYmQyNWJkIiwic2NvcGUiOiJtZWRpYW10eCBwcm9maWxlIGVtYWlsIiwic2lkIjoiY2MyZDQ4Y2MtZDJlOS00NGIwLTg5M2UtMGE3YTYyYmQyNWJkIn0.yuXV8_JU0TQLuosNdp5xlYMjn7eO5Xq-PusdHzE7bsQ&#34;,&#34;token_type&#34;:&#34;Bearer&#34;,&#34;not-before-policy&#34;:0,&#34;session_state&#34;:&#34;cc2d48cc-d2e9-44b0-893e-0a7a62bd25bd&#34;,&#34;scope&#34;:&#34;mediamtx profile email&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Encrypt the configuration&lt;/h3&gt; &#xA;&lt;p&gt;The configuration file can be entirely encrypted for security purposes by using the &lt;code&gt;crypto_secretbox&lt;/code&gt; function of the NaCL function. An online tool for performing this operation is &lt;a href=&#34;https://play.golang.org/p/rX29jwObNe4&#34;&gt;available here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;After performing the encryption, put the base64-encoded result into the configuration file, and launch the server with the &lt;code&gt;MTX_CONFKEY&lt;/code&gt; variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;MTX_CONFKEY=mykey ./mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Remuxing, re-encoding, compression&lt;/h3&gt; &#xA;&lt;p&gt;To change the format, codec or compression of a stream, use &lt;em&gt;FFmpeg&lt;/em&gt; or &lt;em&gt;GStreamer&lt;/em&gt; together with &lt;em&gt;MediaMTX&lt;/em&gt;. For instance, to re-encode an existing stream, that is available in the &lt;code&gt;/original&lt;/code&gt; path, and publish the resulting stream in the &lt;code&gt;/compressed&lt;/code&gt; path, edit &lt;code&gt;mediamtx.yml&lt;/code&gt; and replace everything inside section &lt;code&gt;paths&lt;/code&gt; with the following content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  compressed:&#xA;  original:&#xA;    runOnReady: &amp;gt;&#xA;      ffmpeg -i rtsp://localhost:$RTSP_PORT/$MTX_PATH&#xA;        -c:v libx264 -pix_fmt yuv420p -preset ultrafast -b:v 600k&#xA;        -max_muxing_queue_size 1024 -f rtsp rtsp://localhost:$RTSP_PORT/compressed&#xA;    runOnReadyRestart: yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Record streams to disk&lt;/h3&gt; &#xA;&lt;p&gt;To save available streams to disk, set the &lt;code&gt;record&lt;/code&gt; and the &lt;code&gt;recordPath&lt;/code&gt; parameter in the configuration file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  # Record streams to disk.&#xA;  record: yes&#xA;  # Path of recording segments.&#xA;  # Extension is added automatically.&#xA;  # Available variables are %path (path name), %Y %m %d (year, month, day),&#xA;  # %H %M %S (hours, minutes, seconds), %f (microseconds), %z (time zone), %s (unix epoch).&#xA;  recordPath: ./recordings/%path/%Y-%m-%d_%H-%M-%S-%f&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All available recording parameters are listed in the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/mediamtx.yml&#34;&gt;sample configuration file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Be aware that not all codecs can be saved with all formats, as described in the compatibility matrix at the beginning of the README.&lt;/p&gt; &#xA;&lt;p&gt;To upload recordings to a remote location, you can use &lt;em&gt;MediaMTX&lt;/em&gt; together with &lt;a href=&#34;https://github.com/rclone/rclone&#34;&gt;rclone&lt;/a&gt;, a command line tool that provides file synchronization capabilities with a huge variety of services (including S3, FTP, SMB, Google Drive):&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Download and install &lt;a href=&#34;https://github.com/rclone/rclone&#34;&gt;rclone&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Configure &lt;em&gt;rclone&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;rclone config&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Place &lt;code&gt;rclone&lt;/code&gt; into the &lt;code&gt;runOnInit&lt;/code&gt; and &lt;code&gt;runOnRecordSegmentComplete&lt;/code&gt; hooks:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  # this is needed to sync segments after a crash.&#xA;  # replace myconfig with the name of the rclone config.&#xA;  runOnInit: rclone sync -v ./recordings myconfig:/my-path/recordings&#xA;&#xA;  # this is called when a segment has been finalized.&#xA;  # replace myconfig with the name of the rclone config.&#xA;  runOnRecordSegmentComplete: rclone sync -v --min-age=1ms ./recordings myconfig:/my-path/recordings&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If you want to delete local segments after they are uploaded, replace &lt;code&gt;rclone sync&lt;/code&gt; with &lt;code&gt;rclone move&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Playback recorded streams&lt;/h3&gt; &#xA;&lt;p&gt;Existing recordings can be served to users through a dedicated HTTP server, that can be enabled inside the configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;playback: yes&#xA;playbackAddress: :9996&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server provides an endpoint to list recorded timespans:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:9996/list?path=[mypath]&amp;amp;start=[start]&amp;amp;end=[end]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[mypath] is the name of a path&lt;/li&gt; &#xA; &lt;li&gt;[start] (optional) is the start date in &lt;a href=&#34;https://www.utctime.net/&#34;&gt;RFC3339 format&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;[end] (optional) is the end date in &lt;a href=&#34;https://www.utctime.net/&#34;&gt;RFC3339 format&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The server will return a list of timespans in JSON format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[&#xA;  {&#xA;    &#34;start&#34;: &#34;2006-01-02T15:04:05Z07:00&#34;,&#xA;    &#34;duration&#34;: 60.0,&#xA;    &#34;url&#34;: &#34;http://localhost:9996/get?path=[mypath]&amp;amp;start=2006-01-02T15%3A04%3A05Z07%3A00&amp;amp;duration=60.0&#34;&#xA;  },&#xA;  {&#xA;    &#34;start&#34;: &#34;2006-01-02T15:07:05Z07:00&#34;,&#xA;    &#34;duration&#34;: 32.33,&#xA;    &#34;url&#34;: &#34;http://localhost:9996/get?path=[mypath]&amp;amp;start=2006-01-02T15%3A07%3A05Z07%3A00&amp;amp;duration=32.33&#34;&#xA;  }&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server provides an endpoint to download recordings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:9996/get?path=[mypath]&amp;amp;start=[start]&amp;amp;duration=[duration]&amp;amp;format=[format]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[mypath] is the path name&lt;/li&gt; &#xA; &lt;li&gt;[start] is the start date in &lt;a href=&#34;https://www.utctime.net/&#34;&gt;RFC3339 format&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;[duration] is the maximum duration of the recording in seconds&lt;/li&gt; &#xA; &lt;li&gt;[format] (optional) is the output format of the stream. Available values are &#34;fmp4&#34; (default) and &#34;mp4&#34;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All parameters must be &lt;a href=&#34;https://www.urlencoder.org/&#34;&gt;url-encoded&lt;/a&gt;. For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:9996/get?path=mypath&amp;amp;start=2024-01-14T16%3A33%3A17%2B00%3A00&amp;amp;duration=200.5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting stream uses the fMP4 format, that is natively compatible with any browser, therefore its URL can be directly inserted into a &amp;lt;video&amp;gt; tag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;video controls&amp;gt;&#xA;  &amp;lt;source src=&#34;http://localhost:9996/get?path=[mypath]&amp;amp;start=[start_date]&amp;amp;duration=[duration]&#34; type=&#34;video/mp4&#34; /&amp;gt;&#xA;&amp;lt;/video&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The fMP4 format may offer limited compatibility with some players. To fix the issue, it&#39;s possible to use the standard MP4 format, by adding &lt;code&gt;format=mp4&lt;/code&gt; to a &lt;code&gt;/get&lt;/code&gt; request:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://localhost:9996/get?path=[mypath]&amp;amp;start=[start_date]&amp;amp;duration=[duration]&amp;amp;format=mp4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Forward streams to other servers&lt;/h3&gt; &#xA;&lt;p&gt;To forward incoming streams to another server, use &lt;em&gt;FFmpeg&lt;/em&gt; inside the &lt;code&gt;runOnReady&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  runOnReady: &amp;gt;&#xA;    ffmpeg -i rtsp://localhost:$RTSP_PORT/$MTX_PATH&#xA;    -c copy&#xA;    -f rtsp rtsp://other-server:8554/another-path&#xA;  runOnReadyRestart: yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Proxy requests to other servers&lt;/h3&gt; &#xA;&lt;p&gt;The server allows to proxy incoming requests to other servers or cameras. This is useful to expose servers or cameras behind a NAT. Edit &lt;code&gt;mediamtx.yml&lt;/code&gt; and replace everything inside section &lt;code&gt;paths&lt;/code&gt; with the following content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  &#34;~^proxy_(.+)$&#34;:&#xA;    # If path name is a regular expression, $G1, G2, etc will be replaced&#xA;    # with regular expression groups.&#xA;    source: rtsp://other-server:8554/$G1&#xA;    sourceOnDemand: yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All requests addressed to &lt;code&gt;rtsp://server:8854/proxy_a&lt;/code&gt; will be forwarded to &lt;code&gt;rtsp://other-server:8854/a&lt;/code&gt; and so on.&lt;/p&gt; &#xA;&lt;h3&gt;On-demand publishing&lt;/h3&gt; &#xA;&lt;p&gt;Edit &lt;code&gt;mediamtx.yml&lt;/code&gt; and replace everything inside section &lt;code&gt;paths&lt;/code&gt; with the following content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  ondemand:&#xA;    runOnDemand: ffmpeg -re -stream_loop -1 -i file.ts -c copy -f rtsp rtsp://localhost:$RTSP_PORT/$MTX_PATH&#xA;    runOnDemandRestart: yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The command inserted into &lt;code&gt;runOnDemand&lt;/code&gt; will start only when a client requests the path &lt;code&gt;ondemand&lt;/code&gt;, therefore the file will start streaming only when requested.&lt;/p&gt; &#xA;&lt;h3&gt;Route absolute timestamps&lt;/h3&gt; &#xA;&lt;p&gt;Some streaming protocols allow to route absolute timestamps, associated with each frame, that are useful for synchronizing several video or data streams together. In particular, &lt;em&gt;MediaMTX&lt;/em&gt; supports receiving absolute timestamps with the following protocols and devices:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;HLS (through the &lt;code&gt;EXT-X-PROGRAM-DATE-TIME&lt;/code&gt; tag in playlists)&lt;/li&gt; &#xA; &lt;li&gt;RTSP (through RTCP reports, when &lt;code&gt;useAbsoluteTimestamp&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; in settings)&lt;/li&gt; &#xA; &lt;li&gt;WebRTC (through RTCP reports, when &lt;code&gt;useAbsoluteTimestamp&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; in settings)&lt;/li&gt; &#xA; &lt;li&gt;Raspberry Pi Camera&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;and supports sending absolute timestamps with the following protocols:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;HLS (through the &lt;code&gt;EXT-X-PROGRAM-DATE-TIME&lt;/code&gt; tag in playlists)&lt;/li&gt; &#xA; &lt;li&gt;RTSP (through RTCP reports)&lt;/li&gt; &#xA; &lt;li&gt;WebRTC (through RTCP reports)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A library that can read absolute timestamps with HLS is &lt;a href=&#34;https://github.com/bluenviron/gohlslib&#34;&gt;gohlslib&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A library that can read absolute timestamps with RTSP is &lt;a href=&#34;https://github.com/bluenviron/gortsplib&#34;&gt;gortsplib&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A browser can read read absolute timestamps with WebRTC if it exposes the &lt;a href=&#34;https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats-estimatedplayouttimestamp&#34;&gt;estimatedPlayoutTimestamp&lt;/a&gt; statistic.&lt;/p&gt; &#xA;&lt;h3&gt;Expose the server in a subfolder&lt;/h3&gt; &#xA;&lt;p&gt;HTTP-based services (WebRTC, HLS, Control API, Playback Server, Metrics, pprof) can be exposed in a subfolder of an existing HTTP server or reverse proxy. The reverse proxy must be able to intercept HTTP requests addressed to MediaMTX and corresponding responses, and perform the following changes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The subfolder path must be stripped from request paths. For instance, if the server is exposed behind &lt;code&gt;/subpath&lt;/code&gt; and the reverse proxy receives a request with path &lt;code&gt;/subpath/mystream/index.m3u8&lt;/code&gt;, this has to be changed into &lt;code&gt;/mystream/index.m3u8&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Any &lt;code&gt;Location&lt;/code&gt; header in responses must be prefixed with the subfolder path. For instance, if the server is exposed behind &lt;code&gt;/subpath&lt;/code&gt; and the server sends a response with &lt;code&gt;Location: /mystream/index.m3u8&lt;/code&gt;, this has to be changed into &lt;code&gt;Location: /subfolder/mystream/index.m3u8&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If &lt;em&gt;nginx&lt;/em&gt; is the reverse proxy, this can be achieved with the following configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;location /subpath/ {&#xA;    proxy_pass http://mediamtx-ip:8889/;&#xA;    proxy_redirect / /subpath/;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;em&gt;Apache HTTP Server&lt;/em&gt; is the reverse proxy, this can be achieved with the following configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;Location /subpath&amp;gt;&#xA;    ProxyPass http://mediamtx-ip:8889&#xA;    ProxyPassReverse http://mediamtx-ip:8889&#xA;    Header edit Location ^(.*)$ &#34;/subpath$1&#34;&#xA;&amp;lt;/Location&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;em&gt;Caddy&lt;/em&gt; is the reverse proxy, this can be achieved with the following configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;:80 {&#xA;    handle_path /subpath/* {&#xA;        reverse_proxy {&#xA;            to mediamtx-ip:8889&#xA;            header_down Location ^/ /subpath/&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Start on boot&lt;/h3&gt; &#xA;&lt;h4&gt;Linux&lt;/h4&gt; &#xA;&lt;p&gt;On most Linux distributions (including Ubuntu and Debian, but not OpenWrt), &lt;em&gt;systemd&lt;/em&gt; is in charge of managing services and starting them on boot.&lt;/p&gt; &#xA;&lt;p&gt;Move the server executable and configuration in global folders:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo mv mediamtx /usr/local/bin/&#xA;sudo mv mediamtx.yml /usr/local/etc/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a &lt;em&gt;systemd&lt;/em&gt; service:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo tee /etc/systemd/system/mediamtx.service &amp;gt;/dev/null &amp;lt;&amp;lt; EOF&#xA;[Unit]&#xA;Wants=network.target&#xA;[Service]&#xA;ExecStart=/usr/local/bin/mediamtx /usr/local/etc/mediamtx.yml&#xA;[Install]&#xA;WantedBy=multi-user.target&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If SELinux is enabled (for instance in case of RedHat, Rocky, CentOS++), add correct security context:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;semanage fcontext -a -t bin_t /usr/local/bin/mediamtx&#xA;restorecon -Fv /usr/local/bin/mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable and start the service:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo systemctl daemon-reload&#xA;sudo systemctl enable mediamtx&#xA;sudo systemctl start mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;OpenWrt&lt;/h4&gt; &#xA;&lt;p&gt;Move the server executable and configuration in global folders:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mv mediamtx /usr/bin/&#xA;mkdir -p /usr/etc &amp;amp;&amp;amp; mv mediamtx.yml /usr/etc/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a procd service:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;tee /etc/init.d/mediamtx &amp;gt;/dev/null &amp;lt;&amp;lt; EOF&#xA;#!/bin/sh /etc/rc.common&#xA;USE_PROCD=1&#xA;START=95&#xA;STOP=01&#xA;start_service() {&#xA;    procd_open_instance&#xA;    procd_set_param command /usr/bin/mediamtx&#xA;    procd_set_param stdout 1&#xA;    procd_set_param stderr 1&#xA;    procd_close_instance&#xA;}&#xA;EOF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable and start the service:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;chmod +x /etc/init.d/mediamtx&#xA;/etc/init.d/mediamtx enable&#xA;/etc/init.d/mediamtx start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Read the server logs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;logread&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;p&gt;Download the &lt;a href=&#34;https://github.com/winsw/winsw/releases/download/v2.11.0/WinSW-x64.exe&#34;&gt;WinSW v2 executable&lt;/a&gt; and place it into the same folder of &lt;code&gt;mediamtx.exe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the same folder, create a file named &lt;code&gt;WinSW-x64.xml&lt;/code&gt; with this content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;service&amp;gt;&#xA;  &amp;lt;id&amp;gt;mediamtx&amp;lt;/id&amp;gt;&#xA;  &amp;lt;name&amp;gt;mediamtx&amp;lt;/name&amp;gt;&#xA;  &amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;&#xA;  &amp;lt;executable&amp;gt;%BASE%/mediamtx.exe&amp;lt;/executable&amp;gt;&#xA;&amp;lt;/service&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Open a terminal, navigate to the folder and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;WinSW-x64 install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server is now installed as a system service and will start at boot time.&lt;/p&gt; &#xA;&lt;h3&gt;Hooks&lt;/h3&gt; &#xA;&lt;p&gt;The server allows to specify commands that are executed when a certain event happens, allowing the propagation of events to external software.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnConnect&lt;/code&gt; allows to run a command when a client connects to the server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# Command to run when a client connects to the server.&#xA;# This is terminated with SIGINT when a client disconnects from the server.&#xA;# The following environment variables are available:&#xA;# * MTX_CONN_TYPE: connection type&#xA;# * MTX_CONN_ID: connection ID&#xA;# * RTSP_PORT: RTSP server port&#xA;runOnConnect: curl http://my-custom-server/webhook?conn_type=$MTX_CONN_TYPE&amp;amp;conn_id=$MTX_CONN_ID&#xA;# Restart the command if it exits.&#xA;runOnConnectRestart: no&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnDisconnect&lt;/code&gt; allows to run a command when a client disconnects from the server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# Command to run when a client disconnects from the server.&#xA;# Environment variables are the same of runOnConnect.&#xA;runOnDisconnect: curl http://my-custom-server/webhook?conn_type=$MTX_CONN_TYPE&amp;amp;conn_id=$MTX_CONN_ID&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnInit&lt;/code&gt; allows to run a command when a path is initialized. This can be used to publish a stream when the server is launched:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  mypath:&#xA;    # Command to run when this path is initialized.&#xA;    # This can be used to publish a stream when the server is launched.&#xA;    # The following environment variables are available:&#xA;    # * MTX_PATH: path name&#xA;    # * RTSP_PORT: RTSP server port&#xA;    # * G1, G2, ...: regular expression groups, if path name is&#xA;    #   a regular expression.&#xA;    runOnInit: ffmpeg -i my_file.mp4 -c copy -f rtsp rtsp://localhost:8554/mypath&#xA;    # Restart the command if it exits.&#xA;    runOnInitRestart: no&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnDemand&lt;/code&gt; allows to run a command when a path is requested by a reader. This can be used to publish a stream on demand:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  # Command to run when this path is requested by a reader&#xA;  # and no one is publishing to this path yet.&#xA;  # This is terminated with SIGINT when there are no readers anymore.&#xA;  # The following environment variables are available:&#xA;  # * MTX_PATH: path name&#xA;  # * MTX_QUERY: query parameters (passed by first reader)&#xA;  # * RTSP_PORT: RTSP server port&#xA;  # * G1, G2, ...: regular expression groups, if path name is&#xA;  #   a regular expression.&#xA;  runOnDemand: ffmpeg -i my_file.mp4 -c copy -f rtsp rtsp://localhost:8554/mypath&#xA;  # Restart the command if it exits.&#xA;  runOnDemandRestart: no&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnUnDemand&lt;/code&gt; allows to run a command when there are no readers anymore:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  # Command to run when there are no readers anymore.&#xA;  # Environment variables are the same of runOnDemand.&#xA;  runOnUnDemand:&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnReady&lt;/code&gt; allows to run a command when a stream is ready to be read:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  # Command to run when the stream is ready to be read, whenever it is&#xA;  # published by a client or pulled from a server / camera.&#xA;  # This is terminated with SIGINT when the stream is not ready anymore.&#xA;  # The following environment variables are available:&#xA;  # * MTX_PATH: path name&#xA;  # * MTX_QUERY: query parameters (passed by publisher)&#xA;  # * MTX_SOURCE_TYPE: source type&#xA;  # * MTX_SOURCE_ID: source ID&#xA;  # * RTSP_PORT: RTSP server port&#xA;  # * G1, G2, ...: regular expression groups, if path name is&#xA;  #   a regular expression.&#xA;  runOnReady: curl http://my-custom-server/webhook?path=$MTX_PATH&amp;amp;source_type=$MTX_SOURCE_TYPE&amp;amp;source_id=$MTX_SOURCE_ID&#xA;  # Restart the command if it exits.&#xA;  runOnReadyRestart: no&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnNotReady&lt;/code&gt; allows to run a command when a stream is not available anymore:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  # Command to run when the stream is not available anymore.&#xA;  # Environment variables are the same of runOnReady.&#xA;  runOnNotReady: curl http://my-custom-server/webhook?path=$MTX_PATH&amp;amp;source_type=$MTX_SOURCE_TYPE&amp;amp;source_id=$MTX_SOURCE_ID&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnRead&lt;/code&gt; allows to run a command when a client starts reading:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  # Command to run when a client starts reading.&#xA;  # This is terminated with SIGINT when a client stops reading.&#xA;  # The following environment variables are available:&#xA;  # * MTX_PATH: path name&#xA;  # * MTX_QUERY: query parameters (passed by reader)&#xA;  # * MTX_READER_TYPE: reader type&#xA;  # * MTX_READER_ID: reader ID&#xA;  # * RTSP_PORT: RTSP server port&#xA;  # * G1, G2, ...: regular expression groups, if path name is&#xA;  #   a regular expression.&#xA;  runOnRead: curl http://my-custom-server/webhook?path=$MTX_PATH&amp;amp;reader_type=$MTX_READER_TYPE&amp;amp;reader_id=$MTX_READER_ID&#xA;  # Restart the command if it exits.&#xA;  runOnReadRestart: no&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnUnread&lt;/code&gt; allows to run a command when a client stops reading:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  # Command to run when a client stops reading.&#xA;  # Environment variables are the same of runOnRead.&#xA;  runOnUnread: curl http://my-custom-server/webhook?path=$MTX_PATH&amp;amp;reader_type=$MTX_READER_TYPE&amp;amp;reader_id=$MTX_READER_ID&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnRecordSegmentCreate&lt;/code&gt; allows to run a command when a recording segment is created:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  # Command to run when a recording segment is created.&#xA;  # The following environment variables are available:&#xA;  # * MTX_PATH: path name&#xA;  # * MTX_SEGMENT_PATH: segment file path&#xA;  # * RTSP_PORT: RTSP server port&#xA;  # * G1, G2, ...: regular expression groups, if path name is&#xA;  #   a regular expression.&#xA;  runOnRecordSegmentCreate: curl http://my-custom-server/webhook?path=$MTX_PATH&amp;amp;segment_path=$MTX_SEGMENT_PATH&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;runOnRecordSegmentComplete&lt;/code&gt; allows to run a command when a recording segment is complete:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;pathDefaults:&#xA;  # Command to run when a recording segment is complete.&#xA;  # The following environment variables are available:&#xA;  # * MTX_PATH: path name&#xA;  # * MTX_SEGMENT_PATH: segment file path&#xA;  # * MTX_SEGMENT_DURATION: segment duration&#xA;  # * RTSP_PORT: RTSP server port&#xA;  # * G1, G2, ...: regular expression groups, if path name is&#xA;  #   a regular expression.&#xA;  runOnRecordSegmentComplete: curl http://my-custom-server/webhook?path=$MTX_PATH&amp;amp;segment_path=$MTX_SEGMENT_PATH&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Control API&lt;/h3&gt; &#xA;&lt;p&gt;The server can be queried and controlled with an API, that can be enabled by setting the &lt;code&gt;api&lt;/code&gt; parameter in the configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;api: yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To obtain a list of of active paths, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl http://127.0.0.1:9997/v3/paths/list&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Full documentation of the Control API is available on the &lt;a href=&#34;https://bluenviron.github.io/mediamtx/&#34;&gt;dedicated site&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Be aware that by default the Control API is accessible by localhost only; to increase visibility or add authentication, check &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#authentication&#34;&gt;Authentication&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Metrics&lt;/h3&gt; &#xA;&lt;p&gt;A metrics exporter, compatible with &lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;, can be enabled with the parameter &lt;code&gt;metrics: yes&lt;/code&gt;; then the server can be queried for metrics with Prometheus or with a simple HTTP request:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl localhost:9998/metrics&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Obtaining:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;# metrics of every path&#xA;paths{name=&#34;[path_name]&#34;,state=&#34;[state]&#34;} 1&#xA;paths_bytes_received{name=&#34;[path_name]&#34;,state=&#34;[state]&#34;} 1234&#xA;paths_bytes_sent{name=&#34;[path_name]&#34;,state=&#34;[state]&#34;} 1234&#xA;&#xA;# metrics of every HLS muxer&#xA;hls_muxers{name=&#34;[name]&#34;} 1&#xA;hls_muxers_bytes_sent{name=&#34;[name]&#34;} 187&#xA;&#xA;# metrics of every RTSP connection&#xA;rtsp_conns{id=&#34;[id]&#34;} 1&#xA;rtsp_conns_bytes_received{id=&#34;[id]&#34;} 1234&#xA;rtsp_conns_bytes_sent{id=&#34;[id]&#34;} 187&#xA;&#xA;# metrics of every RTSP session&#xA;rtsp_sessions{id=&#34;[id]&#34;,state=&#34;idle&#34;} 1&#xA;rtsp_sessions_bytes_received{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1234&#xA;rtsp_sessions_bytes_sent{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 187&#xA;rtsp_sessions_rtp_packets_received{id=&#34;[id]&#34;} 123&#xA;rtsp_sessions_rtp_packets_sent{id=&#34;[id]&#34;} 123&#xA;rtsp_sessions_rtp_packets_lost{id=&#34;[id]&#34;} 123&#xA;rtsp_sessions_rtp_packets_in_error{id=&#34;[id]&#34;} 123&#xA;rtsp_sessions_rtp_packets_jitter{id=&#34;[id]&#34;} 123&#xA;rtsp_sessions_rtcp_packets_received{id=&#34;[id]&#34;} 123&#xA;rtsp_sessions_rtcp_packets_sent{id=&#34;[id]&#34;} 123&#xA;rtsp_sessions_rtcp_packets_in_error{id=&#34;[id]&#34;} 123&#xA;&#xA;# metrics of every RTSPS connection&#xA;rtsps_conns{id=&#34;[id]&#34;} 1&#xA;rtsps_conns_bytes_received{id=&#34;[id]&#34;} 1234&#xA;rtsps_conns_bytes_sent{id=&#34;[id]&#34;} 187&#xA;&#xA;# metrics of every RTSPS session&#xA;rtsps_sessions{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1&#xA;rtsps_sessions_bytes_received{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1234&#xA;rtsps_sessions_bytes_sent{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 187&#xA;rtsps_sessions_rtp_packets_received{id=&#34;[id]&#34;} 123&#xA;rtsps_sessions_rtp_packets_sent{id=&#34;[id]&#34;} 123&#xA;rtsps_sessions_rtp_packets_lost{id=&#34;[id]&#34;} 123&#xA;rtsps_sessions_rtp_packets_in_error{id=&#34;[id]&#34;} 123&#xA;rtsps_sessions_rtp_packets_jitter{id=&#34;[id]&#34;} 123&#xA;rtsps_sessions_rtcp_packets_received{id=&#34;[id]&#34;} 123&#xA;rtsps_sessions_rtcp_packets_sent{id=&#34;[id]&#34;} 123&#xA;rtsps_sessions_rtcp_packets_in_error{id=&#34;[id]&#34;} 123&#xA;&#xA;# metrics of every RTMP connection&#xA;rtmp_conns{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1&#xA;rtmp_conns_bytes_received{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1234&#xA;rtmp_conns_bytes_sent{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 187&#xA;&#xA;# metrics of every RTMPS connection&#xA;rtmps_conns{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1&#xA;rtmps_conns_bytes_received{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1234&#xA;rtmps_conns_bytes_sent{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 187&#xA;&#xA;# metrics of every SRT connection&#xA;srt_conns{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1&#xA;srt_conns_packets_sent{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_sent_unique{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received_unique{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_send_loss{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received_loss{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_retrans{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received_retrans{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_sent_ack{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received_ack{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_sent_nak{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received_nak{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_sent_km{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received_km{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_us_snd_duration{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_send_drop{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received_drop{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received_undecrypt{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_sent{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 187&#xA;srt_conns_bytes_received{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1234&#xA;srt_conns_bytes_sent_unique{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_received_unique{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_received_loss{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_retrans{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_received_retrans{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_send_drop{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_received_drop{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_received_undecrypt{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_us_packets_send_period{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123.123&#xA;srt_conns_packets_flow_window{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_flight_size{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_ms_rtt{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123.123&#xA;srt_conns_mbps_send_rate{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_mbps_receive_rate{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123.123&#xA;srt_conns_mbps_link_capacity{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123.123&#xA;srt_conns_bytes_avail_send_buf{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_avail_receive_buf{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_mbps_max_bw{id=&#34;[id]&#34;,state=&#34;[state]&#34;} -123&#xA;srt_conns_bytes_mss{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_send_buf{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_send_buf{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_ms_send_buf{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_ms_send_tsb_pd_delay{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_receive_buf{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_bytes_receive_buf{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_ms_receive_buf{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_ms_receive_tsb_pd_delay{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_reorder_tolerance{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received_avg_belated_time{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_send_loss_rate{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;srt_conns_packets_received_loss_rate{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 123&#xA;&#xA;# metrics of every WebRTC session&#xA;webrtc_sessions{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1&#xA;webrtc_sessions_bytes_received{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 1234&#xA;webrtc_sessions_bytes_sent{id=&#34;[id]&#34;,state=&#34;[state]&#34;} 187&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;pprof&lt;/h3&gt; &#xA;&lt;p&gt;A performance monitor, compatible with pprof, can be enabled with the parameter &lt;code&gt;pprof: yes&lt;/code&gt;; then the server can be queried for metrics with pprof-compatible tools, like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;go tool pprof -text http://localhost:9999/debug/pprof/goroutine&#xA;go tool pprof -text http://localhost:9999/debug/pprof/heap&#xA;go tool pprof -text http://localhost:9999/debug/pprof/profile?seconds=30&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SRT-specific features&lt;/h3&gt; &#xA;&lt;h4&gt;Standard stream ID syntax&lt;/h4&gt; &#xA;&lt;p&gt;In SRT, the stream ID is a string that is sent to the remote part in order to advertise what action the caller is gonna do (publish or read), the path and the credentials. All these informations have to be encoded into a single string. This server supports two stream ID syntaxes, a custom one (that is the one reported in rest of the README) and also a &lt;a href=&#34;https://github.com/Haivision/srt/raw/master/docs/features/access-control.md&#34;&gt;standard one&lt;/a&gt; proposed by the authors of the protocol and enforced by some hardware. The standard syntax can be used in this way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;srt://localhost:8890?streamid=#!::m=publish,r=mypath,u=myuser,s=mypass&amp;amp;pkt_size=1316&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;key &lt;code&gt;m&lt;/code&gt; contains the action (&lt;code&gt;publish&lt;/code&gt; or &lt;code&gt;request&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;key &lt;code&gt;r&lt;/code&gt; contains the path&lt;/li&gt; &#xA; &lt;li&gt;key &lt;code&gt;u&lt;/code&gt; contains the username&lt;/li&gt; &#xA; &lt;li&gt;key &lt;code&gt;s&lt;/code&gt; contains the password&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;WebRTC-specific features&lt;/h3&gt; &#xA;&lt;h4&gt;Authenticating with WHIP/WHEP&lt;/h4&gt; &#xA;&lt;p&gt;When using WHIP or WHEP to establish a WebRTC connection, there are several ways to provide credentials.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If internal authentication or HTTP-based authentication is in use, username and password can be passed through the &lt;code&gt;Authorization: Basic&lt;/code&gt; HTTP header:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;Authorization: Basic base64(user:pass)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Where &lt;code&gt;base64(user:pass)&lt;/code&gt; is the base64 encoding of &#34;user:pass&#34;.&lt;/p&gt; &lt;p&gt;When the &lt;code&gt;Authorization: Basic&lt;/code&gt; header cannot be used (for instance, in software like OBS Studio), credentials can be passed through the &lt;code&gt;Authorization: Bearer&lt;/code&gt; header, where value is the concatenation of username and password, separated by a colon:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;Authorization: Bearer username:password&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If JWT-based authentication is in use, the JWT can be passed through the &lt;code&gt;Authorization: Bearer&lt;/code&gt; header:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;Authorization: Bearer MY_JWT&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Solving WebRTC connectivity issues&lt;/h4&gt; &#xA;&lt;p&gt;If the server is hosted inside a container or is behind a NAT, additional configuration is required in order to allow the two WebRTC parts (server and client) to establish a connection.&lt;/p&gt; &#xA;&lt;p&gt;Make sure that &lt;code&gt;webrtcAdditionalHosts&lt;/code&gt; includes your public IPs, that are IPs that can be used by clients to reach the server. If clients are on the same LAN as the server, add the LAN address of the server. If clients are coming from the internet, add the public IP address of the server, or alternatively a DNS name, if you have one. You can add multiple values to support all scenarios:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;webrtcAdditionalHosts: [192.168.x.x, 1.2.3.4, my-dns.example.org, ...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If there&#39;s a NAT / container between server and clients, it must be configured to route all incoming UDP packets on port 8189 to the server. If you&#39;re using Docker, this can be achieved with the flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run --rm -it \&#xA;-p 8189:8189/udp&#xA;....&#xA;bluenviron/mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you still have problems, the UDP protocol might be blocked by a firewall. Enable the TCP protocol by enabling the local TCP listener:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;webrtcLocalTCPAddress: :8189&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If there&#39;s a NAT / container between server and clients, it must be configured to route all incoming TCP packets on port 8189 to the server.&lt;/p&gt; &#xA;&lt;p&gt;If you still have problems, add a STUN server. When a STUN server is in use, server IP is obtained automatically and connections are established with the &#34;UDP hole punching&#34; technique, that uses a random UDP port that does not need to be open. For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;webrtcICEServers2:&#xA;  - url: stun:stun.l.google.com:19302&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you really still have problems, you can force all WebRTC/ICE connections to pass through a TURN server, like &lt;a href=&#34;https://github.com/coturn/coturn&#34;&gt;coturn&lt;/a&gt;, that must be configured externally. The server address and credentials must be set in the configuration file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;webrtcICEServers2:&#xA;- url: turn:host:port&#xA;  username: user&#xA;  password: password&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where user and pass are the username and password of the server. Note that port is not optional.&lt;/p&gt; &#xA;&lt;p&gt;If the server uses a secret-based authentication (for instance, coturn with the use-auth-secret option), it must be configured by using AUTH_SECRET as username, and the secret as password:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;webrtcICEServers2:&#xA;- url: turn:host:port&#xA;  username: AUTH_SECRET&#xA;  password: secret&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where secret is the secret of the TURN server. MediaMTX will generate a set of credentials by using the secret, and credentials will be sent to clients before the WebRTC/ICE connection is established.&lt;/p&gt; &#xA;&lt;p&gt;In some cases you may want the browser to connect using TURN servers but have mediamtx not using TURN (for example if the TURN server is on the same network as mediamtx). To allow this you can configure the TURN server to be client only:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;webrtcICEServers2:&#xA;- url: turn:host:port&#xA;  username: user&#xA;  password: password&#xA;  clientOnly: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Supported browsers&lt;/h4&gt; &#xA;&lt;p&gt;The server can ingest and broadcast with WebRTC a wide variety of video and audio codecs (that are listed at the beginning of the README), but not all browsers can publish and read all codecs due to internal limitations that cannot be overcome by this or any other server.&lt;/p&gt; &#xA;&lt;p&gt;In particular, reading and publishing H265 tracks with WebRTC was not possible until some time ago due to lack of browser support. The situation improved recently and can be described as following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Safari on iOS and macOS fully supports publishing and reading H265 tracks&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Chrome on Windows supports publishing and reading H265 tracks when a GPU is present and when the browser is launched with the following flags:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;chrome.exe --enable-features=PlatformHEVCEncoderSupport,WebRtcAllowH265Receive,WebRtcAllowH265Send --force-fieldtrials=WebRTC-Video-H26xPacketBuffer/Enabled&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We are expecting these flags to become redundant in the future and the feature to be turned on by default.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can check what codecs your browser can publish or read with WebRTC by &lt;a href=&#34;https://jsfiddle.net/v24s8q1f/&#34;&gt;using this tool&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to support most browsers, you can to re-encode the stream by using H264 and Opus codecs, for instance by using FFmpeg:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ffmpeg -i rtsp://original-source \&#xA;-c:v libx264 -pix_fmt yuv420p -preset ultrafast -b:v 600k \&#xA;-c:a libopus -b:a 64K -async 50 \&#xA;-f rtsp rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;HLS-specific features&lt;/h3&gt; &#xA;&lt;h4&gt;Supported browsers&lt;/h4&gt; &#xA;&lt;p&gt;The server can produce HLS streams with a variety of video and audio codecs (that are listed at the beginning of the README), but not all browsers can read all codecs due to internal limitations that cannot be overcome by this or any other server.&lt;/p&gt; &#xA;&lt;p&gt;You can check what codecs your browser can read with HLS by &lt;a href=&#34;https://jsfiddle.net/tjcyv5aw/&#34;&gt;using this tool&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to support most browsers, you can to re-encode the stream by using H264 and AAC codecs, for instance by using FFmpeg:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ffmpeg -i rtsp://original-source \&#xA;-c:v libx264 -pix_fmt yuv420p -preset ultrafast -b:v 600k \&#xA;-c:a aac -b:a 160k \&#xA;-f rtsp rtsp://localhost:8554/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RTSP-specific features&lt;/h3&gt; &#xA;&lt;h4&gt;Transport protocols&lt;/h4&gt; &#xA;&lt;p&gt;The RTSP protocol supports different underlying transport protocols, that are chosen by clients during the handshake with the server:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;UDP: the most performant, but doesn&#39;t work when there&#39;s a NAT/firewall between server and clients.&lt;/li&gt; &#xA; &lt;li&gt;UDP-multicast: allows to save bandwidth when clients are all in the same LAN, by sending packets once to a fixed multicast IP.&lt;/li&gt; &#xA; &lt;li&gt;TCP: the most versatile.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The default transport protocol is UDP. To change the transport protocol, you have to tune the configuration of your client of choice.&lt;/p&gt; &#xA;&lt;h4&gt;Encryption&lt;/h4&gt; &#xA;&lt;p&gt;Incoming and outgoing RTSP streams can be encrypted with TLS, obtaining the RTSPS protocol. A TLS certificate is needed and can be generated with OpenSSL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl genrsa -out server.key 2048&#xA;openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Edit &lt;code&gt;mediamtx.yml&lt;/code&gt; and set the &lt;code&gt;encryption&lt;/code&gt;, &lt;code&gt;serverKey&lt;/code&gt; and serverCert parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;rtspEncryption: optional&#xA;rtspServerKey: server.key&#xA;rtspServerCert: server.crt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Streams can be published and read with the &lt;code&gt;rtsps&lt;/code&gt; scheme and the &lt;code&gt;8322&lt;/code&gt; port:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtsps://localhost:8322/mystream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Corrupted frames&lt;/h4&gt; &#xA;&lt;p&gt;In some scenarios, when publishing or reading from the server with RTSP, frames can get corrupted. This can be caused by multiple reasons:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;the write queue of the server is too small and can&#39;t keep up with the stream throughput. A solution consists in increasing its size:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;writeQueueSize: 1024&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The stream throughput is too big and the stream can&#39;t be transmitted correctly with the UDP transport protocol. UDP is more performant, faster and more efficient than TCP, but doesn&#39;t have a retransmission mechanism, that is needed in case of streams that need a large bandwidth. A solution consists in switching to TCP:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;rtspTransports: [tcp]&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In case the source is a camera:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;paths:&#xA;  test:&#xA;    source: rtsp://..&#xA;    rtspTransport: tcp&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The stream throughput is too big to be handled by the network between server and readers. Upgrade the network or decrease the stream bitrate by re-encoding it.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;RTMP-specific features&lt;/h3&gt; &#xA;&lt;h4&gt;Encryption&lt;/h4&gt; &#xA;&lt;p&gt;RTMP connections can be encrypted with TLS, obtaining the RTMPS protocol. A TLS certificate is needed and can be generated with OpenSSL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;openssl genrsa -out server.key 2048&#xA;openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Edit mediamtx.yml and set the &lt;code&gt;rtmpEncryption&lt;/code&gt;, &lt;code&gt;rtmpServerKey&lt;/code&gt; and &lt;code&gt;rtmpServerCert&lt;/code&gt; parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;rtmpEncryption: optional&#xA;rtmpServerKey: server.key&#xA;rtmpServerCert: server.crt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Streams can be published and read with the rtmps scheme and the 1937 port:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtmps://localhost:1937/...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Be aware that RTMPS is currently unsupported by all major players. However, you can use a proxy like &lt;a href=&#34;https://www.stunnel.org&#34;&gt;stunnel&lt;/a&gt; or &lt;a href=&#34;https://nginx.org/&#34;&gt;nginx&lt;/a&gt; or a dedicated &lt;em&gt;MediaMTX&lt;/em&gt; instance to decrypt streams before reading them.&lt;/p&gt; &#xA;&lt;h2&gt;Compile from source&lt;/h2&gt; &#xA;&lt;h3&gt;Standard&lt;/h3&gt; &#xA;&lt;p&gt;Install git and Go ‚â• 1.24. Clone the repository, enter into the folder and start the building process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/bluenviron/mediamtx&#xA;cd mediamtx&#xA;go generate ./...&#xA;CGO_ENABLED=0 go build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The command will produce the &lt;code&gt;mediamtx&lt;/code&gt; binary.&lt;/p&gt; &#xA;&lt;h3&gt;OpenWrt&lt;/h3&gt; &#xA;&lt;p&gt;The compilation procedure is the same as the standard one. On the OpenWrt device, install git and Go:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;opkg update&#xA;opkg install golang git git-http&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Clone the repository, enter into the folder and start the building process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/bluenviron/mediamtx&#xA;cd mediamtx&#xA;go generate ./...&#xA;CGO_ENABLED=0 go build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The command will produce the &lt;code&gt;mediamtx&lt;/code&gt; binary.&lt;/p&gt; &#xA;&lt;p&gt;If the OpenWrt device doesn&#39;t have enough resources to compile, you can &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/#cross-compile&#34;&gt;cross compile&lt;/a&gt; from another machine.&lt;/p&gt; &#xA;&lt;h3&gt;Custom libcamera&lt;/h3&gt; &#xA;&lt;p&gt;If you need to use a custom or external libcamera when interacting with the Raspberry Pi Camera, you have to compile &lt;a href=&#34;https://github.com/bluenviron/mediamtx-rpicamera&#34;&gt;mediamtx-rpicamera&lt;/a&gt; before compiling the server. Instructions are present in the &lt;code&gt;mediamtx-rpicamera&lt;/code&gt; repository.&lt;/p&gt; &#xA;&lt;h3&gt;Cross compile&lt;/h3&gt; &#xA;&lt;p&gt;Cross compilation allows to build an executable for a target machine from another machine with different operating system or architecture. This is useful in case the target machine doesn&#39;t have enough resources for compilation or if you don&#39;t want to install the compilation dependencies on it.&lt;/p&gt; &#xA;&lt;p&gt;On the machine you want to use to compile, install git and Go ‚â• 1.24. Clone the repository, enter into the folder and start the building process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/bluenviron/mediamtx&#xA;cd mediamtx&#xA;go generate ./...&#xA;CGO_ENABLED=0 GOOS=my_os GOARCH=my_arch go build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replace &lt;code&gt;my_os&lt;/code&gt; and &lt;code&gt;my_arch&lt;/code&gt; with the operating system and architecture of your target machine. A list of all supported combinations can be obtained with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go tool dist list&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case of the &lt;code&gt;arm&lt;/code&gt; architecture, there&#39;s an additional flag available, &lt;code&gt;GOARM&lt;/code&gt;, that allows to set the ARM version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;CGO_ENABLED=0 GOOS=linux GOARCH=arm64 GOARM=7 go build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case of the &lt;code&gt;mips&lt;/code&gt; architecture, there&#39;s an additional flag available, &lt;code&gt;GOMIPS&lt;/code&gt;, that allows to set additional parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;CGO_ENABLED=0 GOOS=linux GOARCH=mips GOMIPS=softfloat go build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The command will produce the &lt;code&gt;mediamtx&lt;/code&gt; binary.&lt;/p&gt; &#xA;&lt;h3&gt;Compile for all supported platforms&lt;/h3&gt; &#xA;&lt;p&gt;Install Docker and launch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make binaries&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The command will produce tarballs in folder &lt;code&gt;binaries/&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Docker image&lt;/h3&gt; &#xA;&lt;p&gt;The official Docker image can be recompiled by following these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Build binaries for all supported platforms:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make binaries&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build the image by using one of the Dockerfiles inside the &lt;code&gt;docker/&lt;/code&gt; folder:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;docker build . -f docker/standard.Dockerfile -t my-mediamtx&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;A Dockerfile is available for each image variant (&lt;code&gt;standard.Dockerfile&lt;/code&gt;, &lt;code&gt;ffmpeg.Dockerfile&lt;/code&gt;, &lt;code&gt;rpi.Dockerfile&lt;/code&gt;, &lt;code&gt;ffmpeg-rpi.Dockerfile&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;All the code in this repository is released under the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/LICENSE&#34;&gt;MIT License&lt;/a&gt;. Compiled binaries include some third-party dependencies:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;all the Golang-based dependencies listed into the &lt;a href=&#34;https://raw.githubusercontent.com/bluenviron/mediamtx/main/go.mod&#34;&gt;go.mod file&lt;/a&gt;, which are all released under either the MIT license, BSD 3-Clause license or Apache License 2.0.&lt;/li&gt; &#xA; &lt;li&gt;hls.js, released under the &lt;a href=&#34;https://github.com/video-dev/hls.js/raw/master/LICENSE&#34;&gt;Apache License 2.0&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;mediamtx-rpicamera, which is released under the same license of &lt;em&gt;MediaMTX&lt;/em&gt; but includes some &lt;a href=&#34;https://github.com/bluenviron/mediamtx-rpicamera?tab=readme-ov-file#license&#34;&gt;third-party dependencies&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Specifications&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;name&lt;/th&gt; &#xA;   &lt;th&gt;area&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/bluenviron/gortsplib#specifications&#34;&gt;RTSP / RTP / RTCP specifications&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RTSP&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/bluenviron/gohlslib#specifications&#34;&gt;HLS specifications&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;HLS&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://veovera.org/docs/legacy/amf0-file-format-spec.pdf&#34;&gt;Action Message Format - AMF 0&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RTMP&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://veovera.org/docs/legacy/video-file-format-v10-1-spec.pdf&#34;&gt;FLV&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RTMP&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://veovera.org/docs/legacy/rtmp-v1-0-spec.pdf&#34;&gt;RTMP&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RTMP&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://veovera.org/docs/enhanced/enhanced-rtmp-v2.pdf&#34;&gt;Enhanced RTMP v2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;RTMP&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.w3.org/TR/webrtc/&#34;&gt;WebRTC: Real-Time Communication in Browsers&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WebRTC&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc8835&#34;&gt;RFC8835, Transports for WebRTC&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WebRTC&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc7742&#34;&gt;RFC7742, WebRTC Video Processing and Codec Requirements&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WebRTC&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc7874&#34;&gt;RFC7847, WebRTC Audio Codec and Processing Requirements&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WebRTC&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc7875&#34;&gt;RFC7875, Additional WebRTC Audio Codecs for Interoperability&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WebRTC&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/draft-ietf-avtcore-hevc-webrtc/&#34;&gt;H.265 Profile for WebRTC&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WebRTC&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/draft-ietf-wish-whip/&#34;&gt;WebRTC HTTP Ingestion Protocol (WHIP)&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WebRTC&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/draft-murillo-whep/&#34;&gt;WebRTC HTTP Egress Protocol (WHEP)&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;WebRTC&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://haivision.github.io/srt-rfc/draft-sharabayko-srt.html&#34;&gt;The SRT Protocol&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;SRT&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/bluenviron/mediacommon#specifications&#34;&gt;Codec specifications&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;codecs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/golang-standards/project-layout&#34;&gt;Golang project layout&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;project layout&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bluenviron/gortsplib&#34;&gt;gortsplib (RTSP library used internally)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bluenviron/gohlslib&#34;&gt;gohlslib (HLS library used internally)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bluenviron/mediacommon&#34;&gt;mediacommon (codecs and formats library used internally)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bluenviron/mediamtx-rpicamera&#34;&gt;mediamtx-rpicamera (Raspberry Pi Camera component)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/datarhei/gosrt&#34;&gt;datarhei/gosrt (SRT library used internally)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pion/webrtc&#34;&gt;pion/webrtc (WebRTC library used internally)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pion/sdp&#34;&gt;pion/sdp (SDP library used internally)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pion/rtp&#34;&gt;pion/rtp (RTP library used internally)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pion/rtcp&#34;&gt;pion/rtcp (RTCP library used internally)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/asticode/go-astits&#34;&gt;go-astits (MPEG-TS library used internally)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/abema/go-mp4&#34;&gt;go-mp4 (MP4 library used internally)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/video-dev/hls.js&#34;&gt;hls.js (browser-side HLS library used internally)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>