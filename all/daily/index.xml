<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-02-21T01:28:32Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>treetrum/amazon-kindle-bulk-downloader</title>
    <updated>2025-02-21T01:28:32Z</updated>
    <id>tag:github.com,2025-02-21:/treetrum/amazon-kindle-bulk-downloader</id>
    <link href="https://github.com/treetrum/amazon-kindle-bulk-downloader" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Designed for downloading your Kindle eBooks in a more automated fashion than is typically permitted, this tool allows you to create backup copies of the books you&#39;ve already purchased.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Amazon Kindle eBook Bulk Downloader&lt;/h1&gt; &#xA;&lt;p&gt;Designed for downloading your Kindle eBooks in a more automated fashion than is typically permitted, this tool allows you to create backup copies of the books you&#39;ve already purchased.&lt;/p&gt; &#xA;&lt;h2&gt;Pre-Requisites&lt;/h2&gt; &#xA;&lt;p&gt;The most important pre-requisite is that you have a physical e-ink Kindle or an Amazon Fire Tablet linked to your Amazon account. This is a requirement from Amazon&#39;s side and this tool does not offer a way to bypass this.&lt;/p&gt; &#xA;&lt;p&gt;An important distinction is that the physical Kindle you have linked cannot be one of the latest 2024 models. For whatever reason, Amazon has decided to block the ability to download books from these devices. This tool will not work with these devices.&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to check if this tool will work for you is to log into your Amazon account manually and navigate to &lt;code&gt;Manage Your Content and Devices&lt;/code&gt;. From there when clicking on &lt;code&gt;More Actions &amp;gt; Download &amp;amp; Transfer via USB&lt;/code&gt; on a book, you should see your Kindle or Fire Tablet device listed. If you see the message &lt;code&gt;You do not have any compatible devices registered for this content&lt;/code&gt; then it means you:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;either don&#39;t have a Kindle or Fire Tablet device linked to your account, OR&lt;/li&gt; &#xA; &lt;li&gt;have a Kindle or Fire Tablet device that is not compatible with this tool&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you are able to proceed to the next screen and download the book, then this tool should work for you.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;Clone this repository onto your machine, then install dependencies with bun. You can install bun using the instructions found &lt;a href=&#34;https://bun.sh/docs/installation&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bun install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running&lt;/h2&gt; &#xA;&lt;p&gt;Note that amazon credentials will need to be provided. Currently this script expects them to be in the following ENV variables:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Variable&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Required&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;AMAZON_USER&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Account username&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;PASSWORD&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Account password&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;OTP&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;6 digit one-time password&lt;/td&gt; &#xA;   &lt;td&gt;If 2 factor auth is enabled&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;I recommend using the env template found in the root of the repo to create and .env file containing your specific vars.&lt;/p&gt; &#xA;&lt;h3&gt;CLI Arguments&lt;/h3&gt; &#xA;&lt;p&gt;The following CLI arguments are made available to customise the downloader to your needs&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Argument&lt;/th&gt; &#xA;   &lt;th&gt;Default Value&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--baseUrl&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.amazon.com.au&#34;&gt;https://www.amazon.com.au&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Which Amazon base URL to use. Note, this MUST include &lt;a href=&#34;http://www&#34;&gt;www&lt;/a&gt;. in order to work properly&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--totalDownloads&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;9999&lt;/td&gt; &#xA;   &lt;td&gt;Total number of downloads to do&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--maxConcurrency&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;10&lt;/td&gt; &#xA;   &lt;td&gt;Maximum number of concurrent downloads&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--startFromOffset&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;Index offset to begin downloading from. Allows resuming of previous failed attempts. Note this argument has &lt;a href=&#34;https://github.com/treetrum/amazon-kindle-bulk-downloader/issues/162#issuecomment-2669569874&#34;&gt;known issues&lt;/a&gt; and should probably be avoided for now.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;--manualAuth&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;Allows user to manually login using the pupeteer UI instead of automatically using ENV vars. Use when auto login is not working.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Running&lt;/h3&gt; &#xA;&lt;p&gt;You can run this tool using the following command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bun run start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Command line arguments can be provided as follows&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bun run start --baseUrl &#34;https://www.amazon.com.au&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re having any issues with the tool, please first ensure that you have the latest version of the code by running &lt;code&gt;git pull&lt;/code&gt; or redownloading the repository and then running &lt;code&gt;bun install&lt;/code&gt; from the root of the repository.&lt;/p&gt; &#xA;&lt;p&gt;In addition, please ensure that you have followed the &lt;a href=&#34;https://github.com/treetrum/amazon-kindle-bulk-downloader?tab=readme-ov-file#pre-requisites&#34;&gt;pre-requisites&lt;/a&gt; section carefully and can download a book manually through the website.&lt;/p&gt; &#xA;&lt;h3&gt;Common Errors&lt;/h3&gt; &#xA;&lt;h4&gt;Error: Found 0 books in total&lt;/h4&gt; &#xA;&lt;p&gt;This error &lt;em&gt;may&lt;/em&gt; indicate that you are authenticated to the wrong Amazon account for your locale.&lt;/p&gt; &#xA;&lt;p&gt;You need to ensure that you provide the base URL for the Amazon region where your purchases were made. For example, if you are in Australia, you should use &lt;code&gt;https://www.amazon.com.au&lt;/code&gt;, if you are in the USA, you should use &lt;code&gt;https://www.amazon.com&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;This base URL should be provided as a CLI argument when running the tool. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# For USA based accounts&#xA;bun run start --baseUrl &#34;https://www.amazon.com&#34;&#xA;&#xA;# For Australia based accounts&#xA;bun run start --baseUrl &#34;https://www.amazon.com.au&#34;&#xA;&#xA;# ... etc.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>mastra-ai/mastra</title>
    <updated>2025-02-21T01:28:32Z</updated>
    <id>tag:github.com,2025-02-21:/mastra-ai/mastra</id>
    <link href="https://github.com/mastra-ai/mastra" rel="alternate"></link>
    <summary type="html">&lt;p&gt;the TypeScript AI agent framework&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mastra &lt;img align=&#34;cener&#34; alt=&#34;Project Status: Beta&#34; src=&#34;https://img.shields.io/badge/beta-status-blue&#34;&gt; &lt;img align=&#34;cener&#34; alt=&#34;Project Status: Alpha&#34; src=&#34;https://img.shields.io/badge/Y%20Combinator-W25-orange?style=flat-square&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Mastra is an opinionated Typescript framework that helps you build AI applications and features quickly. It gives you the set of primitives you need: workflows, agents, RAG, integrations and evals. You can run Mastra on your local machine, or deploy to a serverless cloud.&lt;/p&gt; &#xA;&lt;p&gt;The main Mastra features are:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Features&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;LLM Models&lt;/td&gt; &#xA;   &lt;td&gt;Mastra uses the &lt;a href=&#34;https://sdk.vercel.ai/docs/introduction&#34;&gt;Vercel AI SDK&lt;/a&gt; for model routing, providing a unified interface to interact with any LLM provider including OpenAI, Anthropic, and Google Gemini. You can choose the specific model and provider, and decide whether to stream the response.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://mastra.ai/docs/agents/00-overview&#34;&gt;Agents&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Agents are systems where the language model chooses a sequence of actions. In Mastra, agents provide LLM models with tools, workflows, and synced data. Agents can call your own functions or APIs of third-party integrations and access knowledge bases you build.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://mastra.ai/docs/agents/02-adding-tools&#34;&gt;Tools&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Tools are typed functions that can be executed by agents or workflows, with built-in integration access and parameter validation. Each tool has a schema that defines its inputs, an executor function that implements its logic, and access to configured integrations.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://mastra.ai/docs/workflows/00-overview&#34;&gt;Workflows&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Workflows are durable graph-based state machines. They have loops, branching, wait for human input, embed other workflows, do error handling, retries, parsing and so on. They can be built in code or with a visual editor. Each step in a workflow has built-in OpenTelemetry tracing.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://mastra.ai/docs/rag/overview&#34;&gt;RAG&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Retrieval-augemented generation (RAG) lets you construct a knowledge base for agents. RAG is an ETL pipeline with specific querying techniques, including chunking, embedding, and vector search.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://mastra.ai/docs/local-dev/integrations&#34;&gt;Integrations&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;In Mastra, integrations are auto-generated, type-safe API clients for third-party services that can be used as tools for agents or steps in workflows.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://mastra.ai/docs/08-running-evals&#34;&gt;Evals&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Evals are automated tests that evaluate LLM outputs using model-graded, rule-based, and statistical methods. Each eval returns a normalized score between 0-1 that can be logged and compared. Evals can be customized with your own prompts and scoring functions.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Node.js (v20.0+)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Get an LLM provider API key&lt;/h2&gt; &#xA;&lt;p&gt;If you don&#39;t have an API key for an LLM provider, you can get one from the following services:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://platform.openai.com/&#34;&gt;OpenAI&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://console.anthropic.com/settings/keys&#34;&gt;Anthropic&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ai.google.dev/gemini-api/docs&#34;&gt;Google Gemini&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you don&#39;t have an account with these providers, you can sign up and get an API key. Anthropic require a credit card to get an API key. Some OpenAI models and Gemini do not and have a generous free tier for its API.&lt;/p&gt; &#xA;&lt;h2&gt;Create a new project&lt;/h2&gt; &#xA;&lt;p&gt;The easiest way to get started with Mastra is by using &lt;code&gt;create-mastra&lt;/code&gt;. This CLI tool enables you to quickly start building a new Mastra application, with everything set up for you.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npx create-mastra@latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run the script&lt;/h3&gt; &#xA;&lt;p&gt;Finally, run &lt;code&gt;mastra dev&lt;/code&gt; to open the Mastra playground.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm run dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;re using Anthropic, set the &lt;code&gt;ANTHROPIC_API_KEY&lt;/code&gt;. If you&#39;re using Gemini, set the &lt;code&gt;GOOGLE_GENERATIVE_AI_API_KEY&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Looking to contribute? All types of help are appreciated, from coding to testing and feature specification.&lt;/p&gt; &#xA;&lt;p&gt;If you are a developer and would like to contribute with code, please open an issue to discuss before opening a Pull Request.&lt;/p&gt; &#xA;&lt;p&gt;Information about the project setup can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/mastra-ai/mastra/main/DEVELOPMENT.md&#34;&gt;development documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;We have an &lt;a href=&#34;https://discord.gg/BTYqqHKUrf&#34;&gt;open community Discord&lt;/a&gt;. Come and say hello and let us know if you have any questions or need any help getting things running.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also super helpful if you leave the project a star here at the &lt;a href=&#34;https://github.com/mastra-ai/mastra&#34;&gt;top of the page&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>NVIDIA/cutlass</title>
    <updated>2025-02-21T01:28:32Z</updated>
    <id>tag:github.com,2025-02-21:/NVIDIA/cutlass</id>
    <link href="https://github.com/NVIDIA/cutlass" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CUDA Templates for Linear Algebra Subroutines&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/images/gemm-hierarchy-with-epilogue-no-labels.png&#34; alt=&#34;ALT&#34; title=&#34;Complete CUDA GEMM decomposition&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;CUTLASS 3.8.0&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;CUTLASS 3.8.0 - January 2025&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS is a collection of CUDA C++ template abstractions for implementing high-performance matrix-matrix multiplication (GEMM) and related computations at all levels and scales within CUDA. It incorporates strategies for hierarchical decomposition and data movement similar to those used to implement cuBLAS and cuDNN. CUTLASS decomposes these &#34;moving parts&#34; into reusable, modular software components abstracted by C++ template classes. Primitives for different levels of a conceptual parallelization hierarchy can be specialized and tuned via custom tiling sizes, data types, and other algorithmic policy. The resulting flexibility simplifies their use as building blocks within custom kernels and applications.&lt;/p&gt; &#xA;&lt;p&gt;To support a wide variety of applications, CUTLASS provides extensive support for mixed-precision computations, providing specialized data-movement and multiply-accumulate abstractions for FP64, FP32, TF32, FP16, BF16, &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/27_ampere_3xtf32_fast_accurate_tensorop_gemm&#34;&gt;FP32 emulation via tensor core instruction&lt;/a&gt;, 8b floating point types (e5m2 and e4m3), block scaled data types (NVIDIA NVFP4 and OCP standard MXFP4, MXFP6, MXFP8), narrow integer types (4 and 8b signed and unsigned integers), and binary 1b data types (where architectures allow for the native support of such data types). CUTLASS demonstrates optimal matrix multiply operations targeting the programmable, high-throughput &lt;em&gt;Tensor Cores&lt;/em&gt; implemented by NVIDIA&#39;s Volta, Turing, Ampere, Ada, Hopper, and Blackwell architectures.&lt;/p&gt; &#xA;&lt;p&gt;In addition to GEMMs, CUTLASS implements high-performance convolution via the implicit GEMM algorithm. Implicit GEMM is the formulation of a convolution operation as a GEMM thereby taking advantage of CUTLASS&#39;s modular GEMM pipeline. This allows CUTLASS to build convolutions by reusing highly-optimized GEMM components.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md&#34;&gt;Quick Start Guide&lt;/a&gt; to get started quickly.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/functionality.md&#34;&gt;functionality docs&lt;/a&gt; for a more comprehensive list of kernel level features, data types, instructions, and minimum supported by CUTLASS on each GPU architecture.&lt;/p&gt; &#xA;&lt;h1&gt;What&#39;s New in CUTLASS 3.8&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS 3.8 is the first release that supports the NVIDIA Blackwell SM100 architecture. For a background on Blackwell&#39;s new features, please consult the PTX documentation for CUDA 12.8.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for new CuTe building blocks specifically for Blackwell SM100 architecture: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cute/atom/mma_traits_sm100.hpp&#34;&gt;5th generation Blackwell Tensor Core instructions (TCGen05)&lt;/a&gt; via CuTe MMA atoms.&lt;/li&gt; &#xA;   &lt;li&gt;Extensions to &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cute/atom/copy_traits_sm100_tma.hpp&#34;&gt;Tensor Memory Accelerator&lt;/a&gt; via CuTe Copy atoms.&lt;/li&gt; &#xA;   &lt;li&gt;Exposure of Blackwell&#39;s new tensor memory (note: distinct from TMA) as &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cute/pointer.hpp&#34;&gt;&lt;code&gt;tmem&lt;/code&gt;&lt;/a&gt; across CuTe as a first class data locale.&lt;/li&gt; &#xA;   &lt;li&gt;Exposure of &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cute/atom/copy_traits_sm100.hpp&#34;&gt;&lt;code&gt;tmem-&amp;gt;rmem&lt;/code&gt;, &lt;code&gt;rmem-&amp;gt;tmem&lt;/code&gt; and &lt;code&gt;smem-&amp;gt;tmem data movement instructions&lt;/code&gt;&lt;/a&gt; as copy atoms in CuTe.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cute/atom/copy_traits_sm100.hpp&#34;&gt;&lt;code&gt;make_tmem_copy()&lt;/code&gt;&lt;/a&gt; utility method to ease creation of tiled copies for tmem copy atoms.&lt;/li&gt; &#xA;   &lt;li&gt;Support for &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cute/atom/copy_traits_sm100.hpp&#34;&gt;new variants of LDSM on Blackwell&lt;/a&gt; via CuTe Copy atoms.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Support for new CUTLASS building blocks specifically for Blackwell SM100 architecture: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Various narrow precision &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/exmy_base.h&#34;&gt;FP4, FP6, and FP8&lt;/a&gt; formats as well as their &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/float_subbyte.h&#34;&gt;block-scaled variants NVFP4, MXFP4, MXFP6, and MXFP8&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/pipeline/sm100_pipeline.hpp&#34;&gt;Pipelines that implement Blackwell specific synchronization&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/cluster_launch.hpp&#34;&gt;Cluster launch control API supporting preferred and fallback cluster shapes&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Data types including NVFP4, MXFP4, MXFP6, and MXFP8 and all their supported element and scale factor types.&lt;/li&gt; &#xA;   &lt;li&gt;Tile schedulers using &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/blackwell_cluster_launch_control.md&#34;&gt;Blackwell&#39;s Cluster Launch Control (CLC) feature&lt;/a&gt; to implement dynamic persistence scheduling for &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/gemm/kernel/sm100_tile_scheduler.hpp&#34;&gt;GEMMs&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/gemm/kernel/sm100_tile_scheduler_stream_k.hpp&#34;&gt;stream-K&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Extensions to testbeds and reference check code for unit tests and CUTLASS profiler.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Full support for Blackwell SM100 kernels in CUTLASS 3.x API: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/gemm/kernel/sm100_gemm_tma_warpspecialized.hpp&#34;&gt;Blackwell specific kernel layers&lt;/a&gt; that &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Implement a new warp-specialization recipe tuned specifically for Blackwell SM100 architecture.&lt;/li&gt; &#xA;     &lt;li&gt;Leverage all the new features such as CLC based tile scheduling, preferred cluster, and TMEM based double buffering of accumulators.&lt;/li&gt; &#xA;     &lt;li&gt;Support stream-K load balancing for all kernel types everywhere via composable scheduler support.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Blackwell collective mainloops that target the TCGen05 MMA instructions (both SS and TS) for &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/gemm/collective/sm100_mma_warpspecialized.hpp&#34;&gt;Non-block scaled data types without support for pointer array and grouped GEMM with TMA&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/gemm/collective/sm100_mma_array_warpspecialized.hpp&#34;&gt;Non-block scaled data types with support for pointer array and grouped GEMM with TMA&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/gemm/collective/sm100_blockscaled_mma_warpspecialized.hpp&#34;&gt;Block scaled data types without support for pointer array and grouped GEMM with TMA&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/gemm/collective/sm100_blockscaled_mma_array_warpspecialized.hpp&#34;&gt;Block scaled data types with support for pointer array and grouped GEMM with TMA&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Blackwell &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/conv/collective/sm100_implicit_gemm_umma_warpspecialized.hpp&#34;&gt;collective mainloop for convolution kernels&lt;/a&gt; supporting non-block scaled data types for fprop, dgrad, and wgrad.&lt;/li&gt; &#xA;   &lt;li&gt;New &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/gemm/dispatch_policy.hpp&#34;&gt;GEMM&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/conv/dispatch_policy.hpp&#34;&gt;convolution&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/epilogue/dispatch_policy.hpp&#34;&gt;epilogue&lt;/a&gt; dispatch policies for collectives, kernel layers, and builders.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/epilogue/collective/sm100_epilogue_tma_warpspecialized.hpp&#34;&gt;Blackwell epilogue that supports loading accumulators from &lt;code&gt;tmem&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;&#34;&gt;full set of EVT fusions&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;CUTLASS library and profiler integration for block scaled data types for kernel emission, profiling, and verification. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Support for preferred and fallback cluster shapes via profiler command line arguments parsing to set dynamic cluster shapes.&lt;/li&gt; &#xA;   &lt;li&gt;Support for dynamic datatypes by parsing profiler via profiler command line arguments parsing to set dynamic datatype setting in TCGen05 MMA instruction descriptors.&lt;/li&gt; &#xA;   &lt;li&gt;Support for mixed input GEMM kernels on Hopper in the profiler.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;New CUTLASS profiler flag &lt;code&gt;use-cuda-graphs&lt;/code&gt; to reduce overheads when benchmarking launch-bound kernels.&lt;/li&gt; &#xA; &lt;li&gt;A new 3.x version of grouped GEMM to the CUTLASS library and generates kernels for Hopper and Blackwell. Now grouped GEMM support is enabled in the CUTLASS profiler (&lt;code&gt;./cutlass_profiler --operation=GroupedGemm --help&lt;/code&gt; for details).&lt;/li&gt; &#xA; &lt;li&gt;Set of examples that demonstrate the usage of the 3.x API for targeting Blackwell SM100 architecture: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/70_blackwell_gemm/&#34;&gt;Basic FP16 and FP8 GEMMs with minimal changes from Hopper examples&lt;/a&gt;, demonstrating ease of migration for off the shelf kernels using the 3.x collective builder API.&lt;/li&gt; &#xA;   &lt;li&gt;GEMM with &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/71_blackwell_gemm_with_collective_builder/71_blackwell_gemm_with_collective_builder.cu&#34;&gt;opt-in collective builder schedules showcasing available recipes&lt;/a&gt; for Blackwell.&lt;/li&gt; &#xA;   &lt;li&gt;Block scaled data type GEMMs targeting Blackwell&#39;s native block scaled Tensor Cores: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/72_blackwell_narrow_precision_gemm/72a_blackwell_nvfp4_bf16_gemm.cu&#34;&gt;NVFP4 inputs with BF16 output&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/72_blackwell_narrow_precision_gemm/72b_blackwell_nvfp4_nvfp4_gemm.cu&#34;&gt;NVFP4 inputs with NVFP4 output&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/72_blackwell_narrow_precision_gemm/72c_blackwell_mixed_mxfp8_bf16_gemm.cu&#34;&gt;Mixed MXFP8 and MXFP6 inputs with BF16 output&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;GEMM example demonstrating &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/73_blackwell_gemm_preferred_cluster/blackwell_gemm_preferred_cluster.cu&#34;&gt;Blackwell&#39;s new preferred cluster support via dynamic cluster shapes&lt;/a&gt; for increased occupancy.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/74_blackwell_gemm_streamk/blackwell_gemm_streamk.cu&#34;&gt;GEMM with CLC based StreamK scheduler for load balancing&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Grouped GEMM for &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/75_blackwell_grouped_gemm/75_blackwell_grouped_gemm.cu&#34;&gt;vanilla FP8 data inputs&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/75_blackwell_grouped_gemm/75_blackwell_grouped_gemm_block_scaled.cu&#34;&gt;NVFP4 block scaled inputs&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Convolution kernels for &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/76_blackwell_conv/76_blackwell_conv_fprop.cu&#34;&gt;fprop&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/76_blackwell_conv/76_blackwell_conv_dgrad.cu&#34;&gt;dgrad&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/76_blackwell_conv/76_blackwell_conv_wgrad.cu&#34;&gt;wgrad&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/77_blackwell_fmha/77_blackwell_fmha.cu&#34;&gt;Fused multi-head attention fprop kernel&lt;/a&gt; supporting fp16/bf16/fp8 data types across head dims of 32,64, and 128.&lt;/li&gt; &#xA;   &lt;li&gt;A new BF16x9 GEMM &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/78_blackwell_emulated_bf16x9_gemm/78_blackwell_emulated_bf16x9_gemm.cu&#34;&gt;kernel&lt;/a&gt; that emulates FP32 GEMM (SGEMM) using BF16 operations.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Set of examples that demonstrate the usage of the 3.x API for targeting Hopper architecture: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A set of new &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/69_hopper_mixed_dtype_grouped_gemm/&#34;&gt;Hopper grouped GEMM kernels&lt;/a&gt; that support mixed A and B datatypes.&lt;/li&gt; &#xA;   &lt;li&gt;A new &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/67_hopper_fp8_warp_specialized_gemm_with_blockwise_scaling/67_hopper_fp8_warp_specialized_gemm_with_groupwise_scaling.cu&#34;&gt;Hopper FP8 GEMM with groupwise scaling&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Documentation updates: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md#instantiating-a-blackwell-gemm-kernel&#34;&gt;Quickstart - instantiating a Blackwell block-scaled GEMM&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Detailed &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/blackwell_functionality.md&#34;&gt;Blackwell block-scaled GEMM functionality documentation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;A new &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/functionality.md&#34;&gt;functionality documentation&lt;/a&gt; specifically for 3.x API comprehensively documenting all supported kernel types, data types, kernel features, minimum CUDA tookit support etc for 3.x supported architectures.&lt;/li&gt; &#xA;   &lt;li&gt;Updates to &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/README.md#compatibility&#34;&gt;compatibility&lt;/a&gt; section regarding supported compilers, operating systems, CUDA Toolkits, Hardware Architectures, and &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/README.md#Target-Architecture&#34;&gt;Target Architecture&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: CUTLASS 3.x builds are known to be down on Windows platforms for all CUDA toolkits. CUTLASS team is working on a fix.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt; for details of all past releases and updates.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Performance&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS primitives are very efficient. When used to construct device-wide GEMM kernels, they exhibit nearly optimal utilization of peak theoretical throughput. The figure below shows CUTLASS 3.8&#39;s performance as a % of theoretical peak utilization on various input and output data types when run on NVIDIA Blackwell SM100 architecture GPU.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/images/cutlass-3.8-blackwell-gemm-peak-performance.svg?sanitize=true&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The two figures below show the continual CUTLASS performance improvements on an &lt;a href=&#34;https://www.nvidia.com/en-us/data-center/h100/&#34;&gt;NVIDIA H100&lt;/a&gt; (NVIDIA Hopper architecture) since CUTLASS 3.1. CUTLASS 3.5.1 was compiled with the &lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;CUDA 12.5u1 Toolkit&lt;/a&gt;. Tensor Core operations are implemented using CUDA&#39;s &lt;a href=&#34;https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-instructions-mma&#34;&gt;mma&lt;/a&gt; and &lt;a href=&#34;https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#asynchronous-warpgroup-level-matrix-instructions&#34;&gt;wgmma&lt;/a&gt; instructions.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/images/cutlass-3.5.1-gemm-peak-performance.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/images/cutlass-3.5.1-gemm-peak-performance-fp8.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;CuTe&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS 3.0 introduced a new core library, CuTe, to describe and manipulate tensors of threads and data. CuTe is a collection of C++ CUDA template abstractions for defining and operating on hierarchically multidimensional layouts of threads and data. CuTe provides &lt;code&gt;Layout&lt;/code&gt; and &lt;code&gt;Tensor&lt;/code&gt; objects that compactly package the type, shape, memory space, and layout of data, while performing the complicated indexing for the user. This lets programmers focus on the logical descriptions of their algorithms while CuTe does the mechanical bookkeeping for them. With these tools, we can quickly design, implement, and modify all dense linear algebra operations.&lt;/p&gt; &#xA;&lt;p&gt;The core abstractions of CuTe are hierarchically multidimensional layouts which can be composed with data arrays to represent tensors. The representation of layouts is powerful enough to represent nearly everything we need to implement efficient dense linear algebra. Layouts can also be combined and manipulated via functional composition, on which we build a large set of common operations such as tiling and partitioning.&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS 3.0 and beyond adopts CuTe throughout the GEMM hierarchy in its templates. This greatly simplifies the design and improves code composability and readability. More documentation specific to CuTe can be found in its &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/cute/00_quickstart.md&#34;&gt;dedicated documentation directory&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Compatibility&lt;/h1&gt; &#xA;&lt;p&gt;Minimum requirements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Architecture: Volta (compute capability 7.0)&lt;/li&gt; &#xA; &lt;li&gt;Compiler: Must support at least C++17&lt;/li&gt; &#xA; &lt;li&gt;CUDA Toolkit version: 11.4&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;CUTLASS requires a C++17 host compiler and performs best when built with the &lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;&lt;strong&gt;CUDA 12.8 Toolkit&lt;/strong&gt;&lt;/a&gt;. It is also compatible with CUDA 11.4, CUDA 11.5, CUDA 11.6, CUDA 11.7, CUDA 11.8, and all other CUDA 12.x versions.&lt;/p&gt; &#xA;&lt;h2&gt;Operating Systems&lt;/h2&gt; &#xA;&lt;p&gt;We have tested the following environments.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Operating System&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Compiler&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Ubuntu 18.04&lt;/td&gt; &#xA;   &lt;td&gt;GCC 7.5.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Ubuntu 20.04&lt;/td&gt; &#xA;   &lt;td&gt;GCC 10.3.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Ubuntu 22.04&lt;/td&gt; &#xA;   &lt;td&gt;GCC 11.2.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Note: GCC 8.5.0 has known regressions regarding fold expressions and overloaded operators. Using GCC 7.5.0 or (preferred) GCC &amp;gt;= 9 is recommended.&lt;/p&gt; &#xA;&lt;p&gt;Note: CUTLASS 3.x builds are known to be down on Windows platforms for all CUDA toolkits. CUTLASS team is working on a fix.&lt;/p&gt; &#xA;&lt;h2&gt;Hardware&lt;/h2&gt; &#xA;&lt;p&gt;CUTLASS runs successfully on the following NVIDIA GPUs, and it is expected to be efficient on Volta, Turing, Ampere, Ada, and Hopper architecture based NVIDIA GPUs.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;GPU&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;CUDA Compute Capability&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Minimum CUDA Toolkit Required by CUTLASS-3&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA V100 Tensor Core GPU&lt;/td&gt; &#xA;   &lt;td&gt;7.0&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA TitanV&lt;/td&gt; &#xA;   &lt;td&gt;7.0&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA GeForce RTX 20x0 series&lt;/td&gt; &#xA;   &lt;td&gt;7.5&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA T4&lt;/td&gt; &#xA;   &lt;td&gt;7.5&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA A100 Tensor Core GPU&lt;/td&gt; &#xA;   &lt;td&gt;8.0&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA A10&lt;/td&gt; &#xA;   &lt;td&gt;8.6&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA GeForce RTX 30x0 series&lt;/td&gt; &#xA;   &lt;td&gt;8.6&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA GeForce RTX 40x0 series&lt;/td&gt; &#xA;   &lt;td&gt;8.9&lt;/td&gt; &#xA;   &lt;td&gt;11.8&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA L40&lt;/td&gt; &#xA;   &lt;td&gt;8.9&lt;/td&gt; &#xA;   &lt;td&gt;11.8&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA H100 Tensor Core GPU&lt;/td&gt; &#xA;   &lt;td&gt;9.0&lt;/td&gt; &#xA;   &lt;td&gt;11.8&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA H200 Tensor Core GPU&lt;/td&gt; &#xA;   &lt;td&gt;9.0&lt;/td&gt; &#xA;   &lt;td&gt;11.8&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA B200 Tensor Core GPU&lt;/td&gt; &#xA;   &lt;td&gt;10.0&lt;/td&gt; &#xA;   &lt;td&gt;12.8&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Target Architecture&lt;/h2&gt; &#xA;&lt;p&gt;In general, PTX code generated for one target architecture can be run on future architectures (i.e., it is forward compatible). However, CUDA 12.0 introduced the concept of &#34;architecture-accelerated features&#34; whose PTX does not have forward compatibility guarantees. Several Hopper and Blackwell PTX instructions fall under this category of architecture-accelerated features, and thus require a &lt;code&gt;sm_90a&lt;/code&gt; or &lt;code&gt;sm100a&lt;/code&gt; target architecture (note the &#34;a&#34; appended). For more details on this and other architecture-accelerated instructions, please refer to the &lt;a href=&#34;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#feature-availability&#34;&gt;CUDA Documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The target architecture information is passed on to CUTLASS via the cmake flag &lt;code&gt;CUTLASS_NVCC_ARCHS&lt;/code&gt;. In order to maximize performance on Hopper GH100, users are required to build CUTLASS with &lt;code&gt;90a&lt;/code&gt; as the target architecture. If a user accidentally builds a kernel which uses SM90a features (e.g. Hopper Tensor Core Instructions), using the SM90 target (note the lack of &#34;a&#34;), with either CUDA Toolkit 12 or 11.8, the kernel is expected to fail with a runtime error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake .. -DCUTLASS_NVCC_ARCHS=&#34;90a&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake .. -DCUTLASS_NVCC_ARCHS=&#34;100a&#34; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: The NVIDIA Blackwell SM100 architecture used in the datacenter products has a different compute capability than the one underpinning NVIDIA Blackwell GeForce RTX 50 series GPUs. As a result, kernels compiled for Blackwell SM100 architecture with arch conditional features (using &lt;code&gt;sm100a&lt;/code&gt;) are not compatible with RTX 50 series GPUs.&lt;/p&gt; &#xA;&lt;p&gt;Please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/functionality.md&#34;&gt;functionality documentation&lt;/a&gt; for details on which kernels require which target architectures.&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is described in the following documents and the accompanying &lt;a href=&#34;https://nvidia.github.io/cutlass&#34;&gt;Doxygen documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md&#34;&gt;Quick Start Guide&lt;/a&gt; - basics of building and running CUTLASS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/functionality.md&#34;&gt;Functionality&lt;/a&gt; - summarizes functionality available in CUTLASS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/efficient_gemm.md&#34;&gt;Efficient GEMM in CUDA&lt;/a&gt; - describes how GEMM kernels may be implemented efficiently in CUDA&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/cutlass_3x_design.md&#34;&gt;CUTLASS 3.x Design&lt;/a&gt; - describes the CUTLASS 3.x design, its benefits, and how CuTe enables us to write much more composable components&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/gemm_api_3x.md&#34;&gt;GEMM API 3.x&lt;/a&gt; - describes the CUTLASS 3.x GEMM model and C++ template concepts&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/gemm_api.md&#34;&gt;GEMM API 2.x&lt;/a&gt; - describes the CUTLASS 2.x GEMM model and C++ template concepts&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/implicit_gemm_convolution.md&#34;&gt;Implicit GEMM Convolution&lt;/a&gt; - describes 2-D and 3-D convolution in CUTLASS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/code_organization.md&#34;&gt;Code Organization&lt;/a&gt; - describes the organization and contents of the CUTLASS project&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/terminology.md&#34;&gt;Terminology&lt;/a&gt; - describes terms used in the code&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/programming_guidelines.md&#34;&gt;Programming Guidelines&lt;/a&gt; - guidelines for writing efficient modern CUDA C++&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/fundamental_types.md&#34;&gt;Fundamental types&lt;/a&gt; - describes basic C++ classes used in CUTLASS to represent numeric quantities and arrays&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/layout.md&#34;&gt;Layouts&lt;/a&gt; - describes layouts of matrices and tensors in memory&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/tile_iterator_concept.md&#34;&gt;Tile Iterators&lt;/a&gt; - describes C++ concepts for iterating over tiles of matrices in memory&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/profiler.md&#34;&gt;CUTLASS Profiler&lt;/a&gt; - command-line driven profiling application&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/utilities.md&#34;&gt;CUTLASS Utilities&lt;/a&gt; - additional templates used to facilitate rapid development&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/dependent_kernel_launch.md&#34;&gt;Dependent kernel launch&lt;/a&gt; - describes a new feature in Hopper which allows overlapping dependent kernels in the same stream, and how it is used in CUTLASS.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Resources&lt;/h1&gt; &#xA;&lt;p&gt;We have also described the structure of an efficient GEMM in our talk at the &lt;a href=&#34;http://on-demand.gputechconf.com/gtc/2018/presentation/s8854-cutlass-software-primitives-for-dense-linear-algebra-at-all-levels-and-scales-within-cuda.pdf&#34;&gt;GPU Technology Conference 2018&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/on-demand/session/gtcsiliconvalley2018-s8854/&#34;&gt;CUTLASS: Software Primitives for Dense Linear Algebra at All Levels and Scales within CUDA&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/on-demand/session/gtcsj20-s21745/&#34;&gt;Developing CUDA Kernels to Push Tensor Cores to the Absolute Limit on NVIDIA A100&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/on-demand/session/gtcspring21-s31883/&#34;&gt;Accelerating Convolution with Tensor Cores in CUTLASS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/on-demand/session/gtcspring22-s41996/&#34;&gt;Accelerating Backward Data Gradient by Increasing Tensor Core Utilization in CUTLASS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/on-demand/session/gtcfall22-a41131/&#34;&gt;CUTLASS: Python API, Enhancements, and NVIDIA Hopper&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Building CUTLASS&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is a header-only template library and does not need to be built to be used by other projects. Client applications should target CUTLASS&#39;s &lt;code&gt;include/&lt;/code&gt; directory in their include paths.&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS unit tests, examples, and utilities can be build with CMake. The minimum version of CMake is given in the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md&#34;&gt;Quickstart guide&lt;/a&gt;. Make sure the &lt;code&gt;CUDACXX&lt;/code&gt; environment variable points to NVCC in the CUDA Toolkit installed on your system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export CUDACXX=${CUDA_INSTALL_PATH}/bin/nvcc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a build directory within the CUTLASS project, then run CMake. By default CUTLASS will build kernels for CUDA architecture versions 5.0, 6.0, 6.1, 7.0, 7.5, 8.0, 8.6, 8.9, and 9.0. To reduce compile time you can specify the architectures to build CUTLASS for by changing the CMake configuration setting &lt;code&gt;CUTLASS_NVCC_ARCHS&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir build &amp;amp;&amp;amp; cd build&#xA;&#xA;$ cmake .. -DCUTLASS_NVCC_ARCHS=80               # compiles for NVIDIA&#39;s Ampere Architecture&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From the &lt;code&gt;build/&lt;/code&gt; directory, compile and run the CUTLASS unit tests by building the target &lt;code&gt;test_unit&lt;/code&gt; with make.&lt;/p&gt; &#xA;&lt;p&gt;The unit tests are organized as several binaries mirroring the top-level namespaces of CUTLASS, and they may be executed in parallel via make&#39;s &lt;code&gt;-j&lt;/code&gt; command line argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make test_unit -j&#xA;...&#xA;...&#xA;...&#xA;[----------] Global test environment tear-down&#xA;[==========] 946 tests from 57 test cases ran. (10812 ms total)&#xA;[  PASSED  ] 946 tests.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All tests should pass on supported platforms, though the exact number of tests may vary over time.&lt;/p&gt; &#xA;&lt;h1&gt;Project Structure&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is arranged as a header-only library along with Utilities, Tools, Examples, and unit tests. &lt;a href=&#34;https://nvidia.github.io/cutlass&#34;&gt;Doxygen documentation&lt;/a&gt; provides a complete list of files, classes, and template concepts defined in the CUTLASS project.&lt;/p&gt; &#xA;&lt;p&gt;A detailed explanation of the source code organization may be found in the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/code_organization.md&#34;&gt;CUTLASS documentation&lt;/a&gt;, but several main components are summarized below.&lt;/p&gt; &#xA;&lt;h2&gt;CUTLASS Template Library&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;include/                     # client applications should target this directory in their build&#39;s include paths&#xA;&#xA;  cutlass/                   # CUDA Templates for Linear Algebra Subroutines and Solvers - headers only&#xA;&#xA;    arch/                    # direct exposure of architecture features (including instruction-level GEMMs)&#xA;&#xA;    conv/                    # code specialized for convolution&#xA;&#xA;    epilogue/                # code specialized for the epilogue of gemm/convolution&#xA;&#xA;    gemm/                    # code specialized for general matrix product computations&#xA;&#xA;    layout/                  # layout definitions for matrices, tensors, and other mathematical objects in memory&#xA;&#xA;    platform/                # CUDA-capable Standard Library components&#xA;&#xA;    reduction/               # bandwidth-limited reduction kernels that do not fit the &#34;gemm&#34; model&#xA;&#xA;    thread/                  # simt code that can be performed within a CUDA thread&#xA;    &#xA;    transform/               # code specialized for layout, type, and domain transformations&#xA;&#xA;    *                        # core vocabulary types, containers, and basic numeric operations&#xA;&#xA;  cute/                      # CuTe Layout, layout algebra, MMA/Copy atoms, tiled MMA/Copy&#xA;&#xA;    algorithm/               # Definitions of core operations such as copy, gemm, and operations on cute::tuples&#xA;&#xA;    arch/                    # Bare bones PTX wrapper structs for copy and math instructions&#xA;&#xA;    atom/                    # Meta-information either link to or built from arch/ operators&#xA;&#xA;      mma_atom.hpp           # cute::Mma_Atom and cute::TiledMma&#xA;&#xA;      copy_atom.hpp          # cute::Copy_Atom and cute::TiledCopy&#xA;&#xA;      *sm*.hpp               # Arch specific meta-information for copy and math operations&#xA;&#xA;    *                        # Core library types such as Shape, Stride, Layout, Tensor, and associated operations&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CUTLASS SDK Examples&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples&#34;&gt;CUTLASS SDK examples&lt;/a&gt; apply CUTLASS templates to implement basic computations.&lt;/p&gt; &#xA;&lt;h3&gt;Tools&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;tools/&#xA;  library/                   # CUTLASS Instance Library - contains instantiations of all supported CUTLASS templates&#xA;    include/&#xA;      cutlass/&#xA;        library/&#xA;&#xA;  profiler/                  # CUTLASS Profiler         - command-line utility for executing operations in the&#xA;                             #                            CUTLASS Library&#xA;  &#xA;  util/                      # CUTLASS Utilities        - contains numerous helper classes for&#xA;    include/                 #                            manging tensors in device memory, reference&#xA;      cutlass/               #                            implementations for GEMM, random initialization&#xA;        util/                #                            of tensors, and I/O.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Test&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;test/unit/&lt;/code&gt; directory consist of unit tests implemented with Google Test that demonstrate basic usage of Core API components and complete tests of the CUTLASS GEMM computations.&lt;/p&gt; &#xA;&lt;p&gt;Instructions for building and running the Unit tests are described in the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md&#34;&gt;Quickstart guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Performance Profiling&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;code&gt;tools/profiler/&lt;/code&gt; directory contains a command-line utility for launching each of the GEMM kernels. It can be built as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building all GEMM and Convolution kernels (&lt;em&gt;long&lt;/em&gt; build times)&lt;/h2&gt; &#xA;&lt;p&gt;By default, only one tile size is instantiated for each data type, math instruction, and layout. To instantiate all, set the following environment variable when running CMake from an empty &lt;code&gt;build/&lt;/code&gt; directory. Beware, this results in &lt;em&gt;tens of thousands&lt;/em&gt; of kernels and long build times. This would also result in a large binary size and on some platforms linker to fail on building the library. Therefore, it&#39;s highly recommended to generate only a subset of kernels as demonstrated in the sub-section below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=90a -DCUTLASS_LIBRARY_KERNELS=all&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building a subset of GEMM and Convolution kernels (&lt;em&gt;reduced&lt;/em&gt; build times)&lt;/h2&gt; &#xA;&lt;p&gt;To compile strictly one kernel or a small set of kernels, a comma-delimited list of kernel names with wildcard characters may be used to reduce the set of kernels. The following examples show building exactly one or a subset of kernels for NVIDIA Ampere and Turing architecture:&lt;/p&gt; &#xA;&lt;h3&gt;Building a subset Tensor Core GEMM kernels&lt;/h3&gt; &#xA;&lt;p&gt;To compile a subset of Tensor Core GEMM kernels with FP32 accumulation and FP16 input targeting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_tensorop_s*gemm_f16_*_nt_align8&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling a subset of Tensor Core GEMM kernels is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./tools/profiler/cutlass_profiler --kernels=cutlass_tensorop_s*gemm_f16_*_nt_align8 --m=3456 --n=4096 --k=4096&#xA;&#xA;...&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: gemm&#xA;       Operation: cutlass_tensorop_s1688gemm_f16_256x128_32x2_nt_align8&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;reference_device: Passed&#xA;          cuBLAS: Passed&#xA;&#xA;       Arguments: --gemm_kind=universal --m=3456 --n=4096 --k=4096 --A=f16:column --B=f16:row --C=f32:column --alpha=1  \&#xA;                  --beta=0 --split_k_slices=1 --batch_count=1 --op_class=tensorop --accum=f32 --cta_m=256 --cta_n=128  \&#xA;                  --cta_k=32 --stages=2 --warps_m=4 --warps_n=2 --warps_k=1 --inst_m=16 --inst_n=8 --inst_k=8 --min_cc=75  \&#xA;                  --max_cc=1024&#xA;&#xA;           Bytes: 118489088  bytes&#xA;           FLOPs: 115992428544  flops&#xA;&#xA;         Runtime: 1.55948  ms&#xA;          Memory: 70.7616 GiB/s&#xA;&#xA;            Math: 74378.8 GFLOP/s&#xA;&#xA;&#xA;&#xA;=============================&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building one CUDA Core GEMM kernel&lt;/h3&gt; &#xA;&lt;p&gt;To compile one SGEMM kernel targeting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_simt_sgemm_128x128_8x2_nn_align1&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling single SGEMM CUDA kernel is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./tools/profiler/cutlass_profiler --kernels=sgemm --m=3456 --n=4096 --k=4096&#xA;&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: gemm&#xA;       Operation: cutlass_simt_sgemm_128x128_8x2_nn_align1&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;          cuBLAS: Passed&#xA;&#xA;       Arguments: --m=3456 --n=4096 --k=4096 --A=f32:column --B=f32:column --C=f32:column --alpha=1 --beta=0 --split_k_slices=1  \&#xA;                  --batch_count=1 --op_class=simt --accum=f32 --cta_m=128 --cta_n=128 --cta_k=8 --stages=2 --warps_m=4  \&#xA;                  --warps_n=2 --warps_k=1 --inst_m=1 --inst_n=1 --inst_k=1 --min_cc=50 --max_cc=1024&#xA;&#xA;           Bytes: 180355072  bytes&#xA;           FLOPs: 115992428544  flops&#xA;&#xA;         Runtime: 6.73655  ms&#xA;          Memory: 24.934 GiB/s&#xA;&#xA;            Math: 17218.4 GFLOP/s&#xA;&#xA;=============================&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building a subset of Tensor Core Convolution kernels&lt;/h3&gt; &#xA;&lt;p&gt;To compile a subset of Tensor core convolution kernels implementing forward propagation (fprop) with FP32 accumulation and FP16 input targeting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_tensorop_s*fprop_optimized_f16&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling a subset of Tensor Core convolution kernels is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./tools/profiler/cutlass_profiler --kernels=cutlass_tensorop_s*fprop_optimized_f16 --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3&#xA;&#xA;...&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: conv2d&#xA;       Operation: cutlass_tensorop_s16816fprop_optimized_f16_128x128_32x5_nhwc&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;reference_device: Passed&#xA;&#xA;       Arguments: --conv_kind=fprop --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3 --p=224 --q=224 --pad_h=1 --pad_w=1  \&#xA;                  --stride_h=1 --stride_w=1 --dilation_h=1 --dilation_w=1 --Activation=f16:nhwc --Filter=f16:nhwc --Output=f32:nhwc  \&#xA;                  --conv_mode=cross --iterator_algorithm=optimized --alpha=1 --beta=0 --split_k_mode=serial --split_k_slices=1  \&#xA;                  --eq_gemm_provider=none --op_class=tensorop --accum=f32 --cta_m=128 --cta_n=128 --cta_k=32 --stages=5  \&#xA;                  --warps_m=2 --warps_n=2 --warps_k=1 --inst_m=16 --inst_n=8 --inst_k=16 --min_cc=80 --max_cc=1024&#xA;&#xA;           Bytes: 1130659840  bytes&#xA;           FLOPs: 118482796544  flops&#xA;&#xA;         Runtime: 0.711496  ms&#xA;          Memory: 1479.99 GiB/s&#xA;&#xA;            Math: 166526 GFLOP/s&#xA;&#xA;=============================&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building one Convolution CUDA kernel&lt;/h3&gt; &#xA;&lt;p&gt;To compile and run one CUDA Core convolution kernel implementing forward propagation (fprop) with F32 accumulation and FP32 input targeting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_simt_sfprop_optimized_128x128_8x2_nhwc&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling one CUDA Core convolution kernel:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./tools/profiler/cutlass_profiler --kernels=cutlass_simt_sfprop_optimized_128x128_8x2_nhwc --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3&#xA;&#xA;&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: conv2d&#xA;       Operation: cutlass_simt_sfprop_optimized_128x128_8x2_nhwc&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;reference_device: Passed&#xA;&#xA;       Arguments: --conv_kind=fprop --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3 --p=224 --q=224 --pad_h=1 --pad_w=1  \&#xA;                  --stride_h=1 --stride_w=1 --dilation_h=1 --dilation_w=1 --Activation=f32:nhwc --Filter=f32:nhwc --Output=f32:nhwc  \&#xA;                  --conv_mode=cross --iterator_algorithm=optimized --alpha=1 --beta=0 --split_k_mode=serial --split_k_slices=1  \&#xA;                  --eq_gemm_provider=none --op_class=simt --accum=f32 --cta_m=128 --cta_n=128 --cta_k=8 --stages=2 --warps_m=4  \&#xA;                  --warps_n=2 --warps_k=1 --inst_m=1 --inst_n=1 --inst_k=1 --min_cc=50 --max_cc=1024&#xA;&#xA;           Bytes: 2055798784  bytes&#xA;           FLOPs: 118482796544  flops&#xA;&#xA;         Runtime: 7.34266  ms&#xA;          Memory: 260.752 GiB/s&#xA;&#xA;            Math: 16136.2 GFLOP/s&#xA;&#xA;&#xA;=============================&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;More Details on Compiling CUTLASS Kernels and CUTLASS Profiler&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Please follow the links for more CMake examples on selectively compiling CUTLASS kernels: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md#gemm-cmake-examples&#34;&gt;GEMM CMake Examples&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md#convolution-cmake-examples&#34;&gt;Implicit GEMM convolution CMake Examples&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/profiler.md&#34;&gt;Further details about the CUTLASS Profiler are described here.&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;About&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is released by NVIDIA Corporation as Open Source software under the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/LICENSE.txt&#34;&gt;3-clause &#34;New&#34; BSD license&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Contributors&lt;/h1&gt; &#xA;&lt;p&gt;The official list of CUTLASS developers and contributors is available here: &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/CONTRIBUTORS.md&#34;&gt;CONTRIBUTORS&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Copyright&lt;/h1&gt; &#xA;&lt;p&gt;Copyright (c) 2017 - 2025 NVIDIA CORPORATION &amp;amp; AFFILIATES. All rights reserved. SPDX-License-Identifier: BSD-3-Clause&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  Redistribution and use in source and binary forms, with or without&#xA;  modification, are permitted provided that the following conditions are met:&#xA;&#xA;  1. Redistributions of source code must retain the above copyright notice, this&#xA;  list of conditions and the following disclaimer.&#xA;&#xA;  2. Redistributions in binary form must reproduce the above copyright notice,&#xA;  this list of conditions and the following disclaimer in the documentation&#xA;  and/or other materials provided with the distribution.&#xA;&#xA;  3. Neither the name of the copyright holder nor the names of its&#xA;  contributors may be used to endorse or promote products derived from&#xA;  this software without specific prior written permission.&#xA;&#xA;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;&#xA;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&#xA;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&#xA;  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE&#xA;  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&#xA;  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&#xA;  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER&#xA;  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,&#xA;  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&#xA;  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>