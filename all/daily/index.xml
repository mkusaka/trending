<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-30T01:22:32Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>swordbluesword/PalWorld-NetCrack</title>
    <updated>2024-01-30T01:22:32Z</updated>
    <id>tag:github.com,2024-01-30:/swordbluesword/PalWorld-NetCrack</id>
    <link href="https://github.com/swordbluesword/PalWorld-NetCrack" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PalWorld-NetCrack&lt;/h1&gt; &#xA;&lt;p&gt;This is the PalWorld network cracking framework modifying player data in the Player tab Network cracking in the Exploit tab&lt;/p&gt; &#xA;&lt;h1&gt;Note: The master branch does not include visual,but In imperfect branch, we&#39;ll add something that isn&#39;t on the master branch.&lt;/h1&gt; &#xA;&lt;h1&gt;Player Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Modify Player Speed&lt;/li&gt; &#xA; &lt;li&gt;Modify Player Attack Power&lt;/li&gt; &#xA; &lt;li&gt;Modify Player Defense Power&lt;/li&gt; &#xA; &lt;li&gt;Infinite Stamina&lt;/li&gt; &#xA; &lt;li&gt;Infinite Ammo&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Exploits&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SafeTeleport(You can choose the implementation for TP)&lt;/li&gt; &#xA; &lt;li&gt;HomeTP&lt;/li&gt; &#xA; &lt;li&gt;AnywhereTP(It requires you to manually give a position)&lt;/li&gt; &#xA; &lt;li&gt;ToggleFly&lt;/li&gt; &#xA; &lt;li&gt;DeleteSelf(Warning: After testing, it will delete your data on the server)&lt;/li&gt; &#xA; &lt;li&gt;GodHealth&lt;/li&gt; &#xA; &lt;li&gt;Give EXP (Credit: WoodgamerHD)&lt;/li&gt; &#xA; &lt;li&gt;Give Pal (Credit: Kaotic13)&lt;/li&gt; &#xA; &lt;li&gt;Spawn Pal&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;AOBS&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;GObjects: &lt;code&gt;48 8B 05 ? ? ? ? 48 8B 0C C8 4C 8D 04 D1 EB 03&lt;/code&gt;&lt;br&gt; FNames: &lt;code&gt;48 8D 05 ? ? ? ? EB 13 48 8D 0D ? ? ? ? E8 ? ? ? ? C6 05 ? ? ? ? ? 0F 10&lt;/code&gt;&lt;br&gt; GWorld: &lt;code&gt;48 8B 1D ?? ?? ?? ?? 48 85 DB 74 33 41 B0&lt;/code&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;External Library Credits&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ocornut/imgui&#34;&gt;Dear ImGui&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/TsudaKageyu/minhook&#34;&gt;MinHook&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/Encryqed/Dumper-7&#34;&gt;Dumper7&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/NightFyre/DX11-ImGui-Internal-Hook&#34;&gt;DX11-Internal-Base&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>bclavie/RAGatouille</title>
    <updated>2024-01-30T01:22:32Z</updated>
    <id>tag:github.com,2024-01-30:/bclavie/RAGatouille</id>
    <link href="https://github.com/bclavie/RAGatouille" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Welcome to RAGatouille&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Easily use and train state of the art retrieval methods in any RAG pipeline. Designed for modularity and ease-of-use, backed by research.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bclavie/ragatouille/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/bclavie/ragatouille.svg?sanitize=true&#34; alt=&#34;GitHub stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pepy.tech/project/ragatouille&#34;&gt;&lt;img src=&#34;https://static.pepy.tech/badge/ragatouille/month&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://ben.clavie.eu/ragatouille/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/docs-available-brightgreen&#34; alt=&#34;Documentation&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/bclavie&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/bclavie?style=social&#34; alt=&#34;Twitter Follow&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img width=&#34;500&#34; alt=&#34;The RAGatouille logo, it&#39;s a cheerful rat on his laptop (branded with a slightly eaten piece of cheese) and a pile of books he&#39;s looking for information in.&#34; src=&#34;https://raw.githubusercontent.com/bclavie/RAGatouille/main/RAGatouille.png&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;The main motivation of RAGatouille is simple: bridging the gap between state-of-the-art research and alchemical RAG pipeline practices. RAG is complex, and there are many moving parts. To get the best performance, you need to optimise for many components: among them, a very important one is the models you use for retrieval.&lt;/p&gt; &#xA;&lt;p&gt;Dense retrieval, i.e. using embeddings such as OpenAI&#39;s &lt;code&gt;text-ada-002&lt;/code&gt;, is a good baseline, but there&#39;s a lot of research &lt;a href=&#34;https://arxiv.org/abs/2104.08663&#34;&gt;showing dense embeddings might not be the&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/2204.11447&#34;&gt;best fit for &lt;strong&gt;your&lt;/strong&gt; usecase&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The Information Retrieval research field has recently been booming, and models like ColBERT have been shown to &lt;a href=&#34;https://arxiv.org/abs/2203.10053&#34;&gt;generalise better&lt;/a&gt; &lt;a href=&#34;https://aclanthology.org/2022.findings-emnlp.78/&#34;&gt;to new or complex domains&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/2205.02870&#34;&gt;than dense embeddings&lt;/a&gt;, are &lt;a href=&#34;https://arxiv.org/abs/2309.06131&#34;&gt;ridiculously data-efficient&lt;/a&gt; and are even &lt;a href=&#34;https://arxiv.org/abs/2312.09508&#34;&gt;better suited to efficiently being trained&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/2312.16144&#34;&gt;on non-English languages with low amount of data&lt;/a&gt;! Unfortunately, most of those new approaches aren&#39;t very well known, and are much harder to use than dense embeddings.&lt;/p&gt; &#xA;&lt;p&gt;This is where &lt;strong&gt;RAGatouille&lt;/strong&gt; comes in: RAGatouille&#39;s purpose is to bridge this gap: make it easy to use state-of-the-art methods in your RAG pipeline, without having to worry about the details or the years of literature! At the moment, RAGatouille focuses on making ColBERT simple to use. If you want to check out what&#39;s coming next, you can check out our &lt;a href=&#34;https://ben.clavie.eu/ragatouille/roadmap&#34;&gt;broad roadmap&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;If you want to read more about the motivations, philosophy, and why the late-interaction approach used by ColBERT works so well, check out the &lt;a href=&#34;https://ben.clavie.eu/ragatouille/&#34;&gt;introduction in the docs&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Want to give it a try? Nothing easier, just run &lt;code&gt;pip install ragatouille&lt;/code&gt; and you&#39;re good to go!&lt;/p&gt; &#xA;&lt;p&gt;‚ö†Ô∏è RAGatouille currently has two running requirements: ‚ö†Ô∏è&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If running inside a script, you must run it inside &lt;code&gt;if __name__ == &#34;__main__&#34;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;It does not currently support Google Colab **&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Get Started&lt;/h2&gt; &#xA;&lt;p&gt;RAGatouille makes it as simple as can be to use ColBERT! We want the library to work on two levels:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Strong, but parameterable defaults: you should be able to get started with just a few lines of code and still leverage the full power of ColBERT, and you should be able to tweak any relevant parameter if you need to!&lt;/li&gt; &#xA; &lt;li&gt;Powerful yet simple re-usable components under-the-hood: any part of the library should be usable stand-alone. You can use our DataProcessor or our negative miners outside of &lt;code&gt;RAGPretrainedModel&lt;/code&gt; and &lt;code&gt;RagTrainer&lt;/code&gt;, and you can even write your own negative miner and use it in the pipeline if you want to!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- (more on [components](https://ben.clavie.eu/ragatouille/components)). --&gt; &#xA;&lt;p&gt;In this section, we&#39;ll quickly walk you through the three core aspects of RAGatouille:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bclavie/RAGatouille/main/#training-and-fine-tuning&#34;&gt;üöÄ Training and Fine-Tuning ColBERT models&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bclavie/RAGatouille/main/#indexing&#34;&gt;üóÑÔ∏è Embedding and Indexing Documents&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bclavie/RAGatouille/main/#retrieving-documents&#34;&gt;üîé Retrieving documents&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;‚û°Ô∏è If you want just want to see fully functional code examples, head over to the &lt;a href=&#34;https://github.com/bclavie/RAGatouille/tree/main/examples&#34;&gt;examples&lt;/a&gt;‚¨ÖÔ∏è&lt;/p&gt; &#xA;&lt;h3&gt;üöÄ Training and fine-tuning&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;If you&#39;re just prototyping, you don&#39;t need to train your own model! While finetuning can be useful, one of the strength of ColBERT is that the pretrained models are particularly good at generalisation, and &lt;a href=&#34;https://huggingface.co/colbert-ir/colbertv2.0&#34;&gt;ColBERTv2&lt;/a&gt; has &lt;a href=&#34;https://arxiv.org/abs/2303.00807&#34;&gt;repeatedly been shown to be extremely strong&lt;/a&gt; at zero-shot retrieval in new domains!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Data Processing&lt;/h4&gt; &#xA;&lt;p&gt;RAGatouille&#39;s RAGTrainer has a built-in &lt;code&gt;TrainingDataProcessor&lt;/code&gt;, which can take most forms of retrieval training data, and automatically convert it to training triplets, with data enhancements. The pipeline works as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Accepts pairs, labelled pairs and various forms of triplets as inputs (strings or list of strings) -- transparently!&lt;/li&gt; &#xA; &lt;li&gt;Automatically remove all duplicates and maps all positives/negatives to their respective query.&lt;/li&gt; &#xA; &lt;li&gt;By default, mine hard negatives: this means generating negatives that are hard to distinguish from positives, and that are therefore more useful for training.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is all handled by &lt;code&gt;RAGTrainer.prepare_training_data()&lt;/code&gt;, and is as easy as doing passing your data to it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ragatouille import RAGTrainer&#xA;&#xA;my_data = [&#xA;    (&#34;What is the meaning of life ?&#34;, &#34;The meaning of life is 42&#34;),&#xA;    (&#34;What is Neural Search?&#34;, &#34;Neural Search is a terms referring to a family of ...&#34;),&#xA;    ...&#xA;]  # Unlabelled pairs here&#xA;trainer = RAGTrainer()&#xA;trainer.prepare_training_data(raw_data=my_data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ColBERT prefers to store processed training data on-file, which also makes easier to properly version training data via &lt;code&gt;wandb&lt;/code&gt; or &lt;code&gt;dvc&lt;/code&gt;. By default, it will write to &lt;code&gt;./data/&lt;/code&gt;, but you can override this by passing a &lt;code&gt;data_out_path&lt;/code&gt; argument to &lt;code&gt;prepare_training_data()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Just like all things in RAGatouille, &lt;code&gt;prepare_training_data&lt;/code&gt; uses strong defaults, but is also fully parameterable.&lt;/p&gt; &#xA;&lt;!-- Check out the [Data Processing](https://ben.clavie.eu/ragatouille/data-processing) section of the docs! --&gt; &#xA;&lt;h4&gt;Running the Training/Fine-Tuning&lt;/h4&gt; &#xA;&lt;p&gt;Training and Fine-Tuning follow the exact same process. When you instantiate &lt;code&gt;RAGTrainer&lt;/code&gt;, you must pass it a &lt;code&gt;pretrained_model_name&lt;/code&gt;. If this pretrained model is a ColBERT instance, the trainer will be in fine-tuning mode, if it&#39;s another kind of transformer, it will be in training mode to begin training a new ColBERT initialised from the model&#39;s weights!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ragatouille import RAGTrainer&#xA;from ragatouille.utils import get_wikipedia_page&#xA;&#xA;pairs = [&#xA;    (&#34;What is the meaning of life ?&#34;, &#34;The meaning of life is 42&#34;),&#xA;    (&#34;What is Neural Search?&#34;, &#34;Neural Search is a terms referring to a family of ...&#34;),&#xA;    # You need many more pairs to train! Check the examples for more details!&#xA;    ...&#xA;]&#xA;&#xA;my_full_corpus = [get_wikipedia_page(&#34;Hayao_Miyazaki&#34;), get_wikipedia_page(&#34;Studio_Ghibli&#34;)]&#xA;&#xA;&#xA;trainer = RAGTrainer(model_name = &#34;MyFineTunedColBERT&#34;,&#xA;        pretrained_model_name = &#34;colbert-ir/colbertv2.0&#34;) # In this example, we run fine-tuning&#xA;&#xA;# This step handles all the data processing, check the examples for more details!&#xA;trainer.prepare_training_data(raw_data=pairs,&#xA;                                data_out_path=&#34;./data/&#34;,&#xA;                                all_documents=my_full_corpus)&#xA;&#xA;trainer.train(batch_size=32) # Train with the default hyperparams&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you run &lt;code&gt;train()&lt;/code&gt;, it&#39;ll by default inherit its parent ColBERT hyperparameters if fine-tuning, or use the default training parameters if training a new ColBERT. Feel free to modify them as you see fit (check the example and API reference for more details!)&lt;/p&gt; &#xA;&lt;h3&gt;üóÑÔ∏è Indexing&lt;/h3&gt; &#xA;&lt;p&gt;To create an index, you&#39;ll need to load a trained model, this can be one of your own or a pretrained one from the hub! Creating an index with the default configuration is just a few lines of code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ragatouille import RAGPretrainedModel&#xA;from ragatouille.utils import get_wikipedia_page&#xA;&#xA;RAG = RAGPretrainedModel.from_pretrained(&#34;colbert-ir/colbertv2.0&#34;)&#xA;my_documents = [get_wikipedia_page(&#34;Hayao_Miyazaki&#34;), get_wikipedia_page(&#34;Studio_Ghibli&#34;)]&#xA;index_path = RAG.index(index_name=&#34;my_index&#34;, collection=my_documents)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also optionally add document IDs or document metadata when creating the index:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;document_ids = [&#34;miyazaki&#34;, &#34;ghibli&#34;]&#xA;document_metadatas = [&#xA;    {&#34;entity&#34;: &#34;person&#34;, &#34;source&#34;: &#34;wikipedia&#34;},&#xA;    {&#34;entity&#34;: &#34;organisation&#34;, &#34;source&#34;: &#34;wikipedia&#34;},&#xA;]&#xA;index_path = RAG.index(&#xA;    index_name=&#34;my_index_with_ids_and_metadata&#34;,&#xA;    collection=my_documents,&#xA;    document_ids=document_ids,&#xA;    document_metadatas=document_metadatas,&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once this is done running, your index will be saved on-disk and ready to be queried! RAGatouille and ColBERT handle everything here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Splitting your documents&lt;/li&gt; &#xA; &lt;li&gt;Tokenizing your documents&lt;/li&gt; &#xA; &lt;li&gt;Identifying the individual terms&lt;/li&gt; &#xA; &lt;li&gt;Embedding the documents and generating the bags-of-embeddings&lt;/li&gt; &#xA; &lt;li&gt;Compressing the vectors and storing them on disk&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Curious about how this works? Check out the &lt;a href=&#34;https://ben.clavie.eu/ragatouille/#late-interaction&#34;&gt;Late-Interaction &amp;amp; ColBERT concept explainer&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- or find out more about [indexing](https://ben.clavie.eu/ragatouille/indexing)! --&gt; &#xA;&lt;h3&gt;üîé Retrieving Documents&lt;/h3&gt; &#xA;&lt;p&gt;Once an index is created, querying it is just as simple as creating it! You can either load the model you need directly from an index&#39;s configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ragatouille import RAGPretrainedModel&#xA;&#xA;query = &#34;ColBERT my dear ColBERT, who is the fairest document of them all?&#34;&#xA;RAG = RAGPretrainedModel.from_index(&#34;path_to_your_index&#34;)&#xA;results = RAG.search(query)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is the preferred way of doing things, since every index saves the full configuration of the model used to create it, and you can easily load it back up.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;RAG.search&lt;/code&gt; is a flexible method! You can set the &lt;code&gt;k&lt;/code&gt; value to however many results you want (it defaults to &lt;code&gt;10&lt;/code&gt;), and you can also use it to search for multiple queries at once:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;RAG.search([&#34;What manga did Hayao Miyazaki write?&#34;,&#xA;&#34;Who are the founders of Ghibli?&#34;&#xA;&#34;Who is the director of Spirited Away?&#34;],)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;RAG.search&lt;/code&gt; returns results in the form of a list of dictionaries, or a list of list of dictionaries if you used multiple queries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# single-query result&#xA;[&#xA;    {&#34;content&#34;: &#34;blablabla&#34;, &#34;score&#34;: 42.424242, &#34;rank&#34;: 1, &#34;document_id&#34;: &#34;x&#34;},&#xA;    ...,&#xA;    {&#34;content&#34;: &#34;albalbalba&#34;, &#34;score&#34;: 24.242424, &#34;rank&#34;: k, &#34;document_id&#34;: &#34;y&#34;},&#xA;]&#xA;# multi-query result&#xA;[&#xA;    [&#xA;        {&#34;content&#34;: &#34;blablabla&#34;, &#34;score&#34;: 42.424242, &#34;rank&#34;: 1, &#34;document_id&#34;: &#34;x&#34;},&#xA;        ...,&#xA;        {&#34;content&#34;: &#34;albalbalba&#34;, &#34;score&#34;: 24.242424, &#34;rank&#34;: k, &#34;document_id&#34;: &#34;y&#34;},&#xA;    ],&#xA;    [&#xA;        {&#34;content&#34;: &#34;blablabla&#34;, &#34;score&#34;: 42.424242, &#34;rank&#34;: 1, &#34;document_id&#34;: &#34;x&#34;},&#xA;        ...,&#xA;        {&#34;content&#34;: &#34;albalbalba&#34;, &#34;score&#34;: 24.242424, &#34;rank&#34;: k, &#34;document_id&#34;: &#34;y&#34;},&#xA;    ],&#xA; ],&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your index includes document metadata, it&#39;ll be returned as a dictionary in the &lt;code&gt;document_metadata&lt;/code&gt; key of the result dictionary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[&#xA;    {&#34;content&#34;: &#34;blablabla&#34;, &#34;score&#34;: 42.424242, &#34;rank&#34;: 1, &#34;document_id&#34;: &#34;x&#34;, &#34;document_metadata&#34;: {&#34;A&#34;: 1, &#34;B&#34;: 2}},&#xA;    ...,&#xA;    {&#34;content&#34;: &#34;albalbalba&#34;, &#34;score&#34;: 24.242424, &#34;rank&#34;: k, &#34;document_id&#34;: &#34;y&#34;, &#34;document_metadata&#34;: {&#34;A&#34;: 3, &#34;B&#34;: 4}},&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;I&#39;m sold, can I integrate late-interaction RAG into my project?&lt;/h2&gt; &#xA;&lt;p&gt;To get started, RAGatouille bundles everything you need to build a ColBERT native index and query it. Just look at the docs! RAGatouille persists indices on disk in compressed format, and a very viable production deployment is to simply integrate the index you need into your project and query it directly. Don&#39;t just take our word for it, this is what Spotify does in production with their own vector search framework, serving dozens of millions of users:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Statelessness: Many of Spotify‚Äôs systems use nearest-neighbor search in memory, enabling stateless deployments (via Kubernetes) and almost entirely removing the maintenance and cost burden of maintaining a stateful database cluster. (&lt;em&gt;&lt;a href=&#34;https://engineering.atspotify.com/2023/10/introducing-voyager-spotifys-new-nearest-neighbor-search-library/&#34;&gt;Spotify, announcing Voyager&lt;/a&gt;&lt;/em&gt;)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Integrations&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;d like to use more than RAGatouille, ColBERT has a growing number of integrations, and they all fully support models trained or fine-tuned with RAGatouille!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/stanford-futuredata/ColBERT&#34;&gt;official ColBERT implementation&lt;/a&gt; has a built-in query server (using Flask), which you can easily query via API requests and does support indexes generated with RAGatouille! This should be enough for most small applications, so long as you can persist the index on disk.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vespa.ai&#34;&gt;Vespa&lt;/a&gt; offers a fully managed RAG engine with ColBERT support: it&#39;s essentially just like a vector DB, except with many more retrieval options! Full support for ColBERT models will be released in the next couple weeks, and using a RAGatouille-trained model will be as simple as loading it from the huggingface hub! &lt;strong&gt;Vespa is a well-tested, widely used framework and is &lt;a href=&#34;https://python.langchain.com/docs/integrations/providers/vespa&#34;&gt;fully-supported in LangChain&lt;/a&gt;, making it the ideal slot-in replacement to replace your current RAG pipeline with ColBERT!&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/IntelLabs/fastRAG&#34;&gt;Intel&#39;s FastRAG&lt;/a&gt; supports ColBERT models for RAG, and is fully compatible with RAGatouille-trained models.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.llamaindex.ai&#34;&gt;LlamaIndex&lt;/a&gt; is building ColBERT integrations and already &lt;a href=&#34;https://github.com/run-llama/llama_index/pull/9656&#34;&gt;has early ColBERT support, with active development continuing&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>nicknochnack/MLTradingBot</title>
    <updated>2024-01-30T01:22:32Z</updated>
    <id>tag:github.com,2024-01-30:/nicknochnack/MLTradingBot</id>
    <link href="https://github.com/nicknochnack/MLTradingBot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;TraderBot&lt;/h1&gt; &#xA;&lt;p&gt;Build a trader bot which looks at sentiment of live news events and trades appropriately.&lt;/p&gt; &#xA;&lt;h2&gt;See it live and in action üì∫&lt;/h2&gt; &#xA;&lt;img src=&#34;https://i.imgur.com/FaQH8rz.png&#34;&gt; &#xA;&lt;h1&gt;Startup üöÄ&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a virtual environment &lt;code&gt;conda create -n trader python=3.10&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Activate it &lt;code&gt;conda activate trader&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install initial deps &lt;code&gt;pip install lumibot timedelta alpaca-trade-api&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install transformers and friends &lt;code&gt;pip install torch torchvision torchaudio transformers&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Update the &lt;code&gt;API_KEY&lt;/code&gt; and &lt;code&gt;API_SECRET&lt;/code&gt; with values from your Alpaca account&lt;/li&gt; &#xA; &lt;li&gt;Run the bot &lt;code&gt;python tradingbot.py&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;N.B. Torch installation instructions will vary depending on your operating system and hardware. See here for more: &lt;a href=&#34;https://raw.githubusercontent.com/nicknochnack/MLTradingBot/main/pytorch.org/&#34;&gt;PyTorch Installation Instructions&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re getting an SSL error when you attempt to call out to the Alpaca Trading api, you&#39;ll need to install the required SSL certificates into your machine.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the following intermediate SSL Certificates, these are required to communicate with Alpaca&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://letsencrypt.org/certs/lets-encrypt-r3.pem&#34;&gt;https://letsencrypt.org/certs/lets-encrypt-r3.pem&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://letsencrypt.org/certs/isrg-root-x1-cross-signed.pem&#34;&gt;https://letsencrypt.org/certs/isrg-root-x1-cross-signed.pem&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Once downloaded, change the file extension of each file to &lt;code&gt;.cer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Double click the file and run through the wizard to install it, use all of the default selections.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;br&gt; # Other References üîó &#xA;&lt;p&gt;-&lt;a href=&#34;https://raw.githubusercontent.com/nicknochnack/MLTradingBot/main/github.com/Lumiwealth/lumibot)&#34;&gt;Lumibot&lt;/a&gt;:trading bot library, makes lifecycle stuff easier .&lt;/p&gt; &#xA;&lt;h1&gt;Who, When, Why?&lt;/h1&gt; &#xA;&lt;p&gt;üë®üèæ‚Äçüíª Author: Nick Renotte &lt;br&gt; üìÖ Version: 1.x&lt;br&gt; üìú License: This project is licensed under the MIT License &lt;br&gt;&lt;/p&gt;</summary>
  </entry>
</feed>