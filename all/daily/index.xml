<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-16T01:29:22Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jart/blink</title>
    <updated>2022-12-16T01:29:22Z</updated>
    <id>tag:github.com,2022-12-16:/jart/blink</id>
    <link href="https://github.com/jart/blink" rel="alternate"></link>
    <summary type="html">&lt;p&gt;tiniest x86-64-linux emulator&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jart/blink/master/blink/blink-gcc.png&#34; alt=&#34;Screenshot of Blink running GCC 9.4.0&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;blink&lt;/h1&gt; &#xA;&lt;p&gt;blink is a virtual machine for running statically-compiled x86-64-linux programs on different operating systems and hardware architectures. It&#39;s designed to do the same thing as the &lt;code&gt;qemu-x86_64&lt;/code&gt; command, except rather than being a 4mb binary, blink only has a ~166kb footprint. The tradeoff is Blink goes half as fast as Qemu and doesn&#39;t have as many systems integrations. Blink is a great fit when you want a virtual machine that&#39;s embeddable, readable, hackable, and easy to compile. For further details on the motivations for this tool, please read &lt;a href=&#34;https://justine.lol/ape.html&#34;&gt;https://justine.lol/ape.html&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Caveat Emptor&lt;/h2&gt; &#xA;&lt;p&gt;Welcome everyone from the Hacker News, Lobsters, and Reddit communities! This project is a work in progress. Please don&#39;t use this for production yet. If you try this be sure to calibrate your expectations accordingly.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;You can compile Blink on x86-64 Linux, Darwin, FreeBSD, NetBSD, OpenBSD, Apple Silicon, and Raspberry Pi using your operating system&#39;s toolchain.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# for all x86-64 platforms&#xA;$ build/bootstrap/make.com -j8 o//blink/blink&#xA;&#xA;# for apple m1 arm silicon&#xA;# don&#39;t use the ancient version of gnu make that comes with xcode&#xA;$ make -j8 o//blink/blink&#xA;&#xA;# for linux raspberry pi&#xA;$ build/bootstrap/blink-linux-aarch64 build/bootstrap/make.com -j8 o//blink/blink&#xA;&#xA;# run actually portable executable in virtual machine&#xA;$ o//blink/blink third_party/cosmo/hello.com&#xA;hello world&#xA;&#xA;# run static elf binary in virtual machine&#xA;$ o//blink/blink third_party/cosmo/tinyhello.elf&#xA;hello world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s a terminal interface for debugging:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ build/bootstrap/make.com -j8 o//blink/tui&#xA;$ o//blink/tui third_party/cosmo/tinyhello.elf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run our test executables to check your local platform build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ build/bootstrap/make.com -j8 check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For maximum performance, use &lt;code&gt;MODE=rel&lt;/code&gt; or &lt;code&gt;MODE=opt&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ build/bootstrap/make.com MODE=opt -j8 check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For maximum tinyness, use &lt;code&gt;MODE=tiny&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ build/bootstrap/make.com MODE=tiny -j8 check&#xA;$ strip o/tiny/blink/blink&#xA;$ ls -hal o/tiny/blink/blink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can sanitize using &lt;code&gt;MODE=asan&lt;/code&gt;, &lt;code&gt;MODE=ubsan&lt;/code&gt;, &lt;code&gt;MODE=tsan&lt;/code&gt;, and &lt;code&gt;MODE=msan&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re building your code on an x86-64 Linux machine, then the following command will cross-compile blink for i386, arm, m68k, riscv, mips, s390x. Then it&#39;ll launch all the cross-compiled binaries in qemu to ensure the test programs above work on all architectures.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ build/bootstrap/make.com -j8 emulates&#xA;$ o/third_party/qemu/qemu-aarch64 o//aarch64/blink/blink third_party/cosmo/hello.com&#xA;hello world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Technical Details&lt;/h2&gt; &#xA;&lt;p&gt;blink is an x86-64 interpreter for POSIX platforms that&#39;s written in ANSI C11 that&#39;s compatible with C++ compilers. Instruction decoding is done using our trimmed-down version of Intel&#39;s disassembler Xed.&lt;/p&gt; &#xA;&lt;p&gt;The prime directive of this project is to act as a virtual machine for userspace binaries compiled by Cosmopolitan Libc. However we&#39;ve also had success virtualizing programs compiled with Glibc and Musl Libc, such as GCC and Qemu. Blink supports more than a hundred Linux system call ABIs, including fork() and clone(). The SSE2, SSE3, SSSE3, POPCNT, CLMUL, RDTSCP, and RDRND hardware ISAs are supported. Blink&#39;s legacy x87 FPU currently only supports double (64-bit) precision, just like Windows.&lt;/p&gt; &#xA;&lt;p&gt;Blink uses just-in-time compilation, which is supported on x86_64 and aarch64. Blink takes the appropriate steps to work around restrictions relating to JIT, on platforms like Apple and OpenBSD. We generate JIT code using a printf-style domain-specific language. The JIT works by generating functions at runtime which call the micro-op functions the compiler created. To make micro-operations go faster, Blink determines the byte length of the compiled function at runtime by scanning for a RET instruction. Blink will then copy the compiled function into the function that the JIT is generating. This works in most cases, however some tools can cause problems. For example, OpenBSD RetGuard inserts static memory relocations into every compiled function, which Blink&#39;s JIT currently doesn&#39;t understand; so we need to use compiler flags to disable that type of magic. In the event other such magic slips through, Blink has a runtime check which will catch obvious problems, and then gracefully fall back to using a CALL instruction. Since no JIT can be fully perfect on all platforms, the &lt;code&gt;o//blink/blink -j&lt;/code&gt; flag may be passed to disable Blink&#39;s JIT. Please note that disabling JIT makes Blink go 10x slower. With the &lt;code&gt;o//blink/tui&lt;/code&gt; command, the &lt;code&gt;-j&lt;/code&gt; flag takes on the opposite meaning, where it instead &lt;em&gt;enables&lt;/em&gt; JIT. This can be useful for troubleshooting the JIT, because the TUI display has a feature that lets JIT path formation be visualized. Blink currently only enables the JIT for programs running in long mode (64-bit) but we may support JITing 16-bit programs in the future.&lt;/p&gt; &#xA;&lt;p&gt;Blink virtualizes memory using the same PML4T approach as the hardware itself, where memory lookups are indirected through a four-level radix tree. Since performing four separate page table lookups on every memory access can be slow, Blink checks a translation lookaside buffer, which contains the sixteen most recently used page table entries. The PML4T allows all memory lookups in Blink to be &#34;safe&#34; but it still doesn&#39;t offer the best possible performance. Therefore, on systems with a huge address space (i.e. petabytes of virtual memory) Blink relies on itself being loaded to a random location, and then identity maps guest memory using a simple linear translation. For example, if the guest virtual address is &lt;code&gt;0x400000&lt;/code&gt; then the host address might be &lt;code&gt;0x400000+0x088800000000&lt;/code&gt;. This means that each time a memory operation is executed, only a simple addition needs to be performed. This goes extremely fast, however it may present issues for programs that use &lt;code&gt;MAP_FIXED&lt;/code&gt;. Some systems, such as modern Raspberry Pi, actually have a larger address space than x86-64, which lets Blink offer the guest the complete address space. However on some platforms, like 32-bit ones, only a limited number of identity mappings are possible. There&#39;s also compiler tools like TSAN which lay claim to much of the fixed address space. Blink&#39;s solution is designed to meet the needs of Cosmopolitan Libc, while working around Apple&#39;s restriction on 32-bit addresses, and still remain fully compatible with ASAN&#39;s restrictions. In the event that this translation scheme doesn&#39;t work on your system, the &lt;code&gt;blink -m&lt;/code&gt; flag may be passed to disable the linear translation optimization, and instead use only the memory safe full virtualization approach of the PML4T and TLB.&lt;/p&gt; &#xA;&lt;p&gt;Blink has an xterm-compatible ANSI teletypewriter display implementation which allows Blink&#39;s TUI interface to host other TUI programs, within an embedded terminal display. For example, it&#39;s possible to use Antirez&#39;s Kilo text editor inside Blink&#39;s TUI.&lt;/p&gt; &#xA;&lt;p&gt;Blink supports 16-bit BIOS programs, such as SectorLISP. To boot real mode programs in Blink, the &lt;code&gt;o//blink/tui -r&lt;/code&gt; flag may be passed, which puts the virtual machine in i8086 mode. Currently only a limited set of BIOS APIs are available. For example, Blink supports IBM PC Serial UART, CGA display, and the MDA display APIs which are rendered using block characters in the TUI interface. We hope to expand our real mode support in the near future, in order to run operating systems like ELKS.&lt;/p&gt; &#xA;&lt;p&gt;Blink supports troubleshooting operating system bootloaders. Blink was designed for Cosmopolitan Libc, which embeds an operating system in each binary it compiles. Blink has helped us debug our bare metal support, since Blink is capable of running in the 16-bit, 32-bit, and 64-bit modes a bootloader requires at various stages. In order to do that, we needed to implement some ring0 hardware instructions. Blink has enough to support Cosmopolitan, but it&#39;ll take much more time to get Blink to a point where it can boot something like Windows.&lt;/p&gt; &#xA;&lt;p&gt;Blink supports several different executable formats, all of which are static. You can run:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Actually Portable Executables, which have either the &lt;code&gt;MZqFpD&lt;/code&gt; or &lt;code&gt;jartsr&lt;/code&gt; magic.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Statically-compiled x86-64-linux ELF executables, so long as they don&#39;t use PIC/PIE or require a interpreter.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Flat executables, which must end with the file extension &lt;code&gt;.bin&lt;/code&gt;. In this case, you can make executables as small as 10 bytes in size, since they&#39;re treated as raw x86-64 code. Blink always loads flat executables to the address &lt;code&gt;0x400000&lt;/code&gt; and automatically appends 16mb of BSS memory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Real mode executables, which are loaded to the address &lt;code&gt;0x7c00&lt;/code&gt;. These programs must be run using the &lt;code&gt;tui&lt;/code&gt; command with the &lt;code&gt;-r&lt;/code&gt; flag.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>betaveros/noulith</title>
    <updated>2022-12-16T01:29:22Z</updated>
    <id>tag:github.com,2022-12-16:/betaveros/noulith</id>
    <link href="https://github.com/betaveros/noulith" rel="alternate"></link>
    <summary type="html">&lt;p&gt;*slaps roof of [programming language]* this bad boy can fit so much [syntax sugar] into it&lt;/p&gt;&lt;hr&gt;&lt;p&gt;An attempt to give myself a new Pareto-optimal choice for quick-and-dirty scripts, particularly when I&#39;m not on a dev computer, and to practice writing a more realistic programming language instead of the &lt;a href=&#34;https://github.com/betaveros/paradoc&#34;&gt;overengineered stack-based nonsense&lt;/a&gt; I spend too much time on. (&lt;a href=&#34;https://craftinginterpreters.com/&#34;&gt;Crafting Interpreters&lt;/a&gt; is such a good book, I have no excuses.)&lt;/p&gt; &#xA;&lt;h2&gt;Elevator pitches (and anti-pitches)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Immutable data structures (but not variables) means you can write &lt;code&gt;matrix = [[0] ** 10] ** 10; matrix[1][2] = 3&lt;/code&gt; and not worry about it, instead of the &lt;code&gt;[[0] * 10 for _ in range(10)]&lt;/code&gt; you always have to do in Python. You can also freely use things as keys in dictionaries. But, thanks to mutate-or-copy-on-write shenanigans behind the scenes (powered by Rust&#39;s overpowered reference-counting pointers), you don&#39;t have to sacrifice the performance you&#39;d get from mutating lists. (There are almost certainly space leaks from cavalier use of &lt;code&gt;Rc&lt;/code&gt; but shhhhh.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Everything is an infix operator; nearly everything can be partially applied. If you thought Scala had a lot of syntax sugar, wait till you see what we&#39;ve got.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;noulith&amp;gt; 1 to 10 filter even map (3*)&#xA;[6, 12, 18, 24, 30]&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ever wanted to write &lt;code&gt;x max= y&lt;/code&gt; while searching for some maximum value in some complicated loop? You can do that here. You can do it with literally any function.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You know how Python has this edge case where you can write things like &lt;code&gt;{1}&lt;/code&gt; and &lt;code&gt;{1, 2}&lt;/code&gt; to get sets, but &lt;code&gt;{}&lt;/code&gt; is a dictionary because dictionaries came first? We don&#39;t have that problem because we don&#39;t distinguish sets and dictionaries.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Operator precedence is customizable and resolved at runtime.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;noulith&amp;gt; f := \-&amp;gt; 2 + 5 * 3&#xA;noulith&amp;gt; f()&#xA;17&#xA;noulith&amp;gt; swap +, *&#xA;noulith&amp;gt; f() # (2 times 5) plus 3&#xA;13&#xA;noulith&amp;gt; swap +[&#34;precedence&#34;], *[&#34;precedence&#34;]&#xA;noulith&amp;gt; f() # 2 times (5 plus 3)&#xA;16&#xA;noulith&amp;gt; swap +, *&#xA;noulith&amp;gt; f() # (2 plus 5) times 3&#xA;21&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Imagine all the &lt;a href=&#34;https://adventofcode.com/2020/day/18&#34;&gt;operator parsing&lt;/a&gt; code you won&#39;t need to write. When you need like arbitrarily many levels of operator precedence, and are happy to &lt;code&gt;eval&lt;/code&gt; inputs.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How do you run this thing?&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s a standard Rust project, so, in brief:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;Install Rust&lt;/a&gt; and set it up&lt;/li&gt; &#xA; &lt;li&gt;Clone this repository, &lt;code&gt;cd&lt;/code&gt; to it&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo run --release --features cli,request,crypto&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This will drop you into a REPL, or you can pass a filename to run it. If you just want to build an executable so you can alias it or add it to &lt;code&gt;$PATH&lt;/code&gt;, just run &lt;code&gt;cargo build --release --features cli,request,crypto&lt;/code&gt; and look inside &lt;code&gt;target/release&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;None of the command-line options to &lt;code&gt;cargo run&lt;/code&gt; or &lt;code&gt;cargo build&lt;/code&gt; are required; they just give you better run-time performance and features for a slower compile time and larger binary size. (Without &lt;code&gt;--release&lt;/code&gt;, stack frames are so large that one of the tests overflows the stack...)&lt;/p&gt; &#xA;&lt;h2&gt;Features (and anti-features) (and claims that will become false as I keep hacking on this)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dynamically typed.&lt;/li&gt; &#xA; &lt;li&gt;Not whitespace- or indentation-sensitive (except for delimiting tokens, of course, but that does matter more than is common: operator symbols can be strung together freely like Haskell or Scala). In particular, newlines don&#39;t mean anything; semicolons everywhere. (I can foresee myself regretting this choice so we might revisit it later.)&lt;/li&gt; &#xA; &lt;li&gt;Declare variables with &lt;code&gt;:=&lt;/code&gt;. (I never would have considered this on my own, but then I read the &lt;a href=&#34;https://craftinginterpreters.com/statements-and-state.html#design-note&#34;&gt;Crafting Interpreters design note&lt;/a&gt; and was just totally convinced.)&lt;/li&gt; &#xA; &lt;li&gt;List concatenation is &lt;code&gt;++&lt;/code&gt;. String concatenation is &lt;code&gt;$&lt;/code&gt;. Maybe? Not sure yet.&lt;/li&gt; &#xA; &lt;li&gt;Things that introduce scopes: functions, loops, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, apparently.&lt;/li&gt; &#xA; &lt;li&gt;Everything is an expression.&lt;/li&gt; &#xA; &lt;li&gt;No classes or members or whatever, it&#39;s just global functions all the way down. Or up.&lt;/li&gt; &#xA; &lt;li&gt;I already said this, but operator precedence is resolved at runtime.&lt;/li&gt; &#xA; &lt;li&gt;At the highest level, statements are C/Java/Scala-style &lt;code&gt;if (condition) body else body&lt;/code&gt;, &lt;code&gt;for (thing) body&lt;/code&gt; (not the modern &lt;code&gt;if cond { body }&lt;/code&gt;). The &lt;code&gt;if ... else&lt;/code&gt; is the ternary expression.&lt;/li&gt; &#xA; &lt;li&gt;Lists and dictionaries should look familiar from Python. Lists are brackets: &lt;code&gt;[a, b, c]&lt;/code&gt;. Dictionaries are curly braces: &lt;code&gt;{a, b, c}&lt;/code&gt;. We don&#39;t bother with a separate set type, but dictionaries often behave quite like their sets of keys.&lt;/li&gt; &#xA; &lt;li&gt;For loops use left arrows: &lt;code&gt;for (x &amp;lt;- xs) ...&lt;/code&gt;. Use a double-headed arrow for index-value or key-value pairs: &lt;code&gt;for (i, x &amp;lt;&amp;lt;- xs) ...&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Prefix operators are wonky. When in doubt, parenthesize the operand: &lt;code&gt;a + -(b)&lt;/code&gt;; &lt;code&gt;x and not(y)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Lambdas look like &lt;code&gt;\x, y -&amp;gt; x + y&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Somewhat imperative:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;for (x &amp;lt;- 1 to 100) (&#xA;  o := &#39;&#39;;&#xA;  for (f, s &amp;lt;- [[3, &#39;Fizz&#39;], [5, &#39;Buzz&#39;]])&#xA;    if (x % f == 0)&#xA;      o $= s;&#xA;  print(if (o == &#39;&#39;) x else o)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Somewhat functional:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;for (x &amp;lt;- 1 to 100) print([[3, &#39;Fizz&#39;], [5, &#39;Buzz&#39;]] map (\(f, s) -&amp;gt; if (x % f == 0) s else &#34;&#34;) join &#34;&#34; or x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;More in-depth tour&lt;/h2&gt; &#xA;&lt;p&gt;NOTE: I will probably keep changing the language and may not keep all this totally up to date.&lt;/p&gt; &#xA;&lt;p&gt;Numbers, arithmetic operators, and comparisons mostly work as you&#39;d expect, including C-style bitwise operators, except that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;^&lt;/code&gt; is exponentiation. Instead, &lt;code&gt;~&lt;/code&gt; as a binary operator is xor (but can still be unary as bitwise complement). Or you can just use &lt;code&gt;xor&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/&lt;/code&gt; does perfect rational division like in Common Lisp or something. &lt;code&gt;%&lt;/code&gt; does C-style signed modulo. &lt;code&gt;//&lt;/code&gt; does integer division rounding down, and &lt;code&gt;%%&lt;/code&gt; does the paired modulo (roughly).&lt;/li&gt; &#xA; &lt;li&gt;The precedence is something somewhat reasonable and simpler, inspired by Go&#39;s precedence, rather than following C&#39;s legacy:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Tighter ^ &amp;lt;&amp;lt; &amp;gt;&amp;gt;&#xA;        * / % &amp;amp;&#xA;        + - ~&#xA;        |&#xA;Looser  == != &amp;lt; &amp;gt; &amp;lt;= &amp;gt;=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We support arbitrary radixes up to 36 with syntax &lt;code&gt;36r1000 == 36^3&lt;/code&gt;, plus specifically the slightly weird base-64 &lt;code&gt;64rBAAA == 64^3&lt;/code&gt; (because in base-64 &lt;code&gt;A&lt;/code&gt; is 0, &lt;code&gt;B&lt;/code&gt; is 1, etc.)&lt;/p&gt; &#xA;&lt;p&gt;Like in Python and mathematics, comparison operators can be chained like &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt;; we explain how this works later. We also have &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, and the three-valued comparison operator &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and its reverse &lt;code&gt;&amp;gt;=&amp;lt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;End-of-line comments: &lt;code&gt;#&lt;/code&gt; (not immediately followed by &lt;code&gt;(&lt;/code&gt;). Range comments: &lt;code&gt;#( ... )&lt;/code&gt;. Those count parentheses so can be nested.&lt;/p&gt; &#xA;&lt;p&gt;Strings: &lt;code&gt;&#34;&lt;/code&gt; or &lt;code&gt;&#39;&lt;/code&gt;. (What will we use the backtick for one day, I wonder.) Also like in Python, we don&#39;t have a separate character type; iterating over a string just gives single-character strings.&lt;/p&gt; &#xA;&lt;p&gt;Data types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Null&lt;/li&gt; &#xA; &lt;li&gt;Numbers: big integers, rationals, floats, and complex numbers, which coerce from left to right in that list as needed. Note that there are no booleans, we just use 0 and 1.&lt;/li&gt; &#xA; &lt;li&gt;Lists (heterogeneous): &lt;code&gt;[a, b]&lt;/code&gt;. Pythonic indexing and slicing, both in syntax and semantics of negative integers. Assigning to slices is indefinitely unimplemented.&lt;/li&gt; &#xA; &lt;li&gt;Dictionaries (heterogeneous): &lt;code&gt;{a: b, c: d}&lt;/code&gt;. (Valid JSON is valid Noulith, maybe modulo the same kind of weird whitespace issues that make valid JSON not valid JavaScript.) Values can be omitted, in which case they&#39;re just &lt;code&gt;null&lt;/code&gt;, and are used like sets. Index &lt;code&gt;my_dict[key]&lt;/code&gt;, test &lt;code&gt;key in my_dict&lt;/code&gt;. If you add a &lt;code&gt;{:a}&lt;/code&gt;, that&#39;s the default value.&lt;/li&gt; &#xA; &lt;li&gt;Strings: just what Rust has, always valid UTF-8 sequences of bytes&lt;/li&gt; &#xA; &lt;li&gt;Bytes&lt;/li&gt; &#xA; &lt;li&gt;Vectors: lists of numbers, notable in that most operations on these automatically vectorize/broadcast, e.g. &lt;code&gt;V(2, 3) + V(4, 5) == V(6, 8)&lt;/code&gt;; &lt;code&gt;V(2, 3) + 4 == V(6, 7)&lt;/code&gt;. (Note that comparison operators don&#39;t vectorize!)&lt;/li&gt; &#xA; &lt;li&gt;Streams: lazy lists, only generated in a few specific situations for now. Most higher-order functions are eager.&lt;/li&gt; &#xA; &lt;li&gt;Functions, which carry with them a precedence. Fun!&lt;/li&gt; &#xA; &lt;li&gt;Structs!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Expressions&lt;/h3&gt; &#xA;&lt;p&gt;Everything is a global function and can be used as an operator! For example &lt;code&gt;a + b&lt;/code&gt; is really just &lt;code&gt;+(a, b)&lt;/code&gt;; &lt;code&gt;a max b&lt;/code&gt; is &lt;code&gt;max(a, b)&lt;/code&gt;. As a special case, &lt;code&gt;a b&lt;/code&gt; (when fenced by other syntax that prevents treating either as binary operator) is &lt;code&gt;a(b)&lt;/code&gt; (this is mainly to allow unary minus), but four or more evenly-many identifiers and similar things in a row like &lt;code&gt;(a b c d)&lt;/code&gt; is illegal. (Also, beware that &lt;code&gt;a[b]&lt;/code&gt; parses as indexing &lt;code&gt;b&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt;, not &lt;code&gt;a([b])&lt;/code&gt; like you might sometimes hope if you start relying on this too much.) Also:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Many functions/operators that normally accept two arguments also accept just one and partially-apply it as their second, e.g. &lt;code&gt;+(3)&lt;/code&gt; (which, as above, can be written &lt;code&gt;+3&lt;/code&gt; in the right context) is a function that adds 3. (This is not special syntax, just opt-in from many functions; &lt;code&gt;+&lt;/code&gt; is defined to take one or two arguments and if it takes one it partially applies itself.) Since &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; have unary overloads, we provide alternatives &lt;code&gt;subtract&lt;/code&gt; and &lt;code&gt;xor&lt;/code&gt; that do partially apply when called with one argument, just like in Haskell.&lt;/li&gt; &#xA; &lt;li&gt;If you call &lt;code&gt;a(b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; isn&#39;t a function but &lt;code&gt;b&lt;/code&gt; is, &lt;code&gt;b&lt;/code&gt; partially applies &lt;code&gt;a&lt;/code&gt; as its first argument! It&#39;s just like Haskell sections. For a slightly more verbose / less mystical way to do this, you can use Scala-style &lt;code&gt;_&lt;/code&gt;, see below.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(Sort of considering removing some of the partial application stuff now that &lt;code&gt;_&lt;/code&gt;s work... hmm...)&lt;/p&gt; &#xA;&lt;p&gt;Operator precedence is determined at runtime! This is mainly to support chained comparisons: &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; works like in Python. Functions can decide at runtime when they chain (though there&#39;s no way for user-defined functions to do this yet), and we use this to make a few other functions nicer. For example, &lt;code&gt;zip&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; (cartesian product) chain with themselves; &lt;code&gt;a ** b ** c&lt;/code&gt; and &lt;code&gt;a zip b zip c&lt;/code&gt; will give you a list of triplets, instead of a bunch of &lt;code&gt;[[x, y], z]&lt;/code&gt;-shaped things.&lt;/p&gt; &#xA;&lt;p&gt;Identifiers can consist of a letter or &lt;code&gt;_&lt;/code&gt; followed by any number of alphanumerics, &lt;code&gt;&#39;&lt;/code&gt;, or &lt;code&gt;?&lt;/code&gt;; or any consecutive number of valid symbols for use in operators, including &lt;code&gt;?&lt;/code&gt;. (So e.g. &lt;code&gt;a*-1&lt;/code&gt; won&#39;t work because &lt;code&gt;*-&lt;/code&gt; will be parsed as a single token. &lt;code&gt;a* -1&lt;/code&gt; won&#39;t work either, but for a different reason — it parses like it begins with calling &lt;code&gt;*&lt;/code&gt; with &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; as arguments. &lt;code&gt;a*(-1)&lt;/code&gt; or &lt;code&gt;a* -(1)&lt;/code&gt; would work.) Compared to similar languages, note that &lt;code&gt;:&lt;/code&gt; is not a legal character to use in operators, while &lt;code&gt;$&lt;/code&gt; is. In addition, a bunch of keywords are forbidden, as are all single-letter uppercase letters and tokens beginning with single-letter uppercase letters immediately followed by a single quote (though these are just reserved and the language doesn&#39;t recognize all of them yet); &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt;, &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;-&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt;. Also, with the exception of &lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;, operators ending in &lt;code&gt;=&lt;/code&gt; will be parsed as the operator followed by an &lt;code&gt;=&lt;/code&gt;, so in general operators cannot end with &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Almost all builtin functions&#39; precedences are determined by this Scala-inspired rule: Look up each character in the function&#39;s name in this table, then take the &lt;em&gt;loosest&lt;/em&gt; precedence of any individual character. But note that this isn&#39;t a rule in the syntax, it&#39;s just a strategy I decided to follow when selecting builtin functions&#39; precedences. For example, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;.+&lt;/code&gt;, and &lt;code&gt;+.&lt;/code&gt; all have the same precedence. As of time of writing, the only exceptions to this rule are &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, which have precedence like &lt;code&gt;^&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Tighter . (every other symbol, mainly @ which I haven&#39;t allocated yet)&#xA;        !?&#xA;        ^&#xA;        */%&amp;amp;&#xA;        +-~&#xA;        |&#xA;        $&#xA;        =&amp;lt;&amp;gt;&#xA;Looser  (alphanumerics)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;.&lt;/code&gt; is not special syntax, it&#39;s actually just an operator that does tightly-binding reverse function application! &lt;code&gt;a.b = b(a)&lt;/code&gt;. &lt;code&gt;then&lt;/code&gt; is loosely-binding reverse function application.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;!&lt;/code&gt; is syntax that&#39;s spiritually sort of like what Haskell&#39;s &lt;code&gt;$&lt;/code&gt; lets you write. It&#39;s as tight as an opening parenthesis on its left, but performs a function call that lets you can omit the closing one up to the next semicolon or so. &lt;code&gt;f! a, b&lt;/code&gt; is &lt;code&gt;f(a, b)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;_&lt;/code&gt; is special; assigning to it discards (but type checks still happen; see below). Some expressions produce Scala-style anonymous functions, e.g. &lt;code&gt;1 &amp;lt; _ &amp;lt; 3&lt;/code&gt;, &lt;code&gt;[_, 2]&lt;/code&gt;, &lt;code&gt;_[3]&lt;/code&gt;. I might implement more later.&lt;/p&gt; &#xA;&lt;p&gt;Types double as conversion functions: &lt;code&gt;str(3)&lt;/code&gt; &lt;code&gt;int(3)&lt;/code&gt; &lt;code&gt;dict([[1, 2], [3, 4]])&lt;/code&gt; etc. Bending internal consistency for pure syntax sweetness, &lt;code&gt;to&lt;/code&gt; is overloaded to takes a type as its second argument to call the same conversion. Test types explicitly with &lt;code&gt;is&lt;/code&gt;: &lt;code&gt;3 is int&lt;/code&gt;, &lt;code&gt;int is type&lt;/code&gt;. The type of &lt;code&gt;null&lt;/code&gt; is &lt;code&gt;nulltype&lt;/code&gt;. Strings are &lt;code&gt;str&lt;/code&gt; and functions are &lt;code&gt;func&lt;/code&gt;. The &#34;top&#34; type is &lt;code&gt;anything&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We got &lt;code&gt;eval&lt;/code&gt;, a dumb dynamic guy; &lt;code&gt;vars&lt;/code&gt; for examining local variables; &lt;code&gt;assert&lt;/code&gt;, which is currently a silly function and will probably become a keyword so it can inspect the expression being asserted.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;freeze&lt;/code&gt; is a wonky keyword that goes through an expression and eagerly resolves each free variable to what it points to outside. It can slightly optimize some functions, surface some name errors earlier, and more elegantly(??) handle some binding acrobatics that you might have to write IIFEs for in other languages.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;import&lt;/code&gt; statement takes a filename and approximately just parses it and splices it in where written, sort of like how C/C++&#39;s &lt;code&gt;#include&lt;/code&gt; works. This is an awful hack and might be fixed one day.&lt;/p&gt; &#xA;&lt;h3&gt;Variables and assignments&lt;/h3&gt; &#xA;&lt;p&gt;Declare with &lt;code&gt;:=&lt;/code&gt;, assign with &lt;code&gt;=&lt;/code&gt;. (Statements must be separated by semicolons.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x := 0; x = 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Actually &lt;code&gt;:=&lt;/code&gt; is just a declaration with an empty type. You can declare typed variables like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x : int = 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pythonically, sequences can be unpacked with commas, including a single trailing comma for a single-element unpack. Type annotations are looser than commas, so below, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both ints. Prefix &lt;code&gt;...&lt;/code&gt; to pack/unpack multiple things, and likewise in function calls.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x, y : int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can declare in an assignment with a parenthesized annotation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a := 0&#xA;a, (c:) = 1, 2&#xA;a, (d:int) = 3, 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These are checked at runtime! Assigning non-&lt;code&gt;int&lt;/code&gt;s to x will throw an error. Hopefully. This is useful in other scenarios.&lt;/p&gt; &#xA;&lt;p&gt;You can also do operator-assignments like you&#39;d expect, with &lt;em&gt;any&lt;/em&gt; operator! &lt;code&gt;a f= b&lt;/code&gt; is basically just &lt;code&gt;a = f(a, b)&lt;/code&gt;. Note that the left side is parsed just like a call &lt;code&gt;a(f)&lt;/code&gt;, so the operator can even be parenthesized: after&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x := [1, 2]; x (zip+)= [3, 4]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;x&lt;/code&gt; is &lt;code&gt;[4, 6]&lt;/code&gt;. In particular when you want to write &lt;code&gt;a = f(a)&lt;/code&gt; you can just write &lt;code&gt;a .= f&lt;/code&gt; because &lt;code&gt;.&lt;/code&gt; is function application.&lt;/p&gt; &#xA;&lt;p&gt;One corner case in the semantics here: While the operator is being called, the LHS variable will be null. That is, the following code will print &lt;code&gt;null&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x := 0&#xA;f := \a -&amp;gt; (print x; a)&#xA;x .= f&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows us to not have to keep an extra copy of the LHS variable in common cases where we &#34;modify&#34; it, so code like &lt;code&gt;x append= y&lt;/code&gt; is actually efficient (see discussion of immutability below).&lt;/p&gt; &#xA;&lt;p&gt;The weird keyword &lt;code&gt;every&lt;/code&gt; lets you assign to or operate on multiple variables or elements of a slice at once. This initializes three variables to &lt;code&gt;1&lt;/code&gt;. This doesn&#39;t work with operator-assignments, though it might in the future.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;every a, b, c := 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After this, &lt;code&gt;x == [0, 0, 1, 1, 0]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x := [0] ** 5; every x[2:4] = 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Important note about assignment: &lt;strong&gt;All data structures are immutable.&lt;/strong&gt; When we mutate indexes, we make a fresh copy to mutate if anything else points to the same data structure. So for example, after&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x := [1, 2, 3];&#xA;y := x;&#xA;x[0] = 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;y&lt;/code&gt; will still be &lt;code&gt;[1, 2, 3]&lt;/code&gt;. You may wish to think of &lt;code&gt;x[0] = 4&lt;/code&gt; as syntax sugar for &lt;code&gt;x = [4] ++ x[1:]&lt;/code&gt;, although when nothing else refers to the same list, it&#39;s actually as fast as a mutation.&lt;/p&gt; &#xA;&lt;p&gt;As a consequence, calling a function on a data structure cannot mutate it. There are a few special keywords that mutate whatever they&#39;re given. There&#39;s &lt;code&gt;swap&lt;/code&gt; like &lt;code&gt;swap x, y&lt;/code&gt; for swapping two values; there&#39;s &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; for mutating sequences; and the crudest instrument of all, &lt;code&gt;consume&lt;/code&gt; gives you the value after replacing it in where it came from with &lt;code&gt;null&lt;/code&gt;. After&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x := [1, 2, 3, 4, 5];&#xA;y := pop x;&#xA;z := remove x[0]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;y&lt;/code&gt; will be &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;[2, 3, 4]&lt;/code&gt;. There&#39;s no way to implement &lt;code&gt;pop&lt;/code&gt; as a function yourself; the best you could do is take a list and separately return the last element and everything before it.&lt;/p&gt; &#xA;&lt;p&gt;You can implement your own &#34;mutable data cells&#34; easily (?) with a closure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make_cell := \init -&amp;gt; (x := init; [\ -&amp;gt; x, \y -&amp;gt; (x = y)])&#xA;get_a, set_a := make_cell(0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Control Flow&lt;/h3&gt; &#xA;&lt;p&gt;As above: statements must be separated by semicolons.&lt;/p&gt; &#xA;&lt;p&gt;Everything is an expression, so the &#34;ternary expression&#34; and if/else statement are one and the same: &lt;code&gt;if (a) b else c&lt;/code&gt;. Loops: &lt;code&gt;for (var &amp;lt;- list) body&lt;/code&gt;; &lt;code&gt;while (cond) body&lt;/code&gt;. For loops can have many iteration clauses: &lt;code&gt;for (a &amp;lt;- b; c &amp;lt;- d)&lt;/code&gt;. Several other clauses are supported: &lt;code&gt;for (p &amp;lt;&amp;lt;- m)&lt;/code&gt; iterates over index-value or key-value pairs, &lt;code&gt;for (x := y)&lt;/code&gt; declares a variable in the middle, and &lt;code&gt;for (if x)&lt;/code&gt; is a guard. Finally &lt;code&gt;for&lt;/code&gt; loops can &lt;code&gt;yield&lt;/code&gt; (only the entire body, not inside a more complicated expression) to turn into a list comprehension, like Scala: &lt;code&gt;for (x &amp;lt;- xs) yield x + 1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are no &#34;blocks&#34;; just use more parentheses: &lt;code&gt;if (a) (b; c; d)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We have short-circuiting, quite-low-precedence &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;. We also have &lt;code&gt;coalesce&lt;/code&gt;, which is similar to &lt;code&gt;or&lt;/code&gt;, but it only takes its RHS if its LHS is precisely &lt;code&gt;null&lt;/code&gt;, not other falsy things. Note &lt;code&gt;not&lt;/code&gt; is just a normal function.&lt;/p&gt; &#xA;&lt;p&gt;Switch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;switch (x)&#xA;case 1 -&amp;gt; b&#xA;case 2 -&amp;gt; d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run-time type checking does some work here:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;switch (x)&#xA;case _: int -&amp;gt; print(&#34;it&#39;s an int&#34;)&#xA;case _ -&amp;gt; print(&#34;not sure&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Stupid complicated runtime types with &lt;code&gt;satisfying&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;switch (x)&#xA;case _: satisfying! 1 &amp;lt; _ &amp;lt; 9 -&amp;gt; print(&#34;it&#39;s between 1 and 9&#34;)&#xA;case _ -&amp;gt; print(&#34;not sure&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Don&#39;t do weird things in the argument to &lt;code&gt;satisfying&lt;/code&gt;, it&#39;s illegal. (Also actually you can just write this because the comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt; have yet another layer of magic — &lt;code&gt;1 &amp;lt; _ &amp;lt; 9&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a lambda here; you could have actually replaced &lt;code&gt;_&lt;/code&gt; with a named variable to bind it.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;switch (x)&#xA;case 1 &amp;lt; _ &amp;lt; 9 -&amp;gt; print(&#34;it&#39;s between 1 and 9&#34;)&#xA;case _ -&amp;gt; print(&#34;not sure&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Try-catch: &lt;code&gt;try a catch x -&amp;gt; y&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;break&lt;/code&gt; &lt;code&gt;continue&lt;/code&gt; &lt;code&gt;return&lt;/code&gt; work.&lt;/p&gt; &#xA;&lt;p&gt;Only lambdas exist, declare all functions this way: &lt;code&gt;\a, b -&amp;gt; c&lt;/code&gt;. You can annotate parameters and otherwise pattern match in functions as you&#39;d expect: &lt;code&gt;\a: int, (b, c) -&amp;gt; d&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Structs&lt;/h3&gt; &#xA;&lt;p&gt;Super bare-bones product types right now. No methods or namespaces or anything. (Haskell survived without them for a few decades, we can procrastinate.) You can&#39;t even give fields types or default values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;struct Foo (bar, baz);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can construct an all-null instance &lt;code&gt;Foo()&lt;/code&gt; or all values with &lt;code&gt;Foo(a, b)&lt;/code&gt;. &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are now member access functions, or if you have a &lt;code&gt;foo&lt;/code&gt; of type &lt;code&gt;Foo&lt;/code&gt;, you can access, assign, or modify the fields as &lt;code&gt;foo[bar]&lt;/code&gt; and &lt;code&gt;foo[baz]&lt;/code&gt;. To be clear, these names really are not namespaced at all; &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are new variables holding functions in whatever scope you declared this struct in, and can be passed around as functions in their own right, assigned to variables, etc. (but won&#39;t work on any other struct).&lt;/p&gt; &#xA;&lt;h3&gt;Sequence operators&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;len&lt;/code&gt; for length.&lt;/p&gt; &#xA;&lt;p&gt;Most operators for working with lists/dictionaries/other sequences are two characters, doubled or involving a &lt;code&gt;.&lt;/code&gt; on the side of an individual element:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;List concatenation is &lt;code&gt;++&lt;/code&gt;. You can combine individual elements with lists with &lt;code&gt;+.&lt;/code&gt;, &lt;code&gt;.+&lt;/code&gt;, and &lt;code&gt;..&lt;/code&gt;, e.g. &lt;code&gt;[1, 2] +. 3 == [1, 2, 3]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Replicate is &lt;code&gt;.*&lt;/code&gt;, e.g. &lt;code&gt;2 .* 3 == [2, 2, 2]&lt;/code&gt;. List multiplication or (n-ary) cartesian product is &lt;code&gt;**&lt;/code&gt;. Cartesian exponentiation (?) is &lt;code&gt;^^&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Dictionary union, intersection, and subtraction are &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, and &lt;code&gt;--&lt;/code&gt;; &lt;code&gt;|.&lt;/code&gt; and &lt;code&gt;|..&lt;/code&gt; and &lt;code&gt;-.&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Indexing, alternatives to &lt;code&gt;a[b]&lt;/code&gt; syntax: &lt;code&gt;!!&lt;/code&gt; and &lt;code&gt;!?&lt;/code&gt; for or-null (these are Haskell-isms roughly); &lt;code&gt;!%&lt;/code&gt; for mod the length.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tail&lt;/code&gt; &lt;code&gt;first&lt;/code&gt; &lt;code&gt;second&lt;/code&gt; &lt;code&gt;third&lt;/code&gt; &lt;code&gt;last&lt;/code&gt; &lt;code&gt;take&lt;/code&gt; &lt;code&gt;drop&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Get keys, values: &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;. Get index/key-value pairs: &lt;code&gt;enumerate&lt;/code&gt;, &lt;code&gt;items&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;String concatenation is &lt;code&gt;$&lt;/code&gt;. It has quite low precedence and coerces things to strings. String multiplication &lt;code&gt;$*&lt;/code&gt; / &lt;code&gt;*$&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Ranges: &lt;code&gt;a til b&lt;/code&gt; is exclusive, &lt;code&gt;a to b&lt;/code&gt; is inclusive. Both use chaining to allow &lt;code&gt;a til b by c&lt;/code&gt;. &lt;code&gt;iota a&lt;/code&gt; counts from &lt;code&gt;a&lt;/code&gt; up. These are all lazy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;unique&lt;/code&gt;. &lt;code&gt;set&lt;/code&gt; &#34;converts to a set&#34;. &lt;code&gt;transpose&lt;/code&gt;. &lt;code&gt;prefixes&lt;/code&gt; &lt;code&gt;suffixes&lt;/code&gt; &lt;code&gt;frequencies&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;lower&lt;/code&gt;; &lt;code&gt;is_upper&lt;/code&gt;, ...&lt;/li&gt; &#xA; &lt;li&gt;strings: &lt;code&gt;split&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt;, &lt;code&gt;strip&lt;/code&gt;, &lt;code&gt;starts_with&lt;/code&gt;, &lt;code&gt;ends_with&lt;/code&gt;. Split always takes two arguments, a string and a separator, common splits and joins are like in Haskell, &lt;code&gt;words&lt;/code&gt;/&lt;code&gt;unwords&lt;/code&gt;/&lt;code&gt;lines&lt;/code&gt;/&lt;code&gt;unlines&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some functions to make streams: &lt;code&gt;repeat&lt;/code&gt; &lt;code&gt;cycle&lt;/code&gt; &lt;code&gt;permutations&lt;/code&gt; &lt;code&gt;combinations&lt;/code&gt; &lt;code&gt;subsequences&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;start iterate func&lt;/code&gt; swallows, plus you can cause weird borrow errors if the function is weird. Don&#39;t do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x := iterate! 0, \t -&amp;gt; x const t&#xA;x[0] = 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Functional programming&lt;/h3&gt; &#xA;&lt;p&gt;All the usuals and some weird ones: &lt;code&gt;each&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flat_map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;reject&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;find&lt;/code&gt;/&lt;code&gt;find?&lt;/code&gt;, &lt;code&gt;locate&lt;/code&gt;/&lt;code&gt;locate?&lt;/code&gt; (finds the index of something), &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;take&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;zip&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;group&lt;/code&gt;. These take the function as the second argument / on the right! Also they&#39;re eager!&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;zip&lt;/code&gt;, &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;window&lt;/code&gt; have overloads that don&#39;t take functions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;zip&lt;/code&gt; is n-ary and can take a function to zip with too (which gets all arguments); you can also use &lt;code&gt;with&lt;/code&gt;. &lt;code&gt;merge&lt;/code&gt; is similar but for like-keyed entries of dictionaries. &lt;code&gt;ziplongest&lt;/code&gt; is like &lt;code&gt;zip&lt;/code&gt;, but, well, the longest; and when there&#39;s a function it&#39;s used to reduce all the remaining elements, two at a time, instead of called with all of them at once.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;fold&lt;/code&gt;/&lt;code&gt;reduce&lt;/code&gt; (which are the same) require a nonempty sequence with two arguments, but also chain with an optional &lt;code&gt;from&lt;/code&gt; starting value, e.g. &lt;code&gt;x fold * from 1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sort&lt;/code&gt; takes a three-valued comparator, which you can get by &lt;code&gt;&amp;lt;=&amp;gt; on&lt;/code&gt; some key function. Or &lt;code&gt;&amp;gt;=&amp;lt;&lt;/code&gt; for backwards. Sorry, no built-in Schwartzian transform yet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[[1], [2, 3, 4], [5, 6]] sort_by (&amp;lt;=&amp;gt; on len)&#xA;\1: [[1], [5, 6], [2, 3, 4]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other goodies: &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; (returns its second argument!), &lt;code&gt;flip&lt;/code&gt;. Some Haskell-Arrow-esque operators exist: &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;***&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;. The first two are n-ary like &lt;code&gt;zip&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;I/O and interfacing with the world&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;print&lt;/code&gt;: space-separated newline-terminated&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;echo&lt;/code&gt;: space-separated&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;write&lt;/code&gt;: just concatenated&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;debug&lt;/code&gt;: debug&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;input&lt;/code&gt;: read line&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;read&lt;/code&gt;: read all&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;read_file&lt;/code&gt; &lt;code&gt;read_file?&lt;/code&gt; &lt;code&gt;read_file_bytes&lt;/code&gt; &lt;code&gt;read_file_bytes?&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;write_file&lt;/code&gt; &lt;code&gt;append_file&lt;/code&gt; These take the file as the second argument to better support partial application, but I feel like I&#39;ll regret this soon.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;(current implementation completely disrespects cross-OS unicode things) &lt;code&gt;path_join&lt;/code&gt; &lt;code&gt;path_parent&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;time&lt;/code&gt; &lt;code&gt;now&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If compiled with &lt;code&gt;request&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;request(&#34;https://httpbin.org/&#34;, {&#34;method&#34;: &#34;POST&#34;, &#34;headers&#34;: {&#34;Foo&#34;: &#34;Bar&#34;}})&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>mifi/lossless-cut</title>
    <updated>2022-12-16T01:29:22Z</updated>
    <id>tag:github.com,2022-12-16:/mifi/lossless-cut</id>
    <link href="https://github.com/mifi/lossless-cut" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The swiss army knife of lossless video/audio editing&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;br&gt; &#xA; &lt;br&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://mifi.no/losslesscut/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/src/icon.svg?sanitize=true&#34; width=&#34;130&#34; alt=&#34;LosslessCut&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;b&gt;LosslessCut&lt;/b&gt;&lt;/p&gt; The swiss army knife of lossless video/audio editing &#xA; &lt;br&gt; &#xA; &lt;img src=&#34;https://github.com/mifi/lossless-cut/workflows/Build/release/badge.svg?sanitize=true&#34;&gt; &#xA; &lt;a href=&#34;https://paypal.me/mifino/usd&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Donate-PayPal-green.svg?sanitize=true&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;https://github.com/mifi/lossless-cut#download&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/mifi/lossless-cut&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;https://discord.gg/fhnEREfUJ3&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/986051448385183804&#34;&gt;&lt;/a&gt; &#xA; &lt;br&gt; &#xA; &lt;br&gt; &#xA; &lt;a href=&#34;https://mifi.no/thanks/&#34;&gt;Thanks to my supporters&lt;/a&gt; and everyone who purchased LosslessCut! &#xA; &lt;br&gt; &#xA; &lt;br&gt; &#xA; &lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://github.com/mifi/lossless-cut/raw/master/main_screenshot.jpg&#34; width=&#34;600&#34; alt=&#34;screenshot&#34;&gt;&lt;/p&gt; &#xA; &lt;br&gt; &#xA; &lt;br&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;LosslessCut aims to be the ultimate cross platform FFmpeg GUI for extremely fast and lossless operations on video, audio, subtitle and other related media files. The main feature is lossless trimming and cutting of video and audio files, which is great for saving space by rough-cutting your large video files taken from a video camera, GoPro, drone, etc. It lets you quickly extract the good parts from your videos and discard many gigabytes of data without doing a slow re-encode and thereby losing quality. Or you can add a music or subtitle track to your video without needing to encode. Everything is extremely fast because it does an almost direct data copy, fueled by the awesome FFmpeg which does all the grunt work.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lossless cutting of most video and audio formats&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mifi/lossless-cut/issues/126&#34;&gt;Smart cut&lt;/a&gt; (experimental)&lt;/li&gt; &#xA; &lt;li&gt;Losslessly cut out parts of video/audio (for cutting away commercials etc.)&lt;/li&gt; &#xA; &lt;li&gt;Losslessly rearrange the order of video/audio segments&lt;/li&gt; &#xA; &lt;li&gt;Lossless merge/concatenation of arbitrary files (with identical codecs parameters, e.g. from the same camera)&lt;/li&gt; &#xA; &lt;li&gt;Lossless stream editing &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Combine arbitrary tracks from multiple files (ex. add music or subtitle track to a video file)&lt;/li&gt; &#xA;   &lt;li&gt;Remove unneeded tracks&lt;/li&gt; &#xA;   &lt;li&gt;Replace or re-encode only some tracks&lt;/li&gt; &#xA;   &lt;li&gt;Extract all tracks from a file (extract video, audio, subtitle, attachments and other tracks from one file into separate files)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Batch view for fast multi-file workflow&lt;/li&gt; &#xA; &lt;li&gt;Keyboard shortcut workflow&lt;/li&gt; &#xA; &lt;li&gt;Losslessly remux video/audio into a different container (file) format&lt;/li&gt; &#xA; &lt;li&gt;Take full-resolution snapshots from videos in JPEG/PNG format, or export ranges of video frames to images&lt;/li&gt; &#xA; &lt;li&gt;Manual input of cutpoint times&lt;/li&gt; &#xA; &lt;li&gt;Apply a per-file timecode offset (and auto load timecode from file)&lt;/li&gt; &#xA; &lt;li&gt;Edit file metadata, per-track metadata and per-track disposition&lt;/li&gt; &#xA; &lt;li&gt;Change rotation/orientation metadata in videos&lt;/li&gt; &#xA; &lt;li&gt;View technical data about all tracks&lt;/li&gt; &#xA; &lt;li&gt;Timeline zoom and frame/keyframe jumping for cutting around keyframes&lt;/li&gt; &#xA; &lt;li&gt;Video thumbnails and audio waveform&lt;/li&gt; &#xA; &lt;li&gt;Saves per project cut segments to project file&lt;/li&gt; &#xA; &lt;li&gt;View FFmpeg last command log so you can modify and re-run recent commands on the command line&lt;/li&gt; &#xA; &lt;li&gt;Undo/redo&lt;/li&gt; &#xA; &lt;li&gt;Give labels to cut segments&lt;/li&gt; &#xA; &lt;li&gt;Annotate segments with tags&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/import-export.md&#34;&gt;Import/export&lt;/a&gt; segments: MP4/MKV chapter marks, Text file, YouTube, CSV, CUE, XML (DaVinci, Final Cut Pro) and more&lt;/li&gt; &#xA; &lt;li&gt;MKV/MP4 embedded chapters marks editor&lt;/li&gt; &#xA; &lt;li&gt;View subtitles&lt;/li&gt; &#xA; &lt;li&gt;Customizable keyboard hotkeys&lt;/li&gt; &#xA; &lt;li&gt;Black scene detection&lt;/li&gt; &#xA; &lt;li&gt;Divide timeline into segments with length L or into N segments or even randomized segments!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/cli.md&#34;&gt;Basic CLI support&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example lossless use cases&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cut out commercials from a recorded TV show (and re-format from TS to MP4)&lt;/li&gt; &#xA; &lt;li&gt;Remove audio tracks from a file&lt;/li&gt; &#xA; &lt;li&gt;Extract music track from a video and cut it to your needs&lt;/li&gt; &#xA; &lt;li&gt;Add music to a video (or replace existing audio track)&lt;/li&gt; &#xA; &lt;li&gt;Combine audio and video tracks from separate recordings&lt;/li&gt; &#xA; &lt;li&gt;Include an external subtitle into a video&lt;/li&gt; &#xA; &lt;li&gt;Quickly change a H264/H265 MKV video to MOV or MP4 for playback on iPhone&lt;/li&gt; &#xA; &lt;li&gt;Import a list of cut times from other tool as a EDL (edit decision list, CSV) and run these cuts with LosslessCut&lt;/li&gt; &#xA; &lt;li&gt;Export a list of cut times as a CSV EDL and process these in another tool&lt;/li&gt; &#xA; &lt;li&gt;Quickly cut a file by its MP4/MKV chapters&lt;/li&gt; &#xA; &lt;li&gt;Quickly cut a &lt;a href=&#34;https://youtube-dl.org/&#34;&gt;YouTube video&lt;/a&gt; by its chapters (or music times from a comment)&lt;/li&gt; &#xA; &lt;li&gt;Change the language of a file&#39;s audio/subtitle tracks&lt;/li&gt; &#xA; &lt;li&gt;Attach cover art / thumbnail to videos / audio from an external JPEG file or from a frame on the timeline&lt;/li&gt; &#xA; &lt;li&gt;Change author, title, GPS position, recording time of a video&lt;/li&gt; &#xA; &lt;li&gt;Fix rotation of a video that has the wrong orientation flag set &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Great for rotating phone videos that come out the wrong way without actually re-encoding the video.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Loop a video / audio clip X times quickly without re-encoding &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;See &lt;a href=&#34;https://github.com/mifi/lossless-cut/issues/284&#34;&gt;#284&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Convert a video or parts of it into X image files (not lossless)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Export cut times as YouTube Chapters&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Export with Merge and &#34;Create chapters from merged segments&#34; enabled&lt;/li&gt; &#xA; &lt;li&gt;Open the exported file and select &#34;Import chapters&#34; in the dialog&lt;/li&gt; &#xA; &lt;li&gt;File -&amp;gt; Export project -&amp;gt; YouTube Chapters&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Re-encode only the audio track, keeping the lossless video track&lt;/h3&gt; &#xA;&lt;p&gt;First export each track as individual files. Then use Handbrake or similar to re-encode the audio file (if mp4 file, encode as AAC.) Then open the extracted video stream in LosslessCut. The open your encoded audio file and select &#34;Include all tracks from the new file&#34;. Then export.&lt;/p&gt; &#xA;&lt;h3&gt;Advanced multi-step workflows&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; you can use LosslessCut in multiple passes in order to achieve separate trimming of individual tracks:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open a file an export all tracks as individual files&lt;/li&gt; &#xA; &lt;li&gt;Open the exported track files independently and cut them as desired&lt;/li&gt; &#xA; &lt;li&gt;Add the track back to the video and combine them to one output video&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;If you want to support my continued work on LosslessCut, and you want the advantage of a secure and simple installation process with automatic updates, consider getting it from your favorite store:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://apps.apple.com/app/id1505323402&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/mac-app-store-badge.svg?sanitize=true&#34; alt=&#34;Mac App Store&#34; height=&#34;50&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.microsoft.com/store/apps/9P30LSR4705L?cid=storebadge&amp;amp;ocid=badge&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/ms-store-badge.svg?sanitize=true&#34; alt=&#34;MS badge&#34; height=&#34;50&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For Linux these are some alternatives:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://snapcraft.io/losslesscut&#34;&gt;&lt;img src=&#34;https://snapcraft.io/static/images/badges/en/snap-store-black.svg?sanitize=true&#34; alt=&#34;Snapcraft&#34; height=&#34;50&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://flathub.org/apps/details/no.mifi.losslesscut&#34;&gt;&lt;img src=&#34;https://flathub.org/assets/badges/flathub-badge-en.png&#34; alt=&#34;Flathub&#34; height=&#34;50&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you prefer to download the executables manually, this will of course always be free:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mac OS X: &lt;a href=&#34;https://github.com/mifi/lossless-cut/releases/latest/download/LosslessCut-mac-x64.dmg&#34;&gt;Intel DMG&lt;/a&gt; / &lt;a href=&#34;https://github.com/mifi/lossless-cut/releases/latest/download/LosslessCut-mac-arm64.dmg&#34;&gt;Apple Silicon DMG&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Windows: &lt;a href=&#34;https://github.com/mifi/lossless-cut/releases/latest/download/LosslessCut-win-x64.7z&#34;&gt;7zip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Linux: &lt;a href=&#34;https://github.com/mifi/lossless-cut/releases/latest/download/LosslessCut-linux-x64.tar.bz2&#34;&gt;x64 tar.bz2&lt;/a&gt; / &lt;a href=&#34;https://github.com/mifi/lossless-cut/releases/latest/download/LosslessCut-linux-x86_64.AppImage&#34;&gt;x64 AppImage&lt;/a&gt; / &lt;a href=&#34;https://github.com/mifi/lossless-cut/releases/latest/download/LosslessCut-linux-arm64.tar.bz2&#34;&gt;arm64 tar.bz2&lt;/a&gt; / &lt;a href=&#34;https://github.com/mifi/lossless-cut/releases/latest/download/LosslessCut-linux-armv7l.tar.bz2&#34;&gt;Raspberry Pi armv7l&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mifi/lossless-cut/releases&#34;&gt;More releases&lt;/a&gt; (note that APPX for Windows and PKG for MacOS &lt;strong&gt;do not work&lt;/strong&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you find LosslessCut useful, I&#39;m very thankful for &lt;a href=&#34;https://github.com/mifi/lossless-cut#donate-&#34;&gt;donations&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Difference between App Stores and GitHub download&lt;/h3&gt; &#xA;&lt;p&gt;They have exactly the same in-app features, except for a few platform limitations. Apple doesn&#39;t allow opening VOB files with App Store apps. Apple App Store apps need to prompt for output directory. LosslessCut version in the App Stores is a few versions behind the GitHub version, because I want to be sure that the new versions work perfectly before releasing in the App Stores. GitHub version can contain new, untested features and may contain some bugs. I consider the newest GitHub versions to be a public &#34;beta&#34; test.&lt;/p&gt; &#xA;&lt;h2&gt;Supported formats&lt;/h2&gt; &#xA;&lt;p&gt;Since LosslessCut is based on Chromium and uses the HTML5 video player, not all FFmpeg supported formats will be supported smoothly. The following formats/codecs should generally work: MP4, MOV, WebM, MKV, OGG, WAV, MP3, AAC, H264, Theora, VP8, VP9 For more information about supported formats / codecs, see &lt;a href=&#34;https://www.chromium.org/audio-video&#34;&gt;https://www.chromium.org/audio-video&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unsupported files can still be converted to a supported format/codec from the &lt;code&gt;File&lt;/code&gt; menu. (Try the &#34;fastest&#34; option first.) A low quality version of the file (with/without audio) will then be created and opened in the player. The actual cut/export operation will still be performed on the original file, so it will be lossless. This allows for potentially opening any file that FFmpeg is able to decode.&lt;/p&gt; &#xA;&lt;h2&gt;Video demos&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=pYHMxXy05Jg&#34;&gt;Common features&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=4pYJ93cn80E&#34;&gt;How to add a thumbnail / cover art to an MP4&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=MRBGDsuw_WU&#34;&gt;How to add multi-language audio to a video&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Your video here?&lt;/strong&gt; If you would like to make a video showing off LosslessCut use cases, let me know and I can link it here!&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Typical workflow&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Drag drop a video file into player or use &lt;kbd&gt;⌘&lt;/kbd&gt;/&lt;kbd&gt;CTRL&lt;/kbd&gt;+&lt;kbd&gt;O&lt;/kbd&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Press &lt;kbd&gt;SPACE&lt;/kbd&gt; to play/pause or &lt;kbd&gt;◀&lt;/kbd&gt;&lt;kbd&gt;▶&lt;/kbd&gt;, &lt;kbd&gt;,&lt;/kbd&gt;&lt;kbd&gt;.&lt;/kbd&gt; or mouse/trackpad wheel to seek back/forth.&lt;/li&gt; &#xA; &lt;li&gt;Select the cut segment&#39;s start and end time by moving the time marker and then pressing &lt;kbd&gt;I&lt;/kbd&gt; to set start time, and &lt;kbd&gt;O&lt;/kbd&gt; to set end time. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Note that all segments you create will be &lt;strong&gt;preserved&lt;/strong&gt; and exported as new files. You can change this behavior with the &lt;strong&gt;Yin Yang&lt;/strong&gt; symbol ☯️, in which case it will instead &lt;strong&gt;remove&lt;/strong&gt; all selected segments and export the parts &lt;strong&gt;between&lt;/strong&gt; segments.&lt;/li&gt; &#xA;   &lt;li&gt;Note also that start times will not be accurate, see &lt;a href=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/issues.md&#34;&gt;Known issues&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;(optional)&lt;/em&gt; If you want to add more than one segment, move to the desired start time and press &lt;kbd&gt;+&lt;/kbd&gt;, then select the next segment start/end times with &lt;kbd&gt;I&lt;/kbd&gt;/&lt;kbd&gt;O&lt;/kbd&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;(optional)&lt;/em&gt; If you want to re-merge all the selected segments into one file after cutting, toggle the button &lt;code&gt;Separate files&lt;/code&gt; to &lt;code&gt;Merge cuts&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;(optional)&lt;/em&gt; If you want to export to a certain output folder, press the &lt;code&gt;Working dir unset&lt;/code&gt; button (default: Input file folder)&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;(optional)&lt;/em&gt; If you want to change orientation, press the &lt;strong&gt;rotation&lt;/strong&gt; button&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;(optional)&lt;/em&gt; By default, audio, video and subtitle tracks from the input file will be cut and exported. Press the &lt;code&gt;Tracks&lt;/code&gt; button to customise and/or add new tracks from other files.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;(optional)&lt;/em&gt; select a new output format&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;(optional)&lt;/em&gt; In the right-hand segments panel, right click a segment for options, or drag-drop to reorder. Segments will appear in this order in the merged output.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;When done, press the &lt;code&gt;Export&lt;/code&gt; button (or &lt;kbd&gt;E&lt;/kbd&gt;) to show an overview with export options.&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;(optional)&lt;/em&gt; adjust any export options&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Then press &lt;code&gt;Export&lt;/code&gt; again to confirm the export&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Press the &lt;strong&gt;Camera&lt;/strong&gt; button (or &lt;kbd&gt;C&lt;/kbd&gt;) if you want to take a JPEG/PNG snapshot from the current time&lt;/li&gt; &#xA; &lt;li&gt;If you want to move the original file to trash, press the &lt;strong&gt;trash&lt;/strong&gt; button&lt;/li&gt; &#xA; &lt;li&gt;For best results you may need to trial and error with another output format (Matroska takes nearly everything), change keyframe cut mode or disable some tracks (see &lt;a href=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/issues.md&#34;&gt;known issues&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Press &lt;kbd&gt;H&lt;/kbd&gt; to view help and all keyboard shortcuts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Note:&lt;/strong&gt; The original video file will not be modified. Instead, a file is created file in the same directory as the original file with from/to timestamps in the file name.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/import-export.md&#34;&gt;Import / export&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/cli.md&#34;&gt;Command line interface (CLI)&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/developer-notes.md&#34;&gt;Developer notes&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/issues.md&#34;&gt;Known issues, limitations, troubleshooting, FAQ&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;If you have any problem or question, &lt;a href=&#34;https://raw.githubusercontent.com/mifi/lossless-cut/master/issues.md&#34;&gt;please read this&lt;/a&gt; before creating an issue. I try to answer most common questions here.&lt;/p&gt; &#xA;&lt;h2&gt;Donate 🙈&lt;/h2&gt; &#xA;&lt;p&gt;This project is maintained by me alone. The project will always remain free and open source, but if it&#39;s useful for you, consider supporting me. :) It will give me extra motivation to improve it. Or even better &lt;a href=&#34;https://www.ffmpeg.org/donations.html&#34;&gt;donate to ffmpeg&lt;/a&gt; because they are doing the world a big favor 🙏&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://paypal.me/mifino/usd&#34;&gt;Paypal&lt;/a&gt; | &lt;a href=&#34;https://mifi.no/thanks&#34;&gt;crypto&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Featured&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://console.substack.com/p/console-93&#34;&gt;Featured in the Console newsletter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://news.ycombinator.com/item?id=33969490&#34;&gt;Hacker News&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Attributions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;App icon made by &lt;a href=&#34;http://www.flaticon.com/authors/dimi-kazak&#34; title=&#34;Dimi Kazak&#34;&gt;Dimi Kazak&lt;/a&gt; from &lt;a href=&#34;http://www.flaticon.com&#34; title=&#34;Flaticon&#34;&gt;www.flaticon.com&lt;/a&gt; is licensed by &lt;a href=&#34;http://creativecommons.org/licenses/by/3.0/&#34; title=&#34;Creative Commons BY 3.0&#34;&gt;CC 3.0 BY&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://lottiefiles.com/7077-magic-flow&#34;&gt;Lottie animation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Thanks to Adi Abinun for his UI sketch work, inspiration and guidance&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://mifi.no/thanks/&#34;&gt;Thanks to everyone for supporting&lt;/a&gt; my open source work 🙌&lt;/li&gt; &#xA; &lt;li&gt;Thanks to translators who helped translate the app. &lt;a href=&#34;https://hosted.weblate.org/projects/losslesscut/losslesscut/&#34;&gt;You can too!&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;More software&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;I made a command line video editor with slick transitions and lots of colors! &lt;a href=&#34;https://github.com/mifi/editly&#34;&gt;editly&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;I made a tool for cross platform sharing of files between computer/phone over the local network: &lt;a href=&#34;https://github.com/mifi/ezshare&#34;&gt;ezshare&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;I created a super simple Instagram bot for getting more followers &lt;a href=&#34;https://github.com/mifi/SimpleInstaBot&#34;&gt;SimpleInstaBot&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Made with ❤️ in &lt;a href=&#34;https://www.youtube.com/watch?v=uQIv8Vo9_Jc&#34;&gt;🇳🇴&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://mifi.no/&#34;&gt;More apps by mifi.no&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Follow me on &lt;a href=&#34;https://github.com/mifi/&#34;&gt;GitHub&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/channel/UC6XlvVH63g0H54HSJubURQA&#34;&gt;YouTube&lt;/a&gt;, &lt;a href=&#34;https://www.instagram.com/mifi.no/&#34;&gt;IG&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/mifi_no&#34;&gt;Twitter&lt;/a&gt; for more awesome content!&lt;/p&gt;</summary>
  </entry>
</feed>