<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-22T01:28:05Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>InstantID/InstantID</title>
    <updated>2024-01-22T01:28:05Z</updated>
    <id>tag:github.com,2024-01-22:/InstantID/InstantID</id>
    <link href="https://github.com/InstantID/InstantID" rel="alternate"></link>
    <summary type="html">&lt;p&gt;InstantID : Zero-shot Identity-Preserving Generation in Seconds üî•&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;InstantID&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://instantid.github.io/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Project-Page-green&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/2401.07519&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Technique-Report-red&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://huggingface.co/papers/2401.07519&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Paper&amp;amp;message=Huggingface&amp;amp;color=orange&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;InstantID : Zero-shot Identity-Preserving Generation in Seconds&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;We are currently organizing code and pre-training checkpoints, which will be available soon! Please don&#39;t hesitate to star our work.&lt;/p&gt; &#xA;&lt;h2&gt;Abstract&lt;/h2&gt; &#xA;&lt;p&gt;There has been significant progress in personalized image synthesis with methods such as Textual Inversion, DreamBooth, and LoRA. Yet, their real-world applicability is hindered by high storage demands, lengthy fine-tuning processes, and the need for multiple reference images. Conversely, existing ID embedding-based methods, while requiring only a single forward inference, face challenges: they either necessitate extensive fine-tuning across numerous model parameters, lack compatibility with community pre-trained models, or fail to maintain high face fidelity. Addressing these limitations, we introduce InstantID, a powerful diffusion model-based solution. Our plug-and-play module adeptly handles image personalization in various styles using just a single facial image, while ensuring high fidelity. To achieve this, we design a novel IdentityNet by imposing strong semantic and weak spatial conditions, integrating facial and landmark images with textual prompts to steer the image generation. InstantID demonstrates exceptional performance and efficiency, proving highly beneficial in real-world applications where identity preservation is paramount. Moreover, our work seamlessly integrates with popular pre-trained text-to-image diffusion models like SD1.5 and SDXL, serving as an adaptable plugin. Our codes and pre-trained checkpoints will be available at &lt;a href=&#34;https://github.com/InstantID/InstantID&#34;&gt;https://github.com/InstantID/InstantID&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/InstantID/InstantID/main/assets/famous.png&#34;&gt; &#xA;&lt;h2&gt;Release&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[2024/1/15] üî• We release the technical report.&lt;/li&gt; &#xA; &lt;li&gt;[2023/12/11] üî• We launch the project page.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Demos&lt;/h2&gt; &#xA;&lt;h3&gt;Stylized Synthesis&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/InstantID/InstantID/main/assets/author.png&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;Comparison with Previous Works&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/InstantID/InstantID/main/assets/compare-a.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Comparison with existing tuning-free state-of-the-art techniques. Specifically, we compare with IP-Adapter (IPA), IP-Adapter-FaceID, and recent PhotoMaker. Among them, PhotoMaker needs to train the LoRA parameters of UNet. It can be seen that both PhotoMaker and IP-Adapter-FaceID achieves good fidelity, but there is obvious degradation of text control capabilities. In contrast, InstantID achieves better fidelity and retain good text editability (faces and styles blend better).&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/InstantID/InstantID/main/assets/compare-c.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Comparison of InstantID with pre-trained character LoRAs. We can achieve competitive results as LoRAs without any training.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/InstantID/InstantID/main/assets/compare-b.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Comparison of InstantID with InsightFace Swapper (also known as ROOP or Refactor). However, in non-realistic style, our work is more flexible on the integration of face and background.&lt;/p&gt; &#xA;&lt;h2&gt;Code&lt;/h2&gt; &#xA;&lt;p&gt;We are working with diffusers team and will release the code before the end of January. Starring our work will definitely speed up the process. No kidding!&lt;/p&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;This project is released under &lt;a href=&#34;https://github.com/InstantID/InstantID?tab=Apache-2.0-1-ov-file#readme&#34;&gt;Apache License&lt;/a&gt; and aims to positively impact the field of AI-driven image generation. Users are granted the freedom to create images using this tool, but they are obligated to comply with local laws and utilize it responsibly. The developers will not assume any responsibility for potential misuse by users.&lt;/p&gt; &#xA;&lt;h2&gt;Cite&lt;/h2&gt; &#xA;&lt;p&gt;If you find InstantID useful for your research and applications, please cite us using this BibTeX:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@article{wang2024instantid,&#xA;  title={InstantID: Zero-shot Identity-Preserving Generation in Seconds},&#xA;  author={Wang, Qixun and Bai, Xu and Wang, Haofan and Qin, Zekui and Chen, Anthony},&#xA;  journal={arXiv preprint arXiv:2401.07519},&#xA;  year={2024}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>sst/demo-ai-app</title>
    <updated>2024-01-22T01:28:05Z</updated>
    <id>tag:github.com,2024-01-22:/sst/demo-ai-app</id>
    <link href="https://github.com/sst/demo-ai-app" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Sample AI movies app built with ‚ùç Ion&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;‚ùç Movies Demo&lt;/h1&gt; &#xA;&lt;p&gt;A sample movies app built with &lt;a href=&#34;https://github.com/sst/ion&#34;&gt;‚ùç Ion&lt;/a&gt; to demo how to &lt;strong&gt;use AI in your apps using your data&lt;/strong&gt; ‚Äî &lt;a href=&#34;https://movies.sst.dev&#34;&gt;movies.sst.dev&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sst/demo-ai-app/main/screenshot.png&#34; alt=&#34;Movies App&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The movie database in this app contains around 700 popular movies. You can search through them, check out related movies, and some of the movies are also tagged.&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Most of the AI demos to date include some form of chat. While this is useful, it doesn&#39;t apply to majority of the apps out there. It also involves storing your data outside your infrastructure.&lt;/p&gt; &#xA;&lt;p&gt;This demo shows how you can use AI related features in your infrastructure in a way that makes sense to your users.&lt;/p&gt; &#xA;&lt;h2&gt;AI&lt;/h2&gt; &#xA;&lt;p&gt;The following AI features are powered by our new Vector component.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Tags&lt;/strong&gt; ‚Äî Classify data based on text that&#39;s more descriptive and carries more context&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Related&lt;/strong&gt; ‚Äî Find semantically similar data in your database&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Search&lt;/strong&gt; ‚Äî Deep search your data and images using natural language&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Search Images&lt;/strong&gt; ‚Äî Do a deep search through your data, including your images&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Vector Component&lt;/h3&gt; &#xA;&lt;p&gt;The Vector component is based on Amazon Bedrock and it exposes a couple of functions that makes it easy to use AI with your data.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ingest&lt;/code&gt;: This takes some text, generates an embedding with a given model, and stores it in a Vector database powered by RDS. Also takes some metadata to tag the data.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;retrieve&lt;/code&gt;: Takes a prompt and optionally the metadata to filter on. Returns matching results with a score 0 - 1.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Models&lt;/h3&gt; &#xA;&lt;p&gt;Currently the embeddings can be generated using the &lt;code&gt;titan-embed-text-v1&lt;/code&gt;, &lt;code&gt;titan-embed-image-v1&lt;/code&gt;, and &lt;code&gt;text-embedding-ada-002&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Ion&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sst/ion&#34;&gt;‚ùç Ion&lt;/a&gt; is an experimental new engine for &lt;a href=&#34;https://sst.dev&#34;&gt;SST&lt;/a&gt; that has some unique advantages over our previous CDK based engine. Here are a couple that you can see in action in this repo:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;It&#39;s a lot faster to deploy, 10x faster&lt;/li&gt; &#xA; &lt;li&gt;There are &lt;a href=&#34;https://raw.githubusercontent.com/sst/demo-ai-app/main/sst.config.ts#L15&#34;&gt;no stacks&lt;/a&gt; or stack limits&lt;/li&gt; &#xA; &lt;li&gt;No cyclical dependency issues in your resources&lt;/li&gt; &#xA; &lt;li&gt;Access linked resources in Next.js doesn&#39;t need top-level await&lt;/li&gt; &#xA; &lt;li&gt;Next.js 14 with linked resources are deployed in order and don&#39;t need a &lt;em&gt;double deploy&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Next.js apps have access to linked resources without the need for &lt;a href=&#34;https://raw.githubusercontent.com/sst/demo-ai-app/main/package.json#L7&#34;&gt;&lt;code&gt;sst bind next build&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;How it Works&lt;/h2&gt; &#xA;&lt;p&gt;This demo works by ingesting movie data from IMDB, generating embeddings, and storing it in a Vector database. The Next.js app then retrieves the data from the Vector database.&lt;/p&gt; &#xA;&lt;p&gt;The sample app is made up of &lt;strong&gt;4 simple components&lt;/strong&gt; defined in the &lt;a href=&#34;https://raw.githubusercontent.com/sst/demo-ai-app/main/sst.config.ts&#34;&gt;&lt;code&gt;sst.config.ts&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;A DynamoDB table to store the movies&lt;/li&gt; &#xA; &lt;li&gt;An S3 bucket to store the posters&lt;/li&gt; &#xA; &lt;li&gt;A Vector database to store the embeddings&lt;/li&gt; &#xA; &lt;li&gt;A Next.js app&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Join the SST community over on &lt;a href=&#34;https://discord.gg/sst&#34;&gt;Discord&lt;/a&gt; and follow us on &lt;a href=&#34;https://twitter.com/SST_dev&#34;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Codium-ai/AlphaCodium</title>
    <updated>2024-01-22T01:28:05Z</updated>
    <id>tag:github.com,2024-01-22:/Codium-ai/AlphaCodium</id>
    <link href="https://github.com/Codium-ai/AlphaCodium" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Official implementation for the paper: &#34;Code Generation with AlphaCodium: From Prompt Engineering to Flow Engineering&#34;&#34;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Code Generation with AlphaCodium: From Prompt Engineering to Flow Engineering&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2401.08500&#34;&gt;Paper&lt;/a&gt; | &lt;a href=&#34;https://huggingface.co/datasets/talrid/CodeContests_valid_and_test_AlphaCodium/blob/main/codecontests_valid_and_test_processed_alpha_codium.zip&#34;&gt;Dataset&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Official Implementation&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Tal Ridnik, Dedy Kredo, Itamar Friedman &lt;br&gt; CodiumAI&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/#abstract&#34;&gt;Abstract&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/#how-to-run&#34;&gt;How to run&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/#technical-qa&#34;&gt;Technical Q&amp;amp;A&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/#broader-applicability&#34;&gt;Broader Applicability&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/#acknowledgments&#34;&gt;Acknowledgments&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/#citation&#34;&gt;Citation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Abstract&lt;/h2&gt; &#xA;&lt;p&gt;Code generation problems differ from common natural language problems - they require matching the exact syntax of the target language, identifying happy paths and edge cases, paying attention to numerous small details in the problem spec, and addressing other code-specific issues and requirements. Hence, many of the optimizations and tricks that have been successful in natural language generation may not be effective for code tasks.&lt;/p&gt; &#xA;&lt;p&gt;In this work, we propose a new approach to code generation by LLMs, which we call AlphaCodium - a test-based, multi-stage, code-oriented iterative flow, that improves the performances of LLMs on code problems.&lt;/p&gt; &#xA;&lt;p&gt;We tested AlphaCodium on a challenging code generation dataset called CodeContests, which includes competitive programming problems from platforms such as Codeforces. The proposed flow consistently and significantly improves results. On the validation set, for example, GPT-4 accuracy (pass@5) increased from 19% with a single well-designed direct prompt to 44% with the AlphaCodium flow.&lt;/p&gt; &#xA;&lt;p&gt;Many of the principles and best practices we acquired in this work, we believe, are broadly applicable to general code generation tasks.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;/p&gt;&#xA;&lt;table class=&#34;tg&#34;&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td class=&#34;tg-c3ow&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/pics/proposed_flow.png&#34; align=&#34;center&#34; width=&#34;600&#34; &#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td class=&#34;tg-c3ow&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/pics/iterations.png&#34; align=&#34;center&#34; width=&#34;600&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;(1) setup a virtual environment and run: &lt;code&gt;pip install -r requirements.txt&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;(2) Duplicate the file &lt;code&gt;alpha_codium/settings/.secrets_template.toml&lt;/code&gt;, rename it as &lt;code&gt;.secrets.toml&lt;/code&gt;, and fill your openai api key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[openai]&#xA;key = &#34;...&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(3) Download the processed CodeContest validation and test dataset from &lt;a href=&#34;https://huggingface.co/datasets/talrid/CodeContests_valid_and_test_AlphaCodium/blob/main/codecontests_valid_and_test_processed_alpha_codium.zip&#34;&gt;hugging face&lt;/a&gt;, extract the zip file, and placed the extracted folder in the root of the project.&lt;/p&gt; &#xA;&lt;h2&gt;How to run&lt;/h2&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;The file: &lt;code&gt;alpha_codium/settings/configuration.toml&lt;/code&gt; contains the configuration for the project. In the &lt;code&gt;config&lt;/code&gt; section you can choose the model you want to use (&#34;gpt-4&#34;, &#34;gpt-3.5-turbo-16k&#34;, or others).&lt;/p&gt; &#xA;&lt;h3&gt;Solving a specific problem&lt;/h3&gt; &#xA;&lt;p&gt;To solve a specific problem with AlphaCodium, from the root folder run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m alpha_codium.solve_problem \&#xA;--dataset_name /path/to/dataset \&#xA;--split_name test \&#xA;--problem_number 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;dataset_name&lt;/code&gt; is the path to the dataset folder you downloaded in the installation step.&lt;/li&gt; &#xA; &lt;li&gt;Note that the validation set contains 117 problems, and the test set contains 165 problems, so the &lt;code&gt;problem_number&lt;/code&gt; parameter should be accordingly (zero-based)&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;split_name&lt;/code&gt; can be either &lt;code&gt;valid&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The followings sections in the configuration file: &lt;code&gt;solve&lt;/code&gt;, &lt;code&gt;self_reflection&lt;/code&gt;,&lt;code&gt;possible_solutions&lt;/code&gt;,&lt;code&gt;generate_ai_tests&lt;/code&gt;,&lt;code&gt;initial_code_generation&lt;/code&gt;,&lt;code&gt;public_tests&lt;/code&gt;, &lt;code&gt;ai_tests&lt;/code&gt;&lt;br&gt; enable to adjust possible configurations for the different stages of the flow.&lt;/li&gt; &#xA; &lt;li&gt;Each run logs the results to a file named &lt;code&gt;alpha_codium/example.log&lt;/code&gt;. Reviewing the log file is a good way to understand what is going on in each stage of the flow.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example problem (test set, problem number 12):&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;/p&gt;&#xA;&lt;table class=&#34;tg&#34;&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td class=&#34;tg-c3ow&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/pics/example_problem.png&#34; align=&#34;center&#34; width=&#34;600&#34; &#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Solving the entire dataset&lt;/h3&gt; &#xA;&lt;p&gt;to solve the entire dataset with AlphaCodium, from the root folder run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m alpha_codium.solve_dataset \&#xA;--dataset_name /path/to/dataset \&#xA;--split_name test&#xA;--database_solution_path /path/to/output/dir/dataset_output.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;split_name&lt;/code&gt; can be either &lt;code&gt;valid&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;database_solution_path&lt;/code&gt; is the path to the directory where the solutions will be saved.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;dataset&lt;/code&gt; section in the configuration file contains the configuration for the running and evaluation a dataset.&lt;/li&gt; &#xA; &lt;li&gt;Note that this is a long process, and it may take a few days to complete with large models (e.g. GPT-4) and several iterations per problem.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dataset.num_iterations&lt;/code&gt; defines the number of iterations for each problem (pass@K). For large number of iterations, it is recommended to introduce some randomness and different options for each iteration to achieve top results.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Running the evaluation&lt;/h3&gt; &#xA;&lt;p&gt;Once you generate a solution for the entire dataset (valid or test), you can evaluate it by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m alpha_codium.evaluate_dataset\&#xA;--dataset_name /path/to/dataset\&#xA;--split_name test\&#xA;--database_solution_path /path/to/output/dir/dataset_output.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Technical Q&amp;amp;A&lt;/h2&gt; &#xA;&lt;p&gt;Aggregating some technical questions we received about this project:&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: How much time did you spend on &#34;prompt engineering&#34; compared to &#34;flow engineering&#34;?&lt;/strong&gt;&lt;br&gt;&lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; Structured output almost completely eliminates the need for simple prompt engineering. We estimate that ~95% of the time we did more high-level design, reasoning, injecting data at the correct places, ..., a.k.a. &#34;flow engineering&#34;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: How do you know that there wasn&#39;t a data leakage ?&lt;/strong&gt; &lt;br&gt;&lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; The test set of CodeContests dataset comprises from problems published after September 2021, while the GPT-4 model variant we used (gpt-4-0613) has a data cutoff of September 2021. Hence, there is no data leakage for GPT4, on the test set. For other models like DeepSeek, we cannot be sure. However, note that our &lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/pics/comparison.png&#34;&gt;main result&lt;/a&gt; is a comparison of &#34;direct prompt&#34; vs. &#34;AlphaCodium flow&#34;. Data leakage would help both approaches, so the relative improvement of AlphaCodium flow is still valid.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Is this project relevant only to specific programming languages?&lt;/strong&gt;&lt;br&gt;&lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; No. The proposed flow is language agnostic. We generated solutions in Python, but the flow can be applied to any language.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: How did you manage the context window?&lt;/strong&gt; &lt;br&gt;&lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; We used models with a context window of 8192 tokens, and we did not encounter cases where it did not suffice. However, we clearly observed that as the context we used in practice grows larger (let&#39;s say, above 4000 tokens), the model starts to &#34;ignore&#34; some of the information in the context. Hence, there is a clear tradeoff:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Injecting the results of previous stages into the context, may help the model to generate better code.&lt;/li&gt; &#xA; &lt;li&gt;However, it may also cause the model to ignore specific details and nuances from the problem description.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Is this work &#34;realistic&#34; in terms of the number of LLM calls?&lt;/strong&gt; &lt;br&gt;&lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; In comparison to AlphaCode, we do four orders of magnitude (!) fewer &lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/pics/computational_effort.png&#34;&gt;calls&lt;/a&gt; (per solution AlphaCodium does 15-20 calls). Yet we acknowledge that for some applications, this may still be too much, and more optimizations are needed. We however believe that many of the ideas and principles we acquired in this work are broadly applicable, even when the number of calls is further limited.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Why do you iterate only on the generated code, and not on the AI-generated tests?&lt;/strong&gt; &lt;br&gt;&lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; For code problems in CodeContests, the tests are a list of input-output pairs. Hence, you don&#39;t really learn anything new when you &#34;fix&#34; a test - you just change its output to the prediction of the generated code. Instead of fixing tests, we preferred to always try and fix the code, while using &#34;test anchors&#34;. (see the &lt;a href=&#34;https://arxiv.org/abs/2401.08500&#34;&gt;paper&lt;/a&gt; for more details). However, for other code generation tasks, where the tests are more complex and actually contain runnable code, iterating on the tests, in addition to iterating on the generated code, may be beneficial.&lt;/p&gt; &#xA;&lt;h2&gt;Broader Applicability&lt;/h2&gt; &#xA;&lt;p&gt;While this work presents results on CodeContests dataset, we believe that it has a broader applicability.&lt;/p&gt; &#xA;&lt;p&gt;First and foremost, we feel that the proposed AlphaCodium &lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/pics/proposed_flow.png&#34;&gt;flow&lt;/a&gt;, with reasonable adjustments, can be used as a more general framework for other code generation tasks.&lt;/p&gt; &#xA;&lt;p&gt;Secondly, many of the design concepts, principles, and tricks we acquired in this work are broadly applicable as-is to any general code generation tasks. For example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;YAML Structured output&lt;/strong&gt;: asking the model to generate an output in YAML format, equivalent to a given Pydantic class&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Semantic reasoning via bullet points analysis&lt;/strong&gt;: bullet points analysis encourages an in-depth understanding of the problem, and force the model to divide the output into logical semantic sections, leading to improved results&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;LLMs do better when generating a modular code&lt;/strong&gt;: when clearly asking the model to: &lt;code&gt;divide the generated code into small sub-functions, with meaningful names and functionality&lt;/code&gt;, we observe a better-produced code, with fewer bugs, and higher success rates for the iterative fixing stages.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Soft decisions with double validation&lt;/strong&gt;: with a double validation process, we add an extra step where, given the generated output, the model is asked to re-generate the same output, but correct it if needed&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Leave room for exploration&lt;/strong&gt;: since the model can be wrong, it‚Äôs better to avoid irreversible decisions, and leave room for exploration and code iterations with different possible solutions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The list above is partial. See the &lt;a href=&#34;https://arxiv.org/abs/2401.08500&#34;&gt;paper&lt;/a&gt; for more details. The code provided &lt;a href=&#34;https://raw.githubusercontent.com/Codium-ai/AlphaCodium/main/alpha_codium/settings&#34;&gt;in this repo&lt;/a&gt; can be used as a reference for better understanding the proposed concepts, and for applying them to other code generation tasks.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;Our process CodeContests dataset is based on the original &lt;a href=&#34;https://huggingface.co/datasets/deepmind/code_contests&#34;&gt;CodeContests&lt;/a&gt; dataset. We removed the train set (which is not relevant for our work), and did some post-processing and cleaning to the validation and test sets.&lt;/p&gt; &#xA;&lt;h2&gt;Citation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;@misc{ridnik2024code,&#xA;      title={Code Generation with AlphaCodium: From Prompt Engineering to Flow Engineering}, &#xA;      author={Tal Ridnik and Dedy Kredo and Itamar Friedman},&#xA;      year={2024},&#xA;      eprint={2401.08500},&#xA;      archivePrefix={arXiv},&#xA;      primaryClass={cs.LG}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>