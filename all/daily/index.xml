<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-08T01:30:02Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sourcegraph/conc</title>
    <updated>2023-01-08T01:30:02Z</updated>
    <id>tag:github.com,2023-01-08:/sourcegraph/conc</id>
    <link href="https://github.com/sourcegraph/conc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Better structured concurrency for go&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/12631702/210295964-785cc63d-d697-420c-99ff-f492eb81dec9.svg?sanitize=true&#34; alt=&#34;conch&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;&lt;code&gt;conc&lt;/code&gt;: better structured concurrency for go&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc&#34;&gt;&lt;img src=&#34;https://pkg.go.dev/badge/github.com/sourcegraph/conc.svg?sanitize=true&#34; alt=&#34;Go Reference&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sourcegraph.com/github.com/sourcegraph/conc&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/view%20on-sourcegraph-A112FE?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAEZklEQVRoQ+2aXWgUZxSG3292sxtNN43BhBakFPyhxSujRSxiU1pr7SaGXqgUxOIEW0IFkeYighYUxAuLUlq0lrq2iCDpjWtmFVtoG6QVNOCFVShVLyxIk0DVjZLMxt3xTGTccd2ZOd/8JBHci0CY9zvnPPN+/7sCIXwKavOwAcy2QgngQiIztDSE0OwQlDPYR1ebiaH6J5kZChyfW12gRG4QVgGTBfMchMbFP9Sn5nlZL2D0JjLD6710lc+z0NfqSGTXQRQ4bX07Mq423yoBL3OSyHSvUxirMuaEvgbJWrdcvkHMoJwxYuq4INUhyuWvQa1jvdMGxAvCxJlyEC9XOBCWL04wwRzpbDoDQ7wfZJzIQLi5Eggk6DiRhZgWIAbE3NrM4A3LPT8Q7UgqAqLqTmLSHLGPkyzG/qXEczhd0q6RH+zaSBfaUoc4iQx19pIClIscrTkNZzG6gd7qMY6eC2Hqyo705ZfTf+eqJmhMzcSbYtQpOXc92ZsZjLVAL4YNUQbJ5Ttg4CQrQdGYj44Xr9m1XJCzmZusFDJOWNpHjmh5x624a2ZFtOKDVL+uNo2TuXE3bZQQZUf8gtgqP31uI94Z/rMqix+IGiRfWw3xN9dCgVx+L3WrHm4Dju6PXz/EkjuXJ6R+IGgyOE1TbZqTq9y1eo0EZo7oMo1ktPu3xjHvuiLT5AFNszUyDULtWpzE2/fEsey8O5TbWuGWwxrs5rS7nFNMWJrNh2No74s9Ec4vRNmRRzPXMP19fBMSVsGcOJ98G8N3Wl2gXcbTjbX7vUBxLaeASDQCm5Cu/0E2tvtb0Ea+BowtskFD0wvlc6Rf2M+Jx7dTu7ubFr2dnKDRaMQe2v/tcIrNB7FH0O50AcrBaApmRDVwFO31ql3pD8QW4dP0feNwl/Q+kFEtRyIGyaWXnpy1OO0qNJWHo1y6iCmAGkBb/Ru+HenDWIF2mo4r8G+tRRzoniSn2uqFLxANhe9LKHVyTbz6egk9+x5w5fK6ulSNNMhZ/Feno+GebLZV6isTTa6k5qNl5RnZ5u56Ib6SBvFzaWBBVFZzvnERWlt/Cg4l27XChLCqFyLekjhy6xJyoytgjPf7opIB8QPx7sYFiMXHPGt76m741MhCKMZfng0nBOIjmoJPsLqWHwgFpe6V6qtfcopxveR2Oy+J0ntIN/zCWkf8QNAJ7y6d8Bq4lxLc2/qJl5K7t432XwcqX5CrI34gzATWuYILQtdQPyePDK3iuOekCR3Efjhig1B1Uq5UoXEEoZX7d1q535J5S9VOeFyYyEBku5XTMXXKQTToX5Rg7OI44nbW5oKYeYK4EniMeF0YFNSmb+grhc84LyRCEP1/OurOcipCQbKxDeK2V5FcVyIDMQvsgz5gwFhcWWwKyRlvQ3gv29RwWoDYAbIofNyBxI9eDlQ+n3YgsgCWnr4MStGXQXmv9pF2La/k3OccV54JEBM4yp9EsXa/3LfO0dGPcYq0Y7DfZB8nJzZw2rppHgKgVHs8L5wvRwAAAABJRU5ErkJggg==&#34; alt=&#34;Sourcegraph&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/sourcegraph/conc&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/sourcegraph/conc&#34; alt=&#34;Go Report Card&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/sourcegraph/conc&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/sourcegraph/conc/branch/main/graph/badge.svg?token=MQZTEA1QWT&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/bvXQXmtRjN&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/discord-chat-%235765F2&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;conc&lt;/code&gt; is your toolbelt for structured concurrency in go, making common tasks easier and safer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go get github.com/sourcegraph/conc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;At a glance&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc#WaitGroup&#34;&gt;&lt;code&gt;conc.WaitGroup&lt;/code&gt;&lt;/a&gt; if you just want a safer version of &lt;code&gt;sync.WaitGroup&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#Pool&#34;&gt;&lt;code&gt;pool.Pool&lt;/code&gt;&lt;/a&gt; if you want a concurrency-limited task runner&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#ResultPool&#34;&gt;&lt;code&gt;pool.ResultPool&lt;/code&gt;&lt;/a&gt; if you want a concurrent task runner that collects task results&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#ErrorPool&#34;&gt;&lt;code&gt;pool.(Result)?ErrorPool&lt;/code&gt;&lt;/a&gt; if your tasks are fallible&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#ContextPool&#34;&gt;&lt;code&gt;pool.(Result)?ContextPool&lt;/code&gt;&lt;/a&gt; if your tasks should be canceled on failure&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/stream#Stream&#34;&gt;&lt;code&gt;stream.Stream&lt;/code&gt;&lt;/a&gt; if you want to process an ordered stream of tasks in parallel with serial callbacks&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/iter#Map&#34;&gt;&lt;code&gt;iter.Map&lt;/code&gt;&lt;/a&gt; if you want to concurrently map a slice&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/iter#ForEach&#34;&gt;&lt;code&gt;iter.ForEach&lt;/code&gt;&lt;/a&gt; if you want to concurrently iterate over a slice&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc#PanicCatcher&#34;&gt;&lt;code&gt;conc.PanicCatcher&lt;/code&gt;&lt;/a&gt; if you want to catch panics in your own goroutines&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All pools are created with &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#New&#34;&gt;&lt;code&gt;pool.New()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#NewWithResults&#34;&gt;&lt;code&gt;pool.NewWithResults[T]()&lt;/code&gt;&lt;/a&gt;, then configured with methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#Pool.MaxGoroutines&#34;&gt;&lt;code&gt;p.WithMaxGoroutines()&lt;/code&gt;&lt;/a&gt; configures the maximum number of goroutines in the pool&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#Pool.WithErrors&#34;&gt;&lt;code&gt;p.WithErrors()&lt;/code&gt;&lt;/a&gt; configures the pool to run tasks that return errors&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#Pool.WithContext&#34;&gt;&lt;code&gt;p.WithContext(ctx)&lt;/code&gt;&lt;/a&gt; configures the pool to run tasks that should be canceled on first error&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#ErrorPool.WithFirstError&#34;&gt;&lt;code&gt;p.WithFirstError()&lt;/code&gt;&lt;/a&gt; configures error pools to only keep the first returned error rather than an aggregated error&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pkg.go.dev/github.com/sourcegraph/conc@v0.1.0/pool#ResultContextPool.WithCollectErrored&#34;&gt;&lt;code&gt;p.WithCollectErrored()&lt;/code&gt;&lt;/a&gt; configures result pools to only collect results that did not error&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Goals&lt;/h1&gt; &#xA;&lt;p&gt;The main goals of the package are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Make it harder to leak goroutines&lt;/li&gt; &#xA; &lt;li&gt;Handle panics gracefully&lt;/li&gt; &#xA; &lt;li&gt;Make concurrent code easier to read&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Goal #1: Make it harder to leak goroutines&lt;/h2&gt; &#xA;&lt;p&gt;A common pain point when working with goroutines is cleaning them up. It&#39;s really easy to fire off a &lt;code&gt;go&lt;/code&gt; statement and fail to properly wait for it to complete.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;conc&lt;/code&gt; takes the opinionated stance that all concurrency should be scoped. That is, goroutines should have an owner and that owner should always ensure that its owned goroutines exit properly.&lt;/p&gt; &#xA;&lt;p&gt;In &lt;code&gt;conc&lt;/code&gt;, the owner of a goroutine is always a &lt;code&gt;conc.WaitGroup&lt;/code&gt;. Goroutines are spawned in a &lt;code&gt;WaitGroup&lt;/code&gt; with &lt;code&gt;(*WaitGroup).Go()&lt;/code&gt;, and &lt;code&gt;(*WaitGroup).Wait()&lt;/code&gt; should always be called before the &lt;code&gt;WaitGroup&lt;/code&gt; goes out of scope.&lt;/p&gt; &#xA;&lt;p&gt;In some cases, you might want a spawned goroutine to outlast the scope of the caller. In that case, you could pass a &lt;code&gt;WaitGroup&lt;/code&gt; into the spawning function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;    var wg conc.WaitGroup&#xA;    defer wg.Wait()&#xA;&#xA;    startTheThing(&amp;amp;wg)&#xA;}&#xA;&#xA;func startTheThing(wg *conc.WaitGroup) {&#xA;    wg.Go(func() { ... })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For some more discussion on why scoped concurrency is nice, check out &lt;a href=&#34;https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/&#34;&gt;this blog post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Goal #2: Handle panics gracefully&lt;/h2&gt; &#xA;&lt;p&gt;A frequent problem with goroutines in long-running applications is handling panics. A goroutine spawned without a panic handler will crash the whole process on panic. This is usually undesirable.&lt;/p&gt; &#xA;&lt;p&gt;However, if you do add a panic handler to a goroutine, what do you do with the panic once you catch it? Some options:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Ignore it&lt;/li&gt; &#xA; &lt;li&gt;Log it&lt;/li&gt; &#xA; &lt;li&gt;Turn it into an error and return that to the goroutine spawner&lt;/li&gt; &#xA; &lt;li&gt;Propagate the panic to the goroutine spawner&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Ignoring panics is a bad idea since panics usually mean there is actually something wrong and someone should fix it.&lt;/p&gt; &#xA;&lt;p&gt;Just logging panics isn&#39;t great either because then there is no indication to the spawner that something bad happened, and it might just continue on as normal even though your program is in a really bad state.&lt;/p&gt; &#xA;&lt;p&gt;Both (3) and (4) are reasonable options, but both require the goroutine to have an owner that can actually receive the message that something went wrong. This is generally not true with a goroutine spawned with &lt;code&gt;go&lt;/code&gt;, but in the &lt;code&gt;conc&lt;/code&gt; package, all goroutines have an owner that must collect the spawned goroutine. In the conc package, any call to &lt;code&gt;Wait()&lt;/code&gt; will panic if any of the spawned goroutines panicked. Additionally, it decorates the panic value with a stacktrace from the child goroutine so that you don&#39;t lose information about what caused the panic.&lt;/p&gt; &#xA;&lt;p&gt;Doing this all correctly every time you spawn something with &lt;code&gt;go&lt;/code&gt; is not trivial and it requires a lot of boilerplate that makes the important parts of the code more difficult to read, so &lt;code&gt;conc&lt;/code&gt; does this for you.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;stdlib&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;conc&lt;/code&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type caughtPanicError struct {&#xA;    val   any&#xA;    stack []byte&#xA;}&#xA;&#xA;func (e *caughtPanicError) Error() string {&#xA;    return fmt.Sprintf(&#xA;        &#34;panic: %q\n%s&#34;,&#xA;        e.val,&#xA;        string(e.stack)&#xA;    )&#xA;}&#xA;&#xA;func main() {&#xA;    done := make(chan error)&#xA;    go func() {&#xA;        defer func() {&#xA;            if v := recover(); v != nil {&#xA;                done &amp;lt;- caughtPanicError{&#xA;                    val: v,&#xA;                    stack: debug.Stack()&#xA;                }&#xA;            } else {&#xA;                done &amp;lt;- nil&#xA;            }&#xA;        }()&#xA;        doSomethingThatMightPanic()&#xA;    }()&#xA;    err := &amp;lt;-done&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;    var wg conc.WaitGroup&#xA;    wg.Go(doSomethingThatMightPanic)&#xA;    // panics with a nice stacktrace&#xA;    wg.Wait()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Goal #3: Make concurrent code easier to read&lt;/h2&gt; &#xA;&lt;p&gt;Doing concurrency correctly is difficult. Doing it in a way that doesn&#39;t obfuscate what the code is actually doing is more difficult. The &lt;code&gt;conc&lt;/code&gt; package attempts to make common operations easier by abstracting as much boilerplate complexity as possible.&lt;/p&gt; &#xA;&lt;p&gt;Want to run a set of concurrent tasks with a bounded set of goroutines? Use &lt;code&gt;pool.New()&lt;/code&gt;. Want to process an ordered stream of results concurrently, but still maintain order? Try &lt;code&gt;stream.New()&lt;/code&gt;. What about a concurrent map over a slice? Take a peek at &lt;code&gt;iter.Map()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Browse some examples below for some comparisons with doing these by hand.&lt;/p&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;p&gt;Each of these examples forgoes propagating panics for simplicity. To see what kind of complexity that would add, check out the &#34;Goal #2&#34; header above.&lt;/p&gt; &#xA;&lt;p&gt;Spawn a set of goroutines and waiting for them to finish:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;stdlib&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;conc&lt;/code&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;    var wg sync.WaitGroup&#xA;    for i := 0; i &amp;lt; 10; i++ {&#xA;        wg.Add(1)&#xA;        go func() {&#xA;            defer wg.Done()&#xA;            // crashes on panic!&#xA;            doSomething()&#xA;        }()&#xA;    }&#xA;    wg.Wait()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;    var wg conc.WaitGroup&#xA;    for i := 0; i &amp;lt; 10; i++ {&#xA;        wg.Go(doSomething)&#xA;    }&#xA;    wg.Wait()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;Process each element of a stream in a static pool of goroutines:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;stdlib&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;conc&lt;/code&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func process(stream chan int) {&#xA;    var wg sync.WaitGroup&#xA;    for i := 0; i &amp;lt; 10; i++ {&#xA;        wg.Add(1)&#xA;        go func() {&#xA;            defer wg.Done()&#xA;            for elem := range stream {&#xA;                handle(elem)&#xA;            }&#xA;        }()&#xA;    }&#xA;    wg.Wait()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func process(stream chan int) {&#xA;    p := pool.New().WithMaxGoroutines(10)&#xA;    for elem := range stream {&#xA;        elem := elem&#xA;        p.Go(func() {&#xA;            handle(elem)&#xA;        })&#xA;    }&#xA;    p.Wait()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;Process each element of a slice in a static pool of goroutines:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;stdlib&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;conc&lt;/code&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func process(values []int) {&#xA;    feeder := make(chan int, 8)&#xA;&#xA;    var wg sync.WaitGroup&#xA;    for i := 0; i &amp;lt; 10; i++ {&#xA;        wg.Add(1)&#xA;        go func() {&#xA;            defer wg.Done()&#xA;            for elem := range feeder {&#xA;                handle(elem)&#xA;            }&#xA;        }()&#xA;    }&#xA;&#xA;    for _, value := range values {&#xA;        feeder &amp;lt;- value&#xA;    }&#xA;&#xA;    wg.Wait()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func process(values []int) {&#xA;    iter.ForEach(values, handle)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;Concurrently map a slice:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;stdlib&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;conc&lt;/code&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func concMap(&#xA;    input []int,&#xA;    f func(int) int,&#xA;) []int {&#xA;    res := make([]int, len(input))&#xA;    var idx atomic.Int64&#xA;&#xA;    var wg sync.WaitGroup&#xA;    for i := 0; i &amp;lt; 10; i++ {&#xA;        wg.Add(1)&#xA;        go func() {&#xA;            defer wg.Done()&#xA;&#xA;            for {&#xA;                i := int(idx.Add(1) - 1)&#xA;                if i &amp;gt;= len(input) {&#xA;                    return&#xA;                }&#xA;&#xA;                res[i] = f(input[i])&#xA;            }&#xA;        }()&#xA;    }&#xA;    wg.Wait()&#xA;    return res&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func concMap(&#xA;    input []int,&#xA;    f func(int) int,&#xA;) []int {&#xA;    return iter.Map(input, f)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;Process an ordered stream concurrently:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;code&gt;stdlib&lt;/code&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;code&gt;conc&lt;/code&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func mapStream&#xA;    in chan int,&#xA;    out chan int,&#xA;    f func(int) int,&#xA;) {&#xA;    tasks := make(chan func())&#xA;    taskResults := make(chan chan int)&#xA;&#xA;    // Worker goroutines&#xA;    var workerWg sync.WaitGroup&#xA;    for i := 0; i &amp;lt; 10; i++ {&#xA;        workerWg.Add(1)&#xA;        go func() {&#xA;            defer workerWg.Done()&#xA;            for task := range tasks {&#xA;                task()&#xA;            }&#xA;        }()&#xA;    }&#xA;&#xA;    // Ordered reader goroutines&#xA;    var readerWg sync.WaitGroup&#xA;    readerWg.Add(1)&#xA;    go func() {&#xA;        defer readerWg.Done()&#xA;        for result := range taskResults {&#xA;            out &amp;lt;- result&#xA;        }&#xA;    }&#xA;&#xA;    // Feed the workers with tasks&#xA;    for elem := range in {&#xA;        resultCh := make(chan int, 1)&#xA;        taskResults &amp;lt;- resultCh&#xA;        tasks &amp;lt;- func() {&#xA;            resultCh &amp;lt;- f(elem)&#xA;        }&#xA;    }&#xA;&#xA;    // We&#39;ve exhausted input.&#xA;    // Wait for everything to finish&#xA;    close(tasks)&#xA;    workerWg.Wait()&#xA;    close(taskResults)&#xA;    readerWg.Wait()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func mapStream(&#xA;    in chan int,&#xA;    out chan int,&#xA;    f func(int) int,&#xA;) {&#xA;    s := stream.New().WithMaxGoroutines(10)&#xA;    for elem := range in {&#xA;        elem := elem&#xA;        s.Go(func() stream.Callback {&#xA;            res := f(elem)&#xA;            return func() { out &amp;lt;- res }&#xA;        })&#xA;    }&#xA;    s.Wait()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Status&lt;/h1&gt; &#xA;&lt;p&gt;This package is currently pre-1.0. There are likely to be minor breaking changes before a 1.0 release as we stabilize the APIs and tweak defaults. Please open an issue if you have questions, concerns, or requests that you&#39;d like addressed before the 1.0 release. Currently, a 1.0 is targeted for March 2023.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>EddieHubCommunity/LinkFree</title>
    <updated>2023-01-08T01:30:02Z</updated>
    <id>tag:github.com,2023-01-08:/EddieHubCommunity/LinkFree</id>
    <link href="https://github.com/EddieHubCommunity/LinkFree" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Connect to your audience with a single link. Showcase the content you create and your projects in one place. Make it easier for people to find, follow and subscribe.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://gitpod.io/#https://github.com/EddieHubCommunity/LinkFree&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Gitpod-Ready--to--Code-blue?logo=gitpod&#34; alt=&#34;Open in GitPod&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2FEddieHubCommunity%2Fmonitoring%2Fmaster%2Fapi%2Flink-free%2Fuptime.json&#34; alt=&#34;Uptime&#34;&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-yellow.svg?sanitize=true&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/EddieHubCommunity/LinkFree&#34; alt=&#34;GitHub release (latest by date)&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/repo-size/EddieHubCommunity/LinkFree&#34; alt=&#34;GitHub repo size&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;What is LinkFree?&lt;/h1&gt; &#xA;&lt;p&gt;LinkFree is the Open Source alternative to LinkTree. A platform where people in tech can have a single hub to showcase their content in order to accelerate their career, whilst contributing to an Open Source project and being part of a community which has a say in where the project is going.&lt;/p&gt; &#xA;&lt;p&gt;Your profile will have links to your social media and content. You can also add your timeline, testimonials and upcoming events that you are participating in.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example of a LinkFree Profile &lt;a href=&#34;https://linkfree.eddiehub.io/eddiejaoude&#34;&gt;https://linkfree.eddiehub.io/eddiejaoude&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/624760/207048057-0f8cc74f-cc50-4cb3-b1a9-7e37f1a66d2c.png&#34; alt=&#34;Example profile on LinkFree&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;🛠️ Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;You have 4 options to contribute to the repo, please pick your favourite from:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;GitHub UI (recommended for adding/editing your profile)&lt;/li&gt; &#xA; &lt;li&gt;Gitpod&lt;/li&gt; &#xA; &lt;li&gt;Local development&lt;/li&gt; &#xA; &lt;li&gt;Local development with Docker Compose&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Brief documentation below, but full documentation can be found here &lt;a href=&#34;https://linkfree.eddiehub.io/docs&#34;&gt;https://linkfree.eddiehub.io/docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;GitHub UI&lt;/h3&gt; &#xA;&lt;p&gt;This is great if you only want to add your Profile or make changes to it.&lt;/p&gt; &#xA;&lt;p&gt;Here is the &lt;strong&gt;QuickStart&lt;/strong&gt; guide to add your profile &lt;a href=&#34;https://linkfree.eddiehub.io/docs/quickstart&#34;&gt;https://linkfree.eddiehub.io/docs/quickstart&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;note: give extra attention to json formatting and the GitHub Action after you create the Pull Request&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Gitpod&lt;/h3&gt; &#xA;&lt;p&gt;In the cloud free development environment which will have all the dependencies you need (for example MongoDB).&lt;/p&gt; &#xA;&lt;p&gt;You can use Gitpod in the cloud &lt;a href=&#34;https://gitpod.io/#https://github.com/EddieHubCommunity/LinkFree/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Gitpod-Ready--to--Code-blue?logo=gitpod&#34; alt=&#34;Gitpod Ready-to-Code&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Local development&lt;/h3&gt; &#xA;&lt;p&gt;This environment is fully on computer, and requires each dependency (for example MongoDB) to be installed and setup, but gives you the most flexiblity for customisation.&lt;/p&gt; &#xA;&lt;h4&gt;Prerequisites&lt;/h4&gt; &#xA;&lt;p&gt;Before contributing or adding a new feature, please make sure you have already installed the following tools:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nodejs.org/en/download/&#34;&gt;NodeJs&lt;/a&gt; (Works with Node LTS version v16.17.0)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.mongodb.com/home&#34;&gt;MongoDB&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Optional &lt;a href=&#34;https://github.com/nvm-sh/nvm&#34;&gt;NVM&lt;/a&gt;: Switch Node version by using &lt;code&gt;nvm use&lt;/code&gt; (on Windows, use &lt;code&gt;nvm use v16.17.0&lt;/code&gt;). If this is not installed, run &lt;code&gt;nvm install v16.17.0&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Commands&lt;/h4&gt; &#xA;&lt;p&gt;You can set this up locally with the following steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;copy the &lt;code&gt;.env.example&lt;/code&gt; file to &lt;code&gt;.env&lt;/code&gt; and update any details required&lt;/li&gt; &#xA; &lt;li&gt;mongodb is required, it is possible to use &lt;code&gt;docker-compose up&lt;/code&gt; to start the mongodb service&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;npm ci&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;npm run dev&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Local development with Docker Compose&lt;/h3&gt; &#xA;&lt;p&gt;This will allow you to run your favourite IDE but not have to install any dependencies on your computer like NodeJS and MongoDB.&lt;/p&gt; &#xA;&lt;h4&gt;Prerequisites&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker&lt;/li&gt; &#xA; &lt;li&gt;Docker Compose&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Commands&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose up&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;🙂 How to add YOUR Profile&lt;/h3&gt; &#xA;&lt;p&gt;Step by step quickstart guide can be found in the full docs here &lt;a href=&#34;https://linkfree.eddiehub.io/docs/quickstart&#34;&gt;https://linkfree.eddiehub.io/docs/quickstart&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Looking for inspiration? You can view the following profiles for an example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/EddieHubCommunity/LinkFree/raw/main/data/eddiejaoude.json&#34;&gt;Eddie Jaoude&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/EddieHubCommunity/LinkFree/raw/main/data/krupalitrivedi.json&#34;&gt;Krupali Trivedi || Chai&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/EddieHubCommunity/LinkFree/raw/main/data/Pradumnasaraf.json&#34;&gt;Pradumna Saraf&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;🛡️ License&lt;/h2&gt; &#xA;&lt;p&gt;LinkFree is licensed under the MIT License - see the &lt;a href=&#34;https://raw.githubusercontent.com/EddieHubCommunity/LinkFree/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file for details.&lt;/p&gt; &#xA;&lt;h2&gt;🧰 Contributing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contributions make the open source community such an amazing place to learn, inspire, and create.&lt;/li&gt; &#xA; &lt;li&gt;Any contributions you make are &lt;strong&gt;truly appreciated&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;🙏 Support&lt;/h2&gt; &#xA;&lt;p&gt;Don&#39;t forget to leave a star ⭐️&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>WhatsApp/proxy</title>
    <updated>2023-01-08T01:30:02Z</updated>
    <id>tag:github.com,2023-01-08:/WhatsApp/proxy</id>
    <link href="https://github.com/WhatsApp/proxy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This repository contains the WhatsApp proxy implementation for users to host their own proxy infrastructure to connect to WhatsApp for chat (VoIP and media upload/download not currently proxied)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;WhatsApp Chat Proxy&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/WhatsApp/proxy&#34;&gt;&lt;img alt=&#34;github&#34; src=&#34;https://img.shields.io/badge/github-WhatsApp/proxy-8da0cb?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=github&#34; height=&#34;20&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/WhatsApp/proxy/actions?query=branch%3Amain&#34;&gt;&lt;img alt=&#34;build status&#34; src=&#34;https://img.shields.io/github/workflow/status/WhatsApp/proxy/ci/main?style=for-the-badge&#34; height=&#34;20&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you are unable to connect directly to WhatsApp, a proxy can be used as a gateway between you and our servers. To help yourself or others re-establish connection to WhatsApp, you can set up a proxy server.&lt;/p&gt; &#xA;&lt;p&gt;If you already have a proxy to use, you can connect it to WhatsApp by following the steps in this &lt;a href=&#34;https://faq.whatsapp.com/520504143274092&#34;&gt;article&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;What you&#39;ll need&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/install/&#34;&gt;Docker&lt;/a&gt; (enable Docker on startup if your host system allows)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;Docker compose&lt;/a&gt; (optional)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Setting up your proxy&lt;/h2&gt; &#xA;&lt;h3&gt;1. Clone the repository to your local machine&lt;/h3&gt; &#xA;&lt;h3&gt;2. &lt;a href=&#34;https://docs.docker.com/get-docker/&#34;&gt;Install Docker&lt;/a&gt; for your system&lt;/h3&gt; &#xA;&lt;h3&gt;3. Install Docker compose&lt;/h3&gt; &#xA;&lt;p&gt;For Linux users, if your &lt;a href=&#34;https://docs.docker.com/desktop/install/linux-install/&#34;&gt;version of Docker&lt;/a&gt; doesn&#39;t come pre-installed with Docker compose, you can install a one-off version (For Linux).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Download the pkg&#xA;sudo curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o /usr/bin/docker-compose&#xA;# Enable execution of the script&#xA;sudo chmod +x /usr/bin/docker-compose&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3. Build the proxy host container&lt;/h3&gt; &#xA;&lt;p&gt;Build the proxy host container with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build /path_to_cloned_repository/proxy/ -t whatsapp_proxy:1.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The container will be compiled and tagged as &lt;code&gt;whatsapp_proxy:1.0&lt;/code&gt; for easy reference.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Please note&lt;/strong&gt;, the &lt;code&gt;/path_to_cloned_repository&lt;/code&gt; should the same folder where you cloned this repository in step 1 above. Additionally, the Dockerfile to build the container is in a sub-folder &lt;strong&gt;proxy&lt;/strong&gt; of the repository.&lt;/p&gt; &#xA;&lt;h2&gt;Running the proxy&lt;/h2&gt; &#xA;&lt;h3&gt;Manually execute the container&lt;/h3&gt; &#xA;&lt;p&gt;You can manually execute the Docker container with the following &lt;code&gt;docker&lt;/code&gt; command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -it -p 80:80 -p 443:443 -p 5222:5222 -p 8080:8080 -p 8443:8443 -p 8222:8222 -p 8199:8199 whatsapp_proxy:1.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Automate the container lifecycle with Docker compose&lt;/h3&gt; &#xA;&lt;p&gt;Docker Compose is an automated tool to run multi-container deployments, but it also helps automate the command-line arguments necessary to run a single container. It is a YAML definition file that denotes all the settings to start up and run the container. It also has restart strategies in the event the container crashes or self-restarts. Docker Compose helps manage your container setup and necessary port forwards without user interaction. We recommend utilizing Docker Compose because you usually don’t want to manually run the container outside of testing scenarios.&lt;/p&gt; &#xA;&lt;p&gt;We provide a sample &lt;a href=&#34;https://raw.githubusercontent.com/WhatsApp/proxy/main/proxy/ops/docker-compose.yml&#34;&gt;docker-compose.yml&lt;/a&gt; file for you which defines a standard deployment of the proxy container.&lt;/p&gt; &#xA;&lt;p&gt;Once Docker compose is installed, you can test your specific configuration by running Docker compose interactively with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker compose -f /path/to/this/repo/docker-compose.yml up&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will allow you to see the output from the build + container hosting process and check that everything is set up correctly.&lt;/p&gt; &#xA;&lt;p&gt;When you are ready to run the container as a service, do*:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker compose -f /path/to/this/repo/docker-compose.yml up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;*Note the &lt;code&gt;-d&lt;/code&gt; flag which means &#34;daemonize&#34; and run as a service.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;To stop the container you can similarly do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker compose down&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Automate host reboots with Docker compose&lt;/h3&gt; &#xA;&lt;p&gt;Once you have Docker compose set up, you can also automate the deployment for host reboots by utilizing a &lt;code&gt;systemd&lt;/code&gt; service (if your hosting environment supports it).&lt;/p&gt; &#xA;&lt;p&gt;We provide a sample &lt;a href=&#34;https://raw.githubusercontent.com/WhatsApp/proxy/main/proxy/ops/docker_boot.service&#34;&gt;&lt;code&gt;docker_boot.service&lt;/code&gt;&lt;/a&gt; service definition for you which you should customize to your own environment.&lt;/p&gt; &#xA;&lt;p&gt;To install and setup the &lt;code&gt;systemd&lt;/code&gt; service*:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Copy the service definition to systemd folder&#xA;cp -v docker_boot.service /etc/systemd/system/&#xA;# Enable starting the service on startup&#xA;systemctl enable docker_boot.service&#xA;# Start the service (will docker compose up the container)&#xA;systemctl start docker_boot.service&#xA;# Check container status with&#xA;docker ps&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;*Make sure to update the path to your specific &lt;code&gt;docker-compose.yml&lt;/code&gt; file in the service definition &lt;code&gt;docker_boot.service&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Kubernetes deployment&lt;/h2&gt; &#xA;&lt;p&gt;If you would like to configure your proxy using Kubernetes, or run the Docker runtime through Kubernetes, please see our &lt;a href=&#34;https://raw.githubusercontent.com/WhatsApp/proxy/main/charts/README.md&#34;&gt;Helm chart README&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;An Overview of the WhatsApp Proxy Architecture&lt;/h1&gt; &#xA;&lt;p&gt;Depending on the scenario in which you utilize your proxy, the proxy container exposes multiple ports. The basic ports may include:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;80: Standard web traffic (HTTP)&lt;/li&gt; &#xA; &lt;li&gt;443: Standard web traffic, encrypted (HTTPS)&lt;/li&gt; &#xA; &lt;li&gt;5222: Jabber protocol traffic (WhatsApp default)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;There are also ports configured which accept incoming &lt;a href=&#34;https://www.haproxy.com/blog/use-the-proxy-protocol-to-preserve-a-clients-ip-address/&#34;&gt;proxy headers&lt;/a&gt; (version 1 or 2) on connections. If you have a network load balancer you can preserve the client IP address if you want.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;8080: Standard web traffic (HTTP) with PROXY protocol expected&lt;/li&gt; &#xA; &lt;li&gt;8443: Standard web traffic, encrypted (HTTPS) with PROXY protocol expected&lt;/li&gt; &#xA; &lt;li&gt;8222: Jabber protocol traffic (WhatsApp default) with PROXY protocol expected&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Additionally the container exposes a statistics port on &lt;code&gt;:8199&lt;/code&gt; which can be connected to directly with &lt;code&gt;http://&amp;lt;host-ip&amp;gt;:8199&lt;/code&gt; which you can use to monitor HAProxy statistics.&lt;/p&gt; &#xA;&lt;h2&gt;Certificate generation for SSL encrypted ports&lt;/h2&gt; &#xA;&lt;p&gt;Ports 443 and 8443 are protected by a self-signed encryption certificate generated at container start time. There are some custom options should you wish to tweak the settings of the generated certificates&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SSL_DNS&lt;/code&gt; comma seperate list of alternative hostnames, no default&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SSL_IP&lt;/code&gt; comma seperate list of alternative IPs, no default&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;They can be set with commands like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build . --build-arg SSL_DNS=test.example.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Contributors&lt;/h1&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;The authors of this code are Sean Lawlor (&lt;a href=&#34;https://github.com/slawlor&#34;&gt;@slawlor&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;To learn more about contributing to this project, &lt;a href=&#34;https://github.com/whatsapp/proxy/raw/main/CONTRIBUTING.md&#34;&gt;see this document&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;This project is licensed under &lt;a href=&#34;https://github.com/novifinancial/akd/raw/main/LICENSE-MIT&#34;&gt;MIT&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>