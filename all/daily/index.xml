<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-28T01:21:15Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Eladlev/AutoPrompt</title>
    <updated>2024-02-28T01:21:15Z</updated>
    <id>tag:github.com,2024-02-28:/Eladlev/AutoPrompt</id>
    <link href="https://github.com/Eladlev/AutoPrompt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A framework for prompt tuning using Intent-based Prompt Calibration&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;!-- community badges --&gt; &lt;a href=&#34;https://discord.gg/G2rSbAf8uP&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Join-Discord-blue.svg?sanitize=true&#34;&gt;&lt;/a&gt; &#xA; &lt;!-- license badge --&gt; &lt;a href=&#34;https://github.com/Eladlev/AutoPrompt/raw/main/LICENSE&#34;&gt; &lt;img alt=&#34;License&#34; src=&#34;https://img.shields.io/badge/License-Apache_2.0-blue.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h1&gt;üìù AutoPrompt&lt;/h1&gt; &#xA;&lt;!-- MARKDOWN LINKS &amp; IMAGES --&gt; &#xA;&lt;!-- https://www.markdownguide.org/basic-syntax/#reference-style-links --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Auto Prompt is a prompt optimization framework designed to enhance and perfect your prompts for real-world use cases.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The framework automatically generates high-quality, detailed prompts tailored to user intentions. It employs a refinement (calibration) process, where it iteratively builds a dataset of challenging edge cases and optimizes the prompt accordingly. This approach not only reduces manual effort in prompt engineering but also effectively addresses common issues such as prompt &lt;a href=&#34;https://arxiv.org/abs/2307.09009&#34;&gt;sensitivity&lt;/a&gt; and inherent prompt &lt;a href=&#34;https://arxiv.org/abs/2311.04205&#34;&gt;ambiguity&lt;/a&gt; issues.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Our mission:&lt;/strong&gt; Empower users to produce high-quality robust prompts using the power of large language models (LLMs).&lt;/p&gt; &#xA;&lt;h1&gt;Why Auto Prompt?&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Prompt Engineering Challenges.&lt;/strong&gt; The quality of LLMs greatly depends on the prompts used. Even &lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/#prompt-sensitivity-example&#34;&gt;minor changes&lt;/a&gt; can significantly affect their performance.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Benchmarking Challenges.&lt;/strong&gt; Creating a benchmark for production-grade prompts is often labour-intensive and time-consuming.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Reliable Prompts.&lt;/strong&gt; Auto Prompt generates robust high-quality prompts, offering measured accuracy and performance enhancement using minimal data and annotation steps.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Modularity and Adaptability.&lt;/strong&gt; With modularity at its core, Auto Prompt integrates seamlessly with popular open-source tools such as LangChain, Wandb, and Argilla, and can be adapted for a variety of tasks, including data synthesis and prompt migration.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;System Overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/AutoPrompt_Diagram.png&#34; alt=&#34;System Overview&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The system is designed for real-world scenarios, such as moderation tasks, which are often challenged by imbalanced data distributions. The system implements the &lt;a href=&#34;https://arxiv.org/abs/2402.03099&#34;&gt;Intent-based Prompt Calibration&lt;/a&gt; method. The process begins with a user-provided initial prompt and task description, optionally including user examples. The refinement process iteratively generates diverse samples, annotates them via user/LLM, and evaluates prompt performance, after which an LLM suggests an improved prompt.&lt;/p&gt; &#xA;&lt;p&gt;The optimization process can be extended to content generation tasks by first devising a ranker prompt and then performing the prompt optimization with this learned ranker. The optimization concludes upon reaching the budget or iteration limit.&lt;/p&gt; &#xA;&lt;p&gt;This joint synthetic data generation and prompt optimization approach outperform traditional methods while requiring minimal data and iterations. Learn more in our paper &lt;a href=&#34;https://arxiv.org/abs/2402.03099&#34;&gt;Intent-based Prompt Calibration: Enhancing prompt optimization with synthetic boundary cases&lt;/a&gt; by E. Levi et al. (2024).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using GPT-4 Turbo, this optimization typically completes in just a few minutes at a cost of under $1.&lt;/strong&gt; To manage costs associated with GPT-4 LLM&#39;s token usage, the framework enables users to set a budget limit for optimization, in USD or token count, configured as illustrated &lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/examples.md#steps-to-run-example&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/autoprompt_recording.gif&#34; alt=&#34;pipeline_recording&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üìñ Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/installation.md&#34;&gt;How to install&lt;/a&gt; (Setup instructions)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/examples.md&#34;&gt;Prompt optimization examples&lt;/a&gt; (Use cases: movie review classification, generation, and chat moderation)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/how-it-works.md&#34;&gt;How it works&lt;/a&gt; (Explanation of pipelines)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/architecture.md&#34;&gt;Architecture guide&lt;/a&gt; (Overview of main components)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üìù Boosts prompt quality with a minimal amount of data and annotation steps.&lt;/li&gt; &#xA; &lt;li&gt;üõ¨ Designed for production use cases like moderation, multi-label classification, and content generation.&lt;/li&gt; &#xA; &lt;li&gt;‚öôÔ∏è Enables seamless migrating of prompts across model versions or LLM providers.&lt;/li&gt; &#xA; &lt;li&gt;üéì Supports prompt squeezing. Combine multiple rules into a single efficient prompt.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;QuickStart&lt;/h2&gt; &#xA;&lt;br&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt; - Download the project&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:Eladlev/AutoPrompt.git&#xA;cd AutoPrompt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Step 2&lt;/strong&gt; - Install dependencies&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Use either Conda or pip, depending on your preference. Using Conda:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;conda env create -f environment_dev.yml&#xA;conda activate AutoPrompt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using pip:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -r requirements.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt; - Configure your LLM.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Set your OpenAI API key by updating the configuration file &lt;code&gt;config/llm_env.yml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If you need help locating your API key, visit this &lt;a href=&#34;https://help.openai.com/en/articles/4936850-where-do-i-find-my-api-key&#34;&gt;link&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;We recommend using &lt;a href=&#34;https://platform.openai.com/docs/guides/gpt&#34;&gt;OpenAI&#39;s GPT-4&lt;/a&gt; for the LLM. Our framework also supports other providers and open-source models, as discussed &lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/installation.md#configure-your-llm&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Step 4&lt;/strong&gt; - Configure your Annotator&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Select an annotation approach for your project. We recommend beginning with a human-in-the-loop method, utilizing &lt;a href=&#34;https://docs.argilla.io/en/latest/index.html&#34;&gt;Argilla&lt;/a&gt;. Follow the &lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/installation.md#configure-human-in-the-loop-annotator-&#34;&gt;Argilla setup instructions&lt;/a&gt; to configure your server. Alternatively, you can set up an LLM as your annotator by following these &lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/installation.md#configure-llm-annotator-&#34;&gt;configuration steps&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The default predictor LLM, GPT-3.5, for estimating prompt performance, is configured in the &lt;code&gt;predictor&lt;/code&gt; section of &lt;code&gt;config/config_default.yml&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Define your budget in the input config yaml file using the &lt;code&gt;max_usage parameter&lt;/code&gt;. For OpenAI models, &lt;code&gt;max_usage&lt;/code&gt; sets the maximum spend in USD. For other LLMs, it limits the maximum token count.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Step 5&lt;/strong&gt; - Run the pipeline&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;First, configure your labels by editing &lt;code&gt;config/config_default.yml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dataset:&#xA;    label_schema: [&#34;Yes&#34;, &#34;No&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a &lt;strong&gt;classification pipeline&lt;/strong&gt;, use the following command from your terminal within the appropriate working directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; python run_pipeline.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the initial prompt and task description are not provided directly as input, you will be guided to provide these details. Alternatively, specify them as command-line arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; python run_pipeline.py \&#xA;    --prompt &#34;Does this movie review contain a spoiler? answer Yes or No&#34; \&#xA;    --task_description &#34;Assistant is an expert classifier that will classify a movie review, and let the user know if it contains a spoiler for the reviewed movie or not.&#34; \&#xA;    --num_steps 30&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can track the optimization progress using the &lt;a href=&#34;https://wandb.ai/site&#34;&gt;W&amp;amp;B&lt;/a&gt; dashboard, with setup instructions available &lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/installation.md#monitoring-weights-and-biases-setup&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Generation pipeline&lt;/h4&gt; &#xA;&lt;p&gt;To run the generation pipeline, use the following example command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; python run_generation_pipeline.py \&#xA;    --prompt &#34;Write a good and comprehensive movie review about a specific movie.&#34; \&#xA;    --task_description &#34;Assistant is a large language model that is tasked with writing movie reviews.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information, refer to our &lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/examples.md#generating-movie-reviews-generation-task&#34;&gt;generation task example&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;Enjoy the results. Completion of these steps yields a &lt;strong&gt;refined (calibrated) prompt&lt;/strong&gt; tailored for your task, alongside a &lt;strong&gt;benchmark&lt;/strong&gt; featuring challenging samples, stored in the default &lt;code&gt;dump&lt;/code&gt; path.&lt;/p&gt; &#xA;&lt;h2&gt;Tips&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Prompt accuracy may fluctuate during the optimization. To identify the best prompts, we recommend continuous refinement following the initial generation of the benchmark. Set the number of optimization iterations with &lt;code&gt;--num_steps&lt;/code&gt; and control sample generation by specifying &lt;code&gt;max_samples&lt;/code&gt; in the &lt;code&gt;dataset&lt;/code&gt; section. For instance, setting &lt;code&gt;max_samples: 50&lt;/code&gt; and &lt;code&gt;--num_steps 30&lt;/code&gt; limits the benchmark to 50 samples, allowing for 25 additional refinement iterations, assuming 10 samples per iteration.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The framework supports checkpoints for easy resumption of optimization from the last saved state. It automatically saves the most recent optimization state in a &lt;code&gt;dump&lt;/code&gt; path. Use &lt;code&gt;--output_dump&lt;/code&gt; to set this path and &lt;code&gt;--load_path&lt;/code&gt; to resume from a checkpoint.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The iterations include multiple calls to the LLM service, with long prompts and requests for a relatively large amount of generated tokens by the LLM. This might take time ~1 minute (especially in the generative tasks), so please be patient.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If there are some issues with the Argilla server connection/error, try to restart the space.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- &#xA;Meanwhile, the num_initialize_samples and num_generated_samples fields within the meta_prompts section specify the counts for initial and per iteration sample generation, respectively. --&gt; &#xA;&lt;h2&gt;Prompt Sensitivity Example&lt;/h2&gt; &#xA;&lt;p&gt;You write a prompt for identifying movie spoilers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Review the content provided and indicate whether it includes any significant plot revelations or critical points that could reveal important elements of the story or its outcome. Respond with &#34;Yes&#34; if it contains such spoilers or critical insights, and &#34;No&#34; if it refrains from unveiling key story elements.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This prompt scores 81 on your &lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/examples.md#filtering-movie-reviews-with-spoilers-classification-task&#34;&gt;benchmark&lt;/a&gt; using GPT-4 LLM. Then, you make a minor modification:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Review the text and determine if it provides essential revelations or critical details about the story that would constitute a spoiler. Respond with &#34;Yes&#34; for the presence of spoilers, and &#34;No&#34; for their absence.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Surprisingly, the second prompt scores 72, representing an 11% drop in accuracy. This illustrates the need for a careful prompt engineering process.&lt;/p&gt; &#xA;&lt;h2&gt;üöÄ Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Your contributions are greatly appreciated! If you&#39;re eager to contribute, kindly refer to our &lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/contributing.md&#34;&gt;Contributing Guidelines&lt;/a&gt;) for detailed information.&lt;/p&gt; &#xA;&lt;!-- For an insight into our future plans, visit our Project Roadmap. --&gt; &#xA;&lt;p&gt;If you wish to be a part of our journey, we invite you to connect with us through our &lt;a href=&#34;https://discord.gg/G2rSbAf8uP&#34;&gt;Discord Community&lt;/a&gt;. We&#39;re excited to have you onboard!&lt;/p&gt; &#xA;&lt;h2&gt;üõ° Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;The AutoPrompt project is provided on an &#34;as-is&#34; basis without any guarantees or warranties, expressed or implied.&lt;/p&gt; &#xA;&lt;p&gt;Our perspective on the optimization and usage of prompts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The core objective of AutoPrompt is to refine and perfect prompts to achieve high-quality results. This is achieved through an iterative calibration process, which helps in reducing errors and enhancing the performance of LLMs. However, the framework does not guarantee absolute correctness or unbiased results in every instance.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;AutoPrompt aims to improve the reliability of prompts and mitigate sensitivity issues, but it does not claim to completely eliminate such issues.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;!-- Our community is committed to exploring the most effective ways to interact with LLMs, fostering a space for diverse views and approaches. --&gt; &#xA;&lt;p&gt;Please note that using LLMs like OpenAI&#39;s GPT-4, supported by AutoPrompt, may lead to significant costs due to token usage. By using AutoPrompt, you acknowledge your responsibility to monitor and manage your token use and expenses. We advise regularly reviewing your LLM provider&#39;s API usage and establishing limits or alerts to prevent unexpected charges. To manage costs associated with GPT-4 LLM&#39;s token usage, the framework enables users to set a budget limit for optimization, in USD or token count, configured as illustrated &lt;a href=&#34;https://raw.githubusercontent.com/Eladlev/AutoPrompt/main/docs/examples.md#steps-to-run-example&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Citation&lt;/h2&gt; &#xA;&lt;p&gt;If you have used our code in your research, please cite our &lt;a href=&#34;https://arxiv.org/abs/2402.03099&#34;&gt;paper&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@misc{2402.03099,&#xA;Author = {Elad Levi and Eli Brosh and Matan Friedmann},&#xA;Title = {Intent-based Prompt Calibration: Enhancing prompt optimization with synthetic boundary cases},&#xA;Year = {2024},&#xA;Eprint = {arXiv:2402.03099},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This framework is licensed under the &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache License, Version 2.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;‚úâÔ∏è Support / Contact us&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://discord.gg/G2rSbAf8uP&#34;&gt;Community Discord&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Our email: &lt;a href=&#34;mailto:autopromptai@gmail.com&#34;&gt;‚Ä´autopromptai@gmail.com‚Ä¨&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>FuelLabs/sway</title>
    <updated>2024-02-28T01:21:15Z</updated>
    <id>tag:github.com,2024-02-28:/FuelLabs/sway</id>
    <link href="https://github.com/FuelLabs/sway" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üå¥ Empowering everyone to build reliable and efficient smart contracts.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Sway&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/FuelLabs/sway/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/FuelLabs/sway/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/forc&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/forc?label=latest&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/forc/&#34;&gt;&lt;img src=&#34;https://docs.rs/forc/badge.svg?sanitize=true&#34; alt=&#34;docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/xfpK4Pe&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/chat%20on-discord-orange?&amp;amp;logo=discord&amp;amp;logoColor=ffffff&amp;amp;color=7389D8&amp;amp;labelColor=6A7EC2&#34; alt=&#34;discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sway is a language developed for the Fuel blockchain. It is heavily inspired by Rust and aims to bring modern language development and performance to the blockchain ecosystem.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;For user documentation, including installing release builds, see the Sway Book: &lt;a href=&#34;https://fuellabs.github.io/sway/latest/&#34;&gt;https://fuellabs.github.io/sway/latest/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For Sway Standard library documentation, see: &lt;a href=&#34;https://fuellabs.github.io/sway/master/std/&#34;&gt;https://fuellabs.github.io/sway/master/std/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Also view the technical reference for the Sway programming language: &lt;a href=&#34;https://fuellabs.github.io/sway/master/reference/&#34;&gt;https://fuellabs.github.io/sway/master/reference/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Building from Source&lt;/h2&gt; &#xA;&lt;p&gt;This section is for developing the Sway compiler and toolchain. For developing contracts and using Sway, see the above documentation section.&lt;/p&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;Sway is built in Rust. To begin, install the Rust toolchain following instructions at &lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt;. Then configure your Rust toolchain to use Rust &lt;code&gt;stable&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rustup default stable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If not already done, add the Cargo bin directory to your &lt;code&gt;PATH&lt;/code&gt; by adding the following line to &lt;code&gt;~/.profile&lt;/code&gt; and restarting the shell session.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export PATH=&#34;${HOME}/.cargo/bin:${PATH}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building Forc&lt;/h3&gt; &#xA;&lt;p&gt;Clone the repository and build the Sway toolchain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone git@github.com:FuelLabs/sway.git&#xA;cd sway&#xA;cargo build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Confirm the Sway toolchain built successfully:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cargo run --bin forc -- --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing to Sway&lt;/h2&gt; &#xA;&lt;p&gt;We welcome contributions to Sway!&lt;/p&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://fuellabs.github.io/sway/master/book/reference/contributing_to_sway.html&#34;&gt;Contributing To Sway&lt;/a&gt; section of the Sway book for guidelines and instructions to help you get started.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>electric-sql/pglite</title>
    <updated>2024-02-28T01:21:15Z</updated>
    <id>tag:github.com,2024-02-28:/electric-sql/pglite</id>
    <link href="https://github.com/electric-sql/pglite" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lightweight Postgres packaged as WASM into a TypeScript library for the browser, Node.js, Bun and Deno&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PGlite - Postgres in WASM&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/electric-sql/pglite/main/screenshot.png&#34; alt=&#34;PGlite&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;PGlite is a WASM Postgres build packaged into a TypeScript client library that enables you to run Postgres in the browser, Node.js and Bun, with no need to install any other dependencies. It is only 3.7mb gzipped.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { PGlite } from &#34;@electric-sql/pglite&#34;&#xA;&#xA;const db = new PGlite()&#xA;await db.query(&#34;select &#39;Hello world&#39; as message;&#34;)&#xA;// -&amp;gt; [ { message: &#34;Hello world&#34; } ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can be used both as an ephemeral in-memory database or with persistance to the file system (Node/Bun) or indexedDB (Browser).&lt;/p&gt; &#xA;&lt;p&gt;Unlike previous &#34;Postgres in the browser&#34; projects, PGlite does not use a Linux virtual machine - it is simply Postgres in WASM.&lt;/p&gt; &#xA;&lt;p&gt;It is being developed at &lt;a href=&#34;http://electric-sql.com&#34;&gt;ElectricSQL&lt;/a&gt; in collaboration with &lt;a href=&#34;http://neon.tech&#34;&gt;Neon&lt;/a&gt;. We plan to continue to build on this experiment, and aim to create a fully capable lightweight WASM Postgres with support for extensions such as pgvector.&lt;/p&gt; &#xA;&lt;h2&gt;Node/Bun&lt;/h2&gt; &#xA;&lt;p&gt;Install into your project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install @electric-sql/pglite&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use the in-memory Postgres:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { PGlite } from &#34;@electric-sql/pglite&#34;&#xA;&#xA;const db = new PGlite()&#xA;await db.query(&#34;select &#39;Hello world&#39; as message;&#34;)&#xA;// -&amp;gt; [ { message: &#34;Hello world&#34; } ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or to persist to the filesystem:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const db = new PGlite(&#39;./path/to/pgdata&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Browser&lt;/h2&gt; &#xA;&lt;p&gt;It can be loaded via JSDeliver or your usual package manager, and for an in-memory Postgres:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&#34;module&#34;&amp;gt;&#xA;import { PGlite } from &#34;https://cdn.jsdelivr.net/npm/@electric-sql/pglite/dist/index.js&#34;;&#xA;&#xA;const db = new PGlite()&#xA;await db.query(&#34;select &#39;Hello world&#39; as message;&#34;)&#xA;// -&amp;gt; [ { message: &#34;Hello world&#34; } ]&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or to persist the database to indexedDB:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const db = new PGlite(&#39;idb://my-pgdata&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Deno&lt;/h2&gt; &#xA;&lt;p&gt;To use the in-memory Postgres, create a file &lt;code&gt;server.ts&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { PGlite } from &#34;npm:@electric-sql/pglite&#34;&#xA;&#xA;Deno.serve(async (_request: Request) =&amp;gt; {&#xA;  const db = new PGlite()&#xA;  const query = await db.query(&#34;select &#39;Hello world&#39; as message;&#34;)&#xA;&#xA;  return new Response(JSON.stringify(query))&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run the file with &lt;code&gt;deno run --allow-net --allow-read server.ts&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;Parameterized queries are not currently supported, but this will be added soon.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;There are a couple of prerequisites:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the Postgres build toolchain - &lt;a href=&#34;https://www.postgresql.org/download/&#34;&gt;https://www.postgresql.org/download/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;emscripten version 3.1.25 - &lt;a href=&#34;https://emscripten.org/docs/getting_started/downloads.html&#34;&gt;https://emscripten.org/docs/getting_started/downloads.html&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To build, checkout the repo, then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git submodule update --init&#xA;cd ./pglite/packages/pglite&#xA;emsdk install 3.1.25&#xA;emsdk activate 3.1.25&#xA;pnpm install&#xA;pnpm build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;PGlite builds on the work of &lt;a href=&#34;https://github.com/kelvich&#34;&gt;Stas Kelvich&lt;/a&gt; of &lt;a href=&#34;https://neon.tech&#34;&gt;Neon&lt;/a&gt; in this &lt;a href=&#34;https://github.com/electric-sql/postgres-wasm&#34;&gt;Postgres fork&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>