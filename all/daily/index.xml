<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-20T01:28:30Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>samber/lo</title>
    <updated>2024-07-20T01:28:30Z</updated>
    <id>tag:github.com,2024-07-20:/samber/lo</id>
    <link href="https://github.com/samber/lo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üí• A Lodash-style Go library based on Go 1.18+ Generics (map, filter, contains, find...)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;lo - Iterate over slices, maps, channels...&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/samber/lo/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/tag/samber/lo.svg?sanitize=true&#34; alt=&#34;tag&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/badge/Go-%3E%3D%201.18-%23007d9c&#34; alt=&#34;Go Version&#34;&gt; &lt;a href=&#34;https://pkg.go.dev/github.com/samber/lo&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/samber/lo?status.svg?sanitize=true&#34; alt=&#34;GoDoc&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/samber/lo/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt; &lt;a href=&#34;https://goreportcard.com/report/github.com/samber/lo&#34;&gt;&lt;img src=&#34;https://goreportcard.com/badge/github.com/samber/lo&#34; alt=&#34;Go report&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/samber/lo&#34;&gt;&lt;img src=&#34;https://img.shields.io/codecov/c/github/samber/lo&#34; alt=&#34;Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/samber/lo/graphs/contributors&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/contributors/samber/lo&#34; alt=&#34;Contributors&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/samber/lo&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;‚ú® &lt;strong&gt;&lt;code&gt;samber/lo&lt;/code&gt; is a Lodash-style Go library based on Go 1.18+ Generics.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;This project started as an experiment with the new generics implementation. It may look like &lt;a href=&#34;https://github.com/lodash/lodash&#34;&gt;Lodash&lt;/a&gt; in some aspects. I used to code with the fantastic &lt;a href=&#34;https://github.com/thoas/go-funk&#34;&gt;&#34;go-funk&#34;&lt;/a&gt; package, but &#34;go-funk&#34; uses reflection and therefore is not typesafe.&lt;/p&gt; &#xA;&lt;p&gt;As expected, benchmarks demonstrate that generics are much faster than implementations based on the &#34;reflect&#34; package. Benchmarks also show similar performance gains compared to pure &lt;code&gt;for&lt;/code&gt; loops. &lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#-benchmark&#34;&gt;See below&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In the future, 5 to 10 helpers will overlap with those coming into the Go standard library (under package names &lt;code&gt;slices&lt;/code&gt; and &lt;code&gt;maps&lt;/code&gt;). I feel this library is legitimate and offers many more valuable abstractions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;See also:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/samber/do&#34;&gt;samber/do&lt;/a&gt;: A dependency injection toolkit based on Go 1.18+ Generics&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/samber/mo&#34;&gt;samber/mo&lt;/a&gt;: Monads based on Go 1.18+ Generics (Option, Result, Either...)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Why this name?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;I wanted a &lt;strong&gt;short name&lt;/strong&gt;, similar to &#34;Lodash&#34; and no Go package uses this name.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/samber/lo/master/img/logo-full.png&#34; alt=&#34;lo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üöÄ Install&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go get github.com/samber/lo@v1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This library is v1 and follows SemVer strictly.&lt;/p&gt; &#xA;&lt;p&gt;No breaking changes will be made to exported APIs before v2.0.0.&lt;/p&gt; &#xA;&lt;p&gt;This library has no dependencies outside the Go standard library.&lt;/p&gt; &#xA;&lt;h2&gt;üí° Usage&lt;/h2&gt; &#xA;&lt;p&gt;You can import &lt;code&gt;lo&lt;/code&gt; using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&#xA;    &#34;github.com/samber/lo&#34;&#xA;    lop &#34;github.com/samber/lo/parallel&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use one of the helpers below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;names := lo.Uniq([]string{&#34;Samuel&#34;, &#34;John&#34;, &#34;Samuel&#34;})&#xA;// []string{&#34;Samuel&#34;, &#34;John&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Most of the time, the compiler will be able to infer the type so that you can call: &lt;code&gt;lo.Uniq([]string{...})&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Tips for lazy developers&lt;/h3&gt; &#xA;&lt;p&gt;I cannot recommend it, but in case you are too lazy for repeating &lt;code&gt;lo.&lt;/code&gt; everywhere, you can import the entire library into the namespace.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&#xA;    . &#34;github.com/samber/lo&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I take no responsibility on this junk. üòÅ üí©&lt;/p&gt; &#xA;&lt;h2&gt;ü§† Spec&lt;/h2&gt; &#xA;&lt;p&gt;GoDoc: &lt;a href=&#34;https://godoc.org/github.com/samber/lo&#34;&gt;https://godoc.org/github.com/samber/lo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Supported helpers for slices:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#filter&#34;&gt;Filter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#map&#34;&gt;Map&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#filtermap&#34;&gt;FilterMap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#flatmap&#34;&gt;FlatMap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#reduce&#34;&gt;Reduce&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#reduceright&#34;&gt;ReduceRight&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#foreach&#34;&gt;ForEach&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#foreachwhile&#34;&gt;ForEachWhile&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#times&#34;&gt;Times&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#uniq&#34;&gt;Uniq&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#uniqby&#34;&gt;UniqBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#groupby&#34;&gt;GroupBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#chunk&#34;&gt;Chunk&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#partitionby&#34;&gt;PartitionBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#flatten&#34;&gt;Flatten&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#interleave&#34;&gt;Interleave&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#shuffle&#34;&gt;Shuffle&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#reverse&#34;&gt;Reverse&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#fill&#34;&gt;Fill&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#repeat&#34;&gt;Repeat&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#repeatby&#34;&gt;RepeatBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#keyby&#34;&gt;KeyBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#associate-alias-slicetomap&#34;&gt;Associate / SliceToMap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#drop&#34;&gt;Drop&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#dropright&#34;&gt;DropRight&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#dropwhile&#34;&gt;DropWhile&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#droprightwhile&#34;&gt;DropRightWhile&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#DropByIndex&#34;&gt;DropByIndex&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#reject&#34;&gt;Reject&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#rejectmap&#34;&gt;RejectMap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#filterreject&#34;&gt;FilterReject&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#count&#34;&gt;Count&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#countby&#34;&gt;CountBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#countvalues&#34;&gt;CountValues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#countvaluesby&#34;&gt;CountValuesBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#subset&#34;&gt;Subset&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#slice&#34;&gt;Slice&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#replace&#34;&gt;Replace&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#replaceall&#34;&gt;ReplaceAll&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#compact&#34;&gt;Compact&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#issorted&#34;&gt;IsSorted&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#issortedbykey&#34;&gt;IsSortedByKey&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#Splice&#34;&gt;Splice&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported helpers for maps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#keys&#34;&gt;Keys&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#HasKey&#34;&gt;HasKey&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#valueor&#34;&gt;ValueOr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#values&#34;&gt;Values&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#pickby&#34;&gt;PickBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#pickbykeys&#34;&gt;PickByKeys&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#pickbyvalues&#34;&gt;PickByValues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#omitby&#34;&gt;OmitBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#omitbykeys&#34;&gt;OmitByKeys&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#omitbyvalues&#34;&gt;OmitByValues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#entries-alias-topairs&#34;&gt;Entries / ToPairs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#fromentries-alias-frompairs&#34;&gt;FromEntries / FromPairs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#invert&#34;&gt;Invert&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#assign&#34;&gt;Assign (merge of maps)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#mapkeys&#34;&gt;MapKeys&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#mapvalues&#34;&gt;MapValues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#mapentries&#34;&gt;MapEntries&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#maptoslice&#34;&gt;MapToSlice&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported math helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#range--rangefrom--rangewithsteps&#34;&gt;Range / RangeFrom / RangeWithSteps&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#clamp&#34;&gt;Clamp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#sum&#34;&gt;Sum&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#sumby&#34;&gt;SumBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#mean&#34;&gt;Mean&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#meanby&#34;&gt;MeanBy&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported helpers for strings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#randomstring&#34;&gt;RandomString&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#substring&#34;&gt;Substring&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#chunkstring&#34;&gt;ChunkString&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#runelength&#34;&gt;RuneLength&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#pascalcase&#34;&gt;PascalCase&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#camelcase&#34;&gt;CamelCase&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#kebabcase&#34;&gt;KebabCase&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#snakecase&#34;&gt;SnakeCase&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#words&#34;&gt;Words&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#capitalize&#34;&gt;Capitalize&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#elipse&#34;&gt;Elipse&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported helpers for tuples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#t2---t9&#34;&gt;T2 -&amp;gt; T9&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#unpack2---unpack9&#34;&gt;Unpack2 -&amp;gt; Unpack9&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#zip2---zip9&#34;&gt;Zip2 -&amp;gt; Zip9&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#zipby2---zipby9&#34;&gt;ZipBy2 -&amp;gt; ZipBy9&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#unzip2---unzip9&#34;&gt;Unzip2 -&amp;gt; Unzip9&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#unzipby2---unzipby9&#34;&gt;UnzipBy2 -&amp;gt; UnzipBy9&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported helpers for time and duration:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#duration&#34;&gt;Duration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#duration0-duration10&#34;&gt;Duration0 -&amp;gt; Duration10&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported helpers for channels:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#channeldispatcher&#34;&gt;ChannelDispatcher&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#slicetochannel&#34;&gt;SliceToChannel&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#generator&#34;&gt;Generator&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#buffer&#34;&gt;Buffer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#bufferwithtimeout&#34;&gt;BufferWithTimeout&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#fanin&#34;&gt;FanIn&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#fanout&#34;&gt;FanOut&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported intersection helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#contains&#34;&gt;Contains&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#containsby&#34;&gt;ContainsBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#every&#34;&gt;Every&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#everyby&#34;&gt;EveryBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#some&#34;&gt;Some&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#someby&#34;&gt;SomeBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#none&#34;&gt;None&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#noneby&#34;&gt;NoneBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#intersect&#34;&gt;Intersect&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#difference&#34;&gt;Difference&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#union&#34;&gt;Union&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#without&#34;&gt;Without&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#withoutempty&#34;&gt;WithoutEmpty&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported search helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#indexof&#34;&gt;IndexOf&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#lastindexof&#34;&gt;LastIndexOf&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#find&#34;&gt;Find&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#findindexof&#34;&gt;FindIndexOf&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#findlastindexof&#34;&gt;FindLastIndexOf&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#findorelse&#34;&gt;FindOrElse&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#findkey&#34;&gt;FindKey&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#findkeyby&#34;&gt;FindKeyBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#finduniques&#34;&gt;FindUniques&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#finduniquesby&#34;&gt;FindUniquesBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#findduplicates&#34;&gt;FindDuplicates&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#findduplicatesby&#34;&gt;FindDuplicatesBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#min&#34;&gt;Min&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#minby&#34;&gt;MinBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#earliest&#34;&gt;Earliest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#earliestby&#34;&gt;EarliestBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#max&#34;&gt;Max&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#maxby&#34;&gt;MaxBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#latest&#34;&gt;Latest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#latestby&#34;&gt;LatestBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#first&#34;&gt;First&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#FirstOrEmpty&#34;&gt;FirstOrEmpty&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#FirstOr&#34;&gt;FirstOr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#last&#34;&gt;Last&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#LastOrEmpty&#34;&gt;LastOrEmpty&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#LastOr&#34;&gt;LastOr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#nth&#34;&gt;Nth&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#sample&#34;&gt;Sample&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#samples&#34;&gt;Samples&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Conditional helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#ternary&#34;&gt;Ternary&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#ternaryf&#34;&gt;TernaryF&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#if--elseif--else&#34;&gt;If / ElseIf / Else&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#switch--case--default&#34;&gt;Switch / Case / Default&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Type manipulation helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#isnil&#34;&gt;IsNil&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#toptr&#34;&gt;ToPtr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#nil&#34;&gt;Nil&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#emptyabletoptr&#34;&gt;EmptyableToPtr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#fromptr&#34;&gt;FromPtr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#fromptror&#34;&gt;FromPtrOr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#tosliceptr&#34;&gt;ToSlicePtr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#toanyslice&#34;&gt;ToAnySlice&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#fromanyslice&#34;&gt;FromAnySlice&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#empty&#34;&gt;Empty&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#isempty&#34;&gt;IsEmpty&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#isnotempty&#34;&gt;IsNotEmpty&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#coalesce&#34;&gt;Coalesce&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#coalesceorempty&#34;&gt;CoalesceOrEmpty&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Function helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#partial&#34;&gt;Partial&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#partial2---partial5&#34;&gt;Partial2 -&amp;gt; Partial5&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Concurrency helpers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#attempt&#34;&gt;Attempt&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#attemptwhile&#34;&gt;AttemptWhile&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#attemptwithdelay&#34;&gt;AttemptWithDelay&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#attemptwhilewithdelay&#34;&gt;AttemptWhileWithDelay&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#debounce&#34;&gt;Debounce&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#debounceby&#34;&gt;DebounceBy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#synchronize&#34;&gt;Synchronize&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#async&#34;&gt;Async&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#transaction&#34;&gt;Transaction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#waitfor&#34;&gt;WaitFor&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#waitforwithcontext&#34;&gt;WaitForWithContext&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Error handling:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#validate&#34;&gt;Validate&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#must&#34;&gt;Must&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#try&#34;&gt;Try&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#try0-6&#34;&gt;Try1 -&amp;gt; Try6&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#tryor&#34;&gt;TryOr&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#tryor0-6&#34;&gt;TryOr1 -&amp;gt; TryOr6&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#trycatch&#34;&gt;TryCatch&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#trywitherrorvalue&#34;&gt;TryWithErrorValue&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#trycatchwitherrorvalue&#34;&gt;TryCatchWithErrorValue&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/#errorsas&#34;&gt;ErrorsAs&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Constraints:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clonable&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Filter&lt;/h3&gt; &#xA;&lt;p&gt;Iterates over a collection and returns an array of all the elements the predicate function returns &lt;code&gt;true&lt;/code&gt; for.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;even := lo.Filter([]int{1, 2, 3, 4}, func(x int, index int) bool {&#xA;    return x%2 == 0&#xA;})&#xA;// []int{2, 4}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/Apjg3WeSi7K&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Map&lt;/h3&gt; &#xA;&lt;p&gt;Manipulates a slice of one type and transforms it into a slice of another type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &#34;github.com/samber/lo&#34;&#xA;&#xA;lo.Map([]int64{1, 2, 3, 4}, func(x int64, index int) string {&#xA;    return strconv.FormatInt(x, 10)&#xA;})&#xA;// []string{&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/OkPcYAhBo0D&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;p&gt;Parallel processing: like &lt;code&gt;lo.Map()&lt;/code&gt;, but the mapper function is called in a goroutine. Results are returned in the same order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lop &#34;github.com/samber/lo/parallel&#34;&#xA;&#xA;lop.Map([]int64{1, 2, 3, 4}, func(x int64, _ int) string {&#xA;    return strconv.FormatInt(x, 10)&#xA;})&#xA;// []string{&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FilterMap&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice which obtained after both filtering and mapping using the given callback function.&lt;/p&gt; &#xA;&lt;p&gt;The callback function should return two values: the result of the mapping operation and whether the result element should be included or not.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;matching := lo.FilterMap([]string{&#34;cpu&#34;, &#34;gpu&#34;, &#34;mouse&#34;, &#34;keyboard&#34;}, func(x string, _ int) (string, bool) {&#xA;    if strings.HasSuffix(x, &#34;pu&#34;) {&#xA;        return &#34;xpu&#34;, true&#xA;    }&#xA;    return &#34;&#34;, false&#xA;})&#xA;// []string{&#34;xpu&#34;, &#34;xpu&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/-AuYXfy7opz&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;FlatMap&lt;/h3&gt; &#xA;&lt;p&gt;Manipulates a slice and transforms and flattens it to a slice of another type. The transform function can either return a slice or a &lt;code&gt;nil&lt;/code&gt;, and in the &lt;code&gt;nil&lt;/code&gt; case no value is added to the final slice.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.FlatMap([]int64{0, 1, 2}, func(x int64, _ int) []string {&#xA;    return []string{&#xA;        strconv.FormatInt(x, 10),&#xA;        strconv.FormatInt(x, 10),&#xA;    }&#xA;})&#xA;// []string{&#34;0&#34;, &#34;0&#34;, &#34;1&#34;, &#34;1&#34;, &#34;2&#34;, &#34;2&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/YSoYmQTA8-U&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Reduce&lt;/h3&gt; &#xA;&lt;p&gt;Reduces a collection to a single value. The value is calculated by accumulating the result of running each element in the collection through an accumulator function. Each successive invocation is supplied with the return value returned by the previous call.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sum := lo.Reduce([]int{1, 2, 3, 4}, func(agg int, item int, _ int) int {&#xA;    return agg + item&#xA;}, 0)&#xA;// 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/R4UHXZNaaUG&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;ReduceRight&lt;/h3&gt; &#xA;&lt;p&gt;Like &lt;code&gt;lo.Reduce&lt;/code&gt; except that it iterates over elements of collection from right to left.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.ReduceRight([][]int{{0, 1}, {2, 3}, {4, 5}}, func(agg []int, item []int, _ int) []int {&#xA;    return append(agg, item...)&#xA;}, []int{})&#xA;// []int{4, 5, 2, 3, 0, 1}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/Fq3W70l7wXF&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;ForEach&lt;/h3&gt; &#xA;&lt;p&gt;Iterates over elements of a collection and invokes the function over each element.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &#34;github.com/samber/lo&#34;&#xA;&#xA;lo.ForEach([]string{&#34;hello&#34;, &#34;world&#34;}, func(x string, _ int) {&#xA;    println(x)&#xA;})&#xA;// prints &#34;hello\nworld\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/oofyiUPRf8t&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;p&gt;Parallel processing: like &lt;code&gt;lo.ForEach()&lt;/code&gt;, but the callback is called as a goroutine.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lop &#34;github.com/samber/lo/parallel&#34;&#xA;&#xA;lop.ForEach([]string{&#34;hello&#34;, &#34;world&#34;}, func(x string, _ int) {&#xA;    println(x)&#xA;})&#xA;// prints &#34;hello\nworld\n&#34; or &#34;world\nhello\n&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ForEachWhile&lt;/h3&gt; &#xA;&lt;p&gt;Iterates over collection elements and invokes iteratee for each element collection return value decide to continue or break, like do while().&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;list := []int64{1, 2, -42, 4}&#xA;&#xA;ForEachWhile(list, func(x int64, _ int) bool {&#xA;    if x &amp;lt; 0 {&#xA;        return false&#xA;    }&#xA;    fmt.Println(x)&#xA;    return true&#xA;})&#xA;&#xA;// 1&#xA;// 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Times&lt;/h3&gt; &#xA;&lt;p&gt;Times invokes the iteratee n times, returning an array of the results of each invocation. The iteratee is invoked with index as argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &#34;github.com/samber/lo&#34;&#xA;&#xA;lo.Times(3, func(i int) string {&#xA;    return strconv.FormatInt(int64(i), 10)&#xA;})&#xA;// []string{&#34;0&#34;, &#34;1&#34;, &#34;2&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/vgQj3Glr6lT&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;p&gt;Parallel processing: like &lt;code&gt;lo.Times()&lt;/code&gt;, but callback is called in goroutine.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lop &#34;github.com/samber/lo/parallel&#34;&#xA;&#xA;lop.Times(3, func(i int) string {&#xA;    return strconv.FormatInt(int64(i), 10)&#xA;})&#xA;// []string{&#34;0&#34;, &#34;1&#34;, &#34;2&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Uniq&lt;/h3&gt; &#xA;&lt;p&gt;Returns a duplicate-free version of an array, in which only the first occurrence of each element is kept. The order of result values is determined by the order they occur in the array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;uniqValues := lo.Uniq([]int{1, 2, 2, 1})&#xA;// []int{1, 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/DTzbeXZ6iEN&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;UniqBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns a duplicate-free version of an array, in which only the first occurrence of each element is kept. The order of result values is determined by the order they occur in the array. It accepts &lt;code&gt;iteratee&lt;/code&gt; which is invoked for each element in array to generate the criterion by which uniqueness is computed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;uniqValues := lo.UniqBy([]int{0, 1, 2, 3, 4, 5}, func(i int) int {&#xA;    return i%3&#xA;})&#xA;// []int{0, 1, 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/g42Z3QSb53u&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;GroupBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns an object composed of keys generated from the results of running each element of collection through iteratee.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lo &#34;github.com/samber/lo&#34;&#xA;&#xA;groups := lo.GroupBy([]int{0, 1, 2, 3, 4, 5}, func(i int) int {&#xA;    return i%3&#xA;})&#xA;// map[int][]int{0: []int{0, 3}, 1: []int{1, 4}, 2: []int{2, 5}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/XnQBd_v6brd&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;p&gt;Parallel processing: like &lt;code&gt;lo.GroupBy()&lt;/code&gt;, but callback is called in goroutine.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lop &#34;github.com/samber/lo/parallel&#34;&#xA;&#xA;lop.GroupBy([]int{0, 1, 2, 3, 4, 5}, func(i int) int {&#xA;    return i%3&#xA;})&#xA;// map[int][]int{0: []int{0, 3}, 1: []int{1, 4}, 2: []int{2, 5}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Chunk&lt;/h3&gt; &#xA;&lt;p&gt;Returns an array of elements split into groups the length of size. If array can&#39;t be split evenly, the final chunk will be the remaining elements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.Chunk([]int{0, 1, 2, 3, 4, 5}, 2)&#xA;// [][]int{{0, 1}, {2, 3}, {4, 5}}&#xA;&#xA;lo.Chunk([]int{0, 1, 2, 3, 4, 5, 6}, 2)&#xA;// [][]int{{0, 1}, {2, 3}, {4, 5}, {6}}&#xA;&#xA;lo.Chunk([]int{}, 2)&#xA;// [][]int{}&#xA;&#xA;lo.Chunk([]int{0}, 2)&#xA;// [][]int{{0}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/EeKl0AuTehH&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;PartitionBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns an array of elements split into groups. The order of grouped values is determined by the order they occur in collection. The grouping is generated from the results of running each element of collection through iteratee.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lo &#34;github.com/samber/lo&#34;&#xA;&#xA;partitions := lo.PartitionBy([]int{-2, -1, 0, 1, 2, 3, 4, 5}, func(x int) string {&#xA;    if x &amp;lt; 0 {&#xA;        return &#34;negative&#34;&#xA;    } else if x%2 == 0 {&#xA;        return &#34;even&#34;&#xA;    }&#xA;    return &#34;odd&#34;&#xA;})&#xA;// [][]int{{-2, -1}, {0, 2, 4}, {1, 3, 5}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/NfQ_nGjkgXW&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;p&gt;Parallel processing: like &lt;code&gt;lo.PartitionBy()&lt;/code&gt;, but callback is called in goroutine. Results are returned in the same order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import lop &#34;github.com/samber/lo/parallel&#34;&#xA;&#xA;partitions := lop.PartitionBy([]int{-2, -1, 0, 1, 2, 3, 4, 5}, func(x int) string {&#xA;    if x &amp;lt; 0 {&#xA;        return &#34;negative&#34;&#xA;    } else if x%2 == 0 {&#xA;        return &#34;even&#34;&#xA;    }&#xA;    return &#34;odd&#34;&#xA;})&#xA;// [][]int{{-2, -1}, {0, 2, 4}, {1, 3, 5}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Flatten&lt;/h3&gt; &#xA;&lt;p&gt;Returns an array a single level deep.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;flat := lo.Flatten([][]int{{0, 1}, {2, 3, 4, 5}})&#xA;// []int{0, 1, 2, 3, 4, 5}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/rbp9ORaMpjw&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Interleave&lt;/h3&gt; &#xA;&lt;p&gt;Round-robin alternating input slices and sequentially appending value at index into result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;interleaved := lo.Interleave([]int{1, 4, 7}, []int{2, 5, 8}, []int{3, 6, 9})&#xA;// []int{1, 2, 3, 4, 5, 6, 7, 8, 9}&#xA;&#xA;interleaved := lo.Interleave([]int{1}, []int{2, 5, 8}, []int{3, 6}, []int{4, 7, 9, 10})&#xA;// []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/-RJkTLQEDVt&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Shuffle&lt;/h3&gt; &#xA;&lt;p&gt;Returns an array of shuffled values. Uses the Fisher-Yates shuffle algorithm.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;randomOrder := lo.Shuffle([]int{0, 1, 2, 3, 4, 5})&#xA;// []int{1, 4, 0, 3, 5, 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/Qp73bnTDnc7&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Reverse&lt;/h3&gt; &#xA;&lt;p&gt;Reverses array so that the first element becomes the last, the second element becomes the second to last, and so on.&lt;/p&gt; &#xA;&lt;p&gt;‚ö†Ô∏è This helper is &lt;strong&gt;mutable&lt;/strong&gt;. This behavior might change in &lt;code&gt;v2.0.0&lt;/code&gt;. See &lt;a href=&#34;https://github.com/samber/lo/issues/160&#34;&gt;#160&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;reverseOrder := lo.Reverse([]int{0, 1, 2, 3, 4, 5})&#xA;// []int{5, 4, 3, 2, 1, 0}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/fhUMLvZ7vS6&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Fill&lt;/h3&gt; &#xA;&lt;p&gt;Fills elements of array with &lt;code&gt;initial&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type foo struct {&#xA;  bar string&#xA;}&#xA;&#xA;func (f foo) Clone() foo {&#xA;  return foo{f.bar}&#xA;}&#xA;&#xA;initializedSlice := lo.Fill([]foo{foo{&#34;a&#34;}, foo{&#34;a&#34;}}, foo{&#34;b&#34;})&#xA;// []foo{foo{&#34;b&#34;}, foo{&#34;b&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/VwR34GzqEub&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Repeat&lt;/h3&gt; &#xA;&lt;p&gt;Builds a slice with N copies of initial value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type foo struct {&#xA;  bar string&#xA;}&#xA;&#xA;func (f foo) Clone() foo {&#xA;  return foo{f.bar}&#xA;}&#xA;&#xA;slice := lo.Repeat(2, foo{&#34;a&#34;})&#xA;// []foo{foo{&#34;a&#34;}, foo{&#34;a&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/g3uHXbmc3b6&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;RepeatBy&lt;/h3&gt; &#xA;&lt;p&gt;Builds a slice with values returned by N calls of callback.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice := lo.RepeatBy(0, func (i int) string {&#xA;    return strconv.FormatInt(int64(math.Pow(float64(i), 2)), 10)&#xA;})&#xA;// []string{}&#xA;&#xA;slice := lo.RepeatBy(5, func(i int) string {&#xA;    return strconv.FormatInt(int64(math.Pow(float64(i), 2)), 10)&#xA;})&#xA;// []string{&#34;0&#34;, &#34;1&#34;, &#34;4&#34;, &#34;9&#34;, &#34;16&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/ozZLCtX_hNU&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;KeyBy&lt;/h3&gt; &#xA;&lt;p&gt;Transforms a slice or an array of structs to a map based on a pivot callback.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.KeyBy([]string{&#34;a&#34;, &#34;aa&#34;, &#34;aaa&#34;}, func(str string) int {&#xA;    return len(str)&#xA;})&#xA;// map[int]string{1: &#34;a&#34;, 2: &#34;aa&#34;, 3: &#34;aaa&#34;}&#xA;&#xA;type Character struct {&#xA;  dir  string&#xA;  code int&#xA;}&#xA;characters := []Character{&#xA;    {dir: &#34;left&#34;, code: 97},&#xA;    {dir: &#34;right&#34;, code: 100},&#xA;}&#xA;result := lo.KeyBy(characters, func(char Character) string {&#xA;    return string(rune(char.code))&#xA;})&#xA;//map[a:{dir:left code:97} d:{dir:right code:100}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/mdaClUAT-zZ&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Associate (alias: SliceToMap)&lt;/h3&gt; &#xA;&lt;p&gt;Returns a map containing key-value pairs provided by transform function applied to elements of the given slice. If any of two pairs would have the same key the last one gets added to the map.&lt;/p&gt; &#xA;&lt;p&gt;The order of keys in returned map is not specified and is not guaranteed to be the same from the original array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;in := []*foo{{baz: &#34;apple&#34;, bar: 1}, {baz: &#34;banana&#34;, bar: 2}}&#xA;&#xA;aMap := lo.Associate(in, func (f *foo) (string, int) {&#xA;    return f.baz, f.bar&#xA;})&#xA;// map[string][int]{ &#34;apple&#34;:1, &#34;banana&#34;:2 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/WHa2CfMO3Lr&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Drop&lt;/h3&gt; &#xA;&lt;p&gt;Drops n elements from the beginning of a slice or array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;l := lo.Drop([]int{0, 1, 2, 3, 4, 5}, 2)&#xA;// []int{2, 3, 4, 5}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/JswS7vXRJP2&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;DropRight&lt;/h3&gt; &#xA;&lt;p&gt;Drops n elements from the end of a slice or array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;l := lo.DropRight([]int{0, 1, 2, 3, 4, 5}, 2)&#xA;// []int{0, 1, 2, 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/GG0nXkSJJa3&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;DropWhile&lt;/h3&gt; &#xA;&lt;p&gt;Drop elements from the beginning of a slice or array while the predicate returns true.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;l := lo.DropWhile([]string{&#34;a&#34;, &#34;aa&#34;, &#34;aaa&#34;, &#34;aa&#34;, &#34;aa&#34;}, func(val string) bool {&#xA;    return len(val) &amp;lt;= 2&#xA;})&#xA;// []string{&#34;aaa&#34;, &#34;aa&#34;, &#34;aa&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/7gBPYw2IK16&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;DropRightWhile&lt;/h3&gt; &#xA;&lt;p&gt;Drop elements from the end of a slice or array while the predicate returns true.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;l := lo.DropRightWhile([]string{&#34;a&#34;, &#34;aa&#34;, &#34;aaa&#34;, &#34;aa&#34;, &#34;aa&#34;}, func(val string) bool {&#xA;    return len(val) &amp;lt;= 2&#xA;})&#xA;// []string{&#34;a&#34;, &#34;aa&#34;, &#34;aaa&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/3-n71oEC0Hz&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;DropByIndex&lt;/h3&gt; &#xA;&lt;p&gt;Drops elements from a slice or array by the index. A negative index will drop elements from the end of the slice.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;l := lo.DropByIndex([]int{0, 1, 2, 3, 4, 5}, 2, 4, -1)&#xA;// []int{0, 1, 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/JswS7vXRJP2&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Reject&lt;/h3&gt; &#xA;&lt;p&gt;The opposite of Filter, this method returns the elements of collection that predicate does not return truthy for.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;odd := lo.Reject([]int{1, 2, 3, 4}, func(x int, _ int) bool {&#xA;    return x%2 == 0&#xA;})&#xA;// []int{1, 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/YkLMODy1WEL&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;RejectMap&lt;/h3&gt; &#xA;&lt;p&gt;The opposite of FilterMap, this method returns a slice which obtained after both filtering and mapping using the given callback function.&lt;/p&gt; &#xA;&lt;p&gt;The callback function should return two values:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the result of the mapping operation and&lt;/li&gt; &#xA; &lt;li&gt;whether the result element should be included or not.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;items := lo.RejectMap([]int{1, 2, 3, 4}, func(x int, _ int) (int, bool) {&#xA;    return x*10, x%2 == 0&#xA;})&#xA;// []int{10, 30}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FilterReject&lt;/h3&gt; &#xA;&lt;p&gt;Mixes Filter and Reject, this method returns two slices, one for the elements of collection that predicate returns truthy for and one for the elements that predicate does not return truthy for.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;kept, rejected := lo.FilterReject([]int{1, 2, 3, 4}, func(x int, _ int) bool {&#xA;    return x%2 == 0&#xA;})&#xA;// []int{2, 4}&#xA;// []int{1, 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Count&lt;/h3&gt; &#xA;&lt;p&gt;Counts the number of elements in the collection that compare equal to value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;count := lo.Count([]int{1, 5, 1}, 1)&#xA;// 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/Y3FlK54yveC&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;CountBy&lt;/h3&gt; &#xA;&lt;p&gt;Counts the number of elements in the collection for which predicate is true.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;count := lo.CountBy([]int{1, 5, 1}, func(i int) bool {&#xA;    return i &amp;lt; 4&#xA;})&#xA;// 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/ByQbNYQQi4X&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;CountValues&lt;/h3&gt; &#xA;&lt;p&gt;Counts the number of each element in the collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.CountValues([]int{})&#xA;// map[int]int{}&#xA;&#xA;lo.CountValues([]int{1, 2})&#xA;// map[int]int{1: 1, 2: 1}&#xA;&#xA;lo.CountValues([]int{1, 2, 2})&#xA;// map[int]int{1: 1, 2: 2}&#xA;&#xA;lo.CountValues([]string{&#34;foo&#34;, &#34;bar&#34;, &#34;&#34;})&#xA;// map[string]int{&#34;&#34;: 1, &#34;foo&#34;: 1, &#34;bar&#34;: 1}&#xA;&#xA;lo.CountValues([]string{&#34;foo&#34;, &#34;bar&#34;, &#34;bar&#34;})&#xA;// map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/-p-PyLT4dfy&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;CountValuesBy&lt;/h3&gt; &#xA;&lt;p&gt;Counts the number of each element in the collection. It ss equivalent to chaining lo.Map and lo.CountValues.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;isEven := func(v int) bool {&#xA;    return v%2==0&#xA;}&#xA;&#xA;lo.CountValuesBy([]int{}, isEven)&#xA;// map[bool]int{}&#xA;&#xA;lo.CountValuesBy([]int{1, 2}, isEven)&#xA;// map[bool]int{false: 1, true: 1}&#xA;&#xA;lo.CountValuesBy([]int{1, 2, 2}, isEven)&#xA;// map[bool]int{false: 1, true: 2}&#xA;&#xA;length := func(v string) int {&#xA;    return len(v)&#xA;}&#xA;&#xA;lo.CountValuesBy([]string{&#34;foo&#34;, &#34;bar&#34;, &#34;&#34;}, length)&#xA;// map[int]int{0: 1, 3: 2}&#xA;&#xA;lo.CountValuesBy([]string{&#34;foo&#34;, &#34;bar&#34;, &#34;bar&#34;}, length)&#xA;// map[int]int{3: 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/2U0dG1SnOmS&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Subset&lt;/h3&gt; &#xA;&lt;p&gt;Returns a copy of a slice from &lt;code&gt;offset&lt;/code&gt; up to &lt;code&gt;length&lt;/code&gt; elements. Like &lt;code&gt;slice[start:start+length]&lt;/code&gt;, but does not panic on overflow.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;in := []int{0, 1, 2, 3, 4}&#xA;&#xA;sub := lo.Subset(in, 2, 3)&#xA;// []int{2, 3, 4}&#xA;&#xA;sub := lo.Subset(in, -4, 3)&#xA;// []int{1, 2, 3}&#xA;&#xA;sub := lo.Subset(in, -2, math.MaxUint)&#xA;// []int{3, 4}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/tOQu1GhFcog&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Slice&lt;/h3&gt; &#xA;&lt;p&gt;Returns a copy of a slice from &lt;code&gt;start&lt;/code&gt; up to, but not including &lt;code&gt;end&lt;/code&gt;. Like &lt;code&gt;slice[start:end]&lt;/code&gt;, but does not panic on overflow.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;in := []int{0, 1, 2, 3, 4}&#xA;&#xA;slice := lo.Slice(in, 0, 5)&#xA;// []int{0, 1, 2, 3, 4}&#xA;&#xA;slice := lo.Slice(in, 2, 3)&#xA;// []int{2}&#xA;&#xA;slice := lo.Slice(in, 2, 6)&#xA;// []int{2, 3, 4}&#xA;&#xA;slice := lo.Slice(in, 4, 3)&#xA;// []int{}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/8XWYhfMMA1h&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Replace&lt;/h3&gt; &#xA;&lt;p&gt;Returns a copy of the slice with the first n non-overlapping instances of old replaced by new.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;in := []int{0, 1, 0, 1, 2, 3, 0}&#xA;&#xA;slice := lo.Replace(in, 0, 42, 1)&#xA;// []int{42, 1, 0, 1, 2, 3, 0}&#xA;&#xA;slice := lo.Replace(in, -1, 42, 1)&#xA;// []int{0, 1, 0, 1, 2, 3, 0}&#xA;&#xA;slice := lo.Replace(in, 0, 42, 2)&#xA;// []int{42, 1, 42, 1, 2, 3, 0}&#xA;&#xA;slice := lo.Replace(in, 0, 42, -1)&#xA;// []int{42, 1, 42, 1, 2, 3, 42}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/XfPzmf9gql6&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;ReplaceAll&lt;/h3&gt; &#xA;&lt;p&gt;Returns a copy of the slice with all non-overlapping instances of old replaced by new.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;in := []int{0, 1, 0, 1, 2, 3, 0}&#xA;&#xA;slice := lo.ReplaceAll(in, 0, 42)&#xA;// []int{42, 1, 42, 1, 2, 3, 42}&#xA;&#xA;slice := lo.ReplaceAll(in, -1, 42)&#xA;// []int{0, 1, 0, 1, 2, 3, 0}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/a9xZFUHfYcV&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Compact&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice of all non-zero elements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;in := []string{&#34;&#34;, &#34;foo&#34;, &#34;&#34;, &#34;bar&#34;, &#34;&#34;}&#xA;&#xA;slice := lo.Compact(in)&#xA;// []string{&#34;foo&#34;, &#34;bar&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/tXiy-iK6PAc&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;IsSorted&lt;/h3&gt; &#xA;&lt;p&gt;Checks if a slice is sorted.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice := lo.IsSorted([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/mc3qR-t4mcx&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;IsSortedByKey&lt;/h3&gt; &#xA;&lt;p&gt;Checks if a slice is sorted by iteratee.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice := lo.IsSortedByKey([]string{&#34;a&#34;, &#34;bb&#34;, &#34;ccc&#34;}, func(s string) int {&#xA;    return len(s)&#xA;})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/wiG6XyBBu49&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Splice&lt;/h3&gt; &#xA;&lt;p&gt;Splice inserts multiple elements at index i. A negative index counts back from the end of the slice. The helper is protected against overflow errors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.Splice([]string{&#34;a&#34;, &#34;b&#34;}, 1, &#34;1&#34;, &#34;2&#34;)&#xA;// []string{&#34;a&#34;, &#34;1&#34;, &#34;2&#34;, &#34;b&#34;}&#xA;&#xA;// negative&#xA;result = lo.Splice([]string{&#34;a&#34;, &#34;b&#34;}, -1, &#34;1&#34;, &#34;2&#34;)&#xA;// []string{&#34;a&#34;, &#34;1&#34;, &#34;2&#34;, &#34;b&#34;}&#xA;&#xA;// overflow&#xA;result = lo.Splice([]string{&#34;a&#34;, &#34;b&#34;}, 42, &#34;1&#34;, &#34;2&#34;)&#xA;// []string{&#34;a&#34;, &#34;b&#34;, &#34;1&#34;, &#34;2&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/G5_GhkeSUBA&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Keys&lt;/h3&gt; &#xA;&lt;p&gt;Creates an array of the map keys.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;keys := lo.Keys(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2})&#xA;// []string{&#34;foo&#34;, &#34;bar&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/Uu11fHASqrU&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;HasKey&lt;/h3&gt; &#xA;&lt;p&gt;Returns whether the given key exists.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;exists := lo.HasKey(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2}, &#34;foo&#34;)&#xA;// true&#xA;&#xA;exists := lo.HasKey(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2}, &#34;baz&#34;)&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/aVwubIvECqS&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Values&lt;/h3&gt; &#xA;&lt;p&gt;Creates an array of the map values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;values := lo.Values(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2})&#xA;// []int{1, 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/nnRTQkzQfF6&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;ValueOr&lt;/h3&gt; &#xA;&lt;p&gt;Returns the value of the given key or the fallback value if the key is not present.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;value := lo.ValueOr(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2}, &#34;foo&#34;, 42)&#xA;// 1&#xA;&#xA;value := lo.ValueOr(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2}, &#34;baz&#34;, 42)&#xA;// 42&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/bAq9mHErB4V&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;PickBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given predicate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.PickBy(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, func(key string, value int) bool {&#xA;    return value%2 == 1&#xA;})&#xA;// map[string]int{&#34;foo&#34;: 1, &#34;baz&#34;: 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/kdg8GR_QMmf&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;PickByKeys&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given keys.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.PickByKeys(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, []string{&#34;foo&#34;, &#34;baz&#34;})&#xA;// map[string]int{&#34;foo&#34;: 1, &#34;baz&#34;: 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/R1imbuci9qU&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;PickByValues&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.PickByValues(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, []int{1, 3})&#xA;// map[string]int{&#34;foo&#34;: 1, &#34;baz&#34;: 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/1zdzSvbfsJc&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;OmitBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given predicate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.OmitBy(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, func(key string, value int) bool {&#xA;    return value%2 == 1&#xA;})&#xA;// map[string]int{&#34;bar&#34;: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/EtBsR43bdsd&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;OmitByKeys&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given keys.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.OmitByKeys(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, []string{&#34;foo&#34;, &#34;baz&#34;})&#xA;// map[string]int{&#34;bar&#34;: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/t1QjCrs-ysk&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;OmitByValues&lt;/h3&gt; &#xA;&lt;p&gt;Returns same map type filtered by given values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.OmitByValues(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, []int{1, 3})&#xA;// map[string]int{&#34;bar&#34;: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/9UYZi-hrs8j&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Entries (alias: ToPairs)&lt;/h3&gt; &#xA;&lt;p&gt;Transforms a map into array of key/value pairs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;entries := lo.Entries(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2})&#xA;// []lo.Entry[string, int]{&#xA;//     {&#xA;//         Key: &#34;foo&#34;,&#xA;//         Value: 1,&#xA;//     },&#xA;//     {&#xA;//         Key: &#34;bar&#34;,&#xA;//         Value: 2,&#xA;//     },&#xA;// }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/3Dhgx46gawJ&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;FromEntries (alias: FromPairs)&lt;/h3&gt; &#xA;&lt;p&gt;Transforms an array of key/value pairs into a map.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := lo.FromEntries([]lo.Entry[string, int]{&#xA;    {&#xA;        Key: &#34;foo&#34;,&#xA;        Value: 1,&#xA;    },&#xA;    {&#xA;        Key: &#34;bar&#34;,&#xA;        Value: 2,&#xA;    },&#xA;})&#xA;// map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/oIr5KHFGCEN&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Invert&lt;/h3&gt; &#xA;&lt;p&gt;Creates a map composed of the inverted keys and values. If map contains duplicate values, subsequent values overwrite property assignments of previous values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m1 := lo.Invert(map[string]int{&#34;a&#34;: 1, &#34;b&#34;: 2})&#xA;// map[int]string{1: &#34;a&#34;, 2: &#34;b&#34;}&#xA;&#xA;m2 := lo.Invert(map[string]int{&#34;a&#34;: 1, &#34;b&#34;: 2, &#34;c&#34;: 1})&#xA;// map[int]string{1: &#34;c&#34;, 2: &#34;b&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/rFQ4rak6iA1&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Assign&lt;/h3&gt; &#xA;&lt;p&gt;Merges multiple maps from left to right.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;mergedMaps := lo.Assign(&#xA;    map[string]int{&#34;a&#34;: 1, &#34;b&#34;: 2},&#xA;    map[string]int{&#34;b&#34;: 3, &#34;c&#34;: 4},&#xA;)&#xA;// map[string]int{&#34;a&#34;: 1, &#34;b&#34;: 3, &#34;c&#34;: 4}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/VhwfJOyxf5o&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;MapKeys&lt;/h3&gt; &#xA;&lt;p&gt;Manipulates a map keys and transforms it to a map of another type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m2 := lo.MapKeys(map[int]int{1: 1, 2: 2, 3: 3, 4: 4}, func(_ int, v int) string {&#xA;    return strconv.FormatInt(int64(v), 10)&#xA;})&#xA;// map[string]int{&#34;1&#34;: 1, &#34;2&#34;: 2, &#34;3&#34;: 3, &#34;4&#34;: 4}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/9_4WPIqOetJ&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;MapValues&lt;/h3&gt; &#xA;&lt;p&gt;Manipulates a map values and transforms it to a map of another type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m1 := map[int]int64{1: 1, 2: 2, 3: 3}&#xA;&#xA;m2 := lo.MapValues(m1, func(x int64, _ int) string {&#xA;    return strconv.FormatInt(x, 10)&#xA;})&#xA;// map[int]string{1: &#34;1&#34;, 2: &#34;2&#34;, 3: &#34;3&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/T_8xAfvcf0W&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;MapEntries&lt;/h3&gt; &#xA;&lt;p&gt;Manipulates a map entries and transforms it to a map of another type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;in := map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2}&#xA;&#xA;out := lo.MapEntries(in, func(k string, v int) (int, string) {&#xA;    return v,k&#xA;})&#xA;// map[int]string{1: &#34;foo&#34;, 2: &#34;bar&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/VuvNQzxKimT&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;MapToSlice&lt;/h3&gt; &#xA;&lt;p&gt;Transforms a map into a slice based on specific iteratee.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := map[int]int64{1: 4, 2: 5, 3: 6}&#xA;&#xA;s := lo.MapToSlice(m, func(k int, v int64) string {&#xA;    return fmt.Sprintf(&#34;%d_%d&#34;, k, v)&#xA;})&#xA;// []string{&#34;1_4&#34;, &#34;2_5&#34;, &#34;3_6&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/ZuiCZpDt6LD&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Range / RangeFrom / RangeWithSteps&lt;/h3&gt; &#xA;&lt;p&gt;Creates an array of numbers (positive and/or negative) progressing from start up to, but not including end.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.Range(4)&#xA;// [0, 1, 2, 3]&#xA;&#xA;result := lo.Range(-4)&#xA;// [0, -1, -2, -3]&#xA;&#xA;result := lo.RangeFrom(1, 5)&#xA;// [1, 2, 3, 4, 5]&#xA;&#xA;result := lo.RangeFrom[float64](1.0, 5)&#xA;// [1.0, 2.0, 3.0, 4.0, 5.0]&#xA;&#xA;result := lo.RangeWithSteps(0, 20, 5)&#xA;// [0, 5, 10, 15]&#xA;&#xA;result := lo.RangeWithSteps[float32](-1.0, -4.0, -1.0)&#xA;// [-1.0, -2.0, -3.0]&#xA;&#xA;result := lo.RangeWithSteps(1, 4, -1)&#xA;// []&#xA;&#xA;result := lo.Range(0)&#xA;// []&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/0r6VimXAi9H&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Clamp&lt;/h3&gt; &#xA;&lt;p&gt;Clamps number within the inclusive lower and upper bounds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r1 := lo.Clamp(0, -10, 10)&#xA;// 0&#xA;&#xA;r2 := lo.Clamp(-42, -10, 10)&#xA;// -10&#xA;&#xA;r3 := lo.Clamp(42, -10, 10)&#xA;// 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/RU4lJNC2hlI&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Sum&lt;/h3&gt; &#xA;&lt;p&gt;Sums the values in a collection.&lt;/p&gt; &#xA;&lt;p&gt;If collection is empty 0 is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;list := []int{1, 2, 3, 4, 5}&#xA;sum := lo.Sum(list)&#xA;// 15&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/upfeJVqs4Bt&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;SumBy&lt;/h3&gt; &#xA;&lt;p&gt;Summarizes the values in a collection using the given return value from the iteration function.&lt;/p&gt; &#xA;&lt;p&gt;If collection is empty 0 is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;strings := []string{&#34;foo&#34;, &#34;bar&#34;}&#xA;sum := lo.SumBy(strings, func(item string) int {&#xA;    return len(item)&#xA;})&#xA;// 6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/Dz_a_7jN_ca&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Mean&lt;/h3&gt; &#xA;&lt;p&gt;Calculates the mean of a collection of numbers.&lt;/p&gt; &#xA;&lt;p&gt;If collection is empty 0 is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;mean := lo.Mean([]int{2, 3, 4, 5})&#xA;// 3&#xA;&#xA;mean := lo.Mean([]float64{2, 3, 4, 5})&#xA;// 3.5&#xA;&#xA;mean := lo.Mean([]float64{})&#xA;// 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MeanBy&lt;/h3&gt; &#xA;&lt;p&gt;Calculates the mean of a collection of numbers using the given return value from the iteration function.&lt;/p&gt; &#xA;&lt;p&gt;If collection is empty 0 is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;list := []string{&#34;aa&#34;, &#34;bbb&#34;, &#34;cccc&#34;, &#34;ddddd&#34;}&#xA;mapper := func(item string) float64 {&#xA;    return float64(len(item))&#xA;}&#xA;&#xA;mean := lo.MeanBy(list, mapper)&#xA;// 3.5&#xA;&#xA;mean := lo.MeanBy([]float64{}, mapper)&#xA;// 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;RandomString&lt;/h3&gt; &#xA;&lt;p&gt;Returns a random string of the specified length and made of the specified charset.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := lo.RandomString(5, lo.LettersCharset)&#xA;// example: &#34;eIGbt&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/rRseOQVVum4&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Substring&lt;/h3&gt; &#xA;&lt;p&gt;Return part of a string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sub := lo.Substring(&#34;hello&#34;, 2, 3)&#xA;// &#34;llo&#34;&#xA;&#xA;sub := lo.Substring(&#34;hello&#34;, -4, 3)&#xA;// &#34;ell&#34;&#xA;&#xA;sub := lo.Substring(&#34;hello&#34;, -2, math.MaxUint)&#xA;// &#34;lo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/TQlxQi82Lu1&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;ChunkString&lt;/h3&gt; &#xA;&lt;p&gt;Returns an array of strings split into groups the length of size. If array can&#39;t be split evenly, the final chunk will be the remaining elements.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.ChunkString(&#34;123456&#34;, 2)&#xA;// []string{&#34;12&#34;, &#34;34&#34;, &#34;56&#34;}&#xA;&#xA;lo.ChunkString(&#34;1234567&#34;, 2)&#xA;// []string{&#34;12&#34;, &#34;34&#34;, &#34;56&#34;, &#34;7&#34;}&#xA;&#xA;lo.ChunkString(&#34;&#34;, 2)&#xA;// []string{&#34;&#34;}&#xA;&#xA;lo.ChunkString(&#34;1&#34;, 2)&#xA;// []string{&#34;1&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/__FLTuJVz54&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;RuneLength&lt;/h3&gt; &#xA;&lt;p&gt;An alias to utf8.RuneCountInString which returns the number of runes in string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sub := lo.RuneLength(&#34;hell√¥&#34;)&#xA;// 5&#xA;&#xA;sub := len(&#34;hell√¥&#34;)&#xA;// 6&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/tuhgW_lWY8l&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;PascalCase&lt;/h3&gt; &#xA;&lt;p&gt;Converts string to pascal case.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := lo.PascalCase(&#34;hello_world&#34;)&#xA;// HelloWorld&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/iZkdeLP9oiB&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;CamelCase&lt;/h3&gt; &#xA;&lt;p&gt;Converts string to camel case.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := lo.CamelCase(&#34;hello_world&#34;)&#xA;// helloWorld&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/dtyFB58MBRp&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;KebabCase&lt;/h3&gt; &#xA;&lt;p&gt;Converts string to kebab case.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := lo.KebabCase(&#34;helloWorld&#34;)&#xA;// hello-world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/2YTuPafwECA&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;SnakeCase&lt;/h3&gt; &#xA;&lt;p&gt;Converts string to snake case.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := lo.SnakeCase(&#34;HelloWorld&#34;)&#xA;// hello_world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/QVKJG9nOnDg&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Words&lt;/h3&gt; &#xA;&lt;p&gt;Splits string into an array of its words.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := lo.Words(&#34;helloWorld&#34;)&#xA;// []string{&#34;hello&#34;, &#34;world&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/2P4zhqqq61g&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Capitalize&lt;/h3&gt; &#xA;&lt;p&gt;Converts the first character of string to upper case and the remaining to lower case.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := lo.Capitalize(&#34;heLLO&#34;)&#xA;// Hello&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Elipse&lt;/h3&gt; &#xA;&lt;p&gt;Truncates a string to a specified length and appends an ellipsis if truncated.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := lo.Elipse(&#34;Lorem Ipsum&#34;, 5)&#xA;// Lo...&#xA;&#xA;str := lo.Elipse(&#34;Lorem Ipsum&#34;, 100)&#xA;// Lorem Ipsum&#xA;&#xA;str := lo.Elipse(&#34;Lorem Ipsum&#34;, 3)&#xA;// ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;T2 -&amp;gt; T9&lt;/h3&gt; &#xA;&lt;p&gt;Creates a tuple from a list of values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;tuple1 := lo.T2(&#34;x&#34;, 1)&#xA;// Tuple2[string, int]{A: &#34;x&#34;, B: 1}&#xA;&#xA;func example() (string, int) { return &#34;y&#34;, 2 }&#xA;tuple2 := lo.T2(example())&#xA;// Tuple2[string, int]{A: &#34;y&#34;, B: 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/IllL3ZO4BQm&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Unpack2 -&amp;gt; Unpack9&lt;/h3&gt; &#xA;&lt;p&gt;Returns values contained in tuple.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r1, r2 := lo.Unpack2(lo.Tuple2[string, int]{&#34;a&#34;, 1})&#xA;// &#34;a&#34;, 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unpack is also available as a method of TupleX.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;tuple2 := lo.T2(&#34;a&#34;, 1)&#xA;a, b := tuple2.Unpack()&#xA;// &#34;a&#34;, 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/xVP_k0kJ96W&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Zip2 -&amp;gt; Zip9&lt;/h3&gt; &#xA;&lt;p&gt;Zip creates a slice of grouped elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on.&lt;/p&gt; &#xA;&lt;p&gt;When collections have different size, the Tuple attributes are filled with zero value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;tuples := lo.Zip2([]string{&#34;a&#34;, &#34;b&#34;}, []int{1, 2})&#xA;// []Tuple2[string, int]{{A: &#34;a&#34;, B: 1}, {A: &#34;b&#34;, B: 2}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/jujaA6GaJTp&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;ZipBy2 -&amp;gt; ZipBy9&lt;/h3&gt; &#xA;&lt;p&gt;ZipBy creates a slice of transformed elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on.&lt;/p&gt; &#xA;&lt;p&gt;When collections have different size, the Tuple attributes are filled with zero value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;items := lo.ZipBy2([]string{&#34;a&#34;, &#34;b&#34;}, []int{1, 2}, func(a string, b int) string {&#xA;    return fmt.Sprintf(&#34;%s-%d&#34;, a, b)&#xA;})&#xA;// []string{&#34;a-1&#34;, &#34;b-2&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unzip2 -&amp;gt; Unzip9&lt;/h3&gt; &#xA;&lt;p&gt;Unzip accepts an array of grouped elements and creates an array regrouping the elements to their pre-zip configuration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a, b := lo.Unzip2([]Tuple2[string, int]{{A: &#34;a&#34;, B: 1}, {A: &#34;b&#34;, B: 2}})&#xA;// []string{&#34;a&#34;, &#34;b&#34;}&#xA;// []int{1, 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/ciHugugvaAW&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;UnzipBy2 -&amp;gt; UnzipBy9&lt;/h3&gt; &#xA;&lt;p&gt;UnzipBy2 iterates over a collection and creates an array regrouping the elements to their pre-zip configuration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a, b := lo.UnzipBy2([]string{&#34;hello&#34;, &#34;john&#34;, &#34;doe&#34;}, func(str string) (string, int) {&#xA;    return str, len(str)&#xA;})&#xA;// []string{&#34;hello&#34;, &#34;john&#34;, &#34;doe&#34;}&#xA;// []int{5, 4, 3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Duration&lt;/h3&gt; &#xA;&lt;p&gt;Returns the time taken to execute a function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;duration := lo.Duration(func() {&#xA;    // very long job&#xA;})&#xA;// 3s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Duration0 -&amp;gt; Duration10&lt;/h3&gt; &#xA;&lt;p&gt;Returns the time taken to execute a function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;duration := lo.Duration0(func() {&#xA;    // very long job&#xA;})&#xA;// 3s&#xA;&#xA;err, duration := lo.Duration1(func() error {&#xA;    // very long job&#xA;    return fmt.Errorf(&#34;an error&#34;)&#xA;})&#xA;// an error&#xA;// 3s&#xA;&#xA;err, duration := lo.Duration3(func() (string, int, error) {&#xA;    // very long job&#xA;    return &#34;hello&#34;, 42, nil&#xA;})&#xA;// hello&#xA;// 42&#xA;// nil&#xA;// 3s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ChannelDispatcher&lt;/h3&gt; &#xA;&lt;p&gt;Distributes messages from input channels into N child channels. Close events are propagated to children.&lt;/p&gt; &#xA;&lt;p&gt;Underlying channels can have a fixed buffer capacity or be unbuffered when cap is 0.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := make(chan int, 42)&#xA;for i := 0; i &amp;lt;= 10; i++ {&#xA;    ch &amp;lt;- i&#xA;}&#xA;&#xA;children := lo.ChannelDispatcher(ch, 5, 10, DispatchingStrategyRoundRobin[int])&#xA;// []&amp;lt;-chan int{...}&#xA;&#xA;consumer := func(c &amp;lt;-chan int) {&#xA;    for {&#xA;        msg, ok := &amp;lt;-c&#xA;        if !ok {&#xA;            println(&#34;closed&#34;)&#xA;&#xA;            break&#xA;        }&#xA;&#xA;        println(msg)&#xA;    }&#xA;}&#xA;&#xA;for i := range children {&#xA;    go consumer(children[i])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Many distributions strategies are available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/channel.go&#34;&gt;lo.DispatchingStrategyRoundRobin&lt;/a&gt;: Distributes messages in a rotating sequential manner.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/channel.go&#34;&gt;lo.DispatchingStrategyRandom&lt;/a&gt;: Distributes messages in a random manner.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/channel.go&#34;&gt;lo.DispatchingStrategyWeightedRandom&lt;/a&gt;: Distributes messages in a weighted manner.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/channel.go&#34;&gt;lo.DispatchingStrategyFirst&lt;/a&gt;: Distributes messages in the first non-full channel.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/channel.go&#34;&gt;lo.DispatchingStrategyLeast&lt;/a&gt;: Distributes messages in the emptiest channel.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/channel.go&#34;&gt;lo.DispatchingStrategyMost&lt;/a&gt;: Distributes to the fullest channel.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some strategies bring fallback, in order to favor non-blocking behaviors. See implementations.&lt;/p&gt; &#xA;&lt;p&gt;For custom strategies, just implement the &lt;code&gt;lo.DispatchingStrategy&lt;/code&gt; prototype:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type DispatchingStrategy[T any] func(message T, messageIndex uint64, channels []&amp;lt;-chan T) int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Eg:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Message struct {&#xA;    TenantID uuid.UUID&#xA;}&#xA;&#xA;func hash(id uuid.UUID) int {&#xA;    h := fnv.New32a()&#xA;    h.Write([]byte(id.String()))&#xA;    return int(h.Sum32())&#xA;}&#xA;&#xA;// Routes messages per TenantID.&#xA;customStrategy := func(message string, messageIndex uint64, channels []&amp;lt;-chan string) int {&#xA;    destination := hash(message) % len(channels)&#xA;&#xA;    // check if channel is full&#xA;    if len(channels[destination]) &amp;lt; cap(channels[destination]) {&#xA;        return destination&#xA;    }&#xA;&#xA;    // fallback when child channel is full&#xA;    return utils.DispatchingStrategyRoundRobin(message, uint64(destination), channels)&#xA;}&#xA;&#xA;children := lo.ChannelDispatcher(ch, 5, 10, customStrategy)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SliceToChannel&lt;/h3&gt; &#xA;&lt;p&gt;Returns a read-only channels of collection elements. Channel is closed after last element. Channel capacity can be customized.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;list := []int{1, 2, 3, 4, 5}&#xA;&#xA;for v := range lo.SliceToChannel(2, list) {&#xA;    println(v)&#xA;}&#xA;// prints 1, then 2, then 3, then 4, then 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ChannelToSlice&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice built from channels items. Blocks until channel closes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;list := []int{1, 2, 3, 4, 5}&#xA;ch := lo.SliceToChannel(2, list)&#xA;&#xA;items := ChannelToSlice(ch)&#xA;// []int{1, 2, 3, 4, 5}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Generator&lt;/h3&gt; &#xA;&lt;p&gt;Implements the generator design pattern. Channel is closed after last element. Channel capacity can be customized.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;generator := func(yield func(int)) {&#xA;    yield(1)&#xA;    yield(2)&#xA;    yield(3)&#xA;}&#xA;&#xA;for v := range lo.Generator(2, generator) {&#xA;    println(v)&#xA;}&#xA;// prints 1, then 2, then 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Buffer&lt;/h3&gt; &#xA;&lt;p&gt;Creates a slice of n elements from a channel. Returns the slice, the slice length, the read time and the channel status (opened/closed).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := lo.SliceToChannel(2, []int{1, 2, 3, 4, 5})&#xA;&#xA;items1, length1, duration1, ok1 := lo.Buffer(ch, 3)&#xA;// []int{1, 2, 3}, 3, 0s, true&#xA;items2, length2, duration2, ok2 := lo.Buffer(ch, 3)&#xA;// []int{4, 5}, 2, 0s, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example: RabbitMQ consumer üëá&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := readFromQueue()&#xA;&#xA;for {&#xA;    // read 1k items&#xA;    items, length, _, ok := lo.Buffer(ch, 1000)&#xA;&#xA;    // do batching stuff&#xA;&#xA;    if !ok {&#xA;        break&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;BufferWithTimeout&lt;/h3&gt; &#xA;&lt;p&gt;Creates a slice of n elements from a channel, with timeout. Returns the slice, the slice length, the read time and the channel status (opened/closed).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;generator := func(yield func(int)) {&#xA;    for i := 0; i &amp;lt; 5; i++ {&#xA;        yield(i)&#xA;        time.Sleep(35*time.Millisecond)&#xA;    }&#xA;}&#xA;&#xA;ch := lo.Generator(0, generator)&#xA;&#xA;items1, length1, duration1, ok1 := lo.BufferWithTimeout(ch, 3, 100*time.Millisecond)&#xA;// []int{1, 2}, 2, 100ms, true&#xA;items2, length2, duration2, ok2 := lo.BufferWithTimeout(ch, 3, 100*time.Millisecond)&#xA;// []int{3, 4, 5}, 3, 75ms, true&#xA;items3, length3, duration2, ok3 := lo.BufferWithTimeout(ch, 3, 100*time.Millisecond)&#xA;// []int{}, 0, 10ms, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example: RabbitMQ consumer üëá&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := readFromQueue()&#xA;&#xA;for {&#xA;    // read 1k items&#xA;    // wait up to 1 second&#xA;    items, length, _, ok := lo.BufferWithTimeout(ch, 1000, 1*time.Second)&#xA;&#xA;    // do batching stuff&#xA;&#xA;    if !ok {&#xA;        break&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example: Multithreaded RabbitMQ consumer üëá&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := readFromQueue()&#xA;&#xA;// 5 workers&#xA;// prefetch 1k messages per worker&#xA;children := lo.ChannelDispatcher(ch, 5, 1000, lo.DispatchingStrategyFirst[int])&#xA;&#xA;consumer := func(c &amp;lt;-chan int) {&#xA;    for {&#xA;        // read 1k items&#xA;        // wait up to 1 second&#xA;        items, length, _, ok := lo.BufferWithTimeout(ch, 1000, 1*time.Second)&#xA;&#xA;        // do batching stuff&#xA;&#xA;        if !ok {&#xA;            break&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;for i := range children {&#xA;    go consumer(children[i])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FanIn&lt;/h3&gt; &#xA;&lt;p&gt;Merge messages from multiple input channels into a single buffered channel. Output messages has no priority. When all upstream channels reach EOF, downstream channel closes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;stream1 := make(chan int, 42)&#xA;stream2 := make(chan int, 42)&#xA;stream3 := make(chan int, 42)&#xA;&#xA;all := lo.FanIn(100, stream1, stream2, stream3)&#xA;// &amp;lt;-chan int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FanOut&lt;/h3&gt; &#xA;&lt;p&gt;Broadcasts all the upstream messages to multiple downstream channels. When upstream channel reach EOF, downstream channels close. If any downstream channels is full, broadcasting is paused.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;stream := make(chan int, 42)&#xA;&#xA;all := lo.FanOut(5, 100, stream)&#xA;// [5]&amp;lt;-chan int&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Contains&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if an element is present in a collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;present := lo.Contains([]int{0, 1, 2, 3, 4, 5}, 5)&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ContainsBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if the predicate function returns &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;present := lo.ContainsBy([]int{0, 1, 2, 3, 4, 5}, func(x int) bool {&#xA;    return x == 3&#xA;})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Every&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if all elements of a subset are contained into a collection or if the subset is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ok := lo.Every([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})&#xA;// true&#xA;&#xA;ok := lo.Every([]int{0, 1, 2, 3, 4, 5}, []int{0, 6})&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;EveryBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if the predicate returns true for all of the elements in the collection or if the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := EveryBy([]int{1, 2, 3, 4}, func(x int) bool {&#xA;    return x &amp;lt; 5&#xA;})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Some&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if at least 1 element of a subset is contained into a collection. If the subset is empty Some returns false.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ok := lo.Some([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})&#xA;// true&#xA;&#xA;ok := lo.Some([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SomeBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if the predicate returns true for any of the elements in the collection. If the collection is empty SomeBy returns false.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := SomeBy([]int{1, 2, 3, 4}, func(x int) bool {&#xA;    return x &amp;lt; 3&#xA;})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;None&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if no element of a subset are contained into a collection or if the subset is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := None([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})&#xA;// false&#xA;b := None([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;NoneBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if the predicate returns true for none of the elements in the collection or if the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;b := NoneBy([]int{1, 2, 3, 4}, func(x int) bool {&#xA;    return x &amp;lt; 0&#xA;})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Intersect&lt;/h3&gt; &#xA;&lt;p&gt;Returns the intersection between two collections.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result1 := lo.Intersect([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})&#xA;// []int{0, 2}&#xA;&#xA;result2 := lo.Intersect([]int{0, 1, 2, 3, 4, 5}, []int{0, 6})&#xA;// []int{0}&#xA;&#xA;result3 := lo.Intersect([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})&#xA;// []int{}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Difference&lt;/h3&gt; &#xA;&lt;p&gt;Returns the difference between two collections.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The first value is the collection of element absent of list2.&lt;/li&gt; &#xA; &lt;li&gt;The second value is the collection of element absent of list1.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;left, right := lo.Difference([]int{0, 1, 2, 3, 4, 5}, []int{0, 2, 6})&#xA;// []int{1, 3, 4, 5}, []int{6}&#xA;&#xA;left, right := lo.Difference([]int{0, 1, 2, 3, 4, 5}, []int{0, 1, 2, 3, 4, 5})&#xA;// []int{}, []int{}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Union&lt;/h3&gt; &#xA;&lt;p&gt;Returns all distinct elements from given collections. Result will not change the order of elements relatively.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;union := lo.Union([]int{0, 1, 2, 3, 4, 5}, []int{0, 2}, []int{0, 10})&#xA;// []int{0, 1, 2, 3, 4, 5, 10}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Without&lt;/h3&gt; &#xA;&lt;p&gt;Returns slice excluding all given values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;subset := lo.Without([]int{0, 2, 10}, 2)&#xA;// []int{0, 10}&#xA;&#xA;subset := lo.Without([]int{0, 2, 10}, 0, 1, 2, 3, 4, 5)&#xA;// []int{10}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;WithoutEmpty&lt;/h3&gt; &#xA;&lt;p&gt;Returns slice excluding empty values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;subset := lo.WithoutEmpty([]int{0, 2, 10})&#xA;// []int{2, 10}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;IndexOf&lt;/h3&gt; &#xA;&lt;p&gt;Returns the index at which the first occurrence of a value is found in an array or return -1 if the value cannot be found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;found := lo.IndexOf([]int{0, 1, 2, 1, 2, 3}, 2)&#xA;// 2&#xA;&#xA;notFound := lo.IndexOf([]int{0, 1, 2, 1, 2, 3}, 6)&#xA;// -1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;LastIndexOf&lt;/h3&gt; &#xA;&lt;p&gt;Returns the index at which the last occurrence of a value is found in an array or return -1 if the value cannot be found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;found := lo.LastIndexOf([]int{0, 1, 2, 1, 2, 3}, 2)&#xA;// 4&#xA;&#xA;notFound := lo.LastIndexOf([]int{0, 1, 2, 1, 2, 3}, 6)&#xA;// -1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Find&lt;/h3&gt; &#xA;&lt;p&gt;Search an element in a slice based on a predicate. It returns element and true if element was found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str, ok := lo.Find([]string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;b&#34;, true&#xA;&#xA;str, ok := lo.Find([]string{&#34;foobar&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;&#34;, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindIndexOf&lt;/h3&gt; &#xA;&lt;p&gt;FindIndexOf searches an element in a slice based on a predicate and returns the index and true. It returns -1 and false if the element is not found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str, index, ok := lo.FindIndexOf([]string{&#34;a&#34;, &#34;b&#34;, &#34;a&#34;, &#34;b&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;b&#34;, 1, true&#xA;&#xA;str, index, ok := lo.FindIndexOf([]string{&#34;foobar&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;&#34;, -1, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindLastIndexOf&lt;/h3&gt; &#xA;&lt;p&gt;FindLastIndexOf searches an element in a slice based on a predicate and returns the index and true. It returns -1 and false if the element is not found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str, index, ok := lo.FindLastIndexOf([]string{&#34;a&#34;, &#34;b&#34;, &#34;a&#34;, &#34;b&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;b&#34;, 4, true&#xA;&#xA;str, index, ok := lo.FindLastIndexOf([]string{&#34;foobar&#34;}, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;&#34;, -1, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindOrElse&lt;/h3&gt; &#xA;&lt;p&gt;Search an element in a slice based on a predicate. It returns the element if found or a given fallback value otherwise.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := lo.FindOrElse([]string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;}, &#34;x&#34;, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;b&#34;&#xA;&#xA;str := lo.FindOrElse([]string{&#34;foobar&#34;}, &#34;x&#34;, func(i string) bool {&#xA;    return i == &#34;b&#34;&#xA;})&#xA;// &#34;x&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindKey&lt;/h3&gt; &#xA;&lt;p&gt;Returns the key of the first value matching.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result1, ok1 := lo.FindKey(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, 2)&#xA;// &#34;bar&#34;, true&#xA;&#xA;result2, ok2 := lo.FindKey(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, 42)&#xA;// &#34;&#34;, false&#xA;&#xA;type test struct {&#xA;    foobar string&#xA;}&#xA;result3, ok3 := lo.FindKey(map[string]test{&#34;foo&#34;: test{&#34;foo&#34;}, &#34;bar&#34;: test{&#34;bar&#34;}, &#34;baz&#34;: test{&#34;baz&#34;}}, test{&#34;foo&#34;})&#xA;// &#34;foo&#34;, true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindKeyBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns the key of the first element predicate returns truthy for.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result1, ok1 := lo.FindKeyBy(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, func(k string, v int) bool {&#xA;    return k == &#34;foo&#34;&#xA;})&#xA;// &#34;foo&#34;, true&#xA;&#xA;result2, ok2 := lo.FindKeyBy(map[string]int{&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3}, func(k string, v int) bool {&#xA;    return false&#xA;})&#xA;// &#34;&#34;, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindUniques&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice with all the unique elements of the collection. The order of result values is determined by the order they occur in the array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;uniqueValues := lo.FindUniques([]int{1, 2, 2, 1, 2, 3})&#xA;// []int{3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindUniquesBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice with all the unique elements of the collection. The order of result values is determined by the order they occur in the array. It accepts &lt;code&gt;iteratee&lt;/code&gt; which is invoked for each element in array to generate the criterion by which uniqueness is computed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;uniqueValues := lo.FindUniquesBy([]int{3, 4, 5, 6, 7}, func(i int) int {&#xA;    return i%3&#xA;})&#xA;// []int{5}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindDuplicates&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice with the first occurrence of each duplicated elements of the collection. The order of result values is determined by the order they occur in the array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;duplicatedValues := lo.FindDuplicates([]int{1, 2, 2, 1, 2, 3})&#xA;// []int{1, 2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FindDuplicatesBy&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice with the first occurrence of each duplicated elements of the collection. The order of result values is determined by the order they occur in the array. It accepts &lt;code&gt;iteratee&lt;/code&gt; which is invoked for each element in array to generate the criterion by which uniqueness is computed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;duplicatedValues := lo.FindDuplicatesBy([]int{3, 4, 5, 6, 7}, func(i int) int {&#xA;    return i%3&#xA;})&#xA;// []int{3, 4}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Min&lt;/h3&gt; &#xA;&lt;p&gt;Search the minimum value of a collection.&lt;/p&gt; &#xA;&lt;p&gt;Returns zero value when the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;min := lo.Min([]int{1, 2, 3})&#xA;// 1&#xA;&#xA;min := lo.Min([]int{})&#xA;// 0&#xA;&#xA;min := lo.Min([]time.Duration{time.Second, time.Hour})&#xA;// 1s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MinBy&lt;/h3&gt; &#xA;&lt;p&gt;Search the minimum value of a collection using the given comparison function.&lt;/p&gt; &#xA;&lt;p&gt;If several values of the collection are equal to the smallest value, returns the first such value.&lt;/p&gt; &#xA;&lt;p&gt;Returns zero value when the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;min := lo.MinBy([]string{&#34;s1&#34;, &#34;string2&#34;, &#34;s3&#34;}, func(item string, min string) bool {&#xA;    return len(item) &amp;lt; len(min)&#xA;})&#xA;// &#34;s1&#34;&#xA;&#xA;min := lo.MinBy([]string{}, func(item string, min string) bool {&#xA;    return len(item) &amp;lt; len(min)&#xA;})&#xA;// &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Earliest&lt;/h3&gt; &#xA;&lt;p&gt;Search the minimum time.Time of a collection.&lt;/p&gt; &#xA;&lt;p&gt;Returns zero value when the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;earliest := lo.Earliest(time.Now(), time.Time{})&#xA;// 0001-01-01 00:00:00 +0000 UTC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;EarliestBy&lt;/h3&gt; &#xA;&lt;p&gt;Search the minimum time.Time of a collection using the given iteratee function.&lt;/p&gt; &#xA;&lt;p&gt;Returns zero value when the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type foo struct {&#xA;    bar time.Time&#xA;}&#xA;&#xA;earliest := lo.EarliestBy([]foo{{time.Now()}, {}}, func(i foo) time.Time {&#xA;    return i.bar&#xA;})&#xA;// {bar:{2023-04-01 01:02:03 +0000 UTC}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Max&lt;/h3&gt; &#xA;&lt;p&gt;Search the maximum value of a collection.&lt;/p&gt; &#xA;&lt;p&gt;Returns zero value when the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;max := lo.Max([]int{1, 2, 3})&#xA;// 3&#xA;&#xA;max := lo.Max([]int{})&#xA;// 0&#xA;&#xA;max := lo.Max([]time.Duration{time.Second, time.Hour})&#xA;// 1h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MaxBy&lt;/h3&gt; &#xA;&lt;p&gt;Search the maximum value of a collection using the given comparison function.&lt;/p&gt; &#xA;&lt;p&gt;If several values of the collection are equal to the greatest value, returns the first such value.&lt;/p&gt; &#xA;&lt;p&gt;Returns zero value when the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;max := lo.MaxBy([]string{&#34;string1&#34;, &#34;s2&#34;, &#34;string3&#34;}, func(item string, max string) bool {&#xA;    return len(item) &amp;gt; len(max)&#xA;})&#xA;// &#34;string1&#34;&#xA;&#xA;max := lo.MaxBy([]string{}, func(item string, max string) bool {&#xA;    return len(item) &amp;gt; len(max)&#xA;})&#xA;// &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Latest&lt;/h3&gt; &#xA;&lt;p&gt;Search the maximum time.Time of a collection.&lt;/p&gt; &#xA;&lt;p&gt;Returns zero value when the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;latest := lo.Latest([]time.Time{time.Now(), time.Time{}})&#xA;// 2023-04-01 01:02:03 +0000 UTC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;LatestBy&lt;/h3&gt; &#xA;&lt;p&gt;Search the maximum time.Time of a collection using the given iteratee function.&lt;/p&gt; &#xA;&lt;p&gt;Returns zero value when the collection is empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type foo struct {&#xA;    bar time.Time&#xA;}&#xA;&#xA;latest := lo.LatestBy([]foo{{time.Now()}, {}}, func(i foo) time.Time {&#xA;    return i.bar&#xA;})&#xA;// {bar:{2023-04-01 01:02:03 +0000 UTC}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;First&lt;/h3&gt; &#xA;&lt;p&gt;Returns the first element of a collection and check for availability of the first element.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;first, ok := lo.First([]int{1, 2, 3})&#xA;// 1, true&#xA;&#xA;first, ok := lo.First([]int{})&#xA;// 0, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FirstOrEmpty&lt;/h3&gt; &#xA;&lt;p&gt;Returns the first element of a collection or zero value if empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;first := lo.FirstOrEmpty([]int{1, 2, 3})&#xA;// 1&#xA;&#xA;first := lo.FirstOrEmpty([]int{})&#xA;// 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FirstOr&lt;/h3&gt; &#xA;&lt;p&gt;Returns the first element of a collection or the fallback value if empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;first := lo.FirstOr([]int{1, 2, 3}, 245)&#xA;// 1&#xA;&#xA;first := lo.FirstOr([]int{}, 31)&#xA;// 31&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Last&lt;/h3&gt; &#xA;&lt;p&gt;Returns the last element of a collection or error if empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;last, ok := lo.Last([]int{1, 2, 3})&#xA;// 3&#xA;// true&#xA;&#xA;last, ok := lo.Last([]int{})&#xA;// 0&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;LastOrEmpty&lt;/h3&gt; &#xA;&lt;p&gt;Returns the first element of a collection or zero value if empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;last := lo.LastOrEmpty([]int{1, 2, 3})&#xA;// 3&#xA;&#xA;last := lo.LastOrEmpty([]int{})&#xA;// 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;LastOr&lt;/h3&gt; &#xA;&lt;p&gt;Returns the first element of a collection or the fallback value if empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;last := lo.LastOr([]int{1, 2, 3}, 245)&#xA;// 3&#xA;&#xA;last := lo.LastOr([]int{}, 31)&#xA;// 31&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Nth&lt;/h3&gt; &#xA;&lt;p&gt;Returns the element at index &lt;code&gt;nth&lt;/code&gt; of collection. If &lt;code&gt;nth&lt;/code&gt; is negative, the nth element from the end is returned. An error is returned when nth is out of slice bounds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;nth, err := lo.Nth([]int{0, 1, 2, 3}, 2)&#xA;// 2&#xA;&#xA;nth, err := lo.Nth([]int{0, 1, 2, 3}, -2)&#xA;// 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sample&lt;/h3&gt; &#xA;&lt;p&gt;Returns a random item from collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.Sample([]string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;})&#xA;// a random string from []string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;}&#xA;&#xA;lo.Sample([]string{})&#xA;// &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Samples&lt;/h3&gt; &#xA;&lt;p&gt;Returns N random unique items from collection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.Samples([]string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;}, 3)&#xA;// []string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;} in random order&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Ternary&lt;/h3&gt; &#xA;&lt;p&gt;A 1 line if/else statement.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.Ternary(true, &#34;a&#34;, &#34;b&#34;)&#xA;// &#34;a&#34;&#xA;&#xA;result := lo.Ternary(false, &#34;a&#34;, &#34;b&#34;)&#xA;// &#34;b&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/t-D7WBL44h2&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;TernaryF&lt;/h3&gt; &#xA;&lt;p&gt;A 1 line if/else statement whose options are functions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.TernaryF(true, func() string { return &#34;a&#34; }, func() string { return &#34;b&#34; })&#xA;// &#34;a&#34;&#xA;&#xA;result := lo.TernaryF(false, func() string { return &#34;a&#34; }, func() string { return &#34;b&#34; })&#xA;// &#34;b&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Useful to avoid nil-pointer dereferencing in initializations, or avoid running unnecessary code&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var s *string&#xA;&#xA;someStr := TernaryF(s == nil, func() string { return uuid.New().String() }, func() string { return *s })&#xA;// ef782193-c30c-4e2e-a7ae-f8ab5e125e02&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/AO4VW20JoqM&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;If / ElseIf / Else&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.If(true, 1).&#xA;    ElseIf(false, 2).&#xA;    Else(3)&#xA;// 1&#xA;&#xA;result := lo.If(false, 1).&#xA;    ElseIf(true, 2).&#xA;    Else(3)&#xA;// 2&#xA;&#xA;result := lo.If(false, 1).&#xA;    ElseIf(false, 2).&#xA;    Else(3)&#xA;// 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using callbacks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.IfF(true, func () int {&#xA;        return 1&#xA;    }).&#xA;    ElseIfF(false, func () int {&#xA;        return 2&#xA;    }).&#xA;    ElseF(func () int {&#xA;        return 3&#xA;    })&#xA;// 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mixed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.IfF(true, func () int {&#xA;        return 1&#xA;    }).&#xA;    Else(42)&#xA;// 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/WSw3ApMxhyW&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Switch / Case / Default&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.Switch(1).&#xA;    Case(1, &#34;1&#34;).&#xA;    Case(2, &#34;2&#34;).&#xA;    Default(&#34;3&#34;)&#xA;// &#34;1&#34;&#xA;&#xA;result := lo.Switch(2).&#xA;    Case(1, &#34;1&#34;).&#xA;    Case(2, &#34;2&#34;).&#xA;    Default(&#34;3&#34;)&#xA;// &#34;2&#34;&#xA;&#xA;result := lo.Switch(42).&#xA;    Case(1, &#34;1&#34;).&#xA;    Case(2, &#34;2&#34;).&#xA;    Default(&#34;3&#34;)&#xA;// &#34;3&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using callbacks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.Switch(1).&#xA;    CaseF(1, func() string {&#xA;        return &#34;1&#34;&#xA;    }).&#xA;    CaseF(2, func() string {&#xA;        return &#34;2&#34;&#xA;    }).&#xA;    DefaultF(func() string {&#xA;        return &#34;3&#34;&#xA;    })&#xA;// &#34;1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mixed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.Switch(1).&#xA;    CaseF(1, func() string {&#xA;        return &#34;1&#34;&#xA;    }).&#xA;    Default(&#34;42&#34;)&#xA;// &#34;1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/TGbKUMAeRUd&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;IsNil&lt;/h3&gt; &#xA;&lt;p&gt;Checks if a value is nil or if it&#39;s a reference type with a nil underlying value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x int&#xA;IsNil(x))&#xA;// false&#xA;&#xA;var k struct{}&#xA;IsNil(k)&#xA;// false&#xA;&#xA;var i *int&#xA;IsNil(i)&#xA;// true&#xA;&#xA;var ifaceWithNilValue any = (*string)(nil)&#xA;IsNil(ifaceWithNilValue)&#xA;// true&#xA;ifaceWithNilValue == nil&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ToPtr&lt;/h3&gt; &#xA;&lt;p&gt;Returns a pointer copy of the value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ptr := lo.ToPtr(&#34;hello world&#34;)&#xA;// *string{&#34;hello world&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Nil&lt;/h3&gt; &#xA;&lt;p&gt;Returns a nil pointer of type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ptr := lo.Nil[float64]()&#xA;// nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;EmptyableToPtr&lt;/h3&gt; &#xA;&lt;p&gt;Returns a pointer copy of value if it&#39;s nonzero. Otherwise, returns nil pointer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ptr := lo.EmptyableToPtr(nil)&#xA;// nil&#xA;&#xA;ptr := lo.EmptyableToPtr(&#34;&#34;)&#xA;// nil&#xA;&#xA;ptr := lo.EmptyableToPtr([]int{})&#xA;// *[]int{}&#xA;&#xA;ptr := lo.EmptyableToPtr(&#34;hello world&#34;)&#xA;// *string{&#34;hello world&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FromPtr&lt;/h3&gt; &#xA;&lt;p&gt;Returns the pointer value or empty.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := &#34;hello world&#34;&#xA;value := lo.FromPtr(&amp;amp;str)&#xA;// &#34;hello world&#34;&#xA;&#xA;value := lo.FromPtr(nil)&#xA;// &#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FromPtrOr&lt;/h3&gt; &#xA;&lt;p&gt;Returns the pointer value or the fallback value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str := &#34;hello world&#34;&#xA;value := lo.FromPtrOr(&amp;amp;str, &#34;empty&#34;)&#xA;// &#34;hello world&#34;&#xA;&#xA;value := lo.FromPtrOr(nil, &#34;empty&#34;)&#xA;// &#34;empty&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ToSlicePtr&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice of pointer copy of value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ptr := lo.ToSlicePtr([]string{&#34;hello&#34;, &#34;world&#34;})&#xA;// []*string{&#34;hello&#34;, &#34;world&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ToAnySlice&lt;/h3&gt; &#xA;&lt;p&gt;Returns a slice with all elements mapped to &lt;code&gt;any&lt;/code&gt; type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;elements := lo.ToAnySlice([]int{1, 5, 1})&#xA;// []any{1, 5, 1}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FromAnySlice&lt;/h3&gt; &#xA;&lt;p&gt;Returns an &lt;code&gt;any&lt;/code&gt; slice with all elements mapped to a type. Returns false in case of type conversion failure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;elements, ok := lo.FromAnySlice([]any{&#34;foobar&#34;, 42})&#xA;// []string{}, false&#xA;&#xA;elements, ok := lo.FromAnySlice([]any{&#34;foobar&#34;, &#34;42&#34;})&#xA;// []string{&#34;foobar&#34;, &#34;42&#34;}, true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Empty&lt;/h3&gt; &#xA;&lt;p&gt;Returns an empty value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.Empty[int]()&#xA;// 0&#xA;lo.Empty[string]()&#xA;// &#34;&#34;&#xA;lo.Empty[bool]()&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;IsEmpty&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if argument is a zero value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.IsEmpty(0)&#xA;// true&#xA;lo.IsEmpty(42)&#xA;// false&#xA;&#xA;lo.IsEmpty(&#34;&#34;)&#xA;// true&#xA;lo.IsEmpty(&#34;foobar&#34;)&#xA;// false&#xA;&#xA;type test struct {&#xA;    foobar string&#xA;}&#xA;&#xA;lo.IsEmpty(test{foobar: &#34;&#34;})&#xA;// true&#xA;lo.IsEmpty(test{foobar: &#34;foobar&#34;})&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;IsNotEmpty&lt;/h3&gt; &#xA;&lt;p&gt;Returns true if argument is a zero value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lo.IsNotEmpty(0)&#xA;// false&#xA;lo.IsNotEmpty(42)&#xA;// true&#xA;&#xA;lo.IsNotEmpty(&#34;&#34;)&#xA;// false&#xA;lo.IsNotEmpty(&#34;foobar&#34;)&#xA;// true&#xA;&#xA;type test struct {&#xA;    foobar string&#xA;}&#xA;&#xA;lo.IsNotEmpty(test{foobar: &#34;&#34;})&#xA;// false&#xA;lo.IsNotEmpty(test{foobar: &#34;foobar&#34;})&#xA;// true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Coalesce&lt;/h3&gt; &#xA;&lt;p&gt;Returns the first non-empty arguments. Arguments must be comparable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result, ok := lo.Coalesce(0, 1, 2, 3)&#xA;// 1 true&#xA;&#xA;result, ok := lo.Coalesce(&#34;&#34;)&#xA;// &#34;&#34; false&#xA;&#xA;var nilStr *string&#xA;str := &#34;foobar&#34;&#xA;result, ok := lo.Coalesce(nil, nilStr, &amp;amp;str)&#xA;// &amp;amp;&#34;foobar&#34; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CoalesceOrEmpty&lt;/h3&gt; &#xA;&lt;p&gt;Returns the first non-empty arguments. Arguments must be comparable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;result := lo.CoalesceOrEmpty(0, 1, 2, 3)&#xA;// 1&#xA;&#xA;result := lo.CoalesceOrEmpty(&#34;&#34;)&#xA;// &#34;&#34;&#xA;&#xA;var nilStr *string&#xA;str := &#34;foobar&#34;&#xA;result := lo.CoalesceOrEmpty(nil, nilStr, &amp;amp;str)&#xA;// &amp;amp;&#34;foobar&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Partial&lt;/h3&gt; &#xA;&lt;p&gt;Returns new function that, when called, has its first argument set to the provided value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;add := func(x, y int) int { return x + y }&#xA;f := lo.Partial(add, 5)&#xA;&#xA;f(10)&#xA;// 15&#xA;&#xA;f(42)&#xA;// 47&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Partial2 -&amp;gt; Partial5&lt;/h3&gt; &#xA;&lt;p&gt;Returns new function that, when called, has its first argument set to the provided value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;add := func(x, y, z int) int { return x + y + z }&#xA;f := lo.Partial2(add, 42)&#xA;&#xA;f(10, 5)&#xA;// 57&#xA;&#xA;f(42, -4)&#xA;// 80&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Attempt&lt;/h3&gt; &#xA;&lt;p&gt;Invokes a function N times until it returns valid output. Returning either the caught error or nil. When first argument is less than &lt;code&gt;1&lt;/code&gt;, the function runs until a successful response is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;iter, err := lo.Attempt(42, func(i int) error {&#xA;    if i == 5 {&#xA;        return nil&#xA;    }&#xA;&#xA;    return fmt.Errorf(&#34;failed&#34;)&#xA;})&#xA;// 6&#xA;// nil&#xA;&#xA;iter, err := lo.Attempt(2, func(i int) error {&#xA;    if i == 5 {&#xA;        return nil&#xA;    }&#xA;&#xA;    return fmt.Errorf(&#34;failed&#34;)&#xA;})&#xA;// 2&#xA;// error &#34;failed&#34;&#xA;&#xA;iter, err := lo.Attempt(0, func(i int) error {&#xA;    if i &amp;lt; 42 {&#xA;        return fmt.Errorf(&#34;failed&#34;)&#xA;    }&#xA;&#xA;    return nil&#xA;})&#xA;// 43&#xA;// nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced retry strategies (delay, exponential backoff...), please take a look on &lt;a href=&#34;https://github.com/cenkalti/backoff&#34;&gt;cenkalti/backoff&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/3ggJZ2ZKcMj&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;AttemptWithDelay&lt;/h3&gt; &#xA;&lt;p&gt;Invokes a function N times until it returns valid output, with a pause between each call. Returning either the caught error or nil.&lt;/p&gt; &#xA;&lt;p&gt;When first argument is less than &lt;code&gt;1&lt;/code&gt;, the function runs until a successful response is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;iter, duration, err := lo.AttemptWithDelay(5, 2*time.Second, func(i int, duration time.Duration) error {&#xA;    if i == 2 {&#xA;        return nil&#xA;    }&#xA;&#xA;    return fmt.Errorf(&#34;failed&#34;)&#xA;})&#xA;// 3&#xA;// ~ 4 seconds&#xA;// nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced retry strategies (delay, exponential backoff...), please take a look on &lt;a href=&#34;https://github.com/cenkalti/backoff&#34;&gt;cenkalti/backoff&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/tVs6CygC7m1&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;AttemptWhile&lt;/h3&gt; &#xA;&lt;p&gt;Invokes a function N times until it returns valid output. Returning either the caught error or nil, and along with a bool value to identifying whether it needs invoke function continuously. It will terminate the invoke immediately if second bool value is returned with falsy value.&lt;/p&gt; &#xA;&lt;p&gt;When first argument is less than &lt;code&gt;1&lt;/code&gt;, the function runs until a successful response is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;count1, err1 := lo.AttemptWhile(5, func(i int) (error, bool) {&#xA;    err := doMockedHTTPRequest(i)&#xA;    if err != nil {&#xA;        if errors.Is(err, ErrBadRequest) { // lets assume ErrBadRequest is a critical error that needs to terminate the invoke&#xA;            return err, false // flag the second return value as false to terminate the invoke&#xA;        }&#xA;&#xA;        return err, true&#xA;    }&#xA;&#xA;    return nil, false&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced retry strategies (delay, exponential backoff...), please take a look on &lt;a href=&#34;https://github.com/cenkalti/backoff&#34;&gt;cenkalti/backoff&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/M2wVq24PaZM&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;AttemptWhileWithDelay&lt;/h3&gt; &#xA;&lt;p&gt;Invokes a function N times until it returns valid output, with a pause between each call. Returning either the caught error or nil, and along with a bool value to identifying whether it needs to invoke function continuously. It will terminate the invoke immediately if second bool value is returned with falsy value.&lt;/p&gt; &#xA;&lt;p&gt;When first argument is less than &lt;code&gt;1&lt;/code&gt;, the function runs until a successful response is returned.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;count1, time1, err1 := lo.AttemptWhileWithDelay(5, time.Millisecond, func(i int, d time.Duration) (error, bool) {&#xA;    err := doMockedHTTPRequest(i)&#xA;    if err != nil {&#xA;        if errors.Is(err, ErrBadRequest) { // lets assume ErrBadRequest is a critical error that needs to terminate the invoke&#xA;            return err, false // flag the second return value as false to terminate the invoke&#xA;        }&#xA;&#xA;        return err, true&#xA;    }&#xA;&#xA;    return nil, false&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced retry strategies (delay, exponential backoff...), please take a look on &lt;a href=&#34;https://github.com/cenkalti/backoff&#34;&gt;cenkalti/backoff&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/cfcmhvLO-nv&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Debounce&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;NewDebounce&lt;/code&gt; creates a debounced instance that delays invoking functions given until after wait milliseconds have elapsed, until &lt;code&gt;cancel&lt;/code&gt; is called.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f := func() {&#xA;    println(&#34;Called once after 100ms when debounce stopped invoking!&#34;)&#xA;}&#xA;&#xA;debounce, cancel := lo.NewDebounce(100 * time.Millisecond, f)&#xA;for j := 0; j &amp;lt; 10; j++ {&#xA;    debounce()&#xA;}&#xA;&#xA;time.Sleep(1 * time.Second)&#xA;cancel()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/mz32VMK2nqe&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;DebounceBy&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;NewDebounceBy&lt;/code&gt; creates a debounced instance for each distinct key, that delays invoking functions given until after wait milliseconds have elapsed, until &lt;code&gt;cancel&lt;/code&gt; is called.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f := func(key string, count int) {&#xA;    println(key + &#34;: Called once after 100ms when debounce stopped invoking!&#34;)&#xA;}&#xA;&#xA;debounce, cancel := lo.NewDebounceBy(100 * time.Millisecond, f)&#xA;for j := 0; j &amp;lt; 10; j++ {&#xA;    debounce(&#34;first key&#34;)&#xA;    debounce(&#34;second key&#34;)&#xA;}&#xA;&#xA;time.Sleep(1 * time.Second)&#xA;cancel(&#34;first key&#34;)&#xA;cancel(&#34;second key&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/d3Vpt6pxhY8&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Synchronize&lt;/h3&gt; &#xA;&lt;p&gt;Wraps the underlying callback in a mutex. It receives an optional mutex.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s := lo.Synchronize()&#xA;&#xA;for i := 0; i &amp;lt; 10; i++ {&#xA;    go s.Do(func () {&#xA;        println(&#34;will be called sequentially&#34;)&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is equivalent to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;mu := sync.Mutex{}&#xA;&#xA;func foobar() {&#xA;    mu.Lock()&#xA;    defer mu.Unlock()&#xA;&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Async&lt;/h3&gt; &#xA;&lt;p&gt;Executes a function in a goroutine and returns the result in a channel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := lo.Async(func() error { time.Sleep(10 * time.Second); return nil })&#xA;// chan error (nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Async{0-&amp;gt;6}&lt;/h3&gt; &#xA;&lt;p&gt;Executes a function in a goroutine and returns the result in a channel. For function with multiple return values, the results will be returned as a tuple inside the channel. For function without return, struct{} will be returned in the channel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch := lo.Async0(func() { time.Sleep(10 * time.Second) })&#xA;// chan struct{}&#xA;&#xA;ch := lo.Async1(func() int {&#xA;  time.Sleep(10 * time.Second);&#xA;  return 42&#xA;})&#xA;// chan int (42)&#xA;&#xA;ch := lo.Async2(func() (int, string) {&#xA;  time.Sleep(10 * time.Second);&#xA;  return 42, &#34;Hello&#34;&#xA;})&#xA;// chan lo.Tuple2[int, string] ({42, &#34;Hello&#34;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transaction&lt;/h3&gt; &#xA;&lt;p&gt;Implements a Saga pattern.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;transaction := NewTransaction().&#xA;    Then(&#xA;        func(state int) (int, error) {&#xA;            fmt.Println(&#34;step 1&#34;)&#xA;            return state + 10, nil&#xA;        },&#xA;        func(state int) int {&#xA;            fmt.Println(&#34;rollback 1&#34;)&#xA;            return state - 10&#xA;        },&#xA;    ).&#xA;    Then(&#xA;        func(state int) (int, error) {&#xA;            fmt.Println(&#34;step 2&#34;)&#xA;            return state + 15, nil&#xA;        },&#xA;        func(state int) int {&#xA;            fmt.Println(&#34;rollback 2&#34;)&#xA;            return state - 15&#xA;        },&#xA;    ).&#xA;    Then(&#xA;        func(state int) (int, error) {&#xA;            fmt.Println(&#34;step 3&#34;)&#xA;&#xA;            if true {&#xA;                return state, fmt.Errorf(&#34;error&#34;)&#xA;            }&#xA;&#xA;            return state + 42, nil&#xA;        },&#xA;        func(state int) int {&#xA;            fmt.Println(&#34;rollback 3&#34;)&#xA;            return state - 42&#xA;        },&#xA;    )&#xA;&#xA;_, _ = transaction.Process(-5)&#xA;&#xA;// Output:&#xA;// step 1&#xA;// step 2&#xA;// step 3&#xA;// rollback 2&#xA;// rollback 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;WaitFor&lt;/h3&gt; &#xA;&lt;p&gt;Runs periodically until a condition is validated.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;alwaysTrue := func(i int) bool { return true }&#xA;alwaysFalse := func(i int) bool { return false }&#xA;laterTrue := func(i int) bool {&#xA;    return i &amp;gt; 5&#xA;}&#xA;&#xA;iterations, duration, ok := lo.WaitFor(alwaysTrue, 10*time.Millisecond, 2 * time.Millisecond)&#xA;// 1&#xA;// 1ms&#xA;// true&#xA;&#xA;iterations, duration, ok := lo.WaitFor(alwaysFalse, 10*time.Millisecond, time.Millisecond)&#xA;// 10&#xA;// 10ms&#xA;// false&#xA;&#xA;iterations, duration, ok := lo.WaitFor(laterTrue, 10*time.Millisecond, time.Millisecond)&#xA;// 7&#xA;// 7ms&#xA;// true&#xA;&#xA;iterations, duration, ok := lo.WaitFor(laterTrue, 10*time.Millisecond, 5*time.Millisecond)&#xA;// 2&#xA;// 10ms&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;WaitForWithContext&lt;/h3&gt; &#xA;&lt;p&gt;Runs periodically until a condition is validated or context is invalid.&lt;/p&gt; &#xA;&lt;p&gt;The condition receives also the context, so it can invalidate the process in the condition checker&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ctx := context.Background()&#xA;&#xA;alwaysTrue := func(_ context.Context, i int) bool { return true }&#xA;alwaysFalse := func(_ context.Context, i int) bool { return false }&#xA;laterTrue := func(_ context.Context, i int) bool {&#xA;    return i &amp;gt;= 5&#xA;}&#xA;&#xA;iterations, duration, ok := lo.WaitForWithContext(ctx, alwaysTrue, 10*time.Millisecond, 2 * time.Millisecond)&#xA;// 1&#xA;// 1ms&#xA;// true&#xA;&#xA;iterations, duration, ok := lo.WaitForWithContext(ctx, alwaysFalse, 10*time.Millisecond, time.Millisecond)&#xA;// 10&#xA;// 10ms&#xA;// false&#xA;&#xA;iterations, duration, ok := lo.WaitForWithContext(ctx, laterTrue, 10*time.Millisecond, time.Millisecond)&#xA;// 5&#xA;// 5ms&#xA;// true&#xA;&#xA;iterations, duration, ok := lo.WaitForWithContext(ctx, laterTrue, 10*time.Millisecond, 5*time.Millisecond)&#xA;// 2&#xA;// 10ms&#xA;// false&#xA;&#xA;expiringCtx, cancel := context.WithTimeout(ctx, 5*time.Millisecond)&#xA;iterations, duration, ok := lo.WaitForWithContext(expiringCtx, alwaysFalse, 100*time.Millisecond, time.Millisecond)&#xA;// 5&#xA;// 5.1ms&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Validate&lt;/h3&gt; &#xA;&lt;p&gt;Helper function that creates an error when a condition is not met.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice := []string{&#34;a&#34;}&#xA;val := lo.Validate(len(slice) == 0, &#34;Slice should be empty but contains %v&#34;, slice)&#xA;// error(&#34;Slice should be empty but contains [a]&#34;)&#xA;&#xA;slice := []string{}&#xA;val := lo.Validate(len(slice) == 0, &#34;Slice should be empty but contains %v&#34;, slice)&#xA;// nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/vPyh51XpCBt&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Must&lt;/h3&gt; &#xA;&lt;p&gt;Wraps a function call to panics if second argument is &lt;code&gt;error&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, returns the value otherwise.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;val := lo.Must(time.Parse(&#34;2006-01-02&#34;, &#34;2022-01-15&#34;))&#xA;// 2022-01-15&#xA;&#xA;val := lo.Must(time.Parse(&#34;2006-01-02&#34;, &#34;bad-value&#34;))&#xA;// panics&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/TMoWrRp3DyC&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Must{0-&amp;gt;6}&lt;/h3&gt; &#xA;&lt;p&gt;Must* has the same behavior as Must, but returns multiple values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func example0() (error)&#xA;func example1() (int, error)&#xA;func example2() (int, string, error)&#xA;func example3() (int, string, time.Date, error)&#xA;func example4() (int, string, time.Date, bool, error)&#xA;func example5() (int, string, time.Date, bool, float64, error)&#xA;func example6() (int, string, time.Date, bool, float64, byte, error)&#xA;&#xA;lo.Must0(example0())&#xA;val1 := lo.Must1(example1())    // alias to Must&#xA;val1, val2 := lo.Must2(example2())&#xA;val1, val2, val3 := lo.Must3(example3())&#xA;val1, val2, val3, val4 := lo.Must4(example4())&#xA;val1, val2, val3, val4, val5 := lo.Must5(example5())&#xA;val1, val2, val3, val4, val5, val6 := lo.Must6(example6())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can wrap functions like &lt;code&gt;func (...) (..., ok bool)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// math.Signbit(float64) bool&#xA;lo.Must0(math.Signbit(v))&#xA;&#xA;// bytes.Cut([]byte,[]byte) ([]byte, []byte, bool)&#xA;before, after := lo.Must2(bytes.Cut(s, sep))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can give context to the panic message by adding some printf-like arguments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;val, ok := lo.Find(myString, func(i string) bool {&#xA;    return i == requiredChar&#xA;})&#xA;lo.Must0(ok, &#34;&#39;%s&#39; must always contain &#39;%s&#39;&#34;, myString, requiredChar)&#xA;&#xA;list := []int{0, 1, 2}&#xA;item := 5&#xA;lo.Must0(lo.Contains(list, item), &#34;&#39;%s&#39; must always contain &#39;%s&#39;&#34;, list, item)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/TMoWrRp3DyC&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Try&lt;/h3&gt; &#xA;&lt;p&gt;Calls the function and returns false in case of error and panic.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ok := lo.Try(func() error {&#xA;    panic(&#34;error&#34;)&#xA;    return nil&#xA;})&#xA;// false&#xA;&#xA;ok := lo.Try(func() error {&#xA;    return nil&#xA;})&#xA;// true&#xA;&#xA;ok := lo.Try(func() error {&#xA;    return fmt.Errorf(&#34;error&#34;)&#xA;})&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/mTyyWUvn9u4&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;Try{0-&amp;gt;6}&lt;/h3&gt; &#xA;&lt;p&gt;The same behavior as &lt;code&gt;Try&lt;/code&gt;, but the callback returns 2 variables.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ok := lo.Try2(func() (string, error) {&#xA;    panic(&#34;error&#34;)&#xA;    return &#34;&#34;, nil&#xA;})&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/mTyyWUvn9u4&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;TryOr&lt;/h3&gt; &#xA;&lt;p&gt;Calls the function and return a default value in case of error and on panic.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str, ok := lo.TryOr(func() (string, error) {&#xA;    panic(&#34;error&#34;)&#xA;    return &#34;hello&#34;, nil&#xA;}, &#34;world&#34;)&#xA;// world&#xA;// false&#xA;&#xA;str, ok := lo.TryOr(func() error {&#xA;    return &#34;hello&#34;, nil&#xA;}, &#34;world&#34;)&#xA;// hello&#xA;// true&#xA;&#xA;str, ok := lo.TryOr(func() error {&#xA;    return &#34;hello&#34;, fmt.Errorf(&#34;error&#34;)&#xA;}, &#34;world&#34;)&#xA;// world&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/B4F7Wg2Zh9X&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;TryOr{0-&amp;gt;6}&lt;/h3&gt; &#xA;&lt;p&gt;The same behavior as &lt;code&gt;TryOr&lt;/code&gt;, but the callback returns &lt;code&gt;X&lt;/code&gt; variables.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;str, nbr, ok := lo.TryOr2(func() (string, int, error) {&#xA;    panic(&#34;error&#34;)&#xA;    return &#34;hello&#34;, 42, nil&#xA;}, &#34;world&#34;, 21)&#xA;// world&#xA;// 21&#xA;// false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/B4F7Wg2Zh9X&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;TryWithErrorValue&lt;/h3&gt; &#xA;&lt;p&gt;The same behavior as &lt;code&gt;Try&lt;/code&gt;, but also returns the value passed to panic.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;err, ok := lo.TryWithErrorValue(func() error {&#xA;    panic(&#34;error&#34;)&#xA;    return nil&#xA;})&#xA;// &#34;error&#34;, false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/Kc7afQIT2Fs&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;TryCatch&lt;/h3&gt; &#xA;&lt;p&gt;The same behavior as &lt;code&gt;Try&lt;/code&gt;, but calls the catch function in case of error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;caught := false&#xA;&#xA;ok := lo.TryCatch(func() error {&#xA;    panic(&#34;error&#34;)&#xA;    return nil&#xA;}, func() {&#xA;    caught = true&#xA;})&#xA;// false&#xA;// caught == true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/PnOON-EqBiU&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;TryCatchWithErrorValue&lt;/h3&gt; &#xA;&lt;p&gt;The same behavior as &lt;code&gt;TryWithErrorValue&lt;/code&gt;, but calls the catch function in case of error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;caught := false&#xA;&#xA;ok := lo.TryCatchWithErrorValue(func() error {&#xA;    panic(&#34;error&#34;)&#xA;    return nil&#xA;}, func(val any) {&#xA;    caught = val == &#34;error&#34;&#xA;})&#xA;// false&#xA;// caught == true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/8Pc9gwX_GZO&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;ErrorsAs&lt;/h3&gt; &#xA;&lt;p&gt;A shortcut for:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;err := doSomething()&#xA;&#xA;var rateLimitErr *RateLimitError&#xA;if ok := errors.As(err, &amp;amp;rateLimitErr); ok {&#xA;    // retry later&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;1 line &lt;code&gt;lo&lt;/code&gt; helper:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;err := doSomething()&#xA;&#xA;if rateLimitErr, ok := lo.ErrorsAs[*RateLimitError](err); ok {&#xA;    // retry later&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[&lt;a href=&#34;https://go.dev/play/p/8wk5rH8UfrE&#34;&gt;play&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h2&gt;üõ© Benchmark&lt;/h2&gt; &#xA;&lt;p&gt;We executed a simple benchmark with a dead-simple &lt;code&gt;lo.Map&lt;/code&gt; loop:&lt;/p&gt; &#xA;&lt;p&gt;See the full implementation &lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/benchmark_test.go&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;_ = lo.Map[int64](arr, func(x int64, i int) string {&#xA;    return strconv.FormatInt(x, 10)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Result:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here is a comparison between &lt;code&gt;lo.Map&lt;/code&gt;, &lt;code&gt;lop.Map&lt;/code&gt;, &lt;code&gt;go-funk&lt;/code&gt; library and a simple Go &lt;code&gt;for&lt;/code&gt; loop.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go test -benchmem -bench ./...&#xA;goos: linux&#xA;goarch: amd64&#xA;pkg: github.com/samber/lo&#xA;cpu: Intel(R) Core(TM) i5-7267U CPU @ 3.10GHz&#xA;cpu: Intel(R) Core(TM) i7 CPU         920  @ 2.67GHz&#xA;BenchmarkMap/lo.Map-8         &#x9;       8&#x9; 132728237 ns/op&#x9;39998945 B/op&#x9; 1000002 allocs/op&#xA;BenchmarkMap/lop.Map-8        &#x9;       2&#x9; 503947830 ns/op&#x9;119999956 B/op&#x9; 3000007 allocs/op&#xA;BenchmarkMap/reflect-8        &#x9;       2&#x9; 826400560 ns/op&#x9;170326512 B/op&#x9; 4000042 allocs/op&#xA;BenchmarkMap/for-8            &#x9;       9&#x9; 126252954 ns/op&#x9;39998674 B/op&#x9; 1000001 allocs/op&#xA;PASS&#xA;ok  &#x9;github.com/samber/lo&#x9;6.657s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lo.Map&lt;/code&gt; is way faster (x7) than &lt;code&gt;go-funk&lt;/code&gt;, a reflection-based Map implementation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lo.Map&lt;/code&gt; have the same allocation profile than &lt;code&gt;for&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lo.Map&lt;/code&gt; is 4% slower than &lt;code&gt;for&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lop.Map&lt;/code&gt; is slower than &lt;code&gt;lo.Map&lt;/code&gt; because it implies more memory allocation and locks. &lt;code&gt;lop.Map&lt;/code&gt; will be useful for long-running callbacks, such as i/o bound processing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;for&lt;/code&gt; beats other implementations for memory and CPU.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;ü§ù Contributing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ping me on Twitter &lt;a href=&#34;https://twitter.com/samuelberthe&#34;&gt;@samuelberthe&lt;/a&gt; (DMs, mentions, whatever :))&lt;/li&gt; &#xA; &lt;li&gt;Fork the &lt;a href=&#34;https://github.com/samber/lo&#34;&gt;project&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fix &lt;a href=&#34;https://github.com/samber/lo/issues&#34;&gt;open issues&lt;/a&gt; or request new features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Don&#39;t hesitate ;)&lt;/p&gt; &#xA;&lt;p&gt;Helper naming: helpers must be self-explanatory and respect standards (other languages, libraries...). Feel free to suggest many names in your contributions.&lt;/p&gt; &#xA;&lt;h3&gt;With Docker&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose run --rm dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Without Docker&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install some dev dependencies&#xA;make tools&#xA;&#xA;# Run tests&#xA;make test&#xA;# or&#xA;make watch-test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üë§ Contributors&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://contrib.rocks/image?repo=samber/lo&#34; alt=&#34;Contributors&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üí´ Show your support&lt;/h2&gt; &#xA;&lt;p&gt;Give a ‚≠êÔ∏è if this project helped you!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sponsors/samber&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/sponsors/samber?style=for-the-badge&#34; alt=&#34;GitHub Sponsors&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;üìù License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright ¬© 2022 &lt;a href=&#34;https://github.com/samber&#34;&gt;Samuel Berthe&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This project is under &lt;a href=&#34;https://raw.githubusercontent.com/samber/lo/master/LICENSE&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>abseil/abseil-cpp</title>
    <updated>2024-07-20T01:28:30Z</updated>
    <id>tag:github.com,2024-07-20:/abseil/abseil-cpp</id>
    <link href="https://github.com/abseil/abseil-cpp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Abseil Common Libraries (C++)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Abseil - C++ Common Libraries&lt;/h1&gt; &#xA;&lt;p&gt;The repository contains the Abseil C++ library code. Abseil is an open-source collection of C++ code (compliant to C++14) designed to augment the C++ standard library.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/#about&#34;&gt;About Abseil&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/#quickstart&#34;&gt;Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/#build&#34;&gt;Building Abseil&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/#support&#34;&gt;Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/#codemap&#34;&gt;Codemap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/#releases&#34;&gt;Releases&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/#links&#34;&gt;Links&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;about&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About Abseil&lt;/h2&gt; &#xA;&lt;p&gt;Abseil is an open-source collection of C++ library code designed to augment the C++ standard library. The Abseil library code is collected from Google&#39;s own C++ code base, has been extensively tested and used in production, and is the same code we depend on in our daily coding lives.&lt;/p&gt; &#xA;&lt;p&gt;In some cases, Abseil provides pieces missing from the C++ standard; in others, Abseil provides alternatives to the standard for special needs we&#39;ve found through usage in the Google code base. We denote those cases clearly within the library code we provide you.&lt;/p&gt; &#xA;&lt;p&gt;Abseil is not meant to be a competitor to the standard library; we&#39;ve just found that many of these utilities serve a purpose within our code base, and we now want to provide those resources to the C++ community as a whole.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;quickstart&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;If you want to just get started, make sure you at least run through the &lt;a href=&#34;https://abseil.io/docs/cpp/quickstart&#34;&gt;Abseil Quickstart&lt;/a&gt;. The Quickstart contains information about setting up your development environment, downloading the Abseil code, running tests, and getting a simple binary working.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;build&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Building Abseil&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bazel.build&#34;&gt;Bazel&lt;/a&gt; and &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt; are the official build systems for Abseil. See the &lt;a href=&#34;https://abseil.io/docs/cpp/quickstart&#34;&gt;quickstart&lt;/a&gt; for more information on building Abseil using the Bazel build system. If you require CMake support, please check the &lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/CMake/README.md&#34;&gt;CMake build instructions&lt;/a&gt; and &lt;a href=&#34;https://abseil.io/docs/cpp/quickstart-cmake&#34;&gt;CMake Quickstart&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;support&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;Abseil follows Google&#39;s &lt;a href=&#34;https://opensource.google/documentation/policies/cplusplus-support&#34;&gt;Foundational C++ Support Policy&lt;/a&gt;. See &lt;a href=&#34;https://github.com/google/oss-policies-info/raw/main/foundational-cxx-support-matrix.md&#34;&gt;this table&lt;/a&gt; for a list of currently supported versions compilers, platforms, and build tools.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;codemap&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Codemap&lt;/h2&gt; &#xA;&lt;p&gt;Abseil contains the following C++ library components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/base/&#34;&gt;&lt;code&gt;base&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;base&lt;/code&gt; library contains initialization code and other code which all other Abseil code depends on. Code within &lt;code&gt;base&lt;/code&gt; may not depend on any other code (other than the C++ standard library).&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/algorithm/&#34;&gt;&lt;code&gt;algorithm&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;algorithm&lt;/code&gt; library contains additions to the C++ &lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt; library and container-based versions of such algorithms.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/cleanup/&#34;&gt;&lt;code&gt;cleanup&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;cleanup&lt;/code&gt; library contains the control-flow-construct-like type &lt;code&gt;absl::Cleanup&lt;/code&gt; which is used for executing a callback on scope exit.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/container/&#34;&gt;&lt;code&gt;container&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;container&lt;/code&gt; library contains additional STL-style containers, including Abseil&#39;s unordered &#34;Swiss table&#34; containers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/crc/&#34;&gt;&lt;code&gt;crc&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;crc&lt;/code&gt; library contains code for computing error-detecting cyclic redundancy checks on data.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/debugging/&#34;&gt;&lt;code&gt;debugging&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;debugging&lt;/code&gt; library contains code useful for enabling leak checks, and stacktrace and symbolization utilities.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/flags/&#34;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;flags&lt;/code&gt; library contains code for handling command line flags for libraries and binaries built with Abseil.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/hash/&#34;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;hash&lt;/code&gt; library contains the hashing framework and default hash functor implementations for hashable types in Abseil.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/log/&#34;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;log&lt;/code&gt; library contains &lt;code&gt;LOG&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; macros and facilities for writing logged messages out to disk, &lt;code&gt;stderr&lt;/code&gt;, or user-extensible destinations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/memory/&#34;&gt;&lt;code&gt;memory&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;memory&lt;/code&gt; library contains memory management facilities that augment C++&#39;s &lt;code&gt;&amp;lt;memory&amp;gt;&lt;/code&gt; library.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/meta/&#34;&gt;&lt;code&gt;meta&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;meta&lt;/code&gt; library contains compatible versions of type checks available within C++14 and C++17 versions of the C++ &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; library.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/numeric/&#34;&gt;&lt;code&gt;numeric&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;numeric&lt;/code&gt; library contains 128-bit integer types as well as implementations of C++20&#39;s bitwise math functions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/profiling/&#34;&gt;&lt;code&gt;profiling&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;profiling&lt;/code&gt; library contains utility code for profiling C++ entities. It is currently a private dependency of other Abseil libraries.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/random/&#34;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;random&lt;/code&gt; library contains functions for generating psuedorandom values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/status/&#34;&gt;&lt;code&gt;status&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;status&lt;/code&gt; library contains abstractions for error handling, specifically &lt;code&gt;absl::Status&lt;/code&gt; and &lt;code&gt;absl::StatusOr&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/strings/&#34;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;strings&lt;/code&gt; library contains a variety of strings routines and utilities, including a C++14-compatible version of the C++17 &lt;code&gt;std::string_view&lt;/code&gt; type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/synchronization/&#34;&gt;&lt;code&gt;synchronization&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;synchronization&lt;/code&gt; library contains concurrency primitives (Abseil&#39;s &lt;code&gt;absl::Mutex&lt;/code&gt; class, an alternative to &lt;code&gt;std::mutex&lt;/code&gt;) and a variety of synchronization abstractions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/time/&#34;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;time&lt;/code&gt; library contains abstractions for computing with absolute points in time, durations of time, and formatting and parsing time within time zones.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/types/&#34;&gt;&lt;code&gt;types&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;types&lt;/code&gt; library contains non-container utility types, like a C++14-compatible version of the C++17 &lt;code&gt;std::optional&lt;/code&gt; type.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/utility/&#34;&gt;&lt;code&gt;utility&lt;/code&gt;&lt;/a&gt; &lt;br&gt; The &lt;code&gt;utility&lt;/code&gt; library contains utility and helper code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;releases&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Releases&lt;/h2&gt; &#xA;&lt;p&gt;Abseil recommends users &#34;live-at-head&#34; (update to the latest commit from the master branch as often as possible). However, we realize this philosophy doesn&#39;t work for every project, so we also provide &lt;a href=&#34;https://github.com/abseil/abseil-cpp/releases&#34;&gt;Long Term Support Releases&lt;/a&gt; to which we backport fixes for severe bugs. See our &lt;a href=&#34;https://abseil.io/about/releases&#34;&gt;release management&lt;/a&gt; document for more details.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The Abseil C++ library is licensed under the terms of the Apache license. See &lt;a href=&#34;https://raw.githubusercontent.com/abseil/abseil-cpp/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;links&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Links&lt;/h2&gt; &#xA;&lt;p&gt;For more information about Abseil:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Consult our &lt;a href=&#34;https://abseil.io/about/intro&#34;&gt;Abseil Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Read &lt;a href=&#34;https://abseil.io/about/philosophy&#34;&gt;Why Adopt Abseil&lt;/a&gt; to understand our design philosophy.&lt;/li&gt; &#xA; &lt;li&gt;Peruse our &lt;a href=&#34;https://abseil.io/about/compatibility&#34;&gt;Abseil Compatibility Guarantees&lt;/a&gt; to understand both what we promise to you, and what we expect of you in return.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>