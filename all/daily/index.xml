<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-05-22T01:29:20Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>microsoft/WSL</title>
    <updated>2025-05-22T01:29:20Z</updated>
    <id>tag:github.com,2025-05-22:/microsoft/WSL</id>
    <link href="https://github.com/microsoft/WSL" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Windows Subsystem for Linux&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Welcome to the Windows Subsystem for Linux (WSL) repository&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/microsoft/WSL/master/Images/Square44x44Logo.targetsize-256.png&#34; alt=&#34;WSL logo&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://aka.ms/wsldocs&#34;&gt;Learn more about WSL&lt;/a&gt; | &lt;a href=&#34;https://github.com/microsoft/WSL/releases&#34;&gt;Downloads &amp;amp; Release notes&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/WSL/master/CONTRIBUTING.md&#34;&gt;Contributing to WSL&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Windows Subsystem for Linux (WSL) is a powerful way for you to run your Linux command-line tools, utilities and applications, all unmodified and directly on Windows without the overhead of a traditional virtual machine or dual boot setup.&lt;/p&gt; &#xA;&lt;p&gt;You can install WSL right away by running this command inside of your Windows command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;wsl --install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can learn more about &lt;a href=&#34;https://learn.microsoft.com/windows/wsl/setup/environment&#34;&gt;best practices for setup&lt;/a&gt;, &lt;a href=&#34;https://learn.microsoft.com/windows/wsl/about&#34;&gt;overviews of WSL&lt;/a&gt; and more at our &lt;a href=&#34;https://learn.microsoft.com/windows/wsl/&#34;&gt;WSL documentation page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Related repositories&lt;/h2&gt; &#xA;&lt;p&gt;WSL also has related open source repositories:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/WSL2-Linux-Kernel&#34;&gt;microsoft/WSL2-Linux-Kernel&lt;/a&gt; - The Linux kernel shipped with WSL&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/wslg&#34;&gt;microsoft/WSLg&lt;/a&gt; - Support for Linux GUI apps in WSL&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/microsoftdocs/wsl&#34;&gt;microsoftdocs/wsl&lt;/a&gt; - WSL documentation at aka.ms/wsldocs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;This project welcomes contributions of all types, including coding features / bug fixes, documentation fixes, design proposals and more.&lt;/p&gt; &#xA;&lt;p&gt;We ask that before you start working on a contribution, please read our &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/WSL/master/CONTRIBUTING.md&#34;&gt;Contributor&#39;s Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For guidance on developing for WSL, please read the &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/WSL/master/doc/docs/dev-loop.md&#34;&gt;developer docs&lt;/a&gt; for instructions on how to build WSL from source and details on its architecture.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;This project has adopted the &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/WSL/master/CODE_OF_CONDUCT.md&#34;&gt;Microsoft Open Source Code of Conduct&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Trademarks&lt;/h2&gt; &#xA;&lt;p&gt;This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow &lt;a href=&#34;https://www.microsoft.com/legal/intellectualproperty/trademarks&#34;&gt;Microsoft’s Trademark &amp;amp; Brand Guidelines&lt;/a&gt;. Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party’s policies.&lt;/p&gt; &#xA;&lt;h2&gt;Privacy and telemetry&lt;/h2&gt; &#xA;&lt;p&gt;The application logs basic diagnostic data (telemetry). For more information on privacy and what we collect, see our &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/WSL/master/DATA_AND_PRIVACY.md&#34;&gt;data and privacy documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The software may collect information about you and your use of the software and send it to Microsoft. Microsoft may use this information to provide services and improve our products and services. You may turn off the telemetry as described in the repository. There are also some features in the software that may enable you and Microsoft to collect data from users of your applications. If you use these features, you must comply with applicable law, including providing appropriate notices to users of your applications together with a copy of Microsoft’s privacy statement. Our privacy statement is located at &lt;a href=&#34;https://go.microsoft.com/fwlink/?LinkID=824704&#34;&gt;https://go.microsoft.com/fwlink/?LinkID=824704&lt;/a&gt;. You can learn more about data collection and use in the help documentation and our privacy statement. Your use of the software operates as your consent to these practices.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>modelcontextprotocol/registry</title>
    <updated>2025-05-22T01:29:20Z</updated>
    <id>tag:github.com,2025-05-22:/modelcontextprotocol/registry</id>
    <link href="https://github.com/modelcontextprotocol/registry" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A community driven registry service for Model Context Protocol (MCP) servers.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MCP Registry&lt;/h1&gt; &#xA;&lt;p&gt;A community driven registry service for Model Context Protocol (MCP) servers.&lt;/p&gt; &#xA;&lt;h2&gt;Development Status&lt;/h2&gt; &#xA;&lt;p&gt;This project is being built in the open and is currently in the early stages of development. Please see the &lt;a href=&#34;https://github.com/modelcontextprotocol/registry/discussions/11&#34;&gt;overview discussion&lt;/a&gt; for the project scope and goals. If you would like to contribute, please check out the &lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/registry/main/CONTRIBUTING.md&#34;&gt;contributing guidelines&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The MCP Registry service provides a centralized repository for MCP server entries. It allows discovery and management of various MCP implementations with their associated metadata, configurations, and capabilities.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RESTful API for managing MCP registry entries (list, get, create, update, delete)&lt;/li&gt; &#xA; &lt;li&gt;Health check endpoint for service monitoring&lt;/li&gt; &#xA; &lt;li&gt;Support for various environment configurations&lt;/li&gt; &#xA; &lt;li&gt;Graceful shutdown handling&lt;/li&gt; &#xA; &lt;li&gt;MongoDB and in-memory database support&lt;/li&gt; &#xA; &lt;li&gt;Comprehensive API documentation&lt;/li&gt; &#xA; &lt;li&gt;Pagination support for listing registry entries&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Go 1.18 or later&lt;/li&gt; &#xA; &lt;li&gt;MongoDB&lt;/li&gt; &#xA; &lt;li&gt;Docker (optional, but recommended for development)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Running&lt;/h2&gt; &#xA;&lt;p&gt;The easiest way to get the registry running is to use &lt;code&gt;docker compose&lt;/code&gt;. This will setup the MCP Registry service, import the seed data and run MongoDB in a local Docker environment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Build the Docker image&#xA;docker build -t registry .&#xA;&#xA;# Run the registry and MongoDB with docker compose&#xA;docker compose up&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will start the MCP Registry service and MongoDB with Docker, exposing it on port 8080.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;If you prefer to run the service locally without Docker, you can build and run it directly using Go.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Build a registry executable&#xA;go build ./cmd/registry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create the &lt;code&gt;registry&lt;/code&gt; binary in the current directory. You&#39;ll need to have MongoDB running locally or with Docker.&lt;/p&gt; &#xA;&lt;p&gt;By default, the service will run on &lt;code&gt;http://localhost:8080&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Project Structure&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;├── api/           # OpenApi specification&#xA;├── cmd/           # Application entry points&#xA;├── config/        # Configuration files&#xA;├── internal/      # Private application code&#xA;│   ├── api/       # HTTP server and request handlers&#xA;│   ├── config/    # Configuration management&#xA;│   ├── model/     # Data models&#xA;│   └── service/   # Business logic&#xA;├── pkg/           # Public libraries&#xA;├── scripts/       # Utility scripts&#xA;└── tools/         # Command line tools&#xA;    └── publisher/ # Tool to publish MCP servers to the registry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The API is documented using Swagger/OpenAPI. You can access the interactive Swagger UI at:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/v0/swagger/index.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This provides a complete reference of all endpoints with request/response schemas and allows you to test the API directly from your browser.&lt;/p&gt; &#xA;&lt;h2&gt;API Endpoints&lt;/h2&gt; &#xA;&lt;h3&gt;Health Check&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;GET /v0/health&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Returns the health status of the service:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;status&#34;: &#34;ok&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Registry Endpoints&lt;/h3&gt; &#xA;&lt;h4&gt;List Registry Server Entries&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;GET /v0/servers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lists MCP registry server entries with pagination support.&lt;/p&gt; &#xA;&lt;p&gt;Query parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;limit&lt;/code&gt;: Maximum number of entries to return (default: 30, max: 100)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cursor&lt;/code&gt;: Pagination cursor for retrieving next set of results&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Response example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;servers&#34;: [&#xA;    {&#xA;      &#34;id&#34;: &#34;123e4567-e89b-12d3-a456-426614174000&#34;,&#xA;      &#34;name&#34;: &#34;Example MCP Server&#34;,&#xA;      &#34;url&#34;: &#34;https://example.com/mcp&#34;,&#xA;      &#34;description&#34;: &#34;An example MCP server&#34;,&#xA;      &#34;created_at&#34;: &#34;2025-05-17T17:34:22.912Z&#34;,&#xA;      &#34;updated_at&#34;: &#34;2025-05-17T17:34:22.912Z&#34;&#xA;    }&#xA;  ],&#xA;  &#34;metadata&#34;: {&#xA;    &#34;next_cursor&#34;: &#34;123e4567-e89b-12d3-a456-426614174000&#34;,&#xA;    &#34;count&#34;: 30&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Get Server Details&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;GET /v0/servers/{id}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Retrieves detailed information about a specific MCP server entry.&lt;/p&gt; &#xA;&lt;p&gt;Path parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;id&lt;/code&gt;: Unique identifier of the server entry&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Response example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;id&#34;: &#34;01129bff-3d65-4e3d-8e82-6f2f269f818c&#34;,&#xA;  &#34;name&#34;: &#34;io.github.gongrzhe/redis-mcp-server&#34;,&#xA;  &#34;description&#34;: &#34;A Redis MCP server (pushed to https://github.com/modelcontextprotocol/servers/tree/main/src/redis) implementation for interacting with Redis databases. This server enables LLMs to interact with Redis key-value stores through a set of standardized tools.&#34;,&#xA;  &#34;repository&#34;: {&#xA;    &#34;url&#34;: &#34;https://github.com/GongRzhe/REDIS-MCP-Server&#34;,&#xA;    &#34;source&#34;: &#34;github&#34;,&#xA;    &#34;id&#34;: &#34;907849235&#34;&#xA;  },&#xA;  &#34;version_detail&#34;: {&#xA;    &#34;version&#34;: &#34;0.0.1-seed&#34;,&#xA;    &#34;release_date&#34;: &#34;2025-05-16T19:13:21Z&#34;,&#xA;    &#34;is_latest&#34;: true&#xA;  },&#xA;  &#34;package_canonical&#34;: &#34;docker&#34;,&#xA;  &#34;packages&#34;: [&#xA;    {&#xA;      &#34;registry_name&#34;: &#34;docker&#34;,&#xA;      &#34;name&#34;: &#34;@gongrzhe/server-redis-mcp&#34;,&#xA;      &#34;version&#34;: &#34;1.0.0&#34;,&#xA;      &#34;package_arguments&#34;: [&#xA;        {&#xA;          &#34;description&#34;: &#34;Docker image to run&#34;,&#xA;          &#34;is_required&#34;: true,&#xA;          &#34;format&#34;: &#34;string&#34;,&#xA;          &#34;value&#34;: &#34;mcp/redis&#34;,&#xA;          &#34;default&#34;: &#34;mcp/redis&#34;,&#xA;          &#34;type&#34;: &#34;positional&#34;,&#xA;          &#34;value_hint&#34;: &#34;mcp/redis&#34;&#xA;        },&#xA;        {&#xA;          &#34;description&#34;: &#34;Redis server connection string&#34;,&#xA;          &#34;is_required&#34;: true,&#xA;          &#34;format&#34;: &#34;string&#34;,&#xA;          &#34;value&#34;: &#34;redis://host.docker.internal:6379&#34;,&#xA;          &#34;default&#34;: &#34;redis://host.docker.internal:6379&#34;,&#xA;          &#34;type&#34;: &#34;positional&#34;,&#xA;          &#34;value_hint&#34;: &#34;host.docker.internal:6379&#34;&#xA;        }&#xA;      ]&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Publish a Server Entry&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;POST /v0/publish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Publishes a new MCP server entry to the registry. Authentication is required via Bearer token in the Authorization header.&lt;/p&gt; &#xA;&lt;p&gt;Headers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Authorization&lt;/code&gt;: Bearer token for authentication (e.g., &lt;code&gt;Bearer your_token_here&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Content-Type&lt;/code&gt;: application/json&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Request body example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;description&#34;: &#34;&amp;lt;your description here&amp;gt;&#34;,&#xA;    &#34;name&#34;: &#34;io.github.&amp;lt;owner&amp;gt;/&amp;lt;server-name&amp;gt;&#34;,&#xA;    &#34;package_canonical&#34;: &#34;&amp;lt;package_registry&#34;,&#xA;    &#34;packages&#34;: [&#xA;        {&#xA;            &#34;registry_name&#34;: &#34;npm&#34;,&#xA;            &#34;name&#34;: &#34;@&amp;lt;owner&amp;gt;/&amp;lt;server-name&amp;gt;&#34;,&#xA;            &#34;version&#34;: &#34;0.2.23&#34;,&#xA;            &#34;package_arguments&#34;: [&#xA;                {&#xA;                    &#34;description&#34;: &#34;Specify services and permissions.&#34;,&#xA;                    &#34;is_required&#34;: true,&#xA;                    &#34;format&#34;: &#34;string&#34;,&#xA;                    &#34;value&#34;: &#34;-s&#34;,&#xA;                    &#34;default&#34;: &#34;-s&#34;,&#xA;                    &#34;type&#34;: &#34;positional&#34;,&#xA;                    &#34;value_hint&#34;: &#34;-s&#34;&#xA;                }&#xA;            ],&#xA;            &#34;environment_variables&#34;: [&#xA;                {&#xA;                    &#34;description&#34;: &#34;API Key to access the server&#34;,&#xA;                    &#34;name&#34;: &#34;API_KEY&#34;&#xA;                }&#xA;            ]&#xA;        },{&#xA;            &#34;registry_name&#34;: &#34;docker&#34;,&#xA;            &#34;name&#34;: &#34;@&amp;lt;owner&amp;gt;/&amp;lt;server-name&amp;gt;-cli&#34;,&#xA;            &#34;version&#34;: &#34;0.123.223&#34;,&#xA;            &#34;runtime_hint&#34;: &#34;docker&#34;,&#xA;            &#34;runtime_arguments&#34;: [&#xA;                {&#xA;                    &#34;description&#34;: &#34;Specify services and permissions.&#34;,&#xA;                    &#34;is_required&#34;: true,&#xA;                    &#34;format&#34;: &#34;string&#34;,&#xA;                    &#34;value&#34;: &#34;--mount&#34;,&#xA;                    &#34;default&#34;: &#34;--mount&#34;,&#xA;                    &#34;type&#34;: &#34;positional&#34;,&#xA;                    &#34;value_hint&#34;: &#34;--mount&#34;&#xA;                }&#xA;            ],&#xA;            &#34;environment_variables&#34;: [&#xA;                {&#xA;                    &#34;description&#34;: &#34;API Key to access the server&#34;,&#xA;                    &#34;name&#34;: &#34;API_KEY&#34;&#xA;                }&#xA;            ]&#xA;        }&#xA;    ],&#xA;    &#34;repository&#34;: {&#xA;        &#34;url&#34;: &#34;https://github.com//&amp;lt;owner&amp;gt;/&amp;lt;server-name&amp;gt;&#34;,&#xA;        &#34;source&#34;: &#34;github&#34;&#xA;    },&#xA;    &#34;version_detail&#34;: {&#xA;        &#34;version&#34;: &#34;0.0.1-&amp;lt;publisher_version&amp;gt;&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Response example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;message&#34;: &#34;Server publication successful&#34;,&#xA;  &#34;id&#34;: &#34;1234567890abcdef12345678&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Ping Endpoint&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;GET /v0/ping&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Simple ping endpoint that returns environment configuration information:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;environment&#34;: &#34;dev&#34;,&#xA;  &#34;version&#34;: &#34;registry-&amp;lt;sha&amp;gt;&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;The service can be configured using environment variables:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Variable&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MCP_REGISTRY_APP_VERSION&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Application version&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;dev&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MCP_REGISTRY_COLLECTION_NAME&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;MongoDB collection name&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;servers_v2&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MCP_REGISTRY_DATABASE_NAME&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;MongoDB database name&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mcp-registry&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MCP_REGISTRY_DATABASE_URL&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;MongoDB connection string&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;mongodb://localhost:27017&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MCP_REGISTRY_GITHUB_CLIENT_ID&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;GitHub App Client ID&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MCP_REGISTRY_GITHUB_CLIENT_SECRET&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;GitHub App Client Secret&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MCP_REGISTRY_LOG_LEVEL&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Log level&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;info&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MCP_REGISTRY_SEED_FILE_PATH&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Path to import seed file&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;data/seed.json&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MCP_REGISTRY_SEED_IMPORT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Import &lt;code&gt;seed.json&lt;/code&gt; on first run&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MCP_REGISTRY_SERVER_ADDRESS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Listen address for the server&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;:8080&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;Run the test script to validate API endpoints:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./scripts/test_endpoints.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can specify specific endpoints to test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./scripts/test_endpoints.sh --endpoint health&#xA;./scripts/test_endpoints.sh --endpoint servers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/registry/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file for details.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/modelcontextprotocol/registry/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt; file for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Cysharp/ZLinq</title>
    <updated>2025-05-22T01:29:20Z</updated>
    <id>tag:github.com,2025-05-22:/Cysharp/ZLinq</id>
    <link href="https://github.com/Cysharp/ZLinq" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Zero allocation LINQ with LINQ to Span, LINQ to SIMD, and LINQ to Tree (FileSystem, JSON, GameObject, etc.) for all .NET platforms and Unity, Godot.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ZLinq&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Cysharp/ZLinq/actions/workflows/build-debug.yml&#34;&gt;&lt;img src=&#34;https://github.com/Cysharp/ZLinq/actions/workflows/build-debug.yaml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Cysharp/ZLinq/actions/workflows/benchmark.yml&#34;&gt;&lt;img src=&#34;https://github.com/Cysharp/ZLinq/actions/workflows/benchmark.yaml/badge.svg?sanitize=true&#34; alt=&#34;Benchmark&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/ZLinq&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/v/ZLinq&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://deepwiki.com/Cysharp/ZLinq&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Chat%20with-DeepWiki%20%F0%9F%A4%96-blue&#34; alt=&#34;DeepWiki&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Zero allocation LINQ with LINQ to Span, LINQ to SIMD, and LINQ to Tree (FileSystem, JSON, GameObject, etc.) for all .NET platforms(netstandard2.0, 2.1, net8, net9) and Unity, Godot.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/img/benchmarkhead.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Unlike regular LINQ, ZLinq doesn&#39;t increase allocations when adding more method chains, and it also has higher basic performance. You can check various benchmark patterns at &lt;a href=&#34;https://github.com/Cysharp/ZLinq/actions/runs/14569138271&#34;&gt;GitHub Actions/Benchmark&lt;/a&gt;. ZLinq shows high performance in almost all patterns, with some benchmarks showing overwhelming differences.&lt;/p&gt; &#xA;&lt;p&gt;As a bonus, LINQ operators and optimizations equivalent to .NET 10 can be used in .NET Framework 4.8 (netstandard2.0) and Unity (netstandard2.1).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;var seq = source&#xA;    .AsValueEnumerable() // only add this line&#xA;    .Where(x =&amp;gt; x % 2 == 0)&#xA;    .Select(x =&amp;gt; x * 3);&#xA;&#xA;foreach (var item in seq) { }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;99% compatibility&lt;/strong&gt; with .NET 10&#39;s LINQ (including new &lt;code&gt;Shuffle&lt;/code&gt;, &lt;code&gt;RightJoin&lt;/code&gt;, &lt;code&gt;LeftJoin&lt;/code&gt; operators)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Zero allocation&lt;/strong&gt; for method chains through struct-based Enumerable via &lt;code&gt;ValueEnumerable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;LINQ to Span&lt;/strong&gt; to full support LINQ operations on &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; using .NET 9/C# 13&#39;s &lt;code&gt;allows ref struct&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;LINQ to Tree&lt;/strong&gt; to extend tree-structured objects (built-in support for FileSystem, JSON, GameObject)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;LINQ to SIMD&lt;/strong&gt; to automatic application of SIMD where possible and customizable arbitrary operations&lt;/li&gt; &#xA; &lt;li&gt;Optional &lt;strong&gt;Drop-in replacement&lt;/strong&gt; Source Generator to automatically accelerate all LINQ methods&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In ZLinq, we have proven high compatibility and performance by running &lt;a href=&#34;https://github.com/Cysharp/ZLinq/tree/main/tests/System.Linq.Tests&#34;&gt;dotnet/runtime&#39;s System.Linq.Tests&lt;/a&gt; as a drop-in replacement, passing 9000 tests.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/img/testrun.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Previously, value type-based LINQ implementations were often experimental, but ZLinq fully implements all methods to completely replace standard LINQ in production use, delivering high performance suitable even for demanding applications like games. The performance aspects are based on my experience with previous LINQ implementations (&lt;a href=&#34;https://github.com/neuecc/linq.js/&#34;&gt;linq.js&lt;/a&gt;, &lt;a href=&#34;https://github.com/Cysharp/SimdLinq/&#34;&gt;SimdLinq&lt;/a&gt;, &lt;a href=&#34;https://github.com/neuecc/UniRx&#34;&gt;UniRx&lt;/a&gt;, &lt;a href=&#34;https://github.com/Cysharp/R3&#34;&gt;R3&lt;/a&gt;), zero-allocation implementations (&lt;a href=&#34;https://github.com/Cysharp/ZString&#34;&gt;ZString&lt;/a&gt;, &lt;a href=&#34;https://github.com/Cysharp/ZLogger&#34;&gt;ZLogger&lt;/a&gt;), and high-performance serializers (&lt;a href=&#34;https://github.com/MessagePack-CSharp/MessagePack-CSharp/&#34;&gt;MessagePack-CSharp&lt;/a&gt;, &lt;a href=&#34;https://github.com/Cysharp/MemoryPack&#34;&gt;MemoryPack&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;ZLinq achieves zero-allocation LINQ implementation using the following structs and interfaces.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public readonly ref struct ValueEnumerable&amp;lt;TEnumerator, T&amp;gt;(TEnumerator enumerator)&#xA;    where TEnumerator : struct, IValueEnumerator&amp;lt;T&amp;gt;, allows ref struct&#xA;{&#xA;    public readonly TEnumerator Enumerator = enumerator;&#xA;}&#xA;&#xA;public interface IValueEnumerator&amp;lt;T&amp;gt; : IDisposable&#xA;{&#xA;    bool TryGetNext(out T current); // as MoveNext + Current&#xA;&#xA;    // Optimization helper&#xA;    bool TryGetNonEnumeratedCount(out int count);&#xA;    bool TryGetSpan(out ReadOnlySpan&amp;lt;T&amp;gt; span);&#xA;    bool TryCopyTo(scoped Span&amp;lt;T&amp;gt; destination, Index offset);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Besides changing to a struct-based approach, we&#39;ve integrated MoveNext and Current to reduce the number of iterator calls. Also, some operators don&#39;t need to hold Current, which allows minimizing the struct size. Additionally, being struct-based, we efficiently separate internal state by copying the Enumerator instead of using GetEnumerator. With .NET 9/C# 13 or later, &lt;code&gt;allows ref struct&lt;/code&gt; enables natural integration of &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; into LINQ.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static ValueEnumerable&amp;lt;Where&amp;lt;TEnumerator, TSource&amp;gt;, TSource&amp;gt; Where&amp;lt;TEnumerator, TSource&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, TSource&amp;gt; source, Func&amp;lt;TSource, Boolean&amp;gt; predicate)&#xA;    where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;, allows ref struct&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Operators have this method signature. C# cannot infer types from generic constraints(&lt;a href=&#34;https://github.com/dotnet/csharplang/discussions/6930&#34;&gt;dotnet/csharplang#6930&lt;/a&gt;). Therefore, the traditional Struct LINQ approach required implementing all operator combinations as instance methods, resulting in &lt;a href=&#34;https://kevinmontrose.com/2018/01/17/linqaf-replacing-linq-and-not-allocating/&#34;&gt;100,000+ methods and massive assembly sizes&lt;/a&gt;. However, in ZLinq, we&#39;ve successfully avoided all the boilerplate method implementations by devising an approach that properly conveys types to C# compiler.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, &lt;code&gt;TryGetNonEnumeratedCount(out int count)&lt;/code&gt;, &lt;code&gt;TryGetSpan(out ReadOnlySpan&amp;lt;T&amp;gt; span)&lt;/code&gt;, and &lt;code&gt;TryCopyTo(Span&amp;lt;T&amp;gt; destination, Index offset)&lt;/code&gt; defined in the interface itself enable flexible optimizations. To minimize assembly size, we&#39;ve designed the library to achieve maximum optimization with minimal method additions. For example, &lt;code&gt;TryCopyTo&lt;/code&gt; works efficiently with methods like &lt;code&gt;ToArray&lt;/code&gt; when combined with &lt;code&gt;TryGetNonEnumeratedCount&lt;/code&gt;. However, it also allows copying to smaller-sized destinations. By combining this with Index, we can optimize &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;Last&lt;/code&gt;, and &lt;code&gt;ElementAt&lt;/code&gt; using just &lt;code&gt;TryCopyTo&lt;/code&gt; by passing a single-element Span along with an Index.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re interested in architecture, please read my blog post &lt;a href=&#34;https://neuecc.medium.com/zlinq-a-zero-allocation-linq-library-for-net-1bb0a3e5c749&#34;&gt;&lt;strong&gt;&#34;ZLinq&#34;, a Zero-Allocation LINQ Library for .NET&lt;/strong&gt;&lt;/a&gt; where I wrote the details.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;You can install package from &lt;a href=&#34;https://www.nuget.org/packages/ZLinq&#34;&gt;NuGet/ZLinq&lt;/a&gt;. For Unity usage, refer to the &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#unity&#34;&gt;Unity section&lt;/a&gt;. For Godot usage, refer to the &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#godot&#34;&gt;Godot section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;using ZLinq;&lt;/code&gt; and call &lt;code&gt;AsValueEnumerable()&lt;/code&gt; on any iterable type to use ZLinq&#39;s zero-allocation LINQ.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;var source = new int[] { 1, 2, 3, 4, 5 };&#xA;&#xA;// Call AsValueEnumerable to apply ZLinq&#xA;var seq1 = source.AsValueEnumerable().Where(x =&amp;gt; x % 2 == 0);&#xA;&#xA;// Can also be applied to Span (only in .NET 9/C# 13 environments that support allows ref struct)&#xA;Span&amp;lt;int&amp;gt; span = stackalloc int[5] { 1, 2, 3, 4, 5 };&#xA;var seq2 = span.AsValueEnumerable().Select(x =&amp;gt; x * x);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Even if it&#39;s netstandard 2.0 or below .NET 10, all operators up to .NET 10 are available.&lt;/p&gt; &#xA;&lt;p&gt;You can method chain and foreach like regular LINQ, but there are some limitations. Please see &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#difference-and-limitation&#34;&gt;Difference and Limitation&lt;/a&gt; for details. ZLinq has drop-in replacements that apply ZLinq without needing to call &lt;code&gt;AsValueEnumerable()&lt;/code&gt;. For more information, see &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#drop-in-replacement&#34;&gt;Drop-in replacement&lt;/a&gt;. Detailed information about &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#linq-to-tree&#34;&gt;LINQ to Tree&lt;/a&gt; for LINQ-ifying tree structures (FileSystems and JSON) and &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#linq-to-simd&#34;&gt;LINQ to SIMD&lt;/a&gt; for expanding SIMD application range can be found in their respective sections.&lt;/p&gt; &#xA;&lt;h2&gt;Additional Operators&lt;/h2&gt; &#xA;&lt;p&gt;In ZLinq, we prioritize compatibility, so we try to minimize adding custom operators. However, the following methods have been added to enable efficient processing with zero allocation:&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;AsValueEnumerable()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Converts existing collections to a type that can be chained with ZLinq. Any &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; can be converted, but for the following types, conversion is done with zero allocation without &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;.GetEnumerator()&lt;/code&gt; allocation. Standard supported types are &lt;code&gt;T[]&lt;/code&gt;, &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;ArraySegment&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlyMemory&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlySequence&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt;, &lt;code&gt;Queue&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Stack&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;LinkedList&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;HashSet&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;ImmutableArray&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt;. However, conversion from &lt;code&gt;ImmutableArray&amp;lt;T&amp;gt;&lt;/code&gt; requires &lt;code&gt;.NET 8&lt;/code&gt; or higher, and conversion from &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt; requires &lt;code&gt;.NET 9&lt;/code&gt; or higher.&lt;/p&gt; &#xA;&lt;p&gt;When a type is declared as &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;ICollection&amp;lt;T&amp;gt;&lt;/code&gt; rather than concrete types like &lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, generally additional allocations occur when using foreach. In &lt;code&gt;ZLinq&lt;/code&gt;, even when these interfaces are declared, if the actual type is &lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, processing is performed with zero allocation.&lt;/p&gt; &#xA;&lt;p&gt;Convert from &lt;code&gt;System.Collections.IEnumerable&lt;/code&gt; is also supported. In that case, using &lt;code&gt;AsValueEnumerable()&lt;/code&gt; without specifying a type converts to &lt;code&gt;ValueEnumerable&amp;lt;, object&amp;gt;&lt;/code&gt;, but you can also cast it simultaneously by &lt;code&gt;AsValueEnumerable&amp;lt;T&amp;gt;()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;IEnumerable nonGenericCollection = default!;&#xA;nonGenericCollection.AsValueEnumerable(); // ValueEnumerable&amp;lt;, object&amp;gt;&#xA;nonGenericCollection.AsValueEnumerable&amp;lt;int&amp;gt;(); // ValueEnumerable&amp;lt;, int&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;ValueEnumerable.Range()&lt;/code&gt;, &lt;code&gt;ValueEnumerable.Repeat()&lt;/code&gt;, &lt;code&gt;ValueEnumerable.Empty()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ValueEnumerable.Range&lt;/code&gt; operates more efficiently when handling with &lt;code&gt;ZLinq&lt;/code&gt; than &lt;code&gt;Enumerable.Range().AsValueEnumerable()&lt;/code&gt;. The same applies to &lt;code&gt;Repeat&lt;/code&gt; and &lt;code&gt;Empty&lt;/code&gt;. The Range can also handle &lt;code&gt;System.Range&lt;/code&gt;, step increments, &lt;code&gt;IAdditionOperators&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;DateTime&lt;/code&gt;, and more. Please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#range&#34;&gt;Range&lt;/a&gt; section for details.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Average() : where INumber&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Sum() : where INumber&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;System.Linq&#39;s &lt;code&gt;Average&lt;/code&gt; and &lt;code&gt;Sum&lt;/code&gt; are limited to certain primitive types, but ZLinq extends them to all &lt;code&gt;INumber&amp;lt;T&amp;gt;&lt;/code&gt; types. In &lt;code&gt;.NET 8&lt;/code&gt; or higher, where constraints are included, but for others (netstandard2.0, 2.1), runtime errors will occur when called with non-primitive target types.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;SumUnchecked()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Sum&lt;/code&gt; is &lt;code&gt;checked&lt;/code&gt;, but checking for overflow during SIMD execution creates performance overhead. &lt;code&gt;SumUnchecked&lt;/code&gt; skips overflow checking to achieve maximum SIMD aggregation performance. Note that this requires &lt;code&gt;.NET 8&lt;/code&gt; or higher, and SIMD-supported types are &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and the source must be able to get a Span (&lt;code&gt;TryGetSpan&lt;/code&gt; returns true).&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;AggregateBy&lt;/code&gt;, &lt;code&gt;CountBy&lt;/code&gt; constraints&lt;/h3&gt; &#xA;&lt;p&gt;.NET 9 &lt;code&gt;AggregateBy&lt;/code&gt; and &lt;code&gt;CountBy&lt;/code&gt; has &lt;code&gt;TKey : notnull&lt;/code&gt; constraints. However, this is due to internal implementation considerations, and it lacks consistency with traditional operators such as Lookup and Join. Therefore, in ZLinq, the notnull constraint was removed.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;int CopyTo(Span&amp;lt;T&amp;gt; destination)&lt;/code&gt;, &lt;code&gt;void CopyTo(List&amp;lt;T&amp;gt; list)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;CopyTo&lt;/code&gt; can be used to avoid allocation of the return collection unlike &lt;code&gt;ToArray&lt;/code&gt; or &lt;code&gt;ToList&lt;/code&gt;. &lt;code&gt;int CopyTo(Span&amp;lt;T&amp;gt; destination)&lt;/code&gt; allows the destination to be smaller than the source, returning the number of elements copied. &lt;code&gt;void CopyTo(List&amp;lt;T&amp;gt; list)&lt;/code&gt; clears the list and then fills it with elements from the source, so the destination size is list.Count.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;PooledArray&amp;lt;TSource&amp;gt; ToArrayPool()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The returned array is rented from &lt;code&gt;ArrayPool&amp;lt;TSource&amp;gt;.Shared&lt;/code&gt;. &lt;code&gt;PooledArray&amp;lt;TSource&amp;gt;&lt;/code&gt; defines &lt;code&gt;.Span&lt;/code&gt;, &lt;code&gt;.Memory&lt;/code&gt;, &lt;code&gt;.AsEnumerable()&lt;/code&gt; and other methods. These allow you to pass a &lt;code&gt;ValueEnumerable&lt;/code&gt; to another method while minimizing allocations. Additionally, through &lt;code&gt;.AsValueEnumerable()&lt;/code&gt;, you can call &lt;code&gt;ZLinq&lt;/code&gt; methods, which is useful for temporarily materializing computationally expensive operations. Being &lt;code&gt;IDisposable&lt;/code&gt;, you can return the borrowed array to &lt;code&gt;ArrayPool&amp;lt;TSource&amp;gt;.Shared&lt;/code&gt; using the &lt;code&gt;using&lt;/code&gt; statement.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using var array = ValueEnumerable.Range(1, 1000).ToArrayPool();&#xA;&#xA;var size = array.Size; // same as Length/Count in other types&#xA;var span = array.Span;&#xA;var memory = array.Memory;&#xA;var arraySegment = array.ArraySegment;&#xA;var enumerable = array.AsEnumerable();&#xA;var valueEnumerable = array.AsValueEnumerable();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For performance reasons to reduce allocations, &lt;code&gt;PooledArray&amp;lt;TSource&amp;gt;&lt;/code&gt; is a &lt;code&gt;struct&lt;/code&gt;. This creates a risk of returning the same array multiple times due to boxing or copying. Also, ArrayPool is not suitable for long-term array storage. It is recommended to simply use &lt;code&gt;ToArrayPool()&lt;/code&gt; with &lt;code&gt;using&lt;/code&gt; and keep the lifetime short.&lt;/p&gt; &#xA;&lt;p&gt;If you absolutely need the raw internal array, you can &lt;code&gt;Deconstruct&lt;/code&gt; it to &lt;code&gt;(T[] Array, int Size)&lt;/code&gt;. After deconstructing, ownership is considered transferred, and all methods of &lt;code&gt;PooledArray&amp;lt;TSource&amp;gt;&lt;/code&gt; become unavailable.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;JoinToString(char|string seperator)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Since &lt;code&gt;ZLinq&lt;/code&gt; is not &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, it cannot be passed to &lt;code&gt;String.Join&lt;/code&gt;. &lt;code&gt;JoinToString&lt;/code&gt; provides the same functionality as &lt;code&gt;String.Join&lt;/code&gt;, returning a string joined with the separator.&lt;/p&gt; &#xA;&lt;h2&gt;Range&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Range&lt;/code&gt; is not only compatible with System.Linq&#39;s &lt;code&gt;Range(int start, int count)&lt;/code&gt; but also has many additional overloads such as &lt;code&gt;System.Range&lt;/code&gt; and &lt;code&gt;DateTime&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// 95, 96, 97, 98, 99&#xA;var range1 = ValueEnumerable.Range(95..100);&#xA;&#xA;// 95, 96, 97, 98, 99, 100&#xA;var range2 = ValueEnumerable.Range(95..100, RightBound.Inclusive);&#xA;&#xA;// 10, 12, 14, 16, 18&#xA;var step = ValueEnumerable.Range(start: 10, count: 5, step: 2);&#xA;&#xA;// 10, 9, 8, 7, 6&#xA;var reverse = ValueEnumerable.Range(start: 10, count: 5, step: -1);&#xA;&#xA;// 10, 9, 8, 7, 6, 5&#xA;var downTo = ValueEnumerable.Range(start: 10, end: 5, RightBound.Inclusive);&#xA;&#xA;// 0, 1,.........&#xA;var infinite = ValueEnumerable.Range(..);&#xA;&#xA;// a, b, c,..., z&#xA;var alphabets = ValueEnumerable.Range(start: &#39;a&#39;, end: &#39;z&#39;, RightBound.Inclusive);&#xA;&#xA;// 5/13, 5/14, 5/15, 5/16, 5/17, 5/18, 5/19&#xA;var daysOfweek = ValueEnumerable.Range(DateTime.Now, 7, TimeSpan.FromDays(1)); ;&#xA;&#xA;// 5/1, 5/2,...,5/31&#xA;var now = DateTime.Now;&#xA;var calendarOfThisMonth = ValueEnumerable.Range(new DateTime(now.Year, now.Month, 1), DateTime.DaysInMonth(now.Year, now.Month), TimeSpan.FromDays(1));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Passing &lt;code&gt;..&lt;/code&gt; as Range creates an infinite stream. Range is Exclusive by default, but you can also run it as Inclusive by specifying &lt;code&gt;RightBound.Inclusive/Exclusive&lt;/code&gt;. Also, in .NET 8 or later, it supports &lt;code&gt;IAdditionOperators&amp;lt;T&amp;gt;&lt;/code&gt;, allowing you to generate not only int but also &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, etc. In addition, it supports more generic generation with not only count but also &lt;code&gt;T end&lt;/code&gt; specification and &lt;code&gt;TStep step&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It supports &lt;code&gt;DateTime&lt;/code&gt;, &lt;code&gt;DateTimeOffset&lt;/code&gt; + &lt;code&gt;TimeSpan&lt;/code&gt; for all platforms. &lt;a href=&#34;https://github.com/dotnet/runtime/issues/76225&#34;&gt;Unfortunately, &lt;code&gt;DateTime&lt;/code&gt; and &lt;code&gt;DateTimeOffset&lt;/code&gt; do not support Generic Math&lt;/a&gt;, but we have prepared our own implementation that provides functionality equivalent to &lt;code&gt;IAdditionOperators&amp;lt;T&amp;gt;&lt;/code&gt; support. This makes it easy to generate date sequences.&lt;/p&gt; &#xA;&lt;p&gt;The complete list of Range APIs is as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public enum RightBound&#xA;{&#xA;    Inclusive,&#xA;    Exclusive&#xA;}&#xA;&#xA;public static partial class ValueEnumerable&#xA;{&#xA;    public static ValueEnumerable&amp;lt;FromRange, int&amp;gt; Range(int start, int count)&#xA;&#xA;    public static ValueEnumerable&amp;lt;FromRange2, int&amp;gt; Range(Range range, RightBound rightBound = RightBound.Exclusive)&#xA;&#xA;#if NET8_0_OR_GREATER&#xA;&#xA;    public static ValueEnumerable&amp;lt;FromRange&amp;lt;T, T&amp;gt;, T&amp;gt; Range&amp;lt;T&amp;gt;(T start, int count)&#xA;        where T : INumberBase&amp;lt;T&amp;gt;&#xA;&#xA;    public static ValueEnumerable&amp;lt;FromRange&amp;lt;T, TStep&amp;gt;, T&amp;gt; Range&amp;lt;T, TStep&amp;gt;(T start, int count, TStep step)&#xA;        where T : IAdditionOperators&amp;lt;T, TStep, T&amp;gt;&#xA;&#xA;    public static ValueEnumerable&amp;lt;FromRangeTo&amp;lt;T, T&amp;gt;, T&amp;gt; Range&amp;lt;T&amp;gt;(T start, T end, RightBound rightBound)&#xA;        where T : INumberBase&amp;lt;T&amp;gt;, IComparisonOperators&amp;lt;T, T, bool&amp;gt;&#xA;&#xA;    public static ValueEnumerable&amp;lt;FromRangeTo&amp;lt;T, TStep&amp;gt;, T&amp;gt; Range&amp;lt;T, TStep&amp;gt;(T start, T end, TStep step, RightBound rightBound)&#xA;        where T : IAdditionOperators&amp;lt;T, TStep, T&amp;gt;, IComparisonOperators&amp;lt;T, T, bool&amp;gt;&#xA;&#xA;#endif&#xA;&#xA;    public static ValueEnumerable&amp;lt;FromRangeDateTime, DateTime&amp;gt; Range(DateTime start, int count, TimeSpan step)&#xA;    public static ValueEnumerable&amp;lt;FromRangeDateTimeTo, DateTime&amp;gt; Range(DateTime start, DateTime end, TimeSpan step, RightBound rightBound)&#xA;    public static ValueEnumerable&amp;lt;FromRangeDateTimeOffset, DateTimeOffset&amp;gt; Range(DateTimeOffset start, int count, TimeSpan step)&#xA;    public static ValueEnumerable&amp;lt;FromRangeDateTimeOffsetTo, DateTimeOffset&amp;gt; Range(DateTimeOffset start, DateTimeOffset end, TimeSpan step, RightBound rightBound)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Difference and Limitation&lt;/h2&gt; &#xA;&lt;p&gt;For .NET 9 and above, &lt;code&gt;ValueEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; is a &lt;code&gt;ref struct&lt;/code&gt; and cannot be converted to &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;. To ensure compatibility when upgrading, &lt;code&gt;AsEnumerable&lt;/code&gt; is not provided by default even for versions prior to .NET 9.&lt;/p&gt; &#xA;&lt;p&gt;Since &lt;code&gt;ValueEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; is not an &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, it cannot be passed to methods that require &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;. It&#39;s also difficult to pass it to other methods due to the complex type signatures required by generics (implementation is explained in the &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#custom-extensions&#34;&gt;Custom Extensions&lt;/a&gt; section). Using &lt;code&gt;ToArray()&lt;/code&gt; is one solution, but this can cause unnecessary allocations in some cases. For temporary use, you can call &lt;code&gt;ToArrayPool&lt;/code&gt; to pass to methods that require &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; without allocations. However, be careful that this &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; will be returned within the using scope, so you must ensure it doesn&#39;t leak outside the scope (storing it in a field is not allowed).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;String.Join&lt;/code&gt; has overloads for both &lt;code&gt;IEnumerable&amp;lt;string&amp;gt;&lt;/code&gt; and &lt;code&gt;params object[]&lt;/code&gt;. Passing &lt;code&gt;ValueEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; directly will select the &lt;code&gt;object[]&lt;/code&gt; overload, which may not give the desired result. In this case, use the &lt;code&gt;JoinToString&lt;/code&gt; operator instead.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ValueEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; is a struct, and its size increases slightly with each method chain. With many chained methods, copy costs can become significant. When iterating over small collections, these copy costs can outweigh the benefits, causing performance to be worse than standard LINQ. However, this is only an issue with extremely long method chains and small iteration counts, so it&#39;s rarely a practical concern.&lt;/p&gt; &#xA;&lt;p&gt;Each chain operation returns a different type, so you cannot reassign to the same variable. For example, code that continuously reassigns &lt;code&gt;Concat&lt;/code&gt; in a for loop cannot be implemented.&lt;/p&gt; &#xA;&lt;p&gt;In .NET 8 and above, the &lt;code&gt;Sum&lt;/code&gt; and &lt;code&gt;Average&lt;/code&gt; methods for &lt;code&gt;double&lt;/code&gt; use SIMD processing, which performs parallel processing based on SIMD width. This results in calculation errors that differ from normal ones due to the different order of addition.&lt;/p&gt; &#xA;&lt;h2&gt;Drop-in replacement&lt;/h2&gt; &#xA;&lt;p&gt;When introducing &lt;code&gt;ZLinq.DropInGenerator&lt;/code&gt;, you can automatically use ZLinq for all LINQ methods without calling &lt;code&gt;AsValueEnumerable()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq.DropInGenerator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/img/dropin.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It works by using a Source Generator to add extension methods for each type that take priority, making &lt;code&gt;ZLinq&lt;/code&gt; methods be selected instead of System.Linq when the same name and arguments are used. After installing the package, you need to configure it with an assembly attribute.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[assembly: ZLinq.ZLinqDropInAttribute(&#34;ZLinq&#34;, ZLinq.DropInGenerateTypes.Array)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;generateNamespace&lt;/code&gt; is the namespace for the generated code, and &lt;code&gt;DropInGenerateTypes&lt;/code&gt; selects the target types. &lt;code&gt;DropInGenerateTypes&lt;/code&gt; allows you to choose from &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Span&lt;/code&gt; (Span/ReadOnlySpan), &lt;code&gt;Memory&lt;/code&gt; (Memory/ReadOnlyMemory), &lt;code&gt;List&lt;/code&gt;, and &lt;code&gt;Enumerable&lt;/code&gt; (IEnumerable). These are Flags, so you can combine them, such as &lt;code&gt;DropInGenerateTypes.Array | DropInGenerateTypes.Span&lt;/code&gt;. There are also predefined combinations: &lt;code&gt;Collection = Array | Span | Memory | List&lt;/code&gt; and &lt;code&gt;Everything = Array | Span | Memory | List | Enumerable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When using &lt;code&gt;DropInGenerateTypes.Enumerable&lt;/code&gt;, which generates extension methods for &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, you need to make &lt;code&gt;generateNamespace&lt;/code&gt; global as a namespace priority. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[assembly: ZLinq.ZLinqDropInAttribute(&#34;&#34;, ZLinq.DropInGenerateTypes.Everything)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is the most aggressive configuration, causing all LINQ methods to be processed by ZLinq, and making it impossible to use normal LINQ methods (if Enumerable is not included, you can call AsEnumerable() to execute with System.Linq).&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s better to use application&#39;s default namespace rather than globally, as this allows you to switch between normal LINQ using namespaces. This approach is recommended when you need to target &lt;code&gt;Enumerable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;[assembly: ZLinqDropInAttribute(&#34;MyApp&#34;, DropInGenerateTypes.Everything)]&#xA;&#xA;// namespace under MyApp&#xA;namespace MyApp.Foo&#xA;{&#xA;    public class Bar&#xA;    {&#xA;        public static void Foo(IEnumerable&amp;lt;int&amp;gt; source)&#xA;        {&#xA;            // ZLinq ValueEnumerable&amp;lt;T&amp;gt;&#xA;            var seq = source.Select(x =&amp;gt; x * 2).Shuffle();&#xA;            using var e = seq.Enumerator;&#xA;            while (e.TryGetNext(out var current))&#xA;            {&#xA;                Console.WriteLine(current);&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;// not under MyApp namespace&#xA;namespace NotMyApp&#xA;{&#xA;    public class Baz&#xA;    {&#xA;        public static void Foo(IEnumerable&amp;lt;int&amp;gt; source)&#xA;        {&#xA;            // IEnumerable&amp;lt;T&amp;gt;&#xA;            var seq = source.Select(x =&amp;gt; x * 2); // .Shuffle();&#xA;            using var e = seq.GetEnumerator();&#xA;            while (e.MoveNext())&#xA;            {&#xA;                Console.WriteLine(e.Current);&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ZLinq is powerful and in many cases it performs better than regular LINQ, but it also has its limitations. For more information, please refer to &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#difference-and-limitation&#34;&gt;Difference and Limitation&lt;/a&gt;. When you are not familiar with it, we recommend that you use &lt;code&gt;DropInGenerateTypes.Collection&lt;/code&gt; instead of &lt;code&gt;DropInGenerateTypes.Everything&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Other options for &lt;code&gt;ZLinqDropInAttribute&lt;/code&gt; include &lt;code&gt;GenerateAsPublic&lt;/code&gt;, &lt;code&gt;ConditionalCompilationSymbols&lt;/code&gt;, and &lt;code&gt;DisableEmitSource&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)]&#xA;public sealed class ZLinqDropInAttribute : Attribute&#xA;{&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Gets the namespace where the generated LINQ implementations will be placed.&#xA;    /// If empty, the implementations will be generated in the global namespace.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    public string GenerateNamespace { get; }&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Gets the types of collections for which LINQ implementations should be generated.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    public DropInGenerateTypes DropInGenerateTypes { get; }&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Gets whether the generated LINQ implementations should be public.&#xA;    /// When true, the implementations will be generated with public visibility.&#xA;    /// When false (default), the implementations will be generated with internal visibility.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    public bool GenerateAsPublic { get; set; }&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Gets or sets the conditional compilation symbols to wrap the generated code with #if directives.&#xA;    /// If specified, the generated code will be wrapped in #if/#endif directives using these symbols.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    public string? ConditionalCompilationSymbols { get; set; }&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Gets or sets whether to disable source generation in emitted code.&#xA;    /// When true, the source code comments will not be included in the generated code.&#xA;    /// When false (default), source code comments will be included in the generated code.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    public bool DisableEmitSource { get; set; }&#xA;&#xA;    /// &amp;lt;summary&amp;gt;&#xA;    /// Initializes a new instance of the &amp;lt;see cref=&#34;ZLinqDropInAttribute&#34;/&amp;gt; class.&#xA;    /// &amp;lt;/summary&amp;gt;&#xA;    /// &amp;lt;param name=&#34;generateNamespace&#34;&amp;gt;The namespace where the generated LINQ implementations will be placed. If empty, place to global.&amp;lt;/param&amp;gt;&#xA;    /// &amp;lt;param name=&#34;dropInGenerateTypes&#34;&amp;gt;The types of collections for which LINQ implementations should be generated.&amp;lt;/param&amp;gt;&#xA;    public ZLinqDropInAttribute(string generateNamespace, DropInGenerateTypes dropInGenerateTypes)&#xA;    {&#xA;        GenerateNamespace = generateNamespace;&#xA;        DropInGenerateTypes = dropInGenerateTypes;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To support DropIn types other than &lt;code&gt;DropInGenerateTypes&lt;/code&gt;, you can use &lt;code&gt;ZLinqDropInExternalExtensionAttribute&lt;/code&gt;. This attribute allows you to generate DropIn for any type by specifying its fully qualified name. For example, to add support for &lt;code&gt;IReadOnlyCollection&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;IReadOnlyList&amp;lt;T&amp;gt;&lt;/code&gt;, write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// T must be written as `1 (metadata-name). For nested types, connect with +&#xA;[assembly: ZLinqDropInExternalExtension(&#34;ZLinq&#34;, &#34;System.Collections.Generic.IReadOnlyCollection`1&#34;)]&#xA;[assembly: ZLinqDropInExternalExtension(&#34;ZLinq&#34;, &#34;System.Collections.Generic.IReadOnlyList`1&#34;)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For types that support &lt;code&gt;IValueEnumerator&amp;lt;T&amp;gt;&lt;/code&gt; through &lt;code&gt;AsValueEnumerable()&lt;/code&gt;, specify the ValueEnumerator type name as the second argument. For example, with &lt;code&gt;ImmutableArray&amp;lt;T&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[assembly: ZLinqDropInExternalExtension(&#34;ZLinq&#34;, &#34;System.Collections.Immutable.ImmutableArray`1&#34;, &#34;ZLinq.Linq.FromImmutableArray`1&#34;)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows all operators to be processed by ZLinq using an optimized type.&lt;/p&gt; &#xA;&lt;p&gt;If you want to make your custom collection types DropIn compatible, you can embed them in your assembly using &lt;code&gt;[ZLinqDropInExtension]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ZLinqDropInExtension]&#xA;public class AddOnlyIntList : IEnumerable&amp;lt;int&amp;gt;&#xA;{&#xA;    List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();&#xA;&#xA;    public void Add(int x) =&amp;gt; list.Add(x);&#xA;&#xA;    public IEnumerator&amp;lt;int&amp;gt; GetEnumerator() =&amp;gt; list.GetEnumerator();&#xA;    IEnumerator IEnumerable.GetEnumerator() =&amp;gt; list.GetEnumerator();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This generates a &lt;code&gt;public static partial class AddOnlyIntListZLinqDropInExtensions&lt;/code&gt; in the same namespace, overriding all LINQ operators with ZLinq. This works with generic types as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ZLinqDropInExtension]&#xA;public class AddOnlyList&amp;lt;T&amp;gt; : IEnumerable&amp;lt;T&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While &lt;code&gt;[ZLinqDropInExtension]&lt;/code&gt; works with classes implementing &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, implementing &lt;code&gt;IValueEnumerable&amp;lt;TEnumerator, T&amp;gt;&lt;/code&gt; provides zero-allocation optimization for ZLinq:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[ZLinqDropInExtension]&#xA;public class AddOnlyIntList2 : IValueEnumerable&amp;lt;AddOnlyIntList2.Enumerator, int&amp;gt;&#xA;{&#xA;    List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();&#xA;&#xA;    public void Add(int x) =&amp;gt; list.Add(x);&#xA;&#xA;    public ValueEnumerable&amp;lt;FromValueEnumerable&amp;lt;Enumerator, int&amp;gt;, int&amp;gt; AsValueEnumerable()&#xA;    {&#xA;        // you need to write new(new(new())) magic.&#xA;        return new(new(new(list)));&#xA;    }&#xA;&#xA;    // `public` struct enumerator&#xA;    public struct Enumerator(List&amp;lt;int&amp;gt; source) : IValueEnumerator&amp;lt;int&amp;gt;&#xA;    {&#xA;        int index;&#xA;&#xA;        public bool TryGetNonEnumeratedCount(out int count)&#xA;        {&#xA;            count = source.Count;&#xA;            return true;&#xA;        }&#xA;&#xA;        public bool TryGetSpan(out ReadOnlySpan&amp;lt;int&amp;gt; span)&#xA;        {&#xA;            span = CollectionsMarshal.AsSpan(source);&#xA;            return true;&#xA;        }&#xA;&#xA;        public bool TryCopyTo(scoped Span&amp;lt;int&amp;gt; destination, Index offset)&#xA;        {&#xA;            // Optional path: if you can not write this, always return false is ok.&#xA;            ReadOnlySpan&amp;lt;int&amp;gt; span = CollectionsMarshal.AsSpan(source);&#xA;            if (ZLinq.Internal.EnumeratorHelper.TryGetSlice(span, offset, destination.Length, out var slice))&#xA;            {&#xA;                slice.CopyTo(destination);&#xA;                return true;&#xA;&#xA;            }&#xA;            return false;&#xA;        }&#xA;&#xA;        public bool TryGetNext(out int current)&#xA;        {&#xA;            if (index &amp;lt; source.Count)&#xA;            {&#xA;                current = source[index];&#xA;                index++;&#xA;                return true;&#xA;            }&#xA;&#xA;            current = default;&#xA;            return false;&#xA;        }&#xA;&#xA;        public void Dispose() { }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, implementing &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; is not necessary. If a collection implements both &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;IValueEnumerable&amp;lt;TEnumerator, T&amp;gt;&lt;/code&gt;, the latter takes precedence.&lt;/p&gt; &#xA;&lt;h2&gt;LINQ to Tree&lt;/h2&gt; &#xA;&lt;p&gt;LINQ to XML introduced the concept of querying around axes to C#. Even if you don&#39;t use XML, similar APIs are incorporated into Roslyn and effectively used for exploring SyntaxTrees. ZLinq extends this concept to make it applicable to anything that can be considered a Tree, allowing &lt;code&gt;Ancestors&lt;/code&gt;, &lt;code&gt;Children&lt;/code&gt;, &lt;code&gt;Descendants&lt;/code&gt;, &lt;code&gt;BeforeSelf&lt;/code&gt;, and &lt;code&gt;AfterSelf&lt;/code&gt; to be applied.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/img/axis.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Specifically, by defining a struct that implements the following interface, it becomes iterable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public interface ITraverser&amp;lt;TTraverser, T&amp;gt; : IDisposable&#xA;    where TTraverser : struct, ITraverser&amp;lt;TTraverser, T&amp;gt; // self&#xA;{&#xA;    T Origin { get; }&#xA;    TTraverser ConvertToTraverser(T next); // for Descendants&#xA;    bool TryGetHasChild(out bool hasChild); // optional: optimize use for Descendants&#xA;    bool TryGetChildCount(out int count);   // optional: optimize use for Children&#xA;    bool TryGetParent(out T parent); // for Ancestors&#xA;    bool TryGetNextChild(out T child); // for Children | Descendants&#xA;    bool TryGetNextSibling(out T next); // for AfterSelf&#xA;    bool TryGetPreviousSibling(out T previous); // BeforeSelf&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Standard packages are available for FileSystemInfo and JsonNode. For Unity, it&#39;s applicable to GameObject and Transform.&lt;/p&gt; &#xA;&lt;h3&gt;FileSystem&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq.FileSystem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;var root = new DirectoryInfo(&#34;C:\\Program Files (x86)\\Steam&#34;);&#xA;&#xA;// FileSystemInfo(FileInfo/DirectoryInfo) can call `Ancestors`, `Children`, `Descendants`, `BeforeSelf`, `AfterSelf`&#xA;var allDlls = root&#xA;    .Descendants()&#xA;    .OfType&amp;lt;FileInfo&amp;gt;()&#xA;    .Where(x =&amp;gt; x.Extension == &#34;.dll&#34;);&#xA;&#xA;var grouped = allDlls&#xA;    .GroupBy(x =&amp;gt; x.Name)&#xA;    .Select(x =&amp;gt; new { FileName = x.Key, Count = x.Count() })&#xA;    .OrderByDescending(x =&amp;gt; x.Count);&#xA;&#xA;foreach (var item in grouped)&#xA;{&#xA;    Console.WriteLine(item);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JSON(System.Text.Json)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq.Json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;// System.Text.Json&#39;s JsonNode is the target of LINQ to JSON(not JsonDocument/JsonElement).&#xA;var json = JsonNode.Parse(&#34;&#34;&#34;&#xA;{&#xA;    &#34;nesting&#34;: {&#xA;      &#34;level1&#34;: {&#xA;        &#34;description&#34;: &#34;First level of nesting&#34;,&#xA;        &#34;value&#34;: 100,&#xA;        &#34;level2&#34;: {&#xA;          &#34;description&#34;: &#34;Second level of nesting&#34;,&#xA;          &#34;flags&#34;: [true, false, true],&#xA;          &#34;level3&#34;: {&#xA;            &#34;description&#34;: &#34;Third level of nesting&#34;,&#xA;            &#34;coordinates&#34;: {&#xA;              &#34;x&#34;: 10.5,&#xA;              &#34;y&#34;: 20.75,&#xA;              &#34;z&#34;: -5.0&#xA;            },&#xA;            &#34;level4&#34;: {&#xA;              &#34;description&#34;: &#34;Fourth level of nesting&#34;,&#xA;              &#34;metadata&#34;: {&#xA;                &#34;created&#34;: &#34;2025-02-15T14:30:00Z&#34;,&#xA;                &#34;modified&#34;: null,&#xA;                &#34;version&#34;: 2.1&#xA;              },&#xA;              &#34;level5&#34;: {&#xA;                &#34;description&#34;: &#34;Fifth level of nesting&#34;,&#xA;                &#34;settings&#34;: {&#xA;                  &#34;enabled&#34;: true,&#xA;                  &#34;threshold&#34;: 0.85,&#xA;                  &#34;options&#34;: [&#34;fast&#34;, &#34;accurate&#34;, &#34;balanced&#34;],&#xA;                  &#34;config&#34;: {&#xA;                    &#34;timeout&#34;: 30000,&#xA;                    &#34;retries&#34;: 3,&#xA;                    &#34;deepSetting&#34;: {&#xA;                      &#34;algorithm&#34;: &#34;advanced&#34;,&#xA;                      &#34;parameters&#34;: [1, 1, 2, 3, 5, 8, 13]&#xA;                    }&#xA;                  }&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;}&#xA;&#34;&#34;&#34;);&#xA;&#xA;// JsonNode&#xA;var origin = json![&#34;nesting&#34;]![&#34;level1&#34;]![&#34;level2&#34;]!;&#xA;&#xA;// JsonNode axis, Children, Descendants, Anestors, BeforeSelf, AfterSelf and ***Self.&#xA;foreach (var item in origin.Descendants().Select(x =&amp;gt; x.Node).OfType&amp;lt;JsonArray&amp;gt;())&#xA;{&#xA;    // [true, false, true], [&#34;fast&#34;, &#34;accurate&#34;, &#34;balanced&#34;], [1, 1, 2, 3, 5, 8, 13]&#xA;    Console.WriteLine(item.ToJsonString(JsonSerializerOptions.Web));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;GameObject/Transform(Unity)&lt;/h3&gt; &#xA;&lt;p&gt;see: &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#unity&#34;&gt;unity&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;LINQ to SIMD&lt;/h2&gt; &#xA;&lt;p&gt;In .NET 8 and above, there are operators that apply SIMD when &lt;code&gt;ValueEnumerable&amp;lt;T&amp;gt;.TryGetSpan&lt;/code&gt; returns true. The scope of application is wider than in regular System.Linq.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Range&lt;/strong&gt; to ToArray/ToList/CopyTo/etc...&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Repeat&lt;/strong&gt; for &lt;code&gt;unmanaged struct&lt;/code&gt; and &lt;code&gt;size is power of 2&lt;/code&gt; to ToArray/ToList/CopyTo/etc...&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Sum&lt;/strong&gt; for &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;SumUnchecked&lt;/strong&gt; for &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Average&lt;/strong&gt; for &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Max&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;, &lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt128&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Min&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;, &lt;code&gt;Int128&lt;/code&gt;, &lt;code&gt;UInt128&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Contains&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;SequenceEqual&lt;/strong&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;nint&lt;/code&gt;, &lt;code&gt;nuint&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;Sum&lt;/code&gt; performs calculations as checked, but if you don&#39;t need to worry about overflow, using &lt;code&gt;SumUnchecked&lt;/code&gt; is faster.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Method&lt;/th&gt; &#xA;   &lt;th&gt;N&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Mean&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Allocated&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ForLoop&lt;/td&gt; &#xA;   &lt;td&gt;16384&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;25,198.556 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SystemLinqSum&lt;/td&gt; &#xA;   &lt;td&gt;16384&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1,402.259 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ZLinqSum&lt;/td&gt; &#xA;   &lt;td&gt;16384&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1,351.449 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ZLinqSumUnchecked&lt;/td&gt; &#xA;   &lt;td&gt;16384&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;721.832 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;By using &lt;code&gt;ZLinq.Simd&lt;/code&gt; in your using statements, you can call &lt;code&gt;.AsVectorizable()&lt;/code&gt; on &lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt;, which allows you to use &lt;code&gt;Sum&lt;/code&gt;, &lt;code&gt;SumUnchecked&lt;/code&gt;, &lt;code&gt;Average&lt;/code&gt;, &lt;code&gt;Max&lt;/code&gt;, &lt;code&gt;Min&lt;/code&gt;, &lt;code&gt;Contains&lt;/code&gt;, and &lt;code&gt;SequenceEqual&lt;/code&gt;. This explicitly indicates execution with SIMD regardless of the LINQ chain state (though type checking is ambiguous so processing might occur in a normal loop, and if &lt;code&gt;Vector.IsHardwareAccelerated &amp;amp;&amp;amp; Vector&amp;lt;T&amp;gt;.IsSupported&lt;/code&gt; is false, normal loop processing will be used).&lt;/p&gt; &#xA;&lt;p&gt;From &lt;code&gt;int[]&lt;/code&gt; or &lt;code&gt;Span&amp;lt;int&amp;gt;&lt;/code&gt;, you can call &lt;code&gt;VectorizedFillRange&lt;/code&gt;. This is equivalent to &lt;code&gt;ValueEunmerable.Range().CopyTo()&lt;/code&gt; and allows you to quickly generate sequential numbers through SIMD processing.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Method&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Mean&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Allocated&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Range&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;540.0 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;For&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;6,228.9 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;&lt;code&gt;VectorizedUpdate&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;In ZLinq, you can perform relatively flexible vectorized loop processing using &lt;code&gt;Func&lt;/code&gt;. With &lt;code&gt;T[]&lt;/code&gt; and &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;, you can use the &lt;code&gt;VectorizedUpdate&lt;/code&gt; method. By writing two lambda expressions - &lt;code&gt;Func&amp;lt;Vector&amp;lt;T&amp;gt;, Vector&amp;lt;T&amp;gt;&amp;gt; vectorFunc&lt;/code&gt; for vector operations and &lt;code&gt;Func&amp;lt;T, T&amp;gt; func&lt;/code&gt; for handling remainder elements - you can perform loop update processing at SIMD width.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq.Simd; // needs using&#xA;&#xA;int[] source = Enumerable.Range(0, 10000).ToArray();&#xA;&#xA;[Benchmark]&#xA;public void For()&#xA;{&#xA;    for (int i = 0; i &amp;lt; source.Length; i++)&#xA;    {&#xA;        source[i] = source[i] * 10;&#xA;    }&#xA;}&#xA;&#xA;[Benchmark]&#xA;public void VectorizedUpdate()&#xA;{&#xA;    // arg1: Vector&amp;lt;int&amp;gt; =&amp;gt; Vector&amp;lt;int&amp;gt;&#xA;    // arg2: int =&amp;gt; int&#xA;    source.VectorizedUpdate(static x =&amp;gt; x * 10, static x =&amp;gt; x * 10);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Method&lt;/th&gt; &#xA;   &lt;th&gt;N&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Mean&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Error&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;StdDev&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Allocated&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;For&lt;/td&gt; &#xA;   &lt;td&gt;10000&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;4,560.5 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;67.24 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3.69 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;VectorizedUpdate&lt;/td&gt; &#xA;   &lt;td&gt;10000&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;558.9 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;6.42 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;0.35 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;There is delegate overhead when compared to writing everything inline, but processing can be faster than using for-loops. However, this varies case by case, so please take measurements in advance based on your data volume and method content. Of course, if you&#39;re seeking the best possible performance, you should write code inline.&lt;/p&gt; &#xA;&lt;h3&gt;Vectorizable Methods&lt;/h3&gt; &#xA;&lt;p&gt;You can convert from &lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;Vectorizable&amp;lt;T&amp;gt;&lt;/code&gt; using &lt;code&gt;AsVectorizable()&lt;/code&gt;, which allows you to use &lt;code&gt;Aggregate&lt;/code&gt;, &lt;code&gt;All&lt;/code&gt;, &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;, &lt;code&gt;Select&lt;/code&gt;, and &lt;code&gt;Zip&lt;/code&gt; methods that accept a &lt;code&gt;Func&lt;/code&gt; as an argument.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Aggregate&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;source.AsVectorizable().Aggregate((x, y) =&amp;gt; Vector.Min(x, y), (x, y) =&amp;gt; Math.Min(x, y))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;All&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;source.AsVectorizable().All(x =&amp;gt; Vector.GreaterThanAll(x, new(5000)), x =&amp;gt; x &amp;gt; 5000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;source.AsVectorizable().Any(x =&amp;gt; Vector.LessThanAll(x, new(5000)), x =&amp;gt; x &amp;lt; 5000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Count&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;source.AsVectorizable().Count(x =&amp;gt; Vector.GreaterThan(x, new(5000)), x =&amp;gt; x &amp;gt; 5000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Method&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Mean&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Error&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;StdDev&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Allocated&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;VectorizableCount&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1,048.4 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;39.39 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2.16 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;LinqCount&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;10,909.3 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;54.79 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3.00 ns&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Select&lt;/code&gt; -&amp;gt; &lt;code&gt;ToArray&lt;/code&gt; or &lt;code&gt;CopyTo&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;source.AsVectorizable().Select(x =&amp;gt; x * 3, x =&amp;gt; x * 3).ToArray();&#xA;source.AsVectorizable().Select(x =&amp;gt; x * 3, x =&amp;gt; x * 3).CopyTo(destination);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Zip&lt;/code&gt; -&amp;gt; &lt;code&gt;ToArray&lt;/code&gt; or &lt;code&gt;CopyTo&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Zip2&#xA;array1.AsVectorizable().Zip(array2, (x, y) =&amp;gt; x + y, (x, y) =&amp;gt; x + y).CopyTo(destination);&#xA;array1.AsVectorizable().Zip(array2, (x, y) =&amp;gt; x + y, (x, y) =&amp;gt; x + y).ToArray();&#xA;&#xA;// Zip3&#xA;array1.AsVectorizable().Zip(array2, array3, (x, y, z) =&amp;gt; x + y + z, (x, y, z) =&amp;gt; x + y + z).CopyTo(destination);&#xA;array1.AsVectorizable().Zip(array2, array3, (x, y, z) =&amp;gt; x + y + z, (x, y, z) =&amp;gt; x + y + z).ToArray();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Method&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Mean&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ZLinqVectorizableZipCopyTo&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;24.17 μs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ZLinqVectorizableZip3CopyTo&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;29.26 μs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ZLinqZipCopyTo&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;329.43 μs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ZLinqZip3CopyTo&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;584.69 μs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Unity&lt;/h2&gt; &#xA;&lt;p&gt;There are two installation steps required to use it in Unity.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install &lt;code&gt;ZLinq&lt;/code&gt; from NuGet using &lt;a href=&#34;https://github.com/GlitchEnzo/NuGetForUnity&#34;&gt;NuGetForUnity&lt;/a&gt; Open Window from NuGet -&amp;gt; Manage NuGet Packages, Search &#34;ZLinq&#34; and Press Install.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the &lt;code&gt;ZLinq.Unity&lt;/code&gt; package by referencing the git URL&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;https://github.com/Cysharp/ZLinq.git?path=src/ZLinq.Unity/Assets/ZLinq.Unity&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the help of the Unity package, in addition to the standard ZLinq, LINQ to GameObject functionality becomes available for exploring GameObject/Transform.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/img/axis.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using ZLinq;&#xA;&#xA;public class SampleScript : MonoBehaviour&#xA;{&#xA;    public Transform Origin;&#xA;&#xA;    void Start()&#xA;    {&#xA;        Debug.Log(&#34;Ancestors--------------&#34;);  // Container, Root&#xA;        foreach (var item in Origin.Ancestors()) Debug.Log(item.name);&#xA;&#xA;        Debug.Log(&#34;Children--------------&#34;); // Sphere_A, Sphere_B, Group, Sphere_A, Sphere_B&#xA;        foreach (var item in Origin.Children()) Debug.Log(item.name);&#xA;&#xA;        Debug.Log(&#34;Descendants--------------&#34;); // Sphere_A, Sphere_B, Group, P1, Group, Sphere_B, P2, Sphere_A, Sphere_B&#xA;        foreach (var item in Origin.Descendants()) Debug.Log(item.name);&#xA;&#xA;        Debug.Log(&#34;BeforeSelf--------------&#34;); // C1, C2&#xA;        foreach (var item in Origin.BeforeSelf()) Debug.Log(item.name);&#xA;&#xA;        Debug.Log(&#34;AfterSelf--------------&#34;);  // C3, C4&#xA;        foreach (var item in Origin.AfterSelf()) Debug.Log(item.name);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can chain query(LINQ to Objects). Also, you can filter by component using the &lt;code&gt;OfComponent&amp;lt;T&amp;gt;&lt;/code&gt; helper.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// all filtered(tag == &#34;foobar&#34;) objects&#xA;var foobars = root.Descendants().Where(x =&amp;gt; x.tag == &#34;foobar&#34;);&#xA;&#xA;// get FooScript under self childer objects and self&#xA;var fooScripts = root.ChildrenAndSelf().OfComponent&amp;lt;FooScript&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: In Unity, since .NET Standard 2.1 is referenced, SIMD is not utilized.&lt;/p&gt; &#xA;&lt;p&gt;In .NET 9, &lt;code&gt;ValueEnumerable&lt;/code&gt; is a &lt;code&gt;ref struct&lt;/code&gt;, so it cannot be converted to &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;. However, in Unity it&#39;s a regular &lt;code&gt;struct&lt;/code&gt;, making it possible to convert to &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;. You can improve interoperability by preparing an extension method like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static class ZLinqExtensions&#xA;{&#xA;    public static IEnumerable&amp;lt;T&amp;gt; AsEnumerable&amp;lt;TEnumerator, T&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, T&amp;gt; valueEnumerable)&#xA;        where TEnumerator : struct, IValueEnumerator&amp;lt;T&amp;gt;&#xA;    {&#xA;        using (var e = valueEnumerable.Enumerator)&#xA;        {&#xA;            while (e.TryGetNext(out var current))&#xA;            {&#xA;                yield return current;&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In Unity, you can convert &lt;code&gt;NativeArray&lt;/code&gt;, &lt;code&gt;NativeSlice&lt;/code&gt; using &lt;code&gt;AsEnumerable()&lt;/code&gt; to write queries with ZLinq. If Unity Collections(&lt;code&gt;com.unity.collections&lt;/code&gt;) package version is &lt;code&gt;2.1.1&lt;/code&gt; or above, &lt;code&gt;NativeQueue&lt;/code&gt;, &lt;code&gt;NativeHashSet&lt;/code&gt;, &lt;code&gt;NativeText&lt;/code&gt;, &lt;code&gt;FixedList32Bytes&lt;/code&gt;, &lt;code&gt;FixedList64Bytes&lt;/code&gt;, &lt;code&gt;FixedList128Bytes&lt;/code&gt;, &lt;code&gt;FixedList512Bytes&lt;/code&gt;, &lt;code&gt;FixedList4096Bytes&lt;/code&gt;, &lt;code&gt;FixedString32Bytes&lt;/code&gt;, &lt;code&gt;FixedString64Bytes&lt;/code&gt;, &lt;code&gt;FixedString128Bytes&lt;/code&gt;, &lt;code&gt;FixedString512Bytes&lt;/code&gt;, and &lt;code&gt;FixedString4096Bytes&lt;/code&gt; support &lt;code&gt;AsValueEnumerable()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also use drop-in replacement. Add &lt;code&gt;ZLinq.DropInGenerator&lt;/code&gt; from NuGetForUnity. If you want to use DropInGenerator, the minimum supported Unity version will be &lt;code&gt;2022.3.12f1&lt;/code&gt;, as it is necessary to support C# Incremental Source Generator(Compiler Version, 4.3.0).&lt;/p&gt; &#xA;&lt;p&gt;Assembly attributes need to be set for each asmdef. For example, place a &lt;code&gt;.cs&lt;/code&gt; file like the following in each asmdef. The DropInGenerator is defined in the assembly attributes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// AssemblyAttributes.cs&#xA;using ZLinq;&#xA;[assembly: ZLinqDropIn(&#34;MyApp&#34;, DropInGenerateTypes.Array | DropInGenerateTypes.List)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more details about DropInGenerator, please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/#drop-in-replacement&#34;&gt;Drop-in replacement&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;p&gt;To support Native Collections in addition to regular DropIn types, you can use &lt;code&gt;ZLinqDropInExternalExtension&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[assembly: ZLinqDropInExternalExtension(&#34;ZLinq&#34;, &#34;Unity.Collections.NativeArray`1&#34;, &#34;ZLinq.Linq.FromNativeArray`1&#34;)]&#xA;[assembly: ZLinqDropInExternalExtension(&#34;ZLinq&#34;, &#34;Unity.Collections.NativeArray`1+ReadOnly&#34;, &#34;ZLinq.Linq.FromNativeArray`1&#34;)]&#xA;[assembly: ZLinqDropInExternalExtension(&#34;ZLinq&#34;, &#34;Unity.Collections.NativeSlice`1&#34;, &#34;ZLinq.Linq.FromNativeSlice`1&#34;)]&#xA;[assembly: ZLinqDropInExternalExtension(&#34;ZLinq&#34;, &#34;Unity.Collections.NativeList`1&#34;, &#34;ZLinq.Linq.FromNativeList`1&#34;)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is not just about Unity, but using &lt;code&gt;AsValueEnumerable()&lt;/code&gt; even if only for foreach on &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; can sometimes reduce allocations. If the actual implementation of &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; is a &lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, ZLinq will process it appropriately without allocations.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/img/unityforeach.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;void IterateNormal(IEnumerable&amp;lt;int&amp;gt; source)&#xA;{&#xA;    // Normally there&#39;s an allocation when getting IEnumerator&amp;lt;T&amp;gt;.&#xA;    foreach (var item in source)&#xA;    {&#xA;&#xA;    }&#xA;}&#xA;&#xA;void IterateZLinq(IEnumerable&amp;lt;int&amp;gt; source)&#xA;{&#xA;    // Adding AsValueEnumerable results in 0 allocation.&#xA;    // However, zero alloc only works when the actual implementation of IEnumerable&amp;lt;T&amp;gt; is an array [] or List&amp;lt;T&amp;gt;&#xA;    foreach (var item in source.AsValueEnumerable())&#xA;    {&#xA;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Godot&lt;/h2&gt; &#xA;&lt;p&gt;The minimum supported Godot version will be &lt;code&gt;4.0.0&lt;/code&gt;. You can install ZLinq.Godot package via NuGet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dotnet add package ZLinq.Godot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition to the standard ZLinq, LINQ to Node functionality is available.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Cysharp/ZLinq/main/img/godot.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using Godot;&#xA;using ZLinq;&#xA;&#xA;public partial class SampleScript : Node2D&#xA;{&#xA;    public override void _Ready()&#xA;    {&#xA;        var origin = GetNode&amp;lt;Node2D&amp;gt;(&#34;Container/Origin&#34;);&#xA;&#xA;        GD.Print(&#34;Ancestors--------------&#34;); // Container, Root, root (Root Window)&#xA;        foreach (var item in origin.Ancestors()) GD.Print(item.Name);&#xA;&#xA;        GD.Print(&#34;Children--------------&#34;); // Sphere_A, Sphere_B, Group, Sphere_A, Sphere_B&#xA;        foreach (var item in origin.Children()) GD.Print(item.Name);&#xA;&#xA;        GD.Print(&#34;Descendants--------------&#34;); // Sphere_A, Sphere_B, Group, P1, Group, Sphere_B, P2, Sphere_A, Sphere_B&#xA;        foreach (var item in origin.Descendants()) GD.Print(item.Name);&#xA;&#xA;        GD.Print(&#34;BeforeSelf--------------&#34;); // C1, C2&#xA;        foreach (var item in origin.BeforeSelf()) GD.Print(item.Name);&#xA;&#xA;        GD.Print(&#34;AfterSelf--------------&#34;); // C3, C4&#xA;        foreach (var item in origin.AfterSelf()) GD.Print(item.Name);&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can chain query(LINQ to Objects). Also, you can filter by node type using the &lt;code&gt;OfType()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// get ancestors under a Window&#xA;var ancestors = root.Ancestors().TakeWhile(x =&amp;gt; x is not Window);&#xA;// get FooScript under self childer objects and self&#xA;var fooScripts = root.ChildrenAndSelf().OfType&amp;lt;FooScript&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom Extensions&lt;/h2&gt; &#xA;&lt;p&gt;Implementing extension methods for &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; is common. There are two types of operators: consuming operators like &lt;code&gt;Count&lt;/code&gt; and &lt;code&gt;Sum&lt;/code&gt;, and chainable operators like &lt;code&gt;Select&lt;/code&gt; and &lt;code&gt;Where&lt;/code&gt;. This section explains how to implement them.&lt;/p&gt; &#xA;&lt;h4&gt;Consume Operator&lt;/h4&gt; &#xA;&lt;p&gt;The method signature is slightly more complex compared to &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, requiring constraints on &lt;code&gt;TEnumerator&lt;/code&gt;. For .NET 9 or later, &lt;code&gt;allows ref struct&lt;/code&gt; is also needed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static class MyExtensions&#xA;{&#xA;    public static void Consume&amp;lt;TEnumerator, TSource&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, TSource&amp;gt; source)&#xA;        where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;&#xA;#if NET9_0_OR_GREATER&#xA;        , allows ref struct&#xA;#endif&#xA;    {&#xA;        using var e = source.Enumerator; // using Enumerator&#xA;&#xA;        while (e.TryGetNext(out var current)) // MoveNext + Current&#xA;        {&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of &lt;code&gt;GetEnumerator()&lt;/code&gt;, use &lt;code&gt;Enumerator&lt;/code&gt;, and instead of &lt;code&gt;MoveNext + Current&lt;/code&gt;, use &lt;code&gt;TryGetNext(out)&lt;/code&gt; to consume the iterator. The Enumerator must be used with &lt;code&gt;using&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Consumers can call the Enumerator&#39;s optimization methods: &lt;code&gt;TryGetNonEnumeratedCount&lt;/code&gt;, &lt;code&gt;TryGetSpan&lt;/code&gt;, and &lt;code&gt;TryCopyTo&lt;/code&gt;. For example, getting a Span like this is faster than normal iteration with TryGetNext:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static class MyExtensions&#xA;{&#xA;    public static void ForEach&amp;lt;TEnumerator, TSource&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, TSource&amp;gt; source, Action&amp;lt;TSource&amp;gt; action)&#xA;        where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;&#xA;#if NET9_0_OR_GREATER&#xA;        , allows ref struct&#xA;#endif&#xA;    {&#xA;        using var e = source.Enumerator;&#xA;&#xA;        if (e.TryGetSpan(out var span))&#xA;        {&#xA;            // faster iteration&#xA;            foreach (var item in span)&#xA;            {&#xA;                action(item);&#xA;            }&#xA;        }&#xA;        else&#xA;        {&#xA;            while (e.TryGetNext(out var item))&#xA;            {&#xA;                action(item);&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    public static ImmutableArray&amp;lt;T&amp;gt; ToImmutableArray&amp;lt;TEnumerator, T&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, T&amp;gt; source)&#xA;        where TEnumerator : struct, IValueEnumerator&amp;lt;T&amp;gt;&#xA;#if NET9_0_OR_GREATER&#xA;        , allows ref struct&#xA;#endif&#xA;    {&#xA;        using var e = source.Enumerator;&#xA;&#xA;        if (e.TryGetSpan(out var span))&#xA;        {&#xA;            return ImmutableArray.Create(span);&#xA;        }&#xA;        else&#xA;        {&#xA;            // set capacity if can&#xA;            var builder = e.TryGetNonEnumeratedCount(out var count)&#xA;                ? ImmutableArray.CreateBuilder&amp;lt;T&amp;gt;(count)&#xA;                : ImmutableArray.CreateBuilder&amp;lt;T&amp;gt;();&#xA;&#xA;            while (e.TryGetNext(out var current))&#xA;            {&#xA;                builder.Add(current);&#xA;            }&#xA;&#xA;            return builder.ToImmutable();&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since the enumerator&#39;s state changes, you cannot call other methods after calling &lt;code&gt;TryGetNext&lt;/code&gt;. Also, you cannot call &lt;code&gt;TryGetNext&lt;/code&gt; after &lt;code&gt;TryCopyTo&lt;/code&gt; or &lt;code&gt;TryGetSpan&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Custom Operator&lt;/h4&gt; &#xA;&lt;p&gt;Unlike &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, you can&#39;t use &lt;code&gt;yield return&lt;/code&gt;, so everything must be implemented by hand, making it more difficult than Consume operators. A simple &lt;code&gt;Select&lt;/code&gt; implementation looks like this. For .NET 9 or later, &lt;code&gt;IValueEnumerator&amp;lt;T&amp;gt;&lt;/code&gt; must be implemented as a &lt;code&gt;ref struct&lt;/code&gt;. Also, the accessibility must be &lt;code&gt;public&lt;/code&gt; or &lt;code&gt;internal&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static class MyExtensions&#xA;{&#xA;    public static ValueEnumerable&amp;lt;SimpleSelect&amp;lt;TEnumerator, TSource, TResult&amp;gt;, TResult&amp;gt; SimpleSelect&amp;lt;TEnumerator, TSource, TResult&amp;gt;(this ValueEnumerable&amp;lt;TEnumerator, TSource&amp;gt; source, Func&amp;lt;TSource, TResult&amp;gt; selector)&#xA;        where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;&#xA;#if NET9_0_OR_GREATER&#xA;        , allows ref struct&#xA;#endif&#xA;    {&#xA;        // ValueEnumerable is only a wrapper so unwrapping to enumerator immediately is ok.&#xA;        // `new(new())` is `new ValueEnumerable(new SimpleSelect())`, wrap enumerator to ValueEnumerable.&#xA;        return new(new(source.Enumerator, selector));&#xA;    }&#xA;}&#xA;&#xA;#if NET9_0_OR_GREATER&#xA;public ref struct&#xA;#else&#xA;public struct&#xA;#endif&#xA;    SimpleSelect&amp;lt;TEnumerator, TSource, TResult&amp;gt;(TEnumerator source, Func&amp;lt;TSource, TResult&amp;gt; selector) : IValueEnumerator&amp;lt;TResult&amp;gt;&#xA;        where TEnumerator : struct, IValueEnumerator&amp;lt;TSource&amp;gt;&#xA;#if NET9_0_OR_GREATER&#xA;        , allows ref struct&#xA;#endif&#xA;{&#xA;    TEnumerator source = source; // need to store source enumerator in field explicitly (ref struct limitation)&#xA;&#xA;    public bool TryGetNonEnumeratedCount(out int count)&#xA;    {&#xA;        // If source count is not changed, return count.&#xA;        // Select count is same as source.&#xA;        return source.TryGetNonEnumeratedCount(out count);&#xA;    }&#xA;&#xA;    public bool TryGetSpan(out ReadOnlySpan&amp;lt;TResult&amp;gt; span)&#xA;    {&#xA;        // For example, Take or Skip could return a Slice&#xA;        span = default;&#xA;        return false;&#xA;    }&#xA;&#xA;    public bool TryCopyTo(scoped Span&amp;lt;TResult&amp;gt; destination, Index offset)&#xA;    {&#xA;        // TryCopyTo implementation needs to consider Index calculations, so it&#39;s quite complex.&#xA;        // Also, destination can be smaller than the source size.&#xA;        // Helper methods for calculations are available in ZLinq.Internal.EnumeratorHelper,&#xA;        // such as TryGetSliceRange, TryGetSlice, TryGetSliceRange, TryConsumeGetAt, etc.&#xA;        return false;&#xA;    }&#xA;&#xA;    // This is the main body of the normal processing&#xA;    public bool TryGetNext(out TResult current)&#xA;    {&#xA;        while (source.TryGetNext(out var value))&#xA;        {&#xA;            current = selector(value);&#xA;            return true;&#xA;        }&#xA;&#xA;        current = default!;&#xA;        return false;&#xA;    }&#xA;&#xA;    public void Dispose()&#xA;    {&#xA;        // Always dispose the source&#xA;        source.Dispose();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;TryGetNonEnumeratedCount&lt;/code&gt;, &lt;code&gt;TryGetSpan&lt;/code&gt;, and &lt;code&gt;TryCopyTo&lt;/code&gt;, it&#39;s fine to return &lt;code&gt;false&lt;/code&gt; if implementation is difficult. If state is needed (for example, Take needs to keep track of the number of calls), place it in a field, but note that you should not initialize reference types or structs containing reference types in the constructor. This is because in method chains, Enumerators are passed by copy, so reference types would share references. If you need to hold reference types, they must be initialized when &lt;code&gt;TryGetNext&lt;/code&gt; is first called.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgement&lt;/h2&gt; &#xA;&lt;p&gt;Since the preview version release, we have received multiple ideas for fundamental interface revisions leading to performance improvements from &lt;a href=&#34;https://github.com/Akeit0&#34;&gt;@Akeit0&lt;/a&gt;, and test and benchmark infrastructure from &lt;a href=&#34;https://github.com/filzrev&#34;&gt;@filzrev&lt;/a&gt;. We are grateful for their many contributions.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is under MIT License.&lt;/p&gt;</summary>
  </entry>
</feed>