<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-22T01:28:40Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>apankrat/nullboard</title>
    <updated>2024-12-22T01:28:40Z</updated>
    <id>tag:github.com,2024-12-22:/apankrat/nullboard</id>
    <link href="https://github.com/apankrat/nullboard" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Nullboard is a minimalist kanban board, focused on compactness and readability.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Nullboard&lt;/h1&gt; &#xA;&lt;p&gt;Nullboard is a minimalist take on a kanban board / a task list manager, designed to be compact, readable and quick in use.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://nullboard.io/preview&#34;&gt;https://nullboard.io/preview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-example-alt.png&#34; alt=&#34;Nullboard&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The name also happens to abbreviate to &lt;a href=&#34;https://en.wikipedia.org/wiki/Nota_bene&#34;&gt;NB&lt;/a&gt;, which I think is a nice touch.&lt;/p&gt; &#xA;&lt;h2&gt;Dead simple&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Single-page web app - just one HTML file, an ancient jQuery package and a webfont pack.&lt;/li&gt; &#xA; &lt;li&gt;Can be used completely offline. In fact, it&#39;s written exactly with this use in mind.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Locally stored&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All data is stored locally, for now using &lt;a href=&#34;https://developer.mozilla.org/en/docs/Web/API/Window/localStorage&#34;&gt;localStorage&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The data can be exported to- or imported from a plain text file in a simple JSON format.&lt;/li&gt; &#xA; &lt;li&gt;The data can also be automatically backed up to a local disk with the help of: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://nullboard.io/backups&#34;&gt;Nullboard Agent&lt;/a&gt; - a native Windows app&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/justinpchang/nullboard-agent-express&#34;&gt;Nullboard Agent Express Port&lt;/a&gt; - an express.js-based portable app&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/luismedel/nbagent&#34;&gt;nbagent&lt;/a&gt; - a version for Unix systems, in Python&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Beta&lt;/h2&gt; &#xA;&lt;p&gt;Still very much in beta. Caveat emptor and all that.&lt;/p&gt; &#xA;&lt;h2&gt;UI &amp;amp; UX&lt;/h2&gt; &#xA;&lt;p&gt;The whole thing is largely about making it convenient to use.&lt;/p&gt; &#xA;&lt;p&gt;Everything is editable in place, all changes are saved automatically and last 50 revisions are kept for undo/redo:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-inplace-editing.gif&#34; alt=&#34;In-place editing&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;New notes can be quickly added directly where they are needed, e.g. before or after existing notes:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-ctrl-add-note.gif&#34; alt=&#34;Ctrl-add note&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Notes can also be dragged around, including to and from other lists:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-drag-n-drop.gif&#34; alt=&#34;Drag-n-drop&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Nearly all controls are hidden by default to reduce visual clutter to its minimum:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-hidden-controls.gif&#34; alt=&#34;Hidden controls&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Longer notes can be collapsed to show just the first line, for even more compact view of the board:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-collapsed-notes.gif&#34; alt=&#34;Collapsed notes&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The default font is &lt;a href=&#34;https://tribby.com/fonts/barlow/&#34;&gt;Barlow&lt;/a&gt; - it&#39;s both narrow &lt;em&gt;and&lt;/em&gt; still very legible. Absolutely fantastic design!&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/barlow-specimen.png&#34; alt=&#34;Barlow speciment&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Notes can also be set to look a bit different. This is useful for partitioning lists into sections:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-raw-notes.gif&#34; alt=&#34;Raw notes&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Links starting with https:// and http:// are recognized. They will &#34;pulse&#34; on mouse hover and can be opened via the right-click menu.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-links-on-hover.gif&#34; alt=&#34;Links on hover&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Pressing CapsLock will highlight all links and make them left-clickable.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-links-reveal.gif&#34; alt=&#34;Links reveal&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Lists can be moved around as well, though not as flashy as notes:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-list-swap.gif&#34; alt=&#34;List swapping&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The font can be changed; its size and line height can be adjusted:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-ui-preferences.gif&#34; alt=&#34;Theme and zoom&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The color theme can be inverted:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apankrat/nullboard/master/images/nullboard-dark-theme.gif&#34; alt=&#34;Dark theme&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Also:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for multiple boards with near-instant switching&lt;/li&gt; &#xA; &lt;li&gt;Undo/redo for 50 revisions per board (configurable in the code)&lt;/li&gt; &#xA; &lt;li&gt;Keyboard shortcuts, including Tab&#39;ing through notes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Caveats&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Written for desktop and keyboard/mouse use&lt;/li&gt; &#xA; &lt;li&gt;Essentially untested on mobile devices and against tap/touch input&lt;/li&gt; &#xA; &lt;li&gt;Works in Firefox, tested in Chrome, should work in Safari and may work in Edge (or what it&#39;s called now)&lt;/li&gt; &#xA; &lt;li&gt;Uses localStorage for storing boards/lists/notes, so be careful around &lt;a href=&#34;https://stackoverflow.com/questions/9948284/how-persistent-is-localstorage&#34;&gt;clearing your cache&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You spot a bug, file an issue.&lt;/p&gt; &#xA;&lt;h2&gt;Dockerized version&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/rsoper/nullboard&#34;&gt;this fork&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Nullboard is something that handles ToDo lists in the way that works really well. For &lt;em&gt;me&lt;/em&gt; that is.&lt;/p&gt; &#xA;&lt;p&gt;Tried a lot of options, some were almost &lt;em&gt;it&lt;/em&gt;, but none was 100%.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Trello&lt;/strong&gt; wasn&#39;t bad, but never was comfortable with the idea of storing my data in cloud without any actual need.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Wekan&lt;/strong&gt; looked promising, but ultimately too heavy and had no offline usage support or a local storage option.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Things&lt;/strong&gt; was beautiful, but not the right tool for the job.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Inkscape&lt;/strong&gt; - I kid you not - with a laundry list of text items was actually OK, but didn&#39;t scale well.&lt;/p&gt; &#xA;&lt;p&gt;Ditto for the plain &lt;strong&gt;text files&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Pieces of &lt;strong&gt;paper&lt;/strong&gt; were almost there, but rearranging items can be quite a hassle.&lt;/p&gt; &#xA;&lt;p&gt;So finally got annoyed enough to sit down and write exactly what I wanted.&lt;/p&gt; &#xA;&lt;p&gt;And, voilà, Nullboard came out =&amp;gt; &lt;a href=&#34;https://nullboard.io/preview&#34;&gt;https://nullboard.io/preview&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://opensource.org/licenses/BSD-2-Clause/&#34;&gt;2-clause BSD license&lt;/a&gt; with the &lt;a href=&#34;https://commonsclause.com/&#34;&gt;Commons Clause&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;That is, you can use, change and re-distribute it for as long as you don&#39;t try and sell it.&lt;/p&gt; &#xA;&lt;h2&gt;Updates&lt;/h2&gt; &#xA;&lt;p&gt;Primary feed is through &lt;a href=&#34;https://twitter.com/nullboard&#34;&gt;@nullboard&lt;/a&gt; on Twitter.&lt;/p&gt; &#xA;&lt;p&gt;The changelog is here =&amp;gt; &lt;a href=&#34;https://nullboard.io/changes&#34;&gt;https://nullboard.io/changes&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Genesis-Embodied-AI/Genesis</title>
    <updated>2024-12-22T01:28:40Z</updated>
    <id>tag:github.com,2024-12-22:/Genesis-Embodied-AI/Genesis</id>
    <link href="https://github.com/Genesis-Embodied-AI/Genesis" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A generative world for general-purpose robotics &amp; embodied AI learning.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/Genesis-Embodied-AI/Genesis/main/imgs/big_text.png&#34; alt=&#34;Genesis&#34; width=&#34;85%&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/Genesis-Embodied-AI/Genesis/main/imgs/teaser.png&#34; width=&#34;100%&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;left&#34;&gt; &#xA; &lt;a href=&#34;https://pypi.org/project/genesis-world/&#34;&gt; &lt;img alt=&#34;PyPI - Version&#34; src=&#34;https://img.shields.io/pypi/v/genesis-world&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://pypi.org/project/genesis-world/&#34;&gt; &lt;img alt=&#34;PyPI - Downloads&#34; src=&#34;https://img.shields.io/pypi/dm/genesis-world&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://github.com/Genesis-Embodied-AI/Genesis/issues&#34;&gt; &lt;img alt=&#34;GitHub Issues&#34; src=&#34;https://img.shields.io/github/issues/Genesis-Embodied-AI/Genesis&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://github.com/Genesis-Embodied-AI/Genesis/discussions&#34;&gt; &lt;img alt=&#34;GitHub Discussions&#34; src=&#34;https://img.shields.io/github/discussions/Genesis-Embodied-AI/Genesis&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Genesis-Embodied-AI/Genesis/main/README.md&#34;&gt;&lt;img alt=&#34;README in English&#34; src=&#34;https://img.shields.io/badge/English-d9d9d9&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Genesis-Embodied-AI/Genesis/main/README_CN.md&#34;&gt;&lt;img alt=&#34;简体中文版自述文件&#34; src=&#34;https://img.shields.io/badge/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87-d9d9d9&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h1&gt;What is Genesis?&lt;/h1&gt; &#xA;&lt;p&gt;Genesis is a physics platform designed for general purpose &lt;em&gt;Robotics/Embodied AI/Physical AI&lt;/em&gt; applications. It is simultaneously multiple things:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;A &lt;strong&gt;universal physics engine&lt;/strong&gt; re-built from the ground up, capable of simulating a wide range of materials and physical phenomena.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;strong&gt;lightweight&lt;/strong&gt;, &lt;strong&gt;ultra-fast&lt;/strong&gt;, &lt;strong&gt;pythonic&lt;/strong&gt;, and &lt;strong&gt;user-friendly&lt;/strong&gt; robotics simulation platform.&lt;/li&gt; &#xA; &lt;li&gt;A powerful and fast &lt;strong&gt;photo-realistic rendering system&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;A &lt;strong&gt;generative data engine&lt;/strong&gt; that transforms user-prompted natural language description into various modalities of data.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Powered by a universal physics engine re-designed and re-built from the ground up, Genesis integrates various physics solvers and their coupling into a unified framework. This core physics engine is further enhanced by a generative agent framework that operates at an upper level, aiming towards fully &lt;strong&gt;automated data generation&lt;/strong&gt; for robotics and beyond.&lt;/p&gt; &#xA;&lt;p&gt;Currently, we are open-sourcing the &lt;strong&gt;underlying physics engine and the simulation platform&lt;/strong&gt;. Our generative framework is a modular system that incorporates many different generative modules, each handling a certain range of data modalities, routed by a high level agent. Some of the modules integrated existing papers and some are still under submission. Access to our generative feature will be gradually rolled out in the near future. If you are interested, feel free to explore more the &lt;a href=&#34;https://raw.githubusercontent.com/Genesis-Embodied-AI/Genesis/main/#papers-behind-genesis&#34;&gt;paper list&lt;/a&gt; below.&lt;/p&gt; &#xA;&lt;p&gt;Genesis is built and will continuously evolve with the following &lt;em&gt;&lt;strong&gt;long-term missions&lt;/strong&gt;&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lowering the barrier&lt;/strong&gt; to using physics simulations and making robotics research accessible to everyone. (See our &lt;a href=&#34;https://genesis-world.readthedocs.io/en/latest/user_guide/overview/mission.html&#34;&gt;commitment&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Unifying a wide spectrum of state-of-the-art physics solvers&lt;/strong&gt; into a single framework, allowing re-creating the whole physical world in a virtual realm with the highest possible physical, visual and sensory fidelity, using the most advanced simulation techniques.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Minimizing human effort&lt;/strong&gt; in collecting and generating data for robotics and other domains, letting the data flywheel spin on its own.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Project Page: &lt;a href=&#34;https://genesis-embodied-ai.github.io/&#34;&gt;https://genesis-embodied-ai.github.io/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Key Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Speed&lt;/strong&gt;: Genesis delivers an unprecedented simulation speed -- over 43 million FPS when simulating a Franka robotic arm with a single RTX 4090 (430,000 times faster than real-time).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Cross-platform&lt;/strong&gt;: Genesis runs natively across different systems (Linux, MacOS, Windows), and across different compute backend (CPU, Nvidia GPU, AMD GPU, Apple Metal).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Unification of various physics solvers&lt;/strong&gt;: Genesis develops a unified simulation framework that integrates various physics solvers: Rigid body, MPM, SPH, FEM, PBD, Stable Fluid.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Support a wide range of material models&lt;/strong&gt;: Genesis supports simulation (and the coupling) of rigid and articulated bodies, various types of liquids, gaseous phenomenon, deformable objects, thin-shell objects and granular materials.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Support for a wide range of robots&lt;/strong&gt;: Robot arm, legged robot, drone, &lt;em&gt;soft robot&lt;/em&gt;, etc., and extensive support for loading different file types: &lt;code&gt;MJCF (.xml)&lt;/code&gt;, &lt;code&gt;URDF&lt;/code&gt;, &lt;code&gt;.obj&lt;/code&gt;, &lt;code&gt;.glb&lt;/code&gt;, &lt;code&gt;.ply&lt;/code&gt;, &lt;code&gt;.stl&lt;/code&gt;, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Photorealistic and high-performance ray-tracer&lt;/strong&gt;: Genesis supports native ray-tracing based rendering.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Differentiability&lt;/strong&gt;: Genesis is designed to be fully compatible with differentiable simulation. Currently, our MPM solver and Tool Solver are differentiable, and differentiability for other solvers will be added soon (starting with rigid-body simulation).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Physics-based Tactile Sensor&lt;/strong&gt;: Genesis involves a physics-based and differentiable &lt;a href=&#34;https://github.com/Genesis-Embodied-AI/DiffTactile&#34;&gt;tactile sensor simulation module&lt;/a&gt;. This will be integrated to the public version soon (expected in version 0.3.0).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;User-friendliness&lt;/strong&gt;: Genesis is designed in a way to make using simulation as simple as possible. From installation to API design, if there&#39;s anything you found counter-intuitive or difficult to use, please &lt;a href=&#34;https://github.com/Genesis-Embodied-AI/Genesis/issues&#34;&gt;let us know&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Quick Installation&lt;/h3&gt; &#xA;&lt;p&gt;Genesis is available via PyPI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install genesis-world  # Requires Python &amp;gt;=3.9;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You also need to install &lt;strong&gt;PyTorch&lt;/strong&gt; following the &lt;a href=&#34;https://pytorch.org/get-started/locally/&#34;&gt;official instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you would like to try out the latest version, we suggest you to git clone from the repo and do &lt;code&gt;pip install -e .&lt;/code&gt; instead of via PyPI.&lt;/p&gt; &#xA;&lt;h3&gt;Documentation&lt;/h3&gt; &#xA;&lt;p&gt;Please refer to our &lt;a href=&#34;https://genesis-world.readthedocs.io/en/latest/user_guide/index.html&#34;&gt;documentation site (English)&lt;/a&gt; / &lt;a href=&#34;https://genesis-world.readthedocs.io/zh-cn/latest/user_guide/index.html&#34;&gt;(Chinese)&lt;/a&gt; for detailed installation steps, tutorials and API references.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing to Genesis&lt;/h2&gt; &#xA;&lt;p&gt;The goal of the Genesis project is to build a fully transparent, user-friendly ecosystem where contributors from both robotics and computer graphics can &lt;strong&gt;come together to collaboratively create a high-efficiency, realistic (both physically and visually) virtual world for robotics research and beyond&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We sincerely welcome &lt;em&gt;any forms of contributions&lt;/em&gt; from the community to make the world a better place for robots. From &lt;strong&gt;pull requests&lt;/strong&gt; for new features, &lt;strong&gt;bug reports&lt;/strong&gt;, to even tiny &lt;strong&gt;suggestions&lt;/strong&gt; that will make Genesis API more intuitive, all are wholeheartedly appreciated!&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Please use Github &lt;a href=&#34;https://github.com/Genesis-Embodied-AI/Genesis/issues&#34;&gt;Issues&lt;/a&gt; for bug reports and feature requests.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Please use GitHub &lt;a href=&#34;https://github.com/Genesis-Embodied-AI/Genesis/discussions&#34;&gt;Discussions&lt;/a&gt; for discussing ideas, and asking questions.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License and Acknowledgment&lt;/h2&gt; &#xA;&lt;p&gt;The Genesis source code is licensed under Apache 2.0. The development of Genesis won&#39;t be possible without these amazing open-source projects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichi&#34;&gt;Taichi&lt;/a&gt;: for providing a high-performance cross-platform compute backend. Kudos to all the members providing technical support from taichi!&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/zhouxian/FluidLab&#34;&gt;FluidLab&lt;/a&gt; for providing a reference MPM solver implementation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/erizmr/SPH_Taichi&#34;&gt;SPH_Taichi&lt;/a&gt; for providing a reference SPH solver implementation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://matthias-research.github.io/pages/tenMinutePhysics/index.html&#34;&gt;Ten Minute Physics&lt;/a&gt; and &lt;a href=&#34;https://github.com/WASD4959/PBF3D&#34;&gt;PBF3D&lt;/a&gt; for providing a reference PBD solver implementation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/google-deepmind/mujoco&#34;&gt;MuJoCo&lt;/a&gt; and &lt;a href=&#34;https://github.com/google/brax&#34;&gt;Brax&lt;/a&gt; for providing reference for rigid body dynamics&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/danfis/libccd&#34;&gt;libccd&lt;/a&gt; for providing reference for collision detection&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mmatl/pyrender&#34;&gt;PyRender&lt;/a&gt; for rasterization-based renderer&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/LuisaGroup/LuisaCompute&#34;&gt;LuisaCompute&lt;/a&gt; and &lt;a href=&#34;https://github.com/LuisaGroup/LuisaRender&#34;&gt;LuisaRender&lt;/a&gt; for its ray-tracing DSL&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mikedh/trimesh&#34;&gt;trimesh&lt;/a&gt;, &lt;a href=&#34;https://github.com/cnr-isti-vclab/PyMeshLab&#34;&gt;PyMeshLab&lt;/a&gt; and &lt;a href=&#34;https://github.com/SarahWeiii/CoACD&#34;&gt;CoACD&lt;/a&gt; for geometry processing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Papers behind Genesis&lt;/h2&gt; &#xA;&lt;p&gt;Genesis is a large scale effort that integrates state-of-the-art technologies of various existing and on-going research work into a single system. Here we include a non-exhaustive list of all the papers that contributed to the Genesis project in one way or another:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Xian, Zhou, et al. &#34;Fluidlab: A differentiable environment for benchmarking complex fluid manipulation.&#34; arXiv preprint arXiv:2303.02346 (2023).&lt;/li&gt; &#xA; &lt;li&gt;Xu, Zhenjia, et al. &#34;Roboninja: Learning an adaptive cutting policy for multi-material objects.&#34; arXiv preprint arXiv:2302.11553 (2023).&lt;/li&gt; &#xA; &lt;li&gt;Wang, Yufei, et al. &#34;Robogen: Towards unleashing infinite data for automated robot learning via generative simulation.&#34; arXiv preprint arXiv:2311.01455 (2023).&lt;/li&gt; &#xA; &lt;li&gt;Wang, Tsun-Hsuan, et al. &#34;Softzoo: A soft robot co-design benchmark for locomotion in diverse environments.&#34; arXiv preprint arXiv:2303.09555 (2023).&lt;/li&gt; &#xA; &lt;li&gt;Wang, Tsun-Hsuan Johnson, et al. &#34;Diffusebot: Breeding soft robots with physics-augmented generative diffusion models.&#34; Advances in Neural Information Processing Systems 36 (2023): 44398-44423.&lt;/li&gt; &#xA; &lt;li&gt;Katara, Pushkal, Zhou Xian, and Katerina Fragkiadaki. &#34;Gen2sim: Scaling up robot learning in simulation with generative models.&#34; 2024 IEEE International Conference on Robotics and Automation (ICRA). IEEE, 2024.&lt;/li&gt; &#xA; &lt;li&gt;Si, Zilin, et al. &#34;DiffTactile: A Physics-based Differentiable Tactile Simulator for Contact-rich Robotic Manipulation.&#34; arXiv preprint arXiv:2403.08716 (2024).&lt;/li&gt; &#xA; &lt;li&gt;Wang, Yian, et al. &#34;Thin-Shell Object Manipulations With Differentiable Physics Simulations.&#34; arXiv preprint arXiv:2404.00451 (2024).&lt;/li&gt; &#xA; &lt;li&gt;Lin, Chunru, et al. &#34;UBSoft: A Simulation Platform for Robotic Skill Learning in Unbounded Soft Environments.&#34; arXiv preprint arXiv:2411.12711 (2024).&lt;/li&gt; &#xA; &lt;li&gt;Zhou, Wenyang, et al. &#34;EMDM: Efficient motion diffusion model for fast and high-quality motion generation.&#34; European Conference on Computer Vision. Springer, Cham, 2025.&lt;/li&gt; &#xA; &lt;li&gt;Qiao, Yi-Ling, Junbang Liang, Vladlen Koltun, and Ming C. Lin. &#34;Scalable differentiable physics for learning and control.&#34; International Conference on Machine Learning. PMLR, 2020.&lt;/li&gt; &#xA; &lt;li&gt;Qiao, Yi-Ling, Junbang Liang, Vladlen Koltun, and Ming C. Lin. &#34;Efficient differentiable simulation of articulated bodies.&#34; In International Conference on Machine Learning, PMLR, 2021.&lt;/li&gt; &#xA; &lt;li&gt;Qiao, Yi-Ling, Junbang Liang, Vladlen Koltun, and Ming Lin. &#34;Differentiable simulation of soft multi-body systems.&#34; Advances in Neural Information Processing Systems 34 (2021).&lt;/li&gt; &#xA; &lt;li&gt;Wan, Weilin, et al. &#34;Tlcontrol: Trajectory and language control for human motion synthesis.&#34; arXiv preprint arXiv:2311.17135 (2023).&lt;/li&gt; &#xA; &lt;li&gt;Wang, Yian, et al. &#34;Architect: Generating Vivid and Interactive 3D Scenes with Hierarchical 2D Inpainting.&#34; arXiv preprint arXiv:2411.09823 (2024).&lt;/li&gt; &#xA; &lt;li&gt;Zheng, Shaokun, et al. &#34;LuisaRender: A high-performance rendering framework with layered and unified interfaces on stream architectures.&#34; ACM Transactions on Graphics (TOG) 41.6 (2022): 1-19.&lt;/li&gt; &#xA; &lt;li&gt;Fan, Yingruo, et al. &#34;Faceformer: Speech-driven 3d facial animation with transformers.&#34; Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2022.&lt;/li&gt; &#xA; &lt;li&gt;Wu, Sichun, Kazi Injamamul Haque, and Zerrin Yumak. &#34;ProbTalk3D: Non-Deterministic Emotion Controllable Speech-Driven 3D Facial Animation Synthesis Using VQ-VAE.&#34; Proceedings of the 17th ACM SIGGRAPH Conference on Motion, Interaction, and Games. 2024.&lt;/li&gt; &#xA; &lt;li&gt;Dou, Zhiyang, et al. &#34;C· ase: Learning conditional adversarial skill embeddings for physics-based characters.&#34; SIGGRAPH Asia 2023 Conference Papers. 2023.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;... and many more on-going work.&lt;/p&gt; &#xA;&lt;h2&gt;Citation&lt;/h2&gt; &#xA;&lt;p&gt;If you used Genesis in your research, we would appreciate it if you could cite it. We are still working on a technical report, and before it&#39;s public, you could consider citing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@software{Genesis,&#xA;  author = {Genesis Authors},&#xA;  title = {Genesis: A Universal and Generative Physics Engine for Robotics and Beyond},&#xA;  month = {December},&#xA;  year = {2024},&#xA;  url = {https://github.com/Genesis-Embodied-AI/Genesis}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>nicbarker/clay</title>
    <updated>2024-12-22T01:28:40Z</updated>
    <id>tag:github.com,2024-12-22:/nicbarker/clay</id>
    <link href="https://github.com/nicbarker/clay" rel="alternate"></link>
    <summary type="html">&lt;p&gt;High performance UI layout library in C.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Clay&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Clay&lt;/em&gt;&lt;/strong&gt; (short for &lt;strong&gt;C Layout&lt;/strong&gt;) is a high performance 2D UI layout library.&lt;/p&gt; &#xA;&lt;h3&gt;Major Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Microsecond layout performance&lt;/li&gt; &#xA; &lt;li&gt;Flex-box like layout model for complex, responsive layouts including text wrapping, scrolling containers and aspect ratio scaling&lt;/li&gt; &#xA; &lt;li&gt;Single ~2k LOC &lt;strong&gt;clay.h&lt;/strong&gt; file with &lt;strong&gt;zero&lt;/strong&gt; dependencies (including no standard library)&lt;/li&gt; &#xA; &lt;li&gt;Wasm support: compile with clang to a 15kb uncompressed &lt;strong&gt;.wasm&lt;/strong&gt; file for use in the browser&lt;/li&gt; &#xA; &lt;li&gt;Static arena based memory use with no malloc / free, and low total memory overhead (e.g. ~3.5mb for 8192 layout elements).&lt;/li&gt; &#xA; &lt;li&gt;React-like nested declarative syntax&lt;/li&gt; &#xA; &lt;li&gt;Renderer agnostic: outputs a sorted list of rendering primitives that can be easily composited in any 3D engine, and even compiled to HTML (examples provided)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Take a look at the &lt;a href=&#34;https://nicbarker.com/clay&#34;&gt;clay website&lt;/a&gt; for an example of clay compiled to wasm and running in the browser, or others in the &lt;a href=&#34;https://github.com/nicbarker/clay/tree/main/examples&#34;&gt;examples directory&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;img width=&#34;1394&#34; alt=&#34;A screenshot of a code IDE with lots of visual and textual elements&#34; src=&#34;https://github.com/user-attachments/assets/9986149a-ee0f-449a-a83e-64a392267e3d&#34;&gt; &#xA;&lt;p&gt;&lt;em&gt;An example GUI application built with clay&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download or clone clay.h and include it after defining &lt;code&gt;CLAY_IMPLEMENTATION&lt;/code&gt; in one file.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Must be defined in one file, _before_ #include &#34;clay.h&#34;&#xA;#define CLAY_IMPLEMENTATION&#xA;#include &#34;clay.h&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Ask clay for how much static memory it needs using &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_minmemorysize&#34;&gt;Clay_MinMemorySize()&lt;/a&gt;, create an Arena for it to use with &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_createarenawithcapacityandmemory&#34;&gt;Clay_CreateArenaWithCapacityAndMemory(size, void *memory)&lt;/a&gt;, and initialize it with &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_initialize&#34;&gt;Clay_Initialize(arena, dimensions)&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Note: malloc is only used here as an example, any allocator that provides&#xA;// a pointer to addressable memory of at least totalMemorySize will work&#xA;uint64_t totalMemorySize = Clay_MinMemorySize();&#xA;Clay_Arena arena = Clay_CreateArenaWithCapacityAndMemory(totalMemorySize, malloc(totalMemorySize));&#xA;Clay_Initialize(arena, (Clay_Dimensions) { screenWidth, screenHeight });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Provide a &lt;code&gt;MeasureText(text, config)&lt;/code&gt; function pointer with &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_setmeasuretextfunction&#34;&gt;Clay_SetMeasureTextFunction(function)&lt;/a&gt; so that clay can measure and wrap text.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Example measure text function&#xA;static inline Clay_Dimensions MeasureText(Clay_String *text, Clay_TextElementConfig *config) {&#xA;    // Clay_TextElementConfig contains members such as fontId, fontSize, letterSpacing etc&#xA;    // Note: Clay_String-&amp;gt;chars is not guaranteed to be null terminated&#xA;}&#xA;&#xA;// Tell clay how to measure text&#xA;Clay_SetMeasureTextFunction(MeasureText);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Optional&lt;/strong&gt; - Call &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_setlayoutdimensions&#34;&gt;Clay_SetLayoutDimensions(dimensions)&lt;/a&gt; if the window size of your application has changed.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Update internal layout dimensions&#xA;Clay_SetLayoutDimensions((Clay_Dimensions) { screenWidth, screenHeight });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Optional&lt;/strong&gt; - Call &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_setpointerstate&#34;&gt;Clay_SetPointerState(pointerPosition, isPointerDown)&lt;/a&gt; if you want to use mouse interactions.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Update internal pointer position for handling mouseover / click / touch events&#xA;Clay_SetPointerState((Clay_Vector2) { mousePositionX, mousePositionY }, isMouseDown);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Optional&lt;/strong&gt; - Call &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_updatescrollcontainers&#34;&gt;Clay_UpdateScrollContainers(enableDragScrolling, scrollDelta, deltaTime)&lt;/a&gt; if you want to use clay&#39;s built in scrolling containers.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Update internal pointer position for handling mouseover / click / touch events&#xA;Clay_UpdateScrollContainers(true, (Clay_Vector2) { mouseWheelX, mouseWheelY }, deltaTime);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;7&#34;&gt; &#xA; &lt;li&gt;Call &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_beginlayout&#34;&gt;Clay_BeginLayout()&lt;/a&gt; and declare your layout using the provided macros.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;const Clay_Color COLOR_LIGHT = (Clay_Color) {224, 215, 210, 255};&#xA;const Clay_Color COLOR_RED = (Clay_Color) {168, 66, 28, 255};&#xA;const Clay_Color COLOR_ORANGE = (Clay_Color) {225, 138, 50, 255};&#xA;&#xA;// Layout config is just a struct that can be declared statically, or inline&#xA;Clay_LayoutConfig sidebarItemLayout = (Clay_LayoutConfig) {&#xA;    .sizing = { .width = CLAY_SIZING_GROW(), .height = CLAY_SIZING_FIXED(50) },&#xA;};&#xA;&#xA;// Re-useable components are just normal functions&#xA;void SidebarItemComponent() {&#xA;    CLAY(CLAY_LAYOUT(sidebarItemLayout), CLAY_RECTANGLE({ .color = COLOR_ORANGE })) {}&#xA;}&#xA;&#xA;// An example function to begin the &#34;root&#34; of your layout tree&#xA;Clay_RenderCommandArray CreateLayout() {&#xA;    Clay_BeginLayout();&#xA;&#xA;    // An example of laying out a UI with a fixed width sidebar and flexible width main content&#xA;    CLAY(CLAY_ID(&#34;OuterContainer&#34;), CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(), CLAY_SIZING_GROW()}, .padding = {16, 16}, .childGap = 16 }), CLAY_RECTANGLE({ .color = {250,250,255,255} })) {&#xA;        CLAY(CLAY_ID(&#34;SideBar&#34;),&#xA;            CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM, .sizing = { .width = CLAY_SIZING_FIXED(300), .height = CLAY_SIZING_GROW() }, .padding = {16, 16}, .childGap = 16 }),&#xA;            CLAY_RECTANGLE({ .color = COLOR_LIGHT })&#xA;        ) {&#xA;            CLAY(CLAY_ID(&#34;ProfilePictureOuter&#34;), CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_GROW() }, .padding = {16, 16}, .childGap = 16, .childAlignment = { .y = CLAY_ALIGN_Y_CENTER }), CLAY_RECTANGLE({ .color = COLOR_RED })) {&#xA;                CLAY(CLAY_ID(&#34;ProfilePicture&#34;), CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_FIXED(60), .height = CLAY_SIZING_FIXED(60) }}), CLAY_IMAGE({ .imageData = &amp;amp;profilePicture, .height = 60, .width = 60 })) {}&#xA;                CLAY_TEXT(CLAY_STRING(&#34;Clay - UI Library&#34;), CLAY_TEXT_CONFIG({ .fontSize = 24, .textColor = {255, 255, 255, 255} }));&#xA;            }&#xA;&#xA;            // Standard C code like loops etc work inside components&#xA;            for (int i = 0; i &amp;lt; 5; i++) {&#xA;                SidebarItemComponent();&#xA;            }&#xA;        }&#xA;&#xA;        CLAY(CLAY_ID(&#34;MainContent&#34;), CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_GROW(), .height = CLAY_SIZING_GROW() }}), CLAY_RECTANGLE({ .color = COLOR_LIGHT })) {}&#xA;    }&#xA;    // ...&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;8&#34;&gt; &#xA; &lt;li&gt;Call &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_endlayout&#34;&gt;Clay_EndLayout()&lt;/a&gt; and process the resulting &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_rendercommandarray&#34;&gt;Clay_RenderCommandArray&lt;/a&gt; in your choice of renderer.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;Clay_RenderCommandArray renderCommands = Clay_EndLayout();&#xA;&#xA;for (int i = 0; i &amp;lt; renderCommands.length; i++) {&#xA;    Clay_RenderCommand *renderCommand = &amp;amp;renderCommands.internalArray[i];&#xA;    &#xA;    switch (renderCommand-&amp;gt;commandType) {&#xA;        case CLAY_RENDER_COMMAND_TYPE_RECTANGLE: {&#xA;            DrawRectangle(&#xA;                renderCommand-&amp;gt;boundingBox,&#xA;                renderCommand-&amp;gt;config.rectangleElementConfig-&amp;gt;color);&#xA;        }&#xA;        // ... Implement handling of other command types&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above example, rendered correctly will look something like the following:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/1928c6d4-ada9-4a4c-a3d1-44fe9b23b3bd&#34; alt=&#34;Clay Example&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In summary, the general order of steps is:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_setlayoutdimensions&#34;&gt;Clay_SetLayoutDimensions(dimensions)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_setpointerstate&#34;&gt;Clay_SetPointerState(pointerPosition, isPointerDown)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_updatescrollcontainers&#34;&gt;Clay_UpdateScrollContainers(enableDragScrolling, scrollDelta, deltaTime)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_beginlayout&#34;&gt;Clay_BeginLayout()&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Declare your layout with the provided &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#element-macros&#34;&gt;Element Macros&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_endlayout&#34;&gt;Clay_EndLayout()&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Render the results using the outputted &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_rendercommandarray&#34;&gt;Clay_RenderCommandArray&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For help starting out or to discuss clay, considering joining &lt;a href=&#34;https://discord.gg/b4FTWkxdvT&#34;&gt;the discord server.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;High Level Documentation&lt;/h2&gt; &#xA;&lt;h3&gt;Building UI Hierarchies&lt;/h3&gt; &#xA;&lt;p&gt;Clay UIs are built using the C macro &lt;code&gt;CLAY()&lt;/code&gt;. This macro creates a new empty element in the UI hierarchy, and supports modular customisation of layout, styling and functionality. The &lt;code&gt;CLAY()&lt;/code&gt; macro can also be &lt;em&gt;nested&lt;/em&gt;, similar to other declarative UI systems like HTML.&lt;/p&gt; &#xA;&lt;p&gt;Child elements are added by opening a block: &lt;code&gt;{}&lt;/code&gt; after calling the &lt;code&gt;CLAY()&lt;/code&gt; macro (exactly like you would with an &lt;code&gt;if&lt;/code&gt; statement or &lt;code&gt;for&lt;/code&gt; loop), and declaring child components inside the braces.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Parent element with 8px of padding&#xA;CLAY(CLAY_LAYOUT({ .padding = 8 })) {&#xA;    // Child element 1&#xA;    CLAY_TEXT(CLAY_STRING(&#34;Hello World&#34;), CLAY_TEXT_CONFIG({ .fontSize = 16 }));&#xA;    // Child element 2 with red background&#xA;    CLAY(CLAY_RECTANGLE({ .color = COLOR_RED })) {&#xA;        // etc&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, unlike HTML and other declarative DSLs, these macros are just C. As a result, you can use arbitrary C code such as loops, functions and conditions inside your layout declaration code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Re-usable &#34;components&#34; are just functions that declare more UI&#xA;void ButtonComponent(Clay_String buttonText) {&#xA;    // Red box button with 8px of padding&#xA;    CLAY(CLAY_LAYOUT({ .padding = { 8, 8 }}), CLAY_RECTANGLE({ .color = COLOR_RED })) {&#xA;        CLAY_TEXT(buttonText, textConfig);&#xA;    }&#xA;}&#xA;&#xA;// Parent element&#xA;CLAY(CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM })) {&#xA;    // Render a bunch of text elements&#xA;    for (int i = 0; i &amp;lt; textArray.length; i++) {&#xA;        CLAY_TEXT(textArray.elements[i], textConfig);&#xA;    }&#xA;    // Only render this element if we&#39;re on a mobile screen&#xA;    if (isMobileScreen) {&#xA;        CLAY() {&#xA;            // etc&#xA;        }&#xA;    }&#xA;    // Re-usable components&#xA;    ButtonComponent(CLAY_STRING(&#34;Click me!&#34;));&#xA;    ButtonComponent(CLAY_STRING(&#34;No, click me!&#34;));&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuring Layout and Styling UI Elements&lt;/h3&gt; &#xA;&lt;p&gt;The layout of clay elements is configured with the &lt;code&gt;CLAY_LAYOUT()&lt;/code&gt; macro.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;CLAY(CLAY_LAYOUT({ .padding = {.x = 8, .y = 8}, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {&#xA;    // Children are 8px inset into parent, and laid out top to bottom&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This macro isn&#39;t magic - all it&#39;s doing is wrapping the standard designated initializer syntax and adding the result to an internal array. e.g. &lt;code&gt;(Clay_LayoutConfig) { .padding = { .x = 8, .y = 8 } ...&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_layout&#34;&gt;Clay_LayoutConfig&lt;/a&gt; API for the full list of options.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;Clay_LayoutConfig&lt;/code&gt; struct can be defined in file scope or elsewhere, and reused.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Define a style in the global / file scope&#xA;Clay_LayoutConfig reusableStyle = (Clay_LayoutConfig) { .backgroundColor = {120, 120, 120, 255} };&#xA;&#xA;CLAY(CLAY_LAYOUT(reusableStyle)) {&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Element IDs&lt;/h3&gt; &#xA;&lt;p&gt;Clay elements can optionally be tagged with a unique identifier using &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_id&#34;&gt;CLAY_ID()&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Will always produce the same ID from the same input string&#xA;CLAY(CLAY_ID(&#34;OuterContainer&#34;), style) {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Element IDs have two main use cases. Firstly, tagging an element with an ID allows you to query information about the element later, such as its &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_pointerover&#34;&gt;mouseover state&lt;/a&gt; or dimensions.&lt;/p&gt; &#xA;&lt;p&gt;Secondly, IDs are visually useful when attempting to read and modify UI code, as well as when using the built-in &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#debug-tools&#34;&gt;debug tools&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To avoid having to construct dynamic strings at runtime to differentiate ids in loops, clay provides the &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_idi&#34;&gt;CLAY_IDI(string, index)&lt;/a&gt; macro to generate different ids from a single input string. Think of IDI as &#34;&lt;strong&gt;ID&lt;/strong&gt; + &lt;strong&gt;I&lt;/strong&gt;ndex&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// This is the equivalent of calling CLAY_ID(&#34;Item0&#34;), CLAY_ID(&#34;Item1&#34;) etc&#xA;for (int index = 0; index &amp;lt; items.length; index++) {&#xA;    CLAY(CLAY_IDI(&#34;Item&#34;, index)) {}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This ID (or, if not provided, an auto generated ID) will be forwarded to the final &lt;code&gt;Clay_RenderCommandArray&lt;/code&gt; for use in retained mode UIs. Using duplicate IDs may cause some functionality to misbehave (i.e. if you&#39;re trying to attach a floating container to a specific element with ID that is duplicated, it may not attach to the one you expect)&lt;/p&gt; &#xA;&lt;h3&gt;Mouse, Touch and Pointer Interactions&lt;/h3&gt; &#xA;&lt;p&gt;Clay provides several functions for handling mouse and pointer interactions.&lt;/p&gt; &#xA;&lt;p&gt;All pointer interactions depend on the function &lt;code&gt;void Clay_SetPointerState(Clay_Vector2 position)&lt;/code&gt; being called after each mouse position update and before any other clay functions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;During UI declaration&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The function &lt;code&gt;bool Clay_Hovered()&lt;/code&gt; can be called during element construction or in the body of an element, and returns &lt;code&gt;true&lt;/code&gt; if the mouse / pointer is over the currently open element.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// An orange button that turns blue when hovered&#xA;CLAY(CLAY_RECTANGLE(.color = Clay_Hovered() ? COLOR_BLUE : COLOR_ORANGE)) {&#xA;    bool buttonHovered = Clay_Hovered();&#xA;    CLAY_TEXT(buttonHovered ? CLAY_STRING(&#34;Hovered&#34;) : CLAY_STRING(&#34;Hover me!&#34;), headerTextConfig);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function &lt;code&gt;void Clay_OnHover()&lt;/code&gt; allows you to attach a function pointer to the currently open element, which will be called if the mouse / pointer is over the element.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void HandleButtonInteraction(Clay_ElementId elementId, Clay_PointerData pointerInfo, intptr_t userData) {&#xA;    ButtonData *buttonData = (ButtonData *)userData;&#xA;    // Pointer state allows you to detect mouse down / hold / release&#xA;    if (pointerInfo.state == CLAY_POINTER_DATA_PRESSED_THIS_FRAME) {&#xA;        // Do some click handling&#xA;        NavigateTo(buttonData-&amp;gt;link);&#xA;    }&#xA;}&#xA;&#xA;ButtonData linkButton = (ButtonData) { .link = &#34;https://github.com/nicbarker/clay&#34; };&#xA;&#xA;// HandleButtonInteraction will be called for each frame the mouse / pointer / touch is inside the button boundaries&#xA;CLAY(CLAY_LAYOUT({ .padding = { 8, 8 }}), Clay_OnHover(HandleButtonInteraction, &amp;amp;linkButton)) {&#xA;    CLAY_TEXT(CLAY_STRING(&#34;Button&#34;), &amp;amp;headerTextConfig);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Before / After UI declaration&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you want to query mouse / pointer overlaps outside layout declarations, you can use the function &lt;code&gt;bool Clay_PointerOver(Clay_ElementId id)&lt;/code&gt;, which takes an &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#element-ids&#34;&gt;element id&lt;/a&gt; and returns a bool representing whether the current pointer position is within its bounding box.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Reminder: Clay_SetPointerState must be called before functions that rely on pointer position otherwise it will have no effect&#xA;Clay_Vector2 mousePosition = { x, y };&#xA;Clay_SetPointerState(mousePosition);&#xA;// ...&#xA;// If profile picture was clicked&#xA;if (mouseButtonDown(0) &amp;amp;&amp;amp; Clay_PointerOver(Clay_GetElementId(&#34;ProfilePicture&#34;))) {&#xA;    // Handle profile picture clicked&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the bounding box queried by &lt;code&gt;Clay_PointerOver&lt;/code&gt; is from the last frame. This generally shouldn&#39;t make a difference except in the case of animations that move at high speed. If this is an issue for you, performing layout twice per frame with the same data will give you the correct interaction the second time.&lt;/p&gt; &#xA;&lt;h3&gt;Scrolling Elements&lt;/h3&gt; &#xA;&lt;p&gt;Elements are configured as scrollable with the &lt;code&gt;CLAY_SCROLL&lt;/code&gt; macro. To make scroll containers respond to mouse wheel and scroll events, two functions need to be called before &lt;code&gt;BeginLayout()&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;Clay_Vector2 mousePosition = { x, y };&#xA;// Reminder: Clay_SetPointerState must be called before Clay_UpdateScrollContainers otherwise it will have no effect&#xA;Clay_SetPointerState(mousePosition);&#xA;// Clay_UpdateScrollContainers needs to be called before Clay_BeginLayout for the position to avoid a 1 frame delay&#xA;Clay_UpdateScrollContainers(&#xA;    true, // Enable drag scrolling&#xA;    scrollDelta, // Clay_Vector2 scrollwheel / trackpad scroll x and y delta this frame&#xA;    float deltaTime, // Time since last frame in seconds as a float e.g. 8ms is 0.008f&#xA;);&#xA;// ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More specific details can be found in the full &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_scroll&#34;&gt;Scroll API&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Floating Elements (&#34;Absolute&#34; Positioning)&lt;/h3&gt; &#xA;&lt;p&gt;All standard elements in clay are laid out on top of, and &lt;em&gt;within&lt;/em&gt; their parent, positioned according to their parent&#39;s layout rules, and affect the positioning and sizing of siblings.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&#34;Floating&#34;&lt;/strong&gt; is configured with the &lt;code&gt;CLAY_FLOATING()&lt;/code&gt; macro. Floating elements don&#39;t affect the parent they are defined in, or the position of their siblings. They also have a &lt;strong&gt;z-index&lt;/strong&gt;, and as a result can intersect and render over the top of other elements.&lt;/p&gt; &#xA;&lt;p&gt;A classic example use case for floating elements is tooltips and modals.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// The two text elements will be laid out top to bottom, and the floating container&#xA;// will be attached to &#34;Outer&#34;&#xA;CLAY(CLAY_ID(&#34;Outer&#34;), CLAY_LAYOUT({ .layoutDirection = TOP_TO_BOTTOM })) {&#xA;    CLAY_TEXT(CLAY_ID(&#34;Button&#34;), text, &amp;amp;headerTextConfig);&#xA;    CLAY(CLAY_ID(&#34;Tooltip&#34;), CLAY_FLOATING()) {}&#xA;    CLAY_TEXT(CLAY_ID(&#34;Button&#34;), text, &amp;amp;headerTextConfig);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More specific details can be found in the full &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_floating&#34;&gt;Floating API&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Laying Out Your Own Custom Elements&lt;/h3&gt; &#xA;&lt;p&gt;Clay only supports a simple set of UI element primitives, such as rectangles, text and images. Clay provides a singular API for layout out custom elements:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Extend CLAY_CUSTOM_ELEMENT_CONFIG with your custom data&#xA;#define CLAY_EXTEND_CONFIG_CUSTOM struct t_CustomElementData customData;&#xA;// Extensions need to happen _before_ the clay include&#xA;#include &#34;clay.h&#34;&#xA;&#xA;enum CustomElementType {&#xA;    CUSTOM_ELEMENT_TYPE_MODEL,&#xA;    CUSTOM_ELEMENT_TYPE_VIDEO&#xA;};&#xA;&#xA;// A rough example of how you could handle laying out 3d models in your UI&#xA;typedef struct t_CustomElementData {&#xA;    CustomElementType type;&#xA;    union {&#xA;        Model model;&#xA;        Video video;&#xA;        // ...&#xA;    };&#xA;} CustomElementData;&#xA;&#xA;Model myModel = Load3DModel(filePath);&#xA;CustomElement modelElement = (CustomElement) { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel }&#xA;// ...&#xA;CLAY() {&#xA;    // This config is type safe and contains the CustomElementData struct&#xA;    CLAY(CLAY_CUSTOM_ELEMENT({ .customData = { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel } })) {}&#xA;}&#xA;&#xA;// Later during your rendering&#xA;switch (renderCommand-&amp;gt;commandType) {&#xA;    // ...&#xA;    case CLAY_RENDER_COMMAND_TYPE_CUSTOM: {&#xA;        // Your extended struct is passed through&#xA;        CustomElementData *customElement = renderCommand-&amp;gt;config.customElementConfig-&amp;gt;customData;&#xA;        if (!customElement) continue;&#xA;        switch (customElement-&amp;gt;type) {&#xA;            case CUSTOM_ELEMENT_TYPE_MODEL: {&#xA;                // Render your 3d model here&#xA;                break;&#xA;            }&#xA;            case CUSTOM_ELEMENT_TYPE_VIDEO: {&#xA;                // Render your video here&#xA;                break;&#xA;            }&#xA;            // ...&#xA;        }&#xA;        break;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More specific details can be found in the full &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_custom_element&#34;&gt;Custom Element API&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Retained Mode Rendering&lt;/h3&gt; &#xA;&lt;p&gt;Clay was originally designed for &lt;a href=&#34;https://www.youtube.com/watch?v=Z1qyvQsjK5Y&#34;&gt;Immediate Mode&lt;/a&gt; rendering - where the entire UI is redrawn every frame. This may not be possible with your platform, renderer design or performance constraints.&lt;/p&gt; &#xA;&lt;p&gt;There are some general techniques that can be used to integrate clay into a retained mode rendering system:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Clay_RenderCommand&lt;/code&gt; includes the &lt;code&gt;uint32_t id&lt;/code&gt; that was used to declare the element. If unique ids are used, these can be mapped to persistent graphics objects across multiple frames / layouts.&lt;/li&gt; &#xA; &lt;li&gt;Render commands are culled automatically to only currently visible elements, and &lt;code&gt;Clay_RenderCommand&lt;/code&gt; is a small enough struct that you can simply compare the memory of two render commands with matching IDs to determine if the element is &#34;dirty&#34; and needs to be re-rendered or updated.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For a worked example, see the provided &lt;a href=&#34;https://github.com/nicbarker/clay/raw/main/renderers/web/html/clay-html-renderer.html&#34;&gt;HTML renderer&lt;/a&gt;. This renderer converts clay layouts into persistent HTML documents with minimal changes per frame.&lt;/p&gt; &#xA;&lt;h3&gt;Visibility Culling&lt;/h3&gt; &#xA;&lt;p&gt;Clay provides a built-in visibility-culling mechanism that is &lt;strong&gt;enabled by default&lt;/strong&gt;. It will only output render commands for elements that are visible - that is, &lt;strong&gt;at least one pixel of their bounding box is inside the viewport.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;This culling mechanism can be disabled via the use of the &lt;code&gt;#define CLAY_DISABLE_CULLING&lt;/code&gt; directive. See &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#preprocessor-directives&#34;&gt;Preprocessor Directives&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Preprocessor Directives&lt;/h3&gt; &#xA;&lt;p&gt;Clay supports C preprocessor directives to modulate functionality at compile time. These can be set either in code using &lt;code&gt;#define CLAY_DISABLE_CULLING&lt;/code&gt; or on the command line when compiling using the appropriate compiler specific arguments, e.g. &lt;code&gt;clang -DCLAY_DISABLE_CULLING main.c ...&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The supported directives are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_MAX_ELEMENT_COUNT&lt;/code&gt; - Controls the maximum number of clay elements that memory is pre-allocated for. Defaults to &lt;strong&gt;8192&lt;/strong&gt;, which should be more than enough for the majority of use cases. Napkin math is ~450 bytes of memory overhead per element (8192 elements is ~3.5mb of memory)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_DISABLE_CULLING&lt;/code&gt; - Disables &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#visibility-culling&#34;&gt;Visibility Culling&lt;/a&gt; of render commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_WASM&lt;/code&gt; - Required when targeting Web Assembly.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_OVERFLOW_TRAP&lt;/code&gt; - By default, clay will continue to allow function calls without crashing even when it exhausts all its available pre-allocated memory. This can produce erroneous layout results that are difficult to interpret. If &lt;code&gt;CLAY_OVERFLOW_TRAP&lt;/code&gt; is defined, clay will raise a &lt;code&gt;SIGTRAP&lt;/code&gt; signal that will be caught by your debugger. Relies on &lt;code&gt;signal.h&lt;/code&gt; being available in your environment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_DEBUG&lt;/code&gt; - Used for debugging clay&#39;s internal implementation. Useful if you want to modify or debug clay, or learn how things work. It enables a number of debug features such as preserving source strings for hash IDs to make debugging easier.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_EXTEND_CONFIG_RECTANGLE&lt;/code&gt; - Provide additional struct members to &lt;code&gt;CLAY_RECTANGLE&lt;/code&gt; that will be passed through with output render commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_EXTEND_CONFIG_TEXT&lt;/code&gt; - Provide additional struct members to &lt;code&gt;CLAY_TEXT_CONFIG&lt;/code&gt; that will be passed through with output render commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_EXTEND_CONFIG_IMAGE&lt;/code&gt; - Provide additional struct members to &lt;code&gt;CLAY_IMAGE_CONFIG&lt;/code&gt; that will be passed through with output render commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_EXTEND_CONFIG_CUSTOM&lt;/code&gt; - Provide additional struct members to &lt;code&gt;CLAY_IMAGE_CONFIG&lt;/code&gt; that will be passed through with output render commands.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Bindings for non C&lt;/h3&gt; &#xA;&lt;p&gt;Clay is usable out of the box as a &lt;code&gt;.h&lt;/code&gt; include in both C99 and C++20 with designated initializer support. There are also supported bindings for other languages, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nicbarker/clay/tree/main/bindings/odin&#34;&gt;Odin Bindings&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Unfortunately clay does &lt;strong&gt;not&lt;/strong&gt; support Microsoft C11 or C17 via MSVC at this time.&lt;/p&gt; &#xA;&lt;h3&gt;Debug Tools&lt;/h3&gt; &#xA;&lt;p&gt;Clay includes built-in UI debugging tools, similar to the &#34;inspector&#34; in browsers such as Chrome or Firefox. These tools are included in &lt;code&gt;clay.h&lt;/code&gt;, and work by injecting additional render commands into the output &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_rendercommandarray&#34;&gt;Clay_RenderCommandArray&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As long as the renderer that you&#39;re using works correctly, no additional setup or configuration is required to use the debug tools.&lt;/p&gt; &#xA;&lt;p&gt;To enable the debug tools, use the function &lt;code&gt;Clay_SetDebugModeEnabled(bool enabled)&lt;/code&gt;. This boolean is persistent and does not need to be set every frame.&lt;/p&gt; &#xA;&lt;p&gt;The debug tooling by default will render as a panel to the right side of the screen, compressing your layout by its width. The default width is 400 and is currently configurable via the direct mutation of the internal variable &lt;code&gt;Clay__debugViewWidth&lt;/code&gt;, however this is an internal API and is potentially subject to change.&lt;/p&gt; &#xA;&lt;img width=&#34;1506&#34; alt=&#34;Screenshot 2024-09-12 at 12 54 03 PM&#34; src=&#34;https://github.com/user-attachments/assets/2d122658-3305-4e27-88d6-44f08c0cb4e6&#34;&gt; &#xA;&lt;p&gt;&lt;em&gt;The official Clay website with debug tooling visible&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h1&gt;API&lt;/h1&gt; &#xA;&lt;h3&gt;Naming Conventions&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;&lt;strong&gt;CAPITAL_LETTERS()&lt;/strong&gt;&#34; are used for macros.&lt;/li&gt; &#xA; &lt;li&gt;&#34;&lt;strong&gt;Clay__&lt;/strong&gt;&#34; (&#34;Clay&#34; followed by &lt;strong&gt;double&lt;/strong&gt; underscore) is used for internal functions that are not intended for use and are subject to change.&lt;/li&gt; &#xA; &lt;li&gt;&#34;&lt;strong&gt;Clay_&lt;/strong&gt;&#34; (&#34;Clay&#34; followed by &lt;strong&gt;single&lt;/strong&gt; underscore) is used for external functions that can be called by the user.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Public Functions&lt;/h2&gt; &#xA;&lt;h3&gt;Lifecycle for public functions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;At startup / initialization time, run once&lt;/strong&gt; &lt;code&gt;Clay_MinMemorySize&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_CreateArenaWithCapacityAndMemory&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_SetMeasureTextFunction&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_Initialize&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Each Frame&lt;/strong&gt; &lt;code&gt;Clay_SetLayoutDimensions&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_SetPointerState&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_UpdateScrollContainers&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_BeginLayout&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY() etc...&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Clay_MinMemorySize&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;uint32_t Clay_MinMemorySize()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Returns the minimum amount of memory &lt;strong&gt;in bytes&lt;/strong&gt; that clay needs to accomodate the current &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#preprocessor-directives&#34;&gt;CLAY_MAX_ELEMENT_COUNT&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_CreateArenaWithCapacityAndMemory&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_Arena Clay_CreateArenaWithCapacityAndMemory(uint32_t capacity, void *offset)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Creates a &lt;code&gt;Clay_Arena&lt;/code&gt; struct with the given capacity and base memory pointer, which can be passed to &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_initialize&#34;&gt;Clay_Initialize&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_SetMeasureTextFunction&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;void Clay_SetMeasureTextFunction(Clay_Dimensions (*measureTextFunction)(Clay_String *text, Clay_TextElementConfig *config))&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Takes a pointer to a function that can be used to measure the &lt;code&gt;width, height&lt;/code&gt; dimensions of a string. Used by clay during layout to determine &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_text&#34;&gt;CLAY_TEXT&lt;/a&gt; element sizing and wrapping.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note 1: This string is not guaranteed to be null terminated.&lt;/strong&gt; Clay saves significant performance overhead by using slices when wrapping text instead of having to clone new null terminated strings. If your renderer does not support &lt;strong&gt;ptr, length&lt;/strong&gt; style strings (e.g. Raylib), you will need to clone this to a new C string before rendering.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note 2: It is essential that this function is as fast as possible.&lt;/strong&gt; For text heavy use-cases this function is called many times, and despite the fact that clay caches text measurements internally, it can easily become the dominant overall layout cost if the provided function is slow. &lt;strong&gt;This is on the hot path!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Clay_Initialize&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;void Clay_Initialize(Clay_Arena arena, Clay_Dimensions layoutDimensions)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Initializes the internal memory mapping, and sets the internal dimensions for layout.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_SetLayoutDimensions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;void Clay_SetLayoutDimensions(Clay_Dimensions dimensions)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sets the internal layout dimensions. Cheap enough to be called every frame with your screen dimensions to automatically respond to window resizing, etc.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_SetPointerState&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;void Clay_SetPointerState(Clay_Vector2 position, bool isPointerDown)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sets the internal pointer position and state (i.e. current mouse / touch position) and recalculates overlap info, which is used for mouseover / click calculation (via &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_pointerover&#34;&gt;Clay_PointerOver&lt;/a&gt; and updating scroll containers with &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_updatescrollcontainers&#34;&gt;Clay_UpdateScrollContainers&lt;/a&gt;. &lt;strong&gt;isPointerDown should represent the current state this frame, e.g. it should be &lt;code&gt;true&lt;/code&gt; for the entire duration the left mouse button is held down.&lt;/strong&gt; Clay has internal handling for detecting click / touch start &amp;amp; end.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_UpdateScrollContainers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;void Clay_UpdateScrollContainers(bool enableDragScrolling, Clay_Vector2 scrollDelta, float deltaTime)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This function handles scrolling of containers. It responds to both &lt;code&gt;scrollDelta&lt;/code&gt;, which represents mouse wheel or trackpad scrolling this frame, as well as &#34;touch scrolling&#34; on mobile devices, or &#34;drag scrolling&#34; with a mouse or similar device.&lt;/p&gt; &#xA;&lt;p&gt;Touch / drag scrolling only occurs if the &lt;code&gt;enableDragScrolling&lt;/code&gt; parameter is &lt;code&gt;true&lt;/code&gt;, &lt;strong&gt;and&lt;/strong&gt; &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_setpointerstate&#34;&gt;Clay_SetPointerState&lt;/a&gt; has been called this frame. As a result, you can simply always call it with &lt;code&gt;false&lt;/code&gt; as the first argument if you want to disable touch scrolling.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;deltaTime&lt;/code&gt; is the time &lt;strong&gt;in seconds&lt;/strong&gt; since the last frame (e.g. 0.016 is &lt;strong&gt;16 milliseconds&lt;/strong&gt;), and is used to normalize &amp;amp; smooth scrolling across different refresh rates.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_BeginLayout&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;void Clay_BeginLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Prepares clay to calculate a new layout. Called each frame / layout &lt;strong&gt;before&lt;/strong&gt; any of the &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#element-macros&#34;&gt;Element Macros&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_EndLayout&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_RenderCommandArray Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ends declaration of element macros and calculates the results of the current layout. Renders a &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_rendercommandarray&#34;&gt;Clay_RenderCommandArray&lt;/a&gt; containing the results of the layout calculation.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_Hovered&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;bool Clay_Hovered()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Called &lt;strong&gt;during&lt;/strong&gt; layout declaration, and returns &lt;code&gt;true&lt;/code&gt; if the pointer position previously set with &lt;code&gt;Clay_SetPointerState&lt;/code&gt; is inside the bounding box of the currently open element. Note: this is based on the element&#39;s position from the &lt;strong&gt;last&lt;/strong&gt; frame.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_OnHover&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;void Clay_OnHover(void (*onHoverFunction)(Clay_ElementId elementId, Clay_PointerData pointerData, intptr_t userData), intptr_t userData)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Called &lt;strong&gt;during&lt;/strong&gt; layout declaration, this function allows you to attach a function pointer to the currently open element that will be called once per layout if the pointer position previously set with &lt;code&gt;Clay_SetPointerState&lt;/code&gt; is inside the bounding box of the currently open element. See &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_pointerdata&#34;&gt;Clay_PointerData&lt;/a&gt; for more information on the &lt;code&gt;pointerData&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void HandleButtonInteraction(Clay_ElementId elementId, Clay_PointerData pointerData, intptr_t userData) {&#xA;    ButtonData *buttonData = (ButtonData *)userData;&#xA;    // Pointer state allows you to detect mouse down / hold / release&#xA;    if (pointerData.state == CLAY_POINTER_DATA_PRESSED_THIS_FRAME) {&#xA;        // Do some click handling&#xA;        NavigateTo(buttonData-&amp;gt;link);&#xA;    }&#xA;}&#xA;&#xA;ButtonData linkButton = (ButtonData) { .link = &#34;https://github.com/nicbarker/clay&#34; };&#xA;&#xA;// HandleButtonInteraction will be called for each frame the mouse / pointer / touch is inside the button boundaries&#xA;CLAY(CLAY_LAYOUT({ .padding = { 8, 8 }}), Clay_OnHover(HandleButtonInteraction, &amp;amp;buttonData)) {&#xA;    CLAY_TEXT(CLAY_STRING(&#34;Button&#34;), &amp;amp;headerTextConfig);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Clay_PointerOver&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;bool Clay_PointerOver(Clay_ElementId id)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Returns &lt;code&gt;true&lt;/code&gt; if the pointer position previously set with &lt;code&gt;Clay_SetPointerState&lt;/code&gt; is inside the bounding box of the layout element with the provided &lt;code&gt;id&lt;/code&gt;. Note: this is based on the element&#39;s position from the &lt;strong&gt;last&lt;/strong&gt; frame. If frame-accurate pointer overlap detection is required, perhaps in the case of significant change in UI layout between frames, you can simply run your layout code twice that frame. The second call to &lt;code&gt;Clay_PointerOver&lt;/code&gt; will be frame-accurate.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_GetScrollContainerData&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_ScrollContainerData Clay_GetScrollContainerData(Clay_ElementId id)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Returns &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_scrollcontainerdata&#34;&gt;Clay_ScrollContainerData&lt;/a&gt; for the scroll container matching the provided ID. This function allows imperative manipulation of scroll position, allowing you to build things such as scroll bars, buttons that &#34;jump&#34; to somewhere in a scroll container, etc.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_GetElementId&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_ElementId Clay_GetElementId(Clay_String idString)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Returns a &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_elementid&#34;&gt;Clay_ElementId&lt;/a&gt; for the provided id string, used for querying element info such as mouseover state, scroll container data, etc.&lt;/p&gt; &#xA;&lt;h2&gt;Element Macros&lt;/h2&gt; &#xA;&lt;h3&gt;CLAY()&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY(...configuration) { ...children }&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_BeginLayout()&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY()&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CLAY&lt;/strong&gt; opens a generic empty container, that is configurable and supports nested children.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Define an element with 16px of x and y padding&#xA;CLAY(CLAY_ID(&#34;Outer&#34;), CLAY_LAYOUT({ .padding = {16, 16} })) {&#xA;    // A nested child element&#xA;    CLAY(CLAY_ID(&#34;SideBar&#34;), CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM, .childGap = 16 })) {&#xA;        // Children laid out top to bottom with a 16 px gap between them&#xA;    }&#xA;    // A vertical scrolling container with a colored background&#xA;    CLAY(&#xA;        CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM, .childGap = 16 })&#xA;        CLAY_RECTANGLE({ .color = { 200, 200, 100, 255 }, .cornerRadius = CLAY_CORNER_RADIUS(10) })&#xA;        CLAY_SCROLL({ .vertical = true })&#xA;    ) {&#xA;        // child elements&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CLAY_ID&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY(CLAY_ID(char* idString)) {}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_BeginLayout()&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY(&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY_ID()&lt;/code&gt; -&amp;gt; &lt;code&gt;)&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CLAY_ID()&lt;/strong&gt; is used to generate and attach a &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_elementid&#34;&gt;Clay_ElementId&lt;/a&gt; to a layout element during declaration.&lt;/p&gt; &#xA;&lt;p&gt;To regenerate the same ID outside of layout declaration when using utility functions such as &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_pointerover&#34;&gt;Clay_PointerOver&lt;/a&gt;, use the &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_getelementid&#34;&gt;Clay_GetElementId&lt;/a&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Tag a button with the Id &#34;Button&#34;&#xA;CLAY(&#xA;    CLAY_ID(&#34;Button&#34;),&#xA;    CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM, .sizing = { .width = CLAY_SIZING_GROW() }, .padding = {16, 16}, .childGap = 16) })&#xA;) {&#xA;    // ...children&#xA;}&#xA;&#xA;// Later on outside of layout code&#xA;bool buttonIsHovered = Clay_IsPointerOver(Clay_GetElementId(&#34;Button&#34;));&#xA;if (buttonIsHovered &amp;amp;&amp;amp; leftMouseButtonPressed) {&#xA;    // ... do some click handling&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CLAY_IDI()&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_ElementId CLAY_IDI(char *label, int index)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;An offset version of &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_id&#34;&gt;CLAY_ID&lt;/a&gt;. Generates a &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_elementid&#34;&gt;Clay_ElementId&lt;/a&gt; string id from the provided &lt;code&gt;char *label&lt;/code&gt;, combined with the &lt;code&gt;int index&lt;/code&gt;. Used for generating ids for sequential elements (such as in a &lt;code&gt;for&lt;/code&gt; loop) without having to construct dynamic strings at runtime.&lt;/p&gt; &#xA;&lt;h3&gt;CLAY_LAYOUT&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY(CLAY_LAYOUT(...layout config)) {}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_BeginLayout()&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY(&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY_LAYOUT()&lt;/code&gt; -&amp;gt; &lt;code&gt;)&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CLAY_LAYOUT()&lt;/strong&gt; is used for configuring &lt;em&gt;layout&lt;/em&gt; options (i.e. options that affect the final position and size of an element, its parents, siblings, and children)&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Struct API (Pseudocode)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// CLAY_LAYOUT({ .member = value }) supports these options&#xA;Clay_LayoutConfig {&#xA;    Clay_LayoutDirection layoutDirection = CLAY_LEFT_TO_RIGHT (default) | CLAY_TOP_TO_BOTTOM;&#xA;    Clay_Padding padding {&#xA;        float x; float y; &#xA;    };&#xA;    uint16_t childGap;&#xA;    Clay_ChildAlignment childAlignment {&#xA;        .x = CLAY_ALIGN_X_LEFT (default) | CLAY_ALIGN_X_CENTER | CLAY_ALIGN_X_RIGHT;&#xA;        .y = CLAY_ALIGN_Y_TOP (default) | CLAY_ALIGN_Y_CENTER | CLAY_ALIGN_Y_BOTTOM;&#xA;    };&#xA;    Clay_Sizing sizing { // Recommended to use the provided macros here - see #sizing for more in depth explanation&#xA;        .width = CLAY_SIZING_FIT(float min, float max) (default) | CLAY_SIZING_GROW(float min, float max) | CLAY_SIZING_FIXED(width) | CLAY_SIZING_PERCENT(float percent)&#xA;        .height = CLAY_SIZING_FIT(float min, float max) (default) | CLAY_SIZING_GROW(float min, float max) | CLAY_SIZING_FIXED(height) | CLAY_SIZING_PERCENT(float percent)&#xA;    }; // See CLAY_SIZING_GROW() etc for more details&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with all config macros, &lt;code&gt;CLAY_LAYOUT()&lt;/code&gt; accepts designated initializer syntax and provides default values for any unspecified struct members.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.layoutDirection&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_LayoutDirection&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Controls the axis / direction in which child elements are laid out. Available options are &lt;code&gt;CLAY_LEFT_TO_RIGHT&lt;/code&gt; (default) and &lt;code&gt;CLAY_TOP_TO_BOTTOM&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Did you know that &#34;left to right&#34; and &#34;top to bottom&#34; both have 13 letters?&lt;/em&gt;&lt;/p&gt; &#xA;&lt;img width=&#34;580&#34; alt=&#34;Screenshot 2024-08-22 at 11 10 27 AM&#34; src=&#34;https://github.com/user-attachments/assets/7008aa47-8826-4338-9257-8bc83f7813ce&#34;&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.padding&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Padding&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_LAYOUT({ .padding = { .x = 16, .y = 16 } })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Controls horizontal and vertical white-space &#34;padding&#34; around the &lt;strong&gt;outside&lt;/strong&gt; of child elements.&lt;/p&gt; &#xA;&lt;img width=&#34;486&#34; alt=&#34;Screenshot 2024-08-22 at 10 50 49 AM&#34; src=&#34;https://github.com/user-attachments/assets/9311cf10-b8aa-40fe-922a-5dee3663f1a0&#34;&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.childGap&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;uint16_t&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_LAYOUT({ .childGap = 16 })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Controls the white-space &lt;strong&gt;between&lt;/strong&gt; child elements as they are laid out. When &lt;code&gt;.layoutDirection&lt;/code&gt; is &lt;code&gt;CLAY_LEFT_TO_RIGHT&lt;/code&gt; (default), this will be horizontal space, whereas for &lt;code&gt;CLAY_TOP_TO_BOTTOM&lt;/code&gt; it will be vertical space.&lt;/p&gt; &#xA;&lt;img width=&#34;600&#34; alt=&#34;Screenshot 2024-08-22 at 11 05 15 AM&#34; src=&#34;https://github.com/user-attachments/assets/fa0dae1f-1936-47f6-a299-634bd7d40d58&#34;&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.childAlignment&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_ChildAlignment&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_LAYOUT({ .childAlignment = { .x = CLAY_ALIGN_X_LEFT, .y = CLAY_ALIGN_Y_CENTER } })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Controls the alignment of children relative to the height and width of the parent container. Available options are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;.x = CLAY_ALIGN_X_LEFT (default) | CLAY_ALIGN_X_CENTER | CLAY_ALIGN_X_RIGHT;&#xA;.y = CLAY_ALIGN_Y_TOP (default) | CLAY_ALIGN_Y_CENTER | CLAY_ALIGN_Y_BOTTOM;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img width=&#34;1030&#34; alt=&#34;Screenshot 2024-08-22 at 11 25 16 AM&#34; src=&#34;https://github.com/user-attachments/assets/be61b4a7-db4f-447c-b6d6-b2d4a91fc664&#34;&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.sizing&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Sizing&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_FIXED(300), .height = CLAY_SIZING_PERCENT(0.5) } })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Controls how final width and height of element are calculated. The same configurations are available for both the &lt;code&gt;.width&lt;/code&gt; and &lt;code&gt;.height&lt;/code&gt; axis. There are several options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;CLAY_SIZING_FIT(float min, float max) (default)&lt;/code&gt; - The element will be sized to fit its children (plus padding and gaps), up to &lt;code&gt;max&lt;/code&gt;. If &lt;code&gt;max&lt;/code&gt; is left unspecified, it will default to &lt;code&gt;FLOAT_MAX&lt;/code&gt;. When elements are compressed to fit into a smaller parent, this element will not shrink below &lt;code&gt;min&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;CLAY_SIZING_GROW(float min, float max)&lt;/code&gt; - The element will grow to fill available space in its parent, up to &lt;code&gt;max&lt;/code&gt;. If &lt;code&gt;max&lt;/code&gt; is left unspecified, it will default to &lt;code&gt;FLOAT_MAX&lt;/code&gt;. When elements are compressed to fit into a smaller parent, this element will not shrink below &lt;code&gt;min&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;CLAY_SIZING_FIXED(float fixed)&lt;/code&gt; - The final size will always be exactly the provided &lt;code&gt;fixed&lt;/code&gt; value. Shorthand for &lt;code&gt;CLAY_SIZING_FIT(fixed, fixed)&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;CLAY_SIZING_PERCENT(float percent)&lt;/code&gt; - Final size will be a percentage of parent size, minus padding and child gaps. &lt;code&gt;percent&lt;/code&gt; is assumed to be a float between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img width=&#34;1056&#34; alt=&#34;Screenshot 2024-08-22 at 2 10 33 PM&#34; src=&#34;https://github.com/user-attachments/assets/1236efb1-77dc-44cd-a207-7944e0f5e500&#34;&gt; &#xA;&lt;img width=&#34;1141&#34; alt=&#34;Screenshot 2024-08-22 at 2 19 04 PM&#34; src=&#34;https://github.com/user-attachments/assets/a26074ff-f155-4d35-9ca4-9278a64aac00&#34;&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;CLAY(CLAY_ID(&#34;Button&#34;), CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM, .sizing = { .width = CLAY_SIZING_GROW() }, .padding = {16, 16}, .childGap = 16) }) {&#xA;    // Children will be laid out vertically with 16px of padding around and between&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CLAY_RECTANGLE&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY(CLAY_RECTANGLE(...rectangle config)) {}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_BeginLayout()&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY(&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY_RECTANGLE()&lt;/code&gt; -&amp;gt; &lt;code&gt;)&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;RECTANGLE&lt;/strong&gt; configures a clay element to background-fill its bounding box with a color. It uses &lt;code&gt;Clay_RectangleElementConfig&lt;/code&gt; for rectangle specific options.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Struct API (Pseudocode)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// CLAY_RECTANGLE({ .member = value }) supports these options&#xA;Clay_RectangleElementConfig {&#xA;    Clay_Color color {&#xA;        float r; float g; float b; float a;&#xA;    };&#xA;    float cornerRadius;&#xA;&#xA;    #ifdef CLAY_EXTEND_CONFIG_RECTANGLE&#xA;        // Contents of CLAY_EXTEND_CONFIG_RECTANGLE will be pasted here&#xA;    #endif&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with all config macros, &lt;code&gt;CLAY_RECTANGLE()&lt;/code&gt; accepts designated initializer syntax and provides default values for any unspecified struct members.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Extension&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The underlying &lt;code&gt;Clay_RectangleElementConfig&lt;/code&gt; can be extended with new members by using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define CLAY_EXTEND_CONFIG_RECTANGLE float newField;&#xA;#include &#34;clay.h&#34; // Define your extension before including clay.h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.color&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Color&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_RECTANGLE({ .color = {120, 120, 120, 255} })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Conventionally accepts &lt;code&gt;rgba&lt;/code&gt; float values between 0 and 255, but interpretation is left up to the renderer and does not affect layout.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.cornerRadius&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;float&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_RECTANGLE({ .cornerRadius = { .topLeft = 16, .topRight = 16, .bottomLeft = 16, .bottomRight = 16 })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Defines the radius in pixels for the arc of rectangle corners (&lt;code&gt;0&lt;/code&gt; is square, &lt;code&gt;rectangle.width / 2&lt;/code&gt; is circular).&lt;/p&gt; &#xA;&lt;p&gt;Note that the &lt;code&gt;CLAY_CORNER_RADIUS(radius)&lt;/code&gt; function-like macro is available to provide short hand for setting all four corner radii to the same value. e.g. &lt;code&gt;CLAY_BORDER({ .cornerRadius = CLAY_CORNER_RADIUS(10) })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Rendering&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Element is subject to &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#visibility-culling&#34;&gt;culling&lt;/a&gt;. Otherwise, a single &lt;code&gt;Clay_RenderCommand&lt;/code&gt;s with &lt;code&gt;commandType = CLAY_RENDER_COMMAND_TYPE_RECTANGLE&lt;/code&gt; will be created, with &lt;code&gt;renderCommand-&amp;gt;elementConfig.rectangleElementConfig&lt;/code&gt; containing a pointer to the element&#39;s Clay_RectangleElementConfig.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Declare a reusable rectangle config, with a purple color and 10px rounded corners&#xA;Clay_RectangleElementConfig rectangleConfig = (Clay_RectangleElementConfig) { .color = { 200, 200, 100, 255 }, .cornerRadius = CLAY_CORNER_RADIUS(10) };&#xA;// Declare a rectangle element using a reusable config&#xA;CLAY(CLAY_RECTANGLE(rectangleConfig)) {}&#xA;// Declare a retangle element using an inline config&#xA;CLAY(CLAY_RECTANGLE({ .color = { 200, 200, 100, 255 }, .cornerRadius = CLAY_CORNER_RADIUS(10) })) {&#xA;    // child elements&#xA;}&#xA;// Declare a scrolling container with a colored background&#xA;CLAY(&#xA;    CLAY_RECTANGLE({ .color = { 200, 200, 100, 255 }, .cornerRadius = CLAY_CORNER_RADIUS(10) })&#xA;    CLAY_SCROLL({ .vertical = true })&#xA;) {&#xA;    // child elements&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CLAY_TEXT&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_TEXT(Clay_String textContents, Clay_TextElementConfig *textConfig);&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_BeginLayout()&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY_TEXT()&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;TEXT&lt;/strong&gt; is a measured, auto-wrapped text element. It uses &lt;code&gt;Clay_TextElementConfig&lt;/code&gt; to configure text specific options.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;Clay_TextElementConfig&lt;/code&gt; uses &lt;code&gt;uint32_t fontId&lt;/code&gt;. Font ID to font asset mapping is managed in user code and passed to render commands.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Struct API (Pseudocode)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// CLAY_TEXT(text, CLAY_TEXT_CONFIG({ .member = value })) supports these options&#xA;Clay_TextElementConfig {&#xA;    Clay_Color textColor {&#xA;        float r; float g; float b; float a;&#xA;    };&#xA;    uint16_t fontId;&#xA;    uint16_t fontSize;&#xA;    uint16_t letterSpacing;&#xA;    uint16_t lineHeight;&#xA;    Clay_TextElementConfigWrapMode wrapMode {&#xA;        CLAY_TEXT_WRAP_WORDS (default),&#xA;&#x9;CLAY_TEXT_WRAP_NEWLINES,&#xA;&#x9;CLAY_TEXT_WRAP_NONE,&#xA;    };&#xA;&#xA;    #ifdef CLAY_EXTEND_CONFIG_TEXT&#xA;        // Contents of CLAY_EXTEND_CONFIG_TEXT will be pasted here&#xA;    #endif&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with all config macros, &lt;code&gt;CLAY_TEXT_CONFIG()&lt;/code&gt; accepts designated initializer syntax and provides default values for any unspecified struct members.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Extension&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The underlying &lt;code&gt;Clay_TextElementConfig&lt;/code&gt; can be extended with new members by using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define CLAY_EXTEND_CONFIG_TEXT float newField;&#xA;#include &#34;clay.h&#34; // Define your extension before including clay.h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.textColor&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_TEXT_CONFIG(.textColor = {120, 120, 120, 255})&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Conventionally accepts &lt;code&gt;rgba&lt;/code&gt; float values between 0 and 255, but interpretation is left up to the renderer and does not affect layout.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.fontId&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_TEXT_CONFIG(.fontId = FONT_ID_LATO)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s up to the user to load fonts and create a mapping from &lt;code&gt;fontId&lt;/code&gt; to a font that can be measured and rendered.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.fontSize&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_TEXT_CONFIG(.fontSize = 16)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Font size is generally thought of as &lt;code&gt;x pixels tall&lt;/code&gt;, but interpretation is left up to the user &amp;amp; renderer.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.letterSpacing&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_TEXT_CONFIG(.letterSpacing = 1)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;.letterSpacing&lt;/code&gt; results in &lt;strong&gt;horizontal&lt;/strong&gt; white space between individual rendered characters.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.lineHeight&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_TEXT_CONFIG(.lineHeight = 20)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;.lineHeight&lt;/code&gt; - when non zero - forcibly sets the &lt;code&gt;height&lt;/code&gt; of each wrapped line of text to &lt;code&gt;.lineheight&lt;/code&gt; pixels tall. Will affect the layout of both parents and siblings. A value of &lt;code&gt;0&lt;/code&gt; will use the measured height of the font.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.wrapMode&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_TEXT_CONFIG(.wrapMode = CLAY_TEXT_WRAP_NONE)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;.wrapMode&lt;/code&gt; specifies under what conditions text should &lt;a href=&#34;https://en.wikipedia.org/wiki/Line_wrap_and_word_wrap&#34;&gt;wrap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Available options are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_TEXT_WRAP_WORDS&lt;/code&gt; (default) - Text will wrap on whitespace characters as container width shrinks, preserving whole words.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_TEXT_WRAP_NEWLINES&lt;/code&gt; - will only wrap when encountering newline characters.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_TEXT_WRAP_NONE&lt;/code&gt; - Text will never wrap even if its container is compressed beyond the text measured width.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Define a font somewhere in your code&#xA;const uint32_t FONT_ID_LATO = 3;&#xA;// ..&#xA;CLAY_TEXT(CLAY_STRING(&#34;John Smith&#34;), CLAY_TEXT_CONFIG({ .fontId = FONT_ID_LATO, .fontSize = 24, .textColor = {255, 0, 0, 255} }));&#xA;// Rendering example&#xA;Font fontToUse = LoadedFonts[renderCommand-&amp;gt;elementConfig.textElementConfig-&amp;gt;fontId];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Rendering&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Element is subject to &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#visibility-culling&#34;&gt;culling&lt;/a&gt;. Otherwise, multiple &lt;code&gt;Clay_RenderCommand&lt;/code&gt;s with &lt;code&gt;commandType = CLAY_RENDER_COMMAND_TYPE_TEXT&lt;/code&gt; may be created, one for each wrapped line of text.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_RenderCommand.textContent&lt;/code&gt; will be populated with a &lt;code&gt;Clay_String&lt;/code&gt; &lt;em&gt;slice&lt;/em&gt; of the original string passed in (i.e. wrapping doesn&#39;t reallocate, it just returns a &lt;code&gt;Clay_String&lt;/code&gt; pointing to the start of the new line with a &lt;code&gt;length&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;h3&gt;CLAY_IMAGE&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY(CLAY_IMAGE(...image config)) {}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_BeginLayout()&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY(&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY_IMAGE()&lt;/code&gt; -&amp;gt; &lt;code&gt;)&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;IMAGE&lt;/strong&gt; configures a clay element to render an image as its background. It uses Clay_ImageElementConfig for image specific options.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Struct API (Pseudocode)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;Clay_ImageElementConfig {&#xA;    Clay_Dimensions sourceDimensions {&#xA;        float width; float height; &#xA;    };&#xA;    // --&#xA;    #ifndef CLAY_EXTEND_CONFIG_IMAGE&#xA;        void * imageData; // Note: This field will be replaced if #define CLAY_EXTEND_CONFIG_IMAGE is specified&#xA;    #else CLAY_EXTEND_CONFIG_IMAGE&#xA;        // Contents of CLAY_EXTEND_CONFIG_IMAGE will be pasted here&#xA;    #endif&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with all config macros, &lt;code&gt;CLAY_IMAGE_CONFIG()&lt;/code&gt; accepts designated initializer syntax and provides default values for any unspecified struct members.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Extension&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The underlying &lt;code&gt;Clay_ImageElementConfig&lt;/code&gt; can be extended with new members by using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define CLAY_EXTEND_CONFIG_IMAGE float newField;&#xA;#include &#34;clay.h&#34; // Define your extension before including clay.h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.sourceDimensions&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Dimensions&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_IMAGE_CONFIG(.sourceDimensions = { 1024, 768 })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Used to perform &lt;strong&gt;aspect ratio scaling&lt;/strong&gt; on the image element. As of this version of clay, aspect ratio scaling only applies to the &lt;code&gt;height&lt;/code&gt; of an image (i.e. image height will scale with width growth and limitations, but width will not scale with height growth and limitations)&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.imageData&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;void *&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_IMAGE_CONFIG(.imageData = &amp;amp;myImage)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;.imageData&lt;/code&gt; is a generic void pointer that can be used to pass through image data to the renderer. &lt;strong&gt;Note:&lt;/strong&gt; this field is generally not recommended for usage due to the lack of type safety, see &lt;code&gt;#define CLAY_EXTEND_CONFIG_IMAGE&lt;/code&gt; in &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#preprocessor-directives&#34;&gt;Preprocessor Directives&lt;/a&gt; for an alternative.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Load an image somewhere in your code&#xA;Image profilePicture = LoadImage(&#34;profilePicture.png&#34;);&#xA;// Note that when rendering, .imageData will be void* type.&#xA;CLAY(CLAY_IMAGE({ .imageData = &amp;amp;profilePicture, .sourceDimensions = { 60, 60 } })) {}&#xA;&#xA;// OR ----------------&#xA;&#xA;// Extend CLAY_CUSTOM_IMAGE_CONFIG with your custom image format&#xA;#define CLAY_EXTEND_CONFIG_IMAGE struct t_Image image;&#xA;// Extensions need to happen _before_ the clay include&#xA;#include &#34;clay.h&#34;&#xA;&#xA;typedef struct t_Image {&#xA;    ImageFormat format;&#xA;    u8int_t *internalData;&#xA;    // ... etc&#xA;} Image;&#xA;&#xA;// You can now use CLAY_IMAGE with your custom type and still have type safety &amp;amp; code completion&#xA;CLAY(CLAY_IMAGE({ .image = { .format = IMAGE_FORMAT_RGBA, .internalData = &amp;amp;imageData }, .sourceDimensions = { 60, 60 } })) {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Load an image somewhere in your code&#xA;Image profilePicture = LoadImage(&#34;profilePicture.png&#34;);&#xA;// Declare a reusable image config&#xA;Clay_ImageElementConfig imageConfig = (Clay_ImageElementConfig) { .imageData = &amp;amp;profilePicture, .height = 60, .width = 60 };&#xA;// Declare an image element using a reusable config&#xA;CLAY(CLAY_IMAGE(imageConfig)) {}&#xA;// Declare an image element using an inline config&#xA;CLAY(CLAY_IMAGE({ .imageData = &amp;amp;profilePicture, .height = 60, .width = 60 })) {}&#xA;// Rendering example&#xA;Image *imageToRender = renderCommand-&amp;gt;elementConfig.imageElementConfig-&amp;gt;imageData;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Rendering&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Element is subject to &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#visibility-culling&#34;&gt;culling&lt;/a&gt;. Otherwise, a single &lt;code&gt;Clay_RenderCommand&lt;/code&gt;s with &lt;code&gt;commandType = CLAY_RENDER_COMMAND_TYPE_IMAGE&lt;/code&gt; will be created. The user will need to access &lt;code&gt;renderCommand-&amp;gt;elementConfig.imageElementConfig-&amp;gt;imageData&lt;/code&gt; to retrieve image data referenced during layout creation. It&#39;s also up to the user to decide how / if they wish to blend &lt;code&gt;rectangleElementConfig-&amp;gt;color&lt;/code&gt; with the image.&lt;/p&gt; &#xA;&lt;h3&gt;CLAY_SCROLL&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY(CLAY_SCROLL(...scroll config)) {}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_SetPointerState()&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_UpdateScrollContainers()&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_BeginLayout()&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY(&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY_SCROLL()&lt;/code&gt; -&amp;gt; &lt;code&gt;)&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;SCROLL&lt;/strong&gt; configures the element as a scrolling container, enabling masking of children that extend beyond its boundaries. It uses &lt;code&gt;Clay_ScrollElementConfig&lt;/code&gt; to configure scroll specific options.&lt;/p&gt; &#xA;&lt;p&gt;Note: In order to process scrolling based on pointer position and mouse wheel or touch interactions, you must call &lt;code&gt;Clay_SetPointerState()&lt;/code&gt; and &lt;code&gt;Clay_UpdateScrollContainers()&lt;/code&gt; &lt;em&gt;before&lt;/em&gt; calling &lt;code&gt;BeginLayout&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Struct Definition (Pseudocode)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;Clay_ScrollElementConfig {&#xA;    bool horizontal;&#xA;    bool vertical;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with all config macros, &lt;code&gt;CLAY_SCROLL()&lt;/code&gt; accepts designated initializer syntax and provides default values for any unspecified struct members.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.horizontal&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;bool&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_SCROLL(.horizontal = true)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Enables or disables horizontal scrolling for this container element.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.vertical&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;bool&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_SCROLL(.vertical = true)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Enables or disables vertical scrolling for this container element.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;Rendering&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Enabling scroll for an element will result in two additional render commands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;commandType = CLAY_RENDER_COMMAND_TYPE_SCISSOR_START&lt;/code&gt;, which should create a rectangle mask with its &lt;code&gt;boundingBox&lt;/code&gt; and is &lt;strong&gt;not&lt;/strong&gt; subject to &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#visibility-culling&#34;&gt;culling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;commandType = CLAY_RENDER_COMMAND_TYPE_SCISSOR_END&lt;/code&gt;, which disables the previous rectangle mask and is &lt;strong&gt;not&lt;/strong&gt; subject to &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#visibility-culling&#34;&gt;culling&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;CLAY(CLAY_SCROLL(.vertical = true)) {&#xA;    // Create child content with a fixed height of 5000&#xA;    CLAY(CLAY_ID(&#34;ScrollInner&#34;), CLAY_LAYOUT({ .sizing = { .height = CLAY_SIZING_FIXED(5000) } })) {}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CLAY_BORDER&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY(CLAY_BORDER(...border config)) {}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_BeginLayout()&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY(&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY_BORDER()&lt;/code&gt; -&amp;gt; &lt;code&gt;)&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;BORDER&lt;/strong&gt; adds borders to the edges or between the children of elements. It uses Clay_BorderElementConfig to configure border specific options.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Struct Definition (Pseudocode)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct Clay_BorderElementConfig&#xA;{&#xA;    Clay_Border left {&#xA;        float width;&#xA;        Clay_Color color {&#xA;            float r; float g; float b; float a;&#xA;        };&#xA;    };&#xA;    Clay_Border right // Exactly the same as left&#xA;    Clay_Border top // Exactly the same as left&#xA;    Clay_Border bottom // Exactly the same as left&#xA;    Clay_Border betweenChildren // Exactly the same as left&#xA;    Clay_CornerRadius cornerRadius {&#xA;        float topLeft;&#xA;        float topRight;&#xA;        float bottomLeft;&#xA;        float bottomRight;&#xA;    };&#xA;} Clay_BorderElementConfig;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;As with all config macros, &lt;code&gt;CLAY_BORDER()&lt;/code&gt; accepts designated initializer syntax and provides default values for any unspecified struct members.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.left, .right, .top, .bottom&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Border&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_BORDER({ .left = { 2, COLOR_RED }, .right = { 4, COLOR_YELLOW } /* etc */ })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Indicates to the renderer that a border of &lt;code&gt;.color&lt;/code&gt; should be draw at the specified edges of the bounding box, &lt;strong&gt;overlapping the box contents by &lt;code&gt;.width&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This means that border configuration does not affect layout, as the width of the border doesn&#39;t contribute to the total container width or layout position. Border containers with zero padding will be drawn over the top of child elements.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.betweenChildren&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Border&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_BORDER({ .betweenChildren = { 2, COLOR_RED } })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Configures the width and color of borders to be drawn between children. These borders will be vertical lines if the parent uses &lt;code&gt;.layoutDirection = CLAY_LEFT_TO_RIGHT&lt;/code&gt; and horizontal lines if the parent uses &lt;code&gt;CLAY_TOP_TO_BOTTOM&lt;/code&gt;. Unlike &lt;code&gt;.left, .top&lt;/code&gt; etc, this option &lt;strong&gt;will generate additional rectangle render commands representing the borders between children.&lt;/strong&gt; As a result, the renderer does not need to specifically implement rendering for these border elements.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.cornerRadius&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;float&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_BORDER({ .cornerRadius = 16 })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Defines the radius in pixels for the arc of border corners (&lt;code&gt;0&lt;/code&gt; is square, &lt;code&gt;rectangle.width / 2&lt;/code&gt; is circular). It is up to the renderer to decide how to interpolate between differing border widths and colors across shared corners.&lt;/p&gt; &#xA;&lt;p&gt;Note that the &lt;code&gt;CLAY_CORNER_RADIUS(radius)&lt;/code&gt; function-like macro is available to provide short hand for setting all four corner radii to the same value. e.g. &lt;code&gt;CLAY_BORDER(.cornerRadius = CLAY_CORNER_RADIUS(10))&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Convenience Macros&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are some common cases for border configuration that are repetitive, i.e. specifying the same border around all four edges. Some convenience macros are provided for these cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_BORDER_CONFIG_OUTSIDE({ .width = 2, .color = COLOR_RED })&lt;/code&gt; - Shorthand for configuring all 4 outside borders at once.`&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_BORDER_CONFIG_OUTSIDE_RADIUS(width, color, radius)&lt;/code&gt; - Shorthand for configuring all 4 outside borders at once, with the provided &lt;code&gt;.cornerRadius&lt;/code&gt;. Note this is a function-like macro and does not take &lt;code&gt;.member = value&lt;/code&gt; syntax.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_BORDER_CONFIG_ALL({ .width = 2, .color = COLOR_RED })&lt;/code&gt; - Shorthand for configuring all 4 outside borders and &lt;code&gt;.betweenChildren&lt;/code&gt; at once.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_BORDER_CONFIG_ALL_RADIUS(width, color, radius)&lt;/code&gt; - Shorthand for configuring all 4 outside borders and &lt;code&gt;.betweenChildren&lt;/code&gt; at once, with the provided &lt;code&gt;cornerRadius&lt;/code&gt;. Note this is a function-like macro and does not take &lt;code&gt;.member = value&lt;/code&gt; syntax.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// 300x300 container with a 1px red border around all the edges&#xA;CLAY(&#xA;    CLAY_ID(&#34;OuterBorder&#34;),&#xA;    CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_FIXED(300), .height = CLAY_SIZING_FIXED(300)}),&#xA;    CLAY_BORDER_CONFIG_OUTSIDE({ .color = COLOR_RED, .width = 1 })&#xA;) {&#xA;    // ...&#xA;}&#xA;&#xA;// Container with a 3px yellow bottom border&#xA;CLAY(&#xA;    CLAY_ID(&#34;OuterBorder&#34;),&#xA;    CLAY_BORDER({ .bottom = { .color = COLOR_YELLOW, .width = 3 } })&#xA;) {&#xA;    // ...&#xA;}&#xA;&#xA;// Container with a 5px curved border around the edges, and a 5px blue border between all children laid out top to bottom&#xA;CLAY(&#xA;    CLAY_ID(&#34;OuterBorder&#34;),&#xA;    CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM }),&#xA;    CLAY_BORDER_CONFIG_ALL_RADIUS(5, COLOR_BLUE, 5)&#xA;) {&#xA;    // Child&#xA;    // -- 5px blue border will be here --&#xA;    // Child&#xA;    // -- 5px blue border will be here --&#xA;    // Child&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Rendering&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Element is subject to &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#visibility-culling&#34;&gt;culling&lt;/a&gt;. Otherwise, a single &lt;code&gt;Clay_RenderCommand&lt;/code&gt; with &lt;code&gt;commandType = CLAY_RENDER_COMMAND_TYPE_BORDER&lt;/code&gt; representing the container will be created. Rendering of borders and rounded corners is left up to the user. See the provided &lt;a href=&#34;https://github.com/nicbarker/clay/tree/main/renderers/raylib&#34;&gt;Raylib Renderer&lt;/a&gt; for examples of how to draw borders using line and curve primitives.&lt;/p&gt; &#xA;&lt;h3&gt;CLAY_FLOATING&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY(CLAY_FLOATING(...floating config)) {}&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_BeginLayout()&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY(&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY_FLOATING()&lt;/code&gt; -&amp;gt; &lt;code&gt;)&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;FLOATING&lt;/strong&gt; defines an element that &#34;floats&#34; above other content. Typical use-cases include tooltips and modals.&lt;/p&gt; &#xA;&lt;p&gt;Floating containers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;With the default configuration, attach to the top left corner of their &#34;parent&#34;&lt;/li&gt; &#xA; &lt;li&gt;Don&#39;t affect the width and height of their parent&lt;/li&gt; &#xA; &lt;li&gt;Don&#39;t affect the positioning of sibling elements&lt;/li&gt; &#xA; &lt;li&gt;Depending on their z-index can appear above or below other elements, partially or completely occluding them&lt;/li&gt; &#xA; &lt;li&gt;Apart from positioning, function just like standard &lt;code&gt;CLAY&lt;/code&gt; elements - including expanding to fit their children, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The easiest mental model to use when thinking about floating containers is that they are a completely separate UI hierarchy, attached to a specific x,y point on their &#34;parent&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Floating elements uses &lt;code&gt;Clay_FloatingElementConfig&lt;/code&gt; to configure specific options.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Struct Definition (Pseudocode)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;Clay_FloatingElementConfig {&#xA;    Clay_Vector2 offset {&#xA;        float x, float y&#xA;    };&#xA;    Clay_Dimensions expand {&#xA;        float width, float height&#xA;    };&#xA;    uint16_t zIndex;&#xA;    uint32_t parentId;&#xA;    Clay_FloatingAttachPoints attachment {&#xA;        .element = CLAY_ATTACH_POINT_LEFT_TOP (default) | CLAY_ATTACH_POINT_LEFT_CENTER | CLAY_ATTACH_POINT_LEFT_BOTTOM | CLAY_ATTACH_POINT_CENTER_TOP | CLAY_ATTACH_POINT_CENTER_CENTER | CLAY_ATTACH_POINT_CENTER_BOTTOM | CLAY_ATTACH_POINT_RIGHT_TOP | CLAY_ATTACH_POINT_RIGHT_CENTER | CLAY_ATTACH_POINT_RIGHT_BOTTOM&#xA;        .parent = CLAY_ATTACH_POINT_LEFT_TOP (default) | CLAY_ATTACH_POINT_LEFT_CENTER | CLAY_ATTACH_POINT_LEFT_BOTTOM | CLAY_ATTACH_POINT_CENTER_TOP | CLAY_ATTACH_POINT_CENTER_CENTER | CLAY_ATTACH_POINT_CENTER_BOTTOM | CLAY_ATTACH_POINT_RIGHT_TOP | CLAY_ATTACH_POINT_RIGHT_CENTER | CLAY_ATTACH_POINT_RIGHT_BOTTOM&#xA;    };&#xA;    Clay_PointerCaptureMode captureMode {&#xA;        CLAY_POINTER_CAPTURE_MODE_CAPTURE (default),&#xA;        CLAY_POINTER_CAPTURE_MODE_PASSTHROUGH&#xA;    };&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with all config macros, &lt;code&gt;CLAY_FLOATING()&lt;/code&gt; accepts designated initializer syntax and provides default values for any unspecified struct members.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.offset&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Vector2&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_FLOATING({ .offset = { -24, -24 } })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Used to apply a position offset to the floating container &lt;em&gt;after&lt;/em&gt; all other layout has been calculated.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.expand&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Dimensions&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_FLOATING({ .expand = { 16, 16 } })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Used to expand the width and height of the floating container &lt;em&gt;before&lt;/em&gt; laying out child elements.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.zIndex&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;float&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_FLOATING({ .zIndex = 1 })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;All floating elements (as well as their entire child hierarchies) will be sorted by &lt;code&gt;.zIndex&lt;/code&gt; order before being converted to render commands. If render commands are drawn in order, elements with higher &lt;code&gt;.zIndex&lt;/code&gt; values will be drawn on top.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.parentId&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;uint32_t&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_FLOATING({ .parentId = Clay_GetElementId(&#34;HeaderButton&#34;).id })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;By default, floating containers will &#34;attach&#34; to the parent element that they are declared inside. However, there are cases where this limitation could cause significant performance or ergonomics problems. &lt;code&gt;.parentId&lt;/code&gt; allows you to specify a &lt;code&gt;CLAY_ID().id&lt;/code&gt; to attach the floating container to. The parent element with the matching id can be declared anywhere in the hierarchy, it doesn&#39;t need to be declared before or after the floating container in particular.&lt;/p&gt; &#xA;&lt;p&gt;Consider the following case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Load an image somewhere in your code&#xA;CLAY(CLAY_IDI(&#34;SidebarButton&#34;, 1), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;    // .. some button contents&#xA;    if (tooltip.attachedButtonIndex == 1) {&#xA;        CLAY_FLOATING(/* floating config... */)&#xA;    }&#xA;}&#xA;CLAY(CLAY_IDI(&#34;SidebarButton&#34;, 2), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;    // .. some button contents&#xA;    if (tooltip.attachedButtonIndex == 2) {&#xA;        CLAY_FLOATING(/* floating config... */)&#xA;    }&#xA;}&#xA;CLAY(CLAY_IDI(&#34;SidebarButton&#34;, 3), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;    // .. some button contents&#xA;    if (tooltip.attachedButtonIndex == 3) {&#xA;        CLAY_FLOATING(/* floating config... */)&#xA;    }&#xA;}&#xA;CLAY(CLAY_IDI(&#34;SidebarButton&#34;, 4), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;    // .. some button contents&#xA;    if (tooltip.attachedButtonIndex == 4) {&#xA;        CLAY_FLOATING(/* floating config... */)&#xA;    }&#xA;}&#xA;CLAY(CLAY_IDI(&#34;SidebarButton&#34;, 5), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;    // .. some button contents&#xA;    if (tooltip.attachedButtonIndex == 5) {&#xA;        CLAY_FLOATING(/* floating config... */)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The definition of the above UI is significantly polluted by the need to conditionally render floating tooltips as a child of many possible elements. The alternative, using &lt;code&gt;parentId&lt;/code&gt;, looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Load an image somewhere in your code&#xA;CLAY(CLAY_IDI(&#34;SidebarButton&#34;, 1), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;    // .. some button contents&#xA;}&#xA;CLAY(CLAY_IDI(&#34;SidebarButton&#34;, 2), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;    // .. some button contents&#xA;}&#xA;CLAY(CLAY_IDI(&#34;SidebarButton&#34;, 3), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;    // .. some button contents&#xA;}&#xA;CLAY(CLAY_IDI(&#34;SidebarButton&#34;, 4), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;    // .. some button contents&#xA;}&#xA;CLAY(CLAY_IDI(&#34;SidebarButton&#34;, 5), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;    // .. some button contents&#xA;}&#xA;&#xA;// Any other point in the hierarchy&#xA;CLAY_FLOATING(CLAY_ID(&#34;OptionTooltip&#34;), &amp;amp;CLAY_LAYOUT_DEFAULT, CLAY_FLOATING(.parentId = CLAY_IDI(&#34;SidebarButton&#34;, tooltip.attachedButtonIndex).id)) {&#xA;    // Tooltip contents...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.attachment&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_FloatingAttachPoints&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_FLOATING(.attachment = { .element = CLAY_ATTACH_POINT_LEFT_CENTER, .parent = CLAY_ATTACH_POINT_RIGHT_TOP });&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;In terms of positioning the floating container, &lt;code&gt;.attachment&lt;/code&gt; specifies&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The point on the floating container (&lt;code&gt;.element&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;The point on the parent element that it &#34;attaches&#34; to (&lt;code&gt;.parent&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/b8c6dfaa-c1b1-41a4-be55-013473e4a6ce&#34; alt=&#34;Screenshot 2024-08-23 at 11 47 21 AM&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can mentally visualise this as finding a point on the floating container, then finding a point on the parent, and lining them up over the top of one another.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;p&gt;&#34;Attach the LEFT_CENTER of the floating container to the RIGHT_TOP of the parent&#34;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_FLOATING({ .attachment = { .element = CLAY_ATTACH_POINT_LEFT_CENTER, .parent = CLAY_ATTACH_POINT_RIGHT_TOP } });&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/ebe75e0d-1904-46b0-982d-418f929d1516&#34; alt=&#34;Screenshot 2024-08-23 at 11 53 24 AM&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.pointerCaptureMode&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_PointerCaptureMode&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_FLOATING({ .pointerCaptureMode = CLAY_POINTER_CAPTURE_MODE_CAPTURE })&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Controls whether pointer events like hover and click should pass through to content underneath this floating element, or whether the pointer should be &#34;captured&#34; by this floating element. Defaults to &lt;code&gt;CLAY_POINTER_CAPTURE_MODE_CAPTURE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Horizontal container with three option buttons&#xA;CLAY(CLAY_ID(&#34;OptionsList&#34;), CLAY_LAYOUT(.childGap = 16)) {&#xA;    CLAY_RECTANGLE(CLAY_IDI(&#34;Option&#34;, 1), CLAY_LAYOUT(.padding = {16, 16}), CLAY_RECTANGLE(.color = COLOR_BLUE)) {&#xA;        CLAY_TEXT(CLAY_IDI(&#34;OptionText&#34;, 1), CLAY_STRING(&#34;Option 1&#34;), CLAY_TEXT_CONFIG());&#xA;    }&#xA;    CLAY_RECTANGLE(CLAY_IDI(&#34;Option&#34;, 2), CLAY_LAYOUT(.padding = {16, 16}), CLAY_RECTANGLE(.color = COLOR_BLUE)) {&#xA;        CLAY_TEXT(CLAY_IDI(&#34;OptionText&#34;, 2), CLAY_STRING(&#34;Option 2&#34;), CLAY_TEXT_CONFIG());&#xA;        // Floating tooltip will attach above the &#34;Option 2&#34; container and not affect widths or positions of other elements&#xA;        CLAY_FLOATING(CLAY_ID(&#34;OptionTooltip&#34;), &amp;amp;CLAY_LAYOUT_DEFAULT, CLAY_FLOATING({ .zIndex = 1, .attachment = { .element = CLAY_ATTACH_POINT_CENTER_BOTTOM, .parent = CLAY_ATTACH_POINT_CENTER_TOP } })) {&#xA;            CLAY_TEXT(CLAY_IDI(&#34;OptionTooltipText&#34;, 1), CLAY_STRING(&#34;Most popular!&#34;), CLAY_TEXT_CONFIG());&#xA;        }&#xA;    }&#xA;    CLAY_RECTANGLE(CLAY_IDI(&#34;Option&#34;, 3), CLAY_LAYOUT(.padding = {16, 16}), CLAY_RECTANGLE(.color = COLOR_BLUE)) {&#xA;        CLAY_TEXT(CLAY_IDI(&#34;OptionText&#34;, 3), CLAY_STRING(&#34;Option 3&#34;), CLAY_TEXT_CONFIG());&#xA;    }&#xA;}&#xA;&#xA;// Floating containers can also be declared elsewhere in a layout, to avoid branching or polluting other UI&#xA;for (int i = 0; i &amp;lt; 1000; i++) {&#xA;    CLAY(CLAY_IDI(&#34;Option&#34;, i + 1), &amp;amp;CLAY_LAYOUT_DEFAULT) {&#xA;        // ...&#xA;    }&#xA;}&#xA;// Note the use of &#34;parentId&#34;.&#xA;// Floating tooltip will attach above the &#34;Option 2&#34; container and not affect widths or positions of other elements&#xA;CLAY_FLOATING(CLAY_ID(&#34;OptionTooltip&#34;), &amp;amp;CLAY_LAYOUT_DEFAULT, CLAY_FLOATING({ .parentId = CLAY_IDI(&#34;Option&#34;, 2).id, .zIndex = 1, .attachment = { .element = CLAY_ATTACH_POINT_CENTER_BOTTOM, .parent = CLAY_ATTACH_POINT_TOP_CENTER } })) {&#xA;    CLAY_TEXT(CLAY_IDI(&#34;OptionTooltipText&#34;, 1), CLAY_STRING(&#34;Most popular!&#34;), CLAY_TEXT_CONFIG());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When using &lt;code&gt;.parentId&lt;/code&gt;, the floating container can be declared anywhere after &lt;code&gt;BeginLayout&lt;/code&gt; and before &lt;code&gt;EndLayout&lt;/code&gt;. The target element matching the &lt;code&gt;.parentId&lt;/code&gt; doesn&#39;t need to exist when &lt;code&gt;CLAY_FLOATING&lt;/code&gt; is called.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Rendering&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_FLOATING&lt;/code&gt; elements will not generate any render commands.&lt;/p&gt; &#xA;&lt;h3&gt;CLAY_CUSTOM_ELEMENT&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_CUSTOM_ELEMENT(Clay_ElementId id, Clay_LayoutConfig *layoutConfig, Clay_CustomElementConfig *customConfig);&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Clay_BeginLayout()&lt;/code&gt; -&amp;gt; &lt;code&gt;CLAY_CUSTOM_ELEMENT()&lt;/code&gt; -&amp;gt; &lt;code&gt;Clay_EndLayout()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CUSTOM_ELEMENT&lt;/strong&gt; allows the user to pass custom data to the renderer.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Struct Definition (Pseudocode)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct&#xA;{&#xA;    #ifndef CLAY_EXTEND_CONFIG_CUSTOM&#xA;        void * customData; // Note: This field will be replaced if #define CLAY_EXTEND_CONFIG_CUSTOM is specified&#xA;    #else CLAY_EXTEND_CONFIG_CUSTOM&#xA;        // Contents of CLAY_EXTEND_CONFIG_CUSTOM will be pasted here&#xA;    #endif&#xA;} Clay_CustomElementConfig;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with all config macros, &lt;code&gt;CLAY_CUSTOM_ELEMENT_CONFIG()&lt;/code&gt; accepts designated initializer syntax and provides default values for any unspecified struct members.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Extension&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The underlying &lt;code&gt;Clay_ImageCustomConfig&lt;/code&gt; can be extended with new members by using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define CLAY_EXTEND_CONFIG_CUSTOM float newField;&#xA;#include &#34;clay.h&#34; // Define your extension before including clay.h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;.customData&lt;/code&gt; - &lt;code&gt;void *&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;CLAY_CUSTOM_CONFIG(.customData = &amp;amp;myCustomData)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;.customData&lt;/code&gt; is a generic void pointer that can be used to pass through custom data to the renderer. &lt;strong&gt;Note:&lt;/strong&gt; this field is generally not recommended for usage due to the lack of type safety, see &lt;code&gt;#define CLAY_EXTEND_CONFIG_CUSTOM&lt;/code&gt; in &lt;a href=&#34;&#34;&gt;Preprocessor Directives&lt;/a&gt; for an alternative.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// Extend CLAY_CUSTOM_ELEMENT_CONFIG with your custom data&#xA;#define CLAY_EXTEND_CONFIG_CUSTOM struct t_CustomElementData customData;&#xA;// Extensions need to happen _before_ the clay include&#xA;#include &#34;clay.h&#34;&#xA;&#xA;enum CustomElementType {&#xA;    CUSTOM_ELEMENT_TYPE_MODEL,&#xA;    CUSTOM_ELEMENT_TYPE_VIDEO&#xA;};&#xA;&#xA;// A rough example of how you could handle laying out 3d models in your UI&#xA;typedef struct t_CustomElementData {&#xA;    CustomElementType type;&#xA;    union {&#xA;        Model model;&#xA;        Video video;&#xA;        // ...&#xA;    };&#xA;} CustomElementData;&#xA;&#xA;Model myModel = Load3DModel(filePath);&#xA;CustomElement modelElement = (CustomElement) { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel }&#xA;// ...&#xA;CLAY(id, style) {&#xA;    // This config is type safe and contains the CustomElementData struct&#xA;    CLAY_CUSTOM_ELEMENT(id, layout, CLAY_CUSTOM_ELEMENT_CONFIG(.customData = { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel })) {}&#xA;}&#xA;&#xA;// Later during your rendering&#xA;switch (renderCommand-&amp;gt;commandType) {&#xA;    // ...&#xA;    case CLAY_RENDER_COMMAND_TYPE_CUSTOM: {&#xA;        // Your extended struct is passed through&#xA;        CustomElementData *data = renderCommand-&amp;gt;elementConfig.customElementConfig-&amp;gt;customData;&#xA;        if (!customElement) continue;&#xA;        switch (customElement-&amp;gt;type) {&#xA;            case CUSTOM_ELEMENT_TYPE_MODEL: {&#xA;                // Render your 3d model here&#xA;                break;&#xA;            }&#xA;            case CUSTOM_ELEMENT_TYPE_VIDEO: {&#xA;                // Render your video here&#xA;                break;&#xA;            }&#xA;            // ...&#xA;        }&#xA;        break;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Rendering&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Element is subject to &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#visibility-culling&#34;&gt;culling&lt;/a&gt;. Otherwise, a single &lt;code&gt;Clay_RenderCommand&lt;/code&gt; with &lt;code&gt;commandType = CLAY_RENDER_COMMAND_TYPE_CUSTOM&lt;/code&gt; will be created.&lt;/p&gt; &#xA;&lt;h2&gt;Data Structures &amp;amp; Definitions&lt;/h2&gt; &#xA;&lt;h3&gt;Clay_ElementId&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct {&#xA;    uint32_t id;&#xA;    uint32_t offset;&#xA;    uint32_t baseId;&#xA;    Clay_String stringId;&#xA;} Clay_ElementId;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Returned by &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_id&#34;&gt;CLAY_ID&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_idi&#34;&gt;CLAY_IDI&lt;/a&gt;, this struct contains a hash id, as well as the source string that was used to generate it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.id&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;uint32_t&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A unique ID derived from the string passed to &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_id&#34;&gt;CLAY_ID&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_idi&#34;&gt;CLAY_IDI&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.offset&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;uint32_t&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If this id was generated using &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_idi&#34;&gt;CLAY_IDI&lt;/a&gt;, &lt;code&gt;.offset&lt;/code&gt; is the value passed as the second argument. For &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_id&#34;&gt;CLAY_ID&lt;/a&gt;, this will always be &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.baseId&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;uint32_t&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If this id was generated using &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_idi&#34;&gt;CLAY_IDI&lt;/a&gt;, &lt;code&gt;.baseId&lt;/code&gt; is the hash of the base string passed, &lt;strong&gt;before it is additionally hashed with &lt;code&gt;.offset&lt;/code&gt;&lt;/strong&gt;. For &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_id&#34;&gt;CLAY_ID&lt;/a&gt;, this will always be the same as &lt;code&gt;.id&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.stringId&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_String&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Stores the original string that was passed in when &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_id&#34;&gt;CLAY_ID&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_idi&#34;&gt;CLAY_IDI&lt;/a&gt; were called.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_RenderCommandArray&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct&#xA;{&#xA;&#x9;uint32_t capacity;&#xA;&#x9;uint32_t length;&#xA;&#x9;Clay_RenderCommand *internalArray;&#xA;} Clay_RenderCommandArray;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Returned by &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_endlayout&#34;&gt;Clay_EndLayout&lt;/a&gt;, this array contains the &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_rendercommand&#34;&gt;Clay_RenderCommand&lt;/a&gt;s representing the calculated layout.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.capacity&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;uint32_t&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Represents the total capacity of the allocated memory in &lt;code&gt;.internalArray&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.length&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;uint32_t&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Represents the total number of &lt;code&gt;Clay_RenderCommand&lt;/code&gt; elements stored consecutively at the address &lt;code&gt;.internalArray&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.internalArray&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_RenderCommand&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;An array of &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_rendercommand&#34;&gt;Clay_RenderCommand&lt;/a&gt;s representing the calculated layout. If there was at least one render command, this array will contain elements from &lt;code&gt;.internalArray[0]&lt;/code&gt; to &lt;code&gt;.internalArray[.length - 1]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_RenderCommand&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct&#xA;{&#xA;    Clay_BoundingBox boundingBox;&#xA;    Clay_ElementConfigUnion config;&#xA;    Clay_String text;&#xA;    uint32_t id;&#xA;    Clay_RenderCommandType commandType;&#xA;} Clay_RenderCommand;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.commandType&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_RenderCommandType&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;An enum indicating how this render command should be handled. Possible values include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_RENDER_COMMAND_TYPE_NONE&lt;/code&gt; - Should be ignored by the renderer, and never emitted by clay under normal conditions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_RENDER_COMMAND_TYPE_RECTANGLE&lt;/code&gt; - A rectangle should be drawn, configured with &lt;code&gt;.config.rectangleElementConfig&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_RENDER_COMMAND_TYPE_BORDER&lt;/code&gt; - A border should be drawn, configured with &lt;code&gt;.config.borderElementConfig&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_RENDER_COMMAND_TYPE_TEXT&lt;/code&gt; - Text should be drawn, configured with &lt;code&gt;.config.textElementConfig&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_RENDER_COMMAND_TYPE_IMAGE&lt;/code&gt; - An image should be drawn, configured with &lt;code&gt;.config.imageElementConfig&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_RENDER_COMMAND_TYPE_SCISSOR_START&lt;/code&gt; - Named after &lt;a href=&#34;https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissor.xhtml&#34;&gt;glScissor&lt;/a&gt;, this indicates that the renderer should begin culling any subsequent pixels that are drawn outside the &lt;code&gt;.boundingBox&lt;/code&gt; of this render command.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_RENDER_COMMAND_TYPE_SCISSOR_END&lt;/code&gt; - Only ever appears after a matching &lt;code&gt;CLAY_RENDER_COMMAND_TYPE_SCISSOR_START&lt;/code&gt; command, and indicates that the scissor has ended.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CLAY_RENDER_COMMAND_TYPE_CUSTOM&lt;/code&gt; - A custom render command controlled by the user, configured with &lt;code&gt;.config.customElementConfig&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.boundingBox&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_BoundingBox&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct {&#xA;    float x, y, width, height;&#xA;} Clay_BoundingBox;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A rectangle representing the bounding box of this render command, with &lt;code&gt;.x&lt;/code&gt; and &lt;code&gt;.y&lt;/code&gt; representing the top left corner of the element.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.config&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_ElementConfigUnion&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A C union containing various pointers to config data, with the type dependent on &lt;code&gt;.commandType&lt;/code&gt;. Possible values include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;config.rectangleElementConfig&lt;/code&gt; - Used when &lt;code&gt;.commandType == CLAY_RENDER_COMMAND_TYPE_RECTANGLE&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_rectangle&#34;&gt;CLAY_RECTANGLE&lt;/a&gt; for details.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;config.textElementConfig&lt;/code&gt; - Used when &lt;code&gt;.commandType == CLAY_RENDER_COMMAND_TYPE_TEXT&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_text&#34;&gt;CLAY_TEXT&lt;/a&gt; for details.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;config.imageElementConfig&lt;/code&gt; - Used when &lt;code&gt;.commandType == CLAY_RENDER_COMMAND_TYPE_IMAGE&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_image&#34;&gt;CLAY_IMAGE&lt;/a&gt; for details.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;config.borderElementConfig&lt;/code&gt; - Used when &lt;code&gt;.commandType == CLAY_RENDER_COMMAND_TYPE_BORDER&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_border&#34;&gt;CLAY_BORDER&lt;/a&gt; for details.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;config.customElementConfig&lt;/code&gt; - Used when &lt;code&gt;.commandType == CLAY_RENDER_COMMAND_TYPE_CUSTOM&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_custom_element&#34;&gt;CLAY_CUSTOM&lt;/a&gt; for details.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;config.floatingElementConfig&lt;/code&gt; - Not used and will always be NULL.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;config.scrollElementConfig&lt;/code&gt; - Not used and will always be NULL.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.text&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_String&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Only used if &lt;code&gt;.commandType == CLAY_RENDER_COMMAND_TYPE_TEXT&lt;/code&gt;. A &lt;code&gt;Clay_String&lt;/code&gt; containing a string slice (char *chars, int length) representing text to be rendered. &lt;strong&gt;Note: This string is not guaranteed to be null terminated.&lt;/strong&gt; Clay saves significant performance overhead by using slices when wrapping text instead of having to clone new null terminated strings. If your renderer does not support &lt;strong&gt;ptr, length&lt;/strong&gt; style strings (e.g. Raylib), you will need to clone this to a new C string before rendering.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.id&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;uint32_t&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The id that was originally used with the element macro that created this render command. See &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_id&#34;&gt;CLAY_ID&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_ScrollContainerData&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct&#xA;{&#xA;    Clay_Vector2 *scrollPosition;&#xA;    Clay_Dimensions scrollContainerDimensions;&#xA;    Clay_Dimensions contentDimensions;&#xA;    Clay_ScrollElementConfig config;&#xA;    bool found;&#xA;} Clay_ScrollContainerData;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.scrollPosition&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Vector2 *&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A pointer to the internal scroll position of this scroll container. Mutating it will result in elements inside the scroll container shifting up / down (&lt;code&gt;.y&lt;/code&gt;) or left / right (&lt;code&gt;.x&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.scrollContainerDimensions&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Dimensions&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct {&#xA;    float width, height;&#xA;} Clay_Dimensions;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Dimensions representing the outer width and height of the scroll container itself.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.contentDimensions&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Dimensions&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct {&#xA;    float width, height;&#xA;} Clay_Dimensions;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Dimensions representing the inner width and height of the content &lt;em&gt;inside&lt;/em&gt; the scroll container. Scrolling is only possible when the &lt;code&gt;contentDimensions&lt;/code&gt; are larger in at least one dimension than the &lt;code&gt;scrollContainerDimensions&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.config&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_ScrollElementConfig&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_scroll&#34;&gt;Clay_ScrollElementConfig&lt;/a&gt; for the matching scroll container element.&lt;/p&gt; &#xA;&lt;h3&gt;Clay_PointerData&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct&#xA;{&#xA;    Clay_Vector2 position;&#xA;    Clay_PointerDataInteractionState state;&#xA;} Clay_PointerData;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fields&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.position&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_Vector2&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;A Vector2 containing the current x,y coordinates of the mouse pointer, which were originally passed into &lt;a href=&#34;https://raw.githubusercontent.com/nicbarker/clay/main/#clay_setpointerstate&#34;&gt;Clay_SetPointerState()&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.state&lt;/code&gt;&lt;/strong&gt; - &lt;code&gt;Clay_PointerDataInteractionState&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef enum&#xA;{&#xA;    CLAY_POINTER_DATA_PRESSED_THIS_FRAME,&#xA;    CLAY_POINTER_DATA_PRESSED,&#xA;    CLAY_POINTER_DATA_RELEASED_THIS_FRAME,&#xA;    CLAY_POINTER_DATA_RELEASED,&#xA;} Clay_PointerDataInteractionState;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An enum value representing the current &#34;state&#34; of the pointer interaction. As an example, consider the case where a user is on a desktop computer, moves the mouse pointer over a button, clicks and holds the left mouse button for a short time, then releases it:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;While the mouse pointer is over (&#34;hovering&#34;) the button, but no mouse button has been pressed: &lt;code&gt;CLAY_POINTER_DATA_RELEASED&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;First frame that the user presses the left mouse button: &lt;code&gt;CLAY_POINTER_DATA_PRESSED_THIS_FRAME&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;All subsequent frames where the user is still holding the left mouse button: &lt;code&gt;CLAY_POINTER_DATA_PRESSED&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;The single frame where the left mouse button goes from pressed -&amp;gt; released: &lt;code&gt;CLAY_POINTER_DATA_RELEASED_THIS_FRAME&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;All subsequent frames while the mouse pointer is still over the button: &lt;code&gt;CLAY_POINTER_DATA_RELEASED&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt;</summary>
  </entry>
</feed>