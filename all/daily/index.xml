<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-06T01:30:36Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>asottile/pyupgrade</title>
    <updated>2022-10-06T01:30:36Z</updated>
    <id>tag:github.com,2022-10-06:/asottile/pyupgrade</id>
    <link href="https://github.com/asottile/pyupgrade" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A tool (and pre-commit hook) to automatically upgrade syntax for newer versions of the language.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://dev.azure.com/asottile/asottile/_build/latest?definitionId=2&amp;amp;branchName=main&#34;&gt;&lt;img src=&#34;https://dev.azure.com/asottile/asottile/_apis/build/status/asottile.pyupgrade?branchName=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dev.azure.com/asottile/asottile/_build/latest?definitionId=2&amp;amp;branchName=main&#34;&gt;&lt;img src=&#34;https://img.shields.io/azure-devops/coverage/asottile/asottile/2/main.svg?sanitize=true&#34; alt=&#34;Azure DevOps coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://results.pre-commit.ci/latest/github/asottile/pyupgrade/main&#34;&gt;&lt;img src=&#34;https://results.pre-commit.ci/badge/github/asottile/pyupgrade/main.svg?sanitize=true&#34; alt=&#34;pre-commit.ci status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;pyupgrade&lt;/h1&gt; &#xA;&lt;p&gt;A tool (and pre-commit hook) to automatically upgrade syntax for newer versions of the language.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install pyupgrade&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;As a pre-commit hook&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/pre-commit/pre-commit&#34;&gt;pre-commit&lt;/a&gt; for instructions&lt;/p&gt; &#xA;&lt;p&gt;Sample &lt;code&gt;.pre-commit-config.yaml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;-   repo: https://github.com/asottile/pyupgrade&#xA;    rev: v3.0.0&#xA;    hooks:&#xA;    -   id: pyupgrade&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Implemented features&lt;/h2&gt; &#xA;&lt;h3&gt;Set literals&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-set(())&#xA;+set()&#xA;-set([])&#xA;+set()&#xA;-set((1,))&#xA;+{1}&#xA;-set((1, 2))&#xA;+{1, 2}&#xA;-set([1, 2])&#xA;+{1, 2}&#xA;-set(x for x in y)&#xA;+{x for x in y}&#xA;-set([x for x in y])&#xA;+{x for x in y}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Dictionary comprehensions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-dict((a, b) for a, b in y)&#xA;+{a: b for a, b in y}&#xA;-dict([(a, b) for a, b in y])&#xA;+{a: b for a, b in y}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Format Specifiers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-&#39;{0} {1}&#39;.format(1, 2)&#xA;+&#39;{} {}&#39;.format(1, 2)&#xA;-&#39;{0}&#39; &#39;{1}&#39;.format(1, 2)&#xA;+&#39;{}&#39; &#39;{}&#39;.format(1, 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;printf-style string formatting&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Unless &lt;code&gt;--keep-percent-format&lt;/code&gt; is passed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-&#39;%s %s&#39; % (a, b)&#xA;+&#39;{} {}&#39;.format(a, b)&#xA;-&#39;%r %2f&#39; % (a, b)&#xA;+&#39;{!r} {:2f}&#39;.format(a, b)&#xA;-&#39;%(a)s %(b)s&#39; % {&#39;a&#39;: 1, &#39;b&#39;: 2}&#xA;+&#39;{a} {b}&#39;.format(a=1, b=2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unicode literals&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-u&#39;foo&#39;&#xA;+&#39;foo&#39;&#xA;-u&#34;foo&#34;&#xA;+&#39;foo&#39;&#xA;-u&#39;&#39;&#39;foo&#39;&#39;&#39;&#xA;+&#39;&#39;&#39;foo&#39;&#39;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Invalid escape sequences&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; # strings with only invalid sequences become raw strings&#xA;-&#39;\d&#39;&#xA;+r&#39;\d&#39;&#xA; # strings with mixed valid / invalid sequences get escaped&#xA;-&#39;\n\d&#39;&#xA;+&#39;\n\\d&#39;&#xA;-u&#39;\d&#39;&#xA;+r&#39;\d&#39;&#xA; # this fixes a syntax error in python3.3+&#xA;-&#39;\N&#39;&#xA;+r&#39;\N&#39;&#xA;&#xA;# note: pyupgrade is timid in one case (that&#39;s usually a mistake)&#xA;# in python2.x `&#39;\u2603&#39;` is the same as `&#39;\\u2603&#39;` without `unicode_literals`&#xA;# but in python3.x, that&#39;s our friend â˜ƒ&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;is&lt;/code&gt; / &lt;code&gt;is not&lt;/code&gt; comparison to constant literals&lt;/h3&gt; &#xA;&lt;p&gt;In python3.8+, comparison to literals becomes a &lt;code&gt;SyntaxWarning&lt;/code&gt; as the success of those comparisons is implementation specific (due to common object caching).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-x is 5&#xA;+x == 5&#xA;-x is not 5&#xA;+x != 5&#xA;-x is &#39;foo&#39;&#xA;+x == &#39;foo&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.encode()&lt;/code&gt; to bytes literals&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-&#39;foo&#39;.encode()&#xA;+b&#39;foo&#39;&#xA;-&#39;foo&#39;.encode(&#39;ascii&#39;)&#xA;+b&#39;foo&#39;&#xA;-&#39;foo&#39;.encode(&#39;utf-8&#39;)&#xA;+b&#39;foo&#39;&#xA;-u&#39;foo&#39;.encode()&#xA;+b&#39;foo&#39;&#xA;-&#39;\xa0&#39;.encode(&#39;latin1&#39;)&#xA;+b&#39;\xa0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;extraneous parens in &lt;code&gt;print(...)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A fix for &lt;a href=&#34;https://github.com/python-modernize/python-modernize/issues/178&#34;&gt;python-modernize/python-modernize#178&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; # ok: printing an empty tuple&#xA; print(())&#xA; # ok: printing a tuple&#xA; print((1,))&#xA; # ok: parenthesized generator argument&#xA; sum((i for i in range(3)), [])&#xA; # fixed:&#xA;-print((&#34;foo&#34;))&#xA;+print(&#34;foo&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;unittest deprecated aliases&lt;/h3&gt; &#xA;&lt;p&gt;Rewrites &lt;a href=&#34;https://docs.python.org/3/library/unittest.html#deprecated-aliases&#34;&gt;deprecated unittest method aliases&lt;/a&gt; to their non-deprecated forms.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; from unittest import TestCase&#xA;&#xA;&#xA; class MyTests(TestCase):&#xA;     def test_something(self):&#xA;-        self.failUnlessEqual(1, 1)&#xA;+        self.assertEqual(1, 1)&#xA;-        self.assertEquals(1, 1)&#xA;+        self.assertEqual(1, 1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;super()&lt;/code&gt; calls&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; class C(Base):&#xA;     def f(self):&#xA;-        super(C, self).f()&#xA;+        super().f()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&#34;new style&#34; classes&lt;/h3&gt; &#xA;&lt;h4&gt;rewrites class declaration&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-class C(object): pass&#xA;+class C: pass&#xA;-class C(B, object): pass&#xA;+class C(B): pass&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;removes &lt;code&gt;__metaclass__ = type&lt;/code&gt; declaration&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; class C:&#xA;-    __metaclass__ = type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;forced &lt;code&gt;str(&#34;native&#34;)&lt;/code&gt; literals&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-str()&#xA;+&#39;&#39;&#xA;-str(&#34;foo&#34;)&#xA;+&#34;foo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.encode(&#34;utf-8&#34;)&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-&#34;foo&#34;.encode(&#34;utf-8&#34;)&#xA;+&#34;foo&#34;.encode()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;# coding: ...&lt;/code&gt; comment&lt;/h3&gt; &#xA;&lt;p&gt;as of &lt;a href=&#34;https://www.python.org/dev/peps/pep-3120/&#34;&gt;PEP 3120&lt;/a&gt;, the default encoding for python source is UTF-8&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-# coding: utf-8&#xA; x = 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;__future__&lt;/code&gt; import removal&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;by default removes &lt;code&gt;nested_scopes&lt;/code&gt;, &lt;code&gt;generators&lt;/code&gt;, &lt;code&gt;with_statement&lt;/code&gt;, &lt;code&gt;absolute_import&lt;/code&gt;, &lt;code&gt;division&lt;/code&gt;, &lt;code&gt;print_function&lt;/code&gt;, &lt;code&gt;unicode_literals&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--py37-plus&lt;/code&gt; will also remove &lt;code&gt;generator_stop&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-from __future__ import with_statement&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Remove unnecessary py3-compat imports&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-from io import open&#xA;-from six.moves import map&#xA;-from builtins import object  # python-future&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;import replacements&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--py36-plus&lt;/code&gt; (and others) will replace imports&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;see also &lt;a href=&#34;https://github.com/asottile/reorder_python_imports#removing--rewriting-obsolete-six-imports&#34;&gt;reorder-python-imports&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;some examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-from collections import deque, Mapping&#xA;+from collections import deque&#xA;+from collections.abc import Mapping&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-from typing import Sequence&#xA;+from collections.abc import Sequence&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-from typing_extensions import Concatenate&#xA;+from typing import Concatenate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;rewrite &lt;code&gt;mock&lt;/code&gt; imports&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/asottile/pyupgrade/issues/314&#34;&gt;Unless &lt;code&gt;--keep-mock&lt;/code&gt; is passed on the commandline&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-from mock import patch&#xA;+from unittest.mock import patch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;yield&lt;/code&gt; =&amp;gt; &lt;code&gt;yield from&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; def f():&#xA;-    for x in y:&#xA;-        yield x&#xA;+    yield from y&#xA;-    for a, b in c:&#xA;-        yield (a, b)&#xA;+    yield from c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Python2 and old Python3.x blocks&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import sys&#xA;-if sys.version_info &amp;lt; (3,):  # also understands `six.PY2` (and `not`), `six.PY3` (and `not`)&#xA;-    print(&#39;py2&#39;)&#xA;-else:&#xA;-    print(&#39;py3&#39;)&#xA;+print(&#39;py3&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--py36-plus&lt;/code&gt; will remove Python &amp;lt;= 3.5 only blocks&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--py37-plus&lt;/code&gt; will remove Python &amp;lt;= 3.6 only blocks&lt;/li&gt; &#xA; &lt;li&gt;so on and so forth&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; # using --py36-plus for this example&#xA;&#xA; import sys&#xA;-if sys.version_info &amp;lt; (3, 6):&#xA;-    print(&#39;py3.5&#39;)&#xA;-else:&#xA;-    print(&#39;py3.6+&#39;)&#xA;+print(&#39;py3.6+&#39;)&#xA;&#xA;-if sys.version_info &amp;lt;= (3, 5):&#xA;-    print(&#39;py3.5&#39;)&#xA;-else:&#xA;-    print(&#39;py3.6+&#39;)&#xA;+print(&#39;py3.6+&#39;)&#xA;&#xA;-if sys.version_info &amp;gt;= (3, 6):&#xA;-    print(&#39;py3.6+&#39;)&#xA;-else:&#xA;-    print(&#39;py3.5&#39;)&#xA;+print(&#39;py3.6+&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;if&lt;/code&gt; blocks without an &lt;code&gt;else&lt;/code&gt; will not be rewritten as it could introduce a syntax error.&lt;/p&gt; &#xA;&lt;h3&gt;remove &lt;code&gt;six&lt;/code&gt; compatibility code&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-six.text_type&#xA;+str&#xA;-six.binary_type&#xA;+bytes&#xA;-six.class_types&#xA;+(type,)&#xA;-six.string_types&#xA;+(str,)&#xA;-six.integer_types&#xA;+(int,)&#xA;-six.unichr&#xA;+chr&#xA;-six.iterbytes&#xA;+iter&#xA;-six.print_(...)&#xA;+print(...)&#xA;-six.exec_(c, g, l)&#xA;+exec(c, g, l)&#xA;-six.advance_iterator(it)&#xA;+next(it)&#xA;-six.next(it)&#xA;+next(it)&#xA;-six.callable(x)&#xA;+callable(x)&#xA;-six.moves.range(x)&#xA;+range(x)&#xA;-six.moves.xrange(x)&#xA;+range(x)&#xA;&#xA;&#xA;-from six import text_type&#xA;-text_type&#xA;+str&#xA;&#xA;-@six.python_2_unicode_compatible&#xA; class C:&#xA;     def __str__(self):&#xA;         return u&#39;C()&#39;&#xA;&#xA;-class C(six.Iterator): pass&#xA;+class C: pass&#xA;&#xA;-class C(six.with_metaclass(M, B)): pass&#xA;+class C(B, metaclass=M): pass&#xA;&#xA;-@six.add_metaclass(M)&#xA;-class C(B): pass&#xA;+class C(B, metaclass=M): pass&#xA;&#xA;-isinstance(..., six.class_types)&#xA;+isinstance(..., type)&#xA;-issubclass(..., six.integer_types)&#xA;+issubclass(..., int)&#xA;-isinstance(..., six.string_types)&#xA;+isinstance(..., str)&#xA;&#xA;-six.b(&#39;...&#39;)&#xA;+b&#39;...&#39;&#xA;-six.u(&#39;...&#39;)&#xA;+&#39;...&#39;&#xA;-six.byte2int(bs)&#xA;+bs[0]&#xA;-six.indexbytes(bs, i)&#xA;+bs[i]&#xA;-six.int2byte(i)&#xA;+bytes((i,))&#xA;-six.iteritems(dct)&#xA;+dct.items()&#xA;-six.iterkeys(dct)&#xA;+dct.keys()&#xA;-six.itervalues(dct)&#xA;+dct.values()&#xA;-next(six.iteritems(dct))&#xA;+next(iter(dct.items()))&#xA;-next(six.iterkeys(dct))&#xA;+next(iter(dct.keys()))&#xA;-next(six.itervalues(dct))&#xA;+next(iter(dct.values()))&#xA;-six.viewitems(dct)&#xA;+dct.items()&#xA;-six.viewkeys(dct)&#xA;+dct.keys()&#xA;-six.viewvalues(dct)&#xA;+dct.values()&#xA;-six.create_unbound_method(fn, cls)&#xA;+fn&#xA;-six.get_unbound_function(meth)&#xA;+meth&#xA;-six.get_method_function(meth)&#xA;+meth.__func__&#xA;-six.get_method_self(meth)&#xA;+meth.__self__&#xA;-six.get_function_closure(fn)&#xA;+fn.__closure__&#xA;-six.get_function_code(fn)&#xA;+fn.__code__&#xA;-six.get_function_defaults(fn)&#xA;+fn.__defaults__&#xA;-six.get_function_globals(fn)&#xA;+fn.__globals__&#xA;-six.raise_from(exc, exc_from)&#xA;+raise exc from exc_from&#xA;-six.reraise(tp, exc, tb)&#xA;+raise exc.with_traceback(tb)&#xA;-six.reraise(*sys.exc_info())&#xA;+raise&#xA;-six.assertCountEqual(self, a1, a2)&#xA;+self.assertCountEqual(a1, a2)&#xA;-six.assertRaisesRegex(self, e, r, fn)&#xA;+self.assertRaisesRegex(e, r, fn)&#xA;-six.assertRegex(self, s, r)&#xA;+self.assertRegex(s, r)&#xA;&#xA; # note: only for *literals*&#xA;-six.ensure_binary(&#39;...&#39;)&#xA;+b&#39;...&#39;&#xA;-six.ensure_str(&#39;...&#39;)&#xA;+&#39;...&#39;&#xA;-six.ensure_text(&#39;...&#39;)&#xA;+&#39;...&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;open&lt;/code&gt; alias&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-with io.open(&#39;f.txt&#39;) as f:&#xA;+with open(&#39;f.txt&#39;) as f:&#xA;     ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;redundant &lt;code&gt;open&lt;/code&gt; modes&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-open(&#34;foo&#34;, &#34;U&#34;)&#xA;+open(&#34;foo&#34;)&#xA;-open(&#34;foo&#34;, &#34;Ur&#34;)&#xA;+open(&#34;foo&#34;)&#xA;-open(&#34;foo&#34;, &#34;Ub&#34;)&#xA;+open(&#34;foo&#34;, &#34;rb&#34;)&#xA;-open(&#34;foo&#34;, &#34;rUb&#34;)&#xA;+open(&#34;foo&#34;, &#34;rb&#34;)&#xA;-open(&#34;foo&#34;, &#34;r&#34;)&#xA;+open(&#34;foo&#34;)&#xA;-open(&#34;foo&#34;, &#34;rt&#34;)&#xA;+open(&#34;foo&#34;)&#xA;-open(&#34;f&#34;, &#34;r&#34;, encoding=&#34;UTF-8&#34;)&#xA;+open(&#34;f&#34;, encoding=&#34;UTF-8&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;OSError&lt;/code&gt; aliases&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; # also understands:&#xA; # - IOError&#xA; # - WindowsError&#xA; # - mmap.error and uses of `from mmap import error`&#xA; # - select.error and uses of `from select import error`&#xA; # - socket.error and uses of `from socket import error`&#xA;&#xA; def throw():&#xA;-    raise EnvironmentError(&#39;boom&#39;)&#xA;+    raise OSError(&#39;boom&#39;)&#xA;&#xA; def catch():&#xA;     try:&#xA;         throw()&#xA;-    except EnvironmentError:&#xA;+    except OSError:&#xA;         handle_error()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;typing.Text&lt;/code&gt; str alias&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-def f(x: Text) -&amp;gt; None:&#xA;+def f(x: str) -&amp;gt; None:&#xA;     ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unpacking list comprehensions&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-foo, bar, baz = [fn(x) for x in items]&#xA;+foo, bar, baz = (fn(x) for x in items)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rewrite &lt;code&gt;xml.etree.cElementTree&lt;/code&gt; to &lt;code&gt;xml.etree.ElementTree&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-import xml.etree.cElementTree as ET&#xA;+import xml.etree.ElementTree as ET&#xA;-from xml.etree.cElementTree import XML&#xA;+from xml.etree.ElementTree import XML&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rewrite &lt;code&gt;type&lt;/code&gt; of primitive&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-type(&#39;&#39;)&#xA;+str&#xA;-type(b&#39;&#39;)&#xA;+bytes&#xA;-type(0)&#xA;+int&#xA;-type(0.)&#xA;+float&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;typing.NamedTuple&lt;/code&gt; / &lt;code&gt;typing.TypedDict&lt;/code&gt; py36+ syntax&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--py36-plus&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-NT = typing.NamedTuple(&#39;NT&#39;, [(&#39;a&#39;, int), (&#39;b&#39;, Tuple[str, ...])])&#xA;+class NT(typing.NamedTuple):&#xA;+    a: int&#xA;+    b: Tuple[str, ...]&#xA;&#xA;-D1 = typing.TypedDict(&#39;D1&#39;, a=int, b=str)&#xA;+class D1(typing.TypedDict):&#xA;+    a: int&#xA;+    b: str&#xA;&#xA;-D2 = typing.TypedDict(&#39;D2&#39;, {&#39;a&#39;: int, &#39;b&#39;: str})&#xA;+class D2(typing.TypedDict):&#xA;+    a: int&#xA;+    b: str&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;f-strings&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--py36-plus&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-&#39;{foo} {bar}&#39;.format(foo=foo, bar=bar)&#xA;+f&#39;{foo} {bar}&#39;&#xA;-&#39;{} {}&#39;.format(foo, bar)&#xA;+f&#39;{foo} {bar}&#39;&#xA;-&#39;{} {}&#39;.format(foo.bar, baz.womp)&#xA;+f&#39;{foo.bar} {baz.womp}&#39;&#xA;-&#39;{} {}&#39;.format(f(), g())&#xA;+f&#39;{f()} {g()}&#39;&#xA;-&#39;{x}&#39;.format(**locals())&#xA;+f&#39;{x}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;note&lt;/em&gt;: &lt;code&gt;pyupgrade&lt;/code&gt; is intentionally timid and will not create an f-string if it would make the expression longer or if the substitution parameters are sufficiently complicated (as this can decrease readability).&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;subprocess.run&lt;/code&gt;: replace &lt;code&gt;universal_newlines&lt;/code&gt; with &lt;code&gt;text&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--py37-plus&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-output = subprocess.run([&#39;foo&#39;], universal_newlines=True)&#xA;+output = subprocess.run([&#39;foo&#39;], text=True)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;subprocess.run&lt;/code&gt;: replace &lt;code&gt;stdout=subprocess.PIPE, stderr=subprocess.PIPE&lt;/code&gt; with &lt;code&gt;capture_output=True&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--py37-plus&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-output = subprocess.run([&#39;foo&#39;], stdout=subprocess.PIPE, stderr=subprocess.PIPE)&#xA;+output = subprocess.run([&#39;foo&#39;], capture_output=True)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;remove parentheses from &lt;code&gt;@functools.lru_cache()&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--py38-plus&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import functools&#xA;&#xA;-@functools.lru_cache()&#xA;+@functools.lru_cache&#xA; def expensive():&#xA;     ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;replace &lt;code&gt;@functools.lru_cache(maxsize=None)&lt;/code&gt; with shorthand&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--py39-plus&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import functools&#xA;&#xA;-@functools.lru_cache(maxsize=None)&#xA;+@functools.cache&#xA; def expensive():&#xA;     ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;pep 585 typing rewrites&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;File imports &lt;code&gt;from __future__ import annotations&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Unless &lt;code&gt;--keep-runtime-typing&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--py39-plus&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-def f(x: List[str]) -&amp;gt; None:&#xA;+def f(x: list[str]) -&amp;gt; None:&#xA;     ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;remove unnecessary abspath&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;--py39-plus&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; from os.path import abspath&#xA;&#xA;-abspath(__file__)&#xA;+__file__&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;pep 604 typing rewrites&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;File imports &lt;code&gt;from __future__ import annotations&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Unless &lt;code&gt;--keep-runtime-typing&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;--py310-plus&lt;/code&gt; is passed on the commandline.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-def f() -&amp;gt; Optional[str]:&#xA;+def f() -&amp;gt; str | None:&#xA;     ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-def f() -&amp;gt; Union[int, str]:&#xA;+def f() -&amp;gt; int | str:&#xA;     ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;remove quoted annotations&lt;/h3&gt; &#xA;&lt;p&gt;Availability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;File imports &lt;code&gt;from __future__ import annotations&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-def f(x: &#39;queue.Queue[int]&#39;) -&amp;gt; C:&#xA;+def f(x: queue.Queue[int]) -&amp;gt; C:&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>jbogard/MediatR</title>
    <updated>2022-10-06T01:30:36Z</updated>
    <id>tag:github.com,2022-10-06:/jbogard/MediatR</id>
    <link href="https://github.com/jbogard/MediatR" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple, unambitious mediator implementation in .NET&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MediatR&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/jbogard/MediatR/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://www.nuget.org/packages/mediatr&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/dt/mediatr.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.nuget.org/packages/mediatr&#34;&gt;&lt;img src=&#34;https://img.shields.io/nuget/vpre/mediatr.svg?sanitize=true&#34; alt=&#34;NuGet&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://myget.org/gallery/mediatr-ci&#34;&gt;&lt;img src=&#34;https://img.shields.io/myget/mediatr-ci/v/MediatR.svg?sanitize=true&#34; alt=&#34;MyGet (dev)&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Simple mediator implementation in .NET&lt;/p&gt; &#xA;&lt;p&gt;In-process messaging with no dependencies.&lt;/p&gt; &#xA;&lt;p&gt;Supports request/response, commands, queries, notifications and events, synchronous and async with intelligent dispatching via C# generic variance.&lt;/p&gt; &#xA;&lt;p&gt;Examples in the &lt;a href=&#34;https://github.com/jbogard/MediatR/wiki&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Installing MediatR&lt;/h3&gt; &#xA;&lt;p&gt;You should install &lt;a href=&#34;https://www.nuget.org/packages/MediatR&#34;&gt;MediatR with NuGet&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Install-Package MediatR&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or via the .NET Core command line interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dotnet add package MediatR&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Either commands, from Package Manager Console or .NET Core CLI, will download and install MediatR and all required dependencies.&lt;/p&gt; &#xA;&lt;h3&gt;Using Contracts-Only Package&lt;/h3&gt; &#xA;&lt;p&gt;To reference only the contracts for MediatR, which includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;IRequest&lt;/code&gt; (including generic variants and &lt;code&gt;Unit&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;INotification&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IStreamRequest&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Add a package reference to &lt;a href=&#34;https://www.nuget.org/packages/MediatR.Contracts&#34;&gt;MediatR.Contracts&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This package is useful in scenarios where your MediatR contracts are in a separate assembly/project from handlers. Example scenarios include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;API contracts&lt;/li&gt; &#xA; &lt;li&gt;GRPC contracts&lt;/li&gt; &#xA; &lt;li&gt;Blazor&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>bufbuild/protoc-gen-validate</title>
    <updated>2022-10-06T01:30:36Z</updated>
    <id>tag:github.com,2022-10-06:/bufbuild/protoc-gen-validate</id>
    <link href="https://github.com/bufbuild/protoc-gen-validate" rel="alternate"></link>
    <summary type="html">&lt;p&gt;protoc plugin to generate polyglot message validators&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bufbuild/protoc-gen-validate/main/.github/buf-logo.svg?sanitize=true&#34; alt=&#34;The Buf logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;protoc-gen-validate (PGV)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/license/bufbuild/protoc-gen-validate?color=blue&#34; alt=&#34;License&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/bufbuild/protoc-gen-validate?include_prereleases&#34; alt=&#34;Release&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/slack-buf-%23e01563&#34; alt=&#34;Slack&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;This project is currently in &lt;strong&gt;alpha&lt;/strong&gt;. The API should be considered unstable and likely to change&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;PGV is a protoc plugin to generate polyglot message validators. While protocol buffers effectively guarantee the types of structured data, they cannot enforce semantic rules for values. This plugin adds support to protoc-generated code to validate such constraints.&lt;/p&gt; &#xA;&lt;p&gt;Developers import the PGV extension and annotate the messages and fields in their proto files with constraint rules:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;syntax = &#34;proto3&#34;;&#xA;&#xA;package examplepb;&#xA;&#xA;import &#34;validate/validate.proto&#34;;&#xA;&#xA;message Person {&#xA;  uint64 id    = 1 [(validate.rules).uint64.gt    = 999];&#xA;&#xA;  string email = 2 [(validate.rules).string.email = true];&#xA;&#xA;  string name  = 3 [(validate.rules).string = {&#xA;                      pattern:   &#34;^[^[0-9]A-Za-z]+( [^[0-9]A-Za-z]+)*$&#34;,&#xA;                      max_bytes: 256,&#xA;                   }];&#xA;&#xA;  Location home = 4 [(validate.rules).message.required = true];&#xA;&#xA;  message Location {&#xA;    double lat = 1 [(validate.rules).double = { gte: -90,  lte: 90 }];&#xA;    double lng = 2 [(validate.rules).double = { gte: -180, lte: 180 }];&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Executing &lt;code&gt;protoc&lt;/code&gt; with PGV and the target language&#39;s default plugin will create &lt;code&gt;Validate&lt;/code&gt; methods on the generated types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p := new(Person)&#xA;&#xA;err := p.Validate() // err: Id must be greater than 999&#xA;p.Id = 1000&#xA;&#xA;err = p.Validate() // err: Email must be a valid email address&#xA;p.Email = &#34;example@lyft.com&#34;&#xA;&#xA;err = p.Validate() // err: Name must match pattern &#39;^[^\d\s]+( [^\d\s]+)*$&#39;&#xA;p.Name = &#34;Protocol Buffer&#34;&#xA;&#xA;err = p.Validate() // err: Home is required&#xA;p.Home = &amp;amp;Location{37.7, 999}&#xA;&#xA;err = p.Validate() // err: Home.Lng must be within [-180, 180]&#xA;p.Home.Lng = -122.4&#xA;&#xA;err = p.Validate() // err: nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;go&lt;/code&gt; toolchain (â‰¥ v1.7)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;protoc&lt;/code&gt; compiler in &lt;code&gt;$PATH&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;protoc-gen-validate&lt;/code&gt; in &lt;code&gt;$PATH&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;official language-specific plugin for target language(s)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Only &lt;code&gt;proto3&lt;/code&gt; syntax is currently supported.&lt;/strong&gt; &lt;code&gt;proto2&lt;/code&gt; syntax support is planned.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Installing PGV can currently only be done from source:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# fetches this repo into $GOPATH&#xA;go get -d github.com/envoyproxy/protoc-gen-validate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h4&gt;ðŸ’¡ Yes, our go module path is &lt;code&gt;github.com/envoyproxy/protoc-gen-validate&lt;/code&gt; &lt;strong&gt;not&lt;/strong&gt; &lt;code&gt;bufbuild&lt;/code&gt; this is intentional.&lt;/h4&gt; &#xA; &lt;p&gt;Changing the module path is effectively creating a new, independent module. We would prefer not to break our users. The Go team are working on better &lt;code&gt;cmd/go&lt;/code&gt; support for modules that change paths, but progress is slow. Until then, we will continue to use the &lt;code&gt;envoyproxy&lt;/code&gt; module path.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone github.com/bufbuild/protoc-gen-validate&#xA;# installs PGV into $GOPATH/bin&#xA;cd protoc-gen-validate &amp;amp;&amp;amp; make build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parameters&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;lang&lt;/code&gt;&lt;/strong&gt;: specify the target language to generate. Currently, the only supported options are: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;go&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;cc&lt;/code&gt; for c++ (partially implemented)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;java&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Note: Python works via runtime code generation. There&#39;s no compile-time generation. See the Python section for details.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;h4&gt;Go&lt;/h4&gt; &#xA;&lt;p&gt;Go generation should occur into the same output path as the official plugin. For a proto file &lt;code&gt;example.proto&lt;/code&gt;, the corresponding validation code is generated into &lt;code&gt;../generated/example.pb.validate.go&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;protoc \&#xA;  -I . \&#xA;  -I ${GOPATH}/src \&#xA;  -I ${GOPATH}/src/github.com/envoyproxy/protoc-gen-validate \&#xA;  --go_out=&#34;:../generated&#34; \&#xA;  --validate_out=&#34;lang=go:../generated&#34; \&#xA;  example.proto&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All messages generated include the following methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Validate() error&lt;/code&gt; which returns the first error encountered during validation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ValidateAll() error&lt;/code&gt; which returns all errors encountered during validation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;PGV requires no additional runtime dependencies from the existing generated code.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: by default &lt;strong&gt;example.pb.validate.go&lt;/strong&gt; is nested in a directory structure that matches your &lt;code&gt;option go_package&lt;/code&gt; name. You can change this using the protoc parameter &lt;code&gt;paths=source_relative:.&lt;/code&gt;. Then &lt;code&gt;--validate_out&lt;/code&gt; will output the file where it is expected. See Google&#39;s protobuf documentation or &lt;a href=&#34;https://github.com/golang/protobuf#packages-and-input-paths&#34;&gt;packages and input paths&lt;/a&gt; or &lt;a href=&#34;https://github.com/golang/protobuf#parameters&#34;&gt;parameters&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s also support for the &lt;code&gt;module=example.com/foo&lt;/code&gt; flag &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/go-generated#invocation&#34;&gt;described here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Java&lt;/h4&gt; &#xA;&lt;p&gt;Java generation is integrated with the existing protobuf toolchain for java projects. For Maven projects, add the following to your pom.xml or build.gradle.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;build.buf.protoc-gen-validate&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;pgv-java-stub&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;version&amp;gt;${pgv.version}&amp;lt;/version&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;&amp;lt;/dependencies&amp;gt;&#xA;&#xA;&amp;lt;build&amp;gt;&#xA;    &amp;lt;extensions&amp;gt;&#xA;        &amp;lt;extension&amp;gt;&#xA;            &amp;lt;groupId&amp;gt;kr.motd.maven&amp;lt;/groupId&amp;gt;&#xA;            &amp;lt;artifactId&amp;gt;os-maven-plugin&amp;lt;/artifactId&amp;gt;&#xA;            &amp;lt;version&amp;gt;1.4.1.Final&amp;lt;/version&amp;gt;&#xA;        &amp;lt;/extension&amp;gt;&#xA;    &amp;lt;/extensions&amp;gt;&#xA;    &amp;lt;plugins&amp;gt;&#xA;        &amp;lt;plugin&amp;gt;&#xA;            &amp;lt;groupId&amp;gt;org.xolstice.maven.plugins&amp;lt;/groupId&amp;gt;&#xA;            &amp;lt;artifactId&amp;gt;protobuf-maven-plugin&amp;lt;/artifactId&amp;gt;&#xA;            &amp;lt;version&amp;gt;0.6.1&amp;lt;/version&amp;gt;&#xA;            &amp;lt;configuration&amp;gt;&#xA;                &amp;lt;protocArtifact&amp;gt;com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}&amp;lt;/protocArtifact&amp;gt;&#xA;            &amp;lt;/configuration&amp;gt;&#xA;            &amp;lt;executions&amp;gt;&#xA;                &amp;lt;execution&amp;gt;&#xA;                    &amp;lt;id&amp;gt;protoc-java-pgv&amp;lt;/id&amp;gt;&#xA;                    &amp;lt;goals&amp;gt;&#xA;                        &amp;lt;goal&amp;gt;compile-custom&amp;lt;/goal&amp;gt;&#xA;                    &amp;lt;/goals&amp;gt;&#xA;                    &amp;lt;configuration&amp;gt;&#xA;                        &amp;lt;pluginParameter&amp;gt;lang=java&amp;lt;/pluginParameter&amp;gt;&#xA;                        &amp;lt;pluginId&amp;gt;java-pgv&amp;lt;/pluginId&amp;gt;&#xA;                        &amp;lt;pluginArtifact&amp;gt;build.buf.protoc-gen-validate:protoc-gen-validate:${pgv.version}:exe:${os.detected.classifier}&amp;lt;/pluginArtifact&amp;gt;&#xA;                    &amp;lt;/configuration&amp;gt;&#xA;                &amp;lt;/execution&amp;gt;&#xA;            &amp;lt;/executions&amp;gt;&#xA;        &amp;lt;/plugin&amp;gt;&#xA;    &amp;lt;/plugins&amp;gt;&#xA;&amp;lt;/build&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;plugins {&#xA;    ...&#xA;    id &#34;com.google.protobuf&#34; version &#34;${protobuf.version}&#34;&#xA;    ...&#xA;}&#xA;&#xA;protobuf {&#xA;    protoc {&#xA;        artifact = &#34;com.google.protobuf:protoc:${protoc.version}&#34;&#xA;    }&#xA;&#xA;    plugins {&#xA;        javapgv {&#xA;            artifact = &#34;build.buf.protoc-gen-validate:protoc-gen-validate:${pgv.version}&#34;&#xA;        }&#xA;    }&#xA;&#xA;    generateProtoTasks {&#xA;        all()*.plugins {&#xA;            javapgv {&#xA;                option &#34;lang=java&#34;&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Create a validator index that reflectively loads generated validators&#xA;ValidatorIndex index = new ReflectiveValidatorIndex();&#xA;// Assert that a message is valid&#xA;index.validatorFor(message.getClass()).assertValid(message);&#xA;&#xA;// Create a gRPC client and server interceptor to automatically validate messages (requires pgv-java-grpc module)&#xA;clientStub = clientStub.withInterceptors(new ValidatingClientInterceptor(index));&#xA;serverBuilder.addService(ServerInterceptors.intercept(svc, new ValidatingServerInterceptor(index)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Python&lt;/h4&gt; &#xA;&lt;p&gt;The python implementation works via JIT code generation. In other words, the &lt;code&gt;validate(msg)&lt;/code&gt; function is written on-demand and &lt;a href=&#34;https://docs.python.org/3/library/functions.html#exec&#34;&gt;exec-ed&lt;/a&gt;. An LRU-cache improves performance by storing generated functions per descriptor.&lt;/p&gt; &#xA;&lt;p&gt;The python package is available on &lt;a href=&#34;https://pypi.org/project/protoc-gen-validate&#34;&gt;PyPI&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To run &lt;code&gt;validate()&lt;/code&gt;, do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from entities_pb2 import Person&#xA;from protoc_gen_validate.validator import validate, ValidationFailed&#xA;&#xA;p = Person(first_name=&#34;Foo&#34;, last_name=&#34;Bar&#34;, age=42)&#xA;try:&#xA;    validate(p)&#xA;except ValidationFailed as err:&#xA;    print(err)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can view what code has been generated by using the &lt;code&gt;print_validate()&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;h2&gt;Constraint Rules&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bufbuild/protoc-gen-validate/main/validate/validate.proto&#34;&gt;The provided constraints&lt;/a&gt; are modeled largerly after those in JSON Schema. PGV rules can be mixed for the same field; the plugin ensures the rules applied to a field cannot contradict before code generation.&lt;/p&gt; &#xA;&lt;p&gt;Check the &lt;a href=&#34;https://raw.githubusercontent.com/bufbuild/protoc-gen-validate/main/rule_comparison.md&#34;&gt;constraint rule comparison matrix&lt;/a&gt; for language-specific constraint capabilities.&lt;/p&gt; &#xA;&lt;h3&gt;Numerics&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;All numeric types (&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;, &lt;code&gt;sint32&lt;/code&gt;, &lt;code&gt;sint64&lt;/code&gt;, &lt;code&gt;fixed32&lt;/code&gt;, &lt;code&gt;fixed64&lt;/code&gt;, &lt;code&gt;sfixed32&lt;/code&gt;, &lt;code&gt;sfixed64&lt;/code&gt;) share the same rules.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;: the field must be &lt;em&gt;exactly&lt;/em&gt; the specified value.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must equal 1.23 exactly&#xA;float x = 1 [(validate.rules).float.const = 1.23];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;lt/lte/gt/gte&lt;/strong&gt;: these inequalities (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, respectively) allow for deriving ranges in which the field must reside.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be less than 10&#xA;int32 x = 1 [(validate.rules).int32.lt = 10];&#xA;&#xA;// x must be greater than or equal to 20&#xA;uint64 x = 1 [(validate.rules).uint64.gte = 20];&#xA;&#xA;// x must be in the range [30, 40)&#xA;fixed32 x = 1 [(validate.rules).fixed32 = {gte:30, lt: 40}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Inverting the values of &lt;code&gt;lt(e)&lt;/code&gt; and &lt;code&gt;gt(e)&lt;/code&gt; is valid and creates an exclusive range.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be outside the range [30, 40)&#xA;double x = 1 [(validate.rules).double = {lt:30, gte:40}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;in/not_in&lt;/strong&gt;: these two rules permit specifying allow/denylists for the values of a field.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be either 1, 2, or 3&#xA;uint32 x = 1 [(validate.rules).uint32 = {in: [1,2,3]}];&#xA;&#xA;// x cannot be 0 nor 0.99&#xA;float x = 1 [(validate.rules).float = {not_in: [0, 0.99]}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;ignore_empty&lt;/strong&gt;: this rule specifies that if field is empty or set to the default value, to ignore any validation rules. These are typically useful where being able to unset a field in an update request, or to skip validation for optional fields where switching to WKTs is not feasible.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;unint32 x = 1 [(validate.rules).uint32 = {ignore_empty: true, gte: 200}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Bools&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;: the field must be &lt;em&gt;exactly&lt;/em&gt; the specified value.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be set to true&#xA;bool x = 1 [(validate.rules).bool.const = true];&#xA;&#xA;// x cannot be set to true&#xA;bool x = 1 [(validate.rules).bool.const = false];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Strings&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;: the field must be &lt;em&gt;exactly&lt;/em&gt; the specified value.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be set to &#34;foo&#34;&#xA;string x = 1 [(validate.rules).string.const = &#34;foo&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;len/min_len/max_len&lt;/strong&gt;: these rules constrain the number of characters (Unicode code points) in the field. Note that the number of characters may differ from the number of bytes in the string. The string is considered as-is, and does not normalize.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be exactly 5 characters long&#xA;string x = 1 [(validate.rules).string.len = 5];&#xA;&#xA;// x must be at least 3 characters long&#xA;string x = 1 [(validate.rules).string.min_len = 3];&#xA;&#xA;// x must be between 5 and 10 characters, inclusive&#xA;string x = 1 [(validate.rules).string = {min_len: 5, max_len: 10}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;min_bytes/max_bytes&lt;/strong&gt;: these rules constrain the number of bytes in the field.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be at most 15 bytes long&#xA;string x = 1 [(validate.rules).string.max_bytes = 15];&#xA;&#xA;// x must be between 128 and 1024 bytes long&#xA;string x = 1 [(validate.rules).string = {min_bytes: 128, max_bytes: 1024}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;pattern&lt;/strong&gt;: the field must match the specified &lt;a href=&#34;https://github.com/google/re2/wiki/Syntax&#34;&gt;RE2-compliant&lt;/a&gt; regular expression. The included expression should elide any delimiters (ie, &lt;code&gt;/\d+/&lt;/code&gt; should just be &lt;code&gt;\d+&lt;/code&gt;).&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be a non-empty, case-insensitive hexadecimal string&#xA;string x = 1 [(validate.rules).string.pattern = &#34;(?i)^[0-9a-f]+$&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;prefix/suffix/contains/not_contains&lt;/strong&gt;: the field must contain the specified substring in an optionally explicit location, or not contain the specified substring.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must begin with &#34;foo&#34;&#xA;string x = 1 [(validate.rules).string.prefix = &#34;foo&#34;];&#xA;&#xA;// x must end with &#34;bar&#34;&#xA;string x = 1 [(validate.rules).string.suffix = &#34;bar&#34;];&#xA;&#xA;// x must contain &#34;baz&#34; anywhere inside it&#xA;string x = 1 [(validate.rules).string.contains = &#34;baz&#34;];&#xA;&#xA;// x cannot contain &#34;baz&#34; anywhere inside it&#xA;string x = 1 [(validate.rules).string.not_contains = &#34;baz&#34;];&#xA;&#xA;// x must begin with &#34;fizz&#34; and end with &#34;buzz&#34;&#xA;string x = 1 [(validate.rules).string = {prefix: &#34;fizz&#34;, suffix: &#34;buzz&#34;}];&#xA;&#xA;// x must end with &#34;.proto&#34; and be less than 64 characters&#xA;string x = 1 [(validate.rules).string = {suffix: &#34;.proto&#34;, max_len:64}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;in/not_in&lt;/strong&gt;: these two rules permit specifying allow/denylists for the values of a field.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be either &#34;foo&#34;, &#34;bar&#34;, or &#34;baz&#34;&#xA;string x = 1 [(validate.rules).string = {in: [&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;]}];&#xA;&#xA;// x cannot be &#34;fizz&#34; nor &#34;buzz&#34;&#xA;string x = 1 [(validate.rules).string = {not_in: [&#34;fizz&#34;, &#34;buzz&#34;]}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;ignore_empty&lt;/strong&gt;: this rule specifies that if field is empty or set to the default value, to ignore any validation rules. These are typically useful where being able to unset a field in an update request, or to skip validation for optional fields where switching to WKTs is not feasible.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;string CountryCode = 1 [(validate.rules).string = {ignore_empty: true, len: 2}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;well-known formats&lt;/strong&gt;: these rules provide advanced constraints for common string patterns. These constraints will typically be more permissive and performant than equivalent regular expression patterns, while providing more explanatory failure descriptions.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be a valid email address (via RFC 5322)&#xA;string x = 1 [(validate.rules).string.email = true];&#xA;&#xA;// x must be a valid address (IP or Hostname).&#xA;string x = 1 [(validate.rules).string.address = true];&#xA;&#xA;// x must be a valid hostname (via RFC 1034)&#xA;string x = 1 [(validate.rules).string.hostname = true];&#xA;&#xA;// x must be a valid IP address (either v4 or v6)&#xA;string x = 1 [(validate.rules).string.ip = true];&#xA;&#xA;// x must be a valid IPv4 address&#xA;// eg: &#34;192.168.0.1&#34;&#xA;string x = 1 [(validate.rules).string.ipv4 = true];&#xA;&#xA;// x must be a valid IPv6 address&#xA;// eg: &#34;fe80::3&#34;&#xA;string x = 1 [(validate.rules).string.ipv6 = true];&#xA;&#xA;// x must be a valid absolute URI (via RFC 3986)&#xA;string x = 1 [(validate.rules).string.uri = true];&#xA;&#xA;// x must be a valid URI reference (either absolute or relative)&#xA;string x = 1 [(validate.rules).string.uri_ref = true];&#xA;&#xA;// x must be a valid UUID (via RFC 4122)&#xA;string x = 1 [(validate.rules).string.uuid = true];&#xA;&#xA;// x must conform to a well known regex for HTTP header names (via RFC 7230)&#xA;string x = 1 [(validate.rules).string.well_known_regex = HTTP_HEADER_NAME]&#xA;&#xA;// x must conform to a well known regex for HTTP header values (via RFC 7230) &#xA;string x = 1 [(validate.rules).string.well_known_regex = HTTP_HEADER_VALUE];&#xA;&#xA;// x must conform to a well known regex for headers, disallowing \r\n\0 characters.&#xA;string x = 1 [(validate.rules).string {well_known_regex: HTTP_HEADER_VALUE, strict: false}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Bytes&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Literal values should be expressed with strings, using escaping where necessary.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;: the field must be &lt;em&gt;exactly&lt;/em&gt; the specified value.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be set to &#34;foo&#34; (&#34;\x66\x6f\x6f&#34;)&#xA;bytes x = 1 [(validate.rules).bytes.const = &#34;foo&#34;];&#xA;&#xA;// x must be set to &#34;\xf0\x90\x28\xbc&#34;&#xA;bytes x = 1 [(validate.rules).bytes.const = &#34;\xf0\x90\x28\xbc&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;len/min_len/max_len&lt;/strong&gt;: these rules constrain the number of bytes in the field.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be exactly 3 bytes&#xA;bytes x = 1 [(validate.rules).bytes.len = 3];&#xA;&#xA;// x must be at least 3 bytes long&#xA;bytes x = 1 [(validate.rules).bytes.min_len = 3];&#xA;&#xA;// x must be between 5 and 10 bytes, inclusive&#xA;bytes x = 1 [(validate.rules).bytes = {min_len: 5, max_len: 10}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;pattern&lt;/strong&gt;: the field must match the specified &lt;a href=&#34;https://github.com/google/re2/wiki/Syntax&#34;&gt;RE2-compliant&lt;/a&gt; regular expression. The included expression should elide any delimiters (ie, &lt;code&gt;/\d+/&lt;/code&gt; should just be &lt;code&gt;\d+&lt;/code&gt;).&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be a non-empty, ASCII byte sequence&#xA;bytes x = 1 [(validate.rules).bytes.pattern = &#34;^[\x00-\x7F]+$&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;prefix/suffix/contains&lt;/strong&gt;: the field must contain the specified byte sequence in an optionally explicit location.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must begin with &#34;\x99&#34;&#xA;bytes x = 1 [(validate.rules).bytes.prefix = &#34;\x99&#34;];&#xA;&#xA;// x must end with &#34;buz\x7a&#34;&#xA;bytes x = 1 [(validate.rules).bytes.suffix = &#34;buz\x7a&#34;];&#xA;&#xA;// x must contain &#34;baz&#34; anywhere inside it&#xA;bytes x = 1 [(validate.rules).bytes.contains = &#34;baz&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;in/not_in&lt;/strong&gt;: these two rules permit specifying allow/denylists for the values of a field.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be either &#34;foo&#34;, &#34;bar&#34;, or &#34;baz&#34;&#xA;bytes x = 1 [(validate.rules).bytes = {in: [&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;]}];&#xA;&#xA;// x cannot be &#34;fizz&#34; nor &#34;buzz&#34;&#xA;bytes x = 1 [(validate.rules).bytes = {not_in: [&#34;fizz&#34;, &#34;buzz&#34;]}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;ignore_empty&lt;/strong&gt;: this rule specifies that if field is empty or set to the default value, to ignore any validation rules. These are typically useful where being able to unset a field in an update request, or to skip validation for optional fields where switching to WKTs is not feasible.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;bytes x = 1 [(validate.rules).bytes = {ignore_empty: true, in: [&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;]}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;well-known formats&lt;/strong&gt;: these rules provide advanced constraints for common patterns. These constraints will typically be more permissive and performant than equivalent regular expression patterns, while providing more explanatory failure descriptions.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be a valid IP address (either v4 or v6) in byte format&#xA;bytes x = 1 [(validate.rules).bytes.ip = true];&#xA;&#xA;// x must be a valid IPv4 address in byte format&#xA;// eg: &#34;\xC0\xA8\x00\x01&#34;&#xA;bytes x = 1 [(validate.rules).bytes.ipv4 = true];&#xA;&#xA;// x must be a valid IPv6 address in byte format&#xA;// eg: &#34;\x20\x01\x0D\xB8\x85\xA3\x00\x00\x00\x00\x8A\x2E\x03\x70\x73\x34&#34;&#xA;bytes x = 1 [(validate.rules).bytes.ipv6 = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Enums&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;All literal values should use the numeric (int32) value as defined in the enum descriptor.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The following examples use this &lt;code&gt;State&lt;/code&gt; enum&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;enum State {&#xA;  INACTIVE = 0;&#xA;  PENDING  = 1;&#xA;  ACTIVE   = 2;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;: the field must be &lt;em&gt;exactly&lt;/em&gt; the specified value.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be set to ACTIVE (2)&#xA;State x = 1 [(validate.rules).enum.const = 2];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;defined_only&lt;/strong&gt;: the field must be one of the specified values in the enum descriptor.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x can only be INACTIVE, PENDING, or ACTIVE&#xA;State x = 1 [(validate.rules).enum.defined_only = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;in/not_in&lt;/strong&gt;: these two rules permit specifying allow/denylists for the values of a field.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be either INACTIVE (0) or ACTIVE (2)&#xA;State x = 1 [(validate.rules).enum = {in: [0,2]}];&#xA;&#xA;// x cannot be PENDING (1)&#xA;State x = 1 [(validate.rules).enum = {not_in: [1]}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Messages&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If a field contains a message and the message has been generated with PGV, validation will be performed recursively. Message&#39;s not generated with PGV are skipped.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// if Person was generated with PGV and x is set,&#xA;// x&#39;s fields will be validated.&#xA;Person x = 1;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;skip&lt;/strong&gt;: this rule specifies that the validation rules of this field should not be evaluated.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// The fields on Person x will not be validated.&#xA;Person x = 1 [(validate.rules).message.skip = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;required&lt;/strong&gt;: this rule specifies that the field cannot be unset.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x cannot be unset&#xA;Person x = 1 [(validate.rules).message.required = true];&#xA;&#xA;// x cannot be unset, but the validations on x will not be performed&#xA;Person x = 1 [(validate.rules).message = {required: true, skip: true}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Repeated&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;min_items/max_items&lt;/strong&gt;: these rules control how many elements are contained in the field&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must contain at least 3 elements&#xA;repeated int32 x = 1 [(validate.rules).repeated.min_items = 3];&#xA;&#xA;// x must contain between 5 and 10 Persons, inclusive&#xA;repeated Person x = 1 [(validate.rules).repeated = {min_items: 5, max_items: 10}];&#xA;&#xA;// x must contain exactly 7 elements&#xA;repeated double x = 1 [(validate.rules).repeated = {min_items: 7, max_items: 7}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;unique&lt;/strong&gt;: this rule requires that all elements in the field must be unique. This rule does not support repeated messages.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must contain unique int64 values&#xA;repeated int64 x = 1 [(validate.rules).repeated.unique = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;items&lt;/strong&gt;: this rule specifies constraints that should be applied to each element in the field. Repeated message fields also have their validation rules applied unless &lt;code&gt;skip&lt;/code&gt; is specified on this constraint.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must contain positive float values&#xA;repeated float x = 1 [(validate.rules).repeated.items.float.gt = 0];&#xA;&#xA;// x must contain Persons but don&#39;t validate them&#xA;repeated Person x = 1 [(validate.rules).repeated.items.message.skip = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;ignore_empty&lt;/strong&gt;: this rule specifies that if field is empty or set to the default value, to ignore any validation rules. These are typically useful where being able to unset a field in an update request, or to skip validation for optional fields where switching to WKTs is not feasible.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;repeated int64 x = 1 [(validate.rules).repeated = {ignore_empty: true, items: {int64: {gt: 200}}}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Maps&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;min_pairs/max_pairs&lt;/strong&gt;: these rules control how many KV pairs are contained in this field&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must contain at least 3 KV pairs&#xA;map&amp;lt;string, uint64&amp;gt; x = 1 [(validate.rules).map.min_pairs = 3];&#xA;&#xA;// x must contain between 5 and 10 KV pairs&#xA;map&amp;lt;string, string&amp;gt; x = 1 [(validate.rules).map = {min_pairs: 5, max_pairs: 10}];&#xA;&#xA;// x must contain exactly 7 KV pairs&#xA;map&amp;lt;string, Person&amp;gt; x = 1 [(validate.rules).map = {min_pairs: 7, max_pairs: 7}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;no_sparse&lt;/strong&gt;: for map fields with message values, setting this rule to true disallows keys with unset values.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// all values in x must be set&#xA;map&amp;lt;uint64, Person&amp;gt; x = 1 [(validate.rules).map.no_sparse = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;keys&lt;/strong&gt;: this rule specifies constraints that are applied to the keys in the field.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x&#39;s keys must all be negative&#xA;&amp;lt;sint32, string&amp;gt; x = [(validate.rules).map.keys.sint32.lt = 0];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;values&lt;/strong&gt;: this rule specifies constraints that are be applied to each value in the field. Repeated message fields also have their validation rules applied unless &lt;code&gt;skip&lt;/code&gt; is specified on this constraint.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must contain strings of at least 3 characters&#xA;map&amp;lt;string, string&amp;gt; x = 1 [(validate.rules).map.values.string.min_len = 3];&#xA;&#xA;// x must contain Persons but doesn&#39;t validate them&#xA;map&amp;lt;string, Person&amp;gt; x = 1 [(validate.rules).map.values.message.skip = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;ignore_empty&lt;/strong&gt;: this rule specifies that if field is empty or set to the default value, to ignore any validation rules. These are typically useful where being able to unset a field in an update request, or to skip validation for optional fields where switching to WKTs is not feasible.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;map&amp;lt;string, string&amp;gt; x = 1 [(validate.rules).map = {ignore_empty: true, values: {string: {min_len: 3}}}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Well-Known Types (WKTs)&lt;/h3&gt; &#xA;&lt;p&gt;A set of &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/google.protobuf&#34;&gt;WKTs&lt;/a&gt; are packaged with protoc and common message patterns useful in many domains.&lt;/p&gt; &#xA;&lt;h4&gt;Scalar Value Wrappers&lt;/h4&gt; &#xA;&lt;p&gt;In the &lt;code&gt;proto3&lt;/code&gt; syntax, there is no way of distinguishing between unset and the zero value of a scalar field. The value WKTs permit this differentiation by wrapping them in a message. PGV permits using the same scalar rules that the wrapper encapsulates.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// if it is set, x must be greater than 3&#xA;google.protobuf.Int32Value x = 1 [(validate.rules).int32.gt = 3];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Message Rules can also be used with scalar Well-Known Types (WKTs):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// Ensures that if a value is not set for age, it would not pass the validation despite its zero value being 0.&#xA;message X { google.protobuf.Int32Value age = 1 [(validate.rules).int32.gt = -1, (validate.rules).message.required = true]; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Anys&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;required&lt;/strong&gt;: this rule specifies that the field must be set&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x cannot be unset&#xA;google.protobuf.Any x = 1 [(validate.rules).any.required = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;in/not_in&lt;/strong&gt;: these two rules permit specifying allow/denylists for the &lt;code&gt;type_url&lt;/code&gt; value in this field. Consider using a &lt;code&gt;oneof&lt;/code&gt; union instead of &lt;code&gt;in&lt;/code&gt; if possible.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must not be the Duration or Timestamp WKT&#xA;google.protobuf.Any x = 1 [(validate.rules).any = {not_in: [&#xA;    &#34;type.googleapis.com/google.protobuf.Duration&#34;,&#xA;    &#34;type.googleapis.com/google.protobuf.Timestamp&#34;&#xA;  ]}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Durations&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;required&lt;/strong&gt;: this rule specifies that the field must be set&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x cannot be unset&#xA;google.protobuf.Duration x = 1 [(validate.rules).duration.required = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;: the field must be &lt;em&gt;exactly&lt;/em&gt; the specified value.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must equal 1.5s exactly&#xA;google.protobuf.Duration x = 1 [(validate.rules).duration.const = {&#xA;    seconds: 1,&#xA;    nanos:   500000000&#xA;  }];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;lt/lte/gt/gte&lt;/strong&gt;: these inequalities (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, respectively) allow for deriving ranges in which the field must reside.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be less than 10s&#xA;google.protobuf.Duration x = 1 [(validate.rules).duration.lt.seconds = 10];&#xA;&#xA;// x must be greater than or equal to 20ns&#xA;google.protobuf.Duration x = 1 [(validate.rules).duration.gte.nanos = 20];&#xA;&#xA;// x must be in the range [0s, 1s)&#xA;google.protobuf.Duration x = 1 [(validate.rules).duration = {&#xA;    gte: {},&#xA;    lt:  {seconds: 1}&#xA;  }];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Inverting the values of &lt;code&gt;lt(e)&lt;/code&gt; and &lt;code&gt;gt(e)&lt;/code&gt; is valid and creates an exclusive range.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be outside the range [0s, 1s)&#xA;google.protobuf.Duration x = 1 [(validate.rules).duration = {&#xA;    lt:  {},&#xA;    gte: {seconds: 1}&#xA;  }];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;in/not_in&lt;/strong&gt;: these two rules permit specifying allow/denylists for the values of a field.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be either 0s or 1s&#xA;google.protobuf.Duration x = 1 [(validate.rules).duration = {in: [&#xA;    {},&#xA;    {seconds: 1}&#xA;  ]}];&#xA;&#xA;// x cannot be 20s nor 500ns&#xA;google.protobuf.Duration x = 1 [(validate.rules).duration = {not_in: [&#xA;    {seconds: 20},&#xA;    {nanos: 500}&#xA;  ]}];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Timestamps&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;required&lt;/strong&gt;: this rule specifies that the field must be set&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x cannot be unset&#xA;google.protobuf.Timestamp x = 1 [(validate.rules).timestamp.required = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;: the field must be &lt;em&gt;exactly&lt;/em&gt; the specified value.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must equal 2009/11/10T23:00:00.500Z exactly&#xA;google.protobuf.Timestamp x = 1 [(validate.rules).timestamp.const = {&#xA;    seconds: 63393490800,&#xA;    nanos:   500000000&#xA;  }];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;lt/lte/gt/gte&lt;/strong&gt;: these inequalities (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, respectively) allow for deriving ranges in which the field must reside.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be less than the Unix Epoch&#xA;google.protobuf.Timestamp x = 1 [(validate.rules).timestamp.lt.seconds = 0];&#xA;&#xA;// x must be greater than or equal to 2009/11/10T23:00:00Z&#xA;google.protobuf.Timestamp x = 1 [(validate.rules).timestamp.gte.seconds = 63393490800];&#xA;&#xA;// x must be in the range [epoch, 2009/11/10T23:00:00Z)&#xA;google.protobuf.Timestamp x = 1 [(validate.rules).timestamp = {&#xA;    gte: {},&#xA;    lt:  {seconds: 63393490800}&#xA;  }];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Inverting the values of &lt;code&gt;lt(e)&lt;/code&gt; and &lt;code&gt;gt(e)&lt;/code&gt; is valid and creates an exclusive range.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be outside the range [epoch, 2009/11/10T23:00:00Z)&#xA;google.protobuf.Timestamp x = 1 [(validate.rules).timestamp = {&#xA;    lt:  {},&#xA;    gte: {seconds: 63393490800}&#xA;  }];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;lt_now/gt_now&lt;/strong&gt;: these inequalities allow for ranges relative to the current time. These rules cannot be used with the absolute rules above.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be less than the current timestamp&#xA;google.protobuf.Timestamp x = 1 [(validate.rules).timestamp.lt_now = true];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;within&lt;/strong&gt;: this rule specifies that the field&#39;s value should be within a duration of the current time. This rule can be used in conjunction with &lt;code&gt;lt_now&lt;/code&gt; and &lt;code&gt;gt_now&lt;/code&gt; to control those ranges.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// x must be within Â±1s of the current time&#xA;google.protobuf.Timestamp x = 1 [(validate.rules).timestamp.within.seconds = 1];&#xA;&#xA;// x must be within the range (now, now+1h)&#xA;google.protobuf.Timestamp x = 1 [(validate.rules).timestamp = {&#xA;    gt_now: true,&#xA;    within: {seconds: 3600}&#xA;  }];&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Message-Global&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;disabled&lt;/strong&gt;: All validation rules for the fields on a message can be nullified, including any message fields that support validation themselves.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;message Person {&#xA;  option (validate.disabled) = true;&#xA;&#xA;  // x will not be required to be greater than 123&#xA;  uint64 x = 1 [(validate.rules).uint64.gt = 123];&#xA;&#xA;  // y&#39;s fields will not be validated&#xA;  Person y = 2;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;ignored&lt;/strong&gt;: Don&#39;t generate a validate method or any related validation code for this message.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;message Person {&#xA;  option (validate.ignored) = true;&#xA;&#xA;  // x will not be required to be greater than 123&#xA;  uint64 x = 1 [(validate.rules).uint64.gt = 123];&#xA;&#xA;  // y&#39;s fields will not be validated&#xA;  Person y = 2;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;OneOfs&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;required&lt;/strong&gt;: require that one of the fields in a &lt;code&gt;oneof&lt;/code&gt; must be set. By default, none or one of the unioned fields can be set. Enabling this rules disallows having all of them unset.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;oneof id {&#xA;  // either x, y, or z must be set.&#xA;  option (validate.required) = true;&#xA;&#xA;  string x = 1;&#xA;  int32  y = 2;&#xA;  Person z = 3;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;PGV is written in Go on top of the &lt;a href=&#34;https://github.com/lyft/protoc-gen-star&#34;&gt;protoc-gen-star&lt;/a&gt; framework and compiles to a standalone binary.&lt;/p&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;All PGV dependencies are currently checked into the project. To test PGV, &lt;code&gt;protoc&lt;/code&gt; must be installed, either from &lt;a href=&#34;https://github.com/google/protobuf&#34;&gt;source&lt;/a&gt;, the provided &lt;a href=&#34;https://github.com/google/protobuf/releases&#34;&gt;releases&lt;/a&gt;, or a package manager. The official protoc plugin for the target language(s) should be installed as well.&lt;/p&gt; &#xA;&lt;h3&gt;Make Targets&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;make build&lt;/code&gt;&lt;/strong&gt;: generates the constraints proto and compiles PGV into &lt;code&gt;$GOPATH/bin&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;make lint&lt;/code&gt;&lt;/strong&gt;: runs static-analysis rules against the PGV codebase, including &lt;code&gt;golint&lt;/code&gt;, &lt;code&gt;go vet&lt;/code&gt;, and &lt;code&gt;gofmt -s&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;make testcases&lt;/code&gt;&lt;/strong&gt;: generates the proto files in &lt;a href=&#34;https://raw.githubusercontent.com/bufbuild/protoc-gen-validate/main/tests/harness/cases&#34;&gt;&lt;code&gt;/tests/harness/cases&lt;/code&gt;&lt;/a&gt;. These are used by the test harness to verify the validation rules generated for each language.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;make harness&lt;/code&gt;&lt;/strong&gt;: executes the test-cases against each language&#39;s test harness.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Run all tests under Bazel&lt;/h3&gt; &#xA;&lt;p&gt;Ensure that your &lt;code&gt;PATH&lt;/code&gt; is setup to include &lt;code&gt;protoc-gen-go&lt;/code&gt; and &lt;code&gt;protoc&lt;/code&gt;, then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bazel test //tests/...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;p&gt;PGV comes with a &lt;a href=&#34;https://raw.githubusercontent.com/bufbuild/protoc-gen-validate/main/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt; for consistent development tooling and CI. The main entrypoint is &lt;code&gt;make&lt;/code&gt; with &lt;code&gt;quick&lt;/code&gt; as the default target. This repo should be volumed into &lt;code&gt;/go/src/github.com/envoyproxy/protoc-gen-validate&lt;/code&gt; for the proper behavior.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# build the image&#xA;docker build -t lyft/protoc-gen-validate .&#xA;&#xA;# executes the default make target: quick&#xA;docker run --rm \&#xA;  -v $(PWD):/go/src/github.com/envoyproxy/protoc-gen-validate \&#xA;  lyft/protoc-gen-validate&#xA;&#xA;# executes the &#39;build&#39; &amp;amp; &#39;generate-testdata&#39; make targets&#xA;docker run --rm \&#xA;  -v $(PWD):/go/src/github.com/envoyproxy/protoc-gen-validate \&#xA;  lyft/protoc-gen-validate \&#xA;  build generate-testdata&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>