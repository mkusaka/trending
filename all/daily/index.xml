<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-02T01:30:02Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>libevm/subway</title>
    <updated>2022-07-02T01:30:02Z</updated>
    <id>tag:github.com,2022-07-02:/libevm/subway</id>
    <link href="https://github.com/libevm/subway" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A practical example on how to perform sandwich attacks on Ethereum&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Subway&lt;/h1&gt; &#xA;&lt;p&gt;A practical example on how to perform sandwich attacks on UniswapV2 pairs.&lt;/p&gt; &#xA;&lt;p&gt;Having highly optimized contracts is just one part of the equation, a tech stack is just as important as the contracts to execute on the opportunities.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/95674753/145967796-6c2c8925-fb5c-41d4-a64f-a22ce8701ce6.mp4&#34;&gt;https://user-images.githubusercontent.com/95674753/145967796-6c2c8925-fb5c-41d4-a64f-a22ce8701ce6.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The contracts are written in Yul+ and Solidity, and contains the &lt;strong&gt;bare minimum&lt;/strong&gt; needed to perform a sandwich attack (i.e. &lt;code&gt;swap&lt;/code&gt; and &lt;code&gt;transfer&lt;/code&gt;). &lt;strong&gt;They do NOT protect against &lt;a href=&#34;https://twitter.com/bertcmiller/status/1385294417091760134&#34;&gt;uncle bandit attacks&lt;/a&gt; so use at your own risk.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The goal of this bot is to act as a low barrier of entry, reference source code for aspiring new searchers (hence, JavaScript). This bot contains:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;read from the mempool&lt;/li&gt; &#xA; &lt;li&gt;decode transaction data&lt;/li&gt; &#xA; &lt;li&gt;simple logging system&lt;/li&gt; &#xA; &lt;li&gt;profit calculation algos&lt;/li&gt; &#xA; &lt;li&gt;gas bribe calculation&lt;/li&gt; &#xA; &lt;li&gt;bundle firing&lt;/li&gt; &#xA; &lt;li&gt;misc &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;doing math in JS&lt;/li&gt; &#xA;   &lt;li&gt;calculating next base fee&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;While the bot is functional, the bot logic is a very simplistic one and does not contain a lot of the features that many advance searchers have (but not including), such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;circuit breakers&lt;/li&gt; &#xA; &lt;li&gt;poison token checker&lt;/li&gt; &#xA; &lt;li&gt;caching system&lt;/li&gt; &#xA; &lt;li&gt;robust logging system (e.g. graphana)&lt;/li&gt; &#xA; &lt;li&gt;various gas saving ALPHAs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As such, this bot is intended as a piece of educational content, and not for production use.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ccyanxyz/uniswap-arbitrage-analysis</title>
    <updated>2022-07-02T01:30:02Z</updated>
    <id>tag:github.com,2022-07-02:/ccyanxyz/uniswap-arbitrage-analysis</id>
    <link href="https://github.com/ccyanxyz/uniswap-arbitrage-analysis" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Uniswap arbitrage problem analysis&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Uniswap Arbitrage Analysis&lt;/h1&gt; &#xA;&lt;h2&gt;See readme_en.pdf&lt;/h2&gt; &#xA;&lt;h3&gt;0.Foreword&lt;/h3&gt; &#xA;&lt;p&gt;â€‹ Uniswap is the most popular dex with more than 11000 trading pairs and 2B dollars liquidity. Where there is a market, there are arbitrage opportunities. On uniswap we can trade coin A for coin D follow a given path, e.g. A-&amp;gt;B-&amp;gt;C-&amp;gt;D, A and D can also be the same coin, which means, you can trade A for A follow a given path, and if you are lucky, you can get more A than the original input amount! So how do we find such a path and determine the optimal input amount for maximum profit? Here we go:&lt;/p&gt; &#xA;&lt;h3&gt;1.Arbitrage problem alalysis&lt;/h3&gt; &#xA;&lt;p&gt;In order to perform an arbitrage, we need to figure out 2 things:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;How to find the best path: from A-&amp;gt;?-&amp;gt;?-&amp;gt;...-&amp;gt;A&lt;/li&gt; &#xA; &lt;li&gt;How to find the optimal input amount?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;1.1 Path finding&lt;/h4&gt; &#xA;&lt;p&gt;Each coin is a vertex of a graph, and each trading pair is an edge in the graph, now the problem is how to find a circle in such a graph? This is a classic graph problem, we can use depth first search(DFS) to solve it, with DFS, we can also control the max path length, which is import for an arbitrage since longer path requires more gas! Here is a sample code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def findArb(pairs, tokenIn, tokenOut, maxHops, currentPairs, path, circles):&#xA;    for i in range(len(pairs)):&#xA;        newPath = path.copy()&#xA;        pair = pairs[i]&#xA;        if not pair[&#39;token0&#39;][&#39;address&#39;] == tokenIn[&#39;address&#39;] and not pair[&#39;token1&#39;][&#39;address&#39;] == tokenIn[&#39;address&#39;]:&#xA;            continue&#xA;        if pair[&#39;reserve0&#39;]/pow(10, pair[&#39;token0&#39;][&#39;decimal&#39;]) &amp;lt; 1 or pair[&#39;reserve1&#39;]/pow(10, pair[&#39;token1&#39;][&#39;decimal&#39;]) &amp;lt; 1:&#xA;            continue&#xA;        if tokenIn[&#39;address&#39;] == pair[&#39;token0&#39;][&#39;address&#39;]:&#xA;            tempOut = pair[&#39;token1&#39;]&#xA;        else:&#xA;            tempOut = pair[&#39;token0&#39;]&#xA;        newPath.append(tempOut)&#xA;        if tempOut[&#39;address&#39;] == tokenOut[&#39;address&#39;] and len(path) &amp;gt; 2:&#xA;          &#x9;c = { &#39;route&#39;: currentPairs, &#39;path&#39;: newPath }&#xA;            circles.append(c)&#xA;        elif maxHops &amp;gt; 1 and len(pairs) &amp;gt; 1:&#xA;            pairsExcludingThisPair = pairs[:i] + pairs[i+1:]&#xA;            circles = findArb(pairsExcludingThisPair, tempOut, tokenOut, maxHops-1, currentPairs + [pair], newPath, circles)&#xA;    return circles&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;1.2 Optimal input amount&lt;/h4&gt; &#xA;&lt;p&gt;Let&#39;s do a little recap on the uniswap constant function market maker(CFMM) model, assume there is a trading pair for coin A and B, reserve for A is $R_0$, reserve for B is $R_1$, now we use ${\Delta}_a$ amount of A to trade for $\Delta_b$ amount of B, assume the fee is $1-r$, the following equation holds:&lt;/p&gt; &#xA;&lt;p&gt;$(R_0 + r\Delta_a)(R_1 - \Delta_b) = R_0R_1$&lt;/p&gt; &#xA;&lt;p&gt;The equation means that the product of the reserves $R_0R_1$ remains constant during the trade, this is why we call it constant function market maker.&lt;/p&gt; &#xA;&lt;p&gt;Now assume we have found a circle path: A-&amp;gt;B-&amp;gt;C-&amp;gt;A, how do we find the optimal input amount? This is an optimization problem: $$ \begin{align} &amp;amp; max ({\Delta_a}&#39; - \Delta_a) \\ &amp;amp; s.t. \ &amp;amp; R_n &amp;gt; 0, \Delta_n &amp;gt; 0 \\ &amp;amp; (R_0 + r\Delta_a)(R_1 - \Delta_b) = R_0R_1 \tag1 \\ &amp;amp; ({R_1}&#39; + r\Delta_b)(R_2 - \Delta_c) = {R_1}&#39;R_2 \tag2 \\ &amp;amp; ({R_2}&#39; + r\Delta_c)(R_3 - {\Delta_a}&#39;) = {R_2}&#39;{R_1}&#39; \tag3 \end{align} $$ Equation (1) holds during the trade from A to B, (2) holds during the trade from B to C, and (3) holds during the trade from C to A. It seems pretty simple since we only have 3 equations now, we can get the representation for ${\Delta_a}&#39;$ in ${\Delta_a}$, then calculate the derivative of ${\Delta_a}&#39; - \Delta_a$ to find out what the optimal ${\Delta_a}$ is.&lt;/p&gt; &#xA;&lt;p&gt;What if the path is longer? A-&amp;gt;B-&amp;gt;C-&amp;gt;...-&amp;gt;A. We need a general solution for arbitrary length path.&lt;/p&gt; &#xA;&lt;p&gt;Consider the A-&amp;gt;B-&amp;gt;C situation, maybe there is not a trading pair directly from A to C, but with B as the bridge, we can trade A for C, we say there is a &lt;strong&gt;virtual&lt;/strong&gt; trading pool for A and C, can we get the reserves parameter $E_0, E_1$ for this virtual pool?&lt;/p&gt; &#xA;&lt;p&gt;All we need to do is find the representation for $E_0, E_1$ in $R_0, R_1, {R_1}&#39;, R_2$, i.e. the pool parameters of A-&amp;gt;B and B-&amp;gt;C.&lt;/p&gt; &#xA;&lt;p&gt;According to equation(1)(2), we have: $$ \Delta_b = \frac{R_1r\Delta_a}{R_0+r\Delta_a} \tag4 $$&lt;/p&gt; &#xA;&lt;p&gt;$$ \Delta_c = \frac{R_2r\Delta_b}{{R_1}&#39;+r\Delta_b} \tag5 $$&lt;/p&gt; &#xA;&lt;p&gt;Replace $\Delta_b$ in (5) using (4), we have: $$ \Delta_c = \frac{\frac{rR_1R_2}{{R_1}&#39;+R_1r}r\Delta_a}{\frac{R_0{R_1}&#39;}{{R_1}&#39;+R_1r}+r\Delta_a} \tag6 $$ Comparing the form of (6) and (4) or (6) and (5), we have: $$ E_0 = \frac{R_0{R_1}&#39;}{{R_1}&#39;+R_1r} $$&lt;/p&gt; &#xA;&lt;p&gt;$$ E_1 = \frac{rR_1R_2}{{R_1}&#39;+R_1r} $$&lt;/p&gt; &#xA;&lt;p&gt;Now we have the parameters for virtual pool A-&amp;gt;C, consider the path A-&amp;gt;B-&amp;gt;C-&amp;gt;A, with the virtual pool, the path is now: A-&amp;gt;C-&amp;gt;A, we can further calculate the parameters for A-&amp;gt;A, say $E_a, E_b$, if $E_a &amp;lt; E_b$, then there is an arbitrage opportunity. For arbitrary length path, we can calculate $E_a, E_b$ iteratively.&lt;/p&gt; &#xA;&lt;p&gt;Now we have the parameters $E_a, E_b$ for this virtual pool from A-&amp;gt;A constructed from the given path, we have: $$ \begin{align} &amp;amp; {\Delta_a}&#39; = \frac{E_ar\Delta_a}{E_0+r\Delta_a} \ &amp;amp; f = {\Delta_a}&#39; - \Delta_a \end{align} $$ Here $f$ is our profit, calculate its derivative, we can find the optimal input amount: $$ \Delta_a = \frac{\sqrt{E_aE_br}-E_a}{r} $$ Code for path finding with optimal input amount calculation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def findArb(pairs, tokenIn, tokenOut, maxHops, currentPairs, path, bestTrades, count=5):&#xA;    for i in range(len(pairs)):&#xA;        newPath = path.copy()&#xA;        pair = pairs[i]&#xA;        if not pair[&#39;token0&#39;][&#39;address&#39;] == tokenIn[&#39;address&#39;] and not pair[&#39;token1&#39;][&#39;address&#39;] == tokenIn[&#39;address&#39;]:&#xA;            continue&#xA;        if pair[&#39;reserve0&#39;]/pow(10, pair[&#39;token0&#39;][&#39;decimal&#39;]) &amp;lt; 1 or pair[&#39;reserve1&#39;]/pow(10, pair[&#39;token1&#39;][&#39;decimal&#39;]) &amp;lt; 1:&#xA;            continue&#xA;        if tokenIn[&#39;address&#39;] == pair[&#39;token0&#39;][&#39;address&#39;]:&#xA;            tempOut = pair[&#39;token1&#39;]&#xA;        else:&#xA;            tempOut = pair[&#39;token0&#39;]&#xA;        newPath.append(tempOut)&#xA;        if tempOut[&#39;address&#39;] == tokenOut[&#39;address&#39;] and len(path) &amp;gt; 2:&#xA;            Ea, Eb = getEaEb(tokenOut, currentPairs + [pair])&#xA;            newTrade = { &#39;route&#39;: currentPairs + [pair], &#39;path&#39;: newPath, &#39;Ea&#39;: Ea, &#39;Eb&#39;: Eb }&#xA;            if Ea and Eb and Ea &amp;lt; Eb:&#xA;                newTrade[&#39;optimalAmount&#39;] = getOptimalAmount(Ea, Eb)&#xA;                if newTrade[&#39;optimalAmount&#39;] &amp;gt; 0:&#xA;                    newTrade[&#39;outputAmount&#39;] = getAmountOut(newTrade[&#39;optimalAmount&#39;], Ea, Eb)&#xA;                    newTrade[&#39;profit&#39;] = newTrade[&#39;outputAmount&#39;]-newTrade[&#39;optimalAmount&#39;]&#xA;                    newTrade[&#39;p&#39;] = int(newTrade[&#39;profit&#39;])/pow(10, tokenOut[&#39;decimal&#39;])&#xA;                else:&#xA;                    continue&#xA;                bestTrades = sortTrades(bestTrades, newTrade)&#xA;                bestTrades.reverse()&#xA;                bestTrades = bestTrades[:count]&#xA;        elif maxHops &amp;gt; 1 and len(pairs) &amp;gt; 1:&#xA;            pairsExcludingThisPair = pairs[:i] + pairs[i+1:]&#xA;            bestTrades = findArb(pairsExcludingThisPair, tempOut, tokenOut, maxHops-1, currentPairs + [pair], newPath, bestTrades, count)&#xA;    return bestTrades&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2. Implementation&lt;/h3&gt; &#xA;&lt;p&gt;Ethereum block interval is 15 seconds, you have to do 3 things in 15 seconds:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update the reserves of each trading pair: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Small amount of trading pairs: batch request for the states of all trading pairs&lt;/li&gt; &#xA;   &lt;li&gt;Large amount of trading pairs: batch request, then parse every new block, if there is a event in (Swap, Sync, Mint, Burn), update the related pair reserves.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Find the best path and optimal input amount: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Optimize DFS, explore other algorithms like bellman-ford, spfa, etc.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Send the transaction: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Call UniswapV2Router02.getAmountsOut before you send your tx, confirm that you can really make a profit.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;My test:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ccyanxyz/uniswap-arbitrage-analysis/master/test.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Didn&#39;t cover the gas fee though :(&lt;/p&gt; &#xA;&lt;h3&gt;3.Finally&lt;/h3&gt; &#xA;&lt;p&gt;Uniswap arbitrage is a competitive area, you may find it hard to make profit, but still, Defi is the haven for arbitraguers, you can also arbitrage between different exchanges like curve.fi, balancer.exchange, with flashloans, you can even borrow money to make arbitrage! Happy hacking :)&lt;/p&gt; &#xA;&lt;p&gt;Contact: &lt;a href=&#34;mailto:ccyanxyz@gmail.com&#34;&gt;ccyanxyz@gmail.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Donation: 0x0af66d3641640755878F0d72A610FC2EEA856Cd6&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>laravel/vite-plugin</title>
    <updated>2022-07-02T01:30:02Z</updated>
    <id>tag:github.com,2022-07-02:/laravel/vite-plugin</id>
    <link href="https://github.com/laravel/vite-plugin" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Laravel plugin for Vite.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Laravel Vite Plugin&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/laravel/vite-plugin/actions&#34;&gt;&lt;img src=&#34;https://github.com/laravel/vite-plugin/workflows/tests/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.npmjs.com/package/laravel-vite-plugin&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/dt/laravel-vite-plugin&#34; alt=&#34;Total Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.npmjs.com/package/laravel-vite-plugin&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/v/laravel-vite-plugin&#34; alt=&#34;Latest Stable Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.npmjs.com/package/laravel-vite-plugin&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/l/laravel-vite-plugin&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Vite is a modern frontend build tool that provides an extremely fast development environment and bundles your code for production.&lt;/p&gt; &#xA;&lt;p&gt;This plugin configures Vite for use with a Laravel backend server.&lt;/p&gt; &#xA;&lt;h2&gt;Official Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Documentation for the Laravel Vite plugin can be found on the &lt;a href=&#34;https://laravel.com/docs/vite&#34;&gt;Laravel website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Thank you for considering contributing to the Laravel Vite plugin! The contribution guide can be found in the &lt;a href=&#34;https://laravel.com/docs/contributions&#34;&gt;Laravel documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;In order to ensure that the Laravel community is welcoming to all, please review and abide by the &lt;a href=&#34;https://laravel.com/docs/contributions#code-of-conduct&#34;&gt;Code of Conduct&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Security Vulnerabilities&lt;/h2&gt; &#xA;&lt;p&gt;Please review &lt;a href=&#34;https://github.com/laravel/vite-plugin/security/policy&#34;&gt;our security policy&lt;/a&gt; on how to report security vulnerabilities.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The Laravel Vite plugin is open-sourced software licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/laravel/vite-plugin/main/LICENSE.md&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>