<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub All Languages Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-01T01:30:01Z</updated>
  <subtitle>Daily Trending of All Languages in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>whitead/paper-qa</title>
    <updated>2023-03-01T01:30:01Z</updated>
    <id>tag:github.com,2023-03-01:/whitead/paper-qa</id>
    <link href="https://github.com/whitead/paper-qa" rel="alternate"></link>
    <summary type="html">&lt;p&gt;LLM Chain for answering questions from documents with citations&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Paper QA&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/whitead/paper-qa&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&amp;amp;logo=github&amp;amp;logoColor=white&#34; alt=&#34;GitHub&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/whitead/paper-qa&#34;&gt;&lt;img src=&#34;https://github.com/whitead/paper-qa/actions/workflows/tests.yml/badge.svg?sanitize=true&#34; alt=&#34;tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://badge.fury.io/py/paper-qa&#34;&gt;&lt;img src=&#34;https://badge.fury.io/py/paper-qa.svg?sanitize=true&#34; alt=&#34;PyPI version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://lbesson.mit-license.org/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-blue.svg?sanitize=true&#34; alt=&#34;MIT license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is a minimal package for doing question and answering from PDFs or text files (which can be raw HTML). It strives to give very good answers, with no hallucinations, by grounding responses with in-text citations. It uses &lt;a href=&#34;https://platform.openai.com/docs/guides/embeddings&#34;&gt;OpenAI Embeddings&lt;/a&gt; with a vector DB called &lt;a href=&#34;https://github.com/facebookresearch/faiss&#34;&gt;FAISS&lt;/a&gt; to embed and search documents. &lt;a href=&#34;https://github.com/hwchase17/langchain&#34;&gt;langchain&lt;/a&gt; helps generate answers.&lt;/p&gt; &#xA;&lt;p&gt;It uses this process&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;embed docs into vectors -&amp;gt; embed query into vector -&amp;gt; search for top k passages in docs&#xA;&#xA;create summary of each passage relevant to query -&amp;gt; put summaries into prompt -&amp;gt; generate answer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Hugging Face Demo&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://huggingface.co/spaces/whitead/paper-qa&#34;&gt;Hugging Face Demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/908389/218957863-4aa2fa2c-14cf-4b0d-82fd-bf837f5f550b.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s New&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Made it possible to switch models besides OpenAI.&lt;/li&gt; &#xA; &lt;li&gt;Can access the raw passages and references from the answer object.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Question: How can carbon nanotubes be manufactured at a large scale?&lt;/p&gt; &#xA;&lt;p&gt;Carbon nanotubes can be manufactured at a large scale using the electric-arc technique (Journet6644). This technique involves creating an arc between two electrodes in a reactor under a helium atmosphere and using a mixture of a metallic catalyst and graphite powder in the anode. Yields of 80% of entangled carbon filaments can be achieved, which consist of smaller aligned SWNTs self-organized into bundle-like crystallites (Journet6644). Additionally, carbon nanotubes can be synthesized and self-assembled using various methods such as DNA-mediated self-assembly, nanoparticle-assisted alignment, chemical self-assembly, and electro-addressed functionalization (Tulevski2007). These methods have been used to fabricate large-area nanostructured arrays, high-density integration, and freestanding networks (Tulevski2007). 98% semiconducting CNT network solution can also be used and is separated from metallic nanotubes using a density gradient ultracentrifugation approach (Chen2014). The substrate is incubated in the solution and then rinsed with deionized water and dried with N2 air gun, leaving a uniform carbon network (Chen2014).&lt;/p&gt; &#xA;&lt;h3&gt;References&lt;/h3&gt; &#xA;&lt;p&gt;Journet6644: Journet, Catherine, et al. &#34;Large-scale production of single-walled carbon nanotubes by the electric-arc technique.&#34; nature 388.6644 (1997): 756-758.&lt;/p&gt; &#xA;&lt;p&gt;Tulevski2007: Tulevski, George S., et al. &#34;Chemically assisted directed assembly of carbon nanotubes for the fabrication of large-scale device arrays.&#34; Journal of the American Chemical Society 129.39 (2007): 11964-11968.&lt;/p&gt; &#xA;&lt;p&gt;Chen2014: Chen, Haitian, et al. &#34;Large-scale complementary macroelectronics using hybrid integration of carbon nanotubes and IGZO thin-film transistors.&#34; Nature communications 5.1 (2014): 4097.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;Install with pip:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install paper-qa&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Make sure you have set your OPENAI_API_KEY environment variable to your &lt;a href=&#34;https://platform.openai.com/account/api-keys&#34;&gt;openai api key&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To use paper-qa, you need to have a list of paths (valid extensions include: .pdf, .txt) and a list of citations (strings) that correspond to the paths. You can then use the &lt;code&gt;Docs&lt;/code&gt; class to add the documents and then query them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;This uses a lot of tokens!! About 5-10k tokens per answer + embedding cost (negligible unless many documents used). That is up to $0.20 per answer with current GPT-3 pricing. Use wisely.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#xA;from paperqa import Docs&#xA;&#xA;# get a list of paths, citations&#xA;&#xA;docs = Docs()&#xA;for d, c in zip(my_docs, my_citations):&#xA;    docs.add(d, c)&#xA;&#xA;# takes ~ 1 min and costs $0.10-$0.20 to execute this line&#xA;answer = docs.query(&#34;What manufacturing challenges are unique to bispecific antibodies?&#34;)&#xA;print(answer.formatted_answer)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The answer object has the following attributes: &lt;code&gt;formatted_answer&lt;/code&gt;, &lt;code&gt;answer&lt;/code&gt; (answer alone), &lt;code&gt;question&lt;/code&gt;, &lt;code&gt;context&lt;/code&gt; (the summaries of passages found for answer), &lt;code&gt;references&lt;/code&gt; (the docs from which the passages came), and &lt;code&gt;passages&lt;/code&gt; which contain the raw text of the passages as a dictionary.&lt;/p&gt; &#xA;&lt;h2&gt;Adjusting number of sources&lt;/h2&gt; &#xA;&lt;p&gt;You can adjust the numbers of sources (passages of text) to reduce token usage or add more context. &lt;code&gt;k&lt;/code&gt; refers to the top k most relevant and diverse (may from different sources) passages. Each passage is sent to the LLM to summarize, or determine if it is irrelevant. After this step, a limit of &lt;code&gt;max_sources&lt;/code&gt; is applied so that the final answer can fit into the LLM context window. Thus, &lt;code&gt;k&lt;/code&gt; &amp;gt; &lt;code&gt;max_sources&lt;/code&gt; and &lt;code&gt;max_sources&lt;/code&gt; is the number of sources used in the final answer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;docs.query(&#34;What manufacturing challenges are unique to bispecific antibodies?&#34;, k = 5, max_sources = 2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Where do I get papers?&lt;/h2&gt; &#xA;&lt;p&gt;Well that&#39;s a really good question! It&#39;s probably best to just download PDFs of papers you think will help answer your question and start from there.&lt;/p&gt; &#xA;&lt;p&gt;If you want to do it automatically, I&#39;ve found an unrelated project called &lt;a href=&#34;https://github.com/blackadad/paper-scraper&#34;&gt;paper-scraper&lt;/a&gt; that looks like it might help. But beware, this project looks like it uses some scraping tools that may violate publisher&#39;s rights or be in a gray area of legality.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;keyword_search = &#39;bispecific antibody manufacture&#39;&#xA;papers = paperscraper.search_papers(keyword_search)&#xA;docs = paperqa.Docs()&#xA;for path,data in papers.items():&#xA;    try:&#xA;        docs.add(path, data[&#39;citation&#39;], data[&#39;key&#39;])&#xA;    except ValueError as e:&#xA;        # sometimes this happens if PDFs aren&#39;t downloaded or readable&#xA;        print(&#39;Could not read&#39;, path, e)&#xA;# takes ~ 1 min and costs $0.50 to execute this line&#xA;answer = docs.query(&#34;What manufacturing challenges are unique to bispecific antibodies?&#34;)&#xA;print(answer.formatted_answer)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;How is this different from gpt-index?&lt;/h3&gt; &#xA;&lt;p&gt;gpt-index does generate answers, but in a somewhat opinionated way. It doesn&#39;t have a great way to track where text comes from and it&#39;s not easy to force it to pull from multiple documents. I don&#39;t know which way is better, but for writing scholarly text I found it to work better to pull from multiple relevant documents and then generate an answer. I would like to PR to do this to gpt-index but it looks pretty involved right now.&lt;/p&gt; &#xA;&lt;h3&gt;Where do the documents come from?&lt;/h3&gt; &#xA;&lt;p&gt;I use some of my own code to pull papers from Google Scholar. This code is not included because it may enable people to violate Google&#39;s terms of service and publisher&#39;s terms of service.&lt;/p&gt; &#xA;&lt;h3&gt;Can I save or load?&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Docs&lt;/code&gt; class can be pickled and unpickled. This is useful if you want to save the embeddings of the documents and then load them later. The database is stored in &lt;code&gt;$HOME/.paperqa/{name}&lt;/code&gt; where &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;default&lt;/code&gt;, or you can pass a &lt;code&gt;name&lt;/code&gt; when you instantiate the &lt;code&gt;paperqa&lt;/code&gt; doc object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pickle&#xA;&#xA;with open(&#34;my_docs.pkl&#34;, &#34;wb&#34;) as f:&#xA;    pickle.dump(docs, f)&#xA;&#xA;with open(&#34;my_docs.pkl&#34;, &#34;rb&#34;) as f:&#xA;    docs = pickle.load(f)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>henryhu712/technote</title>
    <updated>2023-03-01T01:30:01Z</updated>
    <id>tag:github.com,2023-03-01:/henryhu712/technote</id>
    <link href="https://github.com/henryhu712/technote" rel="alternate"></link>
    <summary type="html">&lt;p&gt;编程笔记&lt;/p&gt;&lt;hr&gt;&lt;p&gt;我的编程笔记&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>vlang/v</title>
    <updated>2023-03-01T01:30:01Z</updated>
    <id>tag:github.com,2023-03-01:/vlang/v</id>
    <link href="https://github.com/vlang/v" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple, fast, safe, compiled language for developing maintainable software. Compiles itself in &lt;1s with zero library dependencies. Supports automatic C =&gt; V translation. https://vlang.io&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34; style=&#34;display:grid;place-items:center;&#34;&gt; &#xA; &lt;p&gt; &lt;a href=&#34;https://vlang.io/&#34; target=&#34;_blank&#34;&gt;&lt;img width=&#34;80&#34; src=&#34;https://raw.githubusercontent.com/vlang/v-logo/master/dist/v-logo.svg?sanitize=true&#34; alt=&#34;V logo&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA; &lt;h1&gt;The V Programming Language&lt;/h1&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://vlang.io&#34;&gt;vlang.io&lt;/a&gt; | &lt;a href=&#34;https://github.com/vlang/v/raw/master/doc/docs.md&#34;&gt;Docs&lt;/a&gt; | &lt;a href=&#34;https://github.com/vlang/v/raw/master/CHANGELOG.md&#34;&gt;Changelog&lt;/a&gt; | &lt;a href=&#34;https://fast.vlang.io/&#34;&gt;Speed&lt;/a&gt; | &lt;a href=&#34;https://github.com/vlang/v/raw/master/CONTRIBUTING.md&#34;&gt;Contributing &amp;amp; compiler design&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34; style=&#34;display:grid;place-items:center;&#34;&gt; &#xA; &lt;!--&#xA;[![Build Status][WorkflowBadge]][WorkflowUrl]&#xA;--&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/sponsors/medvednikov&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/da8bc40db5ed31e4b12660245535b5db67aa03ce/68747470733a2f2f696d672e736869656c64732e696f2f7374617469632f76313f6c6162656c3d53706f6e736f72266d6573736167653d254532253944254134266c6f676f3d476974487562&#34; alt=&#34;Sponsor&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://patreon.com/vlang&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fshieldsio-patreon.vercel.app%2Fapi%3Fusername%3Dvlang%26type%3Dpatrons&amp;amp;style=flat&#34; alt=&#34;Patreon&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/vlang&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/592103645835821068?label=Discord&amp;amp;logo=discord&amp;amp;logoColor=white&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/v_language&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/follow-%40v_language-1DA1F2?logo=twitter&amp;amp;style=flat&amp;amp;logoColor=white&amp;amp;color=1da1f2&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://modules.vlang.io&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/modules-reference-027d9c?logo=v&amp;amp;logoColor=white&amp;amp;logoWidth=10&#34; alt=&#34;Modules&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Key Features of V&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simplicity: the language can be learned in a weekend&lt;/li&gt; &#xA; &lt;li&gt;Fast compilation: ≈110k loc/s with a Clang backend, ≈500k loc/s with native and tcc backends &lt;em&gt;(Intel i5-7500, SSD, no optimization)&lt;/em&gt; (&lt;a href=&#34;https://www.youtube.com/watch?v=pvP6wmcl_Sc&#34;&gt;demo video&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Easy to develop: V compiles itself in less than a second&lt;/li&gt; &#xA; &lt;li&gt;Performance: as fast as C (V&#39;s main backend compiles to human-readable C)&lt;/li&gt; &#xA; &lt;li&gt;Safety: no null, no globals, no undefined behavior (wip), immutability by default&lt;/li&gt; &#xA; &lt;li&gt;C to V translation (&lt;a href=&#34;https://www.youtube.com/watch?v=6oXrz3oRoEg&#34;&gt;Translating DOOM demo video&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Hot code reloading&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vlang.io/#memory&#34;&gt;Flexible memory management&lt;/a&gt;. GC by default, manual via &lt;code&gt;v -gc none&lt;/code&gt;, arena allocation via &lt;code&gt;v -prealloc&lt;/code&gt;, autofree via &lt;code&gt;v -autofree&lt;/code&gt; (&lt;a href=&#34;https://www.youtube.com/watch?v=gmB8ea8uLsM&#34;&gt;autofree demo video&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vlang/ui&#34;&gt;Cross-platform UI library&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Built-in graphics library&lt;/li&gt; &#xA; &lt;li&gt;Easy cross-compilation&lt;/li&gt; &#xA; &lt;li&gt;REPL&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vlang/v/raw/master/doc/docs.md#orm&#34;&gt;Built-in ORM&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vlang/v/raw/master/vlib/vweb/README.md&#34;&gt;Built-in web framework&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;C and JavaScript backends&lt;/li&gt; &#xA; &lt;li&gt;Great for writing low-level software (&lt;a href=&#34;https://github.com/vlang/vinix&#34;&gt;Vinix OS&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Stability guarantee and future changes&lt;/h2&gt; &#xA;&lt;p&gt;Despite being at an early development stage, the V language is relatively stable and has backwards compatibility guarantee, meaning that the code you write today is guaranteed to work a month, a year, or five years from now.&lt;/p&gt; &#xA;&lt;p&gt;There still may be minor syntax changes before the 1.0 release, but they will be handled automatically via &lt;code&gt;vfmt&lt;/code&gt;, as has been done in the past.&lt;/p&gt; &#xA;&lt;p&gt;The V core APIs (primarily the &lt;code&gt;os&lt;/code&gt; module) will still have minor changes until they are stabilized in V 1.0. Of course the APIs will grow after that, but without breaking existing code.&lt;/p&gt; &#xA;&lt;p&gt;Unlike many other languages, V is not going to be always changing, with new features being introduced and old features modified. It is always going to be a small and simple language, very similar to the way it is right now.&lt;/p&gt; &#xA;&lt;h2&gt;Installing V from source&lt;/h2&gt; &#xA;&lt;p&gt;--&amp;gt; &lt;strong&gt;&lt;em&gt;(this is the preferred method)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Linux, macOS, Windows, *BSD, Solaris, WSL, etc.&lt;/h3&gt; &#xA;&lt;p&gt;Usually installing V is quite simple if you have an environment that already has a functional &lt;code&gt;git&lt;/code&gt; installation.&lt;/p&gt; &#xA;&lt;p&gt;To get started, simply try to execute the following in your terminal/shell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/vlang/v&#xA;cd v&#xA;make&#xA;# HINT: Using Windows? run make.bat in a cmd shell, or ./make.bat in PowerShell&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That should be it and you should find your V executable at &lt;code&gt;[path to V repo]/v&lt;/code&gt;. &lt;code&gt;[path to V repo]&lt;/code&gt; can be anywhere.&lt;/p&gt; &#xA;&lt;p&gt;(As in the hint above, on Windows &lt;code&gt;make&lt;/code&gt; means running &lt;code&gt;make.bat&lt;/code&gt;.)&lt;/p&gt; &#xA;&lt;p&gt;Now you can try &lt;code&gt;./v run examples/hello_world.v&lt;/code&gt; (or &lt;code&gt;v run examples/hello_world.v&lt;/code&gt; in cmd shell).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Trouble? Please see the note above and link to &lt;a href=&#34;https://github.com/vlang/v/discussions/categories/installation-issues&#34;&gt;Installation Issues&lt;/a&gt; for help.&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;V is constantly being updated. To update V, simply run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;v up&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; If you run into any trouble, or you have a different operating system or Linux distribution that doesn&#39;t install or work immediately, please see &lt;a href=&#34;https://github.com/vlang/v/discussions/categories/installation-issues&#34;&gt;Installation Issues&lt;/a&gt; and search for your OS and problem.&lt;/p&gt; &#xA; &lt;p&gt;If you can&#39;t find your problem, please add it to an existing discussion if one exists for your OS, or create a new one if a main discussion doesn&#39;t yet exist for your OS.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;C compiler&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://repo.or.cz/w/tinycc.git&#34;&gt;Tiny C Compiler (tcc)&lt;/a&gt; is downloaded for you by &lt;code&gt;make&lt;/code&gt; if there is a compatible version for your system, and installed under the V &lt;code&gt;thirdparty&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;This compiler is very fast, but does almost no optimizations. It is best for development builds.&lt;/p&gt; &#xA;&lt;p&gt;For production builds (using the &lt;code&gt;-prod&lt;/code&gt; option to V), it&#39;s recommended to use clang, gcc, or Microsoft Visual C++. If you are doing development, you most likely already have one of those installed.&lt;/p&gt; &#xA;&lt;p&gt;Otherwise, follow these instructions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Linux-and-macOS&#34;&gt;Installing a C compiler on Linux and macOS&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Windows&#34;&gt;Installing a C compiler on Windows&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Symlinking&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; It is &lt;em&gt;highly recommended&lt;/em&gt;, that you put V on your PATH. That saves you the effort to type in the full path to your v executable every time. V provides a convenience &lt;code&gt;v symlink&lt;/code&gt; command to do that more easily.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;On Unix systems, it creates a &lt;code&gt;/usr/local/bin/v&lt;/code&gt; symlink to your executable. To do that, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./v symlink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Windows, start a new shell with administrative privileges, for example by pressing the &lt;kbd&gt;Windows Key&lt;/kbd&gt;, then type &lt;code&gt;cmd.exe&lt;/code&gt;, right-click on its menu entry, and choose &lt;code&gt;Run as administrator&lt;/code&gt;. In the new administrative shell, cd to the path where you have compiled V, then type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;v symlink&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(or &lt;code&gt;./v symlink&lt;/code&gt; in PowerShell)&lt;/p&gt; &#xA;&lt;p&gt;That will make V available everywhere, by adding it to your PATH. Please restart your shell/editor after that, so that it can pick up the new PATH variable.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; There is no need to run &lt;code&gt;v symlink&lt;/code&gt; more than once - v will still be available, even after &lt;code&gt;v up&lt;/code&gt;, restarts, and so on. You only need to run it again if you decide to move the V repo folder somewhere else.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Void Linux&lt;/h3&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Expand Void Linux instructions&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# xbps-install -Su base-devel&#xA;# xbps-install libatomic-devel&#xA;$ git clone https://github.com/vlang/v&#xA;$ cd v&#xA;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Expand Docker instructions&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/vlang/v&#xA;cd v&#xA;docker build -t vlang .&#xA;docker run --rm -it vlang:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;h3&gt;Docker with Alpine/musl&lt;/h3&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/vlang/v&#xA;cd v&#xA;docker build -t vlang --file=Dockerfile.alpine .&#xA;docker run --rm -it vlang:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Termux/Android&lt;/h3&gt; &#xA;&lt;p&gt;On Termux, V needs some packages preinstalled - a working C compiler, also &lt;code&gt;libexecinfo&lt;/code&gt;, &lt;code&gt;libgc&lt;/code&gt; and &lt;code&gt;libgc-static&lt;/code&gt;. After installing them, you can use the same script, like on Linux/macos:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pkg install clang libexecinfo libgc libgc-static make git&#xA;git clone https://github.com/vlang/v&#xA;cd v&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing and running the examples&lt;/h2&gt; &#xA;&lt;p&gt;Make sure V can compile itself:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ v self&#xA;$ v&#xA;V 0.3.x&#xA;Use Ctrl-C or `exit` to exit&#xA;&#xA;&amp;gt;&amp;gt;&amp;gt; println(&#39;hello world&#39;)&#xA;hello world&#xA;&amp;gt;&amp;gt;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd examples&#xA;v hello_world.v &amp;amp;&amp;amp; ./hello_world    # or simply&#xA;v run hello_world.v                 # this builds the program and runs it right away&#xA;&#xA;v run word_counter/word_counter.v word_counter/cinderella.txt&#xA;v run news_fetcher.v&#xA;v run tetris/tetris.v&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/vlang/v/master/examples/tetris/screenshot.png&#34; width=&#34;300&#34; alt=&#34;tetris screenshot&#34;&gt; &#xA;&lt;p&gt;In order to build Tetris or 2048 (or anything else using &lt;code&gt;sokol&lt;/code&gt; or &lt;code&gt;gg&lt;/code&gt; graphics modules), you will need additional development libraries for your system.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;System&lt;/th&gt; &#xA;   &lt;th&gt;Installation method&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Debian/Ubuntu based&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sudo apt install libxi-dev libxcursor-dev libgl-dev&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Fedora/RH/CentOS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sudo dnf install libXcursor-devel libXi-devel libX11-devel libglvnd-devel&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NixOS&lt;/td&gt; &#xA;   &lt;td&gt;add &lt;code&gt;xorg.libX11.dev xorg.libXcursor.dev xorg.libXi.dev libGL.dev&lt;/code&gt; to &lt;code&gt;environment.systemPackages&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;V net.http, net.websocket, &lt;code&gt;v install&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The net.http module, the net.websocket module, and the &lt;code&gt;v install&lt;/code&gt; command may all use SSL. V comes with a version of mbedtls, which should work on all systems. If you find a need to use OpenSSL instead, you will need to make sure that it is installed on your system, then use the &lt;code&gt;-d use_openssl&lt;/code&gt; switch when you compile.&lt;/p&gt; &#xA;&lt;p&gt;To install OpenSSL on non-Windows systems:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;System&lt;/th&gt; &#xA;   &lt;th&gt;Installation command&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;macOS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;brew install openssl&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Debian/Ubuntu based&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sudo apt install libssl-dev&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Arch/Manjaro&lt;/td&gt; &#xA;   &lt;td&gt;openssl is installed by default&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Fedora/CentOS/RH&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sudo dnf install openssl-devel&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;On Windows, OpenSSL is simply hard to get working correctly. The instructions &lt;a href=&#34;https://tecadmin.net/install-openssl-on-windows/&#34;&gt;here&lt;/a&gt; may (or may not) help.&lt;/p&gt; &#xA;&lt;h2&gt;V sync&lt;/h2&gt; &#xA;&lt;p&gt;V&#39;s &lt;code&gt;sync&lt;/code&gt; module and channel implementation uses libatomic. It is most likely already installed on your system, but if not, you can install it, by doing the following:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;System&lt;/th&gt; &#xA;   &lt;th&gt;Installation command&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;macOS&lt;/td&gt; &#xA;   &lt;td&gt;already installed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Debian/Ubuntu based&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sudo apt install libatomic1&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Fedora/CentOS/RH&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;sudo dnf install libatomic-static&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;V UI&lt;/h2&gt; &#xA;&lt;a href=&#34;https://github.com/vlang/ui&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/vlang/ui/master/examples/screenshot.png&#34; width=&#34;712&#34; alt=&#34;V UI example screenshot&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/vlang/ui&#34;&gt;https://github.com/vlang/ui&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!--&#xA;## JavaScript backend&#xA;&#xA;[examples/hello_v_js.v](examples/hello_v_js.v):&#xA;&#xA;```v&#xA;fn main() {&#xA;&#x9;for i in 0 .. 3 {&#xA;&#x9;&#x9;println(&#39;Hello from V.js&#39;)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;v -o hi.js examples/hello_v_js.v &amp;&amp; node hi.js&#xA;Hello from V.js&#xA;Hello from V.js&#xA;Hello from V.js&#xA;```&#xA;--&gt; &#xA;&lt;h2&gt;Android graphical apps&lt;/h2&gt; &#xA;&lt;p&gt;With V&#39;s &lt;code&gt;vab&lt;/code&gt; tool, building V UI and graphical apps for Android can become as easy as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./vab /path/to/v/examples/2048&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/vlang/vab&#34;&gt;https://github.com/vlang/vab&lt;/a&gt;. &lt;img src=&#34;https://user-images.githubusercontent.com/768942/107622846-c13f3900-6c58-11eb-8a66-55db12979b73.png&#34; alt=&#34;vab examples screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Developing web applications&lt;/h2&gt; &#xA;&lt;p&gt;Check out the &lt;a href=&#34;https://github.com/vlang/v/raw/master/tutorials/building_a_simple_web_blog_with_vweb/README.md&#34;&gt;Building a simple web blog&lt;/a&gt; tutorial and Gitly, a light and fast alternative to GitHub/GitLab:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/vlang/gitly&#34;&gt;https://github.com/vlang/gitly&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/687996/85933714-b195fe80-b8da-11ea-9ddd-09cadc2103e4.png&#34; alt=&#34;gitly screenshot&#34;&gt; &#xA;&lt;h2&gt;Vinix, an OS/kernel written in V&lt;/h2&gt; &#xA;&lt;p&gt;V is great for writing low-level software like drivers and kernels. Vinix is an OS/kernel that already runs bash, GCC, V, and nano.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/vlang/vinix&#34;&gt;https://github.com/vlang/vinix&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://github.com/vlang/vinix/raw/main/screenshot0.png?raw=true&#34; alt=&#34;vinix screenshot 1&#34;&gt; &#xA;&lt;img src=&#34;https://github.com/vlang/vinix/raw/main/screenshot1.png?raw=true&#34; alt=&#34;vinix screenshot 2&#34;&gt; &#xA;&lt;h2&gt;Acknowledgement&lt;/h2&gt; &#xA;&lt;p&gt;V thanks Fabrice Bellard for his original work on the &lt;a href=&#34;https://bellard.org/tcc/&#34;&gt;TCC - Tiny C Compiler&lt;/a&gt;. Note the TCC website is old; the current TCC repository can be found &lt;a href=&#34;https://repo.or.cz/w/tinycc.git&#34;&gt;here&lt;/a&gt;. V utilizes pre-built TCC binaries located at &lt;a href=&#34;https://github.com/vlang/tccbin/&#34;&gt;https://github.com/vlang/tccbin/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://github.com/vlang/v/wiki/Troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt; section on our &lt;a href=&#34;https://github.com/vlang/v/wiki&#34;&gt;wiki page&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>