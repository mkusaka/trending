<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PowerShell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-12T01:50:07Z</updated>
  <subtitle>Daily Trending of PowerShell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>InfosecMatter/SSH-PuTTY-login-bruteforcer</title>
    <updated>2022-06-12T01:50:07Z</updated>
    <id>tag:github.com,2022-06-12:/InfosecMatter/SSH-PuTTY-login-bruteforcer</id>
    <link href="https://github.com/InfosecMatter/SSH-PuTTY-login-bruteforcer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Turn PuTTY into an SSH login bruteforcing tool.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SSH PuTTY login bruteforcer&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;strong&gt;ssh-putty-brute.ps1&lt;/strong&gt; is a wrapper script which uses PuTTY clients (either &lt;strong&gt;putty.exe&lt;/strong&gt; or &lt;strong&gt;plink.exe&lt;/strong&gt;) to perform SSH login bruteforce attacks.&lt;/p&gt; &#xA;&lt;p&gt;See the main article for detailed description: &lt;a href=&#34;https://www.infosecmatter.com/ssh-brute-force-attack-tool-using-putty-plink-ssh-putty-brute-ps1/&#34;&gt;https://www.infosecmatter.com/ssh-brute-force-attack-tool-using-putty-plink-ssh-putty-brute-ps1/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage and examples&lt;/h2&gt; &#xA;&lt;p&gt;The tool requires either &lt;strong&gt;putty.exe&lt;/strong&gt; or &lt;strong&gt;plink.exe&lt;/strong&gt; executables in the PATH or in the current working directory.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how to use this tool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import-module .\ssh-putty-brute.ps1&#xA;&#xA;# Usage:&#xA;ssh-putty-brute [-h ip|ips.txt] [-p port] [-u user|users.txt] [-pw pass|pwdlist.txt]&#xA;&#xA;# Examples:&#xA;ssh-putty-brute -h 10.10.5.11 -p 22 -u root -pw P@ssw0rd&#xA;ssh-putty-brute -h 10.10.5.11 -p 22 -u root -pw (Get-Content .\pwdlist.txt)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;p&gt;SSH login attack against a single target:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60963123/80275175-93e8c500-86f0-11ea-9838-346e68f404b5.png&#34; alt=&#34;ssh-putty-bruteforce-login-attack-0&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;SSH password spraying accross the network:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60963123/80275055-e8d80b80-86ef-11ea-9ada-1fc84ce58f71.png&#34; alt=&#34;ssh-putty-bruteforce-login-attack-password-spraying&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Hunting for default SSH credentials:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60963123/80275192-af53d000-86f0-11ea-80bb-e52cdd490753.png&#34; alt=&#34;ssh-putty-bruteforce-login-attack-full&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For more information, visit: &lt;a href=&#34;https://www.infosecmatter.com/ssh-brute-force-attack-tool-using-putty-plink-ssh-putty-brute-ps1/&#34;&gt;https://www.infosecmatter.com/ssh-brute-force-attack-tool-using-putty-plink-ssh-putty-brute-ps1/&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>monoxgas/sRDI</title>
    <updated>2022-06-12T01:50:07Z</updated>
    <id>tag:github.com,2022-06-12:/monoxgas/sRDI</id>
    <link href="https://github.com/monoxgas/sRDI" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Shellcode implementation of Reflective DLL Injection. Convert DLLs to position independent shellcode&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;sRDI - Shellcode Reflective DLL Injection&lt;/h1&gt; &#xA;&lt;p&gt;sRDI allows for the conversion of DLL files to position independent shellcode. It attempts to be a fully functional PE loader supporting proper section permissions, TLS callbacks, and sanity checks. It can be thought of as a shellcode PE loader strapped to a packed DLL.&lt;/p&gt; &#xA;&lt;p&gt;Functionality is accomplished via two components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;C project which compiles a PE loader implementation (RDI) to shellcode&lt;/li&gt; &#xA; &lt;li&gt;Conversion code which attaches the DLL, RDI, and user data together with a bootstrap&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This project is comprised of the following elements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;ShellcodeRDI:&lt;/strong&gt; Compiles shellcode for the DLL loader&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;NativeLoader:&lt;/strong&gt; Converts DLL to shellcode if neccesarry, then injects into memory&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;DotNetLoader:&lt;/strong&gt; C# implementation of NativeLoader&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Python\ConvertToShellcode.py:&lt;/strong&gt; Convert DLL to shellcode in place&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Python\EncodeBlobs.py:&lt;/strong&gt; Encodes compiled sRDI blobs for static embedding&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;PowerShell\ConvertTo-Shellcode.ps1:&lt;/strong&gt; Convert DLL to shellcode in place&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;FunctionTest:&lt;/strong&gt; Imports sRDI C function for debug testing&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;TestDLL:&lt;/strong&gt; Example DLL that includes two exported functions for call on Load and after&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;The DLL does not need to be compiled with RDI, however the technique is cross compatiable.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Use Cases / Examples&lt;/h2&gt; &#xA;&lt;p&gt;Before use, I recommend you become familiar with &lt;a href=&#34;https://disman.tl/2015/01/30/an-improved-reflective-dll-injection-technique.html&#34;&gt;Reflective DLL Injection&lt;/a&gt; and it&#39;s purpose.&lt;/p&gt; &#xA;&lt;h4&gt;Convert DLL to shellcode using python&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ShellcodeRDI import *&#xA;&#xA;dll = open(&#34;TestDLL_x86.dll&#34;, &#39;rb&#39;).read()&#xA;shellcode = ConvertToShellcode(dll)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Load DLL into memory using C# loader&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;DotNetLoader.exe TestDLL_x64.dll&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Convert DLL with python script and load with Native EXE&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;python ConvertToShellcode.py TestDLL_x64.dll&#xA;NativeLoader.exe TestDLL_x64.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Convert DLL with powershell and load with Invoke-Shellcode&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Import-Module .\Invoke-Shellcode.ps1&#xA;Import-Module .\ConvertTo-Shellcode.ps1&#xA;Invoke-Shellcode -Shellcode (ConvertTo-Shellcode -File TestDLL_x64.dll)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Flags&lt;/h2&gt; &#xA;&lt;p&gt;The PE loader code uses &lt;code&gt;flags&lt;/code&gt; argument to control the various options of loading logic:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SRDI_CLEARHEADER&lt;/code&gt; [0x1]: The DOS Header and DOS Stub for the target DLL are completley wiped with null bytes on load (Except for e_lfanew). This might cause issues with stock windows APIs when supplying the base address as a psuedo &lt;code&gt;HMODULE&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SRDI_CLEARMEMORY&lt;/code&gt; [0x2]: After calling functions in the loaded module (&lt;code&gt;DllMain&lt;/code&gt; and any exports), the DLL data will be cleared from memory. This is dangerous if you expect to continue executing code out of the module (Threads / &lt;code&gt;GetProcAddressR&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SRDI_OBFUSCATEIMPORTS&lt;/code&gt; [0x4]: The order of imports in the module will be randomized before starting IAT patching. Additionally, the high 16 bits of the flag can be used to store the number of seconds to pause before processing the next import. For example, &lt;code&gt;flags | (3 &amp;lt;&amp;lt; 16)&lt;/code&gt; will pause 3 seconds between every import.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SRDI_PASS_SHELLCODE_BASE&lt;/code&gt; [0x8]: As opposed to passing supplied user data to the exported function, sRDI will instead pass the base address of the currently executing shellcode block. This can be useful for self-cleanup inside more advanced modules.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;This project is built using Visual Studio 2019 (v142) and Windows SDK 10. The python script is written using Python 3.&lt;/p&gt; &#xA;&lt;p&gt;The Python and Powershell scripts are located at:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Python\ConvertToShellcode.py&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PowerShell\ConvertTo-Shellcode.ps1&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After building the project, the other binaries will be located at:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;bin\NativeLoader.exe&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bin\DotNetLoader.exe&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bin\TestDLL_&amp;lt;arch&amp;gt;.dll&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bin\ShellcodeRDI_&amp;lt;arch&amp;gt;.bin&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you would like to update the static blobs inside any of the tools:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; python .\lib\Python\EncodeBlobs.py -h&#xA;usage: EncodeBlobs.py [-h] solution_dir&#xA;&#xA;sRDI Blob Encoder&#xA;&#xA;positional arguments:&#xA;  solution_dir  Solution Directory&#xA;&#xA;optional arguments:&#xA;  -h, --help    show this help message and exit&#xA;&#xA;&amp;gt; python lib\Python\EncodeBlobs.py C:\code\srdi&#xA;&#xA;[+] Updated C:\code\srdi\Native/Loader.cpp&#xA;[+] Updated C:\code\srdi\DotNet/Program.cs&#xA;[+] Updated C:\code\srdi\Python/ShellcodeRDI.py&#xA;[+] Updated C:\code\srdi\PowerShell/ConvertTo-Shellcode.ps1&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Alternatives&lt;/h2&gt; &#xA;&lt;p&gt;If you find my code disgusting, or just looking for an alternative memory-PE loader project, check out some of these:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fancycode/MemoryModule&#34;&gt;https://github.com/fancycode/MemoryModule&lt;/a&gt; - Probably one of the cleanest PE loaders out there, great reference.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/TheWover/donut&#34;&gt;https://github.com/TheWover/donut&lt;/a&gt; - Want to convert .NET assemblies? Or how about JScript?&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hasherezade/pe_to_shellcode&#34;&gt;https://github.com/hasherezade/pe_to_shellcode&lt;/a&gt; - Generates a polymorphic PE+shellcode hybrids.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/DarthTon/Blackbone&#34;&gt;https://github.com/DarthTon/Blackbone&lt;/a&gt; - Large library with many memory hacking/hooking primitives.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;The basis of this project is derived from &lt;a href=&#34;https://disman.tl/2015/01/30/an-improved-reflective-dll-injection-technique.html&#34;&gt;&#34;Improved Reflective DLL Injection&#34; from Dan Staples&lt;/a&gt; which itself is derived from the original project by &lt;a href=&#34;https://github.com/stephenfewer/ReflectiveDLLInjection&#34;&gt;Stephen Fewer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The project framework for compiling C code as shellcode is taken from &lt;a href=&#34;http://www.exploit-monday.com/2013/08/writing-optimized-windows-shellcode-in-c.html&#34;&gt;Mathew Graeber&#39;s reasearch &#34;PIC_BindShell&#34;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>okieselbach/Intune</title>
    <updated>2022-06-12T01:50:07Z</updated>
    <id>tag:github.com,2022-06-12:/okieselbach/Intune</id>
    <link href="https://github.com/okieselbach/Intune" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Intune Scripts and Helpers.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Intune&lt;/h1&gt; &#xA;&lt;p&gt;Just a collection of Intune and Azure AD helpers and scripts&lt;/p&gt; &#xA;&lt;p&gt;All scripts are provided &#34;AS IS&#34; with no liability and should always be tested in a test environment before used in production!&lt;/p&gt;</summary>
  </entry>
</feed>