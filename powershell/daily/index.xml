<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PowerShell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-07T01:40:52Z</updated>
  <subtitle>Daily Trending of PowerShell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dahvidschloss/CRASH</title>
    <updated>2023-04-07T01:40:52Z</updated>
    <id>tag:github.com,2023-04-07:/dahvidschloss/CRASH</id>
    <link href="https://github.com/dahvidschloss/CRASH" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Completely Risky Active-Directory Simulation Hub&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CRASH - Completely Risky Active-Directory Simulation Hub&lt;/h1&gt; &#xA;&lt;p&gt;Author: Dahvid Schloss&lt;/p&gt; &#xA;&lt;p&gt;Phone number: (281) 330-8004 (call it I dare you)&lt;/p&gt; &#xA;&lt;h2&gt;The Unintentional IT Administrator(v1.0) (aka ADGenny)&lt;/h2&gt; &#xA;&lt;h3&gt;This PowerShell script generates a set of random users and populates them into Active Directory. It creates Organizational Units (OUs) and corresponding groups based on predefined department names, then assigns users to these groups. Users are given randomly generated names, passwords, and titles specific to their department.&lt;/h3&gt; &#xA;&lt;p&gt;Features&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Generates 100 random users with unique names and passwords&lt;/li&gt; &#xA; &lt;li&gt;Creates OUs and corresponding groups for departments such as HR, Finance, Marketing, IT, Executives, and Programmers&lt;/li&gt; &#xA; &lt;li&gt;Assigns users to respective groups and gives them titles specific to their department&lt;/li&gt; &#xA; &lt;li&gt;Assigns a unique &#34;Director&#34; title to a random user in each department&lt;/li&gt; &#xA; &lt;li&gt;Creates the users in Active Directory and adds them to their respective groups&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the Active Directory module for PowerShell if you haven&#39;t already&lt;/li&gt; &#xA; &lt;li&gt;Run the script in a PowerShell environment with Domain Admin privileges (just do ./adgenny.ps1)&lt;/li&gt; &#xA; &lt;li&gt;Watch the script generate and populate random users in your Active Directory&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version&lt;/h3&gt; &#xA;&lt;p&gt;Current version: 1.0&lt;/p&gt; &#xA;&lt;h5&gt;Patch Notes:&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;what can I say its 1.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Planned Improvements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add more departments and roles to better mimic real-world organizations&lt;/li&gt; &#xA; &lt;li&gt;Implement user-friendly customization of departments, roles, and user counts through either arguments or a config file&lt;/li&gt; &#xA; &lt;li&gt;Generate user email addresses (would be cool if we could fake Exchange entirely but who&#39;s got time for that&#34;&lt;/li&gt; &#xA; &lt;li&gt;Optimize the script to minimize web requests to the Fake Name Generator API (when using more than 100 calls)&lt;/li&gt; &#xA; &lt;li&gt;Add error handling for cases where the Fake Name Generator API is not accessible or rate-limited (or error handling in general, but like if it works it works)&lt;/li&gt; &#xA; &lt;li&gt;Improve the script&#39;s performance by optimizing loops and string manipulation (you got a slow computer then this bad boy goes mad slow)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;ADversary Builder(v1.0)&lt;/h2&gt; &#xA;&lt;h3&gt;This PowerShell script designed to create random vulnerabilities for users within an Active Directory (AD) environment. The script generates a vulnerable_users.csv file, which can be used on workstations set up for your Range or Capture the Flag (CTF) exercises. It is intended to help security professionals assess and improve their organization&#39;s security posture.&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sets weak passwords for randomly selected users from a wordlist&lt;/li&gt; &#xA; &lt;li&gt;Creates Kerberoastable users with weak passwords&lt;/li&gt; &#xA; &lt;li&gt;Grants LAPS access to users in a specified Organizational Unit (OU) and assigns them weak passwords&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;!!NOTE!! To make this work you need a wordlist, Suggest importing Rockyou.txt from your Kali Linux instance to the local CRASH folder. I can&#39;t figure out how to import files larger than 100mb and Rockyou is 110mb.&lt;/h3&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the Active Directory module for PowerShell if you haven&#39;t already&lt;/li&gt; &#xA; &lt;li&gt;Import the script into the current PowerShell Instance&lt;/li&gt; &#xA; &lt;li&gt;Run Set-RandomWeakPasswordsForUsers first&lt;/li&gt; &#xA; &lt;li&gt;Follow up with New-KerberoastableUsers and/or Grant-LAPSAccess (if LAPS is configured)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Version&lt;/h3&gt; &#xA;&lt;p&gt;Current version: 1.0&lt;/p&gt; &#xA;&lt;h5&gt;Patch Notes:&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Inital Commit&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Planned Improvements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add more user vulnerabilites&lt;/li&gt; &#xA; &lt;li&gt;Implement user-friendly wrapper function to run functions at random&lt;/li&gt; &#xA; &lt;li&gt;Implement fucntions to create Workstaion Vulnerabilites within AD&lt;/li&gt; &#xA; &lt;li&gt;Implement functions to create LSASS entries into workstaitons from the vulnerable users csv&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Please feel free to contribute to this project by submitting pull requests or opening issues for any bugs or feature requests.&lt;/h2&gt;</summary>
  </entry>
  <entry>
    <title>awakecoding/wireshark-rdp</title>
    <updated>2023-04-07T01:40:52Z</updated>
    <id>tag:github.com,2023-04-07:/awakecoding/wireshark-rdp</id>
    <link href="https://github.com/awakecoding/wireshark-rdp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Wireshark RDP resources&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Wireshark RDP resources&lt;/h1&gt; &#xA;&lt;p&gt;Looking for a way to capture and inspect RDP traffic in Wireshark? You&#39;ve come to the right place!&lt;/p&gt; &#xA;&lt;h2&gt;SSLKEYLOGFILE&lt;/h2&gt; &#xA;&lt;p&gt;Many applications, including browsers, support the SSLKEYFILEFILE environment variable with a path to a text file where TLS pre-master secrets are dumped. This format &lt;a href=&#34;https://wiki.wireshark.org/TLS#using-the-pre-master-secret&#34;&gt;is supported by Wireshark&lt;/a&gt; and does not require exporting server private keys.&lt;/p&gt; &#xA;&lt;p&gt;To configure Wireshark to use a specific TLS key log file, open the &lt;strong&gt;Preferences&lt;/strong&gt; dialog (Edit -&amp;gt; Preferences), navigate to the &lt;strong&gt;TLS&lt;/strong&gt; section under &lt;strong&gt;Protocols&lt;/strong&gt;, and then change the &lt;strong&gt;(Pre)-Master-Secret log filename&lt;/strong&gt; field:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/awakecoding/wireshark-rdp/master/images/wireshark_tls_key_log_file.png&#34; alt=&#34;Wireshark TLS key log file&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;SChannel&lt;/h3&gt; &#xA;&lt;p&gt;This technique involves attaching to lsass.exe in order to dump TLS pre-master secrets from SChannel into the SSLKEYLOGFILE format supported by Wireshark. This is by far the simplest approach so it&#39;s absolutely worth the trouble, but it should only be used in test environments where security features can be disabled.&lt;/p&gt; &#xA;&lt;p&gt;Follow these instructions using an &lt;em&gt;elevated&lt;/em&gt; PowerShell terminal:&lt;/p&gt; &#xA;&lt;p&gt;Disable &lt;a href=&#34;https://learn.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection#how-to-disable-lsa-protection&#34;&gt;LSA extended protection&lt;/a&gt;, and then reboot the machine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-PowerShell&#34;&gt;Set-ItemProperty -Path &#39;HKLM:\SYSTEM\CurrentControlSet\Control\Lsa&#39; -Name &#39;RunAsPPL&#39; -Value 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://github.com/jborean93/PSDetour&#34;&gt;PSDetour&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-PowerShell&#34;&gt;Install-Module -Name PSDetour -Scope AllUsers -Force&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Launch tls-lsa-dump.ps1:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-PowerShell&#34;&gt;.\tls-lsa-dump.ps1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the script will use &lt;code&gt;C:\Windows\Temp\tls-lsa.log&lt;/code&gt; as the SSLKEYLOGFILE. Make sure that Wireshark is properly configured to use it, then capture a first RDP connection to see if it works!&lt;/p&gt; &#xA;&lt;h2&gt;Wireshark Issues&lt;/h2&gt; &#xA;&lt;p&gt;You thought this was the end of it? Not so fast!&lt;/p&gt; &#xA;&lt;h3&gt;RDP traffic shows up as &#39;TPKT Continuation&#39;&lt;/h3&gt; &#xA;&lt;p&gt;Wireshark associates TCP/3389 with the TPKT dissector by default, which works for the &lt;a href=&#34;https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/902b090b-9cb3-4efc-92bf-ee13373371e3&#34;&gt;X.224 connection request&lt;/a&gt;/&lt;a href=&#34;https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/13757f8f-66db-4273-9d2c-385c33b1e483&#34;&gt;confirm&lt;/a&gt; packets that happen before the TLS handshake.&lt;/p&gt; &#xA;&lt;p&gt;For some reason, the TPKT dissector often won&#39;t handoff the TLS packets to the TLS dissector, causing the &#39;TPKT Continuation&#39; issue. When this happens, right-click on one of the RDP packets, then select **Decode As...&#34;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/awakecoding/wireshark-rdp/master/images/wireshark_tpkt_decode_as.png&#34; alt=&#34;Wireshark TPKT Decode As...&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the Wireshark &lt;strong&gt;Decode As..&lt;/strong&gt; dialog, change the default or current dissector to &lt;strong&gt;TLS&lt;/strong&gt; then click OK:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/awakecoding/wireshark-rdp/master/images/wireshark_decode_as_tls.png&#34; alt=&#34;Wireshark Decode As TLS&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;With the TLS dissector forced on the entire TCP connection, the X.224 packets will show up as &#39;Ignored Unknown Record&#39;, but you should now be able to see the TLS handshake, and hopefully some RDP decrypted packets!&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/awakecoding/wireshark-rdp/master/images/wireshark_tls_dissector_rdp.png&#34; alt=&#34;Wireshark RDP with TLS dissector&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;To get a cleaner view of the RDP traffic without TCP and TLS packets, add &#34;rdp&#34; to the current Wireshark filter.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/awakecoding/wireshark-rdp/master/images/wireshark_rdp_dissector_filter.png&#34; alt=&#34;Wireshark RDP dissector filter&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Noise Reduction&lt;/h2&gt; &#xA;&lt;p&gt;Some RDP features can make packet captures messy and harder to analyze, some Windows features can create unwanted background noise, requiring more advanced filtering to keep only the relevant traffic.&lt;/p&gt; &#xA;&lt;h3&gt;RDP UDP Transport&lt;/h3&gt; &#xA;&lt;p&gt;Unless you intend to work on the RDP UDP protocol itself, I highly recommend disabling RDP UDP to get a single, clean RDP TCP connection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-PowerShell&#34;&gt;Set-ItemProperty -Path &#39;HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services\Client&#39; -Name &#39;fClientDisableUDP&#39; -Value 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Even if you block RDP UDP traffic in the firewall, you will still get some noise from the &lt;a href=&#34;https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpemt/4d98f550-6b0d-4d5f-89f5-2ac8616246a2&#34;&gt;RDP multitransport extension&lt;/a&gt; over the primary RDP TCP connection.&lt;/p&gt; &#xA;&lt;h2&gt;Bandwidth Auto-Detection&lt;/h2&gt; &#xA;&lt;p&gt;Bandwidth auto-detection is &lt;em&gt;VERY&lt;/em&gt; noisy at the beginning of an RDP connection - disable it at all costs in your &lt;a href=&#34;https://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/rdp-files&#34;&gt;.RDP file&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;connection type:i:6&#xA;networkautodetect:i:0&#xA;bandwidthautodetect:i:0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Network auto-detection is connection type 7 (auto-detect), which is when bandwidth auto-detection would kick in. This is why disabling the feature completely is best done by setting an explicit network type (6 for LAN), and then disabling both network and bandwidth auto-detection. If you&#39;re confused, you&#39;re not alone.&lt;/p&gt; &#xA;&lt;h2&gt;Bulk Data Compression&lt;/h2&gt; &#xA;&lt;p&gt;RDP bulk data compression is great everywhere except when you want to inspect the packets. Disable compression by adding &lt;code&gt;compression:i:0&lt;/code&gt; to your &lt;a href=&#34;https://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/rdp-files&#34;&gt;.RDP file&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;compression:i:0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Windows SmartScreen&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re inspecting HTTP traffic alongside the RDP connection (think Azure AD, Azure Virtual Desktop, RD Gateway, etc) then you&#39;ll want to remove some of the background noise by disabling SmartScreen:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-PowerShell&#34;&gt;Set-ItemProperty -Path &#39;HKLM:\SOFTWARE\Policies\Microsoft\Windows\System&#39; -Name &#39;EnableSmartScreen&#39; -Type DWORD -Value 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Don&#39;t forget to close unused browsers, and Windows &lt;em&gt;should&lt;/em&gt; be quiet enough!&lt;/p&gt;</summary>
  </entry>
</feed>