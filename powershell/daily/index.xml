<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub PowerShell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-07T01:50:00Z</updated>
  <subtitle>Daily Trending of PowerShell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>last-byte/PersistenceSniper</title>
    <updated>2022-08-07T01:50:00Z</updated>
    <id>tag:github.com,2022-08-07:/last-byte/PersistenceSniper</id>
    <link href="https://github.com/last-byte/PersistenceSniper" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Powershell script that can be used by Blue Teams, Incident Responders and System Administrators to hunt persistences implanted in Windows machines.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://www.powershellgallery.com/packages/PersistenceSniper/1.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/powershellgallery/p/PersistenceSniper?style=flat-square&#34; alt=&#34;platform badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.powershellgallery.com/packages/PersistenceSniper/1.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/powershellgallery/v/PersistenceSniper?style=flat-square&#34; alt=&#34;version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;table class=&#34;tg&#34;&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th class=&#34;tg-0pky&#34;&gt;&lt;h1 align=&#34;center&#34;&gt;PersistenceSniper&lt;/h1&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td class=&#34;tg-0pky&#34;&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://blog.notso.pro/img/persistencesniper2.png&#34; width=&#34;60%&#34;&gt; &lt;/p&gt;&lt;p&gt;PersistenceSniper is a Powershell script that can be used by Blue Teams, Incident Responders and System Administrators to hunt persistences implanted in Windows machines. The script is also available on &lt;a href=&#34;https://www.powershellgallery.com/packages/PersistenceSniper/1.0&#34;&gt;Powershell Gallery&lt;/a&gt;.&lt;/p&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;The Why&lt;/h2&gt; &#xA;&lt;p&gt;Why writing such a tool, you might ask. Well, for starters, I tried looking around and I did not find a tool which suited my particular use case, which was looking for known persistence techniques, automatically, across multiple machines, while also being able to quickly and easily parse and compare results. Sure, &lt;a href=&#34;https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns&#34;&gt;Sysinternals&#39; Autoruns&lt;/a&gt; is an amazing tool and it&#39;s definitely worth using, but, given it outputs results in non-standard formats and can&#39;t be run remotely unless you do some shenanigans with its command line equivalent, I did not find it a good fit for me. Plus, some of the techniques I implemented so far in PersistenceSniper have not been implemented into Autoruns yet, as far as I know. Anyway, if what you need is an easy to use, GUI based tool with lots of already implemented features, Autoruns is the way to go, otherwise let PersistenceSniper have a shot, it won&#39;t miss it :)&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Using PersistenceSniper is as simple as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; git clone https://github.com/last-byte/PersistenceSniper&#xA;PS C:\&amp;gt; . .\PersistenceSniper\PersistenceSniper.ps1&#xA;PS C:\&amp;gt; Find-AllPersistence&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need a detailed explanation of how to use the tool or which parameters are available and how they work, PersistenceSniper&#39;s &lt;code&gt;Find-AllPersistence&lt;/code&gt; supports Powershell&#39;s help features, so you can get detailed, updated help by using the following command after importing the module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Get-Help -Name Find-AllPersistence -Full&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;PersistenceSniper&#39;s &lt;code&gt;Find-AllPersistence&lt;/code&gt; returns an array of objects of type PSCustomObject with the following properties:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$PersistenceObject = [PSCustomObject]@{&#xA;      &#34;ComputerName&#34; = $ComputerName&#xA;      &#34;Technique&#34; = $Technique&#xA;      &#34;Classification&#34; = $Classification&#xA;      &#34;Path&#34; = $Path&#xA;      &#34;Value&#34; = $Value&#xA;      &#34;Access Gained&#34; = $AccessGained&#xA;      &#34;Note&#34; = $Note&#xA;      &#34;Reference&#34; = $Reference&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows for easy output formatting and filtering. Let&#39;s say you only want to see the persistences that will allow the attacker to regain access as NT AUTHORITY\SYSTEM (aka System):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; Find-AllPersistence | Where-Object &#34;Access Gained&#34; -EQ &#34;System&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://blog.notso.pro/img/findallpersistenceexample01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Of course, being PersistenceSniper a Powershell-based tool, some cool tricks can be performed, like passing its output to &lt;code&gt;Out-GridView&lt;/code&gt; in order to have a GUI-based table to interact with.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://blog.notso.pro/img/findallpersistenceexample03.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Interpreting results&lt;/h2&gt; &#xA;&lt;p&gt;As already introduced, &lt;code&gt;Find-AllPersistence&lt;/code&gt; outputs an array of Powershell Custom Objects. Each object has the following properties, which can be used to filter, sort and better understand the different techniques the function looks for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ComputerName: this is fairly straightforward. If you run &lt;code&gt;Find-AllPersistence&lt;/code&gt; without a &lt;code&gt;-ComputerName&lt;/code&gt; parameter, PersistenceSniper will run only on the local machine. Otherwise it will run on the remote computer(s) you specify;&lt;/li&gt; &#xA; &lt;li&gt;Technique: this is the name of the technique itself, as it&#39;s commonly known in the community;&lt;/li&gt; &#xA; &lt;li&gt;Classification: this property can be used to quickly identify techniques based on their MITRE ATT&amp;amp;CK technique and subtechnique number. For those techniques which don&#39;t have a MITRE ATT&amp;amp;CK classification, other classifications are used, the most common being &lt;a href=&#34;https://www.hexacorn.com/blog/2017/01/28/beyond-good-ol-run-key-all-parts/&#34;&gt;Hexacorn&#39;s one&lt;/a&gt; since a lot of techniques were discovered by him. When a technique&#39;s source cannot be reliably identified, the &#34;Uncatalogued Technique N.#&#34; classification is used;&lt;/li&gt; &#xA; &lt;li&gt;Path: this is the path, on the filesystem or in the registry, at which the technique has been implanted;&lt;/li&gt; &#xA; &lt;li&gt;Value: this is the value of the registry property the techniques uses, or the name of the executable/library used, in case it&#39;s a technique which relies on planting something on the filesystem;&lt;/li&gt; &#xA; &lt;li&gt;Access Gained: this is the kind of access the technique grants the attacker. If it&#39;s a Run key under HKCU for example, the access gained will be at a user level, while if it&#39;s under HKLM it will be at system level;&lt;/li&gt; &#xA; &lt;li&gt;Note: this is a quick explanation of the technique, so that its workings can be easily grasped;&lt;/li&gt; &#xA; &lt;li&gt;Reference: this is a link to a more in-depth explanation of the technique, should the analyst need to study it more.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Dealing with false positives&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s face it, hunting for persistence techniques also comes with having to deal with a lot of false positives. This happens because, while some techniques are almost never legimately used, many indeed are by legit software which needs to autorun on system boot or user login.&lt;/p&gt; &#xA;&lt;p&gt;This poses a challenge, which in many environments can be tackled by creating a CSV file containing known false positives. If your organization deploys systems using something like a golden image, you can run PersistenceSniper on a system you just created, get a CSV of the results and use it to filter out results on other machines. This approach comes with the following benefits:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Not having to manage a whitelist of persistences which can be tedious and error-prone;&lt;/li&gt; &#xA; &lt;li&gt;Tailoring the false positives to the organizations, and their organizational units, which use the tool;&lt;/li&gt; &#xA; &lt;li&gt;Making it harder for attackers who want to blend in false positives by not publicly disclosing them in the tool&#39;s code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;Find-AllPersistence&lt;/code&gt; comes with parameters allowing direct output of the findings to a CSV file, while also being able to take a CSV file as input and diffing the results.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; Find-AllPersistence -DiffCSV false_positives.csv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://blog.notso.pro/img/findallpersistenceexample02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Looking for persistences by taking incremental snapshots&lt;/h2&gt; &#xA;&lt;p&gt;One cool way to use PersistenceSniper my mate &lt;a href=&#34;https://twitter.com/dottor_morte&#34;&gt;Riccardo&lt;/a&gt; suggested is to use it in an incremental way: you could setup a Scheduled Task which runs every X hours, takes in the output of the previous iteration through the &lt;code&gt;-DiffCSV&lt;/code&gt; parameter and outputs the results to a new CSV. By keeping track of the incremental changes, you should be able to spot within a reasonably small time frame new persistences implanted on the machine you are monitoring.&lt;/p&gt; &#xA;&lt;h2&gt;Persistence techniques implemented so far&lt;/h2&gt; &#xA;&lt;p&gt;The topic of persistence, especially on Windows machines, is one of those which see new discoveries basically every other week. Given the sheer amount of persistence techniques found so far by researchers, I am still in the process of implementing them. So far the following 31 techniques have been implemented successfully:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1547/001/&#34;&gt;Run Key&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1547/001/&#34;&gt;RunOnce Key&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1546/012/&#34;&gt;Image File Execution Options&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2018/12/30/beyond-good-ol-run-key-part-98/&#34;&gt;Natural Language Development Platform 6 DLL Override Path&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2013/09/19/beyond-good-ol-run-key-part-4/&#34;&gt;AEDebug Keys&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2019/09/20/beyond-good-ol-run-key-part-116/&#34;&gt;Windows Error Reporting Debugger&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2018/08/31/beyond-good-ol-run-key-part-85/&#34;&gt;Windows Error Reporting ReflectDebugger&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://persistence-info.github.io/Data/cmdautorun.html&#34;&gt;Command Prompt AutoRun&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://persistence-info.github.io/Data/windowsload.html&#34;&gt;Explorer Load&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1547/004/&#34;&gt;Winlogon Userinit&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1547/004/&#34;&gt;Winlogon Shell&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://twitter.com/nas_bench/status/1550836225652686848&#34;&gt;Windows Terminal startOnUserLogin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1546/009/&#34;&gt;AppCertDlls DLL Injection&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2013/01/19/beyond-good-ol-run-key-part-3/&#34;&gt;App Paths Hijacking&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2013/09/19/beyond-good-ol-run-key-part-4/&#34;&gt;ServiceDll Hijacking&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://persistence-info.github.io/Data/gpoextension.html&#34;&gt;Group Policy Extensions DLLs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://persistence-info.github.io/Data/mpnotify.html&#34;&gt;Winlogon MPNotify&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2018/04/22/beyond-good-ol-run-key-part-76/&#34;&gt;CHM Helper DLL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2018/04/23/beyond-good-ol-run-key-part-77/&#34;&gt;Hijacking of hhctrl.ocx&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1547/001/&#34;&gt;Startup Folder&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1037/001/&#34;&gt;User Init Mpr Logon Script&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2015/01/13/beyond-good-ol-run-key-part-24/&#34;&gt;AutodialDLL Winsock Injection&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://persistence-info.github.io/Data/lsaaextension.html&#34;&gt;LSA Extensions DLL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://persistence-info.github.io/Data/serverlevelplugindll.html&#34;&gt;ServerLevelPluginDll DNS Server DLL Hijacking&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1547/002/&#34;&gt;LSA Authentication Packages DLL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1547/005/&#34;&gt;LSA Security Packages DLL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1547/004/&#34;&gt;Winlogon Notify Packages DLL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2017/01/18/beyond-good-ol-run-key-part-55/&#34;&gt;Explorer Tools Hijacking&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2013/09/19/beyond-good-ol-run-key-part-4/&#34;&gt;.NET DbgManagedDebugger&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://www.hexacorn.com/blog/2022/01/16/beyond-good-ol-run-key-part-135/&#34;&gt;ErrorHandler.cmd Hijacking&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;a href=&#34;https://attack.mitre.org/techniques/T1546/003/&#34;&gt;WMI Subscriptions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;The techniques implemented in this script have already been published by skilled researchers around the globe, so it&#39;s right to give credit where credit&#39;s due. This project wouldn&#39;t be around if it weren&#39;t for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.hexacorn.com/&#34;&gt;Hexacorn&lt;/a&gt; and his never-ending &lt;a href=&#34;https://www.hexacorn.com/blog/2017/01/28/beyond-good-ol-run-key-all-parts/&#34;&gt;Beyond good ol&#39; Run key series&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/0gtweet/&#34;&gt;Grzegorz Tworek&lt;/a&gt; and his amazing &lt;a href=&#34;https://persistence-info.github.io/&#34;&gt;persistence-info.github.io website&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;All the other researchers who disclosed cool and unknown persistence techniques.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I&#39;d also like to give credits to my fellow mates at &lt;a href=&#34;https://aptw.tf/about/&#34;&gt;@APTortellini&lt;/a&gt;, in particular &lt;a href=&#34;https://twitter.com/dottor_morte&#34;&gt;Riccardo Ancarani&lt;/a&gt;, for the flood of ideas that helped it grow from a puny text-oriented script to a full-fledged Powershell tool.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is under the &lt;a href=&#34;https://creativecommons.org/publicdomain/zero/1.0/&#34;&gt;CC0 1.0 Universal&lt;/a&gt; license. TL;DR: you can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.&lt;/p&gt; &#xA;&lt;h2&gt;Closing words&lt;/h2&gt; &#xA;&lt;p&gt;If you want, you can &lt;a href=&#34;https://www.buymeacoffee.com/last0x00&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://cdn.buymeacoffee.com/buttons/default-orange.png&#34; alt=&#34;Buy Me A Coffee&#34; height=&#34;41&#34; width=&#34;174&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ansible-collections/ansible.windows</title>
    <updated>2022-08-07T01:50:00Z</updated>
    <id>tag:github.com,2022-08-07:/ansible-collections/ansible.windows</id>
    <link href="https://github.com/ansible-collections/ansible.windows" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Windows core collection for Ansible&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ansible Collection: ansible.windows&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dev.azure.com/ansible/ansible.windows/_build/latest?definitionId=24&amp;amp;branchName=main&#34;&gt;&lt;img src=&#34;https://dev.azure.com/ansible/ansible.windows/_apis/build/status/CI?branchName=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/ansible-collections/ansible.windows&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/ansible-collections/ansible.windows/branch/main/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;ansible.windows&lt;/code&gt; collection includes the core plugins supported by Ansible to help the management of Windows hosts.&lt;/p&gt; &#xA;&lt;!--start requires_ansible--&gt; &#xA;&lt;h2&gt;Ansible version compatibility&lt;/h2&gt; &#xA;&lt;p&gt;This collection has been tested against following Ansible versions: &lt;strong&gt;&amp;gt;=2.11&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Plugins and modules within a collection may be tested with only specific Ansible versions. A collection may contain metadata that identifies these versions. PEP440 is the schema used to describe the versions of Ansible.&lt;/p&gt; &#xA;&lt;!--end requires_ansible--&gt; &#xA;&lt;h2&gt;Included content&lt;/h2&gt; &#xA;&lt;!--start collection content--&gt; &#xA;&lt;p&gt;See the complete list of collection content in the &lt;a href=&#34;https://ansible-collections.github.io/ansible.windows/branch/main/collections/ansible/windows/index.html#plugin-index&#34;&gt;Plugin Index&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;!--end collection content--&gt; &#xA;&lt;h2&gt;Installation and Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Installing the Collection from Ansible Galaxy&lt;/h3&gt; &#xA;&lt;p&gt;Before using the Windows collection, you need to install it with the &lt;code&gt;ansible-galaxy&lt;/code&gt; CLI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ansible-galaxy collection install ansible.windows&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also include it in a &lt;code&gt;requirements.yml&lt;/code&gt; file and install it via &lt;code&gt;ansible-galaxy collection install -r requirements.yml&lt;/code&gt; using the format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;collections:&#xA;- name: ansible.windows&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing to this collection&lt;/h2&gt; &#xA;&lt;p&gt;We welcome community contributions to this collection. If you find problems, please open an issue or create a PR against the &lt;a href=&#34;https://github.com/ansible-collections/ansible.windows&#34;&gt;Ansible Windows collection repository&lt;/a&gt;. See &lt;a href=&#34;https://docs.ansible.com/ansible/devel/community/contributing_maintained_collections.html#contributing-maintained-collections&#34;&gt;Contributing to Ansible-maintained collections&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general_windows.html#developing-modules-general-windows&#34;&gt;Developing modules for Windows&lt;/a&gt; for specifics on Windows modules.&lt;/p&gt; &#xA;&lt;p&gt;You can also join us on the &lt;code&gt;#ansible-windows&lt;/code&gt; &lt;a href=&#34;https://libera.chat/&#34;&gt;libera.chat&lt;/a&gt; IRC channel.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://docs.ansible.com/ansible/latest/community/index.html&#34;&gt;Ansible Community Guide&lt;/a&gt; for details on contributing to Ansible.&lt;/p&gt; &#xA;&lt;h3&gt;Code of Conduct&lt;/h3&gt; &#xA;&lt;p&gt;This collection follows the Ansible project&#39;s &lt;a href=&#34;https://docs.ansible.com/ansible/devel/community/code_of_conduct.html&#34;&gt;Code of Conduct&lt;/a&gt;. Please read and familiarize yourself with this document.&lt;/p&gt; &#xA;&lt;h3&gt;Generating plugin docs&lt;/h3&gt; &#xA;&lt;p&gt;Currently module documentation is generated manually using &lt;a href=&#34;https://github.com/ansible-network/collection_prep/raw/master/add_docs.py&#34;&gt;add_docs.py&lt;/a&gt;. This should be run whenever there are any major doc changes or additional plugins have been added to ensure a docpage is viewable online in this repo. The following commands will run the doc generator and create the updated doc pages under &lt;a href=&#34;https://raw.githubusercontent.com/ansible-collections/ansible.windows/main/docs&#34;&gt;docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# This is the path to the ansible.windows checkout&#xA;COLLECTION_PATH=~/ansible_collections/ansible/windows&#xA;&#xA;cd /tmp&#xA;git clone https://github.com/ansible-network/collection_prep.git&#xA;cd collection_prep&#xA;python add_docs.py -p &#34;${COLLECTION_PATH}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Testing with &lt;code&gt;ansible-test&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;tests&lt;/code&gt; directory contains configuration for running sanity and integration tests using &lt;a href=&#34;https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html&#34;&gt;&lt;code&gt;ansible-test&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can run the collection&#39;s test suites with the commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ansible-test sanity --docker&#xA;ansible-test windows-integration --docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Publishing New Version&lt;/h2&gt; &#xA;&lt;p&gt;The current process for publishing new versions of the Windows Core Collection is manual, and requires a user who has access to the &lt;code&gt;ansible&lt;/code&gt; namespace on Ansible Galaxy and Automation Hub to publish the build artifact.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update &lt;code&gt;galaxy.yml&lt;/code&gt; with the new version for the collection.&lt;/li&gt; &#xA; &lt;li&gt;Rebuild the plugin docs: &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install git+https://github.com/ansible-network/collection_prep&#xA;collection_prep_add_docs --path ./ --branch-name main&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Update the &lt;code&gt;CHANGELOG&lt;/code&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Make sure you have &lt;a href=&#34;https://pypi.org/project/antsibull-changelog/&#34;&gt;&lt;code&gt;antsibull-changelog&lt;/code&gt;&lt;/a&gt; installed &lt;code&gt;pip install antsibull-changelog&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Make sure there are fragments for all known changes in &lt;code&gt;changelogs/fragments&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Add a new fragment with the header &lt;code&gt;release_summary&lt;/code&gt; to give a summary on the release.&lt;/li&gt; &#xA;   &lt;li&gt;Run &lt;code&gt;antsibull-changelog release&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Commit the changes and wait for CI to be green&lt;/li&gt; &#xA; &lt;li&gt;Build and publish the collection to Galaxy: &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/ansible-collections/ansible.windows.git /tmp/ansible.windows&#xA;ansible-galaxy collection build /tmp/ansible.windows --output-path /tmp/ansible.windows&#xA;ansible-galaxy collection publish $(find /tmp/ansible.windows -maxdepth 1 -name &#39;ansible-windows-*.tar.gz&#39;) --token &amp;lt;API_KEY&amp;gt; -vv&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After the version is published, verify it exists on the &lt;a href=&#34;https://galaxy.ansible.com/ansible/windows&#34;&gt;Windows Core Collection Galaxy page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;More Information&lt;/h2&gt; &#xA;&lt;p&gt;For more information about Ansible&#39;s Windows integration, join the &lt;code&gt;#ansible-windows&lt;/code&gt; channel on &lt;a href=&#34;https://libera.chat/&#34;&gt;libera.chat&lt;/a&gt; IRC, and browse the resources in the &lt;a href=&#34;https://github.com/ansible/community/wiki/Windows&#34;&gt;Windows Working Group&lt;/a&gt; Community wiki page.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ansible-collections/overview&#34;&gt;Ansible Collection overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/user_guide/index.html&#34;&gt;Ansible User guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/dev_guide/index.html&#34;&gt;Ansible Developer guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/community/code_of_conduct.html&#34;&gt;Ansible Community code of conduct&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;GNU General Public License v3.0 or later&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/ansible-collections/ansible.windows/main/COPYING&#34;&gt;COPYING&lt;/a&gt; to see the full text.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>BloodHoundAD/BARK</title>
    <updated>2022-08-07T01:50:00Z</updated>
    <id>tag:github.com,2022-08-07:/BloodHoundAD/BARK</id>
    <link href="https://github.com/BloodHoundAD/BARK" rel="alternate"></link>
    <summary type="html">&lt;p&gt;BloodHound Attack Research Kit&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BARK&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/skPLO7U.jpg&#34; alt=&#34;BARK Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;BARK stands for BloodHound Attack Research Kit. It is a PowerShell script built to assist the BloodHound Enterprise team with researching and continuously validating abuse primitives. BARK currently focuses on Microsoft&#39;s Azure suite of products and services.&lt;/p&gt; &#xA;&lt;p&gt;BARK requires no third party dependencies. BARK&#39;s functions are designed to be as simple and maintainable as possible. Most functions are very simple wrappers for making requests to various REST API endpoints. BARK&#39;s basic functions do not even require each other - you can pull almost any BARK function out of BARK and it will work perfectly as a standalone function in your own scripts.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;There are &lt;a href=&#34;https://www.netspi.com/blog/technical/network-penetration-testing/15-ways-to-bypass-the-powershell-execution-policy/&#34;&gt;many ways&lt;/a&gt; to import a PowerShell script. Here&#39;s one way:&lt;/p&gt; &#xA;&lt;p&gt;First, download BARK.ps1 by cloning this repo or simply copy/pasting its raw contents from GitHub.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/BloodHoundAD/BARK&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, cd into the directory where the PS1 is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd BARK&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, you can dot import the PS1 like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;. .\BARK.ps1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hit enter, and your PowerShell instance will now have access to all of BARK&#39;s functions.&lt;/p&gt; &#xA;&lt;h2&gt;Running your first BARK commands&lt;/h2&gt; &#xA;&lt;p&gt;With very few exceptions, Azure API endpoints require authentication to interact with. BARK comes with a few functions that will help you acquire the necessary tokens for interacting with the MS Graph and Azure REST APIs. Any BARK function that interacts with an Azure API that requires authentication will require you to supply a token.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say you want to list all of the users in an Azure Active Directory tenant. You first need to get a token scoped for MS Graph. There are many ways to get this token:&lt;/p&gt; &#xA;&lt;p&gt;If you have a username/password combination for an AzureAD user in that tenant, you can first acquire a refresh token for the user using BARK&#39;s &lt;code&gt;Get-AZRefreshTokenWithUsernamePassword&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$MyRefreshTokenRequest = Get-AZRefreshTokenWithUsernamePassword -username &#34;arobbins@contoso.onmicrosoft.com&#34; -password &#34;MyVeryCoolPassword&#34; -TenantID &#34;contoso.onmicrosoft.com&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting object you just created, &lt;code&gt;$MyRefreshTokenRequest&lt;/code&gt;, will have as part of it a refresh token for your user. You can now request an MS Graph-scoped token using this refresh token:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$MyMSGraphToken = Get-MSGraphTokenWithRefreshToken -RefreshToken $MyRefreshTokenRequest.refresh_token -TenantID &#34;contoso.onmicrosoft.com&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now this new object, &lt;code&gt;$MyMSGraphToken&lt;/code&gt;, will have as one of its property values an MS Graph-scoped JWT for your user. You are now ready to use this token to list all the users in the AzureAD tenant:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$MyAADUsers = Get-AllAzureADUsers -Token $MyMSGraphToken.access_token -ShowProgress&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once finished, the &lt;code&gt;$MyAADUsers&lt;/code&gt; variable will be populated by objects representing all of the users in your AzureAD tenant.&lt;/p&gt; &#xA;&lt;h2&gt;Token Management and Manipulation Functions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Parse-JWTToken&lt;/code&gt; will take a Base64 encoded JWT as input and parse it for you. Useful for verifying correct token audience and claims.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-AZRefreshTokenWithUsernamePassword&lt;/code&gt; requests a collection of tokens, including a refresh token, from login.microsoftonline.com with a user-supplied username and password. This will fail if the user has Multi-Factor Authentication requirements or is affected by a Conditional Access Policy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-MSGraphTokenWithClientCredentials&lt;/code&gt; requests an MS Graph-scoped JWT with a client ID and secret. Useful for authenticating as an AzureAD service principal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-MSGraphTokenWithRefreshToken&lt;/code&gt; requests an MS Graph-scoped JWT with a user-supplied refresh token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-MSGraphTokenWithPortalAuthRefreshToken&lt;/code&gt; requests an MS Graph-scoped JWT with a user-supplied Azure Portal Auth Refresh token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-AzureRMTokenWithClientCredentials&lt;/code&gt; requests an AzureRM-scoped JWT with a client ID and secret. Useful for authenticating as an AzureAD service principal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-ARMTokenWithPortalAuthRefreshToken&lt;/code&gt; requests an AzureRM-scoped JWT with a user-supplied Azure Portal Auth Refresh token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-ARMTokenWithRefreshToken&lt;/code&gt; requests an AzureRM-scoped JWT with a user-supplied refresh token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-AzurePortalTokenWithRefreshToken&lt;/code&gt; requests an Azure Portal Auth Refresh token with a user-supplied refresh token.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The refresh token-based functions in BARK are based on functions in &lt;a href=&#34;https://raw.githubusercontent.com/BloodHoundAD/BARK/main/TokenTactics&#34;&gt;https://github.com/rvrsh3ll/TokenTactics&lt;/a&gt; by [https://twitter.com/424f424f](Steve Borosh)&lt;/p&gt; &#xA;&lt;h2&gt;Abuse Functions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Set-AZUserPassword&lt;/code&gt; will attempt to set the password of another user to a new user-provided value.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Reset-AZUserPassword&lt;/code&gt; will attempt to reset the password of another user. If successful, the output will contain the new, Azure-generated password of the user&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;New-AzureRMRoleAssignment&lt;/code&gt; will attempt to grant a user-specified AzureRM role assignment to a particular principal over a certain scope.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;New-AppRegSecret&lt;/code&gt; will attempt to create a new secret for an existing AzureAD app registration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;New-ServicePrincipalSecret&lt;/code&gt; will attempt to create a new secret for an existing AzureAD service principal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;New-AppRoleAssignment&lt;/code&gt; will attempt to grant an app role to a service principal. For example, you can use this to grant a service principal the RoleManagement.ReadWrite.Directory app role.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Enumeration Functions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-AzureRMRoleDefinitions&lt;/code&gt; collects all role definitions described at a subscription scope, including custom roles.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-MGAppRoles&lt;/code&gt; collects the app roles made available by the MS Graph service principal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-AllAzureADApps&lt;/code&gt; collects all AzureAD application registration objects.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-AllAzureADServicePrincipals&lt;/code&gt; collects all AzureAD service principal objects.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-AllAzureADUsers&lt;/code&gt; collects all AzureAD users.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-AllAzureADGroups&lt;/code&gt; collects all AzureAD groups.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Get-AllAzureRMSubscriptions&lt;/code&gt; collects all AzureRM subscriptions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Meta Functions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Test-AzureRMAddSelfToAzureRMRole&lt;/code&gt; used in abuse validation testing to determine whether a service principal with certain rights can grant itself the User Access Admin role over a subscription.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Test-AzureRMCreateFunction&lt;/code&gt; used in abuse validation testing to test if a service principal can add a new function to an existing function app.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Invoke-AllAzureRMAbuseTests&lt;/code&gt; performs all AzureRM abuse validation tests and outputs a resulting object that describes which AzureRM roles granted the ability to perform each abuse.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Remove-AbuseTestAzureRMRoles&lt;/code&gt; is a clean-up function for removing AzureRM admin roles created during testing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Remove-AbuseTestServicePrincipals&lt;/code&gt; cleans up abuse tests by removing the serivce principals that were created during testing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;New-TestAppReg&lt;/code&gt; creates an application registration object for the explicit purpose of abuse validation testing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;New-TestSP&lt;/code&gt; creates a new service principal and associates it with the app created by the above function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Test-MGAddSelfAsOwnerOfApp&lt;/code&gt; is used in abuse validation testing to determine whether a service principal with a particular privilege can grant itself ownership of an existing AzureAD app.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Test-MGAddSelfAsOwnerOfSP&lt;/code&gt; is used in abuse validation testing to determine whether a service principal with a particular privilege can grant itself ownership of an existing AzureAD service principal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Test-MGAddSelfToAADRole&lt;/code&gt; is used in abuse validation testing to determine whether a service principal with a particular privilege can add itself to an AzureAD admin role - Global Admin, for example.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Test-MGAddSelfToMGAppRole&lt;/code&gt;is used in abuse validation testing to determine whether a service principal with a particular privilege can grant itself a particular MS Graph app role without admin consent.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Test-MGAddOwnerToRoleEligibleGroup&lt;/code&gt; is used to test whether a service principal can grant itself explicit ownership of a role assignable group.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Test-MGAddMemberToRoleEligibleGroup&lt;/code&gt; is used to test whether the service principal can add itself to a role assignable group.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Test-MGAddSecretToSP&lt;/code&gt; is used to test whether the service principal can add a new secret to an existing service principal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Test-MGAddSecretToApp&lt;/code&gt; is used to test whether the service principal can add a new secret to an existing app.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Invoke-AllAzureMGAbuseTests&lt;/code&gt; performs all abuse validation tests that can be executed by holding an MS Graph app role. Returns an object describing which privileges were successful at performing each abuse test.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Invoke-AllAzureADAbuseTests&lt;/code&gt; performs all abuse validation tests that can be executed by principals granted AzureAD admin roles. Returns an object describing which privileges were successful at performing each abuse test.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ConvertTo-Markdown&lt;/code&gt; is used for massaging output from the Invoke-&#xA;  &lt;type&gt;&#xA;   Tests functions for usage in another platform.&#xA;  &lt;/type&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>