<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-09T01:36:40Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zanfranceschi/rinha-de-backend-2024-q1</title>
    <updated>2024-02-09T01:36:40Z</updated>
    <id>tag:github.com,2024-02-09:/zanfranceschi/rinha-de-backend-2024-q1</id>
    <link href="https://github.com/zanfranceschi/rinha-de-backend-2024-q1" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Repositório da 2ª edição da Rinha de Backend&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rinha de Backend - 2024/Q1&lt;/h1&gt; &#xA;&lt;p&gt;A Rinha de Backend é um desafio que tem como principal objetivo compartilhar conhecimento em formato de desafio! Esta é a segunda edição. A data limite para enviar sua submissão é &lt;code&gt;2024-03-10T23:59:59-03:00&lt;/code&gt; e em &lt;code&gt;2024-03-14T19:00:00-03:00&lt;/code&gt; os resultados serão anunciados &lt;a href=&#34;https://www.youtube.com/watch?v=2OonGBGcl5k&#34;&gt;numa live&lt;/a&gt; no YouTube.&lt;/p&gt; &#xA;&lt;p&gt;O principal assunto dessa Rinha trata de controle de concorrência com o tema créditos e débitos (crébitos) e foi inspirado pelos colegas &lt;a href=&#34;https://twitter.com/lucascs&#34;&gt;@lucascs&lt;/a&gt; e &lt;a href=&#34;https://twitter.com/kmyokoyama&#34;&gt;@kmyokoyama&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/lucascs/status/1744014270331769000&#34;&gt;nesse&lt;/a&gt; e &lt;a href=&#34;https://twitter.com/kmyokoyama/status/1744018208082760133&#34;&gt;nesse&lt;/a&gt; comentário &lt;a href=&#34;https://twitter.com/zanfranceschi/status/1743876243815059738&#34;&gt;dessa&lt;/a&gt; tweet.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/misc/arte.jpg&#34; alt=&#34;arte&#34;&gt; Se quiser entender mais sobre o espírito das Rinhas, confira o &lt;a href=&#34;https://github.com/zanfranceschi/rinha-de-backend-2023-q3&#34;&gt;repositório da primeira edição&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Ah! E antes de continuar, é importante dizer que a &lt;a href=&#34;https://cubos.academy/&#34;&gt;Cubos Academy&lt;/a&gt; disponibilizou o cupom &lt;code&gt;RINHADEV&lt;/code&gt; que te dá 20% de desconto &lt;strong&gt;PARA QUALQUER CURSO&lt;/strong&gt;! Vai lá no site deles e dá uma olhada – têm muitos cursos bem legais!&lt;/p&gt; &#xA;&lt;h2&gt;O Que Precisa Ser Feito?&lt;/h2&gt; &#xA;&lt;p&gt;Para participar você precisa desenvolver uma API HTTP com os seguintes endpoints:&lt;/p&gt; &#xA;&lt;h3&gt;Transações&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Requisição&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;POST /clientes/[id]/transacoes&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;valor&#34;: 1000,&#xA;    &#34;tipo&#34; : &#34;c&#34;,&#xA;    &#34;descricao&#34; : &#34;descricao&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Onde&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;[id]&lt;/code&gt; (na URL) deve ser um número inteiro representando a identificação do cliente.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;valor&lt;/code&gt; deve um número inteiro positivo que representa centavos (não vamos trabalhar com frações de centavos). Por exemplo, R$ 10 são 1000 centavos.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tipo&lt;/code&gt; deve ser apenas &lt;code&gt;c&lt;/code&gt; para crédito ou &lt;code&gt;d&lt;/code&gt; para débito.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;descricao&lt;/code&gt; deve ser uma string de 1 a 10 caractéres.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Todos os campos são obrigatórios.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Resposta&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;HTTP 200 OK&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;limite&#34; : 100000,&#xA;    &#34;saldo&#34; : -9098&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Onde&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;limite&lt;/code&gt; deve ser o limite cadastrado do cliente.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;saldo&lt;/code&gt; deve ser o novo saldo após a conclusão da transação.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Obrigatoriamente, o http status code de requisições para transações bem sucedidas deve ser 200!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Regras&lt;/strong&gt; Uma transação de débito &lt;strong&gt;nunca&lt;/strong&gt; pode deixar o saldo do cliente menor que seu limite disponível. Por exemplo, um cliente com limite de 1000 (R$ 10) nunca deverá ter o saldo menor que -1000 (R$ -10). Nesse caso, um saldo de -1001 ou menor significa inconsistência na Rinha de Backend!&lt;/p&gt; &#xA;&lt;p&gt;Se uma requisição para débito for deixar o saldo inconsistente, a API deve retornar HTTP Status Code 422 sem completar a transação! O corpo da resposta nesse caso não será testado e você pode escolher como o representar.&lt;/p&gt; &#xA;&lt;p&gt;Se o atributo &lt;code&gt;[id]&lt;/code&gt; da URL for de uma identificação não existente de cliente, a API deve retornar HTTP Status Code 404. O corpo da resposta nesse caso não será testado e você pode escolher como o representar. Se a API retornar algo como HTTP 200 informando que o cliente não foi encontrado no corpo da resposta ou HTTP 204 sem corpo, ficarei extremamente deprimido e a Rinha será cancelada para sempre.&lt;/p&gt; &#xA;&lt;h2&gt;Extrato&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Requisição&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;GET /clientes/[id]/extrato&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Onde&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;[id]&lt;/code&gt; (na URL) deve ser um número inteiro representando a identificação do cliente.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Resposta&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;HTTP 200 OK&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;saldo&#34;: {&#xA;    &#34;total&#34;: -9098,&#xA;    &#34;data_extrato&#34;: &#34;2024-01-17T02:34:41.217753Z&#34;,&#xA;    &#34;limite&#34;: 100000&#xA;  },&#xA;  &#34;ultimas_transacoes&#34;: [&#xA;    {&#xA;      &#34;valor&#34;: 10,&#xA;      &#34;tipo&#34;: &#34;c&#34;,&#xA;      &#34;descricao&#34;: &#34;descricao&#34;,&#xA;      &#34;realizada_em&#34;: &#34;2024-01-17T02:34:38.543030Z&#34;&#xA;    },&#xA;    {&#xA;      &#34;valor&#34;: 90000,&#xA;      &#34;tipo&#34;: &#34;d&#34;,&#xA;      &#34;descricao&#34;: &#34;descricao&#34;,&#xA;      &#34;realizada_em&#34;: &#34;2024-01-17T02:34:38.543030Z&#34;&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Onde&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;saldo&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;total&lt;/code&gt; deve ser o saldo total atual do cliente (não apenas das últimas transações seguintes exibidas).&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;data_extrato&lt;/code&gt; deve ser a data/hora da consulta do extrato.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;limite&lt;/code&gt; deve ser o limite cadastrado do cliente.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ultimas_transacoes&lt;/code&gt; é uma lista ordenada por data/hora das transações de forma decrescente contendo até as 10 últimas transações com o seguinte: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;valor&lt;/code&gt; deve ser o valor da transação.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;tipo&lt;/code&gt; deve ser &lt;code&gt;c&lt;/code&gt; para crédito e &lt;code&gt;d&lt;/code&gt; para débito.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;descricao&lt;/code&gt; deve ser a descrição informada durante a transação.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;realizada_em&lt;/code&gt; deve ser a data/hora da realização da transação.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Regras&lt;/strong&gt; Se o atributo &lt;code&gt;[id]&lt;/code&gt; da URL for de uma identificação não existente de cliente, a API deve retornar HTTP Status Code 404. O corpo da resposta nesse caso não será testado e você pode escolher como o representar. Já sabe o que acontece se sua API retornar algo na faixa 2XX, né? Agradecido.&lt;/p&gt; &#xA;&lt;h2&gt;Cadastro Inicial de Clientes&lt;/h2&gt; &#xA;&lt;p&gt;Para haver ênfase em concorrência durante o teste, poucos clientes devem ser cadastrados e testados. Por isso, apenas cinco clientes, com os seguintes IDs, limites e saldos iniciais, devem ser previamente cadastrados para o teste – isso é imprescindível!&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;id&lt;/th&gt; &#xA;   &lt;th&gt;limite&lt;/th&gt; &#xA;   &lt;th&gt;saldo inicial&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;100000&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;80000&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;1000000&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;10000000&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;500000&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Obs.: Não cadastre um cliente com o ID 6 especificamente, pois parte do teste é verificar se o cliente com o ID 6 realmente não existe e a API retorna HTTP 404!&lt;/p&gt; &#xA;&lt;h2&gt;Como Fazer e Entregar?&lt;/h2&gt; &#xA;&lt;p&gt;Assim como na Rinha de Backend anterior, você precisará conteinerizar sua API e outros componentes usados no formato de &lt;em&gt;docker-compose&lt;/em&gt;, obedecer às &lt;a href=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/#restricoes&#34;&gt;restrições de recursos de CPU e memória&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/#arquitetura&#34;&gt;configuração mínima arquitetural&lt;/a&gt;, e estrutura de artefatos e processo de entrega (o que, onde e quando suas coisas precisam ser entregues).&lt;/p&gt; &#xA;&lt;p&gt;Você pode fazer a submissão de forma individual, dupla de 2, dupla de 3 ou até dupla de 50 pessoas. Não tem limite. E você e/ou seu grupo pode fazer mais de uma submissão desde que a API seja diferente.&lt;/p&gt; &#xA;&lt;h3&gt;Artefato, Processo e Data Limite de Entrega&lt;/h3&gt; &#xA;&lt;p&gt;Para participar, basta fazer um pull request neste repositório incluindo um subdiretório em &lt;a href=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/participantes&#34;&gt;participantes&lt;/a&gt; com os seguintes arquivos:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; - arquivo interpretável por &lt;code&gt;docker-compose&lt;/code&gt; contendo a declaração dos serviços que compõe sua API respeitando as &lt;a href=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/#restricoes&#34;&gt;restrições de CPU/memória&lt;/a&gt; e &lt;a href=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/#arquitetura&#34;&gt;arquitetura mínima&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;README.md&lt;/code&gt; - incluindo pelo menos seu nome, tecnologias que usou, o link para o repositório do código fonte da sua API, e alguma forma de entrar em contato caso vença. Fique à vontade para incluir informações adicionais como link para site, etc.&lt;/li&gt; &#xA; &lt;li&gt;Inclua aqui também quaisquer outros diretórios/arquivos necessários para que seus contêineres subam corretamente como, por exemplo, &lt;code&gt;nginx.conf&lt;/code&gt;, &lt;code&gt;banco.sql&lt;/code&gt;, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/participantes/exemplo&#34;&gt;Aqui&lt;/a&gt; tem um exemplo de submissão para te ajudar, caso queira.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Importante!&lt;/strong&gt; É fundamental que todos os serviços declarados no &lt;code&gt;docker-compose.yml&lt;/code&gt; estejam publicamente disponíveis! Caso contrário, não será possível executar os testes. Para isso, você pode criar uma conta em hub.docker.com para disponibilizar suas imagens. Essa imagens geralmente terão o formato &amp;lt;user&amp;gt;/&amp;lt;imagem&amp;gt;:&amp;lt;tag&amp;gt; – por exemplo, &lt;code&gt;zanfranceschi/rinha-api:latest&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Um erro comum na edição anterior da Rinha foi a declaração de imagens como se estivessem presentes localmente. Isso pode ser verdade para quem as construiu (realizou o build localmente), mas não será verdadeiro para o servidor que executará os testes!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Importante!&lt;/strong&gt; É obrigatório deixar o repositório contendo o código fonte da sua API publicamente acessível e informado no arquivo &lt;code&gt;README.md&lt;/code&gt; entregue na submissão. Afinal, a Rinha de Backend tem como principal objetivo compartilhar conhecimento!&lt;/p&gt; &#xA;&lt;p&gt;Um exemplo de submissão/pull request da Ana, poderia ter os seguintes arquivos:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;├─ participantes/&#xA;|  ├─ ana-01/&#xA;|  |  ├─ docker-compose.yml&#xA;|  |  ├─ nginx.config&#xA;|  |  ├─ sql/&#xA;|  |  |  ├─ ddl.sql&#xA;|  |  |  ├─ dml.sql&#xA;|  |  ├─ README.md&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A data/hora limite para fazer pull requests para sua submissão é até &lt;code&gt;2024-03-10T23:59:59-03:00&lt;/code&gt;. Após esse dia/hora, qualquer pull request será automaticamente rejeitado.&lt;/p&gt; &#xA;&lt;p&gt;Note que você poderá fazer quantos pull requests desejar até essa data/hora limite!&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a name=&#34;arquitetura&#34;&gt;Arquitetura Mínima da API&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Por &#34;API&#34; aqui, me refiro a todos os serviços envolvidos para que o serviço que atenderá às requisições HTTP funcione, tais como o load balancer, banco de dados e servidor HTTP.&lt;/p&gt; &#xA;&lt;p&gt;A sua API precisa ter, no mínimo, os seguintes serviços:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Um &lt;strong&gt;load balancer&lt;/strong&gt; que faça a distribuição de tráfego usando o algoritmo round robin. Diferentemente da edição anterior, você não precisa usar o Nginx – pode escolher (ou até fazer) qualquer um como p.ex. o HAProxy. &lt;strong&gt;O load balancer será o serviço que receberá as requisições do teste e ele precisa aceitar requisições na porta 9999&lt;/strong&gt;!&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;2 instâncias de servidores web&lt;/strong&gt; que atenderão às requisições HTTP (distribuídas pelo load balancer).&lt;/li&gt; &#xA; &lt;li&gt;Um banco de dados relacional ou não relacional (exceto bancos de dados que têm como principal característica o armazenamento de dados em memória, tal como Redis, por exemplo).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart TD&#xA;    G(Stress Test - Gatling) -.-&amp;gt; LB(Load Balancer / porta 9999)&#xA;    subgraph Sua Aplicação&#xA;        LB -.-&amp;gt; API1(API - instância 01)&#xA;        LB -.-&amp;gt; API2(API - instância 02)&#xA;        API1 -.-&amp;gt; Db[(Database)]&#xA;        API2 -.-&amp;gt; Db[(Database)]&#xA;    end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: Você pode usar componentes adicionais se quiser. Mas lembre-se de que as restrições de CPU e memória devem obedecer a regra de que a soma dos limites (que devem ser declarados para todos os serviços) não poderá ultrapassar 1.5 unidades de CPU e 550MB de memória! Use o bom senso e boa fé, não adicione um banco relacional e um Redis, por exemplo, e use apenas o Redis como armazenamento – afinal, a Rinha é apenas uma brincadeira que fomenta o aprendizado e não a competição desleal.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a name=&#34;restricoes&#34;&gt;Restrições de CPU/Memória&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Dentro do seu arquivo docker-compose.yml, você deverá limitar todos os serviços para que a soma deles não ultrapasse os seguintes limites:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;deploy.resources.limits.cpu&lt;/code&gt; 1.5 – uma unidade e meia de CPU distribuída entre todos os seus serviços&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;deploy.resources.limits.memory&lt;/code&gt; 550MB – 550 mega bytes de memória distribuídos entre todos os seus serviços&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Obs.: Por favor, use &lt;code&gt;MB&lt;/code&gt; para unidade de medida de memória; isso facilita as verificações de restrições.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# exemplo de parte de configuração de um serviço dentro do um arquivo docker-compose.yml&#xA;...&#xA;  nginx:&#xA;    image: nginx:latest&#xA;    volumes:&#xA;      - ./nginx.conf:/etc/nginx/nginx.conf:ro&#xA;    depends_on:&#xA;      - api01&#xA;      - api02&#xA;    ports:&#xA;      - &#34;9999:9999&#34;&#xA;    deploy:&#xA;      resources:&#xA;        limits:&#xA;          cpus: &#34;0.17&#34;&#xA;          memory: &#34;10MB&#34;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a name=&#34;examplo&#34;&gt;Arquivos de exemplo para te ajudar&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;O seguinte são apenas arquivos de exemplo para que você não saia do zero, caso tenha alguma dificuldade ou apenas queira acelerar a construção da sua API. Obviamente, modifique como quiser respeitando todos as restrições anteriormente explicadas aqui. Novamente, você não precisa usar especificamente um banco de dados relacional – o exemplo seguinte é apenas ilustrativo.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;version: &#34;3.5&#34;&#xA;&#xA;services:&#xA;  api01: &amp;amp;api&#xA;    # Lembre-se de que seu serviço HTTP deve estar hospedado num repositório&#xA;    # publicamente acessível! Ex.: hub.docker.com&#xA;    image: ana/minha-api-matadora:latest&#xA;    hostname: api01&#xA;    environment:&#xA;      - DB_HOSTNAME=db&#xA;    &#xA;    # Não é necessário expor qualquer porta além da porta do load balancer,&#xA;    # mas é comum as pessoas o fazerem para testarem suas APIs e conectarem&#xA;    # ao banco de dados na fase de desenvolvimento.&#xA;    ports:&#xA;      - &#34;8081:8080&#34;&#xA;    depends_on:&#xA;      - db&#xA;    deploy:&#xA;      resources:&#xA;        limits:&#xA;          cpus: &#34;0.6&#34;&#xA;          memory: &#34;200MB&#34;&#xA;&#xA;  api02:&#xA;    # Essa sintaxe reusa o que foi declarado em &#39;api01&#39;.&#xA;    &amp;lt;&amp;lt;: *api &#xA;    hostname: api02&#xA;    environment:&#xA;      - DB_HOSTNAME=db&#xA;    ports:&#xA;      - &#34;8082:8080&#34;&#xA; &#xA;  nginx:&#xA;    image: nginx:latest&#xA;    volumes:&#xA;      - ./nginx.conf:/etc/nginx/nginx.conf:ro&#xA;    depends_on:&#xA;      - api01&#xA;      - api02&#xA;    ports:&#xA;        # Obrigatório expor/usar a porta 9999 no load balancer!&#xA;      - &#34;9999:9999&#34; &#xA;    deploy:&#xA;      resources:&#xA;        limits:&#xA;          cpus: &#34;0.17&#34;&#xA;          memory: &#34;10MB&#34;&#xA;&#xA;  db:&#xA;    image: postgres:latest&#xA;    hostname: db&#xA;    environment:&#xA;      - POSTGRES_PASSWORD=123&#xA;      - POSTGRES_USER=admin&#xA;      - POSTGRES_DB=rinha&#xA;    ports:&#xA;      - &#34;5432:5432&#34;&#xA;    volumes:&#xA;      - ./script.sql:/docker-entrypoint-initdb.d/script.sql&#xA;    deploy:&#xA;      resources:&#xA;        limits:&#xA;          # Note que a soma de todos os limites dos serviços&#xA;          # aqui declarados é de 1.5 unidades de CPU e 550MB&#xA;          # de memória. A distribuição feita aqui é apenas&#xA;          # um exemplo – distribua como quiser.&#xA;          cpus: &#34;0.13&#34;&#xA;          memory: &#34;140MB&#34;&#xA;&#xA;# O uso do modo `bridge` deve ser adequado à carga que será usada no teste.&#xA;# A edição anterior se beneficiou do modo host pois o volume de requisições&#xA;# era relativamente alto e a virtualização da rede se tornou um gargalo, mas&#xA;# este modo é mais complexo de ser configurado. Fique à vontade para usar o&#xA;# modo que quiser desde que não conflite com portas trivialmente usadas em um&#xA;# SO.&#xA;networks:&#xA;  default:&#xA;    driver: bridge&#xA;    name: rinha-nginx-2024q1&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;script.sql&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- Coloque scripts iniciais aqui&#xA;CREATE TABLE...&#xA;&#xA;DO $$&#xA;BEGIN&#xA;  INSERT INTO clientes (nome, limite)&#xA;  VALUES&#xA;    (&#39;o barato sai caro&#39;, 1000 * 100),&#xA;    (&#39;zan corp ltda&#39;, 800 * 100),&#xA;    (&#39;les cruders&#39;, 10000 * 100),&#xA;    (&#39;padaria joia de cocaia&#39;, 100000 * 100),&#xA;    (&#39;kid mais&#39;, 5000 * 100);&#xA;END; $$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;nginx.conf&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-config&#34;&gt;events {&#xA;    worker_connections 1000;&#xA;}&#xA;&#xA;http {&#xA;    access_log off;&#xA;    sendfile   on;&#xA;    &#xA;    upstream api {&#xA;        server api01:8080;&#xA;        server api02:8080;&#xA;    }&#xA;&#xA;    server {&#xA;        listen 9999; # Lembra da porta 9999 obrigatória?&#xA;        &#xA;        location / {&#xA;            proxy_pass http://api;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Ferramenta de Teste&lt;/h2&gt; &#xA;&lt;p&gt;Como na edição anterior, a ferramenta Gatling será usada novamente para realizar o teste de performance. Pode fazer muita diferença você executar os testes durante a fase de desenvolvimento para detectar possíveis problemas e gargalos. O teste está disponível nesse repositório em &lt;a href=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/load-test&#34;&gt;load-test&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Ambiente de Testes&lt;/h2&gt; &#xA;&lt;p&gt;Para saber os detalhes sobre o ambiente (SO e versões de software) acesse &lt;a href=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/SPECTESTENV.md&#34;&gt;Especificações do Ambiente de Testes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note que o ambiente em que os testes serão executados é Linux x64. Portanto, se seu ambiente de desenvolvimento possui outra arquitetura, você precisará fazer o build do docker da seguinte forma: &lt;code&gt;$ docker buildx build --platform linux/amd64&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Por exemplo: &lt;code&gt;$ docker buildx build --platform linux/amd64 -t ana/minha-api-matadora:latest .&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Para executar os testes&lt;/h3&gt; &#xA;&lt;p&gt;Aqui estão instruções rápidas para você poder executar os testes:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Baixe o Gatling em &lt;a href=&#34;https://gatling.io/open-source/&#34;&gt;https://gatling.io/open-source/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Certifique-se de que tenha o JDK instalado (64bits OpenJDK LTS (Long Term Support) versions: 11, 17 e 21) &lt;a href=&#34;https://gatling.io/docs/gatling/tutorials/installation/&#34;&gt;https://gatling.io/docs/gatling/tutorials/installation/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Configure o script &lt;code&gt;./executar-teste-local.sh&lt;/code&gt; (ou &lt;code&gt;./executar-teste-local.ps1&lt;/code&gt; se estiver no Windows)&lt;/li&gt; &#xA; &lt;li&gt;Suba sua API (ou load balancer) na porta 9999&lt;/li&gt; &#xA; &lt;li&gt;Execute &lt;code&gt;./executar-teste-local.sh&lt;/code&gt; (ou &lt;code&gt;./executar-teste-local.ps1&lt;/code&gt; se estiver no Windows)&lt;/li&gt; &#xA; &lt;li&gt;Agora é só aguardar o teste terminar e abrir o relatório O caminho do relatório é exibido ao término da simulação. Os resultados/relatórios são salvos em &lt;code&gt;./load-test/user-files/results&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Fique à vontade para alterar a &lt;a href=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/load-test/user-files/simulations/rinhabackend/RinhaBackendCrebitosSimulation.scala&#34;&gt;simulação&lt;/a&gt; para testar diferentes aspectos e cenários. Não inclua essas alterações no pull request de submissão!&lt;/p&gt; &#xA;&lt;p&gt;De nada :)&lt;/p&gt; &#xA;&lt;h3&gt;Pré teste&lt;/h3&gt; &#xA;&lt;p&gt;Na edição anterior da Rinha, o teste começava poucos segundos após a subida dos contêineres e, devido as restrições de CPU e memória, nem todos os serviços estavam prontos para receber requisições em tão pouco tempo. Nessa edição, antes do teste iniciar, um script verificará se a API está respondendo corretamente (via &lt;code&gt;GET /clientes/1/extrato&lt;/code&gt;) por até 40 segundos em intervalos de 2 segundos a cada tentativa. Por isso, certifique-se de que todos seus serviços não demorem mais do que 40 segundos para estarem aptos a receberem requisições!&lt;/p&gt; &#xA;&lt;h4&gt;Nota importante sobre o teste escrito!&lt;/h4&gt; &#xA;&lt;p&gt;A simulação contém um teste de lógica de saldo/limite que extrapola o que é comumente feito em testes de performance. O escrevi assim apenas por causa da natureza da Rinha de Backend. Evite fazer esse tipo de coisa em testes de performance, pois não é uma prática recomendada normalmente. Testes de lógica devem ficar junto ao código fonte em formato de testes de unidade ou integração!&lt;/p&gt; &#xA;&lt;h2&gt;Critérios para Vencer A Rinha de Backend&lt;/h2&gt; &#xA;&lt;p&gt;Surpresa! :)&lt;/p&gt; &#xA;&lt;h2&gt;Acompanhamento do Status das Execuções dos Testes&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zanfranceschi/rinha-de-backend-2024-q1/main/STATUS-TESTES.md&#34;&gt;Link do status parcial da Rinha de Backend&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>u-abramchuk/mcClassSys</title>
    <updated>2024-02-09T01:36:40Z</updated>
    <id>tag:github.com,2024-02-09:/u-abramchuk/mcClassSys</id>
    <link href="https://github.com/u-abramchuk/mcClassSys" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Macro-based class system in scala&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;mcClassSys&lt;/h1&gt; &#xA;&lt;p&gt;One of the important techniques enabled by compile-time metaprogramming is modular language extensibility. With macros, functionality that is typically provided as a hardcoded set of language features can be introduced piece-wise, as a part of the standard library. This is applicable even for such a fundamental functionality as class system [1]. This project will:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;define a baseline subset of Scala that would be used to host the class system,&lt;/li&gt; &#xA; &lt;li&gt;implement a macro-based desugaring which maps object-oriented concepts onto the baseline (an example of such a desugaring can be found in [2]).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The project is especially interesting in the context of the dependent object types research [3], which aims to provide a foundation of Scala. Macros can separate the core calculus of DOT from the rest of the language, keeping the heart of the language pristine.&lt;/p&gt; &#xA;&lt;p&gt;References:&lt;br&gt; [1] Scheme with Classes, Mixins, and Traits &lt;a href=&#34;http://www.ccs.neu.edu/racket/pubs/asplas06-fff.pdf&#34;&gt;http://www.ccs.neu.edu/racket/pubs/asplas06-fff.pdf&lt;/a&gt;&lt;br&gt; [2] Types and Programming Languages &lt;a href=&#34;http://www.cis.upenn.edu/~bcpierce/tapl/&#34;&gt;http://www.cis.upenn.edu/~bcpierce/tapl/&lt;/a&gt;&lt;br&gt; [3] Dependent Object Types, Towards a foundation for Scala’s type system &lt;a href=&#34;http://lampwww.epfl.ch/~amin/dot/fool.pdf&#34;&gt;http://lampwww.epfl.ch/~amin/dot/fool.pdf&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>