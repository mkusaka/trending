<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-26T01:34:56Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rbuckland/akka-escqrs</title>
    <updated>2024-03-26T01:34:56Z</updated>
    <id>tag:github.com,2024-03-26:/rbuckland/akka-escqrs</id>
    <link href="https://github.com/rbuckland/akka-escqrs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;straight.io - aka-persistence + spray.io + Jackson (Un)Marshalling&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;akka-escqrs&lt;/h1&gt; &#xA;&lt;h1&gt;akka-escqrs - akka-persistence Event Sourcing CQRS Implementation&lt;/h1&gt; &#xA;&lt;p&gt;This is a light touch framework (you don&#39;t have to depend on &#34;too many things&#34;).&lt;/p&gt; &#xA;&lt;p&gt;A basic framework - ES/CQRS Implemented on Akka Persistence&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ES - Event Sourcing&lt;/li&gt; &#xA; &lt;li&gt;CQRS - Command / Query Responsibility Separation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In the samples we show how to do some DDD designs for the model&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;DDD - Domain Driven design&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Application Design&lt;/h3&gt; &#xA;&lt;p&gt;This library is an implementation of types, traits and some additional helper classes to use as the base for your application.&lt;/p&gt; &#xA;&lt;h3&gt;Validation&lt;/h3&gt; &#xA;&lt;p&gt;Validation is expected to be used, currently the framework has two implementations&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Scalaz Validation&lt;/li&gt; &#xA; &lt;li&gt;Either Validation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A later version will endeavour to shift these out as pluggable traits. Currently they are your two choices.&lt;/p&gt; &#xA;&lt;p&gt;###&amp;nbsp;Code Base&lt;/p&gt; &#xA;&lt;p&gt;In essence there are three parts that this library implements for you.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Event Sourced Processor trait&lt;/li&gt; &#xA; &lt;li&gt;Repository for storing your objects (after the events have created them)&lt;/li&gt; &#xA; &lt;li&gt;Service class that gives you read access to the repository for querying it&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Event Sourced objects need a good key ID sequence. As a result, we use a UUID (GUUID) but not the way you normally expect.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;UuidRepository implementation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Samples&lt;/h3&gt; &#xA;&lt;p&gt;The samples include&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Reading Events to create some other view&lt;/li&gt; &#xA; &lt;li&gt;Managing Domain Validation (DDD style)&lt;/li&gt; &#xA; &lt;li&gt;Web implementation (see below)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Web APIs&lt;/h4&gt; &#xA;&lt;p&gt;This framework does not provide much in the way of webby stuff, it doesn&#39;t need to. Rather, it provides a sample app built witho&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Play (2.2.2)&lt;/li&gt; &#xA; &lt;li&gt;spray.io (1.3.1)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both Samples use AngularJS for the UI&lt;/p&gt; &#xA;&lt;p&gt;In these two apps you will see how Event Sourcing comes to life in reality (not just some theory).&lt;/p&gt; &#xA;&lt;p&gt;The API for the sample application is simple REST-esq services. We say REST-esq because Event Sourced / CQRS systems are all about sending Commands, and not CRUD/PUT, DELETE, GET instructions.&lt;/p&gt; &#xA;&lt;p&gt;Forget the theory, forget the fanfare, the APIs you can build with this library are nice&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;REST on the Read.. (GET /person/{id}) and on the)&lt;/li&gt; &#xA; &lt;li&gt;REST on the write (POST /person/changeName/{id})&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Marshalling Commands, Events and Domain Objects&lt;/h4&gt; &#xA;&lt;p&gt;To get the Command messages in and the Domain Objects out, we have a good implementation of Jackson JSON marshalling. it does support Jaxb, though this is an exercise for the reader. (Ramon Buckland does have experience if you need a hand)&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://krasserm.blogspot.co.uk/2012/02/using-jaxb-for-xml-and-json-apis-in.html&#34;&gt;http://krasserm.blogspot.co.uk/2012/02/using-jaxb-for-xml-and-json-apis-in.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Versions&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;spray.io : 1.3.1&lt;/li&gt; &#xA; &lt;li&gt;akka-persistence : 2.3.0&lt;/li&gt; &#xA; &lt;li&gt;akka : 2.3.0&lt;/li&gt; &#xA; &lt;li&gt;Scala : 2.10.3&lt;/li&gt; &#xA; &lt;li&gt;Optional : Scalaz 7.0.5 for Validation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Issues and Feature Requests&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;See the github issues list&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Details of the Implementation&lt;/h2&gt; &#xA;&lt;h3&gt;Messages&lt;/h3&gt; &#xA;&lt;p&gt;We took the approach that we don&#39;t won&#39;t this framework bleeding into your code. With that in mind, messages do not have to extend anything, but rather just have to provide a timestamp: Long method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sealed abstract class ConnectGroupCommand(val timestamp: Long)&#xA;&#xA;...&#xA;case class ChangeConnectGroupName(&#xA;    @JsonIgnore override val timestamp: Long = DateTime.now,&#xA;    uuid : Uuid,&#xA;    @JsonDeserialize(contentAs = classOf[java.lang.Long]) expectedVersion: Option[Long], &#xA;    name: String) extends ConnectGroupCommand(timestamp)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our suggestion is to have one base Command and Event abstract class per Event Sourced Processor. This way you can accruately route and manage these events throughout the system.&lt;/p&gt; &#xA;&lt;h3&gt;Using a repository (your memory Image)&lt;/h3&gt; &#xA;&lt;p&gt;The repository is a memory image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/**&#xA; * The Service in injected with effectively Read-Only access to the memory Image&#xA; *&#xA; * If you have special &#34;ways&#34; to interrogate your Service, then put them here&#xA; *&#xA; * @author rbuckland&#xA; */&#xA;class ConnectGroupService()&#xA;                         (implicit val bindingModule: BindingModule)&#xA;  extends UuidAbstractService[ConnectGroup]&#xA;  with AutoInjectable {&#xA;&#xA;  val repository: UuidRepository[ConnectGroup] = inject[UuidRepository[ConnectGroup]]&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The Actor akka-persistence Processor&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/**&#xA; * ConnectGroupProcessor&#xA; */&#xA;class ConnectGroupProcessor()&#xA;                           (implicit val bindingModule: BindingModule)&#xA;  extends SZValidationUuidAbstractProcessor[ConnectGroup, ConnectGroupEvent, ConnectGroupCommand]&#xA;  with AutoInjectable {&#xA;&#xA;  val repository = inject[UuidRepository[ConnectGroup]]&#xA;  val personService = inject[PersonService]&#xA;  val idGenerator = inject[UuidGenerator[ConnectGroup]]&#xA;&#xA;  /**&#xA;   * This magic method will create a ConnectGroup given an Event.&#xA;   * The AbstractProcessor calls this method on our behalf inside the persist(event) {  domainObjectFromEvent(event) }&#xA;   *&#xA;   * remember, although the event is &#34;past tense&#34; (eg ConnectGroupCreated) the order is&#xA;   *&#xA;   * cmd --&amp;gt; event --&amp;gt; objectCreated  .. and not&#xA;   * cmd --&amp;gt; objectCreated --&amp;gt; event&#xA;   *&#xA;   * If you look at the &#34;ConnectGroupProcessor&#34; as a Black Box.. a Command went in and an Event Came out&#xA;   * So .. the past Tense is for the external &#34;looker&#34; of this Processor, not so much us.&#xA;   *&#xA;   * We just need to know how to create a ConnectGroup, given the event (because we are event sourced)&#xA;   *&#xA;   * @param event&#xA;   * @return&#xA;   */&#xA;  override def domainObjectFromEvent(event: ConnectGroupEvent): ConnectGroup = event match {&#xA;    case evt: ConnectGroupCreated =&amp;gt; ConnectGroup(evt)&#xA;    case evt: ConnectGroupNameChanged =&amp;gt; repository.getByKey(evt.id).get.changeName(evt.name)&#xA;  }&#xA;  /**&#xA;   *&#xA;   * @return list of people&#xA;   */&#xA;  def leadersFromUuidList(leaders: List[Uuid]) = leaders.map(id =&amp;gt; personService.get(id)).flatten&#xA;&#xA;  // command to event&#xA;  val processCommand:Receive = {&#xA;      case cmd@CreateConnectGroup(timestamp, leaderIds, connectGroupName) =&amp;gt; process {&#xA;        personService.fromIdList(leaderIds).toList match {&#xA;          case Nil =&amp;gt; DomainError(&#34;None of the Leader Id&#39;s Were valid&#34;).fail&#xA;          case leaders =&amp;gt; ConnectGroup.canCreate(idGenerator.newId(), cmd, leaders)&#xA;        }&#xA;      }&#xA;&#xA;      case cmd@ChangeConnectGroupName(timestamp, connectGroupId, expectedVersion, newName) =&amp;gt; process {&#xA;        for {&#xA;          obj &amp;lt;- ensureVersion(connectGroupId, cmd.expectedVersion)&#xA;          event &amp;lt;- ConnectGroup.canChangeName(obj, cmd)&#xA;        } yield event&#xA;      }&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>