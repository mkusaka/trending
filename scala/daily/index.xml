<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-12T01:47:26Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>foundweekends/pamflet</title>
    <updated>2023-06-12T01:47:26Z</updated>
    <id>tag:github.com,2023-06-12:/foundweekends/pamflet</id>
    <link href="https://github.com/foundweekends/pamflet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;a publishing application for short texts&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Pamflet is a publishing application for short texts, particularly user documentation of open-source software. It is designed to be easy to write and read on any platform.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.foundweekends.org/pamflet/&#34;&gt;See Pamflet&#39;s pamflet for the full story&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mtswd2023/sl1</title>
    <updated>2023-06-12T01:47:26Z</updated>
    <id>tag:github.com,2023-06-12:/mtswd2023/sl1</id>
    <link href="https://github.com/mtswd2023/sl1" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h3&gt;Assignment #1&lt;/h3&gt; &#xA;&lt;p&gt;Please refer to &lt;a href=&#34;https://raw.githubusercontent.com/mtswd2023/sl1/main/src/test/scala/ua/kpi/pti/fp/l1/assignment/Assignment.scala&#34;&gt;Assignment.scala&lt;/a&gt; for instructions.&lt;/p&gt; &#xA;&lt;h4&gt;Local tests&lt;/h4&gt; &#xA;&lt;p&gt;Just run &lt;code&gt;sbt test&lt;/code&gt; in your working directory&lt;/p&gt; &#xA;&lt;h3&gt;PR titles&lt;/h3&gt; &#xA;&lt;p&gt;Please include your name, group and short summary in the PR title.&lt;/p&gt; &#xA;&lt;h3&gt;Formatting&lt;/h3&gt; &#xA;&lt;p&gt;PRs will be rejected if they don&#39;t pass tests. Tests include formatting checks. Please install &lt;a href=&#34;https://scalameta.org/scalafmt/docs/installation.html&#34;&gt;scalafmt&lt;/a&gt; and format your code before pushing.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>scala-tsi/scala-tsi</title>
    <updated>2023-06-12T01:47:26Z</updated>
    <id>tag:github.com,2023-06-12:/scala-tsi/scala-tsi</id>
    <link href="https://github.com/scala-tsi/scala-tsi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Generate typescript interfaces from your scala classes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Scala-TSI&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/scala-tsi/scala-tsi/&#34;&gt;&lt;img src=&#34;https://img.shields.io/circleci/project/github/scala-tsi/scala-tsi/master.svg?sanitize=true&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://mvnrepository.com/artifact/com.scalatsi/scala-tsi&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.scalatsi/scala-tsi_3.svg?label=3.x&#34; alt=&#34;2.12&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mvnrepository.com/artifact/com.scalatsi/scala-tsi&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.scalatsi/scala-tsi_2.13.svg?label=2.13&#34; alt=&#34;2.13&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mvnrepository.com/artifact/com.scalatsi/scala-tsi&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.scalatsi/scala-tsi_2.12.svg?label=2.12&#34; alt=&#34;2.12&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Scala TSI can automatically generate Typescript Interfaces from your Scala classes.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To use the project add the SBT plugin dependency in &lt;code&gt;project/plugins.sbt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sbt&#34;&gt;// See badge above for latest version number&#xA;addSbtPlugin(&#34;com.scalatsi&#34; % &#34;sbt-scala-tsi&#34; % &#34;0.8.2&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And configure the plugin in your project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sbt&#34;&gt;// Replace with your project definition&#xA;lazy val root = (project in file(&#34;.&#34;))&#xA;    .enablePlugins(ScalaTsiPlugin)&#xA;    .settings(&#xA;      // The classes that you want to generate typescript interfaces for&#xA;      typescriptExports := Seq(&#34;MyClass&#34;),&#xA;      // The output file which will contain the typescript interfaces&#xA;      typescriptOutputFile := baseDirectory.value / &#34;model.ts&#34;,&#xA;      // Include the package(s) of the classes here&#xA;      // Optionally import your own TSType implicits to override default default generated&#xA;      typescriptGenerationImports := Seq(&#34;mymodel._&#34;, &#34;MyTypescript._&#34;)&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now &lt;code&gt;sbt generateTypescript&lt;/code&gt; will transform a file like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class MyClass(foo: String, bar: Int)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Into a typescript interface like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export interface IMyClass {&#xA;  foo: string&#xA;  bar: number&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/scala-tsi/scala-tsi/master/#Example&#34;&gt;#Example&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/scala-tsi/scala-tsi/master/example/&#34;&gt;the example project&lt;/a&gt; for more a more examples&lt;/p&gt; &#xA;&lt;h4&gt;Without sbt plugin&lt;/h4&gt; &#xA;&lt;p&gt;The sbt plugin will add the required dependency to your project. It can be added manually if you don&#39;t use the plugin:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sbt&#34;&gt;libraryDependencies += &#34;com.scalatsi&#34; %% &#34;scala-tsi&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Key&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;typescriptExports&lt;/td&gt; &#xA;   &lt;td&gt;Seq[String]&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Seq()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A list of all your (top-level) classes that you want to generate interfaces for&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;typescriptGenerationImports&lt;/td&gt; &#xA;   &lt;td&gt;Seq[String]&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Seq()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A list of all imports. This should import all classes you defined above, as well as custom &lt;code&gt;TSType&lt;/code&gt; implicits&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;typescriptOutputFile&lt;/td&gt; &#xA;   &lt;td&gt;File&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;target/scala-tsi.ts&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The output file with generated typescript interfaces&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;typescriptStyleSemicolons&lt;/td&gt; &#xA;   &lt;td&gt;Boolean&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Whether to add semicolons to the exported model&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;typescriptHeader&lt;/td&gt; &#xA;   &lt;td&gt;Option[String]&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(&#34;...&#34;)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A header for the output file. Contains a notice about the file being generated by default&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;typescriptTaggedUnionDiscriminator&lt;/td&gt; &#xA;   &lt;td&gt;Option[String]&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Some(&#34;type&#34;)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The discriminator field for tagged unions, or None to disable tagged unions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;You can check out the &lt;a href=&#34;https://raw.githubusercontent.com/scala-tsi/scala-tsi/master/example/&#34;&gt;example project&lt;/a&gt; for a complete set-up and more examples.&lt;/p&gt; &#xA;&lt;p&gt;Say we have the following JSON:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;   &#34;name&#34;: &#34;person name&#34;,&#xA;   &#34;email&#34;: &#34;abc@example.org&#34;,&#xA;   &#34;age&#34;: 25,&#xA;   &#34;job&#34;: {&#xA;      &#34;tasks&#34;: [&#34;Be in the office&#34;, &#34;Drink coffee&#34;],&#xA;      &#34;boss&#34;: &#34;Johnson&#34;&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Generated from this Scala domain model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package myproject&#xA;&#xA;case class Person(&#xA;  name: String,&#xA;  email: Email,&#xA;  age: Option[Int],&#xA;  // for privacy reasons, we do not put this social security number in the JSON&#xA;  ssn: Option[Int],&#xA;  job: Job&#xA;)&#xA;// This type will get erased when serializing to JSON, only the string remains&#xA;case class Email(address: String)&#xA;&#xA;case class Job(tasks: Seq[String], boss: String)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;Typescript&lt;/a&gt;, your frontend can know what data is available in what format. However, keeping the Typescript definitions in sync with your scala classes is a pain and error-prone. scala-tsi solves that.&lt;/p&gt; &#xA;&lt;p&gt;First we define the mapping as follows&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package myproject&#xA;&#xA;import com.scalatsi.*&#xA;import com.scalatsi.dsl.*&#xA;&#xA;// A TSType[T] is what tells scala-tsi how to convert your type T into typescript&#xA;// MyModelTSTypes contains all TSType[?]&#39;s for your model&#xA;// You can also spread these throughout your codebase, for example in the same place where your JSON (de)serializers&#xA;object MyModelTSTypes {&#xA; &#xA;  // Tell scala-tsi to use the typescript type of string whenever we have an Email type&#xA;  // Alternatively, TSType.alias[Email, String] will create a `type Email = string` entry in the typescript file&#xA;  implicit val tsEmail: TSType[Email] = TSType.sameAs[Email, String]&#xA;  &#xA;  // TSType.fromCaseClass will convert your case class to a typescript definition&#xA;  // `- ssn` indicated the ssn field should be removed&#xA;  implicit val tsPerson: TSType[Person] = TSType.fromCaseClass[Person] - &#34;ssn&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And in your build.sbt configure the sbt plugin to output your class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sbt&#34;&gt;lazy val root = (project in file(&#34;.&#34;))&#xA;  .settings(&#xA;    typescriptExports           := Seq(&#34;Person&#34;),&#xA;    typescriptGenerationImports := Seq(&#34;myproject._&#34;, &#34;MyModelTSTypes._&#34;),&#xA;    typescriptOutputFile        := baseDirectory.value / &#34;model.ts&#34;&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;this will generate in your project root a &lt;code&gt;model.ts&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export interface IPerson {&#xA;  name : string&#xA;  email : string&#xA;  age ?: number&#xA;  job: IJob&#xA;}&#xA;&#xA;export interface IJob {&#xA;  tasks: string[]&#xA;  boss: string&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/scala-tsi/scala-tsi/master/doc/workings.md&#34;&gt;This document&lt;/a&gt; contains more detailed explanation of the library and usage&lt;/p&gt; &#xA;&lt;h4&gt;Circular references&lt;/h4&gt; &#xA;&lt;p&gt;Currently, scala-tsi cannot always handle circular references. You will get an error along the following lines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;[error] Circular reference encountered while searching for TSType[B]&#xA;[error] Please break the cycle by locally defining an implicit TSType like so:&#xA;[error] implicit val tsType...: TSType[...] = {&#xA;[error]   implicit val tsA: TSType[B] = TSType.external(&#34;IB&#34;) // name of your &#34;B&#34; typescript type here&#xA;[error]   TSType.getOrGenerate[...]&#xA;[error] }&#xA;[error] for more help see https://github.com/scala-tsi/scala-tsi#circular-references&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To help scala-tsi and break the cycle you will need to define an explicit manual reference. For example, if you have the following classes&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class A(b: B)&#xA;case class B(a: A)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will get a warning on Scala 2, and an error on Scala 3. The Scala 2 output might also not always be as desired. To fix this, you can explicitly define the right values.&lt;/p&gt; &#xA;&lt;h5&gt;Scala 2&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object B {&#xA;  // This explicit definition is to help scala-tsi with the recursive definition of A and B&#xA;  private implicit val aReference: TSType[A] = TSType.external[A](&#34;IA&#34;)&#xA;  implicit val bTS: TSType[B] = TSType.fromCaseClass[B]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Scala 3&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object B {&#xA;// This explicit definition is to help scala-tsi with the recursive definition of A and B&#xA;  private given TSType[A] = TSType.external[A](&#34;IA&#34;) &#xA;  prviate val generatedTSType = TSType.getOrGenerate[B] &#xA;  given TSType[B] = generatedTSType&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>