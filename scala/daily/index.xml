<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-07T01:40:19Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>softwaremill/magnolia</title>
    <updated>2023-11-07T01:40:19Z</updated>
    <id>tag:github.com,2023-11-07:/softwaremill/magnolia</id>
    <link href="https://github.com/softwaremill/magnolia" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Easy, fast, transparent generic derivation of typeclass instances&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/softwaremill/magnolia/raw/scala3/banner.jpg&#34; alt=&#34;Magnolia&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/softwaremill/magnolia/actions&#34;&gt;&lt;img alt=&#34;GitHub Workflow&#34; src=&#34;https://img.shields.io/github/actions/workflow/status/softwaremill/magnolia/ci.yml?branch=scala3&amp;amp;style=for-the-badge&#34; height=&#34;24&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://softwaremill.community/c/magnolia&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Discourse-ask%20question-blue?style=for-the-badge&#34; height=&#34;24&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://index.scala-lang.org/softwaremill/magnolia/magnolia&#34;&gt;&lt;img src=&#34;https://index.scala-lang.org/softwaremill/magnolia/magnolia/latest-by-scala-version.svg?color=2465cd&amp;amp;style=for-the-badge&#34; height=&#34;24&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Magnolia&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Magnolia&lt;/strong&gt; is a generic macro for automatic materialization of typeclasses for datatypes composed from product types (e.g. case classes) and coproduct types (e.g. enums). It supports recursively-defined datatypes out-of-the-box, and incurs no significant time-penalty during compilation.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;derives typeclasses for case classes, case objects and sealed traits&lt;/li&gt; &#xA; &lt;li&gt;offers a lightweight syntax for writing derivations without needing to understand complex parts of Scala&lt;/li&gt; &#xA; &lt;li&gt;builds upon Scala 3&#39;s built-in generic derivation&lt;/li&gt; &#xA; &lt;li&gt;works with recursive and mutually-recursive definitions&lt;/li&gt; &#xA; &lt;li&gt;supports parameterized ADTs (GADTs), including those in recursive types&lt;/li&gt; &#xA; &lt;li&gt;supports typeclasses whose generic type parameter is used in either covariant and contravariant positions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Given an ADT such as,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;enum Tree[+T] derives Print:&#xA;  case Branch(left: Tree[T], right: Tree[T])&#xA;  case Leaf(value: T)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and provided a given instance of &lt;code&gt;Print[Int]&lt;/code&gt; is in scope, and a Magnolia derivation for the &lt;code&gt;Print&lt;/code&gt; typeclass has been provided, we can automatically derive given typeclass instances of &lt;code&gt;Print[Tree[Int]]&lt;/code&gt; on-demand, like so,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Tree.Branch(Tree.Branch(Tree.Leaf(1), Tree.Leaf(2)), Tree.Leaf(3)).print&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Typeclass authors may provide Magnolia derivations in the typeclass&#39;s companion object, but it is easy to create your own.&lt;/p&gt; &#xA;&lt;p&gt;Creating a generic derivation with Magnolia requires implementing two methods on &lt;code&gt;magnolia1.Derivation&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;join()&lt;/code&gt; : create typeclasses for case classes (&#39;product types&#39;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;split()&lt;/code&gt; : create typeclasses for sealed-traits/enums (&#39;sum types&#39;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Example derivations&lt;/h3&gt; &#xA;&lt;p&gt;There are many examples in the &lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/magnolia/scala3/src/examples&#34;&gt;&lt;code&gt;src/examples&lt;/code&gt;&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;The definition of a &lt;code&gt;Print&lt;/code&gt; typeclass with generic derivation might look like this (note we&#39;re using the &lt;a href=&#34;https://www.scala-lang.org/news/2.12.0/#lambda-syntax-for-sam-types&#34;&gt;Lambda syntax for Single Abstract Method types&lt;/a&gt; to instantiate the &lt;code&gt;Print&lt;/code&gt; instances in &lt;code&gt;join&lt;/code&gt; &amp;amp; &lt;code&gt;split&lt;/code&gt; - that&#39;s possible because &lt;code&gt;Print&lt;/code&gt; has only a single abstract method, &lt;code&gt;print&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import magnolia1.*&#xA;&#xA;trait Print[T] {&#xA;  extension (x: T) def print: String&#xA;}&#xA;&#xA;object Print extends AutoDerivation[Print]:&#xA;  def join[T](ctx: CaseClass[Print, T]): Print[T] = value =&amp;gt;&#xA;    ctx.params.map { param =&amp;gt;&#xA;      param.typeclass.print(param.deref(value))&#xA;    }.mkString(s&#34;${ctx.typeInfo.short}(&#34;, &#34;,&#34;, &#34;)&#34;)&#xA;&#xA;  override def split[T](ctx: SealedTrait[Print, T]): Print[T] = value =&amp;gt;&#xA;    ctx.choose(value) { sub =&amp;gt; sub.typeclass.print(sub.cast(value)) }&#xA;  &#xA;  given Print[Int] = _.toString&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;AutoDerivation&lt;/code&gt; trait provides a given &lt;code&gt;autoDerived&lt;/code&gt; method which will attempt to construct a corresponding typeclass instance for the type passed to it. Importing &lt;code&gt;Print.autoDerived&lt;/code&gt; as defined in the example above will make generic derivation for &lt;code&gt;Print&lt;/code&gt; typeclasses available in the scope of the import.&lt;/p&gt; &#xA;&lt;p&gt;While any object may be used to define a derivation, if you control the typeclass you are deriving for, the companion object of the typeclass is the obvious choice since it generic derivations for that typeclass will be automatically available for consideration during contextual search.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t want to make the automatic derivation available in the given scope, consider using the &lt;code&gt;Derivation&lt;/code&gt; trait which provides semi-auto derivation with &lt;code&gt;derived&lt;/code&gt; method, but also brings some additional limitations.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;Accessing default values for case class parameters requires compilation with &lt;code&gt;-Yretain-trees&lt;/code&gt; on.&lt;/p&gt; &#xA;&lt;p&gt;For a recursive structures it is required to assign the derived value to an implicit variable e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Scala&#34;&gt;given instance: SemiPrint[Recursive] = SemiPrint.derived&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Availability&lt;/h2&gt; &#xA;&lt;p&gt;For Scala 3:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val magnolia = &#34;com.softwaremill.magnolia1_3&#34; %% &#34;magnolia&#34; % &#34;1.3.4&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Scala 2, see the &lt;a href=&#34;https://github.com/softwaremill/magnolia/tree/scala2&#34;&gt;scala2 branch&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Package and artifact naming, versioning&lt;/h2&gt; &#xA;&lt;p&gt;The main magnolia package is &lt;code&gt;magnolia1&lt;/code&gt;, so that magnolia 1.x can be used alongside magnolia 0.17 (which are binary-incompatible). Future major releases of magnolia can change the package name for the same reason.&lt;/p&gt; &#xA;&lt;p&gt;The group id for magnolia follows the naming scheme: &lt;code&gt;com.softwaremill.magnolia[major version]_[scala major version]&lt;/code&gt;. The scala major version suffix is necessary to allow evolving and publishing versions for Scala 2 &amp;amp; Scala 3 independently. The magnolia major version is included for consistency with the package name, and so that future major releases may be used alongside this release.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributors to Magnolia are welcome and encouraged. New contributors may like to look for issues marked &lt;a href=&#34;https://github.com/softwaremill/magnolia/labels/good%20first%20issue&#34;&gt;&lt;img alt=&#34;label: good first issue&#34; src=&#34;https://img.shields.io/badge/-good%20first%20issue-67b6d0.svg?sanitize=true&#34; valign=&#34;middle&#34;&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;Magnolia was originally designed and developed by &lt;a href=&#34;https://github.com/propensive&#34;&gt;Jon Pretty&lt;/a&gt;, and is currently maintained by &lt;a href=&#34;https://softwaremill.com&#34;&gt;SoftwareMill&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Magnolia is made available under the &lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/magnolia/scala3/license.md&#34;&gt;Apache 2.0 License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>