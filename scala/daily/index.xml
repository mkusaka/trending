<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-03-26T01:37:31Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>typelevel/log4cats</title>
    <updated>2025-03-26T01:37:31Z</updated>
    <id>tag:github.com,2025-03-26:/typelevel/log4cats</id>
    <link href="https://github.com/typelevel/log4cats" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Logging Tools For Interaction with cats-effect&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;log4cats &lt;a href=&#34;https://github.com/typelevel/log4cats/actions?query=branch%3Amain+workflow%3A%22Continuous+Integration%22&#34;&gt;&lt;img src=&#34;https://github.com/typelevel/log4cats/workflows/Continuous%20Integration/badge.svg?branch=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/org.typelevel/log4cats-core_2.12&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/org.typelevel/log4cats-core_2.12/badge.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Project Goals&lt;/h2&gt; &#xA;&lt;p&gt;log4cats attempts to make referentially transparent logging a reality. These F algebras allow you to write code for logging knowing you won&#39;t be doing side-effects as it offers no way to do so. We provide our own slf4j layer, or you can use any of the supported backends, or create your own.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;To use log4cats in an existing SBT project with Scala 2.12 or a later version, add the following dependency to your &lt;code&gt;build.sbt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies ++= Seq(&#xA;  &#34;org.typelevel&#34; %% &#34;log4cats-core&#34;    % &#34;&amp;lt;version&amp;gt;&#34;,  // Only if you want to Support Any Backend&#xA;  &#34;org.typelevel&#34; %% &#34;log4cats-slf4j&#34;   % &#34;&amp;lt;version&amp;gt;&#34;,  // Direct Slf4j Support - Recommended&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why log4cats?&lt;/h2&gt; &#xA;&lt;p&gt;Well, to answer that, let&#39;s take a look at how you might combine cats-effect with vanilla logging...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object MyVanillaLoggingThing {&#xA;  val logger: Logger = Logger(LoggerFactory.getLogger(getClass.getName))&#xA;  &#xA;  def doSomething(): IO[Unit] =&#xA;    IO(logger.info(&#34;Doing something!&#34;)) *&amp;gt; IO.println(&#34;Hello, World!&#34;)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But what if you don&#39;t want to wrap your logger in an &lt;code&gt;IO&lt;/code&gt; like this?&lt;br&gt; Good news, you don&#39;t have to! Enter log4cats! Read on!&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import org.typelevel.log4cats.Logger&#xA;import org.typelevel.log4cats.slf4j.Slf4jLogger&#xA;import cats.effect.Sync&#xA;import cats.syntax.all.*&#xA;&#xA;object MyThing {&#xA;  // Impure But What 90% of Folks I know do with log4s&#xA;  implicit def unsafeLogger[F[_]: Sync] = Slf4jLogger.getLogger[F]&#xA;&#xA;  // Arbitrary Local Function Declaration&#xA;  def doSomething[F[_]: Sync]: F[Unit] =&#xA;    Logger[F].info(&#34;Logging Start Something&#34;) *&amp;gt;&#xA;            Sync[F].delay(println(&#34;I could be doing anything&#34;))&#xA;                    .attempt.flatMap {&#xA;                      case Left(e) =&amp;gt; Logger[F].error(e)(&#34;Something Went Wrong&#34;)&#xA;                      case Right(_) =&amp;gt; Sync[F].pure(())&#xA;                    }&#xA;&#xA;  def safelyDoThings[F[_]: Sync]: F[Unit] = for {&#xA;    logger &amp;lt;- Slf4jLogger.create[F]&#xA;    _ &amp;lt;- logger.info(&#34;Logging at start of safelyDoThings&#34;)&#xA;    something &amp;lt;- Sync[F].delay(println(&#34;I could do anything&#34;))&#xA;            .onError { case e =&amp;gt; logger.error(e)(&#34;Something Went Wrong in safelyDoThings&#34;) }&#xA;    _ &amp;lt;- logger.info(&#34;Logging at end of safelyDoThings&#34;)&#xA;  } yield something&#xA;&#xA;  def passForEasierUse[F[_]: Sync : Logger] = for {&#xA;    _ &amp;lt;- Logger[F].info(&#34;Logging at start of passForEasierUse&#34;)&#xA;    something &amp;lt;- Sync[F].delay(println(&#34;I could do anything&#34;))&#xA;            .onError { case e =&amp;gt; Logger[F].error(e)(&#34;Something Went Wrong in passForEasierUse&#34;) }&#xA;    _ &amp;lt;- Logger[F].info(&#34;Logging at end of passForEasierUse&#34;)&#xA;  } yield something&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Wait...why log4cats again?&lt;/h2&gt; &#xA;&lt;p&gt;If you compare the vanilla logger + cats-effect example with the log4cats examples above, you might be asking yourself &#34;why do I have to do any of this?&#34; or &#34;why can&#39;t I just add a log statement like normal?&#34;&lt;/p&gt; &#xA;&lt;p&gt;Well there are several reasons. Logging is often times an overlooked side-effect, which under the hood can range from writing to a mutable queue, writing to disk, outputting to the console, or sometimes even doing network I/O! To correctly deal with these kinds of side-effects we have to ensure they are properly wrapped in &lt;code&gt;IO&lt;/code&gt;, see the &lt;a href=&#34;https://typelevel.org/cats-effect/docs/concepts#side-effects&#34;&gt;cats-effect docs&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;Basically, we are using cats-effect. We like things like &#34;referential transparency&#34; and &#34;programs-as-values&#34;. Wrapping our log statement in an &lt;code&gt;IO&lt;/code&gt; helps with that.&lt;/p&gt; &#xA;&lt;h3&gt;Laconic syntax&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s possible to use interpolated syntax for logging. Currently, supported ops are: &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;debug&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;. You can use it for your custom &lt;code&gt;Logger&lt;/code&gt; as well as for Slf4j &lt;code&gt;Logger&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import cats.Applicative&#xA;import cats.effect.Sync&#xA;import org.typelevel.log4cats.Logger&#xA;import org.typelevel.log4cats.syntax.*&#xA;&#xA;def successComputation[F[_]: Applicative]: F[Int] = Applicative[F].pure(1)&#xA;def errorComputation[F[_]: Sync]: F[Unit] = Sync[F].raiseError[Unit](new Throwable(&#34;Sorry!&#34;))&#xA;&#xA;def log[F[_]: Sync : Logger] =&#xA;  for {&#xA;    result1 &amp;lt;- successComputation[F]&#xA;    _ &amp;lt;- info&#34;First result is $result1&#34;&#xA;    _ &amp;lt;- errorComputation[F].onError(_ =&amp;gt; error&#34;We got an error!&#34;)&#xA;  } yield ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Logging using capabilities&lt;/h2&gt; &#xA;&lt;p&gt;You can work with logging using capabilities. It&#39;s implemented via the &lt;code&gt;LoggerFactory&lt;/code&gt; trait. You instantiate it once (dependent on the specific logging backend you use) and pass this around in your application.&lt;/p&gt; &#xA;&lt;p&gt;This brings several advantages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;it&#39;s no more needed to pass the very powerful &lt;code&gt;F[_]: Sync&lt;/code&gt; constraint everywhere that can do almost anything when you only need logging.&lt;/li&gt; &#xA; &lt;li&gt;you have control of loggers creation, and you can even add in whatever custom functionality you need for your applications here. E.g. create loggers that also push logs to some external providers by giving a custom implementation of this trait.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you are unsure how to create a new &lt;code&gt;LoggerFactory[F]&lt;/code&gt; instance, then you can look at the &lt;code&gt;log4cats-slf4j&lt;/code&gt;, or &lt;code&gt;log4cats-noop&lt;/code&gt; modules for concrete implementations.&lt;/p&gt; &#xA;&lt;p&gt;The quickest fix might be to import needed implicits:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// assumes dependency on log4cats-slf4j module&#xA;&#xA;import org.typelevel.log4cats.*&#xA;import org.typelevel.log4cats.slf4j.*&#xA;&#xA;val logger: SelfAwareStructuredLogger[IO] = LoggerFactory[IO].getLogger&#xA;&#xA;// or&#xA;def anyFSyncLogger[F[_]: Sync]: SelfAwareStructuredLogger[F] = Slf4jFactory[F].getLogger&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, a mutually exclusive solution is to explicitly create your &lt;code&gt;LoggerFactory[F]&lt;/code&gt; instance and pass them around implicitly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import cats.effect.IO&#xA;import cats.Monad&#xA;import cats.syntax.all.*&#xA;import org.typelevel.log4cats.*&#xA;import org.typelevel.log4cats.slf4j.Slf4jFactory&#xA;&#xA;// create our LoggerFactory&#xA;implicit val logging: LoggerFactory[IO] = Slf4jFactory[IO]&#xA;&#xA;// we summon LoggerFactory instance, and create logger&#xA;val logger: SelfAwareStructuredLogger[IO] = LoggerFactory[IO].getLogger&#xA;logger.info(&#34;logging in IO!&#34;): IO[Unit]&#xA;&#xA;// basic example of a service using LoggerFactory&#xA;class LoggerUsingService[F[_]: LoggerFactory : Monad] {&#xA;  val logger = LoggerFactory[F].getLogger&#xA;&#xA;  def use(args: String): F[Unit] =&#xA;    for {&#xA;      _ &amp;lt;- logger.info(&#34;yay! effect polymorphic code&#34;)&#xA;      _ &amp;lt;- logger.debug(s&#34;and $args&#34;)&#xA;    } yield ()&#xA;}&#xA;&#xA;new LoggerUsingService[IO].use(&#34;foo&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using log4cats in tests&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/typelevel/log4cats/main/testing/README.md&#34;&gt;here&lt;/a&gt; for details&lt;/p&gt; &#xA;&lt;h2&gt;CVE-2021-44228 (&#34;log4shell&#34;)&lt;/h2&gt; &#xA;&lt;p&gt;log4cats is not directly susceptible to CVS-2021-44228. The log4cats-slf4j implementation delegates all logging operations to &lt;a href=&#34;https://www.slf4j.org/&#34;&gt;slf4j&lt;/a&gt;. if you use log4cats-slf4j, your configured slf4j provider may put you at risk. See &lt;a href=&#34;https://www.slf4j.org/log4shell.html&#34;&gt;slf4j&#39;s comments on CVE-2021-44228&lt;/a&gt; for more.&lt;/p&gt;</summary>
  </entry>
</feed>