<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-05-12T01:35:42Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mockito/mockito-scala</title>
    <updated>2025-05-12T01:35:42Z</updated>
    <id>tag:github.com,2025-05-12:/mockito/mockito-scala</id>
    <link href="https://github.com/mockito/mockito-scala" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mockito for Scala language&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Mockito Scala&lt;/h1&gt; &#xA;&lt;a href=&#34;http://site.mockito.org&#34;&gt; &lt;img src=&#34;https://github.com/mockito/mockito/raw/release/2.x/src/javadoc/org/mockito/logo.png&#34; srcset=&#34;https://github.com/mockito/mockito/raw/release/2.x/src/javadoc/org/mockito/logo@2x.png 2x&#34; alt=&#34;Mockito&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;The most popular mocking framework for Java, now in Scala!!!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://search.maven.org/search?q=mockito-scala&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/org.mockito/mockito-scala_2.12.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/mockito-scala/&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/gitterHQ/gitter.png&#34; alt=&#34;Gitter chat&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://typelevel.org/cats/&#34;&gt;&lt;img src=&#34;https://typelevel.org/cats/img/cats-badge-tiny.png&#34; alt=&#34;Cats Friendly&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why separate project?&lt;/h2&gt; &#xA;&lt;p&gt;The library has independent developers, release cycle and versioning from core mockito library (&lt;a href=&#34;https://github.com/mockito/mockito&#34;&gt;https://github.com/mockito/mockito&lt;/a&gt;). This is intentional because core Mockito developers don&#39;t use Scala and cannot confidently review PRs, and set the vision for the Scala library.&lt;/p&gt; &#xA;&lt;h2&gt;Dependency&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Artifact identifier: &#34;org.mockito:mockito-scala_[scala-version]:[version]&#34;&lt;/li&gt; &#xA; &lt;li&gt;Artifact identifier: &#34;org.mockito:mockito-scala-scalatest_[scala-version]:[version]&#34;&lt;/li&gt; &#xA; &lt;li&gt;Artifact identifier: &#34;org.mockito:mockito-scala-specs2_[scala-version]:[version]&#34;&lt;/li&gt; &#xA; &lt;li&gt;Artifact identifier: &#34;org.mockito:mockito-scala-cats_[scala-version]:[version]&#34;&lt;/li&gt; &#xA; &lt;li&gt;Artifact identifier: &#34;org.mockito:mockito-scala-scalaz_[scala-version]:[version]&#34;&lt;/li&gt; &#xA; &lt;li&gt;Latest version - see &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/docs/release-notes.md&#34;&gt;release notes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Repositories: &lt;a href=&#34;https://search.maven.org/search?q=mockito-scala&#34;&gt;Maven Central&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Please ensure you don&#39;t declare &lt;code&gt;mockito-core&lt;/code&gt; as a dependency. &lt;code&gt;mockito-scala&lt;/code&gt; will pull the appropriate version automatically&lt;/h3&gt; &#xA;&lt;h3&gt;Note: For more examples and use cases than the ones shown below, please refer to the library&#39;s specific tests&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/cats/src/test&#34;&gt;Cats&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/scalatest/src/test&#34;&gt;ScalaTest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/specs2/src/test&#34;&gt;Specs2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/scalaz/src/test&#34;&gt;Scalaz&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Partial unification&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re in Scala 2.11 or 2.12 you&#39;ll probably want to add the compiler flag &lt;code&gt;-Ypartial-unification&lt;/code&gt;, if you don&#39;t you risk some compile errors when trying to stub complex types using the idiomatic syntax&lt;/p&gt; &#xA;&lt;h2&gt;Notes for 1.13.6&lt;/h2&gt; &#xA;&lt;p&gt;We slightly changed the way one would expect no/no more interactions with a mock object in Expectations DSL. From now on, &lt;code&gt;expect (...) to&lt;/code&gt; should only be used on stubbed methods, and can&#39;t express expectations about interactions with the mock objects itself.&lt;/p&gt; &#xA;&lt;p&gt;In order to express expectations on a mock, one would use &lt;code&gt;expect (...) on&lt;/code&gt; (note the use of &lt;code&gt;on&lt;/code&gt; vs &lt;code&gt;to&lt;/code&gt;) where such expectations are supported.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Instead of &lt;code&gt;expect no calls to aMock&lt;/code&gt;, use &lt;code&gt;expect no calls on aMock&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Instead of &lt;code&gt;expect noMore calls to aMock&lt;/code&gt;, use &lt;code&gt;expect noMore calls on aMock&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Expectations about no &lt;em&gt;method&lt;/em&gt; calls stay the same: &lt;code&gt;expect no calls to aMock.bar(*)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Notes for 1.13.0&lt;/h2&gt; &#xA;&lt;p&gt;We added a new experimental Expectations DSL for idiomatic syntax. It behaves differently from the original idiomatic verifications: the user declares intent to verify by using &lt;code&gt;expect&lt;/code&gt; at the beginning of the line rather than at the end of it - similar to &#34;verify&#34; in Mockito Java.&lt;/p&gt; &#xA;&lt;p&gt;Now, you can do &lt;code&gt;expect a call to aMock.bar(*)&lt;/code&gt; where previously you did &lt;code&gt;aMock.bar(*) was called&lt;/code&gt;. More examples in &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/#expect-dsl&#34;&gt;Expect DSL&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that since this DSL is currently experimental, it&#39;s not stable - the DSL itself may evolve, components and base traits may move or be renamed, and incompatible changes may be introduced between minor/patch versions.&lt;/p&gt; &#xA;&lt;p&gt;In order to use it...&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;with Scalatest base traits, mix in &lt;code&gt;org.mockito.scalatest.IdiomaticMockitoBase with org.mockito.PrefixExpectations&lt;/code&gt; instead of &lt;code&gt;org.mockito.scalatest.IdiomaticMockito&lt;/code&gt; (or &lt;code&gt;org.mockito.scalatest.AsyncIdiomaticMockitoBase&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;with another test framework, mix in trait &lt;code&gt;org.mockito.IdiomaticMockito.WithExpect&lt;/code&gt; or use its companion object&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Notes for v1.4.0&lt;/h2&gt; &#xA;&lt;p&gt;As Specs2 support was added, now the library has been split in 3 different artifacts&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;mockito-scala&lt;/strong&gt; being the core&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;mockito-scala-scalatest&lt;/strong&gt; having specific classes that provide extra support for Scalatest&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;mockito-scala-specs2&lt;/strong&gt; having specific classes that provide extra support for Specs2&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;From now on, when using the idiomatic syntax, you&#39;ll get any non-matcher parameter automatically wrapped in an &lt;code&gt;eqTo&lt;/code&gt;, this means you shouldn&#39;t need to use it manually anymore. This is to provide a consistent behaviour when a custom &lt;code&gt;scalactic.Equality&lt;/code&gt; has been defined for a type.&lt;/p&gt; &#xA;&lt;p&gt;The traits that provide the specifics for each test framework are&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Scalatest: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;org.mockito.scalatest.MockitoSugar&lt;/code&gt; and &lt;code&gt;org.mockito.scalatest.IdiomaticMockito&lt;/code&gt; for standard specs&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;org.mockito.scalatest.AsyncMockitoSugar&lt;/code&gt;, &lt;code&gt;org.mockito.scalatest.AsyncIdiomaticMockito&lt;/code&gt; for async specs&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Specs2: &lt;code&gt;org.mockito.specs2.Mockito&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This version also includes a lot of under-the-hood fixes and improvements that provide an even better experience.&lt;/p&gt; &#xA;&lt;h2&gt;Note for v1.2.0&lt;/h2&gt; &#xA;&lt;p&gt;As now the varargs support works consistently across the whole lib, no no special syntax is needed, so if you were using &lt;code&gt;eqTo&lt;/code&gt; with varargs, i.e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;verify(myObj).myMethod(eqTo(&#34;arg1&#34;, &#34;arg2&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You must change it now to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;verify(myObj).myMethod(eqTo(&#34;arg1&#34;), eqTo(&#34;arg2&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Migration Notes for version 1.0.0&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;DefaultAnswer&lt;/code&gt; was moved from &lt;code&gt;org.mockito.DefaultAnswer&lt;/code&gt; to &lt;code&gt;org.mockito.stubbing.DefaultAnswer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;The recommended way to use the pre-defined &lt;code&gt;DefaultAnswer&lt;/code&gt;s is via the object &lt;code&gt;org.mockito.DefaultAnswers&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;*&lt;/code&gt; matcher is now defined in &lt;code&gt;org.mockito.ArgumentMatchersSugar&lt;/code&gt;, mixin (or use the companion object) this trait whenever you wanna use it&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;argumentCaptor[String]&lt;/code&gt; was removed, replace by &lt;code&gt;ArgCaptor[T]&lt;/code&gt; (&lt;code&gt;Captor[T]&lt;/code&gt; was renamed to &lt;code&gt;ArgCaptor[T]&lt;/code&gt; to add clarity), &lt;code&gt;ValCaptor[T]&lt;/code&gt; was deprecated, (see &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/#improved-argumentcaptor&#34;&gt;Improved ArgumentCaptor&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;The usage of &lt;code&gt;org.mockito.Answer[T]&lt;/code&gt; was removed from the API in favour of &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/#function-answers&#34;&gt;Function Answers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you were using something like &lt;code&gt;doAnswer(_ =&amp;gt; &amp;lt;something&amp;gt;).when ...&lt;/code&gt; to lazily compute a return value when the method is actually called you should now write it like &lt;code&gt;doAnswer(&amp;lt;something&amp;gt;).when ...&lt;/code&gt;, no need of passing a function as that argument is by-name&lt;/li&gt; &#xA; &lt;li&gt;If you have chained return values like &lt;code&gt;when(myMock.foo) thenReturn &#34;a&#34; thenReturn &#34;b&#34; etc...&lt;/code&gt; the syntax has changed a bit to &lt;code&gt;when(myMock.foo) thenReturn &#34;a&#34; andThen &#34;b&#34; etc...&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Idiomatic syntax has some changes to remove postFix operations and also allow support for mixing values and argument matchers &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/#mix-and-match&#34;&gt;Mix-and-Match&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;aMock.bar shouldCallRealMethod                              =&amp;gt; aMock.bar shouldCall realMethod&#xA;&#xA;aMock wasCalled on bar                                      =&amp;gt; aMock.bar was called&#xA;aMock wasCalled onlyOn bar                                  =&amp;gt; aMock.bar wasCalled onlyHere&#xA;aMock was never called on bar                               =&amp;gt; aMock.bar wasNever called&#xA;aMock wasCalled twiceOn bar                                 =&amp;gt; aMock.bar wasCalled twice&#xA;aMock wasCalled sixTimesOn bar                              =&amp;gt; aMock.bar wasCalled sixTimes&#xA;aMock was never called                                      =&amp;gt; aMock.bar wasNever called&#xA;aMock was never called again                                =&amp;gt; aMock.bar wasNever calledAgain&#xA;&#xA;&#34;mocked!&#34; willBe returned by aMock bar                      =&amp;gt; &#34;mocked!&#34; willBe returned by aMock.bar&#xA;&#34;mocked!&#34; willBe answered by aMock bar                      =&amp;gt; &#34;mocked!&#34; willBe answered by aMock.bar&#xA;((i: Int) =&amp;gt; i * 10) willBe answered by aMock bar *         =&amp;gt; ((i: Int) =&amp;gt; i * 10) willBe answered by aMock.bar(*)&#xA;theRealMethod willBe called by aMock bar                    =&amp;gt; theRealMethod willBe called by aMock.bar&#xA;new IllegalArgumentException willBe thrown by aMock bar     =&amp;gt; new IllegalArgumentException willBe thrown by aMock.bar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;eqToVal matcher syntax was improved to look more natural &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/#value-class-matchers&#34;&gt;Value Class Matchers&lt;/a&gt; NOTE: &lt;code&gt;eqToVal&lt;/code&gt; has been deprecated in v 1.0.2 as &lt;code&gt;eqTo&lt;/code&gt; is now aware of value classes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;verify(myObj).myMethod(eqToVal[MyValueClass](456))    =&amp;gt; verify(myObj).myMethod(eqToVal(MyValueClass(456)))&#xA;myObj.myMethod(eqToVal[MyValueClass](456)) was called =&amp;gt; myObj.myMethod(eqToVal(MyValueClass(456))) was called&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;h2&gt;&lt;code&gt;org.mockito.MockitoSugar&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;For a more detailed explanation read &lt;a href=&#34;https://medium.com/@bbonanno_83496/introduction-to-mockito-scala-ede30769cbda&#34;&gt;this&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This trait wraps the API available on &lt;code&gt;org.mockito.Mockito&lt;/code&gt; from the Java version, but it provides a more Scala-like syntax, mainly&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixes the compiler errors that sometimes occurred when using overloaded methods that use varargs like doReturn&lt;/li&gt; &#xA; &lt;li&gt;Eliminates the need to use &lt;code&gt;classOf[T]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Eliminates parenthesis when possible to make the test code more readable&lt;/li&gt; &#xA; &lt;li&gt;Adds &lt;code&gt;spyLambda[T]&lt;/code&gt; to allow spying lambdas (they don&#39;t work with the standard spy as they are created as final classes by the compiler)&lt;/li&gt; &#xA; &lt;li&gt;Supports mocking inline mixins like &lt;code&gt;mock[MyClass with MyTrait]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Full support for by-name arguments (the full support was added in &lt;strong&gt;1.4.0&lt;/strong&gt;, before it was partial).&lt;/li&gt; &#xA; &lt;li&gt;Adds support for working with default arguments&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The companion object also extends the trait to allow the usage of the API without mixing-in the trait in case that&#39;s desired&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;org.mockito.ArgumentMatchersSugar&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;For a more detailed explanation read &lt;a href=&#34;https://medium.com/@bbonanno_83496/introduction-to-mockito-scala-part-2-ba1a79cc4c53&#34;&gt;this&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This trait exposes all the existent &lt;code&gt;org.mockito.ArgumentMatchers&lt;/code&gt; but again it gives them a more Scala-like syntax, mainly&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;eq&lt;/code&gt; was renamed to &lt;code&gt;eqTo&lt;/code&gt; to avoid clashing with the Scala &lt;code&gt;eq&lt;/code&gt; operator for identity equality, &lt;code&gt;eq&lt;/code&gt; also supports value classes out of the box and relies on &lt;code&gt;org.scalactic.Equality[T]&lt;/code&gt; (see &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/#scalactic-integration&#34;&gt;Scalactic integration&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;any[T]&lt;/code&gt; works even when the type can&#39;t be inferred, removing the need of using the likes of &lt;code&gt;anyString&lt;/code&gt;, &lt;code&gt;anyInt&lt;/code&gt;, etc (see &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/#dead-code-warning&#34;&gt;Notes&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;any[T]&lt;/code&gt; also supports value classes (in this case you MUST provide the type parameter)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;isNull&lt;/code&gt; and &lt;code&gt;isNotNull&lt;/code&gt; are deprecated as using nulls in Scala is clear code smell&lt;/li&gt; &#xA; &lt;li&gt;Adds support for value classes via &lt;code&gt;anyVal[T]&lt;/code&gt; and &lt;code&gt;eqToVal[T]()&lt;/code&gt; &lt;strong&gt;NOTE: both had been deprecated (use &lt;code&gt;any[T]&lt;/code&gt; or &lt;code&gt;eqTo[T]&lt;/code&gt; instead)&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Adds &lt;code&gt;function0&lt;/code&gt; to easily match for a function that returns a given value&lt;/li&gt; &#xA; &lt;li&gt;Adds &lt;code&gt;argMatching&lt;/code&gt; that takes a partial function to match, i.e. &lt;code&gt;argMatching({ case Baz(_, &#34;pepe&#34;) =&amp;gt; })&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Again, the companion object also extends the trait to allow the usage of the API without mixing-in the trait in case that&#39;s desired&lt;/p&gt; &#xA;&lt;h3&gt;Value Class Matchers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;eqTo&lt;/code&gt; and &lt;code&gt;any[T]&lt;/code&gt; support value classes since v1.0.2, so no special syntax is needed for them (but you MUST provide the type param for &lt;code&gt;any[T]&lt;/code&gt; otherwise you&#39;ll get a NPE)&lt;/p&gt; &#xA;&lt;h2&gt;Improved ArgumentCaptor&lt;/h2&gt; &#xA;&lt;p&gt;For a more detailed explanation read &lt;a href=&#34;https://medium.com/@bbonanno_83496/introduction-to-mockito-scala-part-3-383c3b2ed55f&#34;&gt;this&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A new set of classes were added to make it easier, cleaner and more elegant to work with ArgumentCaptors, they also add support to capture value classes without any annoying syntax&lt;/p&gt; &#xA;&lt;p&gt;There is a new &lt;code&gt;object org.mockito.captor.ArgCaptor[T]&lt;/code&gt; that exposes a nicer API&lt;/p&gt; &#xA;&lt;p&gt;Before:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val aMock  = mock[Foo]&#xA;val captor = argumentCaptor[String]&#xA;&#xA;aMock.stringArgument(&#34;it worked!&#34;)&#xA;&#xA;verify(aMock).stringArgument(captor.capture())&#xA;&#xA;captor.getValue shouldBe &#34;it worked!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val aMock  = mock[Foo]&#xA;val captor = ArgCaptor[String]&#xA;&#xA;aMock.stringArgument(&#34;it worked!&#34;)&#xA;&#xA;verify(aMock).stringArgument(captor)&#xA;&#xA;captor hasCaptured &#34;it worked!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see there is no need to call &lt;code&gt;capture()&lt;/code&gt; nor &lt;code&gt;getValue&lt;/code&gt; anymore (although they&#39;re still there if you need them as &lt;code&gt;capture&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; respectively)&lt;/p&gt; &#xA;&lt;p&gt;The only scenario where you still have to call &lt;code&gt;capture&lt;/code&gt; by hand is where the argument you want to capture is &lt;code&gt;Any&lt;/code&gt; on the method signature, in that case the &lt;code&gt;implicit&lt;/code&gt; conversion that automatically does the capture&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit def asCapture[T](c: Captor[T]): T = c.capture&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is not called as the compiler finds no need to convert &lt;code&gt;Captor[Any]&lt;/code&gt; into &lt;code&gt;Any&lt;/code&gt;, as it is already an instance of &lt;code&gt;Any&lt;/code&gt;, given that &lt;code&gt;Any&lt;/code&gt; is the parent of every type in Scala. Because of that, the type does not need any transformation to be passed in.&lt;/p&gt; &#xA;&lt;p&gt;There is another constructor &lt;code&gt;ValCaptor[T]&lt;/code&gt; that should be used to capture value classes &lt;strong&gt;NOTE: Since version 1.0.2 &lt;code&gt;ValCaptor[T]&lt;/code&gt; has been deprecated as &lt;code&gt;ArgCaptor[T]&lt;/code&gt; now support both, standard and value classes&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Both &lt;code&gt;ArgCaptor[T]&lt;/code&gt; and &lt;code&gt;ValCaptor[T]&lt;/code&gt; return an instance of &lt;code&gt;Captor[T]&lt;/code&gt; so the API is the same for both&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;org.mockito.MockitoScalaSession&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;Basic usage&lt;/h3&gt; &#xA;&lt;p&gt;This is a wrapper around &lt;code&gt;org.mockito.MockitoSession&lt;/code&gt;, it&#39;s main purpose (on top of having a Scala API) is to improve the search of mis-used mocks and unexpected invocations to reduce debugging effort when something doesn&#39;t work&lt;/p&gt; &#xA;&lt;p&gt;To use it just wrap your code with it, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;MockitoScalaSession().run {&#xA;    val foo = mock[Foo]&#xA;    when(foo.bar(&#34;pepe&#34;)) thenReturn &#34;mocked&#34;&#xA;    foo.bar(&#34;pepe&#34;) shouldBe &#34;mocked&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! that block of code will execute within a session which will take care of checking the use of the framework and, if the test fails, it will try to find out if the failure could be related to a mock being used incorrectly&lt;/p&gt; &#xA;&lt;h3&gt;Spies&lt;/h3&gt; &#xA;&lt;p&gt;Spies for partial mocking of real objects&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&#34;LinkedList size&#34; should &#34;return 100&#34; in {&#xA;    val spiedList = spy(new util.LinkedList[String])&#xA;    when(spiedList.size).thenReturn(100)&#xA;    assert(spiedList.size === 100)&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Leniency&lt;/h3&gt; &#xA;&lt;p&gt;If for some reason we want that a mock created within the scope of a session does not report failures for some or all methods we can specify leniency for it.&lt;/p&gt; &#xA;&lt;p&gt;For the whole mock or spy to be ignored by the session, so basically a mock/spy that behaves as if the session didn&#39;t exist at all, we can make it lenient, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val aMock = mock[Foo](withSettings.lenient())&#xA;val aSpy = spy(new Bar, lenient = true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, if we just want to make one or more methods to be ignored by the session checks, we can make the method call lenient, this works as any other stubbing, so what it matters what matchers you define&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;aMock.myMethod(*) isLenient()&#xA;//or&#xA;when(aMock.myMethod(*)).isLenient()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Strict Mode&lt;/h2&gt; &#xA;&lt;p&gt;For a more detailed explanation read &lt;a href=&#34;https://medium.com/@bbonanno_83496/introduction-to-mockito-scala-part-3-383c3b2ed55f&#34;&gt;this&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;When using Scalatest and &lt;code&gt;org.mockito.scalatest.IdiomaticMockito&lt;/code&gt; this is the default mode, you can override the strictness to be lenient by doing &lt;code&gt;val strictness: Strictness = Strictness.Lenient&lt;/code&gt; The implication under the hood is that every test will run inside a &lt;code&gt;MockitoScalaSession&lt;/code&gt;, so &lt;strong&gt;all&lt;/strong&gt; of them will run in &lt;strong&gt;Strict Stub&lt;/strong&gt; mode.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;org.mockito.scalatest.IdiomaticMockito&lt;/code&gt; also includes &lt;code&gt;org.mockito.IdiomaticMockito&lt;/code&gt; and &lt;code&gt;org.mockito.ArgumentMatchersSugar&lt;/code&gt; so you have pretty much all the mockito-scala API available in one go, i.e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class MyTest extends WordSpec with IdiomaticMockito&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;IMPORTANT: A session is defined on a per-test basis, and only the mocks created within the scope of the session are handled by it, so if you have class level fields with mocks, i.e. mocks that are not created within the test, they will be ignored by the session. If you use the same mocks in all or most of the tests and want to avoid the boilerplate while still usfing the advantages of strict stubbing then declare those mocks in a setup trait.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class MySpec extends WordSpec with Mockito {&#xA;   trait Setup {&#xA;      val myMock = mock[Sth] &#xA;      myMock.someMethod returns &#34;something&#34; /*stub common to **all** tests -notice that if it&#39;s not used by all of them then the session will find it as an unused stubbing on those-*/&#xA;   }&#xA;&#xA;   &#34;some feature&#34; should {&#xA;       &#34;test whatever i want&#34; in new Setup {&#xA;            myMock.someOtherMethod(*) returns None /*stub specific only to this test*/&#xA;             ...test&#xA;       }&#xA;&#xA;      &#34;test something else&#34; in new Setup {&#xA;             myMock.someOtherMethod(&#34;expected value&#34;) returns Some(&#34;result&#34;)  /*stub specific only to this test*/&#xA;             ...test&#xA;       }&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will give you a fresh new instance of &lt;code&gt;myMock&lt;/code&gt; for each test but at the same time you only declare the creation/common stubbing once.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;org.mockito.integrations.scalatest.ResetMocksAfterEachTest&lt;/code&gt; | &lt;code&gt;org.mockito.integrations.scalatest.ResetMocksAfterEachAsyncTest&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Inspired by &lt;a href=&#34;https://stackoverflow.com/questions/51387234/is-there-a-per-test-non-specific-mock-reset-pattern-using-scalaplayspecmockito&#34;&gt;this&lt;/a&gt; StackOverflow question, mockito-scala provides these traits that helps to automatically reset any existent mock after each test is run The trait has to be mixed &lt;strong&gt;after&lt;/strong&gt; &lt;code&gt;org.mockito.MockitoSugar&lt;/code&gt; in order to work, otherwise your test will not compile The code shown in the StackOverflow question would look like this if using this mechanism&lt;/p&gt; &#xA;&lt;p&gt;NOTE: MockitoFixture and ResetMocksAfterEachTest are mutually exclusive, so don&#39;t expect them to work together&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class MyTest extends PlaySpec with MockitoSugar with ResetMocksAfterEachTest&#xA;&#xA;private val foo = mock[Foo]&#xA;&#xA;override def fakeApplication(): Application = new GuiceApplicationBuilder().overrides(bind[Foo].toInstance(foo)).build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The main advantage being we don&#39;t have to remember to reset each one of the mocks...&lt;/p&gt; &#xA;&lt;p&gt;If for some reason we want to have a mock that is not reset automatically while using this trait, then it should be created via the companion object of &lt;code&gt;org.mockito.MockitoSugar&lt;/code&gt; so is not tracked by this mechanism&lt;/p&gt; &#xA;&lt;h2&gt;Idiomatic Mockito&lt;/h2&gt; &#xA;&lt;p&gt;By adding the trait &lt;code&gt;org.mockito.IdiomaticMockito&lt;/code&gt; you get access to some improved methods in the API&lt;/p&gt; &#xA;&lt;p&gt;This API is heavily inspired on Scalatest&#39;s Matchers, so if you have used them, you&#39;ll find it very familiar&lt;/p&gt; &#xA;&lt;p&gt;Here we can see the old syntax on the left and the new one on the right&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Foo {&#xA;  def bar: String&#xA;  def bar(v: Int): Int&#xA;}&#xA;  &#xA;val aMock = mock[Foo]  &#xA;  &#xA;when(aMock.bar) thenReturn &#34;mocked!&#34;                            &amp;lt;=&amp;gt; aMock.bar returns &#34;mocked!&#34;&#xA;when(aMock.bar) thenReturn &#34;mocked!&#34; thenReturn &#34;mocked again!&#34; &amp;lt;=&amp;gt; aMock.bar returns &#34;mocked!&#34; andThen &#34;mocked again!&#34;&#xA;when(aMock.bar) thenCallRealMethod()                            &amp;lt;=&amp;gt; aMock.bar shouldCall realMethod&#xA;when(aMock.bar).thenThrow[IllegalArgumentException]             &amp;lt;=&amp;gt; aMock.bar.shouldThrow[IllegalArgumentException]&#xA;when(aMock.bar) thenThrow new IllegalArgumentException          &amp;lt;=&amp;gt; aMock.bar throws new IllegalArgumentException&#xA;when(aMock.bar) thenAnswer(_ =&amp;gt; &#34;mocked!&#34;)                      &amp;lt;=&amp;gt; aMock.bar answers &#34;mocked!&#34;&#xA;when(aMock.bar(any)) thenAnswer(_.getArgument[Int](0) * 10)     &amp;lt;=&amp;gt; aMock.bar(*) answers ((i: Int) =&amp;gt; i * 10)&#xA;&#xA;doReturn(&#34;mocked!&#34;).when(aMock).bar                             &amp;lt;=&amp;gt; &#34;mocked!&#34; willBe returned by aMock.bar&#xA;doAnswer(_ =&amp;gt; &#34;mocked!&#34;).when(aMock).bar                        &amp;lt;=&amp;gt; &#34;mocked!&#34; willBe answered by aMock.bar&#xA;doAnswer(_.getArgument[Int](0) * 10).when(aMock).bar(any)       &amp;lt;=&amp;gt; ((i: Int) =&amp;gt; i * 10) willBe answered by aMock.bar(*)&#xA;doCallRealMethod.when(aMock).bar                                &amp;lt;=&amp;gt; theRealMethod willBe called by aMock.bar&#xA;doThrow(new IllegalArgumentException).when(aMock).bar           &amp;lt;=&amp;gt; new IllegalArgumentException willBe thrown by aMock.bar&#xA;&#xA;doNothing().when(aMock).bar                                     &amp;lt;=&amp;gt; aMock.bar.doesNothing()&#xA;  &#xA;verifyZeroInteractions(aMock)                                   &amp;lt;=&amp;gt; aMock wasNever called&#xA;verify(aMock).bar                                               &amp;lt;=&amp;gt; aMock.bar was called&#xA;verify(aMock).bar(any)                                          &amp;lt;=&amp;gt; aMock.bar(*) was called&#xA;&#xA;verify(aMock, only).bar                                         &amp;lt;=&amp;gt; aMock.bar wasCalled onlyHere&#xA;verify(aMock, never).bar                                        &amp;lt;=&amp;gt; aMock.bar wasNever called&#xA;&#xA;verify(aMock, times(2)).bar                                     &amp;lt;=&amp;gt; aMock.bar wasCalled twice&#xA;verify(aMock, times(2)).bar                                     &amp;lt;=&amp;gt; aMock.bar wasCalled 2.times&#xA;&#xA;verify(aMock, times(6)).bar                                     &amp;lt;=&amp;gt; aMock.bar wasCalled sixTimes&#xA;verify(aMock, times(6)).bar                                     &amp;lt;=&amp;gt; aMock.bar wasCalled 6.times&#xA;&#xA;verify(aMock, atLeast(6)).bar                                   &amp;lt;=&amp;gt; aMock.bar wasCalled atLeastSixTimes&#xA;verify(aMock, atLeast(6)).bar                                   &amp;lt;=&amp;gt; aMock.bar wasCalled atLeast(sixTimes)&#xA;verify(aMock, atLeast(6)).bar                                   &amp;lt;=&amp;gt; aMock.bar wasCalled atLeast(6.times)&#xA;&#xA;verify(aMock, atMost(6)).bar                                    &amp;lt;=&amp;gt; aMock.bar wasCalled atMostSixTimes&#xA;verify(aMock, atMost(6)).bar                                    &amp;lt;=&amp;gt; aMock.bar wasCalled atMost(sixTimes)&#xA;verify(aMock, atMost(6)).bar                                    &amp;lt;=&amp;gt; aMock.bar wasCalled atMost(6.times)&#xA;&#xA;verify(aMock, timeout(2000).atLeast(6)).bar                     &amp;lt;=&amp;gt; aMock.bar wasCalled (atLeastSixTimes within 2.seconds)&#xA;&#xA;verifyNoMoreInteractions(aMock)                                 &amp;lt;=&amp;gt; aMock wasNever calledAgain&#xA;&#xA;val order = inOrder(mock1, mock2)                               &amp;lt;=&amp;gt; InOrder(mock1, mock2) { implicit order =&amp;gt;&#xA;order.verify(mock2).someMethod()                                &amp;lt;=&amp;gt;   mock2.someMethod() was called&#xA;order.verify(mock1).anotherMethod()                             &amp;lt;=&amp;gt;   mock1.anotherMethod() was called&#xA;                                                                &amp;lt;=&amp;gt; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see the new syntax reads a bit more natural, also notice you can use &lt;code&gt;*&lt;/code&gt; instead of &lt;code&gt;any[T]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Check the &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/scalatest/src/test/scala/user/org/mockito/scalatest/IdiomaticMockitoTest.scala&#34;&gt;tests&lt;/a&gt; for more examples&lt;/p&gt; &#xA;&lt;p&gt;NOTE: When using the willBe syntax for stubbing, you can only stub one value to be returned, this is due to a limitation of the type inference. If for some reason you have to do that (ideally all functions should be referentially transparent, so you wouldn&#39;t have to), you can use the traditional syntax via the MockitoSugar companion object &lt;code&gt;MockitoSugar.doReturn(&#34;meh&#34;).when(myMock).foo&lt;/code&gt; or you can use an answer that can decide what to return given whatever condition you need to simulate &lt;code&gt;{ (args) =&amp;gt; if(&amp;lt;condition&amp;gt;) something else somethingElse } willBe answered by myMock.foo&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Expect DSL&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: This DSL is experimental, may be unstable and may introduce incompatible changes between minor/patch versions&lt;/p&gt; &#xA;&lt;p&gt;This DSL is available as a prefix alternative to &lt;code&gt;aMock.bar was called&lt;/code&gt; DSL provided by &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/#idiomatic-mockito&#34;&gt;Idiomatic Mockito&lt;/a&gt; while keeping the original mocking and stubbing functionality. As you can see, with the new syntax you declare the intent of verification before describing the called pattern, so it reads even more naturally then before.&lt;/p&gt; &#xA;&lt;p&gt;It is available via &lt;code&gt;org.mockito.IdiomaticMockito.WithExpect&lt;/code&gt; mix-in (or its companion object). Mocking and stubbing works the same as before, and below are the examples of how verifications should be done.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Foo {&#xA;  def bar: String&#xA;  def bar(v: Int): Int&#xA;}&#xA;  &#xA;val aMock = mock[Foo]  &#xA;  &#xA;verifyZeroInteractions(aMock)                     &amp;lt;=&amp;gt; expect no calls on aMock&#xA;&#xA;verify(aMock).bar                                 &amp;lt;=&amp;gt; expect a call to aMock.bar&#xA;verify(aMock).bar(any)                            &amp;lt;=&amp;gt; expect a call to aMock.bar(*)&#xA;&#xA;verify(aMock, only).bar                           &amp;lt;=&amp;gt; expect only call to aMock.bar&#xA;verify(aMock, never).bar                          &amp;lt;=&amp;gt; expect no calls to aMock.bar&#xA;&#xA;verify(aMock, times(2)).bar                       &amp;lt;=&amp;gt; expect exactly 2.calls to aMock.bar&#xA;verify(aMock, times(2)).bar                       &amp;lt;=&amp;gt; expect two calls to aMock.bar&#xA;verify(aMock, times(2)).bar                       &amp;lt;=&amp;gt; expect (2.calls) to aMock.bar&#xA;&#xA;verify(aMock, times(6)).bar                       &amp;lt;=&amp;gt; expect exactly 6.calls to aMock.bar&#xA;verify(aMock, times(6)).bar                       &amp;lt;=&amp;gt; expect six calls to aMock.bar&#xA;verify(aMock, times(6)).bar                       &amp;lt;=&amp;gt; expect (6.calls) to aMock.bar&#xA;&#xA;verify(aMock, atLeast(6)).bar                     &amp;lt;=&amp;gt; expect atLeast 6.calls to aMock.bar&#xA;verify(aMock, atLeast(6)).bar                     &amp;lt;=&amp;gt; expect atLeastSix calls to aMock.bar&#xA;&#xA;verify(aMock, atMost(6)).bar                      &amp;lt;=&amp;gt; expect atMost 6.calls to aMock.bar&#xA;verify(aMock, atMost(6)).bar                      &amp;lt;=&amp;gt; expect atMostSix calls to aMock.bar&#xA;&#xA;verify(aMock, timeout(2000).times(2)).bar         &amp;lt;=&amp;gt; expect (2.calls within 2.seconds) to aMock.bar&#xA;verify(aMock, timeout(2000).atLeast(6)).bar       &amp;lt;=&amp;gt; expect (atLeast(6.calls) within 2.seconds) to aMock.bar&#xA;&#xA;verifyNoMoreInteractions(aMock)                   &amp;lt;=&amp;gt; expect noMore calls on aMock&#xA;verifyNoMoreInteractions(ignoreStubs(aMock))      &amp;lt;=&amp;gt; expect noMore calls(ignoringStubs) on aMock&#xA;&#xA;val order = inOrder(mock1, mock2)                 &amp;lt;=&amp;gt; InOrder(mock1, mock2) { implicit order =&amp;gt;&#xA;order.verify(mock2).someMethod()                  &amp;lt;=&amp;gt;   expect a call to mock2.someMethod()&#xA;order.verify(mock1).anotherMethod()               &amp;lt;=&amp;gt;   expect a call to mock1.anotherMethod()&#xA;                                                  &amp;lt;=&amp;gt; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Default Answers&lt;/h2&gt; &#xA;&lt;p&gt;We defined a new type &lt;code&gt;org.mockito.stubbing.DefaultAnswer&lt;/code&gt; which is used to configure the default behaviour of a mock when a non-stubbed invocation is made on it.&lt;/p&gt; &#xA;&lt;p&gt;The object &lt;code&gt;org.mockito.DefaultAnswers&lt;/code&gt; contains each one of the provided ones&lt;/p&gt; &#xA;&lt;p&gt;All the mocks created will use &lt;code&gt;ReturnsSmartNulls&lt;/code&gt; by default, this is different to the Java version, which returns null for any non-primitive or non-final class.&lt;/p&gt; &#xA;&lt;p&gt;A &#34;Smart Null&#34;, is nothing else than a mock of the type returned by the called method. The main advantage of doing that is that if the code tries to call any method on this mock, instead of failing with a NPE the mock will throw a different exception with a hint of the non-stubbed method that was called (including its params), this should make much easier the task of finding and fixing non-stubbed calls&lt;/p&gt; &#xA;&lt;p&gt;Most of the Answers defined in &lt;code&gt;org.mockito.Answers&lt;/code&gt; have it&#39;s counterpart in &lt;code&gt;org.mockito.DefaultAnswers&lt;/code&gt;, and on top of that we also provide &lt;code&gt;ReturnsEmptyValues&lt;/code&gt; which will try its best to return an empty object for well known types, i.e. &lt;code&gt;Nil&lt;/code&gt; for &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; for &lt;code&gt;Option&lt;/code&gt; etc. This DefaultAnswer is not part of the default behaviour as we think a SmartNull is better, to explain why, let&#39;s imagine we have the following code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class UserRepository {&#xA;  def find(id: Int): Option[User]&#xA;}&#xA;class UserController(userRepository: UserRepository) {&#xA;  def get(userId: Int): Option[Json] = userRepository.find(userId).map(_.toJson)&#xA;}&#xA;&#xA;class UserControllerTest extends WordSpec with IdiomaticMockito {&#xA;&#xA;  &#34;get&#34; should {&#xA;     &#34;return the expected json&#34; in {&#xA;        val repo = mock[UserRepository]&#xA;        val testObj = new UserController(repo)&#xA;&#xA;        testObj.get(123) shouldBe Some(Json(....)) //overly simplified for clarity&#xA;      }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, in that example that test could fail in 3 different ways&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;With the standard implementation of Mockito, the mock would return null and we would get a NullPointerException, which we all agree it&#39;s far from ideal, as it&#39;s hard to know where did it happen in non trivial code&lt;/li&gt; &#xA; &lt;li&gt;With the default/empty values, we would get a &lt;code&gt;None&lt;/code&gt;, so the final result would be &lt;code&gt;None&lt;/code&gt; and we will get an assertion error as &lt;code&gt;None&lt;/code&gt; is not &lt;code&gt;Some(Json(....))&lt;/code&gt;, but I&#39;m not sure how much improvement over the NPE this would be, because in a non-trivial method we may have many dependencies returning &lt;code&gt;Option&lt;/code&gt; and it could be hard to track down which one is returning &lt;code&gt;None&lt;/code&gt; and why&lt;/li&gt; &#xA; &lt;li&gt;With a smart-null, we would return a &lt;code&gt;mock[Option]&lt;/code&gt; and as soon as our code calls to &lt;code&gt;.map()&lt;/code&gt; that mock would fail with an exception telling you what non-stubbed method was called and on which mock (in the example would say something you called the &lt;code&gt;find&lt;/code&gt; method on some &lt;code&gt;mock of type UserRepository&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;And that&#39;s why we use option 3 as default&lt;/p&gt; &#xA;&lt;p&gt;Of course you can override the default behaviour, for this you have 2 options&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If you wanna do it just for a particular mock, you can, at creation time do &lt;code&gt;mock[MyType](MyDefaultAnswer)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you wanna do it for all the mocks in a test, you can define an &lt;code&gt;implicit&lt;/code&gt;, i.e. &lt;code&gt;implicit val defaultAnswer: DefaultAnswer = MyDefaultAnswer&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;DefaultAnswers are also composable, so for example if you wanted empty values first and then smart nulls you could do &lt;code&gt;implicit val defaultAnswer: DefaultAnswer = ReturnsEmptyValues orElse ReturnsSmartNulls&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Function Answers&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;org.mockito.Answer[T]&lt;/code&gt; can be a bit boilerplate-ish, mostly if you&#39;re still in Scala 2.11 (in 2.12 with SAM is much nicer), to simplify the usage for both versions is that we replaced it by standard scala functions, so instead of&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;when(myMock.foo(&#34;bar&#34;, 42)) thenAnswer new Answer[String] {&#xA;  override def answer(invocation: InvocationOnMock): String = i.getArgument[String](0) + i.getArgument[Int](1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can now write: (this may be nothing new for users of 2.12, but at least now the API is consistent for both 2.11 and 2.12)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;when(myMock.foo(&#34;bar&#34;, 42)) thenAnswer ((i: InvocationOnMock) =&amp;gt; i.getArgument[String](0) + i.getArgument[Int](1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;I guess we all agree that&#39;s much better, but, it gets even better, we can now pass standard functions that work over the arguments, we only need to take care to pass the right types, so the previous example would become&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;when(myMock.foo(&#34;bar&#34;, 42)) thenAnswer ((v1: String, v2: Int) =&amp;gt; v1 + v2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Mix and match&lt;/h2&gt; &#xA;&lt;h3&gt;Mixing normal values with argument matchers&lt;/h3&gt; &#xA;&lt;p&gt;Since mockito 1.0.0, when you use the idiomatic syntax, you are not forced anymore to use argument matchers for all your parameters as soon as you use one, so stuff like this is now valid (not a comprehensive list, just a bunch of examples)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Foo {&#xA;  def bar(v: Int, v2: Int, v3: Int = 42): Int&#xA;}&#xA;  &#xA;val aMock = mock[Foo]  &#xA;  &#xA;aMock.bar(1,2) returns &#34;mocked!&#34;&#xA;aMock.bar(1,*) returns &#34;mocked!&#34;&#xA;aMock.bar(*,*) returns &#34;mocked!&#34;&#xA;aMock.bar(*,*, 3) returns &#34;mocked!&#34;&#xA;&#xA;&#34;mocked!&#34; willBe returned by aMock.bar(1,2)&#xA;&#34;mocked!&#34; willBe returned by aMock.bar(1,*)&#xA;&#34;mocked!&#34; willBe returned by aMock.bar(*,*)&#xA;&#34;mocked!&#34; willBe returned by aMock.bar(*,*, 3)&#xA;&#xA;aMock.bar(1,2) was called&#xA;aMock.bar(1,*) was called&#xA;aMock.bar(*,*) was called&#xA;aMock.bar(*,*, 3) was called&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So far there is one caveat, if you have a curried function that has default arguments on the second (or any following) argument list, the macro that achieves this will fail, this is related to how the default method is created by the compiler. I&#39;ll write a more detailed explanation at some point, but there are more than one reason why this is probably never going to work The workaround is quite easy though, just provide a value (or a matcher) for that argument and you are good to go.&lt;/p&gt; &#xA;&lt;h2&gt;Numeric matchers&lt;/h2&gt; &#xA;&lt;p&gt;A new set of matchers to deal with number comparison were introduced (see &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/#tolerance&#34;&gt;Scalactic tolerance&lt;/a&gt; for approximation), the syntax is slightly different to make them more readable, so now we can write stuff like (notice the &#39;n&#39;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;aMock.method(5)&#xA;&#xA;aMock.method(n &amp;gt; 4.99) was called&#xA;aMock.method(n &amp;gt;= 5) was called&#xA;aMock.method(n &amp;lt; 5.1) was called&#xA;aMock.method(n &amp;lt;= 5) was called&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Varargs&lt;/h2&gt; &#xA;&lt;p&gt;Most matchers that makes sense to, work with varargs out of the box, the only thing to notice is that if you are passing more than one value and want to use &lt;code&gt;eqTo&lt;/code&gt; then you should pass all of them to the same instance of &lt;code&gt;eqTo&lt;/code&gt; e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait FooWithVarArgAndSecondParameterList {&#xA;  def bar(bells: String*)(cheese: String): String&#xA;}&#xA;&#xA;foo.bar(eqTo(&#34;cow&#34;, &#34;blue&#34;))(*) was called //RIGHT&#xA;foo.bar(eqTo(&#34;cow&#34;), eqTo(&#34;blue&#34;))(*) was called //WRONG - it will complain it was expecting 2 matchers but got 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Scalactic integration&lt;/h2&gt; &#xA;&lt;h3&gt;Equality&lt;/h3&gt; &#xA;&lt;p&gt;Since version 1.0.0 the &lt;code&gt;eqTo&lt;/code&gt; matcher uses the &lt;code&gt;org.scalactic.Equality[T]&lt;/code&gt; typeclass, this doesn&#39;t change anything on the API and existent code will not be affected, but it allows you to override the standard equality of any class by just providing an implicit &lt;code&gt;Equality&lt;/code&gt; in scope, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit val fooEquality: Equality[Foo] = new Equality[Foo] { &#xA;  override def areEqual(a: Foo, b: Any): Boolean = /*Do the comparison as you like*/ &#xA;}&#xA;&#xA;aMock.method(eqTo(/*some foo instance/*))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tolerance&lt;/h3&gt; &#xA;&lt;p&gt;You can use Scalactic&#39;s &lt;code&gt;Spread[T]&lt;/code&gt; to deal with the precision errors in floating points, so you can now write stuff like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;aMock.method(4.999)&#xA;&#xA;aMock.method(n =~ 5.0 +- 0.001) was called&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Prettifier&lt;/h3&gt; &#xA;&lt;p&gt;An instance of &lt;code&gt;org.scalactic.Prettifier&lt;/code&gt; is implicitly pulled by the &lt;code&gt;EqTo&lt;/code&gt; matcher to provide a nicer (and customisable) printing of your types when an verification fails. &lt;code&gt;EqTo&lt;/code&gt; is also used internally by &lt;code&gt;Mockito&lt;/code&gt; to print the arguments of every invocation, so you&#39;ll get a consistent printing for both the expectation and the actual call.&lt;/p&gt; &#xA;&lt;p&gt;If you want to customise the print of any type you just need to declare your &lt;code&gt;Prettifier&lt;/code&gt; in the implicit scope like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  implicit val prettifier: Prettifier = new Prettifier {&#xA;    override def apply(o: Any): String = o match {&#xA;      case Baz2(_, s) =&amp;gt; s&#34;PrettifiedBaz($s)&#34;&#xA;      case other      =&amp;gt; Prettifier.default(other)&#xA;    }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Cats integration&lt;/h2&gt; &#xA;&lt;p&gt;By adding the module &lt;code&gt;mockito-scala-cats&lt;/code&gt; 2 new traits are available, &lt;code&gt;IdiomaticMockitoCats&lt;/code&gt; and &lt;code&gt;MockitoCats&lt;/code&gt; which are meant to be mixed-in in tests that use &lt;code&gt;IdiomaticMockito&lt;/code&gt; and &lt;code&gt;MockitoSugar&lt;/code&gt; respectively. Please look at the &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/cats/src/test&#34;&gt;tests&lt;/a&gt; for more detailed examples&lt;/p&gt; &#xA;&lt;h3&gt;MockitoCats&lt;/h3&gt; &#xA;&lt;p&gt;This traits adds &lt;code&gt;whenF()&lt;/code&gt; which allows stubbing methods that return an Applicative (or an ApplicativeError) to be stubbed by just providing the content of said applicative (or the error). So for&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Foo {&#xA;    def returnsOption[T](v: T): Option[T]&#xA;    def returnsMT[M[_], T](v: T): M[T]&#xA;}&#xA;// We can now write &#xA;val aMock = mock[Foo]&#xA;whenF(aMock.returnsOption(*)) thenReturn &#34;mocked!&#34;&#xA;whenF(aMock.returnsMT[Future, String](*)) thenReturn &#34;mocked!&#34;&#xA;// Rather than&#xA;when(aMock.returnsOption(*)) thenReturn Some(&#34;mocked!&#34;)&#xA;when(aMock.returnsMT[Future, String](*)) thenReturn Future.successful(&#34;mocked!&#34;)&#xA;&#xA;//We could also do stubbings in a single line if that&#39;s all we need from the mock&#xA;val inlineMock: Foo = whenF(mock[Foo].returnsOption(*)) thenReturn &#34;mocked!&#34;&#xA;&#xA;// For errors we can do&#xA;type ErrorOr[A] = Either[Error, A]&#xA;val failingMock: Foo = whenF(mock[Foo].returnsMT[ErrorOr, MyClass](*)) thenFailWith Error(&#34;error&#34;)&#xA;//Rather than&#xA;val failingMock: Foo = when(mock[Foo].returnsMT[ErrorOr, MyClass](*)) thenReturn Left(Error(&#34;error&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The trait also provides and implicit conversion from &lt;code&gt;cats.Eq&lt;/code&gt; to &lt;code&gt;scalactic.Equality&lt;/code&gt; so if you have an implicit &lt;code&gt;cats.Eq&lt;/code&gt; instance in scope, it will be automatically used by the &lt;code&gt;eqTo&lt;/code&gt; matcher.&lt;/p&gt; &#xA;&lt;h3&gt;IdiomaticMockitoCats&lt;/h3&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;MockitoCats&lt;/code&gt; but for the idiomatic syntax (including the conversion from &lt;code&gt;cats.Eq&lt;/code&gt; to &lt;code&gt;scalactic.Equality&lt;/code&gt;), so the code would look like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Foo {&#xA;    def returnsOption[T](v: T): Option[T]&#xA;    def returnsMT[M[_], T](v: T): M[T]&#xA;}&#xA;// We can now write &#xA;val aMock = mock[Foo]&#xA;aMock.returnsOption(*) returnsF &#34;mocked!&#34;&#xA;aMock.returnsMT[Future, String](*) returnsF &#34;mocked!&#34;&#xA;// Rather than&#xA;aMock.returnsOption(*) returns Some(&#34;mocked!&#34;)&#xA;aMock.returnsMT[Future, String](*) returns Future.successful(&#34;mocked!&#34;)&#xA;&#xA;//We could also do stubbings in a single line if that&#39;s all we need from the mock&#xA;val inlineMock: Foo = mock[Foo].returnsOption(*) returnsF &#34;mocked!&#34;&#xA;&#xA;// For errors we can do&#xA;type ErrorOr[A] = Either[Error, A]&#xA;val failingMock: Foo = mock[Foo].returnsMT[ErrorOr, MyClass](*) raises Error(&#34;error&#34;)&#xA;//Rather than&#xA;val failingMock: Foo = mock[Foo].returnsMT[ErrorOr, MyClass](*) returns Left(Error(&#34;error&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Scalaz integration&lt;/h2&gt; &#xA;&lt;p&gt;By adding the module &lt;code&gt;mockito-scala-scalaz&lt;/code&gt; 2 new traits are available, &lt;code&gt;IdiomaticMockitoScalaz&lt;/code&gt; and &lt;code&gt;MockitoScalaz&lt;/code&gt; which are meant to be mixed-in in tests that use &lt;code&gt;IdiomaticMockito&lt;/code&gt; and &lt;code&gt;MockitoSugar&lt;/code&gt; respectively. Please look at the &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/scalaz/src/test&#34;&gt;tests&lt;/a&gt; for more detailed examples&lt;/p&gt; &#xA;&lt;h3&gt;MockitoScalaz&lt;/h3&gt; &#xA;&lt;p&gt;This traits adds &lt;code&gt;whenF()&lt;/code&gt; which allows stubbing methods that return an Applicative (or an ApplicativeError) to be stubbed by just providing the content of said applicative (or the error). So for&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Foo {&#xA;    def returnsOption[T](v: T): Option[T]&#xA;    def returnsMT[M[_], T](v: T): M[T]&#xA;}&#xA;// We can now write &#xA;val aMock = mock[Foo]&#xA;whenF(aMock.returnsOption(*)) thenReturn &#34;mocked!&#34;&#xA;whenF(aMock.returnsMT[Future, String](*)) thenReturn &#34;mocked!&#34;&#xA;// Rather than&#xA;when(aMock.returnsOption(*)) thenReturn Some(&#34;mocked!&#34;)&#xA;when(aMock.returnsMT[Future, String](*)) thenReturn Future.successful(&#34;mocked!&#34;)&#xA;&#xA;//We could also do stubbings in a single line if that&#39;s all we need from the mock&#xA;val inlineMock: Foo = whenF(mock[Foo].returnsOption(*)) thenReturn &#34;mocked!&#34;&#xA;&#xA;// For errors we can do&#xA;type ErrorOr[A] = Either[Error, A]&#xA;val failingMock: Foo = whenF(mock[Foo].returnsMT[ErrorOr, MyClass](*)) thenFailWith Error(&#34;error&#34;)&#xA;//Rather than&#xA;val failingMock: Foo = when(mock[Foo].returnsMT[ErrorOr, MyClass](*)) thenReturn Left(Error(&#34;error&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The trait also provides and implicit conversion from &lt;code&gt;scalaz.Equal&lt;/code&gt; to &lt;code&gt;scalactic.Equality&lt;/code&gt; so if you have an implicit &lt;code&gt;scalaz.Equal&lt;/code&gt; instance in scope, it will be automatically used by the &lt;code&gt;eqTo&lt;/code&gt; matcher.&lt;/p&gt; &#xA;&lt;h3&gt;IdiomaticMockitoScalaz&lt;/h3&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;MockitoScalaz&lt;/code&gt; but for the idiomatic syntax (including the conversion from &lt;code&gt;scalaz.Equal&lt;/code&gt; to &lt;code&gt;scalactic.Equality&lt;/code&gt;), so the code would look like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Foo {&#xA;    def returnsOption[T](v: T): Option[T]&#xA;    def returnsMT[M[_], T](v: T): M[T]&#xA;}&#xA;// We can now write &#xA;val aMock = mock[Foo]&#xA;aMock.returnsOption(*) returnsF &#34;mocked!&#34;&#xA;aMock.returnsMT[Future, String](*) returnsF &#34;mocked!&#34;&#xA;// Rather than&#xA;aMock.returnsOption(*) returns Some(&#34;mocked!&#34;)&#xA;aMock.returnsMT[Future, String](*) returns Future.successful(&#34;mocked!&#34;)&#xA;&#xA;//We could also do stubbings in a single line if that&#39;s all we need from the mock&#xA;val inlineMock: Foo = mock[Foo].returnsOption(*) returnsF &#34;mocked!&#34;&#xA;&#xA;// For errors we can do&#xA;type ErrorOr[A] = Either[Error, A]&#xA;val failingMock: Foo = mock[Foo].returnsMT[ErrorOr, MyClass](*) raises Error(&#34;error&#34;)&#xA;//Rather than&#xA;val failingMock: Foo = mock[Foo].returnsMT[ErrorOr, MyClass](*) returns Left(Error(&#34;error&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Mocking Scala &lt;code&gt;object&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Since version 1.16.0 it is possible to mock &lt;code&gt;object&lt;/code&gt; methods, given that such definitions are global, the way to mock them is slightly different in order to ensure we restore the real implementation of the object after we are done&lt;/p&gt; &#xA;&lt;p&gt;To enable &lt;code&gt;withObjectMocked&lt;/code&gt; feature, it is mandatory to create the file &lt;code&gt;src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker&lt;/code&gt; containing a single line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt; mock-maker-inline&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object FooObject {&#xA;  def simpleMethod: String = &#34;not mocked!&#34;&#xA;}&#xA;&#xA;&#34;mock&#34; should {&#xA;    &#34;stub an object method&#34; in {&#xA;      FooObject.simpleMethod shouldBe &#34;not mocked!&#34;&#xA;&#xA;      withObjectMocked[FooObject.type] {&#xA;        FooObject.simpleMethod returns &#34;mocked!&#34;&#xA;        //or&#xA;        when(FooObject.simpleMethod) thenReturn &#34;mocked!&#34;&#xA;&#xA;        FooObject.simpleMethod shouldBe &#34;mocked!&#34;&#xA;      }&#xA;&#xA;      FooObject.simpleMethod shouldBe &#34;not mocked!&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, the effect of the mocking is only available inside the code block passed to &lt;code&gt;withObjectMocked&lt;/code&gt;, when such block ends the behavior of the object is restored to its original implementation&lt;/p&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;h3&gt;Dead code warning&lt;/h3&gt; &#xA;&lt;p&gt;if you have enabled the compiler flag &lt;code&gt;-Ywarn-dead-code&lt;/code&gt;, you will see the warning &lt;em&gt;dead code following this construct&lt;/em&gt; when using the &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt; matchers , this is because in some cases the compiler can not infer the return type of those matchers and it will default to &lt;code&gt;Nothing&lt;/code&gt;, and this compiler warning is shown every time &lt;code&gt;Nothing&lt;/code&gt; is found on our code. This will &lt;strong&gt;NOT&lt;/strong&gt; affect the behaviour of Mockito nor your test in any way, so it can be ignored, but in case you want to get rid of it then you have 2 options:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If you are not too fuss about dead code warnings in test code, you can add &lt;code&gt;scalacOptions in Test -= &#34;-Ywarn-dead-code&#34;&lt;/code&gt; to your build.sbt and that warning will be ignored for your tests &lt;strong&gt;only&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you wanna keep the warning enabled for potentially real dead code statements, but get rid of the warnings related to the matchers usage then you have to explicitly provide the type for the matcher, thus &lt;code&gt;any&lt;/code&gt; would become &lt;code&gt;any[MyType]&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; would become &lt;code&gt;*[MyType]&lt;/code&gt; (you can also use &lt;code&gt;anyShort&lt;/code&gt;, &lt;code&gt;anyInt&lt;/code&gt;, etc for the primitive types)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Scala 2.11&lt;/h3&gt; &#xA;&lt;p&gt;Please note that in Scala 2.11 the following features are not supported&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Default arguments on methods defined in traits (they will behave as before, getting &lt;code&gt;null&lt;/code&gt; or a default value if they are of a primitive type)&lt;/li&gt; &#xA; &lt;li&gt;Any kind of &lt;code&gt;ArgumentMatcher[T]&lt;/code&gt; for methods with by-name parameters (they&#39;ll throw an exception if used with &lt;code&gt;ArgumentMatcher[T]&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Authors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Bruno Bonanno&lt;/strong&gt; - &lt;em&gt;Initial work&lt;/em&gt; - &lt;a href=&#34;https://github.com/bbonanno&#34;&gt;bbonanno&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the MIT License - see the &lt;a href=&#34;https://raw.githubusercontent.com/mockito/mockito-scala/release/1.x/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file for details&lt;/p&gt;</summary>
  </entry>
</feed>