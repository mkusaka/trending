<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-03T02:30:47Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kitlangton/quotidian</title>
    <updated>2023-03-03T02:30:47Z</updated>
    <id>tag:github.com,2023-03-03:/kitlangton/quotidian</id>
    <link href="https://github.com/kitlangton/quotidian" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A menagerie of macro utilities and extensions for Scala 3&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;quotidian&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://oss.sonatype.org/content/repositories/releases/io/github/kitlangton/quotidian_3/&#34; title=&#34;Sonatype Releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/nexus/r/https/oss.sonatype.org/io.github.kitlangton/quotidian_3.svg?sanitize=true&#34; alt=&#34;Release Artifacts&#34; title=&#34;Sonatype Releases&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://oss.sonatype.org/content/repositories/snapshots/io/github/kitlangton/quotidian_3/&#34; title=&#34;Sonatype Snapshots&#34;&gt;&lt;img src=&#34;https://img.shields.io/nexus/s/https/oss.sonatype.org/io.github.kitlangton/quotidian_3.svg?sanitize=true&#34; alt=&#34;Snapshot Artifacts&#34; title=&#34;Sonatype Snapshots&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A menagerie of macro utilities and extensions for Scala 3.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&#34;io.github.kitlangton&#34; %% &#34;quotidian&#34; % &#34;0.0.3&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Currently, this library supports &lt;code&gt;FromExpr&lt;/code&gt; and &lt;code&gt;ToExpr&lt;/code&gt; derivation. It also contains an opinionated set of extensions and extractors for working with &lt;code&gt;scala.quoted&lt;/code&gt;; these are brought into scope with &lt;code&gt;import quotidian.syntax.*&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add &lt;code&gt;FromExpr&lt;/code&gt; derivation&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Add &lt;code&gt;ToExpr&lt;/code&gt; derivation&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support Parameterized Types&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Add support for leaving out default values&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Derive &lt;code&gt;FromExpr&lt;/code&gt; Instances&lt;/h2&gt; &#xA;&lt;p&gt;Writing &lt;code&gt;FromExpr&lt;/code&gt; instances is a boilerplate-heavy task. Wouldn&#39;t it be better if it were &lt;em&gt;derivable&lt;/em&gt;?&lt;/p&gt; &#xA;&lt;h3&gt;Before&lt;/h3&gt; &#xA;&lt;p&gt;How boring! How trite! üò≠&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import quotidian.*&#xA;import scala.quoted.*&#xA;&#xA;final case class Person(name: String, age: Int, pet: Pet)&#xA;&#xA;object Person:&#xA;  given FromExpr[Person] with&#xA;    def unapply(expr: Expr[Person])(using Quotes): Option[Person] =&#xA;      import quotes.reflect.*&#xA;      expr match&#xA;        case &#39;{ Person(${ Expr(name) }, ${ Expr(age) }, ${ Expr(pet) }) } =&amp;gt;&#xA;          Some(Person(name, age, pet))&#xA;        case _ =&amp;gt; None&#xA;&#xA;  given ToExpr[Person] with&#xA;    def apply(person: Person)(using Quotes): Expr[Person] =&#xA;      import quotes.reflect.*&#xA;      &#39;{ Person(${ Expr(person.name) }, ${ Expr(person.age) }, ${ Expr(person.pet) }) }&#xA;&#xA;final case class Pet(name: String, hasBone: Boolean, favoritePerson: Option[Person])&#xA;&#xA;object Pet:&#xA;  given FromExpr[Pet] with&#xA;    def unapply(expr: Expr[Pet])(using Quotes): Option[Pet] =&#xA;      import quotes.reflect.*&#xA;      expr match&#xA;        case &#39;{ Pet(${ Expr(name) }, ${ Expr(hasBone) }, ${ Expr(favoritePerson) }) } =&amp;gt;&#xA;          Some(Pet(name, hasBone, favoritePerson))&#xA;        case _ =&amp;gt; None&#xA;&#xA;  given ToExpr[Pet] with&#xA;    def apply(pet: Pet)(using Quotes): Expr[Pet] =&#xA;      import quotes.reflect.*&#xA;      &#39;{ Pet(${ Expr(pet.name) }, ${ Expr(pet.hasBone) }, ${ Expr(pet.favoritePerson) }) }&#xA;&#xA;&#xA;enum Fruit:&#xA;  case Apple(variety: String)&#xA;  case Orange(juiciness: Int)&#xA;  case Banana(isYellow: Boolean)&#xA;&#xA;object Fruit:&#xA;  given FromExpr[Fruit] with&#xA;    def unapply(expr: Expr[Fruit])(using Quotes): Option[Fruit] =&#xA;      import quotes.reflect.*&#xA;      expr match&#xA;        case &#39;{ Fruit.Apple(${ Expr(variety) }) }    =&amp;gt; Some(Fruit.Apple(variety))&#xA;        case &#39;{ Fruit.Orange(${ Expr(juiciness) }) } =&amp;gt; Some(Fruit.Orange(juiciness))&#xA;        case &#39;{ Fruit.Banana(${ Expr(isYellow) }) }  =&amp;gt; Some(Fruit.Banana(isYellow))&#xA;        case _ =&amp;gt; None&#xA;&#xA;  given ToExpr[Fruit] with&#xA;    def apply(fruit: Fruit)(using Quotes): Expr[Fruit] =&#xA;      import quotes.reflect.*&#xA;      fruit match&#xA;        case Fruit.Apple(variety)    =&amp;gt; &#39;{ Fruit.Apple(${ Expr(variety) }) }&#xA;        case Fruit.Orange(juiciness) =&amp;gt; &#39;{ Fruit.Orange(${ Expr(juiciness) }) }&#xA;        case Fruit.Banana(isYellow)  =&amp;gt; &#39;{ Fruit.Banana(${ Expr(isYellow) }) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;After&lt;/h3&gt; &#xA;&lt;p&gt;Much better! Much more concise! üòç&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import quotidian.*&#xA;import scala.quoted.*&#xA;&#xA;case class Person(name: String, age: Int, pet: Pet) derives FromExpr, ToExpr&#xA;case class Pet(name: String, hasBone: Boolean, favoritePerson: Option[Person]) derives FromExpr, ToExpr&#xA;&#xA;enum Fruit derives FromExpr, ToExpr:&#xA;  case Apple(variety: String)&#xA;  case Orange(juiciness: Int)&#xA;  case Banana(isYellow: Boolean)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>