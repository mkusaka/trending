<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-28T01:40:11Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>OpenRigil/openrigil-rtl</title>
    <updated>2022-08-28T01:40:11Z</updated>
    <id>tag:github.com,2022-08-28:/OpenRigil/openrigil-rtl</id>
    <link href="https://github.com/OpenRigil/openrigil-rtl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open-source RISC-V cryptographic hardware token, RTL repo&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;openrigil-rtl&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;OpenRigil is an open-source RISC-V cryptographic hardware token. It could be used with your OpenPGP/PIV/FIDO2 applications.&lt;/p&gt; &#xA;&lt;p&gt;This the mono-repo for OpenRigil RTL for FPGA prototype, it will include:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Rocket-based CPU&lt;/li&gt; &#xA; &lt;li&gt;RISC-V Crypto Extension&lt;/li&gt; &#xA; &lt;li&gt;Montgomery Accelerator for RSA4096/Ed25519&lt;/li&gt; &#xA; &lt;li&gt;USB 1.1 FS device&lt;/li&gt; &#xA; &lt;li&gt;SoC designs&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Build the emulator&lt;/h2&gt; &#xA;&lt;p&gt;First you should follow the &lt;code&gt;Quick Start&lt;/code&gt; section in playground, or more specifically, only these two steps are necessary.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make init # init submodules, only a few of them are necessary though.&#xA;make patch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you should build the firmware in &lt;a href=&#34;https://github.com/OpenRigil/openrigil-firmware&#34;&gt;openrigil-firmware&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now you should change the &lt;code&gt;/path/to/openrigil.hex&lt;/code&gt; in &lt;code&gt;sanitytests/rocketchip/resources/vsrc/usbbootrom.rom.v&lt;/code&gt; to your built &lt;code&gt;openrigil.hex&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;After setting up environments/tools like mill/dtc/clang (see Arch/Nix guide below), you can run the following command to build the emulator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you could find the emulator in &lt;code&gt;out/VerilatorTest/build/emulator&lt;/code&gt;. You could emulate for a while to see if the firmware was loaded or not.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./out/VerilatorTest/build/emulator +verbose /dev/null&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;FPGA&lt;/h2&gt; &#xA;&lt;p&gt;Now you can find the generated verilog in &lt;code&gt;out/VerilatorTest/&lt;/code&gt; and you can import them to your EDA. Also Remember to import the &lt;code&gt;usbbootrom.rom.v&lt;/code&gt; and corresponding &lt;code&gt;openrigil.hex&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For Vivado, we have some reference design files in &lt;code&gt;vivado/&lt;/code&gt;. Note that you should generate a 60MHz clock in block design and connect that to the clk pin of &lt;code&gt;truetop&lt;/code&gt;. You can change it to other frequencies in &lt;code&gt;sanitytests/rocketchip/src/OpenRigil.scala&lt;/code&gt; but it must be multiples of 12MHz and at least 48MHz is recommended (otherwise USB may not function well, we have not tested it yet.)&lt;/p&gt; &#xA;&lt;p&gt;The constraint file is for Arty A7-100T. You may also use it for Arty A7-35T. Note that USB traffic are carried through GPIO pins with pullup. You should also prepare a dupont to USB Type-A board.&lt;/p&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;There is still a long way to go to build a fully secure cryptographic hardware token. Now this could only be used for testing and playing. Do not use it in production!&lt;/p&gt; &#xA;&lt;h2&gt;Project Management&lt;/h2&gt; &#xA;&lt;p&gt;It will depend on &lt;a href=&#34;https://github.com/sequencer/playground&#34;&gt;https://github.com/sequencer/playground&lt;/a&gt; for keep updating with upstream dependency. When playground updates, this project should be totally rebased to that. After development, it will be rebase out from playground as a standalone project.&lt;br&gt; &lt;code&gt;RocketCore&lt;/code&gt; will be forked out to &lt;code&gt;RigilCore&lt;/code&gt; in &lt;code&gt;rigil&lt;/code&gt; directory.&lt;br&gt; It will depend on &lt;code&gt;diplomacy&lt;/code&gt; SoC framework and TileLink interconnection protocol before TileLink landing to its own repository. Some other RTL(USB, DDR Controller) will be incubated inside this project as well, and finally being split to their own project to chipsalliance.&lt;br&gt; Physical Design is also included but won&#39;t be open sourced.&lt;/p&gt; &#xA;&lt;h1&gt;Below are playground template&lt;/h1&gt; &#xA;&lt;p&gt;DONT MODIFY! UNLESS YOU WANT TO HANDLE CONFLICT EVERYDAY!&lt;/p&gt; &#xA;&lt;h1&gt;playground&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;This is a template repository for those who want to develop RTL based on rocket-chip and even chipyard, being able to edit all sources from chisel environments without publish them to local ivy. You can add your own submodule in &lt;code&gt;build.sc&lt;/code&gt;.&lt;br&gt; For more information please visit &lt;a href=&#34;https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html&#34;&gt;Mill documentation&lt;/a&gt; after adding your own code, you can add your library to playground dependency, and re-index Intellij to add your own library.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;To use this repo as your Chisel development environment, simply follow the steps.&lt;/p&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Clone this repo;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@github.com:sequencer/playground.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Install dependencies and setup environments:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Arch Linux &lt;code&gt;pacman -Syu --noconfirm make parallel wget cmake ninja mill dtc verilator git llvm clang lld protobuf antlr4 numactl&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Nix &lt;code&gt;nix-shell&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;[Optional] Remove unused dependences to accelerate bsp compile in &lt;code&gt;build.sc&lt;/code&gt; &lt;code&gt;playground.moduleDeps&lt;/code&gt;;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd playground # entry your project directory&#xA;vim build.sc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// build.sc&#xA;&#xA;// Original&#xA;object playground extends CommonModule {&#xA;  override def moduleDeps = super.moduleDeps ++ Seq(myrocketchip, inclusivecache, blocks, rocketdsputils, shells, firesim, boom, chipyard, chipyard.fpga, chipyard.utilities, mychiseltest)&#xA;  ...&#xA;}&#xA;&#xA;// Remove unused dependences, e.g.,&#xA;object playground extends CommonModule {&#xA;  override def moduleDeps = super.moduleDeps ++ Seq(mychiseltest)&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Init and update dependences;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd playground # entry your project directory&#xA;make init     # init the submodules&#xA;make patch    # using the correct patches for some repos&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Generate IDE bsp;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make bsp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Open your IDE and wait bsp compile;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;idea . # open IDEA at current directory&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;Enjory your development with playground :)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;IDE support&lt;/h2&gt; &#xA;&lt;p&gt;For mill use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mill mill.bsp.BSP/install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then open by your favorite IDE, which supports &lt;a href=&#34;https://build-server-protocol.github.io/&#34;&gt;BSP&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Pending PRs&lt;/h2&gt; &#xA;&lt;p&gt;Philosophy of this repository is &lt;strong&gt;fast break and fast fix&lt;/strong&gt;. This repository always tracks remote developing branches, it may need some patches to work, &lt;code&gt;make patch&lt;/code&gt; will append below in sequence:&lt;/p&gt; &#xA;&lt;!-- BEGIN-PATCH --&gt; &#xA;&lt;p&gt;cva6-wrapper &lt;a href=&#34;https://github.com/ucb-bar/cva6-wrapper/pull/15&#34;&gt;https://github.com/ucb-bar/cva6-wrapper/pull/15&lt;/a&gt;&lt;br&gt; chipyard &lt;a href=&#34;https://github.com/ucb-bar/chipyard/pull/1160&#34;&gt;https://github.com/ucb-bar/chipyard/pull/1160&lt;/a&gt;&lt;br&gt; dsptools &lt;a href=&#34;https://github.com/ucb-bar/dsptools/pull/240&#34;&gt;https://github.com/ucb-bar/dsptools/pull/240&lt;/a&gt;&lt;br&gt; riscv-sodor &lt;a href=&#34;https://github.com/ucb-bar/riscv-sodor/pull/72&#34;&gt;https://github.com/ucb-bar/riscv-sodor/pull/72&lt;/a&gt;&lt;br&gt; riscv-boom &lt;a href=&#34;https://github.com/riscv-boom/riscv-boom/pull/600&#34;&gt;https://github.com/riscv-boom/riscv-boom/pull/600&lt;/a&gt;&lt;br&gt; riscv-boom &lt;a href=&#34;https://github.com/riscv-boom/riscv-boom/pull/601&#34;&gt;https://github.com/riscv-boom/riscv-boom/pull/601&lt;/a&gt;&lt;br&gt; rocket-chip &lt;a href=&#34;https://github.com/chipsalliance/rocket-chip/pull/2968&#34;&gt;https://github.com/chipsalliance/rocket-chip/pull/2968&lt;/a&gt;&lt;br&gt; rocket-chip-blocks &lt;a href=&#34;https://github.com/chipsalliance/rocket-chip-blocks/pull/1&#34;&gt;https://github.com/chipsalliance/rocket-chip-blocks/pull/1&lt;/a&gt;&lt;br&gt; rocket-chip-blocks &lt;a href=&#34;https://github.com/chipsalliance/rocket-chip-blocks/pull/2&#34;&gt;https://github.com/chipsalliance/rocket-chip-blocks/pull/2&lt;/a&gt;&lt;br&gt; rocket-chip-blocks &lt;a href=&#34;https://github.com/chipsalliance/rocket-chip-blocks/pull/3&#34;&gt;https://github.com/chipsalliance/rocket-chip-blocks/pull/3&lt;/a&gt;&lt;br&gt; rocket-chip-fpga-shells &lt;a href=&#34;https://github.com/chipsalliance/rocket-chip-fpga-shells/pull/1&#34;&gt;https://github.com/chipsalliance/rocket-chip-fpga-shells/pull/1&lt;/a&gt;&lt;br&gt; rocket-chip-fpga-shells &lt;a href=&#34;https://github.com/chipsalliance/rocket-chip-fpga-shells/pull/2&#34;&gt;https://github.com/chipsalliance/rocket-chip-fpga-shells/pull/2&lt;/a&gt;&lt;br&gt; rocket-chip-fpga-shells &lt;a href=&#34;https://github.com/chipsalliance/rocket-chip-fpga-shells/pull/3&#34;&gt;https://github.com/chipsalliance/rocket-chip-fpga-shells/pull/3&lt;/a&gt;&lt;br&gt; rocket-chip-inclusive-cache &lt;a href=&#34;https://github.com/chipsalliance/rocket-chip-inclusive-cache/pull/2&#34;&gt;https://github.com/chipsalliance/rocket-chip-inclusive-cache/pull/2&lt;/a&gt;&lt;br&gt; rocket-dsp-utils &lt;a href=&#34;https://github.com/ucb-bar/rocket-dsp-utils/pull/6&#34;&gt;https://github.com/ucb-bar/rocket-dsp-utils/pull/6&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- END-PATCH --&gt; &#xA;&lt;h2&gt;Why not Chipyard&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Building Chisel and FIRRTL from sources, get rid of any version issue. You can view Chisel/FIRRTL source codes from IDEA.&lt;/li&gt; &#xA; &lt;li&gt;No more make+sbt: Scala dependencies are managed by mill -&amp;gt; bsp -&amp;gt; IDEA, minimal IDEA indexing time.&lt;/li&gt; &#xA; &lt;li&gt;flatten git submodule in dependency, get rid of submodule recursive update.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;So generally, this repo is the fast and cleanest way to start your Chisel project codebase.&lt;/p&gt; &#xA;&lt;h2&gt;Always keep update-to-date&lt;/h2&gt; &#xA;&lt;p&gt;You can use this template and start your own job by appending commits on it. GitHub Action will automatically bump all dependencies, you can merge or rebase &lt;code&gt;sequencer/master&lt;/code&gt; to your branch.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd playground # entry your project directory&#xA;git rebase origin/master&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;System Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;Currently, only support &lt;strong&gt;Arch Linux&lt;/strong&gt;, if you are using other distros please install nix.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GNU Make &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: make&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;git &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: git&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;mill &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: mill&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;wget &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: wget&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;GNU Parallel &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: parallel&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Device Tree Compiler &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: dtc&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;protobuf &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: protobuf&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;antlr4 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: antlr4&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;SanityTests&lt;/h2&gt; &#xA;&lt;p&gt;This package is the standalone tests to check is bumping correct or not, served as the unittest, this also can be a great example to illustrate usages.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTICE: SanityTests also contains additional system dependencies:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;clang: bootrom cross compiling and veriltor C++ -&amp;gt; binary compiling &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: clang&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;llvm: gnu toolchain replacement &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: llvm&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;lld: LLVM based linker &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: lld&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;verilator -&amp;gt; Verilog -&amp;gt; C++ generation &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: verilator numactl&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;cmake -&amp;gt; verilator emulator build system &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: cmake&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;ninja -&amp;gt; verilator emulator build system &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Arch Linux: ninja&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;rocketchip&lt;/h3&gt; &#xA;&lt;p&gt;This package is a replacement to RocketChip Makefile based generator, it directly generate a simple RocketChip emulator with verilator and linked to spike.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mill sanitytests.rocketchip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;vcu118&lt;/h3&gt; &#xA;&lt;p&gt;This package uses rocketchip and fpga-shells to elaborate FPGA bitstream generator and debug script with board &lt;a href=&#34;https://www.xilinx.com/products/boards-and-kits/vcu118.html&#34;&gt;VCU118&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mill sanitytests.vcu118&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you wanna alter this to your own board, you can choose implmenting your own Shell to replace &lt;code&gt;VCU118Shell&lt;/code&gt; in this test.&lt;/p&gt;</summary>
  </entry>
</feed>