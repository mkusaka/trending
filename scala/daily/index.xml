<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-25T01:47:11Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>softwaremill/macwire</title>
    <updated>2023-06-25T01:47:11Z</updated>
    <id>tag:github.com,2023-06-25:/softwaremill/macwire</id>
    <link href="https://github.com/softwaremill/macwire" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lightweight and Nonintrusive Scala Dependency Injection Library&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/softwaremill/macwire/raw/master/banner.png&#34; alt=&#34;MacWire&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#table-of-contents&#34;&gt;Table of Contents&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#macwire&#34;&gt;MacWire&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#how-wiring-works&#34;&gt;How wiring works&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#factories&#34;&gt;Factories&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#factory-methods&#34;&gt;Factory methods&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#lazy-val-vs-val&#34;&gt;&lt;code&gt;lazy val&lt;/code&gt; vs. &lt;code&gt;val&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#recursive-wiring&#34;&gt;Recursive wiring&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#autowire&#34;&gt;Autowire&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#composing-modules&#34;&gt;Composing modules&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#scopes&#34;&gt;Scopes&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#accessing-wired-instances-dynamically&#34;&gt;Accessing wired instances dynamically&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#interceptors&#34;&gt;Interceptors&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#qualifiers&#34;&gt;Qualifiers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#multi-wiring-wireset&#34;&gt;Multi Wiring (wireSet)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#akka-integration&#34;&gt;Akka integration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#installation-using-with-sbt&#34;&gt;Installation, using with SBT&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#debugging&#34;&gt;Debugging&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#scalajs&#34;&gt;Scala.js&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#future-development---vote&#34;&gt;Future development - vote!&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#migrating-from-1x-a-id%22migrating%22a&#34;&gt;Migrating from 1.x &lt;/a&gt;&lt;a id=&#34;migrating&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#play-24x-a-id%22play24x%22a&#34;&gt;Play 2.4.x &lt;/a&gt;&lt;a id=&#34;play24x&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#play-25x-a-id%22play25x%22a&#34;&gt;Play 2.5.x &lt;/a&gt;&lt;a id=&#34;play25x&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#scala3-support&#34;&gt;Scala3 support&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;MacWire&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://softwaremill.community/c/macwire&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Discourse-ask%20question-blue&#34; alt=&#34;Ideas, suggestions, problems, questions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/com.softwaremill.macwire/macros_2.13&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/com.softwaremill.macwire/macros_2.13/badge.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;MacWire generates &lt;code&gt;new&lt;/code&gt; instance creation code of given classes, using values in the enclosing type for constructor parameters, with the help of Scala Macros.&lt;/p&gt; &#xA;&lt;p&gt;For a general introduction to DI in Scala, take a look at the &lt;a href=&#34;http://di-in-scala.github.io/&#34;&gt;Guide to DI in Scala&lt;/a&gt;, which also features MacWire.&lt;/p&gt; &#xA;&lt;p&gt;MacWire helps to implement the Dependency Injection (DI) pattern, by removing the need to write the class-wiring code by hand. Instead, it is enough to declare which classes should be wired, and how the instances should be accessed (see Scopes).&lt;/p&gt; &#xA;&lt;p&gt;Classes to be wired should be organized in &#34;modules&#34;, which can be Scala &lt;code&gt;trait&lt;/code&gt;s, &lt;code&gt;class&lt;/code&gt;es or &lt;code&gt;object&lt;/code&gt;s. Multiple modules can be combined using inheritance or composition; values from the inherited/nested modules are also used for wiring.&lt;/p&gt; &#xA;&lt;p&gt;MacWire can be in many cases a replacement for DI containers, offering greater control on when and how classes are instantiated, typesafety and using only language (Scala) mechanisms.&lt;/p&gt; &#xA;&lt;p&gt;Example usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class DatabaseAccess()&#xA;class SecurityFilter()&#xA;class UserFinder(databaseAccess: DatabaseAccess, securityFilter: SecurityFilter)&#xA;class UserStatusReader(userFinder: UserFinder)&#xA;&#xA;trait UserModule {&#xA;    import com.softwaremill.macwire._&#xA;&#xA;    lazy val theDatabaseAccess   = wire[DatabaseAccess]&#xA;    lazy val theSecurityFilter   = wire[SecurityFilter]&#xA;    lazy val theUserFinder       = wire[UserFinder]&#xA;    lazy val theUserStatusReader = wire[UserStatusReader]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will generate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait UserModule {&#xA;    lazy val theDatabaseAccess   = new DatabaseAccess()&#xA;    lazy val theSecurityFilter   = new SecurityFilter()&#xA;    lazy val theUserFinder       = new UserFinder(theDatabaseAccess, theSecurityFilter)&#xA;    lazy val theUserStatusReader = new UserStatusReader(theUserFinder)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For testing, just extend the base module and override any dependencies with mocks/stubs etc, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait UserModuleForTests extends UserModule {&#xA;    override lazy val theDatabaseAccess = mockDatabaseAccess&#xA;    override lazy val theSecurityFilter = mockSecurityFilter&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The core library has no dependencies.&lt;/p&gt; &#xA;&lt;p&gt;For more motivation behind the project see also these blogs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.warski.org/blog/2013/03/dependency-injection-with-scala-macros-auto-wiring/&#34;&gt;Dependency injection with Scala macros: auto-wiring&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.warski.org/blog/2013/04/macwire-0-1-framework-less-dependency-injection-with-scala-macros/&#34;&gt;MacWire 0.1: Framework-less Dependency Injection with Scala Macros&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.warski.org/blog/2013/04/macwire-0-2-scopes-are-simple/&#34;&gt;MacWire 0.2: Scopes are simple!&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.warski.org/blog/2013/06/implementing-factories-in-scala-macwire-0-3/&#34;&gt;Implementing factories in Scala &amp;amp; MacWire 0.3&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.warski.org/blog/2013/08/dependency-injection-in-play-with-macwire/&#34;&gt;Dependency Injection in Play! with MacWire&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.warski.org/blog/2013/10/macwire-0-5-interceptors/&#34;&gt;MacWire 0.5: Interceptors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.warski.org/blog/2014/02/using-scala-traits-as-modules-or-the-thin-cake-pattern/&#34;&gt;Using Scala traits as modules, or the &#34;Thin Cake&#34; Pattern&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How wiring works&lt;/h2&gt; &#xA;&lt;p&gt;For each constructor parameter of the given class, MacWire tries to find a value &lt;a href=&#34;http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#conformance&#34;&gt;conforming&lt;/a&gt; to the parameter&#39;s type in the enclosing method and trait/class/object:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;first it tries to find a unique value declared as a value in the current block, argument of enclosing methods and anonymous functions.&lt;/li&gt; &#xA; &lt;li&gt;then it tries to find a unique value declared or imported in the enclosing type&lt;/li&gt; &#xA; &lt;li&gt;then it tries to find a unique value in parent types (traits/classes)&lt;/li&gt; &#xA; &lt;li&gt;if the parameter is marked as implicit, it is ignored by MacWire and handled by the normal implicit resolution mechanism&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here value means either a &lt;code&gt;val&lt;/code&gt; or a no-parameter &lt;code&gt;def&lt;/code&gt;, as long as the return type matches.&lt;/p&gt; &#xA;&lt;p&gt;A compile-time error occurs if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;there are multiple values of a given type declared in the enclosing block/method/function&#39;s arguments list, enclosing type or its parents.&lt;/li&gt; &#xA; &lt;li&gt;parameter is marked as implicit and implicit lookup fails to find a value&lt;/li&gt; &#xA; &lt;li&gt;there is no value of a given type&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The generated code is then once again type-checked by the Scala compiler.&lt;/p&gt; &#xA;&lt;h2&gt;Factories&lt;/h2&gt; &#xA;&lt;p&gt;A factory is simply a method. The constructor of the wired class can contain parameters both from the factory (method) parameters, and from the enclosing/super type(s).&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class DatabaseAccess()&#xA;class TaxDeductionLibrary(databaseAccess: DatabaseAccess)&#xA;class TaxCalculator(taxBase: Double, taxDeductionLibrary: TaxDeductionLibrary)&#xA;&#xA;trait TaxModule {&#xA;    import com.softwaremill.macwire._&#xA;&#xA;    lazy val theDatabaseAccess      = wire[DatabaseAccess]&#xA;    lazy val theTaxDeductionLibrary = wire[TaxDeductionLibrary]&#xA;    def taxCalculator(taxBase: Double) = wire[TaxCalculator]&#xA;    // or: lazy val taxCalculator = (taxBase: Double) =&amp;gt; wire[TaxCalculator]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will generate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait TaxModule {&#xA;    lazy val theDatabaseAccess      = new DatabaseAccess()&#xA;    lazy val theTaxDeductionLibrary = new TaxDeductionLibrary(theDatabaseAccess)&#xA;    def taxCalculator(taxBase: Double) =&#xA;       new TaxCalculator(taxBase, theTaxDeductionLibrary)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Factory methods&lt;/h2&gt; &#xA;&lt;p&gt;You can also wire an object using a factory method, instead of a constructor. For that, use &lt;code&gt;wireWith&lt;/code&gt; instead of &lt;code&gt;wire&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class A()&#xA;&#xA;class C(a: A, specialValue: Int)&#xA;object C {&#xA;  def create(a: A) = new C(a, 42)&#xA;}&#xA;&#xA;trait MyModule {&#xA;  lazy val a = wire[A]&#xA;  lazy val c = wireWith(C.create _)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;lazy val&lt;/code&gt; vs. &lt;code&gt;val&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;It is safer to use &lt;code&gt;lazy val&lt;/code&gt;s, as when using &lt;code&gt;val&lt;/code&gt;, if a value is forward-referenced, it&#39;s value during initialization will be &lt;code&gt;null&lt;/code&gt;. With &lt;code&gt;lazy val&lt;/code&gt; the correct order of initialization is resolved by Scala.&lt;/p&gt; &#xA;&lt;h2&gt;Recursive wiring&lt;/h2&gt; &#xA;&lt;p&gt;When using &lt;code&gt;wire&lt;/code&gt; and a value for a parameter can&#39;t be found, an error is reported. &lt;code&gt;wireRec&lt;/code&gt; takes a different approach - it tries to recursively create an instance, using normal wiring rules. This allows to explicitly wire only those objects, which are referenced from the code, skipping helper or internal ones.&lt;/p&gt; &#xA;&lt;p&gt;The previous example becomes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class DatabaseAccess()&#xA;class SecurityFilter()&#xA;class UserFinder(databaseAccess: DatabaseAccess, securityFilter: SecurityFilter)&#xA;class UserStatusReader(userFinder: UserFinder)&#xA;&#xA;trait UserModule {&#xA;    import com.softwaremill.macwire._&#xA;&#xA;    lazy val theUserStatusReader = wireRec[UserStatusReader]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and will generate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait UserModule {&#xA;    lazy val theUserStatusReader = new UserStatusReader(&#xA;&#x9;&#x9;new UserFinder(new DatabaseAccess(), new SecurityFilter()))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This feature is inspired by @yakivy&#39;s work on &lt;a href=&#34;https://github.com/yakivy/jam&#34;&gt;jam&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Autowire&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;autowire&lt;/code&gt; is an experimental feature, if you have any feedback regarding its usage, let us know! Future releases might break source/binary compatibility. It is available for Scala 2 only for now.&lt;/p&gt; &#xA;&lt;p&gt;Dependency: &lt;code&gt;&#34;com.softwaremill.macwire&#34; %% &#34;macrosautocats&#34; % &#34;2.5.8&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;In case you need to build an instance from some particular instances and factory methods you can leverage &lt;code&gt;autowire&lt;/code&gt;. This feature is intended to integrate with effect-management libraries (currently we support &lt;a href=&#34;https://github.com/typelevel/cats-effect&#34;&gt;cats-effect&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;autowire&lt;/code&gt; takes as an argument a list of arguments which may contain:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;values (e.g. &lt;code&gt;new A()&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;factory methods (e.g. &lt;code&gt;C.create _&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;factory methods that return &lt;code&gt;cats.effect.Resource&lt;/code&gt; or &lt;code&gt;cats.effect.IO&lt;/code&gt; (e.g. &lt;code&gt;C.createIO _&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cats.effect.Resource&lt;/code&gt; (e.g. &lt;code&gt;cats.effect.Resource[IO].pure(new A())&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cats.effect.IO&lt;/code&gt; (e.g. &lt;code&gt;cats.effect.IO.pure(new A())&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Using the dependencies from the given arguments it creates an instance of the given type. Any missing instances are created using their primary constructor, provided that the dependencies are met. If this is not possible, a compile-time error is reported. In other words, a &lt;code&gt;wireRec&lt;/code&gt; is performed, bypassing the instances search phase.&lt;/p&gt; &#xA;&lt;p&gt;The result of the wiring is always wrapped in &lt;code&gt;cats.effect.Resource&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import cats.effect._&#xA;&#xA;class DatabaseAccess()&#xA;&#xA;class SecurityFilter private (databaseAccess: DatabaseAccess)&#xA;object SecurityFilter {&#xA;  def apply(databaseAccess: DatabaseAccess): SecurityFilter = new SecurityFilter(databaseAccess)&#xA;}&#xA;&#xA;class UserFinder(databaseAccess: DatabaseAccess, securityFilter: SecurityFilter)&#xA;class UserStatusReader(databaseAccess: DatabaseAccess, userFinder: UserFinder)&#xA;&#xA;object UserModule {&#xA;  import com.softwaremill.macwire.autocats._&#xA;&#xA;  val theDatabaseAccess: Resource[IO, DatabaseAccess] = Resource.pure(new DatabaseAccess())&#xA;&#xA;  val theUserStatusReader: Resource[IO, UserStatusReader] = autowire[UserStatusReader](theDatabaseAccess)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will generate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;[...]&#xA;object UserModule {&#xA;  import com.softwaremill.macwire.autocats._&#xA;&#xA;  val theDatabaseAccess: Resource[IO, DatabaseAccess] = Resource.pure(new DatabaseAccess())&#xA;&#xA;  val theUserStatusReader: Resource[IO, UserStatusReader] = UserModule.this.theDatabaseAccess.flatMap(&#xA;    da =&amp;gt; Resource.pure[IO, UserStatusReader](new UserStatusReader(da, new UserFinder(da, SecurityFilter.apply(da))))&#xA;  )&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Composing modules&lt;/h2&gt; &#xA;&lt;p&gt;Modules (traits or classes containing parts of the object graph) can be combined using inheritance or composition. The inheritance case is straightforward, as &lt;code&gt;wire&lt;/code&gt; simply looks for values in parent traits/classes. With composition, you need to tell MacWire that it should look inside the nested modules.&lt;/p&gt; &#xA;&lt;p&gt;To do that, you can use imports:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class FacebookAccess(userFind: UserFinder)&#xA;&#xA;class UserModule {&#xA;  lazy val userFinder = ... // as before&#xA;}&#xA;&#xA;class SocialModule(userModule: UserModule) {&#xA;  import userModule._&#xA;&#xA;  lazy val facebookAccess = wire[FacebookAccess]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, if you are using that pattern a lot, you can annotate your modules using &lt;code&gt;@Module&lt;/code&gt;, and they will be used when searching for values automatically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class FacebookAccess(userFind: UserFinder)&#xA;&#xA;@Module&#xA;class UserModule { ... } // as before&#xA;&#xA;class SocialModule(userModule: UserModule) {&#xA;  lazy val facebookAccess = wire[FacebookAccess]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: the &lt;code&gt;@Module&lt;/code&gt; annotation is an experimental feature, if you have any feedback regarding its usage, let us know!&lt;/p&gt; &#xA;&lt;h2&gt;Scopes&lt;/h2&gt; &#xA;&lt;p&gt;There are two &#34;built-in&#34; scopes, depending on how the dependency is defined:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;singleton: &lt;code&gt;lazy val&lt;/code&gt; / &lt;code&gt;val&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;dependent - separate instance for each dependency usage: &lt;code&gt;def&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;MacWire also supports user-defined scopes, which can be used to implement request or session scopes in web applications. The &lt;code&gt;proxy&lt;/code&gt; subproject defines a &lt;code&gt;Scope&lt;/code&gt; trait, which has two methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;apply&lt;/code&gt;, to create a scoped value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;get&lt;/code&gt;, to get or create the current value from the scope&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To define a dependency as scoped, we need a scope instance, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait WebModule {&#xA;   lazy val loggedInUser = session(new LoggedInUser)&#xA;&#xA;   def session: Scope&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With abstract scopes as above, it is possible to use no-op scopes for testing (&lt;code&gt;NoOpScope&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s an implementation of &lt;code&gt;Scope&lt;/code&gt; targeted at classical synchronous frameworks, &lt;code&gt;ThreadLocalScope&lt;/code&gt;. The apply method of this scope creates a proxy (using &lt;a href=&#34;http://www.csg.is.titech.ac.jp/~chiba/javassist/&#34;&gt;javassist&lt;/a&gt;); the get method stores the value in a thread local. The proxy should be defined as a &lt;code&gt;val&lt;/code&gt; or &lt;code&gt;lazy val&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In a web application, the scopes have to be associated and disassociated with storages. This can be done for example in a servlet filter. To implement a:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;request scope, we need a new empty storage for every request. The &lt;code&gt;associateWithEmptyStorage&lt;/code&gt; is useful here&lt;/li&gt; &#xA; &lt;li&gt;session scope, the storage (a &lt;code&gt;Map&lt;/code&gt;) should be stored in the &lt;code&gt;HttpSession&lt;/code&gt;. The &lt;code&gt;associate(Map)&lt;/code&gt; method is useful here&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example usage see the &lt;a href=&#34;https://github.com/adamw/macwire/tree/master/examples/scalatra/src/main/scala/com/softwaremill/macwire/examples/scalatra&#34;&gt;MacWire+Scalatra example&lt;/a&gt; sources.&lt;/p&gt; &#xA;&lt;p&gt;You can run the example with &lt;code&gt;sbt examples-scalatra/run&lt;/code&gt; and going to &lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that the &lt;code&gt;proxy&lt;/code&gt; subproject does not depend on MacWire core, and can be used stand-alone with manual wiring or any other frameworks.&lt;/p&gt; &#xA;&lt;h2&gt;Accessing wired instances dynamically&lt;/h2&gt; &#xA;&lt;p&gt;To integrate with some frameworks (e.g. &lt;a href=&#34;http://www.playframework.com/&#34;&gt;Play 2&lt;/a&gt;) or to create instances of classes which names are only known at run-time (e.g. plugins) it is necessary to access the wired instances dynamically. MacWire contains a utility class in the &lt;code&gt;util&lt;/code&gt; subproject, &lt;code&gt;Wired&lt;/code&gt;, to support such functionality.&lt;/p&gt; &#xA;&lt;p&gt;An instance of &lt;code&gt;Wired&lt;/code&gt; can be obtained using the &lt;code&gt;wiredInModule&lt;/code&gt; macro, given an instance of a module containing the wired object graph. Any &lt;code&gt;vals&lt;/code&gt;, &lt;code&gt;lazy val&lt;/code&gt;s and parameter-less &lt;code&gt;def&lt;/code&gt;s (factories) from the module which are references will be available in the &lt;code&gt;Wired&lt;/code&gt; instance.&lt;/p&gt; &#xA;&lt;p&gt;The object graph in the module can be hand-wired, wired using &lt;code&gt;wire&lt;/code&gt;, or a result of any computation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Wired&lt;/code&gt; has two basic functionalities: looking up an instance by its class (or trait it implements), and instantiating new objects using the available dependencies. You can also extend &lt;code&gt;Wired&lt;/code&gt; with new instances/instance factories.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// 1. Defining the object graph and the module&#xA;trait DatabaseConnector&#xA;class MysqlDatabaseConnector extends DatabaseConnector&#xA;&#xA;class MyApp {&#xA;    def securityFilter = new SecurityFilter()&#xA;    val databaseConnector = new MysqlDatabaseConnector()&#xA;}&#xA;&#xA;// 2. Creating a Wired instance&#xA;import com.softwaremill.macwire._&#xA;val wired = wiredInModule(new MyApp)&#xA;&#xA;// 3. Dynamic lookup of instances&#xA;wired.lookup(classOf[SecurityFilter])&#xA;&#xA;// Returns the mysql database connector, even though its type is MysqlDatabaseConnector, which is&#xA;// assignable to DatabaseConnector.&#xA;wired.lookup(classOf[DatabaseConnector])&#xA;&#xA;// 4. Instantiation using the available dependencies&#xA;{&#xA;    package com.softwaremill&#xA;    class AuthenticationPlugin(databaseConnector: DatabaseConnector)&#xA;}&#xA;&#xA;// Creates a new instance of the given class using the dependencies available in MyApp&#xA;wired.wireClassInstanceByName(&#34;com.softwaremill.AuthenticationPlugin&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Interceptors&lt;/h2&gt; &#xA;&lt;p&gt;MacWire contains an implementation of interceptors, which can be applied to class instances in the modules. Similarly to scopes, the &lt;code&gt;proxy&lt;/code&gt; subproject defines an &lt;code&gt;Interceptor&lt;/code&gt; trait, which has only one method: &lt;code&gt;apply&lt;/code&gt;. When applied to an instance, it should return an instance of the same class, but with the interceptor applied.&lt;/p&gt; &#xA;&lt;p&gt;There are two implementations of the &lt;code&gt;Interceptor&lt;/code&gt; trait provided:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;NoOpInterceptor&lt;/code&gt;: returns the given instance without changes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ProxyingInterceptor&lt;/code&gt;: proxies the instance, and returns the proxy. A provided function is called with information on the invocation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Interceptors can be abstract in modules. E.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait BusinessLogicModule {&#xA;   lazy val moneyTransferer = transactional(wire[MoneyTransferer])&#xA;&#xA;   def transactional: Interceptor&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;During tests, you can then use the &lt;code&gt;NoOpInterceptor&lt;/code&gt;. In production code or integration tests, you can specify a real interceptor, either by extending the &lt;code&gt;ProxyingInterceptor&lt;/code&gt; trait, or by passing a function to the &lt;code&gt;ProxyingInterceptor&lt;/code&gt; object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object MyApplication extends BusinessLogicModule {&#xA;    lazy val tm = wire[TransactionManager]&#xA;&#xA;    lazy val transactional = ProxyingInterceptor { ctx =&amp;gt;&#xA;        try {&#xA;            tm.begin()&#xA;            val result = ctx.proceed()&#xA;            tm.commit()&#xA;&#xA;            result&#xA;        } catch {&#xA;            case e: Exception =&amp;gt; tm.rollback()&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;ctx&lt;/code&gt; is an instance of an &lt;code&gt;InvocationContext&lt;/code&gt;, and contains information on the parameters passed to the method, the method itself, and the target object. It also allows to proceed with the invocation with the same or changed parameters.&lt;/p&gt; &#xA;&lt;p&gt;For more general AOP, e.g. if you want to apply an interceptor to all methods matching a given pointcut expression, you should use &lt;a href=&#34;http://eclipse.org/aspectj/&#34;&gt;AspectJ&lt;/a&gt; or an equivalent library. The interceptors that are implemented in MacWire correspond to annotation-based interceptors in Java.&lt;/p&gt; &#xA;&lt;h2&gt;Qualifiers&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you have multiple objects of the same type that you want to use during wiring. Macwire needs to have some way of telling the instances apart. As with other things, the answer is: types! Even when not using &lt;code&gt;wire&lt;/code&gt;, it may be useful to give the instances distinct types, to get compile-time checking.&lt;/p&gt; &#xA;&lt;p&gt;For that purpose Macwire includes support for tagging via &lt;a href=&#34;https://github.com/softwaremill/scala-common&#34;&gt;scala-common&lt;/a&gt;, which lets you attach tags to instances to qualify them. This is a compile-time only operation, and doesn&#39;t affect the runtime. The tags are derived from &lt;a href=&#34;https://gist.github.com/milessabin/89c9b47a91017973a35f&#34;&gt;Miles Sabin&#39;s gist&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To bring the tagging into scope, import &lt;code&gt;com.softwaremill.tagging._&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Using tagging has two sides. In the constructor, when declaring a dependency, you need to declare what tag it needs to have. You can do this with the &lt;code&gt;_ @@ _&lt;/code&gt; type constructor, or if you prefer another syntax &lt;code&gt;Tagged[_, _]&lt;/code&gt;. The first type parameter is the type of the dependency, the second is a tag.&lt;/p&gt; &#xA;&lt;p&gt;The tag can be any type, but usually it is just an empty marker trait.&lt;/p&gt; &#xA;&lt;p&gt;When defining the available instances, you need to specify which instance has which tag. This can be done with the &lt;code&gt;taggedWith[_]&lt;/code&gt; method, which returns a tagged instance (&lt;code&gt;A.taggedWith[T]: A @@ T&lt;/code&gt;). Tagged instances can be used as regular ones, without any constraints.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;wire&lt;/code&gt; macro does not contain any special support for tagging, everything is handled by subtyping. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Berry()&#xA;trait Black&#xA;trait Blue&#xA;&#xA;case class Basket(blueberry: Berry @@ Blue, blackberry: Berry @@ Black)&#xA;&#xA;lazy val blueberry = wire[Berry].taggedWith[Blue]&#xA;lazy val blackberry = wire[Berry].taggedWith[Black]&#xA;lazy val basket = wire[Basket]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Multiple tags can be combined using the &lt;code&gt;andTaggedWith&lt;/code&gt; method. E.g. if we had a berry that is both blue and black:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;lazy val blackblueberry = wire[Berry].taggedWith[Black].andTaggedWith[Blue]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting value has type &lt;code&gt;Berry @ (Black with Blue)&lt;/code&gt; and can be used both as a blackberry and as a blueberry.&lt;/p&gt; &#xA;&lt;h2&gt;Multi Wiring (wireSet)&lt;/h2&gt; &#xA;&lt;p&gt;Using &lt;code&gt;wireSet&lt;/code&gt; you can obtain a set of multiple instances of the same type. This is done without constructing the set explicitly. All instances of the same type which are found by MacWire are used to construct the set.&lt;/p&gt; &#xA;&lt;p&gt;Consider the below example. Let&#39;s suppose that you want to create a &lt;code&gt;RockBand(musicians: Set[Musician])&lt;/code&gt; object. It&#39;s easy to do so using the &lt;code&gt;wireSet&lt;/code&gt; functionality:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Musician&#xA;class RockBand(musicians: Set[Musician])&#xA;&#xA;trait RockBandModule {&#xA;  lazy val singer    = new Musician {}&#xA;  lazy val guitarist = new Musician {}&#xA;  lazy val drummer   = new Musician {}&#xA;  lazy val bassist   = new Musician {}&#xA;&#xA;  lazy val musicians = wireSet[Musician] // all above musicians will be wired together&#xA;                                         // musicians has type Set[Musician]&#xA;&#xA;  lazy val rockBand  = wire[RockBand]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;When:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;referencing wired values within the trait/class/object&lt;/li&gt; &#xA; &lt;li&gt;using multiple modules in the same compilation unit&lt;/li&gt; &#xA; &lt;li&gt;using multiple modules with scopes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;due to limitations of the current macros implementation in Scala (for more details see &lt;a href=&#34;https://groups.google.com/forum/?fromgroups=#!topic/scala-user/k_2KCvO5g04&#34;&gt;this discussion&lt;/a&gt;) to avoid compilation errors it is recommended to add type ascriptions to the dependencies. This is a way of helping the type-checker that is invoked by the macro to figure out the types of the values which can be wired.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class A()&#xA;class B(a: A)&#xA;&#xA;// note the explicit type. Without it wiring would fail with recursive type compile errors&#xA;lazy val theA: A = wire[A]&#xA;// reference to theA; if for some reason we need explicitly write the constructor call&#xA;lazy val theB = new B(theA)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is an inconvenience, but hopefully will get resolved once post-typer macros are introduced to the language.&lt;/p&gt; &#xA;&lt;p&gt;Also, wiring will probably not work properly for traits and classes defined inside the containing trait/class, or in super traits/classes.&lt;/p&gt; &#xA;&lt;p&gt;Note that the type ascription may be a subtype of the wired type. This can be useful if you want to expose e.g. a trait that the wired class extends, instead of the full implementation.&lt;/p&gt; &#xA;&lt;h2&gt;Akka integration&lt;/h2&gt; &#xA;&lt;p&gt;Macwire provides wiring suport for &lt;a href=&#34;http://akka.io&#34;&gt;akka&lt;/a&gt; through the &lt;code&gt;macrosAkka&lt;/code&gt; module. &lt;a href=&#34;https://github.com/adamw/macwire/raw/master/macrosAkkaTests/src/test/scala/com/softwaremill/macwire/akkasupport/demo/Demo.scala&#34;&gt;Here&lt;/a&gt; you can find example code. The module adds three macros &lt;code&gt;wireAnonymousActor[A]&lt;/code&gt;, &lt;code&gt;wireActor[A]&lt;/code&gt; and &lt;code&gt;wireProps[A]&lt;/code&gt; which help create instances of &lt;code&gt;akka.actor.ActorRef&lt;/code&gt; and &lt;code&gt;akka.actor.Props&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;These macros require an &lt;code&gt;ActoRefFactory&lt;/code&gt; (&lt;code&gt;ActorSystem&lt;/code&gt; or &lt;code&gt;Actor.context&lt;/code&gt;) to be in scope as a dependency. If actor&#39;s primary constructor has dependencies - they are required to be in scope as well.&lt;/p&gt; &#xA;&lt;p&gt;Example usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import akka.actor.{Actor, ActorRef, ActorSystem}&#xA;&#xA;class DatabaseAccess()&#xA;class SecurityFilter()&#xA;class UserFinderActor(databaseAccess: DatabaseAccess, securityFilter: SecurityFilter) extends Actor {&#xA;  override def receive: Receive = {&#xA;    case m =&amp;gt; // ...&#xA;  }&#xA;}&#xA;&#xA;import com.softwaremill.macwire._&#xA;import com.softwaremill.macwire.akkasupport._&#xA;&#xA;val theDatabaseAccess = wire[DatabaseAccess] //1st dependency for UserFinderActor&#xA;                                             //it compiles to: val theDatabaseAccess = new DatabaseAccess&#xA;&#xA;val theSecurityFilter = wire[SecurityFilter] //2nd dependency for UserFinderActor&#xA;                                             //it compiles to: val theSecurityFilter = new SecurityFilter&#xA;&#xA;val system = ActorSystem(&#34;actor-system&#34;) //there must be instance of ActoRefFactory in scope&#xA;&#xA;val theUserFinder = wireActor[UserFinderActor](&#34;userFinder&#34;)&#xA;//this compiles to:&#xA;//lazy val theUserFinder = system.actorOf(Props(classOf[UserFinderActor], theDatabaseAccess, theSecurityFilter), &#34;userFinder&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to make it working all dependencies created &lt;code&gt;Actor&lt;/code&gt;&#39;s (&lt;code&gt;UserFinderActor&lt;/code&gt;&#39;s) primary constructor and instance of the &lt;code&gt;akka.actor.ActorRefFactory&lt;/code&gt; must be in scope. In above example this is all true. Dependencies of the &lt;code&gt;UserFinderActor&lt;/code&gt; are &lt;code&gt;DatabaseAccess&lt;/code&gt; and &lt;code&gt;SecurityFilter&lt;/code&gt; and they are in scope. The &lt;code&gt;ActorRefFactory&lt;/code&gt; is in scope as well because &lt;code&gt;ActorSystem&lt;/code&gt; which is subtype of it is there.&lt;/p&gt; &#xA;&lt;p&gt;Creating actor within another actor is even simpler than in first example because we don&#39;t need to have &lt;code&gt;ActorSystem&lt;/code&gt; in scope. The &lt;code&gt;ActorRefFactory&lt;/code&gt; is here because &lt;code&gt;Actor.context&lt;/code&gt; is subtype of it. Let&#39;s see this in action:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class UserStatusReaderActor(theDatabaseAccess: DatabaseAccess) extends Actor {&#xA;  val theSecurityFilter = wire[SecurityFilter]&#xA;&#xA;  val userFinder = wireActor[UserFinderActor](&#34;userFinder&#34;)&#xA;  //this compiles to:&#xA;  //val userFinder = context.actorOf(Props(classOf[UserFinderActor], theDatabaseAccess, theSecurityFilter), &#34;userFinder&#34;)&#xA;&#xA;  override def receive = ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The difference is that previously macro expanded into &lt;code&gt;system.actorOf(...)&lt;/code&gt; and when inside another actor it expanded into &lt;code&gt;context.actorOf(...)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s possible to create anonymous actors. &lt;code&gt;wireAnonymousActor&lt;/code&gt; is for it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val userFinder = wireAnonymousActor[UserFinderActor]&#xA;//this compiles to:&#xA;//val userFinder = context.actorOf(Props(classOf[UserFinderActor], theDatabaseAccess, theSecurityFilter))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;How about creating &lt;code&gt;akka.actor.Props&lt;/code&gt;? It&#39;s there and can be achieved by calling &lt;code&gt;wireProps[A]&lt;/code&gt;. Wiring only &lt;code&gt;Props&lt;/code&gt; can be handy when it&#39;s required to setup the &lt;code&gt;Props&lt;/code&gt; before passing them to the &lt;code&gt;actorOf(...)&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s say we want to create some actor with router. It can be done as below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val userFinderProps = wireProps[UserFinderActor] //create Props&#xA;  //This compiles to: Props(classOf[UserFinderActor], theDatabaseAccess, theSecurityFilter)&#xA;  .withRouter(RoundRobinPool(4)) //change it according requirements&#xA;val userFinderActor = system.actorOf(userFinderProps, &#34;userFinder&#34;)  //create the actor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;How about creating actors which depends on &lt;code&gt;ActorRef&lt;/code&gt;s? The simplest way is to pass them as arguments to the constructor. But how to distinguish two &lt;code&gt;actorRef&lt;/code&gt;s representing two different actors? They have the same type though.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class DatabaseAccessActor extends Actor { ... }&#xA;class SecurityFilterActor extends Actor { ... }&#xA;val db: ActorRef = wireActor[DatabaseAccessActor](&#34;db&#34;)&#xA;val filter: ActorRef = wireActor[SecurityFilterActor](&#34;filter&#34;)&#xA;class UserFinderActor(databaseAccess: ActorRef, securityFilter: ActorRef) extends Actor {...}&#xA;//val userFinder = wireActor[UserFinderActor] wont work here&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can&#39;t just call &lt;code&gt;wireActor[UserFinderActor]&lt;/code&gt; because it&#39;s not obvious which instance of ActorRef is for &lt;code&gt;databaseAccess&lt;/code&gt; and which are for &lt;code&gt;securityFilter&lt;/code&gt;. They are both of the same type - &lt;code&gt;ActorRef&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The solution for it is to use earlier described &lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#qualifiers&#34;&gt;qualifiers&lt;/a&gt;. In above example solution for wiring may look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sealed trait DatabaseAccess //marker type&#xA;class DatabaseAccessActor extends Actor { ... }&#xA;sealed trait SecurityFilter //marker type&#xA;class SecurityFilterActor extends Actor { ... }&#xA;&#xA;val db: ActorRef @@ DatabaseAccess = wireActor[DatabaseAccessActor](&#34;db&#34;).taggedWith[DatabaseAccess]&#xA;val filter: ActorRef @@ SecurityFilter = wireActor[SecurityFilterActor](&#34;filter&#34;).taggedWith[SecurityFilter]&#xA;&#xA;class UserFinderActor(databaseAccess: ActorRef @@ DatabaseAccess, securityFilter: ActorRef @@ SecurityFilter) extends Actor {...}&#xA;&#xA;val userFinder = wireActor[UserFinderActor]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also possible to wire an actor using a factory function. For that, the module provides three additional macros &lt;code&gt;wireAnonymousActorWith&lt;/code&gt;, &lt;code&gt;wireActorWith&lt;/code&gt; and &lt;code&gt;wirePropsWith&lt;/code&gt;. Their usage is similar to &lt;code&gt;wireWith&lt;/code&gt; (see &lt;a href=&#34;https://raw.githubusercontent.com/softwaremill/macwire/master/#factory-methods&#34;&gt;Factory methods&lt;/a&gt;). For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class UserFinderActor(databaseAccess: DatabaseAccess, securityFilter: SecurityFilter) extends Actor { ... }&#xA;&#xA;object UserFinderActor {&#xA;  def get(databaseAccess: DatabaseAccess) = new UserFinderActor(databaseAccess, new SimpleSecurityFilter())&#xA;}&#xA;&#xA;val theUserFinder = wireActorWith(UserFinderActor.get _)(&#34;userFinder&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation, using with SBT&lt;/h2&gt; &#xA;&lt;p&gt;The jars are deployed to &lt;a href=&#34;https://oss.sonatype.org/content/repositories/snapshots/com/softwaremill/macwire/&#34;&gt;Sonatype&#39;s OSS repository&lt;/a&gt;. To use MacWire in your project, add a dependency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;com.softwaremill.macwire&#34; %% &#34;macros&#34; % &#34;2.5.8&#34; % &#34;provided&#34;&#xA;&#xA;libraryDependencies += &#34;com.softwaremill.macwire&#34; %% &#34;macrosakka&#34; % &#34;2.5.8&#34; % &#34;provided&#34;&#xA;&#xA;libraryDependencies += &#34;com.softwaremill.macwire&#34; %% &#34;util&#34; % &#34;2.5.8&#34;&#xA;&#xA;libraryDependencies += &#34;com.softwaremill.macwire&#34; %% &#34;proxy&#34; % &#34;2.5.8&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;MacWire is available for Scala 2.12, 2.13, 3 on the JVM and JS.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;macros&lt;/code&gt; subproject contains only code which is used at compile-time, hence the &lt;code&gt;provided&lt;/code&gt; scope.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;util&lt;/code&gt; subproject contains tagging, &lt;code&gt;Wired&lt;/code&gt; and the &lt;code&gt;@Module&lt;/code&gt; annotation; if you don&#39;t use these features, you don&#39;t need to include this dependency.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;proxy&lt;/code&gt; subproject contains interceptors and scopes, and has a dependency on &lt;code&gt;javassist&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Older 1.x release for Scala 2.10 and 2.11:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;com.softwaremill.macwire&#34; %% &#34;macros&#34; % &#34;1.0.7&#34;&#xA;&#xA;libraryDependencies += &#34;com.softwaremill.macwire&#34; %% &#34;runtime&#34; % &#34;1.0.7&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;To print debugging information on what MacWire does when looking for values, and what code is generated, set the &lt;code&gt;macwire.debug&lt;/code&gt; system property. E.g. with SBT, just add a &lt;code&gt;System.setProperty(&#34;macwire.debug&#34;, &#34;&#34;)&lt;/code&gt; line to your build file.&lt;/p&gt; &#xA;&lt;h2&gt;Scala.js&lt;/h2&gt; &#xA;&lt;p&gt;Macwire also works with &lt;a href=&#34;http://www.scala-js.org/&#34;&gt;Scala.js&lt;/a&gt;. For an example, see here: &lt;a href=&#34;https://github.com/adamw/macwire/tree/master/examples/scalajs&#34;&gt;Macwire+Scala.js example&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Future development - vote!&lt;/h2&gt; &#xA;&lt;p&gt;Take a look at the &lt;a href=&#34;https://github.com/adamw/macwire/issues&#34;&gt;available issues&lt;/a&gt;. If you&#39;d like to see one developed please vote on it. Or maybe you&#39;ll attempt to create a pull request?&lt;/p&gt; &#xA;&lt;h2&gt;Migrating from 1.x &lt;a id=&#34;migrating&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;changed how code is split across modules. You&#39;ll need to depend on &lt;code&gt;util&lt;/code&gt; to get tagging &amp;amp; &lt;code&gt;Wired&lt;/code&gt;, and &lt;code&gt;proxy&lt;/code&gt; to get interceptors and scopes&lt;/li&gt; &#xA; &lt;li&gt;tagging moved to a separate package. If you use tagging, you&#39;ll need to import &lt;code&gt;com.softwaremill.tagging._&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;removed &lt;code&gt;wireImplicit&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;implicit parameters aren&#39;t handled by &lt;code&gt;wire&lt;/code&gt; at all (they used to be subject to the same lookup procedure as normal parameters + implicit lookup)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Play 2.4.x &lt;a id=&#34;play24x&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;In Play 2.4.x, you can no longer use getControllerInstance in GlobalSettings for injection. Play has a new pattern for injecting controllers. You must extend ApplicationLoader, from there you can mix in your modules.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import controllers.{Application, Assets}&#xA;import play.api.ApplicationLoader.Context&#xA;import play.api._&#xA;import play.api.routing.Router&#xA;import router.Routes&#xA;import com.softwaremill.macwire._&#xA;&#xA;class AppApplicationLoader extends ApplicationLoader {&#xA;  def load(context: Context) = {&#xA;&#xA;    // make sure logging is configured&#xA;    Logger.configure(context.environment)&#xA;&#xA;    (new BuiltInComponentsFromContext(context) with AppComponents).application&#xA;  }&#xA;}&#xA;&#xA;trait AppComponents extends BuiltInComponents with AppModule {&#xA;  lazy val assets: Assets = wire[Assets]&#xA;  lazy val prefix: String = &#34;/&#34;&#xA;  lazy val router: Router = wire[Routes]&#xA;}&#xA;&#xA;trait AppModule {&#xA;  // Define your dependencies and controllers&#xA;  lazy val applicationController = wire[Application]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In application.conf, add the reference to the ApplicationLoader.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;play.application.loader = &#34;AppApplicationLoader&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information and to see the sample project, go to &lt;a href=&#34;https://github.com/adamw/macwire/tree/master/examples/play24&#34;&gt;examples/play24&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Reference Play docs for more information:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.playframework.com/documentation/2.4.x/ScalaCompileTimeDependencyInjection&#34;&gt;ScalaCompileTimeDependencyInjection&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Play 2.5.x &lt;a id=&#34;play25x&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;For Play 2.5.x, you must do the same as for Play 2.4.x, except the &lt;code&gt;Logger&lt;/code&gt; configuration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import play.api.LoggerConfigurator&#xA;class AppApplicationLoader extends ApplicationLoader {&#xA;  def load(context: Context) = {&#xA;&#xA;    LoggerConfigurator(context.environment.classLoader).foreach {&#xA;      _.configure(context.environment)&#xA;    }&#xA;    // ... do the same as for Play 2.4.x&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Scala3 support&lt;/h2&gt; &#xA;&lt;p&gt;The Scala 3 version is written to be compatible with Scala 2 where possible. Currently there are a few missing features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lampepfl/dotty/issues/13105&#34;&gt;wire from parent scope&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lampepfl/dotty/issues/12965&#34;&gt;wire from imports&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/softwaremill/macwire/issues/170&#34;&gt;wire in pattern matching&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/softwaremill/macwire/issues/171&#34;&gt;&lt;code&gt;wiredInModule&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/softwaremill/macwire/issues/172&#34;&gt;&lt;code&gt;@Module&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For full list of incompatibilities take a look at &lt;code&gt;tests/src/test/resources/test-cases&lt;/code&gt; and &lt;code&gt;util-tests/src/test/resources/test-cases&lt;/code&gt; .&lt;/p&gt; &#xA;&lt;h2&gt;Commercial Support&lt;/h2&gt; &#xA;&lt;p&gt;We offer commercial support for MacWire and related technologies, as well as development services. &lt;a href=&#34;https://softwaremill.com&#34;&gt;Contact us&lt;/a&gt; to learn more about our offer!&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (C) 2013-2021 SoftwareMill &lt;a href=&#34;https://softwaremill.com&#34;&gt;https://softwaremill.com&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>