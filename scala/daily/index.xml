<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-26T01:36:05Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>comsec-group/cascade-artifacts</title>
    <updated>2023-10-26T01:36:05Z</updated>
    <id>tag:github.com,2023-10-26:/comsec-group/cascade-artifacts</id>
    <link href="https://github.com/comsec-group/cascade-artifacts" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Artifacts for Cascade: CPU Fuzzing via Intricate Program Generation (USENIX Security 2024)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Artifacts Evaluation - README - Usenix Security 2024&lt;/h1&gt; &#xA;&lt;h2&gt;For Paper: Cascade: CPU Fuzzing via Intricate Program Generation&lt;/h2&gt; &#xA;&lt;h3&gt;Overview&lt;/h3&gt; &#xA;&lt;p&gt;Welcome to the artifacts for Cascade! This repository will help you reproduce the results presented in our paper, and will get you started with Cascade without worrying too much about setting up the context. For more information about Cascade, visit &lt;a href=&#34;https://comsec.ethz.ch/cascade&#34;&gt;https://comsec.ethz.ch/cascade&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The repository is structured as follows. First, we indicate a few requirements. Second, we provide a step-by-step guide to reproduce the results in our paper.&lt;/p&gt; &#xA;&lt;p&gt;We recommend using the provided Docker image to reproduce the results. All experiments, except the Questasim experiment, run inside a Docker container. The Questasim experiment is optional as its only purpose is to compare the simulator coverage of Cascade and TheHuzz.&lt;/p&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;p&gt;Some experiments require 64 cores, however, it can be run with less cores, we do not expect a big difference in the results.&lt;/p&gt; &#xA;&lt;p&gt;One optional experiment, which will be explicitly marked, requires access to Questasim (a commercial RTL simulator). No other experiment depends on these results, hence non-Questasim users can safely ignore this experiment and run the rest of the artifacts.&lt;/p&gt; &#xA;&lt;h3&gt;Step-by-step guide&lt;/h3&gt; &#xA;&lt;h4&gt;Obtain the Docker image. (Human time: 1 minute. Computer time: up to some hours.)&lt;/h4&gt; &#xA;&lt;p&gt;If you are willing to use the Docker image, here is how to proceed. Else, we recommend to mimic the structure of the repositories as described in the Dockerfile.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker pull docker.io/ethcomsec/cascade-artifacts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Start a container using the Docker image. (Human time: some minutes, on and off. Computer time: some minutes.)&lt;/h4&gt; &#xA;&lt;p&gt;All relevant experiments have already been reproduced inside this image. We made the steps explicit in the Dockerfile. The Dockerfile is hence also a convenient reference on how to run each experiment.&lt;/p&gt; &#xA;&lt;p&gt;First, start a new container with the image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run -it docker.io/ethcomsec/cascade-artifacts&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This procedure assumes you don&#39;t want to rebuild everything from scratch, although you can re-run commmands that are presented in the Dockerfile.&lt;/p&gt; &#xA;&lt;p&gt;Instead, if you would like to rebuild the Docker image, simply run &lt;code&gt;make build&lt;/code&gt; in the current repository, which will re-build the whole Docker image from scratch. This will take many hours to execute.&lt;/p&gt; &#xA;&lt;p&gt;In this Docker container, we limited the computation for Figure 16 to 30 seconds per point to finish in reasonable time. The value used in the paper is 1200 seconds, which may require multiple days to run, on a 64-core machine. The duration of 30 seconds is sufficient to support the claim made in the paper that longer programs tend to be more efficient at finding bugs. This timeout can be modified by adapting the line &lt;code&gt;ENV TIMEOUT_SECONS_PER_BUG=30&lt;/code&gt; in the Dockerfile with a value of your choice.&lt;/p&gt; &#xA;&lt;p&gt;The following error messages are expected, and can be safely ignored:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SIMLEN environment variable not set.&#xA;make: *** [Makefile:129: run_vanilla_notrace] Error 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Re-running individual experiments&lt;/h4&gt; &#xA;&lt;p&gt;You can re-run individual experiments by re-executing lines of the Dockerfile in the docker container.&lt;/p&gt; &#xA;&lt;p&gt;Make sure that your Verilator version in the Docker container is correct. If you get the following error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ERROR: %Error: Unknown warning specified: -Wno-EOFNEWLINE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then please reinstall the newer version of Verilator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rm -rf verilator &amp;amp;&amp;amp; git clone https://github.com/verilator/verilator &amp;amp;&amp;amp; cd verilator &amp;amp;&amp;amp; git checkout v5.006 &amp;amp;&amp;amp; autoconf &amp;amp;&amp;amp; ./configure &amp;amp;&amp;amp; make -j 200 &amp;amp;&amp;amp; make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Plots&lt;/h4&gt; &#xA;&lt;p&gt;All plots, except for the Questasim experiment, are stored in the &lt;code&gt;/cascade-meta/figures&lt;/code&gt; directory inside the Docker container, and have been generated as indicated in the Dockerfile.&lt;/p&gt; &#xA;&lt;h5&gt;Extracting plots from the Docker container&lt;/h5&gt; &#xA;&lt;p&gt;You must first run a container, for example using the command &lt;code&gt;make run&lt;/code&gt;. You can then see the container id, for example, from the command prompt that you get after running &lt;code&gt;make run&lt;/code&gt;, for example, &lt;code&gt;root@ac674f329a7b:/#&lt;/code&gt; signifies that the container id is &lt;code&gt;ac674f329a7b&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can now copy out the figures from the container to your host machine, for example, using the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mkdir -p figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/bug_categories.png            figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/cascade_dependencies.png      figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/cascade_prevalences.png       figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/difuzzrtl_completions.png     figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/difuzzrtl_coverage.png        figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/difuzzrtl_dependencies.png    figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/difuzzrtl_prevalences.png     figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/reduction_perf.png            figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/rfuzz.png                     figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/security_implications.png     figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/bug_timings_curves.png        figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/execperf_programlength.png    figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/fuzzperf_programlength.png    figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/genduration_programlength.png figures&#xA;docker cp &amp;lt;container_id&amp;gt;:/cascade-meta/figures/fuzzperf.png                  figures&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Mapping to the paper&#39;s figures&lt;/h5&gt; &#xA;&lt;p&gt;Mapping to the paper&#39;s figures:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Figure in paper&lt;/th&gt; &#xA;   &lt;th&gt;Figure in artifacts&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;difuzzrtl_completions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;difuzzrtl_prevalences&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;6&lt;/td&gt; &#xA;   &lt;td&gt;fuzzperf&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;7&lt;/td&gt; &#xA;   &lt;td&gt;execperf_programlength&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;8&lt;/td&gt; &#xA;   &lt;td&gt;genduration_programlength&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;9&lt;/td&gt; &#xA;   &lt;td&gt;fuzzperf_programlength&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;10&lt;/td&gt; &#xA;   &lt;td&gt;cascade_prevalences&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;11&lt;/td&gt; &#xA;   &lt;td&gt;difuzzrtl_dependencies&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;12&lt;/td&gt; &#xA;   &lt;td&gt;cascade_dependencies&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;13&lt;/td&gt; &#xA;   &lt;td&gt;difuzzrtl_coverage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;14&lt;/td&gt; &#xA;   &lt;td&gt;rfuzz&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;15&lt;/td&gt; &#xA;   &lt;td&gt;[optional -- modelsim]&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;16&lt;/td&gt; &#xA;   &lt;td&gt;bug_timings_curves&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;17&lt;/td&gt; &#xA;   &lt;td&gt;bug_categories&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;18&lt;/td&gt; &#xA;   &lt;td&gt;bug_detection_timings&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;19&lt;/td&gt; &#xA;   &lt;td&gt;security_implications&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;20&lt;/td&gt; &#xA;   &lt;td&gt;reduction_perf&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Questasim experiment (Optional)&lt;/h4&gt; &#xA;&lt;p&gt;The Questasim experiment, optional, is the only experiment that must be partially run outside of the Docker container. The experiment requires the presence of the executables &lt;code&gt;vsim&lt;/code&gt;, &lt;code&gt;vlog&lt;/code&gt; and &lt;code&gt;vcover&lt;/code&gt; in the PATH.&lt;/p&gt; &#xA;&lt;p&gt;You will also require fusesoc, as also installed in the Dockerfile.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip3 install fusesoc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will need to clone &lt;code&gt;cascade-meta&lt;/code&gt; and &lt;code&gt;cascade-chipyard&lt;/code&gt; (containing the Rocket core) locally. If potential requirements are missing, ensure to reproduce the first line of the Dockerfile, directly on your machine.&lt;/p&gt; &#xA;&lt;p&gt;To initialize cascade-chipyard, please run, like done in the Dockerfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;source /path/to/cascade-meta &amp;amp;&amp;amp; cd /path/to/cascade-chipyard &amp;amp;&amp;amp; git branch stable &amp;amp;&amp;amp; CASCADE_JOBS=250 scripts/init-submodules-no-riscv-tools.sh -f&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, build the Rocket core for the Questasim simulation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;source /path/to/cascade-meta &amp;amp;&amp;amp; cd /path/to/cascade-chipyard/cascade &amp;amp;&amp;amp; make build_vanilla_notrace_modelsim &amp;amp;&amp;amp; make rerun_vanilla_notrace_modelsim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may have to adapt the &lt;code&gt;rocket&lt;/code&gt; entry in the local &lt;code&gt;cascade_meta/design_processing/design_repos.json&lt;/code&gt; for running the experiment.&lt;/p&gt; &#xA;&lt;p&gt;To run the Questasim experiment, first start a new container with the image and generate the ELF files for DifuzzRTL and Cascade (this may take some hours). Note that we could have done this in the Dockerfile but the resulting Docker image would be very large. You must also choose a local directory where the ELFs directory will be mounted (make sure to have the proper permissions); alternatively, instead of mounting using the &lt;code&gt;-v&lt;/code&gt; flag, you could copy out the ELFs by using &lt;code&gt;docker ps&lt;/code&gt; and then &lt;code&gt;docker cp&lt;/code&gt;. All this can be done, for example, as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;DIFUZZRTL_FUZZER_DIR_PATH_CANDIDATE=&amp;lt;path_to_the_Fuzzer&amp;gt; docker run -v /path/to/some/mount/directory:/cascade-mountdir -it cascade-artifacts bash -c &#34;source /cascade-meta/env.sh &amp;amp;&amp;amp; python3 /cascade-meta/fuzzer/do_genelfs_for_questa.py&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Ensure that you have the Python requirements installed by the Dockerfile on your host machine. Please install any additional Python requirement that would be requested during the course of the experiment, for instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip3 install matplotlib numpy tqdm filelock&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, run the experiment, first indicating where the ELFs are now located (the directory you mounted):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export CASCADE_PATH_TO_DIFUZZRTL_ELFS_FOR_MODELSIM=/path/to/some/mount/directory&#xA;cd &amp;lt;path_to_cascade_meta&amp;gt;/fuzzer &amp;amp;&amp;amp; python3 do_compare_cascade_difuzzrtl_modelsim.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The experiment may take many hours and can be divided in two parts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Running the fuzzer. This can be done in parallel.&lt;/li&gt; &#xA; &lt;li&gt;Merging the coverage results. This must be done sequentially to get the coverage achieved at each step. The result is stored in the file &lt;code&gt;modelsim.png&lt;/code&gt; in the local &lt;code&gt;cascade-meta/figures&lt;/code&gt; directory.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/comsec-group/cascade-artifacts/assets/28906668/0fbbf474-4479-4bf9-96df-43c520f3ae8e&#34; alt=&#34;cascade logo&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>hmrc/emcs-tfe-create-movement-frontend</title>
    <updated>2023-10-26T01:36:05Z</updated>
    <id>tag:github.com,2023-10-26:/hmrc/emcs-tfe-create-movement-frontend</id>
    <link href="https://github.com/hmrc/emcs-tfe-create-movement-frontend" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;emcs-tfe-create-movement-frontend&lt;/h1&gt; &#xA;&lt;p&gt;Contains the frontend journey for EMCS TFE to Create a Movement. Using hmrc-scaffold-g8.&lt;/p&gt; &#xA;&lt;h2&gt;How to build pages with the Scaffoling&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Enter an &lt;code&gt;sbt&lt;/code&gt; shell by issuing the command &lt;code&gt;sbt&lt;/code&gt; in your terminal window. &lt;em&gt;(alternative, if using IntelliJ click on the &lt;code&gt;sbt shell&lt;/code&gt; tab in the bottom panel)&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Once the sbt shell has initialised enter the command &lt;code&gt;g8Scaffold template&lt;/code&gt; where &lt;code&gt;template&lt;/code&gt; is replaced with one of the following available scaffolding templates:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;code&gt;checkboxPage&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;contentPage&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;datePage&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;intPage&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;multipleQuestionsPage&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;radioButtonPage&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;stringPage&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;yesNoPage&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;characterCountPage&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The g8Scaffolding will prompt for values to properties. Such as the &lt;code&gt;className&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Enter appropriate values for each prompt&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Once the g8Scaffold says &lt;code&gt;success :)&lt;/code&gt;, exit out of the sbt shell and back to a normal terminal window&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the script &lt;code&gt;./migrate.sh&lt;/code&gt; to run the migrations &lt;em&gt;(this creates the messages entries and the routes entries - along with a few other things)&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Your page is ready to be refactored and enhanced with business rules, content changes and anything else.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;IMPORTANT:&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Using the scaffolds to generate tests is not a replacement for writing good tests. Please refactor and enhance the default tests with tests which cover extra logic and business rules&lt;/li&gt; &#xA;   &lt;li&gt;Scaffold are here to help us get a head start with simple pages, but do refactor the generated code to improve quality where appropriate&lt;/li&gt; &#xA;   &lt;li&gt;If you find an improvement that could be applied to the Scaffolds update the &lt;code&gt;g8&lt;/code&gt; template so that this can be used by future Engineers&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;This code is open source software licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/hmrc/emcs-tfe-create-movement-frontend/main/%22http://www.apache.org/licenses/LICENSE-2.0.html%22&#34;&gt;Apache 2.0 License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>