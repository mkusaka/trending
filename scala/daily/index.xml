<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-19T01:47:56Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>TheAlgorithms/Scala</title>
    <updated>2022-08-19T01:47:56Z</updated>
    <id>tag:github.com,2022-08-19:/TheAlgorithms/Scala</id>
    <link href="https://github.com/TheAlgorithms/Scala" rel="alternate"></link>
    <summary type="html">&lt;p&gt;All Algorithms implemented in Scala&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;!-- Title: --&gt; &#xA; &lt;a href=&#34;https://github.com/TheAlgorithms/&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/TheAlgorithms/website/1cd824df116b27029f17c2d1b42d81731f28a920/public/logo.svg?sanitize=true&#34; height=&#34;100&#34;&gt; &lt;/a&gt; &#xA; &lt;h1&gt;&lt;a href=&#34;https://github.com/TheAlgorithms/&#34;&gt;The Algorithms&lt;/a&gt; - Scala&lt;/h1&gt; &#xA; &lt;!-- Labels: --&gt; &#xA; &lt;!-- First row: --&gt; &#xA; &lt;a href=&#34;https://github.com/TheAlgorithms/Scala/raw/master/CONTRIBUTING.md&#34;&gt; &lt;img src=&#34;https://img.shields.io/static/v1.svg?label=Contributions&amp;amp;message=Welcome&amp;amp;color=0059b3&amp;amp;style=flat-square&#34; height=&#34;20&#34; alt=&#34;Contributions Welcome&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://discord.gg/c7MnfGFGa6&#34;&gt; &lt;img src=&#34;https://img.shields.io/discord/808045925556682782.svg?logo=discord&amp;amp;colorB=7289DA&amp;amp;style=flat-square&#34; height=&#34;20&#34; alt=&#34;Discord chat&#34;&gt; &lt;/a&gt; &#xA; &lt;a href=&#34;https://gitter.im/TheAlgorithms&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Chat-Gitter-ff69b4.svg?label=Chat&amp;amp;logo=gitter&amp;amp;style=flat-square&#34; height=&#34;20&#34; alt=&#34;Gitter chat&#34;&gt; &lt;/a&gt; &#xA; &lt;!-- Short description: --&gt; &#xA; &lt;h3&gt;All algorithms implemented in Scala - for education&lt;/h3&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;Implementations are for learning purposes only. As they may be less efficient than the implementations in the Scala standard library, use them at your discretion.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Read through our &lt;a href=&#34;https://raw.githubusercontent.com/TheAlgorithms/Scala/master/CONTRIBUTING.md&#34;&gt;Contribution Guidelines&lt;/a&gt; before you contribute.&lt;/p&gt; &#xA;&lt;h2&gt;Community Channels&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re on &lt;a href=&#34;https://discord.gg/c7MnfGFGa6&#34;&gt;Discord&lt;/a&gt; and &lt;a href=&#34;https://gitter.im/TheAlgorithms&#34;&gt;Gitter&lt;/a&gt;! Community channels are great for you to ask questions and get help. Please join us!&lt;/p&gt; &#xA;&lt;h2&gt;List of Algorithms&lt;/h2&gt; &#xA;&lt;p&gt;See our &lt;a href=&#34;https://raw.githubusercontent.com/TheAlgorithms/Scala/master/DIRECTORY.md&#34;&gt;directory&lt;/a&gt; for easier navigation and better overview of the project.&lt;/p&gt; &#xA;&lt;h2&gt;How to use this repository for learning purpose ?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.scala-lang.org/download/&#34;&gt;Download and install Scala&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone the repository on your local machine&lt;/p&gt; &lt;p&gt;&lt;code&gt;git clone https://github.com/TheAlgorithms/Scala.git&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open the repository using an IDE (Preferably IntelliJ Idea)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Enable auto-import to import the dependencies from build.sbt&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open the &lt;a href=&#34;https://github.com/TheAlgorithms/Scala/tree/master/src/main/scala&#34;&gt;src/main/scala&lt;/a&gt; to view the algorithm implementations under various categories&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open &lt;a href=&#34;https://github.com/TheAlgorithms/Scala/tree/master/src/test/scala&#34;&gt;src/test/scala&lt;/a&gt; to run the test cases and view the algorithm in action&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Visit &lt;a href=&#34;https://github.com/TheAlgorithms/Algorithms-Explainations.git&#34;&gt;Algorithms-Explained&lt;/a&gt; to get a more detailed explanation about specific algorithms&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Check &lt;a href=&#34;https://github.com/TheAlgorithms/Scala/raw/master/Algorithms%20Visualization.md&#34;&gt;Algorithms Visualization&lt;/a&gt; for visualization of numerous algorithms&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>thecloudcircle/graphster</title>
    <updated>2022-08-19T01:47:56Z</updated>
    <id>tag:github.com,2022-08-19:/thecloudcircle/graphster</id>
    <link href="https://github.com/thecloudcircle/graphster" rel="alternate"></link>
    <summary type="html">&lt;p&gt;spark-based library that helps construct and query knowledge graphs from unstructured and structured data&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;graphster&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;graphster&lt;/code&gt; is an open-source spark-based library for scalable, end-to-end knowledge graph construction and querying from unstructured and structured source data. The graphster library takes a collection of documents, extracts mentions and relations to populate a raw knowledge graph, links mentions to entities in Wikidata, and then enriches the knowledge graph with facts from Wikidata. Once the knowledge graph is built, graphster can also help natively query the knowledge graph using &lt;a href=&#34;https://en.wikipedia.org/wiki/SPARQL/&#34;&gt;&lt;code&gt;SPARQL&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;http://www.wisecube.org/&#34;&gt;&lt;code&gt;wisecube.org&lt;/code&gt;&lt;/a&gt; for an overview of the library.&lt;/p&gt; &#xA;&lt;p&gt;This README provies instructions on how to use the library in your own project.&lt;/p&gt; &#xA;&lt;h1&gt;Setup&lt;/h1&gt; &#xA;&lt;p&gt;Clone &lt;a href=&#34;https://github.com/thecloudcircle/graphster&#34;&gt;wisecube&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/thecloudcircle/graphster.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;The configuration is used to create Spark &lt;code&gt;Metadata&lt;/code&gt; objects. These objects define transformations between the source data and the graph. All the necessary metadata objects can be kept in a single configuration file and loaded in program that runs the pipelines.&lt;/p&gt; &#xA;&lt;h2&gt;Data Sources&lt;/h2&gt; &#xA;&lt;p&gt;In order to build a knowledge graph you must be able to combine data from other graphs, structured data, and text data.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Graph data: e.g. OWL files, RDF files&lt;/li&gt; &#xA; &lt;li&gt;Structured data: e.g. CSV files, RDBMS database dumps&lt;/li&gt; &#xA; &lt;li&gt;Text data: e.g. Document corpus, text fields in other kinds of data (&amp;gt;= 50 words on average)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The difficulty is that these data sets require different kinds of processing. The idea here is to transform all the data into structured data that will then be transformed into a graph-friendly format. This breaks this complex processing into three phases.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Extraction: where we extract the facts and properties that we are interested from the raw source data&lt;/li&gt; &#xA; &lt;li&gt;Fusion: where we transform the extracted information into a graph-friendly format with a common schema&lt;/li&gt; &#xA; &lt;li&gt;Querying: where we search the data&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Now that we have broken up this complex process into more manageable parts, let&#39;s look at how this library helps enable graph construction.&lt;/p&gt; &#xA;&lt;h2&gt;Extraction&lt;/h2&gt; &#xA;&lt;p&gt;The extraction phase will generally by the most source-specific part of ingestion. In this part logic necessary for transforming the data into a format fusing into the ultimate graph&#39;s schema.&lt;/p&gt; &#xA;&lt;h3&gt;Graph&lt;/h3&gt; &#xA;&lt;h4&gt;RDF data&lt;/h4&gt; &#xA;&lt;p&gt;If the graph data comes in an RDF format then only minimal transformation will be required at this stage. This data should be parsed into tables with the Orpheus schema. The fusion step is where the IRIs, literals, etc. will be mapped to the ultimate schema.&lt;/p&gt; &#xA;&lt;h4&gt;Other Graph Formats&lt;/h4&gt; &#xA;&lt;p&gt;This data should be treated as structured data.&lt;/p&gt; &#xA;&lt;h3&gt;Structured&lt;/h3&gt; &#xA;&lt;p&gt;There are two main concerns structured data - quality and complexity. Of course, general data quality is always important in data engineering, here we are talking about a specific kind of data quality. The kind of data quality we are concerned with is completeness and consistency. What fields are null? In what formats are different data types stored (e.g. dates, floating point, booleans). Complexity is the other ingredient we must manage. Transforming a 30 column CSV into a set of triples is very different from a database with dozens of tables in 3rd normal form.&lt;/p&gt; &#xA;&lt;h3&gt;Text&lt;/h3&gt; &#xA;&lt;p&gt;In order to add text into a graph, we must extract the information we are interested into a structured format. This is where NLP comes in. This library is not an NLP library, which is why there is an abstraction layer. The idea is that the information is extracted into a structured form, so that the downstream process does not need to know what engine was used for NLP.&lt;/p&gt; &#xA;&lt;p&gt;The minimal requirement for an NLP library to serve as an engine is named entity recognition. However, supporting syntactic parsing, entity linking, and relationship extraction can also be utilized.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;wisecube-text&lt;/code&gt; module is a module that acts as an interface to an NLP engine. There is an implementation with JSl Spark NLP.&lt;/p&gt; &#xA;&lt;h2&gt;Fusion&lt;/h2&gt; &#xA;&lt;p&gt;The fusion step is where we take the structured data that has been cleaned, transformed, or extracted and map into the schema of the graph we are building. The first step of fusing new data into a graph is matching what is already there. Matching entities in the new data to entities already in the graph. The next step is mapping the kinds of relationships and properties to predicates.&lt;/p&gt; &#xA;&lt;h3&gt;Mapping to schema&lt;/h3&gt; &#xA;&lt;p&gt;There are two reasons to have custom transformations at this stage. The first is dealing differences in the conceptual design between the new data and the graph. The second is differences in the conventions recording properties.&lt;/p&gt; &#xA;&lt;p&gt;For example, if your graph has an &#34;author&#34; relationship between documents and authors, but the new data has &#34;wrote&#34; relationship between authors and documents.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TB&#xA;    A{123} -- author --&amp;gt; B{456}&#xA;    A -- rdfs:label --&amp;gt; C(Important Article) &#xA;    B -- rdfs:label --&amp;gt; D(Jane Doe) &#xA;    &#xA;    F{123} -- wrote --&amp;gt; E{456}&#xA;    E -- rdfs:label --&amp;gt; G(Important Article) &#xA;    F -- rdfs:label --&amp;gt; H(Jane Doe) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is a simple example. The direction of the relationship needs only be reversed. Let&#39;s consider an example with a deeper difference. Suppose the graph with which we are fusing keeps certain closely related terms as a single entity - &lt;a href=&#34;https://en.wikipedia.org/wiki/Metonymy&#34;&gt;Metonymy&lt;/a&gt;. For example, let&#39;s say the graph contains proteins, genes, and chemicals. The data that is being added only has genes and chemicals. In this data, relationships between a gene and a chemical may actually represent a relationship between a protein encoded by the gene and the chemical.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR&#xA;    A((Gene)) -- encodes --&amp;gt; B((Protein))&#xA;    B((Protein)) -- interacts with --&amp;gt; C((Chemical))&#xA;    C((Chemical)) -- interacts with --&amp;gt; B((Protein))&#xA;    &#xA;    D((Gene)) -- interacts with --&amp;gt; E((Chemical))&#xA;    E((Chemical)) -- interacts with --&amp;gt; D((Gene))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;How this is mapped to the target schema depends on what other data is available as well as how flexible the schema is. If there is additional information about the gene-chemical edges that we can use to deduce the protein (e.g. pathway information), that can be used. Another option, if no such information is available, is to overload the &lt;code&gt;interacts with&lt;/code&gt; edge in the target graph to allow gene-chemical relations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR&#xA;    A((Gene)) -- encodes --&amp;gt; B((Protein))&#xA;    B((Protein)) -- interacts with --&amp;gt; C((Chemical))&#xA;    C((Chemical)) -- interacts with --&amp;gt; B((Protein))&#xA;    A((Gene)) -- interacts with --&amp;gt; C((Chemical))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If such overloading is not possible in the target schema, then these edges can be represented with a special edge.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR&#xA;    A((Gene)) -- encodes --&amp;gt; B((Protein))&#xA;    B((Protein)) -- interacts with --&amp;gt; C((Chemical))&#xA;    C((Chemical)) -- interacts with --&amp;gt; B((Protein))&#xA;    A((Gene)) -- interacts through protein with --&amp;gt; C((Chemical))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Another option is to use blank nodes, and to try and resolve them with other data.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR&#xA;    A((Gene)) -- encodes --&amp;gt; B((Protein))&#xA;    B((Protein)) -- interacts with --&amp;gt; C((Chemical))&#xA;    C((Chemical)) -- interacts with --&amp;gt; B((Protein))&#xA;    A((Gene)) -- encodes --&amp;gt; D((_:blank))&#xA;    D((_:blank)) -- interacts with --&amp;gt; C((Chemical))&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>