<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-18T01:52:12Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>arainko/ducktape</title>
    <updated>2022-08-18T01:52:12Z</updated>
    <id>tag:github.com,2022-08-18:/arainko/ducktape</id>
    <link href="https://github.com/arainko/ducktape" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The thing that glues your code. Or is it duct ðŸ¤”&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ducktape&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/io.github.arainko/ducktape_3&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/io.github.arainko/ducktape_3/badge.svg?style=flat-square&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Ducktape&lt;/em&gt; is a library for boilerplate-less and configurable transformations between case classes/enums (sealed traits) for Scala 3. Directly inspired by &lt;a href=&#34;https://github.com/scalalandio/chimney&#34;&gt;chimney&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;io.github.arainko&#34; %% &#34;ducktape&#34; % &#34;0.0.14&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;h4&gt;1. &lt;em&gt;Case class to case class&lt;/em&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import io.github.arainko.ducktape.*&#xA;&#xA;final case class Person(firstName: String, lastName: String, age: Int)&#xA;final case class PersonButMoreFields(firstName: String, lastName: String, age: Int, socialSecurityNo: String)&#xA;&#xA;val personWithMoreFields = PersonButMoreFields(&#34;John&#34;, &#34;Doe&#34;, 30, &#34;SOCIAL-NUM-12345&#34;)&#xA;// personWithMoreFields: PersonButMoreFields = PersonButMoreFields(&#xA;//   firstName = &#34;John&#34;,&#xA;//   lastName = &#34;Doe&#34;,&#xA;//   age = 30,&#xA;//   socialSecurityNo = &#34;SOCIAL-NUM-12345&#34;&#xA;// )&#xA;&#xA;val transformed = personWithMoreFields.to[Person]&#xA;// transformed: Person = Person(firstName = &#34;John&#34;, lastName = &#34;Doe&#34;, age = 30)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Automatic case class to case class transformations are supported given that the source type has all the fields of a the destination case class and the types corresponding to these fields have an instance of &lt;code&gt;Transformer&lt;/code&gt; in scope.&lt;/p&gt; &#xA;&lt;p&gt;If these are not met, a compiletime error is issued:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val person = Person(&#34;Jerry&#34;, &#34;Smith&#34;, 20)&#xA;&#xA;person.to[PersonButMoreFields]&#xA;&#xA;// error:&#xA;// No field named &#39;socialSecurityNo&#39; found in Person&#xA;//     .into[PersonButMoreFields]&#xA;//                               ^&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;2. &lt;em&gt;Enum to enum&lt;/em&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import io.github.arainko.ducktape.*&#xA;&#xA;enum Size:&#xA;  case Small, Medium, Large&#xA;&#xA;enum ExtraSize:&#xA;  case ExtraSmall, Small, Medium, Large, ExtraLarge&#xA;&#xA;val transformed = Size.Small.to[ExtraSize]&#xA;// transformed: ExtraSize = Small&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can&#39;t go to a coproduct that doesn&#39;t contain all of our cases (name wise):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val size = ExtraSize.Small.to[Size]&#xA;// error:&#xA;// No child named &#39;ExtraSmall&#39; in Size&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Automatic enum to enum transformations are supported given that the destination enum contains a subset of cases we transform into, otherwise a compiletime errors is issued.&lt;/p&gt; &#xA;&lt;h4&gt;3. &lt;em&gt;Case class to case class with config&lt;/em&gt;&lt;/h4&gt; &#xA;&lt;p&gt;As we established earlier, going from &lt;code&gt;Person&lt;/code&gt; to a &lt;code&gt;PersonButMoreFields&lt;/code&gt; cannot happen automatically as the former doesn&#39;t have the &lt;code&gt;socialSecurityNo&lt;/code&gt; field, but it has all the other fields so it&#39;s almost there, we just have to nudge it a lil&#39; bit.&lt;/p&gt; &#xA;&lt;p&gt;We can do so with field configurations in 3 ways:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Set a constant to a specific field&lt;/li&gt; &#xA; &lt;li&gt;Compute the value for a specific field by applying a function&lt;/li&gt; &#xA; &lt;li&gt;Use a different field in its place - &#39;rename&#39; it&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import io.github.arainko.ducktape.*&#xA;&#xA;final case class Person(firstName: String, lastName: String, age: Int)&#xA;final case class PersonButMoreFields(firstName: String, lastName: String, age: Int, socialSecurityNo: String)&#xA;&#xA;val person = Person(&#34;Jerry&#34;, &#34;Smith&#34;, 20)&#xA;// person: Person = Person(firstName = &#34;Jerry&#34;, lastName = &#34;Smith&#34;, age = 20)&#xA;&#xA;// 1. Set a constant to a specific field&#xA;val withConstant = &#xA;  person&#xA;    .into[PersonButMoreFields]&#xA;    .withFieldConst(_.socialSecurityNo, &#34;CONSTANT-SSN&#34;)&#xA;    .transform&#xA;// withConstant: PersonButMoreFields = PersonButMoreFields(&#xA;//   firstName = &#34;Jerry&#34;,&#xA;//   lastName = &#34;Smith&#34;,&#xA;//   age = 20,&#xA;//   socialSecurityNo = &#34;CONSTANT-SSN&#34;&#xA;// )&#xA;&#xA;// 2. Compute the value for a specific field by applying a function&#xA;val withComputed = &#xA;  person&#xA;    .into[PersonButMoreFields]&#xA;    .withFieldComputed(_.socialSecurityNo, p =&amp;gt; s&#34;${p.firstName}-COMPUTED-SSN&#34;)&#xA;    .transform&#xA;// withComputed: PersonButMoreFields = PersonButMoreFields(&#xA;//   firstName = &#34;Jerry&#34;,&#xA;//   lastName = &#34;Smith&#34;,&#xA;//   age = 20,&#xA;//   socialSecurityNo = &#34;Jerry-COMPUTED-SSN&#34;&#xA;// )&#xA;&#xA;// 3. Use a different field in its place - &#39;rename&#39; it&#xA;val withRename = &#xA;  person&#xA;    .into[PersonButMoreFields]&#xA;    .withFieldRenamed(_.socialSecurityNo, _.firstName)&#xA;    .transform&#xA;// withRename: PersonButMoreFields = PersonButMoreFields(&#xA;//   firstName = &#34;Jerry&#34;,&#xA;//   lastName = &#34;Smith&#34;,&#xA;//   age = 20,&#xA;//   socialSecurityNo = &#34;Jerry&#34;&#xA;// )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case we repeatedly apply configurations to the same field, the latest one is chosen:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val withRepeatedConfig =&#xA;  person&#xA;    .into[PersonButMoreFields]&#xA;    .withFieldRenamed(_.socialSecurityNo, _.firstName)&#xA;    .withFieldComputed(_.socialSecurityNo, p =&amp;gt; s&#34;${p.firstName}-COMPUTED-SSN&#34;)&#xA;    .withFieldConst(_.socialSecurityNo, &#34;CONSTANT-SSN&#34;)&#xA;    .transform&#xA;// withRepeatedConfig: PersonButMoreFields = PersonButMoreFields(&#xA;//   firstName = &#34;Jerry&#34;,&#xA;//   lastName = &#34;Smith&#34;,&#xA;//   age = 20,&#xA;//   socialSecurityNo = &#34;CONSTANT-SSN&#34;&#xA;// )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course we can use this to override the automatic derivation per field:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val withEverythingOverriden = &#xA;  person&#xA;    .into[PersonButMoreFields]&#xA;    .withFieldConst(_.socialSecurityNo, &#34;CONSTANT-SSN&#34;)&#xA;    .withFieldConst(_.age, 100)&#xA;    .withFieldConst(_.firstName, &#34;OVERRIDEN-FIRST-NAME&#34;)&#xA;    .withFieldConst(_.lastName, &#34;OVERRIDEN-LAST-NAME&#34;)&#xA;    .transform&#xA;// withEverythingOverriden: PersonButMoreFields = PersonButMoreFields(&#xA;//   firstName = &#34;OVERRIDEN-FIRST-NAME&#34;,&#xA;//   lastName = &#34;OVERRIDEN-LAST-NAME&#34;,&#xA;//   age = 100,&#xA;//   socialSecurityNo = &#34;CONSTANT-SSN&#34;&#xA;// )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;4. Enum to enum with config&lt;/h4&gt; &#xA;&lt;p&gt;Enum transformations, just like case class transformations, can be configured - but only in one way, by applying a function to a specific subtype:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import io.github.arainko.ducktape.*&#xA;&#xA;enum Size:&#xA;  case Small, Medium, Large&#xA;&#xA;enum ExtraSize:&#xA;  case ExtraSmall, Small, Medium, Large, ExtraLarge&#xA;&#xA;val transformed = Size.Small.to[ExtraSize]&#xA;// transformed: ExtraSize = Small&#xA;&#xA;// Apply a function for the specified subtype&#xA;val size = &#xA;  ExtraSize.ExtraSmall&#xA;    .into[Size]&#xA;    .withCaseInstance[ExtraSize.ExtraSmall.type](_ =&amp;gt; Size.Small)&#xA;    .withCaseInstance[ExtraSize.ExtraLarge.type](_ =&amp;gt; Size.Large)&#xA;    .transform&#xA;// size: Size = Small&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;5. Method to case class&lt;/h4&gt; &#xA;&lt;p&gt;We can also let &lt;code&gt;ducktape&lt;/code&gt; expand method incovations for us:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import io.github.arainko.ducktape.*&#xA;&#xA;final case class Person1(firstName: String, lastName: String, age: Int)&#xA;final case class Person2(firstName: String, lastName: String, age: Int)&#xA;&#xA;def methodToExpand(lastName: String, age: Int, firstName: String): Person2 =&#xA;  Person2(firstName, lastName, age)&#xA;&#xA;val person1: Person1 = Person1(&#34;John&#34;, &#34;Doe&#34;, 23)&#xA;// person1: Person1 = Person1(firstName = &#34;John&#34;, lastName = &#34;Doe&#34;, age = 23)&#xA;val person2: Person2 = person1.via(methodToExpand)&#xA;// person2: Person2 = Person2(firstName = &#34;John&#34;, lastName = &#34;Doe&#34;, age = 23)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, &lt;code&gt;ducktape&lt;/code&gt; will match the fields from &lt;code&gt;Person&lt;/code&gt; to parameter names of &lt;code&gt;methodToExpand&lt;/code&gt; failing at compiletime if a parameter cannot be matched (be it there&#39;s no name correspondence or a &lt;code&gt;Transformer&lt;/code&gt; between types of two fields named the same isn&#39;t available):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def methodToExpandButOneMoreArg(lastName: String, age: Int, firstName: String, additionalArg: String): Person2 =&#xA;  Person2(firstName + additionalArg, lastName, age)&#xA;&#xA;person1.via(methodToExpandButOneMoreArg)&#xA;// error:&#xA;// No field named &#39;additionalArg&#39; in Person&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;6. Method to case class with config&lt;/h4&gt; &#xA;&lt;p&gt;Just like transforming between case classes and coproducts we can nudge the derivation in some places to complete the puzzle, let&#39;s tackle the last example once again:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def methodToExpandButOneMoreArg(lastName: String, age: Int, firstName: String, additionalArg: String): Person2 =&#xA;  Person2(firstName + additionalArg, lastName, age)&#xA;&#xA;person1&#xA;  .intoVia(methodToExpandButOneMoreArg)&#xA;  .withArgConst(_.additionalArg, &#34;-CONST ARG&#34;)&#xA;  .transform&#xA;// res5: Person2 = Person2(&#xA;//   firstName = &#34;John-CONST ARG&#34;,&#xA;//   lastName = &#34;Doe&#34;,&#xA;//   age = 23&#xA;// )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can configure method arguments in 3 ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;withArgConst&lt;/code&gt; - supply a constant value to a method argument&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withArgComputed&lt;/code&gt; - compute the argument with a function&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;withArgRenamed&lt;/code&gt; - rename an argument so that it matches a different field&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;A look at the generated code&lt;/h3&gt; &#xA;&lt;h4&gt;-- TODO --&lt;/h4&gt;</summary>
  </entry>
</feed>