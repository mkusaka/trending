<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-13T01:43:45Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>typelevel/twiddles</title>
    <updated>2023-04-13T01:43:45Z</updated>
    <id>tag:github.com,2023-04-13:/typelevel/twiddles</id>
    <link href="https://github.com/typelevel/twiddles" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Twiddles&lt;/h1&gt; &#xA;&lt;p&gt;A twiddle list is a list of one or more values, potentially of differing types, that supports incremental creation and supports conversion to case classes that are &#34;shape compatible&#34; with the constituent types of the twiddle list.&lt;/p&gt; &#xA;&lt;p&gt;Twiddle lists are useful in the creation of protocols (e.g., decoders, encoders, codecs), where a protocol for a complex type is built from simpler constituent protocols. This technique was first popularized by parser combinators with syntax like &lt;code&gt;lparen ~ expr ~ rparen&lt;/code&gt;. In contrast to type driven derivation schemes, where protocols are implicitly determined by the constituent types of a data constructor, twiddle lists keep the focus on the protocol.&lt;/p&gt; &#xA;&lt;p&gt;This library provides the ability to work with twiddle lists for arbitrary types and provides a single API that works for both Scala 3 and Scala 2. On Scala 3, twiddle lists are represented as generic tuples -- e.g., &lt;code&gt;F[Int *: String *: Boolean *: EmptyTuple]&lt;/code&gt; or equivalently &lt;code&gt;F[(Int, String, Boolean)]&lt;/code&gt;. On Scala 2, twiddle lists are represented as Shapeless heterogeneous lists. The &lt;code&gt;org.typelevel.twiddles&lt;/code&gt; package provides type aliases that allow for source compatibility (&lt;code&gt;*:&lt;/code&gt; is aliased to &lt;code&gt;shapeles.::&lt;/code&gt; and &lt;code&gt;EmptyTuple&lt;/code&gt; is aliased to &lt;code&gt;shapeless.HNil&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Enable twiddle syntax for arbitrary types&#xA;import org.typelevel.twiddles.syntax._&#xA;&#xA;case class Foo(x: Int, y: String)&#xA;&#xA;val a = Option(42)&#xA;// a: Option[Int] = Some(value = 42)&#xA;val b = Option(&#34;Hi&#34;)&#xA;// b: Option[String] = Some(value = &#34;Hi&#34;)&#xA;&#xA;val foo = (a *: b).as[Foo]&#xA;// foo: Option[Foo] = Some(value = Foo(x = 42, y = &#34;Hi&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, &lt;code&gt;a *: b&lt;/code&gt; creates an &lt;code&gt;Option[Int *: String *: EmptyTuple]&lt;/code&gt;. We then convert that value to an &lt;code&gt;Option[Foo]&lt;/code&gt; via &lt;code&gt;.as[Foo]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;*:&lt;/code&gt; operation comes from the imported twiddle syntax and is similar to the Scala 3 built-in tuple cons operation, but works on applied type constructors. The expression &lt;code&gt;a *: b *: c&lt;/code&gt; builds an &lt;code&gt;F[A *: B *: C *: EmptyTuple]&lt;/code&gt; from an &lt;code&gt;F[A]&lt;/code&gt;, &lt;code&gt;F[B]&lt;/code&gt;, and &lt;code&gt;F[C]&lt;/code&gt;. The &lt;code&gt;*:&lt;/code&gt; operation requires that the type constructor &lt;code&gt;F&lt;/code&gt; has a &lt;code&gt;cats.InvariantSemigroupal&lt;/code&gt; instance.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;as&lt;/code&gt; operation also comes from the imported twiddle syntax. Calling &lt;code&gt;.as[X]&lt;/code&gt; on an &lt;code&gt;F[T]&lt;/code&gt; for some twiddle list &lt;code&gt;T&lt;/code&gt; results in an &lt;code&gt;F[X]&lt;/code&gt; provided that &lt;code&gt;T&lt;/code&gt; is shape compatible with &lt;code&gt;X&lt;/code&gt;. In the most common case where &lt;code&gt;X&lt;/code&gt; is a case class, shape compatibility is defined as &lt;code&gt;T&lt;/code&gt; having the same types in the same order as the parameters of &lt;code&gt;X&lt;/code&gt;. The &lt;code&gt;as&lt;/code&gt; operation requires that the type constructor &lt;code&gt;F&lt;/code&gt; has a &lt;code&gt;cats.Invariant&lt;/code&gt; instance.&lt;/p&gt; &#xA;&lt;p&gt;Invariant semigroupals are much more general than (covariant) functors, which means twiddle list support works for a wide variety of data types. For instance, contravariant functors are invariant semigroupals allowing us to use twiddle list syntax to incrementally build instances:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val fooOrdering = (summon[Ordering[Int]] *: summon[Ordering[String]]).as[Foo]&#xA;// fooOrdering: Ordering[Foo] = scala.math.Ordering$$anon$1@381596fc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Library Usage&lt;/h2&gt; &#xA;&lt;p&gt;When designing a library that uses twiddle lists, the &lt;code&gt;TwiddleSyntax&lt;/code&gt; trait can be mixed in to the companion object of a type constructor. This has the effect of providing twiddle syntax without requiring users of the library to import &lt;code&gt;org.typelevel.twiddles.syntax._&lt;/code&gt; at each call site.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import org.typelevel.twiddles.TwiddleSyntax&#xA;import cats.Applicative&#xA;&#xA;trait Json&#xA;trait Decoder[A] {&#xA;  def decode(j: Json): Option[A]&#xA;}&#xA;object Decoder extends TwiddleSyntax {&#xA;  implicit val applicative: Applicative[Decoder] = new Applicative[Decoder] {&#xA;    def pure[A](a: A): Decoder[A] = _ =&amp;gt; Some(a)&#xA;    def ap[A, B](ff: Decoder[A =&amp;gt; B])(fa: Decoder[A]): Decoder[B] = j =&amp;gt;&#xA;      for {&#xA;        f &amp;lt;- ff.decode(j)&#xA;        a &amp;lt;- fa.decode(j)&#xA;      } yield f(a)&#xA;  }&#xA;}&#xA;&#xA;val int: Decoder[Int] = _ =&amp;gt; ???&#xA;// int: Decoder[Int] = repl.MdocSession$MdocApp0$$Lambda$55703/0x00000008035c0ed0@3bb9fa50&#xA;val string: Decoder[String] = _ =&amp;gt; ???&#xA;// string: Decoder[String] = repl.MdocSession$MdocApp0$$Lambda$55704/0x00000008035c1318@89caf3a&#xA;&#xA;case class Foo(x: Int, y: String)&#xA;val fooDecoder = (int *: string).as[Foo]&#xA;// fooDecoder: Decoder[Foo] = repl.MdocSession$$anon$8$$Lambda$55707/0x00000008035c2000@34442258&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, the &lt;code&gt;Decoder&lt;/code&gt; type has an &lt;code&gt;Applicative&lt;/code&gt; instance defined in its companion object (and &lt;code&gt;Applicative&lt;/code&gt; extends &lt;code&gt;InvariantSemigroupal&lt;/code&gt;), and the companion object extends &lt;code&gt;TwiddleSyntax&lt;/code&gt;. The latter enables use of &lt;code&gt;*:&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; with &lt;code&gt;Decoder&lt;/code&gt; values without adding explicit imports (that is, there&#39;s no need to import &lt;code&gt;org.typelevel.twiddles.syntax._&lt;/code&gt; at call sites).&lt;/p&gt; &#xA;&lt;h2&gt;Etymology&lt;/h2&gt; &#xA;&lt;p&gt;The term &#34;twiddle list&#34; was first coined by &lt;a href=&#34;https://github.com/tpolecat&#34;&gt;Rob Norris&lt;/a&gt; in the &lt;a href=&#34;https://github.com/tpolecat/skunk&#34;&gt;Skunk&lt;/a&gt; library, where a twiddle list was defined as a left nested tuple. For example, a 4 element twiddle list consisting of an &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, and &lt;code&gt;Double&lt;/code&gt; was represented as &lt;code&gt;(((Int, String), Boolean), Double)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This library uses a different encoding -- twiddle lists are encoded as tuples on Scala 3 and Shapeless heterogeneous lists on Scala 2. The previous 4 element twiddle list is represented as &lt;code&gt;Int *: String *: Boolean *: Double *: EmptyTuple&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We adopt the name &#34;twiddle list&#34; to refer to the general technique of incremental construction of complex protocols.&lt;/p&gt;</summary>
  </entry>
</feed>