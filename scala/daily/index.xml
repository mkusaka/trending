<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-14T01:48:10Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cchantep/acolyte</title>
    <updated>2023-06-14T01:48:10Z</updated>
    <id>tag:github.com,2023-06-14:/cchantep/acolyte</id>
    <link href="https://github.com/cchantep/acolyte" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üêØ Mockup/testing JDBC &amp; MongoDB driver (or Chmeee&#39;s son on the Ringworld).&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Acolyte&lt;/h1&gt; &#xA;&lt;p&gt;Acolyte is a JDBC driver designed for cases like mockup, testing, or any case you would like to be able to handle JDBC query by hand (or maybe that&#39;s only Chmeee&#39;s son on the Ringworld).&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Persistence layer not only apply changes and retrieve raw data. It usually gathers those data from several sources (e.g. various queries), but also converts data types (e.g. integer to boolean) and maps it to structured information.&lt;/p&gt; &#xA;&lt;p&gt;Automated testing about that is not trivial. Using test DB requires tools (scripts) to set up environment repeatly, for each time tests are executed.&lt;/p&gt; &#xA;&lt;p&gt;Considering integration testing that&#39;s fine. It&#39;s different for unit testing.&lt;/p&gt; &#xA;&lt;p&gt;Unit tests must be isolated from each others so each unit can be validated independently.&lt;/p&gt; &#xA;&lt;p&gt;A unit test can alter database as executed. Thus tests coming after would have to cope with this altered environment, without asserting which one is runned first (no order assumption).&lt;/p&gt; &#xA;&lt;p&gt;As tests can be runned in parallel while considering code accessing same data spaces. Without extra attention to isolation/transaction management, this can lead to tests conflicting between them.&lt;/p&gt; &#xA;&lt;p&gt;With Acolyte, connection behaviour can be built, defining which statement is supported with which (query or update) result.&lt;/p&gt; &#xA;&lt;p&gt;Each prepared connection can supports only queries and updates your code is interested in, and there is no need to simulate a whole data store structure/schema.&lt;/p&gt; &#xA;&lt;p&gt;As soon as Acolyte connections don&#39;t rely on data store, statement executions are isolated without extra effort.&lt;/p&gt; &#xA;&lt;p&gt;As a JDBC driver is provided you can simply update test configuration, so that Acolyte connections are resolved by persistence code without change throught standard mechanisms (JDBC URL, JNDI, ...).&lt;/p&gt; &#xA;&lt;p&gt;It also makes simple testing of DB edge cases (e.g. unrecoverable/unexpected error). It&#39;s easy to throw an exception from Acolyte connection, so that it can be validated persistence code is properly handling such case.&lt;/p&gt; &#xA;&lt;p&gt;You can also use Acolyte to fully benefit from data access abstraction, not only not having to wait persistence (DB) being setup to code accesses, but also not having to wait persistence to code tests for access code.&lt;/p&gt; &#xA;&lt;p&gt;You can get a quick interactive tour of Acolyte, online at &lt;a href=&#34;http://tour.acolyte.eu.org&#34;&gt;tour.acolyte.eu.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Acolyte is usable with any code relying on JDBC. It makes it available for any JVM language:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;vanilla &lt;a href=&#34;http://acolyte.eu.org/java/&#34;&gt;Java&lt;/a&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://acolyte.eu.org/scala/&#34;&gt;Scala&lt;/a&gt; (with DSL),&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://clojure.com&#34;&gt;Clojure&lt;/a&gt;, &lt;a href=&#34;https://github.com/Frege/frege&#34;&gt;Fredge&lt;/a&gt;, ...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can get connection defined by Acolyte using the well-known &lt;code&gt;java.sql.DriverManager.getConnection(jdbcUrl)&lt;/code&gt; (see &lt;a href=&#34;http://acolyte.eu.org/java/#Connection&#34;&gt;connection management&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final String jdbcUrl = &#34;jdbc:acolyte:anything-you-want?handler=my-unique-id&#34;;&#xA;&#xA;StatementHandler handler = new CompositeHandler().&#xA;  withQueryDetection(&#34;^SELECT &#34;). // regex test from beginning&#xA;  withQueryDetection(&#34;EXEC that_proc&#34;). // second detection regex&#xA;  withUpdateHandler(new CompositeHandler.UpdateHandler() {&#xA;    // Handle execution of update statement (not query)&#xA;    public UpdateResult apply(String sql, List&amp;lt;Parameter&amp;gt; parameters) {&#xA;      // ...&#xA;    }&#xA;  }).withQueryHandler(new CompositeHandler.QueryHandler () {&#xA;    public QueryResult apply(String sql, List&amp;lt;Parameter&amp;gt; parameters) {&#xA;      // ...&#xA;    }&#xA;  });&#xA;&#xA;// Register prepared handler with expected ID &#39;my-unique-id&#39;&#xA;acolyte.jdbc.Driver.register(&#34;my-unique-id&#34;, handler);&#xA;&#xA;// then when existing code do ...&#xA;Connection con = DriverManager.getConnection(jdbcUrl);&#xA;&#xA;// ... Connection |con| is managed through Acolyte |handler|&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use Acolyte with various JVM test and persistence frameworks (see &lt;a href=&#34;http://acolyte.eu.org/integration/&#34;&gt;Integration guide&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;With &lt;a href=&#34;http://acolyte.eu.org/studio/&#34;&gt;Studio&lt;/a&gt;, you can use data extracted from existing database with Acolyte handler.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Projects using Acolyte:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.playframework.com/&#34;&gt;Play Framework&lt;/a&gt; Anorm (&lt;a href=&#34;https://github.com/playframework/anorm/raw/master/core/src/test/scala/anorm/AnormSpec.scala&#34;&gt;AnormSpec&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/youtube/vitess&#34;&gt;Youtube Vitess&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To share questions, answers &amp;amp; ideas, you can go to the &lt;a href=&#34;https://groups.google.com/forum/#!forum/acolyte-support&#34;&gt;mailing list&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Java 1.6+&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Limited datatype conversions.&lt;/li&gt; &#xA; &lt;li&gt;Binary datatype are not currently supported.&lt;/li&gt; &#xA; &lt;li&gt;Pseudo-support for transaction.&lt;/li&gt; &#xA; &lt;li&gt;Currency types.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Related applications&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://acolyte.eu.org/studio/&#34;&gt;Acolyte Studio&lt;/a&gt;: Application with CLI and GUI which is useful when you already have a database and want tests to use data extracted from there.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://acolyte.eu.org/reactive-mongo/&#34;&gt;Acolyte for ReactiveMongo&lt;/a&gt;. Acolyte module to unit test persistence based on &lt;a href=&#34;http://reactivemongo.org/&#34;&gt;ReactiveMongo&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>