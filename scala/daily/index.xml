<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-21T01:32:27Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>com-lihaoyi/requests-scala</title>
    <updated>2024-05-21T01:32:27Z</updated>
    <id>tag:github.com,2024-05-21:/com-lihaoyi/requests-scala</id>
    <link href="https://github.com/com-lihaoyi/requests-scala" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Scala port of the popular Python Requests HTTP client: flexible, intuitive, and straightforward to use.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Requests-Scala 0.8.2&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/lihaoyi/requests-scala?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/lihaoyi/requests-scala.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/lihaoyi/requests-scala&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Requests-Scala is a Scala port of the popular Python &lt;a href=&#34;http://docs.python-requests.org/&#34;&gt;Requests&lt;/a&gt; HTTP client. Requests-Scala aims to provide the same API and user-experience as the original Requests: flexible, intuitive, and straightforward to use.&lt;/p&gt; &#xA;&lt;p&gt;If you use Requests-Scala and like it, you will probably enjoy the following book by the Author:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.handsonscala.com/&#34;&gt;&lt;em&gt;Hands-on Scala Programming&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;Hands-on Scala&lt;/em&gt; has uses Requests-Scala extensively throughout the book, and has the entirety of &lt;em&gt;Chapter 12: Working with HTTP APIs&lt;/em&gt; dedicated to the library. &lt;em&gt;Hands-on Scala&lt;/em&gt; is a great way to level up your skills in Scala in general and Requests-Scala in particular.&lt;/p&gt; &#xA;&lt;p&gt;You can also support it by donating to our Patreon:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.patreon.com/lihaoyi&#34;&gt;https://www.patreon.com/lihaoyi&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For a hands-on introduction to this library, take a look at the following blog post:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.lihaoyi.com/post/HowtoworkwithHTTPJSONAPIsinScala.html&#34;&gt;How to work with HTTP JSON APIs in Scala&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#requests-scala-081&#34;&gt;Requests-Scala 0.8.2&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#contents&#34;&gt;Contents&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#making-a-request&#34;&gt;Making a Request&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#passing-in-parameters&#34;&gt;Passing in Parameters&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#response-content&#34;&gt;Response Content&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#streaming-requests&#34;&gt;Streaming Requests&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#handling-json&#34;&gt;Handling JSON&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#multipart-uploads&#34;&gt;Multipart Uploads&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#misc-configuration&#34;&gt;Misc Configuration&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#custom-headers&#34;&gt;Custom Headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#timeouts&#34;&gt;Timeouts&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#compression&#34;&gt;Compression&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#cookies&#34;&gt;Cookies&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#redirects&#34;&gt;Redirects&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#client-side-certificates&#34;&gt;Client Side Certificates&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#sessions&#34;&gt;Sessions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#why-requests-scala&#34;&gt;Why Requests-Scala?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#changelog&#34;&gt;Changelog&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#080&#34;&gt;0.8.0&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#071&#34;&gt;0.7.1&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#070&#34;&gt;0.7.0&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#067&#34;&gt;0.6.7&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#065&#34;&gt;0.6.5&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#051&#34;&gt;0.5.1&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#047&#34;&gt;0.4.7&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#030&#34;&gt;0.3.0&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#020&#34;&gt;0.2.0&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#019&#34;&gt;0.1.9&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#018&#34;&gt;0.1.8&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#017&#34;&gt;0.1.7&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#016&#34;&gt;0.1.6&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/com-lihaoyi/requests-scala/master/#015&#34;&gt;0.1.5&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Use the following import to get you started:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;ivy&#34;com.lihaoyi::requests:0.8.2&#34; // mill&#xA;&#34;com.lihaoyi&#34; %% &#34;requests&#34; % &#34;0.8.2&#34; // sbt&#xA;compile &#34;com.lihaoyi:requests_2.12:0.8.2&#34; //gradle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Making a Request&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r = requests.get(&#34;https://api.github.com/users/lihaoyi&#34;)&#xA;&#xA;r.statusCode&#xA;// 200&#xA;&#xA;r.headers(&#34;content-type&#34;)&#xA;// Buffer(&#34;application/json; charset=utf-8&#34;)&#xA;&#xA;r.text&#xA;// {&#34;login&#34;:&#34;lihaoyi&#34;,&#34;id&#34;:934140,&#34;node_id&#34;:&#34;MDQ6VXNlcjkzNDE0MA==&#34;,...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Making your first HTTP request is simple: simply call &lt;code&gt;requests.get&lt;/code&gt; with the URL you want, and requests will fetch it for you.&lt;/p&gt; &#xA;&lt;p&gt;You can also call &lt;code&gt;requests.post&lt;/code&gt;, &lt;code&gt;requests.put&lt;/code&gt;, etc. to make other kinds of HTTP requests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r = requests.post(&#34;http://httpbin.org/post&#34;, data = Map(&#34;key&#34; -&amp;gt; &#34;value&#34;))&#xA;&#xA;val r = requests.put(&#34;http://httpbin.org/put&#34;, data = Map(&#34;key&#34; -&amp;gt; &#34;value&#34;))&#xA;&#xA;val r = requests.delete(&#34;http://httpbin.org/delete&#34;)&#xA;&#xA;val r = requests.head(&#34;http://httpbin.org/head&#34;)&#xA;&#xA;val r = requests.options(&#34;http://httpbin.org/get&#34;)&#xA;&#xA;// dynamically choose what HTTP method to use&#xA;val r = requests.send(&#34;put&#34;)(&#34;http://httpbin.org/put&#34;, data = Map(&#34;key&#34; -&amp;gt; &#34;value&#34;))&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Passing in Parameters&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r = requests.get(&#xA;    &#34;http://httpbin.org/get&#34;,&#xA;    params = Map(&#34;key1&#34; -&amp;gt; &#34;value1&#34;, &#34;key2&#34; -&amp;gt; &#34;value2&#34;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can pass in URL parameters to GET requests via the &lt;code&gt;params&lt;/code&gt; argument; simply pass in a &lt;code&gt;Map[String, String]&lt;/code&gt;. As seen earlier, when passing in POST or PUT parameters, you instead need the &lt;code&gt;data&lt;/code&gt; argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r = requests.post(&#34;http://httpbin.org/post&#34;, data = Map(&#34;key&#34; -&amp;gt; &#34;value&#34;))&#xA;&#xA;val r = requests.put(&#34;http://httpbin.org/put&#34;, data = Map(&#34;key&#34; -&amp;gt; &#34;value&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Apart from POSTing key-value pairs, you can also POST &lt;code&gt;String&lt;/code&gt;s, &lt;code&gt;Array[Byte]&lt;/code&gt;s, &lt;code&gt;java.io.File&lt;/code&gt;s, &lt;code&gt;java.nio.file.Path&lt;/code&gt;s, and &lt;code&gt;requests.MultiPart&lt;/code&gt; uploads:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.post(&#34;https://httpbin.org/post&#34;, data = &#34;Hello World&#34;)&#xA;requests.post(&#34;https://httpbin.org/post&#34;, data = Array[Byte](1, 2, 3))&#xA;requests.post(&#34;https://httpbin.org/post&#34;, data = new java.io.File(&#34;thing.json&#34;))&#xA;requests.post(&#34;https://httpbin.org/post&#34;, data = java.nio.file.Paths.get(&#34;thing.json&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;data&lt;/code&gt; parameter also supports anything that implements the &lt;a href=&#34;https://github.com/com-lihaoyi/geny#writable&#34;&gt;Writable&lt;/a&gt; interface, such as &lt;a href=&#34;http://com-lihaoyi.github.io/upickle/#uJson&#34;&gt;ujson.Value&lt;/a&gt;s, &lt;a href=&#34;http://com-lihaoyi.github.io/upickle&#34;&gt;uPickle&lt;/a&gt;&#39;s &lt;code&gt;upickle.default.writable&lt;/code&gt; values, or &lt;a href=&#34;http://com-lihaoyi.github.io/scalatags/&#34;&gt;Scalatags&lt;/a&gt;&#39;s &lt;code&gt;Tag&lt;/code&gt;s&lt;/p&gt; &#xA;&lt;h3&gt;Response Content&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r = requests.get(&#34;https://api.github.com/events&#34;)&#xA;&#xA;r.statusCode&#xA;// 200&#xA;&#xA;r.headers(&#34;content-type&#34;)&#xA;// Buffer(&#34;application/json; charset=utf-8&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As seen earlier, you can use &lt;code&gt;.statusCode&lt;/code&gt; and &lt;code&gt;.headers&lt;/code&gt; to see the relevant metadata of your HTTP response. The response data is in the &lt;code&gt;.data&lt;/code&gt; field of the &lt;code&gt;Response&lt;/code&gt; object. Most often, it&#39;s text, which you can decode using the &lt;code&gt;.text&lt;/code&gt; property as shown below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;r.text&#xA;// [{&#34;id&#34;:&#34;7990061484&#34;,&#34;type&#34;:&#34;PushEvent&#34;,&#34;actor&#34;:{&#34;id&#34;:6242317,&#34;login&#34;:...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want the raw bytes of the response, use &lt;code&gt;r.contents&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;r.contents&#xA;// Array(91, 123, 34, 105, 100, 34, 58, 34, 55, 57,  57, 48, 48, 54, 49, ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Streaming Requests&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;os.write(&#xA;  os.pwd / &#34;file.json&#34;,&#xA;  requests.get.stream(&#34;https://api.github.com/events&#34;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Requests exposes the &lt;code&gt;requests.get.stream&lt;/code&gt; (and equivalent &lt;code&gt;requests.post.stream&lt;/code&gt;, &lt;code&gt;requests.put.stream&lt;/code&gt;, etc.) functions for you to perform streaming uploads/downloads without needing to load the entire request/response into memory. This is useful if you are upload/downloading large files or data blobs. &lt;code&gt;.stream&lt;/code&gt; returns a &lt;a href=&#34;https://github.com/com-lihaoyi/geny#readable&#34;&gt;Readable&lt;/a&gt; value, that can be then passed to methods like &lt;a href=&#34;https://github.com/com-lihaoyi/os-lib#oswrite&#34;&gt;os.write&lt;/a&gt;, &lt;code&gt;fastparse.parse&lt;/code&gt; or &lt;code&gt;upickle.default.read&lt;/code&gt; to handle the received data in a streaming fashion:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;ujson.read(requests.get.stream(&#34;https://api.github.com/events&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since &lt;code&gt;requests.post&lt;/code&gt; and &lt;code&gt;requests.put&lt;/code&gt; both take a &lt;code&gt;data: geny.Writable&lt;/code&gt; parameter, you can even chain requests together, taking the data returned from one HTTP request and feeding it into another:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;os.write(&#xA;  os.pwd / &#34;chained.json&#34;,&#xA;  requests.post.stream(&#xA;    &#34;https://httpbin.org/post&#34;,&#xA;    data = requests.get.stream(&#34;https://api.github.com/events&#34;)&#xA;  )&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;requests.*.stream&lt;/code&gt; should make it easy for you to work with data too big to fit in memory, while still benefiting from most of Requests&#39; friendly &amp;amp; intuitive API.&lt;/p&gt; &#xA;&lt;h2&gt;Handling JSON&lt;/h2&gt; &#xA;&lt;p&gt;Requests does not provide any built-in JSON support, but you can easily use a third-party JSON library to work with it. This example shows how to use &lt;a href=&#34;https://com-lihaoyi.github.io/upickle/&#34;&gt;uJson&lt;/a&gt; talk to a HTTP endpoint that requires a JSON-formatted body, either using &lt;code&gt;upickle.default.stream&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.post(&#xA;  &#34;https://api.github.com/some/endpoint&#34;,&#xA;  data = upickle.default.stream(Map(&#34;user-agent&#34; -&amp;gt; &#34;my-app/0.0.1&#34;))&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or by constructing &lt;code&gt;ujson.Value&lt;/code&gt;s directly&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.post(&#xA;  &#34;https://api.github.com/some/endpoint&#34;,&#xA;  data = ujson.Obj(&#34;user-agent&#34; -&amp;gt; &#34;my-app/0.0.1&#34;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In both cases, the upload occurs efficiently in a streaming fashion, without materializing the entire JSON blob in memory.&lt;/p&gt; &#xA;&lt;p&gt;It is equally easy ot use uJson to deal with JSON returned in the response from the server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r = requests.get(&#34;https://api.github.com/events&#34;)&#xA;&#xA;val json = ujson.read(r.text)&#xA;&#xA;json.arr.length&#xA;// 30&#xA;&#xA;json.arr(0).obj.keys&#xA;// Set(&#34;id&#34;, &#34;type&#34;, &#34;actor&#34;, &#34;repo&#34;, &#34;payload&#34;, &#34;public&#34;, &#34;created_at&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While Requests-Scala doesn&#39;t come bundled with JSON functionality, it is trivial to use it together with any other 3rd party JSON library (I like &lt;a href=&#34;https://github.com/com-lihaoyi/upickle&#34;&gt;uJson&lt;/a&gt;) So just pick whatever library you want.&lt;/p&gt; &#xA;&lt;h2&gt;Multipart Uploads&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r = requests.post(&#xA;  &#34;http://httpbin.org/post&#34;,&#xA;  data = requests.MultiPart(&#xA;    requests.MultiItem(&#34;name&#34;, new java.io.File(&#34;build.sc&#34;), &#34;file.txt&#34;),&#xA;    // you can upload strings, and file name is optional&#xA;    requests.MultiItem(&#34;name2&#34;, &#34;Hello&#34;),&#xA;    // bytes arrays are ok too&#xA;    requests.MultiItem(&#34;name3&#34;, Array[Byte](1, 2, 3, 4))&#xA;  )&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Multipart uploads are done by passing &lt;code&gt;requests.MultiPart&lt;/code&gt;/&lt;code&gt;requests.MultiItem&lt;/code&gt; to the &lt;code&gt;data&lt;/code&gt; parameter. Each &lt;code&gt;MultiItem&lt;/code&gt; needs a name and a data-source, which can be a &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Array[Byte]&lt;/code&gt;, &lt;code&gt;java.io.File&lt;/code&gt;, or &lt;code&gt;java.nio.file.Path&lt;/code&gt;. Each &lt;code&gt;MultiItem&lt;/code&gt; can optionally take a file name that will get sent to the server&lt;/p&gt; &#xA;&lt;h2&gt;Misc Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Earlier you already saw how to use the &lt;code&gt;params&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt; arguments. Apart from those, the &lt;code&gt;requests.get&lt;/code&gt; method takes in a lot of arguments you can use to configure it, e.g. passing in custom headers:&lt;/p&gt; &#xA;&lt;h3&gt;Custom Headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.get(&#xA;  &#34;https://api.github.com/some/endpoint&#34;,&#xA;  headers = Map(&#34;user-agent&#34; -&amp;gt; &#34;my-app/0.0.1&#34;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Timeouts&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;readTimeout&lt;/code&gt;s and &lt;code&gt;connectTimeout&lt;/code&gt;s:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.get(&#34;https://httpbin.org/delay/1&#34;, readTimeout = 10)&#xA;// TimeoutException&#xA;&#xA;requests.get(&#34;https://httpbin.org/delay/1&#34;, readTimeout = 1500)&#xA;// ok&#xA;&#xA;requests.get(&#34;https://httpbin.org/delay/3&#34;, readTimeout = 1500)&#xA;// TimeoutException&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.get(&#34;https://httpbin.org/delay/1&#34;, connectTimeout = 10)&#xA;// TimeoutException&#xA;&#xA;requests.get(&#34;https://httpbin.org/delay/1&#34;, connectTimeout = 1500)&#xA;// ok&#xA;&#xA;requests.get(&#34;https://httpbin.org/delay/3&#34;, connectTimeout = 1500)&#xA;// ok&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compression&lt;/h3&gt; &#xA;&lt;p&gt;Configuration for compressing the request &lt;code&gt;data&lt;/code&gt; upload with Gzip or Deflate via the &lt;code&gt;compress&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.post(&#xA;  &#34;https://httpbin.org/post&#34;,&#xA;  compress = requests.Compress.None,&#xA;  data = &#34;Hello World&#34;&#xA;)&#xA;&#xA;requests.post(&#xA;  &#34;https://httpbin.org/post&#34;,&#xA;  compress = requests.Compress.Gzip,&#xA;  data = &#34;I am cow&#34;&#xA;)&#xA;&#xA;requests.post(&#xA;  &#34;https://httpbin.org/post&#34;,&#xA;  compress = requests.Compress.Deflate,&#xA;  data = &#34;Hear me moo&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or to disabling the de-compression of the response &lt;code&gt;data&lt;/code&gt; being downloaded via the &lt;code&gt;autoCompress&lt;/code&gt; parameter, in case you want the un-compressed data blob for whatever reason:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.get(&#34;https://httpbin.org/gzip&#34;).contents.length&#xA;// 250&#xA;&#xA;requests.get(&#34;https://httpbin.org/gzip&#34;, autoDecompress=false).contents.length&#xA;// 201&#xA;&#xA;&#xA;requests.get(&#34;https://httpbin.org/deflate&#34;).contents.length&#xA;// 251&#xA;&#xA;requests.get(&#34;https://httpbin.org/deflate&#34;, autoDecompress=false).contents.length&#xA;// 188&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that by default, compression of fixed-size in-memory input (&lt;code&gt;String&lt;/code&gt;s, &lt;code&gt;Array[Byte]&lt;/code&gt;s, ...) buffers up the compressed data in memory before uploading it. Compression of unknown-length/not-in-memory data (files, &lt;code&gt;InputStream&lt;/code&gt;s, ...) doesn&#39;t perform this buffering and uses chunked transfer encoding, as normal. If you want to avoid buffering in memory and are willing to use chunked transfer encoding for in-memory data, wrap it in an inputstream (e.g. &lt;code&gt;Array[Byte]&lt;/code&gt; can be wrapped in a &lt;code&gt;ByteArrayInputStream&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;h3&gt;Cookies&lt;/h3&gt; &#xA;&lt;p&gt;You can take the cookies that result from one HTTP request and pass them into a subsequent HTTP request:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r = requests.get(&#34;https://httpbin.org/cookies/set?freeform=test&#34;)&#xA;&#xA;r.cookies&#xA;// Map(&#34;freeform&#34; -&amp;gt; freeform=test)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&#xA;val r2 = requests.get(&#34;https://httpbin.org/cookies&#34;, cookies = r.cookies)&#xA;&#xA;r2.text&#xA;// {&#34;cookies&#34;:{&#34;freeform&#34;:&#34;test&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is a common pattern, e.g. to maintain an authentication/login session across multiple requests. However, it may be easier to instead use Sessions...&lt;/p&gt; &#xA;&lt;h3&gt;Redirects&lt;/h3&gt; &#xA;&lt;p&gt;Requests handles redirects automatically for you, up to a point:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r = requests.get(&#34;http://www.github.com&#34;)&#xA;&#xA;r.url&#xA;// https://github.com/&#xA;&#xA;r.history&#xA;// Some(Response(&#34;https://www.github.com&#34;, 301, &#34;Moved Permanently&#34;, ...&#xA;&#xA;r.history.get.history&#xA;// Some(Response(&#34;http://www.github.com&#34;, 301, &#34;Moved Permanently&#34;, ...&#xA;&#xA;r.history.get.history.get.history&#xA;// None&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, the request to &lt;code&gt;http://www.github.com&lt;/code&gt; was first redirected to &lt;code&gt;https://www.github.com&lt;/code&gt;, and then to &lt;code&gt;https://github.com/&lt;/code&gt;. Requests by default only follows up to 5 redirects in a row, though this is configurable via the &lt;code&gt;maxRedirects&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r0 = requests.get(&#34;http://www.github.com&#34;, maxRedirects = 0)&#xA;// Response(&#34;http://www.github.com&#34;, 301, &#34;Moved Permanently&#34;, ...&#xA;&#xA;r0.history&#xA;// None&#xA;&#xA;val r1 = requests.get(&#34;http://www.github.com&#34;, maxRedirects = 1)&#xA;// Response(&#34;http://www.github.com&#34;, 301, &#34;Moved Permanently&#34;, ...&#xA;&#xA;r1.history&#xA;// Some(Response(&#34;http://www.github.com&#34;, 301, &#34;Moved Permanently&#34;, ...&#xA;&#xA;r1.history.get.history&#xA;// None&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, you can use &lt;code&gt;maxRedirects = 0&lt;/code&gt; to disable redirect handling completely, or use another number to control how many redirects Requests follows before giving up.&lt;/p&gt; &#xA;&lt;p&gt;All of the intermediate responses in a redirect chain are available in a Response&#39;s &lt;code&gt;.history&lt;/code&gt; field; each &lt;code&gt;.history&lt;/code&gt; points 1 response earlier, forming a linked list of &lt;code&gt;Response&lt;/code&gt; objects until the earliest response has a value of &lt;code&gt;None&lt;/code&gt;. You can crawl up this linked list if you want to inspect the headers or other metadata of the intermediate redirects that brought you to your final value.&lt;/p&gt; &#xA;&lt;h3&gt;Client Side Certificates&lt;/h3&gt; &#xA;&lt;p&gt;To use client certificate you need a PKCS 12 archive with private key and certificate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.get(&#xA;  &#34;https://client.badssl.com&#34;,&#xA;  cert = &#34;./badssl.com-client.p12&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the p12 archive is password protected you can provide a second parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.get(&#xA;  &#34;https://client.badssl.com&#34;,&#xA;  cert = (&#34;./badssl.com-client.p12&#34;, &#34;password&#34;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For test environments you may want to combine &lt;code&gt;cert&lt;/code&gt; with the &lt;code&gt;verifySslCerts = false&lt;/code&gt; option (if you have self signed SSL certificates on test servers).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;requests.get(&#xA;  &#34;https://client.badssl.com&#34;,&#xA;  cert = (&#34;./badssl.com-client.p12&#34;, &#34;password&#34;),&#xA;  verifySslCerts = false&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use a sslContext to provide a more customized ssl configuration&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val sslContext: SSLContext = //initialized sslContext&#xA;&#xA;requests.get(&#xA;  &#34;https://client.badssl.com&#34;,&#xA;  sslcontext = sslContext&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sessions&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;code&gt;requests.Session&lt;/code&gt; automatically handles sending/receiving/persisting cookies for you across multiple requests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val s = requests.Session()&#xA;&#xA;val r = s.get(&#34;https://httpbin.org/cookies/set?freeform=test&#34;)&#xA;&#xA;val r2 = s.get(&#34;https://httpbin.org/cookies&#34;)&#xA;&#xA;r2.text&#xA;// {&#34;cookies&#34;:{&#34;freeform&#34;:&#34;test&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to deal with a website that uses cookies, it&#39;s usually easier to use a &lt;code&gt;requests.Session&lt;/code&gt; rather than passing around &lt;code&gt;cookie&lt;/code&gt; variables manually.&lt;/p&gt; &#xA;&lt;p&gt;Apart from persisting cookies, sessions are also useful for consolidating common configuration that you want to use across multiple requests, e.g. custom headers, cookies or other things:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val s = requests.Session(&#xA;  headers = Map(&#34;x-special-header&#34; -&amp;gt; &#34;omg&#34;),&#xA;  cookieValues = Map(&#34;cookie&#34; -&amp;gt; &#34;vanilla&#34;)&#xA;)&#xA;&#xA;val r1 = s.get(&#34;https://httpbin.org/cookies&#34;)&#xA;&#xA;r1.text&#xA;// {&#34;cookies&#34;:{&#34;cookie&#34;:&#34;vanilla&#34;}}&#xA;&#xA;val r2 = s.get(&#34;https://httpbin.org/headers&#34;)&#xA;&#xA;r2.text&#xA;// {&#34;headers&#34;:{&#34;X-Special-Header&#34;:&#34;omg&#34;, ...}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why Requests-Scala?&lt;/h2&gt; &#xA;&lt;p&gt;There is a whole zoo of HTTP clients in the Scala ecosystem. Akka-http, Play-WS, STTP, HTTP4S, Scalaj-HTTP, RosHTTP, Dispatch. Nevertheless, none of them come close to the ease and weightlessness of using Kenneth Reitz&#39;s &lt;a href=&#34;https://requests.readthedocs.io/en/latest/&#34;&gt;Requests&lt;/a&gt; library: too many implicits, operators, builders, monads, and other things.&lt;/p&gt; &#xA;&lt;p&gt;When I want to make a HTTP request, I do not want to know about &lt;code&gt;.unsafeRunSync&lt;/code&gt;, infix methods like &lt;code&gt;svc OK as.String&lt;/code&gt;, or define implicit &lt;code&gt;ActorSystem&lt;/code&gt;s, &lt;code&gt;ActorMaterializer&lt;/code&gt;s, and &lt;code&gt;ExecutionContext&lt;/code&gt;s. So far &lt;a href=&#34;https://github.com/softwaremill/sttp&#34;&gt;sttp&lt;/a&gt; and &lt;a href=&#34;https://github.com/scalaj/scalaj-http&#34;&gt;scalaj-http&lt;/a&gt; come closest to what I want, but still fall short: both still use a pattern of fluent builders that to me doesn&#39;t fit how I think when making a HTTP request. I just want to call one function to make a HTTP request, and get back my HTTP response.&lt;/p&gt; &#xA;&lt;p&gt;Most people will never reach the scale that asynchrony matters, and most of those who do reach that scale will only need it in a small number of specialized places, not everywhere.&lt;/p&gt; &#xA;&lt;p&gt;Compare the getting-started code necessary for Requests-Scala against some other common Scala HTTP clients:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Requests-Scala&#xA;val r = requests.get(&#xA;  &#34;https://api.github.com/search/repositories&#34;,&#xA;  params = Map(&#34;q&#34; -&amp;gt; &#34;http language:scala&#34;, &#34;sort&#34; -&amp;gt; &#34;stars&#34;)&#xA;)&#xA;&#xA;r.text&#xA;// {&#34;login&#34;:&#34;lihaoyi&#34;,&#34;id&#34;:934140,&#34;node_id&#34;:&#34;MDQ6VXNlcjkzNDE0MA==&#34;,...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Akka-Http&#xA;import akka.actor.ActorSystem&#xA;import akka.http.scaladsl.Http&#xA;import akka.http.scaladsl.model._&#xA;import akka.stream.ActorMaterializer&#xA;&#xA;import scala.concurrent.Future&#xA;import scala.util.{ Failure, Success }&#xA;&#xA;implicit val system = ActorSystem()&#xA;implicit val materializer = ActorMaterializer()&#xA;// needed for the future flatMap/onComplete in the end&#xA;implicit val executionContext = system.dispatcher&#xA;&#xA;val responseFuture: Future[HttpResponse] = Http().singleRequest(HttpRequest(uri = &#34;http://akka.io&#34;))&#xA;&#xA;responseFuture&#xA;  .onComplete {&#xA;    case Success(res) =&amp;gt; println(res)&#xA;    case Failure(_)   =&amp;gt; sys.error(&#34;something wrong&#34;)&#xA;  }&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Play-WS&#xA;&#xA;import akka.actor.ActorSystem&#xA;import akka.stream.ActorMaterializer&#xA;import play.api.libs.ws._&#xA;import play.api.libs.ws.ahc._&#xA;&#xA;import scala.concurrent.Future&#xA;&#xA;import DefaultBodyReadables._&#xA;import scala.concurrent.ExecutionContext.Implicits._&#xA;&#xA;// Create Akka system for thread and streaming management&#xA;implicit val system = ActorSystem()&#xA;implicit val materializer = ActorMaterializer()&#xA;&#xA;// Create the standalone WS client&#xA;// no argument defaults to a AhcWSClientConfig created from&#xA;// &#34;AhcWSClientConfigFactory.forConfig(ConfigFactory.load, this.getClass.getClassLoader)&#34;&#xA;val wsClient = StandaloneAhcWSClient()&#xA;&#xA;wsClient.url(&#34;http://www.google.com&#34;).get()&#xA;  .map { response ⇒&#xA;    val statusText: String = response.statusText&#xA;    val body = response.body[String]&#xA;    println(s&#34;Got a response $statusText&#34;)&#xA;  }.&#xA;  andThen { case _ =&amp;gt; wsClient.close() }&#xA;  andThen { case _ =&amp;gt; system.terminate() }&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Http4s&#xA;import org.http4s.client.dsl.io._&#xA;import org.http4s.headers._&#xA;import org.http4s.MediaType&#xA;&#xA;val request = GET(&#xA;  Uri.uri(&#34;https://my-lovely-api.com/&#34;),&#xA;  Authorization(Credentials.Token(AuthScheme.Bearer, &#34;open sesame&#34;)),&#xA;  Accept(MediaType.application.json)&#xA;)&#xA;&#xA;httpClient.expect[String](request)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// sttp&#xA;import sttp.client3._&#xA;&#xA;val request = basicRequest.response(asStringAlways)&#xA;  .get(uri&#34;https://api.github.com/search&#34;&#xA;    .addParams(Map(&#34;q&#34; -&amp;gt; &#34;http language:scala&#34;, &#34;sort&#34; -&amp;gt; &#34;stars&#34;)))&#xA;&#xA;val backend = HttpURLConnectionBackend()&#xA;val response = backend.send(request)&#xA;&#xA;println(response.body)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Dispatch&#xA;import dispatch._, Defaults._&#xA;val svc = url(&#34;http://api.hostip.info/country.php&#34;)&#xA;val country = Http.default(svc OK as.String)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The existing clients require a complex mix of imports, implicits, operators, and DSLs. The goal of Requests-Scala is to do away with all of that: your HTTP request is just a function call that takes parameters; that is all you need to know.&lt;/p&gt; &#xA;&lt;p&gt;As it turns out, Kenneth Reitz&#39;s Requests is &lt;a href=&#34;https://github.com/requests/requests/tree/main/requests&#34;&gt;not a lot of code&lt;/a&gt;. Most of the heavy lifting is done in other libraries, and his library is a just thin-shim that makes the API 10x better. It turns out on the JVM most of the heavy lifting is also done for you, by &lt;code&gt;java.net.HttpUrlConnection&lt;/code&gt; in the simplest case, and other libraries like &lt;a href=&#34;https://github.com/AsyncHttpClient/async-http-client&#34;&gt;AsyncHttpClient&lt;/a&gt; for more advanced use cases.&lt;/p&gt; &#xA;&lt;p&gt;Given that&#39;s the case, how hard can it be to port over a dozen Python files to Scala? This library attempts to do that: class by class, method by method, keyword-argument by keyword-argument. Not everything has been implemented yet, some things differ (some avoidably, some unavoidably), and it&#39;s nowhere near as polished, but you should definitely try it out as the HTTP client for your next codebase or project!&lt;/p&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;h3&gt;0.8.2&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;fix: content type header not present in multipart item (&lt;a href=&#34;https://github.com/com-lihaoyi/requests-scala/pull/154&#34;&gt;#154&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.8.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update Geny to 1.0.0 &lt;a href=&#34;https://github.com/com-lihaoyi/requests-scala/pull/120&#34;&gt;#120&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.7.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fix issue with data buffers not being flushed when compression is enabled &lt;a href=&#34;https://github.com/com-lihaoyi/requests-scala/pull/108&#34;&gt;#108&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.7.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Allow &lt;code&gt;requests.send(method)(...)&lt;/code&gt; to dynamically choose a HTTP method &lt;a href=&#34;https://github.com/com-lihaoyi/requests-scala/pull/94&#34;&gt;#94&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Avoid crashing on gzipped HEAD requests &lt;a href=&#34;https://github.com/com-lihaoyi/requests-scala/pull/95&#34;&gt;#95&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;All exceptions now inherit from a &lt;code&gt;RequestsException&lt;/code&gt; base class&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.6.7&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add support for Scala 3.0.0-RC2&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.6.5&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;requests.Response&lt;/code&gt; now implements the &lt;code&gt;geny.Readable&lt;/code&gt; interface, and can be directly passed to compatible APIs like &lt;code&gt;ujson.read&lt;/code&gt; or &lt;code&gt;os.write&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add support for custom SSL certs&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Allow body content for DELETE requests&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.5.1&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Made &lt;code&gt;requests.{get,post,put,delete,head,options,patch}.stream&lt;/code&gt; return a &lt;a href=&#34;https://github.com/lihaoyi/geny#readable&#34;&gt;Readable&lt;/a&gt;, allowing upickle and fastparse to operate directly on the streaming input&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.4.7&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;requests.{get,post,put,delete,head,options,patch}&lt;/code&gt; now throw a &lt;code&gt;requests.RequestFailedException(val response: Response)&lt;/code&gt; if a non-2xx status code is received. You can disable throwing the exception by passing in &lt;code&gt;check = false&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;requests.{get,post,put,delete,head,options,patch}.stream&lt;/code&gt; now returns a &lt;a href=&#34;https://github.com/lihaoyi/geny#writable&#34;&gt;Writable&lt;/a&gt; instead of taking callbacks.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.3.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for uploading &lt;a href=&#34;https://github.com/lihaoyi/geny#writable&#34;&gt;geny.Writable&lt;/a&gt; data types in request bodies.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.2.0&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for Scala 2.13.0 final&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.1.9&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support &lt;code&gt;PATCH&lt;/code&gt; and other verbs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.1.8&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for &lt;code&gt;Bearer&lt;/code&gt; token auth&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.1.7&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;RequestBlob&lt;/code&gt; headers no longer over-write session headers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.1.6&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Allow POSTs to take URL parameters&lt;/li&gt; &#xA; &lt;li&gt;Return response body for all 2xx response codes&lt;/li&gt; &#xA; &lt;li&gt;Always set &lt;code&gt;Content-Length&lt;/code&gt; to 0 when request body is empty&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;0.1.5&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First Release&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>rcardin/sus4s</title>
    <updated>2024-05-21T01:32:27Z</updated>
    <id>tag:github.com,2024-05-21:/rcardin/sus4s</id>
    <link href="https://github.com/rcardin/sus4s" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Direct-Style Scala Wrapper Around the Structural Concurrency of Project Loom&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/rcardin/sus4s/scala.yml?branch=main&#34; alt=&#34;GitHub Workflow Status (with branch)&#34;&gt; &lt;img src=&#34;https://img.shields.io/maven-central/v/in.rcard.sus4s/core_3&#34; alt=&#34;Maven Central&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/rcardin/sus4s&#34; alt=&#34;GitHub release (latest by date)&#34;&gt; &lt;a href=&#34;https://javadoc.io/doc/in.rcard.sus4s/core_3&#34;&gt;&lt;img src=&#34;https://javadoc.io/badge2/in.rcard.sus4s/core_3/javadoc.svg?sanitize=true&#34; alt=&#34;javadoc&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;sus4s 🎸🎶&lt;/h1&gt; &#xA;&lt;p&gt;A Direct-Style Scala Wrapper Around the Structural Concurrency of Project Loom&lt;/p&gt; &#xA;&lt;h2&gt;Dependency&lt;/h2&gt; &#xA;&lt;p&gt;The library is available on Maven Central. To use it, add the following dependency to your &lt;code&gt;build.sbt&lt;/code&gt; files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sbt&#34;&gt;libraryDependencies += &#34;in.rcard.sus4s&#34; %% &#34;core&#34; % &#34;0.0.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The library is only available for Scala 3.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The library provides a direct-style API for the structured concurrency of Project Loom. The library requires JDK 21 and Scala 3. Moreover, Java preview features must be enabled in the Scala compiler.&lt;/p&gt; &#xA;&lt;p&gt;The main entry point is the &lt;code&gt;sus4s&lt;/code&gt; package object. The following code snippet shows how to use the library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.sus4s.sus4s.*&#xA;&#xA;val result: Int = structured {&#xA;  val job1: Job[Int] = fork {&#xA;    Thread.sleep(1000)&#xA;    42&#xA;  }&#xA;  val job2: Job[Int] = fork {&#xA;    Thread.sleep(500)&#xA;    43&#xA;  }&#xA;  job1.value + job2.value&#xA;}&#xA;println(result) // 85&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;structured&lt;/code&gt; method creates a new structured concurrency scope represented by the &lt;code&gt;Suspend&lt;/code&gt; trait. It&#39;s built on top of the &lt;code&gt;java.util.concurrent.StructuredTaskScope&lt;/code&gt; class. Hence, the threads forked inside the &lt;code&gt;structured&lt;/code&gt; block are Java Virtual Threads.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;fork&lt;/code&gt; method creates a new Java Virtual Thread that executes the given block of code. The &lt;code&gt;fork&lt;/code&gt; method executes functions declared with the capability of suspend:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findUserById(id: UserId): Suspend ?=&amp;gt; User&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Coloring a function with the &lt;code&gt;Suspend&lt;/code&gt; capability tells the caller that the function performs a suspendable operation, aka some effect. Suspension is managed by the Loom runtime, which is responsible for scheduling the virtual threads.&lt;/p&gt; &#xA;&lt;p&gt;A type alias is available for the &lt;code&gt;Suspend&lt;/code&gt; capability:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type Suspended[A] = Suspend ?=&amp;gt; A&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So, the above function can be rewritten as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findUserById(id: UserId): Suspended[User]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Forking a suspendable function means creating a new virtual thread that executes the function. The thread is represented by the &lt;code&gt;Job&lt;/code&gt; class. The &lt;code&gt;Job&lt;/code&gt; class provides the &lt;code&gt;value&lt;/code&gt; method that waits for the completion of the virtual thread and returns the result of the function.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;structured&lt;/code&gt; function uses structured concurrency to run the suspendable tasks. In detail, it ensures that the thread executing the block waits for the completion of all the forked tasks. The structured blocks terminates when:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;all the forked tasks complete successfully&lt;/li&gt; &#xA; &lt;li&gt;one of the forked tasks throws an exception&lt;/li&gt; &#xA; &lt;li&gt;the block throws an exception&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;structured&lt;/code&gt; function is completely transparent to any exception thrown by the block or by any of the forked tasks.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you want to contribute to the project, please do it! Any help is welcome.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;This project is inspired by the &lt;a href=&#34;https://github.com/softwaremill/ox&#34;&gt;Ox&lt;/a&gt; and the &lt;a href=&#34;https://github.com/xebia-functional/Unwrapped&#34;&gt;Unwrapped&lt;/a&gt; libraries.&lt;/p&gt;</summary>
  </entry>
</feed>