<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-07T01:43:59Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hyperledger-labs/splice</title>
    <updated>2025-04-07T01:43:59Z</updated>
    <id>tag:github.com,2025-04-07:/hyperledger-labs/splice</id>
    <link href="https://github.com/hyperledger-labs/splice" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Reference applications for funding, operating, and incentivizing the use of a decentralized, public Canton synchronizer. Includes the Amulet reference application for creating native payment utilities for Canton synchronizers and Daml applications.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Splice&lt;/h1&gt; &#xA;&lt;h1&gt;Short Description&lt;/h1&gt; &#xA;&lt;p&gt;Reference applications for funding, operating, and incentivizing the use of a decentralized, public Canton synchronizer. Includes the Amulet reference application for creating native payment utilities for Canton synchronizers and Daml applications.&lt;/p&gt; &#xA;&lt;h1&gt;Scope of Lab&lt;/h1&gt; &#xA;&lt;h2&gt;Abstract&lt;/h2&gt; &#xA;&lt;p&gt;Splice is a set of reference applications designed to allow entities to operate, fund, and govern publicly available decentralized Canton synchronizers that provide connectivity and interoperability infrastructure for the Canton Network, as well as to provide bootstrapping rewards and incentives to early users of that service. The Canton Network is the set of all applications, built using the Daml blockchain application platform, that form shared blockchain state via the Canton Protocol.&lt;/p&gt; &#xA;&lt;p&gt;Splice introduces a reference method for operating a publicly available decentralized Canton synchronizer. Each node in the decentralized synchronizer is operated by an entity known in Splice as a &#34;Super Validator&#34;. Splice refers to a group of Super Validators actively operating nodes in a decentralized synchronizer at any point in time as the &#34;decentralized synchronizer operator&#34; (dso). The Splice code uses a code construct called a &#34;decentralized synchronizer operator party&#34; (dso party) to accumulate signatures from and take actions on behalf of the currently-active set of Super Validators.&lt;/p&gt; &#xA;&lt;p&gt;Splice aims to help Super Validator operating groups create a transparent economic ecosystem that will, over time, fund operations of and extensions to multiple public synchronization services in the Canton Network.&lt;/p&gt; &#xA;&lt;h2&gt;Context&lt;/h2&gt; &#xA;&lt;p&gt;Daml is a platform built by Digital Asset designed for deploying blockchains and developing blockchain applications. It includes a smart contract language, a set of APIs for calling smart contract code, a transaction processing engine, a query-optimized database for accessing smart contract state, and development tooling including an SDK. The open source and enterprise distributions of Daml also include a blockchain protocol, Canton, that creates synchronized state among nodes running the Daml platform.&lt;/p&gt; &#xA;&lt;p&gt;The Canton blockchain guarantees secure state synchronization between participant nodes by running a per-transaction consensus protocol using encrypted messages through a synchronization infrastructure called synchronizers (or sometimes synchronization domains). Synchronizers serve three functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;guaranteeing consistent message order and timestamps among stakeholders;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;guaranteeing delivery of messages to the stakeholders; and&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;aggregating validation confirmations from stakeholders that the proposed transactions use valid inputs and produce valid outputs.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Together these allow ordered, two-phase atomic transaction processing, with confirmation of transaction validation and transaction commits. Canton does this while keeping data private to the stakeholders in each transaction.&lt;/p&gt; &#xA;&lt;p&gt;Daml applications may choose any Canton synchronizer on a per-transaction basis to help them advance the shared blockchain state that forms on the participant nodes. The collection of all Daml applications that synchronize their state via the Canton protocol, and the set of Canton synchronizers they use to do this, together form the Canton Network.&lt;/p&gt; &#xA;&lt;p&gt;Operating groups may charge a fee for traffic that uses their synchronizer. The fee may be metered in USD per megabyte, and levied via an on-chain payment utility. This utility is an implementation of the Splice reference application called Amulet.&lt;/p&gt; &#xA;&lt;p&gt;The Amulet reference application specifies how to implement on-chain payments using “amulets” which represent the ability to pay an operating group to synchronize a transaction with a payload of a given size. Together with the full suite of Splice applications, amulets allow a group of entities to deploy, operate, fund, and govern a decentralized Canton synchronizer, and incentivize application developers and their customers to use that synchronizer to create blockchain state among their nodes. Each operating group configures an Amulet implementation to charge for use of the synchronizer, and distribute their own named version of amulets as rewards to incentivize early use of the service.&lt;/p&gt; &#xA;&lt;p&gt;To provide a mapping between the value of its specific amulet and fiat currencies, the synchronizer operating group may use tooling included in Splice to jointly vote on a fee rate in megabytes per USD, and a nominal conversion rate between USD and the amulet configured by that operating group. This provides a base intrinsic value for the amulet used by the operating group: each amulet represents the value of creating and maintaining high guarantees of synchronized state across multiple computers, for a given data volume of messages shared among those computers. Should a market for that operating group’s amulet develop, the operating group may align the on-ledger price to the market price at its discretion. Synchronizer operating groups can incentivize use of their synchronizer by issuing their amulets to members of the operating group, to application providers, and to Canton participant node operators (“Validators”).&lt;/p&gt; &#xA;&lt;p&gt;Daml applications may choose to use their own, privately operated, Canton synchronizer to create shared state across the Canton participant nodes interacting with those applications, or they may use any shared synchronizer offered by a third party operating group.&lt;/p&gt; &#xA;&lt;h2&gt;Dependent Projects&lt;/h2&gt; &#xA;&lt;p&gt;Splice has grown out of the Daml blockchain ecosystem and its Canton protocol. Open Source versions of Daml are maintained by Digital Asset under an Apache 2.0 License.&lt;/p&gt; &#xA;&lt;p&gt;Splice expands on Daml’s privacy-preserving blockchain technology by providing governance, network bootstrapping and rewards mechanisms as well as payment solutions for any public, decentralized synchronizer built using the Daml blockchain platform. Splice uses the Daml smart contract language to represent the stakeholders and business operations involved in configuring and implementing amulets and the applications that use them. Splice repositories are designed to be deployed in conjunction with Canton synchronizers and participant nodes. Any organization that operates a Canton synchronizer uses the Daml platform in addition to the tooling and applications provided by Splice. This use of the Daml platform could include use of closed-source elements of Daml, at the operating group’s discretion.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Splice aims to create a transparent economic ecosystem that will, over time, fund operations of and extensions to a public synchronization service. Success for Splice would mean that synchronization infrastructure becomes so widely available that any application will be able to use Daml to define a subset of state to be synchronized, distribute Daml code for generating that state to the computers to be synchronized, and use a synchronizer to coordinate creation of that shared state across any set of computers running Daml.&lt;/p&gt; &#xA;&lt;p&gt;For a synchronization infrastructure to be this widely adopted, application developers need to know that they can trust it to operate in a transparent and predictable way, and at a better “price per value” point than comparable integration and synchronization technologies. Application developers and users also need reasons to try out the network before wide adoption creates strong network effects, so Splice includes a system of incentives and fees that reward early adopters.&lt;/p&gt; &#xA;&lt;p&gt;Splice aims to make a high level of trust possible in the following ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Make operations and governance of Canton synchronizers transparent and trackable through built-in governance tooling.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Keep synchronizer transaction costs low via integrated payment, operations monitoring and governance automation, so operating groups can adjust their operations as needed to maintain a stable, long-term service offering.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Manage these tools and applications via an Apache 2.0 license and an open source community within the Hyperledger Foundation.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Splice’s interlocking system of incentives and fees includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Tools for using amulets as a payment utility, including a secure payment redirect feature that allows applications to call an amulet wallet to complete payments with strong security guarantees.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rewards denominated in amulets which strongly incentivize early providers of synchronization infrastructure, application providers who make solutions available in the early stages of the network, and Validator operators, who run blockchain nodes in the early stages of the network.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Traffic acquisition tooling that allows users to purchase access to synchronization infrastructure using amulets.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Handles for amulet users, to make it easy to find counterparties on chain and exchange amulets with them.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;The code that forms Splice was first implemented in June 2023 as part of a TestNet synchronizer operated by the members of an initial set of Super Validators. At that time Splice was a set of applications with various names including Canton Coin and Canton Name Service. The TestNet synchronizer has operated continuously since that time, with regular tests and software upgrades, using the code proposed for Splice to implement its operations, governance and payment applications. In late December 2023, Digital Asset and 46 separate financial institutions demonstrated 30 decentralized application deployments that synchronized roughly 350 financial transactions via the TestNet synchronizer.&lt;/p&gt; &#xA;&lt;p&gt;The group of Super Validators operating this TestNet currently includes Digital Asset and three other organizations, with four additional organizations currently in the process of applying to join.&lt;/p&gt; &#xA;&lt;p&gt;Digital Asset has funded an engineering team to develop the Splice reference applications. Digital Asset is working to build a team of collaborators who can decentralize responsibility for further development as part of the Open Source Software process.&lt;/p&gt; &#xA;&lt;h2&gt;Solution&lt;/h2&gt; &#xA;&lt;p&gt;Splice consists of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Daml models defining the behavior of amulets, including their use as a means of payment for traffic across a decentralized synchronizer, and their use as an incentive mechanism to encourage early adoption of Canton synchronization infrastructure. Amulet behaviors include a minting rate and a burn rate, and various fee mechanisms. These Daml models consist of complex smart contract code written in the Daml language. The minting rate describes a configurable issuance curve over time, while the burn rate consists of several fees paid by destroying (“burning”) amulets to reduce its total supply. Minted amulets are distributed as rewards to synchronizer operating groups, application providers, and Canton participant node operators (“Validators”).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Five reference applications that provide the foundation for configuring and implementing an incentivizing economic ecosystem using amulets. Each application includes Daml models, automation elements and UI components:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;A directory of handles for amulet users called the Name Service&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;An Amulet Wallet for controlling amulets on behalf of a given user, sending and receiving transfers of amulets under the control of that user, handling payment redirects from within applications, and allowing authorized OAuth2 users to interact with wallets under their control.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;A Payment Scan service that collects records of amulet transactions and makes them visible via an API and an application UI.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;A Synchronizer Governance app, which a synchronizer operating group can use for setting fees for its synchronizer, monitoring its operation, setting the nominal price of its amulets in USD, and implementing votes to change governance, operations and the nominal price for its amulet. This app will be accessible to any entity or group that chooses to operate synchronization infrastructure.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;A Traffic Acquisition app, which allows users to purchase traffic across a Canton synchronizer, and configure automatic refills of a desired traffic balance as the user submits transactions via the synchronizer.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Amulet behaviors are controlled by the underlying Daml models. These models can be used to create an on-chain instance of an amulet following the Amulet pattern, but the models do not control actual operations and governance of an on-chain amulet. Actual definition, configuration and governance of operating group-specific amulets takes place by setting configuration variables on these models via governance votes in a specific on-chain context.&lt;/p&gt; &#xA;&lt;p&gt;The Amulet models expose a large number of configuration variables to the Governance app (fifty-five variables in the current version). These allow synchronizer operating groups to use the Governance app to modify minting and burning behaviors, including but not limited to issuance curves, issuance round timing, fees, and rewards. This makes it possible to separate the governance of a particular implementation of the Amulet reference application from development of the Splice code base.&lt;/p&gt; &#xA;&lt;p&gt;We expect that contributors interested in Splice may contribute, for example, extensions to the APIs for the reference applications, including extensions to Amulet Wallet and the Payment Scan; extensions and enhancements to the Synchronizer Governance application; changes to Traffic Acquisition behavior and APIs, and enhanced UI features in the Wallet and the Name Service. These will be accepted based on the Hyperledger Foundation process for open source projects.&lt;/p&gt; &#xA;&lt;p&gt;Any group operating a Canton synchronizer may accept and implement new versions of the Splice reference applications at its own discretion. The amulet configuration used by any Canton synchronizer operating group can be made publicly available (visible) by that operating group.&lt;/p&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;p&gt;The following diagram shows how the Splice applications interact with the Daml platform from Digital Asset.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hyperledger-labs/splice/main/images/Splice-Canton-Decentralized-Synchronizer.jpg&#34; alt=&#34;SV Node Architecture&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Notes:&lt;/h3&gt; &#xA;&lt;p&gt;The Validator module contains the Wallet module and the Traffic Acquisition module.&lt;/p&gt; &#xA;&lt;p&gt;The SV App module contains the Amulet smart contract code and the Amulet configuration variables, as well as the Synchronizer Governance app.&lt;/p&gt; &#xA;&lt;h2&gt;Repository Status&lt;/h2&gt; &#xA;&lt;p&gt;This repository is in the process of being contributed from the private repository of Digital Asset.&lt;/p&gt; &#xA;&lt;p&gt;As of now, it has the following limitations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;No CI or other periodic testing is running directly on this repository. This repository is currently updated daily as a copy of Digital Asset&#39;s &lt;a href=&#34;https://github.com/digital-asset/decentralized-canton-sync&#34;&gt;open source repository&lt;/a&gt;. Over the coming months, we will migrate the CI environment to this repository, and shift our development efforts to be directly against it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The code currently still refers to terms which are either copyrighted by Digital Asset, or otherwise should be removed from this reposotiry, such as Canton and Canton Coin. We are in the process of a thorough renaming, and will complete that over the coming months. Note that this repository will still vendor Canton from its &lt;a href=&#34;https://github.com/digital-asset/canton&#34;&gt;open source repository&lt;/a&gt; as some of its code is reused by the Splice apps for convenience.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>uclid-org/uclid</title>
    <updated>2025-04-07T01:43:59Z</updated>
    <id>tag:github.com,2025-04-07:/uclid-org/uclid</id>
    <link href="https://github.com/uclid-org/uclid" rel="alternate"></link>
    <summary type="html">&lt;p&gt;UCLID5: formal modeling, verification, and synthesis of computational systems&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/uclid-org/uclid&#34;&gt;&lt;img src=&#34;https://travis-ci.org/uclid-org/uclid.svg?branch=master&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/uclid-org/uclid/workflows/Uclid%20CI/badge.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;About&lt;/h1&gt; &#xA;&lt;p&gt;UCLID5 is an integrated modeling, verification and synthesis tool. UCLID5 is an evolution of the earlier UCLID modeling and verification system. The UCLID project was one of the first to develop satisfiability modulo theories (SMT) solvers and SMT-based verification methods. Here is the original UCLID paper that appeared at CAV 2002:&lt;/p&gt; &#xA;&lt;p&gt;Randal E. Bryant, Shuvendu K. Lahiri, and Sanjit A. Seshia. &lt;font color=&#34;blue&#34;&gt;Modeling and Verifying Systems using a Logic of Counter Arithmetic with Lambda Expressions and Uninterpreted Functions.&lt;/font&gt; &lt;a href=&#34;https://people.eecs.berkeley.edu/~sseshia/pubs/b2hd-bryant-cav02.html&#34;&gt;[HTML]&lt;/a&gt; &lt;em&gt;Proceedings of the 14th International Conference on Computer-Aided Verification (CAV)&lt;/em&gt;, pp. 78–92, LNCS 2404, July 2002.&lt;/p&gt; &#xA;&lt;p&gt;If you use UCLID5 in your work, please cite the following papers:&lt;/p&gt; &#xA;&lt;p&gt;Elizabeth Polgreen, Kevin Cheang, Pranav Gaddamadugu, Adwait Godbole, Kevin Laeufer, Shaokai Lin, Yatin A. Manerkar, Federico Mora, and Sanjit A. Seshia. &lt;font color=&#34;blue&#34;&gt;UCLID5: Multi-Modal Formal Modeling, Verification, and Synthesis.&lt;/font&gt; &lt;a href=&#34;https://people.eecs.berkeley.edu/~sseshia/pubs/b2hd-polgreen-cav22.html&#34;&gt;[HTML]&lt;/a&gt;&lt;em&gt;34th International Conference on Computer Aided Verification (CAV 2022)&lt;/em&gt;, Haifa, Israel. July 2022.&lt;/p&gt; &#xA;&lt;p&gt;Sanjit A. Seshia and Pramod Subramanyan. &lt;font color=&#34;blue&#34;&gt;UCLID5: Integrating Modeling, Verification, Synthesis and Learning.&lt;/font&gt; &lt;a href=&#34;https://people.eecs.berkeley.edu/~sseshia/pubs/b2hd-seshia-memocode18.html&#34;&gt;[HTML]&lt;/a&gt; &lt;em&gt;Proceedings of the 16th ACM-IEEE International Conference on Formal Methods and Models for System Design (MEMOCODE 2018)&lt;/em&gt;, Beijing, China. October 2018.&lt;/p&gt; &#xA;&lt;p&gt;For questions and feeback please contact elizabeth.polgreen [at] ed.ac.uk.&lt;/p&gt; &#xA;&lt;h2&gt;Contact us&lt;/h2&gt; &#xA;&lt;p&gt;For bug reports, first preference is for you to file a GitHub issue. For help using UCLID5 in your work, please email &lt;a href=&#34;mailto:uclid@lists.eecs.berkeley.edu&#34;&gt;uclid@lists.eecs.berkeley.edu&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;UCLID5 Tutorial/Publication&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/uclid-org/uclid/raw/master/tutorial/tutorial.pdf&#34;&gt;tutorial document&lt;/a&gt; has a gentle introduction to using UCLID5.&lt;/p&gt; &#xA;&lt;p&gt;A set of tutorial lectures on UCLID5 can be found &lt;a href=&#34;https://people.eecs.berkeley.edu/~sseshia/uclid5-tutorial/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Versions&lt;/h2&gt; &#xA;&lt;p&gt;Get the &lt;a href=&#34;https://github.com/uclid-org/uclid/releases&#34;&gt;latest release&lt;/a&gt;, or get the latest development version &lt;code&gt;git clone https://github.com/uclid-ord/uclid&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;Prerequisites:&lt;/h2&gt; &#xA;&lt;p&gt;To use the prebuilt binaries, UCLID5 requires:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Z3Prover/z3/releases/tag/z3-4.12.1&#34;&gt;Z3 version 4.12.2&lt;/a&gt; with the Java bindings&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://openjdk.java.net/&#34;&gt;OpenJDK&lt;/a&gt; version 8,9,10 or 11&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To compile from source, UCLID5 requires all of the above plus:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.scala-sbt.org/download.html&#34;&gt;SBT version 1.0 or greater.&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following are optional requirements but several CI tests will fail without them:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(optional) &lt;a href=&#34;https://github.com/cvc5/cvc5&#34;&gt;CVC5&lt;/a&gt; version 0.0.4 is the SyGuS-IF compliant solver used for synthesis tests in the CI.&lt;/li&gt; &#xA; &lt;li&gt;(optional) &lt;a href=&#34;https://github.com/polgreen/delphi&#34;&gt;Delphi&lt;/a&gt; is used for verification modulo oracles tests in the CI.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installation of prerequisites on Linux&lt;/h3&gt; &#xA;&lt;h4&gt;Java 11&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install instructions for OpenJDK are available at &lt;a href=&#34;https://openjdk.java.net/install/&#34;&gt;https://openjdk.java.net/install/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;SBT (only required to build from source)&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install instructions for SBT are available at &lt;a href=&#34;http://www.scala-sbt.org/1.0/docs/Setup.html&#34;&gt;http://www.scala-sbt.org/1.0/docs/Setup.html&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;External solvers&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For easy install of prerequisite solvers on Linux, run the following scripts from the root directory of the UCLID5 source repository. These scripts set up Z3/CVC5/Delphi for use with uclid5. This script will download &lt;a href=&#34;https://github.com/Z3Prover/z3/releases/tag/z3-4.12.1&#34;&gt;Z3 version 4.12.2.&lt;/a&gt;/&lt;a href=&#34;https://github.com/cvc5/cvc5/releases/tag/cvc5-1.0.3&#34;&gt;CVC5 1.0.3&lt;/a&gt;/&lt;a href=&#34;https://github.com/polgreen/delphi/releases/tag/0.1&#34;&gt;Delphi&lt;/a&gt; binaries from GitHub.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ source get-z3-linux.sh&#xA;    $ source get-cvc5-linux.sh #(optional but some CI synthesis tests will fail without CVC5)&#xA;    $ source get-delphi-linux.sh #(optional but some CI synthesis tests will fail without Delphi)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;These scripts download the binaries for Z3, CVC5 and Delphi respectively and set up your &lt;code&gt;PATH&lt;/code&gt; and &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; accordingly. You may wish to permanently add the following lines to your bash_profile:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    export PATH=$PATH:/path/to/uclid/z3/bin:/path/to/uclid/cvc5/bin:/path/to/uclid/delphi/bin:/path/to/uclid/oracles&#xA;    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/uclid/z3/bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, &lt;a href=&#34;https://github.com/Z3Prover/z3&#34;&gt;Z3&lt;/a&gt;, &lt;a href=&#34;https://github.com/cvc5/cvc5&#34;&gt;CVC5&lt;/a&gt;, and &lt;a href=&#34;https://github.com/polgreen/delphi&#34;&gt;Delphi&lt;/a&gt; can all be built from source, and instructions can be found on their respective git repositories. If you prefer to build Z3 from source, make sure the Z3/Java interface is enabled in your build (currently by passing &lt;code&gt;--java&lt;/code&gt; to the &lt;code&gt;mk_make.py&lt;/code&gt; script).&lt;/p&gt; &#xA;&lt;h3&gt;Installation of prerequisites on Mac&lt;/h3&gt; &#xA;&lt;h4&gt;Java 11&lt;/h4&gt; &#xA;&lt;p&gt;We recommend using openJDK 11 on MacOS, and provide instructions for installing this with homebrew (further instructions are available at &lt;a href=&#34;https://openjdk.org/install/&#34;&gt;https://openjdk.org/install/&lt;/a&gt;):&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;brew install openjdk@11&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If the above step does not work and you are running an old version of macOS, try:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;brew update&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;brew tap homebrew/cask-versions&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;brew cask install java11&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Make sure Java 11 is the default by adding the following lines to your dotfiles. For &lt;code&gt;bash&lt;/code&gt; this is usually &lt;code&gt;.bash_profile&lt;/code&gt; and for &lt;code&gt;zsh&lt;/code&gt; this is usually &lt;code&gt;.zshrc&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export JAVA_11_HOME=$(/usr/libexec/java_home -v11)&#xA;alias java11=&#39;export JAVA_HOME=$JAVA_11_HOME&#39;&#xA;java11&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SBT (only required to build from source)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;brew install sbt&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;External solvers&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For easy install of prerequisites on macOS, run the following scripts from the root directory of the UCLID5 source repository. These scripts set up Z3/CVC5/Delphi for use with uclid5. This script will download &lt;a href=&#34;https://github.com/Z3Prover/z3/releases/tag/z3-4.12.1&#34;&gt;Z3 version 4.12.2.&lt;/a&gt;/&lt;a href=&#34;https://github.com/cvc5/cvc5/releases/tag/cvc5-1.0.3&#34;&gt;CVC5 1.0.3&lt;/a&gt;/&lt;a href=&#34;https://github.com/polgreen/delphi/releases/tag/0.1&#34;&gt;Delphi&lt;/a&gt; binaries from GitHub.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ source get-z3-macos.sh&#xA;    $ source get-cvc5-macos.sh #(optional but some CI synthesis tests will fail without CVC5)&#xA;    $ source get-delphi-macos.sh #(optional but some CI synthesis tests will fail without Delphi)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;These scripts add the downloaded binaries to your &lt;code&gt;PATH&lt;/code&gt; and &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; accordingly. You may wish to permanently add the following lines to your bash_profile:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    export PATH=$PATH:/path/to/uclid/z3/bin:/path/to/uclid/cvc5/bin:/path/to/uclid/delphi/bin:/path/to/uclid/oracles&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Due to System Integrity Protection, introduced in OS X El Capitan, Java ignores the user set DYLD_LIBRARY_PATH. Depending on the version of MacOS you are using, you may need to fix this issue by copying the JNI dynamic link libraries to Java/Library/Extensions and the non-JNI dynamic link libraries to /usr/local/lib as follows (if you build Z3 from source these files are found in the build directory):&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;    cp /path/to/uclid/z3/bin/libz3.dylib /usr/local/lib&#xA;    cp /path/to/uclid/z3/bin/libz3java.dylib /Library/Java/Extensions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using the Pre-built binaries&lt;/h2&gt; &#xA;&lt;p&gt;Get the &lt;a href=&#34;https://github.com/uclid-org/uclid/releases&#34;&gt;latest release&lt;/a&gt;. The uclid binary is located in the bin/ subdirectory&lt;/p&gt; &#xA;&lt;h2&gt;Compiling uclid5 from source&lt;/h2&gt; &#xA;&lt;p&gt;Run the following command in the root directory of the UCLID5 repository (note that it is not necessary to run &lt;code&gt;sbt update&lt;/code&gt; if you already have the correct dependencies installed as per &lt;a href=&#34;https://github.com/uclid-org/uclid/raw/master/build.sbt&#34;&gt;https://github.com/uclid-org/uclid/blob/master/build.sbt&lt;/a&gt;. However, running it will do no harm.):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sbt update clean compile &#34;set fork:=true&#34; test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If compilation and tests pass (or if the only failing tests are due to CVC5 and Delphi not being found), you can build a universal package.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sbt universal:packageBin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create uclid/target/universal/uclid-0.9.5.zip, which contains the uclid binary in the bin/ subdirectory. Unzip this file, and add it to your path.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ unzip uclid-0.9.5.zip&#xA;$ cd uclid-0.9.5&#xA;$ export PATH=$PATH:$PWD/bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running UCLID&lt;/h2&gt; &#xA;&lt;p&gt;Now you can run uclid using the &#39;uclid&#39; command. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ uclid examples/tutorial/ex1.1-fib-model.ucl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some useful commands to know:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To print the SMT files use the &lt;code&gt;-g&lt;/code&gt; flag, e.g., &lt;code&gt;uclid examples/tutorial/ex1.1-fib-model.ucl -g &#34;filename&#34;&lt;/code&gt; will print the SMT file to SMT files with the prefix &lt;code&gt;filename&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To run UCLID5 with another solver use the &lt;code&gt;-s&lt;/code&gt; flag, e.g., &lt;code&gt;uclid examples/tutorial/ex1.1-fib-model.ucl -s &#34;cvc5 --lang smt2 --produce-models&#34;&lt;/code&gt; will use CVC5 as the back-end solver.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Directory Structure&lt;/h1&gt; &#xA;&lt;p&gt;This repository consists of the following sub-directories.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;examples : This contains example uclid5 models. See examples/tutorial for the examples from the tutorial.&lt;/li&gt; &#xA; &lt;li&gt;lib: Libraries on which uclid5 depends (Z3).&lt;/li&gt; &#xA; &lt;li&gt;project: Build scripts.&lt;/li&gt; &#xA; &lt;li&gt;src/main/scala: uclid5 source.&lt;/li&gt; &#xA; &lt;li&gt;src/test/scala: uclid5 test suite.&lt;/li&gt; &#xA; &lt;li&gt;test: test programs for uclid5.&lt;/li&gt; &#xA; &lt;li&gt;tutorial: uclid5 tutorial (with LaTeX source)&lt;/li&gt; &#xA; &lt;li&gt;vim: vim syntax highlighting for uclid5.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Related Tools&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/uclid-org/chiselucl&#34;&gt;chiselucl&lt;/a&gt; allows Chisel models to be converted into UCLID5.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>