<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-07T01:36:13Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>softprops/hubcat</title>
    <updated>2022-12-07T01:36:13Z</updated>
    <id>tag:github.com,2022-12-07:/softprops/hubcat</id>
    <link href="https://github.com/softprops/hubcat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;hip cats and git hubs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;hubcat&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/softprops/hubcat&#34;&gt;&lt;img src=&#34;https://travis-ci.org/softprops/hubcat.png?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;hip cats, git hubs, good times. asynchronous vvip client of the github enterprises&lt;/p&gt; &#xA;&lt;h2&gt;install&lt;/h2&gt; &#xA;&lt;p&gt;In sbt...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;libraryDependencies += &#34;me.lessis&#34; %% &#34;hubcat&#34; % &#34;0.1.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;do as &lt;strong&gt;little&lt;/strong&gt; as possible while providing much of what you &lt;strong&gt;need&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;what it does&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;handle authentication (basic &amp;amp; oauth)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Most HTTP APIs are composed of REST-style endpoints which have little need for API wrappers. Dispatch&#39;s path building interface is sufficient and down-right ideal to suit most of these cases. Authenticated APIs incur some extra complexity for clients which makes using a library more worth your while to avoid writing extra code for handling API specific authentication. This library provides an interface that supports github basic and oauth(2) credentials. How you choose to store those credentials is up to your application.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;provide a fluent interface for composing api requests&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The choice of design is modeled after the library dispatch is based on which provides low-level builder interface for composing HTTP requests. This library provides a builder interface at the level of the github API.&lt;/p&gt; &#xA;&lt;h2&gt;what it doesn&#39;t&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;make assumptions about what you want to do with responses&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In the spirit of dispatch, your interface for responses is a just function. It just happens to have the same function signature dispatch uses for handlers of responses: &lt;code&gt;com.ning.http.client.AsyncResponse[T]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;All builder methods define a method &lt;code&gt;apply[T](hand: Client.Handler[T]): Promise[T]&lt;/code&gt; so, at any point, you can provide a handler function and get back a dispatch Promise to compose with other promises to process a chain of responses.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;provide a modeling of responses&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Many applications may already define their own representation of github api objects. This library does not intend to replace those. This library allows you to directly adapt them to standard dispatch interfaces.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;parse responses&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Most of the time you will wish to query a github server for a single piece of information. Github serves most services in JSON. There are alot of great JSON parsers out there. You are probably already using one. This library doesn&#39;t assume which one you will use. There is probably already a dispatch interface out there for the one you are using. You should use those instead. If not, contribute to dispatch!&lt;/p&gt; &#xA;&lt;h2&gt;usage&lt;/h2&gt; &#xA;&lt;p&gt;Get a list of contributors for repo ranked by contribution&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import hubcat._; import dispatch._; import org.json4s._&#xA;val (login, pass) = (&#34;yrlogin&#34;, &#34;yrpass&#34;)&#xA;val (user, repo) = (&#34;dispatch&#34;, &#34;reboot&#34;)&#xA;val auth = new AuthorizationClient(login, pass).&#xA;                 authorize.&#xA;                 scopes(&#34;repo&#34;).&#xA;                 note(&#34;just for fun&#34;)&#xA;for {&#xA;  JObject(fields)           &amp;lt;- auth(as.json4s.Json)()&#xA;  (&#34;token&#34;, JString(token)) &amp;lt;- fields&#xA;} yield {&#xA;  val contrib = new Client(token).&#xA;                     repo(user, repo).&#xA;                     contributors&#xA;  (for {&#xA;    JObject(cfields)               &amp;lt;- contrib(as.json4s.Json)()&#xA;    (&#34;login&#34;, JString(login))      &amp;lt;- cfields&#xA;    (&#34;contributions&#34;, JInt(count)) &amp;lt;- cfields&#xA;  } yield (login, count)).sortBy(_._2).reverse&#xA;}.foreach {&#xA;  case (l, c) =&amp;gt; println(&#34;%-15s - %s&#34; format(l, c))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Changelog&lt;/h3&gt; &#xA;&lt;p&gt;You can find a list of notable changes on &lt;a href=&#34;http://notes.implicit.ly/search/hubcat&#34;&gt;implicit.ly&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Github &lt;a href=&#34;http://developer.github.com/&#34;&gt;api docs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Your Github &lt;a href=&#34;https://github.com/settings/applications&#34;&gt;oauth clients&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Doug Tangren (softprops) 2012&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>samanz/OntoNER</title>
    <updated>2022-12-07T01:36:13Z</updated>
    <id>tag:github.com,2022-12-07:/samanz/OntoNER</id>
    <link href="https://github.com/samanz/OntoNER" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OntoNER&lt;/h1&gt;</summary>
  </entry>
</feed>