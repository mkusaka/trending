<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-17T01:45:22Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>AugustNagro/magnum</title>
    <updated>2023-06-17T01:45:22Z</updated>
    <id>tag:github.com,2023-06-17:/AugustNagro/magnum</id>
    <link href="https://github.com/AugustNagro/magnum" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A &#39;new look&#39; for database access in Scala&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Magnum&lt;/h2&gt; &#xA;&lt;p&gt;Yet another database client for Scala. No dependencies, high productivity.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#installing&#34;&gt;Installing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#scaladoc&#34;&gt;ScalaDoc&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#documentation&#34;&gt;Documentation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#connect-creates-a-database-connection&#34;&gt;&lt;code&gt;connect&lt;/code&gt; creates a database connection&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#transact-creates-a-database-transaction&#34;&gt;&lt;code&gt;transact&lt;/code&gt; creates a database transaction&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#type-safe-transaction--connection-management&#34;&gt;Type-safe Transaction &amp;amp; Connection Management&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#customizing-the-transactions-jdbc-connection&#34;&gt;Customizing the transaction&#39;s JDBC Connection&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#sql-interpolator-frag-query-and-update&#34;&gt;Sql Interpolator, Frag, Query, and Update&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#batch-updates&#34;&gt;Batch Updates&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#immutable-repositories&#34;&gt;Immutable Repositories&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#repositories&#34;&gt;Repositories&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#database-generated-columns&#34;&gt;Database generated columns&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#specifications&#34;&gt;Specifications&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#scala-3-enum-support&#34;&gt;Scala 3 Enum Support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#dbcodec-typeclass-for-jdbc-reading--writing&#34;&gt;&lt;code&gt;DbCodec&lt;/code&gt;: Typeclass for JDBC reading &amp;amp; writing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#logging-sql-queries&#34;&gt;Logging&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#feature-list&#34;&gt;Feature List And Database Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/#talks-and-presentations&#34;&gt;Talks and Presentations&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;com.augustnagro&#34; %% &#34;magnum&#34; % &#34;1.0.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Magnum requires Scala &amp;gt;= 3.3.0&lt;/p&gt; &#xA;&lt;p&gt;You must also install the JDBC driver for your database, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;org.postgresql&#34; % &#34;postgresql&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And for performance, a JDBC connection pool like &lt;a href=&#34;https://github.com/brettwooldridge/HikariCP&#34;&gt;HikariCP&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;ScalaDoc&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://javadoc.io/doc/com.augustnagro/magnum_3&#34;&gt;https://javadoc.io/doc/com.augustnagro/magnum_3&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;connect&lt;/code&gt; creates a database connection.&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;connect&lt;/code&gt; takes two parameters; the database DataSource, and a context function with a given &lt;code&gt;DbCon&lt;/code&gt; connection. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.augustnagro.magnum.*&#xA;&#xA;val ds: java.sql.DataSource = ???&#xA;&#xA;val users: Vector[User] = connect(ds):&#xA;  sql&#34;SELECT * FROM user&#34;.query[User].run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;transact&lt;/code&gt; creates a database transaction.&lt;/h3&gt; &#xA;&lt;p&gt;Like &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;transact&lt;/code&gt; accepts a DataSource and context function. The context function provides a &lt;code&gt;DbTx&lt;/code&gt; instance. If the function throws, the transaction will be rolled back.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// update is rolled back&#xA;transact(ds):&#xA;  sql&#34;UPDATE user SET first_name = $firstName WHERE id = $id&#34;.update.run()&#xA;  thisMethodThrows()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Type-safe Transaction &amp;amp; Connection Management&lt;/h3&gt; &#xA;&lt;p&gt;Annotate transactional methods with &lt;code&gt;using DbTx&lt;/code&gt;, and connections with &lt;code&gt;using DbCon&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Since &lt;code&gt;DbTx &amp;lt;: DbCon&lt;/code&gt;, it&#39;s impossible to call a method with the wrong context.&lt;/p&gt; &#xA;&lt;p&gt;For example, this compiles:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def runUpdateAndGetUsers()(using DbTx): Vector[User] =&#xA;  userRepo.deleteById(1L)&#xA;  getUsers&#xA;&#xA;def getUsers(using DbCon): Vector[User] =&#xA;  sql&#34;SELECT * FROM user&#34;.query.run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But not this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def runSomeQueries(using DbCon): Vector[User] =&#xA;  runUpdateAndGetUsers()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Customizing the transaction&#39;s JDBC Connection.&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;transact&lt;/code&gt; lets you customize the underlying java.sql.Connection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;transact(ds(), withRepeatableRead):&#xA;  ???&#xA;&#xA;def withRepeatableRead(con: Connection): Unit =&#xA;  con.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sql Interpolator, Frag, Query, and Update&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;sql&lt;/code&gt; interpolator can express any SQL expression, returning a &lt;code&gt;Frag&lt;/code&gt; sql fragment. You can interpolate values without the risk of SQL-injection attacks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val firstNameOpt = Some(&#34;John&#34;)&#xA;val twoDaysAgo = OffsetDateTime.now.minusDays(2)&#xA;&#xA;val frag: Frag =&#xA;  sql&#34;&#34;&#34;&#xA;    SELECT id, last_name FROM user&#xA;    WHERE first_name = $firstNameOpt&#xA;    AND created &amp;lt;= $twoDaysAgo&#xA;    &#34;&#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Frags can be turned into queries with the &lt;code&gt;query[T](using DbCodec[T])&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val query = frag.query[(Long, String)] // Query[(Long, String)]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or updates via &lt;code&gt;update&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val update: Update =&#xA;  sql&#34;UPDATE user SET first_name = &#39;Buddha&#39; WHERE id = 3&#34;.update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both are executed via &lt;code&gt;run()(using DbCon)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;transact(ds):&#xA;  val tuples: Vector[(Long, String)] = query.run()&#xA;  val updatedRows: Int = update.run()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Batch Updates&lt;/h3&gt; &#xA;&lt;p&gt;Batch updates are supported via &lt;code&gt;batchUpdate&lt;/code&gt; method in package &lt;code&gt;com.augustnagro.magnum&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;connect(ds):&#xA;  val users: Iterable[User] = ???&#xA;  val updateResult: BatchUpdateResult =&#xA;    batchUpdate(users): user =&amp;gt;&#xA;      sql&#34;...&#34;.update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;batchUpdate&lt;/code&gt; returns a &lt;code&gt;BatchUpdateResult&lt;/code&gt; enum, which is &lt;code&gt;Success(numRowsUpdated)&lt;/code&gt; or &lt;code&gt;SuccessNoInfo&lt;/code&gt; otherwise.&lt;/p&gt; &#xA;&lt;h3&gt;Immutable Repositories&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;ImmutableRepo&lt;/code&gt; class auto-generates the following methods at compile-time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def count(using DbCon): Long&#xA;  def existsById(id: ID)(using DbCon): Boolean&#xA;  def findAll(using DbCon): Vector[E]&#xA;  def findAll(spec: Spec[E])(using DbCon): Vector[E]&#xA;  def findById(id: ID)(using DbCon): Option[E]&#xA;  def findAllById(ids: Iterable[ID])(using DbCon): Vector[E]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@Table(PostgresDbType, SqlNameMapper.CamelToSnakeCase)&#xA;case class User(&#xA;  @Id id: Long,&#xA;  firstName: Option[String],&#xA;  lastName: String,&#xA;  created: OffsetDateTime&#xA;) derives DbCodec&#xA;&#xA;val userRepo = ImmutableRepo[User, Long]&#xA;&#xA;transact(ds):&#xA;  val cnt = userRepo.count&#xA;  val userOpt = userRepo.findById(2L)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Importantly, class User is annotated with &lt;code&gt;@Table&lt;/code&gt;, which defines the table&#39;s database type. The annot optionally specifies the name-mapping between the scala fields and column names. The table must also &lt;code&gt;derive DbCodec&lt;/code&gt;, or otherwise provide an implicit DbCodec instance.&lt;/p&gt; &#xA;&lt;p&gt;The optional &lt;code&gt;@Id&lt;/code&gt; annotation denotes the table&#39;s primary key. Not setting &lt;code&gt;@Id&lt;/code&gt; will default to using the first field. If there is no logical id, then strip the annotation and use Null in the ID type parameter of Repositories (see next).&lt;/p&gt; &#xA;&lt;p&gt;It is a best practice to extend ImmutableRepo to encapsulate your SQL in repositories. This way, it&#39;s easier to maintain since they&#39;re grouped together.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class UserRepo extends ImmutableRepo[User, Long]:&#xA;  def firstNamesForLast(lastName: String)(using DbCon): Vector[String] =&#xA;    sql&#34;&#34;&#34;&#xA;      SELECT DISTINCT first_name&#xA;      FROM user&#xA;      WHERE last_name = $lastName&#xA;      &#34;&#34;&#34;.query[String].run()&#xA;        &#xA;  // other User-related queries here&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Repositories&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Repo&lt;/code&gt; class auto-generates the following methods at compile-time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def count(using DbCon): Long&#xA;  def existsById(id: ID)(using DbCon): Boolean&#xA;  def findAll(using DbCon): Vector[E]&#xA;  def findAll(spec: Spec[E])(using DbCon): Vector[E]&#xA;  def findById(id: ID)(using DbCon): Option[E]&#xA;  def findAllById(ids: Iterable[ID])(using DbCon): Vector[E]&#xA;  &#xA;  def delete(entity: E)(using DbCon): Unit&#xA;  def deleteById(id: ID)(using DbCon): Unit&#xA;  def truncate()(using DbCon): Unit&#xA;  def deleteAll(entities: Iterable[E])(using DbCon): Unit&#xA;  def deleteAllById(ids: Iterable[ID])(using DbCon): Unit&#xA;  def insert(entityCreator: EC)(using DbCon): E&#xA;  def insertAll(entityCreators: Iterable[EC])(using DbCon): Vector[E]&#xA;  def insertReturning(entityCreator: EC)(using DbCon): E&#xA;  def insertAllReturning(entityCreators: Iterable[EC])(using DbCon): Vector[E]&#xA;  def update(entity: E)(using DbCon): Unit&#xA;  def updateAll(entities: Iterable[E])(using DbCon): Unit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@Table(PostgresDbType, SqlNameMapper.CamelToSnakeCase)&#xA;case class User(&#xA;  @Id id: Long,&#xA;  firstName: Option[String],&#xA;  lastName: String,&#xA;  created: OffsetDateTime&#xA;) derives DbCodec&#xA;&#xA;val userRepo = Repo[User, User, Long]&#xA;&#xA;val countAfterUpdate = transact(ds):&#xA;  userRepo.deleteById(2L)&#xA;  userRepo.count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is a best practice to encapsulate your SQL in repositories.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class UserRepo extends Repo[User, User, Long]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also note that Repo extends ImmutableRepo. Some databases cannot support every method, and will throw UnsupportedOperationException.&lt;/p&gt; &#xA;&lt;h3&gt;Database generated columns&lt;/h3&gt; &#xA;&lt;p&gt;It is often the case that database columns are auto-generated, for example, primary key IDs. This is why the Repo class has 3 type parameters.&lt;/p&gt; &#xA;&lt;p&gt;The first defines the Entity-Creator, which should omit any fields that are auto-generated. The entity-creator class must be an &#39;effective&#39; subclass of the entity class, but it does not have to subclass the entity. This is verified at compile time.&lt;/p&gt; &#xA;&lt;p&gt;The second type parameter is the Entity class, and the final is for the ID. If the Entity does not have a logical ID, use Null.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class UserCreator(&#xA;  firstName: Option[String],&#xA;  lastName: String,&#xA;) derives DbCodec&#xA;&#xA;@Table(PostgresDbType, SqlNameMapper.CamelToSnakeCase)&#xA;case class User(&#xA;  @Id id: Long,&#xA;  firstName: Option[String],&#xA;  lastName: String,&#xA;  created: OffsetDateTime&#xA;) derives DbCodec&#xA;&#xA;val userRepo = Repo[UserCreator, User, Long]&#xA;&#xA;val newUser: User = transact(ds):&#xA;  userRepo.insertReturning(&#xA;    UserCreator(Some(&#34;Adam&#34;), &#34;Smith&#34;)&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifications&lt;/h3&gt; &#xA;&lt;p&gt;Specifications help you write safe, dynamic queries. An example use-case would be a search results page that allows users to sort and filter the paginated data.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If you need to perform joins to get the data needed, first create a database view.&lt;/li&gt; &#xA; &lt;li&gt;Next, create an entity class that derives DbReader.&lt;/li&gt; &#xA; &lt;li&gt;Finally, use the Spec class to create a specification.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val partialName = &#34;Ja&#34;&#xA;val searchDate = OffsetDateTime.now.minusDays(2)&#xA;val idPosition = 42L&#xA;&#xA;val spec = Spec[User]&#xA;  .where(sql&#34;first_name ILIKE &#39;$partialName%&#39;&#34;)&#xA;  .where(sql&#34;created &amp;gt;= $searchDate&#34;)&#xA;  .seek(&#34;id&#34;, SeekDir.Gt, idPosition, SortOrder.Asc)&#xA;  .limit(10)&#xA;&#xA;val users: Vector[User] = userRepo.findAll(spec)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that both &lt;a href=&#34;https://blog.jooq.org/faster-sql-paging-with-jooq-using-the-seek-method/&#34;&gt;seek pagination&lt;/a&gt; and offset pagination is supported.&lt;/p&gt; &#xA;&lt;h3&gt;Scala 3 Enum Support&lt;/h3&gt; &#xA;&lt;p&gt;Magnum supports Scala 3 enums (non-adt) fully, by default writing &amp;amp; reading them as Strings. For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@Table(PostgresDbType, SqlNameMapper.CamelToUpperSnakeCase)&#xA;enum Color derives DbCodec:&#xA;  case Red, Green, Blue&#xA;&#xA;@Table(PostgresDbType, SqlNameMapper.CamelToSnakeCase)&#xA;case class User(&#xA;  @Id id: Long,&#xA;  firstName: Option[String],&#xA;  lastName: String,&#xA;  created: OffsetDateTime,&#xA;  favoriteColor: Color&#xA;) derives DbCodec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;DbCodec&lt;/code&gt;: Typeclass for JDBC reading &amp;amp; writing&lt;/h3&gt; &#xA;&lt;p&gt;DbCodec is a Typeclass for JDBC reading &amp;amp; writing.&lt;/p&gt; &#xA;&lt;p&gt;Built-in DbCodecs are provided for many types, including primitives, dates, Options, and Tuples. You can derive DbCodecs by adding &lt;code&gt;derives DbCodec&lt;/code&gt; to your case class or enum.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val rs: ResultSet = ???&#xA;val ints: Vector[Int] = DbCodec[Int].read(rs)&#xA;&#xA;val ps: PreparedStatement = ???&#xA;DbCodec[Int].writeSingle(22, ps)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Defining your own DbCodecs&lt;/h3&gt; &#xA;&lt;p&gt;To modify the JDBC mappings, implement a given DbCodec instance as you would for any Typeclass.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;Historically, database clients on the JVM fall into three categories.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Object Oriented Repositories (Spring-Data, Hibernate)&lt;/li&gt; &#xA; &lt;li&gt;Functional DSLs (JOOQ, Slick, quill, zio-sql)&lt;/li&gt; &#xA; &lt;li&gt;SQL String interpolators (Anorm, doobie, plain jdbc)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Magnum is a Scala 3 library combining aspects of all three, providing a typesafe and refactorable SQL interface, which can express all SQL expressions, on all JDBC-supported databases.&lt;/p&gt; &#xA;&lt;p&gt;Like in Zoolander (the movie), Magnum represents a &#39;new look&#39; for Database access in Scala.&lt;/p&gt; &#xA;&lt;h2&gt;Feature List&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports any database with a JDBC driver, including Postgres, MySql, Oracle, ClickHouse, H2, and Sqlite&lt;/li&gt; &#xA; &lt;li&gt;Efficient &lt;code&gt;sql&#34; &#34;&lt;/code&gt; interpolator&lt;/li&gt; &#xA; &lt;li&gt;Purely-functional API&lt;/li&gt; &#xA; &lt;li&gt;Common queries (like insert, update, delete) generated at compile time&lt;/li&gt; &#xA; &lt;li&gt;Difficult to hit N+1 query problem&lt;/li&gt; &#xA; &lt;li&gt;Type-safe Transactions&lt;/li&gt; &#xA; &lt;li&gt;Supports database-generated columns&lt;/li&gt; &#xA; &lt;li&gt;Easy to use, Loom-ready API (no Futures or Effect Systems)&lt;/li&gt; &#xA; &lt;li&gt;Easy to define entities. Easy to implement DB support &amp;amp; codecs for custom types.&lt;/li&gt; &#xA; &lt;li&gt;Scales to complex SQL queries&lt;/li&gt; &#xA; &lt;li&gt;Specifications for building dynamic queries, such as table filters with pagination&lt;/li&gt; &#xA; &lt;li&gt;Supports high-performance &lt;a href=&#34;https://blog.jooq.org/faster-sql-paging-with-jooq-using-the-seek-method/&#34;&gt;Seek pagination&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Performant batch-queries&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Logging SQL queries&lt;/h3&gt; &#xA;&lt;p&gt;If you set the java.util Logging level to DEBUG, all SQL queries will be logged. Setting to TRACE will log SQL queries and their parameters.&lt;/p&gt; &#xA;&lt;h2&gt;Developing&lt;/h2&gt; &#xA;&lt;p&gt;The tests are written using TestContainers, which requires Docker be installed.&lt;/p&gt; &#xA;&lt;h2&gt;Todo&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support MSSql&lt;/li&gt; &#xA; &lt;li&gt;Streaming support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Talks and Presentations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Scala Days 2023: &lt;a href=&#34;https://raw.githubusercontent.com/AugustNagro/magnum/master/Magnum-Slides-to-Share.pdf&#34;&gt;slides&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>