<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-20T01:42:02Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rcardin/raise4s</title>
    <updated>2024-04-20T01:42:02Z</updated>
    <id>tag:github.com,2024-04-20:/rcardin/raise4s</id>
    <link href="https://github.com/rcardin/raise4s" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Porting of the Raise DSL from the Arrow Kt Kotlin library&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/rcardin/raise4s/scala.yml?branch=main&#34; alt=&#34;GitHub Workflow Status (with branch)&#34;&gt; &lt;img src=&#34;https://img.shields.io/maven-central/v/in.rcard/raise4s_3&#34; alt=&#34;Maven Central&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/rcardin/raise4s&#34; alt=&#34;GitHub release (latest by date)&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;raise4s&lt;/h1&gt; &#xA;&lt;p&gt;Porting of the Raise DSL from the Arrow Kt Kotlin library&lt;/p&gt; &#xA;&lt;h2&gt;Dependency&lt;/h2&gt; &#xA;&lt;p&gt;The library is available on Maven Central. To use it, add the following dependency to your &lt;code&gt;build.sbt&lt;/code&gt; files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sbt&#34;&gt;libraryDependencies += &#34;in.rcard&#34; % &#34;raise4s_3&#34; % &#34;0.0.2&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The library is only available for Scala 3.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;The &lt;code&gt;Raise&lt;/code&gt; DSL in Scala&lt;/h3&gt; &#xA;&lt;p&gt;The Raise DSL is a new way to handle typed errors in Scala. Instead of using a wrapper type to address both the happy path and errors, the &lt;code&gt;Raise[E]&lt;/code&gt; type describes the possibility that a function can raise a logical error of type &lt;code&gt;E&lt;/code&gt;. A function that can raise an error of type &lt;code&gt;E&lt;/code&gt; must execute in a scope that can also handle the error. In recent Scala, it&#39;s something that is referred to &lt;em&gt;direct style&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to define a function that can raise an error of type &lt;code&gt;E&lt;/code&gt; is to create a context function using the &lt;code&gt;Raise[E]&lt;/code&gt; the implicit parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class User(id: String, name: String)&#xA;&#xA;sealed trait Error&#xA;case class UserNotFound(id: String) extends Error&#xA;&#xA;def findUserById(id: String): Raise[Error] ?=&amp;gt; User = User(id, &#34;Alice&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can do better than that, using the &lt;code&gt;infix type raises&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findUserById(id: String): User raises Error = User(id, &#34;Alice&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;How do we read the above syntax? The function &lt;code&gt;findUserById&lt;/code&gt; returns a &lt;code&gt;User&lt;/code&gt; and can raise an error of type &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The above function let us short-circuit an execution and raise an error of type &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;raise&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findUserById(id: String): User raises Error =&#xA;  if (id == &#34;42&#34;) User(id, &#34;Alice&#34;) else Raise.raise(UserNotFound(id))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The type of error a function can raise is checked at compile time. If we try to raise an error of a different type, the compiler will complain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findUserById(id: String): User raises Error =&#xA;  if (id == &#34;42&#34;) User(id, &#34;Alice&#34;) else Raise.raise(&#34;User not found&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code will not compile with the following error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[error] 9 |  if (id == &#34;42&#34;) User(id) else Raise.raise(&#34;User not found&#34;)&#xA;[error]   |                                                       ^&#xA;[error]   |No given instance of type in.rcard.raise4s.Raise[String] was found for parameter raise of method raise in package in.rcard.raise4s&#xA;[error] one error found&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s also possible to lift a value to the context &lt;code&gt;Raise[E] ?=&amp;gt; A&lt;/code&gt;. If we want to lift a value of type &lt;code&gt;A&lt;/code&gt; to the context &lt;code&gt;Raise[Nothing]&lt;/code&gt;, we can use the &lt;code&gt;succeed&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def aliceUser: User raises UserNotFound = Raise.succeed(User(&#34;42&#34;, &#34;Alice&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More useful is to lift a value of type &lt;code&gt;E&lt;/code&gt; as the error in the context &lt;code&gt;Raise[E]&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def userNotFound: User raises UserNotFound = UserNotFound(&#34;42&#34;).raise[User]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can always rewrite che last function as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def userNotFound: User raises UserNotFound = {&#xA;  Raise.raise(UserNotFound(&#34;42&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We may have noticed that one advantage of using the &lt;code&gt;Raise[E]&lt;/code&gt; context is that the return type of the function listed only the happy path. As we’ll see in a moment, this is a huge advantage when we want to compose functions that can raise errors.&lt;/p&gt; &#xA;&lt;p&gt;As you might guess from the previous compiler error, the Raise DSL is using implicit resolutions under the hood. In fact, to execute a function that uses the Raise DSL we need to provide an instance of the &lt;code&gt;Raise[E]&lt;/code&gt; type class for the error type &lt;code&gt;E&lt;/code&gt;. The most generic way to execute a function that can raise an error of type &lt;code&gt;E&lt;/code&gt; and that is defined in the context of a &lt;code&gt;Raise[E]&lt;/code&gt; is the &lt;code&gt;fold&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Raise.fold(&#xA;  block = { findUserById(&#34;43&#34;) },&#xA;  catchBlock = ex =&amp;gt; println(s&#34;Error: $ex&#34;),&#xA;  recover = error =&amp;gt; println(s&#34;User not found: $error&#34;),&#xA;  transform = user =&amp;gt; println(s&#34;User found: $user&#34;)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let’s split the above function into parts. The &lt;code&gt;block&lt;/code&gt; parameter is the function that we want to execute. The &lt;code&gt;catchBlock&lt;/code&gt; parameter is a function that is executed when the &lt;code&gt;block&lt;/code&gt; function throws an exception. Don&#39;t worry: The lambda handles only &lt;code&gt;NonFatal&lt;/code&gt; exceptions. The &lt;code&gt;recover&lt;/code&gt; parameter is a function that is executed when the &lt;code&gt;block&lt;/code&gt; function raises a logical typed error of type &lt;code&gt;E&lt;/code&gt;. Finally, the &lt;code&gt;transform&lt;/code&gt; parameter is a function that is executed when the block function returns a value of type &lt;code&gt;A&lt;/code&gt;, which is the happy path. All the handling blocks return the exact value of type &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;fold&lt;/code&gt; function “consumes” the context, creating a concrete instance of a &lt;code&gt;Raise[E]&lt;/code&gt; type and executing the &lt;code&gt;block&lt;/code&gt; lambda in the context of that instance.&lt;/p&gt; &#xA;&lt;p&gt;There are other flavors of the &lt;code&gt;fold&lt;/code&gt; function. So, please, be sure to check them in the documentation.&lt;/p&gt; &#xA;&lt;p&gt;Please be aware that any exception thrown inside the &lt;code&gt;Raise[E]&lt;/code&gt; context will bubble up and not be transformed automatically into a logical typed error. What if we want to convert the exception into a typed error? For example, we want to convert the &lt;code&gt;IllegalArgumentException&lt;/code&gt; into a &lt;code&gt;UserNotFound&lt;/code&gt;. Well, we can do it using a function called &lt;code&gt;$catch&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findUserByIdWithEx(id: String): User =&#xA;  if (id == &#34;42&#34;) User(id, &#34;Alice&#34;) else throw new IllegalArgumentException(s&#34;User not found with id: $id&#34;)&#xA;&#xA;val maybeUser: Either[Error, User] =&#xA;  Raise.either:&#xA;    Raise.$catch[User](() =&amp;gt; findUserByIdWithEx(&#34;42&#34;), {&#xA;      case _: IllegalArgumentException =&amp;gt; Raise.raise(UserNotFound(&#34;42&#34;))&#xA;    })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We will see the &lt;code&gt;either&lt;/code&gt; function in a moment. As we can see, there’s nothing special with the &lt;code&gt;$catch&lt;/code&gt; function. It just catches the exception and calls the catch lambda with the exception. The &lt;code&gt;$catch&lt;/code&gt; function lets the fatal exception bubble up.&lt;/p&gt; &#xA;&lt;p&gt;It’s a different story if we want to recover or react to a typed error. In this case, we can use the &lt;code&gt;recover&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class NegativeAmount(amount: Double) extends Error&#xA;def convertToUsd(amount: Double, currency: String): Double raises NegativeAmount =&#xA;  if (amount &amp;lt; 0) Raise.raise(NegativeAmount(amount))&#xA;  else amount * 1.2&#xA;&#xA;val usdAmount: Double =&#xA;  Raise.recover({ convertToUsd(-1, &#34;EUR&#34;) }, { case NegativeAmount(amount) =&amp;gt; 0.0D })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Conversion to Wrapped Types&lt;/h3&gt; &#xA;&lt;p&gt;What if we want to convert a computation in the &lt;code&gt;Raise[E]&lt;/code&gt; context to a function returning an &lt;code&gt;Either[E, A]&lt;/code&gt;, a &lt;code&gt;Try[A]&lt;/code&gt;, an &lt;code&gt;Option[A]&lt;/code&gt;? Well, nothing is more straightforward than that.&lt;/p&gt; &#xA;&lt;p&gt;Let’s start with &lt;code&gt;Either[E, A]&lt;/code&gt;. The &lt;code&gt;either&lt;/code&gt; builder is what we&#39;re searching for. We can translate the result of the &lt;code&gt;findUserById&lt;/code&gt; function to an &lt;code&gt;Either[Error, User]&lt;/code&gt; quite easily:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val maybeUser: Either[Error, User] = &#xA;  Raise.either:&#xA;    findUserById(&#34;42&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we want to retrieve more information of a user using her name, we can just use the &lt;code&gt;User&lt;/code&gt; instance directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val maybeUserNameInUpperCase: Either[Error, String] = &#xA;  Raise.either:&#xA;    val user: User = findUserById(&#34;42&#34;)&#xA;    user.name.toUpperCase&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please praise the simplicity and absence of boilerplate code, like calls to &lt;code&gt;map&lt;/code&gt; functions or when expressions. This is the power of Scala direct style.&lt;/p&gt; &#xA;&lt;p&gt;It’s also possible to make the backward conversion from an &lt;code&gt;Either[E, A]&lt;/code&gt; to a &lt;code&gt;Raise[E]&lt;/code&gt; using the &lt;code&gt;bind&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val userNameInUpperCaseRaiseLambda: Raise[Error] ?=&amp;gt; String = maybeUserNameInUpperCase.bind()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;bind&lt;/code&gt; function is very handful when we need to compose functions that return an &lt;code&gt;Either[E, A]&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val one = Right(1)&#xA;val two = Right(2)&#xA;val three = Raise.either {&#xA;  val oneValue = one.bind()&#xA;  val twoValue = two.bind()&#xA;  oneValue + twoValue&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;bind&lt;/code&gt; function calls the &lt;code&gt;raise&lt;/code&gt; function if the &lt;code&gt;Either&lt;/code&gt; instance is a &lt;code&gt;Left&lt;/code&gt;; otherwise, it returns the value wrapped by the &lt;code&gt;Right&lt;/code&gt; instance. Despite the trivial logic implemented in the above example, it&#39;s a good example of how to compose functions that return an &lt;code&gt;Either[E, A]&lt;/code&gt; using the Raise DSL without the use of any &lt;code&gt;flatMap&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;We can do the same with &lt;code&gt;Try[A]&lt;/code&gt; and &lt;code&gt;Option[A]&lt;/code&gt; using the &lt;code&gt;$try&lt;/code&gt; and &lt;code&gt;option&lt;/code&gt; builders, respectively. Let&#39;s start with the &lt;code&gt;$try&lt;/code&gt; builder. In this case, the only available type of error is &lt;code&gt;Throwable&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val maybeUserWithTry: Try[User] =&#xA;  Raise.$try:&#xA;    findUserByIdWithEx(&#34;42&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you might guess, any fatal exception thrown inside the &lt;code&gt;$try&lt;/code&gt; context will bubble up and not handled.&lt;/p&gt; &#xA;&lt;p&gt;Last but not least, the &lt;code&gt;option&lt;/code&gt; builder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findUserByIdWithNone(id: String): User raises None.type =&#xA;  if (id == &#34;42&#34;) User(id, &#34;Alice&#34;) else Raise.raise(None)&#xA;&#xA;val maybeUserWithOpt: Option[User] =&#xA;  Raise.option:&#xA;    findUserByIdWithNone(&#34;42&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;bind&lt;/code&gt; function is available for &lt;code&gt;Try[A]&lt;/code&gt; and &lt;code&gt;Option[A]&lt;/code&gt; as well.&lt;/p&gt; &#xA;&lt;p&gt;By the way, there are more feature in the Raise DSL. Please, check the documentation for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you want to contribute to the project, please do it! Any help is welcome.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;This project is inspired by the Arrow Kt library&#39;s Raise DSL. I want to thank the Arrow Kt team for their outstanding work. In detail, thanks to Simon Vergauwen for the great discussions we had on Slack. A lot of thanks also to Daniel Ciocîrlan, my mentor and friend.&lt;/p&gt;</summary>
  </entry>
</feed>