<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-26T01:37:56Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>scalaz/scalaz</title>
    <updated>2022-09-26T01:37:56Z</updated>
    <id>tag:github.com,2022-09-26:/scalaz/scalaz</id>
    <link href="https://github.com/scalaz/scalaz" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Principled Functional Programming in Scala&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Scalaz&lt;/h1&gt; &#xA;&lt;p&gt;Scalaz is a Scala library for functional programming.&lt;/p&gt; &#xA;&lt;p&gt;It provides purely functional data structures to complement those from the Scala standard library. It defines a set of foundational type classes (e.g. &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Monad&lt;/code&gt;) and corresponding instances for a large number of data structures.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;irc://irc.libera.chat/scalaz&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/chat-on%20libera-brightgreen.svg?sanitize=true&#34; alt=&#34;IRC&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Scalaz&lt;/h2&gt; &#xA;&lt;p&gt;The current stable version is 7.3.6, which is cross-built against Scala 2.11.x, 2.12.x, 2.13.x, 3.x and Scala.js, scala-native.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re using SBT, add the following line to your build file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;org.scalaz&#34; %% &#34;scalaz-core&#34; % &#34;7.3.6&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Maven and other build tools, you can visit &lt;a href=&#34;https://search.maven.org/search?q=g:org.scalaz%20AND%20v:7.3.6&#34;&gt;search.maven.org&lt;/a&gt;. (This search will also list all available modules of scalaz.)&lt;/p&gt; &#xA;&lt;p&gt;To get sample configurations, click on the version of the module you are interested in. You can also find direct download links at the bottom of that page. Choose the file ending in &lt;code&gt;7.3.6.jar&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scalaz._&#xA;import std.option._, std.list._ // functions and type class instances for Option and List&#xA;&#xA;scala&amp;gt; Apply[Option].apply2(some(1), some(2))((a, b) =&amp;gt; a + b)&#xA;res0: Option[Int] = Some(3)&#xA;&#xA;scala&amp;gt; Traverse[List].traverse(List(1, 2, 3))(i =&amp;gt; some(i))&#xA;res1: Option[List[Int]] = Some(List(1, 2, 3))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use of the &lt;code&gt;Ops&lt;/code&gt; classes, defined under &lt;code&gt;scalaz.syntax&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scalaz._&#xA;import std.list._ // type class instances for List&#xA;import syntax.bind._ // syntax for the Bind type class (and its parents)&#xA;&#xA;scala&amp;gt; List(List(1)).join&#xA;res0: List[Int] = List(1)&#xA;&#xA;scala&amp;gt; List(true, false).ifM(List(0, 1), List(2, 3))&#xA;res1: List[Int] = List(0, 1, 2, 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;ve gone to great lengths to give you an &lt;em&gt;a-la-carte&lt;/em&gt; importing experience, but if you prefer an all-you-can-eat buffet, you&#39;re in luck:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scalaz._&#xA;import Scalaz._&#xA;&#xA;scala&amp;gt; NonEmptyList(1, 2, 3).cojoin&#xA;res0: scalaz.NonEmptyList[scalaz.NonEmptyList[Int]] = NonEmptyList(NonEmptyList(1, 2, 3), NonEmptyList(2, 3), NonEmptyList(3))&#xA;&#xA;scala&amp;gt; 1.node(2.leaf, 3.node(4.leaf))&#xA;res1: scalaz.Tree[Int] = &amp;lt;tree&amp;gt;&#xA;&#xA;scala&amp;gt; List(some(1), none).suml&#xA;res2: Option[Int] = Some(1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;p&gt;Let the types speak for themselves via the &lt;a href=&#34;https://scalaz.github.io/scalaz/#scaladoc&#34;&gt;Scalaz Scaladocs&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/scalaz/scalaz/tree/master/example/src/main/scala/scalaz/example&#34;&gt;examples module&lt;/a&gt; contains some snippets of Scalaz usage.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/scalaz/scalaz/wiki&#34;&gt;wiki&lt;/a&gt; contains release and migration information.&lt;/p&gt; &#xA;&lt;p&gt;Talk with us by joining &lt;a href=&#34;https://web.libera.chat/#scalaz&#34;&gt;IRC: irc.libera.chat channel #scalaz&lt;/a&gt;, or join &lt;a href=&#34;https://groups.google.com/group/scalaz&#34;&gt;the Scalaz mailing list on Google Groups&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://typelevel.org/blog/&#34;&gt;typelevel blog&lt;/a&gt; has some great posts such as &lt;a href=&#34;https://typelevel.org/blog/2013/10/13/towards-scalaz-1.html&#34;&gt;Towards Scalaz&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/adelbertchang&#34;&gt;Adelbert Chang&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://eed3si9n.com/learning-scalaz/index.html&#34;&gt;Learning Scalaz&lt;/a&gt; is a great series of blog posts by &lt;a href=&#34;https://twitter.com/eed3si9n&#34;&gt;Eugene Yokota&lt;/a&gt;. Thanks, Eugene!&lt;/p&gt; &#xA;&lt;h2&gt;Changes in Version 7&lt;/h2&gt; &#xA;&lt;p&gt;Scalaz 7 represents a major reorganization of the library. We have taken a fresh look at the challenges of encoding type classes in Scala, in particular at when and how to employ the implicit scope.&lt;/p&gt; &#xA;&lt;h3&gt;At a glance&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;scalaz.{effect, iteratee}&lt;/code&gt; split to separate sub-projects; &lt;code&gt;scalaz.{http, geo}&lt;/code&gt; dropped.&lt;/li&gt; &#xA; &lt;li&gt;Refined and expanded the type class hierarchy.&lt;/li&gt; &#xA; &lt;li&gt;Type class instances are no longer defined in the companion objects of the type class. Instances for standard library types are defined under &lt;code&gt;scalaz.std&lt;/code&gt;, and instances for Scalaz data types are defined in the companion object for those types. An instance definition can provide multiple type classes in a single place, which was not always possible in Scalaz 6.&lt;/li&gt; &#xA; &lt;li&gt;Type class instances have been organized to avoid ambiguity, a problem that arises when instances are dependent on other instances (for example, &lt;code&gt;Monoid[(A, B)]&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Use of implicit views to provide access to Scalaz functionality as extension methods has been segregated to &lt;code&gt;scalaz.syntax&lt;/code&gt;, and can be imported selectively, and need not be used at all.&lt;/li&gt; &#xA; &lt;li&gt;Related functions are defined in the type class trait, to support standalone usage of the type class. In Scalaz 6, these were defined in &lt;code&gt;Identity&lt;/code&gt;, &lt;code&gt;MA&lt;/code&gt;, or &lt;code&gt;MAB&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;New data structures have been added, and existing ones generalized. A number of monad transformers have been provided, in some cases generalizing old data structures.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Modularity&lt;/h3&gt; &#xA;&lt;p&gt;Scalaz has been modularised.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;scalaz-core&lt;/strong&gt;: Type class hierarchy, data structures, type class instances for the Scala and Java standard libraries, implicit conversions / syntax to access these.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;scalaz-effect&lt;/strong&gt;: Data structures to represent and compose IO effects in the type system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;scalaz-iteratee&lt;/strong&gt;: Experimental new Iteratee implementation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Type Class Hierarchy&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Type classes form an inheritance hierarchy, as in Scalaz 6. This is convenient both at the call site and at the type class instance definition. At the call site, it ensures that you can call a method requiring a more general type class with an instance of a more specific type class:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def bar[M[_]: Functor] = ()&#xA;&#xA;def foo[M[_]: Monad] = bar[M] // Monad[M] is a subtype of Functor[M]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The hierarchy itself is largely the same as in Scalaz 6. However, there have been a few adjustments, some method signatures have been adjusted to support better standalone usage, so code depending on these will need to be re-worked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Type Class Instance Definition&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Constructive&lt;/em&gt; implicits, which create a type class instance automatically based on instances of all parent type classes, are removed. These led to subtle errors with ambiguous implicits, such as this problem with &lt;a href=&#34;https://stackoverflow.com/questions/7447591/how-do-i-use-name-as-an-applicative/7448111#7448111&#34;&gt;FunctorBindApply&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Type class instances are no longer declared in fragments in the companion objects of the type class. Instead, they are defined in the package &lt;code&gt;scalaz.std&lt;/code&gt;, and must be imported. These instances are defined in traits which will be mixed together into an object for importing &lt;em&gt;en-masse&lt;/em&gt;, if desired.&lt;/li&gt; &#xA; &lt;li&gt;A single implicit can define a number of type class instances for a type.&lt;/li&gt; &#xA; &lt;li&gt;A type class definition can override methods (including derived methods) for efficiency.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here is an instance definition for &lt;code&gt;Option&lt;/code&gt;. Notice that the method &lt;code&gt;map&lt;/code&gt; has been overridden.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  implicit val option: Traverse[Option] with MonadPlus[Option] = new Traverse[Option] with MonadPlus[Option] {&#xA;    def point[A](a: =&amp;gt; A) = Some(a)&#xA;    def bind[A, B](fa: Option[A])(f: A =&amp;gt; Option[B]): Option[B] = fa flatMap f&#xA;    override def map[A, B](fa: Option[A])(f: A =&amp;gt; B): Option[B] = fa map f&#xA;    def traverseImpl[F[_], A, B](fa: Option[A])(f: A =&amp;gt; F[B])(implicit F: Applicative[F]) =&#xA;      fa map (a =&amp;gt; F.map(f(a))(Some(_): Option[B])) getOrElse F.point(None)&#xA;    def empty[A]: Option[A] = None&#xA;    def plus[A](a: Option[A], b: =&amp;gt; Option[A]) = a orElse b&#xA;    def foldR[A, B](fa: Option[A], z: B)(f: (A) =&amp;gt; (=&amp;gt; B) =&amp;gt; B): B = fa match {&#xA;      case Some(a) =&amp;gt; f(a)(z)&#xA;      case None =&amp;gt; z&#xA;    }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use this, one would:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scalaz.std.option.optionInstance&#xA;// or, importing all instances en-masse&#xA;// import scalaz.Scalaz._&#xA;&#xA;val M = Monad[Option]&#xA;val oi: Option[Int] = M.point(0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Syntax&lt;/h3&gt; &#xA;&lt;p&gt;We co-opt the term &lt;em&gt;syntax&lt;/em&gt; to refer to the way we allow the functionality of Scalaz to be called in the &lt;code&gt;object.method(args)&lt;/code&gt; form, which can be easier to read, and, given that type inference in Scala flows from left-to-right, can require fewer type annotations.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No more &lt;code&gt;Identity&lt;/code&gt;, &lt;code&gt;MA&lt;/code&gt;, or &lt;code&gt;MAB&lt;/code&gt; from Scalaz 6.&lt;/li&gt; &#xA; &lt;li&gt;Syntax is segregated from rest of the library, in a sub-package &lt;code&gt;scalaz.syntax&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;All Scalaz functionality is available &lt;em&gt;without&lt;/em&gt; using the provided syntax, by directly calling methods on the type class or its companion object.&lt;/li&gt; &#xA; &lt;li&gt;Syntax is available &lt;em&gt;a-la-carte&lt;/em&gt;. You can import the syntax for working with particular type classes where you need it. This avoids flooding the autocompletion in your IDE with every possible extension method. This should also help compiler performance, by reducing the implicit search space.&lt;/li&gt; &#xA; &lt;li&gt;Syntax is layered in the same way as type classes. Importing the syntax for, say, &lt;code&gt;Applicative&lt;/code&gt; will also provide the syntax for &lt;code&gt;Apply&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Syntax can be imported in two ways. Firstly, the syntax specialized for a particular instance of a type class can be imported directly from the instance itself.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// import the type class instance&#xA;import scalaz.std.option.optionInstance&#xA;&#xA;// import the implicit conversions to `MonadOps[Option, A]`, `BindOps[Option, A]`, ...&#xA;import optionInstance.monadSyntax._&#xA;&#xA;val oi: Option[Option[Int]] = Some(Some(1))&#xA;&#xA;// Expands to: `ToBindOps(io).join`&#xA;oi.join&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, the syntax can be imported for a particular type class.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// import the type class instance&#xA;import scalaz.std.option.optionInstance&#xA;&#xA;// import the implicit conversions to `MonadOps[F, A]`, `BindOps[F, A]`, ...&#xA;import scalaz.syntax.monad._&#xA;&#xA;val oi: Option[Option[Int]] = Some(Some(1))&#xA;&#xA;// Expands to: ToBindOps(io).join&#xA;oi.join&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For some degree of backwards compatibility with Scalaz 6, the über-import of &lt;code&gt;import scalaz.Scalaz._&lt;/code&gt; will import &lt;em&gt;all&lt;/em&gt; implicit conversions that provide syntax (as well as type class instances and other functions). However, we recommend to review usage of this and replace with more focussed imports.&lt;/p&gt; &#xA;&lt;h3&gt;Standalone Type Class Usage&lt;/h3&gt; &#xA;&lt;p&gt;Type classes should be directly usable, without first needing to trigger implicit conversions. This might be desirable to reduce the runtime or cognitive overhead of the pimped types, or to define your own pimped types with a syntax of your choosing.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The methods in type classes have been curried to maximize type inference.&lt;/li&gt; &#xA; &lt;li&gt;Derived methods, based on the abstract methods in a type class, are defined in the type class itself.&lt;/li&gt; &#xA; &lt;li&gt;Each type class companion object is fitted with a convenient &lt;code&gt;apply&lt;/code&gt; method to obtain an instance of the type class.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;    // Equivalent to `implicitly[Monad[Option]]`&#xA;    val O = Monad[Option]&#xA;&#xA;    // `bind` is defined with two parameter sections, so that the type of `x` is inferred as `Int`.&#xA;    O.bind(Some(1))(x =&amp;gt; Some(x * 2))&#xA;&#xA;    def plus(a: Int, b: Int) = a + b&#xA;&#xA;    // `Apply#lift2` is a function derived from `Apply#ap`.&#xA;    val plusOpt = O.lift2(plus)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Type Class Instance Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;Type class instances may depend on other instances. In simple cases, this is as straightforward as adding an implicit parameter (or, equivalently, a context bound), to the implicit method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  implicit def optionMonoid[A: Semigroup]: Monoid[Option[A]] = new Monoid[Option[A]] {&#xA;    def append(f1: Option[A], f2: =&amp;gt; Option[A]): Option[A] = (f1, f2) match {&#xA;      case (Some(a1), Some(a2)) =&amp;gt; Some(Semigroup[A].append(a1, a2))&#xA;      case (Some(a1), None) =&amp;gt; f1&#xA;      case (None, Some(a2)) =&amp;gt; f2&#xA;      case (None, None) =&amp;gt; None&#xA;    }&#xA;&#xA;    def zero: Option[A] = None&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type class instances for &#39;transformers&#39;, such as &lt;code&gt;OptionT&lt;/code&gt;, present a more subtle challenge. &lt;code&gt;OptionT[F, A]&lt;/code&gt; is a wrapper for a value of type &lt;code&gt;F[Option[A]]&lt;/code&gt;. It allows us to write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val ot = OptionT(List(Some(1), None))&#xA;ot.map((a: Int) =&amp;gt; a * 2) // OptionT(List(Some(2), None))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The method &lt;code&gt;OptionT#map&lt;/code&gt; requires an implicit parameter of type &lt;code&gt;Functor[F]&lt;/code&gt;, whereas &lt;code&gt;OptionT#flatMap&lt;/code&gt; requires one of type &lt;code&gt;Monad[F]&lt;/code&gt;. The capabilities of &lt;code&gt;OptionT&lt;/code&gt; increase with those of &lt;code&gt;F&lt;/code&gt;. We need to encode this into the type class instances for &lt;code&gt;[a]OptionT[F[A]]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is done with a hierarchy of &lt;a href=&#34;https://github.com/scalaz/scalaz/raw/v7.1.2/core/src/main/scala/scalaz/OptionT.scala#L122&#34;&gt;type class implementation traits&lt;/a&gt; and a corresponding set of &lt;a href=&#34;https://github.com/scalaz/scalaz/raw/v7.1.2/core/src/main/scala/scalaz/OptionT.scala#L24&#34;&gt;prioritized implicit methods&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In case of ambiguous implicits, Scala will favour one defined in a sub-class of the other. This is to avoid ambiguity when in cases like the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type OptionTList[A] = OptionT[List[A]]&#xA;implicitly[Functor[OptionTList]]&#xA;&#xA;// Candidates:&#xA;// 1. OptionT.OptionTFunctor[List](implicitly[Functor[List]])&#xA;// 2. OptionT.OptionTMonad[List](implicitly[Functor[List]])&#xA;// #2 is defined in a subclass of the enclosing class of #1, so #2 is preferred.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transformers and Identity&lt;/h3&gt; &#xA;&lt;p&gt;A stronger emphasis has been placed on transformer data structures (aka Monad Transformers). For example &lt;code&gt;State&lt;/code&gt; is now a type alias for &lt;code&gt;StateT[Id, A, B]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Id&lt;/code&gt; is defined in the &lt;code&gt;scalaz&lt;/code&gt; package object as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type Id[A] = A&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/raw/master/CONTRIBUTING.md&#34;&gt;Documentation for contributors&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;Support for Scalaz development is provided by &lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;Jetbrains&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to Mark Harrah and the sbt contributors for providing &lt;a href=&#34;https://www.scala-sbt.org&#34;&gt;our build tool&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>