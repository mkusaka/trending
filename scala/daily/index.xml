<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-15T01:36:42Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>typelevel/fabric</title>
    <updated>2022-12-15T01:36:42Z</updated>
    <id>tag:github.com,2022-12-15:/typelevel/fabric</id>
    <link href="https://github.com/typelevel/fabric" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Object-Notation Abstraction for JSON, binary, HOCON, etc.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;fabric&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/typelevel/fabric/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/typelevel/fabric/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/typelevel/fabric&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Join%20Chat.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/org.typelevel/fabric-core_2.13&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/org.typelevel/fabric-core_2.13/badge.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://index.scala-lang.org/typelevel/fabric/fabric-core&#34;&gt;&lt;img src=&#34;https://index.scala-lang.org/typelevel/fabric/fabric-core/latest.svg?sanitize=true&#34; alt=&#34;fabric-core Scala version support&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Abstract Syntax Tree (AST) based on JSON concepts, but more abstract for parsing and application.&lt;/p&gt; &#xA;&lt;h2&gt;Justification&lt;/h2&gt; &#xA;&lt;p&gt;Having worked with Circe and uPickle for years there are many things I love about each, but unfortunately a few things I was frustrated by. At a high level, I think Circe can be a bit overly complicated and compilation quite slow in large projects. With uPickle, I found the mutable underlying references within the structure very concerning and problematic when doing things like merges. Both of them suffer from slow releases periodically, so I ultimately decided to try my hand at accomplishing the same and incorporate some of my own crazy ideas in the process.&lt;/p&gt; &#xA;&lt;p&gt;I won&#39;t say that fabric is a better library than either of those great projects, but it was inspired by both of them and customized to suit my particular needs. If you find it useful as well, please use it and offer some feedback.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;I wrote a performance benchmark with every expectation to be slower than the alternatives as I&#39;ve done very little tuning, and I&#39;m just one person versus the many developers that have worked on the others for years. However, I was shocked to see how well my little library performed compared to the alternatives: &lt;a href=&#34;https://jmh.morethan.io/?source=https://raw.githubusercontent.com/typelevel/fabric/master/bench/results/benchmarks-1.7.0.json&#34;&gt;JMH Results for 1.7.0 on Scala 3&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;The focus of this project is minimalism and flexibility. To that end, the features are somewhat sparse:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for JVM, Scala.js, and Scala Native&lt;/li&gt; &#xA; &lt;li&gt;Support for Scala 2.11, 2.12, 2.13, and 3.x&lt;/li&gt; &#xA; &lt;li&gt;AST for representation of &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Numeric&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt; in a type-safe and immutable way&lt;/li&gt; &#xA; &lt;li&gt;Clean DSL to create tree structures&lt;/li&gt; &#xA; &lt;li&gt;Deep merging support&lt;/li&gt; &#xA; &lt;li&gt;Compile-time generation of conversions to/from case classes with support for default arguments&lt;/li&gt; &#xA; &lt;li&gt;Easy and convenient extensibility support&lt;/li&gt; &#xA; &lt;li&gt;Parsing support for JSON on JVM and Scala.js&lt;/li&gt; &#xA; &lt;li&gt;JSON DDL generation from data&lt;/li&gt; &#xA; &lt;li&gt;Scala code generation from JSON DDL (data -&amp;gt; DDL -&amp;gt; Scala) for easy data mapping&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;p&gt;For SBT simply include: &lt;code&gt;libraryDependencies += &#34;org.typelevel&#34; %%% &#34;fabric-core&#34; % &#34;1.8.3&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For parsing support include: &lt;code&gt;libraryDependencies += &#34;org.typelevel&#34; %%% &#34;fabric-io&#34; % &#34;1.8.3&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Create&lt;/h3&gt; &#xA;&lt;p&gt;Creating fabric structures with the DSL is very easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import fabric._&#xA;&#xA;val v1 = obj(&#xA;  &#34;name&#34; -&amp;gt; &#34;John Doe&#34;,&#xA;  &#34;age&#34; -&amp;gt; 21,&#xA;  &#34;numbers&#34; -&amp;gt; List(1, 2, 3),&#xA;  &#34;address&#34; -&amp;gt; obj(&#xA;    &#34;street&#34; -&amp;gt; &#34;123 Somewhere Rd.&#34;,&#xA;    &#34;city&#34; -&amp;gt; &#34;San Jose&#34;&#xA;  )&#xA;)&#xA;// v1: Obj = {&#34;name&#34;: &#34;John Doe&#34;, &#34;age&#34;: 21, &#34;numbers&#34;: [1, 2, 3], &#34;address&#34;: {&#34;street&#34;: &#34;123 Somewhere Rd.&#34;, &#34;city&#34;: &#34;San Jose&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Merging&lt;/h3&gt; &#xA;&lt;p&gt;Deep-merging is trivial:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import fabric._&#xA;&#xA;val v2 = obj(&#xA;  &#34;age&#34; -&amp;gt; 23,&#xA;  &#34;numbers&#34; -&amp;gt; List(4, 5, 6),&#xA;  &#34;address&#34; -&amp;gt; obj(&#xA;    &#34;state&#34; -&amp;gt; &#34;California&#34;&#xA;  )&#xA;)&#xA;// v2: Obj = {&#34;age&#34;: 23, &#34;numbers&#34;: [4, 5, 6], &#34;address&#34;: {&#34;state&#34;: &#34;California&#34;}}&#xA;&#xA;val v3 = v1.merge(v2)&#xA;// v3: Json = {&#34;age&#34;: 23, &#34;numbers&#34;: [4, 5, 6], &#34;address&#34;: {&#34;state&#34;: &#34;California&#34;, &#34;street&#34;: &#34;123 Somewhere Rd.&#34;, &#34;city&#34;: &#34;San Jose&#34;}, &#34;name&#34;: &#34;John Doe&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is worth mentioning that because values are immutable, &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; remain unchanged.&lt;/p&gt; &#xA;&lt;h3&gt;Convert&lt;/h3&gt; &#xA;&lt;p&gt;Conversion to other types is very easy with the built-in compile-time conversions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import fabric._&#xA;import fabric.rw._&#xA;&#xA;val person = obj(&#xA;  &#34;name&#34; -&amp;gt; &#34;John Doe&#34;,&#xA;  &#34;age&#34; -&amp;gt; 21&#xA;).as[Person]&#xA;// person: Person = Person(name = &#34;John Doe&#34;, age = 21)&#xA;&#xA;val backToValue: Json = person.json&#xA;// backToValue: Json = {&#34;name&#34;: &#34;John Doe&#34;, &#34;age&#34;: 21}&#xA;&#xA;case class Person(name: String, age: Int)&#xA;&#xA;object Person {&#xA;  implicit val rw: RW[Person] = RW.gen[Person]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parse&lt;/h3&gt; &#xA;&lt;p&gt;Parsing from existing JSON requires the use of the &lt;code&gt;fabric-parse&lt;/code&gt; module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import fabric._&#xA;import fabric.io._&#xA;&#xA;val value = JsonParser(&#34;&#34;&#34;{&#34;name&#34;: &#34;John Doe&#34;, &#34;age&#34;: 21}&#34;&#34;&#34;, Format.Json)&#xA;// value: Json = {&#34;name&#34;: &#34;John Doe&#34;, &#34;age&#34;: 21}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Formatting&lt;/h3&gt; &#xA;&lt;p&gt;Taking an existing value and formatting it for output as JSON:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val formattedString: String = JsonFormatter.Default(value)&#xA;// formattedString: String = &#34;&#34;&#34;{&#xA;//   &#34;name&#34;: &#34;John Doe&#34;,&#xA;//   &#34;age&#34;: 21&#xA;// }&#34;&#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>mariussoutier/PlayBasics</title>
    <updated>2022-12-15T01:36:42Z</updated>
    <id>tag:github.com,2022-12-15:/mariussoutier/PlayBasics</id>
    <link href="https://github.com/mariussoutier/PlayBasics" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Example code for my tutorial series about Play Framework 2.x&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Play Basics&lt;/h1&gt; &#xA;&lt;h2&gt;Templates&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.mariussoutier.com/blog/2012/04/27/play-framework-2-0-templates-part-1-parameters/&#34;&gt;http://www.mariussoutier.com/blog/2012/04/27/play-framework-2-0-templates-part-1-parameters/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Routes&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.mariussoutier.com/blog/2012/12/10/playframework-routes-part-1-basics/&#34;&gt;http://www.mariussoutier.com/blog/2012/12/10/playframework-routes-part-1-basics/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.mariussoutier.com/blog/2012/12/11/playframework-routes-part-2-advanced/&#34;&gt;http://www.mariussoutier.com/blog/2012/12/11/playframework-routes-part-2-advanced/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Actions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.mariussoutier.com/blog/2013/09/17/playframework-2-2-action-building-action-composition/&#34;&gt;http://www.mariussoutier.com/blog/2013/09/17/playframework-2-2-action-building-action-composition/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Dependency Injection&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://mariussoutier.com/blog/2015/12/06/playframework-2-4-dependency-injection-di/&#34;&gt;http://mariussoutier.com/blog/2015/12/06/playframework-2-4-dependency-injection-di/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>