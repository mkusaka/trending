<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-08T01:55:10Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ucb-bar/riscv-torture</title>
    <updated>2022-07-08T01:55:10Z</updated>
    <id>tag:github.com,2022-07-08:/ucb-bar/riscv-torture</id>
    <link href="https://github.com/ucb-bar/riscv-torture" rel="alternate"></link>
    <summary type="html">&lt;p&gt;RISC-V Torture Test&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;=========================================================================== RISC-V Torture Test Generator&lt;/h1&gt; &#xA;&lt;h1&gt;Author: Yunsup Lee and Henry Cook&lt;/h1&gt; &#xA;&lt;h1&gt;Date: January 29th, 2012&lt;/h1&gt; &#xA;&lt;h1&gt;Version: (under version control)&lt;/h1&gt; &#xA;&lt;p&gt;This is the RISC-V torture test generator and framework. This repository contains three sub-projects that build upon one another. The first, [generator], is used to create a single random torture test. The second, [testrun], is used to run a particular test on particular simulators, diffing the resulting signature with the ISA simulator and optionally creating a derivative test subset that pinpoints the divergence. The third, [overnight], wraps testrun, allowing tests to be run repeatedly for a given duration or until a failure count.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;p&gt;Modify &#34;config/default.config&#34; to set the parameters desired for building tests (e.g., setting which instructions to use and in which ratio).&lt;/p&gt; &#xA;&lt;p&gt;Modify &#34;Makefile&#34; as desired to execute the C simulator or RTL simulator of your choice, and to set the other parameters as you require.&lt;/p&gt; &#xA;&lt;p&gt;To build a single test and test it on Spike:&lt;/p&gt; &#xA;&lt;p&gt;$ make igentest&lt;/p&gt; &#xA;&lt;p&gt;To build single test and run it on the C simulator or RTL simulator, use &#34;make cgentest&#34; or &#34;make rgentest&#34;.&lt;/p&gt; &#xA;&lt;p&gt;To run overnight tests, you can use &#34;make cnight&#34; and &#34;make rnight&#34;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Signatures&lt;/h2&gt; &#xA;&lt;p&gt;Torture works by dumping the register state out to memory at the end of the test program execution. This output is then compared against the output from the Spike ISA simulator.&lt;/p&gt; &#xA;&lt;p&gt;The torture program writes the register state to the memory address specified by &#34;xreg_output_data&#34;, which is located in the memory section &#34;.global begin_signature&#34;. The Spike ISA simulator will write out the data found in the &#34;begin_signature&#34; section on exit if provided with the &#34;+signature=&#34; argument:&lt;/p&gt; &#xA;&lt;p&gt;$ spike +signature=my_spike_signature.txt test_binary&lt;/p&gt; &#xA;&lt;p&gt;The Rocket-chip infrastructure uses the &#34;riscv-fesvr&#34; program to control the execution of the C and RTL simulators. The &#34;riscv-fesvr&#34; also accepts the +signature argument too.&lt;/p&gt; &#xA;&lt;p&gt;$ ./csim-rocket-chip +signature=my_rocket_signature.txt test_binary&lt;/p&gt; &#xA;&lt;p&gt;A simple diff between the Spike and chip simulator signatures will tell you if any errors have occurred.&lt;/p&gt; &#xA;&lt;p&gt;$ diff my_spike_signature.txt my_rocket_signature.txt&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;PORTING TORTURE TO YOUR OWN RISC-V PROCESSOR:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you would like to use riscv-torture with your own RISC-V processor, you will need to provide a way to dump the &#34;begin_signature&#34; section to a file.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Low-level Usage&lt;/h2&gt; &#xA;&lt;p&gt;Some basic use cases are illustrated here (note the Makefile abstracts this for you).&lt;/p&gt; &#xA;&lt;p&gt;Make a single test: % ./sbt generator/run % cd output % make % spike +signature=test.sig test&lt;/p&gt; &#xA;&lt;p&gt;Take an existing test and diff the signatures of ISA and C simulators: % ./sbt &#39;testrun/run -a output/test.S -c /path/to/reference-chip/emulator/emulator&#39;&lt;/p&gt; &#xA;&lt;p&gt;*** Currently, due to the limiation of scala process library, you cannot torture the RTL simulator ***&lt;/p&gt; &#xA;&lt;h1&gt;Generate a random test and diff the signatures of ISA and RTL simulators:&lt;/h1&gt; &#xA;&lt;h1&gt;% ./sbt &#39;testrun/run -r /path/to/reference-chip/vlsi/build/vcs-sim-rtl/simv&#39;&lt;/h1&gt; &#xA;&lt;p&gt;Run tests for 30 minutes, email hcook when done, and save failures to dir: % ./sbt &#39;overnight/run -m 30 -e &lt;a href=&#34;mailto:hcook@eecs.berkeley.edu&#34;&gt;hcook@eecs.berkeley.edu&lt;/a&gt; -p dir&#39;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;p&gt;% git submodule update --init&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Overnight Overview&lt;/h2&gt; &#xA;&lt;p&gt;This framework utilizes both the test runner and test generator to perform a long terms serach for failing test cases. It takes the following command line arguments:&lt;/p&gt; &#xA;&lt;p&gt;Usage: overnight/run [options] -C &#xA; &lt;file&gt;&#xA;   | --config &#xA;  &lt;file&gt;&#xA;    config file -p &#xA;  &lt;/file&gt;&#xA; &lt;/file&gt;&lt;/p&gt;&#xA;&lt;dir&gt;&#xA;  | --permdir &#xA; &lt;dir&gt;&#xA;   dir to store failing tests -c &#xA;  &lt;file&gt;&#xA;    | --csim &#xA;   &lt;file&gt;&#xA;     C simulator -r &#xA;    &lt;file&gt;&#xA;      | --rtlsim &#xA;     &lt;file&gt;&#xA;       RTL simulator -e &#xA;      &lt;address&gt; | --email &lt;address&gt; email to report to -t &#xA;        &lt;count&gt;&#xA;          | --threshold &#xA;         &lt;count&gt;&#xA;           number of failures to trigger email -m &#xA;          &lt;int&gt;&#xA;            | --minutes &#xA;           &lt;int&gt;&#xA;             number of minutes to run tests&#xA;            &lt;p&gt;&lt;/p&gt; &#xA;            &lt;p&gt;You can only generate tests with one instruction mix at a time (based on the setting in the config file). It doesn&#39;t matter what simulator you use with the -r and -c flags, they just determines the name used to describe whose diff failed.&lt;/p&gt; &#xA;            &lt;hr&gt; &#xA;            &lt;h2&gt;Testrun Overview&lt;/h2&gt; &#xA;            &lt;p&gt;This utility compares the signatures generated by passing the -testsig flag to the specified simulators. If it encounters a difference, it subdivides the test into many subtests and searches for which exact program segment reveals the failure. It takes the following command line arguments:&lt;/p&gt; &#xA;            &lt;p&gt;Usage: testrun/run [options] -C &#xA;             &lt;file&gt;&#xA;               | --config &#xA;              &lt;file&gt;&#xA;                config file -a &#xA;               &lt;file&gt;&#xA;                 | --asm &#xA;                &lt;file&gt;&#xA;                  input ASM file -c &#xA;                 &lt;file&gt;&#xA;                   | --csim &#xA;                  &lt;file&gt;&#xA;                    C simulator -r &#xA;                   &lt;file&gt;&#xA;                     | --rtlsim &#xA;                    &lt;file&gt;&#xA;                      RTL simulator -s &#xA;                     &lt;boolean&gt;&#xA;                       | --seek &#xA;                      &lt;boolean&gt;&#xA;                        Seek for failing pseg -d &#xA;                       &lt;boolean&gt;&#xA;                         | --dump &#xA;                        &lt;boolean&gt;&#xA;                          Dump mismatched signatures&#xA;                        &lt;/boolean&gt;&#xA;                       &lt;/boolean&gt;&#xA;                      &lt;/boolean&gt;&#xA;                     &lt;/boolean&gt;&#xA;                    &lt;/file&gt;&#xA;                   &lt;/file&gt;&#xA;                  &lt;/file&gt;&#xA;                 &lt;/file&gt;&#xA;                &lt;/file&gt;&#xA;               &lt;/file&gt;&#xA;              &lt;/file&gt;&#xA;             &lt;/file&gt;&lt;/p&gt; &#xA;            &lt;p&gt;If you don&#39;t specify a asm file, a random one will be generated for you. You can only generate tests with one instruction mix at a time (based on the setting in the config file). It doesn&#39;t matter what simulator you use with the -r and -c flags, they just determines the name used to describe whose diff failed. By default, a failed diff will result in the subtest sweep occuring, but this search can be diasbled. Note that the pseg ID reported is actually the pseg following the pseg containing the error. You can optionally dump mistmatched signatures to the dir containing the asm file under test.&lt;/p&gt; &#xA;            &lt;hr&gt; &#xA;            &lt;h2&gt;Generator Overview&lt;/h2&gt; &#xA;            &lt;p&gt;To generate a random test, the torture test generator randomly generates many test sequences from a set of test sequences that are written by hand, performs a random register allocation for all test sequences, and finally randomly interleaves instructions from these test sequences. To extend the set of tests or coverage, the programmer needs to write new test sequences. It takes the following command line arguments:&lt;/p&gt; &#xA;            &lt;p&gt;Usage: generator/run [options] -o &#xA;             &lt;filename&gt;&#xA;               | --output &#xA;              &lt;filename&gt;&#xA;                output filename -C &#xA;               &lt;file&gt;&#xA;                 | --config &#xA;                &lt;file&gt;&#xA;                  config file&#xA;                &lt;/file&gt;&#xA;               &lt;/file&gt;&#xA;              &lt;/filename&gt;&#xA;             &lt;/filename&gt;&lt;/p&gt; &#xA;            &lt;p&gt;The following sections describe adding new functionality to the generator.&lt;/p&gt; &#xA;            &lt;hr&gt; &#xA;            &lt;h2&gt;Test sequence example&lt;/h2&gt; &#xA;            &lt;p&gt;Before we talk about how to write a test sequence, let&#39;s look at a very simple example. The following example is a test sequence, which emits an add instruction.&lt;/p&gt; &#xA;            &lt;p&gt;class SeqADD extends Seq { val src1 = reg_read_any() val src2 = reg_read_any() val dest = reg_write(src1, src2) insts += ADD(dest, src1, src2) }&lt;/p&gt; &#xA;            &lt;p&gt;As I hinted in the overview that the test generator will do register allocation you don&#39;t write a string of instructions with architectural registers. You request a virtual registers (i.e., registers that are yet tied down to architectural registers) when you need them, save them in scala values, and use them when you need to (e.g., in an instruction).&lt;/p&gt; &#xA;            &lt;hr&gt; &#xA;            &lt;h2&gt;Types of virtual registers&lt;/h2&gt; &#xA;            &lt;ul&gt; &#xA;             &lt;li&gt; &lt;p&gt;Hidden (position dependent registers): Registers that will have different values when the code is positioned at a different address. An example is registers that hold addresses. Registers that are hidden should be excluded from the output signature.&lt;/p&gt; &lt;/li&gt; &#xA;             &lt;li&gt; &lt;p&gt;Visible (position independent registers): Registers that are not hidden, therefore will have the same values when the code is positioned at a different address. These registers should be included as part of the output signature.&lt;/p&gt; &lt;/li&gt; &#xA;            &lt;/ul&gt; &#xA;            &lt;hr&gt; &#xA;            &lt;h2&gt;How to write a sequence&lt;/h2&gt; &#xA;            &lt;p&gt;Use the following functions to request a register, and generate a string of instructions (look at Inst.scala to see what instructions are available) that uses these virtual registers, and add them to the insts array.&lt;/p&gt; &#xA;            &lt;ul&gt; &#xA;             &lt;li&gt;reg_read_zero(): returns register x0&lt;/li&gt; &#xA;             &lt;li&gt;reg_read_any(): returns any type of register (hidden or visible)&lt;/li&gt; &#xA;             &lt;li&gt;reg_read_visible(): returns a visible register&lt;/li&gt; &#xA;             &lt;li&gt;reg_write_ra(): returns register ra for write&lt;/li&gt; &#xA;             &lt;li&gt;reg_write_visible(): returns a visible register for write&lt;/li&gt; &#xA;             &lt;li&gt;reg_write_hidden(): returns a hidden register for write&lt;/li&gt; &#xA;             &lt;li&gt;reg_write(regs: Reg*): returns a register that matches the type of regs (if any reg in regs are hidden, the output type is hidden)&lt;/li&gt; &#xA;            &lt;/ul&gt; &#xA;            &lt;p&gt;Note that the torture test framework is written in scala, you can use any scala functionality to generate instructions. Look at SeqALU.scala, SeqMem.scala, and SeqBranch.scala to get inspired.&lt;/p&gt; &#xA;            &lt;hr&gt; &#xA;            &lt;h2&gt;Future TODO&lt;/h2&gt; &#xA;            &lt;ul&gt; &#xA;             &lt;li&gt; &lt;p&gt;provide support for loops&lt;/p&gt; &lt;/li&gt; &#xA;             &lt;li&gt; &lt;p&gt;generate statistics of a test to get a sense of coverage&lt;/p&gt; &#xA;              &lt;ul&gt; &#xA;               &lt;li&gt;statistics should include instruction count of each type&lt;/li&gt; &#xA;               &lt;li&gt;statistics should include register usage&lt;/li&gt; &#xA;              &lt;/ul&gt; &lt;/li&gt; &#xA;             &lt;li&gt; &lt;p&gt;complete floating point tests&lt;/p&gt; &#xA;              &lt;ul&gt; &#xA;               &lt;li&gt;add floating point memory move tests&lt;/li&gt; &#xA;               &lt;li&gt;improve floating point init randomization&lt;/li&gt; &#xA;               &lt;li&gt;add rounding modes tests&lt;/li&gt; &#xA;              &lt;/ul&gt; &lt;/li&gt; &#xA;             &lt;li&gt; &lt;p&gt;complete vector tests&lt;/p&gt; &#xA;              &lt;ul&gt; &#xA;               &lt;li&gt;better randomization&lt;/li&gt; &#xA;               &lt;li&gt;add SeqVOnly: Tests special vf-only instructions&lt;/li&gt; &#xA;              &lt;/ul&gt; &lt;/li&gt; &#xA;             &lt;li&gt; &lt;p&gt;code refactoring&lt;/p&gt; &#xA;              &lt;ul&gt; &#xA;               &lt;li&gt;consolidate RegPool logic&lt;/li&gt; &#xA;               &lt;li&gt;detect and suppress unallocatable sequences&lt;/li&gt; &#xA;              &lt;/ul&gt; &lt;/li&gt; &#xA;            &lt;/ul&gt; &#xA;           &lt;/int&gt;&#xA;          &lt;/int&gt;&#xA;         &lt;/count&gt;&#xA;        &lt;/count&gt;&lt;/address&gt;&lt;/address&gt;&#xA;     &lt;/file&gt;&#xA;    &lt;/file&gt;&#xA;   &lt;/file&gt;&#xA;  &lt;/file&gt;&#xA; &lt;/dir&gt;&#xA;&lt;/dir&gt;</summary>
  </entry>
  <entry>
    <title>kaitai-io/kaitai_struct_compiler</title>
    <updated>2022-07-08T01:55:10Z</updated>
    <id>tag:github.com,2022-07-08:/kaitai-io/kaitai_struct_compiler</id>
    <link href="https://github.com/kaitai-io/kaitai_struct_compiler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Kaitai Struct: compiler to translate .ksy =&gt; .cpp / .cs / .dot / .go / .java / .js / .lua / .nim / .php / .pm / .py / .rb&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Kaitai Struct: compiler&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/workflow/status/kaitai-io/kaitai_struct_compiler/test&#34; alt=&#34;Build Status&#34;&gt; &lt;a href=&#34;https://search.maven.org/artifact/io.kaitai/kaitai-struct-compiler_2.12&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/io.kaitai/kaitai-struct-compiler_2.12&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/kaitai-struct-compiler/v/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/v/kaitai-struct-compiler/latest&#34; alt=&#34;npm@latest&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.npmjs.com/package/kaitai-struct-compiler/v/next&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/v/kaitai-struct-compiler/next&#34; alt=&#34;npm@next&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.npmtrends.com/kaitai-struct-compiler&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/dm/kaitai-struct-compiler?label=npm%20downloads&#34; alt=&#34;npm downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This project is an official reference compiler for &lt;a href=&#34;http://kaitai.io&#34;&gt;Kaitai Struct&lt;/a&gt; project.&lt;/p&gt; &#xA;&lt;p&gt;Kaitai Struct is a declarative language used to describe various binary data structures, laid out in files or in memory: i.e. binary file formats, network stream packet formats, etc.&lt;/p&gt; &#xA;&lt;p&gt;The main idea is that a particular format is described in Kaitai Struct language (&lt;code&gt;.ksy&lt;/code&gt; files) only once and then can be compiled with this compiler into source files in one of the supported programming languages. These modules will include the generated code for a parser that can read described data structure from a file / stream and give access to it in a nice, easy-to-comprehend API.&lt;/p&gt; &#xA;&lt;h2&gt;Further information&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re looking for information on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Kaitai Struct language itself (&lt;code&gt;.ksy&lt;/code&gt; files, general usage patterns) — refer to the &lt;a href=&#34;http://doc.kaitai.io/user_guide.html&#34;&gt;user guide&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;How to download and install Kaitai Struct — see the &lt;a href=&#34;http://kaitai.io/#download&#34;&gt;downloads&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;How to build the compiler, run the test suite, and join the development — see the &lt;a href=&#34;http://doc.kaitai.io/developers.html&#34;&gt;developer memo&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Licensing&lt;/h2&gt; &#xA;&lt;h3&gt;Main code&lt;/h3&gt; &#xA;&lt;p&gt;Kaitai Struct compiler itself is copyright (C) 2015-2021 Kaitai Project.&lt;/p&gt; &#xA;&lt;p&gt;This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;You should have received a copy of the GNU General Public License along with this program. If not, see &lt;a href=&#34;http://www.gnu.org/licenses/&#34;&gt;http://www.gnu.org/licenses/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;FastParse&lt;/h3&gt; &#xA;&lt;p&gt;Portions of Kaitai Struct compiler are loosely based on &lt;a href=&#34;https://github.com/lihaoyi/fastparse/tree/master/pythonparse/shared/src/main/scala/pythonparse&#34;&gt;pythonparse&lt;/a&gt; from &lt;a href=&#34;https://com-lihaoyi.github.io/fastparse/&#34;&gt;FastParse&lt;/a&gt; and are copyright (c) 2014 Li Haoyi (&lt;a href=&#34;mailto:haoyi.sg@gmail.com&#34;&gt;haoyi.sg@gmail.com&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt; &#xA;&lt;h3&gt;XMLUtils code&lt;/h3&gt; &#xA;&lt;p&gt;Portions of Kaitai Struct compiler are based on &lt;code&gt;scala/xml/Utility.scala&lt;/code&gt; from &lt;a href=&#34;https://github.com/scala/scala-xml&#34;&gt;Scala XML&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2002-2017 EPFL Copyright (c) 2011-2017 Lightbend, Inc.&lt;/p&gt; &#xA;&lt;p&gt;All rights reserved.&lt;/p&gt; &#xA;&lt;p&gt;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.&lt;/li&gt; &#xA; &lt;li&gt;Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.&lt;/li&gt; &#xA; &lt;li&gt;Neither the name of the EPFL nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&lt;/p&gt; &#xA;&lt;h3&gt;Libraries used&lt;/h3&gt; &#xA;&lt;p&gt;Kaitai Struct compiler depends on the following libraries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/scopt/scopt&#34;&gt;scopt&lt;/a&gt; — MIT license&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://com-lihaoyi.github.io/fastparse/&#34;&gt;fastparse&lt;/a&gt; — MIT license&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://bitbucket.org/asomov/snakeyaml&#34;&gt;snakeyaml&lt;/a&gt; — Apache 2.0 license&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Note that these clauses only apply only to compiler itself, not &lt;code&gt;.ksy&lt;/code&gt; input files that one supplies in normal process of compilation, nor to compiler&#39;s output files — that consitutes normal usage process and you obviously keep copyright to both.&lt;/p&gt;</summary>
  </entry>
</feed>