<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-06T01:48:44Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hmemcpy/zio-clippy</title>
    <updated>2023-06-06T01:48:44Z</updated>
    <id>tag:github.com,2023-06-06:/hmemcpy/zio-clippy</id>
    <link href="https://github.com/hmemcpy/zio-clippy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Scala compiler plugin for better ZIO type mismatch errors.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ZIO Clippy&lt;/h1&gt; &#xA;&lt;p&gt;A Scala compiler plugin for better ZIO type mismatch errors.&lt;/p&gt; &#xA;&lt;p&gt;Go from this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hmemcpy/zio-clippy/master/.github/img/before.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;To this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hmemcpy/zio-clippy/master/.github/img/after.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;IntelliJ IDEA&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;VSCode / Metals&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hmemcpy/zio-clippy/master/.github/img/main.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hmemcpy/zio-clippy/master/.github/img/vscode.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.hmemcpy/zio-clippy_2.12.svg?style=flat-square&#34; alt=&#34;Maven Central&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Add the following to your &lt;code&gt;build.sbt&lt;/code&gt; to install the plugin in your project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;addCompilerPlugin(&#34;com.hmemcpy&#34; %% &#34;zio-clippy&#34; % &#34;0.0.1&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(replace with the latest available version from Maven Central)&lt;/p&gt; &#xA;&lt;p&gt;Reload your project, and any ZIO type mismatch errors will now be rendered in a nice output. This works with all build servers (sbt, bsp) and all editors (IntelliJ IDEA, VSCode/Metals).&lt;/p&gt; &#xA;&lt;p&gt;The plugin supports Scala 2.12, 2.13 with Scala 3 support coming soon! The plugin supports both ZIO 1 and ZIO 2.&lt;/p&gt; &#xA;&lt;h3&gt;Alternative installation method&lt;/h3&gt; &#xA;&lt;p&gt;Another way to install the plugin that does not require manually adding it to your &lt;code&gt;build.sbt&lt;/code&gt; is to install it as a global sbt plugin:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Checkout this repository&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;sbt install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;In your project, reload sbt/bsp&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Running &lt;code&gt;sbt install&lt;/code&gt; builds and places the plugin jar and the &lt;a href=&#34;https://github.com/hmemcpy/zio-clippy/raw/master/project/ZIOPlugin.scala&#34;&gt;&lt;code&gt;ZIOPlugin.scala&lt;/code&gt;&lt;/a&gt; file in the global &lt;code&gt;~/.sbt/1.0/plugins&lt;/code&gt; directory, allowing any sbt project to load the plugin automatically. To remove, delete the ZIOPlugin.scala file from &lt;code&gt;~/.sbt/1.0/plugins&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Additional configuration&lt;/h2&gt; &#xA;&lt;p&gt;To render the original type mismatch error in addition to the plugin output, add the following flag to your &lt;code&gt;scalacOptions&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&#34;-P:clippy:show-original-error&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hmemcpy/zio-clippy/master/.github/img/full-error.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Technical information&lt;/h2&gt; &#xA;&lt;p&gt;This plugin implements a custom &lt;code&gt;Reporter&lt;/code&gt; class, intercepting any &lt;code&gt;type mismatch&lt;/code&gt; errors that contain ZIO-specific information (it&#39;s all regex!) with all other errors passing through to the underlying reporter.&lt;/p&gt; &#xA;&lt;p&gt;The plugin tries to extract the &lt;em&gt;found&lt;/em&gt; and &lt;em&gt;required&lt;/em&gt; dependencies from the error message and performs a set diff to remove the found types from the required ones. This leaves just the type(s) that are missing/were not provided to the effect.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;The project borrows some ideas from Sam Halliday&#39;s excellent &lt;a href=&#34;https://ensime.github.io/&#34;&gt;Ensime TNG&lt;/a&gt;, for both the local development setup and the &lt;em&gt;hack&lt;/em&gt; to replace the reporter.&lt;/p&gt; &#xA;&lt;p&gt;In addition, the ANSI rendering is heavily inspired by Kit Langton&#39;s excellent work on &lt;a href=&#34;https://github.com/kitlangton/zio-magic&#34;&gt;zio-magic&lt;/a&gt;, which is also part of ZIO 2&#39;s default error rendering.&lt;/p&gt; &#xA;&lt;h2&gt;Bugs? Suggestions?&lt;/h2&gt; &#xA;&lt;p&gt;Let us know! Report an issue or send a PR!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>byzer-org/byzer-extension</title>
    <updated>2023-06-06T01:48:44Z</updated>
    <id>tag:github.com,2023-06-06:/byzer-org/byzer-extension</id>
    <link href="https://github.com/byzer-org/byzer-extension" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Byzer Extensions&lt;/h1&gt; &#xA;&lt;p&gt;This project is a collection of extensions for Byzer.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;The user should install the byzer-lang in your local maven repository before compiling this project.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Python &amp;gt;= 3.6&lt;/li&gt; &#xA; &lt;li&gt;Maven &amp;gt;= 3.0&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Byzer-lang dependencies&lt;/h2&gt; &#xA;&lt;p&gt;Clone &lt;a href=&#34;https://github.com/byzer-org/byzer-lang&#34;&gt;byzer-lang&lt;/a&gt;, and run the following command to install it in your local maven repository.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mvn clean install -DskipTests -Ponline -pl streamingpro-mlsql -am  &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Install build tools&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/allwefantasy/mlsql_plugin_tool&#34;&gt;mlsql_plugin_tool&lt;/a&gt; is a tool to build tool for Byzer extensions.&lt;/p&gt; &#xA;&lt;p&gt;Installing command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install mlsql_plugin_tool&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can try the following command to check if the tool is installed successfully.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mlsql_plugin_tool build --module_name xxxxx --spark spark330&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;spark: spark243, spark311 and spark330.&lt;/li&gt; &#xA; &lt;li&gt;module_name e.g mlsql-excel, byzer-simple-auth&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Once build success, the system will show message like fowllowing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#xA;====Build success!=====&#xA; File location 0ï¼š&#xA; /Users/allwefantasy/Volumes/Samsung_T5/allwefantasy/CSDNWorkSpace/mlsqlplugins/xxx/target/xxx-0.1.0-SNAPSHOT.jar&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Extensions list&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Extension&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-simple-auth&#34;&gt;byzer-simple-auth&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A simple auth extension for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-yaml-visulization&#34;&gt;byzer-yaml-visulization&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A yaml visulization extension for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-eval&#34;&gt;byzer-eval&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Byzer-eval is an extension which can execute string variable as Byzer script.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-doris&#34;&gt;byzer-doris&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Doris datasource extension for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-expand-include&#34;&gt;byzer-expand-include&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Expand include extension for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-objectstore-blob&#34;&gt;byzer-objectstore-blob&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Azure Object Storage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-objectstore-cos&#34;&gt;byzer-objectstore-cos&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Tencent Cloud Object Storage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-objectstore-s3&#34;&gt;byzer-objectstore-s3&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Amazon S3 Object Storage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-objectstore-oss&#34;&gt;byzer-objectstore-oss&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Alibaba Cloud Object Storage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-objectstore-obs&#34;&gt;byzer-objectstore-obs&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Huawei Cloud Object Storage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-openmldb&#34;&gt;byzer-openmldb&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;OpenMLDB extension for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/byzer-xgboost&#34;&gt;byzer-xgboost&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;XGBoost extension for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/connect-persist&#34;&gt;connect-persist&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Persist the connect statement to delta lake&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/delta-enhancer&#34;&gt;delta-enhancer&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Delta lake tools for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/last-command&#34;&gt;last-command&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Get the result of last statement. This is useful for reference the output of command&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/mlsql-excel&#34;&gt;mlsql-excel&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Excel datasource extension for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/mlsql-assert&#34;&gt;mlsql-assert&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Assert function support for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/mlsql-canal&#34;&gt;mlsql-canal&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Replay the CDC which is generated from canal to Delta Lake&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/mlsql-shell&#34;&gt;mlsql-shell&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Execute shell command in Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/mlsql-ke&#34;&gt;mlsql-ke&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A tool to operate Kyligence Enterprise.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/stream-persist&#34;&gt;stream-persist&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Persist the stream job to delta lake for recovery&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/table-repartition&#34;&gt;table-repartition&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Repartition the table for better performance.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/mlsql-mllib&#34;&gt;mlsql-mllib&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Some statistical extensions for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/mlsql-ext-ets&#34;&gt;mlsql-ext-ets&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Some extension collection for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/mlsql-ds&#34;&gt;mlsql-ds&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Some datasource collection for Byzer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/byzer-org/byzer-extension/master/echo-controller&#34;&gt;echo-controller&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A simple demo extension for new http request.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
  <entry>
    <title>allenai/pdffigures2</title>
    <updated>2023-06-06T01:48:44Z</updated>
    <id>tag:github.com,2023-06-06:/allenai/pdffigures2</id>
    <link href="https://github.com/allenai/pdffigures2" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Given a scholarly PDF, extract figures, tables, captions, and section titles.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PDFFigures 2.0&lt;/h1&gt; &#xA;&lt;p&gt;PDFFigures 2.0 is a Scala based project built to extract figures, captions, tables and section titles from scholarly documents, with a strong focus on documents from the domain of computer science. See our &lt;a href=&#34;http://ai2-website.s3.amazonaws.com/publications/pdf2.0.pdf&#34;&gt;paper&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Input and Output&lt;/h2&gt; &#xA;&lt;p&gt;PDFFigures 2.0 takes as input a scholarly document in PDF form. Its output will be a list of &#39;Figure&#39; objects where, for each figure, we have identified:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The page the figure occurs in (0 based).&lt;/li&gt; &#xA; &lt;li&gt;The bounding box of the figure within that page, given as pixel coordinates where (0,0) is the top left of the PDF&#39;s cropbox and the page is assumed to be rendered at 72 DPI.&lt;/li&gt; &#xA; &lt;li&gt;Any text that occurs inside the figure.&lt;/li&gt; &#xA; &lt;li&gt;The caption of the figure.&lt;/li&gt; &#xA; &lt;li&gt;The bounding box of the caption.&lt;/li&gt; &#xA; &lt;li&gt;The &#39;name&#39; of the figure as deduced from the caption. Usually, this is a number (ex. the name of a figure captioned &#34;Figure 1&#34; would be &#34;1&#34;), but it might take on some other form depending on the PDF parsed.&lt;/li&gt; &#xA; &lt;li&gt;Whether the figure was labelled as a Table or a Figure, again based on the caption.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;PDFFigures 2 also supports the ability to save images of the extracted figures as rasterized images. Currently, we support any format that a BufferedImage can be saved to (png, jpeg, etc.). More experimentally, if pdftocairo is installed it can be used to save the figures to a selection of vector graphics formats (svg, ps, eps, etc.).&lt;/p&gt; &#xA;&lt;p&gt;PDFFigures 2 only seeks to extract figures or tables that have been captioned, in which case we define a figure to be all elements on the page that the caption refers to. If a figure has subfigures, the returned figure will include all the subfigures. If a table or figure includes text titles or comments, those elements will be included in the figure.&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Clone the repo and then run with sbt.&lt;/p&gt; &#xA;&lt;p&gt;For licensing reasons, PDFFigures2 does not include libraries for some image formats. Without these libraries, PDFFigures2 cannot process PDFs that contain images in these formats. If you have no licensing restrictions in your project, we recommend you add these additional dependencies to your project as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  &#34;com.github.jai-imageio&#34; % &#34;jai-imageio-core&#34; % &#34;1.2.1&#34;,&#xA;  &#34;com.github.jai-imageio&#34; % &#34;jai-imageio-jpeg2000&#34; % &#34;1.3.0&#34;, // For handling jpeg2000 images&#xA;  &#34;com.levigo.jbig2&#34; % &#34;levigo-jbig2-imageio&#34; % &#34;1.6.5&#34;, // For handling jbig2 images&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Command Line Tools&lt;/h3&gt; &#xA;&lt;p&gt;PDFFigures 2 provides two CLI tools. One, &#39;FigureExtractorBatchCli&#39;, can be used to extract figures from a large number of PDFs and save the results to disk. The second, &#39;FigureExtractorVisualizationCli&#39;, works on a single PDF and provides extensive debug visualizations. Note it is recommended to use the &#34;-Dsun.java2d.cmm=sun.java2d.cmm.kcms.KcmsServiceProvider&#34; to get the best performance out of the PDF parser, see here[https://pdfbox.apache.org/2.0/getting-started.html]&lt;/p&gt; &#xA;&lt;p&gt;To run on a PDF and get a preview of the results use:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sbt &#34;runMain org.allenai.pdffigures2.FigureExtractorVisualizationCli /path/to/pdf&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;To get a visualization of how the PDF was parsed:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sbt &#34;runMain org.allenai.pdffigures2.FigureExtractorVisualizationCli /path/to/pdf&#34; -r&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;To get a visualization of all the intermediate steps:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sbt &#34;runMain org.allenai.pdffigures2.FigureExtractorVisualizationCli /path/to/pdf&#34; -s&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;To run on lots of PDFs while saving the images, figure objects, and run statistics:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sbt &#34;runMain org.allenai.pdffigures2.FigureExtractorBatchCli /path/to/pdf_directory/ -s stat_file.json -m /figure/image/output/prefix -d /figure/data/output/prefix&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;To compile a stand-alone JAR with these tools:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sbt assembly&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Section Titles&lt;/h3&gt; &#xA;&lt;p&gt;FigureExtractor has experimental support for additionally identifying section titles. Section titles, along with the PDF&#39;s text, can be returned from the BatchCli using the &#34;-g&#34; flag. The output will the full text of the PDF, organized into sections. An effort is made to identify the abstract, if there is one, and to exclude text like page headers, authors names, and page numbers. Text inside figures and captions will also be excluded from the main text and encoded separately. Note that while the extracted section titles have been found to be reliable, the quality of the returned text itself has not been tested and is mostly what is returned by PDFBox&#39;s &lt;code&gt;ExtractText&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Interface&lt;/h3&gt; &#xA;&lt;p&gt;FigureExtractor exports its high level programmatic interfaces in FigureExtractor.scala&lt;/p&gt; &#xA;&lt;h3&gt;Multithreading&lt;/h3&gt; &#xA;&lt;p&gt;FigureExtractor rigorously checks Thread.interrupted and so can be timed out easily. FigureExtractorBatchCli supports multi-threading.&lt;/p&gt; &#xA;&lt;h2&gt;Implementation Overview&lt;/h2&gt; &#xA;&lt;p&gt;See the paper for more details. In brief, the input PDF is pushed through the following steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Text is extracted from the PDF. See TextExtractor.scala.&lt;/li&gt; &#xA; &lt;li&gt;Page numbers, page headers, and abstracts are identified and removed. See FormattingTextExtractor.scala.&lt;/li&gt; &#xA; &lt;li&gt;Some statistics are gathered about the remaining text. We use these statistics later to identify text that is atypical/unusual since that text is likely to be part of a figure. See DocumentLayout.scala.&lt;/li&gt; &#xA; &lt;li&gt;The locations of captions within the text are identified. See CaptionDetector.scala.&lt;/li&gt; &#xA; &lt;li&gt;For each page with captions, we identify where any graphical/non-textual elements are. See GraphicExtractor.scala.&lt;/li&gt; &#xA; &lt;li&gt;We determine the entirety of each caption. (Previous steps just identified the line that started each caption; this step identifies the full text of each caption.) See CaptionBuilder.scala.&lt;/li&gt; &#xA; &lt;li&gt;The text in each page that contained a caption is classified as &#34;BodyText&#34; or &#34;Other.&#34; Future steps will assume &#34;BodyText&#34; is never part of a Figure/Table but &#34;Other&#34; text might be. See RegionClassifier.scala.&lt;/li&gt; &#xA; &lt;li&gt;Figures are located using the classification from the previous step. See FigureDetector.scala. This has two substeps:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For each caption, a number of regions within the page are &#34;proposed&#34; as possible figure regions. We propose regions that are adjacent to the caption and contain only &#34;Other&#34; text and graphical elements.&lt;/li&gt; &#xA; &lt;li&gt;A scoring function is used to select the best proposal to match to each caption. This process also makes sure we don&#39;t select overlapping figure regions for two captions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;9&#34;&gt; &#xA; &lt;li&gt;Finally, the figures are optionally rendered to images using PDFBox. See FigureRenderer.scala.&lt;/li&gt; &#xA; &lt;li&gt;More experimentally, section titles can be also extracted. See SectionTitleExtractor.scala.&lt;/li&gt; &#xA; &lt;li&gt;Then, the document can be broken up to logical sections. See SectionedTextBuilder.scala.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Evaluation&lt;/h2&gt; &#xA;&lt;p&gt;This repo includes python-based scripts to evaluate figure extractors and two datasets with ground truth labels. See the evaluation directory.&lt;/p&gt; &#xA;&lt;h2&gt;Common Sources of Errors&lt;/h2&gt; &#xA;&lt;p&gt;FigureExtractor has been tested on papers selected from &lt;a href=&#34;https://raw.githubusercontent.com/allenai/pdffigures2/master/www.semanticscholar.com&#34;&gt;Semantic Scholar&lt;/a&gt;. It is not well tested on domains outside of computer science. When errors do occur, some common causes are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Poorly Encoded PDFs: Some PDFs can appear to be perfectly fine in a PDF viewer, but when we try to extract the text we might get garbage, or we might get a bunch of extraneous text that is not visible to the eye. Trying to ignore text that is encoded in the PDF as being the background color (might?) be a good to start to solving these issues, but is not implemented.&lt;/li&gt; &#xA; &lt;li&gt;Text Classification: Text classification works well for tables and most figures, but we get some errors for text-heavy figures (such as a figure outlining the steps in an algorithm). RegionClassifier.scala will sometimes classify bullet points and equations as non-body text, which can cause those text elements to get incorrectly chunked into figures.&lt;/li&gt; &#xA; &lt;li&gt;Region Proposing: Even when text classification is accurate, generating good proposed figure regions can be a non-trivial task. It is in particular important to build proposals that do not encompass multiple figures, which is sometimes quite difficult if there are many figures on a single page.&lt;/li&gt; &#xA; &lt;li&gt;Caption Building: For some cases where captions are very closely packed to the following text, our returned captions will include too much text. For some some papers with unusual caption formats, we might fail to include some text in the captions.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Unhandled Edge Cases&lt;/h2&gt; &#xA;&lt;p&gt;There are a few edge cases were we consistently fail, due to hard coded assumptions or special cases we do not handle at the moment:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&#34;L&#34; shaped figures. For example, see evaluation/datasets/s2/pdfs/202042e6f88abe690a55e136475053a3eac68d40.pdf, page 7. To handle these one would need to adjust the API to allow figure regions to be described by multiple bounding boxes and then adjust &#34;FigureDetector.scala&#34; to return them.&lt;/li&gt; &#xA; &lt;li&gt;Three adjacent figures, where the figures share borders with each other. For example, see evaluation/datasets/conference/pdfs/icml10_4.pdf. I think this would not be too difficult to handle as a special case. It would require heuristically guessing how to split up the region all the figures occupy.&lt;/li&gt; &#xA; &lt;li&gt;Rotated text. For example, see evaluation/datasets/conference/pdfs/W10-1721.pdf page 6. Unfortunately PDFBox does not handle extracting rotated text; it tends to group rotated text as paragraphs with each character being line. This means for pages with captions rotated at a 90 degree angle we will be unable to detect any captions that exist on that page and then be unable to extract the figures. Handling this might require post-processing the text we get from PDFBox to attempt to get coherent lines of text for these cases.&lt;/li&gt; &#xA; &lt;li&gt;Captions on the same line. For example, see evaluation/datasets/conference/pdfs/icml14_9.pdf, page 5. PDFBox will group both captions into the same line. Our caption detection code assumes that captions always start lines (this assumption is almost never wrong outside of these cases), which causes us to miss the second caption. This might be relatively easy to address by checking each line we find to have a caption for large gap between the words in the line, followed by a second caption.&lt;/li&gt; &#xA; &lt;li&gt;Figures above the abstract. Currently it is assumed all text above the abstract is not part of a figure. This helps avoid false positives induced by including emails/names/title from the header in figures on the first page, but there is probably a way to relax this assumption to resolve this issue.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;Christopher Clark, &lt;a href=&#34;mailto:chrisc@allenai.org&#34;&gt;chrisc@allenai.org&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>