<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-30T01:39:05Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>apache/hbase-connectors</title>
    <updated>2022-08-30T01:39:05Z</updated>
    <id>tag:github.com,2022-08-30:/apache/hbase-connectors</id>
    <link href="https://github.com/apache/hbase-connectors" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Apache HBase Connectors&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;hbase-connectors&lt;/h1&gt; &#xA;&lt;p&gt;Connectors for &lt;a href=&#34;https://hbase.apache.org&#34;&gt;Apache HBaseâ„¢&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/hbase-connectors/tree/master/kafka&#34;&gt;Kafka Proxy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/hbase-connectors/tree/master/spark&#34;&gt;Spark&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>chipsalliance/rocket-chip-fpga-shells</title>
    <updated>2022-08-30T01:39:05Z</updated>
    <id>tag:github.com,2022-08-30:/chipsalliance/rocket-chip-fpga-shells</id>
    <link href="https://github.com/chipsalliance/rocket-chip-fpga-shells" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Wrapper shells enabling designs generated by rocket-chip to map onto certain FPGA boards&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;FPGA Shells for the Rocket Chip Generator&lt;/h1&gt; &#xA;&lt;p&gt;An FPGA shell is a Chisel module designed to wrap any Rocket Chip subsystem configuration. The goal of the fpga-shell system is to reduce the number of wrappers so as to have only one for each physical device rather than one for every combination of physical device and core configuration.&lt;/p&gt; &#xA;&lt;p&gt;This repository replaces &lt;a href=&#34;https://github.com/sifive/fpga-shells&#34;&gt;https://github.com/sifive/fpga-shells&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Each shell consists of Overlays which use dependency injection to create and connect peripheral device interfaces in an FPGADesign to the toplevel shell module.&lt;/p&gt; &#xA;&lt;p&gt;Most devices already have an overlay defined for them in &lt;code&gt;src/main/scala/shell[/xilinx]&lt;/code&gt;. If you&#39;re using a Xilinx device, you&#39;ll probably want to use the xilinx-specific overlay because it defines a few things that you&#39;d otherwise have to specify yourself.&lt;/p&gt; &#xA;&lt;p&gt;Generally, you&#39;ll want to create a device shell that extends &lt;code&gt;Series7Shell&lt;/code&gt; or &lt;code&gt;UltraScaleShell&lt;/code&gt;. If you need different functionality (or you&#39;re not using a Xilinx device), you can extend &lt;code&gt;Shell&lt;/code&gt; and implement abstract members. Some Microsemi devices are supported by fgpa-shells as well (and can be found in &lt;code&gt;src/main/scala/shell/microsemi&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Scala&#34;&gt;class DeviceShell()(implicit p: Parameters) extends UltraScaleShell {&#xA;  // create Overlays&#xA;  val myperipheral = Overlay(PeripheralOverlayKey) (new PeripheralOverlay(_,_,_))&#xA;  // ...&#xA;&#xA;  // assign abstract members&#xA;  val pllReset = InModuleBody { Wire(Bool()) }&#xA;  val topDesign = LazyModule(p(DesignKey)(designParameters))&#xA;&#xA;  // ensure clocks are connected&#xA;  designParameters(ClockInputOverlayKey).foreach { unused =&amp;gt;&#xA;    val source = unused(ClockInputOverlayParams())&#xA;    val sink = ClockSinkNode(Seq(ClockSinkParameters()))&#xA;    sink := source&#xA;  }&#xA;&#xA;  // override module implementation to connect reset&#xA;  override lazy val module = new LazyRawModuleImp(this) {&#xA;    val reset = IO(Input(Bool()))&#xA;    pllReset := reset&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each peripheral device to be added to the shell must define an &lt;code&gt;Overlay&lt;/code&gt;, which creates the device and connects it to the toplevel shell. In addition, in order to access the overlay, the device needs to have a &lt;code&gt;case class OverlayParams&lt;/code&gt; and a &lt;code&gt;case object OverlayKey&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Scala&#34;&gt;case class PeripheralOverlayParams()(implicit val p: Parameters)&#xA;case object PeripheralOverlayKey extends Field[Seq[DesignOverlay[PeripheralOverlayParams, PeripheralDesignOutput]]](Nil)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the device is parameterizable, then each parameter for the device creation can be passed to the &lt;code&gt;PeripheralOverlayParams&lt;/code&gt; constructor by adding a field for said parameter. Typically, devices are connected to a TileLink bus for processor control, so &lt;code&gt;PeripheralDesignOutput&lt;/code&gt; can usually be substituted with &lt;code&gt;TLInwardNode&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Overlay&lt;/code&gt; extends &lt;code&gt;IOOverlay&lt;/code&gt; which is paramerized by the device&#39;s &lt;code&gt;IO&lt;/code&gt; (in this case &lt;code&gt;PeripheralDeviceIO&lt;/code&gt; is a subtype of &lt;code&gt;Data&lt;/code&gt; and is a port specification for the peripheral device) and &lt;code&gt;DesignOutput&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Scala&#34;&gt;abstract class AbstractPeripheralOverlay(val params: PeripheralOverlayParams)&#xA;  extends IOOverlay[PeripheralDeviceIO, PeripheralDesignOutput]&#xA;{&#xA;  // assign abstract member p (used to access overlays with their key)&#xA;  // e.g. p(PeripheralOverlayKey) will return a Seq[DesignOverlay[PeripheralOverlayParams, PeripheralDesignOutput]]&#xA;  implicit val p = params.p&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Continuing our example with a &lt;code&gt;DeviceShell&lt;/code&gt; shell, the actual overlay is constructed by extending our abstract &lt;code&gt;PeripheralOverlay&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Scala&#34;&gt;class ConcretePeripheralOverlay(val shell: DeviceShell, val name: String, params: PeripheralOverlayParams)&#xA;  extends AbstractPeripheralOverlay(params)&#xA;{&#xA;  val device = LazyModule(new PeripheralDevice(PeripheralDeviceParams(???))) // if your peripheral device isn&#39;t parameterizable, then it&#39;ll have an empty constructor&#xA;&#xA;  def ioFactory = new PeripheralDeviceIO // ioFactory defines interface of val io&#xA;  val designOutput = device.node&#xA;&#xA;  // this is where &#34;code-injection&#34; starts&#xA;  val ioSource = BundleBridgeSource(() =&amp;gt; device.module.io.cloneType) // create a bridge between device (source) and shell (sink)&#xA;  val ioSink = shell { ioSource.makeSink() }&#xA;&#xA;  InModuleBody { ioSource.bundle &amp;lt;&amp;gt; device.module.io }&#xA;&#xA;  shell { InModuleBody {&#xA;    val port = ioSink.bundle&#xA;&#xA;    io &amp;lt;&amp;gt; port // io is the bundle of shell-level IO as specified by ioFactory&#xA;  } }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The actual device implementation (where the device&#39;s functionality is defined) will be something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Scala&#34;&gt;case class PeripheralDeviceParams(param1: Param1Type, ???) // only necessary if your device is parameterizable&#xA;class PeripheralDevice(c: PeripheralDeviceParams)(implicit p: Parameters) extends LazyModule {&#xA;  &#xA;  val node: PeripheralDesignOutput = ???&#xA;&#xA;  // device implementation&#xA;  lazy val module = new LazyModuleImp(this) {&#xA;    val io = ???&#xA;    ???&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>