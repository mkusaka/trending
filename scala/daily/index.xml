<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-06T01:38:12Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>j-mie6/Parsley</title>
    <updated>2022-12-06T01:38:12Z</updated>
    <id>tag:github.com,2022-12-06:/j-mie6/Parsley</id>
    <link href="https://github.com/j-mie6/Parsley" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An exceptionally fast parser combinator library for Scala&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Parsley &lt;img src=&#34;https://img.shields.io/github/workflow/status/j-mie6/parsley/CI&#34; alt=&#34;GitHub Workflow Status&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/j-mie6/parsley?include_prereleases&amp;amp;sort=semver&#34; alt=&#34;GitHub release&#34;&gt; &lt;a href=&#34;https://github.com/j-mie6/parsley/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/j-mie6/parsley.svg?sanitize=true&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/commits-since/j-mie6/parsley/latest&#34; alt=&#34;GitHub commits since latest release (by SemVer)&#34;&gt; &lt;a href=&#34;https://javadoc.io/doc/com.github.j-mie6/parsley_2.13/latest/index.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/documentation-available-green&#34; alt=&#34;Badge-Scaladoc&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;What is Parsley?&lt;/h2&gt; &#xA;&lt;p&gt;Parsley is a very fast parser combinator library for Scala based on a Haskell-style Parsec API.&lt;/p&gt; &#xA;&lt;h2&gt;How do I use it? &lt;a href=&#34;https://index.scala-lang.org/j-mie6/parsley/parsley&#34;&gt;&lt;img src=&#34;https://index.scala-lang.org/j-mie6/parsley/parsley/latest-by-scala-version.svg?platform=jvm&#34; alt=&#34;parsley Scala version support&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://index.scala-lang.org/j-mie6/parsley/parsley&#34;&gt;&lt;img src=&#34;https://index.scala-lang.org/j-mie6/parsley/parsley/latest-by-scala-version.svg?platform=sjs1&#34; alt=&#34;parsley Scala version support&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://index.scala-lang.org/j-mie6/parsley/parsley&#34;&gt;&lt;img src=&#34;https://index.scala-lang.org/j-mie6/parsley/parsley/latest-by-scala-version.svg?platform=native0.4&#34; alt=&#34;parsley Scala version support&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Parsley is distributed on Maven Central, and can be added to your project via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;com.github.j-mie6&#34; %% &#34;parsley&#34; % &#34;4.0.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Documentation can be found &lt;a href=&#34;https://javadoc.io/doc/com.github.j-mie6/parsley_2.13/latest/index.html&#34;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import parsley.Parsley, Parsley._&#xA;import parsley.character.{char, string, digit}&#xA;import parsley.implicits.character.{charLift, stringLift}&#xA;&#xA;val hello: Parsley[Unit] = (&#39;h&#39; *&amp;gt; (&#34;ello&#34; &amp;lt;|&amp;gt; &#34;i&#34;) *&amp;gt; &#34; world!&#34;).void&#xA;hello.parse(&#34;hello world!&#34;) // returns Success(())&#xA;hello.parse(&#34;hi world!&#34;) // returns Success(())&#xA;hello.parse(&#34;hey world!&#34;) // returns a Failure&#xA;&#xA;val natural: Parsley[Int] = digit.foldLeft1(0)((n, d) =&amp;gt; n * 10 + d.asDigit)&#xA;natural.parse(&#34;0&#34;) // returns Success(0)&#xA;natural.parse(&#34;123&#34;) // returns Success(123)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more see &lt;a href=&#34;https://github.com/j-mie6/Parsley/wiki&#34;&gt;the Wiki&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h3&gt;What are the differences to Haskell&#39;s Parsec?&lt;/h3&gt; &#xA;&lt;p&gt;Mostly, this library is quite similar. However, due to Scala&#39;s differences in operator characters a few operators are changed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;(&amp;lt;$&amp;gt;)&lt;/code&gt; is known as &lt;code&gt;map&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;try&lt;/code&gt; is known as &lt;code&gt;attempt&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(&amp;lt;$)&lt;/code&gt; and &lt;code&gt;($&amp;gt;)&lt;/code&gt; are &lt;code&gt;&amp;lt;#&lt;/code&gt; and &lt;code&gt;#&amp;gt;&lt;/code&gt; respectively.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition, &lt;code&gt;lift2&lt;/code&gt; and &lt;code&gt;lift3&lt;/code&gt; are uncurried in this library: this is to provide better performance and easier usage with Scala&#39;s traditionally uncurried functions. There are also a few new operators in general to be found here!&lt;/p&gt; &#xA;&lt;h2&gt;How does it work?&lt;/h2&gt; &#xA;&lt;p&gt;Parsley represents parsers as an abstract-syntax tree AST, which is constructed lazily. As a result, Parsley is able to perform analysis and optimisations on your parsers, which helps reduce the burden on you, the programmer. This representation is then compiled into a light-weight stack-based instruction set designed to run fast on the JVM. This is what offers Parsley its competitive performance, but for best effect a parser should be compiled once and used many times (so-called hot execution).&lt;/p&gt; &#xA;&lt;p&gt;To make recursive parsers work in this AST format, you must ensure that recursion is done by knot-tying: you should define all recursive parsers with &lt;code&gt;val&lt;/code&gt; and introduce &lt;code&gt;lazy val&lt;/code&gt; where necessary for the compiler to accept the definition.&lt;/p&gt; &#xA;&lt;h2&gt;Bug Reports &lt;a href=&#34;https://isitmaintained.com/project/j-mie6/Parsley&#34; title=&#34;Percentage of issues still open&#34;&gt;&lt;img src=&#34;https://isitmaintained.com/badge/open/j-mie6/Parsley.svg?sanitize=true&#34; alt=&#34;Percentage of issues still open&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/j-mie6/Parsley&#34;&gt;&lt;img src=&#34;https://img.shields.io/codeclimate/maintainability/j-mie6/Parsley&#34; alt=&#34;Maintainability&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/j-mie6/Parsley&#34;&gt;&lt;img src=&#34;https://img.shields.io/codeclimate/coverage-letter/j-mie6/Parsley&#34; alt=&#34;Test Coverage&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;If you encounter a bug when using Parsley, try and minimise the example of the parser (and the input) that triggers the bug. If possible, make a self contained example: this will help me to identify the issue without too much issue.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This work is based on my Master&#39;s Thesis (2018) which can be found &lt;a href=&#34;https://github.com/J-mie6/Parsley/raw/master/parsley.pdf&#34;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;This work spawned a paper at the Scala Symposium at ICFP 2018: &lt;a href=&#34;https://dl.acm.org/doi/abs/10.1145/3241653.3241656&#34;&gt;&lt;strong&gt;Garnishing Parsec with Parsley&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;This work supports the patterns introduced at the Scala Symposium in 2022: &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3550198.3550427&#34;&gt;&lt;strong&gt;Design Patterns for Parser Combinators in Scala&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- Badges and Links --&gt;</summary>
  </entry>
</feed>