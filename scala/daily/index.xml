<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-03-31T01:37:55Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rcardin/yaes</title>
    <updated>2025-03-31T01:37:55Z</updated>
    <id>tag:github.com,2025-03-31:/rcardin/yaes</id>
    <link href="https://github.com/rcardin/yaes" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An experimental effect system in Scala using capability passing style&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/rcardin/yaes/scala.yml?branch=main&#34; alt=&#34;GitHub Workflow Status (with branch)&#34;&gt; &lt;img src=&#34;https://img.shields.io/maven-central/v/in.rcard.yaes/yaes-core_3&#34; alt=&#34;Maven Central&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/rcardin/yaes&#34; alt=&#34;GitHub release (latest by date)&#34;&gt; &lt;a href=&#34;https://javadoc.io/doc/in.rcard.yaes/yaes-core_3&#34;&gt;&lt;img src=&#34;https://javadoc.io/badge2/in.rcard.yaes/yaes-core_3/javadoc.svg?sanitize=true&#34; alt=&#34;javadoc&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Yet Another Effect System (yæs)&lt;/h1&gt; &#xA;&lt;p&gt;YÆS is an experimental effect system in Scala based upon Capabilities and Algebraic Effects. Using Scala 3 &lt;a href=&#34;https://docs.scala-lang.org/scala3/reference/contextual/using-clauses.html&#34;&gt;context parameters&lt;/a&gt; and &lt;a href=&#34;https://docs.scala-lang.org/scala3/reference/contextual/context-functions.html&#34;&gt;context functions&lt;/a&gt;, it provides a way to define and handle effects in a modular and composable manner.&lt;/p&gt; &#xA;&lt;p&gt;What&#39;s new in YÆS when compared to other effect systems? Well, you can choose to use a monadic style like the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Random&#xA;import in.rcard.yaes.Random.*&#xA;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;import in.rcard.yaes.Yaes.*&#xA;&#xA;def drunkFlip(using Random, Raise[String]): String = for {&#xA;  caught &amp;lt;- Random.nextBoolean&#xA;  heads  &amp;lt;- if (caught) Random.nextBoolean else Raise.raise(&#34;We dropped the coin&#34;)&#xA;} yield if (heads) &#34;Heads&#34; else &#34;Tails&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or a more direct style like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Random&#xA;import in.rcard.yaes.Random.*&#xA;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;&#xA;def drunkFlip(using Random, Raise[String]): String = {&#xA;  val caught = Random.nextBoolean&#xA;  if (caught) {&#xA;    val heads = Random.nextBoolean&#xA;    if (heads) &#34;Heads&#34; else &#34;Tails&#34;&#xA;  } else {&#xA;    Raise.raise(&#34;We dropped the coin&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In YÆS types like &lt;code&gt;Random&lt;/code&gt; and &lt;code&gt;Raise&lt;/code&gt; are capabilities, or &lt;em&gt;Effects&lt;/em&gt;. An &lt;em&gt;Effect&lt;/em&gt; is an unpredictable interaction, usually with an external system. An Effect System manages &lt;em&gt;Effects&lt;/em&gt; by wrapping them and providing a set of components that replace effectful functions in standard libraries. We manage Effect behavior by putting that Effect in a kind of box.&lt;/p&gt; &#xA;&lt;p&gt;Calling the above &lt;code&gt;drunkFlip&lt;/code&gt; function will not execute the effects. Instead, it will return a value that represents something that can be run but hasn’t yet. This is called deferred execution. It&#39;s kinda different than &lt;em&gt;direct-style&lt;/em&gt; approach. We call it &lt;strong&gt;Capability-Passing Style&lt;/strong&gt;. As you might image, &lt;em&gt;Effect&lt;/em&gt; and &lt;em&gt;Capabilities&lt;/em&gt; are quite sinonyms in the YÆS context.&lt;/p&gt; &#xA;&lt;p&gt;An Effect System provides all the tools to manage and execute Effectful computations in a deferred manner. In YÆS, such tools are called &lt;em&gt;Handlers&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Random&#xA;import in.rcard.yaes.Random.*&#xA;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;&#xA;val result: String = Raise.run { &#xA;  Random.run { &#xA;    drunkFlip&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above code, we are running the &lt;code&gt;drunkFlip&lt;/code&gt; function with the &lt;code&gt;Random&lt;/code&gt; and &lt;code&gt;Raise&lt;/code&gt; capabilities. The &lt;code&gt;Raise.run&lt;/code&gt; and &lt;code&gt;Random.run&lt;/code&gt; functions are defined using &lt;em&gt;Handlers&lt;/em&gt; that will execute the deferred effects. The approach remids the one defined in the Algebraic Effects and Handlers. theory. The example shows how to handle the &lt;code&gt;Raise&lt;/code&gt; and &lt;code&gt;Random&lt;/code&gt; effects one at time. However, we&#39;re free to handle only one effect at time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Random&#xA;import in.rcard.yaes.Random.*&#xA;&#xA;val result: Raise[String] ?=&amp;gt; String = Random.run { &#xA;  drunkFlip&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code shows how to handle only the &lt;code&gt;Random&lt;/code&gt; effect. The &lt;code&gt;Raise&lt;/code&gt; effect is still present in the needed capabilities. It&#39;s a powerful feature that allows for a fine-grained management of the effects.&lt;/p&gt; &#xA;&lt;h2&gt;Dependency&lt;/h2&gt; &#xA;&lt;p&gt;The library is available on Maven Central. To use it, add the following dependency to your build.sbt files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sbt&#34;&gt;libraryDependencies += &#34;in.rcard.yaes&#34; %% &#34;yaes-core&#34; % &#34;0.0.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The library is only available for Scala 3 and is currently in an experimental stage. The API is subject to change.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The library provides a set of effects that can be used to define and handle effectful computations. The available effects are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rcardin/yaes/main/#the-io-effect&#34;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;: Allows for running side-effecting operations.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rcardin/yaes/main/#the-async-effect&#34;&gt;&lt;code&gt;Async&lt;/code&gt;&lt;/a&gt;: Allows for asynchronous computations and fiber management.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rcardin/yaes/main/#the-raise-effect&#34;&gt;&lt;code&gt;Raise&lt;/code&gt;&lt;/a&gt;: Allows for raising and handling errors.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rcardin/yaes/main/#the-input-effect&#34;&gt;&lt;code&gt;Input&lt;/code&gt;&lt;/a&gt;: Allows for reading input from the console.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rcardin/yaes/main/#the-output-effect&#34;&gt;&lt;code&gt;Output&lt;/code&gt;&lt;/a&gt;: Allows for printing output to the console.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rcardin/yaes/main/#the-random-effect&#34;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt;: Allows for generating random content.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Each effect provides a not-comprehensive set of operations that can be used to define effectful computations. The operations are defined directly on the companion object of the effect. For example, here is the set of functions available on the &lt;code&gt;Random&lt;/code&gt; effect:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Random {&#xA;  def nextInt(using r: Random): Int&#xA;  def nextBoolean(using r: Random): Boolean&#xA;  def nextDouble(using r: Random): Double&#xA;  def nextLong(using r: Random): Long&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each effect also defines an &lt;code&gt;Unsafe&lt;/code&gt; trait that provides the implementation of the effect in an unsafe manner. The &lt;code&gt;Unsafe&lt;/code&gt; trait is always part of the effect companion object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Random {&#xA;  trait Unsafe {&#xA;    def nextInt: Int&#xA;    def nextBoolean: Boolean&#xA;    def nextDouble: Double&#xA;    def nextLong: Long&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Unsafe&lt;/code&gt; trait is used to define the &lt;em&gt;Handlers&lt;/em&gt; that will execute the deferred effects. It&#39;s not intended to be used directly by the user since is does not provide any kind of safety (referential transparency, for example). The &lt;code&gt;Handler&lt;/code&gt; trait is in the &lt;code&gt;Yeas&lt;/code&gt; object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Handler[F, A, B] {&#xA;  def handle(program: Yaes[F] ?=&amp;gt; A): B // FIXME Make it inline&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each handler handles an effectful program that requires a capability of type &lt;code&gt;Yeas[F]&lt;/code&gt;. The &lt;code&gt;Yaes&lt;/code&gt; type is a class wrapping an instance of capability (or effect) of type &lt;code&gt;F&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Yaes[F](val unsafe: F)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s the core of the library since it allows the definition of the &lt;code&gt;flatMap&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; functions on the &lt;code&gt;Yaes[F] ?=&amp;gt; A&lt;/code&gt; type.&lt;/p&gt; &#xA;&lt;p&gt;Every effect companion objects defines a type alias for the capability of the effect:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Random {&#xA;  type Random = Yaes[Random]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Handlers are used to define the &lt;code&gt;run&lt;/code&gt; method of each effect, which is the method that will execute the deferred effects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Random {&#xA;  def run[A](block: Random ?=&amp;gt; A): A = {&#xA;    val handler = new Yaes.Handler[Random.Unsafe, A, A] {&#xA;      override def handle(program: Random ?=&amp;gt; A): A = program(using&#xA;        new Yaes(new Random.Unsafe {&#xA;          override def nextInt(): Int         = scala.util.Random.nextInt()&#xA;          override def nextLong(): Long       = scala.util.Random.nextLong()&#xA;          override def nextBoolean(): Boolean = scala.util.Random.nextBoolean()&#xA;          override def nextDouble(): Double   = scala.util.Random.nextDouble()&#xA;        })&#xA;      )&#xA;    }&#xA;    Yaes.handle(block)(using handler)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It follows the list of effects and for each of them a brief description of their operations.&lt;/p&gt; &#xA;&lt;h2&gt;Effects (or Capabilities)&lt;/h2&gt; &#xA;&lt;h3&gt;The &lt;code&gt;IO&lt;/code&gt; Effect&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;IO&lt;/code&gt; effect allows for running side-effecting operations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.IO&#xA;import in.rcard.yaes.IO.*&#xA;&#xA;case class User(name: String)&#xA;&#xA;def saveUser(user: User)(using IO): Long =&#xA;  throw new RuntimeException(&#34;Read timed out&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code can throw an uncontrolled exception if the connection with the database times out. The generic &lt;code&gt;IO&lt;/code&gt; effect lift the function in the world of the effectful computations, making it referentially transparent. It means that everything that is not referentially transparent should be defined using the &lt;code&gt;IO&lt;/code&gt; effect. In fact, the &lt;code&gt;IO&lt;/code&gt; effect provides a guard rail to uncontrolled exceptions since its handler returns always a monad that wraps the result of the effectful computation.&lt;/p&gt; &#xA;&lt;p&gt;To run the effectful computation, we can use the provided handlers.&lt;/p&gt; &#xA;&lt;p&gt;The first handler doesn&#39;t block the current thread:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.IO&#xA;import in.rcard.yaes.IO.*&#xA;&#xA;import scala.concurrent.Future&#xA;import scala.concurrent.ExecutionContext.Implicits.global&#xA;&#xA;val result: Future[Long] = IO.run {&#xA;  saveUser(User(&#34;John&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The library also provides a blocking handler that will block the current thread until the effectful computation is finished:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.IO&#xA;import in.rcard.yaes.IO.*&#xA;&#xA;import scala.concurrent.ExecutionContext.Implicits.global&#xA;import scala.concurrent.duration.DurationInt&#xA;import scala.util.Try&#xA;&#xA;val result: Long = IO.blockingRun {&#xA;  saveUser(User(&#34;John&#34;))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please, be aware that running an &lt;code&gt;IO&lt;/code&gt; effectful computation both using the &lt;code&gt;IO.run&lt;/code&gt; and &lt;code&gt;IO.blockingRun&lt;/code&gt; methods breaks the referential transparency. Handlers should be used only at the edge of the application.&lt;/p&gt; &#xA;&lt;p&gt;The default &lt;code&gt;IO&lt;/code&gt; handler is implemented using Java Virtual Threads machinery. For every effectful computation, a new virtual thread is created and the computation is executed in that thread.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;Async&lt;/code&gt; Effect&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Async&lt;/code&gt; effect is built around the ideas developed in the &lt;a href=&#34;https://github.com/rcardin/sus4s&#34;&gt;Sus4s&lt;/a&gt; library. It allows for running asynchronous computations and managing fibers.&lt;/p&gt; &#xA;&lt;p&gt;The default implementation of the &lt;code&gt;Async&lt;/code&gt; effect is based Java Structured Concurrency provided by Java versions after 21. The &lt;code&gt;Async&lt;/code&gt; effect provides a way to define asynchronous computations that are executed in a structured way. It means that every asynchronous computation is executed in a fiber that is managed by the &lt;code&gt;Async&lt;/code&gt; effect.&lt;/p&gt; &#xA;&lt;p&gt;The most important operation of the &lt;code&gt;Async&lt;/code&gt; effect is the &lt;code&gt;fork&lt;/code&gt; operation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Async&#xA;import in.rcard.yaes.Async.*&#xA;&#xA;def findUserByName(name: String): Option[User] = Some(User(name))&#xA;val fb: Async ?=&amp;gt; Fiber[Option[User]] = Async.fork { findUserByName(&#34;John&#34;) }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;fb&lt;/code&gt; variable represent a fiber (lightweight thread) that is executing the &lt;code&gt;findUserByName&lt;/code&gt; function. The &lt;code&gt;fork&lt;/code&gt; operation returns a &lt;code&gt;Fiber&lt;/code&gt; object that can be used to manage the execution of the asynchronous computation. In details, we can wait for the value of the computation using the &lt;code&gt;value&lt;/code&gt; operation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Async&#xA;import in.rcard.yaes.Async.*&#xA;import in.rcard.yaes.Raise.Raise&#xA;&#xA;val maybeUser: (Async, Raise[Cancelled]) ?=&amp;gt; Option[User] = fb.value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, we can just wait for the computation to finish:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val p: Async ?=&amp;gt; Option[User] = fb.join()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As for the &lt;code&gt;IO&lt;/code&gt; effect, forking a new fiber or joining it doesn&#39;t execute the effectful computation. It just returns a value that represents the computation that can be run but hasn&#39;t yet.&lt;/p&gt; &#xA;&lt;p&gt;Again, we can run the effectful computation using the provided handlers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Async&#xA;import in.rcard.yaes.Async.*&#xA;&#xA;val maybeUser: Raise[Cancelled] ?=&amp;gt; Option[User] = Async.run {&#xA;    val fb: Async ?=&amp;gt; Fiber[Option[User]] = Async.fork { findUserByName(&#34;John&#34;) }&#xA;    fb.value&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code shows another important aspect of the YÆS library. We can handle an effect eliminating it from the needed capabilities one at time. In the above code, we are handling the &lt;code&gt;Async&lt;/code&gt; effect first, and we remain with the &lt;code&gt;Raise&lt;/code&gt; effect. It&#39;s a powerful feature that allows for a fine-grained management of the effects.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Async&lt;/code&gt; effect is transparent to possible exceptions thrown by the effectful computation. Please, add the &lt;code&gt;IO&lt;/code&gt; effect if you think the effectful computation can throw any exception.&lt;/p&gt; &#xA;&lt;h4&gt;Structured Concurrency&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;Async&lt;/code&gt; effect implements &lt;strong&gt;structured concurrency&lt;/strong&gt;. The &lt;code&gt;Async.run&lt;/code&gt; handler creates a new structured concurrency scope where all the fibers are executed. The &lt;code&gt;Async.run&lt;/code&gt; will wait for all the fibers to finish before returning the result of the effectful computation both if the fibers are joined or not.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Async&#xA;import in.rcard.yaes.Async.*&#xA;&#xA;def updateUser(user: User): Unit                = ???&#xA;def updateClicks(user: User, clicks: Int): Unit = ???&#xA;&#xA;Async.run {&#xA;  val john = User(&#34;John&#34;)&#xA;  Async.fork {&#xA;    updateUser(john)&#xA;  }&#xA;  Async.fork {&#xA;    updateClicks(john, 10)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Async.run&lt;/code&gt; function will wait for both the &lt;code&gt;updateUser&lt;/code&gt; and &lt;code&gt;updateClicks&lt;/code&gt; functions to finish before returning. It&#39;s a powerful feature that allows for a structured way to manage the execution of asynchronous computations.&lt;/p&gt; &#xA;&lt;p&gt;Another important feature of strutctured concurrency is the &lt;em&gt;cancellation&lt;/em&gt; of the fibers. Canceling a fiber is possible by calling the &lt;code&gt;cancel&lt;/code&gt; method on the &lt;code&gt;Fiber&lt;/code&gt; instance. The following code snippet shows how:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Async&#xA;import in.rcard.yaes.Async.*&#xA;import java.util.concurrent.ConcurrentLinkedQueue&#xA;&#xA;val actualQueue = Async.run {&#xA;  val queue = new ConcurrentLinkedQueue[String]()&#xA;  val cancellable = Async.fork {&#xA;    Async.delay(2.seconds)&#xA;    queue.add(&#34;cancellable&#34;)&#xA;  }&#xA;  val fb = Async.fork {&#xA;    Async.delay(500.millis)&#xA;    `cancellable.cancel()`&#xA;    queue.add(&#34;fb2&#34;)&#xA;  }&#xA;  cancellable.join()&#xA;  queue&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Cancellation is collaborative. In the above example, the fiber &lt;code&gt;cancellable&lt;/code&gt; is marked for cancellation by the call &lt;code&gt;cancellable.cancel()&lt;/code&gt;. However, the fiber is not immediately canceled. The fiber is canceled when it reaches the first operation that can be interrupted by the JVM. Hence, cancellation is based on the concept of interruption. In the above example, the &lt;code&gt;cancellable&lt;/code&gt; is canceled when it reaches the &lt;code&gt;delay(2.seconds)&lt;/code&gt; operation. The fiber will never be canceled if we remove the delay operation. A similar behavior is implemented by Kotlin coroutines (see &lt;a href=&#34;https://rockthejvm.com/articles/kotlin-101-coroutines#cancellation&#34;&gt;Kotlin Coroutines - A Comprehensive Introduction / Cancellation&lt;/a&gt; for further details).&lt;/p&gt; &#xA;&lt;p&gt;Cancelling a fiber follows the relationship between parent and child jobs. If a parent&#39;s fiber is canceled, all the children&#39;s fibers are canceled as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Async&#xA;import in.rcard.yaes.Async.*&#xA;import java.util.concurrent.ConcurrentLinkedQueue&#xA;&#xA;val actualQueue = Async.run {&#xA;  val queue = new ConcurrentLinkedQueue[String]()&#xA;  val fb1 = Async.fork(&#34;fb1&#34;) {&#xA;    Async.fork(&#34;inner-fb&#34;) {&#xA;      Async.fork(&#34;inner-inner-fb&#34;) {&#xA;        Async.delay(6.seconds)&#xA;        queue.add(&#34;inner-inner-fb&#34;)&#xA;      }&#xA;&#xA;      Async.delay(5.seconds)&#xA;      queue.add(&#34;innerfb&#34;)&#xA;    }&#xA;    Async.delay(1.second)&#xA;    queue.add(&#34;fb1&#34;)&#xA;  }&#xA;  Async.fork(&#34;fb2&#34;) {&#xA;    Async.delay(500.millis)&#xA;    fb1.cancel()&#xA;    queue.add(&#34;fb2&#34;)&#xA;  }&#xA;  queue&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Trying to get the value from a canceled fiber will raise a &lt;code&gt;Cancelled&lt;/code&gt; error. However, joining a canceled fiber will not raise any error.&lt;/p&gt; &#xA;&lt;h4&gt;Structured Concurrency Primitives&lt;/h4&gt; &#xA;&lt;p&gt;Using the &lt;code&gt;Async.fork&lt;/code&gt; DSL is quite low-level. The library provides a set of structured concurrency primitives that can be used to define more complex asynchronous computations. The available primitives are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Async.par&lt;/code&gt;: Runs two asynchronous computations in parallel and returns both .&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Async.race&lt;/code&gt;: Runs two asynchronous computations in parallel and returns the result of the first computation that finishes. The other one is canceled.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Async.racePair&lt;/code&gt;: Runs two asynchronous computations in parallel and returns the result of the first computation that finishes along with the fiber that is still running.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;The &lt;code&gt;Raise&lt;/code&gt; Effect&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Raise[E]&lt;/code&gt; type describes the possibility that a function can raise an error of type &lt;code&gt;E&lt;/code&gt;. &lt;code&gt;E&lt;/code&gt; can be a logic typed error or an exception. The DSL is heavinly inspired by the &lt;a href=&#34;https://github.com/rcardin/raise4s&#34;&gt;&lt;code&gt;raise4s&lt;/code&gt;&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s see an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;&#xA;def divide(a: Int, b: Int)(using Raise[ArithmeticException]): Int =&#xA;  if (b == 0) Raise.raise(new ArithmeticException(&#34;Division by zero&#34;))&#xA;  else a / b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, the &lt;code&gt;divide&lt;/code&gt; function can raise an &lt;code&gt;ArithmeticException&lt;/code&gt; if the second parameter is zero. In the example, we used an exception as the error type. However, we can use any type as the error type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;&#xA;object DivisionByZero&#xA;type DivisionByZero = DivisionByZero.type&#xA;&#xA;def divide(a: Int, b: Int)(using Raise[DivisionByZero]): Int =&#xA;  if (b == 0) Raise.raise(DivisionByZero)&#xA;  else a / b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The capability offers some functions to lift an program into an effectful computation that uses the &lt;code&gt;Raise[E]&lt;/code&gt; capability. For example, we can rewrite the above example using the &lt;code&gt;ensure&lt;/code&gt; utility function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;&#xA;def divide(a: Int, b: Int)(using Raise[DivisionByZero]): Int =&#xA;  Raise.ensure(b != 0) { DivisionByZero }&#xA;  a / b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we know that a function can throw an exception, we can catch it and trasform it into an error of type &lt;code&gt;E&lt;/code&gt; with the &lt;code&gt;catching&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;&#xA;def divide(a: Int, b: Int)(using Raise[DivisionByZero]): Int =&#xA;  Raise.catching[ArithmeticException] {&#xA;    a / b&#xA;  } { _ =&amp;gt; DivisionByZero }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The effect defines many handlers to deal with the raised errors. For example, we can execute the effectful computation and handle the raised error as a union type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;&#xA;val divisionByZeroResult: Int | DivisionByZero = Raise.run {&#xA;    divide(10, 0)&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, we can handle the raised error transforming it into an &lt;code&gt;Either&lt;/code&gt; type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;&#xA;val divisionByZeroResult: Either[DivisionByZero, Int] = Raise.either {&#xA;  divide(10, 0)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we&#39;re not interested in propagating the exact reason of error, we can use the &lt;code&gt;option&lt;/code&gt; handler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;&#xA;val divisionByZeroResult: Option[Int] = Raise.option {&#xA;  divide(10, 0)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can even ignore the raised error returning a &lt;code&gt;Null&lt;/code&gt; value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Raise&#xA;import in.rcard.yaes.Raise.*&#xA;&#xA;val divisionByZeroResult: Int | Null = Raise.nullable {&#xA;  divide(10, 0)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;The &lt;code&gt;Input&lt;/code&gt; Effect&lt;/h3&gt; &#xA;&lt;p&gt;Every time we need to read input from the console, we can use the &lt;code&gt;Input&lt;/code&gt; effect. The &lt;code&gt;Input&lt;/code&gt; effect provides a set of operations to read input from the console. Since the project is still in an experimental stage, the only one developed operation is the &lt;code&gt;readLn&lt;/code&gt; function that reads a line from the console:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Input&#xA;import in.rcard.yaes.Input.*&#xA;import in.rcard.yaes.Raise.Raise&#xA;import java.io.IOException&#xA;&#xA;val name: (Input, Raise[IOException]) ?=&amp;gt; String = Input.readLn()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The effect uses the Scala &lt;code&gt;scala.io.StdIn&lt;/code&gt; object under the hood, which uses the Java &lt;code&gt;System.in&lt;/code&gt; object to read input from the console. Reading from the console can result in an &lt;code&gt;IOException&lt;/code&gt;, so the &lt;code&gt;Input&lt;/code&gt; effect requires a &lt;code&gt;Raise[IOException]&lt;/code&gt; capability.&lt;/p&gt; &#xA;&lt;p&gt;To run the effectful computation, we can use the provided handlers, which returns the read line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Input&#xA;import in.rcard.yaes.Input.*&#xA;import in.rcard.yaes.Raise.Raise&#xA;import java.io.IOException&#xA;&#xA;val result: String | Null = Raise.nullable {&#xA;  Input.run {&#xA;    name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, we decided to ignore the &lt;code&gt;IOException&lt;/code&gt; error and return a &lt;code&gt;Null&lt;/code&gt; value if an error occurs.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;Output&lt;/code&gt; Effect&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Output&lt;/code&gt; effect provides a set of operations to print output to the console. Is uses the &lt;code&gt;scala.Console&lt;/code&gt; object under the hood.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Output&#xA;import in.rcard.yaes.Output.*&#xA;&#xA;val program: Output ?=&amp;gt; Unit = Output.printLn(&#34;Hello, world!&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As we can see, outputting to the console doesn&#39;t raise any error. The behavior mimics exactly the one exposed by the &lt;code&gt;scala.Console&lt;/code&gt;, which silently ignores any error that can occur during the output operation.&lt;/p&gt; &#xA;&lt;p&gt;To run the effectful computation, we can use the provided handlers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Output&#xA;import in.rcard.yaes.Output.*&#xA;&#xA;// Prints &#34;Hello, world!&#34; to the console&#xA;Output.run {&#xA;  program&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In a similar way, we can output to system err using the &lt;code&gt;printErr&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Output&#xA;import in.rcard.yaes.Output.*&#xA;&#xA;val program: Output ?=&amp;gt; Unit = Output.printErr(&#34;Hello, world!&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;The &lt;code&gt;Random&lt;/code&gt; Effect&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Random&lt;/code&gt; effect provides a set of operations to generate random content. If we need to generate non-deterministic content, we can use it. Under the hood, the effect uses the &lt;code&gt;scala.util.Random&lt;/code&gt; object. As we saw in the introduction, we can use the &lt;code&gt;Random&lt;/code&gt; effect to define a function that generates a random boolean:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Random&#xA;import in.rcard.yaes.Random.*&#xA;&#xA;def flipCoin(using Random): Boolean = Random.nextBoolean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The other random content we can generate is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;nextInt&lt;/code&gt;: Generates a random integer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nextDouble&lt;/code&gt;: Generates a random double.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nextLong&lt;/code&gt;: Generates a random long.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As usual, we can run the effectful computation using the provided handlers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import in.rcard.yaes.Random&#xA;import in.rcard.yaes.Random.*&#xA;&#xA;val result: Boolean = Random.run {&#xA;  flipCoin&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you want to contribute to the project, please do it 🙏! Any help is welcome.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;Many smart engineers helped me with thei ideas and suggestions. I want to thank them all. In particular, I want to thank:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://rockthejvm.com/&#34;&gt;Daniel Ciocîrlan&lt;/a&gt;: He&#39;s the first that saw something in me and gave me the opportunity to work with him. He&#39;s a great mentor and a great friend.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nomisRev&#34;&gt;Simon Vergauwen&lt;/a&gt;: He&#39;s a great engineer. Now, he&#39;s focused on Kotlin and the Arrow Kt library, which drove many of the ideas behind the YÆS library.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/propensive&#34;&gt;Jon Pretty&lt;/a&gt;: We shared some great ideas about the [Raise] effect. I love the way he thinks about programming.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://noelwelsh.com/&#34;&gt;Noel Welsh&lt;/a&gt;: We chat about the &lt;code&gt;Raise&lt;/code&gt; effect and the way to handle errors in a functional way. He&#39;s a great engineer and a great person.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fwbrasil&#34;&gt;Flavio Brasil&lt;/a&gt;: He creates the Kyo library, which is a great inspiration for the YÆS library. He helped me a lot with good suggestions and ideas.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Thanks guys! 🙏&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;p&gt;It follows some quotations and links to valuable resources to understand the concepts behind the library:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.unison-lang.org/docs/fundamentals/abilities/#what-do-we-mean-by-effects&#34;&gt;Introduction to Abilities: A Mental Model - What do we mean by effects&lt;/a&gt;:&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;[…] You might think of an effectful computation as one which performs an action outside of its local scope compared to one which simply returns a calculable value. […] So when functional programmers talk about managing effects, they&#39;re talking about expressing the basic logic of their programs within some guard rails provided by data structures or programming language constructs.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://softwaremill.com/trying-out-unison-part-3-effects-through-abilities/&#34;&gt;Abilities, not monads&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;[…] Unison offers abilities, which are an implementation of algebraic effects. An ability is a property of a function (it&#39;s not part of the value&#39;s type!).&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.unison-lang.org/docs/fundamentals/abilities/for-monadically-inclined/&#34;&gt;Abilities for the monadically inclined&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://effectorientedprogramming.com/&#34;&gt;Effect Oriented Programming, by Bill Frasure, Bruce Eckel, James Ward&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;An Effect is an unpredictable interaction, usually with an external system. […] An Effect System manages Effects by wrapping these calls. […] Unpredictable elements are Side Effects. […] A Side Effect occurs when calling a function changes the context of that function. […] There’s an important difference: Side Effects are unmanaged and Effects are managed. A Side Effect “just happens” but an Effect is explicitly tracked and controlled. […] With an Effect System, we manage Effect behavior by putting that Effect in a kind of box. […] An Effect System provides a set of components that replace Side-Effecting functions in standard libraries, along with the structure for managing Effectful functions that you write. An Effect System enables us to add almost any functionality to a program. […] Managing an Effect means we not only control what results are produced by a function like &lt;code&gt;nextInt()&lt;/code&gt;, but also when those results are produced. The control of when is called deferred execution. Deferred execution is part of the solution for easily attaching functionality to an existing program. […] Deferring the execution of an Effect is part of what enables us to add functionality to that Effect. […] If Effects ran immediately, we could not freely add behaviors. […] When we manage an Effect, we hold a value that represents something that can be run but hasn’t yet.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.eff-lang.org/handlers-tutorial.pdf&#34;&gt;An Introduction to Algebraic Effects and Handlers&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;The idea behind it is that operation calls do not perform actual effects (e.g. printing to an output device), but behave as signals that propagate outwards until they reach a handler with a matching clause&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://docs.scala-lang.org/scala3/reference/experimental/canthrow.html&#34;&gt;CanThrow Capabilities&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://essentialeffects.dev/&#34;&gt;Essential Effects, by Adam Rosien&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;we’ll distinguish two aspects of code: computing values and interacting with the environment. At the same time, we’ll talk about how transparent, or not, our code can be in describing these aspects. […] To understand what plusOne does, you don’t have to look anywhere except the (literal) definition of plusOne. There are no references to anything outside of it. This is sometimes referred to as local reasoning. Under substitution, programs mean the same thing if they evaluate to the same value. 13 + 1 means exactly the same thing as 14. So does plusOne(12 + 1), or even (12 + 1) + 1. This is known as referential transparency. […] If we impose some conditions, we can tame the side effects into something safer; we’ll call these effects. […] The type of the program should tell us what kind of effects the program will perform, in addition to the type of the value it will produce. If the behavior we want relies upon some externally-visible side effect, we separate describing the effects we want to happen from actually making them happen. We can freely substitute the description of effects until the point we run them. […] We delay the side effect so it executes outside of any evaluation, ensuring substitution still holds within. We’ll call these conditions the Effect Pattern. […] We can construct individual effects, and run them, but how do we combine them? We may want to modify the output of an effect (via map), or use the output of an effect to create a new effect (via flatMap). But be careful! Composing effects must not execute them.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://koka-lang.github.io/koka/doc/book.html#sec-handlers&#34;&gt;Koka Language - 3.4. Effect Handlers&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;Effect handlers are a novel way to define control-flow abstractions and dynamic binding as user defined handlers – no need anymore to add special compiler extensions for exceptions, iterators, async-await, probabilistic programming, etc. Moreover, these handlers can be composed freely so the interaction between, say, async-await and exceptions are well-defined.&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=qPvPdRbTF-E&amp;amp;t=763s&#34;&gt;Algebraic Effects from Scratch by Kit Langton&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.cambridge.org/core/journals/journal-of-functional-programming/article/effekt-capabilitypassing-style-for-type-and-effectsafe-extensible-effect-handlers-in-scala/A19680B18FB74AD95F8D83BC4B097D4F&#34;&gt;Effekt: Capability-passing style for type- and effect-safe, extensible effect handlers in Scala&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>