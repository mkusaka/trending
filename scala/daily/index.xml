<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-09T01:43:51Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>scalapb/ScalaPB</title>
    <updated>2023-01-09T01:43:51Z</updated>
    <id>tag:github.com,2023-01-09:/scalapb/ScalaPB</id>
    <link href="https://github.com/scalapb/ScalaPB" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Protocol buffer compiler for Scala.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ScalaPB&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/ScalaPB/community&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/ScalaPB/community.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/ScalaPB/community&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/scalapb/ScalaPB/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/scalapb/ScalaPB/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;ScalaPB is a protocol buffer compiler (&lt;code&gt;protoc&lt;/code&gt;) plugin for Scala. It will generate Scala case classes, parsers and serializers for your protocol buffers.&lt;/p&gt; &#xA;&lt;p&gt;ScalaPB generates case classes that can co-exist in the same project alongside the Java-generated code for ProtocolBuffer. This makes it easy to gradually migrate an existing project from the Java version of protocol buffers to Scala. This is achieved by having the ScalaPB generated code use the proto file as part of the package name (in contrast to Java which uses the file name in CamelCase as an outer class)&lt;/p&gt; &#xA;&lt;p&gt;Each top-level message and enum is written to a separate Scala file. This results in a significant improvement in incremental compilations.&lt;/p&gt; &#xA;&lt;p&gt;Another cool feature of ScalaPB is that it can optionally generate methods that convert a Java protocol buffer to a Scala protocol buffer and vice versa. This is useful if you are gradually migrating a large code base from Java protocol buffers to Scala. The optional Java conversion is required if you want to use &lt;code&gt;fromAscii&lt;/code&gt; (parsing ASCII representation of a protocol buffer). The current implementation delegates to the Java version.&lt;/p&gt; &#xA;&lt;h1&gt;Highlights&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Supports proto2 and proto3&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Easily update nested structure in functional way using lenses&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Scala.js integration&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;GRPC integration&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Compatible with SparkSQL (through a helper library)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Conversion to and from JSON&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Support user-defined options (since 0.5.29)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Support extensions (since 0.6.0)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Versions&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Version&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.6.x&lt;/td&gt; &#xA;   &lt;td&gt;Stable. Supports Protobuf 2.6.x to 3.5.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.5.x&lt;/td&gt; &#xA;   &lt;td&gt;Supports Protobuf 2.6.x and Protobuf 3.1.x.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0.4.x&lt;/td&gt; &#xA;   &lt;td&gt;Stable, unsupported. Works with Protobuf 2.6.x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Installing&lt;/h1&gt; &#xA;&lt;p&gt;To automatically generate Scala case classes for your messages add ScalaPB&#39;s sbt plugin to your project. Create a file named &lt;code&gt;project/protoc.sbt&lt;/code&gt; containing the following line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;addSbtPlugin(&#34;com.thesamet&#34; % &#34;sbt-protoc&#34; % &#34;1.0.2&#34;)&#xA;&#xA;libraryDependencies += &#34;com.thesamet.scalapb&#34; %% &#34;compilerplugin&#34; % &#34;0.11.3&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add the following line to your &lt;code&gt;build.sbt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Compile / PB.targets := Seq(&#xA;  scalapb.gen() -&amp;gt; (Compile / sourceManaged).value / &#34;scalapb&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For additional configuration options, see &lt;a href=&#34;https://scalapb.github.io/docs/sbt-settings&#34;&gt;ScalaPB SBT Settings&lt;/a&gt; documentation&lt;/p&gt; &#xA;&lt;h1&gt;Using ScalaPB&lt;/h1&gt; &#xA;&lt;p&gt;Documentation is available at &lt;a href=&#34;https://scalapb.github.io/&#34;&gt;ScalaPB website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Questions?&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://scalapb.github.io/docs/contact&#34;&gt;contacting us&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Testing&lt;/h1&gt; &#xA;&lt;p&gt;ScalaPB uses ScalaCheck to aggressively test the generated code. The test generates many different sets of proto files. The sets are growing in complexity: number of files, references to messages from other protos, message nesting and so on. Then, test data is generated to populate this protocol schema, then we check that the ScalaPB generated code behaves exactly like the reference implementation in Java.&lt;/p&gt; &#xA;&lt;p&gt;Running the tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sbt test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The tests take a few minutes to run. There is a smaller test suite called &lt;code&gt;e2e&lt;/code&gt; that uses the sbt plugin to compile the protos and runs a series of ScalaChecks on the outputs. To run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./e2e.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Sponsors&lt;/h1&gt; &#xA;&lt;p&gt;We are very thankful to our sponsors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://moia.io&#34;&gt;MOIA&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ollyw&#34;&gt;Oliver Wickham (ollyw)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bikaras&#34;&gt;Evgeny Rubtsov (bikaras)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alex-gaiduchok&#34;&gt;Alex Gaiduchok&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ASRagab&#34;&gt;Ahmad Ragab&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>gvolpe/pfps-shopping-cart</title>
    <updated>2023-01-09T01:43:51Z</updated>
    <id>tag:github.com,2023-01-09:/gvolpe/pfps-shopping-cart</id>
    <link href="https://github.com/gvolpe/pfps-shopping-cart" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üõí The Shopping Cart application developed in the book &#34;Practical FP in Scala: A hands-on approach&#34;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;shopping-cart&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/gvolpe/pfps-shopping-cart/workflows/Build/badge.svg?sanitize=true&#34; alt=&#34;CI Status&#34;&gt; &lt;a href=&#34;https://mergify.io&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint.svg?url=https://gh.mergify.io/badges/gvolpe/pfps-shopping-cart&amp;amp;style=flat&#34; alt=&#34;MergifyStatus&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://scala-steward.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Scala_Steward-helping-brightgreen.svg?style=flat&amp;amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAMAAAARSr4IAAAAVFBMVEUAAACHjojlOy5NWlrKzcYRKjGFjIbp293YycuLa3pYY2LSqql4f3pCUFTgSjNodYRmcXUsPD/NTTbjRS+2jomhgnzNc223cGvZS0HaSD0XLjbaSjElhIr+AAAAAXRSTlMAQObYZgAAAHlJREFUCNdNyosOwyAIhWHAQS1Vt7a77/3fcxxdmv0xwmckutAR1nkm4ggbyEcg/wWmlGLDAA3oL50xi6fk5ffZ3E2E3QfZDCcCN2YtbEWZt+Drc6u6rlqv7Uk0LdKqqr5rk2UCRXOk0vmQKGfc94nOJyQjouF9H/wCc9gECEYfONoAAAAASUVORK5CYII=&#34; alt=&#34;Scala Steward badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://typelevel.org/cats/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/typelevel/cats/c23130d2c2e4a320ba4cde9a7c7895c6f217d305/docs/src/main/resources/microsite/img/cats-badge.svg?sanitize=true&#34; height=&#34;40px&#34; align=&#34;right&#34; alt=&#34;Cats friendly&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;‚ö†Ô∏è &lt;strong&gt;IMPORTANT NOTICE&lt;/strong&gt; If you are reading the first edition of &lt;a href=&#34;https://leanpub.com/pfp-scala&#34;&gt;Practical FP in Scala&lt;/a&gt;, go to the &lt;a href=&#34;https://github.com/gvolpe/pfps-shopping-cart/tree/master&#34;&gt;master&lt;/a&gt; branch. You&#39;re now on the &lt;code&gt;second-edition&lt;/code&gt; branch, which is the new default. ‚ö†Ô∏è&lt;/p&gt; &#xA;&lt;h2&gt;Components Overview&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s an overview of the different components that make this application.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/gvolpe/pfps-shopping-cart/second-edition/app.png&#34; alt=&#34;components&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Both &lt;strong&gt;Services&lt;/strong&gt; and &lt;strong&gt;Authentication&lt;/strong&gt; are &lt;em&gt;algebras&lt;/em&gt;. The latter are mainly dependencies for some of the services.&lt;/li&gt; &#xA; &lt;li&gt;Programs shows &lt;strong&gt;Checkout&lt;/strong&gt;, the business logic that combines most of the services.&lt;/li&gt; &#xA; &lt;li&gt;Effects show our custom interfaces required implicitly.&lt;/li&gt; &#xA; &lt;li&gt;The lines connecting services to Redis and PostgreSQL show which ones access which storage.&lt;/li&gt; &#xA; &lt;li&gt;The HTTP layer shows the client and the different routes.&lt;/li&gt; &#xA; &lt;li&gt;At the very end, we have both the modules and the entry point to the application.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Authentication Data&lt;/h2&gt; &#xA;&lt;p&gt;For didactic purposes, this is made available but in a real application &lt;strong&gt;THIS SHOULD NEVER BE MADE PUBLIC&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For Admin users, the following environment variables are needed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SC_JWT_SECRET_KEY&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SC_JWT_CLAIM&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SC_ADMIN_USER_TOKEN&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For access token (manipulation of the shopping cart):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SC_ACCESS_TOKEN_SECRET_KEY&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For password encryption:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SC_PASSWORD_SALT&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the files &lt;a href=&#34;https://raw.githubusercontent.com/gvolpe/pfps-shopping-cart/second-edition/app/docker-compose.yml&#34;&gt;docker-compose.yml&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/gvolpe/pfps-shopping-cart/second-edition/.env&#34;&gt;.env&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Generate your own auth data&lt;/h3&gt; &#xA;&lt;p&gt;In order to generate a valid JWT token, you need a &lt;em&gt;secret key&lt;/em&gt;, which can be any String, and a &lt;em&gt;JWT Claim&lt;/em&gt;, which can be any valid JSON. You can then generate a token, as shown below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val claim = JwtClaim(&#xA;  &#34;&#34;&#34;&#xA;    {&#34;uuid&#34;: &#34;6290c116-4153-11ea-b77f-2e728ce88125&#34;}&#xA;  &#34;&#34;&#34;&#xA;)&#xA;&#xA;val secretKey = JwtSecretKey(&#34;any-secret&#34;)&#xA;&#xA;val algo = JwtAlgorithm.HS256&#xA;&#xA;val mkToken: IO[JwtToken] =&#xA;  jwtEncode[IO](claim, secretKey, algo)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In our case, our claim contains a UUID, which is used to identify the Admin Id. In practice, though, a JWT can be any valid JSON.&lt;/p&gt; &#xA;&lt;p&gt;Take a look at the &lt;a href=&#34;https://github.com/gvolpe/pfps-shopping-cart/tree/master/modules/core/src/main/scala/tokens/generator.scala&#34;&gt;TokenGenerator program&lt;/a&gt; to learn more.&lt;/p&gt; &#xA;&lt;h2&gt;Tests&lt;/h2&gt; &#xA;&lt;p&gt;To run Unit Tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sbt test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run Integration Tests we need to run both &lt;code&gt;PostgreSQL&lt;/code&gt; and &lt;code&gt;Redis&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker-compose up&#xA;sbt it:test&#xA;docker-compose down&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Access Redis &amp;amp; Postgres&lt;/h3&gt; &#xA;&lt;p&gt;We can interact with both servers directly using the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ docker-compose exec Redis /usr/local/bin/redis-cli&#xA;$ docker-compose exec Postgres usr/local/bin/psql -d store -U postgres&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build Docker image&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;sbt docker:publishLocal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Our image should now be built. We can check it by running the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt; docker images | grep shopping-cart&#xA;REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE&#xA;shopping-cart                 latest              646501a87362        2 seconds ago       138MB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run our application using our Docker image, run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /app&#xA;docker-compose up&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Payments Client&lt;/h2&gt; &#xA;&lt;p&gt;The configured test payment client is a fake API that always returns 200 with a Payment Id. Users are encouraged to make modifications, e.g. return 409 with another Payment Id (you can create one &lt;a href=&#34;https://www.uuidgenerator.net/api/version1/1&#34;&gt;here&lt;/a&gt;) or any other HTTP status to see how our application handles the different cases.&lt;/p&gt; &#xA;&lt;p&gt;This fake API can be modified at: &lt;a href=&#34;https://beeceptor.com/console/payments&#34;&gt;https://beeceptor.com/console/payments&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;HTTP API Resources&lt;/h2&gt; &#xA;&lt;p&gt;If you use the &lt;a href=&#34;https://insomnia.rest/&#34;&gt;Insomnia&lt;/a&gt; REST Client, you can import the shopping cart resources using the &lt;a href=&#34;https://raw.githubusercontent.com/gvolpe/pfps-shopping-cart/second-edition/insomnia.json&#34;&gt;insomnia.json&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;h2&gt;LICENSE&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this project except in compliance with the License. You may obtain a copy of the License at &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.&lt;/p&gt;</summary>
  </entry>
</feed>