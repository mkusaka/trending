<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-27T01:34:14Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>business4s/decisions4s</title>
    <updated>2024-05-27T01:34:14Z</updated>
    <id>tag:github.com,2024-05-27:/business4s/decisions4s</id>
    <link href="https://github.com/business4s/decisions4s" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple, Business-friendly Decisions Engine for Scala&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Decisions4s&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/discord/1240565362601230367?style=flat-square&amp;amp;logo=discord&amp;amp;link=https%3A//bit.ly/business4s-discord&#34; alt=&#34;Discord&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository contains a prototype of library helping in expressing business rules. It can be seen as an alternative to Rules Engines or DMN.&lt;/p&gt; &#xA;&lt;p&gt;The approach taken relies on higher-order data and follows DMN evaluation model, where each decision has specific input &amp;amp; output types and consists of a set of rules that match on the input and produce the output.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] As of now Decisions4s don&#39;t have a single release. The example below assumes you released it yourself or you&#39;re contributing to the examples project.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We will model rules governing a pull request process. We start by defining the input and out of the decision.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import decisions4s.*&#xA;&#xA;case class Input[F[_]](numOfApprovals: F[Int], isTargetBranchProtected: F[Boolean], authorIsAdmin: F[Boolean])&#xA;  derives HKD&#xA;&#xA;case class Output[F[_]](allowMerging: F[Boolean], notifyUnusualAction: F[Boolean])&#xA;  derives HKD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We take 3 values as input and provide 2 values as the output. Now let&#39;s define the rules&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def rules: List[Rule[Input, Output]] = List(&#xA;  Rule(&#xA;    matching = Input(&#xA;      numOfApprovals = it &amp;gt; 0,&#xA;      isTargetBranchProtected = it.isFalse,&#xA;      authorIsAdmin = it.catchAll,&#xA;    ),&#xA;    output = Output(&#xA;      allowMerging = true,&#xA;      notifyUnusualAction = false,&#xA;    ),&#xA;  ),&#xA;  Rule(&#xA;    matching = Input(&#xA;      numOfApprovals = it &amp;gt; 1,&#xA;      isTargetBranchProtected = it.isTrue,&#xA;      authorIsAdmin = it.catchAll,&#xA;    ),&#xA;    output = Output(&#xA;      allowMerging = true,&#xA;      notifyUnusualAction = false,&#xA;    ),&#xA;  ),&#xA;  Rule(&#xA;    matching = Input(&#xA;      numOfApprovals = it.catchAll,&#xA;      isTargetBranchProtected = it.catchAll,&#xA;      authorIsAdmin = it.isTrue,&#xA;    ),&#xA;    output = Output(&#xA;      allowMerging = true,&#xA;      notifyUnusualAction = true,&#xA;    ),&#xA;  ),&#xA;  Rule.default(&#xA;    Output(&#xA;      allowMerging = false,&#xA;      notifyUnusualAction = false,&#xA;    ),&#xA;  ),&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We have defined 4 rules:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;unprotected branch requires 1 approval&lt;/li&gt; &#xA; &lt;li&gt;protected branch requires 2 approvals&lt;/li&gt; &#xA; &lt;li&gt;admin can merge anything without approvals but this sends a notification&lt;/li&gt; &#xA; &lt;li&gt;nothing can be merged otherwise&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Now let&#39;s create a decision table&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val decisionTable: DecisionTable[Input, Output] =&#xA;  DecisionTable(&#xA;    rules,&#xA;    inputNames = Name.auto[Input],&#xA;    outputNames = Name.auto[Output],&#xA;    name = &#34;PullRequestDecision&#34;,&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Defining the decision means specifying the rules and names for fields and decision itself.&lt;/p&gt; &#xA;&lt;p&gt;Now we can evaluate our decision:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;decisionTable.evaluate(Input[Value](&#xA;  numOfApprovals = 1,&#xA;  isTargetBranchProtected = false,&#xA;  authorIsAdmin = true&#xA;))&#xA;// Output(allowMerging = true, notifyUnusualAction = false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It works! Lets generate the DMN for the business.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import decisions4s.dmn.DmnConverter&#xA;val dmnInstance = DmnConverter.convert(decisionTable)&#xA;import org.camunda.bpm.model.dmn.Dmn&#xA;Dmn.writeModelToFile(new java.io.File(s&#34;./${decisionTable.name}.dmn&#34;), dmnInstance)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now if we open this file in &lt;a href=&#34;https://bpmn.io/toolkit/dmn-js/&#34;&gt;bpmn.io&lt;/a&gt; or Camunda Modeler we will see the following table.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/business4s/decisions4s/main/docs/PullRequestDecision.png&#34; alt=&#34;PullRequestDecision.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;To see the full example check &lt;a href=&#34;https://raw.githubusercontent.com/business4s/decisions4s/main/decisions4s-examples/src/main/scala/decisions4s/example/docs/PullRequestDecision.scala&#34;&gt;PullRequestDecision.scala&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;TODO:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Defining hit policy - Currently decision table returns the first result, this can be customised to allow for at least collecting all the hits&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Release/CI/CD&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Non-features&lt;/h2&gt; &#xA;&lt;p&gt;The following items are currently not available, although they could be implemented if there is enough interest.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Serialization&lt;/strong&gt; - currently the decisions are not meant to be serialized and transferred over the wire, but it should be possible.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Effectful evaluation&lt;/strong&gt; - as of now, all the inputs are expected to be present at the time of evaluation. This could be extended for them to be lazily evaluated, so that rule can skip some expensive operations (e.g. network calls) if the decision is taken without them. This item has a high chance of being implemented through accepting IO as input and memoizing it.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>business4s/workflows4s</title>
    <updated>2024-05-27T01:34:14Z</updated>
    <id>tag:github.com,2024-05-27:/business4s/workflows4s</id>
    <link href="https://github.com/business4s/workflows4s" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple, Composable, Business-oriented Workflows for Scala&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Workflows4s&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/discord/1240565362601230367?style=flat-square&amp;amp;logo=discord&amp;amp;link=https%3A%2F%2Fbit.ly%2Fbusiness4s-discord&#34; alt=&#34;Discord&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository contains an experimental approach to building workflows in Scala.&lt;/p&gt; &#xA;&lt;p&gt;It tries to merge Temporal&#39;s execution model with native event-sourcing while removing the most of the magic from the solution.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://business4s.github.io/workflows4s&#34;&gt;&lt;strong&gt;Docs&lt;/strong&gt;&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;p&gt;The following items are planned in scope of this experiment&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Handling signals&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Handling queries&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Recovery from events&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Handling step sequencing (flatMap)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Handling IO execution&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Handling state transitions&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Handling errors&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Declarative API + graph rendering&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Typesafe state queries&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Handling interruptions&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Handling timers (await, timout)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Pekko runtime PoC&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Postgres runtime PoC&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Checkpointing&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Test harness&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Explicit approach to handling workflow evolutions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Followup work&lt;/h3&gt; &#xA;&lt;p&gt;Items below are outside the scope of PoC but showcase the possibilities.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; UI &amp;amp; API to visualize workflow progress&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Observability support&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Non-interrupting events (e.g. signal or cycle timer) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;non interrupting cycle timer example: every 24h send a notif&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Splitting the workflow (parallel execution and/or parallel waiting)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Design&lt;/h2&gt; &#xA;&lt;h3&gt;What it does?&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;workflows are built using &lt;code&gt;WIO&lt;/code&gt; monad&lt;/li&gt; &#xA; &lt;li&gt;a workflow supports following operations: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;running side-effectful/non-deterministic computations&lt;/li&gt; &#xA;   &lt;li&gt;receiving signals that can modify the workflow state&lt;/li&gt; &#xA;   &lt;li&gt;querying the workflow state&lt;/li&gt; &#xA;   &lt;li&gt;recovering workflow state without re-triggering of side-effecting operations&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;WIO&lt;/code&gt; is just a pure value object describing the workflow &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;to run it you need an interpreter with ability to persist events in a journal and read them&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How it works?&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;on the first run &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;it executes IOs on its path. Each IO has to produce an event that is persisted in the journal.&lt;/li&gt; &#xA;   &lt;li&gt;event handlers are allowed to modify the workflow state&lt;/li&gt; &#xA;   &lt;li&gt;workflow stops when signal is expected and moves forward once signal is received&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;during recovery (e.g. after service restart) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;events are read from the journal and applied to the workflow&lt;/li&gt; &#xA;   &lt;li&gt;all IOs and signals are skipped if the corresponding event is registered&lt;/li&gt; &#xA;   &lt;li&gt;once events are exhausted the workflow continues to run as usual&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Caveats:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;all the IOs need to be idempotent, we can&#39;t gaurantee exactly-once execution, only at-least-once&lt;/li&gt; &#xA; &lt;li&gt;workflow migrations (modify the workflow structure, e.g. order of operations) is a very complicated topic and will be described separately in due time&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Alternatives&lt;/h1&gt; &#xA;&lt;p&gt;Workflows4s is heavily inspired by Temporal, and other similar projects but it has two primary design differences:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;no additional server - there is no external component to be deployed and managed. Your code and database is all you need.&lt;/li&gt; &#xA; &lt;li&gt;process diagram rendering - it allows to render a process diagram from code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;List of related projects:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Project&lt;/th&gt; &#xA;   &lt;th&gt;Self-contained&lt;/th&gt; &#xA;   &lt;th&gt;Code-first&lt;/th&gt; &#xA;   &lt;th&gt;Declarative&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://temporal.io/&#34;&gt;Temporal&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/uber/cadence&#34;&gt;Cadence&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://camunda.com/&#34;&gt;Camunda&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Netflix/conductor&#34;&gt;Conductor&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.golem.cloud/&#34;&gt;Golem Cloud&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://aws.amazon.com/step-functions/&#34;&gt;Aws Step Functions&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/zio/zio-flow&#34;&gt;zio-flow&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;~ [2]&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/notxcain/aecor&#34;&gt;aecor&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/endless4s/endless&#34;&gt;endless&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/business4s/workflows4s/main/infinitic.io&#34;&gt;infintic&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;~ [1]&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://ing-bank.github.io/baker/&#34;&gt;Baker&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[1] - Infintic requires Apache Pulsar, which can be seen as a database and is not specific to Infintic&lt;/li&gt; &#xA; &lt;li&gt;[2] - zio-flow could theoretically render the diagrams but its not implemented at the moment&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A longer list of similar tools can be found &lt;a href=&#34;https://meirwah.github.io/awesome-workflow-engines/&#34;&gt;here&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>viperproject/silver</title>
    <updated>2024-05-27T01:34:14Z</updated>
    <id>tag:github.com,2024-05-27:/viperproject/silver</id>
    <link href="https://github.com/viperproject/silver" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Definition of the Viper intermediate verification language.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;====== Silver&lt;/h1&gt; &#xA;&lt;p&gt;Silver is the intermediate verification language of the &lt;code&gt;Viper project &amp;lt;http://www.pm.inf.ethz.ch/research/viper.html&amp;gt;&lt;/code&gt;_ by &lt;code&gt;Programming Methodology Group &amp;lt;http://www.pm.inf.ethz.ch/&amp;gt;&lt;/code&gt;_ at the Department of Computer Science, ETH Zurich.&lt;/p&gt; &#xA;&lt;h1&gt;Quick Start&lt;/h1&gt; &#xA;&lt;p&gt;Instructions for how to get started with Viper can be found &lt;code&gt;here. &amp;lt;http://www.pm.inf.ethz.ch/research/viper/downloads.html&amp;gt;&lt;/code&gt;_&lt;/p&gt; &#xA;&lt;h1&gt;Syntax Highlighting&lt;/h1&gt; &#xA;&lt;p&gt;Files for LaTeX and various editors can be found under &lt;code&gt;silver/util/highlighting&lt;/code&gt; directory.&lt;/p&gt;</summary>
  </entry>
</feed>