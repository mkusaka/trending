<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-11T02:41:37Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nulab/scala-oauth2-provider</title>
    <updated>2023-11-11T02:41:37Z</updated>
    <id>tag:github.com,2023-11-11:/nulab/scala-oauth2-provider</id>
    <link href="https://github.com/nulab/scala-oauth2-provider" rel="alternate"></link>
    <summary type="html">&lt;p&gt;OAuth 2.0 server-side implementation written in Scala&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;oauth2-server for Scala &lt;a href=&#34;https://github.com/nulab/scala-oauth2-provider/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/nulab/scala-oauth2-provider/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://tools.ietf.org/html/rfc6749&#34;&gt;The OAuth 2.0&lt;/a&gt; server-side implementation written in Scala.&lt;/p&gt; &#xA;&lt;p&gt;This provides OAuth 2.0 server-side functionality and supporting function for &lt;a href=&#34;http://www.playframework.com/&#34;&gt;Play Framework&lt;/a&gt; and &lt;a href=&#34;http://akka.io/&#34;&gt;Akka HTTP&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The idea of this library originally comes from &lt;a href=&#34;https://github.com/yoichiro/oauth2-server&#34;&gt;oauth2-server&lt;/a&gt; which is Java implementation of OAuth 2.0.&lt;/p&gt; &#xA;&lt;h2&gt;Supported OAuth features&lt;/h2&gt; &#xA;&lt;p&gt;This library supports all grant types.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Authorization Code Grant (PKCE Authorization Code Grants are supported)&lt;/li&gt; &#xA; &lt;li&gt;Resource Owner Password Credentials Grant&lt;/li&gt; &#xA; &lt;li&gt;Client Credentials Grant&lt;/li&gt; &#xA; &lt;li&gt;Implicit Grant&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;and an access token type called &lt;a href=&#34;http://tools.ietf.org/html/rfc6750&#34;&gt;Bearer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;h3&gt;Play Framework&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/nulab/play2-oauth2-provider&#34;&gt;the project&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Akka HTTP&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/nulab/akka-http-oauth2-provider&#34;&gt;the project&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Other frameworks&lt;/h3&gt; &#xA;&lt;p&gt;Add &lt;code&gt;scala-oauth2-core&lt;/code&gt; library dependencies of your project. In this case, you need to implement your own OAuth provider working with web framework you use.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies ++= Seq(&#xA;  &#34;com.nulab-inc&#34; %% &#34;scala-oauth2-core&#34; % &#34;1.6.0&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;h3&gt;Implement DataHandler&lt;/h3&gt; &#xA;&lt;p&gt;Whether you use Play Framework or not, you have to implement &lt;code&gt;DataHandler&lt;/code&gt; trait and make it work with your own &lt;code&gt;User&lt;/code&gt; class that may be already defined in your application.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class User(id: Long, name: String, hashedPassword: String)&#xA;&#xA;class MyDataHandler extends DataHandler[User] {&#xA;&#xA;  def validateClient(maybeClientCredential: Option[ClientCredential], request: AuthorizationRequest): Future[Boolean] = ???&#xA;&#xA;  def findUser(maybeClientCredential: Option[ClientCredential], request: AuthorizationRequest): Future[Option[User]] = ???&#xA;&#xA;  def createAccessToken(authInfo: AuthInfo[User]): Future[AccessToken] = ???&#xA;&#xA;  def getStoredAccessToken(authInfo: AuthInfo[User]): Future[Option[AccessToken]] = ???&#xA;&#xA;  def refreshAccessToken(authInfo: AuthInfo[User], refreshToken: String): Future[AccessToken] = ???&#xA;&#xA;  def findAuthInfoByCode(code: String): Future[Option[AuthInfo[User]]] = ???&#xA;&#xA;  def findAuthInfoByRefreshToken(refreshToken: String): Future[Option[AuthInfo[User]]] = ???&#xA;&#xA;  def deleteAuthCode(code: String): Future[Unit] = ???&#xA;&#xA;  def findAccessToken(token: String): Future[Option[AccessToken]] = ???&#xA;&#xA;  def findAuthInfoByAccessToken(accessToken: AccessToken): Future[Option[AuthInfo[User]]] = ???&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your data access is blocking for the data storage, then you just wrap your implementation in the &lt;code&gt;DataHandler&lt;/code&gt; trait with &lt;code&gt;Future.successful(...)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For more details, refer to Scaladoc of &lt;code&gt;DataHandler&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;AuthInfo&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;DataHandler&lt;/code&gt; returns &lt;code&gt;AuthInfo&lt;/code&gt; as authorized information. &lt;code&gt;AuthInfo&lt;/code&gt; is made up of the following fields.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class AuthInfo[User](&#xA;  user: User,&#xA;  clientId: Option[String],&#xA;  scope: Option[String],&#xA;  redirectUri: Option[String],&#xA;  codeChallenge: Option[String] = None,&#xA;  codeChallengeMethod: Option[CodeChallengeMethod] = None&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;user &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;user&lt;/code&gt; is authorized by DataHandler&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;clientId &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;clientId&lt;/code&gt; which is sent from a client has been verified by &lt;code&gt;DataHandler&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;If your application requires client_id for client authentication, you can get &lt;code&gt;clientId&lt;/code&gt; as below &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;val clientId = authInfo.clientId.getOrElse(throw new InvalidClient())&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;scope &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;inform the client of the scope of the access token issued&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;redirectUri &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This value must be enabled on authorization code grant&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;codeChallenge: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This value is OPTIONAL. Only set this value if doing a PKCE authorization request. When set, PKCE rules apply on the AuthorizationCode Grant Handler&lt;/li&gt; &#xA;   &lt;li&gt;This value is from a PKCE authorization request. This is the challenge supplied during the auth request if given.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;codeChallengeMethod: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This value is OPTIONAL and used only by PKCE when a codeChallenge value is also set.&lt;/li&gt; &#xA;   &lt;li&gt;This value is from a PKCE authorization request. This is the method used to transform the code verifier. Must be either Plain or S256. If not specified and codeChallenge is provided then Plain is assumed (per RFC7636)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>nulab/typetalk-webhook-play-example</title>
    <updated>2023-11-11T02:41:37Z</updated>
    <id>tag:github.com,2023-11-11:/nulab/typetalk-webhook-play-example</id>
    <link href="https://github.com/nulab/typetalk-webhook-play-example" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Example code for webhook in Typetalk http://www.typetalk.in&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Typetalk Webhook Example using Play Framework 2&lt;/h1&gt; &#xA;&lt;p&gt;This is an example of &lt;a href=&#34;https://developer.nulab-inc.com/docs/typetalk/webhook&#34;&gt;Typetalk Webhook feature&lt;/a&gt; using Play Framework 2.&lt;/p&gt; &#xA;&lt;p&gt;(&lt;a href=&#34;https://typetalk.in&#34;&gt;Typetalk&lt;/a&gt; is an instant messaging app to share and discuss ideas with your team.)&lt;/p&gt; &#xA;&lt;h2&gt;Run&lt;/h2&gt; &#xA;&lt;p&gt;You can run this application on Heroku.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git push heroku master&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Bot setting&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open the Edit Topic page, then click on the Bots tab and &#34;Add bot&#34; button.&lt;/li&gt; &#xA; &lt;li&gt;Enter a bot ID, name and its Webhook URL, then click on the &#34;Create&#34; button.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cacoo.com/diagrams/uD1XUqaS0ZqGXaPx-78DF3.png&#34; alt=&#34;Bot setting&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Bots&lt;/h2&gt; &#xA;&lt;p&gt;This example has 3 bots.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;/lgtm&lt;/li&gt; &#xA; &lt;li&gt;/weather&lt;/li&gt; &#xA; &lt;li&gt;/weather/forecast&lt;/li&gt; &#xA; &lt;li&gt;/localtime&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;LGTM&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cacoo.com/diagrams/uD1XUqaS0ZqGXaPx-369EF.png&#34; alt=&#34;lgtm&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Weather&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cacoo.com/diagrams/uD1XUqaS0ZqGXaPx-3AE84.png&#34; alt=&#34;weather&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Weather forecast&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cacoo.com/diagrams/uD1XUqaS0ZqGXaPx-C1333.png&#34; alt=&#34;weather&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Local time&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cacoo.com/diagrams/uD1XUqaS0ZqGXaPx-7E57A.png&#34; alt=&#34;local time&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>