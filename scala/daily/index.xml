<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-04T01:44:56Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>yoohaemin/decrel</title>
    <updated>2023-03-04T01:44:56Z</updated>
    <id>tag:github.com,2023-03-04:/yoohaemin/decrel</id>
    <link href="https://github.com/yoohaemin/decrel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Composable relations for Scala&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Decrel&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/yoohaemin/decrel/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/yoohaemin/decrel/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;Continuous Integration&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/yoohaemin/decrel/master/#&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Project%20Stage-Experimental-yellow.svg?sanitize=true&#34; alt=&#34;Project stage: Experimental&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://s01.oss.sonatype.org/content/repositories/releases/com/yoohaemin/decrel-core_3/&#34; title=&#34;Sonatype Releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/nexus/r/https/s01.oss.sonatype.org/com.yoohaemin/decrel-core_3.svg?sanitize=true&#34; alt=&#34;Release Artifacts&#34; title=&#34;Sonatype Releases&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://s01.oss.sonatype.org/content/repositories/snapshots/com/yoohaemin/decrel-core_3/&#34; title=&#34;Sonatype Snapshots&#34;&gt;&lt;img src=&#34;https://img.shields.io/nexus/s/https/s01.oss.sonatype.org/com.yoohaemin/decrel-core_3.svg?sanitize=true&#34; alt=&#34;Snapshot Artifacts&#34; title=&#34;Sonatype Snapshots&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Decrel is a library for &lt;strong&gt;dec&lt;/strong&gt;larative programming using &lt;strong&gt;rel&lt;/strong&gt;ations between your data.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;We commonly use abstractions from optics libraries to zoom into data that is in memory.&lt;/p&gt; &#xA;&lt;p&gt;For a moment, let&#39;s free ourselves of the in-memory limitation, and try imagining an applications&#39; entire datasource as a giant case class.&lt;/p&gt; &#xA;&lt;p&gt;In such a structure, abstract &lt;em&gt;relations&lt;/em&gt; between data will correspond to concrete lenses in optics.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Please visit the &lt;a href=&#34;https://decrel.yoohaemin.com&#34;&gt;documentation&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Usecases&lt;/h2&gt; &#xA;&lt;p&gt;For a given domain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Book(id: Book.Id, name: String, author: Author.Id)&#xA;object Book {&#xA;  case class Id(value: String)&#xA;}&#xA;&#xA;case class Author(id: Author.Id, name: String, books: List[Book.Id])&#xA;object Author {&#xA;  case class Id(value: String)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can declare relations between your entities by extending the appropriate &lt;code&gt;Relation&lt;/code&gt; types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Book(id: Book.Id, name: String, author: Author.Id)&#xA;object Book {&#xA;  case class Id(value: String)&#xA;  &#xA;  // Define a relation to itself by extending Relation.Self&#xA;  // This is useful when composing with other relations later&#xA;  case object self extends Relation.Self[Book]&#xA;  &#xA;  // Define the relation and the kind of relation that exists between two entities&#xA;  // Relation.Single means for a book there is a single author&#xA;  // depending on your domain, you may want to choose different kinds&#xA;  case object author extends Relation.Single[Book, Author]&#xA;}&#xA;&#xA;case class Author(id: Author.Id, name: String, books: List[Book.Id])&#xA;object Author {&#xA;  case class Id(value: String)&#xA;  &#xA;  case object self extends Relation.Self[Author]&#xA;&#xA;  // Extending Relation.Many means for a given author, there is a list of books&#xA;  case object book extends Relation.Many[Author, List, Book]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Accessing your data source&lt;/h3&gt; &#xA;&lt;p&gt;To express &#34;given a book, get the author &amp;amp;&amp;amp; all the books written by them&#34;, looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val getAuthorAndTheirBooks = Book.author &amp;lt;&amp;gt;: Author.books&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But how would you run this with an instance of Book that you have?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val exampleBook = Book(Book.Id(&#34;book_id&#34;), &#34;bookname&#34;, Author.Id(&#34;author_id&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your application uses &lt;a href=&#34;https://github.com/zio/zio&#34;&gt;ZIO&lt;/a&gt;, there is an integration with ZIO through &lt;a href=&#34;https://github.com/zio/zio-query&#34;&gt;ZQuery&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import decrel.reify.zquery._&#xA;import proofs._  // Datasource implementation defined elsewhere in your code&#xA;&#xA;// Exception is user defined in the datasource implementation&#xA;val output: zio.IO[AppError, (Author, List[Book])] = &#xA;  getAuthorAndTheirBooks.toZIO(exampleBook)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or if you use &lt;a href=&#34;https://github.com/typelevel/cats-effect&#34;&gt;cats-effect&lt;/a&gt;, there is an integration with any effect type that implements &lt;code&gt;cats.effect.Concurrent&lt;/code&gt; (including &lt;code&gt;cats.effect.IO&lt;/code&gt;) through the &lt;a href=&#34;https://github.com/47degrees/fetch&#34;&gt;Fetch&lt;/a&gt; library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class BookServiceImpl[F[_]](&#xA;  // contains your datasource implementations&#xA;  proofs: Proofs[F]&#xA;) {&#xA;  import proofs._&#xA;&#xA;  val output: F[(Author, List[Book])] =&#xA;    getAuthorAndTheirBooks.toF(exampleBook) &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, queries made by decrel will be efficiently batched and deduplicated, thanks to the underlying[^1] &lt;code&gt;ZQuery&lt;/code&gt; or &lt;code&gt;Fetch&lt;/code&gt; data types which are based on &lt;a href=&#34;https://github.com/facebook/Haxl&#34;&gt;Haxl&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[^1]: You are not required to interact with ZQuery or Fetch datatypes in your application -- simply use the APIs that exposes &lt;code&gt;ZIO&lt;/code&gt; or &lt;code&gt;F[_]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Generating mock data&lt;/h3&gt; &#xA;&lt;p&gt;You can combine generators defined using scalacheck or zio-test. [^2]&lt;/p&gt; &#xA;&lt;p&gt;[^2]: Even if your testing library is not supported, adding one is done easily. See &lt;code&gt;decrel.scalacheck.gen&lt;/code&gt; or &lt;code&gt;decrel.ziotest.gen&lt;/code&gt;. The implementation code should work for a different &lt;code&gt;Gen&lt;/code&gt; type with minimal changes.&lt;/p&gt; &#xA;&lt;p&gt;To express generating an author and a list of books by the author, you can write the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val authorAndBooks: Gen[(Author, Book)] =&#xA;  gen.author // This is your existing generator for Author&#xA;    .expand(Author.self &amp;amp; Author.books) // Give me the generated author,&#xA;                                        // additionally list of books for the author&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can simply use the composed generator in your test suite.&lt;/p&gt; &#xA;&lt;p&gt;The benefit of using decrel to compose generators is twofold:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;less boilerplate compared to specifying generators one-by-one (especially when options/lists are involved)&lt;/li&gt; &#xA; &lt;li&gt;values generated are more consistent compared to generating values independently &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;In this case, all books will have the &lt;code&gt;authorId&lt;/code&gt; fields set to the generated author.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Notice to all Scala 3 users&lt;/h2&gt; &#xA;&lt;p&gt;Any method that requires an implicit (given) instance of &lt;code&gt;Proof&lt;/code&gt; needs to be called against a &lt;code&gt;val&lt;/code&gt; value.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/yoohaemin/decrel/commit/8b836b5c41b58a77d791c36e8b81e4f6e979e297&#34;&gt;this commit&lt;/a&gt; for examples.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://github.com/ghostdogpr&#34;&gt;@ghostdogpr&lt;/a&gt; for critical piece of insight regarding the design of the api and the initial feedback.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://github.com/benrbray&#34;&gt;@benrbray&lt;/a&gt; for all the helpful discussions.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://github.com/benetis&#34;&gt;@benetis&lt;/a&gt; for pointing out there was a problem that needs fixing.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to all of my friends and colleagues who provided valuable initial feedback.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;decrel is copyright Haemin Yoo, and is licensed under Mozilla Public License v2.0&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;modules/core/src/main/scala/decrel/Zippable.scala&lt;/code&gt; is based on &lt;a href=&#34;https://github.com/zio/zio/raw/v2.0.2/core/shared/src/main/scala/zio/Zippable.scala&#34;&gt;https://github.com/zio/zio/blob/v2.0.2/core/shared/src/main/scala/zio/Zippable.scala&lt;/a&gt; , licensed under the Apache License v2.0&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>sequencer/vector</title>
    <updated>2023-03-04T01:44:56Z</updated>
    <id>tag:github.com,2023-03-04:/sequencer/vector</id>
    <link href="https://github.com/sequencer/vector" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Vector&lt;/h1&gt; &#xA;&lt;p&gt;This is a RISC-V Vector RTL generator, supporting Zvl1024b,Zve32x extension for now. More documentation will be released after the first release.&lt;/p&gt; &#xA;&lt;h2&gt;Nix setup&lt;/h2&gt; &#xA;&lt;p&gt;We use nix flake to setup test environment. If you have not installed nix, install it following the &lt;a href=&#34;https://nixos.org/manual/nix/stable/installation/installing-binary.html&#34;&gt;guide&lt;/a&gt;, and enable flake following the &lt;a href=&#34;https://nixos.wiki/wiki/Flakes#Enable_flakes&#34;&gt;wiki&lt;/a&gt;. For example:&lt;/p&gt; &#xA;&lt;p&gt;Install with package manager e.g. on ArchLinux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pacman -S nix&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or with installation script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sh &amp;lt;(curl -L https://nixos.org/nix/install)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add flake to configurations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &#34;experimental-features = nix-command flakes&#34; &amp;gt;&amp;gt; ~/.config/nix/nix.conf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enable nix-daemon systemd service (if your package manager has not enabled it automatically):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl start nix-daemon.service&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After nix is installed, run &lt;code&gt;nix develop&lt;/code&gt; to enter the development shell, all environment variables and dependencies is included. If you want a pure environment without system packages, use &lt;code&gt;env -i nix develop&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;h3&gt;Note on “I have no name” Problem&lt;/h3&gt; &#xA;&lt;p&gt;If you are using dynamic user, you may experience bash or other programs complaining about “I have no name” when entering nix shell. This is caused by that when &lt;code&gt;nscd&lt;/code&gt; started inside nix environments for &lt;code&gt;getent&lt;/code&gt; query, glibc will query &lt;code&gt;nsswtich&lt;/code&gt;, but nss modules from outside nix is not visible to nix, causing glibc failing to find the user.&lt;/p&gt; &#xA;&lt;p&gt;As a workaround, you can start &lt;code&gt;nscd&lt;/code&gt; or &lt;code&gt;nsncd&lt;/code&gt; outside nix environment, such as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl start nscd.service&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or use &lt;code&gt;nsncd&lt;/code&gt; in Arch Linux instead&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;paru -S nsncd-git&#xA;systemctl start nsncd.service&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Test&lt;/h2&gt; &#xA;&lt;p&gt;We use &lt;a href=&#34;https://github.com/riscv/riscv-isa-sim&#34;&gt;spike&lt;/a&gt; for reference model. In nix development shell, run with &lt;code&gt;mill -i &#39;tests.run[smoketest]&#39;&lt;/code&gt; for a single test. The simulator record events of vector register file and memory load store to perform online difftest. The simulator use spike to emulate the RISC-V core, which means this vector generator doesn&#39;t provide a hart implementation.&lt;/p&gt; &#xA;&lt;h2&gt;Patches&lt;/h2&gt; &#xA;&lt;!-- BEGIN-PATCH --&gt; &#xA;&lt;!-- END-PATCH --&gt;</summary>
  </entry>
</feed>