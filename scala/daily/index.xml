<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-21T01:43:42Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jchapuis/fs2-kafka-mock</title>
    <updated>2023-06-21T01:43:42Z</updated>
    <id>tag:github.com,2023-06-21:/jchapuis/fs2-kafka-mock</id>
    <link href="https://github.com/jchapuis/fs2-kafka-mock" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mocks for fs2-kafka consumers and producers&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;fs2-kafka-mock&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jchapuis/fs2-kafka-mock/actions/workflows/release.yml&#34;&gt;&lt;img src=&#34;https://github.com/jchapuis/fs2-kafka-mock/actions/workflows/release.yml/badge.svg?sanitize=true&#34; alt=&#34;Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/io.github.jchapuis/fs2-kafka-mock_2.13&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/io.github.jchapuis/fs2-kafka-mock_2.13/badge.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/jchapuis/fs2-kafka-mock&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/jchapuis/fs2-kafka-mock/branch/master/graph/badge.svg?token=BOAOIFC7BF&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://typelevel.org/cats/&#34;&gt;&lt;img src=&#34;https://typelevel.org/cats/img/cats-badge.svg?sanitize=true&#34; height=&#34;40px&#34; align=&#34;right&#34; alt=&#34;Cats friendly&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Mocks for fs2-kafka consumers and producers wrapping the native mocks built into the apache kafka clients library. This allows for testing applications without the need for a real kafka implementation such as testcontainers or embedded kafka.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Add the following dependency to your &lt;code&gt;build.sbt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;io.github.jchapuis&#34; %% &#34;fs2-kafka-mock&#34; % &#34;{latest version}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Mock consumer&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/jchapuis/fs2-kafka-mock/master/src/main/scala/io/github/jchapuis/fs2/kafka/mock/MockKafkaConsumer.scala&#34;&gt;mock consumer&lt;/a&gt; allows covering code making use of fs2-kafka&#39;s &lt;code&gt;KafkaConsumer&lt;/code&gt;. Injection of the mock is done via the implicit &lt;code&gt;MkConsumer&lt;/code&gt; parameter (that fs2-kafka had the foresight to allow). Methods on the mock allow for publishing and redacting messages, as if these were being published on the real kafka.&lt;/p&gt; &#xA;&lt;p&gt;Internally, the mock consumer tracks published records in an array. Note, however, that there are some limitations imposed by the native kafka mock:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;single partition support&lt;/li&gt; &#xA; &lt;li&gt;consumers must subscribe for publication to succeed&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;p&gt;Here&#39;s a short example taken from the project&#39;s munit test suite: we mock publication of a message, consume it using a fs2 kafka consumer configured with the mock and verify that the consumer was able to read the record.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;test(&#34;mock kafka consumer can read a published message&#34;) {&#xA;  MockKafkaConsumer(&#34;topic&#34;).use { mockConsumer =&amp;gt;&#xA;    for {&#xA;      _ &amp;lt;- mockConsumer&#xA;        .publish(&#34;topic&#34;, &#34;key&#34;, &#34;value&#34;)&#xA;        .start // this call semantically blocks until we can publish to the consumer&#xA;               // hence the need to run it in a separate fiber&#xA;      record &amp;lt;- {&#xA;        implicit val mkConsumer: MkConsumer[IO] = mockConsumer.mkConsumer&#xA;        KafkaConsumer&#xA;          .stream(&#xA;            ConsumerSettings[IO, String, String]&#xA;              .withGroupId(&#34;test&#34;)&#xA;          )&#xA;          .subscribeTo(&#34;topic&#34;)&#xA;          .records&#xA;          .map(_.record)&#xA;          .map(record =&amp;gt; (record.topic, record.key, record.value))&#xA;          .take(1)&#xA;          .compile&#xA;          .toList&#xA;          .map(_.head)&#xA;      }&#xA;    } yield assertEquals(record, (&#34;topic&#34;, &#34;key&#34;, &#34;value&#34;))&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Mock producer&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/jchapuis/fs2-kafka-mock/master/src/main/scala/io/github/jchapuis/fs2/kafka/mock/MockKafkaProducer.scala&#34;&gt;mock producer&lt;/a&gt; allows covering code producing with fs2-kafka&#39;s &lt;code&gt;KafkaProducer&lt;/code&gt;. Injection of the mock is done via the implicit &lt;code&gt;MkProducer&lt;/code&gt; parameter, in a similar way as for the consumer. Various access methods on the mock allow for retrieving published records and iteratively checking for newer messages.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;test(&#34;mock kafka producer returns next message and allows for checking full history&#34;) {&#xA;  MockKafkaProducer()&#xA;  .flatMap { mock =&amp;gt;&#xA;    implicit val mkProducer: MkProducer[IO] = mock.mkProducer&#xA;    val producer = KafkaProducer.resource(ProducerSettings[IO, String, String])&#xA;    producer.map((mock, _))&#xA;  }&#xA;  .use { case (mock, producer) =&amp;gt;&#xA;    for {&#xA;      _ &amp;lt;- producer.produce(ProducerRecords.one(ProducerRecord[String, String](&#34;topic&#34;, &#34;key&#34;, &#34;value&#34;))).flatten&#xA;      _ &amp;lt;- mock&#xA;        .nextMessageFor[String, String](&#34;topic&#34;)&#xA;        .map(maybeKeyValue =&amp;gt; assertEquals(maybeKeyValue, Some((&#34;key&#34;, &#34;value&#34;))))&#xA;      _ &amp;lt;- mock&#xA;        .historyFor[String, String](&#34;topic&#34;)&#xA;        .map(history =&amp;gt; assertEquals(history, List((&#34;key&#34;, &#34;value&#34;))))&#xA;    } yield ()&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>maproulette/maproulette-backend</title>
    <updated>2023-06-21T01:43:42Z</updated>
    <id>tag:github.com,2023-06-21:/maproulette/maproulette-backend</id>
    <link href="https://github.com/maproulette/maproulette-backend" rel="alternate"></link>
    <summary type="html">&lt;p&gt;MapRoulette back-end / API&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MapRoulette API&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/maproulette/maproulette2&#34;&gt;&lt;img src=&#34;https://travis-ci.org/maproulette/maproulette2.svg?branch=dev&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/dashboard?id=maproulette_maproulette2&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=maproulette_maproulette2&amp;amp;metric=alert_status&#34; alt=&#34;Quality Gate Status&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/maproulette/maproulette-backend&#34; alt=&#34;GitHub release (latest by date)&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Welcome to the repository for the MapRoulette back-end server code. The MapRoulette back-end exposes the MapRoulette API, which the MapRoulette front-end web application depends on. The source code for the web application is in &lt;a href=&#34;https://github.com/maproulette/maproulette3&#34;&gt;a separate repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;If you just want to deploy the MapRoulette back-end, &lt;a href=&#34;https://github.com/maproulette/maproulette2-docker&#34;&gt;we have a ðŸš¢ Docker image ðŸš¢ for that&lt;/a&gt;&lt;/strong&gt;. This is especially useful if you want to contribute to the MapRoulette front-end and don&#39;t intend to touch the back-end.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;MapRoulette depends on several technologies for building and running the project:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Java 11 JDK&lt;/li&gt; &#xA; &lt;li&gt;PostgreSQL with PostGIS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.scala-sbt.org/download.html&#34;&gt;Scala Build Tool&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;MapRoulette is a complex tool and depends on several other tools (&lt;a href=&#34;https://www.mapillary.com/&#34;&gt;Mapillary&lt;/a&gt;, &lt;a href=&#34;https://overpass-api.de/&#34;&gt;Overpass API&lt;/a&gt;, &lt;a href=&#34;https://www.openstreetmap.org/&#34;&gt;OpenStreetMap&lt;/a&gt;, PostgreSQL, and others) that need to be correctly configured within the application&#39;s &lt;a href=&#34;https://github.com/lightbend/config/raw/main/HOCON.md&#34;&gt;HOCON configuration&lt;/a&gt; files.&lt;/p&gt; &#xA;&lt;p&gt;The initial setup is not trivial, so the documentation is split to specific steps where each step can be easily validated. The validation at each step is a helpful sanity check so please, regardless of your experience, &lt;strong&gt;take the time to verify along the way&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 1: Installing Tools&lt;/h3&gt; &#xA;&lt;p&gt;To get started you&#39;ll need to install Docker, JDK 11, and sbt.&lt;/p&gt; &#xA;&lt;h4&gt;Docker&lt;/h4&gt; &#xA;&lt;p&gt;Docker is a virtualization tool and feel free to use &lt;a href=&#34;https://docs.docker.com/get-docker/&#34;&gt;Docker Desktop&lt;/a&gt;, or &lt;a href=&#34;https://podman.io/&#34;&gt;Podman&lt;/a&gt;, or even &lt;a href=&#34;https://rancherdesktop.io/&#34;&gt;Rancher Desktop&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;JDK 11 and sbt&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sdkman.io/install&#34;&gt;sdkman&lt;/a&gt; is a great tool to install a specific build of the JDK to keep your environment as similar to production as possible. It also handles fetching x8664 and aarch64 builds automatically. Follow the installation steps and install the JDK and sbt using a command similar to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;sdk install java 11.0.17-tem&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sdk install sbt 1.8.2&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Validation&lt;/h4&gt; &#xA;&lt;p&gt;Within a terminal check that docker, javac, and sbt are working.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;docker run hello-world&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Verify docker works&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;javac -version&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Verify javac is JDK 11&lt;/li&gt; &#xA;   &lt;li&gt;Apple Silicon: Verify that the JDK is an aarch64 build and not x8664.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt -version&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 2: Setup PostGIS and MapRoulette DB Configuration&lt;/h3&gt; &#xA;&lt;h4&gt;PostGIS Container&lt;/h4&gt; &#xA;&lt;p&gt;MapRoulette development assumes a database is running on the local system within a docker container.&lt;/p&gt; &#xA;&lt;p&gt;Below is a sample command to run a PostGIS database within a container and sets necessary ports/credentials.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;NOTE: Apple Silicon:&lt;/strong&gt; Use &lt;code&gt;ghcr.io/baosystems/postgis:13-3.3&lt;/code&gt; docker image since postGIS does not yet publish aarch64 images.&lt;/li&gt; &#xA; &lt;li&gt;NOTE: No volume mount is used so the database&#39;s data will be deleted when the container is deleted. If you&#39;d like to keep the data external of the container, be sure to add &lt;code&gt;--volume &#34;/some/path/here/postgres-data&#34;:/var/lib/postgresql/data&lt;/code&gt; to the docker call.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run \&#xA;    -d \&#xA;    -p 5432:5432 \&#xA;    --name maproulette-postgis \&#xA;    --restart unless-stopped \&#xA;    --shm-size=512MB \&#xA;    -e POSTGRES_DB=maproulette-db \&#xA;    -e POSTGRES_USER=maproulette-db-user \&#xA;    -e POSTGRES_PASSWORD=maproulette-db-pass \&#xA;    postgis/postgis:13-3.3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NOTE: If there&#39;s a port conflict, you probably have another pg instance running. Check with &lt;code&gt;docker ps&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;NOTE: It is helpful to see logs with &lt;code&gt;docker logs -f maproulette-postgis&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;NOTE: To stop the container, that&#39;d be &lt;code&gt;docker stop maproulette-postgis&lt;/code&gt;. Then you can start it again using &lt;code&gt;docker start maproulette-postgis&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;MapRoulette Database Configuration&lt;/h4&gt; &#xA;&lt;p&gt;Clone the maproulette-backend repository and &lt;code&gt;cd&lt;/code&gt; to that directory, and create &lt;code&gt;conf/dev.conf&lt;/code&gt; using the example file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;    cp conf/dev.conf.example conf/dev.conf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Edit &lt;code&gt;conf/dev.conf&lt;/code&gt; and set db.default based on the previous step&#39;s POSTGRES_DB, POSTGRES_USER, and POSTGRES_PASSWORD values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;db.default {&#xA;  url=&#34;jdbc:postgresql://localhost:5432/maproulette-db&#34;&#xA;  username=&#34;maproulette-db-user&#34;&#xA;  password=&#34;maproulette-db-pass&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now start the MapRoulette server! Run this command in a terminal, &lt;strong&gt;not within Intellij/vscode&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sbt -J-Xms4G -J-Xmx4G -J-Dconfig.file=./conf/dev.conf -J-Dlogger.resource=logback-dev.xml run&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;There should be some output that looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--- (Running the application, auto-reloading is enabled) ---&#xA;[info] p.c.s.AkkaHttpServer - Listening for HTTP on /0:0:0:0:0:0:0:0:9000&#xA;(Server started, use Enter to stop and go back to the console...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s the expected output. And when you need, like it says, use Enter to stop the server.&lt;/p&gt; &#xA;&lt;h4&gt;Step 2 - Validation&lt;/h4&gt; &#xA;&lt;p&gt;Open a new terminal so that the MapRoulette server is not stopped. Verify:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Check that the database is running, &lt;code&gt;docker inspect -f &#39;{{.State.Running}}&#39; maproulette-postgis&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Start the MapRoulette server if it&#39;s not already running (see the previous section for the &lt;code&gt;sbt&lt;/code&gt; command)&lt;/li&gt; &#xA; &lt;li&gt;Verify that the local &lt;a href=&#34;http://127.0.0.1:9000/docs/&#34;&gt;Swagger docs load in a web browser&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Do this GET call to get the list of challenges: &lt;code&gt;curl http://127.0.0.1:9000/api/v2/challenges&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The result may be an empty array or some data, as long as it&#39;s not a failed call&lt;/li&gt; &#xA;   &lt;li&gt;Tip: the response can be formatted by piping to &lt;code&gt;jq&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Open the terminal that has &lt;code&gt;sbt&lt;/code&gt; running the server. Verify that there are log messages printed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If there&#39;s a failure at this point &lt;em&gt;READ THE LOG MESSAGES&lt;/em&gt;, checking for simple setup issues.&lt;/p&gt; &#xA;&lt;p&gt;A few known setup misconfigurations could be:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Does the server log that it can&#39;t communicate with the database? &#34;HikariPool Connection is not available, request timed out after 30000ms&#34; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Check the &lt;code&gt;conf/dev.conf&lt;/code&gt; MapRoulette server configuration file for typos, accidental setting overrides, etc&lt;/li&gt; &#xA;   &lt;li&gt;Check that the MapRoulette server conf and postgis are using the same database, user, password.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Recursive loading of Guice injected object: &#39;java.lang.IllegalStateException: Recursive load of: org.maproulette.framework.service.ServiceManager.&#xA;  &lt;init&gt;&#xA;   ()&#39; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;We&#39;ve seen this with Apple Silicon aarch64 systems. Possibly related to mixing aarch64 and x8664 JDKs. Intellij 2022.3 pre-release seems to work fine&lt;/li&gt; &#xA;   &lt;/ul&gt; &#xA;  &lt;/init&gt;&lt;/li&gt; &#xA; &lt;li&gt;Having some other issue? &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Please file a GitHub issue with a detailed description on what was tried and include the error message.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 3: Setup OAuth Login and Run the front-end GUI&lt;/h3&gt; &#xA;&lt;p&gt;With the database and MapRoulette server working together, it&#39;s now time to get the front-end login workflow working!&lt;/p&gt; &#xA;&lt;p&gt;High level the user visits to MapRoulette, clicks &#39;login&#39; and is sent to OpenStreepMap to login then, after authentication, MapRoulette is able to make OSM changes of behalf of the user. This is done by registering the local dev instance of MapRoulette as an OSM OAuth Application to create keys, and then the those keys are pasted into the MapRoulette server configuration. More details on how OSM uses OAuth is on the &lt;a href=&#34;https://wiki.openstreetmap.org/wiki/OAuth&#34;&gt;OpenStreetMap OAuth documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Register localhost as an OpenStreetMap OAuth Application&lt;/h4&gt; &#xA;&lt;p&gt;Within OpenStreetMap, MapRoulette needs to be setup as an &#34;OAuth Application&#34; so that changes in MapRoulette are associated with a user&#39;s OSM account.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Login to the &lt;a href=&#34;https://master.apis.dev.openstreetmap.org&#34;&gt;development OpenStreetMap server&lt;/a&gt; (make an account if needed)&lt;/li&gt; &#xA; &lt;li&gt;In the top right, click the user and go to &lt;code&gt;My Settings&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Then click &lt;code&gt;OAuth 1 settings&lt;/code&gt; tab&lt;/li&gt; &#xA; &lt;li&gt;At the bottom of the OAuth 1 settings page, click &lt;code&gt;Register your application&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Register using these settings: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;Name&lt;/code&gt;: maprouletteDevLocalhost (any name is fine)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Main Application URL&lt;/code&gt;: &lt;a href=&#34;http://127.0.0.1:9000&#34;&gt;http://127.0.0.1:9000&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Callback URL&lt;/code&gt;: &lt;a href=&#34;http://127.0.0.1:9000&#34;&gt;http://127.0.0.1:9000&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Support URL&lt;/code&gt;: empty string is fine&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Request the following permissions from the user&lt;/code&gt;: Select &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;read their user preferences&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;modify their user preferences&lt;/code&gt; (MapRoulette saves the user&#39;s MR API key in OSM)&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;modify the map&lt;/code&gt; (MapRoulette tasks edit the map)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Click &lt;code&gt;Register&lt;/code&gt; and note the displayed Consumer Key and the Consumer Secret. Copy and paste those keys into the MapRoulette &lt;code&gt;conf/dev.conf&lt;/code&gt; file&#39;s osm section where it has &#34;CHANGE_ME&#34;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;osm {&#xA;  consumerKey=&#34;CHANGE_ME&#34;&#xA;  consumerSecret=&#34;CHANGE_ME&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Stop and start the MapRoulette server to load the updated configuration.&lt;/p&gt; &#xA;&lt;h4&gt;Run the MapRoulette front-end&lt;/h4&gt; &#xA;&lt;p&gt;Clone the maproulette3 repository and follow the steps in the &lt;a href=&#34;https://github.com/maproulette/maproulette3/raw/develop/DEVELOPMENT.md#run-the-ui-from-docker&#34;&gt;DEVELOPMENT.md &#34;Run the UI from Docker&#34; section&lt;/a&gt;. Be sure to execute the &lt;code&gt;docker run&lt;/code&gt; step that starts the UI.&lt;/p&gt; &#xA;&lt;h4&gt;Step 3 - Validation&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open &lt;a href=&#34;http://localhost:3000/&#34;&gt;http://localhost:3000/&lt;/a&gt; and attempt to log in &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This should redirect to the development OpenStreetMap server and redirect back to MapRoulette&lt;/li&gt; &#xA;   &lt;li&gt;The username should show in the top-right corner&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Create a new Project (this is the easiest way to verify), or a new challenge, or update a project/challenge/task, or do some other work that causes various request types to the MapRoulette server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Known setup issues:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Exceptions with &#39;java.lang.NumberFormatException: For input string: &#34;CHANGE_ME&#34;&#39;. Edit the &lt;code&gt;conf/dev.conf&lt;/code&gt; and verify that these are not &#34;CHANGE_ME&#34;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;osm.consumerKey&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;osm.consumerSecret&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;maproulette.super.key&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;maproulette.super.accounts&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Step 4: Intelllij Configuration&lt;/h3&gt; &#xA;&lt;p&gt;The server is working end-to-end on command line! Time to import into IntelliJ. Stop the running MapRoulette server from the previous step, if it&#39;s still running.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open IntelliJ&lt;/li&gt; &#xA; &lt;li&gt;Click &lt;code&gt;Plugins&lt;/code&gt; and verify that the Scala plugin is installed&lt;/li&gt; &#xA; &lt;li&gt;Click &lt;code&gt;Open&lt;/code&gt; and navigate to the MapRoulette source directory and &lt;code&gt;Open as Project&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The project will load&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Create a new &lt;code&gt;sbt Task&lt;/code&gt; runtime configuration &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Name it &lt;code&gt;MapRoulette Server&lt;/code&gt; or similar&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Set Tasks to &lt;code&gt;run&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Uncheck &#39;Use sbt shell`&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Use these &lt;code&gt;VM parameters&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;-Xms4G&#xA;-Xmx4G&#xA;-Dconfig.file=./conf/dev.conf&#xA;-Dlogger.resource=logback-dev.xml&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Step 4 - Validation&lt;/h4&gt; &#xA;&lt;p&gt;Open the front-end UI &lt;a href=&#34;http://localhost:3000/&#34;&gt;http://localhost:3000/&lt;/a&gt; and attempt to log in. It should function.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Additional (Optional) Server Configuration&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open &lt;code&gt;dev.conf&lt;/code&gt; in a text editor and change at least the following entries: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;super.key&lt;/code&gt;: a randomly chosen API key for superuser access&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;super.accounts&lt;/code&gt;: a comma-separated list of OSM accound IDs whose corresponding MapRoulette users will have superuser access. Can be an empty string.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;mapillary.clientId&lt;/code&gt;: a &lt;a href=&#34;https://www.mapillary.com/dashboard/developers&#34;&gt;Mapillary Client ID&lt;/a&gt;, needed if you want to use any of the Mapillary integrations.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;h3&gt;Logging Levels&lt;/h3&gt; &#xA;&lt;p&gt;During development, please set &lt;code&gt;-Dlogger.resource=logback-dev.xml&lt;/code&gt; to have the best experience. The logback dev file sets many items to the devel level and logs all HTTP request paths and response times.&lt;/p&gt; &#xA;&lt;p&gt;Any changes to the &lt;code&gt;conf/logback-dev.xml&lt;/code&gt; will be loaded within about 5 seconds and a service restart is not needed.&lt;/p&gt; &#xA;&lt;p&gt;To have all request &lt;em&gt;headers&lt;/em&gt; sent by the client logged, update the &lt;code&gt;conf/logback-dev.xml&lt;/code&gt; &#34;org.maproulette.filters&#34; entry to TRACE.&lt;/p&gt; &#xA;&lt;h3&gt;Deploying on Windows&lt;/h3&gt; &#xA;&lt;p&gt;Windows is not officially supported. However, there is an unofficial &lt;a href=&#34;https://gist.github.com/3710d7f15534ec747423a3117cd7cc9c&#34;&gt;setup guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;SMTP (email) configuration&lt;/h3&gt; &#xA;&lt;p&gt;MapRoulette now supports transmission of emails, for example to inform users when they receive new in-app notifications. You will need access to an SMTP server to send emails, and will also need to add SMTP configuration settings to your configuration file (or whatever configuration mechanism you&#39;re using). &lt;code&gt;play.mailer.host&lt;/code&gt; is the only required SMTP setting, but most SMTP servers will also want a username and password.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;play.mailer.host = &#34;smtp.server.com&#34;&#xA;play.mailer.user = &#34;smtpusername&#34;&#xA;play.mailer.password = &#34;secret&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Many additional SMTP configuration options are available -- see &lt;a href=&#34;https://github.com/playframework/play-mailer/raw/master/README.md&#34;&gt;play-mailer&lt;/a&gt; for a full list.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: If you&#39;re doing development, you can set &lt;code&gt;play.mailer.mock = yes&lt;/code&gt; to simply log emails instead of transmitting them&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;It&#39;s also important that you set the &lt;code&gt;emailFrom&lt;/code&gt; setting to the email address you wish emails to come from, and that you ensure &lt;code&gt;publicOrigin&lt;/code&gt; is set so that links in emails will properly point to your server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;emailFrom = &#34;maproulette@yourserver.com&#34;&#xA;publicOrigin = &#34;https://www.yourserver.com&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, notification emails that are to be sent immediately are processed by a background job every 1 minute. Both the frequency and max number of emails to process in a single run can be controlled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;notifications.immediateEmail.interval = &#34;1 minute&#34;&#xA;notifications.immediateEmail.batchSize = 10         # max emails per run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notification emails that are to be sent as a digest are initially processed at 8pm local server time by default, and then every 24 hours thereafter (i.e. daily digests). Both of these settings can be customized. There is not currently a maximum limit to the number of emails for digest emails.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;notifications.digestEmail.startTime = &#34;20:00:00&#34;    # 8pm local server time&#xA;notifications.digestEmail.interval = &#34;24 hours&#34;     # once daily&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Creating new Challenges&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/maproulette/maproulette-backend/wiki&#34;&gt;The wiki for this repo&lt;/a&gt; has some information on creating challenges.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/maproulette/maproulette-backend/dev/docs/challenge_api.md&#34;&gt;Challenge API&lt;/a&gt; has further information about creating challenges through the API.&lt;/p&gt; &#xA;&lt;p&gt;See also the Swagger API documentation. You can view the documentation by going to the URL &lt;code&gt;/docs/swagger-ui/index.html&lt;/code&gt; on any MapRoulette instance.&lt;/p&gt; &#xA;&lt;h2&gt;Dev Docs&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/maproulette/maproulette-backend/dev/docs/challenge_api.md&#34;&gt;Creating Challenges&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/maproulette/maproulette-backend/dev/docs/deployment.md&#34;&gt;Deployment&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/maproulette/maproulette-backend/dev/docs/github_example.md&#34;&gt;Github Example&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/maproulette/maproulette-backend/dev/docs/graphql.md&#34;&gt;GraphQL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/maproulette/maproulette-backend/dev/docs/tag_changes.md&#34;&gt;Tag Changes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/maproulette/maproulette-backend/dev/docs/testing.md&#34;&gt;Testing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/maproulette/maproulette-backend/dev/conf/v2_route/readme.md&#34;&gt;Routes&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Please fork the project and submit a pull request. See &lt;a href=&#34;https://raw.githubusercontent.com/maproulette/maproulette-backend/dev/postman/README.md&#34;&gt;Postman Docs&lt;/a&gt; for information on API Testing. The project is integrated with Travis-CI, so PR&#39;s will only be accepted once the build compiles successfully. MapRoulette also uses Scalafmt as it&#39;s code formatter. This is too keep the code style consistent across all developers. The check will be run first in Travis for the build, so if there are any code style issues it will fail the build immediately. IntelliJ should pick up the formatter and use Scalafmt automatically, however you can also use &lt;code&gt;sbt scalafmt&lt;/code&gt; to format any and all code for you.&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;Bug and feature requests are best left as an issue right here on Github. For other things, contact &lt;a href=&#34;mailto:maproulette@maproulette.org&#34;&gt;maproulette@maproulette.org&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;MapRoulette now also has a channel #maproulette on the &lt;a href=&#34;http://osmus.slack.com&#34;&gt;OSM US Slack community&lt;/a&gt;. Invite yourself &lt;a href=&#34;https://osmus-slack.herokuapp.com/&#34;&gt;here&lt;/a&gt;!&lt;/p&gt;</summary>
  </entry>
</feed>