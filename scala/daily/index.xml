<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-22T01:45:35Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>softwaremill/saft</title>
    <updated>2022-08-22T01:45:35Z</updated>
    <id>tag:github.com,2022-08-22:/softwaremill/saft</id>
    <link href="https://github.com/softwaremill/saft" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Saft: a Scala Raft implementation&lt;/h1&gt; &#xA;&lt;p&gt;An implementation of the &lt;a href=&#34;https://raft.github.io&#34;&gt;Raft&lt;/a&gt; consensus algorithm, using the &lt;a href=&#34;https://scala-lang.org&#34;&gt;Scala&lt;/a&gt; language and a functional effect system (&lt;a href=&#34;https://zio.dev&#34;&gt;zio&lt;/a&gt;). Currently, the goal of this project is educational, not production usage.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re new to Scala, you might want to setup your environment first, installing Java and an IDE. &lt;a href=&#34;https://scala.page&#34;&gt;This page&lt;/a&gt; might be helpful.&lt;/p&gt; &#xA;&lt;h2&gt;Running a Raft simulation&lt;/h2&gt; &#xA;&lt;p&gt;To run the provided in-memory Raft simulation, using 5 nodes, use the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sbt &#34;zio/runMain saft.SaftSim&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll need to have &lt;a href=&#34;https://www.scala-sbt.org&#34;&gt;sbt&lt;/a&gt; installed.&lt;/p&gt; &#xA;&lt;h2&gt;How to read the code&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;zio&lt;/code&gt; module contains a number of files which implement the Raft algorithm, along with an in-memory runnable simulation, an HTTP+json-based app and some tests.&lt;/p&gt; &#xA;&lt;p&gt;Before getting to know the implementation, it&#39;s best to at least skim the &lt;a href=&#34;https://raft.github.io/raft.pdf&#34;&gt;Raft paper&lt;/a&gt;. There&#39;s a one-page summary of the algorithm on page 4.&lt;/p&gt; &#xA;&lt;p&gt;Reading the files in the following order might be easiest:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;start with &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/domain.scala&#34;&gt;&lt;code&gt;domain.scala&lt;/code&gt;&lt;/a&gt;, which defines some basic data types. We&#39;ve got a representation of a &lt;code&gt;NodeId&lt;/code&gt;, which simply wraps a number. These ids are then used to identify and communicate between nodes. There are also some opaque types (newtypes), which at runtime are erased to their base representation, however at compile-time are distinct (here we&#39;re creating artificial subtypes of &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt;). This includes &lt;code&gt;Term&lt;/code&gt;, which counts the Raft terms, log indexes and log data. Finally, there are data structures which represent the content of the logs, such as &lt;code&gt;LogEntry&lt;/code&gt;, which combines data in the log with the term in which the entry was added (as described in the Raft paper).&lt;/li&gt; &#xA; &lt;li&gt;these basic types are used to create representations of server state in &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/state.scala&#34;&gt;&lt;code&gt;state.scala&lt;/code&gt;&lt;/a&gt;. This file contains classes such as &lt;code&gt;ServerState&lt;/code&gt;, &lt;code&gt;LeaderState&lt;/code&gt; etc., which correspond directly to the state that each server should store as described in the Raft paper. If there&#39;s anything extra, it is clearly commented with justification. The state classes contain methods which either update the state with new data (such as appending a new entry), check conditions (such as checking if a log entry can be applied given the current state), or compute views of the data (such as computing the commit index). These functions are always pure, that is side-effect-free, and in case of updates, return a new immutable representation of the state.&lt;/li&gt; &#xA; &lt;li&gt;then, take a look at &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/messages.scala&#34;&gt;&lt;code&gt;messages.scala&lt;/code&gt;&lt;/a&gt;. There, you can find the messages that are defined in the Raft protocol, such as &lt;code&gt;RequestVote&lt;/code&gt; or &lt;code&gt;AppendEntries&lt;/code&gt;, along with classes representing responses to these requests. The messages are classified basing on whether a client or a sever is the sender/recipient, and if the message is a request or response. These classification traits (&lt;code&gt;ToServerMessage&lt;/code&gt;, &lt;code&gt;ResponseMessage&lt;/code&gt; etc.) are then used to ensure that a message can only be used in appropriate context.&lt;/li&gt; &#xA; &lt;li&gt;the implementation is event-driven, that is appropriate logic is run in response to events being placed on a queue. The events are defined in &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/ServerEvent.scala&#34;&gt;&lt;code&gt;ServerEvent&lt;/code&gt;&lt;/a&gt;, and the queues are abstracted using the &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/Comms.scala&#34;&gt;&lt;code&gt;Comms&lt;/code&gt;&lt;/a&gt; interface. The events are pretty straightforward, representing the possibility that a node can either receive a timeout (for example an election timeout, if there was no communication from the leader for the specified amount of time), or a request/response.&lt;/li&gt; &#xA; &lt;li&gt;finally, with these prerequisites, it should be enough to study the &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/Node.scala&#34;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt; implementation itself. That&#39;s where the main logic of the Raft algorithm is implemented. The code is commented using excerpts from Raft &#34;cheat-sheet&#34;, the one-page summary from the &lt;a href=&#34;https://raft.github.io/raft.pdf&#34;&gt;Raft paper, page 4&lt;/a&gt;. The implementation of a node reads events from the queue in a loop, first matching on the event type (timeout / request received / response received), and then matching on the current role of the node (follower / candidate / leader). Each handler follows roughly the same steps: first the state is changed, yielding a new state instance (e.g. &lt;code&gt;ServerState&lt;/code&gt; or &lt;code&gt;LeaderState&lt;/code&gt;). Then, side-effects are run, such as restarting the timer, or sending out messages to other nodes (requesting votes or appending entries). After a handler completes, the state is persisted and the response is sent back, if any.&lt;/li&gt; &#xA; &lt;li&gt;to see the implementation in action, it&#39;s easiest to run the &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/SaftSim.scala&#34;&gt;&lt;code&gt;SaftSim&lt;/code&gt;&lt;/a&gt; app, which runs a number of nodes in-memory, using in-memory communication and in-memory persistence. Using the provided console interface new entries can be added, nodes can be interrupted and started again. Alternatively, you can start an http+json-based version, using &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/SaftHttp.scala&#34;&gt;&lt;code&gt;SaftHttp&lt;/code&gt;&lt;/a&gt;. This will require starting the three nodes separately, though.&lt;/li&gt; &#xA; &lt;li&gt;there are three files which we haven&#39;t yet discussed, though they should be self-explanatory. &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/Conf.scala&#34;&gt;&lt;code&gt;Conf&lt;/code&gt;&lt;/a&gt; groups configuration values such as the number of nodes and timeouts. The &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/Persistence.scala&#34;&gt;&lt;code&gt;Persistence&lt;/code&gt;&lt;/a&gt; interface is used to save the part of &lt;code&gt;ServerState&lt;/code&gt; that should be persistent. Finally, &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/main/scala/saft/StateMachine.scala&#34;&gt;&lt;code&gt;StateMachine&lt;/code&gt;&lt;/a&gt; is where replicated, committed log entries are applied. A simple implementation applying the given function in the background (so that applying a log entry doesn&#39;t block the node itself) is provided.&lt;/li&gt; &#xA; &lt;li&gt;the &lt;a href=&#34;https://github.com/softwaremill/saft/raw/master/zio/src/test/scala/saft/NodeTest.scala&#34;&gt;test code&lt;/a&gt; might also be interesting, as it uses an manually-managed clock, allowing running time-based tests in a faster and predictable way, eliminating possible flakiness&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Vocabulary&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;node&lt;/code&gt; - one server running the Raft protocol&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;message&lt;/code&gt; - sent between server nodes, or between a client and a server. Includes the messages defined by the Raft protocol: &lt;code&gt;RequestVote&lt;/code&gt;, &lt;code&gt;AppendEntries&lt;/code&gt;, &lt;code&gt;NewEntry&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;event&lt;/code&gt; - processed by nodes sequentially, mediated by an event queue. Events include outside communication (receiving a &lt;code&gt;message&lt;/code&gt; as a request or response), or a timeout (e.g. election timeout)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;state&lt;/code&gt; - the persistent and volatile data associated with each node &lt;code&gt;role&lt;/code&gt;, as defined in the Raft paper, along with some implementation-specific elements. Includes for example the log itself (of which entries are being replicated), the commit index, or the known leader id.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;role&lt;/code&gt; - follower, candidate or leader; determines the logic that a particular node runs in response to incoming &lt;code&gt;event&lt;/code&gt;s.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;state machine&lt;/code&gt; - where the replicated and committed log entries are applied; the ultimate destination of all log entries&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>jaszczur/ScalaXmlProcessing</title>
    <updated>2022-08-22T01:45:35Z</updated>
    <id>tag:github.com,2022-08-22:/jaszczur/ScalaXmlProcessing</id>
    <link href="https://github.com/jaszczur/ScalaXmlProcessing" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Trying XML parsing in Scala&lt;/p&gt;&lt;hr&gt;&lt;h3&gt;Running&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;sbt run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Sample output&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;Responses for PLMN/RNC-1&#xA;  Response(Undefined,0,Just started)&#xA;  Response(Ongoing,69,Still going)&#xA;  Response(Successfull,100,Everything&#39;s fine)&#xA;end&#xA;Responses for PLMN/RNC-2&#xA;  Response(Failed,100,)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>