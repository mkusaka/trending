<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-24T01:56:00Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>olxbr/scala-utils</title>
    <updated>2022-06-24T01:56:00Z</updated>
    <id>tag:github.com,2022-06-24:/olxbr/scala-utils</id>
    <link href="https://github.com/olxbr/scala-utils" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Utility code for Scala: logging, testing, configuration and more&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;scala-utils&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/grupozap/scala-utils&#34;&gt;&lt;img src=&#34;https://travis-ci.org/grupozap/scala-utils.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;scala-utils&lt;/code&gt; is an utility library that attempts to add useful code rapidly in your development pipeline, so that you can focus on what is really needed. It does not replace any existing library, instead it allows you to add production-ready features.&lt;/p&gt; &#xA;&lt;p&gt;Code quality: &lt;a href=&#34;https://sonarcloud.io/project/overview?id=olxbr_scala-utils&#34;&gt;Sonar&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Logging&lt;/strong&gt;: Add features such as a configurable GELF log formatter without the need of a full Graylog connector library (&lt;a href=&#34;https://github.com/grupozap/scala-utils/tree/master/src/main/scala/com/grupozap/scalautils/logging&#34;&gt;https://github.com/grupozap/scala-utils/tree/master/src/main/scala/com/grupozap/scalautils/logging&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Use it in your project&lt;/h2&gt; &#xA;&lt;h3&gt;SBT&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;libraryDependencies += &#34;br.com.gzvr&#34; %% &#34;scala-utils&#34; % &#34;1.1.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll need to add our JFrog repository:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;resolvers += &#34;Artifactory&#34; at &#34;https://squadzapquality.jfrog.io/artifactory/olxbr-sbt-release/&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supported Scala versions: &lt;code&gt;2.11&lt;/code&gt; and &lt;code&gt;2.12&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Renato Silva (&lt;a href=&#34;https://github.com/resilva87&#34;&gt;https://github.com/resilva87&lt;/a&gt;) - maintainer&lt;/li&gt; &#xA; &lt;li&gt;Thiago Pereira (&lt;a href=&#34;https://github.com/thiagoandrade6&#34;&gt;https://github.com/thiagoandrade6&lt;/a&gt;) - maintainer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you found a bug in the source code or if you want to contribute with new features, you can help submitting an issue; even better if you can submit a pull request :)&lt;/p&gt; &#xA;&lt;h3&gt;Publish&lt;/h3&gt; &#xA;&lt;p&gt;Once you merge your code to the master branch, &lt;a href=&#34;https://github.com/olxbr/scala-utils/actions&#34;&gt;GitHub Actions&lt;/a&gt; should automatically publish it.&lt;/p&gt; &#xA;&lt;p&gt;To publish manually, create a &lt;code&gt;credentials.properties&lt;/code&gt; file in the project&#39;s directory, with &lt;a href=&#34;https://vault.grupozap.io/ui/vault/secrets/squad-quality/show/servicos/jfrog-quality&#34;&gt;the content you can find here&lt;/a&gt;, and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sbt clean compile package publish&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>digital-asset/daml</title>
    <updated>2022-06-24T01:56:00Z</updated>
    <id>tag:github.com,2022-06-24:/digital-asset/daml</id>
    <link href="https://github.com/digital-asset/daml" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Daml smart contract language&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://www.digitalasset.com/developers&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/digital-asset/daml/main/daml-logo.png&#34; alt=&#34;Daml logo&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.daml.com/getting-started/installation.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/digital-asset/daml.svg?label=Download&#34; alt=&#34;Download&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/digital-asset/daml/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache%202.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dev.azure.com/digitalasset/daml/_build/latest?definitionId=4&amp;amp;branchName=main&#34;&gt;&lt;img src=&#34;https://dev.azure.com/digitalasset/daml/_apis/build/status/digital-asset.daml?branchName=main&amp;amp;label=Build&#34; alt=&#34;Build&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All Rights Reserved. SPDX-License-Identifier: Apache-2.0&lt;/p&gt; &#xA;&lt;h1&gt;Welcome to the Daml repository!&lt;/h1&gt; &#xA;&lt;p&gt;This repository hosts all code for the &lt;a href=&#34;https://www.digitalasset.com/developers&#34;&gt;Daml smart contract language and SDK&lt;/a&gt;, originally created by &lt;a href=&#34;https://www.digitalasset.com&#34;&gt;Digital Asset&lt;/a&gt;. Daml is an open-source smart contract language for building future-proof distributed applications on a safe, privacy-aware runtime. The SDK is a set of tools to help you develop applications based on Daml.&lt;/p&gt; &#xA;&lt;h2&gt;Using Daml&lt;/h2&gt; &#xA;&lt;p&gt;To download Daml, follow &lt;a href=&#34;https://docs.daml.com/getting-started/installation.html&#34;&gt;the installation instructions&lt;/a&gt;. Once installed, to try it out, follow the &lt;a href=&#34;https://docs.daml.com/getting-started/quickstart.html&#34;&gt;quickstart guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have questions about how to use Daml or how to build Daml-based solutions, please join us on the &lt;a href=&#34;https://discuss.daml.com&#34;&gt;Daml forum&lt;/a&gt;. Alternatively, if you prefer asking on StackOverflow, please use &lt;a href=&#34;https://stackoverflow.com/tags/daml&#34;&gt;the &lt;code&gt;daml&lt;/code&gt; tag&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing to Daml&lt;/h2&gt; &#xA;&lt;p&gt;We warmly welcome &lt;a href=&#34;https://raw.githubusercontent.com/digital-asset/daml/main/CONTRIBUTING.md&#34;&gt;contributions&lt;/a&gt;. If you are looking for ideas on how to contribute, please browse our &lt;a href=&#34;https://github.com/digital-asset/daml/issues&#34;&gt;issues&lt;/a&gt;. To build and test Daml:&lt;/p&gt; &#xA;&lt;h3&gt;1. Clone this repository&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone git@github.com:digital-asset/daml.git&#xA;cd daml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2. Set up the development dependencies&lt;/h3&gt; &#xA;&lt;p&gt;Our builds require various development dependencies (e.g. Java, Bazel, Python), provided by a tool called &lt;code&gt;dev-env&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Linux&lt;/h4&gt; &#xA;&lt;p&gt;On Linux &lt;code&gt;dev-env&lt;/code&gt; can be installed with:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Nix by running: &lt;code&gt;bash &amp;lt;(curl -sSfL https://nixos.org/nix/install)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Enter &lt;code&gt;dev-env&lt;/code&gt; by running: &lt;code&gt;eval &#34;$(dev-env/bin/dade assist)&#34;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you don&#39;t want to enter &lt;code&gt;dev-env&lt;/code&gt; manually each time using &lt;code&gt;eval &#34;$(dev-env/bin/dade assist)&#34;&lt;/code&gt;, you can also install &lt;a href=&#34;https://direnv.net&#34;&gt;direnv&lt;/a&gt;. This repo already provides a &lt;code&gt;.envrc&lt;/code&gt; file, with an option to add more in a &lt;code&gt;.envrc.private&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;h4&gt;Mac&lt;/h4&gt; &#xA;&lt;p&gt;On Mac &lt;code&gt;dev-env&lt;/code&gt; can be installed with:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install Nix by running: &lt;code&gt;bash &amp;lt;(curl -sSfL https://nixos.org/nix/install)&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This is a &lt;em&gt;multi-user installation&lt;/em&gt; (there is no single-user installation option for macOS). Because of this, you need to configure &lt;code&gt;/etc/nix/nix.conf&lt;/code&gt; to use Nix caches:&lt;/li&gt; &#xA;  &lt;/ul&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt; &lt;p&gt;Add yourself as a nix trusted user by running &lt;code&gt;echo &#34;extra-trusted-users = $USER&#34; | sudo tee -a /etc/nix/nix.conf&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Restart the &lt;code&gt;nix-daemon&lt;/code&gt; by running &lt;code&gt;sudo launchctl stop org.nixos.nix-daemon &amp;amp;&amp;amp; sudo launchctl start org.nixos.nix-daemon&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Enter &lt;code&gt;dev-env&lt;/code&gt; by running: &lt;code&gt;eval &#34;$(dev-env/bin/dade assist)&#34;&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you don&#39;t want to enter &lt;code&gt;dev-env&lt;/code&gt; manually each time using &lt;code&gt;eval &#34;$(dev-env/bin/dade assist)&#34;&lt;/code&gt;, you can also install &lt;a href=&#34;https://direnv.net&#34;&gt;direnv&lt;/a&gt;. This repo already provides a &lt;code&gt;.envrc&lt;/code&gt; file, with an option to add more in a &lt;code&gt;.envrc.private&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;Note that after a macOS update it can appear as if Nix is not installed. This is because macOS updates can modify shell config files in &lt;code&gt;/etc&lt;/code&gt;, which the multi-user installation of Nix modifies as well. A workaround for this problem is to add the following to your shell config file in your &lt;code&gt;$HOME&lt;/code&gt; directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Nix&#xA;if [ -e &#39;/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh&#39; ]; then&#xA;  . &#39;/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh&#39;&#xA;fi&#xA;# End Nix&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/NixOS/nix/issues/3616&#34;&gt;https://github.com/NixOS/nix/issues/3616&lt;/a&gt; for more information about this issue.&lt;/p&gt; &#xA;&lt;h5&gt;MacOS M1&lt;/h5&gt; &#xA;&lt;p&gt;The above procedure will use and build native arm64 M1 binaries for this project. However, note that at the time of writing the CI system of the Daml project does not yet include MacOS M1 nodes. Therefore, the M1 configuration is untested on CI, and the remote cache is not populated with native M1 artifacts.&lt;/p&gt; &#xA;&lt;p&gt;If you encounter issues with a native M1 build, then you can configure project to build x86-64 binaries instead and run them through Rosetta. To do that replace the contents of the file &lt;code&gt;nix/system.nix&lt;/code&gt; with the following content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-nix&#34;&gt;&#34;x86_64-darwin&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;p&gt;On Windows you need to enable long file paths by running the following command in an admin powershell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Set-ItemProperty -Path &#39;HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem&#39; -Name LongPathsEnabled -Type DWord -Value 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You also need to configure Bazel for Windows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo &#34;build --config windows&#34; &amp;gt; .bazelrc.local&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note, if you are on a Windows ad-hoc or CI machine you can use &lt;code&gt;ci/configure-bazel.sh&lt;/code&gt; instead of performing these steps manually. In that case, you should checkout the &lt;code&gt;daml&lt;/code&gt; repository into the path &lt;code&gt;D:\a\1\s&lt;/code&gt; in order to be able to use remote cache artifacts.&lt;/p&gt; &#xA;&lt;p&gt;Then start &lt;code&gt;dev-env&lt;/code&gt; from PowerShell with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.\dev-env\windows\bin\dadew.ps1 install&#xA;.\dev-env\windows\bin\dadew.ps1 sync&#xA;.\dev-env\windows\bin\dadew.ps1 enable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In all new PowerShell processes started, you need to repeat the &lt;code&gt;enable&lt;/code&gt; step.&lt;/p&gt; &#xA;&lt;h3&gt;3. First build and test&lt;/h3&gt; &#xA;&lt;p&gt;We have a single script to build most targets and run the tests. On Linux and Mac run &lt;code&gt;./build.sh&lt;/code&gt;. On Windows run &lt;code&gt;.\build.ps1&lt;/code&gt;. Note that these scripts may take over an hour the first time.&lt;/p&gt; &#xA;&lt;p&gt;To just build do &lt;code&gt;bazel build //...&lt;/code&gt;, and to just test do &lt;code&gt;bazel test //...&lt;/code&gt;. To read more about Bazel and how to use it, see &lt;a href=&#34;https://bazel.build&#34;&gt;the Bazel site&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On Mac if building is causing trouble complaining about missing nix packages, you can try first running &lt;code&gt;nix-build -A tools -A cached nix&lt;/code&gt; repeatedly until it completes without error.&lt;/p&gt; &#xA;&lt;h3&gt;4. Installing a local copy&lt;/h3&gt; &#xA;&lt;p&gt;On Linux and Mac run &lt;code&gt;daml-sdk-head&lt;/code&gt; which installs a version of the SDK with version number &lt;code&gt;0.0.0&lt;/code&gt;. Set the &lt;code&gt;version:&lt;/code&gt; field in any Daml project to 0.0.0 and it will use the locally installed one.&lt;/p&gt; &#xA;&lt;p&gt;On Windows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bazel build //release:sdk-release-tarball&#xA;tar -vxf .\bazel-bin\release\sdk-release-tarball-ce.tar.gz&#xA;cd sdk-*&#xA;daml\daml.exe install . --install-assistant=yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That should tell you what to put in the path, something along the lines of &lt;code&gt;C:\Users\admin\AppData\Roaming\daml\bin&lt;/code&gt;. Note that the Windows build is not yet fully functional.&lt;/p&gt; &#xA;&lt;h3&gt;Caching: build speed and disk space considerations&lt;/h3&gt; &#xA;&lt;p&gt;Bazel has a lot of nice properties, but they come at the cost of frequently rebuilding &#34;the world&#34;. To make that bearable, we make extensive use of caching. Most artifacts should be cached in our CDN, which is configured in &lt;code&gt;.bazelrc&lt;/code&gt; in this project.&lt;/p&gt; &#xA;&lt;p&gt;However, even then, you may end up spending a lot of time (and bandwidth!) downloading artifacts from the CDN. To alleviate that, by default, our build will create a subfolder &lt;code&gt;.bazel-cache&lt;/code&gt; in this project and keep an on-disk cache. &lt;strong&gt;This can take about 10GB&lt;/strong&gt; at the time of writing.&lt;/p&gt; &#xA;&lt;p&gt;To disable the disk cache, remove the following lines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;build:linux --disk_cache=.bazel-cache&#xA;build:darwin --disk_cache=.bazel-cache&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;from the &lt;code&gt;.bazelrc&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;If you work with multiple copies of this repository, you can point all of them to the same disk cache by overwriting these configs in either a &lt;code&gt;.bazelrc.local&lt;/code&gt; file in each copy, or a &lt;code&gt;~/.bazelrc&lt;/code&gt; file in your home directory.&lt;/p&gt; &#xA;&lt;h3&gt;Shared memory segment issues&lt;/h3&gt; &#xA;&lt;p&gt;On macOS at least, it looks like our setup does not always properly close the resources PostgreSQL uses. After a number of test runs, you may encounter an error message along the lines of:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;FATAL:  could not create shared memory segment: No space left on device&#xA;DETAIL:  Failed system call was shmget(key=5432001, size=56, 03600).&#xA;HINT:  This error does *not* mean that you have run out of disk space. It occurs either if all available shared memory IDs have been taken, in which case you need to raise the SHMMNI parameter in your kernel, or because the system&#39;s overall limit for shared memory has been reached.&#xA;        The PostgreSQL documentation contains more information about shared memory configuration.&#xA;child process exited with exit code 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, this is a memory leak, so increasing &lt;code&gt;SHMNI&lt;/code&gt; (or &lt;code&gt;SHMALL&lt;/code&gt; etc.) as suggested will only delay the issue. You can look at the existing shared memory segments on your system by running &lt;code&gt;ipcs -mcopt&lt;/code&gt;; this will print a line per segment, indicating the process ID of the last process to connect to the segment as well as the last access time and the number of currently connected processes.&lt;/p&gt; &#xA;&lt;p&gt;If you identify segments with no connected processes, and you are confident you can remove them, you can do so with &lt;code&gt;ipcrm $sid&lt;/code&gt;, where &lt;code&gt;$sid&lt;/code&gt; is the process ID displayed (as the second column) by &lt;code&gt;ipcs&lt;/code&gt;. Not many macOS applications use shared memory segments; &lt;strong&gt;if you have verified that all the existing memory segments on your machine need to be deleted&lt;/strong&gt;, e.g. because they have all been created by PostgreSQL instances that are no longer running, here is a Bash invocation you can use to remove all shared memory segments from your system.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;This is a dangerous command. Make sure you understand what it does before running it.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;for shmid in $(ipcs -m | sed 1,3d | awk &#39;{print $2}&#39; | sed &#39;$d&#39;); do ipcrm -m $shmid; done&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Haskell profiling builds&lt;/h3&gt; &#xA;&lt;p&gt;To build Haskell executables with profiling enabled, pass &lt;code&gt;-c dbg&lt;/code&gt; to Bazel, e.g. &lt;code&gt;bazel build -c dbg damlc&lt;/code&gt;. If you want to build the whole SDK with profiling enabled use &lt;code&gt;daml-sdk-head --profiling&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ucb-bar/chiseltest</title>
    <updated>2022-06-24T01:56:00Z</updated>
    <id>tag:github.com,2022-06-24:/ucb-bar/chiseltest</id>
    <link href="https://github.com/ucb-bar/chiseltest" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The official testing library for Chisel circuits.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;chiseltest&lt;/h1&gt; &#xA;&lt;p&gt;Chiseltest is the &lt;em&gt;batteries-included&lt;/em&gt; testing and formal verification library for &lt;a href=&#34;https://github.com/chipsalliance/chisel3&#34;&gt;Chisel&lt;/a&gt;-based RTL designs. Chiseltest emphasizes tests that are lightweight (minimizes boilerplate code), easy to read and write (understandability), and compose (for better test code reuse).&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To use chisel-testers as a managed dependency, add this in your build.sbt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;edu.berkeley.cs&#34; %% &#34;chiseltest&#34; % &#34;0.5.2&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are also directly depending on the &lt;code&gt;chisel3&lt;/code&gt; library, please &lt;a href=&#34;https://www.chisel-lang.org/chisel3/docs/appendix/versioning.html&#34;&gt;make sure that your chisel3 and chiseltest versions match&lt;/a&gt; to avoid linking errors.&lt;/p&gt; &#xA;&lt;h2&gt;Writing a Test&lt;/h2&gt; &#xA;&lt;p&gt;ChiselTest integrates with the &lt;a href=&#34;http://scalatest.org&#34;&gt;ScalaTest&lt;/a&gt; framework, which provides good IDE and continuous integration support for launching unit tests.&lt;/p&gt; &#xA;&lt;p&gt;Assuming a typical Chisel project with &lt;code&gt;MyModule&lt;/code&gt; defined in &lt;code&gt;src/main/scala/MyModule.scala&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class MyModule extend Module {&#xA;    val io = IO(new Bundle {&#xA;        val in = Input(UInt(16.W))&#xA;        val out = Output(UInt(16.W))&#xA;    })&#xA;&#xA;    io.out := RegNext(io.in)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a new file in &lt;code&gt;src/test/scala/&lt;/code&gt;, for example, &lt;code&gt;BasicTest.scala&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In this file:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Add the necessary imports: &lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import chisel3._&#xA;import chiseltest._&#xA;import org.scalatest.flatspec.AnyFlatSpec&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Create a test class: &lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class BasicTest extends AnyFlatSpec with ChiselScalatestTester {&#xA;  behavior of &#34;MyModule&#34;&#xA;  // test class body here&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;AnyFlatSpec&lt;/code&gt; is the &lt;a href=&#34;http://www.scalatest.org/user_guide/selecting_a_style&#34;&gt;default and recommended ScalaTest style for unit testing&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;ChiselScalatestTester&lt;/code&gt; provides testdriver functionality and integration (like signal value assertions) within the context of a ScalaTest environment.&lt;/li&gt; &#xA;   &lt;li&gt;For those interested in additional ScalaTest assertion expressibility, &lt;code&gt;Matchers&lt;/code&gt; provides additional &lt;a href=&#34;http://www.scalatest.org/user_guide/using_matchers&#34;&gt;assertion syntax options&lt;/a&gt;. &lt;code&gt;Matchers&lt;/code&gt; is optional as it&#39;s mainly for Scala-land assertions and does not inter-operate with circuit operations.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;In the test class, define a test case: &lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;it should &#34;do something&#34; in {&#xA;  // test case body here&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; There can be multiple test cases per test class, and we recommend one test class per Module being tested, and one test case per individual test.&lt;/li&gt; &#xA; &lt;li&gt;In the test case, define the module being tested: &lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;test(new MyModule) { c =&amp;gt;&#xA;  // test body here&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;code&gt;test&lt;/code&gt; automatically runs the default simulator (which is &lt;a href=&#34;https://github.com/freechipsproject/treadle&#34;&gt;treadle&lt;/a&gt;), and runs the test stimulus in the block. The argument to the test stimulus block (&lt;code&gt;c&lt;/code&gt; in this case) is a handle to the module under test.&lt;/li&gt; &#xA; &lt;li&gt;In the test body, use &lt;code&gt;poke&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;, and &lt;code&gt;expect&lt;/code&gt; operations to write the test: &lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;c.io.in.poke(0.U)&#xA;c.clock.step()&#xA;c.io.out.expect(0.U)&#xA;c.io.in.poke(42.U)&#xA;c.clock.step()&#xA;c.io.out.expect(42.U)&#xA;println(&#34;Last output value :&#34; + c.io.out.peek().litValue)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;With your test case complete, you can run all the test cases in your project by invoking ScalaTest. If you&#39;re using &lt;a href=&#34;http://scala-sbt.org&#34;&gt;sbt&lt;/a&gt;, you can either run &lt;code&gt;sbt test&lt;/code&gt; from the command line, or &lt;code&gt;test&lt;/code&gt; from the sbt console. &lt;code&gt;testOnly&lt;/code&gt; can also be used to run specific tests.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Usage References&lt;/h3&gt; &#xA;&lt;p&gt;See the test cases for examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ucb-bar/chiseltest/main/src/test/scala/chiseltest/tests/BasicTest.scala&#34;&gt;BasicTest&lt;/a&gt; shows basic &lt;code&gt;peek&lt;/code&gt;, &lt;code&gt;poke&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; functionality&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ucb-bar/chiseltest/main/src/test/scala/chiseltest/tests/QueueTest.scala&#34;&gt;QueueTest&lt;/a&gt; shows example uses of the DecoupledDriver library, providing functions like &lt;code&gt;enqueueNow&lt;/code&gt;, &lt;code&gt;expectDequeueNow&lt;/code&gt;, their sequence variants, &lt;code&gt;expectPeek&lt;/code&gt;, and &lt;code&gt;expectInvalid&lt;/code&gt;. Also, check out the &lt;a href=&#34;https://raw.githubusercontent.com/ucb-bar/chiseltest/main/src/main/scala/chiseltest/DecoupledDriver.scala&#34;&gt;DecoupledDriver&lt;/a&gt; implementation, and note that it is not a special case, but code that any user can write.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ucb-bar/chiseltest/main/src/test/scala/chiseltest/tests/BundleLiteralsSpec.scala&#34;&gt;BundleLiteralsSpec&lt;/a&gt; shows examples of using bundle literals to poke and expect bundle wires. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Note: Bundle literals are still an experimental chisel3 feature and need to be explicitly imported: &lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import chisel3.experimental.BundleLiterals._&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ucb-bar/chiseltest/main/src/test/scala/chiseltest/tests/AluTest.scala&#34;&gt;AlutTest&lt;/a&gt; shows an example of re-using the same test for different data&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ucb-bar/chiseltest/main/src/test/scala/chiseltest/tests/ShiftRegisterTest.scala&#34;&gt;ShiftRegisterTest&lt;/a&gt; shows an example of using fork/join to define a test helper function, where multiple invocations of it are pipelined using &lt;code&gt;fork&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;New Constructs&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;fork&lt;/code&gt; to spawn threads, and &lt;code&gt;join&lt;/code&gt; to block (wait) on a thread. Pokes and peeks/expects to wires from threads are checked during runtime to ensure no collisions or unexpected behavior. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;fork&lt;/code&gt;ed threads provide a concurrency abstraction for writing testbenches only, without real parallelism. The test infrastructure schedules threads one at a time, with threads running once per simulation cycle.&lt;/li&gt; &#xA;   &lt;li&gt;Thread order is deterministic, and attempts to follow lexical order (as it would appear from the code text): &lt;code&gt;fork&lt;/code&gt;ed (child) threads run immediately, then return to the spawning (parent) thread. On future cycles, child threads run before their parent, in the order they were spawned.&lt;/li&gt; &#xA;   &lt;li&gt;Only cross-thread operations that round-trip through the simulator (eg, peek-after-poke) are checked. You can do cross-thread operations in Scala (eg, using shared variables) that aren&#39;t checked, but it is up to you to make sure they are correct and intuitive. This is not recommended. In the future, we may provide checked mechanisms for communicating between test threads.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Regions can be associated with a thread, with &lt;code&gt;fork.withRegion(...)&lt;/code&gt;, which act as a synchronization barrier within simulator time steps. This can be used to create monitors that run after other main testdriver threads have been run, and can read wires those threads have poked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;timescope&lt;/code&gt; allows pokes to be scoped - that is, pokes inside the timescope block &#34;disappear&#34; and the wire reverts to its previous value at the end of the block. This fits well with the pattern of assigning a default pull-up/down to a wire, and temporarily overriding that value, for example a Decoupled &lt;code&gt;valid&lt;/code&gt; signal defaulting low but driven high during an enqueue transaction. See &lt;a href=&#34;https://raw.githubusercontent.com/ucb-bar/chiseltest/main/src/test/scala/chiseltest/tests/TimescopeTest.scala&#34;&gt;TimescopeTest&lt;/a&gt; for examples.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Simulator Backends&lt;/h2&gt; &#xA;&lt;p&gt;One of our goals is to keep your tests independent of the underlying simulator as much as possible. Thus, in most cases you should be able to choose from one of our four supported backends and get the exact same test results albeit with differences in execution speed and wave dump quality.&lt;/p&gt; &#xA;&lt;p&gt;We provide full bindings to two popular open-source simulator:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chipsalliance/treadle&#34;&gt;treadle&lt;/a&gt;: default, fast startup times, slow execution for larger circuits, supports only VCD&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.veripool.org/wiki/verilator&#34;&gt;verilator&lt;/a&gt;: enable with &lt;code&gt;VerilatorBackendAnnotation&lt;/code&gt;, slow startup, fast execution, supports VCD and FST&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We also provide bindings with some feature limitations to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://iverilog.icarus.com/&#34;&gt;iverilog&lt;/a&gt;: open-source, enable with &lt;code&gt;IcarusBackendAnnotation&lt;/code&gt;, supports VCD, FST and LXT&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.synopsys.com/verification/simulation/vcs.html&#34;&gt;vcs&lt;/a&gt;: commercial, enable with &lt;code&gt;VcsBackendAnnotation&lt;/code&gt;, supports VCD and FSDB&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Verilator Versions&lt;/h3&gt; &#xA;&lt;p&gt;We currently support the following versions of the &lt;a href=&#34;https://www.veripool.org/wiki/verilator&#34;&gt;verilator&lt;/a&gt; simulator:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;v4.028&lt;/code&gt;: &lt;a href=&#34;https://packages.ubuntu.com/focal/verilator&#34;&gt;Ubuntu 20.04&lt;/a&gt;, &lt;a href=&#34;https://src.fedoraproject.org/rpms/verilator&#34;&gt;Fedora 32&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;v4.032&lt;/code&gt;: &lt;a href=&#34;https://src.fedoraproject.org/rpms/verilator&#34;&gt;Fedora 33&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;v4.034&lt;/code&gt;: &lt;a href=&#34;https://chipyard.readthedocs.io/en/latest/Chipyard-Basics/Initial-Repo-Setup.html#requirements&#34;&gt;Chipyard&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;v4.038&lt;/code&gt;: &lt;a href=&#34;https://packages.ubuntu.com/groovy/verilator&#34;&gt;Ubuntu 20.10&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;v4.108&lt;/code&gt;: &lt;a href=&#34;https://src.fedoraproject.org/rpms/verilator&#34;&gt;Fedora 34&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;v4.202&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Frequently Asked Questions&lt;/h2&gt; &#xA;&lt;h3&gt;How do I rerun with --full-stacktrace?&lt;/h3&gt; &#xA;&lt;p&gt;Whereas Chisel accepts command-line arguments, chiseltest exposes the underlying annotation interface. You can pass annotations to a test by using &lt;code&gt;.withAnnotations(...)&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Top of file&#xA;import chisel3.stage.PrintFullStackTraceAnnotation&#xA;&#xA;// ...&#xA;&#xA;    // Inside your test spec&#xA;    test(new MyModule).withAnnotations(Seq(PrintFullStackTraceAnnotation)) { c =&amp;gt;&#xA;      // test body here&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will remove the chisel3 stacktrace suppression (ie. &lt;code&gt;at ... ()&lt;/code&gt;). However, if you are using ScalaTest, you may notice a shortened stack trace with &lt;code&gt;...&lt;/code&gt; at the end. You can tell ScalaTest to stop suppressing the stack trace by passing &lt;code&gt;-oF&lt;/code&gt; to it. For example (using SBT):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sbt&#xA;&amp;gt; testOnly &amp;lt;spec name&amp;gt; -- -oF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any arguments after &lt;code&gt;--&lt;/code&gt; pass to ScalaTest directly instead of being interpreted by SBT.&lt;/p&gt; &#xA;&lt;h2&gt;Stability&lt;/h2&gt; &#xA;&lt;p&gt;Most APIs that can be accessed through &lt;code&gt;import chiseltest._&lt;/code&gt; are going to remain stable. We are also trying to keep the API provided through &lt;code&gt;import chiseltest.formal._&lt;/code&gt; relatively stable. All other packages are considered internal and thus might change at any time.&lt;/p&gt; &#xA;&lt;h2&gt;Migrating from chisel-testers / iotesters&lt;/h2&gt; &#xA;&lt;h3&gt;Port to new API&lt;/h3&gt; &#xA;&lt;p&gt;The core abstractions (&lt;code&gt;poke&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;) are similar to &lt;a href=&#34;https://github.com/freechipsproject/chisel-testers&#34;&gt;chisel-testers&lt;/a&gt;, but the syntax is inverted: instead of doing &lt;code&gt;tester.poke(wire, value)&lt;/code&gt; with a Scala number value, in ChiselTest you would write &lt;code&gt;wire.poke(value)&lt;/code&gt; with a Chisel literal value. Furthermore, as no reference to the tester context is needed, test helper functions can be defined outside a test class and written as libraries.&lt;/p&gt; &#xA;&lt;h3&gt;PeekPokeTester compatibility&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;chiseltest&lt;/code&gt; now provides a compatibility layer that makes it possible to re-use old &lt;code&gt;PeekPokeTester&lt;/code&gt; based tests with little to no changes to the code. We ported the majority of &lt;a href=&#34;https://github.com/freechipsproject/chisel-testers/tree/master/src/test/scala&#34;&gt;tests from the chisel-testers repository&lt;/a&gt; to our &lt;a href=&#34;https://github.com/ucb-bar/chiseltest/tree/main/src/test/scala/chiseltest/iotesters&#34;&gt;new compatibility layer&lt;/a&gt;. While the test itself can mostly remain unchanged, the old &lt;code&gt;Driver&lt;/code&gt; is removed and instead tests are launched with the new &lt;code&gt;test&lt;/code&gt; syntax.&lt;/p&gt; &#xA;&lt;h3&gt;Hardware testers&lt;/h3&gt; &#xA;&lt;p&gt;Hardware testers are synthesizeable tests, most often extending the &lt;code&gt;BasicTester&lt;/code&gt; class provided by &lt;code&gt;chisel3&lt;/code&gt;. You can now directly &lt;a href=&#34;https://github.com/ucb-bar/chiseltest/raw/main/src/test/scala/chiseltest/tests/HardwareTestsTest.scala&#34;&gt;use these tests with &lt;code&gt;chiseltest&lt;/code&gt; through the &lt;code&gt;runUntilStop&lt;/code&gt; function&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>