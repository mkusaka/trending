<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-21T01:44:14Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>microsoft/scala_torch</title>
    <updated>2023-01-21T01:44:14Z</updated>
    <id>tag:github.com,2023-01-21:/microsoft/scala_torch</id>
    <link href="https://github.com/microsoft/scala_torch" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scala bindings for LibTorch&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;scala-torch&lt;/h1&gt; &#xA;&lt;p&gt;JVM/Scala wrappers for LibTorch.&lt;/p&gt; &#xA;&lt;h2&gt;State of this project&lt;/h2&gt; &#xA;&lt;p&gt;This project is mature enough to be used regularly in production code. The API exposed is fairly clean and tries to follow PyTorch syntax as much as possible. The API is a mix of hand-written wrappings and a wrapper around most of &lt;code&gt;Declarations.yaml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;That said, some internal documentation is not quite ready for public consumption yet, though there is enough documentation that people who are already familiar with Scala and LibTorch can probably figure out what&#39;s going on. Code generation is accomplished through a combination of &lt;a href=&#34;https://www.swig.org&#34;&gt;Swig&lt;/a&gt; and a quick-and-dirty &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/scala_torch/main/swig/src/main/swig/bindgen.py&#34;&gt;Python script&lt;/a&gt; that reads in &lt;code&gt;Declarations.yaml&lt;/code&gt;, which provides a language-independent API for a large part of LibTorch. This file is &lt;a href=&#34;https://github.com/pytorch/pytorch/issues/69471&#34;&gt;deprecated&lt;/a&gt; and in the future, we can hopefully replace &lt;code&gt;bindgen.py&lt;/code&gt; using the forthcoming &lt;a href=&#34;https://github.com/pytorch/pytorch/issues/69471#issuecomment-1273642655&#34;&gt;torchgen&lt;/a&gt; tool provided by PyTorch.&lt;/p&gt; &#xA;&lt;p&gt;One major annoyance with Scala in particular is that you cannot define multiple overloads of a method that take default arguments. Currently, &lt;code&gt;bindgen.py&lt;/code&gt; uses any defaults present in only the first overload found in &lt;code&gt;Declarations.yaml&lt;/code&gt;. In some cases, clever use of Scala&#39;s implicit conversions can hide these headaches, but currently, you occasionaly have to write out the defaults where you would not have to in Python. One potential future option is to give overloads different names, but we elected not to do that (yet).&lt;/p&gt; &#xA;&lt;p&gt;We have not yet published JARs for this project. These are coming soon.&lt;/p&gt; &#xA;&lt;h2&gt;Short tour&lt;/h2&gt; &#xA;&lt;p&gt;Scala-torch exposes an API that tries to mirror PyTorch as much as Scala syntax allows. For example, taking some snippets from &lt;a href=&#34;https://pytorch.org/tutorials/beginner/basics/tensorqs_tutorial.html&#34;&gt;this tutorial&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;p&gt;PyTorch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch&#xA;&#xA;data = [[1, 2],[3, 4]]&#xA;x_data = torch.tensor(data)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scala-Torch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.microsoft.scalatorch.torch&#xA;import com.microsoft.scalatorch.torch.syntax._&#xA;&#xA;torch.ReferenceManager.forBlock { implicit rm =&amp;gt;&#xA; val data = $($(1, 2), $(3, 4))&#xA; val x_data = torch.tensor(data)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;PyTorch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tensor = torch.ones(4, 4)&#xA;print(f&#34;First row: {tensor[0]}&#34;)&#xA;print(f&#34;First column: {tensor[:, 0]}&#34;)&#xA;print(f&#34;Last column: {tensor[..., -1]}&#34;)&#xA;tensor[:,1] = 0&#xA;print(tensor)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scala-Torch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val tensor = torch.ones($(4, 4))&#xA;println(s&#34;First row: ${tensor(0)}&#34;)&#xA;println(s&#34;First column: ${tensor(::, 0)}&#34;)&#xA;println(s&#34;Last column: ${tensor(---, -1)}&#34;)&#xA;tensor(::, 1) = 0&#xA;println(tensor)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/scala_torch/main/scala-torch/src/test/scala/com/microsoft/scalatorch/torch/tutorial/PyTorchOrgTensorTutorialTest.scala&#34;&gt;this file&lt;/a&gt; for a complete translation of the PyTorch tutorial into Scala-Torch.&lt;/p&gt; &#xA;&lt;h3&gt;Memory management&lt;/h3&gt; &#xA;&lt;p&gt;One big difference between Scala-Torch and PyTorch is in memory management. Because Python and LibTorch both use reference counting, memory management is fairly transparent to users. However, since the JVM uses garbage collection and &lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#finalize--&#34;&gt;finalizers are not guaranteed to run&lt;/a&gt;, it is not easy to make memory management transparent to the user. Scala-Torch elects to make memory management something the user must control by providing &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/scala_torch/main/scala-torch/src/main/scala/com/microsoft/scalatorch/torch/ReferenceManager.scala&#34;&gt;ReferenceManager&lt;/a&gt;s that define the lifetime of any LibTorch-allocated object that is added to it. All Scala-Torch methods that allocate objects from LibTorch take an &lt;code&gt;implicit&lt;/code&gt; &lt;code&gt;ReferenceManager&lt;/code&gt;, so it is the responsibility of the caller to make sure there is a &lt;code&gt;ReferenceManager&lt;/code&gt; in &lt;code&gt;implicit&lt;/code&gt; scope (or passed explicitly) and that that &lt;code&gt;ReferenceManager&lt;/code&gt; will be &lt;code&gt;close()&lt;/code&gt;ed when appropriate. See documentation and uses of &lt;code&gt;ReferenceManager&lt;/code&gt; for more examples.&lt;/p&gt; &#xA;&lt;h2&gt;Handling of native dependencies&lt;/h2&gt; &#xA;&lt;p&gt;PyTorch provides pre-built binaries for the native code backing it &lt;a href=&#34;https://pytorch.org/get-started/locally/&#34;&gt;here&lt;/a&gt;. We make use of the pre-built dynamic libraries by packaging them up in a jar, much like &lt;a href=&#34;http://platanios.org/tensorflow_scala/installation.html&#34;&gt;TensorFlow Scala&lt;/a&gt;. Downstream projects have two options for handling the native dependencies: they can either&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Declare a dependency on the packaged native dependencies wrapped up with a jar using&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val osClassifier = System.getProperty(&#34;os.name&#34;).toLowerCase match {&#xA;  case os if os.contains(&#34;mac&#34;) || os.contains(&#34;darwin&#34;) =&amp;gt; &#34;darwin&#34;&#xA;  case os if os.contains(&#34;linux&#34;)                        =&amp;gt; &#34;linux&#34;&#xA;  case os if os.contains(&#34;windows&#34;)                      =&amp;gt; &#34;windows&#34;&#xA;  case os                                                =&amp;gt; throw new sbt.MessageOnlyException(s&#34;The OS $os is not a supported platform.&#34;)&#xA;}&#xA;libraryDependencies += (&#34;com.microsoft.scalatorch&#34; % &#34;libtorch-jar&#34; % &#34;1.10.0&#34;).classifier(osClassifier + &#34;_cpu&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Ensure that the libtorch dependencies are installed in the OS-dependent way, for example, in &lt;code&gt;/usr/lib&lt;/code&gt; or in &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; on Linux, or in &lt;code&gt;PATH&lt;/code&gt; on windows. Note that on recent version of MacOS, &lt;a href=&#34;https://developer.apple.com/library/archive/documentation/Security/Conceptual/System_Integrity_Protection_Guide/RuntimeProtections/RuntimeProtections.html&#34;&gt;System Integrity Protected&lt;/a&gt; resets &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; and &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; when working processes, so it is very hard to use that approach on MacOS.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The native binaries for the JNI bindings for all three supported OSes are published in &lt;code&gt;scala-torch-swig.jar&lt;/code&gt;, so there is no need for OS-specific treatment of those libraries.&lt;/p&gt; &#xA;&lt;p&gt;Approach 1 is convenient because sbt will handle the libtorch native dependency for you and users won&#39;t need install libtorch or set any environment variables. This is the ideal approach for local development.&lt;/p&gt; &#xA;&lt;p&gt;There are several downsides of approach 1:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;it may unnecessarily duplicate installation of libtorch if, for example, pytorch is already installed&lt;/li&gt; &#xA; &lt;li&gt;jars for GPU builds of libtorch are not provided, so approach 2 is the only option if GPU support is required&lt;/li&gt; &#xA; &lt;li&gt;care must be taken when publishing any library that depends on Scala-Torch to not publish the dependency on the &lt;code&gt;libtorch-jar&lt;/code&gt;, since that would force the consumer of that library to depend on whatever OS-specific version of the jar was used at building time. See the use of &lt;code&gt;pomPostProcess&lt;/code&gt; in &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/scala_torch/main/build.sbt&#34;&gt;build.sbt&lt;/a&gt; for how we handle that. Note that another option is for downstream libraries to exclude the &lt;code&gt;libtorch-jar&lt;/code&gt; using something like&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += (&#34;com.microsoft&#34; % &#34;scala-torch&#34; % &#34;0.1.0&#34;).exclude(&#34;com.microsoft.scalatorch&#34;, &#34;libtorch-jar&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Approach 2 is the better option for CI, remote jobs, production, etc.&lt;/p&gt; &#xA;&lt;h3&gt;Local Development (MacOS)&lt;/h3&gt; &#xA;&lt;p&gt;You will need to have SWIG installed, which you can install using &lt;code&gt;brew install swig&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git submodule update --init --recursive&#xA;cd pytorch&#xA;python3 -m tools.codegen.gen -s aten/src/ATen -d torch/share/ATen&#xA;cd ..&#xA;curl https://download.pytorch.org/libtorch/cpu/libtorch-macos-$(pytorchVersion).zip -o libtorch.zip&#xA;unzip libtorch.zip&#xA;rm -f libtorch.zip&#xA;conda env create --name scala-torch --file environment.yml&#xA;conda activate scala-torch&#xA;export TORCH_DIR=$PWD/libtorch&#xA;# This links to the JNI shared library to the absolute paths in the libtorch dir instead of &#xA;# using an rpath.&#xA;export LINK_TO_BUILD_LIB=true&#xA;sbt test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A similar setup should work for Linux and Windows.&lt;/p&gt; &#xA;&lt;h4&gt;Troubleshooting&lt;/h4&gt; &#xA;&lt;p&gt;If you are using Clang 11.0.3 you may run into an error when compiling the &lt;code&gt;SobolEngineOps&lt;/code&gt; file. This is most likely due to an issue with the compiler and it has already been reported &lt;a href=&#34;https://github.com/pytorch/pytorch/issues/35478&#34;&gt;here&lt;/a&gt;. A temporary workaround is to install another version of Clang (e.g., by executing &lt;code&gt;brew install llvm&lt;/code&gt;). Another option is to downgrade XCode to a version &amp;lt; 11.4.&lt;/p&gt; &#xA;&lt;h3&gt;Upgrading the LibTorch version&lt;/h3&gt; &#xA;&lt;p&gt;To upgrade the underlying version of LibTorch:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cd pytorch; git checkout &amp;lt;commit&amp;gt;&lt;/code&gt; with the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; of the desired release version, best found &lt;a href=&#34;https://github.com/pytorch/pytorch/releases&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Rerun the steps under &lt;strong&gt;Local Development&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Change &lt;code&gt;TORCH_VERSION&lt;/code&gt; in &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/scala_torch/main/.github/workflows/run_tests.yml&#34;&gt;run_tests.yml&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Address compilation errors when running &lt;code&gt;sbt compile&lt;/code&gt;. Changes to &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/scala_torch/main/swig/src/main/swig/bindgen.py&#34;&gt;bindgen.py&lt;/a&gt; may be necessary.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contributors&lt;/h1&gt; &#xA;&lt;p&gt;Thanks to the following contributors to this project:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/adampauls&#34;&gt;Adam Pauls&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dlwh&#34;&gt;David Hall&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/theo-lanman&#34;&gt;Theo Lanman&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alexanderkyte&#34;&gt;Alex Kyte&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hao-fang&#34;&gt;Hao Fang&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/eaplatanios&#34;&gt;Anthony Platanios&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Dpetters&#34;&gt;Dmitrij Peters&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Trademarks&lt;/h1&gt; &#xA;&lt;p&gt;This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow &lt;a href=&#34;https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general&#34;&gt;Microsoft&#39;s Trademark &amp;amp; Brand Guidelines&lt;/a&gt;. Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party&#39;s policies.&lt;/p&gt;</summary>
  </entry>
</feed>