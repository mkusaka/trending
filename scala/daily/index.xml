<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-08T01:22:36Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>viperproject/silicon</title>
    <updated>2024-05-08T01:22:36Z</updated>
    <id>tag:github.com,2024-05-08:/viperproject/silicon</id>
    <link href="https://github.com/viperproject/silicon" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Symbolic-execution-based verifier for the Viper intermediate verification language.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Silicon: A Viper Verifier Based on Symbolic Execution&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;512&#34; height=&#34;144&#34; alt=&#34;Silicon logo&#34; src=&#34;https://raw.githubusercontent.com/viperproject/silicon/master/docs/logo_name.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Silicon is a state-of-the-art, automated verifier based on symbolic execution, and the default verifier of the &lt;a href=&#34;http://www.pm.inf.ethz.ch/research/viper.html&#34;&gt;Viper verification infrastructure&lt;/a&gt;. Silicon&#39;s input language is the &lt;a href=&#34;http://pm.inf.ethz.ch/publications/getpdf.php?bibname=Own&amp;amp;id=MuellerSchwerhoffSummers16.pdf&#34;&gt;Viper intermediate verification language&lt;/a&gt;: a language in the spirit of Microsoft&#39;s Boogie, but with a higher level of abstraction and a built-in notation of permissions, which makes Viper well-suited for encoding and verifying properties of sequential and concurrent programs with shared mutable state. Loads of details can (but don&#39;t need to) be found in the &lt;a href=&#34;http://pm.inf.ethz.ch/publications/getpdf.php?bibname=Own&amp;amp;id=Schwerhoff16.pdf&#34;&gt;PhD thesis of Malte Schwerhoff&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As an example, consider the following simple C++ program, which runs two threads in parallel that increment a shared memory location and that uses a lock to avoid race conditions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;thread&amp;gt;&#xA;#include &amp;lt;mutex&amp;gt;&#xA;#include &amp;lt;assert.h&amp;gt;&#xA;&#xA;struct Cell {&#xA;  int val;&#xA;};&#xA;&#xA;void inc(Cell* c, std::mutex* guard) {&#xA;  guard-&amp;gt;lock();&#xA;  &#xA;  int t = c-&amp;gt;val;&#xA;  std::this_thread::sleep_for(std::chrono::seconds(1));&#xA;  c-&amp;gt;val = t + 1;&#xA;  &#xA;  guard-&amp;gt;unlock();&#xA;}&#xA;&#xA;int main() {&#xA;  Cell* c = new Cell{0};&#xA;  std::mutex* guard = new std::mutex();&#xA;  &#xA;  std::thread t1 = std::thread(inc, c, guard);&#xA;  std::thread t2 = std::thread(inc, c, guard);&#xA;&#xA;  t1.join();&#xA;  t2.join();&#xA;  &#xA;  guard-&amp;gt;~mutex();&#xA;  assert(c-&amp;gt;val == 2);&#xA;&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Such a program can be encoded in Viper, e.g. using an Owicki-Gries approach as shown below, and Silicon can be used to automatically verify that the shared memory location is indeed modified in an orderly manner.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;field val: Int&#xA;field t1: Int&#xA;field t2: Int&#xA;&#xA;// Monitor/lock invariant associated with the shared cell&#xA;// Macro&#39;ed for easy reuse&#xA;define guard_INV(c)&#xA;  acc(c.val) &amp;amp;&amp;amp; acc(c.t1, 1/2) &amp;amp;&amp;amp; acc(c.t2, 1/2) &amp;amp;&amp;amp;&#xA;  c.val == c.t1 + c.t2&#xA;&#xA;// Precondition of inc&#xA;define inc_PRE(c, tid)&#xA;  (tid == 0 || tid == 1) &amp;amp;&amp;amp;&#xA;  (tid == 0 ? acc(c.t1, 1/2) : acc(c.t2, 1/2))&#xA;  &#xA;// Postcondition of inc&#xA;define inc_POST(c, tid, oldv)&#xA;  tid == 0 ? (acc(c.t1, 1/2) &amp;amp;&amp;amp; c.t1 == oldv + 1)&#xA;            : (acc(c.t2, 1/2) &amp;amp;&amp;amp; c.t2 == oldv + 1)&#xA;&#xA;method inc(c: Ref, tid: Int)&#xA;  requires inc_PRE(c, tid)&#xA;  ensures  inc_POST(c, tid, tid == 0 ? old(c.t1) : old(c.t2))&#xA;{&#xA;  inhale guard_INV(c) // models guard.lock()&#xA;  &#xA;  c.val := c.val + 1&#xA;  &#xA;  if (tid == 0) { c.t1 := c.t1 + 1 }&#xA;  else { c.t2 := c.t2 + 1 }&#xA;  &#xA;  exhale guard_INV(c) // models guard.unlock()&#xA;}&#xA;&#xA;method main() {&#xA;  var c: Ref&#xA;  c := new(val, t1, t2) // allocate real and ghost memory&#xA;  c.val := 0&#xA;  c.t1 := 0&#xA;  c.t2 := 0&#xA;  &#xA;  exhale guard_INV(c) // share the cell, i.e. create the guarding mutex&#xA;  &#xA;  label pre_fork&#xA;  exhale inc_PRE(c, 0) // fork thread 1&#xA;  exhale inc_PRE(c, 1) // fork thread 2&#xA;  &#xA;  inhale inc_POST(c, 0, old[pre_fork](c.t1)) // join thread 1&#xA;  inhale inc_POST(c, 1, old[pre_fork](c.t2)) // join thread 2&#xA;  &#xA;  inhale guard_INV(c) // unshare the cell, i.e. destroy the mutex&#xA;  &#xA;  assert c.val == 2;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Getting Started&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Download the &lt;a href=&#34;http://www.pm.inf.ethz.ch/research/viper/downloads.html&#34;&gt;Viper IDE&lt;/a&gt; (based on Microsoft Visual Studio Code).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Experiment with Viper using the &lt;a href=&#34;http://viper.ethz.ch/examples/&#34;&gt;Viper online&lt;/a&gt; web interface.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Build Instructions&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;See &lt;a href=&#34;https://github.com/viperproject/documentation/wiki&#34;&gt;the documentation wiki&lt;/a&gt; for instructions on how to try out or install the Viper tools.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You need recent installations of &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;the &lt;a href=&#34;https://www.scala-sbt.org/&#34;&gt;sbt build tool&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;the &lt;a href=&#34;https://github.com/Z3Prover/z3/releases&#34;&gt;Z3 SMT solver&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;(optional) the &lt;a href=&#34;https://github.com/cvc5/cvc5/releases&#34;&gt;cvc5 SMT solver&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;Clone this repository &lt;em&gt;recursively&lt;/em&gt; by running:&lt;br&gt; &lt;code&gt;git clone --recursive https://github.com/viperproject/silicon&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And then, from the cloned directory, with the &lt;code&gt;Z3_EXE&lt;/code&gt; environment variable set appropriately;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compile and run with:&lt;br&gt; &lt;code&gt;sbt &#34;run [options] &amp;lt;path to Viper file&amp;gt;&#34;&lt;/code&gt;&lt;br&gt; Or run all tests via &lt;code&gt;sbt test&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Alternatively, for a faster startup without compilation each time, build a &lt;code&gt;.jar&lt;/code&gt; file:&lt;br&gt; &lt;code&gt;sbt assembly&lt;/code&gt;&lt;br&gt; And then run with:&lt;br&gt; &lt;code&gt;java -jar ./target/scala-*/silicon.jar [options] &amp;lt;path to Viper file&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;We recommend IDEA IntelliJ for Scala development, but any IDE that supports sbt will do&lt;/p&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
</feed>