<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-11T01:42:26Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>quelgar/scala-uv</title>
    <updated>2024-01-11T01:42:26Z</updated>
    <id>tag:github.com,2024-01-11:/quelgar/scala-uv</id>
    <link href="https://github.com/quelgar/scala-uv" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scala Native language bindings for libuv&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Scala Native bindings for libuv&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;scala-uv&lt;/strong&gt; is a Scala Native library that provides Scala bindings for &lt;a href=&#34;https://libuv.org&#34;&gt;libuv&lt;/a&gt;, which is a multi-platform asynchronous IO library written in C. libuv was originally developed for Node.js, but it&#39;s also used by other software projects.&lt;/p&gt; &#xA;&lt;p&gt;Only Scala 3 is supported at this time.&lt;/p&gt; &#xA;&lt;h2&gt;Getting it&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;io.github.quelgar&#34; %%% &#34;scala-uv&#34; % &#34;0.0.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Current status&lt;/h2&gt; &#xA;&lt;p&gt;Very early days, only some of the APIs are bound. What works so far:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Error handling&lt;/li&gt; &#xA; &lt;li&gt;Event loop&lt;/li&gt; &#xA; &lt;li&gt;Async callbacks&lt;/li&gt; &#xA; &lt;li&gt;Read and write files&lt;/li&gt; &#xA; &lt;li&gt;TCP client and server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;But the API is still in flux.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Async callback&lt;/h3&gt; &#xA;&lt;p&gt;Runs a callback once, then closes the handle:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scala.scalanative.unsafe.*&#xA;import scala.scalanative.unsigned.*&#xA;import scalauv.*&#xA;import LibUv.*&#xA;&#xA;object Main {&#xA;&#xA;  private var done = false&#xA;&#xA;  private val callback: AsyncCallback = { (handle: AsyncHandle) =&amp;gt;&#xA;    println(&#34;Callback!!&#34;)&#xA;    done = true&#xA;    uv_close(handle, null)&#xA;  }&#xA;&#xA;  def main(args: Array[String]): Unit = {&#xA;&#xA;    withZone {&#xA;      val loop = uv_default_loop()&#xA;&#xA;      val asyncHandle = UvUtils.zoneAllocateHandle(HandleType.UV_ASYNC)&#xA;      uv_async_init(loop, asyncHandle, callback).checkErrorThrowIO()&#xA;&#xA;      uv_async_send(asyncHandle).checkErrorThrowIO()&#xA;&#xA;      println(s&#34;Main before, done = $done&#34;)&#xA;      uv_run(loop, RunMode.DEFAULT).checkErrorThrowIO()&#xA;      println(s&#34;Main after, done = $done&#34;)&#xA;    }&#xA;&#xA;  }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Test examples&lt;/h3&gt; &#xA;&lt;p&gt;See also the tests&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/quelgar/scala-uv/main/src/test/scala/scalauv/TcpSpec.scala&#34;&gt;TcpSpec.scala&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/quelgar/scala-uv/main/src/test/scala/scalauv/FileSpec.scala&#34;&gt;FileSpec.scala&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Conveniences&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;LibUv&lt;/code&gt; objects provides the exact libuv API, but when using it directly you are basically writing C code with Scala syntax. A few convenienves are provided to make this less painful.&lt;/p&gt; &#xA;&lt;h3&gt;Dealing with libuv failures&lt;/h3&gt; &#xA;&lt;p&gt;libuv functions that can fail return a negative integer on failure, with the value indicating the precise error. The possible error codes are in &lt;a href=&#34;https://raw.githubusercontent.com/quelgar/scala-uv/main/src/main/scala/scalauv/errors.scala&#34;&gt;errors.scala&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Pass an error code to &lt;code&gt;UvUtils.errorMessage&lt;/code&gt; to get the human-readable error message as a Scala string.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;.checkErrorThrowIO()&lt;/code&gt; on the result of a libuv function to throw an &lt;code&gt;IOException&lt;/code&gt; if the function failed. Note this isn&#39;t useful inside a callback, since you definitely should &lt;em&gt;not&lt;/em&gt; throw exceptions from a C callback.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;uv_listen(serverTcpHandle, 128, onNewConnection).checkErrorThrowIO()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;.onFail&lt;/code&gt; to run some cleanup if the function failed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;uv_write(writeReq, stream, buf, 1.toUInt, onWrite).onFail {&#xA;    stdlib.free(writeReq)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Malloc C strings&lt;/h3&gt; &#xA;&lt;p&gt;While the &lt;code&gt;Zone&lt;/code&gt; memory allocation API from Scala Native is very nice, it&#39;s not useful when the memory is freed in a different callback, as there won&#39;t be a shared lexical scope. So &lt;code&gt;mallocCString&lt;/code&gt; converts a Scala string to a C string, allocating the memory the old-fashioned way.&lt;/p&gt; &#xA;&lt;h3&gt;Other UvUtils methods&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;allocate memory for requests&lt;/li&gt; &#xA; &lt;li&gt;allocate memory for handles&lt;/li&gt; &#xA; &lt;li&gt;allocate, use and free file system requests&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Copyright 2024 Lachlan O&#39;Dea&lt;/p&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.&lt;/p&gt;</summary>
  </entry>
</feed>