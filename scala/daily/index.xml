<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-14T01:37:25Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>vsalvis/DslStreams</title>
    <updated>2023-09-14T01:37:25Z</updated>
    <id>tag:github.com,2023-09-14:/vsalvis/DslStreams</id>
    <link href="https://github.com/vsalvis/DslStreams" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>non/antimirov</title>
    <updated>2023-09-14T01:37:25Z</updated>
    <id>tag:github.com,2023-09-14:/non/antimirov</id>
    <link href="https://github.com/non/antimirov" rel="alternate"></link>
    <summary type="html">&lt;p&gt;algebraic manipulation of regular expressions&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/non/antimirov&#34;&gt;&lt;img src=&#34;https://api.travis-ci.org/non/antimirov.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://codecov.io/github/non/antimirov?branch=master&#34;&gt;&lt;img src=&#34;http://codecov.io/github/non/antimirov/coverage.svg?branch=master&#34; alt=&#34;codecov.io&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Antimirov&lt;/h2&gt; &#xA;&lt;h3&gt;Dedication&lt;/h3&gt; &#xA;&lt;p&gt;This project is named after Valentin Antimirov (1961 - 1995). His work on &lt;a href=&#34;https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.2509&#34;&gt;partial derivatives&lt;/a&gt; of regular expressions is fundmental to this project.&lt;/p&gt; &#xA;&lt;h3&gt;Overview&lt;/h3&gt; &#xA;&lt;p&gt;Antimirov is a Scala package for working with &lt;a href=&#34;https://en.wikipedia.org/wiki/Regular_expression&#34;&gt;regular expressions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Antimirov defines an &lt;code&gt;Rx&lt;/code&gt; type, which supports the following regular expression combinators:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Unmatchable regular expressions (&lt;code&gt;Rx.Phi&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Matching the empty string (&lt;code&gt;Rx.Empty&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Matching single characters (&lt;code&gt;Rx.Letter(c)&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Matching sets of characters (&lt;code&gt;Rx.Letters(cs)&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Alternation (&lt;code&gt;Rx.Choice(x, y)&lt;/code&gt;, i.e. &lt;code&gt;x + y&lt;/code&gt; or &lt;code&gt;x | y&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Concatenation (&lt;code&gt;Rx.Concat(x, y)&lt;/code&gt;, i.e. &lt;code&gt;x * y&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Kleene Star (&lt;code&gt;Rx.Star(x)&lt;/code&gt;, i.e. &lt;code&gt;x.star&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Repetition (&lt;code&gt;Rx.Repeat(r, m, n)&lt;/code&gt;, i.e. &lt;code&gt;r.repeat(m, n)&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition to the previous combinators which are reified as algebraic data types, &lt;code&gt;Rx&lt;/code&gt; supports additional operations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Exponentiation (&lt;code&gt;x.pow(k)&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Optionality (&lt;code&gt;x.optional&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Intersection (&lt;code&gt;x &amp;amp; y&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Exclusive-or (XOR, i.e. &lt;code&gt;x ^ y&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Difference (&lt;code&gt;x - y&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Complement (&lt;code&gt;~x&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Equality (&lt;code&gt;x === y&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Partial-ordering (&lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;x partialCompare y&lt;/code&gt;, etc.)&lt;/li&gt; &#xA; &lt;li&gt;Derivatives (&lt;code&gt;x.deriv(c)&lt;/code&gt;, &lt;code&gt;x.partialDeriv(c)&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These operations are consistent with the corresponding set operations. What this means is that each &lt;code&gt;Rx&lt;/code&gt; value has a corresponding set of strings it accepts, and that these operations produce new &lt;code&gt;Rx&lt;/code&gt; values whose sets are consistent with the corresponding set operations.&lt;/p&gt; &#xA;&lt;p&gt;Finaly, &lt;code&gt;Rx&lt;/code&gt; values can be compiled down to an automaton for more efficient matching (either a &lt;code&gt;Dfa&lt;/code&gt; or &lt;code&gt;Nfa&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Getting Antimirov&lt;/h3&gt; &#xA;&lt;p&gt;Antimirov supports Scala 2.13 and 2.12. It is avilable from Sonatype.&lt;/p&gt; &#xA;&lt;p&gt;To include Antimirov in your projects, you can use the following &lt;code&gt;build.sbt&lt;/code&gt; snippet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies +=&#xA;  &#34;org.spire-math&#34; %% &#34;antimirov-core&#34; % &#34;0.2.6&#34;&#xA;&#xA;libraryDependencies += // optional scalacheck support&#xA;  &#34;org.spire-math&#34; %% &#34;antimirov-check&#34; % &#34;0.2.6&#34;&#xA;&#xA;libraryDependencies += // optional scalaprops support&#xA;  &#34;org.spire-math&#34; %% &#34;antimirov-props&#34; % &#34;0.2.6&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Antimirov also supports Scala.js. To use Antimirov in your Scala.js projects, include the following &lt;code&gt;build.sbt&lt;/code&gt; snippet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies +=&#xA;  &#34;org.spire-math&#34; %%% &#34;antimirov-core&#34; % &#34;0.2.6&#34;&#xA;&#xA;libraryDependencies += // optional scalacheck support&#xA;  &#34;org.spire-math&#34; %%% &#34;antimirov-check&#34; % &#34;0.2.6&#34;&#xA;&#xA;libraryDependencies += // optional scalaprops support&#xA;  &#34;org.spire-math&#34; %%% &#34;antimirov-props&#34; % &#34;0.2.6&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Details&lt;/h3&gt; &#xA;&lt;p&gt;Antimirov provides an algebraic interface for building regular expressions, as well as testing them for equality, subset/superset relationships, and more:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import antimirov.Rx&#xA;&#xA;val x: Rx = Rx.parse(&#34;[1-9][0-9]*&#34;)&#xA;&#xA;x.accepts(&#34;0&#34;)      // false&#xA;x.accepts(&#34;1&#34;)      // true&#xA;x.accepts(&#34;19&#34;)     // true&#xA;x.accepts(&#34;09&#34;)     // false&#xA;&#xA;val y: Rx = Rx.parse(&#34;[0-9a-f][0-9a-f]&#34;)&#xA;&#xA;y.accepts(&#34;af&#34;)     // true&#xA;y.accepts(&#34;09&#34;)     // true&#xA;y.accepts(&#34;099&#34;)    // false&#xA;&#xA;// set operations&#xA;//&#xA;// note that the full Char range is:&#xA;//   [&#39;\u0000&#39;, ..., &#39;/&#39;, &#39;0&#39;, ... &#39;9&#39;, &#39;:&#39;, ... &#39;\uffff&#39;]&#xA;&#xA;val z1: Rx = x | y  // [1-9][0-9]*|[0-9a-f][0-9a-f]&#xA;val z2: Rx = x &amp;amp; y  // [1-9][0-9]&#xA;val z3: Rx = x ^ y  // 0[0-9a-f]|[1-9][0-9][0-9][0-9]*|[1-9][a-f]|[1-9]|[a-f][0-9a-f]&#xA;val z4: Rx = x - y  // [1-9][0-9][0-9][0-9]*|[1-9]&#xA;val z5: Rx = ~x     // [^1-9].*|[1-9][0-9]*[^0-9].*|&#xA;&#xA;// equality, subset, and superset comparisons&#xA;&#xA;val xx: Rx = Rx.parse(&#34;[1-4][0-9]*|[5-9][0-9]*&#34;)&#xA;x == xx  // false&#xA;x === xx // true&#xA;x &amp;lt;= xx  // true&#xA;x &amp;lt; xx   // false&#xA;&#xA;val U: Rx = Rx.parse(&#34;.*&#34;)&#xA;x == U   // false&#xA;x === U  // false&#xA;x &amp;lt;= U   // true&#xA;x &amp;lt; U    // true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An &lt;code&gt;antimirov.Rx&lt;/code&gt; value can be converted to any of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;antimirov.Nfa&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;antimirov.Dfa&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;java.util.regex.Pattern&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scala.util.matching.Regex&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that unlike many modern regex libraries, Antimirov&#39;s regular expressions do not contain non-regular features (such as back-references), and are solely focused on matching, not on searching or extraction.&lt;/p&gt; &#xA;&lt;p&gt;Concretely, this means that:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Patterns are matched against the entire string&lt;/li&gt; &#xA; &lt;li&gt;No subgroup extraction is possible&lt;/li&gt; &#xA; &lt;li&gt;Zero-width assertions are unsupported&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Technically zero-width assertions are still regular, but they are not easily composable. For example, for &lt;code&gt;(?=x)&lt;/code&gt; as a zero-width look-ahead assertion on &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;(?&amp;lt;=y)&lt;/code&gt; as a zero-width look-behind assertion on &lt;code&gt;y&lt;/code&gt;, the following is true:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;[a-z]*(?=[^b])&lt;/code&gt; is equivalent to &lt;code&gt;[a-z]*[^b]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(?&amp;lt;=[^c])[a-z]*&lt;/code&gt; is equivalent to &lt;code&gt;[^c][a-z]*&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;[a-z]*(?=[^b])(?&amp;lt;=[^c])[a-z]*)&lt;/code&gt; is &lt;em&gt;NOT&lt;/em&gt; equivalent to &lt;code&gt;[a-z]*[^b][^c][a-z]*&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;instead it&#39;s equivalent to &lt;code&gt;[a-z]*[^bc][a-z]*&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These assertions don&#39;t play well with the algebraic structure of &lt;code&gt;Rx&lt;/code&gt; which is why they are left out (for now at least).&lt;/p&gt; &#xA;&lt;p&gt;In exchange for giving up these sorts of affordances, Antimirov can do things that most regular expression libraries can&#39;t do, such as intersection, exclusive-or, negation, semantic equality checks, subset comparisons (e.g. inclusion), and more.&lt;/p&gt; &#xA;&lt;h3&gt;ScalaCheck support&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;antimirov-check&lt;/code&gt; package support ScalaCheck, adding the ability to generate strings according to a regular expression. There are two ways to use it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package demo&#xA;&#xA;import antimirov.Rx&#xA;import antimirov.check.Regex&#xA;import org.scalacheck.{Prop, Properties}&#xA;&#xA;object Demo extends Properties(&#34;Demo&#34;) {&#xA;&#xA;  property(&#34;Arbitrary-based usage&#34;) = {&#xA;    val r1 = Regex(&#34;-?(0|[1-9][0-9]*)&#34;)&#xA;    Prop.forAll { (w: r1.Word) =&amp;gt;&#xA;      val s: String = w.value&#xA;      // s is guaranteed to be accepted by r1&#xA;      ???&#xA;    }&#xA;  }&#xA;&#xA;  property(&#34;Gen-based usage&#34;) = {&#xA;    val r2 = Rx.parse(&#34;-?(0|[1-9][0-9]*)&#34;)&#xA;    val mygen: Gen[String] = Regex.gen(r2)&#xA;    Prop.forAll(mygen) { s: String =&amp;gt;&#xA;      // s is guaranteed to be accepted by r2&#xA;      ???&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One thing to note here is that &lt;code&gt;antimirov.Rx&lt;/code&gt; has no direct dependency on ScalaCheck, which is why we introduce &lt;code&gt;antimirov.check.Regex&lt;/code&gt; to gain &lt;code&gt;Arbitrary&lt;/code&gt; support.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Regex&lt;/code&gt; is wrapper type around &lt;code&gt;Rx&lt;/code&gt; that adds the path-dependent type &lt;code&gt;Word&lt;/code&gt; as well as implementations of &lt;code&gt;Gen&lt;/code&gt; and &lt;code&gt;Arbitrary&lt;/code&gt; used by ScalaCheck. &lt;code&gt;Regex&lt;/code&gt; does not support the full suit of Antimirov operations (such as &lt;code&gt;&amp;amp;&lt;/code&gt;) and is really just meant for use with ScalaCheck. (For other usages, prefer its embedded &lt;code&gt;Rx&lt;/code&gt; value).&lt;/p&gt; &#xA;&lt;h3&gt;ScalaProps support&lt;/h3&gt; &#xA;&lt;p&gt;Antimirov also supports ScalaProps via &lt;code&gt;antimirov-props&lt;/code&gt;. This package is very similar to &lt;code&gt;antimirov-check&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package demo&#xA;&#xA;import antimirov.Rx&#xA;import antimirov.props.Regex&#xA;import scalaprops.{Gen, Property, Scalaprops}&#xA;&#xA;object Demo extends Scalaprops {&#xA;&#xA;  val implicitStyle = {&#xA;    val r1 = Regex(&#34;-?(0|[1-9][0-9]*)&#34;)&#xA;    Property.forAll { (w: r1.Word) =&amp;gt;&#xA;      val s: String = w.value&#xA;      // s is guaranteed to be accepted by r1&#xA;      ???&#xA;    }&#xA;  }&#xA;&#xA;  val explicitStyle = {&#xA;    val r2 = Rx.parse(&#34;-?(0|[1-9][0-9]*)&#34;)&#xA;    val mygen: Gen[String] = Regex.gen(r2)&#xA;    Property.forAllG(mygen) { s =&amp;gt;&#xA;      // s is guaranteed to be accepted by r2&#xA;      ???&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Web/JS tool&lt;/h3&gt; &#xA;&lt;p&gt;Antimirov has an interactive JS/HTML tool for working with regular expressions.&lt;/p&gt; &#xA;&lt;p&gt;You can try it out at &lt;a href=&#34;http://phylactery.org/antimirov/&#34;&gt;http://phylactery.org/antimirov/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To visit this page locally, simply run &lt;code&gt;sbt web/fullOptJS&lt;/code&gt; and then visit &lt;code&gt;web/index.html&lt;/code&gt; in your web browser.&lt;/p&gt; &#xA;&lt;h3&gt;Known Issues&lt;/h3&gt; &#xA;&lt;p&gt;The biggest issue with this library is that the problems are exponential in the general case. This means there are plenty of expressions for which Antimirov&#39;s operations (equality, inclusion, intersection, and so on) are prohibitively slow.&lt;/p&gt; &#xA;&lt;p&gt;There are some good strategies for dealing with this complexity through heuristics and optimizations. But some constructions (such as very wide alternations contained within a Kleene star) will probably never perform very well.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a list of other known problems:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Antimirov doesn&#39;t preserve user-specified expression syntax&lt;/li&gt; &#xA; &lt;li&gt;Antimirov cannot (yet) check constant expressions at compile-time&lt;/li&gt; &#xA; &lt;li&gt;Synthetic operators (e.g. &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;) are not reified in the AST&lt;/li&gt; &#xA; &lt;li&gt;There could be more work on simplification/canonicalization&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Future Work&lt;/h3&gt; &#xA;&lt;p&gt;Since the general problem is exponential, there is likely a lot of future work around chipping away at the margins: heuristics that cover most interesting regular expressions users are interested in.&lt;/p&gt; &#xA;&lt;p&gt;We could add support for other kinds of generators and test frameworks (e.g. Hedgehog, Scalaprops, etc.)&lt;/p&gt; &#xA;&lt;p&gt;We could add predefined character classes (e.g. &lt;code&gt;\w&lt;/code&gt; from PCRE or &lt;code&gt;[:digit:]&lt;/code&gt; from POSIX). It&#39;s fairly straightforward to add support for reading these, but a bit tricker figuring out when to emit them.&lt;/p&gt; &#xA;&lt;p&gt;There is room for improvement of the automata implementations (particularly &lt;code&gt;antimirov.NFA&lt;/code&gt;). Relatedly, we could add support for searching instead of just matching.&lt;/p&gt; &#xA;&lt;p&gt;There is major room for improvement for the HTML/JS tool (the current version was optimized for what was easy for the author to produce).&lt;/p&gt; &#xA;&lt;p&gt;Additionally, we could provide an interactive/command-line tool to help work with regular expressions (potentially using Graal or Scala Native to produce a native executable).&lt;/p&gt; &#xA;&lt;p&gt;It would be interesting to see how many of Antimirov&#39;s features we would have to give up to add support for extracting subgroup matches.&lt;/p&gt; &#xA;&lt;h3&gt;Copyright and License&lt;/h3&gt; &#xA;&lt;p&gt;All code is available to you under the Apache 2 license, available at &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;https://opensource.org/licenses/Apache-2.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Copyright Erik Osheim, 2020.&lt;/p&gt;</summary>
  </entry>
</feed>