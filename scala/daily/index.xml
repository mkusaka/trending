<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-13T01:36:59Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>oyvindberg/tui-scala</title>
    <updated>2022-12-13T01:36:59Z</updated>
    <id>tag:github.com,2022-12-13:/oyvindberg/tui-scala</id>
    <link href="https://github.com/oyvindberg/tui-scala" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;tui-scala&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-scala/actions?query=workflow%3ACI+&#34;&gt;&lt;img src=&#34;https://github.com/oyvindberg/tui-scala/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/247937/206300852-9afab78b-5705-4241-bef1-f841bf5d42cc.mp4&#34;&gt;https://user-images.githubusercontent.com/247937/206300852-9afab78b-5705-4241-bef1-f841bf5d42cc.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;tui-scala&lt;/code&gt; is a &lt;a href=&#34;https://www.scala-lang.org&#34;&gt;Scala&lt;/a&gt; library to build rich terminal user interfaces and dashboards. It is a port of &lt;a href=&#34;https://github.com/fdehau/tui-rs&#34;&gt;tui-rs&lt;/a&gt;, which is heavily inspired by the &lt;code&gt;Javascript&lt;/code&gt; library &lt;a href=&#34;https://github.com/yaronn/blessed-contrib&#34;&gt;blessed-contrib&lt;/a&gt; and the &lt;code&gt;Go&lt;/code&gt; library &lt;a href=&#34;https://github.com/gizak/termui&#34;&gt;termui&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;The port is not yet complete, see &lt;a href=&#34;https://github.com/oyvindberg/tui-scala/issues/15&#34;&gt;roadmap&lt;/a&gt; for immediate plans. There are &lt;a href=&#34;https://github.com/oyvindberg/tui-scala/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22&#34;&gt;bite-sized&lt;/a&gt; tasks to complete if you want to contribute!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The library uses &lt;a href=&#34;https://github.com/crossterm-rs/crossterm&#34;&gt;crossterm&lt;/a&gt; as a backend. &lt;code&gt;crossterm&lt;/code&gt; handles differences between platforms, so everything should work on major operating systems, including windows.&lt;/p&gt; &#xA;&lt;p&gt;The integration with &lt;code&gt;crossterm&lt;/code&gt; is published separately as a Java artifact, which calls native rust code through JNI. This integration works both when running on the JVM and when running as GraalVM native image.&lt;/p&gt; &#xA;&lt;p&gt;The library is based on the principle of immediate rendering with intermediate buffers. This means that at each new frame you should build all widgets that are supposed to be part of the UI. While providing a great flexibility for rich and interactive UI, this may introduce overhead for highly dynamic content. So, the implementation try to minimize the number of ansi escapes sequences generated to draw the updated UI. In practice, given the speed of the JVM the overhead rather comes from the terminal emulator than the library itself.&lt;/p&gt; &#xA;&lt;p&gt;Moreover, the library does not provide any input handling nor any event system, and you may rely on &lt;code&gt;crossterm&lt;/code&gt; achieve such features.&lt;/p&gt; &#xA;&lt;h3&gt;Widgets&lt;/h3&gt; &#xA;&lt;p&gt;The library comes with a bunch of widgets: here is some example code:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/barchart.scala&#34;&gt;BarChart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/block.scala&#34;&gt;Block&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/canvas.scala&#34;&gt;Canvas (with line, point cloud, world map)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/chart.scala&#34;&gt;Chart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/custom_widget.scala&#34;&gt;Custom widget&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/gauge.scala&#34;&gt;Gauge&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/layout.scala&#34;&gt;Layout&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/list.scala&#34;&gt;List&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/paragraph.scala&#34;&gt;Paragraph&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/popup.scala&#34;&gt;Popup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/sparkline.scala&#34;&gt;Sparkline&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/table.scala&#34;&gt;Table&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/tabs.scala&#34;&gt;Tabs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyvindberg/tui-rs/raw/master/examples/user_input.scala&#34;&gt;User input&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Click on each item to see the source of the example. Run the examples with bleep (e.g. to run the barchart example &lt;code&gt;bleep run demo@jvm213 barchart&lt;/code&gt;), and quit by pressing &lt;code&gt;q&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;For sbt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  libraryDependencies += &#34;com.olvind.tui&#34; %% &#34;tui&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you only want &lt;code&gt;crossterm&lt;/code&gt; to do low-level things, or if you want to experiment with making a TUI, these are the coordinates:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  libraryDependencies += &#34;com.olvind.tui&#34; % &#34;crossterm&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then copy/paste one of the demos above to get started.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s cross published for scala 2.13 and 3. Note that scala 3 won&#39;t work with graalvm native image until 3.3.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll need a recent JVM with support for sealed interfaces and records. likely 18.&lt;/p&gt; &#xA;&lt;h3&gt;Contributing/building&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/oyvindberg/tui-scala/master/contributing.md&#34;&gt;contributing&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>plokhotnyuk/jsoniter-scala</title>
    <updated>2022-12-13T01:36:59Z</updated>
    <id>tag:github.com,2022-12-13:/plokhotnyuk/jsoniter-scala</id>
    <link href="https://github.com/plokhotnyuk/jsoniter-scala" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scala macros for compile-time generation of safe and ultra-fast JSON codecs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;jsoniter-scala&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/actions&#34;&gt;&lt;img src=&#34;https://github.com/plokhotnyuk/jsoniter-scala/workflows/build/badge.svg?sanitize=true&#34; alt=&#34;Actions Build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://scala-steward.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Scala_Steward-helping-brightgreen.svg?style=flat&amp;amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAMAAAARSr4IAAAAVFBMVEUAAACHjojlOy5NWlrKzcYRKjGFjIbp293YycuLa3pYY2LSqql4f3pCUFTgSjNodYRmcXUsPD/NTTbjRS+2jomhgnzNc223cGvZS0HaSD0XLjbaSjElhIr+AAAAAXRSTlMAQObYZgAAAHlJREFUCNdNyosOwyAIhWHAQS1Vt7a77/3fcxxdmv0xwmckutAR1nkm4ggbyEcg/wWmlGLDAA3oL50xi6fk5ffZ3E2E3QfZDCcCN2YtbEWZt+Drc6u6rlqv7Uk0LdKqqr5rk2UCRXOk0vmQKGfc94nOJyQjouF9H/wCc9gECEYfONoAAAAASUVORK5CYII=&#34; alt=&#34;Scala Steward&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/plokhotnyuk/jsoniter-scala?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Join%20Chat.svg?sanitize=true&#34; alt=&#34;Gitter Chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://repo1.maven.org/maven2/com/github/plokhotnyuk/jsoniter-scala/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/maven--central-2.19.1-blue.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Scala macros for compile-time generation of safe and ultra-fast JSON codecs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://plokhotnyuk.github.io/jsoniter-scala/&#34;&gt;&lt;strong&gt;Latest results of benchmarks on JVMs&lt;/strong&gt;&lt;/a&gt; that compare parsing and serialization performance of jsoniter-scala with: &lt;a href=&#34;https://github.com/sirthias/borer&#34;&gt;Borer&lt;/a&gt;, &lt;a href=&#34;https://github.com/circe/circe&#34;&gt;Circe&lt;/a&gt;, &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/tree/master/jsoniter-scala-circe&#34;&gt;Circe with jsoniter-scala booster&lt;/a&gt;, &lt;a href=&#34;https://github.com/FasterXML/jackson-module-scala&#34;&gt;jackson-module-scala&lt;/a&gt;, &lt;a href=&#34;https://github.com/json4s/json4s/tree/master/jackson&#34;&gt;json4s.jackson&lt;/a&gt;, &lt;a href=&#34;https://github.com/json4s/json4s/tree/master/native&#34;&gt;json4s.native&lt;/a&gt;, &lt;a href=&#34;https://github.com/playframework/play-json&#34;&gt;Play-JSON&lt;/a&gt;, &lt;a href=&#34;https://github.com/disneystreaming/smithy4s/tree/main/modules/json&#34;&gt;smithy4s-json&lt;/a&gt;, &lt;a href=&#34;https://github.com/spray/spray-json&#34;&gt;Spray-JSON&lt;/a&gt;, &lt;a href=&#34;https://github.com/lihaoyi/upickle&#34;&gt;uPickle&lt;/a&gt;, &lt;a href=&#34;https://github.com/rallyhealth/weePickle&#34;&gt;weePickle&lt;/a&gt;, &lt;a href=&#34;https://github.com/zio/zio-json&#34;&gt;zio-json&lt;/a&gt; libraries using different JDK and GraalVM versions on the following environment: Intel® Core™ i9-11900H CPU @ 2.5GHz (max 4.9GHz), RAM 32Gb DDR4-3200, Ubuntu 22.04, and latest versions of Azul Zulu 11/17, OpenJDK 20&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1IxIvLoLlLb0bxUaRgSsaaRuXV0RUQ3I04vFqhDc2Bt8/edit?usp=sharing&#34;&gt;*&lt;/a&gt;, GraalVM CE 23-dev for Java 17/19, and GraalVM EE 22.3 for Java 11/17/19.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://plokhotnyuk.github.io/jsoniter-scala/index-scalajs.html&#34;&gt;&lt;strong&gt;Latest results of benchmarks on browsers&lt;/strong&gt;&lt;/a&gt; that compares libraries which supports Scala.js on the same environment compiled by Scala.js 1.12.0 to ES 2015 with GCC v20220202 optimizations applied.&lt;/p&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/plokhotnyuk/jsoniter-scala/master/#acknowledgments&#34;&gt;Acknowledgments&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/plokhotnyuk/jsoniter-scala/master/#goals&#34;&gt;Goals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/plokhotnyuk/jsoniter-scala/master/#features-and-limitations&#34;&gt;Features and limitations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/plokhotnyuk/jsoniter-scala/master/#how-to-use&#34;&gt;&lt;strong&gt;How to use&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/plokhotnyuk/jsoniter-scala/master/#known-issues&#34;&gt;Known issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/plokhotnyuk/jsoniter-scala/master/#how-to-develop&#34;&gt;How to develop&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;This library had started from macros that reused &lt;a href=&#34;https://github.com/json-iterator/java&#34;&gt;jsoniter (json-iterator) for Java&lt;/a&gt; reader and writer but then the library evolved to have its own core of mechanics for parsing and serialization.&lt;/p&gt; &#xA;&lt;p&gt;The idea to generate codecs by Scala macros and main details were borrowed from &lt;a href=&#34;https://github.com/evolution-gaming/kryo-macros&#34;&gt;Kryo Macros&lt;/a&gt; and adapted for the needs of the JSON domain.&lt;/p&gt; &#xA;&lt;p&gt;Other Scala macros features were peeped in &lt;a href=&#34;https://github.com/AVSystem/scala-commons/tree/master/commons-macros/src/main/scala/com/avsystem/commons/macros&#34;&gt;AVSystem Commons&lt;/a&gt; and &lt;a href=&#34;https://github.com/softwaremill/magnolia&#34;&gt;magnolia&lt;/a&gt; libraries.&lt;/p&gt; &#xA;&lt;p&gt;Ideas for the most efficient parsing and serialization of &lt;code&gt;java.time.*&lt;/code&gt; values were inspired by &lt;a href=&#34;https://github.com/ngs-doo/dsl-json&#34;&gt;DSL-JSON&lt;/a&gt;&#39;s implementation for &lt;code&gt;java.time.OffsetDateTime&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Other projects and a blog post that have helped deliver unparalleled safety and performance characteristics for parsing and serialization of numbers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/c4f7fcce9cb06515/Schubfach/&#34;&gt;Schubfach&lt;/a&gt; - the most efficient and concise way to serialize doubles and floats to the textual representation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Alexhuszagh/rust-lexical&#34;&gt;rust-lexical&lt;/a&gt; - the most efficient way to parse floats and doubles from the textual representation precisely&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/eobermuhlner/big-math&#34;&gt;big-math&lt;/a&gt; - parsing of &lt;code&gt;BigInt&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; values with the &lt;code&gt;O(n^1.5)&lt;/code&gt; complexity instead of &lt;code&gt;O(n^2)&lt;/code&gt; using Java&#39;s implementations where &lt;code&gt;n&lt;/code&gt; is a number of digits&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jk-jeon.github.io/posts/2022/02/jeaiii-algorithm/&#34;&gt;James Anhalt&#39;s algorithm&lt;/a&gt; - the ingenious algorithm for printing integers into decimal strings&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A bunch of SWAR technique tricks for JVM platform are based on following projects and a blog post:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sirthias/borer/raw/fde9d1ce674d151b0fee1dd0c2565020c3f6633a/core/src/main/scala/io/bullet/borer/json/JsonParser.scala#L456&#34;&gt;borer&lt;/a&gt; - the fast parsing of JSON strings by 8-byte words&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/simdjson/simdjson/raw/7e1893db428936e13457ba0e9a5aac0cdfb7bc15/include/simdjson/generic/numberparsing.h#L344&#34;&gt;simdjson&lt;/a&gt; - the fast checking of string for digits by 8-byte words&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wrandelshofer/FastDoubleParser/raw/0903817a765b25e654f02a5a9d4f1476c98a80c9/src/main/java/ch.randelshofer.fastdoubleparser/ch/randelshofer/fastdoubleparser/FastDoubleSimd.java#L114-L130&#34;&gt;FastDoubleParser&lt;/a&gt; - the fast parsing of numbers by 8-byte words&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://johnnylee-sde.github.io/Fast-time-string-to-seconds/&#34;&gt;Johnny Lee&#39;s article&lt;/a&gt; - the fast time string to seconds conversion&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Safety&lt;/strong&gt;: validate parsed values safely with the fail-fast approach and clear reporting, provide configurable limits for suboptimal data structures with safe defaults to be resilient for DoS attacks, generate codecs that create instances of a &lt;em&gt;fixed&lt;/em&gt; set of classes during parsing to avoid RCE attacks&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Correctness&lt;/strong&gt;: support the latest JSON format (RFC-8259), do not replace illegally encoded characters of string values by placeholder characters, parse numbers with limited binary representation doing half even rounding for too long JSON numbers, serialize floats and doubles to the &lt;em&gt;shortest&lt;/em&gt; textual representation without loosing of precision&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Speed&lt;/strong&gt;: do parsing and serialization of JSON directly from UTF-8 bytes to your data structures and back, do it crazily fast without using of runtime reflection or runtime code generation, intermediate ASTs, hash maps, but with minimum allocations and copying&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Productivity&lt;/strong&gt;: derive codecs recursively for complex types using one line macro, do it in &lt;em&gt;compile-time&lt;/em&gt; to minimize the probability of run-time issues, optionally print generated sources as compiler output to be inspected for proving safety and correctness or to be reused as a starting point for the implementation of custom codecs, prohibit serializing of &lt;code&gt;null&lt;/code&gt; Scala values and parsing immediately to them in generated codecs&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ergonomics&lt;/strong&gt;: have preconfigured defaults for the safest and common usage that can be easily altered by compile- and run-time configuration instances, combined with compile-time annotations and implicits, embrace the textual representation of JSON providing a pretty printing option, provide a hex dump in the error message to speed up the view of an error context&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The library targets JDK 11+ and GraalVM 22+ (including compilation to native images) without any platform restrictions.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/releases/tag/v2.13.5.2&#34;&gt;&lt;strong&gt;v2.13.5.2&lt;/strong&gt;&lt;/a&gt; release is the last version that supports JDK 8+ and native image compilation with earlier versions of GraalVM.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/releases/tag/v2.13.5.2&#34;&gt;&lt;strong&gt;v2.13.3.2&lt;/strong&gt;&lt;/a&gt; release is the last version that supports Scala 2.11.&lt;/p&gt; &#xA;&lt;h2&gt;Features and limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;JSON parsing from &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Array[Byte]&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, &lt;code&gt;java.io.InputStream&lt;/code&gt;/&lt;code&gt;java.io.FileInputStream&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;JSON serialization to &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Array[Byte]&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, &lt;code&gt;java.io.OutputStream&lt;/code&gt;/&lt;code&gt;java.io.FileOutputStream&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Support of parsing from or writing to part of &lt;code&gt;Array[Byte]&lt;/code&gt; or &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt; by specifying of position and limit&lt;/li&gt; &#xA; &lt;li&gt;Parsing of streaming JSON values and JSON arrays from &lt;code&gt;java.io.InputStream&lt;/code&gt;/&lt;code&gt;java.io.FileInputStream&lt;/code&gt; without the need of holding all input and parsed values in the memory&lt;/li&gt; &#xA; &lt;li&gt;Only UTF-8 encoding is supported when working with buffered bytes directly but there is a fallback to parse and serialize JSON from/to &lt;code&gt;String&lt;/code&gt; (while this is much less efficient)&lt;/li&gt; &#xA; &lt;li&gt;Parsing of strings with escaped characters for JSON keys and string values&lt;/li&gt; &#xA; &lt;li&gt;Codecs can be generated for primitives, boxed primitives, enums, tuples, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;BigInt&lt;/code&gt;, &lt;code&gt;BigDecimal&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt;, &lt;code&gt;Either&lt;/code&gt;, &lt;code&gt;java.util.UUID&lt;/code&gt;, &lt;code&gt;java.time.*&lt;/code&gt; (to/from ISO-8601 representation only), Scala collections, arrays, module classes, literal types, value classes, and case classes with values/fields having any of types listed here&lt;/li&gt; &#xA; &lt;li&gt;Classes should be defined with a primary constructor that hasn&#39;t defined default values in non-first parameter lists&lt;/li&gt; &#xA; &lt;li&gt;Non-case Scala classes also supported, but they should have getter accessors for all arguments of a primary constructor&lt;/li&gt; &#xA; &lt;li&gt;Types that supported as map keys are primitives, boxed primitives, enums, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;BigInt&lt;/code&gt;, &lt;code&gt;BigDecimal&lt;/code&gt;, &lt;code&gt;java.util.UUID&lt;/code&gt;, &lt;code&gt;java.time.*&lt;/code&gt;, literal types, and value classes for any of them&lt;/li&gt; &#xA; &lt;li&gt;Codecs for sorted maps and sets can be customized by implicit &lt;code&gt;Ordering[K]&lt;/code&gt; instances for keys that are available at the scope of the &lt;code&gt;make&lt;/code&gt; macro call&lt;/li&gt; &#xA; &lt;li&gt;Core module support reading and writing byte arrays from/to Base16 and Base64 representations (RFC 4648) for using in custom codecs&lt;/li&gt; &#xA; &lt;li&gt;Parsing of escaped characters is not supported for strings which are mapped to byte arrays, numeric and &lt;code&gt;java.time.*&lt;/code&gt; types&lt;/li&gt; &#xA; &lt;li&gt;Support of first-order and higher-kind types&lt;/li&gt; &#xA; &lt;li&gt;Support of 2 representations of ADTs with a sealed trait or a Scala class as a base type and non-abstract Scala classes or objects as leaf classes: 1st representation uses discriminator field with string type of value, 2nd one uses string values for objects and a wrapper JSON object with a discriminator key for case class instances&lt;/li&gt; &#xA; &lt;li&gt;Implicitly resolvable value codecs for JSON values and key codecs for JSON object keys that are mapped to maps allows to inject your custom codecs for adding support of other types or for altering representation in JSON for already supported classes&lt;/li&gt; &#xA; &lt;li&gt;Type aliases are supported for all types mentioned above&lt;/li&gt; &#xA; &lt;li&gt;Only acyclic graphs of class instances are supported by generated codecs&lt;/li&gt; &#xA; &lt;li&gt;Order of instance fields is preserved during serialization for generated codecs&lt;/li&gt; &#xA; &lt;li&gt;Throws a parsing exception if duplicated keys were detected for a class instance (except maps)&lt;/li&gt; &#xA; &lt;li&gt;Serialization of &lt;code&gt;null&lt;/code&gt; values is prohibited by throwing of &lt;code&gt;NullPointerException&lt;/code&gt; errors&lt;/li&gt; &#xA; &lt;li&gt;Parsing of &lt;code&gt;null&lt;/code&gt; values allowed only for optional of collection types (that means the &lt;code&gt;None&lt;/code&gt; value or an empty collection accordingly) and for fields which have defined non-null default values&lt;/li&gt; &#xA; &lt;li&gt;Fields with default values that defined in the constructor are optional, other fields are required (no special annotation required)&lt;/li&gt; &#xA; &lt;li&gt;Fields with values that are equals to default values, or are empty options/collections/arrays are not serialized to provide a sparse output&lt;/li&gt; &#xA; &lt;li&gt;Any values that used directly or as part of default values of the constructor parameters should have right implementations of the &lt;code&gt;equals&lt;/code&gt; method (it mostly concerns non-case classes or other types that have custom codecs)&lt;/li&gt; &#xA; &lt;li&gt;Fields can be annotated as transient or just not defined in the constructor to avoid parsing and serializing at all&lt;/li&gt; &#xA; &lt;li&gt;Field names can be overridden for serialization/parsing by field annotation in the primary constructor of classes&lt;/li&gt; &#xA; &lt;li&gt;Reading and writing of any arbitrary bytes or raw values are possible by using custom codecs&lt;/li&gt; &#xA; &lt;li&gt;Parsing exception always reports a hexadecimal offset of &lt;code&gt;Array[Byte]&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, &lt;code&gt;java.io.InputStream&lt;/code&gt;/ &lt;code&gt;java.io.FileInputStream&lt;/code&gt; where it occurs, and an optional hex dump affected by error part of an internal byte buffer&lt;/li&gt; &#xA; &lt;li&gt;Configurable by field annotation ability to read/write numeric fields from/to string values&lt;/li&gt; &#xA; &lt;li&gt;Both key and value codecs are specialized to work with primitives efficiently without boxing/unboxing&lt;/li&gt; &#xA; &lt;li&gt;No extra buffering is required when parsing from &lt;code&gt;java.io.InputStream&lt;/code&gt;/&lt;code&gt;java.io.FileInputStream&lt;/code&gt; or serializing to &lt;code&gt;java.io.OutputStream&lt;/code&gt;/&lt;code&gt;java.io.FileOuputStream&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Using black box macros only for codec generation ensures that your types will never be changed&lt;/li&gt; &#xA; &lt;li&gt;Ability to print generated code for codecs using an implicit val of &lt;code&gt;CodecMakerConfig.PrintCodec&lt;/code&gt; type in a scope of codec derivation&lt;/li&gt; &#xA; &lt;li&gt;No dependencies on extra libraries in &lt;em&gt;runtime&lt;/em&gt; excluding Scala&#39;s &lt;code&gt;scala-library&lt;/code&gt; (all platforms) and &lt;code&gt;scala-java-time&lt;/code&gt; (replacement of JDKs &lt;code&gt;java.time._&lt;/code&gt; types for Scala.js and Scala Native)&lt;/li&gt; &#xA; &lt;li&gt;Codecs and runtime configurations implement &lt;code&gt;java.io.Serializable&lt;/code&gt; for easier usage in distributive computing&lt;/li&gt; &#xA; &lt;li&gt;Support of shading to another package for locking on a particular released version&lt;/li&gt; &#xA; &lt;li&gt;Patch versions are backward and forward compatible, minor versions are backward compatible&lt;/li&gt; &#xA; &lt;li&gt;Support of compilation to a native image by GraalVM&lt;/li&gt; &#xA; &lt;li&gt;Integration with circe for faster parsing/serialization and decoding/encoding to/from circe AST&lt;/li&gt; &#xA; &lt;li&gt;Releases for different Scala versions: 2.12, 2.13, and 3.2&lt;/li&gt; &#xA; &lt;li&gt;Support of Scala.js 1.0+ for all supported Scala versions&lt;/li&gt; &#xA; &lt;li&gt;Support of Scala Native 0.4.4+ for all supported Scala versions and all modules except jsoniter-scala-circe&lt;/li&gt; &#xA; &lt;li&gt;Suppressing of all WartRemover warnings of generated codecs for Scala 2.12 and 2.13&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are configurable options that can be set in compile-time:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ability to read/write numbers from/to string values&lt;/li&gt; &#xA; &lt;li&gt;Skipping of unexpected fields or throwing of parse exceptions&lt;/li&gt; &#xA; &lt;li&gt;Skipping of serialization of fields that have empty collection values can be turned off to force serialization of them&lt;/li&gt; &#xA; &lt;li&gt;Skipping of serialization of fields that have empty optional values can be turned off to force serialization of them&lt;/li&gt; &#xA; &lt;li&gt;Skipping of serialization of fields which values are matched with defaults that are defined in the primary constructor can be turned off to force serialization of that values&lt;/li&gt; &#xA; &lt;li&gt;Ability to override names of classes of ADTs and fields using a compile-time annotation&lt;/li&gt; &#xA; &lt;li&gt;Mapping functions from names of classes and their fields to JSON keys or from names of Java enumeration values to JSON strings and back, including predefined functions which enforce snake_case, kebab-case, camelCase or PascalCase names for all fields in the generated codec&lt;/li&gt; &#xA; &lt;li&gt;An optional name of the discriminator field for ADTs&lt;/li&gt; &#xA; &lt;li&gt;Mapping function for values of a discriminator field that is used for distinguishing classes of ADTs&lt;/li&gt; &#xA; &lt;li&gt;Ability to set a precision, a scale limit, and the max number of significant digits when parsing &lt;code&gt;BigDecimal&lt;/code&gt; values&lt;/li&gt; &#xA; &lt;li&gt;Ability to set the max number of significant digits when parsing &lt;code&gt;BigInt&lt;/code&gt; values&lt;/li&gt; &#xA; &lt;li&gt;Ability to set the max allowed value when parsing bit sets&lt;/li&gt; &#xA; &lt;li&gt;Ability to set the limit for the number of inserts when parsing sets or maps&lt;/li&gt; &#xA; &lt;li&gt;Throwing of a compilation error for recursive data structures can be turned off&lt;/li&gt; &#xA; &lt;li&gt;Throwing of a runtime error when the discriminator is not the first field can be turned off&lt;/li&gt; &#xA; &lt;li&gt;Ability to parse/serialize Scala enumeration from/to id numbers&lt;/li&gt; &#xA; &lt;li&gt;Ability to derive codecs that can distinguish &lt;code&gt;null&lt;/code&gt; field values and missing fields as &lt;code&gt;Some(None)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; values of &lt;code&gt;Option[Option[_]]&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;List of options that change parsing and serialization in runtime:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Serialization of strings with escaped Unicode characters to be ASCII compatible&lt;/li&gt; &#xA; &lt;li&gt;Indenting of output and its step&lt;/li&gt; &#xA; &lt;li&gt;Throwing of stack-less parsing exceptions by default to greatly reduce the impact on performance, while stack traces can be turned on in development for debugging&lt;/li&gt; &#xA; &lt;li&gt;Turning off hex dumping affected by error part of an internal byte buffer to reduce the impact on performance&lt;/li&gt; &#xA; &lt;li&gt;Size of the hex dump can be adjusted for bigger or smaller number of 16-byte lines&lt;/li&gt; &#xA; &lt;li&gt;Max size of internal input buffers when parsing from &lt;code&gt;java.io.InputStream&lt;/code&gt; or &lt;code&gt;java.nio.DirectByteBuffer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Preferred size of internal input buffers when parsing from &lt;code&gt;java.io.InputStream&lt;/code&gt; or &lt;code&gt;java.nio.DirectByteBuffer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Preferred size of internal output buffers when serializing to &lt;code&gt;java.io.OutputStream&lt;/code&gt; or &lt;code&gt;java.nio.DirectByteBuffer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Max size of char buffers when parsing string values&lt;/li&gt; &#xA; &lt;li&gt;Preferred size of char buffers when parsing string values&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For upcoming features and fixes see &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/commits/master&#34;&gt;Commits&lt;/a&gt; and &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/issues&#34;&gt;Issues page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s assume that you have the following data structures:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Device(id: Int, model: String)&#xA;&#xA;case class User(name: String, devices: Seq[Device])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add the core library with a &#34;compile&#34; scope and the macros library with &#34;compile-internal&#34; or &#34;provided&#34; scopes to your list of dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sbt&#34;&gt;libraryDependencies ++= Seq(&#xA;  // Use the %%% operator instead of %% for Scala.js and Scala Native &#xA;  &#34;com.github.plokhotnyuk.jsoniter-scala&#34; %% &#34;jsoniter-scala-core&#34;   % &#34;2.19.1&#34;,&#xA;  // Use the &#34;provided&#34; scope instead when the &#34;compile-internal&#34; scope is not supported  &#xA;  &#34;com.github.plokhotnyuk.jsoniter-scala&#34; %% &#34;jsoniter-scala-macros&#34; % &#34;2.19.1&#34; % &#34;compile-internal&#34;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Derive a codec for the top-level type that need to be parsed or serialized:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.github.plokhotnyuk.jsoniter_scala.macros._&#xA;import com.github.plokhotnyuk.jsoniter_scala.core._&#xA;&#xA;given codec: JsonValueCodec[User] = JsonCodecMaker.make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! You have generated an instance of &lt;code&gt;com.github.plokhotnyuk.jsoniter_scala.core.JsonValueCodec&lt;/code&gt; for the whole nested data structure. No need to derive intemendiate codecs if you use the default or the same derivation configuration for them.&lt;/p&gt; &#xA;&lt;p&gt;Now use it for parsing and serialization:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val user = readFromArray(&#34;&#34;&#34;{&#34;name&#34;:&#34;John&#34;,&#34;devices&#34;:[{&#34;id&#34;:1,&#34;model&#34;:&#34;HTC One X&#34;}]}&#34;&#34;&#34;.getBytes(&#34;UTF-8&#34;))&#xA;val json = writeToArray(User(name = &#34;John&#34;, devices = Seq(Device(id = 2, model = &#34;iPhone X&#34;))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To print generated code for codecs add the following line to the scope of the codec derivation before &lt;code&gt;make&lt;/code&gt; call.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;given CodecMakerConfig.PrintCodec with {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Full code of this &lt;code&gt;How to&lt;/code&gt; section see in the &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/raw/master/jsoniter-scala-examples/src/main/scala/com/github/plokhotnyuk/jsoniter_scala/examples/Example01.scala&#34;&gt;examples&lt;/a&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;Also, you can use the following on-line services to generate an initial version of your data structures from JSON samples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://json2caseclass.cleverapps.io/&#34;&gt;json2caseclass&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://transform.now.sh/json-to-scala-case-class/&#34;&gt;json-to-scala-case-class&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://chadselph.github.io/json2classes/&#34;&gt;json2classes&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more use cases, please, check out tests:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/raw/master/jsoniter-scala-macros/shared/src/test/scala/com/github/plokhotnyuk/jsoniter_scala/macros/JsonCodecMakerSpec.scala&#34;&gt;JsonCodecMakerSpec&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/raw/master/jsoniter-scala-core/shared/src/test/scala/com/github/plokhotnyuk/jsoniter_scala/core/PackageSpec.scala&#34;&gt;PackageSpec&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/raw/master/jsoniter-scala-core/shared/src/test/scala/com/github/plokhotnyuk/jsoniter_scala/core/JsonReaderSpec.scala&#34;&gt;JsonReaderSpec&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/raw/master/jsoniter-scala-core/shared/src/test/scala/com/github/plokhotnyuk/jsoniter_scala/core/JsonWriterSpec.scala&#34;&gt;JsonWriterSpec&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Samples for integration with different web frameworks and HTTP servers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hseeberger/akka-http-json/raw/master/akka-http-jsoniter-scala/src/test/scala/de/heikoseeberger/akkahttpjsoniterscala/ExampleApp.scala&#34;&gt;akka-http&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/TechEmpower/FrameworkBenchmarks/raw/b3a39dcd95b207cd2509d7bbf873a0dfb91097f5/frameworks/Scala/blaze/src/main/scala/Main.scala&#34;&gt;blaze&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/TechEmpower/FrameworkBenchmarks/raw/b3a39dcd95b207cd2509d7bbf873a0dfb91097f5/frameworks/Scala/colossus/src/main/scala/example/Main.scala&#34;&gt;colossus&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/TechEmpower/FrameworkBenchmarks/raw/d1f960b2d4d6ea7b5c30a3ef2a8b47670f346f1c/frameworks/Scala/http4s/src/main/scala/WebServer.scala&#34;&gt;http4s&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/plokhotnyuk/play/tree/master/src/main/scala/microservice&#34;&gt;Play (with Netty native transport)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/TechEmpower/FrameworkBenchmarks/raw/master/frameworks/Scala/youi/src/main/scala/example/Main.scala&#34;&gt;youi&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/TechEmpower/FrameworkBenchmarks/raw/master/frameworks/Scala/zio-http/src/main/scala/Main.scala&#34;&gt;zio-http&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Other usages of jsoniter-scala:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/tree/master/jsoniter-scala-circe&#34;&gt;jsoniter-scala-circe&lt;/a&gt; - the circe booster for faster parsing/serialization to/form circe AST and decoding/encoding of &lt;code&gt;java.time._&lt;/code&gt; and &lt;code&gt;BigInt&lt;/code&gt; types.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jvican/dijon&#34;&gt;dijon&lt;/a&gt; - support of schema-less JSON using safe and efficient AST representation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/evolution-gaming/play-json-tools&#34;&gt;play-json-jsoniter&lt;/a&gt; - provides the fastest way to convert an instance of &lt;code&gt;play.api.libs.json.JsValue&lt;/code&gt; to byte array (or byte buffer, or output stream) and read it back&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/disneystreaming/smithy4s&#34;&gt;smithy4s-json&lt;/a&gt; - JSON protocol of &lt;a href=&#34;https://awslabs.github.io/smithy/&#34;&gt;Smithy&lt;/a&gt; tooling for Scala&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/stephennancekivell/scalatest-json&#34;&gt;scalatest-json&lt;/a&gt; - Scalatest matchers with appropriate equality and descriptive error messages&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/endpoint/json.html#jsoniter-scala&#34;&gt;tapir&lt;/a&gt; - Typed API descRiptions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also, for usages in other OSS projects see the &lt;code&gt;Dependents&lt;/code&gt; section of &lt;a href=&#34;https://index.scala-lang.org/plokhotnyuk/jsoniter-scala&#34;&gt;peoject&#39;s Scala Index page&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For all dependent projects it is recommended to use &lt;a href=&#34;https://github.com/rtimush/sbt-updates&#34;&gt;sbt-updates plugin&lt;/a&gt; or &lt;a href=&#34;https://github.com/scala-steward&#34;&gt;Scala steward service&lt;/a&gt; to keep up with using of the latest releases.&lt;/p&gt; &#xA;&lt;h2&gt;Known issues&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;There is no validation for the length of JSON representation during parsing.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;So if your system is sensitive for that and can accept untrusted input then avoid parsing with &lt;code&gt;readFromStream&lt;/code&gt; and check the input length for other &lt;code&gt;read...&lt;/code&gt; calls.&lt;/p&gt; &#xA;&lt;p&gt;If you have an input that is an array of values or white-space separate values then consider parsing it by &lt;code&gt;scanJsonArrayFromInputStream&lt;/code&gt; or &lt;code&gt;scanJsonValuesFromInputStream&lt;/code&gt; instead of &lt;code&gt;readFromStream&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;The configuration parameter for the &lt;code&gt;make&lt;/code&gt; macro is evaluated in compile-time. It requires no dependency on other code that uses a result of the macro&#39;s call, otherwise the following compilation error will be reported:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;[error] Cannot evaluate a parameter of the &#39;make&#39; macro call for type &#39;full.name.of.YourType&#39;. It should not depend on&#xA;        code from the same compilation module where the &#39;make&#39; macro is called. Use a separated submodule of the project&#xA;        to compile all such dependencies before their usage for generation of codecs.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sometime Scala 2 compiler can fail to compile the &lt;code&gt;make&lt;/code&gt; macro call with the same error message for the configuration that has not clear dependencies on other code. For those cases workarounds can be simpler than recommended usage of separated submodule:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;use &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;make...&lt;/code&gt; macro calls without parameters&lt;/li&gt; &#xA; &lt;li&gt;isolate the &lt;code&gt;make&lt;/code&gt; macro call in the separated object, like in &lt;a href=&#34;https://github.com/plokhotnyuk/play/pull/5/files&#34;&gt;this PR&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;move jsoniter-scala imports to be local, like &lt;a href=&#34;https://github.com/plokhotnyuk/play/raw/master/src/main/scala/microservice/HelloWorld.scala#L6-L7&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/plokhotnyuk/play/raw/master/src/main/scala/microservice/HelloWorldController.scala#L12&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;use &lt;code&gt;sbt clean compile stage&lt;/code&gt; or &lt;code&gt;sbt clean test stage&lt;/code&gt; instead of just &lt;code&gt;sbt clean stage&lt;/code&gt;, like in &lt;a href=&#34;https://github.com/hochgi/HTTP-stream-exercise/tree/jsoniter-2nd-round&#34;&gt;this repo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;use &lt;code&gt;mill clean&lt;/code&gt; if mill&#39;s native BSP support is used in IntelliJ IDEA&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/issues/551&#34;&gt;Unexpected compiler errors&lt;/a&gt; can happen during compilation of ADT definitions or their derived codecs if they are nested in some classes or functions like &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/commit/db52782e6c426b73efac6c5ecaa4c28c9d128f48&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The workaround is the same for both cases: don&#39;t enclose ADT definitions into outer &lt;em&gt;classes&lt;/em&gt;, &lt;em&gt;traits&lt;/em&gt; or &lt;em&gt;functions&lt;/em&gt;, use the outer &lt;em&gt;object&lt;/em&gt; (not a class) instead.&lt;/p&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Compile-time configuration for &lt;code&gt;make&lt;/code&gt; calls in Scala 3 has limited support of possible expressions for name mapping.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Please use examples of &lt;code&gt;CodecMakerConfig&lt;/code&gt; usage from &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/raw/master/jsoniter-scala-macros/shared/src/test/scala/com/github/plokhotnyuk/jsoniter_scala/macros/JsonCodecMakerSpec.scala&#34;&gt;unit tests&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/issues/923&#34;&gt;Unexpected parsing or serialization errors&lt;/a&gt; can happen for nested parsing or serialization routines when the same instance of &lt;code&gt;JsonReader&lt;/code&gt; or &lt;code&gt;JsonWriter&lt;/code&gt; is reused:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scanJsonValuesFromStream[String](in) { s =&amp;gt;&#xA;  readFromString[String](s)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The workaround is using reentrant parsing or serialization routines for all except the most nested call. That will create a new instance of &lt;code&gt;JsonReader&lt;/code&gt; or &lt;code&gt;JsonWriter&lt;/code&gt; on each reentrant call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scanJsonValuesFromStreamReentrant[String](in) { s =&amp;gt;&#xA;  readFromString[String](s)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;Scala.js doesn&#39;t support Java enums compiled from Java sources, so linking fails with errors like:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;[error] Referring to non-existent class com.github.plokhotnyuk.jsoniter_scala.macros.Level&#xA;[error]   called from private com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMakerSpec.$anonfun$new$24()void&#xA;[error]   called from private com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMakerSpec.$anonfun$new$1()void&#xA;[error]   called from constructor com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMakerSpec.&amp;lt;init&amp;gt;()void&#xA;[error]   called from static constructor com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMakerSpec.&amp;lt;clinit&amp;gt;()void&#xA;[error]   called from core module analyzer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The workaround for Scala 2 is to split sources for JVM and other platforms and use Java enum emulation for Scala.js and Scala Native.&lt;/p&gt; &#xA;&lt;p&gt;Code for JVM:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum Level {&#xA;    HIGH, LOW;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Code for Scala.js and Scala Native:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Level {&#xA;  val HIGH: Level = new Level(&#34;HIGH&#34;, 0)&#xA;  val LOW: Level = new Level(&#34;LOW&#34;, 1)&#xA;  &#xA;  val values: Array[Level] = Array(HIGH, LOW)&#xA;&#xA;  def valueOf(name: String): Level =&#xA;    if (HIGH.name() == name) HIGH&#xA;    else if (LOW.name() == name) LOW&#xA;    else throw new IllegalArgumentException(s&#34;Unrecognized Level name: $name&#34;)&#xA;}&#xA;&#xA;final class Level private (name: String, ordinal: Int) extends Enum[Level](name, ordinal)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Scala 3 the workaround can be the same for all platforms:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;enum Level extends Enum[Level] {&#xA;  case HIGH&#xA;  case LOW&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;7&#34;&gt; &#xA; &lt;li&gt;Scala 3 compiler cannot derive anonymous codecs for generic types with concrete type parameters:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class DeResult[T](isSucceed: Boolean, data: T, message: String)&#xA;case class RootPathFiles(files: List[String])&#xA;&#xA;given JsonValueCodec[DeResult[Option[String]]] = JsonCodecMaker.make&#xA;given JsonValueCodec[DeResult[RootPathFiles]] = JsonCodecMaker.make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Current 3.2.x versions of scalac fail with the duplicating definition error like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[error] 19 |      given JsonValueCodec[DeResult[RootPathFiles]] = JsonCodecMaker.make&#xA;[error]    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#xA;[error]    |given_JsonValueCodec_DeResult is already defined as given instance given_JsonValueCodec_DeResult&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The workaround is using named instances of codecs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;given codecOfDeResult1: JsonValueCodec[DeResult[Option[String]]] = JsonCodecMaker.make&#xA;given codecOfDeResult2: JsonValueCodec[DeResult[RootPathFiles]] = JsonCodecMaker.make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or private type aliases with &lt;code&gt;given&lt;/code&gt; definitions gathered in some trait:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait DeResultCodecs:&#xA;&#xA;  private type DeResult1 = DeResult[Option[String]]&#xA;  private type DeResult2 = DeResult[RootPathFiles]&#xA;&#xA;  given JsonValueCodec[DeResult1] = JsonCodecMaker.make&#xA;  given JsonValueCodec[DeResult2] = JsonCodecMaker.make&#xA;&#xA;end DeResultCodecs&#xA;&#xA;object DeResultCodecs extends DeResultCodecs&#xA;&#xA;import DeResultCodecs.given&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;8&#34;&gt; &#xA; &lt;li&gt;Currently, the &lt;code&gt;JsonCodecMaker.make&lt;/code&gt; call cannot derive codecs for Scala 3 opaque and union types. The workaround is using a custom codec for these types defined with &lt;code&gt;implicit val&lt;/code&gt; before the &lt;code&gt;JsonCodecMaker.make&lt;/code&gt; call, like &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/raw/7da4af1c45e11f3877708ab6d394dad9f92a3766/jsoniter-scala-macros/shared/src/test/scala-3/com/github/plokhotnyuk/jsoniter_scala/macros/JsonCodeMakerNewTypeSpec.scala#L16-L45&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/raw/7da4af1c45e11f3877708ab6d394dad9f92a3766/jsoniter-scala-macros/shared/src/test/scala-3/com/github/plokhotnyuk/jsoniter_scala/macros/JsonCodeMakerNewTypeSpec.scala#L47-L137&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;How to develop&lt;/h2&gt; &#xA;&lt;p&gt;Feel free to ask questions in &lt;a href=&#34;https://gitter.im/plokhotnyuk/jsoniter-scala&#34;&gt;chat&lt;/a&gt;, open issues, or contribute by creating pull requests (fixes and improvements to docs, code, and tests are highly appreciated).&lt;/p&gt; &#xA;&lt;h3&gt;Run tests, check coverage and binary compatibility&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt -java-home /usr/lib/jvm/zulu-11 clean coverage test coverageReport&#xA;sbt -java-home /usr/lib/jvm/zulu-11 clean +test +mimaReportBinaryIssues&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;BEWARE: jsoniter-scala is included into &lt;a href=&#34;https://github.com/scala/community-builds&#34;&gt;Scala Community Build&lt;/a&gt; for Scala 2 and &lt;a href=&#34;https://scala3.westeurope.cloudapp.azure.com/job/runBuild/&#34;&gt;Scala Open Community Build&lt;/a&gt; for Scala 3.&lt;/p&gt; &#xA;&lt;h3&gt;Run JVM benchmarks&lt;/h3&gt; &#xA;&lt;p&gt;Before benchmark running check if your CPU works in &lt;code&gt;performance&lt;/code&gt; mode (not a &lt;code&gt;powersave&lt;/code&gt; one). On Linux use following commands to print current and set the &lt;code&gt;performance&lt;/code&gt; mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&#xA;echo performance | sudo tee /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sbt plugin for JMH tool is used for benchmarking, to see all their features and options please check &lt;a href=&#34;https://github.com/ktoso/sbt-jmh&#34;&gt;Sbt-JMH docs&lt;/a&gt; and &lt;a href=&#34;https://openjdk.java.net/projects/code-tools/jmh/&#34;&gt;JMH tool docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Learn how to write benchmarks in &lt;a href=&#34;https://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&#34;&gt;JMH samples&lt;/a&gt; and JMH articles posted in &lt;a href=&#34;https://shipilev.net/&#34;&gt;Aleksey Shipilёv’s&lt;/a&gt; and &lt;a href=&#34;https://psy-lob-saw.blogspot.com/p/jmh-related-posts.html&#34;&gt;Nitsan Wakart’s&lt;/a&gt; blogs.&lt;/p&gt; &#xA;&lt;p&gt;List of available options can be printed by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt &#39;jsoniter-scala-benchmarkJVM/jmh:run -h&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Results of benchmark can be stored in different formats: *.csv, *.json, etc. All supported formats can be listed by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt &#39;jsoniter-scala-benchmarkJVM/jmh:run -lrf&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JMH allows running benchmarks with different profilers, to get a list of supported use (can require entering of user password):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt &#39;jsoniter-scala-benchmarkJVM/jmh:run -lprof&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Help for profiler options can be printed by following command (&lt;code&gt;&amp;lt;profiler_name&amp;gt;&lt;/code&gt; should be replaced by the name of the supported profiler from the command above):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt &#39;jsoniter-scala-benchmarkJVM/jmh:run -prof &amp;lt;profiler_name&amp;gt;:help&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For parametrized benchmarks the constant value(s) for parameter(s) can be set by &lt;code&gt;-p&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt &#39;jsoniter-scala-benchmarkJVM/jmh:run -p size=1,10,100,1000 ArrayOf.*&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To see throughput with the allocation rate of generated codecs run benchmarks with GC profiler using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt &#39;jsoniter-scala-benchmarkJVM/jmh:run -prof gc .*Reading.*&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Results that are stored in JSON can be easy plotted in &lt;a href=&#34;https://jmh.morethan.io/&#34;&gt;JMH Visualizer&lt;/a&gt; by drugging &amp;amp; dropping of your file to the drop zone or using the &lt;code&gt;source&lt;/code&gt; parameter with an HTTP link to your file in the URL like &lt;a href=&#34;https://jmh.morethan.io/?source=https://plokhotnyuk.github.io/jsoniter-scala/oraclejdk11.json&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On Linux the perf profiler can be used to see CPU event statistics normalized per ops:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt &#39;jsoniter-scala-benchmarkJVM/jmh:run -prof perfnorm TwitterAPIReading.jsoniterScala&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, it can be run with a specified list of events:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt &#39;jsoniter-scala-benchmarkJVM/jmh:run -prof &#34;perfnorm:event=cycles,instructions,ld_blocks_partial.address_alias&#34; TwitterAPIReading.jsoniterScala&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;List of available events for the perf profiler can be retrieved by the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;perf list&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To get a result for some benchmarks with an in-flight recording file from JFR profiler use command like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt &#39;jsoniter-scala-benchmarkJVM/jmh:run -prof &#34;jfr:dir=target/jfr-reports&#34; -wi 10 -i 60 TwitterAPIReading.jsoniterScala&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will get the profile in the &lt;code&gt;jsoniter-scala-benchmark/jvm/target/jfr-reports&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;To run benchmarks with recordings by &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler&#34;&gt;Async profiler&lt;/a&gt;, extract binaries to &lt;code&gt;/opt/async-profiler&lt;/code&gt; directory and use command like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt -java-home /usr/lib/jvm/zulu-17 clean &#39;jsoniter-scala-benchmarkJVM/jmh:run -prof &#34;async:dir=target/async-reports;interval=1000000;output=flamegraph;libPath=/opt/async-profiler/build/libasyncProfiler.so&#34; --p size=128 -wi 5 -i 10 jsoniterScala&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now you can open direct and reverse flame graphs in the &lt;code&gt;jsoniter-scala-benchmark/jvmtarget/async-reports&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;To see list of available events need to start your app or benchmark, and run &lt;code&gt;jps&lt;/code&gt; command. I will show list of PIDs and names for currently running Java processes. While your Java process still running launch the Async Profiler with the &lt;code&gt;list&lt;/code&gt; option and ID of your process like here:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ~/Projects/com/github/jvm-profiling-tools/async-profiler/profiler.sh list 6924&#xA;Basic events:&#xA;  cpu&#xA;  alloc&#xA;  lock&#xA;  wall&#xA;  itimer&#xA;Perf events:&#xA;  page-faults&#xA;  context-switches&#xA;  cycles&#xA;  instructions&#xA;  cache-references&#xA;  cache-misses&#xA;  branches&#xA;  branch-misses&#xA;  bus-cycles&#xA;  L1-dcache-load-misses&#xA;  LLC-load-misses&#xA;  dTLB-load-misses&#xA;  mem:breakpoint&#xA;  trace:tracepoint&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Following command can be used to profile and print assembly code of the hottest methods, but it requires &lt;a href=&#34;https://psy-lob-saw.blogspot.com/2013/01/java-print-assembly.html&#34;&gt;a setup of an additional library to make PrintAssembly feature enabled&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt &#39;jsoniter-scala-benchmarkJVM/jmh:run -prof perfasm -wi 10 -i 10 -p size=128 BigIntReading.jsoniterScala&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More info about extras, options, and ability to generate flame graphs see in &lt;a href=&#34;https://github.com/ktoso/sbt-jmh&#34;&gt;Sbt-JMH docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Other benchmarks with results for jsoniter-scala:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sirthias/borer/pull/30&#34;&gt;comparison&lt;/a&gt; with other JSON parsers for Scala mostly on samples from real APIs, but with mapping to simple types only like strings and primitives and results for GraalVM EE Java8 only&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dkomanov/scala-serialization/pull/8&#34;&gt;comparison&lt;/a&gt; with the best binary parsers and serializers for Scala&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/saint1991/serialization-benchmark&#34;&gt;comparison&lt;/a&gt; with different binary and text serializers for Scala&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tkrs/json-bench&#34;&gt;comparison&lt;/a&gt; with JSON serializers for Scala on synthetic samples&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/yanns/scala-json-parsers-performance&#34;&gt;comparison&lt;/a&gt; with JSON parsers for Scala when parsing from/to a string representation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/guillaumebort/mison/pull/1&#34;&gt;comparison&lt;/a&gt; with a state-of-the-art filter that by &#34;building structural indices converts control flow into data flow, thereby largely eliminating inherently unpredictable branches in the program and exploiting the parallelism available in modern processors&#34;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Run Scala.js benchmarks&lt;/h3&gt; &#xA;&lt;p&gt;Use JDK 11+ for building of &lt;code&gt;jsoniter-scala-benchmarkJS&lt;/code&gt; module:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt -DassemblyJSBenchmarks -java-home /usr/lib/jvm/zulu-11 jsoniter-scala-benchmarkJS/fullOptJS&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then open the list of benchmarks in a browser:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd jsoniter-scala-benchmark/js&#xA;open scala-3-fullopt.html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The released version of Scala.js benchmarks is available &lt;a href=&#34;https://plokhotnyuk.github.io/jsoniter-scala/scala-3-fullopt.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Run compilation time benchmarks&lt;/h3&gt; &#xA;&lt;p&gt;Use the &lt;a href=&#34;https://github.com/stephennancekivell/circe-argonaut-compile-times&#34;&gt;circe-argonaut-compile-times&lt;/a&gt; project to compare compilation time of jsoniter-scala for deeply nested data structures with other JSON parsers like argonaut, play-json, and circe in 3 modes: auto, semi-auto, and derivation.&lt;/p&gt; &#xA;&lt;h3&gt;Publish locally&lt;/h3&gt; &#xA;&lt;p&gt;Publish to local Ivy repo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt clean +publishLocal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Publish to local Maven repo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt clean +publishM2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Release&lt;/h3&gt; &#xA;&lt;p&gt;For version numbering use &lt;a href=&#34;https://docs.scala-lang.org/overviews/core/binary-compatibility-for-library-authors.html#recommended-versioning-scheme&#34;&gt;Recommended Versioning Scheme&lt;/a&gt; that is used in the Scala ecosystem.&lt;/p&gt; &#xA;&lt;p&gt;Double-check binary and source compatibility, including behavior, and release using the following command on the enironment with 16+GB of RAM:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sbt -java-home /usr/lib/jvm/zulu-11 -J-Xmx8g release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Do not push changes to GitHub until promoted artifacts for the new version are not available for downloading on &lt;a href=&#34;https://repo1.maven.org/maven2/com/github/plokhotnyuk/jsoniter-scala&#34;&gt;Maven Central Repository&lt;/a&gt; to avoid binary compatibility check failures in triggered Travis CI builds.&lt;/p&gt; &#xA;&lt;p&gt;The last step is updating of the tag info in a &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/releases&#34;&gt;release list&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>