<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-12T01:40:58Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>soundcloud/cosine-lsh-join-spark</title>
    <updated>2022-11-12T01:40:58Z</updated>
    <id>tag:github.com,2022-11-12:/soundcloud/cosine-lsh-join-spark</id>
    <link href="https://github.com/soundcloud/cosine-lsh-join-spark" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Approximate Nearest Neighbors in Spark&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cosine LSH Join Spark&lt;/h1&gt; &#xA;&lt;p&gt;A spark library for approximate nearest neighbours (ANN).&lt;/p&gt; &#xA;&lt;h1&gt;Background&lt;/h1&gt; &#xA;&lt;p&gt;In many computational problems such as NLP, Recommendation Systems and Search, items (e.g. words) are represented as vectors in a multidimensional space. Then given a specific item it&#39;s nearest neighbours need to be find e.g. given a query find the most similar ones. A naive liner scan over the data set might be too slow for most data sets.&lt;/p&gt; &#xA;&lt;p&gt;Hence, more efficient algorithms are needed. One of the most widely used approaches is Locality Sensitive Hashing (LSH). This family of algorithms are very fast but might not give the exact solution and are hence called approximate nearest neighbours (ANN). The trade off between accuracy and speed is generally set via parameters of the algorithm.&lt;/p&gt; &#xA;&lt;h1&gt;Joiner Interface&lt;/h1&gt; &#xA;&lt;p&gt;This is an interface to find the k nearest neighbors from a data set for every other object in the same data set. Implementations may be either exact or approximate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;trait Joiner {&#xA;    def join(matrix: IndexedRowMatrix): CoordinateMatrix&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;matrix is a row oriented matrix. Each row in the matrix represents an item in the dataset. Items are identified by their matrix index. Returns a similarity matrix with MatrixEntry(itemA, itemB, similarity).&lt;/p&gt; &#xA;&lt;h1&gt;Example&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;// item_a --&amp;gt; (1.0, 1.0, 1.0)&#xA;// item_b --&amp;gt; (2.0, 2.0, 2.0)&#xA;// item_c --&amp;gt; (6.0, 3.0, 2.0)&#xA;&#xA;val rows = Seq(&#xA;  IndexedRow(1, Vectors.dense(1.0, 1.0, 1.0)),&#xA;  IndexedRow(2, Vectors.dense(2.0, 2.0, 2.0)),&#xA;  IndexedRow(5, Vectors.dense(6.0, 3.0, 2.0))&#xA;)&#xA;val matrix = new IndexedRowMatrix(sc.parallelize(rows))&#xA;val similariyMatrix = joiner.join(matrix)&#xA;&#xA;val results = similariyMatrix.entries.map {&#xA;      entry =&amp;gt;&#xA;        &#34;item:%d item:%d cosine:%.2f&#34;.format(entry.i, entry.j, entry.value)&#xA;    }&#xA;&#xA;results.foreach(println)&#xA;&#xA;// above will print:&#xA;// item:2 item:3 cosine:0,87&#xA;// item:1 item:3 cosine:0,87&#xA;// item:1 item:2 cosine:1,00&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please see included &lt;strong&gt;Main.scala&lt;/strong&gt; file for a more detailed example.&lt;/p&gt; &#xA;&lt;h2&gt;Implementations of the joiner interface&lt;/h2&gt; &#xA;&lt;h3&gt;LSH&lt;/h3&gt; &#xA;&lt;p&gt;This is an implementation of the following paper for Spark:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://dl.acm.org/citation.cfm?id=1219917&#34;&gt;Randomized Algorithms and NLP: Using Locality Sensitive Hash Function for High Speed Noun Clustering&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;-- &lt;cite&gt;Ravichandran et al.&lt;/cite&gt;&lt;/p&gt; &#xA;&lt;p&gt;The algorithm determines a set of candidate items in the first stage and only computes the exact cosine similarity for those candidates. It has been succesfully used in production with typical run times of a couple of minutes for millions of items.&lt;/p&gt; &#xA;&lt;p&gt;Note that candidates are ranked by their exact cosine similarity. Hence, this algorithm will not return any false positives (items that the system thinks are nearby but are actually not). Most real world applications require this e.g. in recommendation systems it is ok to return similar items which are almost as good as the exact nearest neighbours but showing false positives would result in senseless recommendations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;val lsh = new Lsh(&#xA;  minCosineSimilarity = 0.5,&#xA;  dimensions = 2,&#xA;  numNeighbours = 3,&#xA;  numPermutations = 1,&#xA;  partitions = 1,&#xA;  storageLevel = StorageLevel.MEMORY_ONLY&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please see the original publication for a detailed description of the parameters.&lt;/p&gt; &#xA;&lt;h3&gt;NearestNeighbours&lt;/h3&gt; &#xA;&lt;p&gt;Brute force method to compute exact nearest neighbours. As this is a very expensive computation O(n^2) an additional sample parameter may be passed such that neighbours are just computed for a random fraction. This interface may be used to tune parameters for approximate solutions on a small subset of data.&lt;/p&gt; &#xA;&lt;h1&gt;QueryJoiner Interface&lt;/h1&gt; &#xA;&lt;p&gt;An interface to find the nearest neighbours in a catalog matrix for each entry in a query matrix. Implementations may be either exact or approximate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;trait QueryJoiner {&#xA;  def join(queryMatrix: IndexedRowMatrix, catalogMatrix: IndexedRowMatrix): CoordinateMatrix&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Implementations of the QueryJoiner Interface&lt;/h2&gt; &#xA;&lt;h3&gt;QueryLsh&lt;/h3&gt; &#xA;&lt;p&gt;Standard Lsh implementation. A query matrix is hashed multiple times and exact hash matches are searched for in a catalog Matrix. These candidates are used to compute the exact cosine distance.&lt;/p&gt; &#xA;&lt;h3&gt;QueryHamming&lt;/h3&gt; &#xA;&lt;p&gt;Implementation based on approximated cosine distances. The cosine distances are approximated using hamming distances which are way faster to compute. The catalog matrix is broadcasted. This implementation is therefore suited for tasks where the catalog matrix is very small compared to the query matrix.&lt;/p&gt; &#xA;&lt;h3&gt;QueryNearestNeighbours&lt;/h3&gt; &#xA;&lt;p&gt;Brute force O(size(query) * size(catalog)) method to compute exact nearest neighbours for rows in the query matrix. As this is a very expensive computation additional sample parameters may be passed such that neighbours are just computed for a random fraction of the data set. This interface may be used to tune parameters for approximate solutions on a small subset of data.&lt;/p&gt; &#xA;&lt;h1&gt;Maven&lt;/h1&gt; &#xA;&lt;p&gt;The artifacts are hosted on Maven Central. For Spark 1.x add the following line to your build.sbt file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;libraryDependencies += &#34;com.soundcloud&#34; % &#34;cosine-lsh-join-spark_2.10&#34; % &#34;0.0.5&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Spark 2.x use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;libraryDependencies += &#34;com.soundcloud&#34; % &#34;cosine-lsh-join-spark_2.10&#34; % &#34;1.0.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or if you&#39;re on scala 2.11.x use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;libraryDependencies += &#34;com.soundcloud&#34; % &#34;cosine-lsh-join-spark_2.11&#34; % &#34;1.0.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Releasing (maintainers only)&lt;/h2&gt; &#xA;&lt;p&gt;In order to release the library using the release plugin &lt;code&gt;sbt release&lt;/code&gt;, you need to set up the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A PGP key in order to sign the package.&lt;/li&gt; &#xA; &lt;li&gt;Register an account on sonatype&#39;s JIRA: &lt;a href=&#34;https://issues.sonatype.org/secure/Signup!default.jspa&#34;&gt;https://issues.sonatype.org/secure/Signup!default.jspa&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Request the right permissions by filing an issue (see for example &lt;a href=&#34;https://issues.sonatype.org/browse/OSSRH-39877&#34;&gt;https://issues.sonatype.org/browse/OSSRH-39877&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Add your credentials to &lt;code&gt;$HOME/.ivy2/.credentials&lt;/code&gt; as explained here: &lt;a href=&#34;https://www.scala-sbt.org/1.x/docs/Publishing.html#Credentials&#34;&gt;https://www.scala-sbt.org/1.x/docs/Publishing.html#Credentials&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run the release command&lt;/li&gt; &#xA; &lt;li&gt;Close and release the staging repository as explained here: &lt;a href=&#34;http://central.sonatype.org/pages/releasing-the-deployment.html&#34;&gt;http://central.sonatype.org/pages/releasing-the-deployment.html&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contributors&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ozgurdemir&#34;&gt;Özgür Demir&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/purzelrakete/&#34;&gt;Rany Keddo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/alexeyrodriguez&#34;&gt;Alexey Rodriguez Yakushev&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/aaronlevin&#34;&gt;Aaron Levin&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>soundcloud/twinagle</title>
    <updated>2022-11-12T01:40:58Z</updated>
    <id>tag:github.com,2022-11-12:/soundcloud/twinagle</id>
    <link href="https://github.com/soundcloud/twinagle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Twinagle = Twirp + Finagle&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Twinagle = Twirp + Finagle&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/soundcloud/twinagle/workflows/Scala%20CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt; &lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/com.soundcloud/twinagle-runtime_2.13&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/com.soundcloud/twinagle-runtime_2.13/badge.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Twinagle is an implementation of the &lt;a href=&#34;https://github.com/twitchtv/twirp/raw/master/PROTOCOL.md&#34;&gt;Twirp wire protocol&lt;/a&gt; for Scala+Finagle.&lt;/p&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://soundcloud.github.io/twinagle&#34;&gt;the documentation website&lt;/a&gt; for an introduction.&lt;/p&gt; &#xA;&lt;h1&gt;How to contribute&lt;/h1&gt; &#xA;&lt;p&gt;Thanks for your interest in Twinagle, we&#39;re welcome your contributions! For larger changes, please open an issue to discuss them before spending lots of time implementing things. For small changes, hack away and submit a pull request.&lt;/p&gt; &#xA;&lt;p&gt;Please ensure that &lt;code&gt;sbt scalafmtCheckAll +test scripted&lt;/code&gt; passes when submitting code changes.&lt;/p&gt; &#xA;&lt;h1&gt;Notes&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;IntelliJ [doesn&#39;t run plugins][intellij] during project build. Before importing, &lt;code&gt;sbt compile&lt;/code&gt; may be necessary.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In order to run the full test suite (i.e. the unit tests &amp;amp; the end-to-end tests for code-generation) use &lt;code&gt;sbt +test scripted&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>lrytz/lambda-impl</title>
    <updated>2022-11-12T01:40:58Z</updated>
    <id>tag:github.com,2022-11-12:/lrytz/lambda-impl</id>
    <link href="https://github.com/lrytz/lambda-impl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
</feed>