<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-18T01:55:56Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Normation/rudder-plugins</title>
    <updated>2022-07-18T01:55:56Z</updated>
    <id>tag:github.com,2022-07-18:/Normation/rudder-plugins</id>
    <link href="https://github.com/Normation/rudder-plugins" rel="alternate"></link>
    <summary type="html">&lt;p&gt;All Rudder public plugins in one repository. Licenses are by-plugin.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rudder-plugins&lt;/h1&gt; &#xA;&lt;div id=&#34;preamble&#34;&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;This is the repository for plugins for Rudder: Continuous configuration for effective compliance.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;&lt;a href=&#34;https://www.rudder-project.org/site/documentation/&#34; class=&#34;bare&#34;&gt;https://www.rudder-project.org/site/documentation/&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_creating_a_new_plugin&#34;&gt;Creating a new plugin&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;If you want to create a new plugin, you can use giter8 (&lt;a href=&#34;http://www.foundweekends.org/giter8/&#34; class=&#34;bare&#34;&gt;http://www.foundweekends.org/giter8/&lt;/a&gt;) on that repository or directly from the file system.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Once &lt;code&gt;g8&lt;/code&gt; command is installed (see &lt;a href=&#34;http://www.foundweekends.org/giter8/setup.html&#34; class=&#34;bare&#34;&gt;http://www.foundweekends.org/giter8/setup.html&lt;/a&gt;), use:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;listingblock&#34;&gt; &#xA;   &lt;div class=&#34;content&#34;&gt; &#xA;    &lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;% g8 file://.&lt;/code&gt;&lt;/pre&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;You can alos use the github resolution:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;listingblock&#34;&gt; &#xA;   &lt;div class=&#34;content&#34;&gt; &#xA;    &lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;% g8 normation/rudder-plugins&lt;/code&gt;&lt;/pre&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;And answer the questions. Only the &lt;code&gt;name&lt;/code&gt; is mandatory: use the plugin short name, with space and capital if you want (see convetion below). Juste hitting &amp;lt;ENTER&amp;gt; choose the default value (the one between []).&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;listingblock&#34;&gt; &#xA;   &lt;div class=&#34;content&#34;&gt; &#xA;    &lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;name [My Plugin]: Node External Reports &amp;lt;ENTER&amp;gt;&#xA;version [1.0 ]: &amp;lt;ENTER&amp;gt;&#xA;title_description [One line description of plugin]: Add external reports in node details&#xA;web_description [&amp;lt;p&amp;gt;HTML description of plugin&amp;lt;/p&amp;gt;]: &amp;lt;p&amp;gt;Add external reports in node details&amp;lt;/p&amp;gt;&#xA;you_should_not_change_following_variables [just hit enter]: &amp;lt;ENTER&amp;gt;&#xA;plugin_name [node-external-reports]: &amp;lt;ENTER&amp;gt;&#xA;plugin_pkg [nodeexternalreports]: &amp;lt;ENTER&amp;gt;&#xA;plugin_class [NodeExternalReports]: &amp;lt;ENTER&amp;gt;&lt;/code&gt;&lt;/pre&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;If you don’t want to use giter8, you can replace by hand the placeholders &lt;code&gt;$plugin_name$&lt;/code&gt;, &lt;code&gt;$plugin_pkg$&lt;/code&gt; and &lt;code&gt;$plugin_class$&lt;/code&gt; using the same convention as the previous example. Be careful to replace them in both file (with &lt;code&gt;sed&lt;/code&gt; for example) and in path (with &lt;code&gt;mv&lt;/code&gt;).&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_repository_structure&#34;&gt;Repository structure&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;The repository is organized with one directory for each plugin under repository root directory.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Each plugin’s root directory is named with the plugin &#34;shortname identifier&#34;, i.e the plugin name minus &#39;rudder-plugin-&#34; prefix.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Each plugin build information are grouped in file &lt;code&gt;build.conf&lt;/code&gt; in plugin root directory.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_branch_versionning_and_compatibility_with_rudder_versions&#34;&gt;Branch versionning and compatibility with Rudder versions&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Plugins are linked to Rudder main version, so we retrieve in &lt;code&gt;rudder-plugins&lt;/code&gt; the same branch structure than in &lt;code&gt;rudder&lt;/code&gt;. Moreover, one needs to always compile and use a plugin for the corresponding Rudder version:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;listingblock&#34;&gt; &#xA;   &lt;div class=&#34;content&#34;&gt; &#xA;    &lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;- master (plugin compatible with Rudder next version, i.e developing branch)&#xA;- branches/rudder/5.0 (plugins compatible with Rudder 5.0)&#xA;- branches/rudder/5.1 (plugins compatible with Rudder 5.1)&#xA;- etc&lt;/code&gt;&lt;/pre&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;This branch scheme allows to accommodate API changes between main Rudder versions.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Most of the time, there is no need to recompile a plugin for the corresponding Rudder minor version, so that plugins compiled on branch &lt;code&gt;branches/rudder/5.1&lt;/code&gt; should be compatible with all Rudder 5.1.x versions.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;It may happens that at some point in the Rudder maintenance cycle, a Rudder minor version introduces a breaking change in a plugin API or a binary incompability in a plugin ABI. In such a case, we will explain which plugin versions are compatible with which Rudder versions in plugin readme file.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;sect2&#34;&gt; &#xA;   &lt;h3 id=&#34;_summary_of_binary_compatibility_for_rudder_6_0_branch&#34;&gt;Summary of binary compatibility for Rudder 6.0 branch&lt;/h3&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;Please see file: version-compat.adoc&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_plugin_version_and_tag_convention&#34;&gt;Plugin version and Tag convention&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Plugin versions are composed in two parts separated by a &lt;code&gt;-&lt;/code&gt;:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;ulist&#34;&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt; &lt;p&gt;the Rudder corresponding version (without the minor number),&lt;/p&gt; &lt;/li&gt; &#xA;    &lt;li&gt; &lt;p&gt;the plugin own version in format X.Y(.Z) where the Z part is optionnal.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;/ul&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;For example, the &lt;code&gt;datasources&lt;/code&gt; plugin, in own version 1.1, for Rudder 4.1 will get version: &lt;code&gt;4.1-1.1&lt;/code&gt;.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;This version is used to postfix plugin package name.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Each plugin follow his own development pace, and so there is no release cycle for plugins. Each time a plugin reaches a new step, a version for it is published by changing version information in its &lt;code&gt;build.conf&lt;/code&gt; file. The related commit is tagged with the convention: &lt;code&gt;pluginShortName-pluginVersion&lt;/code&gt;.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;You can get all the versions for a given plugins with the &lt;code&gt;git tag --list&lt;/code&gt; command. For example, for the &lt;code&gt;datasources&lt;/code&gt; plugin:&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;listingblock&#34;&gt; &#xA;   &lt;div class=&#34;content&#34;&gt; &#xA;    &lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;$ git tag --list &#39;datasources-*&#39;&#xA;&#xA;# results&#xA;datasources-4.1-0.1&#xA;datasources-4.1-0.2&#xA;datasources-4.1-1.0&#xA;datasources-4.1-1.1&#xA;datasources-4.2-1.1&lt;/code&gt;&lt;/pre&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_building_plugins&#34;&gt;Building plugins&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;sect2&#34;&gt; &#xA;   &lt;h3 id=&#34;_building_and_java_stack_requirements&#34;&gt;Building and Java stack requirements&lt;/h3&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;All plugins share the same build infrastructure based on Make.&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;You will need:&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;ulist&#34;&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt; &lt;p&gt;standard &lt;code&gt;make&lt;/code&gt; tool chain,&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;code&gt;ar&lt;/code&gt;, and for any plugin with scala code (i.e most of them),&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;code&gt;maven&lt;/code&gt; in version 3.2 or up,&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;`Java 8 JDK tools (javac, jar, etc).&lt;/p&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;For information, this the list of package that need to be installed on a minimal linux distribution:&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;listingblock&#34;&gt; &#xA;    &lt;div class=&#34;content&#34;&gt; &#xA;     &lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;openjdk-8-jdk maven binutils make git-core xz-utils&lt;/code&gt;&lt;/pre&gt; &#xA;    &lt;/div&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;For the branding plugin, you need to have elm-install present on the system&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;listingblock&#34;&gt; &#xA;    &lt;div class=&#34;content&#34;&gt; &#xA;     &lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;npm install -g  elm&lt;/code&gt;&lt;/pre&gt; &#xA;    &lt;/div&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;To build a plugin package, do:&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;listingblock&#34;&gt; &#xA;    &lt;div class=&#34;content&#34;&gt; &#xA;     &lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;git checkout tag-corresponding-to-plugin-vesion&#xA;make clean &amp;amp;&amp;amp; make generate-all-pom &amp;amp;&amp;amp; make plugin-name&lt;/code&gt;&lt;/pre&gt; &#xA;    &lt;/div&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;After compilation, you will find in plugin root directory (i.e at the same level than the Makefile file) the plugin package: &lt;code&gt;pluginShortName-pluginVersion.rpkg&lt;/code&gt;.&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;This package can then be transferred to a Rudder server and installed with the command:&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;listingblock&#34;&gt; &#xA;    &lt;div class=&#34;content&#34;&gt; &#xA;     &lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;/opt/rudder/bin/rudder-pkg install-file /path/to/pluginShortName-pluginVersion.rpkg&lt;/code&gt;&lt;/pre&gt; &#xA;    &lt;/div&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;sect2&#34;&gt; &#xA;   &lt;h3 id=&#34;_building_licensed_limited_plugin_version&#34;&gt;Building licensed / limited plugin version&lt;/h3&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;As of Rudder 4.1, plugins can have a license and adapt there behavior based on runtime license information. The licensing framework is not open source, and such plugin need access to Rudder private repositories.&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;The common API can be build and installed in user local maven repository with the following command line when on &lt;code&gt;rudder-plugins&lt;/code&gt; directory (for example for &lt;code&gt;datasources&lt;/code&gt;, use the same &lt;code&gt;-licensed&lt;/code&gt; naming convention for other):&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;listingblock&#34;&gt; &#xA;    &lt;div class=&#34;content&#34;&gt; &#xA;     &lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;make datasources-licensed&lt;/code&gt;&lt;/pre&gt; &#xA;    &lt;/div&gt; &#xA;   &lt;/div&gt; &#xA;   &lt;div class=&#34;paragraph&#34;&gt; &#xA;    &lt;p&gt;The file &lt;code&gt;license.sign&lt;/code&gt; is a license information file signed with the private key matching the public one used in the command line. The path of &lt;code&gt;license.sign&lt;/code&gt; is relative to the plugin directory, so in our example, it will be located at: &lt;code&gt;./datasources/license.sign&lt;/code&gt;&lt;/p&gt; &#xA;   &lt;/div&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_licensing&#34;&gt;Licensing&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;License are by-plugin and the license for a given plugin is specified in the LICENSE file in its plugin directory.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Nonetheless most projects are licensed under GNU GPLv3 license (&lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.txt&#34; class=&#34;bare&#34;&gt;http://www.gnu.org/licenses/gpl-3.0.txt&lt;/a&gt;) or ASLv2 (&lt;a href=&#34;https://www.apache.org/licenses/LICENSE-2.0&#34; class=&#34;bare&#34;&gt;https://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;)&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_contributing&#34;&gt;Contributing&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Thank you for your interest in your our project! The contribution process is detailed here: &lt;a href=&#34;https://www.rudder.io/en/expand/contribute/&#34; class=&#34;bare&#34;&gt;https://www.rudder.io/en/expand/contribute/&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt; &#xA;&lt;div class=&#34;sect1&#34;&gt; &#xA; &lt;h2 id=&#34;_authors&#34;&gt;Authors&lt;/h2&gt; &#xA; &lt;div class=&#34;sectionbody&#34;&gt; &#xA;  &lt;div class=&#34;paragraph&#34;&gt; &#xA;   &lt;p&gt;Authors are tracked by their git name and public git hostory of the project.&lt;/p&gt; &#xA;  &lt;/div&gt; &#xA; &lt;/div&gt; &#xA;&lt;/div&gt;</summary>
  </entry>
  <entry>
    <title>atedeg/mdm</title>
    <updated>2022-07-18T01:55:56Z</updated>
    <id>tag:github.com,2022-07-18:/atedeg/mdm</id>
    <link href="https://github.com/atedeg/mdm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/atedeg/mdm/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/atedeg/mdm/actions/workflows/ci.yml/badge.svg?branch=main&#34; alt=&#34;Build test and deploy&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/semantic-release/semantic-release&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/semantic--release-conventional_commits-e10098?logo=semantic-release&#34; alt=&#34;semantic-release: conventional-commits&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache_2.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;MDM - Mambelli Domain Model&lt;/h1&gt; &#xA;&lt;p&gt;This is the final project for the &lt;a href=&#34;https://www.unibo.it/it/didattica/insegnamenti/insegnamento/2021/412677&#34;&gt;LSS exam&lt;/a&gt;; it uses a DDD approach to model the domain of the &lt;a href=&#34;https://www.mambelli.com/it/&#34;&gt;Mambelli&lt;/a&gt; cheese factory&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MDM is licensed under the &lt;a href=&#34;https://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache License Version 2.0&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>zio/zio-json</title>
    <updated>2022-07-18T01:55:56Z</updated>
    <id>tag:github.com,2022-07-18:/zio/zio-json</id>
    <link href="https://github.com/zio/zio-json" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fast, secure JSON library with tight ZIO integration.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;zio-json&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Project Stage&lt;/th&gt; &#xA;   &lt;th&gt;CI&lt;/th&gt; &#xA;   &lt;th&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Snapshot&lt;/th&gt; &#xA;   &lt;th&gt;Discord&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/zio/zio/wiki/Project-Stages&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Project%20Stage-Production%20Ready-brightgreen.svg?sanitize=true&#34; alt=&#34;Project stage&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://github.com/zio/zio-json/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-json_2.12/&#34; title=&#34;Sonatype Releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-json_2.12.svg?sanitize=true&#34; alt=&#34;Release Artifacts&#34; title=&#34;Sonatype Releases&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-json_2.12/&#34; title=&#34;Sonatype Snapshots&#34;&gt;&lt;img src=&#34;https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-json_2.12.svg?sanitize=true&#34; alt=&#34;Snapshot Artifacts&#34; title=&#34;Sonatype Snapshots&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://discord.gg/2ccFBr4&#34; title=&#34;Discord&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/629491597070827530?logo=discord&#34; alt=&#34;Badge-Discord&#34; title=&#34;chat on discord&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Summary&lt;/h1&gt; &#xA;&lt;p&gt;The goal of this project is to create the best all-round JSON library for Scala:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Performance&lt;/strong&gt; to handle more requests per second than the incumbents, i.e. reduced operational costs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Security&lt;/strong&gt; to mitigate against adversarial JSON payloads that threaten the capacity of the server.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Fast Compilation&lt;/strong&gt; no shapeless, no type astronautics.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Future-Proof&lt;/strong&gt;, prepared for Scala 3 and next generation Java.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Simple&lt;/strong&gt; small codebase, short and concise documentation that covers everything.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Helpful errors&lt;/strong&gt; are readable by humans and machines.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ZIO Integration&lt;/strong&gt; so nothing more is required.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How&lt;/h1&gt; &#xA;&lt;p&gt;Extreme &lt;strong&gt;performance&lt;/strong&gt; is achieved by decoding JSON directly from the input source into business objects (inspired by &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala&#34;&gt;plokhotnyuk&lt;/a&gt;). Although not a requirement, the latest advances in &lt;a href=&#34;https://wiki.openjdk.java.net/display/loom/Main&#34;&gt;Java Loom&lt;/a&gt; can be used to support arbitrarily large payloads with near-zero overhead.&lt;/p&gt; &#xA;&lt;p&gt;Best in class &lt;strong&gt;security&lt;/strong&gt; is achieved with an aggressive &lt;em&gt;early exit&lt;/em&gt; strategy that avoids costly stack traces, even when parsing malformed numbers. Malicious (and badly formed) payloads are rejected before finishing reading.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fast compilation&lt;/strong&gt; and &lt;strong&gt;future-proofing&lt;/strong&gt; is possible thanks to &lt;a href=&#34;https://propensive.com/opensource/magnolia/&#34;&gt;Magnolia&lt;/a&gt; which allows us to generate boilerplate in a way that will survive the exodus to Scala 3. &lt;code&gt;zio-json&lt;/code&gt; is internally implemented using a &lt;a href=&#34;https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/Reader.html&#34;&gt;&lt;code&gt;java.io.Reader&lt;/code&gt;&lt;/a&gt; / &lt;a href=&#34;https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/Writer.html&#34;&gt;&lt;code&gt;java.io.Writer&lt;/code&gt;&lt;/a&gt;-like interface, which is making a comeback to center stage in Loom.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Simplicity&lt;/strong&gt; is achieved by using well-known software patterns and avoiding bloat. The only requirement to use this library is to know about Scala&#39;s encoding of typeclasses, described in &lt;a href=&#34;https://leanpub.com/fpmortals/read#leanpub-auto-functionality&#34;&gt;Functional Programming for Mortals&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Helpful errors&lt;/strong&gt; are produced in the form of a &lt;a href=&#34;https://stedolan.github.io/jq/&#34;&gt;&lt;code&gt;jq&lt;/code&gt;&lt;/a&gt; query, with a note about what went wrong, pointing to the exact part of the payload that failed to parse.&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;dev.zio&#34; %% &#34;zio-json&#34; % &#34;0.1.0&#34;&#xA;&#xA;scalaVersion in ThisBuild := &#34;2.13.4&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All of the following code snippets assume that the following imports have been declared&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import zio.json._&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Simple Example&lt;/h2&gt; &#xA;&lt;p&gt;Say we want to be able to read some JSON like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;curvature&#34;:0.5}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;into a Scala &lt;code&gt;case class&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Banana(curvature: Double)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To do this, we create an &lt;em&gt;instance&lt;/em&gt; of the &lt;code&gt;JsonDecoder&lt;/code&gt; typeclass for &lt;code&gt;Banana&lt;/code&gt; using the &lt;code&gt;zio-json&lt;/code&gt; code generator. It is best practice to put it on the companion of &lt;code&gt;Banana&lt;/code&gt;, like so&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Banana {&#xA;  implicit val decoder: JsonDecoder[Banana] = DeriveJsonDecoder.gen[Banana]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: If you’re using Scala 3 and your case class is defining default parameters, &lt;code&gt;-Yretain-trees&lt;/code&gt; needs to be added to &lt;code&gt;scalacOptions&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now we can parse JSON into our object&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;scala&amp;gt; &#34;&#34;&#34;{&#34;curvature&#34;:0.5}&#34;&#34;&#34;.fromJson[Banana]&#xA;val res: Either[String, Banana] = Right(Banana(0.5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Likewise, to produce JSON from our data we define a &lt;code&gt;JsonEncoder&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Banana {&#xA;  ...&#xA;  implicit val encoder: JsonEncoder[Banana] = DeriveJsonEncoder.gen[Banana]&#xA;}&#xA;&#xA;scala&amp;gt; Banana(0.5).toJson&#xA;val res: String = {&#34;curvature&#34;:0.5}&#xA;&#xA;scala&amp;gt; Banana(0.5).toJsonPretty&#xA;val res: String =&#xA;{&#xA;  &#34;curvature&#34; : 0.5&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And bad JSON will produce an error in &lt;code&gt;jq&lt;/code&gt; syntax with an additional piece of contextual information (in parentheses)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;scala&amp;gt; &#34;&#34;&#34;{&#34;curvature&#34;: womp}&#34;&#34;&#34;.fromJson[Banana]&#xA;val res: Either[String, Banana] = Left(.curvature(expected a number, got w))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Say we extend our data model to include more data types&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sealed trait Fruit&#xA;case class Banana(curvature: Double) extends Fruit&#xA;case class Apple (poison: Boolean)   extends Fruit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;we can generate the encoder and decoder for the entire &lt;code&gt;sealed&lt;/code&gt; family&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Fruit {&#xA;  implicit val decoder: JsonDecoder[Fruit] = DeriveJsonDecoder.gen[Fruit]&#xA;  implicit val encoder: JsonEncoder[Fruit] = DeriveJsonEncoder.gen[Fruit]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;allowing us to load the fruit based on a single field type tag in the JSON&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;scala&amp;gt; &#34;&#34;&#34;{&#34;Banana&#34;:{&#34;curvature&#34;:0.5}}&#34;&#34;&#34;.fromJson[Fruit]&#xA;val res: Either[String, Fruit] = Right(Banana(0.5))&#xA;&#xA;scala&amp;gt; &#34;&#34;&#34;{&#34;Apple&#34;:{&#34;poison&#34;:false}}&#34;&#34;&#34;.fromJson[Fruit]&#xA;val res: Either[String, Fruit] = Right(Apple(false))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Almost all of the standard library data types are supported as fields on the case class, and it is easy to add support if one is missing.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;By default the field names of a case class are used as the JSON fields, but it is easy to override this with an annotation &lt;code&gt;@jsonField&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It is also possible to change the type hint that is used to discriminate case classes with &lt;code&gt;@jsonHint&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example, these annotations change the expected JSON of our &lt;code&gt;Fruit&lt;/code&gt; family&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sealed trait Fruit&#xA;@jsonHint(&#34;banaani&#34;) case class Banana(&#xA;  @jsonField(&#34;bendiness&#34;) curvature: Double&#xA;) extends Fruit&#xA;@jsonHint(&#34;omena&#34;) case class Apple(&#xA;  @jsonField(&#34;bad&#34;) poison: Boolean&#xA;) extends Fruit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;from&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;Banana&#34;:{&#34;curvature&#34;:0.5}}&#xA;&#xA;{&#34;Apple&#34;:{&#34;poison&#34;:false}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;banaani&#34;:{&#34;bendiness&#34;:0.5}}&#xA;&#xA;{&#34;omena&#34;:{&#34;bad&#34;:false}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can raise an error if we encounter unexpected fields by using the &lt;code&gt;@jsonNoExtraFields&lt;/code&gt; annotation on a case class.&lt;/p&gt; &#xA;&lt;p&gt;A popular alternative way to encode sealed traits:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;type&#34;:&#34;banaani&#34;, &#34;bendiness&#34;:0.5}&#xA;&#xA;{&#34;type&#34;:&#34;omena&#34;, &#34;bad&#34;:false}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is discouraged for performance reasons. However, if we have no choice in the matter, it may be accomodated with the &lt;code&gt;@jsonDiscriminator&lt;/code&gt; annotation&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@jsonDiscriminator(&#34;type&#34;) sealed trait Fruit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Manual Instances&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes it is easier to reuse an existing &lt;code&gt;JsonDecoder&lt;/code&gt; rather than generate a new one. This can be accomplished using convenience methods on the &lt;code&gt;JsonDecoder&lt;/code&gt; typeclass to &lt;em&gt;derive&lt;/em&gt; new decoders:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait JsonDecoder[A] {&#xA;  def map[B](f: A =&amp;gt; B): JsonDecoder[B]&#xA;  def mapOrFail[B](f: A =&amp;gt; Either[String, B]): JsonDecoder[B]&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, we can reuse an existing &lt;code&gt;JsonEncoder&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait JsonEncoder[A] {&#xA;  def contramap[B](f: B =&amp;gt; A): JsonEncoder[B]&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;We can &lt;code&gt;.map&lt;/code&gt; from another &lt;code&gt;JsonDecoder&lt;/code&gt; in cases where the conversion will always succeed. This is very useful if we have a &lt;code&gt;case class&lt;/code&gt; that simply wraps another thing and shares the same expected JSON.&lt;/p&gt; &#xA;&lt;p&gt;For example, say we want to model the count of fruit with a &lt;code&gt;case class&lt;/code&gt; to provide us with additional type safety in our business logic (this pattern is known as a &lt;em&gt;newtype&lt;/em&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class FruitCount(value: Int)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but this would cause us to expect JSON of the form&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;value&#34;:1}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;wheres we really expect the raw number. We can derive a decoder from &lt;code&gt;JsonDecoder[Int]&lt;/code&gt; and &lt;code&gt;.map&lt;/code&gt; the result into a &lt;code&gt;FruitCount&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object FruitCount {&#xA;  implicit val decoder: JsonDecoder[FruitCount] = JsonDecoder[Int].map(FruitCount(_))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and now the &lt;code&gt;JsonDecoder&lt;/code&gt; for &lt;code&gt;FruitCount&lt;/code&gt; just expects a raw &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Every time we use a &lt;code&gt;.map&lt;/code&gt; to create a &lt;code&gt;JsonDecoder&lt;/code&gt; we can usually create a &lt;code&gt;JsonEncoder&lt;/code&gt; with &lt;code&gt;.contramap&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object FruitCount {&#xA;  ...&#xA;  implicit val encoder: JsonEncoder[FruitCount] = JsonEncoder[Int].contramap(_.value)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Another usecase is if we want to encode a &lt;code&gt;case class&lt;/code&gt; as an array of values, rather than an object with named fields. Such an encoding is very efficient because the messages are smaller and require less processing, but are very strict schemas that cannot be upgraded.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Things(s: String, i: Int, b: Boolean)&#xA;object Things {&#xA;  implicit val decoder: JsonDecoder[Things] =&#xA;    JsonDecoder[(String, Int, Boolean)].map { case (p1, p2, p3) =&amp;gt; Things(p1, p2, p3) }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which parses the following JSON&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[&#34;hello&#34;,1,true]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;.mapOrFail&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;We can use &lt;code&gt;.mapOrFail&lt;/code&gt; to take the result of another &lt;code&gt;JsonDecoder&lt;/code&gt; and try to convert it into our custom data type, failing with a message if there is an error.&lt;/p&gt; &#xA;&lt;p&gt;Say we are using the &lt;a href=&#34;https://github.com/fthomas/refined&#34;&gt;&lt;code&gt;refined&lt;/code&gt;&lt;/a&gt; library to ensure that a &lt;code&gt;Person&lt;/code&gt; data type only holds a non-empty string in its &lt;code&gt;name&lt;/code&gt; field&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import zio.json._&#xA;import zio.json.interop.refined._&#xA;&#xA;import eu.timepit.refined.api.Refined&#xA;import eu.timepit.refined.collection.NonEmpty&#xA;&#xA;case class Person(name: String Refined NonEmpty)&#xA;&#xA;object Person {&#xA;  implicit val decoder: JsonDecoder[Person] = DeriveJsonDecoder.gen&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;we will get a compiletime error because there is no &lt;code&gt;JsonDecoder[String Refined NonEmpty]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;However, we can derive one by requesting the &lt;code&gt;JsonDecoder[String]&lt;/code&gt; and calling &lt;code&gt;.mapOrFail&lt;/code&gt;, supplying the constructor for our special &lt;code&gt;String Refined NonEmpty&lt;/code&gt; type&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit val decodeName: JsonDecoder[String Refined NonEmpty] =&#xA;  JsonDecoder[String].mapOrFail(refined.refineV[NonEmpty](_))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now the code compiles.&lt;/p&gt; &#xA;&lt;p&gt;In fact, we do not need to provide &lt;code&gt;decodeName&lt;/code&gt; for each &lt;code&gt;Refined&lt;/code&gt; data type; &lt;code&gt;zio-json&lt;/code&gt; comes with support out of the box, see the Integrations section below.&lt;/p&gt; &#xA;&lt;h2&gt;Integrations&lt;/h2&gt; &#xA;&lt;p&gt;Integrations are provided several popular libraries, which are published as separate artifacts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Akka Http&lt;/li&gt; &#xA; &lt;li&gt;HTTP4s&lt;/li&gt; &#xA; &lt;li&gt;Refined&lt;/li&gt; &#xA; &lt;li&gt;Scalaz 7&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://zio.github.io/zio-json/docs/interop/interop_index&#34;&gt;Complete list of interop modules&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Performance&lt;/h1&gt; &#xA;&lt;p&gt;The following benchmarks are freely available to run on your hardware with &lt;code&gt;sbt &#34;zioJsonJVM/jmh:run -prof gc&#34;&lt;/code&gt; and can be extended to include more niche libraries. We only compare &lt;code&gt;zio-json&lt;/code&gt; against Circe and Play as they are the incumbent solutions used by most of the Scala ecosystem.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;zio-json&lt;/code&gt;, when used in legacy mode (i.e. using a &lt;code&gt;StringReader&lt;/code&gt;), is typically x2 faster than Circe and x5 faster than Play. When used with Loom, &lt;code&gt;zio-json&lt;/code&gt; has finished its work before the others even begin. The following benchmarks are therefore only for legacy mode comparisons.&lt;/p&gt; &#xA;&lt;p&gt;There are two main factors to consider when comparing the performance of JSON libraries: memory usage and operations per second. We perform measurements in one thread at a time but in a real server situation, there are multiple threads each consuming resources.&lt;/p&gt; &#xA;&lt;p&gt;Here are JMH benchmarks (higher &lt;code&gt;ops/sec&lt;/code&gt; is better, lower &lt;code&gt;MB/sec&lt;/code&gt; is better) on a standard Google Maps API performance-testing dataset (stressing array and number parsing). Note that a better metric for memory usage might be &lt;code&gt;MB&lt;/code&gt; per decode or encode, since it can be misleading to have the same &lt;code&gt;MB/sec&lt;/code&gt; but be processing more JSON: the library that consumes the least amount of memory is likely to have highest throughput.&lt;/p&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc GoogleMaps.*Success1 --&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc GoogleMaps.*encode* --&gt; &#xA;&lt;pre&gt;&lt;code&gt;       Decoding                    | Encoding&#xA;       ops/sec       MB/sec        | ops/sec      MB/sec&#xA;zio    15761 ± 283   1633 ± 29     | 14289 ±  84  2214 ± 12&#xA;circe   8832 ± 269   1816 ± 55     | 11980 ± 142  2030 ± 24&#xA;play    5756 ±  47   2260 ± 19     |  6669 ± 160  2677 ± 64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;on a standard Twitter API performance-testing dataset (stressing nested case classes with lots of fields)&lt;/p&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc Twitter.*Success1 --&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc Twitter.*encode* --&gt; &#xA;&lt;pre&gt;&lt;code&gt;       Decoding                    | Encoding&#xA;       ops/sec       MB/sec        | ops/sec      MB/sec&#xA;zio    16989 ± 113    827 ±  6     | 23085 ± 641  1791 ± 50&#xA;circe  16010 ±  72   1349 ±  6     | 15664 ± 209  1627 ± 22&#xA;play    5256 ± 165   1231 ± 39     | 15580 ± 314  2260 ± 45&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;on a standard GeoJSON performance-testing dataset (stressing nested sealed traits that use a discriminator)&lt;/p&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc GeoJSON.*Success1 --&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc GeoJSON.*encode* --&gt; &#xA;&lt;pre&gt;&lt;code&gt;       Decoding                    | Encoding&#xA;       ops/sec       MB/sec        | ops/sec       MB/sec&#xA;zio    17104 ± 155   2768 ± 25     | 5372 ± 26      817 ±  4&#xA;circe   8388 ± 118   2879 ± 41     | 4762 ± 47      592 ±  6&#xA;play     704 ±   9   3946 ± 55     | 2587 ± 24     1091 ± 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and on a standard synthetic performance-testing dataset (stressing nested recursive types)&lt;/p&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc Synthetic.*Success --&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc Synthetic.*encode* --&gt; &#xA;&lt;pre&gt;&lt;code&gt;       Decoding                    | Encoding&#xA;       ops/sec       MB/sec        | ops/sec       MB/sec&#xA;zio    59099 ± 1307  2108 ± 46     | 32048 ±  240  2573 ± 19&#xA;circe  19609 ±  370  2873 ± 53     | 13830 ±  109  1730 ± 14&#xA;play    9001 ±  182  3348 ± 67     | 14529 ±  200  3533 ± 48&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;zio-json&lt;/code&gt; easily wins every benchmark except ops/sec for the Twitter test data where Circe matches ops/sec but loses heavily on memory usage. Play loses on every benchmark.&lt;/p&gt; &#xA;&lt;h1&gt;Security&lt;/h1&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Denial-of-service_attack&#34;&gt;Denial of Service&lt;/a&gt; (DOS) attack is a cyber-attack in which the perpetrator seeks to make a machine or network resource unavailable to its intended users by temporarily or indefinitely disrupting services. The vast majority of public-facing servers written in Scala are vulnerable to DOS attack.&lt;/p&gt; &#xA;&lt;p&gt;Attacks that are in the form of a valid payload are designed to be stealthy and will produce the same end-result as a legitimate payload, but will consume more resources along the way. In this section we investigate specific attacks and how &lt;code&gt;zio-json&lt;/code&gt; mitigates against them.&lt;/p&gt; &#xA;&lt;h3&gt;Resource Attack: Larger Payload&lt;/h3&gt; &#xA;&lt;p&gt;An obvious way to slow down a server is to give it more data to read. JSON is particularly susceptible to this kind of attack because it has an in-built mechanism to expand the size of the message without altering the contents: pad with whitespace.&lt;/p&gt; &#xA;&lt;p&gt;Many web frameworks will fully consume the contents of a payload into a &lt;code&gt;String&lt;/code&gt; before handing it off to the JSON library, so if we receive a JSON message consisting of 1GB of whitespace, we will consume 1GB of heap on that server.&lt;/p&gt; &#xA;&lt;p&gt;The best way to mitigate against message size attacks is to cap the &lt;code&gt;Content-Length&lt;/code&gt; to a reasonable size for the use case. A further mitigation is to use a streaming parser that does not require the entire message to be read into memory before parsing begins.&lt;/p&gt; &#xA;&lt;p&gt;For all the remaining attacks, we will cap the malicious message size to 100KB (the original message is 25KB) and compare the attacks against this baseline. The benchmark results for the original (unedited) payload are given in parentheses, and we can immediately see a reduction in the ops/sec for all frameworks, accompanied by a reduction in memory usage.&lt;/p&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc GoogleMaps.*Attack0 --&gt; &#xA;&lt;pre&gt;&lt;code&gt;       ops/sec        MB/sec&#xA;zio    10104 (14823)  1047 (1537)&#xA;circe   7456 ( 8832)  1533 (1816)&#xA;play    3589 ( 5756)  1344 (2260)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Redundant Data&lt;/h3&gt; &#xA;&lt;p&gt;Most JSON libraries (but not &lt;code&gt;zio-json&lt;/code&gt;) first create a representation of the JSON message in an Abstract Syntax Tree (AST) that represents all the objects, arrays and values in a generic way. Their decoders typically read what they need from the AST.&lt;/p&gt; &#xA;&lt;p&gt;An intermediate AST enables attack vectors that insert redundant data, for example in our Google Maps dataset we can add a new field called &lt;code&gt;redundant&lt;/code&gt; at top-level containing a 60K &lt;code&gt;String&lt;/code&gt;. If we do this, and run the benchmarks, we see that Circe is heavily impacted, with a 75% reduction in capacity and an increase in memory usage. Play is also impacted, although not as severely. &lt;code&gt;zio-json&lt;/code&gt;&#39;s ops/sec are reduced but the memory usage is in line which means that throughput is unlikely to be affected by this kind of attack.&lt;/p&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc GoogleMaps.*Attack1 --&gt; &#xA;&lt;pre&gt;&lt;code&gt;       ops/sec       MB/sec&#xA;zio    5999 (10104)   622 (1047)&#xA;circe  2224 ( 7456)  1655 (1533)&#xA;play   2350 ( 3589)  1854 (1344)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason why &lt;code&gt;zio-json&lt;/code&gt; is not as badly affected is because it skips values that are unexpected. We can completely mitigate this kind of attack by using the &lt;code&gt;@jsonNoExtraFields&lt;/code&gt; annotation which results in the payload being rejected at a rate of 5.5 million ops/sec.&lt;/p&gt; &#xA;&lt;p&gt;Other kinds of redundant values attacks are also possible, such as using an array of 60K full of high precision decimal numbers that require slow parsing (also known as &lt;a href=&#34;https://www.exploringbinary.com/17-digits-gets-you-there-once-youve-found-your-way/&#34;&gt;&#34;near halfway numbers&#34;&lt;/a&gt;), attacking the CPU. However, the memory attack afforded to us by a redundant &lt;code&gt;String&lt;/code&gt; is already quite effective.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;hashCode&lt;/code&gt; Collisions&lt;/h3&gt; &#xA;&lt;p&gt;Following on from the redundant data attack, we can place redundant data in the location of object fields.&lt;/p&gt; &#xA;&lt;p&gt;JSON libraries that use an intermediate AST often store JSON objects as a stringy &lt;code&gt;HashMap&lt;/code&gt; (circe uses a &lt;a href=&#34;https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/LinkedHashMap.html&#34;&gt;&lt;code&gt;java.util.LinkedHashMap&lt;/code&gt;&lt;/a&gt;). If we insert redundant fields that have hashcode collisions with legitimate fields, we can successfully attack both memory and CPU. We need to know the hashing algorithm that is being used, which often falls down to some version of the default Java &lt;code&gt;String.hashCode&lt;/code&gt; &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/raw/master/jsoniter-scala-benchmark/shared/src/main/scala/com/github/plokhotnyuk/jsoniter_scala/benchmark/HashCodeCollider.scala&#34;&gt;which is very easy to exploit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In this malicious payload, we add redundant fields that have hashcode collisions, up to 4 collisions per field; we could add more if we used a bruteforce search.&lt;/p&gt; &#xA;&lt;!-- zioJsonJVM/jmh:run -prof gc GoogleMaps.*Attack2 --&gt; &#xA;&lt;p&gt;Again, &lt;code&gt;zio-json&lt;/code&gt; completely mitigates this attack if the &lt;code&gt;@jsonNoExtraFields&lt;/code&gt; annotation is used. Note that even if Circe and Play rejected payloads of this nature, it would be too late because the attack happens at the AST layer, not the decoders. However, for the sake of comparison, let&#39;s turn off the &lt;code&gt;zio-json&lt;/code&gt; mitigation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;       ops/sec       MB/sec&#xA;zio    3742 (10104)   695 (1047)&#xA;circe  1992 ( 7456)  1162 (1533)&#xA;play   1312 ( 3589)  1636 (1344)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ops/sec is down for all decoders relative to the baseline, but since &lt;code&gt;zio-json&lt;/code&gt; and Circe memory usage is also reduced the throughput on a server might not be impacted as badly as it sounds.&lt;/p&gt; &#xA;&lt;p&gt;However, this attack hurts Play very badly; memory usage is up compared to the baseline with throughput reduced to 40% of the baseline (22% of the original).&lt;/p&gt; &#xA;&lt;p&gt;There is a variant of this attack that can be devastating for libraries that rely on &lt;code&gt;HashMap&lt;/code&gt;. In this attack, &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala/pull/325&#34;&gt;developed by plokhotnyuk to DOS ujson&lt;/a&gt;, an object is filled with many fields that have a &lt;code&gt;hashCode&lt;/code&gt; of zero. This exploits two facts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Java &lt;code&gt;String&lt;/code&gt; does not cache &lt;code&gt;hashCode&lt;/code&gt; of zero, recomputing every time it is requested&lt;/li&gt; &#xA; &lt;li&gt;many &lt;code&gt;HashMap&lt;/code&gt; implementations re-request the hashes of all objects as the number of entries increases during construction.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Death by a Thousand Zeros&lt;/h3&gt; &#xA;&lt;p&gt;Another kind of attack is to provide data that will cause the decoder for a specific value to do more work than it needs to. Numbers are always a great example of this.&lt;/p&gt; &#xA;&lt;p&gt;The most brutal attack of this nature is to trick a deserialization library into constructing a gigantic number as a &lt;code&gt;BigDecimal&lt;/code&gt; and then to downcast to a &lt;code&gt;BigInteger&lt;/code&gt;. The JVM will happily attempt to reserve GBs of heap for the conversion. Try this in your REPL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;new java.math.BigDecimal(&#34;1e214748364&#34;).toBigInteger&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fortunately, this kind of attack is prevented by all the mainstream libraries. But it is possible to perform a much weaker form of the attack on Circe, which (to its credit) goes to great effort to pre-validate numbers.&lt;/p&gt; &#xA;&lt;p&gt;The Google Maps schema has fields of type &lt;code&gt;Int&lt;/code&gt; and Circe supports the conversion of floating point numbers to integers if the fractional part is zero: so we can pad an integer with as many zeros as possible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;       ops/sec       MB/sec&#xA;circe  4529 ( 7456)  2037 (1533)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This attack is very effective in schemas with lots of numbers, causing ops/sec to be halved with a 33% increase in memory usage.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;zio-json&lt;/code&gt; is resistant to a wide range of number based attacks because it uses a from-scratch number parser that will exit early when the number of bits of any number exceeds 128 bits, which can be customized by the system property &lt;code&gt;zio.json.number.bits&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Even Moar Performance&lt;/h1&gt; &#xA;&lt;p&gt;If &lt;code&gt;zio-json&lt;/code&gt; isn&#39;t fast enough for you, then try out &lt;a href=&#34;https://github.com/plokhotnyuk/jsoniter-scala&#34;&gt;jsoniter-scala&lt;/a&gt;; whereas &lt;code&gt;zio-json&lt;/code&gt; is fully integrated into ZIO, including streams and pipeline support, jsoniter is library agnostic.&lt;/p&gt; &#xA;&lt;p&gt;JSON is an inefficient transport format and everybody would benefit from a port of this library to msgpack or protobuf. For legacy services, a port supporting XML is also be possible.&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://zio.github.io/zio-json/&#34;&gt;zio-json Microsite&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://zio.github.io/zio-json/docs/about/about_contributing&#34;&gt;Documentation for contributors&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://zio.github.io/zio-json/docs/about/about_coc&#34;&gt;Code of Conduct&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;Come chat with us on &lt;a href=&#34;https://discord.gg/2ccFBr4&#34; title=&#34;Discord&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/629491597070827530?logo=discord&#34; alt=&#34;Badge-Discord&#34; title=&#34;chat on discord&#34;&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zio/zio-json/series/2.x/LICENSE&#34;&gt;License&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Uses &lt;a href=&#34;https://github.com/nst/JSONTestSuite&#34;&gt;JsonTestSuite&lt;/a&gt; to test parsing. (c) 2016 Nicolas Seriot)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Uses &lt;a href=&#34;https://www.yourkit.com/java/profiler/&#34;&gt;YourKit Java Profiler&lt;/a&gt; for performance optimisation. &lt;img src=&#34;https://www.yourkit.com/images/yklogo.png&#34; alt=&#34;YourKit Logo&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>