<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-15T01:44:28Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zio/zio-cli</title>
    <updated>2023-07-15T01:44:28Z</updated>
    <id>tag:github.com,2023-07-15:/zio/zio-cli</id>
    <link href="https://github.com/zio/zio-cli" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rapidly build powerful command-line applications powered by ZIO&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ZIO CLI&lt;/h1&gt; &#xA;&lt;p&gt;Rapidly build powerful command-line applications powered by ZIO&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zio/zio/wiki/Project-Stages&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Project%20Stage-Experimental-yellowgreen.svg?sanitize=true&#34; alt=&#34;Experimental&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/zio/zio-cli/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI Badge&#34;&gt; &lt;a href=&#34;https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-cli_2.13/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-cli_2.13.svg?label=Sonatype%20Release&#34; alt=&#34;Sonatype Releases&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-cli_2.13/&#34;&gt;&lt;img src=&#34;https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-cli_2.13.svg?label=Sonatype%20Snapshot&#34; alt=&#34;Sonatype Snapshots&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://javadoc.io/doc/dev.zio/zio-cli-docs_2.13&#34;&gt;&lt;img src=&#34;https://javadoc.io/badge2/dev.zio/zio-cli-docs_2.13/javadoc.svg?sanitize=true&#34; alt=&#34;javadoc&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/zio/zio-cli&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/zio/zio-cli?style=social&#34; alt=&#34;ZIO CLI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;To use &lt;strong&gt;ZIO CLI&lt;/strong&gt;, we need to add the following to our &lt;code&gt;build.sbt&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;dev.zio&#34; %% &#34;zio-cli&#34; % &#34;0.6.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;ZIO CLI&lt;/strong&gt; allows to easily construct a CLI application. A CLI or Command-Line Interface is an application that allows the user to give instructions by means of pieces of text called commands. A command has the following structure&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;command param1 param2 ... paramN&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;command&lt;/code&gt; is the name of the command and &lt;code&gt;param1&lt;/code&gt;, &lt;code&gt;param2&lt;/code&gt;, ..., &lt;code&gt;paramN&lt;/code&gt; form a list of parameters depending on the command that determines the precise instruction to the CLI application.&lt;/p&gt; &#xA;&lt;p&gt;Given the case, a command itself might contain subcommands. This allows a better design of the command-line application and a more comfortable user experience.&lt;/p&gt; &#xA;&lt;p&gt;A command might include arguments and options.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Arguments are name-less and position-based parameters that the user specifies just by the position in the command. As an example, we can consider the widely used command-line application Git. One subcommand is &lt;code&gt;clone&lt;/code&gt;. It creates a copy of an existing repository. An argument of &lt;code&gt;git clone&lt;/code&gt; is &lt;code&gt;repository&lt;/code&gt;. If the repository name is &lt;code&gt;https://github.com/zio/zio-cli.git&lt;/code&gt;, we will use it in the following manner:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/zio/zio-cli.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Options are named and position-independent parameters that are specified by writing the content after the name. The name is preceded by &lt;code&gt;--&lt;/code&gt;. An option may have a shorter form called an alias. When the alias is used instead of the full name, only &lt;code&gt;-&lt;/code&gt; is needed. An option of command &lt;code&gt;git clone&lt;/code&gt; is &lt;code&gt;local&lt;/code&gt;. It is a boolean option, so it is not necessary to write true or false after it: it will be true only if it appears. It is used in the following manner:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone --local&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It also has an alias &lt;code&gt;-l&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone -l&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The description of the command &lt;code&gt;git clone&lt;/code&gt;, taking only into account option &lt;code&gt;local&lt;/code&gt; and argument &lt;code&gt;repository&lt;/code&gt; will be&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone [-l] &amp;lt;repository&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &lt;code&gt;[]&lt;/code&gt; implies that the option is optional and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; indicates an argument.&lt;/p&gt; &#xA;&lt;h3&gt;Difference between Args and Options&lt;/h3&gt; &#xA;&lt;p&gt;Arguments and options are different due to the way the user specifies them. Arguments are not specified using its name, only by the position inside the command. On the other hand, options must be preceded by its name and &lt;code&gt;--&lt;/code&gt; indicating that it is the name of an option.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, a command-line application will represent them in different ways. Argument&#39;s name will be inside &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; while an option will be preceded by &lt;code&gt;--&lt;/code&gt;. In case that the option has a short form or alias, this will be preceded by &lt;code&gt;-&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;First ZIO CLI example&lt;/h3&gt; &#xA;&lt;p&gt;This is done by defining &lt;code&gt;cliApp&lt;/code&gt; value from &lt;code&gt;ZIOCliDefault&lt;/code&gt; using &lt;code&gt;CliApp.make&lt;/code&gt; and specifying a &lt;code&gt;Command&lt;/code&gt; as parameter. A &lt;code&gt;Command[Model]&lt;/code&gt; is a description of the commands of a CLI application that allows to specify which commands are valid and how to transform the input into an instance of &lt;code&gt;Model&lt;/code&gt;. Then it is possible to implement the logic of the CLI application in terms of &lt;code&gt;Model&lt;/code&gt;. As a sample we are going to create a command of Git. We are going to implement only command &lt;code&gt;git clone&lt;/code&gt; with argument &lt;code&gt;repository&lt;/code&gt; and option &lt;code&gt;local&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import zio.cli._&#xA;import zio.cli.HelpDoc.Span.text&#xA;import zio.Console.printLine&#xA;&#xA;// object of your app must extend ZIOCliDefault&#xA;object Sample extends ZIOCliDefault {&#xA;&#xA;  /**&#xA;   * First we define the commands of the Cli. To do that we need:&#xA;   *    - Create command options&#xA;   *    - Create command arguments&#xA;   *    - Create help (HelpDoc) &#xA;   */&#xA;  val options: Options[Boolean] = Options.boolean(&#34;local&#34;).alias(&#34;l&#34;)&#xA;  val arguments: Args[String] = Args.text(&#34;repository&#34;)&#xA;  val help: HelpDoc = HelpDoc.p(&#34;Creates a copy of an existing repository&#34;)&#xA;  &#xA;  val command: Command[(Boolean, String)] = Command(&#34;clone&#34;).subcommands(Command(&#34;clone&#34;, options, arguments).withHelp(help))&#xA;  &#xA;  // Define val cliApp using CliApp.make&#xA;  val cliApp = CliApp.make(&#xA;    name = &#34;Sample Git&#34;,&#xA;    version = &#34;1.1.0&#34;,&#xA;    summary = text(&#34;Sample implementation of git clone&#34;),&#xA;    command = command&#xA;  ) {&#xA;    // Implement logic of CliApp&#xA;    case _ =&amp;gt; printLine(&#34;executing git clone&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output will be&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   _____@       @           @        @   __@     @       @  ______@   _ @  __ @&#xA;  / ___/@ ____ _@  ____ ___ @   ____ @  / /@ ___ @       @ / ____/@  (_)@ / /_@&#xA;  \__ \ @/ __ `/@ / __ `__ \@  / __ \@ / / @/ _ \@       @/ / __  @ / / @/ __/@&#xA; ___/ / / /_/ / @/ / / / / /@ / /_/ /@/ /  /  __/@       / /_/ /  @/ /  / /_  @&#xA;/____/  \__,_/  /_/ /_/ /_/ @/ .___/ /_/   \___/ @       \____/   /_/   \__/  @&#xA;        @       @           /_/      @     @     @       @        @     @     @&#xA;&#xA;&#xA;Sample Git v1.1.0 -- Sample implementation of git clone&#xA;&#xA;USAGE&#xA;&#xA;  $ clone clone [(-l, --local)] &amp;lt;repository&amp;gt;&#xA;&#xA;COMMANDS&#xA;&#xA;  clone [(-l, --local)] &amp;lt;repository&amp;gt;  Creates a copy of an existing repository&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If there is a &lt;code&gt;CliApp&lt;/code&gt;, you can run a command using its method &lt;code&gt;run&lt;/code&gt; and passing parameters in a &lt;code&gt;List[String]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=UeR8YUN4Tws&#34;&gt;10 Minute Command-Line Apps With ZIO CLI&lt;/a&gt; by Aiswarya Prakasan&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=HxPCXfnbg3U&#34;&gt;Hacking on ZIO-CLI&lt;/a&gt; by Adam Fraser and Kit Langton&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=0c3zbUq4lQo&#34;&gt;Behold! The Happy Path To Captivate Your Users With Stunning CLI Apps!&lt;/a&gt; by Jorge Vasquez&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Learn more on the &lt;a href=&#34;https://zio.dev/zio-cli/&#34;&gt;ZIO CLI homepage&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;For the general guidelines, see ZIO &lt;a href=&#34;https://zio.dev/about/contributing&#34;&gt;contributor&#39;s guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://zio.dev/about/code-of-conduct&#34;&gt;Code of Conduct&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;Come chat with us on &lt;a href=&#34;https://discord.gg/2ccFBr4&#34; title=&#34;Discord&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/629491597070827530?logo=discord&#34; alt=&#34;Badge-Discord&#34; title=&#34;chat on discord&#34;&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zio/zio-cli/master/LICENSE&#34;&gt;License&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Kraks/diamond-lang</title>
    <updated>2023-07-15T01:44:28Z</updated>
    <id>tag:github.com,2023-07-15:/Kraks/diamond-lang</id>
    <link href="https://github.com/Kraks/diamond-lang" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A prototype programming language with polymorphic reachability types that track freshness, sharing and separation.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Diamond Language&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/Kraks/Diamond-lang/actions/workflows/scala.yml/badge.svg?sanitize=true&#34; alt=&#34;Scala CI&#34;&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/Kraks/diamond-lang/main/rusty_diamond.png?raw=true&#34; alt=&#34;A rusty diamond by Midjourney&#34; width=&#34;300px&#34; height=&#34;300px&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;A prototype implementation of the polymorphic reachability type system, dubbed the Diamond programming language. The Diamond language has a Scala-like syntax, and enhances types with reachability qualifiers that track reachability and sharing of resources.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tracking aliases in types&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A freshly allocated resource (e.g. memory allocation) is &lt;em&gt;tracked&lt;/em&gt; but has not aliased to any variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Ref 42  // : Ref[Int]^◆&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The diamond qualifier notation indicates that this term yields a fresh resource.&lt;/p&gt; &#xA;&lt;p&gt;Assignment propagates aliases (or reachability):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val x = Ref 42;&#xA;val y = x;       // : Ref[Int]^y under the context of y: Ref[Int]^x, x: Ref[Int]^◆&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Polymorphic identity function&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def polyId[T &amp;lt;: Top](x: T^&amp;lt;&amp;gt;): T^x = x&#xA;val x = id[Int](3);              // : Int^∅&#xA;// type argument to id is optional&#xA;val c = id(Ref 42);              // : Ref[Int]^c&#xA;x + (! c)                        // : Int^∅&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The identity function is not only polymorphic with respect to argument types, but also to its reachability. The result of &lt;code&gt;id(3)&lt;/code&gt; is untracked, since its argument is untracked (indicated by the empty set notation). In contrast, the result of &lt;code&gt;id(Ref 42)&lt;/code&gt; remains tracked (indicated by the &lt;code&gt;c&lt;/code&gt; in the type), since &lt;code&gt;Ref 42&lt;/code&gt; is a freshly allocated resource that we want to track. The type system guarantees tracked resources remain tracked all the time.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Separation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val c1 = Ref 42;&#xA;val c2 = c1;       // c2 and c1 are aliased&#xA;def f(x: Ref[Int]^&amp;lt;&amp;gt;): Int = { (!x) + (!c1) };&#xA;f(c2)              // type error&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Function applications in Diamond check separation between the applied function and argument. For example, &lt;code&gt;f&lt;/code&gt; captures &lt;code&gt;c1&lt;/code&gt; from its defining scope, and also takes an argument &lt;code&gt;x&lt;/code&gt;. The argument of &lt;code&gt;x&lt;/code&gt; is annotated with the diamond, indicating that the function cannot take argument that has overlap with what can be observed by the function from the environment. Therefore, the above example issues a type error.&lt;/p&gt; &#xA;&lt;p&gt;Programmers can indicate permissible overlap at the function&#39;s argument position. For example, we can add &lt;code&gt;c1&lt;/code&gt; into the &lt;code&gt;f&lt;/code&gt;&#39;s argument qualifier, then the following program type checks (even though we provide &lt;code&gt;c2&lt;/code&gt; as argument but the typechecker knows that &lt;code&gt;c1&lt;/code&gt; can be reached from &lt;code&gt;c2&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val c1 = Ref 42;&#xA;val c2 = c1;       // c2 and c1 are aliased&#xA;def f(x: Ref[Int]^{c1, &amp;lt;&amp;gt;}): Int = { (!x) + (!c1) };&#xA;f(c2)              // ok&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Escaped resources&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Diamond smoothly supports tracking escaped resources via self-reference. The following snippet shows an example that we allocate a mutable cell with function &lt;code&gt;counter&lt;/code&gt;, which then returns two functions to increase and decrease the mutable cell. These two functions they capture the same resource and are returned as a pair.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def counter(n: Int) = {&#xA;  val x = Ref n;&#xA;  val inc = () =&amp;gt; { x := (! x) + 1 };&#xA;  val dec = () =&amp;gt; { x := (! x) - 1 };&#xA;  makePair[(() =&amp;gt; Unit)^x][(() =&amp;gt; Unit)^x](inc)(dec)&#xA;};&#xA;val p = counter(0);&#xA;val inc = fst[(() =&amp;gt; Unit)^p][(() =&amp;gt; Unit)^p](p); // (() =&amp;gt; Unit)^p&#xA;val dec = snd[(() =&amp;gt; Unit)^p][(() =&amp;gt; Unit)^p](p); // (() =&amp;gt; Unit)^p&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the outer scope, once we leave the scope of &lt;code&gt;x&lt;/code&gt;, we can still track the fact that the &lt;code&gt;inc&lt;/code&gt; and &lt;code&gt;dec&lt;/code&gt; function they access and mutate the same hidden resource (see &lt;code&gt;examples/counter.dia&lt;/code&gt; for full example).&lt;/p&gt; &#xA;&lt;h2&gt;Get Started&lt;/h2&gt; &#xA;&lt;p&gt;Diamond is written in Scala 3, so to get started with the project, you need &lt;code&gt;sbt&lt;/code&gt;, the build tool for Scala projects. You can install &lt;code&gt;sbt&lt;/code&gt; and JVM environment using &lt;a href=&#34;https://get-coursier.io/docs/cli-installation&#34;&gt;Coursier&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Play with Examples&lt;/h2&gt; &#xA;&lt;p&gt;You can play with the type checker and interpreter by writing programs under &lt;code&gt;examples&lt;/code&gt; and run the following command to see its type and evaluation result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sbt:Diamond&amp;gt; run &amp;lt;filename.dia&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, &lt;code&gt;examples/polyId.dia&lt;/code&gt; contains a snippet of the polymorphic identity function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def polyId[T &amp;lt;: Top](x: T^&amp;lt;&amp;gt;): T^x = x&#xA;val x = id(3);              // : Int^∅&#xA;val c = id(Ref 42);         // : Ref[Int]^◆&#xA;x + (! c)                   // : Int^∅&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running &lt;code&gt;run polyId.dia&lt;/code&gt; shows the parsed AST, the type of the final result, as well as the evaluation result.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, you may run &lt;code&gt;test&lt;/code&gt; in &lt;code&gt;sbt&lt;/code&gt; to check all mechanized test cases.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sbt:Diamond&amp;gt; test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Experiment with Qualifiers&lt;/h3&gt; &#xA;&lt;p&gt;The implemented front-end language adds a &lt;code&gt;topval&lt;/code&gt; form to define top-level bindings. It is useful to assist experimenting with the language, but is not intended to be used as a real feature of the language. In contrast to ordinary let-binding using the &lt;code&gt;val&lt;/code&gt; keyword, bindings declared with &lt;code&gt;topval&lt;/code&gt; will be persistent, i.e. we would not leave its scope at the end of the program. In this way, we can examine the qualifiers more clearly. For example, if we define &lt;code&gt;x&lt;/code&gt; using &lt;code&gt;topval&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;def polyId[T &amp;lt;: Top](x: T^&amp;lt;&amp;gt;): T^x = x&#xA;topval x = id(Ref 42);&#xA;x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We will see the final type is &lt;code&gt;Ref[Int^∅]^x&lt;/code&gt; where the reachability &lt;code&gt;x&lt;/code&gt; is residualized (instead of &lt;code&gt;Ref[Int^∅]^◆&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Structure&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;src/main/scala/qualfsub&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;CoreLang.scala&lt;/code&gt; the core language definitions.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;TypeCheck.scala&lt;/code&gt; the type checker.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Eval.scala&lt;/code&gt; the interpreter.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Run.scala&lt;/code&gt; top-level driver and pretty-printers.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Parser.scala&lt;/code&gt; the parser that translates the Diamond front-end language to the core language.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;src/test/scala&lt;/code&gt; test cases.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;examples&lt;/code&gt; examples written in the Diamond front-end language.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;coq&lt;/code&gt;: Coq proof for the metatheory of algorithmic subtyping used in the implementation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Reachability Types: Tracking Aliasing and Separation in Higher-order Functional Programs&lt;/strong&gt; (OOPSLA 2021)&lt;br&gt; by Yuyan Bao, Guannan Wei, Oliver Bračevac, Luke Jiang, Qiyang He, and Tiark Rompf (&lt;a href=&#34;https://dl.acm.org/doi/10.1145/3485516&#34;&gt;pdf&lt;/a&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Mechanizations and Coq proofs of the core calculus can be found &lt;a href=&#34;https://github.com/TiarkRompf/reachability&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>CedricGatay/codestory2013</title>
    <updated>2023-07-15T01:44:28Z</updated>
    <id>tag:github.com,2023-07-15:/CedricGatay/codestory2013</id>
    <link href="https://github.com/CedricGatay/codestory2013" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Codestory 2013&lt;/h1&gt; &#xA;&lt;p&gt;Code réalisé en utilisant Play2 + Scala Le code de Jajascript est recursif et peu performant, je n&#39;ai pas eu le temps de réécrire l&#39;algo en itératif en coupant les branches sans intêrets.&lt;/p&gt; &#xA;&lt;p&gt;En recherche de binôme pour la phase finale, environnement de dev usuel : Mac OS / AZERTY / IntelliJ&lt;/p&gt;</summary>
  </entry>
</feed>