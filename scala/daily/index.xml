<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-21T01:40:05Z</updated>
  <subtitle>Daily Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>VirtusLab/avocADO</title>
    <updated>2022-11-21T01:40:05Z</updated>
    <id>tag:github.com,2022-11-21:/VirtusLab/avocADO</id>
    <link href="https://github.com/VirtusLab/avocADO" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Safe compile-time parallelization of for-comprehensions for Scala 3&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://index.scala-lang.org/virtuslab/avocado/avocado&#34;&gt;&lt;img src=&#34;https://index.scala-lang.org/virtuslab/avocado/avocado/latest-by-scala-version.svg?platform=jvm&#34; alt=&#34;avocado Scala version support&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;avocADO - Safe compile-time parallelization of &lt;code&gt;for&lt;/code&gt; comprehensions&lt;/h1&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import cats.effect.IO&#xA;&#xA;import avocado.*&#xA;import avocado.instances.cats.given&#xA;&#xA;val run: IO[Int] =&#xA;  ado {&#xA;    for {&#xA;      a &amp;lt;- doStuff1&#xA;      b &amp;lt;- doStuff2(a)&#xA;      c &amp;lt;- doStuff3&#xA;      d &amp;lt;- doStuff4(a)&#xA;    } yield combine(a, b, c, d)&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;avocADO&lt;/code&gt; will transform the above for-comprehension to code equivalent to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for {&#xA;  a &amp;lt;- doStuff1&#xA;  (b, c, d) &amp;lt;- doStuff2(a).zip(doStuff3).zip(doStuff4(a))&#xA;} yield combine(a, b, c, d)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;avocADO&lt;/code&gt; is a small library that allows for automatic rewriting of &lt;code&gt;for&lt;/code&gt; comprehensions to their parallel versions.&lt;/p&gt; &#xA;&lt;p&gt;The name &lt;code&gt;avocADO&lt;/code&gt; is a pun on the most important function exposed by the library - &lt;code&gt;ado&lt;/code&gt; (name taken from Haskell&#39;s language extension &lt;code&gt;ApplicativeDo&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Usage (with build tools)&lt;/h2&gt; &#xA;&lt;h3&gt;sbt&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies ++= Seq(&#xA;  &#34;org.virtuslab&#34; %% &#34;avocado&#34; % &#34;version from the badge&#34;,&#xA;  &#34;org.virtuslab&#34; %% &#34;avocado-cats&#34; % &#34;version from the badge&#34;, // for Cats&#xA;  &#34;org.virtuslab&#34; %% &#34;avocado-zio-2&#34; % &#34;version from the badge&#34;, // for ZIO 2.x&#xA;  &#34;org.virtuslab&#34; %% &#34;avocado-zio-1&#34; % &#34;version from the badge&#34;, // for ZIO 1.x&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;scala-cli&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//&amp;gt; using lib &#34;org.virtuslab:&lt;span&gt;ðŸ¥‘&lt;/span&gt;version from the badge&#34;&#xA;//&amp;gt; using lib &#34;org.virtuslab::avocado-cats:version from the badge&#34; // for Cats&#xA;//&amp;gt; using lib &#34;org.virtuslab::avocado-zio-2:version from the badge&#34; // for ZIO 2.x&#xA;//&amp;gt; using lib &#34;org.virtuslab::avocado-zio-1:version from the badge&#34; // for ZIO 1.x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage (in code)&lt;/h2&gt; &#xA;&lt;p&gt;All you need to do in order to use &lt;code&gt;avocADO&lt;/code&gt; is to import the &lt;code&gt;ado&lt;/code&gt; function and an &lt;code&gt;AvocADO&lt;/code&gt; instance for your effect system. i.e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import avocado.* // This line exposes the `ado` function - entrypoint of the library&#xA;// You should choose one of the following imports depending on your effect system of choice&#xA;import avocado.instances.cats.given&#xA;import avocado.instances.zio2.given&#xA;import avocado.instances.zio1.given&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And that&#39;s it! All that&#39;s left is to wrap the &lt;code&gt;for&lt;/code&gt;-comprehensions that you want to parallelize with a call to &lt;code&gt;ado&lt;/code&gt; an watch your program run in parallel! Like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;ado {&#xA;  for {&#xA;    ...&#xA;  } yield ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage (custom monads)&lt;/h2&gt; &#xA;&lt;p&gt;On the off chance that &lt;code&gt;avocADO&lt;/code&gt; doesn&#39;t provide an instance for your favourite effect monad, you might have to write an instance of our &lt;code&gt;AvocADO&lt;/code&gt; typeclass yourself. Don&#39;t worry, it&#39;s relatively straightforward.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;AvocADO&lt;/code&gt; is just a &lt;code&gt;Monad&lt;/code&gt; with a changed name, so that it can be easily associated with &lt;code&gt;avocADO&lt;/code&gt;. So if you want to write an instance for a class called &lt;code&gt;Effect&lt;/code&gt; it might look like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;given AvocADO[Effect] = new AvocADO[Effect] {&#xA;  def pure[A](a: A): Effect[A] = Effect.pure(a)&#xA;  def map[A, B](fa: Effect[A], f: A =&amp;gt; B): Effect[B] = fa.map(f)&#xA;  def zip[A, B](fa: Effect[A], fb: Effect[B]): Effect[(A, B)] = fa.zipPar(fb) // This is the most important method&#xA;  def flatMap[A, B](fa: Effect[A], f: A =&amp;gt; Effect[B]): Effect[B] = fa.flatMap(f)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Every parallel part of the computation will be rewritten to a call to &lt;code&gt;zip&lt;/code&gt;, so in order to achieve any speedup, you have to provide a parallel implementation for &lt;code&gt;zip&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;p&gt;Inspired by &lt;a href=&#34;https://gitlab.haskell.org/ghc/ghc/-/wikis/applicative-do&#34;&gt;Haskell&#39;s Applicative do-notation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Similar project: &lt;a href=&#34;https://github.com/kitlangton/parallel-for&#34;&gt;&lt;code&gt;kitlangton/parallel-for&lt;/code&gt;&lt;/a&gt; (only for Scala 2)&lt;/p&gt;</summary>
  </entry>
</feed>