<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-19T02:00:46Z</updated>
  <subtitle>Weekly Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>chipsalliance/treadle</title>
    <updated>2023-02-19T02:00:46Z</updated>
    <id>tag:github.com,2023-02-19:/chipsalliance/treadle</id>
    <link href="https://github.com/chipsalliance/treadle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Chisel/Firrtl execution engine&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Treadle -- A Chisel/Firrtl Execution Engine&lt;/h1&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/freechipsproject/firrtl?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/freechipsproject/firrtl.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/freechipsproject/firrtl&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/freechipsproject/treadle/workflows/Test/badge.svg?sanitize=true&#34; alt=&#34;Test&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Treadle&lt;/strong&gt; is an experimental circuit simulator that executes low Firrtl IR. It is based on earlier work on the &lt;a href=&#34;https://github.com/freechipsproject/firrtl-interpreter&#34;&gt;firrtl_interpreter&lt;/a&gt; It will be one of the standard back-ends available as part of the &lt;a href=&#34;https://github.com/ucb-bar/chisel-testers.git&#34;&gt;chisel-testers&lt;/a&gt; project, and thus one of the tools in the &lt;a href=&#34;https://github.com/freechipsproject&#34;&gt;freechipsproject/chisel3&lt;/a&gt; hardware synthesis toolbox. This project provides a test harness supporting a peek, poke expect model.&lt;br&gt; It also provides a interactive simulator shell or repl (see treadle.sh) that allows fine grained incremental execution of a circuit. In combination with a scala debugger such as Eclipse or IntelliJ it can be a very powerful way of analyzing problematic behavior.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ucb-bar/chisel3.git&#34;&gt;Chisel3&lt;/a&gt; is a high-level functional circuit generator. It produces &lt;strong&gt;Flexible Intermediate Representation for RTL&lt;/strong&gt; or &lt;strong&gt;FIRRTL&lt;/strong&gt;. The &lt;a href=&#34;https://github.com/ucb-bar/firrtl.git&#34;&gt;Firrtl&lt;/a&gt; project parses and transforms firrtl. It also provides mechanisms for emitting verilog, for processing by downstream toolchains. &lt;strong&gt;Treadle&lt;/strong&gt; parses and execute the LoFirrtl subset of Firrtl. &lt;strong&gt;Treadle&lt;/strong&gt; has a short spin up time and is close to the performance of verilator simulations. It can be useful for an initial debugging of Chisel circuits and is also used for other forms of circuit analysis.&lt;/p&gt; &#xA;&lt;h2&gt;Using Treadle&lt;/h2&gt; &#xA;&lt;h3&gt;Attach it to your project&lt;/h3&gt; &#xA;&lt;p&gt;If you are using the &lt;a href=&#34;https://github.com/freechipsproject/chisel-testers&#34;&gt;freechipsproject/chisel-testers&lt;/a&gt; you will have access to &lt;strong&gt;Treadle&lt;/strong&gt; through it&#39;s dependency declarations.&lt;/p&gt; &#xA;&lt;p&gt;If chisel-testers is not part of your tool chain then you must add the dependency explicitly. To do so, in your project &lt;code&gt;build.sbt&lt;/code&gt; add a dependency on&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;edu.berkeley.cs&#34; %% &#34;treadle&#34; % &#34;1.1-SNAPSHOT&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a number of different ways to specify this dependency in the build.sbt file. If you have based your circuit on the &lt;a href=&#34;https://github.com/freechipsproject/chisel-template.git&#34;&gt;Chisel-template&lt;/a&gt; the addition should look like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies ++= Seq(&#xA;  &#34;edu.berkeley.cs&#34; %% &#34;chisel3&#34; % chiselVersion,&#xA;  &#34;edu.berkeley.cs&#34; %% &#34;chisel-iotesters&#34; % &#34;1.0&#34;,&#xA;  &#34;edu.berkeley.cs&#34; %% &#34;treadle&#34; % &#34;1.1-SNAPSHOT&#34;,&#xA;  &#34;org.scalatest&#34; %% &#34;scalatest&#34; % &#34;3.2.8&#34; % &#34;test&#34;,&#xA;  &#34;org.scalacheck&#34; %% &#34;scalacheck&#34; % &#34;1.12.4&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;for other usage consult &lt;strong&gt;sbt&lt;/strong&gt; documentation&lt;/p&gt; &#xA;&lt;h3&gt;Use the Tester Metaphor&lt;/h3&gt; &#xA;&lt;p&gt;The easiest way to invoke the interpreter is through a test based harness. The InterpretiveTester is very similar to the chisel ClassicTester, it&#39;s api consists of poke, peek and expect statements. Here is an example of a GCD Circuit&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import chisel3._&#xA;import treadle.TreadleTester&#xA;import org.scalatest.{Matchers, FlatSpec}&#xA;&#xA;object GCDCalculator {&#xA;  def computeGcd(a: Int, b: Int): (Int, Int) = {&#xA;    var x = a&#xA;    var y = b&#xA;    var depth = 1&#xA;    while(y &amp;gt; 0 ) {&#xA;      if (x &amp;gt; y) {&#xA;        x -= y&#xA;      }&#xA;      else {&#xA;        y -= x&#xA;      }&#xA;      depth += 1&#xA;    }&#xA;    (x, depth)&#xA;  }&#xA;}&#xA;&#xA;class GCD extends Module {&#xA;  val io = IO(new Bundle {&#xA;    val a  = Input(UInt(16.W))&#xA;    val b  = Input(UInt(16.W)))&#xA;    val e  = Input(Bool())&#xA;    val z  = Output(UInt(16.W))&#xA;    val v  = Output(Bool())&#xA;  })&#xA;  val x  = Reg(UInt())&#xA;  val y  = Reg(UInt())&#xA;  when(x &amp;gt; y) { x := x - y }&#xA;    .elsewhen(x &amp;lt;= y) { y := y - x }&#xA;  when (io.e) { x := io.a; y := io.b }&#xA;  io.z := x&#xA;  io.v := y === UInt(0)&#xA;}&#xA;&#xA;class TreadleUsageSpec extends FlatSpec with Matchers {&#xA;&#xA;  &#34;GCD&#34; should &#34;return correct values for a range of inputs&#34; in {&#xA;    val s = Driver.emit(() =&amp;gt; new GCD)&#xA;&#xA;    val tester = TreadleTester(s)&#xA;&#xA;    for {&#xA;      i &amp;lt;- 1 to 100&#xA;      j &amp;lt;- 1 to 100&#xA;    } {&#xA;      tester.poke(&#34;io_a&#34;, i)&#xA;      tester.poke(&#34;io_b&#34;, j)&#xA;      tester.poke(&#34;io_e&#34;, 1)&#xA;      tester.step()&#xA;      tester.poke(&#34;io_e&#34;, 0)&#xA;&#xA;      var cycles = 0&#xA;      while (tester.peek(&#34;io_v&#34;) != BigInt(1)) {&#xA;        tester.step()&#xA;        cycles += 1&#xA;      }&#xA;      tester.expect(&#34;io_z&#34;, BigInt(GCDCalculator.computeGcd(i, j)._1))&#xA;      // uncomment the println to see a lot of output&#xA;      // println(f&#34;GCD(${i}%3d, ${j}%3d) =&amp;gt; ${interpretiveTester.peek(&#34;io_z&#34;)}%3d in $cycles%3d cycles&#34;)&#xA;    }&#xA;    tester.report()&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Style conventions ScalaFmt&lt;/h3&gt; &#xA;&lt;p&gt;Treadle is the first repo in the chisel family to use the &lt;a href=&#34;https://scalameta.org/scalafmt/&#34;&gt;ScalaFmt&lt;/a&gt; code formatter. The plan going forward from 12/9/2019 is that all Scala code in PRs to Treadle after that date must be formatted using the specification in the &lt;code&gt;.scalafmt.conf&lt;/code&gt; file. Doing the formatting is simple and can be done via IntelliJ or &lt;code&gt;sbt&lt;/code&gt;. More details can be found on the link above. For the present we are also interested in comments on the formatting decisions we have made. Keep in mind that there is no set of rules that will satisfy everyone.&lt;/p&gt; &#xA;&lt;h3&gt;About ports and names&lt;/h3&gt; &#xA;&lt;p&gt;The firrtl transformations that result in LoFirrtl alter the names of ports. What would be io.a becomes io_a and so forth.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ucb-bar/ibex-wrapper</title>
    <updated>2023-02-19T02:00:46Z</updated>
    <id>tag:github.com,2023-02-19:/ucb-bar/ibex-wrapper</id>
    <link href="https://github.com/ucb-bar/ibex-wrapper" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Wrapper for lowRISC Ibex&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ibex Wrapper&lt;/h1&gt; &#xA;&lt;p&gt;This wraps up the 32-bit Ibex embedded core (&lt;a href=&#34;https://github.com/lowRISC/ibex&#34;&gt;https://github.com/lowRISC/ibex&lt;/a&gt;) into a Rocket Chip based tile to be used in Chipyard.&lt;/p&gt; &#xA;&lt;p&gt;For more information on how to use this wrapper, refer to (&lt;a href=&#34;https://github.com/ucb-bar/chipyard&#34;&gt;https://github.com/ucb-bar/chipyard&lt;/a&gt;).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ucb-bar/cva6-wrapper</title>
    <updated>2023-02-19T02:00:46Z</updated>
    <id>tag:github.com,2023-02-19:/ucb-bar/cva6-wrapper</id>
    <link href="https://github.com/ucb-bar/cva6-wrapper" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Wrapper for ETH Ariane Core&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CVA6 Wrapper&lt;/h1&gt; &#xA;&lt;p&gt;This wraps up the CVA6 6-stage RISC-V CPU (formerly known as Ariane) (&lt;a href=&#34;https://github.com/openhwgroup/cva6&#34;&gt;https://github.com/openhwgroup/cva6&lt;/a&gt;) into a Rocket Chip based tile to be used in Chipyard.&lt;/p&gt; &#xA;&lt;p&gt;For more information on how to use this wrapper, refer to (&lt;a href=&#34;https://github.com/ucb-bar/chipyard&#34;&gt;https://github.com/ucb-bar/chipyard&lt;/a&gt;).&lt;/p&gt;</summary>
  </entry>
</feed>