<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-04T01:59:29Z</updated>
  <subtitle>Weekly Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zio/zio-quickstarts</title>
    <updated>2024-02-04T01:59:29Z</updated>
    <id>tag:github.com,2024-02-04:/zio/zio-quickstarts</id>
    <link href="https://github.com/zio/zio-quickstarts" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A minimal quickstart ZIO application for writing a RESTful Web Service&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ZIO Quickstarts&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains a collection of quickstarts for ZIO. Each quickstart is a self-contained project that demonstrates a particular aspect of ZIO. The quickstarts are designed to be easy to run and explore.&lt;/p&gt; &#xA;&lt;p&gt;To learn about each quickstart, we have a dedicated article about it at the ZIO documentation website. You can find the list of quickstart articles &lt;a href=&#34;https://zio.dev/guides/#quickstart-guides&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Running Quickstarts&lt;/h2&gt; &#xA;&lt;p&gt;First, open the console and clone the project using &lt;code&gt;git&lt;/code&gt; (or you can simply download the project) and then to the directory of the quickstart you want to run, e.g. &lt;code&gt;zio-quickstart-restful-webservice&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;git clone git@github.com:zio/zio-quickstarts.git &#xA;cd zio-quickstarts/zio-quickstart-restful-webservice&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you are inside the project directory, run the application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sbt run&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>ucb-bar/fixedpoint</title>
    <updated>2024-02-04T01:59:29Z</updated>
    <id>tag:github.com,2024-02-04:/ucb-bar/fixedpoint</id>
    <link href="https://github.com/ucb-bar/fixedpoint" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Chisel Fixed-Point Arithmetic Library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Fixed-Point User Library for Chisel &lt;a href=&#34;https://github.com/ucb-bar/fixedpoint/actions&#34;&gt;&lt;img src=&#34;https://github.com/ucb-bar/fixedpoint/actions/workflows/test.yml/badge.svg?branch=master&#34; alt=&#34;Test&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;This is an attempt to add the FixedPoint type to Chisel as a user-level library. The main motivation behind this is the deprecation of FixedPoint starting from &lt;a href=&#34;https://github.com/chipsalliance/chisel/releases/v3.6.0&#34;&gt;Chisel v3.6&lt;/a&gt;, where Chisel is transitioning from Scala for Chisel compiler (SFC) to MLIR FIRRTL compiler. In this transition, FixedPoint &lt;a href=&#34;https://github.com/chipsalliance/chisel/issues/3161&#34;&gt;was dropped at the FIRRTL level&lt;/a&gt;, meaning that FixedPoint would need to be re-implemented as something that depends on the remaining existing Chisel types, and by using Chisel&#39;s public API. This library aims to provide that user-level implementation.&lt;/p&gt; &#xA;&lt;p&gt;The main goal of this library is to faithfully reproduce Chisel&#39;s established FixedPoint interface, so that existing code that depends on it can just replace Chisel&#39;s FixedPoint imports with this library&#39;s FixedPoint imports and have the code work just as it did before. To that end, the following classes/traits have been (re)implemented:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;FixedPoint&lt;/li&gt; &#xA; &lt;li&gt;BinaryPoint, KnownBinaryPoint, UnknownBinaryPoint&lt;/li&gt; &#xA; &lt;li&gt;HasBinaryPoint&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Currently, this library works with &lt;a href=&#34;https://github.com/chipsalliance/chisel/releases/v5.1.0&#34;&gt;Chisel v5.1.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Here is an example module using this library&#39;s FixedPoint type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import chisel3._&#xA;import circt.stage.ChiselStage&#xA;import fixedpoint._&#xA;&#xA;class Example extends Module {&#xA;  val in = IO(Input(FixedPoint(8.W, 4.BP)))&#xA;  val out1 = IO(Output(FixedPoint(8.W, 5.BP)))&#xA;  val out2 = IO(Output(FixedPoint()))&#xA;&#xA;  out1 := in&#xA;  out2 := WireDefault(3.14.F(8.BP))&#xA;}&#xA;&#xA;object ExampleApp extends App {&#xA;  println(ChiselStage.emitSystemVerilog(new Example))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This outputs the following SystemVerilog code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-systemverilog&#34;&gt;// Generated by CIRCT firtool-1.43.0&#xA;module Example(&#x9;// &amp;lt;stdin&amp;gt;:3:10&#xA;  input         clock,&#x9;// &amp;lt;stdin&amp;gt;:4:11&#xA;                reset,&#x9;// &amp;lt;stdin&amp;gt;:5:11&#xA;  input  [7:0]  in,&#x9;// src/main/scala/Example.scala:6:14&#xA;  output [7:0]  out1,&#x9;// src/main/scala/Example.scala:7:16&#xA;  output [10:0] out2&#x9;// src/main/scala/Example.scala:8:16&#xA;);&#xA;&#xA;  assign out1 = {in[6:0], 1&#39;h0}; // &amp;lt;stdin&amp;gt;:3:10, src/main/scala/Example.scala:10:8&#xA;  assign out2 = 11&#39;h324;         // &amp;lt;stdin&amp;gt;:3:10, src/main/scala/Example.scala:11:22&#xA;endmodule&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How It Works&lt;/h2&gt; &#xA;&lt;p&gt;FixedPoint is implemented as an extension of &lt;code&gt;Record&lt;/code&gt;, which has one &lt;em&gt;anonymous&lt;/em&gt; data field of type &lt;code&gt;SInt&lt;/code&gt;; it is also an &lt;a href=&#34;https://github.com/chipsalliance/chisel/raw/v5.1.0/core/src/main/scala/chisel3/experimental/OpaqueType.scala&#34;&gt;opaque type&lt;/a&gt;. Most of the arithmetic involving FixedPoints has been delegated to the &lt;code&gt;SInt&lt;/code&gt; arithmetic of the underlying data field, where shift operations are first used to align the data of FixedPoints that have different binary points. Connect methods have also been overridden to account for data alignment of FixedPoints with different binary points, and to implement binary point inference.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;It was challenging to implement FixedPoint using Chisel&#39;s public API as some of the needed functionality for FixedPoints was originally implemented in Chisel&#39;s package-private objects, which cannot be accessed or altered from a user-level library. Due to this issue, some of the original FixedPoint functionality could not be implemented without limited workarounds. Here is the current list of limitations of this implementation of FixedPoint:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;FixedPoints with different binary points are not aligned properly when used inside Chisel&#39;s Muxes (&lt;code&gt;Mux&lt;/code&gt;, &lt;code&gt;Mux1H&lt;/code&gt;, &lt;code&gt;PriorityMux&lt;/code&gt;, &lt;code&gt;MuxLookup&lt;/code&gt;, &lt;code&gt;MuxCase&lt;/code&gt;). To that end, these objects have been redefined in the package &lt;code&gt;fixedpoint.shadow&lt;/code&gt; to align FixedPoints by width and binary point before calling Chisel&#39;s corresponding Mux objects. In order to make FixedPoint work properly with Muxes, you have to import the new Mux definitions as follows: &lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import fixedpoint.shadow.{Mux, Mux1H, PriorityMux, MuxLookup, MuxCase}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Records with inferred widths cannot be used inside &lt;code&gt;Mux1H&lt;/code&gt;. If you want to use FixedPoints inside a &lt;code&gt;Mux1H&lt;/code&gt;, make sure that both width and binary point are specified in advance.&lt;/li&gt; &#xA; &lt;li&gt;FixedPoints do not connect properly if they are nested inside a &lt;code&gt;Bundle&lt;/code&gt; or &lt;code&gt;Record&lt;/code&gt;. If you have a bundle/record that has a FixedPoint field, you will have to extend it with the &lt;code&gt;ForceElementwiseConnect&lt;/code&gt; trait. If you have a bundle &lt;code&gt;Foo&lt;/code&gt; defined as: &lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Foo extends Bundle {&#xA;  val data = FixedPoint(8.W, 4.BP)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; ...then you will have to redefine it as: &lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Foo(implicit val ct: ClassTag[Foo]) extends Bundle&#xA;  with ForceElementwiseConnect[Foo] {&#xA;  val data = FixedPoint(8.W, 4.BP)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; If you have multiple levels of nesting inside Bundles, each bundle at every level needs to extend &lt;code&gt;ForceElementwiseConnect&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;FixedPoints do not connect properly if they are part of a &lt;code&gt;Vec&lt;/code&gt;. &lt;strong&gt;Currently, there is no solution available for this problem.&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>