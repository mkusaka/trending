<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-03T02:22:00Z</updated>
  <subtitle>Weekly Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>softwaremill/tapir</title>
    <updated>2022-06-03T02:22:00Z</updated>
    <id>tag:github.com,2022-06-03:/softwaremill/tapir</id>
    <link href="https://github.com/softwaremill/tapir" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Declarative, type-safe web endpoints library&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/banner.png&#34; alt=&#34;tapir, or Typed API descRiptions&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/softwaremill/tapir?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Join%20Chat.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/softwaremill/tapir&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/softwaremill/tapir/actions?query=workflow%3A%22CI%22&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/com.softwaremill.sttp.tapir/tapir-core_2.13&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/com.softwaremill.sttp.tapir/tapir-core_2.13/badge.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Intro&lt;/h2&gt; &#xA;&lt;p&gt;With tapir, you can describe HTTP API endpoints as immutable Scala values. Each endpoint can contain a number of input and output parameters. An endpoint specification can be interpreted as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a server, given the &#34;business logic&#34;: a function, which computes output parameters based on input parameters. Currently supported: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/server/akkahttp.html&#34;&gt;Akka HTTP&lt;/a&gt; &lt;code&gt;Route&lt;/code&gt;s/&lt;code&gt;Directive&lt;/code&gt;s&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/server/http4s.html&#34;&gt;Http4s&lt;/a&gt; &lt;code&gt;HttpRoutes[F]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/server/netty.html&#34;&gt;Netty&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/server/finatra.html&#34;&gt;Finatra&lt;/a&gt; &lt;code&gt;FinatraRoute&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/server/play.html&#34;&gt;Play&lt;/a&gt; &lt;code&gt;Route&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/server/vertx.html&#34;&gt;Vert.X&lt;/a&gt; &lt;code&gt;Router =&amp;gt; Route&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/server/ziohttp.html&#34;&gt;ZIO Http&lt;/a&gt; &lt;code&gt;Http&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/server/armeria.html&#34;&gt;Armeria&lt;/a&gt; &lt;code&gt;HttpServiceWithRoutes&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/server/aws.html&#34;&gt;aws&lt;/a&gt; through Lambda/SAM/Terraform&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;a client, which is a function from input parameters to output parameters. Currently supported: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/client/sttp.html&#34;&gt;sttp&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/client/play.html&#34;&gt;Play&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/client/http4s.html&#34;&gt;http4s&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;documentation. Currently supported: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/docs/openapi.html&#34;&gt;OpenAPI&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://tapir.softwaremill.com/en/latest/docs/asyncapi.html&#34;&gt;AsyncAPI&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Depending on how you prefer to explore the library, take a look at one of the &lt;a href=&#34;https://tapir.softwaremill.com/en/latest/examples.html&#34;&gt;examples&lt;/a&gt; or &lt;a href=&#34;https://tapir.softwaremill.com/en/latest/index.html&#34;&gt;head over to the docs&lt;/a&gt; for a more detailed description of how tapir works!&lt;/p&gt; &#xA;&lt;h2&gt;Why tapir?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;type-safety&lt;/strong&gt;: compile-time guarantees, develop-time completions, read-time information&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;declarative&lt;/strong&gt;: separate the shape of the endpoint (the &#34;what&#34;), from the server logic (the &#34;how&#34;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;OpenAPI / Swagger integration&lt;/strong&gt;: generate documentation from endpoint descriptions&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;observability&lt;/strong&gt;: leverage the metadata to report rich metrics and tracing information&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;abstraction&lt;/strong&gt;: re-use common endpoint definitions, as well as individual inputs/outputs&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;library, not a framework&lt;/strong&gt;: integrates with your stack&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Adopters&lt;/h2&gt; &#xA;&lt;p&gt;Is your company already using tapir? We&#39;re continually expanding the &#34;adopters&#34; section in the documentation; the more the merrier! It would be great to feature your company&#39;s logo, but in order to do that, we&#39;ll need written permission to avoid any legal misunderstandings.&lt;/p&gt; &#xA;&lt;p&gt;Please email us at &lt;a href=&#34;mailto:tapir@softwaremill.com&#34;&gt;tapir@softwaremill.com&lt;/a&gt; from your company&#39;s email with a link to your logo (if we can use it, of course!) or with details who to kindly ask for permission to feature the logo in tapir&#39;s documentation. We&#39;ll handle the rest.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.adobe.com&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/adobe.png&#34; alt=&#34;Adobe&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.colisweb.com&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/colisweb.png&#34; alt=&#34;Colisweb&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://swissborg.com&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/swissborg.png&#34; alt=&#34;Swissborg&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://kaizo.com&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/kaizo.png&#34; alt=&#34;Kaizo&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.process.st/&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/process_street.png&#34; alt=&#34;Process Street&#34; width=&#34;100&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.tranzzo.com/&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/tranzzo.svg?sanitize=true&#34; alt=&#34;Tranzzo&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.kelkoogroup.com&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/kelkoogroup.png&#34; alt=&#34;Kelkoo group&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.softwaremill.com/&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/softwaremill.png&#34; alt=&#34;SoftwareMill&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.carvana.com&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/carvana.svg?sanitize=true&#34; alt=&#34;Carvana&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.moneyfarm.com&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/moneyfarm.png&#34; alt=&#34;Moneyfarm&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.ocadogroup.com/about-us/ocado-technology&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/ocado.png&#34; alt=&#34;Ocado Technology&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.wegtam.com&#34;&gt;&lt;img src=&#34;https://github.com/softwaremill/tapir/raw/master/doc/adopters/wegtam.svg?sanitize=true&#34; alt=&#34;Wegtam&#34; width=&#34;160&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Teaser&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import sttp.tapir._&#xA;import sttp.tapir.generic.auto._&#xA;import sttp.tapir.json.circe._&#xA;import io.circe.generic.auto._&#xA;&#xA;type Limit = Int&#xA;type AuthToken = String&#xA;case class BooksQuery(genre: String, year: Int)&#xA;case class Book(title: String)&#xA;&#xA;&#xA;// Define an endpoint&#xA;&#xA;val booksListing: PublicEndpoint[(BooksQuery, Limit, AuthToken), String, List[Book], Any] = &#xA;  endpoint&#xA;    .get&#xA;    .in((&#34;books&#34; / path[String](&#34;genre&#34;) / path[Int](&#34;year&#34;)).mapTo[BooksQuery])&#xA;    .in(query[Limit](&#34;limit&#34;).description(&#34;Maximum number of books to retrieve&#34;))&#xA;    .in(header[AuthToken](&#34;X-Auth-Token&#34;))&#xA;    .errorOut(stringBody)&#xA;    .out(jsonBody[List[Book]])&#xA;&#xA;&#xA;// Generate OpenAPI documentation&#xA;&#xA;import sttp.apispec.openapi.circe.yaml._&#xA;import sttp.tapir.docs.openapi.OpenAPIDocsInterpreter&#xA;&#xA;val docs = OpenAPIDocsInterpreter().toOpenAPI(booksListing, &#34;My Bookshop&#34;, &#34;1.0&#34;)&#xA;println(docs.toYaml)&#xA;&#xA;&#xA;// Convert to akka-http Route&#xA;&#xA;import sttp.tapir.server.akkahttp.AkkaHttpServerInterpreter&#xA;import akka.http.scaladsl.server.Route&#xA;import scala.concurrent.Future&#xA;import scala.concurrent.ExecutionContext.Implicits.global&#xA;&#xA;def bookListingLogic(bfy: BooksQuery,&#xA;                     limit: Limit,&#xA;                     at: AuthToken): Future[Either[String, List[Book]]] =&#xA;  Future.successful(Right(List(Book(&#34;The Sorrows of Young Werther&#34;))))&#xA;  &#xA;val booksListingRoute: Route = AkkaHttpServerInterpreter()&#xA;  .toRoute(booksListing.serverLogic((bookListingLogic _).tupled))&#xA;&#xA;&#xA;// Convert to sttp Request&#xA;&#xA;import sttp.tapir.client.sttp.SttpClientInterpreter&#xA;import sttp.client3._&#xA;&#xA;val booksListingRequest: Request[DecodeResult[Either[String, List[Book]]], Any] = &#xA;  SttpClientInterpreter()&#xA;    .toRequest(booksListing, Some(uri&#34;http://localhost:8080&#34;))&#xA;    .apply((BooksQuery(&#34;SF&#34;, 2016), 20, &#34;xyz-abc-123&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;tapir documentation is available at &lt;a href=&#34;http://tapir.softwaremill.com&#34;&gt;tapir.softwaremill.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart with sbt&lt;/h2&gt; &#xA;&lt;p&gt;Add the following dependency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sbt&#34;&gt;&#34;com.softwaremill.sttp.tapir&#34; %% &#34;tapir-core&#34; % &#34;1.0.0-RC2&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, import:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import sttp.tapir._&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And finally, type &lt;code&gt;endpoint.&lt;/code&gt; and see where auto-complete gets you!&lt;/p&gt; &#xA;&lt;h3&gt;Scala 2.12&lt;/h3&gt; &#xA;&lt;p&gt;Partial unification is now enabled by default from Scala 2.13. However, if you&#39;re using Scala 2.12 or older, then you&#39;ll need partial unification enabled in the compiler (alternatively, you&#39;ll need to manually provide type arguments in some cases):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sbt&#34;&gt;scalacOptions += &#34;-Ypartial-unification&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sidenote for scala 2.12.4 and higher: if you encounter an issue with compiling your project because of a &lt;code&gt;StackOverflowException&lt;/code&gt; related to &lt;a href=&#34;https://github.com/scala/bug/issues/10604&#34;&gt;this&lt;/a&gt; scala bug, please increase your stack memory. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sbt -J-Xss4M clean compile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Other sttp projects&lt;/h2&gt; &#xA;&lt;p&gt;sttp is a family of Scala HTTP-related projects, and currently includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/softwaremill/sttp&#34;&gt;sttp client&lt;/a&gt;: the Scala HTTP client you always wanted!&lt;/li&gt; &#xA; &lt;li&gt;sttp tapir: this project&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/softwaremill/sttp-model&#34;&gt;sttp model&lt;/a&gt;: simple HTTP model classes (used by client &amp;amp; tapir)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/softwaremill/sttp-shared&#34;&gt;sttp shared&lt;/a&gt;: shared web socket, FP abstractions, capabilities and streaming code.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/softwaremill/sttp-apispec&#34;&gt;sttp apispec&lt;/a&gt;: OpenAPI, AsyncAPI and JSON Schema models.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;All suggestions welcome :)&lt;/p&gt; &#xA;&lt;p&gt;See the list of &lt;a href=&#34;https://github.com/softwaremill/tapir/issues&#34;&gt;issues&lt;/a&gt; and pick one! Or report your own.&lt;/p&gt; &#xA;&lt;p&gt;If you are having doubts on the &lt;em&gt;why&lt;/em&gt; or &lt;em&gt;how&lt;/em&gt; something works, don&#39;t hesitate to ask a question on &lt;a href=&#34;https://gitter.im/softwaremill/tapir&#34;&gt;gitter&lt;/a&gt; or via github. This probably means that the documentation, scaladocs or code is unclear and be improved for the benefit of all.&lt;/p&gt; &#xA;&lt;h3&gt;Testing locally&lt;/h3&gt; &#xA;&lt;p&gt;The JS tests use &lt;a href=&#34;https://github.com/scala-js/scala-js-env-selenium/issues/119&#34;&gt;Gecko instead of Chrome&lt;/a&gt;, although this causes another problem: out of memory when running JS tests for multiple modules. Work-arounds:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;run only JVM tests for a specific Scala version using &lt;code&gt;testJVM2_13&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;test single JS projects&lt;/li&gt; &#xA; &lt;li&gt;use CI (GitHub Actions) to test all projects - the &lt;code&gt;.github/workflows/ci.yml&lt;/code&gt; enumerates them one by one&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can test only server/client/doc/other projects using &lt;code&gt;testServers&lt;/code&gt;, &lt;code&gt;testClients&lt;/code&gt;, &lt;code&gt;testDocs&lt;/code&gt; and &lt;code&gt;testOther&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To verify that the code snippet in docs compile, run &lt;code&gt;compileDocumentation&lt;/code&gt;. A full mdoc run is done during a release (when the documentation is generated).&lt;/p&gt; &#xA;&lt;h2&gt;Commercial Support&lt;/h2&gt; &#xA;&lt;p&gt;We offer commercial support for tapir and related technologies, as well as development services. &lt;a href=&#34;https://softwaremill.com&#34;&gt;Contact us&lt;/a&gt; to learn more about our offer!&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (C) 2018-2022 SoftwareMill &lt;a href=&#34;https://softwaremill.com&#34;&gt;https://softwaremill.com&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>playframework/playframework</title>
    <updated>2022-06-03T02:22:00Z</updated>
    <id>tag:github.com,2022-06-03:/playframework/playframework</id>
    <link href="https://github.com/playframework/playframework" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Play Framework&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Play Framework - The High Velocity Web Framework&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://twitter.com/playframework&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/playframework?label=follow&amp;amp;style=flat&amp;amp;logo=twitter&amp;amp;color=brightgreen&#34; alt=&#34;Twitter Follow&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/g5s2vtZ4Fa&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/931647755942776882?logo=discord&amp;amp;logoColor=white&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/playframework/playframework/discussions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/discussions/playframework/playframework?&amp;amp;logo=github&amp;amp;color=brightgreen&#34; alt=&#34;GitHub Discussions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stackoverflow.com/tags/playframework&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=stackoverflow&amp;amp;logo=stackoverflow&amp;amp;logoColor=fe7a16&amp;amp;color=brightgreen&amp;amp;message=playframework&#34; alt=&#34;StackOverflow&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.youtube.com/channel/UCRp6QDm5SDjbIuisUpxV9cg&#34;&gt;&lt;img src=&#34;https://img.shields.io/youtube/channel/views/UCRp6QDm5SDjbIuisUpxV9cg?label=watch&amp;amp;logo=youtube&amp;amp;style=flat&amp;amp;color=brightgreen&amp;amp;logoColor=ff0000&#34; alt=&#34;YouTube&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.twitch.tv/playframework&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitch/status/playframework?logo=twitch&amp;amp;logoColor=white&amp;amp;color=brightgreen&amp;amp;label=live%20stream&#34; alt=&#34;Twitch Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/playframework&#34;&gt;&lt;img src=&#34;https://img.shields.io/opencollective/all/playframework?label=financial%20contributors&amp;amp;logo=open-collective&#34; alt=&#34;OpenCollective&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/playframework/playframework/actions/workflows/build-test.yml&#34;&gt;&lt;img src=&#34;https://github.com/playframework/playframework/actions/workflows/build-test.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mvnrepository.com/artifact/com.typesafe.play/play_2.13&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.typesafe.play/play_2.13.svg?logo=apache-maven&#34; alt=&#34;Maven&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/playframework/playframework&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/repo-size/playframework/playframework.svg?logo=git&#34; alt=&#34;Repository size&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://scala-steward.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Scala_Steward-helping-blue.svg?style=flat&amp;amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAMAAAARSr4IAAAAVFBMVEUAAACHjojlOy5NWlrKzcYRKjGFjIbp293YycuLa3pYY2LSqql4f3pCUFTgSjNodYRmcXUsPD/NTTbjRS+2jomhgnzNc223cGvZS0HaSD0XLjbaSjElhIr+AAAAAXRSTlMAQObYZgAAAHlJREFUCNdNyosOwyAIhWHAQS1Vt7a77/3fcxxdmv0xwmckutAR1nkm4ggbyEcg/wWmlGLDAA3oL50xi6fk5ffZ3E2E3QfZDCcCN2YtbEWZt+Drc6u6rlqv7Uk0LdKqqr5rk2UCRXOk0vmQKGfc94nOJyQjouF9H/wCc9gECEYfONoAAAAASUVORK5CYII=&#34; alt=&#34;Scala Steward badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mergify.com&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint.svg?url=https://api.mergify.com/v1/badges/playframework/playframework&amp;amp;style=flat&#34; alt=&#34;Mergify Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The Play Framework combines productivity and performance making it easy to build scalable web applications with Java and Scala. Play is developer friendly with a &#34;just hit refresh&#34; workflow and built-in testing support. With Play, applications scale predictably due to a stateless and non-blocking architecture. By being RESTful by default, including assets compilers, JSON &amp;amp; WebSocket support, Play is a perfect fit for modern web &amp;amp; mobile applications.&lt;/p&gt; &#xA;&lt;h2&gt;Learn More&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.playframework.com&#34;&gt;www.playframework.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.playframework.com/download&#34;&gt;Download&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.playframework.com/documentation/latest/Installing&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.playframework.com/documentation/latest/NewApplication&#34;&gt;Create a new application&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.playframework.com/documentation/latest/ScalaHome&#34;&gt;Play for Scala developers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.playframework.com/documentation/latest/JavaHome&#34;&gt;Play for Java developers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.playframework.com/documentation/latest/BuildingFromSource&#34;&gt;Build from source&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/playframework/playframework/issues&#34;&gt;Search or create issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/tagged/playframework&#34;&gt;Get help&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.playframework.com/contributing&#34;&gt;Contribute&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Sponsors &amp;amp; Backers&lt;/h2&gt; &#xA;&lt;p&gt;If you find Play useful for work, please consider asking your company to support this Open Source project by &lt;a href=&#34;https://www.playframework.com/sponsors&#34;&gt;becoming a sponsor&lt;/a&gt;.&lt;br&gt; You can also individually sponsor the project by &lt;a href=&#34;https://www.playframework.com/sponsors&#34;&gt;becoming a backer&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://opencollective.com/playframework&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://opencollective.com/playframework/donate/button@2x.png?color=blue&#34; width=&#34;250&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;h3&gt;Thank you to our premium sponsors!&lt;/h3&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://informaticon.com/&#34;&gt;&lt;img src=&#34;https://www.playframework.com/assets/images/home/sponsors/61220b8306493af6a21b7db17de7f4b2-informaticon-logo-full-color.png&#34; width=&#34;250&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;https://cedarlakeventures.com/&#34;&gt;&lt;img src=&#34;https://www.playframework.com/assets/images/home/sponsors/bec2b526c9ce52c051f9089a10044867-cedar-lake-ventures.png&#34; width=&#34;250&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;https://iterable.com/&#34;&gt;&lt;img src=&#34;https://www.playframework.com/assets/images/home/sponsors/61ddb4c3665b621e6672181f97196748-iterable.png&#34; width=&#34;250&#34;&gt;&lt;/a&gt; &#xA; &lt;a href=&#34;https://pronto.net/&#34;&gt;&lt;img src=&#34;https://www.playframework.com/assets/images/home/sponsors/c77b1d664f10a1c9cb19b97c6d8bd204-pronto-software.png&#34; width=&#34;250&#34;&gt; &lt;/a&gt;&#xA; &lt;a href=&#34;https://civiform.us/&#34;&gt;&lt;img src=&#34;https://www.playframework.com/assets/images/home/sponsors/cb047b3782866c962c4d6a35b056b809-civiform.png&#34; width=&#34;250&#34;&gt; &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&lt;a href=&#34;https://civiform.us/&#34;&gt; &lt;h3&gt;Thank you to all our backers!&lt;/h3&gt; &lt;/a&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://civiform.us/&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://opencollective.com/playframework#section-contributors&#34;&gt;&lt;img src=&#34;https://opencollective.com/playframework/organizations.svg?width=890&amp;amp;button=false&amp;amp;avatarHeight=46&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opencollective.com/playframework#section-contributors&#34;&gt;&lt;img src=&#34;https://opencollective.com/playframework/individuals.svg?width=890&amp;amp;button=false&amp;amp;avatarHeight=46&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (C) Lightbend Inc. (&lt;a href=&#34;https://www.lightbend.com&#34;&gt;https://www.lightbend.com&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this project except in compliance with the License. You may obtain a copy of the License at &lt;a href=&#34;https://www.apache.org/licenses/LICENSE-2.0&#34;&gt;https://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>chipsalliance/chisel3</title>
    <updated>2022-06-03T02:22:00Z</updated>
    <id>tag:github.com,2022-06-03:/chipsalliance/chisel3</id>
    <link href="https://github.com/chipsalliance/chisel3" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Chisel 3: A Modern Hardware Design Language&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/docs/src/images/chisel_logo.svg?sanitize=true&#34; alt=&#34;Chisel 3&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Upcoming Events&lt;/h2&gt; &#xA;&lt;h3&gt;Chisel Dev Meeting&lt;/h3&gt; &#xA;&lt;p&gt;Chisel/FIRRTL development meetings happen every Monday and Tuesday from 1100--1200 PT.&lt;/p&gt; &#xA;&lt;p&gt;Call-in info and meeting notes are available &lt;a href=&#34;https://docs.google.com/document/d/1BLP2DYt59DqI-FgFCcjw8Ddl4K-WU0nHmQu0sZ_wAGo/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Chisel Community Conference 2021, Shanghai, China.&lt;/h3&gt; &#xA;&lt;p&gt;CCC is an annual gathering of Chisel community enthusiasts and technical exchange workshop. This year with the support of the Chisel development community and RISC-V World Conference China 2021 Committee, we have brought together designers and developers with hands-on experience in Chisel from home and abroad to share cutting-edge results and experiences from both the open source community as well as industry.&lt;br&gt; English translated recordings version will be updated soon.&lt;br&gt; Looking forward to CCC 2022! See you then!&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/freechipsproject/chisel3?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/chipsalliance/chisel3.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/freechipsproject/chisel3&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/chipsalliance/chisel3/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://github.com/chipsalliance/chisel3/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/tag/chipsalliance/chisel3.svg?include_prereleases&amp;amp;sort=semver&#34; alt=&#34;GitHub tag (latest SemVer)&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.chisel-lang.org&#34;&gt;&lt;strong&gt;Chisel&lt;/strong&gt;&lt;/a&gt; is a hardware design language that facilitates &lt;strong&gt;advanced circuit generation and design reuse for both ASIC and FPGA digital logic designs&lt;/strong&gt;. Chisel adds hardware construction primitives to the &lt;a href=&#34;https://www.scala-lang.org&#34;&gt;Scala&lt;/a&gt; programming language, providing designers with the power of a modern programming language to write complex, parameterizable circuit generators that produce synthesizable Verilog. This generator methodology enables the creation of re-usable components and libraries, such as the FIFO queue and arbiters in the &lt;a href=&#34;https://www.chisel-lang.org/api/latest/#chisel3.util.package&#34;&gt;Chisel Standard Library&lt;/a&gt;, raising the level of abstraction in design while retaining fine-grained control.&lt;/p&gt; &#xA;&lt;p&gt;For more information on the benefits of Chisel see: &lt;a href=&#34;https://stackoverflow.com/questions/53007782/what-benefits-does-chisel-offer-over-classic-hardware-description-languages&#34;&gt;&#34;What benefits does Chisel offer over classic Hardware Description Languages?&#34;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Chisel is powered by &lt;a href=&#34;https://github.com/chipsalliance/firrtl&#34;&gt;FIRRTL (Flexible Intermediate Representation for RTL)&lt;/a&gt;, a hardware compiler framework that performs optimizations of Chisel-generated circuits and supports custom user-defined circuit transformations.&lt;/p&gt; &#xA;&lt;h2&gt;What does Chisel code look like?&lt;/h2&gt; &#xA;&lt;p&gt;Consider an FIR filter that implements a convolution operation, as depicted in this block diagram:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/docs/src/images/fir_filter.svg?sanitize=true&#34; width=&#34;512&#34;&gt; &#xA;&lt;p&gt;While Chisel provides similar base primitives as synthesizable Verilog, and &lt;em&gt;could&lt;/em&gt; be used as such:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// 3-point moving sum implemented in the style of a FIR filter&#xA;class MovingSum3(bitWidth: Int) extends Module {&#xA;  val io = IO(new Bundle {&#xA;    val in = Input(UInt(bitWidth.W))&#xA;    val out = Output(UInt(bitWidth.W))&#xA;  })&#xA;&#xA;  val z1 = RegNext(io.in)&#xA;  val z2 = RegNext(z1)&#xA;&#xA;  io.out := (io.in * 1.U) + (z1 * 1.U) + (z2 * 1.U)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;the power of Chisel comes from the ability to create generators, such as an FIR filter that is defined by the list of coefficients:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Generalized FIR filter parameterized by the convolution coefficients&#xA;class FirFilter(bitWidth: Int, coeffs: Seq[UInt]) extends Module {&#xA;  val io = IO(new Bundle {&#xA;    val in = Input(UInt(bitWidth.W))&#xA;    val out = Output(UInt(bitWidth.W))&#xA;  })&#xA;  // Create the serial-in, parallel-out shift register&#xA;  val zs = Reg(Vec(coeffs.length, UInt(bitWidth.W)))&#xA;  zs(0) := io.in&#xA;  for (i &amp;lt;- 1 until coeffs.length) {&#xA;    zs(i) := zs(i-1)&#xA;  }&#xA;&#xA;  // Do the multiplies&#xA;  val products = VecInit.tabulate(coeffs.length)(i =&amp;gt; zs(i) * coeffs(i))&#xA;&#xA;  // Sum up the products&#xA;  io.out := products.reduce(_ + _)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and use and re-use them across designs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val movingSum3Filter = Module(new FirFilter(8, Seq(1.U, 1.U, 1.U)))  // same 3-point moving sum filter as before&#xA;val delayFilter = Module(new FirFilter(8, Seq(0.U, 1.U)))  // 1-cycle delay as a FIR filter&#xA;val triangleFilter = Module(new FirFilter(8, Seq(1.U, 2.U, 3.U, 2.U, 1.U)))  // 5-point FIR filter with a triangle impulse response&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above can be converted to Verilog using &lt;code&gt;ChiselStage&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import chisel3.stage.{ChiselStage, ChiselGeneratorAnnotation}&#xA;&#xA;(new chisel3.stage.ChiselStage).execute(&#xA;  Array(&#34;-X&#34;, &#34;verilog&#34;),&#xA;  Seq(ChiselGeneratorAnnotation(() =&amp;gt; new FirFilter(8, Seq(1.U, 1.U, 1.U)))))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you may generate some Verilog directly for inspection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val verilogString = chisel3.emitVerilog(new FirFilter(8, Seq(0.U, 1.U)))&#xA;println(verilogString)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Bootcamp Interactive Tutorial&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://mybinder.org/v2/gh/freechipsproject/chisel-bootcamp/master&#34;&gt;&lt;strong&gt;online Chisel Bootcamp&lt;/strong&gt;&lt;/a&gt; is the recommended way to get started with and learn Chisel. &lt;strong&gt;No setup is required&lt;/strong&gt; (it runs in the browser), nor does it assume any prior knowledge of Scala.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/ucb-bar/chisel-tutorial&#34;&gt;&lt;strong&gt;classic Chisel tutorial&lt;/strong&gt;&lt;/a&gt; contains small exercises and runs on your computer.&lt;/p&gt; &#xA;&lt;h3&gt;A Textbook on Chisel&lt;/h3&gt; &#xA;&lt;p&gt;If you like a textbook to learn Chisel and also a bit of digital design in general, you may be interested in reading &lt;a href=&#34;http://www.imm.dtu.dk/~masca/chisel-book.html&#34;&gt;&lt;strong&gt;Digital Design with Chisel&lt;/strong&gt;&lt;/a&gt;. It is available in English, Chinese, Japanese, and Vietnamese.&lt;/p&gt; &#xA;&lt;h3&gt;Build Your Own Chisel Projects&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/SETUP.md&#34;&gt;the setup instructions&lt;/a&gt; for how to set up your environment to build Chisel locally.&lt;/p&gt; &#xA;&lt;p&gt;When you&#39;re ready to build your own circuits in Chisel, &lt;strong&gt;we recommend starting from the &lt;a href=&#34;https://github.com/freechipsproject/chisel-template&#34;&gt;Chisel Template&lt;/a&gt; repository&lt;/strong&gt;, which provides a pre-configured project, example design, and testbench. Follow the &lt;a href=&#34;https://github.com/freechipsproject/chisel-template&#34;&gt;chisel-template README&lt;/a&gt; to get started.&lt;/p&gt; &#xA;&lt;p&gt;If you insist on setting up your own project from scratch, your project needs to depend on both the chisel3-plugin (Scalac plugin) and the chisel3 library. For example, in SBT this could be expressed as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// build.sbt&#xA;scalaVersion := &#34;2.13.7&#34;&#xA;addCompilerPlugin(&#34;edu.berkeley.cs&#34; % &#34;chisel3-plugin&#34; % &#34;3.5.0&#34; cross CrossVersion.full)&#xA;libraryDependencies += &#34;edu.berkeley.cs&#34; %% &#34;chisel3&#34; % &#34;3.5.0&#34;&#xA;// We also recommend using chiseltest for writing unit tests &#xA;libraryDependencies += &#34;edu.berkeley.cs&#34; %% &#34;chiseltest&#34; % &#34;0.5.0&#34; % &#34;test&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Guide For New Contributors&lt;/h3&gt; &#xA;&lt;p&gt;If you are trying to make a contribution to this project, please read &lt;a href=&#34;https://github.com/Burnleydev1/chisel3/raw/recent_PR/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Design Verification&lt;/h3&gt; &#xA;&lt;p&gt;These simulation-based verification tools are available for Chisel:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/freechipsproject/chisel-testers&#34;&gt;&lt;strong&gt;iotesters&lt;/strong&gt;&lt;/a&gt;, specifically &lt;a href=&#34;https://github.com/freechipsproject/chisel-testers/wiki/Using%20the%20PeekPokeTester&#34;&gt;PeekPokeTester&lt;/a&gt;, provides constructs (&lt;code&gt;peek&lt;/code&gt;, &lt;code&gt;poke&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;) similar to a non-synthesizable Verilog testbench.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ucb-bar/chisel-testers2&#34;&gt;&lt;strong&gt;testers2&lt;/strong&gt;&lt;/a&gt; is an in-development replacement for PeekPokeTester, providing the same base constructs but with a streamlined interface and concurrency support with &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;h3&gt;Useful Resources&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/freechipsproject/chisel-cheatsheet/releases/latest/download/chisel_cheatsheet.pdf&#34;&gt;&lt;strong&gt;Cheat Sheet&lt;/strong&gt;&lt;/a&gt;, a 2-page reference of the base Chisel syntax and libraries&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.chisel-lang.org/api/latest/chisel3/index.html&#34;&gt;&lt;strong&gt;ScalaDoc&lt;/strong&gt;&lt;/a&gt;, a listing, description, and examples of the functionality exposed by Chisel&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gitter.im/freechipsproject/chisel3&#34;&gt;&lt;strong&gt;Gitter&lt;/strong&gt;&lt;/a&gt;, where you can ask questions or discuss anything Chisel&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.chisel-lang.org&#34;&gt;&lt;strong&gt;Website&lt;/strong&gt;&lt;/a&gt; (&lt;a href=&#34;https://github.com/freechipsproject/www.chisel-lang.org/&#34;&gt;source&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://scastie.scala-lang.org/9ga9i2DvQymKlA5JjS1ieA&#34;&gt;&lt;strong&gt;Scastie (3.5.0)&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.asic-world.com/verilog/veritut.html&#34;&gt;&lt;strong&gt;asic-world&lt;/strong&gt;&lt;/a&gt; If you aren&#39;t familiar with verilog, this is a good tutorial.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you are migrating from Chisel2, see &lt;a href=&#34;https://www.chisel-lang.org/chisel3/chisel3-vs-chisel2.html&#34;&gt;the migration guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Data Types Overview&lt;/h3&gt; &#xA;&lt;p&gt;These are the base data types for defining circuit components:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/docs/src/images/type_hierarchy.svg?sanitize=true&#34; alt=&#34;Image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributor Documentation&lt;/h2&gt; &#xA;&lt;p&gt;This section describes how to get started contributing to Chisel itself, including how to test your version locally against other projects that pull in Chisel using &lt;a href=&#34;https://www.scala-sbt.org/1.x/docs/Library-Dependencies.html&#34;&gt;sbt&#39;s managed dependencies&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Useful Resources for Contributors&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/#useful-resources&#34;&gt;Useful Resources&lt;/a&gt; for users are also helpful for contributors.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.google.com/presentation/d/114YihixFBPCfUnv1inqAL8UjsiWfcNWdPHX7SeqlRQc&#34;&gt;&lt;strong&gt;Chisel Breakdown Slides&lt;/strong&gt;&lt;/a&gt;, an introductory talk about Chisel&#39;s internals&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Compiling and Testing Chisel&lt;/h3&gt; &#xA;&lt;p&gt;You must first install required dependencies to build Chisel locally, please see &lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/SETUP.md&#34;&gt;the setup instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Clone and build the Chisel library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/chipsalliance/chisel3.git&#xA;cd chisel3&#xA;sbt compile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to run the following unit tests, you will need several tools on your &lt;code&gt;PATH&lt;/code&gt;, namely &lt;a href=&#34;https://www.veripool.org/verilator/&#34;&gt;verilator&lt;/a&gt;, &lt;a href=&#34;http://www.clifford.at/yosys/&#34;&gt;yosys&lt;/a&gt;, &lt;a href=&#34;https://github.com/chipsalliance/espresso&#34;&gt;espresso&lt;/a&gt;, and &lt;a href=&#34;https://github.com/Z3Prover/z3&#34;&gt;z3&lt;/a&gt;. Check that each is installed on your &lt;code&gt;PATH&lt;/code&gt; by running &lt;code&gt;which verilator&lt;/code&gt; and so on.&lt;/p&gt; &#xA;&lt;p&gt;If the compilation succeeded and the dependencies noted above are installed, you can then run the included unit tests by invoking:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sbt test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running Projects Against Local Chisel&lt;/h3&gt; &#xA;&lt;p&gt;To use the development version of Chisel (&lt;code&gt;master&lt;/code&gt; branch), you will need to build from source and &lt;code&gt;publishLocal&lt;/code&gt;. The repository version can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/build.sbt&#34;&gt;build.sbt&lt;/a&gt; file. As of the time of writing it was:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;version := &#34;3.6-SNAPSHOT&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To publish your version of Chisel to the local Ivy (sbt&#39;s dependency manager) repository, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sbt publishLocal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The compiled version gets placed in &lt;code&gt;~/.ivy2/local/edu.berkeley.cs/&lt;/code&gt;. If you need to un-publish your local copy of Chisel, remove the directory generated in &lt;code&gt;~/.ivy2/local/edu.berkeley.cs/&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to have your projects use this version of Chisel, you should update the &lt;code&gt;libraryDependencies&lt;/code&gt; setting in your project&#39;s build.sbt file to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;libraryDependencies += &#34;edu.berkeley.cs&#34; %% &#34;chisel3&#34; % &#34;3.6-SNAPSHOT&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building Chisel with FIRRTL in the same SBT Project&lt;/h3&gt; &#xA;&lt;p&gt;While we recommend using the library dependency approach as described above, it is possible to build Chisel and FIRRTL in a single SBT project.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Caveats&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This only works for the &#34;main&#34; configuration; you cannot build the Chisel tests this way because &lt;code&gt;treadle&lt;/code&gt; is only supported as a library dependency.&lt;/li&gt; &#xA; &lt;li&gt;Do not &lt;code&gt;publishLocal&lt;/code&gt; when building this way. The published artifact will be missing the FIRRTL dependency.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This works by using &lt;a href=&#34;http://eed3si9n.com/hot-source-dependencies-using-sbt-sriracha&#34;&gt;sbt-sriracha&lt;/a&gt;, an SBT plugin for toggling between source and library dependencies. It provides two JVM system properties that, when set, will tell SBT to include FIRRTL as a source project:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt.sourcemode&lt;/code&gt; - when set to true, SBT will look for FIRRTL in the workspace&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt.workspace&lt;/code&gt; - sets the root directory of the workspace&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# From root of this repo&#xA;git clone git@github.com:chipsalliance/firrtl.git&#xA;sbt -Dsbt.sourcemode=true -Dsbt.workspace=$PWD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is primarily useful for building projects that themselves want to include Chisel as a source dependency. As an example, see &lt;a href=&#34;https://github.com/chipsalliance/rocket-chip&#34;&gt;Rocket Chip&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Chisel3 Architecture Overview&lt;/h3&gt; &#xA;&lt;p&gt;The Chisel3 compiler consists of these main parts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;The frontend&lt;/strong&gt;, &lt;code&gt;chisel3.*&lt;/code&gt;, which is the publicly visible &#34;API&#34; of Chisel and what is used in Chisel RTL. These just add data to the...&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;The Builder&lt;/strong&gt;, &lt;code&gt;chisel3.internal.Builder&lt;/code&gt;, which maintains global state (like the currently open Module) and contains commands, generating...&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;The intermediate data structures&lt;/strong&gt;, &lt;code&gt;chisel3.firrtl.*&lt;/code&gt;, which are syntactically very similar to Firrtl. Once the entire circuit has been elaborated, the top-level object (a &lt;code&gt;Circuit&lt;/code&gt;) is then passed to...&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;The Firrtl emitter&lt;/strong&gt;, &lt;code&gt;chisel3.firrtl.Emitter&lt;/code&gt;, which turns the intermediate data structures into a string that can be written out into a Firrtl file for further processing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also included is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;The standard library&lt;/strong&gt; of circuit generators, &lt;code&gt;chisel3.util.*&lt;/code&gt;. These contain commonly used interfaces and constructors (like &lt;code&gt;Decoupled&lt;/code&gt;, which wraps a signal with a ready-valid pair) as well as fully parameterizable circuit generators (like arbiters and multiplexors).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Chisel Stage&lt;/strong&gt;, &lt;code&gt;chisel3.stage.*&lt;/code&gt;, which contains compilation and test functions that are invoked in the standard Verilog generation and simulation testing infrastructure. These can also be used as part of custom flows.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Chisel Sub-Projects&lt;/h3&gt; &#xA;&lt;p&gt;Chisel consists of 4 Scala projects; each is its own separate compilation unit:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/core&#34;&gt;&lt;code&gt;core&lt;/code&gt;&lt;/a&gt; is the bulk of the source code of Chisel, depends on &lt;code&gt;macros&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/src/main&#34;&gt;&lt;code&gt;src/main&lt;/code&gt;&lt;/a&gt; is the &#34;main&#34; that brings it all together and includes a &lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/src/main/scala/chisel3/util&#34;&gt;&lt;code&gt;util&lt;/code&gt;&lt;/a&gt; library, which depends on &lt;code&gt;core&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/plugin&#34;&gt;&lt;code&gt;plugin&lt;/code&gt;&lt;/a&gt; is the compiler plugin, no internal dependencies&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/chisel3/master/macros&#34;&gt;&lt;code&gt;macros&lt;/code&gt;&lt;/a&gt; is most of the macros used in Chisel, no internal dependencies&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Code that touches lots of APIs that are private to the &lt;code&gt;chisel3&lt;/code&gt; package should belong in &lt;code&gt;core&lt;/code&gt;, while code that is pure Chisel should belong in &lt;code&gt;src/main&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Which version should I use?&lt;/h3&gt; &#xA;&lt;p&gt;We encourage Chisel users (as opposed to Chisel developers), to use the latest release version of Chisel. This &lt;a href=&#34;https://github.com/freechipsproject/chisel-template&#34;&gt;chisel-template&lt;/a&gt; repository is kept up-to-date, depending on the most recent version of Chisel. The recommended version is also captured near the top of this README, and in the &lt;a href=&#34;https://github.com/chipsalliance/chisel3/releases&#34;&gt;Github releases&lt;/a&gt; section of this repo. If you encounter an issue with a released version of Chisel, please file an issue on GitHub mentioning the Chisel version and provide a simple test case (if possible). Try to reproduce the issue with the associated latest minor release (to verify that the issue hasn&#39;t been addressed).&lt;/p&gt; &#xA;&lt;p&gt;For more information on our versioning policy and what versions of the various Chisel ecosystem projects work together, see &lt;a href=&#34;https://www.chisel-lang.org/chisel3/docs/appendix/versioning.html&#34;&gt;Chisel Project Versioning&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re developing a Chisel library (or &lt;code&gt;chisel3&lt;/code&gt; itself), you&#39;ll probably want to work closer to the tip of the development trunk. By default, the master branches of the chisel repositories are configured to build and publish their version of the code as &lt;code&gt;Z.Y-SNAPSHOT&lt;/code&gt;. Updated SNAPSHOTs are publised on every push to master. You are encouraged to do your development against the latest SNAPSHOT, but note that neither API nor ABI compatibility is guaranteed so your code may break at any time.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>allenai/pnp</title>
    <updated>2022-06-03T02:22:00Z</updated>
    <id>tag:github.com,2022-06-03:/allenai/pnp</id>
    <link href="https://github.com/allenai/pnp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Probabilistic Neural Programming&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Probabilistic Neural Programs&lt;/h1&gt; &#xA;&lt;p&gt;Probabilistic Neural Programming (PNP) is a Scala library for expressing, training and running inference in neural network models that &lt;strong&gt;include discrete choices&lt;/strong&gt;. The enhanced expressivity of PNP is useful for structured prediction, reinforcement learning, and latent variable models.&lt;/p&gt; &#xA;&lt;p&gt;Probabilistic neural programs have several advantages over computation graph libraries for neural networks, such as TensorFlow:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Probabilistic inference&lt;/strong&gt; is implemented within the library. For example, running a beam search to (approximately) generate the highest-scoring output sequence of a sequence-to-sequence model takes 1 line of code in PNP.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Additional training algorithms&lt;/strong&gt; that require running inference during training are part of the library. This includes learning-to-search algorithms, such as LaSO, reinforcement learning, and training latent variable models.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Computation graphs&lt;/strong&gt; are a subset of probabilistic neural programs. We use &lt;a href=&#34;https://github.com/clab/dynet&#34;&gt;DyNet&lt;/a&gt; to express neural networks, which provides a rich set of operations and efficient training.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;This library depends on DyNet with the &lt;a href=&#34;https://github.com/clab/dynet/tree/master/contrib/swig&#34;&gt;Scala DyNet bindings&lt;/a&gt;. See the link for build instructions. After building this library, run the following commands from the &lt;code&gt;pnp&lt;/code&gt; root directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd lib&#xA;ln -s &amp;lt;PATH_TO_DYNET&amp;gt;/build/contrib/swig/dynet_swigJNI_scala.jar .&#xA;ln -s &amp;lt;PATH_TO_DYNET&amp;gt;/build/contrib/swig/dynet_swigJNI_dylib.jar .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it! Verify that your installation works by running &lt;code&gt;sbt test&lt;/code&gt; in the root directory.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;This section describes how to use probabilistic neural programs to define and train a model. The typical usage has three steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Define a model.&lt;/strong&gt; Models are implemented by writing a function that takes your problem input and outputs &lt;code&gt;Pnp[X]&lt;/code&gt; objects. The probabilistic neural program type &lt;code&gt;Pnp[X]&lt;/code&gt; represents a function from neural network parameters to probability distributions over values of type &lt;code&gt;X&lt;/code&gt;. Each program describes a (possibly infinite) space of executions, each of which returns a value of type &lt;code&gt;X&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Train.&lt;/strong&gt; Training is performed by passing a list of examples to a &lt;code&gt;Trainer&lt;/code&gt;, where each example consists of a &lt;code&gt;Pnp[X]&lt;/code&gt; object and a label. Labels are implemented as functions that assign costs to program executions or as conditional distributions over correct executions. Many training algorithms can be used, from loglikelihood to learning-to-search algorithms.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Run the model.&lt;/strong&gt; A model can be run on a new input by constructing the appropriate &lt;code&gt;Pnp[X]&lt;/code&gt; object, then running inference on this object with trained parameters.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;These steps are illustrated in detail for a sequence-to-sequence model in &lt;a href=&#34;https://raw.githubusercontent.com/allenai/pnp/master/src/main/scala/org/allenai/pnp/examples/Seq2Seq.scala&#34;&gt;Seq2Seq2.scala&lt;/a&gt;. For a more complex example, run the &lt;a href=&#34;https://raw.githubusercontent.com/allenai/pnp/master/experiments/geoquery/scripts/example.sh&#34;&gt;GeoQuery semantic parsing experiment&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Defining Probabilistic Neural Programs&lt;/h2&gt; &#xA;&lt;p&gt;Probabilistic neural programs are specified by writing the forward computation of a neural network, using the &lt;code&gt;choose&lt;/code&gt; operation to represent discrete choices. Roughly, we can write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val pnp = for {&#xA;  scores1 &amp;lt;- ... some neural net operations ...&#xA;  // Make a discrete choice&#xA;  x1 &amp;lt;- choose(values, scores1)&#xA;  scores2 &amp;lt;- ... more neural net operations, may depend on x1 ...&#xA;  ...&#xA;  xn &amp;lt;- choose(values, scoresn)&#xA;} yield {&#xA;  xn&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;pnp&lt;/code&gt; then represents a function that takes some neural network parameters and returns a distribution over possible values of &lt;code&gt;xn&lt;/code&gt; (which in turn depends on the values of intermediate choices). We evaluate &lt;code&gt;pnp&lt;/code&gt; by running inference, which simultaneously runs the forward pass of the network and performs probabilistic inference:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;nnParams = ... &#xA;val dist = pnp.beamSearch(10, nnParams)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Choose&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;choose&lt;/code&gt; operator defines a distribution over a list of values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val flip: Pnp[Boolean] = choose(Array(true, false), Array(0.5, 0.5))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This snippet creates a probability distribution that returns either true or false with 50% probability. &lt;code&gt;flip&lt;/code&gt; has type &lt;code&gt;Pnp[Boolean]&lt;/code&gt;, which represents a function from neural network parameters to probability distributions over values of type &lt;code&gt;Boolean&lt;/code&gt;. (In this case it&#39;s just a probability distribution since we haven&#39;t referenced any parameters.) Note that &lt;code&gt;flip&lt;/code&gt; is not a draw from the distribution, rather, &lt;em&gt;it is the distribution itself&lt;/em&gt;. The probability of each choice can be given to &lt;code&gt;choose&lt;/code&gt; either in an explicit list (as above) or via an &lt;code&gt;Expression&lt;/code&gt; of a neural network.&lt;/p&gt; &#xA;&lt;p&gt;We compose distributions using &lt;code&gt;for {...} yield {...}&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val twoFlips: Pnp[Boolean] = for {&#xA;  x &amp;lt;- flip&#xA;  y &amp;lt;- flip&#xA;} yield {&#xA;  x &amp;amp;&amp;amp; y&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This program returns &lt;code&gt;true&lt;/code&gt; if two independent draws from &lt;code&gt;flip&lt;/code&gt; both return &lt;code&gt;true&lt;/code&gt;. The notation &lt;code&gt;x &amp;lt;- flip&lt;/code&gt; can be thought of as drawing a value from &lt;code&gt;flip&lt;/code&gt; and assigning it to &lt;code&gt;x&lt;/code&gt;. However, we can only use the value within the for/yield block to construct another probability distribution. We can now run inference on this object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val marginals3 = twoFlips.beamSearch(5)&#xA;println(marginals3.marginals().getProbabilityMap)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This prints out the expected probabilities:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{false=0.75, true=0.25}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Neural Networks&lt;/h3&gt; &#xA;&lt;p&gt;Probabilistic neural programs have access to an underlying computation graph that is used to define neural networks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def mlp(x: FloatVector): Pnp[Boolean] = {&#xA;  for {&#xA;    // Get the computation graph&#xA;    cg &amp;lt;- computationGraph()&#xA;&#xA;    // Get the parameters of a multilayer perceptron by name.&#xA;    // The dimensionalities and values of these parameters are &#xA;    // defined in a PnpModel that is passed to inference.&#xA;    weights1 &amp;lt;- param(&#34;layer1Weights&#34;)&#xA;    bias1 &amp;lt;- param(&#34;layer1Bias&#34;)&#xA;    weights2 &amp;lt;- param(&#34;layer2Weights&#34;)&#xA;&#xA;    // Input the feature vector to the computation graph and&#xA;    // run the multilayer perceptron to produce scores.&#xA;    inputExpression = input(cg.cg, Seq(FEATURE_VECTOR_DIM), x)&#xA;    scores = weights2 * tanh((weights1 * inputExpression) + bias1)&#xA;&#xA;     // Choose a label given the scores. Scores is expected to&#xA;     // be a 2-element vector, where the first element is the score&#xA;     // of true, etc.&#xA;     y &amp;lt;- choose(Array(true, false), scores)&#xA;  } yield {&#xA;    y&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can then evaluate the network on an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val model = PnpModel.init(true)&#xA;// Initialize the network parameters. The values are&#xA;// chosen randomly.&#xA;model.addParameter(&#34;layer1Weights&#34;, Seq(HIDDEN_DIM, FEATURE_VECTOR_DIM))&#xA;model.addParameter(&#34;layer1Bias&#34;, Seq(HIDDEN_DIM))&#xA;model.addParameter(&#34;layer2Weights&#34;, Seq(2, HIDDEN_DIM))&#xA;&#xA;// Run the multilayer perceptron on featureVector&#xA;val featureVector = new FloatVector(Seq(1.0f, 2.0f, 3.0f))&#xA;val dist = mlp(featureVector)&#xA;val marginals = dist.beamSearch(2, model)&#xA; &#xA;for (x &amp;lt;- marginals.executions) {&#xA;  println(x)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This prints something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Execution true -0.4261836111545563]&#xA;[Execution false -1.058420181274414]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each execution has a single value that is an output of our program and a score derived from the neural network computation. In this case, the scores are log probabilities, but the scores may have different semantics depending on the way the model is defined and its parameters are trained.&lt;/p&gt; &#xA;&lt;p&gt;Pnp uses Dynet as the underlying neural network library, which provides a rich set of operations (e.g., LSTMs). See the &lt;a href=&#34;http://dynet.readthedocs.io/en/latest/operations.html&#34;&gt;Dynet documentation&lt;/a&gt; for details, along with the documentation for &lt;a href=&#34;https://github.com/allenai/dynet/tree/master/swig&#34;&gt;Dynet Scala bindings&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;TODO: document usage of RNNBuilders, which have to be used statelessly.&lt;/p&gt; &#xA;&lt;h3&gt;Defining Richer Models&lt;/h3&gt; &#xA;&lt;p&gt;Probabilistic neural programs can be easily composed to construct richer models using &lt;code&gt;for {...} yield {...}&lt;/code&gt;. For example, we can define a CRF sequence tagger using the multilayer perceptron above:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def sequenceTag(xs: Seq[FloatVector]): Pnp[List[Boolean]] = {&#xA;  xs.foldLeft(Pnp.value(List[Boolean]()))((x, y) =&amp;gt; for {&#xA;    cur &amp;lt;- mlp(y)&#xA;    rest &amp;lt;- x&#xA;&#xA;    cg &amp;lt;- computationGraph()&#xA;    _ &amp;lt;- if (rest.length &amp;gt; 0) {&#xA;      // Add a factor to the model that scores adjacent labels&#xA;      // in the sequence. Here, labelNn runs a neural network&#xA;      // whose inputs are cur and the next label, and whose output&#xA;      // is a 1-element vector containing the score.&#xA;      score(labelNn(cur, rest.head, cg.cg))&#xA;    } else {&#xA;      value(())&#xA;    }&#xA;  } yield {&#xA;    cur :: rest&#xA;  })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can now run this model on a sequence of feature vectors in the same way as the multilayer perceptron:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Same model as before, but make it globally normalized &#xA;// and add some more parameters for labelNn&#xA;model.locallyNormalized = false&#xA;model.addLookupParameter(&#34;left&#34;, 2, Seq(LABEL_DIM))&#xA;model.addLookupParameter(&#34;right&#34;, 2, Seq(LABEL_DIM))&#xA;&#xA;val featureVectors = Seq(new FloatVector(...), new FloatVector(...), new FloatVector(...))&#xA;val dist = sequenceTag(featureVectors)&#xA;val marginals = dist.beamSearch(5, model)&#xA;for (x &amp;lt;- marginals.executions) {&#xA;  println(x)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This prints something like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Execution List(true, true, true) 5.28779661655426]&#xA;[Execution List(false, true, true) 1.7529568672180176]&#xA;[Execution List(true, true, false) 1.4970757961273193]&#xA;[Execution List(true, false, false) -0.007531404495239258]&#xA;[Execution List(true, false, true) -0.42748916149139404]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Training&lt;/h2&gt; &#xA;&lt;p&gt;TODO&lt;/p&gt; &#xA;&lt;h2&gt;Inference&lt;/h2&gt; &#xA;&lt;p&gt;TODO&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>chipsalliance/rocket-chip</title>
    <updated>2022-06-03T02:22:00Z</updated>
    <id>tag:github.com,2022-06-03:/chipsalliance/rocket-chip</id>
    <link href="https://github.com/chipsalliance/rocket-chip" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rocket Chip Generator&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rocket Chip Generator &lt;span&gt;&lt;/span&gt; &lt;img src=&#34;https://github.com/chipsalliance/rocket-chip/workflows/Continuous%20Integration/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains the Rocket chip generator necessary to instantiate the RISC-V Rocket Core. For more information on Rocket Chip, please consult our &lt;a href=&#34;http://www.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-17.html&#34;&gt;technical report&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/#quick&#34;&gt;Quick instructions&lt;/a&gt; for those who want to dive directly into the details without knowing exactly what&#39;s in the repository.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/#what&#34;&gt;What&#39;s in the Rocket chip generator repository?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/#how&#34;&gt;How should I use the Rocket chip generator?&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/#emulator&#34;&gt;Using the cycle-accurate Verilator simulation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/#fpga&#34;&gt;Mapping a Rocket core down to an FPGA&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/#vlsi&#34;&gt;Pushing a Rocket core through the VLSI tools&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/#param&#34;&gt;How can I parameterize my Rocket chip?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/#debug&#34;&gt;Debugging with GDB&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/#ide&#34;&gt;Building Rocket Chip with an IDE&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/#contributors&#34;&gt;Contributors&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;a name=&#34;quick&#34;&gt;&lt;/a&gt; Quick Instructions&lt;/h2&gt; &#xA;&lt;h3&gt;Checkout The Code&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/ucb-bar/rocket-chip.git&#xA;$ cd rocket-chip&#xA;$ git submodule update --init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setting up the RISCV environment variable&lt;/h3&gt; &#xA;&lt;p&gt;To build the rocket-chip repository, you must point the RISCV environment variable to your rocket-tools installation directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ export RISCV=/path/to/riscv/toolchain/installation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The rocket-tools repository known to work with rocket-chip is noted in the file riscv-tools.hash. However, any recent rocket-tools should work. You can build rocket-tools as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/freechipsproject/rocket-tools&#xA;$ cd rocket-tools&#xA;$ git submodule update --init --recursive&#xA;$ export RISCV=/path/to/install/riscv/toolchain&#xA;$ export MAKEFLAGS=&#34;$MAKEFLAGS -jN&#34; # Assuming you have N cores on your host system&#xA;$ ./build.sh&#xA;$ ./build-rv32ima.sh (if you are using RV32).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install Necessary Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;You may need to install some additional packages to use this repository. Rather than list all dependencies here, please see the appropriate section of the READMEs for each of the subprojects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/freechipsproject/rocket-tools/raw/master/README.md&#34;&gt;rocket-tools &#34;Ubuntu Packages Needed&#34;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ucb-bar/chisel3#installation&#34;&gt;chisel3 &#34;Installation&#34;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building The Project&lt;/h3&gt; &#xA;&lt;p&gt;First, to build the C simulator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd emulator&#xA;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or to build the VCS simulator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd vsim&#xA;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In either case, you can run a set of assembly tests or simple benchmarks (Assuming you have N cores on your host system):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make -jN run-asm-tests&#xA;$ make -jN run-bmark-tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build a C simulator that is capable of VCD waveform generation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd emulator&#xA;$ make debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And to run the assembly tests on the C simulator and generate waveforms:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make -jN run-asm-tests-debug&#xA;$ make -jN run-bmark-tests-debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To generate FPGA- or VLSI-synthesizable Verilog (output will be in &lt;code&gt;vsim/generated-src&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd vsim&#xA;$ make verilog&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the Scala tests (&lt;code&gt;sbt test&lt;/code&gt;) or linter (&lt;code&gt;sbt scalafix&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd regression&#xA;&#xA;# Scala tests&#xA;$ make scalatest SUITE=foo&#xA;&#xA;# Scala linter, automatically modifying files to correct issues&#xA;$ make scalafix SUITE=foo&#xA;&#xA;# Scala linter, only printing out issues&#xA;$ make scalafix-check SUITE=foo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Keeping Your Repo Up-to-Date&lt;/h3&gt; &#xA;&lt;p&gt;If you are trying to keep your repo up to date with this GitHub repo, you also need to keep the submodules and tools up to date.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ # Get the newest versions of the files in this repo&#xA;$ git pull origin master&#xA;$ # Make sure the submodules have the correct versions&#xA;$ git submodule update --init --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If rocket-tools version changes, you should recompile and install rocket-tools according to the directions in the &lt;a href=&#34;https://github.com/freechipsproject/rocket-tools/raw/master/README.md&#34;&gt;rocket-tools/README&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd rocket-tools&#xA;$ ./build.sh&#xA;$ ./build-rv32ima.sh (if you are using RV32)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;a name=&#34;what&#34;&gt;&lt;/a&gt; What&#39;s in the Rocket chip generator repository?&lt;/h2&gt; &#xA;&lt;p&gt;The rocket-chip repository is a meta-repository that points to several sub-repositories using &lt;a href=&#34;http://git-scm.com/book/en/Git-Tools-Submodules&#34;&gt;Git submodules&lt;/a&gt;. Those repositories contain tools needed to generate and test SoC designs. This respository also contains code that is used to generate RTL. Hardware generation is done using &lt;a href=&#34;http://chisel.eecs.berkeley.edu&#34;&gt;Chisel&lt;/a&gt;, a hardware construction language embedded in Scala. The rocket-chip generator is a Scala program that invokes the Chisel compiler in order to emit RTL describing a complete SoC. The following sections describe the components of this repository.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a name=&#34;what_submodules&#34;&gt;&lt;/a&gt;Git Submodules&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Tools-Submodules&#34;&gt;Git submodules&lt;/a&gt; allow you to keep a Git repository as a subdirectory of another Git repository. For projects being co-developed with the Rocket Chip Generator, we have often found it expedient to track them as submodules, allowing for rapid exploitation of new features while keeping commit histories separate. As submoduled projects adopt stable public APIs, we transition them to external dependencies. Here are the submodules that are currently being tracked in the rocket-chip repository:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;chisel3&lt;/strong&gt; (&lt;a href=&#34;https://github.com/ucb-bar/chisel3&#34;&gt;https://github.com/ucb-bar/chisel3&lt;/a&gt;): The Rocket Chip Generator uses &lt;a href=&#34;http://chisel.eecs.berkeley.edu&#34;&gt;Chisel&lt;/a&gt; to generate RTL.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;firrtl&lt;/strong&gt; (&lt;a href=&#34;https://github.com/ucb-bar/firrtl&#34;&gt;https://github.com/ucb-bar/firrtl&lt;/a&gt;): &lt;a href=&#34;http://bar.eecs.berkeley.edu/projects/2015-firrtl.html&#34;&gt;Firrtl (Flexible Internal Representation for RTL)&lt;/a&gt; is the intermediate representation of RTL constructions used by Chisel3. The Chisel3 compiler generates a Firrtl representation, from which the final product (Verilog code, C code, etc) is generated.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;hardfloat&lt;/strong&gt; (&lt;a href=&#34;https://github.com/ucb-bar/berkeley-hardfloat&#34;&gt;https://github.com/ucb-bar/berkeley-hardfloat&lt;/a&gt;): Hardfloat holds Chisel code that generates parameterized IEEE 754-2008 compliant floating-point units used for fused multiply-add operations, conversions between integer and floating-point numbers, and conversions between floating-point conversions with different precision.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;rocket-tools&lt;/strong&gt; (&lt;a href=&#34;https://github.com/freechipsproject/rocket-tools&#34;&gt;https://github.com/freechipsproject/rocket-tools&lt;/a&gt;): We tag a version of RISC-V software tools that work with the RTL committed in this repository.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;torture&lt;/strong&gt; (&lt;a href=&#34;https://github.com/ucb-bar/riscv-torture&#34;&gt;https://github.com/ucb-bar/riscv-torture&lt;/a&gt;): This module is used to generate and execute constrained random instruction streams that can be used to stress-test both the core and uncore portions of the design.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;a name=&#34;what_packages&#34;&gt;&lt;/a&gt;Scala Packages&lt;/h3&gt; &#xA;&lt;p&gt;In addition to submodules that track independent Git repositories, the rocket-chip code base is itself factored into a number of Scala packages. These packages are all found within the src/main/scala directory. Some of these packages provide Scala utilities for generator configuration, while other contain the actual Chisel RTL generators themselves. Here is a brief description of what can be found in each package:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;amba&lt;/strong&gt; This RTL package uses diplomacy to generate bus implementations of AMBA protocols, including AXI4, AHB-lite, and APB.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;config&lt;/strong&gt; This utility package provides Scala interfaces for configuring a generator via a dynamically-scoped parameterization library.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;coreplex&lt;/strong&gt; This RTL package generates a complete coreplex by gluing together a variety of components from other packages, including: tiled Rocket cores, a system bus network, coherence agents, debug devices, interrupt handlers, externally-facing peripherals, clock-crossers and converters from TileLink to external bus protocols (e.g. AXI or AHB).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;devices&lt;/strong&gt; This RTL package contains implementations for peripheral devices, including the Debug module and various TL slaves.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;diplomacy&lt;/strong&gt; This utility package extends Chisel by allowing for two-phase hardware elaboration, in which certain parameters are dynamically negotiated between modules. For more information about diplomacy, see &lt;a href=&#34;https://carrv.github.io/2017/papers/cook-diplomacy-carrv2017.pdf&#34;&gt;this paper&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;groundtest&lt;/strong&gt; This RTL package generates synthesizable hardware testers that emit randomized memory access streams in order to stress-tests the uncore memory hierarchy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;jtag&lt;/strong&gt; This RTL package provides definitions for generating JTAG bus interfaces.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;regmapper&lt;/strong&gt; This utility package generates slave devices with a standardized interface for accessing their memory-mapped registers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;rocket&lt;/strong&gt; This RTL package generates the Rocket in-order pipelined core, as well as the L1 instruction and data caches. This library is intended to be used by a chip generator that instantiates the core within a memory system and connects it to the outside world.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;tile&lt;/strong&gt; This RTL package contains components that can be combined with cores to construct tiles, such as FPUs and accelerators.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;tilelink&lt;/strong&gt; This RTL package uses diplomacy to generate bus implementations of the TileLink protocol. It also contains a variety of adapters and protocol converters.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;system&lt;/strong&gt; This top-level utility package invokes Chisel to elaborate a particular configuration of a coreplex, along with the appropriate testing collateral.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;unittest&lt;/strong&gt; This utility package contains a framework for generateing synthesizable hardware testers of individual modules.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;util&lt;/strong&gt; This utility package provides a variety of common Scala and Chisel constructs that are re-used across multiple other packages,&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;a name=&#34;what_else&#34;&gt;&lt;/a&gt;Other Resources&lt;/h3&gt; &#xA;&lt;p&gt;Outside of Scala, we also provide a variety of resources to create a complete SoC implementation and test the generated designs.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;bootrom&lt;/strong&gt; Sources for the first-stage bootloader included in the BootROM.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;csrc&lt;/strong&gt; C sources for use with Verilator simulation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;docs&lt;/strong&gt; Documentation, tutorials, etc for specific parts of the codebase.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;emulator&lt;/strong&gt; Directory in which Verilator simulations are compiled and run.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;project&lt;/strong&gt; Directory used by SBT for Scala compilation and build.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;regression&lt;/strong&gt; Defines continuous integration and nightly regression suites.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;scripts&lt;/strong&gt; Utilities for parsing the output of simulations or manipulating the contents of source files.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;vsim&lt;/strong&gt; Directory in which Synopsys VCS simulations are compiled and run.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;vsrc&lt;/strong&gt; Verilog sources containing interfaces, harnesses and VPI.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;a name=&#34;what_toplevel&#34;&gt;&lt;/a&gt;Extending the Top-Level Design&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/ucb-bar/project-template&#34;&gt;this description&lt;/a&gt; of how to create you own top-level design with custom devices.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a name=&#34;how&#34;&gt;&lt;/a&gt; How should I use the Rocket chip generator?&lt;/h2&gt; &#xA;&lt;p&gt;Chisel can generate code for three targets: a high-performance cycle-accurate Verilator, Verilog optimized for FPGAs, and Verilog for VLSI. The rocket-chip generator can target all three backends. You will need a Java runtime installed on your machine, since Chisel is overlaid on top of &lt;a href=&#34;http://www.scala-lang.org/&#34;&gt;Scala&lt;/a&gt;. Chisel RTL (i.e. rocket-chip source code) is a Scala program executing on top of your Java runtime. To begin, ensure that the ROCKETCHIP environment variable points to the rocket-chip repository.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/ucb-bar/rocket-chip.git&#xA;$ cd rocket-chip&#xA;$ export ROCKETCHIP=`pwd`&#xA;$ git submodule update --init&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Before going any further, you must point the RISCV environment variable to your rocket-tools installation directory. If you do not yet have rocket-tools installed, follow the directions in the &lt;a href=&#34;https://github.com/freechipsproject/rocket-tools/raw/master/README.md&#34;&gt;rocket-tools/README&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export RISCV=/path/to/install/riscv/toolchain&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise, you will see the following error message while executing any command in the rocket-chip generator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;*** Please set environment variable RISCV. Please take a look at README.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a name=&#34;emulator&#34;&gt;&lt;/a&gt; 1) Using the high-performance cycle-accurate Verilator&lt;/h3&gt; &#xA;&lt;p&gt;Your next step is to get the Verilator working. Assuming you have N cores on your host system, do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $ROCKETCHIP/emulator&#xA;$ make -jN run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By doing so, the build system will generate C++ code for the cycle-accurate emulator, compile the emulator, compile all RISC-V assembly tests and benchmarks, and run both tests and benchmarks on the emulator. If Make finished without any errors, it means that the generated Rocket chip has passed all assembly tests and benchmarks!&lt;/p&gt; &#xA;&lt;p&gt;You can also run assembly tests and benchmarks separately:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make -jN run-asm-tests&#xA;$ make -jN run-bmark-tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To generate vcd waveforms, you can run one of the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make -jN run-debug&#xA;$ make -jN run-asm-tests-debug&#xA;$ make -jN run-bmark-tests-debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or call out individual assembly tests or benchmarks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make output/rv64ui-p-add.out&#xA;$ make output/rv64ui-p-add.vcd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now take a look in the emulator/generated-src directory. You will find Chisel generated Verilog code and its associated C++ code generated by Verilator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ls $ROCKETCHIP/emulator/generated-src&#xA;freechips.rocketchip.system.DefaultConfig&#xA;freechips.rocketchip.system.DefaultConfig.0x0.0.regmap.json&#xA;freechips.rocketchip.system.DefaultConfig.0x0.1.regmap.json&#xA;freechips.rocketchip.system.DefaultConfig.0x2000000.0.regmap.json&#xA;freechips.rocketchip.system.DefaultConfig.0x40.0.regmap.json&#xA;freechips.rocketchip.system.DefaultConfig.0xc000000.0.regmap.json&#xA;freechips.rocketchip.system.DefaultConfig.anno.json&#xA;freechips.rocketchip.system.DefaultConfig.behav_srams.v&#xA;freechips.rocketchip.system.DefaultConfig.conf&#xA;freechips.rocketchip.system.DefaultConfig.d&#xA;freechips.rocketchip.system.DefaultConfig.dts&#xA;freechips.rocketchip.system.DefaultConfig.fir&#xA;freechips.rocketchip.system.DefaultConfig.graphml&#xA;freechips.rocketchip.system.DefaultConfig.json&#xA;freechips.rocketchip.system.DefaultConfig.memmap.json&#xA;freechips.rocketchip.system.DefaultConfig.plusArgs&#xA;freechips.rocketchip.system.DefaultConfig.rom.conf&#xA;freechips.rocketchip.system.DefaultConfig.v&#xA;TestHarness.anno.json&#xA;$ ls $ROCKETCHIP/emulator/generated-src/freechips.rocketchip.system.DefaultConfig&#xA;VTestHarness__1.cpp&#xA;VTestHarness__2.cpp&#xA;VTestHarness__3.cpp&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, output of the executed assembly tests and benchmarks can be found at emulator/output/*.out. Each file has a cycle-by-cycle dump of write-back stage of the pipeline. Here&#39;s an excerpt of emulator/output/rv64ui-p-add.out:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;C0: 483 [1] pc=[00000002138] W[r 3=000000007fff7fff][1] R[r 1=000000007fffffff] R[r 2=ffffffffffff8000] inst=[002081b3] add s1, ra, s0&#xA;C0: 484 [1] pc=[0000000213c] W[r29=000000007fff8000][1] R[r31=ffffffff80007ffe] R[r31=0000000000000005] inst=[7fff8eb7] lui t3, 0x7fff8&#xA;C0: 485 [0] pc=[00000002140] W[r 0=0000000000000000][0] R[r 0=0000000000000000] R[r 0=0000000000000000] inst=[00000000] unknown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first [1] at cycle 483, core 0, shows that there&#39;s a valid instruction at PC 0x2138 in the writeback stage, which is 0x002081b3 (add s1, ra, s0). The second [1] tells us that the register file is writing r3 with the corresponding value 0x7fff7fff. When the add instruction was in the decode stage, the pipeline had read r1 and r2 with the corresponding values next to it. Similarly at cycle 484, there&#39;s a valid instruction (lui instruction) at PC 0x213c in the writeback stage. At cycle 485, there isn&#39;t a valid instruction in the writeback stage, perhaps, because of a instruction cache miss at PC 0x2140.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a name=&#34;fpga&#34;&gt;&lt;/a&gt; 2) Mapping a Rocket core to an FPGA&lt;/h3&gt; &#xA;&lt;p&gt;You can generate synthesizable Verilog with the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $ROCKETCHIP/vsim&#xA;$ make verilog CONFIG=freechips.rocketchip.system.DefaultFPGAConfig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Verilog used for the FPGA tools will be generated in vsim/generated-src. Please proceed further with the directions shown in the &lt;a href=&#34;https://github.com/sifive/freedom/raw/master/README.md&#34;&gt;README&lt;/a&gt; of the freedom repository. You can also run Rocket Chip on Amazon EC2 F1 with &lt;a href=&#34;https://github.com/firesim/firesim&#34;&gt;FireSim&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have access to VCS, you will be able to run assembly tests and benchmarks in simulation with the following commands (again assuming you have N cores on your host machine):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $ROCKETCHIP/vsim&#xA;$ make -jN run CONFIG=freechips.rocketchip.system.DefaultFPGAConfig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The generated output looks similar to those generated from the emulator. Look into vsim/output/*.out for the output of the executed assembly tests and benchmarks.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a name=&#34;vlsi&#34;&gt;&lt;/a&gt; 3) Pushing a Rocket core through the VLSI tools&lt;/h3&gt; &#xA;&lt;p&gt;You can generate Verilog for your VLSI flow with the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $ROCKETCHIP/vsim&#xA;$ make verilog&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now take a look at vsim/generated-src, and the contents of the Top.DefaultConfig.conf file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $ROCKETCHIP/vsim/generated-src&#xA;freechips.rocketchip.system.DefaultConfig&#xA;freechips.rocketchip.system.DefaultConfig.0x0.0.regmap.json&#xA;freechips.rocketchip.system.DefaultConfig.0x0.1.regmap.json&#xA;freechips.rocketchip.system.DefaultConfig.0x2000000.0.regmap.json&#xA;freechips.rocketchip.system.DefaultConfig.0x40.0.regmap.json&#xA;freechips.rocketchip.system.DefaultConfig.0xc000000.0.regmap.json&#xA;freechips.rocketchip.system.DefaultConfig.anno.json&#xA;freechips.rocketchip.system.DefaultConfig.behav_srams.v&#xA;freechips.rocketchip.system.DefaultConfig.conf&#xA;freechips.rocketchip.system.DefaultConfig.d&#xA;freechips.rocketchip.system.DefaultConfig.dts&#xA;freechips.rocketchip.system.DefaultConfig.fir&#xA;freechips.rocketchip.system.DefaultConfig.graphml&#xA;freechips.rocketchip.system.DefaultConfig.json&#xA;freechips.rocketchip.system.DefaultConfig.memmap.json&#xA;freechips.rocketchip.system.DefaultConfig.plusArgs&#xA;freechips.rocketchip.system.DefaultConfig.rom.conf&#xA;freechips.rocketchip.system.DefaultConfig.v&#xA;TestHarness.anno.json&#xA;$ cat $ROCKETCHIP/vsim/generated-src/*.conf&#xA;name data_arrays_0_ext depth 512 width 256 ports mrw mask_gran 8&#xA;name tag_array_ext depth 64 width 88 ports mrw mask_gran 22&#xA;name tag_array_0_ext depth 64 width 84 ports mrw mask_gran 21&#xA;name data_arrays_0_1_ext depth 512 width 128 ports mrw mask_gran 32&#xA;name mem_ext depth 33554432 width 64 ports mwrite,read mask_gran 8&#xA;name mem_2_ext depth 512 width 64 ports mwrite,read mask_gran 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The conf file contains information for all SRAMs instantiated in the flow. If you take a close look at the $ROCKETCHIP/Makefrag, you will see that during Verilog generation, the build system calls a $(mem_gen) script with the generated configuration file as an argument, which will fill in the Verilog for the SRAMs. Currently, the $(mem_gen) script points to vsim/vlsi_mem_gen, which simply instantiates behavioral SRAMs. You will see those SRAMs being appended at the end of vsim/generated-src/Top.DefaultConfig.v. To target vendor-specific SRAMs, you will need to make necessary changes to vsim/vlsi_mem_gen.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, if you have access to VCS, you can run assembly tests and benchmarks with the following commands (again assuming you have N cores on your host machine):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $ROCKETCHIP/vsim&#xA;$ make -jN run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The generated output looks similar to those generated from the emulator. Look into vsim/output/*.out for the output of the executed assembly tests and benchmarks.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a name=&#34;param&#34;&gt;&lt;/a&gt; How can I parameterize my Rocket chip?&lt;/h2&gt; &#xA;&lt;p&gt;By now, you probably figured out that all generated files have a configuration name attached, e.g. &lt;code&gt;freechips.rocketchip.system.DefaultConfig&lt;/code&gt;. Take a look at &lt;code&gt;src/main/scala/system/Configs.scala&lt;/code&gt;. Search for &lt;code&gt;NSets&lt;/code&gt; and &lt;code&gt;NWays&lt;/code&gt; defined in &lt;code&gt;BaseConfig&lt;/code&gt;. You can change those numbers to get a Rocket core with different cache parameters. For example, by changing L1I, NWays to 4, you will get a 32KB 4-way set-associative L1 instruction cache rather than a 16KB 2-way set-associative L1 instruction cache. Towards the end, you can also find that &lt;code&gt;DefaultSmallConfig&lt;/code&gt; inherits all parameters from &lt;code&gt;BaseConfig&lt;/code&gt; but overrides the same parameters of &lt;code&gt;WithNSmallCores&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Now take a look at &lt;code&gt;vsim/Makefile&lt;/code&gt;. Search for the &lt;code&gt;CONFIG&lt;/code&gt; variable. By default, it is set to &lt;code&gt;freechips.rocketchip.system.DefaultConfig&lt;/code&gt;. You can also change the CONFIG variable on the make command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $ROCKETCHIP/vsim&#xA;$ make -jN CONFIG=freechips.rocketchip.system.DefaultSmallConfig run-asm-tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, even by defining CONFIG as an environment variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ export CONFIG=freechips.rocketchip.system.DefaultSmallConfig&#xA;$ make -jN run-asm-tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This parameterization is one of the many strengths of processor generators written in Chisel, and will be more detailed in a future blog post, so please stay tuned.&lt;/p&gt; &#xA;&lt;p&gt;To override specific configuration items, such as the number of external interrupts, you can create your own Configuration(s) and compose them with Config&#39;s ++ operator&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class WithNExtInterrupts(nExt: Int) extends Config {&#xA;    (site, here, up) =&amp;gt; {&#xA;        case NExtInterrupts =&amp;gt; nExt&#xA;    }&#xA;}&#xA;class MyConfig extends Config (new WithNExtInterrupts(16) ++ new DefaultSmallConfig)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can build as usual with &lt;code&gt;CONFIG=&amp;lt;MyConfigPackage&amp;gt;.MyConfig&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a name=&#34;debug&#34;&gt;&lt;/a&gt; Debugging with GDB&lt;/h2&gt; &#xA;&lt;h3&gt;1) Generating the Remote Bit-Bang (RBB) Emulator&lt;/h3&gt; &#xA;&lt;p&gt;The objective of this section is to use GNU debugger to debug RISC-V programs running on the emulator in the same fashion as in &lt;a href=&#34;https://github.com/riscv/riscv-isa-sim#debugging-with-gdb&#34;&gt;Spike&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For that we need to add a Remote Bit-Bang client to the emulator. We can do so by extending our Config with JtagDTMSystem, which will add a DebugTransportModuleJTAG to the DUT and connect a SimJTAG module in the Test Harness. This will allow OpenOCD to interface with the emulator, and GDB can interface with OpenOCD. In the following example we add this Config alteration to &lt;code&gt;src/main/scala/system/Configs.scala&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class DefaultConfigRBB extends Config(&#xA;new WithJtagDTMSystem ++ new WithNBigCores(1) ++ new WithCoherentBusTopology ++ new BaseConfig)&#xA;&#xA;class QuadCoreConfigRBB extends Config(&#xA;new WithJtagDTMSystem ++ new WithNBigCores(4) ++ new WithCoherentBusTopology ++ new BaseConfig)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build the emulator with &lt;code&gt;DefaultConfigRBB&lt;/code&gt; configuration we use the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rocket-chip$ cd emulator&#xA;emulator$ CONFIG=freechips.rocketchip.system.DefaultConfigRBB make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also build a debug version capable of generating VCD waveforms using the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;emulator$ CONFIG=freechips.rocketchip.system.DefaultConfigRBB make debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default the emulator is generated under the name &lt;code&gt;emulator-freechips.rocketchip.system-DefaultConfigRBB&lt;/code&gt; in the first case and &lt;code&gt;emulator-freechips.rocketchip.system-DefaultConfigRBB-debug&lt;/code&gt; in the second.&lt;/p&gt; &#xA;&lt;h3&gt;2) Compiling and executing a custom program using the emulator&lt;/h3&gt; &#xA;&lt;p&gt;We suppose that &lt;code&gt;helloworld&lt;/code&gt; is our program, you can use &lt;code&gt;crt.S&lt;/code&gt;, &lt;code&gt;syscalls.c&lt;/code&gt; and the linker script &lt;code&gt;test.ld&lt;/code&gt; to construct your own program, check examples stated in &lt;a href=&#34;https://github.com/riscv/riscv-tests&#34;&gt;riscv-tests&lt;/a&gt;. Note that &lt;code&gt;test.ld&lt;/code&gt; loads the program at 0x80000000 so you will need to use &lt;code&gt;-mcmodel=medany&lt;/code&gt; otherwise you will get relocation errors. See &lt;a href=&#34;https://www.sifive.com/blog/2017/09/11/all-aboard-part-4-risc-v-code-models/&#34;&gt;All Aboard, Part 4: The RISC-V Code Models&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;In our case we will use the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;char text[] = &#34;Vafgehpgvba frgf jnag gb or serr!&#34;;&#xA;&#xA;// Don&#39;t use the stack, because sp isn&#39;t set up.&#xA;volatile int wait = 1;&#xA;&#xA;int main()&#xA;{&#xA;    while (wait)&#xA;        ;&#xA;&#xA;    // Doesn&#39;t actually go on the stack, because there are lots of GPRs.&#xA;    int i = 0;&#xA;    while (text[i]) {&#xA;        char lower = text[i] | 32;&#xA;        if (lower &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; lower &amp;lt;= &#39;m&#39;)&#xA;            text[i] += 13;&#xA;        else if (lower &amp;gt; &#39;m&#39; &amp;amp;&amp;amp; lower &amp;lt;= &#39;z&#39;)&#xA;            text[i] -= 13;&#xA;        i++;&#xA;    }&#xA;&#xA;    while (!wait)&#xA;        ;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;First we can test if your program executes well in the simple version of emulator before moving to debugging in step 3 :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./emulator-freechips.rocketchip.system-DefaultConfig helloworld &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additional verbose information (clock cycle, pc, instruction being executed) can be printed using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./emulator-freechips.rocketchip.system-DefaultConfig +verbose helloworld 2&amp;gt;&amp;amp;1 | spike-dasm &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;VCD output files can be obtained using the &lt;code&gt;-debug&lt;/code&gt; version of the emulator and are specified using &lt;code&gt;-v&lt;/code&gt; or &lt;code&gt;--vcd=FILE&lt;/code&gt; arguments. A detailed log file of all executed instructions can also be obtained from the emulator, this is an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./emulator-freechips.rocketchip.system-DefaultConfig-debug +verbose -v output.vcd  helloworld 2&amp;gt;&amp;amp;1 | spike-dasm &amp;gt; output.log&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that generated VCD waveforms and execution log files can be very voluminous depending on the size of the .elf file (i.e. code size + debugging symbols).&lt;/p&gt; &#xA;&lt;p&gt;Please note also that the time it takes the emulator to load your program depends on executable size. Stripping the .elf executable will unsurprisingly make it run faster. For this you can use &lt;code&gt;$RISCV/bin/riscv64-unknown-elf-strip&lt;/code&gt; tool to reduce the size. This is good for accelerating your simulation but not for debugging. Keep in mind that the HTIF communication interface between our system and the emulator relies on &lt;code&gt;tohost&lt;/code&gt; and &lt;code&gt;fromhost&lt;/code&gt; symbols to communicate. This is why you may get the following error when you try to run a totally stripped executable on the emulator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./emulator-freechips.rocketchip.system-DefaultConfig totally-stripped-helloworld &#xA;This emulator compiled with JTAG Remote Bitbang client. To enable, use +jtag_rbb_enable=1.&#xA;Listening on port 46529&#xA;warning: tohost and fromhost symbols not in ELF; can&#39;t communicate with target&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To resolve this, we need to strip all the .elf executable but keep &lt;code&gt;tohost&lt;/code&gt; and &lt;code&gt;fromhost&lt;/code&gt; symbols using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$riscv64-unknown-elf-strip -s -Kfromhost -Ktohost helloworld&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More details on the GNU strip tool can be found &lt;a href=&#34;https://www.thegeekstuff.com/2012/09/strip-command-examples/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The interest of this step is to make sure your program executes well. To perform debugging you need the original unstripped version, as explained in step 3.&lt;/p&gt; &#xA;&lt;h3&gt;3) Launch the emulator&lt;/h3&gt; &#xA;&lt;p&gt;First, do not forget to compile your program with &lt;code&gt;-g -Og&lt;/code&gt; flags to provide debugging support as explained &lt;a href=&#34;https://github.com/riscv/riscv-isa-sim#debugging-with-gdb&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We can then launch the Remote Bit-Bang enabled emulator with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./emulator-freechips.rocketchip.system-DefaultConfigRBB +jtag_rbb_enable=1 --rbb-port=9823 helloworld&#xA;This emulator compiled with JTAG Remote Bitbang client. To enable, use +jtag_rbb_enable=1.&#xA;Listening on port 9823&#xA;Attempting to accept client socket&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use the &lt;code&gt;emulator-freechips.rocketchip.system-DefaultConfigRBB-debug&lt;/code&gt; version instead if you would like to generate VCD waveforms.&lt;/p&gt; &#xA;&lt;p&gt;Please note that if the argument &lt;code&gt;--rbb-port&lt;/code&gt; is not passed, a default free TCP port on your computer will be chosen randomly.&lt;/p&gt; &#xA;&lt;p&gt;Please note also that when debugging with GDB, the .elf file is not actually loaded by the FESVR. In contrast with Spike, it must be loaded from GDB as explained in step 5. So the &lt;code&gt;helloworld&lt;/code&gt; argument may be replaced by any dummy name.&lt;/p&gt; &#xA;&lt;h3&gt;4) Launch OpenOCD&lt;/h3&gt; &#xA;&lt;p&gt;You will need a RISC-V Enabled OpenOCD binary. This is installed with rocket-tools in &lt;code&gt;$(RISCV)/bin/openocd&lt;/code&gt;, or can be compiled manually from riscv-openocd. OpenOCD requires a configuration file, in which we define the RBB port we will use, which is in our case &lt;code&gt;9823&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cat cemulator.cfg &#xA;interface remote_bitbang&#xA;remote_bitbang_host localhost&#xA;remote_bitbang_port 9823&#xA;&#xA;set _CHIPNAME riscv&#xA;jtag newtap $_CHIPNAME cpu -irlen 5&#xA;&#xA;set _TARGETNAME $_CHIPNAME.cpu&#xA;target create $_TARGETNAME riscv -chain-position $_TARGETNAME&#xA;&#xA;gdb_report_data_abort enable&#xA;&#xA;init&#xA;halt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then we launch OpenOCD in another terminal using the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$(RISCV)/bin/openocd -f ./cemulator.cfg&#xA;Open On-Chip Debugger 0.10.0+dev-00112-g3c1c6e0 (2018-04-12-10:40)&#xA;Licensed under GNU GPL v2&#xA;For bug reports, read&#xA;http://openocd.org/doc/doxygen/bugs.html&#xA;Warn : Adapter driver &#39;remote_bitbang&#39; did not declare which transports it allows; assuming legacy JTAG-only&#xA;Info : only one transport option; autoselect &#39;jtag&#39;&#xA;Info : Initializing remote_bitbang driver&#xA;Info : Connecting to localhost:9823&#xA;Info : remote_bitbang driver initialized&#xA;Info : This adapter doesn&#39;t support configurable speed&#xA;Info : JTAG tap: riscv.cpu tap/device found: 0x00000001 (mfg: 0x000 (&amp;lt;invalid&amp;gt;), part: 0x0000, ver: 0x0)&#xA;Info : datacount=2 progbufsize=16&#xA;Info : Disabling abstract command reads from CSRs.&#xA;Info : Disabling abstract command writes to CSRs.&#xA;Info : [0] Found 1 triggers&#xA;Info : Examined RISC-V core; found 1 harts&#xA;Info :  hart 0: XLEN=64, 1 triggers&#xA;Info : Listening on port 3333 for gdb connections&#xA;Info : Listening on port 6666 for tcl connections&#xA;Info : Listening on port 4444 for telnet connections&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;-d&lt;/code&gt; flag can be added to the command to show further debug information.&lt;/p&gt; &#xA;&lt;h3&gt;5) Launch GDB&lt;/h3&gt; &#xA;&lt;p&gt;In another terminal launch GDB and point to the elf file you would like to load then run it with the debugger (in this example, &lt;code&gt;helloworld&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ riscv64-unknown-elf-gdb helloworld&#xA;GNU gdb (GDB) 8.0.50.20170724-git&#xA;Copyright (C) 2017 Free Software Foundation, Inc.&#xA;License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;&#xA;This is free software: you are free to change and redistribute it.&#xA;There is NO WARRANTY, to the extent permitted by law.  Type &#34;show copying&#34;&#xA;and &#34;show warranty&#34; for details.&#xA;This GDB was configured as &#34;--host=x86_64-pc-linux-gnu --target=riscv64-unknown-elf&#34;.&#xA;Type &#34;show configuration&#34; for configuration details.&#xA;For bug reporting instructions, please see:&#xA;&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.&#xA;Find the GDB manual and other documentation resources online at:&#xA;&amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.&#xA;For help, type &#34;help&#34;.&#xA;Type &#34;apropos word&#34; to search for commands related to &#34;word&#34;...&#xA;Reading symbols from ./proj1.out...done.&#xA;(gdb)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compared to Spike, the C Emulator is very slow, so several problems may be encountered due to timeouts between issuing commands and response from the emulator. To solve this problem, we increase the timeout with the GDB &lt;code&gt;set remotetimeout&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;p&gt;After that we load our program by performing a &lt;code&gt;load&lt;/code&gt; command. This automatically sets the &lt;code&gt;$PC&lt;/code&gt; to the &lt;code&gt;_start&lt;/code&gt; symbol in our .elf file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(gdb) set remotetimeout 2000&#xA;(gdb) target remote localhost:3333&#xA;Remote debugging using localhost:3333&#xA;0x0000000000010050 in ?? ()&#xA;(gdb) load&#xA;Loading section .text.init, size 0x2cc lma 0x80000000&#xA;Loading section .tohost, size 0x48 lma 0x80001000&#xA;Loading section .text, size 0x98c lma 0x80001048&#xA;Loading section .rodata, size 0x158 lma 0x800019d4&#xA;Loading section .rodata.str1.8, size 0x20 lma 0x80001b30&#xA;Loading section .data, size 0x22 lma 0x80001b50&#xA;Loading section .sdata, size 0x4 lma 0x80001b74&#xA;Start address 0x80000000, load size 3646&#xA;Transfer rate: 40 bytes/sec, 520 bytes/write.&#xA;(gdb) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can proceed as with Spike, debugging works in a similar way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(gdb) print wait&#xA;$1 = 1&#xA;(gdb) print wait=0&#xA;$2 = 0&#xA;(gdb) print text&#xA;$3 = &#34;Vafgehpgvba frgf jnag gb or serr!&#34;&#xA;(gdb) c&#xA;Continuing.&#xA;&#xA;^C&#xA;Program received signal SIGINT, Interrupt.&#xA;main (argc=0, argv=&amp;lt;optimized out&amp;gt;) at src/main.c:33&#xA;33&#x9;    while (!wait)&#xA;(gdb) print wait&#xA;$4 = 0&#xA;(gdb) print text&#xA;$5 = &#34;Instruction sets want to be free!&#34;&#xA;(gdb)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Further information about GDB debugging is available &lt;a href=&#34;https://sourceware.org/gdb/onlinedocs/gdb/&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://sourceware.org/gdb/onlinedocs/gdb/Remote-Debugging.html#Remote-Debugging&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a name=&#34;ide&#34;&gt;&lt;/a&gt; Building Rocket Chip with an IDE&lt;/h2&gt; &#xA;&lt;p&gt;The Rocket Chip Scala build uses the standard Scala build tool SBT. IDEs like &lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;IntelliJ&lt;/a&gt; and &lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;VSCode&lt;/a&gt; are popular in the Scala community and work with Rocket Chip. To use one of these IDEs, there is one minor peculiarity of the Rocket Chip build that must be addressed.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a name=&#34;contributors&#34;&gt;&lt;/a&gt; Contributors&lt;/h2&gt; &#xA;&lt;p&gt;Contributing guidelines can be found in &lt;a href=&#34;https://raw.githubusercontent.com/chipsalliance/rocket-chip/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A list of contributors can be found &lt;a href=&#34;https://github.com/chipsalliance/rocket-chip/graphs/contributors&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a name=&#34;attribution&#34;&gt;&lt;/a&gt; Attribution&lt;/h2&gt; &#xA;&lt;p&gt;If used for research, please cite Rocket Chip by the technical report:&lt;/p&gt; &#xA;&lt;p&gt;Krste Asanovi, Rimas Aviienis, Jonathan Bachrach, Scott Beamer, David Biancolin, Christopher Celio, Henry Cook, Palmer Dabbelt, John Hauser, Adam Izraelevitz, Sagar Karandikar, Benjamin Keller, Donggyu Kim, John Koenig, Yunsup Lee, Eric Love, Martin Maas, Albert Magyar, Howard Mao, Miquel Moreto, Albert Ou, David Patterson, Brian Richards, Colin Schmidt, Stephen Twigg, Huy Vo, and Andrew Waterman, &lt;em&gt;&lt;a href=&#34;http://www.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-17.html&#34;&gt;The Rocket Chip Generator&lt;/a&gt;&lt;/em&gt;, Technical Report UCB/EECS-2016-17, EECS Department, University of California, Berkeley, April 2016&lt;/p&gt;</summary>
  </entry>
</feed>