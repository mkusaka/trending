<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-13T02:00:25Z</updated>
  <subtitle>Weekly Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>apache/incubator-pekko-http</title>
    <updated>2023-08-13T02:00:25Z</updated>
    <id>tag:github.com,2023-08-13:/apache/incubator-pekko-http</id>
    <link href="https://github.com/apache/incubator-pekko-http" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Streaming-first HTTP server/module of Apache Pekko&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Apache Pekko HTTP&lt;/h1&gt; &#xA;&lt;!--&#xA;[![pekko-http-core Scala version support](https://index.scala-lang.org/pekko/pekko-http/pekko-http-core/latest-by-scala-version.svg)](https://index.scala-lang.org/pekko/pekko-http/pekko-http-core)&#xA;--&gt; &#xA;&lt;p&gt;The Pekko HTTP modules implement a full server- and client-side HTTP stack on top of pekko-actor and pekko-stream. It&#39;s not a web-framework but rather a more general toolkit for providing and consuming HTTP-based services. While interaction with a browser is of course also in scope it is not the primary focus of Pekko HTTP.&lt;/p&gt; &#xA;&lt;p&gt;Pekko HTTP is a fork of &lt;a href=&#34;https://github.com/akka/akka-http&#34;&gt;Akka HTTP&lt;/a&gt; 10.2.x release, prior to the Akka project&#39;s adoption of the Business Source License.&lt;/p&gt; &#xA;&lt;p&gt;Pekko HTTP follows a rather open design and many times offers several different API levels for &#34;doing the same thing&#34;. You get to pick the API level of abstraction that is most suitable for your application. This means that, if you have trouble achieving something using a high-level API, there&#39;s a good chance that you can get it done with a low-level API, which offers more flexibility but might require you to write more application code.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The documentation is available at &lt;a href=&#34;https://pekko.apache.org/docs/pekko-http/current/&#34;&gt;pekko.apache.org&lt;/a&gt;, for &lt;a href=&#34;https://pekko.apache.org/docs/pekko-http/current/scala/http/&#34;&gt;Scala&lt;/a&gt; and &lt;a href=&#34;https://pekko.apache.org/docs/pekko-http/current/java/http/&#34;&gt;Java&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building from Source&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Make sure you have installed a Java Development Kit (JDK) version 8 or later.&lt;/li&gt; &#xA; &lt;li&gt;Make sure you have &lt;a href=&#34;https://www.scala-sbt.org/&#34;&gt;sbt&lt;/a&gt; installed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://graphviz.gitlab.io/download/&#34;&gt;Graphviz&lt;/a&gt; is needed for the scaladoc generation build task, which is part of the release.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;h2spec&lt;/h3&gt; &#xA;&lt;p&gt;Some tests for HTTP/2 compliance use &lt;a href=&#34;https://github.com/summerwind/h2spec&#34;&gt;h2spec&lt;/a&gt;. The sbt build downloads pre-built binaries from the GitHub releases page for the h2spec project. These binaries are not available for all operating systems. Apple Mac Silicon users may need to install &lt;a href=&#34;https://support.apple.com/en-us/HT211861&#34;&gt;Rosetta&lt;/a&gt; if they do not have it installed already.&lt;/p&gt; &#xA;&lt;h3&gt;Running the Build&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open a command window and change directory to your preferred base directory&lt;/li&gt; &#xA; &lt;li&gt;Use git to clone the &lt;a href=&#34;https://github.com/apache/incubator-pekko-http&#34;&gt;repo&lt;/a&gt; or download a source release from &lt;a href=&#34;https://pekko.apache.org&#34;&gt;https://pekko.apache.org&lt;/a&gt; (and unzip or untar it, as appropriate)&lt;/li&gt; &#xA; &lt;li&gt;Change directory to the directory where you installed the source (you should have a file called &lt;code&gt;build.sbt&lt;/code&gt; in this directory)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt compile&lt;/code&gt; compiles the main source for project default version of Scala (2.13) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;sbt +compile&lt;/code&gt; will compile for all supported versions of Scala&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt test&lt;/code&gt; will compile the code and run the unit tests&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt testQuick&lt;/code&gt; similar to &lt;code&gt;test&lt;/code&gt; but when repeated in shell mode will only run failing tests&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt package&lt;/code&gt; will build the jars &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the jars will built into target dirs of the various modules&lt;/li&gt; &#xA;   &lt;li&gt;for the the &#39;http-core&#39; module, the jar will be built to &lt;code&gt;http-core/target/scala-2.13/&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt publishLocal&lt;/code&gt; will push the jars to your local Apache Ivy repository&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt publishM2&lt;/code&gt; will push the jars to your local Apache Maven repository&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt docs/paradox&lt;/code&gt; will build the docs (the ones describing the module features) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;sbt docs/paradoxBrowse&lt;/code&gt; does the same but will open the docs in your browser when complete&lt;/li&gt; &#xA;   &lt;li&gt;the &lt;code&gt;index.html&lt;/code&gt; file will appear in &lt;code&gt;target/paradox/site/main/&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt unidoc&lt;/code&gt; will build the Javadocs for all the modules and load them to one place (may require Graphviz, see Prerequisites above) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the &lt;code&gt;index.html&lt;/code&gt; file will appear in &lt;code&gt;target/scala-2.13/unidoc/&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sbt sourceDistGenerate&lt;/code&gt; will generate source release to &lt;code&gt;target/dist/&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;The version number that appears in filenames and docs is derived, by default. The derived version contains the most git commit id or the date/time (if the directory is not under git control). &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You can set the version number explicitly when running sbt commands &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;eg &lt;code&gt;sbt &#34;set ThisBuild / version := \&#34;1.0.0\&#34;; sourceDistGenerate&#34;&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Or you can add a file called &lt;code&gt;version.sbt&lt;/code&gt; to the same directory that has the &lt;code&gt;build.sbt&lt;/code&gt; containing something like &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;ThisBuild / version := &#34;1.0.0&#34;&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;If you have questions about the contribution process or discuss specific issues, please interact with the community using the following resources.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/incubator-pekko-http/discussions&#34;&gt;GitHub discussions&lt;/a&gt;: for questions and general discussion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://lists.apache.org/list.html?users@pekko.apache.org&#34;&gt;Pekko users mailing list&lt;/a&gt;: for Pekko development discussions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://lists.apache.org/list.html?dev@pekko.apache.org&#34;&gt;Pekko dev mailing list&lt;/a&gt;: for Pekko development discussions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/incubator-pekko-http/issues&#34;&gt;GitHub issues&lt;/a&gt;: for bug reports and feature requests. Please search the existing issues before creating new ones. If you are unsure whether you have found a bug, consider asking in GitHub discussions or the mailing list first.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!--&#xA;[stackoverflow-badge]: https://img.shields.io/badge/stackoverflow%3A-pekko--http-blue.svg?style=flat-square&#xA;[stackoverflow]:       https://stackoverflow.com/questions/tagged/pekko-http&#xA;[github-issues-badge]: https://img.shields.io/badge/github%3A-issues-blue.svg?style=flat-square&#xA;[github-issues]:       https://github.com/apache/incubator-pekko-http/issues&#xA;[scaladex-badge]:      https://index.scala-lang.org/count.svg?q=dependencies:pekko/pekko-http*&amp;subject=scaladex:&amp;color=blue&amp;style=flat-square&#xA;[scaladex-projects]:   https://index.scala-lang.org/search?q=dependencies:pekko/pekko-http*&#xA;--&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are &lt;em&gt;very&lt;/em&gt; welcome!&lt;/p&gt; &#xA;&lt;p&gt;If you see an issue that you&#39;d like to see fixed, the best way to make it happen is to help out by submitting a pull request. For ideas of where to contribute, &lt;a href=&#34;https://github.com/apache/incubator-pekko-http/labels/help%20wanted&#34;&gt;tickets marked as &#34;help wanted&#34;&lt;/a&gt; are a good starting point.&lt;/p&gt; &#xA;&lt;p&gt;Refer to the &lt;a href=&#34;https://raw.githubusercontent.com/apache/incubator-pekko-http/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; file for more details about the workflow, and general hints on how to prepare your pull request. You can also ask for clarifications or guidance in GitHub issues directly.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Apache Pekko HTTP is Open Source and available under the Apache 2 License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>campudus/vertx-chat</title>
    <updated>2023-08-13T02:00:25Z</updated>
    <id>tag:github.com,2023-08-13:/campudus/vertx-chat</id>
    <link href="https://github.com/campudus/vertx-chat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A chat module for vertx&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Chat&lt;/h1&gt; &#xA;&lt;p&gt;This module adds basic chat functionalities to Vertx.&lt;/p&gt; &#xA;&lt;p&gt;If you want to improve this module or its documentation, feel free to submit a pull request!&lt;/p&gt; &#xA;&lt;p&gt;The latest version of this module can be found in the &lt;a href=&#34;https://github.com/campudus/vertx-chat&#34;&gt;campudus/vertx-chat repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;There are no special dependencies right now. It uses SharedData to store all members in the chat.&lt;/p&gt; &#xA;&lt;h2&gt;Name&lt;/h2&gt; &#xA;&lt;p&gt;The module name is &lt;code&gt;com.campudus.chat&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;The chat module takes the following configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;address&#34;: &amp;lt;address&amp;gt;,&#xA;    &#34;client-prefix&#34;: &amp;lt;clientPrefix&amp;gt;,&#xA;    &#34;map-prefix&#34;: &amp;lt;sharedMapsPrefix&amp;gt;,&#xA;    &#34;timeout&#34;: &amp;lt;timeout&amp;gt;,&#xA;    &#34;latency-timeout&#34;: &amp;lt;latencyTimeout&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;address&#34;: &#34;campudus.chat&#34;,&#xA;    &#34;client-prefix&#34;: &#34;campudus.chatters.&#34;,&#xA;    &#34;map-prefix&#34;: &#34;com.campudus.vertx.chat.&#34;,&#xA;    &#34;timeout&#34;: 120000,&#xA;    &#34;latency-timeout&#34; : 2000&#xA;}        &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A short description about each field:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;address&lt;/code&gt; The main address for the module. Every module has a main address. Defaults to &lt;code&gt;campudus.chat&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;client-prefix&lt;/code&gt; All clients should register an address at &lt;code&gt;prefix.&amp;lt;token&amp;gt;&lt;/code&gt; where &lt;code&gt;&amp;lt;token&amp;gt;&lt;/code&gt; represents a UUID given to the client by the server on its initial connection. The client prefix defaults to &lt;code&gt;campudus.chatters.&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;map-prefix&lt;/code&gt; The chat module uses four different shared data maps. With a unique map-prefix, these maps should not interfere with other shared data maps. The map prefix defaults to &lt;code&gt;com.campudus.vertx.chat.&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; How long after a client should send a ping to tell the server it is still connected. If a timeout occurs, the connection will be disconnected and the token gets invalid. The timeout is set as a long value in milliseconds. Defaults to two minutes, i.e. 120000.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;latency-timeout&lt;/code&gt; How long will it take until the connection will be disconnected if the request for a ping was not answered. The timeout disconnection will occur after &lt;code&gt;timeout&lt;/code&gt; + &lt;code&gt;latency-timeout&lt;/code&gt; effectively. Defaults to two seconds, i.e. 2000.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Here is a small example for a Java Client to get you started using this module.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;public class ChatTestVerticle extends Verticle {&#xA;  final String nickname = &#34;Guest&#34; + new Random().nextInt(1000);&#xA;&#xA;  @Override&#xA;  public void start() throws Exception {&#xA;    vertx.eventBus().send(&#34;campudus.chat&#34;,&#xA;        new JsonObject().putString(&#34;action&#34;, &#34;connect&#34;).putString(&#34;nickname&#34;, nickname),&#xA;        new Handler&amp;lt;Message&amp;lt;JsonObject&amp;gt;&amp;gt;() {&#xA;          public void handle(Message&amp;lt;JsonObject&amp;gt; connectMessage) {&#xA;            final String myToken = connectMessage.body.getString(&#34;token&#34;);&#xA;&#xA;            vertx.eventBus().registerHandler(&#34;campudus.chatters.&#34; + myToken, new Handler&amp;lt;Message&amp;lt;JsonObject&amp;gt;&amp;gt;() {&#xA;              public void handle(Message&amp;lt;JsonObject&amp;gt; message) {&#xA;                switch (message.body.getString(&#34;action&#34;)) {&#xA;                case &#34;message&#34;:&#xA;                  final String sender = message.body.getString(&#34;nickname&#34;);&#xA;                  final String text = message.body.getString(&#34;message&#34;);&#xA;                  final String room = message.body.getString(&#34;room&#34;);&#xA;                  if (room == null) {&#xA;                    handlePrivateMessage(sender, text);&#xA;                  } else {&#xA;                    handleChatMessage(room, sender, text);&#xA;                  }&#xA;                  break;&#xA;                case &#34;join&#34;:&#xA;                  final String joinedPerson = message.body.getString(&#34;nickname&#34;);&#xA;                  final String joinedRoom = message.body.getString(&#34;room&#34;);&#xA;                  handleJoin(joinedPerson, joinedRoom);&#xA;                  break;&#xA;                case &#34;part&#34;:&#xA;                  final String partedPerson = message.body.getString(&#34;nickname&#34;);&#xA;                  final String partedRoom = message.body.getString(&#34;room&#34;);&#xA;                  handlePart(partedPerson, partedRoom);&#xA;                  break;&#xA;                case &#34;ping&#34;:&#xA;                  sendPingToServer(myToken);&#xA;                  break;&#xA;                }&#xA;              }&#xA;&#xA;            });&#xA;&#xA;            performInitialActions(myToken, nickname);&#xA;          }&#xA;        });&#xA;  }&#xA;&#xA;  // ...methods to handle the various incoming messages and performInitialActions...&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Operations&lt;/h2&gt; &#xA;&lt;p&gt;The module supports a few operations. Generally you provide a JSON object with &lt;code&gt;&#34;action&#34; : &amp;lt;action&amp;gt;&lt;/code&gt; and required or optional parameters. For most operations, you will need to provide a token which you receive when you connect to the server for the first time and issue the &lt;code&gt;connect&lt;/code&gt; operation. The server will send messages to the clients to a special address, consisting of the client-prefix and the provided token. See [Incoming Messages][] how this should be set up.&lt;/p&gt; &#xA;&lt;h3&gt;connect (Initializes the connection to the server)&lt;/h3&gt; &#xA;&lt;p&gt;Connecting to the server is required before you can use any other action in a meaningful way. To connect to the server, you will need to provide a nickname, which other clients can see. As a return message, you might get an error, if the nickname you choose is already in use. If connecting succeeded, you will receive a unique token. You have to send this token to the server in all later requests. This will let the server know which client it is dealing with and may allow/disallow it to do specific operations.&lt;/p&gt; &#xA;&lt;p&gt;You should also use this token to register a handler on &lt;code&gt;&amp;lt;client-prefix&amp;gt;&amp;lt;token&amp;gt;&lt;/code&gt;. The server sends messages to this client to this address.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;connect&#34;,&#xA;    &#34;nickname&#34; : &#34;ThePlayfulGorilla&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;success&#34;: true,&#xA;    &#34;token&#34;: &#34;48468827-e20c-4ebd-b1c5-f7c36dc4bc95&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;join (Join a chat-room)&lt;/h3&gt; &#xA;&lt;p&gt;Joins a chat-room. The client will receive incoming text, join and part messages for this room on its handler &lt;code&gt;&amp;lt;client-prefix&amp;gt;&amp;lt;token&amp;gt;&lt;/code&gt;. The server will respond with a list of nicknames connected to this chat-room right now.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;join&#34;,&#xA;    &#34;token&#34; : &#34;48468827-e20c-4ebd-b1c5-f7c36dc4bc95&#34;,&#xA;    &#34;room&#34; : &#34;jungle&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;success&#34; : true,&#xA;    &#34;users&#34; : [&#34;ThePlayfulRobot&#34;, &#34;TheRedSnake&#34;, &#34;GreenFlash&#34;]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;part (Leave a chat-room)&lt;/h3&gt; &#xA;&lt;p&gt;Leaves a chat-room. The client will not receive any more join, part or text messages for this room on its handler.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;part&#34;,&#xA;    &#34;token&#34; : &#34;48468827-e20c-4ebd-b1c5-f7c36dc4bc95&#34;,&#xA;    &#34;room&#34; : &#34;jungle&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;success&#34; : true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;send (Send a message to a chat-room)&lt;/h3&gt; &#xA;&lt;p&gt;Sends a message to all clients inside a chat-room.&lt;/p&gt; &#xA;&lt;p&gt;Example to send a &lt;em&gt;Howdy!&lt;/em&gt; to the chat-room &lt;em&gt;jungle&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;send&#34;,&#xA;    &#34;token&#34; : &#34;48468827-e20c-4ebd-b1c5-f7c36dc4bc95&#34;,&#xA;    &#34;room&#34; : &#34;jungle&#34;,&#xA;    &#34;message&#34; : &#34;Howdy!&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;success&#34; : true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;send (Send a message to another user directly)&lt;/h3&gt; &#xA;&lt;p&gt;Sends a message to another client directly. The other client will receive the message directly on its handler (see incoming operation &lt;code&gt;message&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;In this example, a message is sent to &lt;em&gt;ThePlayfulGorilla&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;send&#34;,&#xA;    &#34;token&#34; : &#34;48468827-e20c-4ebd-b1c5-f7c36dc4bc95&#34;,&#xA;    &#34;nickname&#34; : &#34;ThePlayfulGorilla&#34;,&#xA;    &#34;message&#34; : &#34;Hi there, Mr. Gorilla!&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;success&#34; : true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;disconnect (Disconnects the client from the server)&lt;/h3&gt; &#xA;&lt;p&gt;Disconnects the client from the server. All rooms will receive &lt;code&gt;part&lt;/code&gt; messages if the client did not leave them before its disconnect. The token will be invalid after the client sent the disconnect to the server and cannot be reused after this action. The client has to use the &lt;code&gt;connect&lt;/code&gt; operation again to receive a new token.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;disconnect&#34;,&#xA;    &#34;token&#34; : &#34;48468827-e20c-4ebd-b1c5-f7c36dc4bc95&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;success&#34; : true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ping (Sends a ping to the server to stay connected)&lt;/h3&gt; &#xA;&lt;p&gt;Sends a ping request to the server. The server should reply with a &lt;code&gt;pong&lt;/code&gt; set to the timeout for chat connections.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;ping&#34;,&#xA;    &#34;token&#34; : &#34;48468827-e20c-4ebd-b1c5-f7c36dc4bc95&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Return value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;success&#34; : true,&#xA;    &#34;pong&#34; : 120000&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Incoming Messages&lt;/h2&gt; &#xA;&lt;p&gt;The server will send messages to the client without the client asking for it. The client should therefore register a listener as soon as possible to catch these messages.&lt;/p&gt; &#xA;&lt;p&gt;Here is a small Java example to do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;vertx.eventBus().registerHandler(&#34;campudus.chatters.&#34; + myToken, new Handler&amp;lt;Message&amp;lt;JsonObject&amp;gt;&amp;gt;() {&#xA;  public void handle(Message&amp;lt;JsonObject&amp;gt; message) {&#xA;    switch (message.body.getString(&#34;action&#34;)) {&#xA;    case &#34;message&#34;:&#xA;      final String sender = message.body.getString(&#34;nickname&#34;);&#xA;      final String text = message.body.getString(&#34;message&#34;);&#xA;      final String room = message.body.getString(&#34;room&#34;);&#xA;      if (room == null) {&#xA;        handlePrivateMessage(sender, text);&#xA;      } else {&#xA;        handleChatMessage(room, sender, text);&#xA;      }&#xA;      break;&#xA;    case &#34;join&#34;:&#xA;      final String joinedPerson = message.body.getString(&#34;nickname&#34;);&#xA;      final String joinedRoom = message.body.getString(&#34;room&#34;);&#xA;      handleJoin(joinedPerson, joinedRoom);&#xA;      break;&#xA;    case &#34;part&#34;:&#xA;      final String partedPerson = message.body.getString(&#34;nickname&#34;);&#xA;      final String partedRoom = message.body.getString(&#34;room&#34;);&#xA;      handlePart(partedPerson, partedRoom);&#xA;      break;&#xA;    case &#34;ping&#34;:&#xA;      sendPingToServer(myToken);&#xA;      break;&#xA;    }&#xA;  }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;message (Receives a message)&lt;/h3&gt; &#xA;&lt;p&gt;If there is an incoming message, the server will send it to the client. If the message was sent to a specific room and the client may be only one of many addressed participants, the message will look like this example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;message&#34;,&#xA;    &#34;nickname&#34; : &#34;ThePlayfulGorilla&#34;,&#xA;    &#34;room&#34; : &#34;jungle&#34;,&#xA;    &#34;message&#34; : &#34;Hrrm!&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, the client with nickname &lt;em&gt;ThePlayfulGorilla&lt;/em&gt; sent the text &lt;em&gt;Hrrm!&lt;/em&gt; to the chat-room &lt;em&gt;jungle&lt;/em&gt;. The chat-room is optional. That means, if a client decides to write privately to this client, it will be sent without the &#34;room&#34; key/value. So an example for a private message from &lt;em&gt;ThePlayfulGorilla&lt;/em&gt; with content &lt;em&gt;Hi there, my friend!&lt;/em&gt; looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;message&#34;,&#xA;    &#34;nickname&#34; : &#34;ThePlayfulGorilla&#34;,&#xA;    &#34;message&#34; : &#34;Hi there, my friend!&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;join (Someone joined a chat-room)&lt;/h3&gt; &#xA;&lt;p&gt;The server will notice all clients connected to a chat-room if another clients joins the room. Here is an example message, if &lt;em&gt;TheLawfulHuman&lt;/em&gt; joins the room &lt;em&gt;jungle&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;join&#34;,&#xA;    &#34;nickname&#34; : &#34;TheLawfulHuman&#34;,&#xA;    &#34;room&#34; : &#34;jungle&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now all clients know that this new client joined the conversation.&lt;/p&gt; &#xA;&lt;h3&gt;part (Someone left a chat-room)&lt;/h3&gt; &#xA;&lt;p&gt;This is analog to the join. If someone disconnects from a room, all clients still inside this room will be notified by the server like the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;part&#34;,&#xA;    &#34;nickname&#34; : &#34;TheLawfulHuman&#34;,&#xA;    &#34;room&#34; : &#34;jungle&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here &lt;em&gt;TheLawfulHuman&lt;/em&gt; obviously did not want to stay inside the room &lt;em&gt;jungle&lt;/em&gt; any longer or was disconnected by the server.&lt;/p&gt; &#xA;&lt;h3&gt;ping (The server wants to receive a ping)&lt;/h3&gt; &#xA;&lt;p&gt;The server wants to make sure that all clients stay connected. To be sure a client is still there, it will send a ping request. The client should not answer that message directly but send a &lt;code&gt;ping&lt;/code&gt; action itself to the server. After a ping request by the server, the client has the amount of milliseconds set up in &lt;code&gt;latency-timeout&lt;/code&gt; to send the &lt;code&gt;ping&lt;/code&gt; operation.&lt;/p&gt; &#xA;&lt;p&gt;Example flow of messages:&lt;/p&gt; &#xA;&lt;p&gt;Server sends a message like this to &lt;em&gt;campudus.chatters.48468827-e20c-4ebd-b1c5-f7c36dc4bc95&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;ping&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Client receives that message and sends a message to &lt;em&gt;campudus.chat&lt;/em&gt; with the following content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;ping&#34;,&#xA;    &#34;token&#34; : &#34;48468827-e20c-4ebd-b1c5-f7c36dc4bc95&#34; &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server receives this message and responds with its regular response:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;success&#34; : true,&#xA;    &#34;pong&#34; : 120000&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inside the server module, the timeout will be reset and it will wait the set up &lt;code&gt;timeout&lt;/code&gt; before sending a ping request again.&lt;/p&gt; &#xA;&lt;h3&gt;disconnect (The server disconnected this client)&lt;/h3&gt; &#xA;&lt;p&gt;If the server disconnects a client, it will let the client know. Usually, a disconnect only occurs if the ping request wasn&#39;t sent fast enough and the server timed out the client. The server will let the client know with an error message.&lt;/p&gt; &#xA;&lt;p&gt;A disconnect message will look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{&#xA;    &#34;action&#34; : &#34;disconnect&#34;,&#xA;    &#34;error&#34; : &#34;PING_TIMEOUT&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Right now, there is only a &lt;code&gt;PING_TIMEOUT&lt;/code&gt; error. In future versions, an administrator may disconnect clients which will result in different error messages.&lt;/p&gt;</summary>
  </entry>
</feed>