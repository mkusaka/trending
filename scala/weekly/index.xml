<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-13T01:50:11Z</updated>
  <subtitle>Weekly Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>apache/incubator-pekko</title>
    <updated>2022-11-13T01:50:11Z</updated>
    <id>tag:github.com,2022-11-13:/apache/incubator-pekko</id>
    <link href="https://github.com/apache/incubator-pekko" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Build highly concurrent, distributed, and resilient message-driven applications using Java/Scala&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Apache Pekko&lt;/h1&gt; &#xA;&lt;p&gt;Apache Pekko is an open-source framework for building applications that are concurrent, distributed, resilient and elastic.&lt;/p&gt; &#xA;&lt;p&gt;Pekko uses the Actor Model to provide more intuitive high-level abstractions for concurrency. Using these abstractions, Pekko also provides libraries for persistence, streams, HTTP, and more.&lt;/p&gt; &#xA;&lt;p&gt;Pekko is fork of &lt;a href=&#34;https://github.com/akka/akka&#34;&gt;Akka&lt;/a&gt; 2.6.x, prior to the Akka project&#39;s adoption of the Business Source License.&lt;/p&gt; &#xA;&lt;h2&gt;Reference Documentation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;TODO add documentation links&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;There are several ways to interact with the Pekko community:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/incubator-pekko/discussions&#34;&gt;GitHub discussions&lt;/a&gt;: for questions and general discussion.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://lists.apache.org/list.html?dev@pekko.apache.org&#34;&gt;Pekko dev mailing list&lt;/a&gt;: for Pekko development discussions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/incubator-pekko/issues&#34;&gt;GitHub issues&lt;/a&gt;: for bug reports and feature requests. Please search the existing issues before creating new ones. If you are unsure whether you have found a bug, consider asking in GitHub discussions or the mailing list first.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are very welcome. If you have an idea on how to improve Pekko, don&#39;t hesitate to create an issue or submit a pull request.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/apache/incubator-pekko/raw/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for details on the development workflow and how to create your pull request.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;Apache Pekko is governed by the &lt;a href=&#34;https://www.apache.org/foundation/policies/conduct.html&#34;&gt;Apache code of conduct&lt;/a&gt;. By participating in this project you agree to abide by its terms.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Apache Pekko is available under the Apache License, version 2.0. See &lt;a href=&#34;https://github.com/apache/incubator-pekko/raw/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>prisma/prisma1</title>
    <updated>2022-11-13T01:50:11Z</updated>
    <id>tag:github.com,2022-11-13:/prisma/prisma1</id>
    <link href="https://github.com/prisma/prisma1" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üíæ Database Tools incl. ORM, Migrations and Admin UI (Postgres, MySQL &amp; MongoDB) [deprecated]&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.prisma.io&#34;&gt;&lt;img src=&#34;https://i.imgur.com/QgwDieO.png&#34; alt=&#34;Prisma&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.prisma.io&#34;&gt;Website&lt;/a&gt; ‚Ä¢ &lt;a href=&#34;https://v1.prisma.io/docs/1.34&#34;&gt;Prisma 1 Docs&lt;/a&gt; ‚Ä¢ &lt;a href=&#34;https://github.com/prisma/prisma1-examples/&#34;&gt;Prisma 1 Examples&lt;/a&gt; ‚Ä¢ &lt;a href=&#34;https://www.prisma.io/blog&#34;&gt;Blog&lt;/a&gt; ‚Ä¢ &lt;a href=&#34;https://slack.prisma.io/&#34;&gt;Slack&lt;/a&gt; ‚Ä¢ &lt;a href=&#34;https://twitter.com/prisma&#34;&gt;Twitter&lt;/a&gt; ‚Ä¢ &lt;a href=&#34;https://github.com/prisma/prisma&#34;&gt;Prisma 2&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/prisma/prisma1&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/prisma/prisma1.svg?style=shield&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://slack.prisma.io&#34;&gt;&lt;img src=&#34;https://slack.prisma.io/badge.svg?sanitize=true&#34; alt=&#34;Slack Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;‚ö†Ô∏è&amp;nbsp;&lt;strong&gt;&lt;a href=&#34;https://github.com/prisma/prisma1/issues/5208&#34;&gt;Prisma 1 was deprecated on September 1st, 2022&lt;/a&gt;. If you are new to Prisma, check out the latest version of &lt;a href=&#34;https://www.prisma.io&#34;&gt;Prisma&lt;/a&gt;!&lt;/strong&gt;&amp;nbsp;‚ö†Ô∏è&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Prisma 1 replaces traditional ORMs and simplifies database workflows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Access&lt;/em&gt;: &lt;strong&gt;Type-safe database access with the auto-generated Prisma client&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Migrate&lt;/em&gt;: &lt;strong&gt;Declarative data modelling and migrations&lt;/strong&gt; (optional)&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Manage&lt;/em&gt;: &lt;strong&gt;Visual data management with Prisma Admin&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is used to build &lt;strong&gt;GraphQL, REST, gRPC APIs&lt;/strong&gt; and more. Prisma 1 currently supports MySQL, PostgreSQL, MongoDB.&lt;/p&gt; &#xA;&lt;h2&gt;Get started with Prisma 1&lt;/h2&gt; &#xA;&lt;p&gt;You can find installation and usage instructions in the &lt;a href=&#34;https://v1.prisma.io/docs/1.34/get-started/01-setting-up-prisma-new-database-TYPESCRIPT-t002/&#34;&gt;Prisma 1 docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/prisma/prisma1/issues/5208&#34;&gt;Prisma 1 was deprecated on September 1st, 2022&lt;/a&gt;. If you are new to Prisma, check out the latest version of &lt;a href=&#34;https://www.prisma.io&#34;&gt;Prisma&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;Prisma has a &lt;a href=&#34;https://www.prisma.io/community&#34;&gt;community&lt;/a&gt; of thousands of amazing developers and contributors. Welcome, please join us! üëã&lt;/p&gt; &#xA;&lt;h3&gt;Channels&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://slack.prisma.io/&#34;&gt;Slack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/prisma&#34;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.facebook.com/prisma.io&#34;&gt;Facebook&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:hello@prisma.io&#34;&gt;Email&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Events&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.prisma.io/day/&#34;&gt;Prisma Day&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.meetup.com/TypeScript-Berlin/&#34;&gt;TypeScript Berlin Meetup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.meetup.com/graphql-berlin&#34;&gt;GraphQL Berlin Meetup&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Resources&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/catalinmiron/awesome-prisma&#34;&gt;Awesome Prisma&lt;/a&gt; (Thanks to &lt;a href=&#34;https://github.com/catalinmiron&#34;&gt;Catalin Miron&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://prisma.1wire.com/&#34;&gt;Chinese translation of the Prisma 1 docs&lt;/a&gt; (Thanks to &lt;a href=&#34;https://github.com/Victorkangsh&#34;&gt;Victor Kang&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>stripe/bonsai</title>
    <updated>2022-11-13T01:50:11Z</updated>
    <id>tag:github.com,2022-11-13:/stripe/bonsai</id>
    <link href="https://github.com/stripe/bonsai" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Beautiful trees, without the landscaping.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Bonsai&lt;/h1&gt; &#xA;&lt;p&gt;Beautiful trees, without the landscaping. Bonsai is a Scala library for transforming arbitrary tree structures into read-only versions that take up a fraction of the space.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Bonsai compresses trees in 2 ways: by using significantly less space to store the tree structure itself (tree compression), and by encoding the node labels in a memory efficient structure (label compression).&lt;/p&gt; &#xA;&lt;h3&gt;What is a &#34;Tree&#34;?&lt;/h3&gt; &#xA;&lt;p&gt;Bonsai works over arbitrary trees, so it assumes a fairly generic interface for interacting with trees. In Bonsai a tree;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;has 0 or 1 root nodes&lt;/li&gt; &#xA; &lt;li&gt;each node has 0 or more children&lt;/li&gt; &#xA; &lt;li&gt;each node has a label attached to it&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The actual type of the node is unimportant. What is important is the node labels and the relationships between the nodes (parent, child, sibling, etc). This structure is enough to describe most of the types of trees you are familiar with.&lt;/p&gt; &#xA;&lt;p&gt;Bonsai encodes this notion of trees with the &lt;a href=&#34;https://github.com/stripe/bonsai/raw/master/bonsai-core/src/main/scala/com/stripe/bonsai/TreeOps.scala&#34;&gt;TreeOps type class&lt;/a&gt;. Here is a truncated version of the type class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait TreeOps[Tree, Label] {&#xA;&#xA;  /** The type of the nodes in the tree. */&#xA;  type Node&#xA;&#xA;  /**&#xA;   * Returns the root node of the tree.&#xA;   */&#xA;  def root(t: Tree): Option[Node]&#xA;&#xA;  /**&#xA;   * Returns all the direct children of the given node. The order may or may&#xA;   * not matter. TreeOps does not provide any guarantees here.&#xA;   */&#xA;  def children(node: Node): Iterable[Node]&#xA;&#xA;  /**&#xA;   * Returns the label attached to the given node.&#xA;   */&#xA;  def label(node: Node): Label&#xA;&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The type &lt;code&gt;T&lt;/code&gt; is our actual tree type. The &lt;code&gt;Node&lt;/code&gt; type is the way we reference internal nodes in our tree &lt;code&gt;T&lt;/code&gt;. The actual type of &lt;code&gt;Node&lt;/code&gt; isn&#39;t important, however, and is mostly an implementation detail. The important bit is the &lt;code&gt;Label&lt;/code&gt; type, which is the user-facing data associated with each node.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;bonsai-example&lt;/code&gt; subproject has &lt;a href=&#34;https://github.com/stripe/bonsai/raw/master/bonsai-example/src/main/scala/com/stripe/bonsai/example/Huffman.scala&#34;&gt;an example of a Huffman tree&lt;/a&gt;. A Huffman tree is used to store a Huffman coding for decoding a compressed message (a bitstring). We decode the bitstring, bit-by-bit, using the tree.&lt;/p&gt; &#xA;&lt;p&gt;Starting at the root of the tree, we follow the left child if the current bit is a 0 and the right child if it is a 1. We continue until reaching a leaf node, at which poitn we output the symbol associated with it, then start back at the beginning of the tree. When we&#39;ve exhausted the entire bitstring, we&#39;ll have our decoded message.&lt;/p&gt; &#xA;&lt;p&gt;Here is how we may implement a Huffman tree in Scala:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sealed trait HuffmanTree[+A]&#xA;case class Branch[+A](zero: HuffmanTree[A], one: HuffmanTree[A]) extends HuffmanTree[A]&#xA;case class Leaf[+A](value: A) extends HuffmanTree[A]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And here is how we would implement its &lt;code&gt;TreeOps&lt;/code&gt; instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.stripe.bonsai.TreeOps&#xA;&#xA;object HuffmanTree {&#xA;  implicit def huffmanTreeOps[A]: TreeOps[HuffmanTree[A], Option[A]] =&#xA;    new TreeOps[HuffmanTree[A], Option[A]] {&#xA;      type Node = HuffmanTree[A]&#xA;&#xA;      def root(tree: HuffmanTree[A]): Option[HuffmanTree[A]] = Some(tree)&#xA;      def children(tree: HuffmanTree[A]): Iterable[HuffmanTree[A]] = tree match {&#xA;        case Branch(l, r) =&amp;gt; l :: r :: Nil&#xA;        case _ =&amp;gt; Nil&#xA;      }&#xA;      def label(tree: HuffmanTree[A]): Option[A] = tree match {&#xA;        case Leaf(value) =&amp;gt; Some(value)&#xA;        case _ =&amp;gt; None&#xA;      }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As long as we are careful to implement all our operations on a Huffman tree by using its more generic &lt;code&gt;TreeOps&lt;/code&gt; interface, rather than &lt;code&gt;HuffmanTree&lt;/code&gt; directly, we can then swap out the actual tree data structure, without affecting the code using it.&lt;/p&gt; &#xA;&lt;p&gt;For example, below we implement a &lt;code&gt;decode&lt;/code&gt; operation as an implicit class using just &lt;code&gt;TreeOps&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scala.collection.immutable.BitSet&#xA;&#xA;implicit class HuffmanTreeOps[T, A](tree: T)(implicit treeOps: TreeOps[T, Option[A]]) {&#xA;  // Importing treeOps gives us some useful methods on `tree`&#xA;  import treeOps._&#xA;&#xA;  def decode(bits: BitSet, len: Int): Vector[A] = {&#xA;    val root = tree.root.get&#xA;    val (_, result) = (0 until len)&#xA;      .foldLeft((root, Vector.empty[A])) { case ((node, acc), i) =&amp;gt;&#xA;        node.label match {&#xA;          case Some(value) =&amp;gt; (root, acc :+ value)&#xA;          case None if bits(i) =&amp;gt; (node.children.head, acc)&#xA;          case None =&amp;gt; (node.children.iterator.drop(1).next, acc)&#xA;        }&#xA;      }&#xA;    result&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The goal of this indirection through &lt;code&gt;TreeOps&lt;/code&gt; is to let us use a compressed version of the &lt;code&gt;tree&lt;/code&gt; instead of an actual &lt;code&gt;HuffmanTree&lt;/code&gt;, which will see below.&lt;/p&gt; &#xA;&lt;h3&gt;Tree Compression&lt;/h3&gt; &#xA;&lt;p&gt;Bonsai&#39;s tree compression is based off of a &lt;a href=&#34;https://en.wikipedia.org/wiki/Succinct_data_structure&#34; title=&#34;Succinct Data Structures&#34;&gt;succinct data structure&lt;/a&gt; for binary trees. Bonsai supports k-ary trees by first transforming the original tree into a &lt;a href=&#34;https://en.wikipedia.org/wiki/Left-child_right-sibling_binary_tree&#34;&gt;left-child right-sibling tree&lt;/a&gt;, which preserves all the relationships from the original tree, but ensures we have at most 2 children per node. You can read more about the details of the actual compression algorithm used in &lt;a href=&#34;http://www.dcc.uchile.cl/~gnavarro/algoritmos/ps/wea05.pdf&#34;&gt;&#34;Practical Implementation of Rank and Select Queries&#34;&lt;/a&gt;. &lt;strong&gt;The upshot is that we can store the entire structure of a tree in only ~2.73bits per node.&lt;/strong&gt; This replaces the normal strategy of using JVM objects for nodes and references to store the relationships.&lt;/p&gt; &#xA;&lt;p&gt;We actually compress trees by transforming them into &lt;a href=&#34;https://github.com/stripe/bonsai/raw/master/bonsai-core/src/main/scala/com/stripe/bonsai/Tree.scala&#34;&gt;Bonsai &lt;code&gt;Tree&lt;/code&gt;s&lt;/a&gt;. Bonsai&#39;s &lt;code&gt;Tree&lt;/code&gt; constructor takes any arbitrary tree &lt;code&gt;T&lt;/code&gt; that has a &lt;code&gt;TreeOps[T]&lt;/code&gt; available and will return a &lt;a href=&#34;https://github.com/stripe/bonsai/raw/master/bonsai-core/src/main/scala/com/stripe/bonsai/Tree.scala&#34;&gt;&lt;code&gt;Tree&lt;/code&gt;&lt;/a&gt; with the same structure and labels (and &lt;code&gt;Label&lt;/code&gt; type) as the original tree. However, the entire structure and labels of the tree will have been compressed, so this new tree requires significantly less space.&lt;/p&gt; &#xA;&lt;p&gt;In the example in &lt;code&gt;bonsai-example&lt;/code&gt;, we use the Huffman encoding described above to construct a simple Huffman tree for the printable ASCII characters (0x20 -&amp;gt; 0x7E) and compress it using Bonsai&#39;s &lt;code&gt;Tree&lt;/code&gt;. The result is a &lt;strong&gt;11x reduction&lt;/strong&gt; in memory requirements. Since our &lt;code&gt;decode&lt;/code&gt; operation was implemented using &lt;code&gt;TreeOps&lt;/code&gt;, we can use this compressed tree just as we would&#39;ve used the original tree.&lt;/p&gt; &#xA;&lt;p&gt;This example is a bit contrived, since the trees are small to begin with, but you can imagine that applying this to a large random forest yields great results.&lt;/p&gt; &#xA;&lt;h3&gt;Label Compression&lt;/h3&gt; &#xA;&lt;p&gt;Bonsai provides a &lt;a href=&#34;https://github.com/stripe/bonsai/raw/master/bonsai-core/src/main/scala/com/stripe/bonsai/Layout.scala&#34;&gt;Layout&lt;/a&gt; type class, along with some simple combinators, for describing how to (de)serialize your labels. At the lowest level are a set of Layout &#34;primitives&#34; that can encode simple data types into compact data structures. The combinators then allow more complex structures to be described (tuples, &lt;code&gt;Either&lt;/code&gt;, mappings to case classes, etc), without adding much, if any, overhead.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example of a &lt;code&gt;Layout&lt;/code&gt; for some &lt;code&gt;Widget&lt;/code&gt; type we made up:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import com.stripe.bonsai.Layout&#xA;&#xA;sealed trait Widget&#xA;case class Sprocket(radius: Int, weight: Option[Double]) extends Widget&#xA;case class Doodad(length: Int, width: Int, weight: Option[Double]) extends Widget&#xA;&#xA;object Widget {&#xA;  implicit val WidgetLayout: Layout[Widget] = {&#xA;    Layout[Either[(Int, Option[Double]), ((Int, Int), Option[Double])]].transform(&#xA;      {&#xA;        case Left((r, wt)) =&amp;gt; Sprocket(r, wt)&#xA;        case Right(((l, w), wt)) =&amp;gt; Doodad(l, w, wt)&#xA;      },&#xA;      {&#xA;        case Sprocket(r, wt) =&amp;gt; Left((r, wt))&#xA;        case Doodad(l, w, wt) =&amp;gt; Right(((l, w), wt))&#xA;      }&#xA;    )&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can see the &lt;a href=&#34;https://github.com/stripe/bonsai/raw/master/bonsai-example/src/main/scala/com/stripe/bonsai/example/Widget.scala&#34;&gt;full Widget code/example&lt;/a&gt; in the &lt;code&gt;bonsai-example&lt;/code&gt; sub project. In that example, we compress a &lt;code&gt;Vector[Option[Widget]]&lt;/code&gt; using the layout and end up with over a &lt;strong&gt;6x reduction&lt;/strong&gt; in memory requirements.&lt;/p&gt; &#xA;&lt;p&gt;Currently, Bonsai focuses mainly on compressing the overhead of the structure your data requires (eg options, eithers, tuples), rather than the data itself. This will likely change in future releases, and we&#39;ll support better compression for primitive types, as well as things like dictionary encoding for all types.&lt;/p&gt; &#xA;&lt;h1&gt;Using Bonsai in SBT or Maven&lt;/h1&gt; &#xA;&lt;p&gt;Bonsai is published on sonatype. To use it in your SBT project, you can add the following to your &lt;code&gt;build.sbt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;com.stripe&#34; %% &#34;bonsai&#34; % &#34;0.3.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Miscellaneous&lt;/h1&gt; &#xA;&lt;p&gt;Bonsai is Open Source and available under the MIT License.&lt;/p&gt; &#xA;&lt;p&gt;For more help, feel free to contact the authors or create an issue.&lt;/p&gt;</summary>
  </entry>
</feed>