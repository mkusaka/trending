<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-01T02:04:01Z</updated>
  <subtitle>Weekly Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>softwaremill/ox</title>
    <updated>2023-10-01T02:04:01Z</updated>
    <id>tag:github.com,2023-10-01:/softwaremill/ox</id>
    <link href="https://github.com/softwaremill/ox" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Developer-friendly structured concurrency library for the JVM&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ox&lt;/h1&gt; &#xA;&lt;p&gt;Developer-friendly structured concurrency library for the JVM, based on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://openjdk.org/projects/loom/&#34;&gt;Project Loom&lt;/a&gt; (virtual threads)&lt;/li&gt; &#xA; &lt;li&gt;structured concurrency Java APIs (&lt;a href=&#34;https://openjdk.org/jeps/428&#34;&gt;JEP 428&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;scoped values (&lt;a href=&#34;https://openjdk.org/jeps/429&#34;&gt;JEP 429&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt;-like channels&lt;/li&gt; &#xA; &lt;li&gt;the &lt;a href=&#34;https://www.scala-lang.org&#34;&gt;Scala 3&lt;/a&gt; programming language&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Requires JDK 21.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.scala-sbt.org&#34;&gt;sbt&lt;/a&gt; dependency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&#34;com.softwaremill.ox&#34; %% &#34;core&#34; % &#34;0.0.14&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Introductory articles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://softwaremill.com/prototype-loom-based-concurrency-api-for-scala/&#34;&gt;Prototype Loom-based concurrency API for Scala&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://softwaremill.com/go-like-channels-using-project-loom-and-scala/&#34;&gt;Go-like channels using project Loom and Scala&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Community&lt;/h1&gt; &#xA;&lt;p&gt;If you&#39;d have feedback, development ideas or critique, please head to our &lt;a href=&#34;https://softwaremill.community/c/ox/12&#34;&gt;community forum&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h1&gt;API overview&lt;/h1&gt; &#xA;&lt;h2&gt;Run two computations in parallel&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.par&#xA;&#xA;def computation1: Int =&#xA;  Thread.sleep(2000)&#xA;  1&#xA;&#xA;def computation2: String =&#xA;  Thread.sleep(1000)&#xA;  &#34;2&#34;&#xA;&#xA;val result: (Int, String) = par(computation1)(computation2)&#xA;// (1, &#34;2&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If one of the computations fails, the other is interrupted, and &lt;code&gt;par&lt;/code&gt; waits until both branches complete.&lt;/p&gt; &#xA;&lt;h2&gt;Race two computations&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.raceSuccess&#xA;&#xA;def computation1: Int =&#xA;  Thread.sleep(2000)&#xA;  1&#xA;&#xA;def computation2: Int =&#xA;  Thread.sleep(1000)&#xA;  2&#xA;&#xA;val result: Int = raceSuccess(computation1)(computation2)&#xA;// 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The losing computation is interrupted using &lt;code&gt;Thread.interrupt&lt;/code&gt;. &lt;code&gt;raceSuccess&lt;/code&gt; waits until both branches finish; this also applies to the losing one, which might take a while to clean up after interruption.&lt;/p&gt; &#xA;&lt;h3&gt;Error handling&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;raceSuccess&lt;/code&gt; returns the first result, or re-throws the last exception&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;raceResult&lt;/code&gt; returns the first result, or re-throws the first exception&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Timeout a computation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.timeout&#xA;import scala.concurrent.duration.DurationInt&#xA;&#xA;def computation: Int =&#xA;  Thread.sleep(2000)&#xA;  1&#xA;&#xA;val result1: Try[Int] = Try(timeout(1.second)(computation)) // failure: TimeoutException&#xA;val result2: Try[Int] = Try(timeout(3.seconds)(computation)) // success: 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A variant, &lt;code&gt;timeoutOption&lt;/code&gt;, doesn&#39;t throw a &lt;code&gt;TimeoutException&lt;/code&gt; on timeout, but returns &lt;code&gt;None&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;h2&gt;Fork &amp;amp; join threads&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s safest to use higher-level methods, such as &lt;code&gt;par&lt;/code&gt; or &lt;code&gt;raceSuccess&lt;/code&gt;, however this isn&#39;t always sufficient. For these cases, threads can be started using the structured concurrency APIs described below.&lt;/p&gt; &#xA;&lt;p&gt;Forks (new threads) can only be started with a &lt;strong&gt;scope&lt;/strong&gt;. Such a scope is defined using the &lt;code&gt;supervised&lt;/code&gt; or &lt;code&gt;scoped&lt;/code&gt; methods.&lt;/p&gt; &#xA;&lt;p&gt;The lifetime of the forks is defined by the structure of the code, and corresponds to the enclosing &lt;code&gt;supervised&lt;/code&gt; or &lt;code&gt;scoped&lt;/code&gt; block. Once the code block passed to the scope completes, any forks that are still running are interrupted. The whole block will complete only once all forks have completed (successfully, or with an exception).&lt;/p&gt; &#xA;&lt;p&gt;Hence, it is guaranteed that all forks started within &lt;code&gt;supervised&lt;/code&gt; or &lt;code&gt;scoped&lt;/code&gt; will finish successfully, with an exception, or due to an interrupt.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.{fork, supervised}&#xA;&#xA;// same as `par`&#xA;supervised {&#xA;  val f1 = fork {&#xA;    Thread.sleep(2000)&#xA;    1&#xA;  }&#xA;&#xA;  val f2 = fork {&#xA;    Thread.sleep(1000)&#xA;    2&#xA;  }&#xA;&#xA;  (f1.join(), f2.join())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is a compile-time error to use &lt;code&gt;fork&lt;/code&gt; outside of a &lt;code&gt;supervised&lt;/code&gt; or &lt;code&gt;scoped&lt;/code&gt; block. Helper methods might require to be run within a scope by requiring the &lt;code&gt;Ox&lt;/code&gt; capability:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.{fork, Fork, Ox, supervised}&#xA;&#xA;def forkComputation(p: Int)(using Ox): Fork[Int] = fork {&#xA;  Thread.sleep(p * 1000)&#xA;  p + 1&#xA;}&#xA;&#xA;supervised {&#xA;  val f1 = forkComputation(2)&#xA;  val f2 = forkComputation(4)&#xA;  (f1.join(), f2.join())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scopes can be arbitrarily nested.&lt;/p&gt; &#xA;&lt;h3&gt;Supervision&lt;/h3&gt; &#xA;&lt;p&gt;The default scope, created with &lt;code&gt;supervised&lt;/code&gt;, watches over the forks that are started within. Any forks started with &lt;code&gt;fork&lt;/code&gt; are by default supervised.&lt;/p&gt; &#xA;&lt;p&gt;This means that the scope will end only when either:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;all (non-daemon, supervised) forks, including the code block passed to &lt;code&gt;supervised&lt;/code&gt;, succeed&lt;/li&gt; &#xA; &lt;li&gt;or any (supervised) fork, including the code block passed to &lt;code&gt;supervised&lt;/code&gt;, fails&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Hence an exception in any of the forks will cause the whole scope to end. Ending the scope means that all running forks are cancelled (interrupted). Once all forks complete, the exception is propagated further, that is re-thrown by the &lt;code&gt;supervised&lt;/code&gt; method invocation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.{fork, Fork, Ox, supervised}&#xA;&#xA;supervised {&#xA;  fork {&#xA;    Thread.sleep(1000)&#xA;    println(&#34;Hello!&#34;)&#xA;  }&#xA;  fork {&#xA;    Thread.sleep(500)&#xA;    throw new RuntimeException(&#34;boom!&#34;)&#xA;  }&#xA;}&#xA;&#xA;// doesn&#39;t print &#34;Hello&#34;, instead throws &#34;boom!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Daemon forks&lt;/h3&gt; &#xA;&lt;p&gt;In supervised mode, daemon forks can be created using &lt;code&gt;forkDaemon&lt;/code&gt;. Their failure will still end the scope. However, the scope will also end once all non-daemon forks succeed, regardless if the daemon fork is still running.&lt;/p&gt; &#xA;&lt;p&gt;Finally, entirely unsupervised forks can be ran using &lt;code&gt;forkUnsupervised&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Unsupervised scopes&lt;/h3&gt; &#xA;&lt;p&gt;An unsupervised scope can be created using &lt;code&gt;scoped&lt;/code&gt;. Any forks started within are unsupervised.&lt;/p&gt; &#xA;&lt;p&gt;Such a scope ends, once the code block passed to &lt;code&gt;scoped&lt;/code&gt; completes. Then, all running forks are cancelled. Still, the scope completes (that is, the &lt;code&gt;scoped&lt;/code&gt; block returns) only once all forks have completed.&lt;/p&gt; &#xA;&lt;p&gt;Fork failures aren&#39;t handled in any special way, and can be inspected using the &lt;code&gt;Fork.join()&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;h3&gt;Cancelling forks&lt;/h3&gt; &#xA;&lt;p&gt;By default, forks are not cancellable by the user. Instead, all outstanding forks are cancelled (interrupted) when the enclosing scope ends.&lt;/p&gt; &#xA;&lt;p&gt;If needed, a cancellable fork can be created using &lt;code&gt;forkCancellable&lt;/code&gt;. However, such an operation is more expensive, as it involves creating a nested scope and two virtual threads, instead of one.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;CancellableFork&lt;/code&gt; trait exposes the &lt;code&gt;.cancel&lt;/code&gt; method, which interrupts the fork and awaits its completion. Alternatively, &lt;code&gt;.cancelNow&lt;/code&gt; returns immediately. In any case, the enclosing scope will only complete once all forks have completed.&lt;/p&gt; &#xA;&lt;h3&gt;Error handling&lt;/h3&gt; &#xA;&lt;p&gt;In supervised mode, if a fork fails with an exception, the enclosing scope will end.&lt;/p&gt; &#xA;&lt;p&gt;Moreover, if a fork fails with an exception, the &lt;code&gt;Fork.join&lt;/code&gt; method will throw that exception.&lt;/p&gt; &#xA;&lt;p&gt;In unsupervised mode, if there&#39;s no join and the fork fails, the exception might go unnoticed.&lt;/p&gt; &#xA;&lt;h2&gt;Scoped values&lt;/h2&gt; &#xA;&lt;p&gt;Scoped value replace usages of &lt;code&gt;ThreadLocal&lt;/code&gt; when using virtual threads and structural concurrency. They are useful to propagate auxiliary context, e.g. trace or correlation ids.&lt;/p&gt; &#xA;&lt;p&gt;Values are bound structurally as well, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.{ForkLocal, fork, supervised}&#xA;&#xA;val v = ForkLocal(&#34;a&#34;)&#xA;supervised {&#xA;  println(v.get()) // &#34;a&#34;&#xA;  fork {&#xA;    v.scopedWhere(&#34;x&#34;) {&#xA;      println(v.get()) // &#34;x&#34;&#xA;      fork {&#xA;        println(v.get()) // &#34;x&#34;&#xA;      }.join()&#xA;    }&#xA;  }.join()&#xA;  println(v.get()) // &#34;a&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scoped values propagate across nested scopes.&lt;/p&gt; &#xA;&lt;h2&gt;Interruptions&lt;/h2&gt; &#xA;&lt;p&gt;When catching exceptions, care must be taken not to catch &amp;amp; fail to propagate an &lt;code&gt;InterruptedException&lt;/code&gt;. Doing so will prevent the scope cleanup mechanisms to make appropriate progress, as the scope won&#39;t finish until all started threads complete.&lt;/p&gt; &#xA;&lt;p&gt;A good solution is to catch only non-fatal exception using &lt;code&gt;NonFatal&lt;/code&gt;, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.{forever, fork, supervised}&#xA;&#xA;def processSingleItem(): Unit = ()&#xA;&#xA;supervised {&#xA;  fork {&#xA;    forever {&#xA;      try processSingleItem()&#xA;      catch case NonFatal(e) =&amp;gt; logger.error(&#34;Processing error&#34;, e)&#xA;    }&#xA;  }&#xA;&#xA;  // do something else&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;h3&gt;In-scope&lt;/h3&gt; &#xA;&lt;p&gt;Resources can be allocated within a scope. They will be released in reverse acquisition order, after the scope completes (that is, after all forks started within finish). E.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.{supervised, useInScope}&#xA;&#xA;case class MyResource(c: Int)&#xA;&#xA;def acquire(c: Int) : MyResource =&#xA;  println(s&#34;acquiring $c ...&#34;)&#xA;  MyResource(c)&#xA;&#xA;def release(resource: MyResource): Unit =&#xA;  println(s&#34;releasing ${resource.c} ...&#34;)&#xA;&#xA;supervised {&#xA;  val resource1 = useInScope(acquire(10))(release)&#xA;  val resource2 = useInScope(acquire(20))(release)&#xA;  println(s&#34;Using $resource1 ...&#34;)&#xA;  println(s&#34;Using $resource2 ...&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Supervised / scoped&lt;/h3&gt; &#xA;&lt;p&gt;Resources can also be used in a dedicated scope:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.useSupervised&#xA;&#xA;case class MyResource(c: Int)&#xA;&#xA;def acquire(c: Int): MyResource =&#xA;  println(s&#34;acquiring $c ...&#34;)&#xA;  MyResource(c)&#xA;&#xA;def release(resource: MyResource): Unit =&#xA;  println(s&#34;releasing ${resource.c} ...&#34;)&#xA;&#xA;useSupervised(acquire(10))(release) { resource =&amp;gt;&#xA;  println(s&#34;Using $resource ...&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the resource extends &lt;code&gt;AutoCloseable&lt;/code&gt;, the &lt;code&gt;release&lt;/code&gt; method doesn&#39;t need to be provided.&lt;/p&gt; &#xA;&lt;h2&gt;Helper control flow methods&lt;/h2&gt; &#xA;&lt;p&gt;There are some helper methods which might be useful when writing forked code:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;forever { ... }&lt;/code&gt; repeatedly evaluates the given code block forever&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;repeatWhile { ... }&lt;/code&gt; repeatedly evaluates the given code block, as long as it returns &lt;code&gt;true&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;retry(times, sleep) { ... }&lt;/code&gt; retries the given block up to the given number of times&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;uninterruptible { ... }&lt;/code&gt; evaluates the given code block making sure it can&#39;t be interrupted&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Syntax&lt;/h2&gt; &#xA;&lt;p&gt;Extension-method syntax can be imported using &lt;code&gt;import ox.syntax.*&lt;/code&gt;. This allows calling methods such as &lt;code&gt;.fork&lt;/code&gt;, &lt;code&gt;.raceSuccessWith&lt;/code&gt;, &lt;code&gt;.parWith&lt;/code&gt;, &lt;code&gt;.forever&lt;/code&gt;, &lt;code&gt;.useInScope&lt;/code&gt; directly on code blocks / values.&lt;/p&gt; &#xA;&lt;h2&gt;Channels basics&lt;/h2&gt; &#xA;&lt;p&gt;A channel is like a queue (data can be sent/received), but additionally channels support:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;completion (a source can be &lt;code&gt;done&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;error propagation downstream&lt;/li&gt; &#xA; &lt;li&gt;receiving exactly one value from a number of channels&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Creating a channel is a light-weight operation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channels.*&#xA;val c = Channel[String]()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, channels are unbuffered, that is a sender and receiver must &#34;meet&#34; to exchange a value. Hence, &lt;code&gt;.send&lt;/code&gt; always blocks, unless there&#39;s another thread waiting on a &lt;code&gt;.receive&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Buffered channels can be created by providing a non-zero capacity:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channels.*&#xA;val c = Channel[String](5)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unbounded channels can be created by providing a capacity of &lt;code&gt;Int.MaxValue&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Channels implement two traits: &lt;code&gt;Source&lt;/code&gt; and &lt;code&gt;Sink&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Sinks&lt;/h2&gt; &#xA;&lt;p&gt;Data can be sent to a channel using &lt;code&gt;.send&lt;/code&gt;. Once no more data items are available, completion can be signalled using &lt;code&gt;.done&lt;/code&gt;. If there&#39;s an error when producing data, this can be signalled using &lt;code&gt;.error&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox. {fork, supervised}&#xA;import ox.channels.*&#xA;&#xA;val c = Channel[String]()&#xA;supervised {&#xA;  fork {&#xA;    c.send(&#34;Hello&#34;)&#xA;    c.send(&#34;World&#34;)&#xA;    c.done()&#xA;  }&#xA;&#xA;  // TODO: receive&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;.send&lt;/code&gt; is blocking, hence usually channels are shared across forks to communicate data between them.&lt;/p&gt; &#xA;&lt;h2&gt;Sources&lt;/h2&gt; &#xA;&lt;p&gt;A source can be used to receive elements from a channel. The &lt;code&gt;.receive()&lt;/code&gt; method can block, and the result might be one of the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Source[+T]:&#xA;  def receive(): T | ChannelClosed&#xA;&#xA;sealed trait ChannelClosed&#xA;object ChannelClosed:&#xA;  case class Error(reason: Option[Exception]) extends ChannelClosed&#xA;  case object Done extends ChannelClosed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That is, the result might be a value, or information that the channel is closed. A channel can be done or an error might have occurred. Using an extension method provided by the &lt;code&gt;ox.channels.*&lt;/code&gt; import, closed information can be thrown as an exception using &lt;code&gt;receive().orThrow: T&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Creating sources&lt;/h2&gt; &#xA;&lt;p&gt;Sources can be created using one of the many factory methods on the &lt;code&gt;Source&lt;/code&gt; companion object, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channels.Source&#xA;import scala.concurrent.duration.FiniteDuration&#xA;&#xA;Source.fromValues(1, 2, 3)&#xA;Source.tick(1.second, &#34;x&#34;)&#xA;Source.iterate(0)(_ + 1) // natural numbers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each such source creates a daemon fork, which takes care of sending the elements to the channel, once capacity is available.&lt;/p&gt; &#xA;&lt;h2&gt;Transforming sources (eagerly)&lt;/h2&gt; &#xA;&lt;p&gt;Sources can be transformed by receiving values, manipulating them and sending to other channels - this provides the highest flexibility and allows creating arbitrary channel topologies.&lt;/p&gt; &#xA;&lt;p&gt;However, there&#39;s a number of common operations that are built-in as methods on &lt;code&gt;Source&lt;/code&gt;, which allow transforming the source. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.supervised&#xA;import ox.channels.{Channel, Source}&#xA;&#xA;supervised {&#xA;  val c = Channel[String]()&#xA;  val c2: Source[Int] = c.map(s =&amp;gt; s.length())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;.map&lt;/code&gt; needs to be run within a scope, as it starts a new virtual thread (using &lt;code&gt;forkDaemon&lt;/code&gt;), which:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;immediately starts receiving values from the given source&lt;/li&gt; &#xA; &lt;li&gt;applies the given function&lt;/li&gt; &#xA; &lt;li&gt;sends the result to the new channel&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The new channel is returned to the user as the return value of &lt;code&gt;.map&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Some other available combinators include &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.take&lt;/code&gt;, &lt;code&gt;.zip(otherSource)&lt;/code&gt;, &lt;code&gt;.merge(otherSource)&lt;/code&gt; etc.&lt;/p&gt; &#xA;&lt;p&gt;To run multiple transformations within one virtual thread / fork, the &lt;code&gt;.transform&lt;/code&gt; method is available:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.supervised&#xA;import ox.channels.{Channel, Source}&#xA;&#xA;supervised {&#xA;  val c = Channel[Int]()&#xA;  fork {&#xA;    Source.iterate(0)(_ + 1) // natural numbers&#xA;      .transform(_.filter(_ % 2 == 0).map(_ + 1).take(10)) // take the 10 first even numbers, incremented by 1&#xA;      .foreach(n =&amp;gt; println(n.toString))&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Capacity of transformation stages&lt;/h3&gt; &#xA;&lt;p&gt;Most source transformation methods create new channels, on which the transformed values are produced. The capacity of these channels by default is 0 (unbuffered). This can be overridden by providing &lt;code&gt;StageCapacity&lt;/code&gt; given, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(v: Source[Int]).map(_ + 1)(using StageCapacity(10))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Transforming sources (lazily)&lt;/h2&gt; &#xA;&lt;p&gt;A limited number of transformations can be applied to a source without creating a new channel and a new fork, which computes the transformation. These include: &lt;code&gt;.mapAsView&lt;/code&gt;, &lt;code&gt;.filterAsView&lt;/code&gt; and &lt;code&gt;.collectAsView&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channels.{Channel, Source}&#xA;&#xA;val c = Channel[String]()&#xA;val c2: Source[Int] = c.mapAsView(s =&amp;gt; s.length())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The mapping function (&lt;code&gt;s =&amp;gt; s.length()&lt;/code&gt;) will only be invoked when the source is consumed (using &lt;code&gt;.receive()&lt;/code&gt; or &lt;code&gt;select&lt;/code&gt;), on the calling thread. This is in contrast to &lt;code&gt;.map&lt;/code&gt;, where the mapping function is invoked on a separate fork.&lt;/p&gt; &#xA;&lt;p&gt;Hence, creating views doesn&#39;t need to be run within a scope, and creating the view itself doesn&#39;t consume any elements from the source on which it is run.&lt;/p&gt; &#xA;&lt;h2&gt;Discharging channels&lt;/h2&gt; &#xA;&lt;p&gt;Values of a source can be terminated using methods such as &lt;code&gt;.foreach&lt;/code&gt;, &lt;code&gt;.toList&lt;/code&gt;, &lt;code&gt;.pipeTo&lt;/code&gt; or &lt;code&gt;.drain&lt;/code&gt;. These methods are blocking, and hence don&#39;t need to be run within a scope:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channels.Source&#xA;&#xA;val s = Source.fromValues(1, 2, 3)&#xA;s.toList // List(1, 2, 3)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Selecting from channels&lt;/h2&gt; &#xA;&lt;p&gt;Channels are distinct from queues in that they support a &lt;code&gt;select&lt;/code&gt; method, which takes a number of channel clauses, and block until at least one clause is satisfied. The other channels are left intact (no values are sent or received).&lt;/p&gt; &#xA;&lt;p&gt;Channel clauses include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;channel.receiveClause&lt;/code&gt; - to receive a value from the channel&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;channel.sendClause(value)&lt;/code&gt; - to send a value to a channel&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Default(value)&lt;/code&gt; - to return the given value from the &lt;code&gt;select&lt;/code&gt;, if no other clause can be immediately satisfied&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Receiving from exactly one channel&lt;/h3&gt; &#xA;&lt;p&gt;The most common use-case for &lt;code&gt;select&lt;/code&gt; is to receive exactly one value from a number of channels. There&#39;s a dedicated &lt;code&gt;select&lt;/code&gt; variant for this use-case, which accepts a number of &lt;code&gt;Source&lt;/code&gt;s, for which receive clauses are created. The signature for the two-source variant of this method is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def select[T1, T2](source1: Source[T1], source2: Source[T2]): T1 | T2 | ChannelClosed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As an example, this can be used as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.{Source, supervised}&#xA;import ox.channels.*&#xA;import scala.concurrent.duration.FiniteDuration&#xA;&#xA;case object Tick&#xA;def consumer(strings: Source[String]): Nothing =&#xA;  supervised {&#xA;    val tick = Source.tick(1.second, Tick)&#xA;&#xA;    @tailrec&#xA;    def doConsume(acc: Int): Nothing =&#xA;      select(tick, strings).orThrow match&#xA;        case Tick =&amp;gt;&#xA;          log.info(s&#34;Characters received this second: $acc&#34;)&#xA;          doConsume(0)&#xA;        case s: String =&amp;gt; doConsume(acc + s.length)&#xA;&#xA;    doConsume(0)&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Selects are biased towards clauses/sources that appear first in the argument list. To achieve fairness, you might want to randomize the ordering of the clauses/sources.&lt;/p&gt; &#xA;&lt;h3&gt;Mixed receive and send clauses&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;select&lt;/code&gt; method can also be used to send a value to exactly one channel, or with mixed receive and send clauses. It is guaranteed that exactly one clause will be satisfied (either a value sent, or received from exactly one of the channels).&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channels.Channel&#xA;&#xA;val c = Channel[Int]()&#xA;val d = Channel[Int]()&#xA;&#xA;select(c.sendClause(10), d.receiveClause)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above will block until a value can be sent to &lt;code&gt;d&lt;/code&gt; (as this is an unbuffered channel, for this to happen there must be a concurrently running &lt;code&gt;receive&lt;/code&gt; call), or until a value can be received from &lt;code&gt;c&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The type returned by the above invocation is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;c.Sent | d.Received | ChannelClosed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the &lt;code&gt;Sent&lt;/code&gt; and &lt;code&gt;Received&lt;/code&gt; types are inner types of the &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; values. For different channels, the &lt;code&gt;Sent&lt;/code&gt; / &lt;code&gt;Received&lt;/code&gt; instances will have distinct classes, hence allowing distinguishing which clause has been satisfied.&lt;/p&gt; &#xA;&lt;p&gt;Channel closed values can be inspected, or converted to an exception using &lt;code&gt;.orThrow&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The results of a &lt;code&gt;select&lt;/code&gt; can be inspected using a pattern match:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channels.*&#xA;&#xA;val c = Channel[Int]()&#xA;val d = Channel[Int]()&#xA;&#xA;select(c.sendClause(10), d.receiveClause).orThrow match&#xA;  case c.Sent()      =&amp;gt; println(&#34;Sent to c&#34;)&#xA;  case d.Received(v) =&amp;gt; println(s&#34;Received from d: $v&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If there&#39;s a missing case, the compiler will warn you that the &lt;code&gt;match&lt;/code&gt; is not exhaustive, and give you a hint as to what is missing. Similarly, there will be a warning in case of an unneeded, extra match case.&lt;/p&gt; &#xA;&lt;h3&gt;Closed channels (done / error)&lt;/h3&gt; &#xA;&lt;p&gt;If any of the channels is (or becomes) in an error state, &lt;code&gt;select&lt;/code&gt; returns with that error. If all channels are done, by default &lt;code&gt;select&lt;/code&gt; returns with a &lt;code&gt;Done&lt;/code&gt; as well.&lt;/p&gt; &#xA;&lt;p&gt;However, a variant of the receive clause, namely &lt;code&gt;source.receiveOrDoneClause&lt;/code&gt;, will cause a &lt;code&gt;Done&lt;/code&gt; to be returned from the select, if that source is done (instead of waiting for another clause to become satisfied).&lt;/p&gt; &#xA;&lt;p&gt;It is possible to inspect which channel is in a closed state by using the &lt;code&gt;.isDone&lt;/code&gt;, &lt;code&gt;.isError&lt;/code&gt; and &lt;code&gt;.isClosed&lt;/code&gt; methods (plus detailed variants).&lt;/p&gt; &#xA;&lt;h3&gt;Default clauses&lt;/h3&gt; &#xA;&lt;p&gt;A default clause can be provided, which specifies the return value of the &lt;code&gt;select&lt;/code&gt;, in case no other clause can be immediately satisfied. The clause can be created with &lt;code&gt;Default&lt;/code&gt;, and in case the value is used, it is returned wrapped in &lt;code&gt;DefaultResult&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channels.*&#xA;&#xA;val c = Channel[Int]()&#xA;&#xA;select(c.receiveClause, Default(5)).orThrow match&#xA;  case c.Received(v)    =&amp;gt; println(s&#34;Received from d: $v&#34;)&#xA;  case DefaultResult(v) =&amp;gt; println(s&#34;No value available in c, using default: $v&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There can be at most one default clause in a &lt;code&gt;select&lt;/code&gt; invocation.&lt;/p&gt; &#xA;&lt;h2&gt;Error propagation&lt;/h2&gt; &#xA;&lt;p&gt;Errors are only propagated downstream, ultimately reaching the point where the source is discharged, leading to an exception being thrown there.&lt;/p&gt; &#xA;&lt;p&gt;Won&#39;t this design cause upstream channels / sources to operate despite the consumer being gone (because of the exception)?&lt;/p&gt; &#xA;&lt;p&gt;No: the exception should cause the containing scope to finish (or a supervised fork to fail), cancelling any forks that are operating in the background. Any unused channels can then be garbage-collected.&lt;/p&gt; &#xA;&lt;p&gt;The role of the exception handler is then to re-create the entire processing pipeline, or escalate the error further.&lt;/p&gt; &#xA;&lt;h2&gt;Backpressure&lt;/h2&gt; &#xA;&lt;p&gt;Channels are back-pressured, as the &lt;code&gt;.send&lt;/code&gt; operation is blocking until there&#39;s a receiver thread available, or if there&#39;s enough space in the buffer. The processing space is bound by the total size of channel buffers.&lt;/p&gt; &#xA;&lt;h2&gt;Kafka sources &amp;amp; drains&lt;/h2&gt; &#xA;&lt;p&gt;Dependency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&#34;com.softwaremill.ox&#34; %% &#34;kafka&#34; % &#34;0.0.14&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Source&lt;/code&gt;s which read from a Kafka topic, mapping stages and drains which publish to Kafka topics are available through the &lt;code&gt;KafkaSource&lt;/code&gt;, &lt;code&gt;KafkaStage&lt;/code&gt; and &lt;code&gt;KafkaDrain&lt;/code&gt; objects. In all cases either a manually constructed instance of a &lt;code&gt;KafkaProducer&lt;/code&gt; / &lt;code&gt;KafkaConsumer&lt;/code&gt; is needed, or &lt;code&gt;ProducerSettings&lt;/code&gt; / &lt;code&gt;ConsumerSetttings&lt;/code&gt; need to be provided with the bootstrap servers, consumer group id, key / value serializers, etc.&lt;/p&gt; &#xA;&lt;p&gt;To read from a Kafka topic, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channel.ChannelClosed&#xA;import ox.kafka.{ConsumerSettings, KafkaSource}&#xA;import ox.kafka.ConsumerSettings.AutoOffsetReset.Earliest&#xA;import ox.supervised&#xA;import org.apache.kafka.clients.consumer.ConsumerRecord&#xA;&#xA;supervised {&#xA;  val settings = ConsumerSettings.default(&#34;my_group&#34;).bootstrapServers(&#34;localhost:9092&#34;).autoOffsetReset(Earliest)&#xA;  val source = KafkaSource.subscribe(settings, topic)&#xA;&#xA;  source.receive(): ConsumerRecord[String, String] | ChannelClosed&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To publish data to a Kafka topic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channel.Source&#xA;import ox.kafka.{ProducerSettings, KafkaSink}&#xA;import ox.supervised&#xA;import org.apache.kafka.clients.producer.ProducerRecord&#xA;&#xA;supervised {&#xA;  val settings = ProducerSettings.default.bootstrapServers(&#34;localhost:9092&#34;)&#xA;  Source&#xA;    .fromIterable(List(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;))&#xA;    .mapAsView(msg =&amp;gt; ProducerRecord[String, String](&#34;my_topic&#34;, msg))&#xA;    .applied(KafkaDrain.publish(settings))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To publish data and commit offsets of messages, basing on which the published data is computed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.kafka.{KafkaSink, KafkaSource, ProducerSettings, SendPacket}&#xA;import ox.supervised&#xA;import org.apache.kafka.clients.producer.ProducerRecord&#xA;&#xA;supervised {&#xA;  val consumerSettings = ConsumerSettings.default(&#34;my_group&#34;).bootstrapServers(&#34;localhost:9092&#34;).autoOffsetReset(Earliest)&#xA;  val producerSettings = ProducerSettings.default.bootstrapServers(&#34;localhost:9092&#34;)&#xA;&#xA;  KafkaSource&#xA;    .subscribe(consumerSettings, sourceTopic)&#xA;    .map(in =&amp;gt; (in.value().toLong * 2, in))&#xA;    .map((value, original) =&amp;gt; SendPacket(ProducerRecord[String, String](destTopic, value.toString), original))&#xA;    .applied(KafkaDrain.publishAndCommit(consumerSettings, producerSettings))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The offsets are committed every second in a background process.&lt;/p&gt; &#xA;&lt;p&gt;To publish data as a mapping stage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import ox.channel.Source&#xA;import ox.kafka.{ProducerSettings, KafkaSink}&#xA;import ox.kafka.KafkaStage.*&#xA;import ox.supervised&#xA;import org.apache.kafka.clients.producer.{ProducerRecord, RecordMetadata}&#xA;&#xA;supervised {&#xA;  val settings = ProducerSettings.default.bootstrapServers(&#34;localhost:9092&#34;)&#xA;  val metadatas: Source[RecordMetadata] = Source&#xA;    .fromIterable(List(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;))&#xA;    .mapAsView(msg =&amp;gt; ProducerRecord[String, String](&#34;my_topic&#34;, msg))&#xA;    .mapPublish(settings)&#xA;  &#xA;  // process the metadatas source further&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Dictionary&lt;/h1&gt; &#xA;&lt;p&gt;How we use various terms throughout the codebase (or at least try to):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a scope &lt;strong&gt;ends&lt;/strong&gt;: when unsupervised, the main code block is entirely evaluated; when supervised, all non-daemon, supervised forks completed successfully, or at least one supervised fork failed. When the scope ends, all running forks are interrupted&lt;/li&gt; &#xA; &lt;li&gt;scope &lt;strong&gt;completes&lt;/strong&gt;, once all forks complete and finalizers are run. In other words, the &lt;code&gt;supervised&lt;/code&gt; or &lt;code&gt;scoped&lt;/code&gt; method returns.&lt;/li&gt; &#xA; &lt;li&gt;forks are &lt;strong&gt;started&lt;/strong&gt;, and then they are &lt;strong&gt;running&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;forks &lt;strong&gt;complete&lt;/strong&gt;: either a fork &lt;strong&gt;succeeds&lt;/strong&gt;, or a fork &lt;strong&gt;fails&lt;/strong&gt; with an exception&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;cancellation&lt;/strong&gt; (&lt;code&gt;Fork.cancel()&lt;/code&gt;) interrupts the fork and waits until it completes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Performance&lt;/h1&gt; &#xA;&lt;p&gt;Performance is unknown, hasn&#39;t been measured and the code hasn&#39;t been optimized. We&#39;d welcome contributions in this area!&lt;/p&gt; &#xA;&lt;h1&gt;Development&lt;/h1&gt; &#xA;&lt;p&gt;To compile and test, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sbt compile&#xA;sbt test&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>