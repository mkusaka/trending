<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-19T02:05:16Z</updated>
  <subtitle>Weekly Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ucb-bar/berkeley-hardfloat</title>
    <updated>2023-03-19T02:05:16Z</updated>
    <id>tag:github.com,2023-03-19:/ucb-bar/berkeley-hardfloat</id>
    <link href="https://github.com/ucb-bar/berkeley-hardfloat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Berkeley Hardware Floating-Point Units&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains hardware floating-point units written in Chisel. This library contains parameterized floating-point units for fused multiply-add operations, conversions between integer and floating-point numbers, and conversions between floating-point conversions with different precision.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: These units are works in progress. They may not be yet completely free of bugs, nor are they fully optimized.&lt;/p&gt; &#xA;&lt;h2&gt;Recoded Format&lt;/h2&gt; &#xA;&lt;p&gt;The floating-point units in this repository work on an internal recoded format (exponent has an additional bit) to handle subnormal numbers more efficiently in a microprocessor. A more detailed explanation will come soon, but in the mean time here are some example mappings for single-precision numbers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;IEEE format                           Recoded format&#xA;----------------------------------    -----------------------------------&#xA;s 00000000 00000000000000000000000    s 000------ 00000000000000000000000&#xA;s 00000000 00000000000000000000001    s 001101011 00000000000000000000000&#xA;s 00000000 0000000000000000000001f    s 001101100 f0000000000000000000000&#xA;s 00000000 000000000000000000001ff    s 001101101 ff000000000000000000000&#xA;    ...              ...                   ...              ... &#xA;s 00000000 001ffffffffffffffffffff    s 001111111 ffffffffffffffffffff000&#xA;s 00000000 01fffffffffffffffffffff    s 010000000 fffffffffffffffffffff00&#xA;s 00000000 1ffffffffffffffffffffff    s 010000001 ffffffffffffffffffffff0&#xA;s 00000001 fffffffffffffffffffffff    s 010000010 fffffffffffffffffffffff&#xA;s 00000010 fffffffffffffffffffffff    s 010000011 fffffffffffffffffffffff&#xA;    ...              ...                   ...              ... &#xA;s 11111101 fffffffffffffffffffffff    s 101111110 fffffffffffffffffffffff&#xA;s 11111110 fffffffffffffffffffffff    s 101111111 fffffffffffffffffffffff&#xA;s 11111111 00000000000000000000000    s 110------ -----------------------&#xA;s 11111111 fffffffffffffffffffffff    s 111------ fffffffffffffffffffffff&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Unit-Testing&lt;/h2&gt; &#xA;&lt;p&gt;To unit-test these floating-point units, you need the berkeley-testfloat-3 package.&lt;/p&gt; &#xA;&lt;p&gt;To test floating-point units with the C simulator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>ShiftForward/icfpc2012</title>
    <updated>2023-03-19T02:05:16Z</updated>
    <id>tag:github.com,2023-03-19:/ShiftForward/icfpc2012</id>
    <link href="https://github.com/ShiftForward/icfpc2012" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ICFP Contest 2012&lt;/p&gt;&lt;hr&gt;&lt;pre&gt;&lt;code&gt;// ****************************************************************&#xA;// *   Software Failure.  Press left mouse button to continue.    *&#xA;// *             Guru Meditation #00000000.00000000               *&#xA;// ****************************************************************&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;What is this?&lt;/h2&gt; &#xA;&lt;p&gt;This is Guru Meditation&#39;s entry to the &lt;a href=&#34;http://icfpcontest2012.wordpress.com/&#34;&gt;ICFP 2012 Contest&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Who are you?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;André Silva (ShiftForward)&lt;/li&gt; &#xA; &lt;li&gt;Hugo Sereno Ferreira (ShiftForward, FEUP)&lt;/li&gt; &#xA; &lt;li&gt;Joao Azevedo (ShiftForward)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How did you do this?&lt;/h2&gt; &#xA;&lt;p&gt;We are big fans of the object-functional language Scala, and that&#39;s what we used for coding. We also used SBT, Emacs, Ensime and IntelliJ.&lt;/p&gt; &#xA;&lt;h2&gt;What was your score?&lt;/h2&gt; &#xA;&lt;p&gt;We actually never submitted :-) We deemed our scores not good-enough™ for a modest classification. However, judging from IRC and Twitter reactions, we might have been wrong. At aproximately 12h before the end of the contest, our scores were (ignoring maps with trampolines, which our solver wasn&#39;t properly processing):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;contest1.map: 210&#xA;contest2.map: 278&#xA;contest3.map: 275&#xA;contest4.map: 575&#xA;contest5.map: 1291&#xA;contest6.map: 677&#xA;contest7.map: 867&#xA;contest8.map: 1269&#xA;contest9.map: 1917&#xA;contest10.map: 1931&#xA;flood1.map: 355&#xA;flood2.map: 278&#xA;flood3.map: 747&#xA;flood4.map: 957&#xA;flood5.map: 571&#xA;beard1.map: 437&#xA;beard2.map: 4507&#xA;beard4.map: 1460&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Ok... so... why did you release the code?&lt;/h2&gt; &#xA;&lt;p&gt;Two reasons. First, the number of Scala entries are very low. Opening the code &lt;em&gt;might&lt;/em&gt; attract more people to use the language.&lt;/p&gt; &#xA;&lt;p&gt;The second reason is because we think the Pattern Matching algorithm we used in the simulator is cool. We know there are lots of ways to enhance it, including the design of an external DSL to capture the patterns more &#34;graphically&#34;, and it&#39;s probably slower when compared to an in-place, mutable, switch-case based C implementation... but it&#39;s still cool :-)&lt;/p&gt; &#xA;&lt;h2&gt;Could you talk a little on your solving strategy?&lt;/h2&gt; &#xA;&lt;h3&gt;Patterns&lt;/h3&gt; &#xA;&lt;p&gt;A pattern looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val MvUpRazor = Pattern(OpcodePred(&#39;MoveUp),&#xA;                  Seq((0, -1) -&amp;gt; &#39;Razor, (0, 0) -&amp;gt; &#39;Robot),&#xA;                  Seq((0, -1) -&amp;gt; &#39;Robot, (0, 0) -&amp;gt; &#39;Empty),&#xA;                  { s =&amp;gt; s.copy(nRazors = s.nRazors + 1, robotPos = s.robotPos + Coordinate(0, -1)) } )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s a predicate to test if the pattern is applicable (based on the opcode and board), in this case this pattern is only applicable when the &#39;MoveUp opcode is triggered. The pattern is composed of two matrices which are centered on the target Tile. The source matrix is used to match a pattern scenario on the board, and if it passes, the board is updated according to the transformation matrix. Additionally we can pass a function to capture additional side-effects on the Board (e.g. like changing the number of razors).&lt;/p&gt; &#xA;&lt;p&gt;This allowed us to quickly implement all the game rules as they were announced. It also allowed the solver to independently test all of the possible move patterns &#34;blindly&#34;, which allowed the bot to automatically adapt to new movements as they were implemented on the simulator (of course the heuristic still had to be changed to take into account new rules).&lt;/p&gt; &#xA;&lt;h3&gt;Solver&lt;/h3&gt; &#xA;&lt;p&gt;We started by a greedy best-first approach, just trying to fetch the lambdas that were closer to the bot. This quickly revealed itself as a bad strategy, specially in tricky maps where either the lambdas or the lift would become unreachable (such as contest8.map). We then evolved into a generic A* that would try the available opcodes in each state. The state was identified by the hash code of the map tiles, in order to reduce space. Our heuristic was based on the map score, penalizing the number of moves and prioritizing the number of lambdas gathered. We would also benefit states where we were closer to a lambda or to the lift (in case all lambdas were gathered) and penalize states where either a lambda or the lift was unreachable. In order to check for reachability, we would perform a flood fill starting on the bot position. For every interesting element (lambda or lift) outside the fill area, we would attempt to compute a path from the bot&#39;s current position to the element. We would also keep a cache of paths (which, in the end, I didn&#39;t think it was correctly implemented). We spent a generous amount of time tweaking the heuristic, and didn&#39;t consider flooding, beards, trampolines or higher order rocks in it.&lt;/p&gt; &#xA;&lt;h3&gt;WTF is it with Tile and Opcode?!&lt;/h3&gt; &#xA;&lt;p&gt;We started by representing tiles and opcodes as case classes which allowed for all the pattern matching goodness. Unfortunately it was slow(ish) and had an higher memory consumption, so the move to Symbol was a cheap performance optimization. Looking back on it, I forgot to try case objects instead...&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dulichan/AwesomeApp</title>
    <updated>2023-03-19T02:05:16Z</updated>
    <id>tag:github.com,2023-03-19:/dulichan/AwesomeApp</id>
    <link href="https://github.com/dulichan/AwesomeApp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Saving Awesome ideas for yearly review&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This project will be used to learn more about Scala and MongoDB. Now I have included MongoDB and I have to write the code to interact MongoDB to accompany the awesome ideas.&lt;/p&gt;</summary>
  </entry>
</feed>