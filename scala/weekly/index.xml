<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-11T01:46:32Z</updated>
  <subtitle>Weekly Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hashicorp/nomad-scala-sdk</title>
    <updated>2022-12-11T01:46:32Z</updated>
    <id>tag:github.com,2022-12-11:/hashicorp/nomad-scala-sdk</id>
    <link href="https://github.com/hashicorp/nomad-scala-sdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Scala SDK for interfacing with HashiCorp&#39;s Nomad&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Nomad Scala SDK &lt;a href=&#34;https://travis-ci.org/hashicorp/nomad-scala-sdk&#34;&gt;&lt;img src=&#34;https://travis-ci.org/hashicorp/nomad-scala-sdk.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mvnrepository.com/artifact/com.hashicorp.nomad/nomad-scala-sdk_2.11&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.hashicorp.nomad/nomad-scala-sdk_2.11.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;A Scala SDK for interacting with &lt;a href=&#34;https://www.nomadproject.io/&#34;&gt;HashiCorp&#39;s Nomad&lt;/a&gt; through its &lt;a href=&#34;https://www.nomadproject.io/docs/http/&#34;&gt;HTTP API&lt;/a&gt;. This is a wrapper around the &lt;a href=&#34;https://github.com/hashicorp/nomad-java-sdk&#34;&gt;Java SDK&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This SDK requires at least a Java 8 runtime.&lt;/p&gt; &#xA;&lt;h2&gt;Using&lt;/h2&gt; &#xA;&lt;p&gt;Create a &lt;code&gt;NomadScalaApi&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-.scala&#34;&gt;val api = NomadScalaApi(&#34;http://my.nomad.server:4646&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Methods are grouped into into API groupings according to their function, and these groupings can be accessed from the client. For example, to list the jobs running on the cluster, use the &lt;code&gt;list&lt;/code&gt; method on the jobs API grouping:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-.scala&#34;&gt;val responseFuture: ServerQueryResponse[Seq[JobListStub]] =&#xA;  api.jobs.list()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result is a &lt;code&gt;ServerQueryResponse&lt;/code&gt;. The API has a few different response types, depending on the type of query. The response classes have some methods for getting metadata about the response, and a &lt;code&gt;getValue&lt;/code&gt; method that returns the response value. The generic type parameter in the response class indicates the response value type, so in this case, &lt;code&gt;getValue&lt;/code&gt; will return a sequence of &lt;code&gt;JobListStub&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;h3&gt;Request Options&lt;/h3&gt; &#xA;&lt;p&gt;Endpoints that interact with server APIs accept &lt;code&gt;ScalaQueryOptions&lt;/code&gt; or &lt;code&gt;WriteOptions&lt;/code&gt;, which let you specify additional options when making a request.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ScalaQueryOptions&lt;/code&gt; supports &lt;a href=&#34;https://www.nomadproject.io/docs/http/index.html#consistency-modes&#34;&gt;stale queries&lt;/a&gt;, and &lt;a href=&#34;https://www.nomadproject.io/docs/http/index.html#blocking-queries&#34;&gt;blocking queries&lt;/a&gt;. It also supports repeated performing blocking queries until a condition is met.&lt;/p&gt; &#xA;&lt;h4&gt;Regions&lt;/h4&gt; &#xA;&lt;p&gt;Both &lt;code&gt;ScalaQueryOptions&lt;/code&gt; or &lt;code&gt;WriteOptions&lt;/code&gt; allow you to specify a region to support &lt;a href=&#34;https://www.nomadproject.io/docs/http/index.html#cross-region-requests&#34;&gt;cross-region requests&lt;/a&gt;. Requests sent to a Nomad server are bound to a particular region; if no region is specified, the server assumes the request is bound for its own region. You can specify an explicit region per-request using the options, and you can specify a client-wide default in the client configuration. You can also rely on the default behaviour.&lt;/p&gt; &#xA;&lt;h3&gt;Note on Terminology&lt;/h3&gt; &#xA;&lt;p&gt;Nomad &lt;em&gt;agents&lt;/em&gt; can operate as &lt;em&gt;Nomad servers&lt;/em&gt; which perform scheduling, or &lt;em&gt;Nomad clients&lt;/em&gt; which connect to servers and run the task groups they are assigned, or both (see the &lt;a href=&#34;https://www.nomadproject.io/docs/internals/architecture.html#glossary&#34;&gt;Nomad glossary&lt;/a&gt;). Regardless of their client and/or server roles in the Nomad cluster, all agents have an embedded HTTP server that serves the Nomad &lt;a href=&#34;https://www.nomadproject.io/docs/http/&#34;&gt;HTTP API&lt;/a&gt;. This Java API makes use of an &lt;em&gt;HTTP client&lt;/em&gt; to connect to that API, and is thus a Nomad HTTP &lt;em&gt;API client&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;So be aware that there are two conflicting meanings of &#34;client&#34; in scope. &lt;code&gt;NomadApiClient&lt;/code&gt; is the main API client class, and has nothing to do with the &lt;em&gt;Nomad client&lt;/em&gt; concept. The &lt;code&gt;ClientApi&lt;/code&gt; class, on the other hand, is the API for interacting with Nomad client agents.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;The SDK is built with sbt. You can use &lt;code&gt;scripts/build.sh&lt;/code&gt; to run a build, provided an appropriate Nomad executable is available for tests as described below.&lt;/p&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;p&gt;The tests make use of Nomad&#39;s &lt;a href=&#34;https://github.com/hashicorp/nomad/raw/master/client/driver/mock_driver.go&#34;&gt;&lt;code&gt;mock_driver&lt;/code&gt;&lt;/a&gt;, a driver for test purposes that isn&#39;t built into Nomad by default. To build Nomad with &lt;code&gt;mock_driver&lt;/code&gt; support, you will need Go, a properly configured &lt;code&gt;GOPATH&lt;/code&gt;, and the &lt;a href=&#34;https://github.com/hashicorp/nomad&#34;&gt;Nomad source&lt;/a&gt;, which you can clone with git or with &lt;code&gt;go get&lt;/code&gt;, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-.sh&#34;&gt;go get github.com/hashicorp/nomad&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will then need to pass the &lt;code&gt;nomad_test&lt;/code&gt; flag passed to the Go compiler when building Nomad, e.g. the follow will put a Nomad executable in &lt;code&gt;$GOPATH/bin/&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-.sh&#34;&gt;go install -tags nomad_test github.com/hashicorp/nomad&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can then run the tests with this executable on the &lt;code&gt;PATH&lt;/code&gt;, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-.sh&#34;&gt;PATH=&#34;$GOPATH/bin:$PATH&#34; sbt test&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>zio/zio-direct</title>
    <updated>2022-12-11T01:46:32Z</updated>
    <id>tag:github.com,2022-12-11:/zio/zio-direct</id>
    <link href="https://github.com/zio/zio-direct" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Direct-Style Programming for ZIO&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ZIO direct&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Project Stage&lt;/th&gt; &#xA;   &lt;th&gt;CI&lt;/th&gt; &#xA;   &lt;th&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Snapshot&lt;/th&gt; &#xA;   &lt;th&gt;Discord&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/zio/zio/wiki/Project-Stages&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Project%20Stage-Development-yellowgreen.svg?sanitize=true&#34; alt=&#34;Project stage&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://github.com/zio/zio-direct/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://oss.sonatype.org/content/repositories/releases/dev/zio/zio-direct_2.12/&#34; title=&#34;Sonatype Releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio-direct_2.12.svg?sanitize=true&#34; alt=&#34;Release Artifacts&#34; title=&#34;Sonatype Releases&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio-direct_2.12/&#34; title=&#34;Sonatype Snapshots&#34;&gt;&lt;img src=&#34;https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio-direct_2.12.svg?sanitize=true&#34; alt=&#34;Snapshot Artifacts&#34; title=&#34;Sonatype Snapshots&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://discord.gg/2ccFBr4&#34; title=&#34;Discord&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/629491597070827530?logo=discord&#34; alt=&#34;Badge-Discord&#34; title=&#34;chat on discord&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Summary&lt;/h1&gt; &#xA;&lt;p&gt;Direct-Style programming in ZIO based on the Monadless paradigm.&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;Talk at Functional Scala 2022 &lt;a href=&#34;https://www.slideshare.net/deusaquilus/ziodirect-functional-scala-2022&#34;&gt;https://www.slideshare.net/deusaquilus/ziodirect-functional-scala-2022&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To use zio-direct, add the following to your &lt;code&gt;build.sbt&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;dev.zio&#34; % &#34;zio-direct_3&#34; % &#34;1.0.0-RC1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ZIO-Direct allows direct style programming with ZIO. This library provides a &lt;em&gt;syntactic sugar&lt;/em&gt; that is more powerful than for-comprehensions as well as more natural to use. Simply add the &lt;code&gt;.run&lt;/code&gt; suffix to any ZIO effect in order to retrieve it&#39;s value.&lt;/p&gt; &#xA;&lt;p&gt;ZIO-Direct works by using macros to rewrite sequential code into flatMap-chains based on the &lt;a href=&#34;https://github.com/monadless/monadless&#34;&gt;Monadless&lt;/a&gt; paradigm. The values resulting in &lt;code&gt;.run&lt;/code&gt; calls from the ZIO effects are not actually awaited. Instead, they are rolled-up into a chain of flatMaps.&lt;/p&gt; &#xA;&lt;p&gt;For example, in imperative programming operations typically are done in a simple set of steps.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object FileOps:&#xA;  def read(file: File): String&#xA;  def write(file: File, content: String): Unit&#xA;&#xA;val textA = read(fileA)&#xA;val textB = read(fileB)&#xA;write(fileC, textA + textB)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using functional programming, the equivalent of this functionality is a set of nested flatMap-chains.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object FileOps&#xA;  def read(file: File): ZIO[Any, Throwable, String]&#xA;  def write(file: File, content: String): ZIO[Any, Throwable, Unit]&#xA;&#xA;read(fileA).flatMap { textA =&amp;gt;&#xA;  read(fileB).flatMap { textB =&amp;gt;&#xA;    write(fileC, textA + textB)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to avoid this complexity scala provides a for-comprehension syntactic sugar.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for {&#xA;  textA &amp;lt;- read(fileA)&#xA;  textB &amp;lt;- read(fileB)&#xA;  _ &amp;lt;- write(fileC, textA + textB)&#xA;} yield ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unfortunately this syntactic sugar is limited in many cases, for example, inserting a conditional value inside is impossible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for {&#xA;  textA &amp;lt;- read(fileA)&#xA;  // Not a possible syntax&#xA;  if (fileA.contains(&#34;some string&#34;)) {&#xA;    textB &amp;lt;- read(fileB)&#xA;    _ &amp;lt;- write(fileC, textA + textB)&#xA;  }&#xA;} yield ()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ZIO-Direct offers an equivalent syntactic sugar that is more ergonomic and allows many constructs that for-comprehensions do not.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;defer {&#xA;  val textA = read(fileA).run&#xA;  if (fileA.contains(&#34;some string&#34;)) {&#xA;    val textB = read(fileB).run&#xA;    write(fileC, textA + textB).run&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;ZIO-Tailored&lt;/h1&gt; &#xA;&lt;p&gt;ZIO-Direct is specifically tailored to ZIO capabilities as it supports Environment and Error composition in ZIO effects similar to the for-comprehension.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val out: ZIO[CustomerConfig &amp;amp; DistributorConfig, CustomerGetException | DistrubutorGetException, (Customer, Distributor)] =&#xA;  defer {&#xA;    // Get a customer-configuration object from the environment and extract its .url field&#xA;    val custUrl: String = ZIO.service[CustomerConfig].run.url&#xA;    // Get a distributor-configuration from the environment and extract its .url field&#xA;    val distUrl: String = ZIO.service[DistributorConfig].run.url&#xA;    (&#xA;      // Use the two configurations to make an HTTP-call&#xA;      parseCustomer(httpGetCustomer(custUrl).run),&#xA;      parseDistrubutor(httpGetDistributor(distUrl).run)&#xA;    )&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Branching and Looping Support&lt;/h1&gt; &#xA;&lt;p&gt;Unlike the for-comprehension, ZIO-Direct supports branching and looping in the use of flatMaps composition. Let&#39;s have a look at a another non-trivial example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Database:&#xA;  def nextRow(): ZIO[Any, Throwable, Row]&#xA;  def hasNextRow(): ZIO[Any, Throwable, Boolean]&#xA;  def lockNextRow(): ZIO[Any, Throwable, Boolean]&#xA;object Database:&#xA;  def open: ZIO[Any, Throwable, Database]&#xA;&#xA;defer {&#xA;  // Open a database connection&#xA;  val db = Database.open().run&#xA;  // See if there is is a next-row&#xA;  while (db.hasNextRow().run) {&#xA;    // try to lock, if aquired continue&#xA;    if (db.lockNextRow().run)&#xA;      val nextRow = db.nextRow().run&#xA;      doSomethingWith(nextRow)&#xA;    else&#xA;      waitT()&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;NOTE: The above database-api is imaginary.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The above code needs to be translated into something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Database.open.flatMap { db =&amp;gt;&#xA;  def whileFun(): ZIO[Any, Throwable, Unit] =&#xA;    db.hasNextRow().flatMap { hasNextRow =&amp;gt;&#xA;      if (hasNextRow)(&#xA;        db.lockNextRow().flatMap { lockNextRow =&amp;gt;&#xA;          if (!lockNextRow)&#xA;            db.nextRow().map(nextRow =&amp;gt; doSomethingWith(nextRow))&#xA;          else&#xA;            ZIO.succeed(waitT())&#xA;        }&#xA;      ).flatMap(_ =&amp;gt; whileFun())&#xA;      else&#xA;        ZIO.unit&#xA;    }&#xA;  whileFun()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that normally this is the exact code that would have to be written to capture such functionality For-comprehensions do not provide a way to do looping and branching so in such cases a combination of flatMaps and recursion is necessary to avoid calling effects unnecessarily.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://zio.github.io/zio-direct/docs/about/about_coc&#34;&gt;Code of Conduct&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;Come chat with us on &lt;a href=&#34;https://discord.gg/2ccFBr4&#34; title=&#34;Discord&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/629491597070827530?logo=discord&#34; alt=&#34;Badge-Discord&#34; title=&#34;chat on discord&#34;&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zio/zio-direct/main/LICENSE&#34;&gt;License&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>chipsalliance/rocket-chip-inclusive-cache</title>
    <updated>2022-12-11T01:46:32Z</updated>
    <id>tag:github.com,2022-12-11:/chipsalliance/rocket-chip-inclusive-cache</id>
    <link href="https://github.com/chipsalliance/rocket-chip-inclusive-cache" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An RTL generator for a last-level shared inclusive TileLink cache controller&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rocket Chip SoC Inclusive Cache Generator&lt;/h1&gt; &#xA;&lt;p&gt;This &lt;code&gt;block&lt;/code&gt; package contains an RTL generator for creating instances of a coherent, last-level, inclusive cache. The &lt;code&gt;InclusiveCache&lt;/code&gt; controller enforces coherence among a set of caching clients using an invalidation-based coherence policy implemetated on top of the the TileLink 1.8.1 coherence messaging protocol. This policy is implemented using a full-map of directory bits stored with each cache block&#39;s metadata tag.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;InclusiveCache&lt;/code&gt; is a TileLink adapter; it can be used as a drop-in replacement for Rocket-Chip&#39;s &lt;code&gt;tilelink.BroadcastHub&lt;/code&gt; coherence manager. It additionally supplies a SW-controlled interface for flusing cache blocks based on physical addresses.&lt;/p&gt; &#xA;&lt;p&gt;The following parameters of the cache are easily &lt;code&gt;Config&lt;/code&gt;-urable: size, ways, banking and sub-banking factors, external bandwidth, network interface buffering.&lt;/p&gt; &#xA;&lt;p&gt;Stand-alone unit tests coming soon.&lt;/p&gt; &#xA;&lt;p&gt;This repository is a replacement for &lt;a href=&#34;https://github.com/sifive/block-inclusivecache-sifive&#34;&gt;https://github.com/sifive/block-inclusivecache-sifive&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>