<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Scala Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-17T02:02:27Z</updated>
  <subtitle>Weekly Trending of Scala in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>getkyo/kyo</title>
    <updated>2023-12-17T02:02:27Z</updated>
    <id>tag:github.com,2023-12-17:/getkyo/kyo</id>
    <link href="https://github.com/getkyo/kyo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Toolkit for Scala Development&lt;/p&gt;&lt;hr&gt;&lt;h3&gt;Please visit &lt;a href=&#34;https://getkyo.io&#34;&gt;https://getkyo.io&lt;/a&gt; for an indexed version of this documentation.&lt;/h3&gt; &#xA;&lt;h2&gt;&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/getkyo/kyo/master/kyo.png&#34; width=&#34;200&#34; alt=&#34;Kyo&#34;&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/getkyo/kyo/workflows/build/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt; &lt;img src=&#34;https://img.shields.io/discord/1087005439859904574&#34; alt=&#34;Chat&#34;&gt; &lt;img src=&#34;https://img.shields.io/maven-central/v/io.getkyo/kyo-core_3&#34; alt=&#34;Version&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kyo is a toolkit for Scala development, spanning from browser-based apps in ScalaJS to high-performance backends on the JVM. It introduces a novel approach based on algebraic effects to deliver straightforward APIs in the pure Functional Programming paradigm. Unlike similar solutions, Kyo achieves this without inundating developers with esoteric concepts from Category Theory or using cryptic symbolic operators, resulting in a development experience that is both intuitive and robust.&lt;/p&gt; &#xA;&lt;p&gt;Drawing inspiration from &lt;a href=&#34;https://zio.dev/&#34;&gt;ZIO&lt;/a&gt;&#39;s &lt;a href=&#34;https://degoes.net/articles/rotating-effects&#34;&gt;effect rotation&lt;/a&gt;, Kyo takes a more generalized approach. While ZIO restricts effects to two channels, dependency injection and short-circuiting, Kyo allows for an arbitrary number of effectful channels. This enhancement gives developers greater flexibility in effect management, while also simplifying Kyo&#39;s internal codebase through more principled design patterns.&lt;/p&gt; &#xA;&lt;h3&gt;Getting Started&lt;/h3&gt; &#xA;&lt;p&gt;Kyo is available on Maven Central in multiple modules:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Module&lt;/th&gt; &#xA;   &lt;th&gt;Scala 2&lt;/th&gt; &#xA;   &lt;th&gt;Scala 3&lt;/th&gt; &#xA;   &lt;th&gt;Scala JS&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;kyo-core&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;Core and concurrent effects&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;kyo-direct&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;Direct syntax support&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;kyo-cache&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Caffeine caching&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;kyo-stats-otel&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Stats exporter for OpenTelemetry&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;kyo-sttp&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;X&lt;/td&gt; &#xA;   &lt;td&gt;Sttp HTTP Client&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For Scala 2 and 3:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;io.getkyo&#34; %% &#34;kyo-core&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;libraryDependencies += &#34;io.getkyo&#34; %% &#34;kyo-direct&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;libraryDependencies += &#34;io.getkyo&#34; %% &#34;kyo-cache&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;libraryDependencies += &#34;io.getkyo&#34; %% &#34;kyo-stats-otel&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;libraryDependencies += &#34;io.getkyo&#34; %% &#34;kyo-sttp&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For Scala.js (applicable only to &lt;code&gt;kyo-core&lt;/code&gt;, &lt;code&gt;kyo-direct&lt;/code&gt;, and &lt;code&gt;kyo-sttp&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;libraryDependencies += &#34;io.getkyo&#34; %%% &#34;kyo-core&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;libraryDependencies += &#34;io.getkyo&#34; %%% &#34;kyo-direct&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;libraryDependencies += &#34;io.getkyo&#34; %%% &#34;kyo-sttp&#34; % &#34;&amp;lt;version&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replace &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; with the latest version: &lt;img src=&#34;https://img.shields.io/maven-central/v/io.getkyo/kyo-core_3&#34; alt=&#34;Version&#34;&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;The &#34;Pending&#34; type: &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;In Kyo, computations are expressed via the infix type &lt;code&gt;&amp;gt;&lt;/code&gt;, known as &#34;Pending&#34;. It takes two type parameters:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The type of the expected output.&lt;/li&gt; &#xA; &lt;li&gt;The pending effects that need to be handled, represented as an unordered type-level set via a type intersection.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo._&#xA;&#xA;// &#39;Int&#39; pending &#39;Options&#39;&#xA;Int &amp;gt; Options&#xA;&#xA;// &#39;String&#39; pending &#39;Options&#39; and &#39;IOs&#39;&#xA;String &amp;gt; (Options with IOs)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: The naming convention for effect types is the plural form of the functionalities they manage.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;When expressing the set of pending effects, this documentation uses &lt;code&gt;with&lt;/code&gt; for compatibility with both Scala 2 and 3. If you&#39;re using Scala 3, the type intersection can also be expressed via &lt;code&gt;&amp;amp;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Scala 2 only supports `with`&#xA;// for the pending effects&#xA;String &amp;gt; (Options with IOs)&#xA;&#xA;// Scala 3 also supports `&amp;amp;`&#xA;String &amp;gt; (Options &amp;amp; IOs)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any type &lt;code&gt;T&lt;/code&gt; is automatically considered to be of type &lt;code&gt;T &amp;gt; Any&lt;/code&gt;, where &lt;code&gt;Any&lt;/code&gt; denotes an absence of pending effects. In simpler terms, this means that every value in Kyo is automatically a computation, but one without any effects that you need to handle.&lt;/p&gt; &#xA;&lt;p&gt;This design choice streamlines your code by removing the necessity to differentiate between pure values and computations that may have effects. So, when you&#39;re dealing with a value of type &lt;code&gt;T &amp;gt; Any&lt;/code&gt;, you can safely extract the &lt;code&gt;pure&lt;/code&gt; value directly, without worrying about handling any effects.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo._&#xA;&#xA;// An &#39;Int&#39; is also an &#39;Int &amp;gt; Any&#39;&#xA;val a: Int &amp;gt; Any = 1&#xA;&#xA;// Since there are no pending effects, &#xA;// the computation can produce a pure value&#xA;val b: Int = a.pure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: This README provides explicit type declarations for clarity. However, Scala&#39;s type inference is generally able to infer Kyo types properly.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This unique property removes the need to juggle between &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt;. All values are automatically promoted to a Kyo computation with zero pending effects, enabling you to focus on your application logic rather than the intricacies of effect handling.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.options._&#xA;import kyo.tries._&#xA;&#xA;// Kyo still supports both `map` &#xA;// and `flatMap`.&#xA;def example1(&#xA;    a: Int &amp;gt; Options, &#xA;    b: Int &amp;gt; Tries&#xA;  ): Int &amp;gt; (Options with Tries) =&#xA;    a.flatMap(v =&amp;gt; b.map(_ + v))&#xA;&#xA;// But using only `map` is recommended &#xA;// since it funcions like `flatMap` due &#xA;// to effect widening.&#xA;def example2(&#xA;    a: Int &amp;gt; Options, &#xA;    b: Int &amp;gt; Tries&#xA;  ): Int &amp;gt; (Options with Tries) =&#xA;    a.map(v =&amp;gt; b.map(_ + v))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;map&lt;/code&gt; method automatically updates the set of pending effects. When you apply &lt;code&gt;map&lt;/code&gt; to computations that have different pending effects, Kyo reconciles these into a new computation type that combines all the unique pending effects from both operands.&lt;/p&gt; &#xA;&lt;p&gt;When a computation produces a &lt;code&gt;Unit&lt;/code&gt; value, Kyo also offers an &lt;code&gt;andThen&lt;/code&gt; method for more fluent code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.ios._&#xA;&#xA;// An example computation that &#xA;// produces &#39;Unit&#39;.&#xA;val a: Unit &amp;gt; IOs = &#xA;  IOs(println(&#34;hello&#34;))&#xA;&#xA;// Use &#39;andThen&#39;.&#xA;val b: String &amp;gt; IOs =&#xA;  a.andThen(&#34;test&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Effect widening&lt;/h3&gt; &#xA;&lt;p&gt;Kyo&#39;s set of pending effects is a contravariant type parameter. This encoding permits computations to be widened to encompass a larger set of effects.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An &#39;Int&#39; with an empty effect set (`Any`)&#xA;val a: Int &amp;gt; Any = &#xA;  1&#xA;&#xA;// Widening the effect set from empty (`Any`) &#xA;// to include `Options`&#xA;val b: Int &amp;gt; Options = &#xA;  a&#xA;&#xA;// Further widening the effect set to include &#xA;// both `Options` and `Tries`&#xA;val c: Int &amp;gt; (Options with Tries) = &#xA;  b&#xA;&#xA;// Directly widening a pure value to have &#xA;// `Options` and `Tries`&#xA;val d: Int &amp;gt; (Options with Tries) = &#xA;  42&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This characteristic enables a fluent API for effectful code. Methods can accept parameters with a specific set of pending effects while also permitting those with fewer or no effects.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// The function expects a parameter with both &#xA;// &#39;Options&#39; and &#39;Tries&#39; effects pending&#xA;def example1(v: Int &amp;gt; (Options with Tries)) = &#xA;  v.map(_ + 1)&#xA;&#xA;// A value with only the &#39;Tries&#39; effect can be &#xA;// automatically widened to include &#39;Options&#39;&#xA;def example2(v: Int &amp;gt; Tries) = &#xA;  example1(v)&#xA;&#xA;// A pure value can also be automatically widened&#xA;def example3 = example1(42)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, &lt;code&gt;example1&lt;/code&gt; is designed to accept an &lt;code&gt;Int &amp;gt; (Options with Tries)&lt;/code&gt;. However, thanks to the contravariant encoding of the type-level set of effects, &lt;code&gt;example2&lt;/code&gt; and &lt;code&gt;example3&lt;/code&gt; demonstrate that you can also pass in computations with a smaller set of effects—or even a pure value—and they will be automatically widened to fit the expected type.&lt;/p&gt; &#xA;&lt;h3&gt;Using effects&lt;/h3&gt; &#xA;&lt;p&gt;Kyo offers a modular approach to effect management, accommodating both built-in and user-defined effects organized in &lt;code&gt;object&lt;/code&gt; modules. Importing the corresponding module into scope brings in the effect and any additional types or implicits it may need. The naming convention uses lowercase module names for each effect type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// for &#39;Options&#39; effect&#xA;import kyo.options._&#xA;// for &#39;Tries&#39; effect&#xA;import kyo.tries._ &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Effects follow a naming convention for common operations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;init*&lt;/code&gt;: Initializes an instance of the container type handled by the effect. For instance, &lt;code&gt;Fibers.init&lt;/code&gt; returns a new &lt;code&gt;Fiber&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;get*&lt;/code&gt;: Allows the &#34;extraction&#34; of the value of the container type. &lt;code&gt;Fibers.get&lt;/code&gt; returns a &lt;code&gt;T &amp;gt; Fibers&lt;/code&gt; for a &lt;code&gt;Fiber[T]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;run*&lt;/code&gt;: Handles the effect.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Though named &lt;code&gt;run&lt;/code&gt;, effect handling doesn&#39;t necessarily execute the computation immediately, as the effect handling itself can also be suspended if another effect is pending.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val a: Int &amp;gt; Options = 42&#xA;&#xA;// Handle the &#39;Options&#39; effect&#xA;val b: Option[Int] &amp;gt; Any = &#xA;  Options.run(a)&#xA;&#xA;// Retrieve pure value as there are no more pending effects&#xA;val c: Option[Int] = &#xA;  b.pure&#xA;&#xA;// Computations with no pending effects &#xA;// (`Any`) provide only the `pure` method. &#xA;// For example, this code fails to compile:&#xA;// val c: String &amp;gt; Any = a.map(_.toString)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The order in which you handle effects in Kyo can significantly influence both the type and value of the result. Since effects are unordered at the type level, the runtime behavior depends on the sequence in which effects are processed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scala.util._&#xA;&#xA;def optionsFirst(a: Int &amp;gt; (Options with Tries)): Try[Option[Int]] = {&#xA;  val b: Option[Int] &amp;gt; Tries = &#xA;    Options.run(a)&#xA;  val c: Try[Option[Int]] &amp;gt; Any = &#xA;    Tries.run(b)&#xA;  c.pure&#xA;}&#xA;def triesFirst(a: Int &amp;gt; (Options with Tries)): Option[Try[Int]] = {&#xA;  val b: Try[Int] &amp;gt; Options =&#xA;    Tries.run(a)&#xA;  val c: Option[Try[Int]] &amp;gt; Any = &#xA;    Options.run(b)&#xA;  c.pure&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, the sequence in which effects are handled has a significant impact on the outcome. This is especially true for effects that can short-circuit the computation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val ex = new Exception&#xA;&#xA;// If the effects don&#39;t short-circuit, only the &#xA;// order of nested types in the result changes&#xA;assert(optionsFirst(Options.get(Some(1))) == Success(Some(1)))&#xA;assert(optionsFirst(Tries.get(Success(1))) == Success(Some(1)))&#xA;&#xA;// Note how the result type changes from &#xA;// &#39;Try[Option[T]]&#39; to &#39;Option[Try[T]]&#39;&#xA;assert(triesFirst(Options.get(Some(1))) == Some(Success(1)))&#xA;assert(triesFirst(Tries.get(Success(1))) == Some(Success(1)))&#xA;&#xA;// If there&#39;s short-circuiting, the &#xA;// resulting value can be different&#xA;assert(optionsFirst(Options.get(None)) == Success(None))&#xA;assert(optionsFirst(Tries.get(Failure(ex))) == Failure(ex))&#xA;&#xA;assert(triesFirst(Options.get(None)) == None)&#xA;assert(triesFirst(Tries.get(Failure(ex))) == Some(Failure(ex)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Direct Syntax&lt;/h3&gt; &#xA;&lt;p&gt;Kyo provides direct syntax for a more intuitive and concise way to express computations, especially when dealing with multiple effects. This syntax leverages two primary constructs: &lt;code&gt;defer&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Essentially, &lt;code&gt;await&lt;/code&gt; is a syntactic sugar for the &lt;code&gt;map&lt;/code&gt; function, allowing developers to directly access values from computations without the need for repetitive &lt;code&gt;map&lt;/code&gt; chaining. This makes the code more linear and intuitive.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.direct._&#xA;import scala.util.Try&#xA;&#xA;// Use the direct syntax&#xA;val a: String &amp;gt; (Tries with Options) =&#xA;  defer {&#xA;    val b: String = &#xA;      await(Options.get(Some(&#34;hello&#34;)))&#xA;    val c: String = &#xA;      await(Tries.get(Try(&#34;world&#34;)))&#xA;    b + &#34; &#34; + c&#xA;  }&#xA;&#xA;// Equivalent desugared&#xA;val b: String &amp;gt; (Tries with Options) =&#xA;  Options.get(Some(&#34;hello&#34;)).map { b =&amp;gt;&#xA;    Tries.get(Try(&#34;world&#34;)).map { c =&amp;gt;&#xA;      b + &#34; &#34; + c&#xA;    }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;defer&lt;/code&gt; macro translates the &lt;code&gt;defer&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; constructs by virtualizing control flow. It modifies value definitions, conditional branches, loops, and pattern matching to express compurations in terms of &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For added safety, the direct syntax enforces effectful hygiene. Within a &lt;code&gt;defer&lt;/code&gt; block, values of the &lt;code&gt;&amp;gt;&lt;/code&gt; type must be enclosed by an &lt;code&gt;await&lt;/code&gt; block. This approach ensures all effectful computations are explicitly processed, reducing the potential for missed effects or operation misalignment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.ios._&#xA;&#xA;// This code fails to compile&#xA;val a: Int &amp;gt; (IOs with Options) =&#xA;  defer {&#xA;    // Incorrect usage of a &#39;&amp;gt;&#39; value &#xA;    // without &#39;await&#39; &#xA;    IOs(println(42))&#xA;    val c: Int = &#xA;      await(Options.get(Some(1)))&#xA;    c + 10&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: In the absence of effectful hygiene, the side effect &lt;code&gt;IOs(println(42))&lt;/code&gt; would be overlooked and never executed. With the hygiene in place, such code results in a compilation error.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The syntac sugar supports a variety of constructs to handle effectful computations. These include pure expressions, value definitions, control flow statements like &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt;, logical operations (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;), &lt;code&gt;while&lt;/code&gt;, and pattern matching.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.direct._&#xA;import kyo.ios._&#xA;&#xA;defer {&#xA;  // Pure expression&#xA;  val a: Int = 5&#xA;  &#xA;  // Effectful value&#xA;  val b: Int = await(IOs(10))&#xA;  &#xA;  // Control flow&#xA;  val c: String = &#xA;    if (await(IOs(true))) &#34;True branch&#34; else &#34;False branch&#34;&#xA;  &#xA;  // Logical operations&#xA;  val d: Boolean = &#xA;    await(IOs(true)) &amp;amp;&amp;amp; await(IOs(false))&#xA;  &#xA;  val e: Boolean = &#xA;    await(IOs(true)) || await(IOs(true))&#xA;  &#xA;  // Loop (for demonstration; this loop &#xA;  // won&#39;t execute its body)&#xA;  while (await(IOs(false))) { &#34;Looping&#34; }&#xA;  &#xA;  // Pattern matching&#xA;  val matchResult: String = &#xA;    await(IOs(1)) match {&#xA;      case 1 =&amp;gt; &#34;One&#34;&#xA;      case _ =&amp;gt; &#34;Other&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;defer&lt;/code&gt; method in Kyo mirrors Scala&#39;s &lt;code&gt;for&lt;/code&gt;-comprehensions in providing a constrained yet expressive syntax. In &lt;code&gt;defer&lt;/code&gt;, features like nested &lt;code&gt;defer&lt;/code&gt; blocks, &lt;code&gt;var&lt;/code&gt; declarations, &lt;code&gt;return&lt;/code&gt; statements, &lt;code&gt;lazy val&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt; and &lt;code&gt;def&lt;/code&gt; with &lt;code&gt;await&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; blocks, methods and constructors accepting by-name parameters, &lt;code&gt;throw&lt;/code&gt; expressions, as well as &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;-comprehension, &lt;code&gt;trait&lt;/code&gt;, and &lt;code&gt;object&lt;/code&gt;s are disallowed. This design allows clear virtualization of control flow, eliminating potential ambiguities or unexpected results.&lt;/p&gt; &#xA;&lt;p&gt;In Scala 2, &lt;code&gt;kyo-direct&lt;/code&gt; draws its macro implementation inspiration from &lt;a href=&#34;https://github.com/monadless/monadless&#34;&gt;Monadless&lt;/a&gt;. For Scala 3, &lt;code&gt;kyo-direct&lt;/code&gt; is constructed as a wrapper around &lt;a href=&#34;https://github.com/rssh/dotty-cps-async&#34;&gt;dotty-cps-async&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: &lt;code&gt;defer&lt;/code&gt; is currently the only macro in Kyo. All other features use regular language constructs.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Defining an App&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;KyoApp&lt;/code&gt; offers a structured approach similar to Scala&#39;s &lt;code&gt;App&lt;/code&gt; for defining application entry points. However, it comes with added capabilities, handling a suite of default effects. As a result, the &lt;code&gt;run&lt;/code&gt; method within &lt;code&gt;KyoApp&lt;/code&gt; can accommodate various effects, such as IOs, Fibers, Resources, Clocks, Consoles, Randoms, Timers, and Aspects.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo._&#xA;import kyo.clocks._&#xA;import kyo.consoles._&#xA;import kyo.randoms._&#xA;import kyo.resources._&#xA;import kyo.concurrent.fibers._&#xA;&#xA;object MyApp extends KyoApp {&#xA;  // Only return pending `Fibers`, `Resources`, `Consoles` and `Tries`.&#xA;  // Handle other effects like `Options` before returning.&#xA;  def run: String &amp;gt; (Fibers with Resources with Consoles with Tries) = &#xA;    for {&#xA;      _ &amp;lt;- Consoles.println(s&#34;Main args: $args&#34;)&#xA;      currentTime &amp;lt;- Clocks.now&#xA;      _ &amp;lt;- Consoles.println(s&#34;Current time is: $currentTime&#34;)&#xA;      randomNumber &amp;lt;- Randoms.nextInt(100)&#xA;      _ &amp;lt;- Consoles.println(s&#34;Generated random number: $randomNumber&#34;)&#xA;    } yield {&#xA;      // The produced value can be of any type and is &#xA;      // automatically printed to the console.&#xA;      &#34;example&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While the companion object of &lt;code&gt;KyoApp&lt;/code&gt; provides utility methods to run isolated effectful computations, it&#39;s crucial to approach these with caution. Direct handling of effects like &lt;code&gt;IOs&lt;/code&gt; through these methods can compromise referential transparency, an essential property for functional programming.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.fibers._&#xA;import scala.concurrent.duration._&#xA;&#xA;// An example computation&#xA;val a: Int &amp;gt; IOs =&#xA;  IOs(Math.cos(42).toInt)&#xA;&#xA;// Avoid! Run the application with a specific timeout&#xA;val b: Int = &#xA;  KyoApp.run(2.minutes)(a)&#xA;&#xA;// Avoid! Run the application without specifying a timeout&#xA;val c: Int = &#xA;  KyoApp.run(a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Core Effects&lt;/h2&gt; &#xA;&lt;p&gt;Kyo&#39;s core effects act as the essential building blocks that power your application&#39;s various functionalities. Unlike other libraries that might require heavy boilerplate or specialized knowledge, Kyo&#39;s core effects are designed to be straightforward and flexible. These core effects not only simplify the management of side-effects, dependencies, and several other aspects but also allow for a modular approach to building maintainable systems.&lt;/p&gt; &#xA;&lt;h3&gt;Aborts: Short Circuiting&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Aborts&lt;/code&gt; effect is a generic implementation for short-circuiting effects. It&#39;s equivalent to ZIO&#39;s failure channel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.aborts._&#xA;&#xA;// The &#39;get&#39; method &#34;extracts&#34; the value&#xA;// from an &#39;Either&#39; (right projection)&#xA;val a: Int &amp;gt; Aborts[String] = &#xA;  Aborts[String].get(Right(1))&#xA;&#xA;// short-circuiting via &#39;Left&#39;&#xA;val b: Int &amp;gt; Aborts[String] = &#xA;  Aborts[String].get(Left(&#34;failed!&#34;))&#xA;&#xA;// short-circuiting via &#39;Fail&#39;&#xA;val c: Int &amp;gt; Aborts[String] = &#xA;  Aborts[String].fail(&#34;failed!&#34;)&#xA;&#xA;// &#39;catching&#39; automatically catches exceptions&#xA;val d: Int &amp;gt; Aborts[Exception] = &#xA;  Aborts[Exception].catching(throw new Exception)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note that the &lt;code&gt;Aborts&lt;/code&gt; effect has a type parameter and its methods can only be accessed if the type parameter is provided.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;IOs: Side Effects&lt;/h3&gt; &#xA;&lt;p&gt;Kyo is unlike traditional effect systems since its base type &lt;code&gt;&amp;gt;&lt;/code&gt; does not assume that the computation can perform side effects. The &lt;code&gt;IOs&lt;/code&gt; effect is introduced whenever a side effect needs to be performed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.ios._&#xA;&#xA;def aSideEffect = 1 // placeholder&#xA;&#xA;// &#39;apply&#39; is used to suspend side effects&#xA;val a: Int &amp;gt; IOs = &#xA;  IOs(aSideEffect)&#xA;&#xA;// &#39;value&#39; is a shorthand to widen &#xA;// a pure value to IOs&#xA;val b: Int &amp;gt; IOs = &#xA;  IOs.value(42)&#xA;&#xA;// &#39;fail&#39; returns a computation that &#xA;// will fail once IOs is handled&#xA;val c: Int &amp;gt; IOs = &#xA;  IOs.fail(new Exception)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Users shouldn&#39;t typically handle the &lt;code&gt;IOs&lt;/code&gt; effect directly since it triggers the execution of side effects, which breaks referential transparency. Prefer &lt;code&gt;KyoApp&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;p&gt;In some specific cases where Kyo isn&#39;t used as the main effect system of an application, it might make sense for the user to handle the &lt;code&gt;IOs&lt;/code&gt; effect directly. The &lt;code&gt;run&lt;/code&gt; method can only be used if &lt;code&gt;IOs&lt;/code&gt; is the only pending effect.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val a: Int &amp;gt; IOs = &#xA;  IOs(42)&#xA;&#xA;// ** Avoid &#39;IOs.run&#39;, use &#39;KyoApp&#39; instead. **&#xA;val b: Int = &#xA;  IOs.run(a).pure&#xA;// ** Avoid &#39;IOs.run&#39;, use &#39;KyoApp&#39; instead. **&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;runLazy&lt;/code&gt; method accepts computations with other effects but it doesn&#39;t guarantee that all side effects are performed before the method returns. If other effects still have to be handled, the side effects can be executed later once the other effects are handled. This a low-level API that must be used with caution.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Computation with &#39;Options&#39; and then &#xA;// &#39;IOs&#39; suspensions&#xA;val a: Int &amp;gt; (Options with IOs) = &#xA;  Options.get(Some(42)).map { v =&amp;gt; &#xA;    IOs { &#xA;      println(v)&#xA;      v&#xA;    }&#xA;  }&#xA;&#xA;// ** Avoid &#39;IOs.runLazy&#39;, use &#39;KyoApp&#39; instead. **&#xA;// Handle the &#39;IOs&#39; effect lazily&#xA;val b: Int &amp;gt; Options = &#xA;  IOs.runLazy(a)&#xA;// ** Avoid &#39;IOs.runLazy&#39;, use &#39;KyoApp&#39; instead. **&#xA;&#xA;// Since the computation is suspended with the &#xA;// &#39;Options&#39; effect first, the lazy &#39;IOs&#39; execution &#xA;// will be triggered once &#39;Options&#39; is handled&#xA;val c: Option[Int] = &#xA;  Options.run(b).pure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;IMPORTANT: Avoid handling the &lt;code&gt;IOs&lt;/code&gt; effect directly since it breaks referential transparency. Use &lt;code&gt;KyoApp&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Envs: Dependency Injection&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Envs&lt;/code&gt; is similar to ZIO&#39;s environment feature but offers more granular control. Unlike ZIO, which has built-in layering for dependencies, &lt;code&gt;Envs&lt;/code&gt; allows you to inject individual services directly. However, it lacks ZIO&#39;s structured dependency management; you manage and initialize your services yourself.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.envs._&#xA;&#xA;// Given an interface&#xA;trait Database {&#xA;  def count: Int &amp;gt; IOs &#xA;}&#xA;&#xA;// The &#39;Envs&#39; effect can be used to summon an instance.&#xA;// Note how the computation produces a &#39;Database&#39; but at the&#xA;// same time requires a &#39;Database&#39; from its environment&#xA;val a: Database &amp;gt; Envs[Database] = &#xA;  Envs[Database].get&#xA;&#xA;// Use the &#39;Database&#39; to obtain the count&#xA;val b: Int &amp;gt; (Envs[Database] with IOs) = &#xA;  a.map(_.count)&#xA;&#xA;// A &#39;Database&#39; mock implementation&#xA;val db = new Database { &#xA;  def count = 1&#xA;}&#xA;&#xA;// Handle the &#39;Envs&#39; effect with the mock database&#xA;val c: Int &amp;gt; IOs = &#xA;  Envs[Database].run(db)(b)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, a computation can require multiple values from its environment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// A second interface to be injected&#xA;trait Cache {&#xA;  def clear: Unit &amp;gt; IOs&#xA;}&#xA;&#xA;// A computation that requires two values&#xA;val a: Unit &amp;gt; (Envs[Database] with Envs[Cache] with IOs) = &#xA;  Envs[Database].get.map { db =&amp;gt;&#xA;    db.count.map {&#xA;      case 0 =&amp;gt; &#xA;        Envs[Cache].get.map(_.clear)&#xA;      case _ =&amp;gt; &#xA;        ()&#xA;    }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Locals: Scoped Values&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Locals&lt;/code&gt; effect operates on top of &lt;code&gt;IOs&lt;/code&gt; and enables the definition of scoped values. This mechanism is typically used to store contextual information of a computation. For example, in request processing, locals can be used to store information about the user who initiated the request. In a library for database access, locals can be used to propagate transactions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.locals._&#xA;&#xA;// Locals need to be initialized with a default value&#xA;val myLocal: Local[Int] = &#xA;  Locals.init(42)&#xA;&#xA;// The &#39;get&#39; method returns the current value of the local&#xA;val a: Int &amp;gt; IOs = &#xA;  myLocal.get&#xA;&#xA;// The &#39;let&#39; method assigns a value to a local within the&#xA;// scope of a computation. This code produces 43 (42 + 1)&#xA;val b: Int &amp;gt; IOs =&#xA;  myLocal.let(42)(a.map(_ + 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Kyo&#39;s effects are designed so locals are properly propagated. For example, they&#39;re automatically inherited by forked computations in &lt;code&gt;Fibers&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Resources: Resource Safety&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Resources&lt;/code&gt; effect handles the safe use of external resources like network connections, files, and any other resource that needs to be freed once the computation finalizes. It serves as a mechanism similar to ZIO&#39;s &lt;code&gt;Scope&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.resources._&#xA;import java.io.Closeable&#xA;&#xA;class Database extends Closeable {&#xA;  def count: Int &amp;gt; IOs = 42&#xA;  def close() = {}&#xA;}&#xA;&#xA;// The `acquire` method accepts any object that &#xA;// implements Java&#39;s `Closeable` interface&#xA;val db: Database &amp;gt; (Resources with IOs) = &#xA;  Resources.acquire(new Database)&#xA;&#xA;// Use `run` to handle the effect, while also &#xA;// closing the resources utilized by the &#xA;// computationation&#xA;val b: Int &amp;gt; IOs = &#xA;  Resources.run(db.map(_.count))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;ensure&lt;/code&gt; method provides a low-level API to handle the finalization of resources directly. The &lt;code&gt;acquire&lt;/code&gt; method is implemented in terms of &lt;code&gt;ensure&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Example method to execute a function on a database&#xA;def withDb[T](f: Database =&amp;gt; T &amp;gt; IOs): T &amp;gt; (IOs with Resources) =&#xA;  // Initializes the database (&#39;new Database&#39; is a placeholder)&#xA;  IOs(new Database).map { db =&amp;gt;&#xA;    // Registers `db.close` to be finalized&#xA;    Resources.ensure(db.close).map { _ =&amp;gt;&#xA;      // Invokes the function&#xA;      f(db)&#xA;    }&#xA;  }&#xA;&#xA;// Execute a function&#xA;val a: Int &amp;gt; (IOs with Resources) =&#xA;  withDb(_.count)&#xA;&#xA;// Close resources&#xA;val b: Int &amp;gt; IOs = &#xA;  Resources.run(a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Seqs: Exploratory Branching&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Seqs&lt;/code&gt; effect is designed to aid in handling and exploring multiple options, pathways, or outcomes in a computation. This effect is particularly useful in scenarios where you&#39;re dealing with decision trees, backtracking algorithms, or any situation that involves dynamically exploring multiple options.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.seqs._&#xA;&#xA;// Evaluate each of the provided `Seq`s.&#xA;// Note how &#39;get&#39; takes a &#39;Seq[T]&#39;&#xA;// and returns a &#39;T &amp;gt; Seqs&#39;&#xA;val a: Int &amp;gt; Seqs =&#xA;  Seqs.get(Seq(1, 2, 3, 4))&#xA;&#xA;// &#39;filter&#39; discards the current element if &#xA;// a condition is not met. Produces a &#39;Seq(1, 2)&#39;&#xA;// since values greater than 2 are dropped&#xA;val b: Int &amp;gt; Seqs =&#xA;  a.map(v =&amp;gt; Seqs.filter(v &amp;gt; 2).map(_ =&amp;gt; v))&#xA;&#xA;// &#39;drop&#39; unconditionally discards the &#xA;// current choice. Produces a &#39;Seq(42)&#39;&#xA;// since only the value 1 is transformed&#xA;// to 42 and all other values are dropped&#xA;val c: Int &amp;gt; Seqs = &#xA;  b.map {&#xA;    case 1 =&amp;gt; 42&#xA;    case _ =&amp;gt; Seqs.drop&#xA;  }&#xA;&#xA;// Handle the effect to evaluate all elements &#xA;// and return a &#39;Seq&#39; with the results&#xA;val d: Seq[Int] &amp;gt; Any =&#xA;  Seqs.run(c)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Seqs&lt;/code&gt; effect becomes exceptionally powerful when combined with other effects. This allows you not just to make decisions or explore options in isolation but also to do so in contexts that may involve factors such as asynchronicity, resource management, or even user interaction.&lt;/p&gt; &#xA;&lt;h3&gt;Aspects: Aspect-Oriented Programming&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Aspects&lt;/code&gt; effect in Kyo allows for high-level customization of behavior across your application. This is similar to how some frameworks use aspects for centralized control over diverse functionalities like database timeouts, authentication, authorization, and transaction management. You can modify these core operations without altering their individual codebases, streamlining how centralized logic is applied across different parts of an application. This makes &lt;code&gt;Aspects&lt;/code&gt; ideal for implementing cross-cutting concerns in a clean and efficient manner.&lt;/p&gt; &#xA;&lt;p&gt;To instantiate an aspect, use the &lt;code&gt;Aspects.init&lt;/code&gt; method. It takes three type parameters:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;T&lt;/code&gt;: The input type of the aspect&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;U&lt;/code&gt;: The output type of the aspect&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S&lt;/code&gt;: The effects the aspect may perform&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.aspects._&#xA;&#xA;// Initialize an aspect that takes a &#39;Database&#39; and returns&#xA;// an &#39;Int&#39;, potentially performing &#39;IOs&#39; effects&#xA;val countAspect: Aspect[Database, Int, IOs] = &#xA;  Aspects.init[Database, Int, IOs]&#xA;&#xA;// The method &#39;apply&#39; activates the aspect for a computation&#xA;def count(db: Database): Int &amp;gt; IOs =&#xA;  countAspect(db)(_.count)&#xA;&#xA;// To bind an aspect to an implementation, first create a new &#39;Cut&#39;&#xA;val countPlusOne =&#xA;  new Cut[Database, Int, IOs] {&#xA;    // The first param is the input of the computation and the second is&#xA;    // the computation being handled&#xA;    def apply[S](v: Database &amp;gt; S)(f: Database =&amp;gt; Int &amp;gt; IOs) =&#xA;      v.map(db =&amp;gt; f(db).map(_ + 1))&#xA;  }&#xA;&#xA;// Bind the &#39;Cut&#39; to a computation with the &#39;let&#39; method.&#xA;// The first param is the &#39;Cut&#39; and the second is the computation&#xA;// that will run with the custom binding of the aspect&#xA;def example(db: Database): Int &amp;gt; IOs =&#xA;  countAspect.let(countPlusOne) {&#xA;    count(db)&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If an aspect is bound to multiple &lt;code&gt;Cut&lt;/code&gt; implementations, the order of their execution is determined by the sequence in which they are scoped within the computation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Another &#39;Cut&#39; implementation&#xA;val countTimesTen =&#xA;  new Cut[Database, Int, IOs] {&#xA;    def apply[S](v: Database &amp;gt; S)(f: Database =&amp;gt; Int &amp;gt; IOs) =&#xA;      v.map(db =&amp;gt; f(db).map(_ * 10))&#xA;  }&#xA;&#xA;// First bind &#39;countPlusOne&#39; then &#39;countTimesTen&#39;&#xA;// the result will be (db.count + 1) * 10&#xA;def example1(db: Database) =&#xA;  countAspect.let(countPlusOne) {&#xA;    countAspect.let(countTimesTen) {&#xA;      count(db)&#xA;    }&#xA;  }&#xA;&#xA;// First bind &#39;countTimesTen&#39; then &#39;countPlusOne&#39;&#xA;// the result will be (db.count * 10) + 1&#xA;def example2(db: Database) =&#xA;  countAspect.let(countTimesTen) {&#xA;    countAspect.let(countPlusOne) {&#xA;      count(db)&#xA;    }&#xA;  }&#xA;&#xA;// Cuts can also be composed via `andThen`&#xA;def example3(db: Database) =&#xA;  countAspect.let(countTimesTen.andThen(countPlusOne)) {&#xA;    count(db)&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Options: Optional Values&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.options._&#xA;&#xA;// &#39;get&#39; is used to &#39;extract&#39; the value of an &#39;Option&#39;&#xA;val a: Int &amp;gt; Options = &#xA;  Options.get(Some(1))&#xA;&#xA;// &#39;apply&#39; is the effectful version of &#39;Option.apply&#39;&#xA;val b: Int &amp;gt; Options = &#xA;  Options(1)&#xA;&#xA;// If &#39;apply&#39; receives a &#39;null&#39;, it becomes equivalent to &#39;Options.get(None)&#39;&#xA;assert(Options.run(Options(null)) == Options.run(Options.get(None)))&#xA;&#xA;// Effectful version of `Option.getOrElse`&#xA;val c: Int &amp;gt; Options = &#xA;  Options.getOrElse(None, 42)&#xA;&#xA;// Effectful version of &#39;Option.orElse&#xA;val d: Int &amp;gt; Options = &#xA;  Options.getOrElse(Some(1), c)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tries: Exception Handling&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.tries._&#xA;&#xA;// &#39;get&#39; is used to &#39;extract&#39; the value of a &#39;Try&#39;&#xA;val a: Int &amp;gt; Tries = &#xA;  Tries.get(Try(1))&#xA;&#xA;// &#39;fail&#39; to short-circuit the computation&#xA;val b: Int &amp;gt; Tries = &#xA;  Tries.fail(new Exception)&#xA;&#xA;// &#39;fail&#39; has an overload that takes an error message&#xA;val c: Int &amp;gt; Tries = &#xA;  Tries.fail(&#34;failed&#34;)&#xA;&#xA;// &#39;catching&#39; is the effectful version of &#39;Try.apply&#39;&#xA;val d: Int &amp;gt; Tries = &#xA;  Tries.catching(1)&#xA;&#xA;// The &#39;catching&#39; method automatically catches exceptions&#xA;val e: Int &amp;gt; Tries = &#xA;  Tries.catching(throw new Exception)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Consoles: Console Interaction&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.consoles._&#xA;&#xA;// Read a line from the console&#xA;val a: String &amp;gt; Consoles = &#xA;  Consoles.readln&#xA;&#xA;// Print to stdout&#xA;val b: Unit &amp;gt; Consoles = &#xA;  Consoles.print(&#34;ok&#34;)&#xA;&#xA;// Print to stdout with a new line&#xA;val c: Unit &amp;gt; Consoles = &#xA;  Consoles.println(&#34;ok&#34;)&#xA;&#xA;// Print to stderr&#xA;val d: Unit &amp;gt; Consoles = &#xA;  Consoles.printErr(&#34;fail&#34;)&#xA;&#xA;// Print to stderr with a new line&#xA;val e: Unit &amp;gt; Consoles = &#xA;  Consoles.printlnErr(&#34;fail&#34;)&#xA;&#xA;// Run with the default implicit &#39;Console&#39; implementation&#xA;val f: Unit &amp;gt; IOs = &#xA;  Consoles.run(e)&#xA;&#xA;// Explicitly specifying the &#39;Console&#39; implementation&#xA;val g: Unit &amp;gt; IOs = &#xA;  Consoles.run(Console.default)(e)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note how &lt;code&gt;Consoles.run&lt;/code&gt; returns a computation with the &lt;code&gt;IOs&lt;/code&gt; effect pending, which ensures the implementation of &lt;code&gt;Consoles&lt;/code&gt; is pure.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Clocks: Time Management&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.clocks._&#xA;import java.time.Instant&#xA;&#xA;// Obtain the current time&#xA;val a: Instant &amp;gt; IOs = &#xA;  Clocks.now&#xA;&#xA;// Run with an explicit &#39;Clock&#39;&#xA;val c: Instant &amp;gt; IOs = &#xA;  Clocks.let(Clock.default)(a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Randoms: Random Values&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.randoms._&#xA;&#xA;// Generate a random &#39;Int&#39;&#xA;val a: Int &amp;gt; IOs = Randoms.nextInt&#xA;&#xA;// Generate a random &#39;Int&#39; within a bound&#xA;val b: Int &amp;gt; IOs = Randoms.nextInt(42)&#xA;&#xA;// A few method variants&#xA;val c: Long &amp;gt; IOs = Randoms.nextLong&#xA;val d: Double &amp;gt; IOs = Randoms.nextDouble&#xA;val e: Boolean &amp;gt; IOs = Randoms.nextBoolean&#xA;val f: Float &amp;gt; IOs = Randoms.nextFloat&#xA;val g: Double &amp;gt; IOs = Randoms.nextGaussian&#xA;&#xA;// Obtain a random value from a sequence&#xA;val h: Int &amp;gt; IOs = &#xA;  Randoms.nextValue(List(1, 2, 3))&#xA;&#xA;// Explicitly specify the `Random` implementation&#xA;val k: Int &amp;gt; IOs =&#xA;  Randoms.let(Random.default)(h)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Logs: Logging&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Logs&lt;/code&gt; is designed to streamline the logging process without requiring the instantiation of a &lt;code&gt;Logger&lt;/code&gt;. By leveraging the &lt;a href=&#34;https://github.com/com-lihaoyi/sourcecode&#34;&gt;sourcecode&lt;/a&gt; library, log messages automatically include source code position information, enhancing the clarity and usefulness of the logs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.logs._&#xA;&#xA;// Logs provide trace, debug, info, &#xA;// warn, and error method variants.&#xA;val a: Unit &amp;gt; IOs = &#xA;  Logs.error(&#34;example&#34;)&#xA;&#xA;// Each variant also has a method overload&#xA;// that takes a &#39;Throwable&#39; as a second param&#xA;val d: Unit &amp;gt; IOs = &#xA;  Logs.error(&#34;example&#34;, new Exception)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stats: Observability&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Stats&lt;/code&gt; is a pluggable implementation that provides counters, histograms, gauges, and tracing. It uses Java&#39;s &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&#34;&gt;service loading&lt;/a&gt; to locate exporters.&lt;/p&gt; &#xA;&lt;p&gt;The module &lt;a href=&#34;https://central.sonatype.com/artifact/io.getkyo/kyo-stats-otel_3&#34;&gt;&lt;code&gt;kyo-stats-otel&lt;/code&gt;&lt;/a&gt; provides exporters for &lt;a href=&#34;https://opentelemetry.io/&#34;&gt;OpenTelemetry&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.stats._&#xA;&#xA;// Initialize a Stats instance&#xA;// for a scope path&#xA;val stats: Stats =&#xA;  Stats.initScope(&#34;my_application&#34;, &#34;my_module&#34;)&#xA;&#xA;// Initialize a counter&#xA;val a: Counter =&#xA;  stats.initCounter(&#34;my_counter&#34;)&#xA;&#xA;// It&#39;s also possible to provide&#xA;// metadata when initializing&#xA;val b: Histogram =&#xA;  stats.initHistogram(&#xA;    name = &#34;my_histogram&#34;,&#xA;    description = &#34;some description&#34;,&#xA;    unit = &#34;some unit&#34;,&#xA;    attributes = Attributes.of(&#34;key&#34;, &#34;value&#34;)&#xA;  )&#xA;&#xA;// Gauges take a by-name function to &#xA;// be observed periodically&#xA;val c: Gauge =&#xA;  stats.initGauge(&#34;free_memory&#34;) {&#xA;    Runtime.getRuntime().freeMemory()&#xA;  }&#xA;&#xA;// Ensure gauges are closed once &#xA;// they&#39;re not needed to avoid leaks&#xA;val d: Unit &amp;gt; IOs =&#xA;  c.close&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Although stats initialization may perform side effects, Kyo chooses to consider the operation pure since stats are meant to be initialized in a static scope for optimal performance.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Tracing can be performed via the &lt;code&gt;traceSpan&lt;/code&gt; method. It automatically initializes the span and closes it at the end of the traced computation even in the presence of failures or asynchronous operations. Nested traces are bound to their parent span via &lt;code&gt;Locals&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Some example computation&#xA;val a: Int &amp;gt; IOs =&#xA;  IOs(42)&#xA;&#xA;// Trace the execution of the&#xA;// `a` example computation&#xA;val b: Int &amp;gt; IOs =&#xA;  stats.traceSpan(&#34;my_span&#34;)(a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Concurrent Effects&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;kyo.concurrent&lt;/code&gt; package provides utilities for dealing with concurrency in Scala applications. It&#39;s a powerful set of effects designed for easier asynchronous programming, built on top of other core functionalities provided by the &lt;code&gt;kyo&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;h3&gt;Fibers: Green Threads&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Fibers&lt;/code&gt; effect allows for the asynchronous execution of computations via a managed thread pool. The core function, &lt;code&gt;init&lt;/code&gt;, spawns a new &#34;green thread,&#34; also known as a fiber, to handle the given computation. This provides a powerful mechanism for parallel execution and efficient use of system resources. Moreover, fibers maintain proper propagation of &lt;code&gt;Locals&lt;/code&gt;, ensuring that context information is carried along during the forking process.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.fibers._&#xA;&#xA;// Fork a computation. The parameter is&#xA;// taken by reference and automatically&#xA;// suspended with &#39;IOs&#39;&#xA;val a: Fiber[Int] &amp;gt; IOs =&#xA;  Fibers.init(Math.cos(42).toInt)&#xA;&#xA;// It&#39;s possible to &#34;extract&#34; the value of a &#xA;// &#39;Fiber&#39; via the &#39;get&#39; method. This is also&#xA;// referred as &#34;joining the fiber&#34;&#xA;val b: Int &amp;gt; Fibers =&#xA;  Fibers.get(a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;parallel&lt;/code&gt; methods fork multiple computations in parallel, join the fibers, and return their results.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An example computation&#xA;val a: Int &amp;gt; IOs =&#xA;  IOs(Math.cos(42).toInt)&#xA;&#xA;// There are method overloadings for up to four&#xA;// parallel computations. Paramters taken by&#xA;// reference&#xA;val b: (Int, String) &amp;gt; Fibers =&#xA;  Fibers.parallel(a, &#34;example&#34;)&#xA;&#xA;// Alternatively, it&#39;s possible to provide&#xA;// a &#39;Seq&#39; of computations and produce a &#39;Seq&#39;&#xA;// with the results&#xA;val c: Seq[Int] &amp;gt; Fibers =&#xA;  Fibers.parallel(Seq(a, a.map(_ + 1)))&#xA;&#xA;// The &#39;parallelFiber&#39; method is similar but&#xA;// it doesn&#39;t automatically join the fibers and&#xA;// produces a &#39;Fiber[Seq[T]]&#39;&#xA;val d: Fiber[Seq[Int]] &amp;gt; IOs =&#xA;  Fibers.parallelFiber(Seq(a, a.map(_ + 1)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;race&lt;/code&gt; methods are similar to &lt;code&gt;parallel&lt;/code&gt; but they return the first computation to complete with either a successful result or a failure. Once the first result is produced, the other computations are automatically interrupted.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An example computation&#xA;val a: Int &amp;gt; IOs =&#xA;  IOs(Math.cos(42).toInt)&#xA;&#xA;// There are method overloadings for up to four&#xA;// computations. Pameters taken by reference&#xA;val b: Int &amp;gt; Fibers =&#xA;  Fibers.race(a, a.map(_ + 1))&#xA;&#xA;// It&#39;s also possible to to provide a &#39;Seq&#39; &#xA;// of computations &#xA;val c: Int &amp;gt; Fibers =&#xA;  Fibers.race(Seq(a, a.map(_ + 1)))&#xA;&#xA;// &#39;raceFiber&#39; produces a &#39;Fiber&#39; without&#xA;// joining it&#xA;val d: Fiber[Int] &amp;gt; IOs =&#xA;  Fibers.raceFiber(Seq(a, a.map(_ + 1)))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;sleep&lt;/code&gt; and &lt;code&gt;timeout&lt;/code&gt; methods pause a computation or time it out after a duration.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.timers._&#xA;import scala.concurrent.duration._&#xA;&#xA;// A computation that sleeps for 1s&#xA;val a: Unit &amp;gt; Fibers =&#xA;  Fibers.sleep(1.second)&#xA;&#xA;// Times out and interrupts the provided &#xA;// computation in case it doesn&#39;t produce &#xA;// a result within 1s&#xA;val b: Int &amp;gt; Fibers =&#xA;  Fibers.timeout(1.second)(Math.cos(42).toInt)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;fromFuture&lt;/code&gt; methods provide interoperability with Scala&#39;s &lt;code&gt;Future&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scala.concurrent.Future&#xA;&#xA;// An example &#39;Future&#39; instance&#xA;val a: Future[Int] = Future.successful(42)&#xA;&#xA;// Join the result of a &#39;Future&#39;&#xA;val b: Int &amp;gt; Fibers =&#xA;  Fibers.fromFuture(a)&#xA;&#xA;// Use &#39;fromFutureFiber&#39; to produce &#39;Fiber&#39; &#xA;// instead of joining the computation&#xA;val c: Fiber[Int] &amp;gt; IOs =&#xA;  Fibers.fromFutureFiber(a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Important: Keep in mind that Scala&#39;s Future lacks built-in support for interruption. As a result, any computations executed through Future will run to completion, even if they&#39;re involved in a race operation where another computation finishes first.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;A &lt;code&gt;Fiber&lt;/code&gt; instance also provides a few relevant methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An example fiber&#xA;val a: Fiber[Int] = Fibers.value(42)&#xA;&#xA;// Check if the fiber is done&#xA;val b: Boolean &amp;gt; IOs =&#xA;  a.isDone&#xA;&#xA;// Instance-level version of &#39;Fibers.get&#39;&#xA;val c: Int &amp;gt; Fibers =&#xA;  a.get&#xA;&#xA;// Avoid this low-level API to attach a &#xA;// a callback to a fiber&#xA;val d: Unit &amp;gt; IOs =&#xA;  a.onComplete(println(_))&#xA;&#xA;// A variant of `get` that returns a `Try`&#xA;// with the failed or successful result&#xA;val e: Try[Int] &amp;gt; Fibers =&#xA;  a.getTry&#xA;&#xA;// Try to interrupt/cancel a fiber&#xA;val f: Boolean &amp;gt; IOs =&#xA;  a.interrupt&#xA;&#xA;// Transforms a fiber into a Scala &#39;Future&#39;&#xA;val h: Future[Int] &amp;gt; IOs =&#xA;  a.toFuture&#xA;&#xA;// The &#39;transform&#39; method is similar to `flatMap`&#xA;// in Scala&#39;s &#39;Future&#39;&#xA;val i: Fiber[Int] &amp;gt; IOs =&#xA;  a.transform(v =&amp;gt; Fibers.value(v + 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly to &lt;code&gt;IOs&lt;/code&gt;, users should avoid handling the &lt;code&gt;Fibers&lt;/code&gt; effect directly and rely on &lt;code&gt;KyoApp&lt;/code&gt; instead. If strictly necessary, there are two methods to handle the &lt;code&gt;Fibers&lt;/code&gt; effect:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;run&lt;/code&gt; takes a computation that has only the &lt;code&gt;Fibers&lt;/code&gt; effect pending and returns a &lt;code&gt;Fiber&lt;/code&gt; instance without blocking threads.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;runBlocking&lt;/code&gt; accepts computations with arbitrary pending effects but it handles asynchronous operations by blocking the current thread.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An example computation with fibers&#xA;val a: Int &amp;gt; Fibers =&#xA;  Fibers.init(Math.cos(42).toInt).map(_.get)&#xA;&#xA;// Avoid handling &#39;Fibers&#39; directly&#xA;// Note how the code has to handle the&#xA;// &#39;IOs&#39; effect and then handle &#39;Fibers&#39;&#xA;val b: Fiber[Int] &amp;gt; IOs =&#xA;  Fibers.run(IOs.runLazy(a))&#xA;&#xA;// The &#39;runBlocking&#39; method accepts&#xA;// arbitrary pending effects but relies&#xA;// on thread blocking.&#xA;val c: Int &amp;gt; IOs =&#xA;  Fibers.runBlocking(a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Handling the &lt;code&gt;Fibers&lt;/code&gt; effect doesn&#39;t break referential transparency as with &lt;code&gt;IOs&lt;/code&gt; but its usage is not trivial due to the limitations of the pending effects, especially &lt;code&gt;IOs&lt;/code&gt;. Prefer &lt;code&gt;KyoApp&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The &lt;code&gt;Fibers&lt;/code&gt; effect also offers a low-level API to create &lt;code&gt;Promise&lt;/code&gt;s as way to integrate external async operations with fibers. These APIs should be used only in low-level integration code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Initialize a promise&#xA;val a: Promise[Int] &amp;gt; IOs =&#xA;  Fibers.initPromise[Int]&#xA;&#xA;// Try to fulfill a promise&#xA;val b: Boolean &amp;gt; IOs =&#xA;  a.map(_.complete(42))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;A &lt;code&gt;Promise&lt;/code&gt; is basically a &lt;code&gt;Fiber&lt;/code&gt; with all the regular functionality plus the &lt;code&gt;complete&lt;/code&gt; method to manually fulfill the promise.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Queues: Concurrent Queuing&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Queues&lt;/code&gt; effect operates atop of &lt;code&gt;IOs&lt;/code&gt; and provides thread-safe queue data structures based on the high-performance &lt;a href=&#34;https://github.com/JCTools/JCTools&#34;&gt;JCTools&lt;/a&gt; library on the JVM. For ScalaJS, a simple &lt;code&gt;ArrayQueue&lt;/code&gt; is used.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bounded queues&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.queues._&#xA;&#xA;// A bounded channel rejects new&#xA;// elements once full&#xA;val a: Queue[Int] &amp;gt; IOs =&#xA;  Queues.init(capacity = 42)&#xA;&#xA;// Obtain the number of items in the queue&#xA;// via the method &#39;size&#39; in &#39;Queue&#39;&#xA;val b: Int &amp;gt; IOs =&#xA;  a.map(_.size)&#xA;&#xA;// Get the queue capacity&#xA;val c: Int &amp;gt; IOs =&#xA;  a.map(_.capacity)&#xA;&#xA;// Try to offer a new item&#xA;val d: Boolean &amp;gt; IOs =&#xA;  a.map(_.offer(42))&#xA;&#xA;// Try to poll an item&#xA;val e: Option[Int] &amp;gt; IOs =&#xA;  a.map(_.poll)&#xA;&#xA;// Try to &#39;peek&#39; an item without removing it&#xA;val f: Option[Int] &amp;gt; IOs =&#xA;  a.map(_.peek)&#xA;&#xA;// Check if the queue is empty&#xA;val g: Boolean &amp;gt; IOs =&#xA;  a.map(_.isEmpty)&#xA;&#xA;// Check if the queue is full&#xA;val h: Boolean &amp;gt; IOs =&#xA;  a.map(_.isFull)&#xA;&#xA;// Drain the queue items&#xA;val i: Seq[Int] &amp;gt; IOs =&#xA;  a.map(_.drain)&#xA;&#xA;// Close the queue. If successful,&#xA;// returns a Some with the drained&#xA;// elements&#xA;val j: Option[Seq[Int]] &amp;gt; IOs =&#xA;  a.map(_.close)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Unbounded queues&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Avoid `Queues.unbounded` since if queues can &#xA;// grow without limits, the GC overhead can make &#xA;// the system fail&#xA;val a: Queues.Unbounded[Int] &amp;gt; IOs =&#xA;  Queues.initUnbounded()&#xA;&#xA;// A &#39;dropping&#39; queue discards new entries&#xA;// when full&#xA;val b: Queues.Unbounded[Int] &amp;gt; IOs =&#xA;  Queues.initDropping(capacity = 42)&#xA;&#xA;// A &#39;sliding&#39; queue discards the oldest&#xA;// entries if necessary to make space for new &#xA;// entries&#xA;val c: Queues.Unbounded[Int] &amp;gt; IOs =&#xA;  Queues.initSliding(capacity = 42)&#xA;&#xA;// Note how &#39;dropping&#39; and &#39;sliding&#39; queues&#xA;// return &#39;Queues.Unbounded`. It provides&#xA;// an additional method to &#39;add&#39; new items&#xA;// unconditionally&#xA;val d: Unit &amp;gt; IOs =&#xA;  c.map(_.add(42))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Concurrent access policies&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also possible to specify a concurrent &lt;code&gt;Access&lt;/code&gt; policy as the second parameter of the &lt;code&gt;Queues.init&lt;/code&gt; methods. This configuration has an effect only on the JVM and is ignored in ScalaJS.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Policy&lt;/th&gt; &#xA;   &lt;th&gt;Full Form&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Mpmc&lt;/td&gt; &#xA;   &lt;td&gt;Multiple Producers, Multiple Consumers&lt;/td&gt; &#xA;   &lt;td&gt;Supports multiple threads/fibers simultaneously enqueuing and dequeuing elements. This is the most flexible but may incur the most overhead due to the need to synchronize between multiple producers and consumers.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Mpsc&lt;/td&gt; &#xA;   &lt;td&gt;Multiple Producers, Single Consumer&lt;/td&gt; &#xA;   &lt;td&gt;Allows multiple threads/fibers to enqueue elements but restricts dequeuing to a single consumer. This can be more efficient than &lt;code&gt;Mpmc&lt;/code&gt; when only one consumer is needed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Spmc&lt;/td&gt; &#xA;   &lt;td&gt;Single Producer, Multiple Consumers&lt;/td&gt; &#xA;   &lt;td&gt;Allows only a single thread/fiber to enqueue elements, but multiple threads/fibers can dequeue elements. Useful when only one source is generating elements to be processed by multiple consumers.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Spsc&lt;/td&gt; &#xA;   &lt;td&gt;Single Producer, Single Consumer&lt;/td&gt; &#xA;   &lt;td&gt;The most restrictive but potentially fastest policy. Only one thread/fiber can enqueue elements, and only one thread/fiber can dequeue elements.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Each policy is suitable for different scenarios and comes with its own trade-offs. For example, &lt;code&gt;Mpmc&lt;/code&gt; is highly flexible but can be slower due to the need for more complex synchronization. &lt;code&gt;Spsc&lt;/code&gt;, being the most restrictive, allows for optimizations that could make it faster for specific single-producer, single-consumer scenarios.&lt;/p&gt; &#xA;&lt;p&gt;You can specify the access policy when initializing a queue, and it is important to choose the one that aligns with your application&#39;s needs for optimal performance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.Access&#xA;&#xA;// Initialize a bounded queue with a &#xA;// Multiple Producers, Multiple &#xA;// Consumers policy&#xA;val a: Queue[Int] &amp;gt; IOs =&#xA;  Queues.init(&#xA;    capacity = 42, &#xA;    access = Access.Mpmc&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Channels: Backpressured Communication&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Channels&lt;/code&gt; effect serves as an advanced concurrency primitive, designed to facilitate seamless and backpressured data transfer between various parts of your application. Built upon the &lt;code&gt;Fibers&lt;/code&gt; effect, &lt;code&gt;Channels&lt;/code&gt; not only ensures thread-safe communication but also incorporates a backpressure mechanism. This mechanism temporarily suspends fibers under specific conditions—either when waiting for new items to arrive or when awaiting space to add new items.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.channels._&#xA;&#xA;// A &#39;Channel&#39; is initialized&#xA;// with a fixed capacity&#xA;val a: Channel[Int] &amp;gt; IOs =&#xA;  Channels.init(capacity = 42)&#xA;&#xA;// It&#39;s also possible to specify&#xA;// an &#39;Access&#39; policy&#xA;val b: Channel[Int] &amp;gt; IOs =&#xA;  Channels.init(&#xA;    capacity = 42, &#xA;    access = Access.Mpmc&#xA;  )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While &lt;code&gt;Channels&lt;/code&gt; share similarities with &lt;code&gt;Queues&lt;/code&gt;—such as methods for querying size (&lt;code&gt;size&lt;/code&gt;), adding an item (&lt;code&gt;offer&lt;/code&gt;), or retrieving an item (&lt;code&gt;poll&lt;/code&gt;)—they go a step further by offering backpressure-sensitive methods, namely &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;take&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An example channel&#xA;val a: Channel[Int] &amp;gt; IOs =&#xA;  Channels.init(capacity = 42)&#xA;&#xA;// Adds a new item to the channel.&#xA;// If there&#39;s no capacity, the fiber&#xA;// is automatically suspended until&#xA;// space is made available&#xA;val b: Unit &amp;gt; Fibers =&#xA;  a.map(_.put(42))&#xA;&#xA;// Takes an item from the channel.&#xA;// If the channel is empty, the fiber&#xA;// is suspended until a new item is&#xA;// made available&#xA;val c: Int &amp;gt; Fibers =&#xA;  a.map(_.take)&#xA;&#xA;// &#39;putFiber&#39; returns a `Fiber` that&#xA;// will complete once the put completes&#xA;val d: Fiber[Unit] &amp;gt; IOs =&#xA;  a.map(_.putFiber(42))&#xA;&#xA;// &#39;takeFiber&#39; also returns a fiber&#xA;val e: Fiber[Int] &amp;gt; IOs =&#xA;  a.map(_.takeFiber)&#xA;&#xA;// Closes the channel. If successful,&#xA;// returns a Some with the drained&#xA;// elements. All pending puts and takes&#xA;// are automatically interrupted&#xA;val f: Option[Seq[Int]] &amp;gt; IOs =&#xA;  a.map(_.close)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The ability to suspend fibers during &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;take&lt;/code&gt; operations allows &lt;code&gt;Channels&lt;/code&gt; to provide a more controlled form of concurrency. This is particularly beneficial for rate-sensitive or resource-intensive tasks where maintaining system balance is crucial.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Important: While a &lt;code&gt;Channel&lt;/code&gt; comes with a predefined item capacity, it&#39;s crucial to understand that there is no upper limit on the number of fibers that can be suspended by it. In scenarios where your application spawns an unrestricted number of fibers—such as an HTTP service where each incoming request initiates a new fiber—this can lead to significant memory consumption. The channel&#39;s internal queue for suspended fibers could grow indefinitely, making it a potential source of unbounded queuing and memory issues. Exercise caution in such use-cases to prevent resource exhaustion.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Hubs: Broadcasting with Backpressure&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Hubs&lt;/code&gt; provide a broadcasting mechanism where messages are sent to multiple listeners simultaneously. They are similar to &lt;code&gt;Channels&lt;/code&gt;, but they are uniquely designed for scenarios involving multiple consumers. The key feature of &lt;code&gt;Hubs&lt;/code&gt; is their ability to apply backpressure automatically. This means if the &lt;code&gt;Hub&lt;/code&gt; and any of its listeners&#39; buffers are full, the &lt;code&gt;Hub&lt;/code&gt; will pause both the producers and consumers to prevent overwhelming the system. Unlike &lt;code&gt;Channels&lt;/code&gt;, &lt;code&gt;Hubs&lt;/code&gt; don&#39;t offer customization in concurrent access policy as they are inherently meant for multi-producer, multi-consumer environments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.hubs._&#xA;&#xA;// Initialize a Hub with a buffer&#xA;val a: Hub[Int] &amp;gt; IOs =&#xA;  Hubs.init[Int](3)&#xA;&#xA;// Hubs provide APIs similar to&#xA;// channels: size, offer, isEmpty,&#xA;// isFull, putFiber, put&#xA;val b: Boolean &amp;gt; IOs =&#xA;  a.map(_.offer(1))&#xA;&#xA;// But reading from hubs can only &#xA;// happen via listener. Listeners&#xA;// only receive messages sent after&#xA;// their cration. To create call &#xA;// `listen`:&#xA;val c: Listener[Int] &amp;gt; IOs =&#xA;  a.map(_.listen)&#xA;&#xA;// Each listener can have an&#xA;// additional message buffer&#xA;val d: Listener[Int] &amp;gt; IOs =&#xA;  a.map(_.listen(bufferSize = 3))&#xA;&#xA;// Listeners provide methods for&#xA;// receiving messages similar to&#xA;// channels: size, isEmpty, isFull,&#xA;// poll, takeFiber, take&#xA;val e: Int &amp;gt; Fibers =&#xA;  d.map(_.take)&#xA;&#xA;// A listener can be closed&#xA;// individually. If successful,&#xA;// a Some with the backlog of &#xA;// pending messages is returned&#xA;val f: Option[Seq[Int]] &amp;gt; IOs =&#xA;  d.map(_.close)&#xA;&#xA;// If the Hub is closed, all&#xA;// listeners are automatically&#xA;// closed. The returned backlog&#xA;// only include items pending in&#xA;// the hub&#39;s buffer. The listener&#xA;// buffers are discarded&#xA;val g: Option[Seq[Int]] &amp;gt; IOs =&#xA;  a.map(_.close)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hubs are implemented with an internal structure that efficiently manages message distribution. At their core, Hubs utilize a single channel for incoming messages. This central channel acts as the primary point for all incoming data. For each listener attached to a Hub, a separate channel is created. These individual channels are dedicated to each listener, ensuring that messages are distributed appropriately.&lt;/p&gt; &#xA;&lt;p&gt;The functioning of Hubs is orchestrated by a dedicated fiber. This fiber continuously monitors the main incoming channel. Whenever a new message arrives, it takes this message and concurrently distributes it to all the listener channels. This process involves submitting the message to each listener&#39;s channel in parallel, ensuring simultaneous delivery of messages.&lt;/p&gt; &#xA;&lt;p&gt;After distributing a message, the fiber waits until all the listener channels have successfully received it. This waiting mechanism is crucial for maintaining the integrity of message distribution, ensuring that each listener gets the message before the fiber proceeds to the next one and backpressure is properly applied.&lt;/p&gt; &#xA;&lt;h3&gt;Meters: Computational Limits&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Meters&lt;/code&gt; effect offers utilities to regulate computational execution, be it limiting concurrency or managing rate. It is equipped with a range of pre-set limitations, including mutexes, semaphores, and rate limiters, allowing you to apply fine-grained control over task execution.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.meters._&#xA;&#xA;// &#39;mutex&#39;: One computation at a time&#xA;val a: Meter &amp;gt; IOs = &#xA;  Meters.initMutex&#xA;&#xA;// &#39;semaphore&#39;: Limit concurrent tasks&#xA;val b: Meter &amp;gt; IOs =&#xA;  Meters.initSemaphore(concurrency = 42)&#xA;&#xA;// &#39;rateLimiter&#39;: Tasks per time window&#xA;val c: Meter &amp;gt; IOs =&#xA;  Meters.initRateLimiter(&#xA;    rate = 10, &#xA;    period = 1.second&#xA;  )&#xA;&#xA;// &#39;pipeline&#39;: Combine multiple &#39;Meter&#39;s&#xA;val d: Meter &amp;gt; IOs =&#xA;  Meters.pipeline(a, b, c)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Meter&lt;/code&gt; class comes with a handful of methods designed to provide insights into and control over computational execution.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An example &#39;Meter&#39;&#xA;val a: Meter &amp;gt; IOs = &#xA;  Meters.initMutex&#xA;&#xA;// Get available permits&#xA;val b: Int &amp;gt; IOs =&#xA;  a.map(_.available)&#xA;&#xA;// Check for available permit&#xA;val c: Boolean &amp;gt; IOs =&#xA;  a.map(_.isAvailable)&#xA;&#xA;// Use &#39;run&#39; to execute tasks&#xA;// respecting meter limits&#xA;val d: Int &amp;gt; Fibers =&#xA;  a.map(_.run(Math.cos(42).toInt))&#xA;&#xA;// &#39;tryRun&#39; executes if a permit is&#xA;// available; returns &#39;None&#39; otherwise&#xA;val e: Option[Int] &amp;gt; IOs =&#xA;  a.map(_.tryRun(Math.cos(42).toInt))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Timers: Scheduled Execution&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Timers&lt;/code&gt; effect is designed for control over the timing of task execution.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.timers._&#xA;&#xA;// An example computation to&#xA;// be scheduled&#xA;val a: Unit &amp;gt; IOs = &#xA;  IOs(())&#xA;&#xA;// Schedule a delayed task&#xA;val b: TimerTask &amp;gt; IOs =&#xA;  Timers.schedule(delay = 1.second)(a)&#xA;&#xA;// Recurring task with&#xA;// intial delay&#xA;val c: TimerTask &amp;gt; IOs =&#xA;  Timers.scheduleAtFixedRate(&#xA;    initialDelay = 1.minute,&#xA;    period = 1.minute&#xA;  )(a)&#xA;&#xA;// Recurring task without&#xA;// initial delay&#xA;val d: TimerTask &amp;gt; IOs =&#xA;  Timers.scheduleAtFixedRate(&#xA;    period = 1.minute&#xA;  )(a)&#xA;&#xA;// Schedule with fixed delay between tasks&#xA;val e: TimerTask &amp;gt; IOs =&#xA;  Timers.scheduleWithFixedDelay(&#xA;    initialDelay = 1.minute,&#xA;    period = 1.minute&#xA;  )(a)&#xA;&#xA;// without initial delay&#xA;val f: TimerTask &amp;gt; IOs =&#xA;  Timers.scheduleWithFixedDelay(&#xA;    period = 1.minute&#xA;  )(a)&#xA;&#xA;// Specify the &#39;Timer&#39; explictly&#xA;val i: TimerTask &amp;gt; IOs =&#xA;  Timers.let(Timer.default)(f)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;TimerTask&lt;/code&gt; offers methods for more granular control over the scheduled tasks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Example TimerTask&#xA;val a: TimerTask &amp;gt; IOs = &#xA;  Timers.schedule(1.second)(())&#xA;&#xA;// Try to cancel the task&#xA;val b: Boolean &amp;gt; IOs =&#xA;  a.map(_.cancel)&#xA;&#xA;// Check if the task is cancelled&#xA;val c: Boolean &amp;gt; IOs =&#xA;  a.map(_.isCancelled)&#xA;&#xA;// Check if the task is done&#xA;val d: Boolean &amp;gt; IOs =&#xA;  a.map(_.isDone)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Latches: Fiber Coordination&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Latches&lt;/code&gt; effect serves as a coordination mechanism for fibers in a concurrent environment, primarily used for task synchronization. It provides a low-level API for controlling the flow of execution and ensuring certain tasks are completed before others, all while maintaining thread safety.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.latches._&#xA;&#xA;// Initialize a latch with &#39;n&#39; permits&#xA;val a: Latch &amp;gt; IOs = &#xA;  Latches.init(3)&#xA;&#xA;// Await until the latch releases&#xA;val b: Unit &amp;gt; Fibers =&#xA;  a.map(_.await)&#xA;&#xA;// Release a permit from the latch&#xA;val c: Unit &amp;gt; IOs =&#xA;  a.map(_.release)&#xA;&#xA;// Get the number of pending permits&#xA;val d: Int &amp;gt; IOs =&#xA;  a.map(_.pending)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Atomics: Concurrent State&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Atomics&lt;/code&gt; effect provides a set of thread-safe atomic variables to manage mutable state in a concurrent setting. Available atomic types include Int, Long, Boolean, and generic references.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.atomics._&#xA;&#xA;// Initialize atomic variables&#xA;val aInt: AtomicInt &amp;gt; IOs = &#xA;  Atomics.initInt(0)&#xA;val aLong: AtomicLong &amp;gt; IOs = &#xA;  Atomics.initLong(0L)&#xA;val aBool: AtomicBoolean &amp;gt; IOs = &#xA;  Atomics.initBoolean(false)&#xA;val aRef: AtomicRef[String] &amp;gt; IOs = &#xA;  Atomics.initRef(&#34;initial&#34;)&#xA;&#xA;// Fetch values&#xA;val b: Int &amp;gt; IOs = &#xA;  aInt.map(_.get)&#xA;val c: Long &amp;gt; IOs = &#xA;  aLong.map(_.get)&#xA;val d: Boolean &amp;gt; IOs = &#xA;  aBool.map(_.get)&#xA;val e: String &amp;gt; IOs = &#xA;  aRef.map(_.get)&#xA;&#xA;// Update values&#xA;val f: Unit &amp;gt; IOs = &#xA;  aInt.map(_.set(1))&#xA;val g: Unit &amp;gt; IOs = &#xA;  aLong.map(_.lazySet(1L))&#xA;val h: Boolean &amp;gt; IOs = &#xA;  aBool.map(_.cas(false, true))&#xA;val i: String &amp;gt; IOs = &#xA;  aRef.map(_.getAndSet(&#34;new&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Adders: Concurrent Accumulation&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Adders&lt;/code&gt; effect offers thread-safe variables for efficiently accumulating numeric values. The two primary classes, &lt;code&gt;LongAdder&lt;/code&gt; and &lt;code&gt;DoubleAdder&lt;/code&gt;, are optimized for high-throughput scenarios where multiple threads update the same counter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.adders._&#xA;&#xA;// Initialize Adders&#xA;val longAdder: LongAdder &amp;gt; IOs = &#xA;  Adders.initLong&#xA;val doubleAdder: DoubleAdder &amp;gt; IOs = &#xA;  Adders.initDouble&#xA;&#xA;// Adding values&#xA;val a: Unit &amp;gt; IOs = &#xA;  longAdder.map(_.add(10L))&#xA;val b: Unit &amp;gt; IOs = &#xA;  doubleAdder.map(_.add(10.5))&#xA;&#xA;// Increment and Decrement LongAdder&#xA;val c: Unit &amp;gt; IOs = &#xA;  longAdder.map(_.increment)&#xA;val d: Unit &amp;gt; IOs = &#xA;  longAdder.map(_.decrement)&#xA;&#xA;// Fetch summed values&#xA;val e: Long &amp;gt; IOs = &#xA;  longAdder.map(_.get)&#xA;val f: Double &amp;gt; IOs = &#xA;  doubleAdder.map(_.get)&#xA;&#xA;// Resetting the adders&#xA;val g: Unit &amp;gt; IOs = &#xA;  longAdder.map(_.reset)&#xA;val h: Unit &amp;gt; IOs = &#xA;  doubleAdder.map(_.reset)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Integrations&lt;/h2&gt; &#xA;&lt;h3&gt;Caches: Memoized Functions via Caffeine&lt;/h3&gt; &#xA;&lt;p&gt;Kyo provides caching through memoization. A single &lt;code&gt;Cache&lt;/code&gt; instance can be reused by multiple memoized functions. This allows for flexible scoping of caches, enabling users to use the same cache for various operations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.concurrent.caches._&#xA;import scala.concurrent.duration._&#xA;&#xA;val a: Int &amp;gt; (Fibers with Tries) =&#xA;  for {&#xA;&#xA;    // The initialization takes a &#xA;    // builder function that mirrors&#xA;    // Caffeine&#39;s builder&#xA;    cache &amp;lt;- Caches.init(_.maxSize(100))&#xA;&#xA;    // Create a memoized function&#xA;    fun = cache.memo { (v: String) =&amp;gt;&#xA;      // Note how the implementation&#xA;      // can use other effects&#xA;      Tries.catching(v.toInt)&#xA;    }&#xA;&#xA;    // Use the function&#xA;    v &amp;lt;- fun(&#34;10&#34;)&#xA;  } yield {&#xA;    v&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Although multiple memoized functions can reuse the same &lt;code&gt;Cache&lt;/code&gt;, each function operates as an isolated cache and doesn&#39;t share any values with others. Internally, cache entries include the instance of the function as part of the key to ensure this separation. Only the cache space is shared, allowing for efficient use of resources without compromising the independence of each function&#39;s cache.&lt;/p&gt; &#xA;&lt;h3&gt;Requests: HTTP Client via Sttp&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;Requests&lt;/code&gt; effect provides a simplified API for &lt;a href=&#34;https://github.com/softwaremill/sttp&#34;&gt;Sttp 3&lt;/a&gt; implemented on top of Kyo&#39;s concurrent package.&lt;/p&gt; &#xA;&lt;p&gt;To perform a request, use the &lt;code&gt;apply&lt;/code&gt; method. It takes a builder function based on Sttp&#39;s request building API.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import kyo.requests._&#xA;import sttp.client3._&#xA;&#xA;// Perform a request using a builder function&#xA;val a: String &amp;gt; Requests =&#xA;  Requests[String](_.get(uri&#34;https://httpbin.org/get&#34;))&#xA;&#xA;// Alternatively, requests can be &#xA;// defined separately&#xA;val b: String &amp;gt; Requests =&#xA;  Requests.request[String](Requests.basicRequest.get(uri&#34;https://httpbin.org/get&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When handling the &lt;code&gt;Requests&lt;/code&gt; effect, it&#39;s possible to use the default implementation or provide a custom &lt;code&gt;Backend&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An example request&#xA;val a: String &amp;gt; Requests =&#xA;  Requests[String](_.get(uri&#34;https://httpbin.org/get&#34;))&#xA;&#xA;// Use the default backend for &#xA;// handling the request&#xA;val b: String &amp;gt; Fibers =&#xA;  Requests.run(a)&#xA;&#xA;// Implementing a custom &#xA;// mock backend&#xA;val backend: Backend =&#xA;  new Backend {&#xA;    def send[T](r: Request[T, Any]) = {&#xA;      Response.ok(Right(&#34;mocked&#34;)).asInstanceOf[Response[T]]&#xA;    }&#xA;  }&#xA;&#xA;// Use the custom backend&#xA;val d: String &amp;gt; Fibers =&#xA;  Requests.run(backend)(a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please refer to Sttp&#39;s documentation for details on how to build requests. Streaming is currently unsupported.&lt;/p&gt; &#xA;&lt;p&gt;Users are free to use any JSON libraries supported by Sttp; however, &lt;a href=&#34;https://github.com/zio/zio-json&#34;&gt;zio-json&lt;/a&gt; is recommended, as it is used in Kyo&#39;s tests and modules requiring HTTP communication, such as &lt;code&gt;AIs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Routes: HTTP Server via Tapir&lt;/h3&gt; &#xA;&lt;p&gt;Coming soon..&lt;/p&gt; &#xA;&lt;h3&gt;AIs: LLM Abstractions via OpenAI&lt;/h3&gt; &#xA;&lt;p&gt;Coming soon..&lt;/p&gt; &#xA;&lt;h2&gt;Restrictions&lt;/h2&gt; &#xA;&lt;h3&gt;Recursive Computations&lt;/h3&gt; &#xA;&lt;p&gt;Kyo evaluates pure computations strictly, without the need for suspensions or extra memory allocations. This approach enhances performance but requires careful handling of recursive computations to maintain stack safety.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An example method that accepts&#xA;// a computation with arbitrary&#xA;// effects&#xA;def test[S](v: Int &amp;gt; S) = &#xA;  v.map(_ + 1)&#xA;&#xA;// If the input has no pending effects,&#xA;// `S` is inferred  to `Any` and the&#xA;// value is evaluated immediatelly &#xA;// to 43&#xA;val a: Int &amp;gt; Any =&#xA;  test(42)&#xA;&#xA;// Although users need to call `pure`&#xA;// to obtain an `Int`, the value is &#xA;// represented internally as `T` without &#xA;// the need for extra boxing&#xA;println(a) &#xA;// prints 43&#xA;&#xA;// But if there are pending effects,&#xA;// a suspended computation is produced&#xA;println(test(IOs(a)))&#xA;// prints kyo.ios$IOs$$anon$2@6cd8737&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Given this characteristic, recursive computations need to introduce an effect suspension, like &lt;code&gt;IOs&lt;/code&gt;, to ensure the evaluation is stack safe.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// AVOID! An unsafe recursive computation&#xA;def unsafeLoop[S](n: Int &amp;gt; S): Unit &amp;gt; S =&#xA;  n.map {&#xA;    case 0 =&amp;gt; ()&#xA;    case n =&amp;gt; unsafeLoop(n - 1)&#xA;  }&#xA;&#xA;// Introduce an effect suspension to&#xA;// ensure stack safety&#xA;def safeLoop[S](n: Int &amp;gt; S): Unit &amp;gt; (S with IOs) =&#xA;  IOs {&#xA;    n.map {&#xA;      case 0 =&amp;gt; ()&#xA;      case n =&amp;gt; safeLoop(n - 1)&#xA;    }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the &lt;code&gt;safeLoop&lt;/code&gt; function, the use of &lt;code&gt;IOs&lt;/code&gt; suspends each recursive call, preventing the stack from overflowing. This technique is essential for safely handling recursive computations in Kyo.&lt;/p&gt; &#xA;&lt;h3&gt;Nested Effects&lt;/h3&gt; &#xA;&lt;p&gt;In addition recursion, Kyo&#39;s unboxed representation of computations in certain scenarios introduces a restriction where it&#39;s not possible to handle effects of computations with nested effects like &lt;code&gt;Int &amp;gt; IOs &amp;gt; IOs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An example computation with&#xA;// nested effects&#xA;val a: Int &amp;gt; IOs &amp;gt; Options = &#xA;  Options.get(Some(IOs(1)))&#xA;&#xA;// Can&#39;t handle a effects of a&#xA;// computation with nested effects&#xA;&#xA;// Options.run(a)&#xA;// Compilation failure:&#xA;//   Method doesn&#39;t accept nested Kyo computations.&#xA;//   Detected: &#39;scala.Int &amp;gt; kyo.ios.IOs &amp;gt; kyo.options.Options&#39;. Consider using &#39;flatten&#39; to resolve.&#xA;&#xA;// Use `flatten` before handling&#xA;Options.run(a.flatten)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Kyo performs checks at compilation time to ensure that nested effects are not used. This includes generic methods where the type system cannot confirm whether the computation is nested:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// def test[T](v: T &amp;gt; Options) =&#xA;//   Options.run(v)&#xA;// Compilation failure:&#xA;//   Method doesn&#39;t accept nested Kyo computations.&#xA;//   Cannot prove &#39;T&#39; isn&#39;t nested. Provide an implicit evidence &#39;kyo.Flat[T]&#39;.&#xA;&#xA;// It&#39;s possible to provide an implicit&#xA;// evidence of `Flat` to resolve&#xA;def test[T](v: T &amp;gt; Options)(implicit f: Flat[T]) =&#xA;  Options.run(v)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All APIs that trigger effect handling have this restriction, which includes not only methods that handle effects directly but also methods that use effect handling internally. For example, &lt;code&gt;Fibers.init&lt;/code&gt; handles effects internally and doesn&#39;t allow nested effects.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// An example nested computation&#xA;val a: Int &amp;gt; IOs &amp;gt; IOs = &#xA;  IOs(IOs(1))&#xA;&#xA;// Fails to compile:&#xA;// Fibers.init(a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The compile-time checking mechanism can also be triggered in scenarios where Scala&#39;s type inference artificially introduces nesting due to a mismatch between the effects suported by a method and the provided input. In this scenario, the error message contains an additional observation regarding this possibility. For example, &lt;code&gt;Fibers.init&lt;/code&gt; only accepts computations with &lt;code&gt;Fibers&lt;/code&gt; pending.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Example computation with a&#xA;// mismatching effect (Options)&#xA;val a: Int &amp;gt; Options = &#xA;  Options.get(Some(1))&#xA;&#xA;// Fibers.init(a)&#xA;// Compilation failure:&#xA;//   Method doesn&#39;t accept nested Kyo computations.&#xA;//   Detected: &#39;scala.Int &amp;gt; kyo.options.Options &amp;gt; kyo.concurrent.fibers.Fibers&#39;. Consider using &#39;flatten&#39; to resolve. &#xA;//   Possible pending effects mismatch: Expected &#39;kyo.concurrent.fibers.Fibers&#39;, found &#39;kyo.options.Options&#39;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;Kyo&#39;s development was originally inspired by the paper &lt;a href=&#34;https://arxiv.org/pdf/1611.09259.pdf&#34;&gt;&#34;Do Be Do Be Do&#34;&lt;/a&gt; and its implementation in the &lt;a href=&#34;https://www.unison-lang.org/learn/language-reference/abilities-and-ability-handlers/&#34;&gt;Unison&lt;/a&gt; programming language. Kyo&#39;s design evolved from using interface-based effects to suspending concrete values associated with specific effects, making it more efficient when executed on the JVM.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, Kyo draws inspiration from &lt;a href=&#34;https://zio.dev/&#34;&gt;ZIO&lt;/a&gt; in various aspects. The core mechanism for algebraic effects can be seen as a generalization of ZIO&#39;s effect rotation, and many of Kyo&#39;s effects are directly influenced by ZIO&#39;s mature set of primitives. For instance, &lt;code&gt;Envs&lt;/code&gt; and &lt;code&gt;Aborts&lt;/code&gt; correspond to ZIO&#39;s effect channels, &lt;code&gt;Resources&lt;/code&gt; function similarly to &lt;code&gt;Scope&lt;/code&gt;, and &lt;code&gt;Hubs&lt;/code&gt; was introduced based on ZIO.&lt;/p&gt; &#xA;&lt;p&gt;Kyo&#39;s asynchronous primitives take several aspects from &lt;a href=&#34;https://github.com/twitter/util&#34;&gt;Twitter&#39;s util&lt;/a&gt; and &lt;a href=&#34;https://github.com/twitter/finagle&#34;&gt;Finagle&lt;/a&gt;, including features like async root compression, to provide stack safety, and support for cancellations (interruptions in Kyo).&lt;/p&gt; &#xA;&lt;p&gt;Lastly, the name &#34;Kyo&#34; is derived from the last character of Nam-myoho-renge-kyo, the mantra practiced in &lt;a href=&#34;https://www.sokaglobal.org/&#34;&gt;SGI Buddhism&lt;/a&gt;. It literally translates to &#34;Sutra,&#34; referring to a compiled teaching of Shakyamuni Buddha, and is also interpreted as the &#34;threads&#34; that weave the fundamental fabric of life&#39;s reality.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/getkyo/kyo/raw/master/LICENSE.txt&#34;&gt;LICENSE&lt;/a&gt; file for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>david-christiansen/typesearch</title>
    <updated>2023-12-17T02:02:27Z</updated>
    <id>tag:github.com,2023-12-17:/david-christiansen/typesearch</id>
    <link href="https://github.com/david-christiansen/typesearch" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>PrestaShop/docs</title>
    <updated>2023-12-17T02:02:27Z</updated>
    <id>tag:github.com,2023-12-17:/PrestaShop/docs</id>
    <link href="https://github.com/PrestaShop/docs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PrestaShop technical documentation&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PrestaShop Technical Documentation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/PrestaShop/docs/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/PrestaShop/docs/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/PrestaShop/docs/actions/workflows/update-site.yml&#34;&gt;&lt;img src=&#34;https://github.com/PrestaShop/docs/actions/workflows/update-site.yml/badge.svg?sanitize=true&#34; alt=&#34;DevDocs Site update&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This documentation is available at &lt;a href=&#34;https://devdocs.prestashop-project.org/&#34;&gt;https://devdocs.prestashop-project.org/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are more than welcome! &lt;a href=&#34;https://devdocs.prestashop-project.org/8/contribute/documentation/how/&#34;&gt;Find out how&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] This repository has specific contribution rules, please &lt;a href=&#34;https://github.com/PrestaShop/docs/raw/8.x/.github/CONTRIBUTION_PROCESS.md&#34;&gt;read them&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Rendering the site locally&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/PrestaShop/devdocs-site/&#34;&gt;https://github.com/PrestaShop/devdocs-site/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Deployment&lt;/h2&gt; &#xA;&lt;p&gt;The deployment pipeline is documented on the &lt;a href=&#34;https://github.com/PrestaShop/devdocs-site&#34;&gt;sources repository for DevDocs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Content from this documentation is licensed under the &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Maintaining Hook list referential&lt;/h2&gt; &#xA;&lt;p&gt;A complete referential of hook and informations on each hook is located in &lt;code&gt;modules/concepts/hooks/list-of-hooks/&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This referential can be generated with a script, crawling all:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PrestaShop (core) codebase&lt;/li&gt; &#xA; &lt;li&gt;all native modules&lt;/li&gt; &#xA; &lt;li&gt;all native themes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In the documentation, a hook is described in yaml format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---&#xA;Title: string #name of the hook&#xA;hidden: boolean[true] #must be true&#xA;hookTitle: string #title for the description&#xA;description: string #description sentence&#xA;origin: string #core, module or theme&#xA;files:&#xA;    -&#xA;        theme: string #theme name only if origin=theme&#xA;        module: string #module name only if origin=module&#xA;        url: string #url of the file on github&#xA;        file: string #path of the file&#xA;locations:&#xA;    - string #back office, front office or both&#xA;type: string #action or display&#xA;hookAliases:&#xA;    - string #old hook name or alias&#xA;array_return: boolean #true or false if the hook has an `$array_return` parameter set to `true`&#xA;check_exceptions: boolean #true or false if the hook has a `$check_exceptions` parameter set to `false`&#xA;chain: boolean #true or false if the hook has a `$chain` parameter set to `true` &#xA;---&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This YAML structure enables the shortcode &lt;code&gt;hookDescriptor&lt;/code&gt; to generate an HTML page with condensed information for documentation, and allows the search script to search within this metadata.&lt;/p&gt; &#xA;&lt;p&gt;Next, add the shortcode in the page&#39;s content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{{% hookDescriptor %}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, if available, add a section with a code example and parameters details:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;## Parameters details&#xA;[...]&#xA;&#xA;## Call of the Hook in the origin file&#xA;[...]&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>