<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-03T01:31:27Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Quyunshuo/AndroidBaseFrameMVVM</title>
    <updated>2024-03-03T01:31:27Z</updated>
    <id>tag:github.com,2024-03-03:/Quyunshuo/AndroidBaseFrameMVVM</id>
    <link href="https://github.com/Quyunshuo/AndroidBaseFrameMVVM" rel="alternate"></link>
    <summary type="html">&lt;p&gt;基于 Jetpack + Kotlin 的 Android 组件化 MVVM 框架&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;p align=&#34;center&#34;&gt; AndroidBaseFrameMVVM 🐽&lt;/p&gt;&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;  &lt;strong&gt;AndroidBaseFrameMVVM&lt;/strong&gt; 是一个Android工程框架，所使用技术栈为：&lt;strong&gt;组件化、Kotlin、MVVM、Jetpack、Repository、Kotlin-Coroutine-Flow&lt;/strong&gt;，本框架既是一个可以开箱即用的工程框架基础层，也是一个很好的学习资源，文档下面会对框架中所使用的一些核心技术进行阐述。该框架作为个人技术积累的产物，会一直更新维护，如果有技术方面的谈论或者框架中的错误点，可以在 &lt;strong&gt;GitHub&lt;/strong&gt; 上提 &lt;strong&gt;Issues&lt;/strong&gt;，我会及时进行回应。希望这个框架项目能给大家带来帮助，喜欢可以Start🌟。&lt;/p&gt; &#xA; &lt;p&gt;  项目地址：&lt;a href=&#34;https://github.com/Quyunshuo/AndroidBaseFrameMVVM&#34;&gt;AndroidBaseFrameMVVM&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;​ 以鸿洋大神的玩安卓开放Api做了简单的页面示例，仓库地址：&lt;a href=&#34;https://github.com/Quyunshuo/WanAndroidMVVM&#34;&gt;WanAndroidMVVM&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;框架图示&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;谷歌 Android 团队 Jetpack 视图模型：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://github.com/Quyunshuo/AndroidBaseFrameMVVM/raw/master/img/img2.png&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;模块&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;app:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;app壳&lt;/strong&gt; 工程，是依赖所有组件的壳，该模块不应该包含任何代码，它只作为一个空壳存在，由于项目中使用了EventBusAPT技术，需要索引到各业务组件的对应的APT生成类，所以在 &lt;strong&gt;app壳&lt;/strong&gt; 内有这一部分的代码。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;buildSrc:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;这是一个特殊的文件夹，负责项目的构建，里面存放着一些项目构建时用到的东西，比如项目配置，依赖。这里面还是存放 &lt;strong&gt;Gradle&lt;/strong&gt; 插件的地方，一些自定义的 &lt;strong&gt;Gradle&lt;/strong&gt; 的插件都需要放在此处。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;lib_base:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;项目的基础公共模块，存放着各种基类封装、对远程库的依赖、以及工具类、三方库封装，该组件是和项目业务无关的，和项目业务相关的公共部分需要放在 &lt;strong&gt;lib_common&lt;/strong&gt; 中。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;lib_common:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;项目的业务公共模块，这里面存放着项目里各个业务组件的公共部分，还有一些项目特定需要的一些文件等，该组件是和项目业务有关系的。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;组件化相关&lt;/h2&gt; &#xA;&lt;h3&gt;组件初始化&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;  为了更好的代码隔离与解耦，在特定组件内使用的SDK及三方库，应该只在该组件内依赖，不应该让该组件的特定SDK及三方库的API暴露给其他不需要用的组件。有一个问题就出现了，SDK及三方库常常需要手动去初始化，而且一般都需要在项目一启动（即 &lt;strong&gt;Application&lt;/strong&gt; 中）初始化，但是一个项目肯定只能有一个自定义的 &lt;strong&gt;Application&lt;/strong&gt;，该项目中的自定义 &lt;strong&gt;Application&lt;/strong&gt; 在 &lt;strong&gt;lib_base&lt;/strong&gt; 模块中，并且也是在 &lt;strong&gt;lib_base&lt;/strong&gt; 模块中的清单文件中声明的，那其他组件该如何初始化呢？带着这个问题我们一起来深入研究下。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;常见的组件初始化解决方案：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;在我的了解范围内，目前有两种最为常见的解决方案：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;面向接口编程 + 反射扫描实现类：&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;  该方案是基于接口编程，自定义 &lt;strong&gt;Application&lt;/strong&gt; 去实现一个自定义的接口（&lt;strong&gt;interface&lt;/strong&gt;），这个接口中定一些和 &lt;strong&gt;Application&lt;/strong&gt; 生命周期相对应的抽象方法及其他自定义的抽象方法，每个组件去编写一个实现类，该实现类就类似于一个假的自定义 &lt;strong&gt;Application&lt;/strong&gt;，然后在真正的自定义 &lt;strong&gt;Application&lt;/strong&gt; 中去通过反射去动态查找当前运行时环境中所有该接口的实现类，并且去进行实例化，然后将这些实现类收集到一个集合中，在 &lt;strong&gt;Application&lt;/strong&gt; 的对应声明周期方法中去逐一调用对应方法，以实现各实现类能够和 &lt;strong&gt;Application&lt;/strong&gt; 生命周期相同步，并且持有 &lt;strong&gt;Application&lt;/strong&gt; 的引用及 &lt;strong&gt;context&lt;/strong&gt; 上下文对象，这样我们就可以在组件内模拟 &lt;strong&gt;Application&lt;/strong&gt; 的生命周期并初始化SDK和三方库。使用反射还需要做一些异常的处理。该方案是我见过的最常见的方案，在一些商业项目中也见到过。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;面向接口编程 + meta-data + 反射：&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;  该方案的后半部分也是和第一种方法一样，通过接口编程实现 &lt;strong&gt;Application&lt;/strong&gt; 的生命周期同步，其实这一步是避免不了的，在我的方案中，后半部分也是这样实现的。不同的是前半部分，也就是如何找到接口的实现类，该方案使用的是 &lt;strong&gt;AndroidManifest&lt;/strong&gt; 的 &lt;strong&gt;meta-data&lt;/strong&gt; 标签，通过每个组件内的 &lt;strong&gt;AndroidManifest&lt;/strong&gt; 内去声明一个 &lt;strong&gt;meta-data&lt;/strong&gt; 标签，包含该组件实现类的信息，然后在 &lt;strong&gt;Application&lt;/strong&gt; 中去找到这些配置信息，然后通过反射去创建这些实现类的实例，再将它们收集到一个集合中，剩下的操作基本相同了。该方案和第一种方案一样都需要处理很多的异常。这种方案我在一些开源项目中见到过，个人认为过于繁琐，还要处理很多的异常。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;本项目中所使用的方案：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;面向接口编程 + Java的SPI机制（ServiceLoader）+AutoService：&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;  先来认识下 &lt;strong&gt;Java&lt;/strong&gt; 的 &lt;strong&gt;SPI&lt;/strong&gt; 机制：面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。&lt;strong&gt;JavaSPI&lt;/strong&gt; 就是提供这样的一个机制：为某个接口寻找服务实现的机制。这有点类似 &lt;strong&gt;IOC&lt;/strong&gt; 的思想，将装配的控制权移到了程序之外。这段话也是我复制的别人的，听起来很懵逼，大致意思就是我们可以通过 &lt;strong&gt;SPI&lt;/strong&gt; 机制将实现类暴露出去。关于如何使用 &lt;strong&gt;SPI&lt;/strong&gt;，这里不在陈述，总之是我们在各组件内通过 &lt;strong&gt;SPI&lt;/strong&gt; 去将实现类暴露出去，在 &lt;strong&gt;Application&lt;/strong&gt; 中我们通过 &lt;strong&gt;Java&lt;/strong&gt; 提供的 &lt;strong&gt;SPI&lt;/strong&gt; &lt;strong&gt;API&lt;/strong&gt; 去获取这些暴露的服务，这样我们就拿到了这些类的实例，剩下的步骤就和上面的方案一样了，通过一个集合遍历实现类调用其相应的方法完成初始化的工作。由于使用 &lt;strong&gt;SPI&lt;/strong&gt; 需要在每个模块创建对应的文件配置，这比较麻烦，所以我们使用 &lt;strong&gt;Google&lt;/strong&gt; 的 &lt;strong&gt;AutoService&lt;/strong&gt; 库来帮助我们自动创建这些配置文件，使用方式也非常的简单，就是在实现类添加一个 &lt;strong&gt;AutoService&lt;/strong&gt; 注解。本框架中的核心类是这几个：&lt;strong&gt;lib_base-LoadModuleProxy&lt;/strong&gt;、&lt;strong&gt;lib_base-ApplicationLifecycle&lt;/strong&gt;。这种方案是我请教的一个米哈游的大佬，这位大佬告诉我在组件化中组件的初始化可以使用 &lt;strong&gt;ServiceLoader&lt;/strong&gt; 来做，于是我就去研究了下，最后发现这种方案还不错，比前面提到的两种方案都要简单、安全。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;资源命名冲突&lt;/h3&gt; &#xA;&lt;p&gt;  在组件化方案中，资源命名冲突是一个比较严重的问题，由于在打包时会进行资源的合并，如果两个模块中有两个相同名字的文件，那么最后只会保留一份，如果不知道这个问题的小伙伴，在遇到这个问题时肯定是一脸懵逼的状态。问题既然已经出现，那我们就要去解决，解决办法就是每个组件都用固定的命名前缀，这样就不会出现两个相同的文件的现象了，我们可以在 &lt;strong&gt;build.gradle&lt;/strong&gt; 配置文件中去配置前缀限定，如果不按该前缀进行命名，&lt;strong&gt;AS&lt;/strong&gt; 就会进行警告提示，配置如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Groovy&#34;&gt;android {&#xA;    resourcePrefix &#34;前缀_&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;组件划分&lt;/h3&gt; &#xA;&lt;p&gt;  其实组件的划分一直是一个比较难的部分，这里其实也给不到一些非常适合的建议，看是看具体项目而定。&lt;/p&gt; &#xA;&lt;p&gt;  关于基础组件通常要以独立可直接复用的角度出现，比如网络模块、二维码识别模块等。&lt;/p&gt; &#xA;&lt;p&gt;  关于业务组件，业务组件一般可以进行单独调试，也就是可以作为 &lt;strong&gt;app&lt;/strong&gt; 运行，这样才能发挥组件化的一大用处，当项目越来越大，业务组件越来越多时，编译耗时将会是一个非常棘手的问题，但是如果每个业务模块都可以进行的单独调试，那就大大减少了编译时间，同时，开发人员也不需要关注其他组件。&lt;/p&gt; &#xA;&lt;p&gt;  关于公共模块，&lt;strong&gt;lib_base&lt;/strong&gt; 放一些基础性代码，属于框架基础层，不应该和项目业务有牵扯，而和项目业务相关的公共部分则应该放在 &lt;strong&gt;lib_common&lt;/strong&gt; 中，不要污染 &lt;strong&gt;lib_base&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;h3&gt;依赖版本控制&lt;/h3&gt; &#xA;&lt;p&gt;  组件化常见的一个问题就是依赖版本，每个组件都有可能自己的依赖库，那我们应该统一管理各种依赖库及其版本，使项目所有使用的依赖都是同一个版本，而不是不同版本。本项目中使用 &lt;strong&gt;buildSrc&lt;/strong&gt; 中的几个kt文件进行依赖版本统一性的管理，及其项目的一些配置。&lt;/p&gt; &#xA;&lt;h2&gt;&lt;strong&gt;MVVM相关&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;MVVM&lt;/strong&gt; 采用 &lt;strong&gt;Jetpack&lt;/strong&gt; 组件 + &lt;strong&gt;Repository&lt;/strong&gt; 设计模式 实现，所使用的 &lt;strong&gt;Jetpack&lt;/strong&gt; 并不是很多，像 &lt;strong&gt;DataBinding&lt;/strong&gt;、&lt;strong&gt;Paging 3&lt;/strong&gt;、&lt;strong&gt;Room&lt;/strong&gt; 等并没有使用，如果需要可以添加。采用架构模式目的就是为了解偶代码，对代码进行分层，各模块各司其职，所以既然使用了架构模式那就要遵守好规范。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Repository&lt;/strong&gt; 仓库层负责数据的提供，&lt;strong&gt;ViewModel&lt;/strong&gt; 无需关心数据的来源，&lt;strong&gt;Repository&lt;/strong&gt; 内避免使用 &lt;strong&gt;LiveData&lt;/strong&gt;，框架里使用了 &lt;strong&gt;Kotlin&lt;/strong&gt; 协程的 &lt;strong&gt;Flow&lt;/strong&gt; 进行处理请求或访问数据库，&lt;strong&gt;Repository&lt;/strong&gt; 的函数会返回一个 &lt;strong&gt;Flow&lt;/strong&gt; 给 &lt;strong&gt;ViewModel&lt;/strong&gt; 的调用函数，&lt;strong&gt;Flow&lt;/strong&gt; 上游负责提供数据，下游也就是 &lt;strong&gt;ViewModel&lt;/strong&gt; 获取到数据使用 &lt;strong&gt;LiveData&lt;/strong&gt; 进行存储，&lt;strong&gt;View&lt;/strong&gt; 层订阅 &lt;strong&gt;LiveData&lt;/strong&gt;，实现数据驱动视图&lt;/li&gt; &#xA; &lt;li&gt;三者的依赖都是单向依赖，&lt;strong&gt;View&lt;/strong&gt; -&amp;gt; &lt;strong&gt;ViewModel&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Repository&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;项目使用的三方库及其简单示例和资料&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JetBrains/kotlin&#34;&gt;Kotlin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JetBrains/kotlin&#34;&gt;Kotlin-Coroutines-Flow&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.android.com/jetpack/androidx/releases/lifecycle&#34;&gt;Lifecycle&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/viewmodel&#34;&gt;ViewModel&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/livedata&#34;&gt;LiveData&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.android.com/topic/libraries/view-binding&#34;&gt;ViewBinding&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.android.com/jetpack/androidx/releases/hilt&#34;&gt;Hilt&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/square/okhttp&#34;&gt;OkHttp&lt;/a&gt;：网络请求&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/square/retrofit&#34;&gt;Retrofit&lt;/a&gt;：网络请求&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/MMKV&#34;&gt;MMKV&lt;/a&gt;：腾讯基于 &lt;strong&gt;mmap&lt;/strong&gt; 内存映射的 &lt;strong&gt;key-value&lt;/strong&gt; 本地存储组件&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/coil-kt/coil&#34;&gt;Coil&lt;/a&gt;：一个 Android 图片加载库，通过 Kotlin 协程的方式加载图片&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alibaba/ARouter&#34;&gt;ARoute&lt;/a&gt;：阿里用于帮助 &lt;strong&gt;Android App&lt;/strong&gt; 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/CymChad/BaseRecyclerViewAdapterHelper&#34;&gt;BaseRecyclerViewAdapterHelper&lt;/a&gt;：一个强大并且灵活的 &lt;strong&gt;RecyclerViewAdapter&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/greenrobot/EventBus&#34;&gt;EventBus&lt;/a&gt;：适用于 &lt;strong&gt;Android&lt;/strong&gt; 和 &lt;strong&gt;Java&lt;/strong&gt; 的发布/订阅事件总线&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://bugly.qq.com/v2/index&#34;&gt;Bugly&lt;/a&gt;：腾讯异常上报及热更新(只集成了异常上报)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/guolindev/PermissionX&#34;&gt;PermissionX&lt;/a&gt;：郭霖权限请求框架&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/square/leakcanary&#34;&gt;LeakCanary&lt;/a&gt;：&lt;strong&gt;Android&lt;/strong&gt; 的内存泄漏检测库&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JessYanCoding/AndroidAutoSize&#34;&gt;AndroidAutoSize&lt;/a&gt;：&lt;strong&gt;JessYan&lt;/strong&gt; 大佬的 今日头条屏幕适配方案终极版&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Kotlin协程&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;关于 &lt;strong&gt;Kotlin 协程&lt;/strong&gt;，是真的香，具体教程可以看我的一篇文章：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/6950616789390721037&#34;&gt;万字长文 - Kotlin 协程进阶&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Flow&lt;/strong&gt; 类似于 &lt;strong&gt;RxJava&lt;/strong&gt;，它也有一系列的操作符，资料：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://juejin.im/post/6854573211930066951&#34;&gt;Google 推荐在 MVVM 架构中使用 Kotlin Flow: &lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://juejin.im/post/6854573211418361864&#34;&gt;即学即用Kotlin - 协程:&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://juejin.im/post/6844904057530908679&#34;&gt;Kotlin Coroutines Flow 系列(1-5):&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;strong&gt;PermissionX&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;PermissionX&lt;/strong&gt; 是郭霖的一个权限申请框架 &lt;strong&gt;使用方式:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PermissionX.init(this)&#xA;     .permissions(&#34;需要申请的权限&#34;)&#xA;     .request { allGranted, grantedList, deniedList -&amp;gt; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;资料:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;GitHub: &lt;a href=&#34;https://github.com/guolindev/PermissionX&#34;&gt;https://github.com/guolindev/PermissionX&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;EventBus APT&lt;/h3&gt; &#xA;&lt;p&gt;事件总线这里选择的还是 &lt;strong&gt;EventBus&lt;/strong&gt;，也有很多比较新的事件总线框架,还是选择了这个直接上手的 在框架内我对 &lt;strong&gt;EventBus&lt;/strong&gt; 进行了基类封装，自动注册和解除注册，在需要注册的类上添加 &lt;strong&gt;@EventBusRegister&lt;/strong&gt; 注解即可，无需关心内存泄漏及没及时解除注册的情况，基类里已经做了处理&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@EventBusRegister&#xA;class MainActivity : AppCompatActivity() {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;很多使用 &lt;strong&gt;EventBus&lt;/strong&gt; 的开发者其实都没有发现 &lt;strong&gt;APT&lt;/strong&gt; 的功能，这是 &lt;strong&gt;EventBus3.0&lt;/strong&gt; 的重大更新，使用 &lt;strong&gt;EventBus APT&lt;/strong&gt; 可以在编译期生成订阅类，这样就可以避免使用低效率的反射，很多人不知道这个更新，用着&lt;strong&gt;3.0&lt;/strong&gt;的版本，实际上却是&lt;strong&gt;2.0&lt;/strong&gt;的效率。 项目中已经在各模块中开启了 &lt;strong&gt;EventBus APT&lt;/strong&gt;，&lt;strong&gt;EventBus&lt;/strong&gt; 会在编译器对各模块生成订阅类，需要我们手动编写代码去注册这些订阅类：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 在APP壳的AppApplication类中&#xA;EventBus&#xA;     .builder()&#xA;&#x9; .addIndex(&#34;各模块生成的订阅类的实例 类名在base_module.gradle脚本中进行了设置 比如 module_home 生成的订阅类就是 module_homeIndex&#34;)&#xA;     .installDefaultEventBus()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;屏幕适配 AndroidAutoSize&lt;/h3&gt; &#xA;&lt;p&gt;屏幕适配使用的是 &lt;strong&gt;JessYan&lt;/strong&gt; 大佬的 今日头条屏幕适配方案终极版&lt;/p&gt; &#xA;&lt;p&gt;GitHub: &lt;a href=&#34;https://github.com/JessYanCoding/AndroidAutoSize&#34;&gt;https://github.com/JessYanCoding/AndroidAutoSize&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;使用方式:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// 在清单文件中声明&#xA;&amp;lt;manifest&amp;gt;&#xA;    &amp;lt;application&amp;gt; &#xA;    // 主单位使用dp 没设置副单位&#xA;        &amp;lt;meta-data&#xA;            android:name=&#34;design_width_in_dp&#34;&#xA;            android:value=&#34;360&#34;/&amp;gt;&#xA;        &amp;lt;meta-data&#xA;            android:name=&#34;design_height_in_dp&#34;&#xA;            android:value=&#34;640&#34;/&amp;gt;           &#xA;     &amp;lt;/application&amp;gt;           &#xA;&amp;lt;/manifest&amp;gt;&#xA;&#xA;// 默认是以竖屏的宽度为基准进行适配&#xA;// 如果是横屏项目要适配Pad(Pad适配尽量使用两套布局 因为手机和Pad屏幕宽比差距很大 无法完美适配)&#xA;&amp;lt;manifest&amp;gt;&#xA;    &amp;lt;application&amp;gt;            &#xA;    // 以高度为基准进行适配 (还需要手动代码设置以高度为基准进行适配) 目前以高度适配比宽度为基准适配 效果要好&#xA;        &amp;lt;meta-data&#xA;            android:name=&#34;design_height_in_dp&#34;&#xA;            android:value=&#34;400&#34;/&amp;gt;           &#xA;     &amp;lt;/application&amp;gt;           &#xA;&amp;lt;/manifest&amp;gt;&#xA;&#xA;// 在Application 中设置&#xA;// 屏幕适配 AndroidAutoSize 以横屏高度为基准进行适配&#xA;AutoSizeConfig.getInstance().isBaseOnWidth = false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ARoute&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;ARoute&lt;/strong&gt; 是阿里巴巴的一个用于帮助 &lt;strong&gt;Android App&lt;/strong&gt; 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;使用方式:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// 1.在需要进行路由跳转的Activity或Fragment上添加 @Route 注解&#xA;@Route(path = &#34;/test/activity&#34;)&#xA;public class YourActivity extend Activity {&#xA;    ...&#xA;}&#xA;&#xA;// 2.发起路由跳转&#xA;ARouter.getInstance()&#xA;    .build(&#34;目标路由地址&#34;)&#xA;    .navigation()&#xA;    &#xA;// 3.携带参数跳转&#xA;ARouter.getInstance()&#xA;&#x9;.build(&#34;目标路由地址&#34;)&#xA;    .withLong(&#34;key1&#34;, 666L)&#xA;    .withString(&#34;key3&#34;, &#34;888&#34;)&#xA;    .withObject(&#34;key4&#34;, new Test(&#34;Jack&#34;, &#34;Rose&#34;))&#xA;    .navigation()&#xA;&#xA;// 4.接收参数&#xA;@Route(path = RouteUrl.MainActivity2)&#xA;class MainActivity : AppCompatActivity() {&#xA;&#xA;    // 通过name来映射URL中的不同参数&#xA;    @Autowired(name = &#34;key&#34;)&#xA;    lateinit var name: String&#xA;    &#xA;&#x9;override fun onCreate(savedInstanceState: Bundle?) {&#xA;        super.onCreate(savedInstanceState)&#xA;        setContentView(mBinding.root)&#xA;        // ARouter 依赖注入 ARouter会自动对字段进行赋值，无需主动获取&#xA;        ARouter.getInstance().inject(this)&#xA;    }&#xA;}&#xA;&#xA;// 5.获取Fragment&#xA;Fragment fragment = (Fragment) ARouter.getInstance().build(&#34;/test/fragment&#34;).navigation();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;资料:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;官方文档:&lt;a href=&#34;https://github.com/alibaba/ARouter&#34;&gt;https://github.com/alibaba/ARouter&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;ViewBinding&lt;/h3&gt; &#xA;&lt;p&gt;通过视图绑定功能，可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 &lt;strong&gt;XML&lt;/strong&gt; 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 &lt;strong&gt;ID&lt;/strong&gt; 的所有视图的直接引用。 在大多数情况下，视图绑定会替代 &lt;strong&gt;findViewById&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;使用方式:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;按模块启用&lt;strong&gt;ViewBinding&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;// 模块下的build.gradle文件&#xA;android {&#xA;&#x9;// 开启ViewBinding&#xA;    // 高版本AS&#xA;    buildFeatures {&#xA;        viewBinding = true&#xA;    }&#xA;    // 低版本AS 最低3.6&#xA;    viewBinding {&#xA;        enabled = true&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Activity&lt;/strong&gt; 中 &lt;strong&gt;ViewBinding&lt;/strong&gt; 的使用&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 之前设置视图的方法&#xA;setContentView(R.layout.activity_main)&#xA;&#xA;// 使用ViewBinding后的方法&#xA;val mBinding = ActivityMainBinding.inflate(layoutInflater)&#xA;setContentView(mBinding.root)&#xA;&#xA;// ActivityMainBinding类是根据布局自动生成的 如果没有请先build一下项目&#xA;// ViewBinding会将控件id转换为小驼峰命名法,所以为了保持一致规范,在xml里声明id时也请使用小驼峰命名法&#xA;// 比如你有一个id为mText的控件,可以这样使用&#xA;mBinding.mText.text = &#34;ViewBinding&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fragment&lt;/strong&gt; 中 &lt;strong&gt;ViewBinding&lt;/strong&gt; 的使用&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// 原来的写法&#xA;return inflater.inflate(R.layout.fragment_blank, container, false)&#xA;&#xA;// 使用ViewBinding的写法&#xA;mBinding = FragmentBlankBinding.inflate(inflater)&#xA;return mBinding.root&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;资料:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;官方文档: &lt;a href=&#34;https://developer.android.com/topic/libraries/view-binding&#34;&gt;https://developer.android.com/topic/libraries/view-binding&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;CSDN: &lt;a href=&#34;https://blog.csdn.net/u010976213/article/details/104501830?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&#34;&gt;https://blog.csdn.net/u010976213/article/details/104501830?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;ViewModel&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;ViewModel&lt;/strong&gt; 类旨在以注重生命周期的方式存储和管理界面相关的数据。&lt;strong&gt;ViewModel&lt;/strong&gt; 类让数据可在发生屏幕旋转等配置更改后继续留存。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;使用方式:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel : ViewModel(){}&#xA;&#xA;class MainActivity : AppCompatActivity() {&#xA;&#x9;&#x9;// 获取无参构造的ViewModel实例&#xA;    val mViewModel = ViewModelProvider(this).get(MainViewModel::class.java)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;资料:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;官方文档: &lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/viewmodel&#34;&gt;https://developer.android.com/topic/libraries/architecture/viewmodel&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Android ViewModel，再学不会你砍我: &lt;a href=&#34;https://juejin.im/post/6844903919064186888&#34;&gt;https://juejin.im/post/6844903919064186888&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;LiveData&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;LiveData&lt;/strong&gt; 是一种可观察的数据存储器类。与常规的可观察类不同，&lt;strong&gt;LiveData&lt;/strong&gt; 具有生命周期感知能力，意指它遵循其他应用组件（如 &lt;strong&gt;Activity&lt;/strong&gt;、&lt;strong&gt;Fragment&lt;/strong&gt; 或 &lt;strong&gt;Service&lt;/strong&gt;）的生命周期。这种感知能力可确保 &lt;strong&gt;LiveData&lt;/strong&gt; 仅更新处于活跃生命周期状态的应用组件观察者&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;LiveData&lt;/strong&gt; 分为可变值的 &lt;strong&gt;MutableLiveData&lt;/strong&gt; 和不可变值的 &lt;strong&gt;LiveData&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;常用方法:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun test() {&#xA;        val liveData = MutableLiveData&amp;lt;String&amp;gt;()&#xA;        // 设置更新数据源&#xA;        liveData.value = &#34;LiveData&#34;&#xA;        // 将任务发布到主线程以设置给定值&#xA;        liveData.postValue(&#34;LiveData&#34;)&#xA;        // 获取值&#xA;        val value = liveData.value&#xA;        // 观察数据源更改(第一个参数应是owner:LifecycleOwner 比如实现了LifecycleOwner接口的Activity)&#xA;        liveData.observe(this, {&#xA;            // 数据源更改后触发的逻辑&#xA;        })&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;资料:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;官方文档: &lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/livedata&#34;&gt;https://developer.android.com/topic/libraries/architecture/livedata&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Lifecycle&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt; 是一个类，用于存储有关组件（如 &lt;strong&gt;Activity&lt;/strong&gt; 或 &lt;strong&gt;Fragment&lt;/strong&gt;）的生命周期状态的信息，并允许其他对象观察此状态。&lt;strong&gt;LifecycleOwner&lt;/strong&gt; 是单一方法接口，表示类具有 &lt;strong&gt;Lifecycle&lt;/strong&gt;。它具有一种方法（即 &lt;strong&gt;getLifecycle()&lt;/strong&gt;），该方法必须由类实现。实现 &lt;strong&gt;LifecycleObserver&lt;/strong&gt; 的组件可与实现 &lt;strong&gt;LifecycleOwner&lt;/strong&gt; 的组件无缝协同工作，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;资料:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;官方文档: &lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/lifecycle&#34;&gt;https://developer.android.com/topic/libraries/architecture/lifecycle&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Hilt&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Hilt&lt;/strong&gt; 是 &lt;strong&gt;Android&lt;/strong&gt; 的依赖项注入库，可减少在项目中执行手动依赖项注入的样板代码。执行手动依赖项注入要求您手动构造每个类及其依赖项，并借助容器重复使用和管理依赖项。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Hilt&lt;/strong&gt; 通过为项目中的每个 &lt;strong&gt;Android&lt;/strong&gt; 类提供容器并自动管理其生命周期，提供了一种在应用中使用 **DI（依赖项注入）**的标准方法。&lt;strong&gt;Hilt&lt;/strong&gt; 在热门 &lt;strong&gt;DI&lt;/strong&gt; 库 &lt;strong&gt;Dagger&lt;/strong&gt; 的基础上构建而成，因而能够受益于 &lt;strong&gt;Dagger&lt;/strong&gt; 的编译时正确性、运行时性能、可伸缩性和 &lt;strong&gt;Android Studio&lt;/strong&gt; 支持。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;资料:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;目前官方文档还没有更新正式版的，还是 &lt;strong&gt;alpha&lt;/strong&gt; 版本的文档：&lt;a href=&#34;https://developer.android.com/training/dependency-injection/hilt-android&#34;&gt;使用 Hilt 实现依赖项注入&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Dagger&lt;/strong&gt; 的 &lt;strong&gt;Hilt&lt;/strong&gt; 文档目前是最新的：&lt;a href=&#34;https://dagger.dev/hilt/&#34;&gt;Dagger-Hilt&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Coil&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Coil&lt;/strong&gt; 是一个 Android 图片加载库，通过 Kotlin 协程的方式加载图片。特点如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;更快&lt;/strong&gt;: Coil 在性能上有很多优化，包括内存缓存和磁盘缓存，把缩略图存保存在内存中，循环利用 bitmap，自动暂停和取消图片网络请求等。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;更轻量级&lt;/strong&gt;: Coil 只有2000个方法（前提是你的 APP 里面集成了 OkHttp 和 Coroutines），Coil 和 Picasso 的方法数差不多，相比 Glide 和 Fresco 要轻量很多。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;更容易使用&lt;/strong&gt;: Coil 的 API 充分利用了 Kotlin 语言的新特性，简化和减少了很多样板代码。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;更流行&lt;/strong&gt;: Coil 首选 Kotlin 语言开发并且使用包含 Coroutines, OkHttp, Okio 和 AndroidX Lifecycles 在内最流行的开源库。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Coil&lt;/strong&gt; 名字的由来：取 &lt;strong&gt;Co&lt;/strong&gt;routine &lt;strong&gt;I&lt;/strong&gt;mage &lt;strong&gt;L&lt;/strong&gt;oader 首字母得来。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;资料:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;官方文档: &lt;a href=&#34;https://coil-kt.github.io/coil/&#34;&gt;https://coil-kt.github.io/coil/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;三方库源码笔记（13）-可能是全网第一篇 Coil 的源码分析文章：&lt;a href=&#34;https://juejin.cn/post/6897872882051842061&#34;&gt;https://juejin.cn/post/6897872882051842061&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil：&lt;a href=&#34;https://juejin.cn/post/6844904159527829518&#34;&gt;https://juejin.cn/post/6844904159527829518&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>