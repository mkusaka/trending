<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-28T01:38:45Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rumboalla/apkupdater</title>
    <updated>2023-01-28T01:38:45Z</updated>
    <id>tag:github.com,2023-01-28:/rumboalla/apkupdater</id>
    <link href="https://github.com/rumboalla/apkupdater" rel="alternate"></link>
    <summary type="html">&lt;p&gt;APKUpdater is an open source tool that simplifies the process of finding updates for your installed apps.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;APKUpdater &lt;a href=&#34;https://github.com/rumboalla/apkupdater/actions?query=workflow%3A%22Android+Build%22&#34;&gt;&lt;img src=&#34;https://github.com/rumboalla/apkupdater/workflows/Android%20Build/badge.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://poeditor.com/join/project/NWTNMrPFj8&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/translation-76%25-green.svg?sanitize=true&#34; alt=&#34;translation&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;APKUpdater&lt;/strong&gt; is an open source tool that simplifies the process of &lt;strong&gt;finding updates&lt;/strong&gt; for your installed apps.&lt;br&gt; It provides similar functionality to an app store, but instead of depending on a single source, it aggregates the results from &lt;strong&gt;APKMirror&lt;/strong&gt;, &lt;strong&gt;Aptoide&lt;/strong&gt;, &lt;strong&gt;F-Droid&lt;/strong&gt; and &lt;strong&gt;Google Play&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Update Sources&lt;/strong&gt;: Find updates from &lt;strong&gt;APKMirror&lt;/strong&gt;, &lt;strong&gt;Aptoide&lt;/strong&gt;, &lt;strong&gt;F-Droid&lt;/strong&gt;, &lt;strong&gt;Google Play&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Search Sources&lt;/strong&gt;: Find new apps to install from &lt;strong&gt;APKMirror&lt;/strong&gt;, &lt;strong&gt;Aptoide&lt;/strong&gt;, &lt;strong&gt;F-Droid&lt;/strong&gt;, &lt;strong&gt;Google Play&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Schedule &lt;strong&gt;background update checks&lt;/strong&gt; and receive a &lt;strong&gt;notification&lt;/strong&gt; when updates are found.&lt;/li&gt; &#xA; &lt;li&gt;Supports &lt;strong&gt;Android 4.0.3&lt;/strong&gt; to &lt;strong&gt;Android 10&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Supports &lt;strong&gt;Android TV&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Material Design 2&lt;/strong&gt; with &lt;strong&gt;multiple theme&lt;/strong&gt; support.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Direct install&lt;/strong&gt; of updates for sources that support it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Root install&lt;/strong&gt; of updates.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Languages&lt;/strong&gt;: English, Spanish, Chinese, Turkish, Arabic, French, Indonesian, Italian, Brazilian Portuguese.&lt;/li&gt; &#xA; &lt;li&gt;App ignore list. Filter updates by architecture. Filter experimental apps. Filter apps by API level. Exclude apps installed by an App Store.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Download&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rumboalla/apkupdater/releases/download/2.0.4/app-release.apk&#34;&gt;Stable release (2.0.4)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rumboalla/apkupdater/releases&#34;&gt;Older releases&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Translations&lt;/h1&gt; &#xA;&lt;p&gt;If you want to help with translations, use &lt;a href=&#34;https://poeditor.com/join/project/NWTNMrPFj8&#34;&gt;&lt;img src=&#34;https://poeditor.com/public/images/logo_small.png&#34; alt=&#34;Translate&#34;&gt;&lt;/a&gt; or send a &lt;a href=&#34;https://github.com/rumboalla/apkupdater/pulls&#34;&gt;Pull Request&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Screenshots&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/rumboalla/apkupdater/raw/2.x/screenshots/screenshot_0001.png&#34; alt=&#34;1&#34;&gt; &lt;img src=&#34;https://github.com/rumboalla/apkupdater/raw/2.x/screenshots/screenshot_0002.png&#34; alt=&#34;2&#34;&gt; &lt;img src=&#34;https://github.com/rumboalla/apkupdater/raw/2.x/screenshots/screenshot_0003.png&#34; alt=&#34;3&#34;&gt; &lt;img src=&#34;https://github.com/rumboalla/apkupdater/raw/2.x/screenshots/screenshot_0004.png&#34; alt=&#34;4&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Other Projects&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rumboalla/coolrs&#34;&gt;CoolRs&lt;/a&gt;: A collection of Android RenderScript effecs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rumboalla/KryptoPrefs&#34;&gt;KryptoPrefs&lt;/a&gt;: Kotlin library for handling encrypted SharedPreferences.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Copyright Â© 2019 Rumboalla.&lt;br&gt; Licensed under the &lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0.en.html&#34;&gt;GNU General Public License v3&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>LibChecker/LibChecker</title>
    <updated>2023-01-28T01:38:45Z</updated>
    <id>tag:github.com,2023-01-28:/LibChecker/LibChecker</id>
    <link href="https://github.com/LibChecker/LibChecker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An app to view libraries used in apps in your device.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LibChecker&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/LibChecker/LibChecker/actions/workflows/android.yml&#34;&gt;&lt;img src=&#34;https://github.com/LibChecker/LibChecker/actions/workflows/android.yml/badge.svg?sanitize=true&#34; alt=&#34;Android CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://choosealicense.com/licenses/apache-2.0/&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/LibChecker/LibChecker?label=License&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://t.me/libcheckerr&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Telegram-Group-blue.svg?logo=telegram&#34; alt=&#34;Discussion&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crowdin.com/project/libchecker&#34;&gt;&lt;img src=&#34;https://badges.crowdin.net/libchecker/localized.svg?sanitize=true&#34; alt=&#34;Crowdin&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/LibChecker/LibChecker/master/source/header.png&#34; alt=&#34;Header&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s this?&lt;/h2&gt; &#xA;&lt;p&gt;This app is used to view the third-party libraries used by applications in your device. It can view the ABI architecture of the application&#39;s native library (in general, whether the application is 64-bit or 32-bit). It can also view well-known libraries marked by &lt;a href=&#34;https://github.com/LibChecker/LibChecker-Rules&#34;&gt;The Rule Repository&lt;/a&gt;, and can even sort and view them according to the number of libraries references.&lt;/p&gt; &#xA;&lt;h2&gt;Supported Versions&lt;/h2&gt; &#xA;&lt;p&gt;Android 7.0 ~ 13&lt;/p&gt; &#xA;&lt;p&gt;Android 6 &lt;a href=&#34;https://github.com/LibChecker/LibChecker/tree/marshmallow&#34;&gt;Marshmallow&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Document&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/LibChecker/LibChecker-Docs&#34;&gt;LibChecker-Docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.coolapk.com/apk/com.absinthe.libchecker&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/LibChecker/LibChecker/master/source/coolapk-badge.png&#34; width=&#34;323&#34; height=&#34;125&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://play.google.com/store/apps/details?id=com.absinthe.libchecker&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/LibChecker/LibChecker/master/source/google-play-badge.png&#34; width=&#34;323&#34; height=&#34;125&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://f-droid.org/packages/com.absinthe.libchecker/&#34;&gt;&lt;img src=&#34;https://fdroid.gitlab.io/artwork/badge/get-it-on.png&#34; width=&#34;323&#34; height=&#34;125&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Discussions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/LibChecker/LibChecker/discussions&#34;&gt;Github Discussions&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Telegram Group&lt;/h3&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/LibChecker/LibChecker/master/source/tg_group_dark.png#gh-dark-mode-only&#34; width=&#34;240&#34; height=&#34;240&#34;&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/LibChecker/LibChecker/master/source/tg_group_light.png#gh-light-mode-only&#34; width=&#34;240&#34; height=&#34;240&#34;&gt;</summary>
  </entry>
  <entry>
    <title>SceneView/sceneview-android</title>
    <updated>2023-01-28T01:38:45Z</updated>
    <id>tag:github.com,2023-01-28:/SceneView/sceneview-android</id>
    <link href="https://github.com/SceneView/sceneview-android" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SceneView is a 3D and AR Android Composable and View with Google Filament and ARCore. This is a Sceneform replacement in Kotlin&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SceneView Android&lt;/h1&gt; &#xA;&lt;h3&gt;3D and AR Android Composable and View with Google Filament and ARCore&lt;/h3&gt; &#xA;&lt;p&gt;This is a Sceneform replacement in Kotlin&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://search.maven.org/artifact/io.github.sceneview/sceneview&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/io.github.sceneview/sceneview.svg?label=Maven%20Central%20-%20SceneView&#34; alt=&#34;Maven Central - SceneView&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://search.maven.org/artifact/io.github.sceneview/arsceneview&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/io.github.sceneview/arsceneview.svg?label=Maven%20Central%20-%20ARSceneView&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/UbNDDBTNqb&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/893787194295222292?color=7389D8&amp;amp;label=Discord&amp;amp;logo=Discord&amp;amp;logoColor=ffffff&amp;amp;style=flat-square&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use &lt;code&gt;sceneview&lt;/code&gt; dependency for 3D only or &lt;code&gt;arsceneview&lt;/code&gt; for 3D and ARCore.&lt;/li&gt; &#xA; &lt;li&gt;Compose: Use the &lt;code&gt;Scene&lt;/code&gt; or &lt;code&gt;ARScene&lt;/code&gt; &lt;code&gt;@Composable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Layout: Add the &lt;code&gt;&amp;lt;SceneView&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;ArSceneView&amp;gt;&lt;/code&gt; tag to your layout or call the &lt;code&gt;ArSceneview(context: Context)&lt;/code&gt; constructor in your code.&lt;/li&gt; &#xA; &lt;li&gt;Requesting the camera permission and installing/updating the Google Play Services for AR is handled automatically in the &lt;code&gt;ArSceneView&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Support for the latest ARCore features (the upcoming features will be integrated quicker thanks to Kotlin).&lt;/li&gt; &#xA; &lt;li&gt;Lifecycle-aware components = Better memory management and performance.&lt;/li&gt; &#xA; &lt;li&gt;Resources are loaded using coroutines launched in the &lt;code&gt;LifecycleCoroutineScope&lt;/code&gt; of the &lt;code&gt;SceneView&lt;/code&gt;/&lt;code&gt;ArSceneView&lt;/code&gt;. This means that loading is started when the view is created and cancelled when it is destroyed.&lt;/li&gt; &#xA; &lt;li&gt;Multiple instances are now possible.&lt;/li&gt; &#xA; &lt;li&gt;Much easier to use. For example, the local and world &lt;code&gt;position&lt;/code&gt;, &lt;code&gt;rotation&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; of the &lt;code&gt;Node&lt;/code&gt; are now directly accessible without creating &lt;del&gt;&lt;code&gt;Vector3&lt;/code&gt;&lt;/del&gt; objects (&lt;code&gt;position.x = 1f&lt;/code&gt;, &lt;code&gt;rotation = Rotation(90f, 180f, 0f)&lt;/code&gt;, &lt;code&gt;scale = Scale(0.5f)&lt;/code&gt;, etc.).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=00vj8AttWO4&#34;&gt;&lt;img src=&#34;https://i3.ytimg.com/vi/00vj8AttWO4/maxresdefault.jpg&#34; alt=&#34;&#34;&gt;Youtube&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Dependency&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;app/build.gradle&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;3D (Filament included)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {&#xA;    // 3D only&#xA;    implementation &#39;io.github.sceneview:sceneview:1.0.4&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sceneview.github.io/api/sceneview-android/sceneview/&#34;&gt;API Reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;AR (Filament + ARCore included)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {&#xA;    // 3D and ARCore&#xA;    implementation &#39;io.github.sceneview:arsceneview:0.9.5&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sceneview.github.io/api/sceneview-android/arsceneview/&#34;&gt;API Reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;3D&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compose&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun ModelScreen() {&#xA;    val nodes = remember { mutableStateListOf&amp;lt;Node&amp;gt;() }&#xA;&#xA;    Box(modifier = Modifier.fillMaxSize()) {&#xA;        Scene(&#xA;            modifier = Modifier.fillMaxSize(),&#xA;            nodes = nodes,&#xA;            onCreate = { sceneView -&amp;gt;&#xA;                // Apply your configuration&#xA;            }&#xA;        )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Layout&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;io.github.sceneview.SceneView&#xA;    android:id=&#34;@+id/sceneView&#34;&#xA;    android:layout_width=&#34;match_parent&#34;&#xA;    android:layout_height=&#34;match_parent&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;AR&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compose&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun ARScreen() {&#xA;    val nodes = remember { mutableStateListOf&amp;lt;ArNode&amp;gt;() }&#xA;&#xA;    Box(modifier = Modifier.fillMaxSize()) {&#xA;        ARScene(&#xA;            modifier = Modifier.fillMaxSize(),&#xA;            nodes = nodes,&#xA;            planeRenderer = true,&#xA;            onCreate = { arSceneView -&amp;gt;&#xA;              // Apply your configuration&#xA;            },&#xA;            onSessionCreate = { session -&amp;gt;&#xA;              // Configure the ARCore session&#xA;            },&#xA;            onFrame = { arFrame -&amp;gt;&#xA;              // Retrieve ARCore frame update&#xA;            },&#xA;            onTap = { hitResult -&amp;gt;&#xA;              // User tapped in the AR view&#xA;            }&#xA;        )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Layout&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;io.github.sceneview.ar.ArSceneView&#xA;    android:id=&#34;@+id/sceneView&#34;&#xA;    android:layout_width=&#34;match_parent&#34;&#xA;    android:layout_height=&#34;match_parent&#34; /&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;3D Model Viewer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=GDCy_bUdggg&#34;&gt;&lt;img src=&#34;https://i3.ytimg.com/vi/GDCy_bUdggg/maxresdefault.jpg&#34; alt=&#34;&#34;&gt;Youtube&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;ModelNode(&#xA;    position = Position(x = 0.0f, y = 0.0f, z = -4.0f),&#xA;    rotation = Rotation(y = 90.0f),&#xA;    scale = Scale(0.5f)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Parameters&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;position&lt;/code&gt; The node position to locate it within the coordinate system of its parent&lt;br&gt; Default is &lt;code&gt;Position(x = 0.0f, y = 0.0f, z = 0.0f)&lt;/code&gt;, indicating that the node is placed at the origin of the parent node&#39;s coordinate system.&lt;br&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/6597529/175493300-c1ff1647-8ab1-4c71-b938-4b04acf2c702.png&#34; alt=&#34;image&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rotation&lt;/code&gt; The node orientation in Euler Angles Degrees per axis from &lt;code&gt;0.0f&lt;/code&gt; to &lt;code&gt;360.0f&lt;/code&gt; The three-component rotation vector specifies the direction of the rotation axis in degrees. Rotation is applied relative to the node&#39;s origin property.&lt;br&gt; Default is &lt;code&gt;Rotation(x = 0.0f, y = 0.0f, z = 0.0f)&lt;/code&gt;, specifying no rotation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scale&lt;/code&gt; The node scale on each axis&lt;br&gt; Reduce (&lt;code&gt;scale &amp;lt; 1.0f&lt;/code&gt;) / Increase (&lt;code&gt;scale &amp;gt; 1.0f&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;AR Model Viewer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=HVqAvGJROWk&#34;&gt;&lt;img src=&#34;https://i3.ytimg.com/vi/HVqAvGJROWk/maxresdefault.jpg&#34; alt=&#34;&#34;&gt;Youtube&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;ArModelNode(&#xA;    placementMode = PlacementMode.BEST_AVAILABLE, &#xA;    hitPosition = Position(0.0f, 0.0f, -2.0f),&#xA;    followHitPosition = true,&#xA;    instantAnchor = false&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Parameters&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;placementMode&lt;/code&gt; Define the &lt;a href=&#34;https://raw.githubusercontent.com/SceneView/sceneview-android/main/#ar-placement-mode&#34;&gt;AR Placement Mode&lt;/a&gt; depending on your need&lt;br&gt; You can change it to adjust between a quick (&lt;code&gt;PlacementMode.INSTANT&lt;/code&gt;), more accurate (&lt;code&gt;PlacementMode.DEPTH&lt;/code&gt;), only on planes/walls (&lt;code&gt;PlacementMode.PLANE_HORIZONTAL&lt;/code&gt;, &lt;code&gt;PlacementMode.PLANE_VERTICAL&lt;/code&gt;, &lt;code&gt;PlacementMode.PLANE_HORIZONTAL_AND_VERTICAL&lt;/code&gt;) or with auto refining accuracy placement (&lt;code&gt;PlacementMode.BEST_AVAILABLE&lt;/code&gt;).&lt;br&gt; The &lt;code&gt;hitTest&lt;/code&gt;, &lt;code&gt;pose&lt;/code&gt; and &lt;code&gt;anchor&lt;/code&gt; will be influenced by this choice.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hitPosition&lt;/code&gt; The node camera/screen/view position where the hit will be made to find an AR position&lt;br&gt; Until it is anchored, the &lt;code&gt;Node&lt;/code&gt; will try to find the real world position/orientation of the screen coordinate and constantly place/orientate himself accordingly &lt;code&gt;followHitPosition&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.&lt;br&gt; The Z value is only used when no surface is actually detected or when &lt;code&gt;followHitPosition&lt;/code&gt; and &lt;code&gt;instantAnchor&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; or when instant placement is enabled.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;followHitPosition&lt;/code&gt; Make the node follow the camera/screen matching real world positions&lt;br&gt; Controls if an unanchored node should be moved together with the camera.&lt;br&gt; The node &lt;code&gt;position&lt;/code&gt; is updated with the realtime ARCore &lt;code&gt;pose&lt;/code&gt; at the corresponding &lt;code&gt;hitPosition&lt;/code&gt; until it is anchored (&lt;code&gt;isAnchored&lt;/code&gt;) or until this this value is set to &lt;code&gt;false&lt;/code&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;While there is no AR tracking information available, the node is following the camera moves so it stays at this camera/screen relative position but without adjusting its position and orientation to the real world&lt;/li&gt; &#xA;   &lt;li&gt;Then ARCore will try to find the real world position of the node at the &lt;code&gt;hitPosition&lt;/code&gt; by looking at its &lt;code&gt;hitTest&lt;/code&gt; on each &lt;code&gt;onArFrame&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;In case of instant placement disabled, the z position (distance from the camera) will be estimated by the AR surface distance at the &lt;code&gt;(x,y)&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;The node rotation will be also adjusted in case of &lt;code&gt;PlacementMode.DEPTH&lt;/code&gt; or depending on the detected planes orientations in case of &lt;code&gt;PlacementMode.PLANE_HORIZONTAL&lt;/code&gt;, &lt;code&gt;PlacementMode.PLANE_VERTICAL&lt;/code&gt;, &lt;code&gt;PlacementMode.PLANE_HORIZONTAL_AND_VERTICAL&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;instantAnchor&lt;/code&gt; Anchor the node as soon as an AR position/rotation is found/available&lt;br&gt; If &lt;code&gt;true&lt;/code&gt;, the node will be anchored in the real world at the first suitable place available&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;AR Placement Mode&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=rxzLfTCsm_o&#34;&gt;&lt;img src=&#34;https://i3.ytimg.com/vi/rxzLfTCsm_o/maxresdefault.jpg&#34; alt=&#34;&#34;&gt;Youtube&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Choose how an object is placed within the real world&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;DISABLED&lt;/code&gt; Disable every AR placement preview and handle it by yourself (&lt;code&gt;onTap&lt;/code&gt;, &lt;code&gt;onAugmentedFace&lt;/code&gt;, &lt;code&gt;onAugmentedImage&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PLANE_HORIZONTAL&lt;/code&gt; Place and orientate nodes only on horizontal planes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PLANE_VERTICAL&lt;/code&gt; Place and orientate nodes only on vertical planes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PLANE_HORIZONTAL_AND_VERTICAL&lt;/code&gt; Place and orientate nodes on both horizontal and vertical planes&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DEPTH&lt;/code&gt; Place and orientate nodes on every detected depth surfaces. Not all devices support this mode. In case on non depth enabled device the placement mode will automatically fallback to &lt;code&gt;PLANE_HORIZONTAL_AND_VERTICAL&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;INSTANT&lt;/code&gt; Instantly place only nodes at a fixed orientation and an approximate distance. No AR orientation will be provided = fixed +Y pointing upward, against gravity. This mode is currently intended to be used with hit tests against horizontal surfaces.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BEST_AVAILABLE&lt;/code&gt; Place nodes on every detected surfaces. The node will be placed instantly and then adjusted to fit the best accurate, precise, available placement.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Parameters&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;instantPlacementDistance&lt;/code&gt; Distance in meters at which to create an InstantPlacementPoint. This is only used while the tracking method for the returned point is InstantPlacementPoint.&lt;br&gt; Default: &lt;code&gt;2.0f&lt;/code&gt; (2 meters)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;instantPlacementFallback&lt;/code&gt; Fallback to instantly place nodes at a fixed orientation and an approximate distance when the base placement type is not available yet or at all.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Load a glb/glTF Model&lt;/h2&gt; &#xA;&lt;h3&gt;Asynchronously&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;modelNode.loadModelAsync(&#xA;    context = context,&#xA;    lifecycle = lifecycle,&#xA;    glbFileLocation = &#34;models/mymodel.glb&#34;,&#xA;    autoAnimate = true,&#xA;    autoScale = false,&#xA;    centerOrigin = null,&#xA;    onError = { exception -&amp;gt; },&#xA;    onLoaded = { modelInstance -&amp;gt; }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Within a Coroutine Scope&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;lifecycleScope.launchWhenCreated {&#xA;    val modelInstance = modelNode.loadModel(&#xA;        context = context,&#xA;        glbFileLocation = &#34;https://sceneview.github.io/assets/models/MaterialSuite.glb&#34;,&#xA;        autoAnimate = true,&#xA;        autoScale = true,&#xA;        centerOrigin = Position(x = 0.0f, y = 0.0f, z = 0.0f),&#xA;        onError = { exception -&amp;gt; }&#xA;    )&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Parameters&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;lifecycle&lt;/code&gt; Provide your lifecycle in order to load your model instantly and to destroy it (and its resources) when the lifecycle goes to destroy state&lt;br&gt; Passing &lt;code&gt;null&lt;/code&gt; means the model loading will be done when the &lt;code&gt;Node&lt;/code&gt; is added to the &lt;code&gt;SceneView&lt;/code&gt; and the destroy will be done when the &lt;code&gt;SceneView&lt;/code&gt; is detached.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;modelFileLocation&lt;/code&gt; The model glb/gltf file location &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A relative asset file location (models/mymodel.glb)&lt;/li&gt; &#xA;   &lt;li&gt;An Android resource from the res folder (context.getResourceUri(R.raw.mymodel)&lt;/li&gt; &#xA;   &lt;li&gt;A File path (Uri.fromFile(myModelFile).path)&lt;/li&gt; &#xA;   &lt;li&gt;An http or https url (&lt;a href=&#34;https://mydomain.com/mymodel.glb&#34;&gt;https://mydomain.com/mymodel.glb&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;autoAnimate&lt;/code&gt; Plays the animations automatically if the model has one&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;autoScale&lt;/code&gt; Scale the model to fit a unit cube so it will better fit your SceneView&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;centerOrigin&lt;/code&gt; Center point origin position within the model&lt;br&gt; Float cube position values between -1.0 and 1.0 corresponding to percents from model sizes. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;null&lt;/code&gt; = Keep the origin point where it was at the model export time&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Position(x = 0.0f, y = 0.0f, z = 0.0f)&lt;/code&gt; = Center the model horizontally and vertically&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Position(x = 0.0f, y = -1.0f, z = 0.0f)&lt;/code&gt; = center horizontal | bottom&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Position(x = -1.0f, y = 1.0f, z = 0.0f)&lt;/code&gt; = left | top&lt;/li&gt; &#xA;   &lt;li&gt;...&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;onError&lt;/code&gt; An exception has been thrown during model loading&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;AR Cloud Anchors&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=iptk8jsWyw4&#34;&gt;&lt;img src=&#34;https://i3.ytimg.com/vi/iptk8jsWyw4/maxresdefault.jpg&#34; alt=&#34;&#34;&gt;Youtube&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Gebort/FESTU.Navigator&#34;&gt;Sources&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;&#xA;sceneView.cloudAnchorEnabled = true&#xA;&#xA;// Host/Record a Cloud Anchor&#xA;node.onAnchorChanged = { node: ArNode, anchor: Anchor? -&amp;gt;&#xA;    if(anchor != null) {&#xA;        node.hostCloudAnchor { anchor: Anchor, success: Boolean -&amp;gt;&#xA;            if (success) {&#xA;                // Save the hosted Cloud Anchor Id&#xA;                val cloudAnchorId = anchor.cloudAnchorId&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;// Resolve/Restore the Cloud Anchor&#xA;node.resolveCloudAnchor(cloudAnchorId) { anchor: Anchor, success: Boolean -&amp;gt;&#xA;    if (success) {&#xA;        node.isVisible = true&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;AR Depth/Objects Occlusion&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=bzyoR3ugGFA&#34;&gt;&lt;img src=&#34;https://i3.ytimg.com/vi/bzyoR3ugGFA/maxresdefault.jpg&#34; alt=&#34;&#34;&gt;Youtube&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;sceneView.isDepthOcclusionEnabled = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will process the incoming ARCore &lt;code&gt;DepthImage&lt;/code&gt; to occlude virtual objects behind real world objects.&lt;br&gt; If the AR &lt;code&gt;Session&lt;/code&gt; is not configured properly the standard camera material is used.&lt;br&gt; Valid &lt;code&gt;Session.Config&lt;/code&gt; for the Depth occlusion are &lt;code&gt;Config.DepthMode.AUTOMATIC&lt;/code&gt; and &lt;code&gt;Config.DepthMode.RAW_DEPTH_ONLY&lt;/code&gt;&lt;br&gt; Disable this value to apply the standard camera material to the CameraStream.&lt;/p&gt; &#xA;&lt;h2&gt;AR Geospatial API&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=QZYg9WU5wSA&#34;&gt;&lt;img src=&#34;https://i3.ytimg.com/vi/QZYg9WU5wSA/maxresdefault.jpg&#34; alt=&#34;&#34;&gt;Youtube&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Follow the &lt;a href=&#34;https://developers.google.com/ar/develop/java/geospatial/developer-guide&#34;&gt;official developer guide&lt;/a&gt; to enable Geospatial in your application. For configuring the ARCore session, you just need to enable Geospatial via ArSceneView.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Enable Geospatial via ArSceneView&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;arSceneView.geospatialEnabled = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create an Anchor&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val earth = arSceneView.session?.earth ?: return&#xA;if (earth.trackingState == TrackingState.TRACKING) {&#xA;    // Place the earth anchor at the same altitude as that of the camera to make it easier to view.&#xA;    val altitude = earth.cameraGeospatialPose.altitudeMeters - 1&#xA;    val rotation = Rotation(0f, 0f, 0f)&#xA;    // Put the anchor somewhere around the user.&#xA;    val latitude = earth.cameraGeospatialPose.latitude + 0.0004&#xA;    val longitude = earth.cameraGeospatialPose.longitude + 0.0004&#xA;    earthAnchor = earth.createAnchor(latitude, longitude, altitude, rotation)&#xA;}&#xA;// Attach the anchor to the arModelNode.&#xA;arModelNode.anchor = earthAnchor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Camera Permission and ARCore install/update/unavailable&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ArSceneView&lt;/code&gt; automatically handles the camera permission prompt and the ARCore requirements checks. Everything is proceed when the attached view Activity/Fragment is resumed but you can also add your &lt;code&gt;ArSceneView&lt;/code&gt; at any time, the prompt will then occure when first &lt;code&gt;addView(arSceneView)&lt;/code&gt; is called.&lt;/p&gt; &#xA;&lt;p&gt;If you need it, you can add a listener on both ARCore success or failed session creation (including camera permission denied since a session cannot be created without it)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Camera permission has been granted and latest ARCore Services version are already installed or have been installed during the auto check&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;sceneView.onArSessionCreated = { arSession: ArSession -&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Handle a fallback in case of camera permission denied or AR unavailable and possibly move to 3D only usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;sceneView.onArSessionFailed = { exception: Exception -&amp;gt;&#xA;    // If AR is not available, we add the model directly to the scene for a 3D only usage&#xA;    sceneView.addChild(modelNode)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The exception contains the failure reason. &lt;em&gt;e.g. SecurityException in case of camera permission denied&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Customizing the instructions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The default instruction nodes have a &lt;code&gt;ViewRenderable&lt;/code&gt; with a &lt;code&gt;TextView&lt;/code&gt; or &lt;code&gt;ImageView&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;The text and images of the instruction nodes can be overridden at the resource level (in the &lt;code&gt;strings.xml&lt;/code&gt; file and &lt;code&gt;drawable&lt;/code&gt; directory of your project).&lt;/li&gt; &#xA; &lt;li&gt;Custom instruction nodes can have an arbitrary number of child nodes with &lt;code&gt;ModelRenderable&lt;/code&gt;s and &lt;code&gt;ViewRenderable&lt;/code&gt;s. It is even possible to play animation for a &lt;code&gt;ModelRenderable&lt;/code&gt; if it is defined in a &lt;code&gt;.glb&lt;/code&gt; file or a video using the &lt;code&gt;VideoNode&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;infoNode&lt;/code&gt; can have one of the following values depending on the ARCore features used and the current ARCore state: &lt;code&gt;searchPlaneInfoNode&lt;/code&gt;, &lt;code&gt;tapArPlaneInfoNode&lt;/code&gt; and &lt;code&gt;augmentedImageInfoNode&lt;/code&gt;. Alternatively, it is possible to create your own instruction nodes.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;SearchPlaneInfoNode&lt;/code&gt; displays messages related to the ARCore state. For example, &lt;code&gt;Searching for surfaces...&lt;/code&gt;, &lt;code&gt;Too dark. Try moving to a well-lit area&lt;/code&gt;, &lt;code&gt;Moving too fast. Slow down&lt;/code&gt;, etc.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;TapArPlaneInfoNode&lt;/code&gt; displays a message that helps users to understand how an object can be placed in AR when no objects are currently present in the scene.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;AugmentedImageInfoNode&lt;/code&gt; displays a frame with white corners when no augmented image is currently tracked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;span&gt;ðŸ’¡&lt;/span&gt; &lt;strong&gt;Idea for future:&lt;/strong&gt; when access to the flashlight is finally available with the ARCore shared &lt;code&gt;CameraManager&lt;/code&gt;, it will be great to add a button to the &lt;code&gt;SearchPlaneInfoNode&lt;/code&gt; to enable the flashlight when there isn&#39;t enough light.&lt;/p&gt; &#xA;&lt;h2&gt;Why have we included the Kotlin-Math library in SceneView?&lt;/h2&gt; &#xA;&lt;p&gt;Earlier versions of OpenGL had a fixed rendering pipeline and provided an API for setting positions of vertices, transformation and projection matrices, etc. However, with the new rendering pipeline it is required to prepare this data before passing it to GLSL shaders and OpenGL doesn&#39;t provide any mathematical functions to do that.&lt;/p&gt; &#xA;&lt;p&gt;It is possible to implement the required functions yourself like in &lt;a href=&#34;https://github.com/SceneView/sceneform-android&#34;&gt;Sceneform&lt;/a&gt; or use an existing library. For example, C++ supports operator overloading and benefits from the excellent &lt;a href=&#34;https://glm.g-truc.net/0.9.9/&#34;&gt;GLM library&lt;/a&gt; that allows to use the same syntax and features as GLSL.&lt;/p&gt; &#xA;&lt;p&gt;We use the &lt;a href=&#34;https://github.com/romainguy/kotlin-math&#34;&gt;Kotlin-Math library&lt;/a&gt; to rely on a well-tested functions and get an advantage of using Kotlin operators for vector, matrix and quaternion operations too.&lt;/p&gt; &#xA;&lt;h2&gt;Migration from Sceneform&lt;/h2&gt; &#xA;&lt;p&gt;You will have a little work to do if you are using the &lt;code&gt;ArFragment&lt;/code&gt; in Sceneform. However, there is the &lt;a href=&#34;https://github.com/SceneView/sceneview-android/raw/main/arsceneview/src/main/kotlin/io/github/sceneview/ar/Deprecated.kt&#34;&gt;Deprecated.kt&lt;/a&gt; file to help you with the migration.&lt;/p&gt; &#xA;&lt;h4&gt;Using the migration suggestions&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Remove the Sceneform import for the class you want to migrate.&lt;/li&gt; &#xA; &lt;li&gt;Import this class from the &lt;code&gt;io.github.sceneview.ar&lt;/code&gt; package.&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;Alt+Enter&lt;/code&gt;/the light bulb icon to view and apply the suggestions for replacing the deprecated method calls.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;After the migration you should get cleaner code and all of the benefits described in the &lt;a href=&#34;https://raw.githubusercontent.com/SceneView/sceneview-android/main/#Features&#34;&gt;Features&lt;/a&gt; section &lt;span&gt;ðŸŽ‰&lt;/span&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Requesting the camera permission and installing/updating the Google Play Services for AR&lt;/h4&gt; &#xA;&lt;p&gt;This is handled automatically in the &lt;code&gt;ArSceneView&lt;/code&gt;. You can use the &lt;code&gt;ArSceneView.onArSessionFailed&lt;/code&gt; property to register a callback to be invoked when the ARCore Session cannot be initialized because ARCore is not available on the device or the camera permission has been denied.&lt;/p&gt; &#xA;&lt;h4&gt;Instructions for AR&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;InstructionsController&lt;/code&gt; in the &lt;code&gt;BaseArFragment&lt;/code&gt; has been replaced with the &lt;code&gt;Instructions&lt;/code&gt; in the &lt;code&gt;ArSceneView&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Instructions&lt;/code&gt; use a &lt;code&gt;Node&lt;/code&gt; that is a part of the scene instead of a &lt;code&gt;View&lt;/code&gt;, as opposed to the &lt;code&gt;InstructionsController&lt;/code&gt;. This provides more flexibility for customizing the instructions. The &lt;code&gt;Instructions&lt;/code&gt; have the main &lt;code&gt;Node&lt;/code&gt; that can be accessed through the &lt;code&gt;Instructions.infoNode&lt;/code&gt; property.&lt;/p&gt;</summary>
  </entry>
</feed>