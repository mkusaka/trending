<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-12T01:40:42Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Kotlin/kmm-production-sample</title>
    <updated>2023-06-12T01:40:42Z</updated>
    <id>tag:github.com,2023-06-12:/Kotlin/kmm-production-sample</id>
    <link href="https://github.com/Kotlin/kmm-production-sample" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This is an open-source, mobile, cross-platform application built with Kotlin Multiplatform Mobile. It&#39;s a simple RSS reader, and you can download it from the App Store and Google Play. It&#39;s been designed to demonstrate how KMM can be used in real production projects.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;KMM RSS Reader&lt;/h1&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Kotlin/kmm-production-sample/master/media/ios+android.png&#34;&gt; &#xA;&lt;p&gt;This is an open-source, mobile, cross-platform application built with &lt;a href=&#34;https://kotlinlang.org/lp/mobile/&#34;&gt;Kotlin Multiplatform Mobile&lt;/a&gt;. It&#39;s a simple RSS reader, and you can download it from the &lt;a href=&#34;https://apps.apple.com/ru/app/kmm-rss-reader/id1563922264&#34;&gt;App Store&lt;/a&gt; and &lt;a href=&#34;https://play.google.com/store/apps/details?id=com.github.jetbrains.rssreader.androidApp&#34;&gt;Google Play&lt;/a&gt;. It&#39;s been designed to demonstrate how KMM can be used in real production projects.&lt;/p&gt; &#xA;&lt;h2&gt;Compose multiplatform experiment&lt;/h2&gt; &#xA;&lt;p&gt;iOS and Desktop clients were implemented as experimental features and can be viewed &lt;a href=&#34;https://github.com/Kotlin/kmm-production-sample/tree/compose-app&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Kotlin/kmm-production-sample/master/media/Android+iOS+Desktop.png&#34;&gt; &#xA;&lt;h2&gt;Desktop and Web experiment&lt;/h2&gt; &#xA;&lt;p&gt;Desktop and Web clients were implemented as experimental features and can be viewed &lt;a href=&#34;https://github.com/Kotlin/kmm-production-sample/tree/c6a0d9182802490d17729ae634fb59268f68a447&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Kotlin/kmm-production-sample/master/media/desktop+web.png&#34;&gt; &#xA;&lt;h2&gt;Project structure&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains a common Kotlin Multiplatform module, a Android project and an iOS project. The common module is connected with the Android project via the Gradle multi-project mechanism. For use in iOS applications, the shared module compiles into a framework that is exposed to the Xcode project via the internal integration Gradle task. This framework connects to the Xcode project that builds an iOS application.&lt;/p&gt; &#xA;&lt;p&gt;You can achieve the same structure by creating a project with the &lt;a href=&#34;https://plugins.jetbrains.com/plugin/14936-kotlin-multiplatform-mobile&#34;&gt;KMM Plugin project wizard&lt;/a&gt; or cloning the &lt;a href=&#34;https://github.com/Kotlin/kmm-sample/&#34;&gt;basic sample project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Kotlin/kmm-production-sample/master/media/basic-structure.png&#34;&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;p&gt;Kotlin Multiplatform Mobile is a flexible technology that allows you to share only what you want to share, from the core layer to UI layers.&lt;/p&gt; &#xA;&lt;p&gt;This sample demonstrates sharing not only the data and domain layers of the app but also the application state:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Kotlin/kmm-production-sample/master/media/top-level-arch.jpeg&#34;&gt; &#xA;&lt;h3&gt;Shared data and domain layers&lt;/h3&gt; &#xA;&lt;p&gt;There are two types of data sources. The network service is for getting RSS feed updates, while local storage is for caching the feed, which makes it possible to use the application offline. &lt;a href=&#34;https://ktor.io/docs/client.html&#34;&gt;Ktor HTTP Client&lt;/a&gt; is used for making API requests. &lt;a href=&#34;https://github.com/Kotlin/kotlinx.serialization&#34;&gt;Kotlinx.serialization&lt;/a&gt; is used to serialize feed data and store it locally with &lt;a href=&#34;https://github.com/russhwolf/multiplatform-settings&#34;&gt;MultiplaformSettings&lt;/a&gt;. This logic is organized in the shared module of the &lt;code&gt;com.github.jetbrains.rssreader.core&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;h3&gt;Shared application state&lt;/h3&gt; &#xA;&lt;p&gt;The Redux pattern is used for managing the application state. The simplified Redux architecture is implemented in the shared module. The &lt;code&gt;Store&lt;/code&gt; class dispatches the &lt;strong&gt;actions&lt;/strong&gt; that can be produced either by a user or by some async work, and generates the new state. It stores the actual &lt;strong&gt;state&lt;/strong&gt; and facilitates subscription to state updates via Kotlin&#39;s &lt;code&gt;StateFlow&lt;/code&gt;. To provide additional information about state updates, the &lt;code&gt;Store&lt;/code&gt; class also produces &lt;strong&gt;effects&lt;/strong&gt; that, for example, can be used to display this information via alerts. This logic is organized in the shared KMM module of the &lt;code&gt;com.github.jetbrains.rssreader.app&lt;/code&gt; package.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Kotlin/kmm-production-sample/master/media/arch-details.jpg&#34;&gt; &#xA;&lt;h3&gt;Native UI&lt;/h3&gt; &#xA;&lt;p&gt;The UI layer is fully native and implemented using SwiftUI for iOS, Jetpack Compose for Android, Compose Multiplatform for Desktop and React.js for web browser.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;On the iOS side,&lt;/strong&gt; the &lt;code&gt;Store&lt;/code&gt; from the KMM library is wrapped into the &lt;code&gt;ObservableObject&lt;/code&gt; and implements the state as a &lt;code&gt;@Published&lt;/code&gt; wrapped property. This publishes changes whenever a dispatched action produces a new state after being reduced in the shared module. The store is injected as an &lt;code&gt;Environment Object&lt;/code&gt; into the root view of the application, and is easily accessible from anywhere in the application. SwiftUI performs all aspects of diffing on the render pass when your state changes.&lt;/p&gt; &#xA;&lt;p&gt;For subscribing to state updates, &lt;a href=&#34;https://github.com/Kotlin/kmm-production-sample/raw/master/shared/src/iosMain/kotlin/com/github/jetbrains/rssreader/core/CFlow.kt&#34;&gt;the simple wrapper&lt;/a&gt; is used. This wrapper allows you to provide a callback that will be called when each new value (the state in our case) is emitted.&lt;/p&gt; &#xA;&lt;h2&gt;Multiplatform features used&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;✅ Platform-specific API usage.&lt;/strong&gt; RSS feeds usually only support the XML format. The &lt;code&gt;kotlinx.serialization&lt;/code&gt; library currently doesn&#39;t support parsing XML data, but there is no need to implement your own parser. Instead, platform libraries (&lt;code&gt;XmlPullParser&lt;/code&gt; for Android and &lt;code&gt;NSXMLParser&lt;/code&gt; for iOS) are used. The common &lt;code&gt;FeedParser&lt;/code&gt; interface is declared in the &lt;code&gt;commonMain&lt;/code&gt; source set. Platform implementations are placed in the corresponding &lt;code&gt;iOSMain&lt;/code&gt; and &lt;code&gt;AndroidMain&lt;/code&gt; source sets. They are injected into the RSSReader class (the KMM module entry point) via the &lt;code&gt;create&lt;/code&gt; factory method, which is declared in the &lt;a href=&#34;https://github.com/Kotlin/kmm-production-sample/raw/master/shared/src/androidMain/kotlin/com/github/jetbrains/rssreader/core/RssReader.kt&#34;&gt;RSSReader class companion object&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ANSSI-FR/cry-me</title>
    <updated>2023-06-12T01:40:42Z</updated>
    <id>tag:github.com,2023-06-12:/ANSSI-FR/cry-me</id>
    <link href="https://github.com/ANSSI-FR/cry-me" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CRY.ME (CRYptographic MEssaging application)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CRY.ME - A Flawed Messaging Application for Educational Purposes&lt;/h1&gt; &#xA;&lt;h2&gt;The CRY.ME project&lt;/h2&gt; &#xA;&lt;p&gt;The CRY.ME project consists in a secure messaging application based on the Matrix protocol containing many cryptographic vulnerabilities deliberately introduced for educational purposes. The CRY.ME application has been specified and developped by ANSSI and CryptoExperts to provide a practical security challenge especially targeting cryptography.&lt;/p&gt; &#xA;&lt;p&gt;The application presents many different classes of vulnerabilities to identify and, whenever possible, to exploit. The scope of the vulnerabilities introduced in the CRY.ME covers many of the classical domains of cryptography.&lt;/p&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;All the code and documentation associated with CRY.ME are &lt;strong&gt;flawed&lt;/strong&gt; and have been made specifically in the context of challenging cryptographic competencies.&lt;/p&gt; &#xA;&lt;p&gt;It &lt;strong&gt;MUST NOT BE USED&lt;/strong&gt; in any context other than educational purposes. We deny any responsability when using CRY.ME as a messaging application, or any part of the CRY.ME source code, in other contexts.&lt;/p&gt; &#xA;&lt;h2&gt;Authors&lt;/h2&gt; &#xA;&lt;p&gt;The authors of CRY.ME are from ANSSI and CryptoExperts.&lt;/p&gt; &#xA;&lt;p&gt;ANSSI:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Jérémy JEAN&lt;/li&gt; &#xA; &lt;li&gt;Louiza KHATI&lt;/li&gt; &#xA; &lt;li&gt;Ange MARTINELLI&lt;/li&gt; &#xA; &lt;li&gt;Chrysanthi MAVROMATI&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;CryptoExperts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sonia BELAID&lt;/li&gt; &#xA; &lt;li&gt;Ryad BENADJILA&lt;/li&gt; &#xA; &lt;li&gt;Thibauld FENEUIL&lt;/li&gt; &#xA; &lt;li&gt;Matthieu RIVAIN&lt;/li&gt; &#xA; &lt;li&gt;Abdul Rahman TALEB&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For questions or remarks regarding CRY.ME, please fill issues on this repository or send an email to &lt;a href=&#34;mailto:cryme@ssi.gouv.fr&#34;&gt;cryme@ssi.gouv.fr&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The CRY.ME project is released under the Apache 2.0 license, please check the &lt;a href=&#34;https://raw.githubusercontent.com/ANSSI-FR/cry-me/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file at the root folder of the project.&lt;/p&gt; &#xA;&lt;p&gt;CRY.ME heavily relies on source code from the Android element (&lt;a href=&#34;https://github.com/vector-im/element-android&#34;&gt;https://github.com/vector-im/element-android&lt;/a&gt;) project, the Matrix SDK project (&lt;a href=&#34;https://github.com/matrix-org/matrix-android-sdk2&#34;&gt;https://github.com/matrix-org/matrix-android-sdk2&lt;/a&gt;), and the Android Yubikit (&lt;a href=&#34;https://github.com/Yubico/yubikit-android&#34;&gt;https://github.com/Yubico/yubikit-android&lt;/a&gt;) project. These three projects are under the Apache 2.0 license as well.&lt;/p&gt; &#xA;&lt;h2&gt;The CRY.ME application&lt;/h2&gt; &#xA;&lt;p&gt;CRY.ME is based on Android element (&lt;a href=&#34;https://github.com/vector-im/element-android&#34;&gt;https://github.com/vector-im/element-android&lt;/a&gt;), and it shares many features with the original messaging application. Please check the element &lt;a href=&#34;https://element.io/user-guide&#34;&gt;user guide&lt;/a&gt; for more details on how the application works.&lt;/p&gt; &#xA;&lt;p&gt;For a basic &#34;getting started&#34; documentation, you can refer to the &lt;a href=&#34;https://raw.githubusercontent.com/ANSSI-FR/cry-me/main/README_CRYME.md&#34;&gt;brief howto&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;The CRY.ME application specifications&lt;/h2&gt; &#xA;&lt;p&gt;Cryptographic specifications for the CRY.ME application can be found in the &lt;code&gt;cryme_docs&lt;/code&gt; folder. We provide two documents for the specifications, as well as the security target that can be used for an evaluation to describe the scope to analyze. The first document &lt;code&gt;crypto_specs_without_vulns&lt;/code&gt; contains the specifications without any mention to the cryptographic vulnerabilities and should be the one to use by anyone who wants to give the challenge a try. The second document &lt;code&gt;crypto_specs_with_vulns&lt;/code&gt; contains the full cryptographic specifications with mentions of all the vulnerabilities voluntarily introduced in the application. It can be seen as the solution to the challenge.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: the documents in &lt;code&gt;cryme_docs&lt;/code&gt; are in &lt;strong&gt;French&lt;/strong&gt;. This is mainly due to CRY.ME being the result of a French challenge. We might consider translating parts of this documentation in the future. Anyways, any help on this translation through Pull Requests is welcome!&lt;/p&gt; &#xA;&lt;h2&gt;The CRY.ME Android source code bundle for security analysis&lt;/h2&gt; &#xA;&lt;p&gt;CRY.ME uses &lt;code&gt;element&lt;/code&gt; as a basis for the messaging application. In &lt;code&gt;cryme_app&lt;/code&gt;, all the source code of the application is present. Beware that this source code is &lt;strong&gt;annotated&lt;/strong&gt; with the vulnerabilities (using comments with &lt;code&gt;CRY.ME.VULN.XX&lt;/code&gt;, &lt;code&gt;XX&lt;/code&gt; being a vulnerability number).&lt;/p&gt; &#xA;&lt;p&gt;Of course, for someone wanting to explore the vulnerable source code without any information about the vulnerabilities, these annotations are spoilers. This is why we provide a dedicated way of bundling this source code without the annotations. To do so, go to the &lt;code&gt;cryme_app&lt;/code&gt; folder and execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_app$ make app_bundle_src&#xA;[+] Bundling the source code for vulnerability analysis, please wait ...&#xA;[+] You will find your source bundle without vulnerabilities comments here: cry.me.src.bundle.tar.gz at the project root folder!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The compressed bundle will be created in &lt;code&gt;cry.me.src.bundle.tar.gz&lt;/code&gt;: you can uncompress it and explore it. The bundling script should only have &lt;code&gt;python3&lt;/code&gt; and &lt;code&gt;tar&lt;/code&gt; as dependencies, but we also provide a &lt;strong&gt;Dockerfile&lt;/strong&gt; (you will need &lt;code&gt;docker&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_app$ make app_bundle_src_docker&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The CRY.ME Android compilation&lt;/h2&gt; &#xA;&lt;h3&gt;Pre-built packages&lt;/h3&gt; &#xA;&lt;p&gt;For those who do not want to recompile the CRY.ME application from scratch, it is possible to get the &lt;code&gt;apk&lt;/code&gt; files from the following URL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl https://www.cryptoexperts.com/cry-me/cry.me.build.tar.gz -o cry.me.build.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once downloaded, you can extract this archive in the &lt;code&gt;cryme_app&lt;/code&gt; folder, which will create a &lt;code&gt;build/&lt;/code&gt; subfolder.&lt;/p&gt; &#xA;&lt;p&gt;The bundle contains &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; &lt;code&gt;apk&lt;/code&gt; both for the CRY.ME application, and for the Yubikit &#34;demo&#34; in order to test your Yubikey on Android if needed. Once untared, the CRY.ME &lt;code&gt;debug&lt;/code&gt; &lt;code&gt;apk&lt;/code&gt; files are in &lt;code&gt;build/cryme/gplay/debug/&lt;/code&gt;and the &lt;code&gt;release&lt;/code&gt; ones in &lt;code&gt;build/cryme/gplay/release&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;vector-gplay-universal-debug.apk&lt;/code&gt; and &lt;code&gt;vector-gplay-universal-release-unsigned.apk&lt;/code&gt; are of particular interest as they are &#34;universal&#34; and should be installable on physical devices or emulators (both arm and x86 flavours) with &lt;strong&gt;Android API level at least 29&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please be aware, however, that the release packages are &lt;strong&gt;not signed&lt;/strong&gt;, and hence not directly installable on target devices (which is not the case of debug packages). Signing &lt;code&gt;apk&lt;/code&gt; release packages is out of the scope of the project, please refer to the appropriate Android resources to achieve this.&lt;/p&gt; &#xA;&lt;h3&gt;Compilation from scratch&lt;/h3&gt; &#xA;&lt;p&gt;It is possible to compile the CRY.ME project (producing &lt;code&gt;apk&lt;/code&gt; files for Android) using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_app$ make app_build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This supposes that the following dependencies are installed on your system: &lt;code&gt;openjdk-11-jdk-headless&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;gradle&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt;. Depending on your system, you may need to adapt your environment variables to launch the build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_app$ JAVA_HOME=/usr/lib/jvm/default-java LD_LIBRARY_PATH=LD_LIBRARY_PATH:$JAVA_HOME/lib/server/ make app_build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you do not want to bother with all these dependencies, a &lt;strong&gt;Docker&lt;/strong&gt; version is also available (you will need &lt;code&gt;docker&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_app$ make app_build_docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create a &lt;code&gt;cryme_app/build&lt;/code&gt; folder with the various &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; &lt;code&gt;apk&lt;/code&gt; files.&lt;/p&gt; &#xA;&lt;p&gt;We have tried to make compilation as easy and transparent as possible, but you might also want to install &lt;code&gt;Android Studio&lt;/code&gt; and compile CRY.ME by your own means. If so, please follow the steps in the &lt;a href=&#34;https://raw.githubusercontent.com/ANSSI-FR/cry-me/main/README_ANDROID_STUDIO.md&#34;&gt;dedicated documentation&lt;/a&gt;. Using &lt;code&gt;Android Studio&lt;/code&gt; implies to install a rather heavy software, but allows to use the &lt;strong&gt;debugger&lt;/strong&gt; that can come handy when analyzing the application.&lt;/p&gt; &#xA;&lt;h2&gt;The CRY.ME server&lt;/h2&gt; &#xA;&lt;p&gt;Due to the CRY.ME server heavy dependencies (mostly for the embedded Synapse server), we provide a &lt;code&gt;docker-compose&lt;/code&gt; file to lauch it. Launching an instance of the server is as easy as going to the &lt;code&gt;cryme_server&lt;/code&gt; folder and executing (you will need &lt;code&gt;docker&lt;/code&gt; and &lt;code&gt;docker-compose&lt;/code&gt; to be installed on your system):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_server$ SYNAPSE_SERVER_NAME=cryme.fr make&#xA;...&#xA;Starting cryme-db ... done&#xA;Starting cryme-synapse ... done&#xA;Starting cryme-nginx   ... done&#xA;Attaching to cryme-db, cryme-synapse, cryme-nginx&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: this command supposes that your user can manage Docker with non-root user. You might either follow &lt;a href=&#34;https://docs.docker.com/engine/install/linux-postinstall/&#34;&gt;this documentation&lt;/a&gt;, or use &lt;code&gt;sudo&lt;/code&gt; for this &lt;code&gt;make&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;SYNAPSE_SERVER_NAME&lt;/code&gt; environment variable is used to provide the FQDN name of the server (needed by Synapse). We use &lt;code&gt;cryme.fr&lt;/code&gt; in the command above. If everything goes well, you should see three containers successfully started: &lt;code&gt;cryme-db&lt;/code&gt;, &lt;code&gt;cryme-synapse&lt;/code&gt; and &lt;code&gt;cryme-nginx&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that we provide two files for &lt;code&gt;docker-compose&lt;/code&gt;: the default one (&lt;code&gt;docker-compose.yml&lt;/code&gt;) used by the above &lt;code&gt;make&lt;/code&gt; command pulls a public image from DockerHub that has been prebuilt for a simpler usage. The second one (&lt;code&gt;docker-compose.build.yml&lt;/code&gt;) can be used in case you want to rebuild the server yourself. While this is not necessary for using the application, it might come in handy during a deeper analysis of the application. You can force the local build of the &lt;code&gt;cryme-synapse&lt;/code&gt; docker with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_server$ SYNAPSE_SERVER_NAME=cryme.fr make launch_server_build_synapse&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The users and conversation databases are handled by the &lt;code&gt;cryme-db&lt;/code&gt; container: they should be consistent across executions of the server. If you want to purge the database and get a clean state with empty databases, you can execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_server$ SYNAPSE_SERVER_NAME=cryme.fr make clean&#xA;docker-compose rm cryme-db&#xA;Going to remove cryme-db&#xA;Are you sure? [yN] y&#xA;Removing cryme-db ... done&#xA;docker-compose rm cryme-synapse&#xA;Going to remove cryme-synapse&#xA;Are you sure? [yN] y&#xA;Removing cryme-synapse ... done&#xA;docker-compose rm cryme-nginx&#xA;Going to remove cryme-nginx&#xA;Are you sure? [yN] y&#xA;Removing cryme-nginx ... done&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Beware that with this command, you will &lt;strong&gt;loose all the existing users and conversations&lt;/strong&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;The CRY.ME application emulation&lt;/h2&gt; &#xA;&lt;h3&gt;Overview of the emulated platform&lt;/h3&gt; &#xA;&lt;p&gt;In order to make testing CRY.ME easier, we also provide a way to easily test the application on a single computer. We make use of a server instantiated on localhost, and as many emulators instances communicating with it as CRY.ME users you want to emulate. All the sequel have been tested on a &lt;strong&gt;x86_64 Linux environment&lt;/strong&gt; with the following dependencies installed: &lt;code&gt;docker&lt;/code&gt;, &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;swig&lt;/code&gt;, &lt;code&gt;pcscd&lt;/code&gt;, &lt;code&gt;libpcsclite-dev&lt;/code&gt; and &lt;code&gt;yubikey-manager&lt;/code&gt;. Although any Android emulator image could theoretically be used, the ones we provide are specifically suited to test CRY.ME for two reasons: first of all, they use a custom kernel and system modifications allowing for USB passthough (for communicating with physical Yubikeys), and secondly some system files have been modified for easy network lookups on localhost (for communicating with the local server instance).&lt;/p&gt; &#xA;&lt;p&gt;Since CRY.ME makes use of &lt;strong&gt;Yubikeys&lt;/strong&gt; as authentication tokens, you will need as many Yubikeys as the number of CRY.ME users you wan to emulate.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: emulation of CRY.ME uses images with around 12 GB. Beware of this rather large size that will grow with the number of users when creating multiple images!&lt;/p&gt; &#xA;&lt;h3&gt;Launching the server instance for emulation&lt;/h3&gt; &#xA;&lt;p&gt;First of all, launch an instance of the server using the server name &lt;code&gt;cryme.fr&lt;/code&gt; (beware that this name is important to keep as it is embedded in the emulator images DNS lookup):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_server$ SYNAPSE_SERVER_NAME=cryme.fr make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can modify the &lt;code&gt;SYNAPSE_SERVER_NAME&lt;/code&gt; with the name of another server instance running on a machine elsewhere in the network/internet, however you should make sure that this name can be properly resolved by a DNS server (which should be the case if the URL is indeed accessible, e.g., from a browser).&lt;/p&gt; &#xA;&lt;h3&gt;Creating the CRY.ME users images for emulation&lt;/h3&gt; &#xA;&lt;p&gt;Then, go to the &lt;code&gt;cryme_app_emulation&lt;/code&gt; folder and proceed with some steps. First, we will create as many emulators instances as we have users to create. For the sake of the example, we take two users (1 and 2) in the following. This supposes that you have two &lt;strong&gt;distinct&lt;/strong&gt; Yubikeys, each one associated with each user: let&#39;s call them Yubikey 1 and Yubikey 2.&lt;/p&gt; &#xA;&lt;p&gt;Create the CRY.ME user 1 emulator instance. Plug Yubikey 1 and execute the &lt;code&gt;create_emulator_image.sh&lt;/code&gt; bash script (be sure that only one Yubikey is plugged in at a time):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_app_emulation$ ./create_emulator_image.sh 1&#xA;...&#xA;[+] Creating image for user 1&#xA;[+] Yubikey found with serial 16146863&#xA;[+] Emulator base image not present, downloading it!&#xA;  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&#xA;                                 Dload  Upload   Total   Spent    Left  Speed&#xA;  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0&#xA;100 1991M  100 1991M    0     0   119M      0  0:00:16  0:00:16 --:--:--  119M&#xA;[+] Copying and untaring the base image ...&#xA;[+] Patching the configuration files ...&#xA;[+] All should be good for the CRY.ME emulator image 1 (CRYME1), you can launch the emulator now with this user number 1!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Do the same with Yubikey 2 and user 2 (replacing 1 by 2 of course in the previous command line). This might take a while as the base emulator images must be fetched and uncompressed. You can also provide as a second argument the Yubikey serial number to be used for the image to create: in this case, the script does not check that the Yubikey is plugged in (but beware that the serial number &lt;strong&gt;must be valid&lt;/strong&gt; as during execution il will be checked against a physical Yubikey):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_app_emulation$ ./create_emulator_image.sh 1 18283368&#xA;[+] Creating image for user 1&#xA;[+] We are asked to use Yubikey of serial number 18283368 (forced, NOT checking if the Yubikey is present)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All the created images can be cleaned with the same &lt;code&gt;create_emulator_image.sh&lt;/code&gt; script using &lt;code&gt;clean&lt;/code&gt; as a first argument (all the images will be clean without additional argument), and the image&#39;s user number to clean as a second optional argument:&lt;/p&gt; &#xA;&lt;h3&gt;Launching the emulation images for the users&lt;/h3&gt; &#xA;&lt;p&gt;Then, the instances can be launched using the &lt;code&gt;launch_emulator_usb.sh&lt;/code&gt; bash script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_app_emulation$ ./launch_emulator_usb.sh 1&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, the Yubikey associated with the user must be plugged in. On the first launch, you might be asked to fetch and untar the SDK using &lt;code&gt;make sdk_untar&lt;/code&gt; in the &lt;code&gt;cryme_app&lt;/code&gt; folder: proceed with this (it should be done once). An emulator window should be opened.&lt;/p&gt; &#xA;&lt;p&gt;Finally, you can install the compiled CRY.ME application in the emulator using &lt;code&gt;adb&lt;/code&gt;. Supposing that the &lt;code&gt;build&lt;/code&gt; folder is created following a proper compilation, you can go to the &lt;code&gt;cryme_app&lt;/code&gt; folder and execute the &lt;code&gt;make app_install&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;p&gt;Please ensure that &lt;strong&gt;only one instance&lt;/strong&gt; of the emulator is running when installing (so that there is no ambiguity for &lt;code&gt;adb&lt;/code&gt; to know where to install the application).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_app$ make app_install&#xA;...&#xA;[+] Installing the CRY.ME app&#xA;element/matrix-sdk-android/platform-tools/adb install build/cryme/gplay/debug/vector-gplay-universal-debug.apk&#xA;Performing Streamed Install&#xA;Success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After the installation of the application on every instance for every user, you can begin to use the CRY.ME app while launching all the instances and sign up/sign in users. Please ensure that &lt;strong&gt;all the Yubikeys&lt;/strong&gt; associated to the users you &#34;emulate&#34; are plugged in when you launch the associated images and &lt;strong&gt;do not unplug&lt;/strong&gt; them during your emulation session: &lt;code&gt;qemu&lt;/code&gt; USB passthrough is not very resilient to hot (un)plugging. When asked for a server, enter &lt;code&gt;cryme.fr&lt;/code&gt; and accept to &#34;trust&#34; it (this is asked because of the self-signed TLS certificates on the demo server). Since the Yubikey might not be necessary after a Sign Up / Sign In, you can also force launching the emulator instance associated to a user with &lt;code&gt;noyubi&lt;/code&gt; as a second argument:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cryme_app_emulation$ ./launch_emulator_usb.sh 1 noyubi&#xA;[+] Launching the emulator WITHOUT the associated Yubikey (as forced by the command line)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: keep all the necessary Yubikeys plugged in during the whole emulation session.&lt;/p&gt; &#xA;&lt;h3&gt;Emulation demo video&lt;/h3&gt; &#xA;&lt;p&gt;Here is a little demo for the full workflow of local CRY.ME emulation:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ANSSI-FR/cry-me/assets/38430857/dec65f85-1cc8-45e6-ace9-055cf5acd35e&#34;&gt;https://github.com/ANSSI-FR/cry-me/assets/38430857/dec65f85-1cc8-45e6-ace9-055cf5acd35e&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: in this demo video, during the last part emulating CRY.ME with two users, the two Yubikeys were simultaneously plugged in during the whole emulation session. Please be aware that the emulator does not support &lt;strong&gt;hot (un)plugging&lt;/strong&gt;, so do not unplug you Yubikeys when they are needed (or you will have to launch the instances again).&lt;/p&gt;</summary>
  </entry>
</feed>