<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-14T01:33:01Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sebaslogen/resaca</title>
    <updated>2023-10-14T01:33:01Z</updated>
    <id>tag:github.com,2023-10-14:/sebaslogen/resaca</id>
    <link href="https://github.com/sebaslogen/resaca" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Android library to scope ViewModels to a Composable, surviving configuration changes and navigation&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://jitpack.io/#sebaslogen/resaca&#34;&gt;&lt;img src=&#34;https://jitpack.io/v/sebaslogen/resaca.svg?sanitize=true&#34; alt=&#34;Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sebaslogen/resaca/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/sebaslogen/resaca/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://android-arsenal.com/api?level=21&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/API-21%2B-brightgreen.svg?style=flat&#34; alt=&#34;API 21+&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sebaslogen/resaca/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/sebaslogen/resaca&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Article about this library: &lt;a href=&#34;https://engineering.q42.nl/compose/&#34;&gt;Every Composable deserves a ViewModel&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Resaca üçπ&lt;/h1&gt; &#xA;&lt;p&gt;The right scope for objects and View Models in Android &lt;a href=&#34;https://developer.android.com/jetpack/compose&#34;&gt;Compose&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Resaca provides a simple way to keep a Jetpack ViewModel (or any other object) in memory during the lifecycle of a &lt;code&gt;@Composable&lt;/code&gt; function and automatically clean it up when not needed anymore. This means, it retains your object or ViewModel across recompositions, during configuration changes, and also when the container Fragment or Compose Navigation destination goes into the backstack.&lt;/p&gt; &#xA;&lt;p&gt;With Resaca you can create fine grained ViewModels for fine grained Composables and finally have reusable components across screens.&lt;/p&gt; &#xA;&lt;h1&gt;Why&lt;/h1&gt; &#xA;&lt;p&gt;Compose allows the creation of fine-grained UI components that can be easily reused like Lego blocks üß±. Well architected Android apps isolate functionality in small business logic components (like use cases, interactors, repositories, etc.) that are also reusable like Lego blocks üß±.&lt;/p&gt; &#xA;&lt;p&gt;Screens are built using Compose components together with business logic components, and the standard tool to connect these two types of components is a &lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/viewmodel&#34;&gt;Jetpack ViewModel&lt;/a&gt;. Unfortunately, ViewModels can only be scoped to a whole screen (or larger scope), but not to smaller Compose components on the screen.&lt;/p&gt; &#xA;&lt;p&gt;In practice, this means that we are gluing UI Lego blocks with business logic Lego blocks using a big glue class for the whole screen, the ViewModel üóú.&lt;/p&gt; &#xA;&lt;p&gt;Until now...&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Add the Jitpack repo and include the library (less than 5Kb):&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Kotlin (KTS)&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// In settings.gradle.kts&#xA;dependencyResolutionManagement {&#xA;    repositories {&#xA;         [..]&#xA;         maven { setUrl(&#34;https://jitpack.io&#34;) }&#xA;    }&#xA;}&#xA;// In module&#39;s build.gradle.kts&#xA;dependencies {&#xA;    // The latest version of the lib is available in the badget at the top, replace X.X.X with that version&#xA;    implementation(&#34;com.github.sebaslogen.resaca:resaca:X.X.X&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Groovy&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;allprojects {&#xA;    repositories {&#xA;        [..]&#xA;        maven { url &#34;https://jitpack.io&#34; }&#xA;    }&#xA;}&#xA;dependencies {&#xA;    // The latest version of the lib is available in the badget at the top, replace X.X.X with that version&#xA;    implementation &#39;com.github.sebaslogen.resaca:resaca:X.X.X&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Inside your &lt;code&gt;@Composable&lt;/code&gt; function create and retrieve an object using &lt;code&gt;rememberScoped&lt;/code&gt; to remember any type of object (except ViewModels). For ViewModels use &lt;code&gt;viewModelScoped&lt;/code&gt;. That&#39;s all ü™Ñ‚ú®&lt;/p&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Scope to a Composable an object&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun DemoScopedObject() {&#xA;    val myRepository: MyRepository = rememberScoped { MyRepository() }&#xA;    DemoComposable(inputObject = myRepository)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Scope to a Composable a ViewModel&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun DemoScopedViewModel() {&#xA;    val myScopedVM: MyViewModel = viewModelScoped()&#xA;    DemoComposable(inputObject = myScopedVM)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Scope to a Composable a ViewModel with a dependency&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun DemoScopedViewModelWithDependency() {&#xA;    val myScopedVM: MyViewModelWithDependencies = viewModelScoped { MyViewModelWithDependencies(myDependency) }&#xA;    DemoComposable(inputObject = myScopedVM)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Scope to a Composable a ViewModel with a key&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun DemoViewModelWithKey() {&#xA;    val scopedVMWithFirstKey: MyViewModel = viewModelScoped(&#34;myFirstKey&#34;) { MyViewModel(&#34;myFirstKey&#34;) }&#xA;    val scopedVMWithSecondKey: MyViewModel = viewModelScoped(&#34;mySecondKey&#34;) { MyViewModel(&#34;mySecondKey&#34;) }&#xA;    // We now have 2 ViewModels of the same type with different data inside the same Composable scope&#xA;    DemoComposable(inputObject = scopedVMWithFirstKey)&#xA;    DemoComposable(inputObject = scopedVMWithSecondKey)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Scope to a Composable a ViewModel with a dependency injected with Koin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun DemoKoinInjectedViewModelWithDependency() {&#xA;    val myInjectedScopedVM: MyViewModelWithDependencies = viewModelScoped() { getKoin().get { parametersOf(myConstructorDependency) } }&#xA;    DemoComposable(inputObject = myInjectedScopedVM)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Once you use the &lt;code&gt;rememberScoped&lt;/code&gt; or &lt;code&gt;viewModelScoped&lt;/code&gt; functions, the same object will be restored as long as the Composable is part of the composition, even if it &lt;em&gt;temporarily&lt;/em&gt; leaves composition on configuration change (e.g. screen rotation, change to dark mode, etc.) or while being in the backstack.&lt;/p&gt; &#xA;&lt;p&gt;For ViewModels, in addition to being forgotten when they&#39;re really not needed anymore, their &lt;em&gt;coroutineScope&lt;/em&gt; will also be automatically canceled because ViewModel&#39;s &lt;code&gt;onCleared&lt;/code&gt; method will be automatically called by this library.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;üí° &lt;em&gt;Optional key&lt;/em&gt;: a key can be provided to the call, &lt;code&gt;rememberScoped(key) { ... }&lt;/code&gt; or &lt;code&gt;viewModelScoped(key) { ... }&lt;/code&gt;. This makes possible to forget an old object when there is new input data during a recomposition (e.g. a new input id for your ViewModel).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ö†Ô∏è Note that ViewModels remembered with &lt;code&gt;viewModelScoped&lt;/code&gt; &lt;strong&gt;should not be created&lt;/strong&gt; using any of the Compose &lt;code&gt;viewModel()&lt;/code&gt; or &lt;code&gt;ViewModelProviders&lt;/code&gt; factories, otherwise they will be retained in the scope of the screen regardless of &lt;code&gt;viewModelScoped&lt;/code&gt;. Also, if a ViewModel is remembered with &lt;code&gt;rememberScoped&lt;/code&gt; its clean-up method won&#39;t be called, that&#39;s the reason to use &lt;code&gt;viewModelScoped&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Sample use cases&lt;/h1&gt; &#xA;&lt;p&gt;Here are some sample use cases reported by the users of this library:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üìÉüìÑ Multiple instances of the same type of ViewModel in a screen with a &lt;strong&gt;view-pager&lt;/strong&gt;. This screen will have multiple sub-pages that use the same ViewModel class with different ids. For example, a screen of holiday destinations with multiple pages and each page with its own &lt;code&gt;HolidayDestinationViewModel&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;‚ù§Ô∏è Isolated and stateful UI components like a &lt;strong&gt;favorite button&lt;/strong&gt; that are widely used across the screens. This &lt;code&gt;FavoriteViewModel&lt;/code&gt; can be very small, focused and only require an id to work without affecting the rest of the screen&#39;s UI and state.&lt;/li&gt; &#xA; &lt;li&gt;üó™ &lt;strong&gt;Dialog pop-ups&lt;/strong&gt; can have their own business-logic with state that is better to isolate in a separate ViewModel but the lifespan of these dialogs might be short, so it&#39;s important to clean-up the ViewModel associated to a Dialog after it has been closed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Demo app&lt;/h1&gt; &#xA;&lt;p&gt;Demo app &lt;a href=&#34;https://github.com/sebaslogen/resaca/raw/main/sample/README.md&#34;&gt;documentation can be found here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/1936647/144597718-db7e8901-a726-4871-abf8-7fc53333a90e.gif&#34; alt=&#34;Resaca-demo&#34; width=&#34;340&#34; height=&#34;802&#34;&gt; &lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Before&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;After backstack navigation &amp;amp; configuration change&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img width=&#34;429&#34; alt=&#34;Before&#34; src=&#34;https://user-images.githubusercontent.com/1936647/146558764-42333455-2dd8-43a9-932b-3249d42b7a7d.png&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img width=&#34;430&#34; alt=&#34;After&#34; src=&#34;https://user-images.githubusercontent.com/1936647/146558775-8c77231c-ed0f-4f52-b9b8-cdf9029e106c.png&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Dependency injection support&lt;/h1&gt; &#xA;&lt;p&gt;This library does not influence how your app provides or creates objects so it&#39;s dependency injection strategy and framework agnostic.&lt;/p&gt; &#xA;&lt;p&gt;Nevertheless, this library supports two of the main &lt;strong&gt;dependency injection frameworks&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;h2&gt;Hilt üó°Ô∏è&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dagger.dev/hilt/quick-start&#34;&gt;HILT&lt;/a&gt; (Dagger) support is available in a small extension of this library: &lt;a href=&#34;https://github.com/sebaslogen/resaca/tree/main/resacahilt/&#34;&gt;&lt;strong&gt;resaca-hilt&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sebaslogen/resaca/tree/main/resacahilt/README.md&#34;&gt;Documentation and installation instructions are available here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Koin ü™ô&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://insert-koin.io/&#34;&gt;Koin&lt;/a&gt; is out of the box supported by simply changing the way you request a dependency.&lt;/p&gt; &#xA;&lt;p&gt;Instead of using the &lt;code&gt;getViewModel&lt;/code&gt; or &lt;code&gt;koinViewModel&lt;/code&gt; functions from Koin, you have to use the standard way of getting a dependency from Koin &lt;code&gt;getKoin().get()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Usage example: &lt;code&gt;val viewModel: MyViewModel = viewModelScoped(myId) { getKoin().get { parametersOf(myId) } }&lt;/code&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: if you plan to use a ViewModel with a &lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/viewmodel/viewmodel-savedstate&#34;&gt;SavedStateHandle&lt;/a&gt;, then you need to use the &lt;code&gt;koinViewModelScoped&lt;/code&gt; function from the small extension library &lt;a href=&#34;https://github.com/sebaslogen/resaca/raw/main/resacakoin/Readme.md&#34;&gt;&lt;strong&gt;resaca-koin&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;General considerations for State Hoisting&lt;/h3&gt; &#xA;&lt;p&gt;Here are a few suggestions of how to provide objects in combination with this library in a Compose screen:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When using the Lazy* family of Composables it is recommended that you use &lt;code&gt;rememberScoped&lt;/code&gt;/&lt;code&gt;viewModelScoped&lt;/code&gt; outside the scope of Composables created by Lazy constructors (e.g. LazyColumn) because there is a chance that a lazy initialized Composable will be disposed of when it is not visible anymore (e.g. scrolled away) and that will also dispose of the &lt;code&gt;rememberScoped&lt;/code&gt;/&lt;code&gt;viewModelScoped&lt;/code&gt; object immediately, this might not be the intended behavior. For more info see Compose&#39;s &lt;a href=&#34;https://developer.android.com/jetpack/compose/state#state-hoisting&#34;&gt;State Hoisting&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;When a Composable is used more than once in the same screen with the same input, then the ViewModel (or business logic object) should be provided only once with &lt;code&gt;viewModelScoped&lt;/code&gt; at a higher level in the tree using Compose&#39;s &lt;a href=&#34;https://developer.android.com/jetpack/compose/state#state-hoisting&#34;&gt;State Hoisting&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Why not use remember?&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0)&#34;&gt;Remember&lt;/a&gt;&lt;/strong&gt; will keep our object alive as long as the Composable is not disposed of. Unfortunately, there are a few cases where our Composable will be disposed of and then added again, breaking the lifecycle parity with the remember function. üò¢&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Pros and Cons&lt;/summary&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;em&gt;Pros&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Simple API&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;em&gt;Cons&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;remember value will &lt;strong&gt;NOT&lt;/strong&gt; survive a configuration change&lt;/li&gt; &#xA;  &lt;li&gt;remember value will &lt;strong&gt;NOT&lt;/strong&gt; survive when going into the backstack&lt;/li&gt; &#xA;  &lt;li&gt;remember value will &lt;strong&gt;NOT&lt;/strong&gt; survive a process death&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://developer.android.com/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0)&#34;&gt;RememberSaveable&lt;/a&gt;&lt;/strong&gt; will follow the lifecycle of the Composable, even in the few cases where the Composable is temporarily disposed of. But the object we want to remember needs to implement Parcelable or the &lt;a href=&#34;https://developer.android.com/reference/kotlin/androidx/compose/runtime/saveable/Saver&#34;&gt;Saver&lt;/a&gt; interface in an additional class. üò¢ Implementing these interfaces might not trivial.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Pros and Cons&lt;/summary&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;em&gt;Pros&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;rememberSaveable value will survive a configuration change&lt;/li&gt; &#xA;  &lt;li&gt;rememberSaveable value will survive when going into the backstack&lt;/li&gt; &#xA;  &lt;li&gt;rememberSaveable value will survive a process death&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;em&gt;Cons&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;Complex&lt;/strong&gt; integration work is required to correctly implement Parcelable or &lt;a href=&#34;https://developer.android.com/reference/kotlin/androidx/compose/runtime/saveable/Saver&#34;&gt;Saver&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;The new RememberScoped ü™Ñ‚ú®&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/sebaslogen/resaca/raw/main/resaca/src/main/java/com/sebaslogen/resaca/ScopedMemoizers.kt#L33&#34;&gt;RememberScoped&lt;/a&gt;&lt;/strong&gt; function keeps objects in memory during the lifecycle of the Composable, even in a few cases where the Composable is disposed of, and then added again. Therefore, it will retain objects longer than the &lt;code&gt;remember&lt;/code&gt; function but shorter than &lt;code&gt;rememberSaveable&lt;/code&gt; because there is no serialization involved.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Pros and Cons&lt;/summary&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;em&gt;Pros&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Simple API&lt;/li&gt; &#xA;  &lt;li&gt;rememberScoped/viewModelScoped value will survive a configuration change&lt;/li&gt; &#xA;  &lt;li&gt;rememberScoped/viewModelScoped value will survive when going into the backstack&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;&lt;strong&gt;&lt;em&gt;Cons&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;rememberScoped/viewModelScoped value will &lt;strong&gt;NOT&lt;/strong&gt; survive a process death&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Lifecycle&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/sebaslogen/resaca/raw/main/resaca/src/main/java/com/sebaslogen/resaca/ScopedMemoizers.kt#L33&#34;&gt;RememberScoped&lt;/a&gt;&lt;/strong&gt; function keeps objects in memory during the lifecycle of the Composable, even in a few cases where the Composable is disposed of, and then added again.&lt;/p&gt; &#xA;&lt;h2&gt;RememberScoped lifecycle internal implementation details&lt;/h2&gt; &#xA;&lt;p&gt;This project uses internally a ViewModel as a container to store all scoped ViewModels and scoped objects.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;What happens when a Composable is disposed?&lt;/summary&gt; &#xA; &lt;p&gt;When a Composable is disposed of, we don&#39;t know for sure if it will return again later. So at the moment of disposal, we mark in our container the associated object to be disposed of after the next frame when the Activity is resumed. During the span of time of this next frame, a few things can happen:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;The Composable is not part of the composition anymore after the next frame and the associated object is disposed of. üöÆ&lt;/li&gt; &#xA;  &lt;li&gt;The LifecycleOwner of the disposed Composable (i.e. the navigation destination where the Composable lived) is paused (e.g. screen went to background) before the next frame happened. Then the disposal of the scoped object is canceled, but the object is still marked for disposal at a later stage. &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;This can happen when the application goes through a configuration change and the container Activity is recreated.&lt;/li&gt; &#xA;    &lt;li&gt;Also when the Composable is part of a Fragment that has been pushed to the backstack.&lt;/li&gt; &#xA;    &lt;li&gt;And also when the Composable is part of a Compose Navigation destination that has been pushed to the backstack.&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;When the LifecycleOwner of the disposed Composable is resumed (e.g. Fragment comes back to foreground), then the disposal of the associated object is scheduled again to happen after the next frame when the Activity is resumed. At this point two things can happen: &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;The Composable becomes part of the composition again and the &lt;code&gt;rememberScoped&lt;/code&gt;/&lt;code&gt;viewModelScoped&lt;/code&gt; function restores the associated object while also cancelling any pending disposal in the next frame when the Activity is resumed. üéâ&lt;/li&gt; &#xA;    &lt;li&gt;The Composable is not part of the composition anymore after the next frame and then the associated object is disposed of. üöÆ&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;To know that the same Composable is being added to the composition again after being disposed of, we generate a random ID and store it with &lt;code&gt;rememberSaveable&lt;/code&gt; , which survives recomposition, recreation and even process death.&lt;/li&gt; &#xA;  &lt;li&gt;To detect when the requester Composable is not needed anymore (has left composition and the screen for good), the ScopedViewModelContainer also observes the resume/pause Lifecycle events of the owner of this ScopedViewModelContainer (i.e. Activity, Fragment, or Compose Navigation destination)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Lifecycle example&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1936647/144682707-dd06e2ee-5542-400b-9a8d-cb27fb7c28e8.png&#34; alt=&#34;Compose state scope&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This diagram shows the lifecycle of three Composables (A, B, and C) with their respective objects scoped with the &lt;code&gt;rememberScoped&lt;/code&gt; function. All these Composables are part of a Composable destination which is part of a Fragment which is part of an Activity which is part of the App. The horizontal arrows represent different lifecycle events, events like Composable being disposed of, Composable screen going into the backstack, Fragment going into the backstack and returning from backstack, or Activity recreated after a configuration change.&lt;/p&gt; &#xA;&lt;p&gt;The existing alternatives to replicate the lifecycle of the objects in the diagram without using &lt;code&gt;rememberScoped&lt;/code&gt; are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Object A lifecycle could only be achieved using the Compose &lt;code&gt;viewModel()&lt;/code&gt; or &lt;code&gt;ViewModelProviders&lt;/code&gt; factories.&lt;/li&gt; &#xA; &lt;li&gt;Object B lifecycle could only be achieved using the Compose &lt;code&gt;remember()&lt;/code&gt; function.&lt;/li&gt; &#xA; &lt;li&gt;Object C lifecycle could not be achieved neither by using ViewModel provider functions nor Compose &lt;code&gt;remember&lt;/code&gt; functions.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>