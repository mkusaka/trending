<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-28T01:37:23Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cashapp/molecule</title>
    <updated>2022-08-28T01:37:23Z</updated>
    <id>tag:github.com,2022-08-28:/cashapp/molecule</id>
    <link href="https://github.com/cashapp/molecule" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Build a StateFlow stream using Jetpack Compose&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Molecule&lt;/h1&gt; &#xA;&lt;p&gt;Build a &lt;code&gt;StateFlow&lt;/code&gt; or &lt;code&gt;Flow&lt;/code&gt; stream using Jetpack Compose[^1].&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun CoroutineScope.launchCounter(): StateFlow&amp;lt;Int&amp;gt; = launchMolecule(clock = ContextClock) {&#xA;  var count by remember { mutableStateOf(0) }&#xA;&#xA;  LaunchedEffect(Unit) {&#xA;    while (true) {&#xA;      delay(1_000)&#xA;      count++&#xA;    }&#xA;  }&#xA;&#xA;  count&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[^1]: …and NOT Jetpack Compose UI!&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Jetpack Compose UI makes it easy to build declarative UI with logic.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val userFlow = db.userObservable()&#xA;val balanceFlow = db.balanceObservable()&#xA;&#xA;@Composable&#xA;fun Profile() {&#xA;  val user by userFlow.subscribeAsState(null)&#xA;  val balance by balanceFlow.subscribeAsState(0L)&#xA;&#xA;  if (user == null) {&#xA;    Text(&#34;Loading…&#34;)&#xA;  } else {&#xA;    Text(&#34;${user.name} - $balance&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unfortunately, we are mixing business logic with display logic which makes testing harder than if it were separated. The display layer is also interacting directly with the storage layer which creates undesirable coupling. Additionally, if we want to power a different display with the same logic (potentially on another platform) we cannot.&lt;/p&gt; &#xA;&lt;p&gt;Extracting the business logic to a presenter-like object fixes these three things.&lt;/p&gt; &#xA;&lt;p&gt;In Cash App our presenter objects traditionally expose a single stream of display models through Kotlin coroutine&#39;s &lt;code&gt;Flow&lt;/code&gt; or RxJava &lt;code&gt;Observable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;sealed interface ProfileModel {&#xA;  object Loading : ProfileModel&#xA;  data class Data(&#xA;    val name: String,&#xA;    val balance: Long,&#xA;  ) : ProfileModel&#xA;}&#xA;&#xA;class ProfilePresenter(&#xA;  private val db: Db,&#xA;) {&#xA;  fun transform(events: Flow&amp;lt;Nothing&amp;gt;): Flow&amp;lt;ProfileModel&amp;gt; {&#xA;    return combine(&#xA;      db.users().onStart { emit(null) },&#xA;      db.balances().onStart { emit(0L) },&#xA;    ) { user, balance -&amp;gt;&#xA;      if (user == null) {&#xA;        Loading&#xA;      } else {&#xA;        Data(user.name, balance)&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This code is okay, but the ceremony of combining reactive streams will scale non-linearly. This means the more sources of data which are used and the more complex the logic the harder to understand the reactive code becomes.&lt;/p&gt; &#xA;&lt;p&gt;Despite emitting the &lt;code&gt;Loading&lt;/code&gt; state synchronously, Compose UI &lt;a href=&#34;https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#(kotlinx.coroutines.flow.Flow).collectAsState(kotlin.Any,kotlin.coroutines.CoroutineContext)&#34;&gt;requires an initial value&lt;/a&gt; be specified for all &lt;code&gt;Flow&lt;/code&gt; or &lt;code&gt;Observable&lt;/code&gt; usage. This is a layering violation as the view layer is not in the position to dictate a reasonable default since the presenter layer controls the model object.&lt;/p&gt; &#xA;&lt;p&gt;Molecule lets us fix both of these problems. Our presenter can return a &lt;code&gt;StateFlow&amp;lt;ProfileModel&amp;gt;&lt;/code&gt; whose initial state can be read synchronously at the view layer by Compose UI. And by using Compose we also can build our model objects using imperative code built on features of the Kotlin language rather than reactive code consisting of RxJava library APIs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun ProfilePresenter(&#xA;  userFlow: Flow&amp;lt;User&amp;gt;,&#xA;  balanceFlow: Flow&amp;lt;Long&amp;gt;,&#xA;): ProfileModel {&#xA;  val user by userFlow.collectAsState(null)&#xA;  val balance by balanceFlow.collectAsState(0L)&#xA;&#xA;  return if (user == null) {&#xA;    Loading&#xA;  } else {&#xA;    Data(user.name, balance)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This model-producing composable function can be run with &lt;code&gt;launchMolecule&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val userFlow = db.users()&#xA;val balanceFlow = db.balances()&#xA;val models: StateFlow&amp;lt;ProfileModel&amp;gt; = scope.launchMolecule(clock = ContextClock) {&#xA;  ProfilePresenter(userFlow, balanceFlow)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A coroutine that runs &lt;code&gt;ProfilePresenter&lt;/code&gt; and shares its output with the &lt;code&gt;StateFlow&lt;/code&gt; is launched into the provided &lt;code&gt;CoroutineScope&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;At the view-layer, consuming the &lt;code&gt;StateFlow&lt;/code&gt; of our model objects becomes trivial.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun Profile(models: StateFlow&amp;lt;ProfileModel&amp;gt;) {&#xA;  val model by models.collectAsState()&#xA;  when (model) {&#xA;    is Loading -&amp;gt; Text(&#34;Loading…&#34;)&#xA;    is Data -&amp;gt; Text(&#34;${model.name} - ${model.balance}&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information see &lt;a href=&#34;https://cashapp.github.io/molecule/docs/latest/molecule-runtime/app.cash.molecule/launch-molecule.html&#34;&gt;the &lt;code&gt;launchMolecule&lt;/code&gt; documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Flow&lt;/h3&gt; &#xA;&lt;p&gt;In addition to &lt;code&gt;StateFlow&lt;/code&gt;s, Molecule can create regular &lt;code&gt;Flow&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;p&gt;Here is the presenter example updated to use a regular &lt;code&gt;Flow&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val userFlow = db.users()&#xA;val balanceFlow = db.balances()&#xA;val models: Flow&amp;lt;ProfileModel&amp;gt; = moleculeFlow(clock = Immediate) {&#xA;  ProfilePresenter(userFlow, balanceFlow)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And the counter example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun counter(): Flow&amp;lt;Int&amp;gt; = moleculeFlow((clock = Immediate)) {&#xA;  val count by remember { mutableStateOf(0) }&#xA;&#xA;  LaunchedEffect(Unit) {&#xA;    while (true) {&#xA;      delay(1_000)&#xA;      count++&#xA;    }&#xA;  }&#xA;&#xA;  count&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information see &lt;a href=&#34;https://cashapp.github.io/molecule/docs/latest/molecule-runtime/app.cash.molecule/molecule-flow.html&#34;&gt;the &lt;code&gt;moleculeFlow&lt;/code&gt; documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Add the buildscript dependency and apply the plugin to every module which wants to call &lt;code&gt;launchMolecule&lt;/code&gt; or define &lt;code&gt;@Composable&lt;/code&gt; functions for use with Molecule.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildscript {&#xA;  repositories {&#xA;    mavenCentral()&#xA;  }&#xA;  dependencies {&#xA;    classpath &#39;app.cash.molecule:molecule-gradle-plugin:0.4.0&#39;&#xA;  }&#xA;}&#xA;&#xA;apply plugin: &#39;app.cash.molecule&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Snapshots of the development version are available in Sonatype&#39;s snapshots repository.&lt;/summary&gt; &#xA; &lt;p&gt; &lt;/p&gt;&#xA; &lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildscript {&#xA;  repositories {&#xA;    mavenCentral()&#xA;    maven {&#xA;      url &#39;https://oss.sonatype.org/content/repositories/snapshots/&#39;&#xA;    }&#xA;  }&#xA;  dependencies {&#xA;    classpath &#39;app.cash.molecule:molecule-gradle-plugin:0.5.0-SNAPSHOT&#39;&#xA;  }&#xA;}&#xA;&#xA;apply plugin: &#39;app.cash.molecule&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Frame Clock&lt;/h3&gt; &#xA;&lt;p&gt;Whenever Jetpack Compose recomposes, it always waits for the next frame before beginning its work. It is dependent on a &lt;code&gt;MonotonicFrameClock&lt;/code&gt; in its &lt;code&gt;CoroutineContext&lt;/code&gt; to know when a new frame is sent. Molecule is just Jetpack Compose under the hood, so it also requires a frame clock: values won&#39;t be produced until a frame is sent and recomposition occurs.&lt;/p&gt; &#xA;&lt;p&gt;Unlike Jetpack Compose, however, Molecule will sometimes be run in circumstances that do not provide a &lt;code&gt;MonotonicFrameClock&lt;/code&gt;. So all Molecule APIs require you to specify your preferred clock behavior:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;RecompositionClock.ContextClock&lt;/code&gt; behaves like Jetpack Compose: it will fish the &lt;code&gt;MonotonicFrameClock&lt;/code&gt; out of the calling &lt;code&gt;coroutineContext&lt;/code&gt; and use it for recomposition. If there is no &lt;code&gt;MonotonicFrameClock&lt;/code&gt;, it will throw an exception. &lt;code&gt;ContextClock&lt;/code&gt; is useful with Android&#39;s &lt;a href=&#34;https://cashapp.github.io/molecule/docs/latest/molecule-runtime/app.cash.molecule/-android-ui-dispatcher/-companion/-main.html&#34;&gt;&lt;code&gt;AndroidUiDispatcher.Main&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Main&lt;/code&gt; has a built-in &lt;code&gt;MonotonicFrameClock&lt;/code&gt; that is synchronized with the frame rate of the device. So a Molecule run on &lt;code&gt;Main&lt;/code&gt; with &lt;code&gt;ContextClock&lt;/code&gt; will run in lock step with the frame rate, too. Nifty! You can also provide your own &lt;code&gt;BroadcastFrameClock&lt;/code&gt; to implement your own frame rate.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RecompositionClock.Immediate&lt;/code&gt; will construct an immediate clock. This clock will produce a frame whenever the enclosing flow is ready to emit an item. (This is always the case for a &lt;code&gt;StateFlow&lt;/code&gt;.) &lt;code&gt;Immediate&lt;/code&gt; can be used where no clock is available at all without any additional wiring. It may be used for unit testing, or for running molecules off the main thread.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;p&gt;There are two options for testing:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Use &lt;code&gt;moleculeFlow(clock = Immediate)&lt;/code&gt; and test using &lt;a href=&#34;https://github.com/cashapp/turbine/&#34;&gt;Turbine&lt;/a&gt;. Your &lt;code&gt;moleculeFlow&lt;/code&gt; will run just like any other flow does in Turbine.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use the &lt;code&gt;molecule-testing&lt;/code&gt; dependency. &lt;code&gt;molecule-testing&lt;/code&gt; provides a &lt;code&gt;testMolecule&lt;/code&gt; function with a Turbine-like API.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;dependencies {&#xA;  testImplementation(&#34;app.cash.molecule:molecule-testing&#34;)&#xA;  // or androidTestImplementation…&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike &lt;code&gt;moleculeFlow(clock = Immediate)&lt;/code&gt;, &lt;code&gt;testMolecule&lt;/code&gt; simulates clock ticks: Calling &lt;code&gt;awaitItem&lt;/code&gt; yields to running coroutines and &#34;ticks&#34; the Molecule&#39;s clock until a change to snapshot state occurs, triggering a fresh recomposition and a new item. If snapshot state is never changed, no recomposition will ever occur and &lt;code&gt;awaitItem&lt;/code&gt; will fail.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Test fun counting() {&#xA;  testMolecule({ Counter(1, 3) }) {&#xA;    assertEquals(1, awaitItem())&#xA;    assertEquals(2, awaitItem())&#xA;    assertEquals(3, awaitItem())&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information see &lt;a href=&#34;https://cashapp.github.io/molecule/docs/latest/molecule-testing/app.cash.molecule.testing/test-molecule.html&#34;&gt;the documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright 2021 Square, Inc.&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;   http://www.apache.org/licenses/LICENSE-2.0&#xA;&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>