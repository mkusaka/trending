<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-17T01:35:24Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>yandex/yatagan</title>
    <updated>2022-12-17T01:35:24Z</updated>
    <id>tag:github.com,2022-12-17:/yandex/yatagan</id>
    <link href="https://github.com/yandex/yatagan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Dependency Injection framework based on Google&#39;s Dagger2 API, optimized for fast builds and for managing large graphs with optional dependencies&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Yatagan&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://maven-badges.herokuapp.com/maven-central/com.yandex.yatagan/api-compiled&#34;&gt;&lt;img src=&#34;https://maven-badges.herokuapp.com/maven-central/com.yandex.yatagan/api-compiled/badge.svg?sanitize=true&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/yandex/yatagan/actions/workflows/main.yaml&#34;&gt;&lt;img src=&#34;https://github.com/yandex/yatagan/actions/workflows/main.yaml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache%202.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Yatagan is a fast &lt;strong&gt;Dependency Injection framework&lt;/strong&gt; based on Google&#39;s &lt;a href=&#34;https://dagger.dev/&#34;&gt;Dagger2&lt;/a&gt; API.&lt;/p&gt; &#xA;&lt;p&gt;Yatagan is optimized for fast builds and supports managing large dynamic dependency graphs by introducing &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/#added-apis&#34;&gt;&lt;em&gt;Conditions&lt;/em&gt; and &lt;em&gt;Variants&lt;/em&gt;&lt;/a&gt;. It&#39;s primary goal is to &lt;strong&gt;improve build speed in large complex projects, which already use Dagger&lt;/strong&gt;. Though it might be useful for others.&lt;/p&gt; &#xA;&lt;p&gt;All core Dagger API is supported with little changes. Yet dagger-android, Hilt and a couple of less popular features are not supported. See comparative &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/#yatagan-vs-dagger-api-reference&#34;&gt;API reference&lt;/a&gt; for full info.&lt;/p&gt; &#xA;&lt;p&gt;Yatagan can work in multiple modes (use different &lt;em&gt;backends&lt;/em&gt;):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;With code generation &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;APT/KAPT - classic mode.&lt;/li&gt; &#xA;   &lt;li&gt;KSP - leverages new Google &lt;a href=&#34;https://kotlinlang.org/docs/ksp-quickstart.html&#34;&gt;KSP&lt;/a&gt; framework. Experimental, see &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/#ksp-support&#34;&gt;KSP support status&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Via runtime Java reflection - a backend designed for fast local debug builds, see specific &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/#reflection-support&#34;&gt;notes&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All backends are designed to be working &lt;em&gt;identically&lt;/em&gt;, so one can easily switch backends depending on the working environment and requirements. Any inconsistencies between backends ought to be reported and fixed.&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;One can consider migrating to Yatagan from vanilla Dagger if at least one of the points is true for their project:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The project uses Dagger and has &lt;strong&gt;build performance issues&lt;/strong&gt; because of it.&lt;/li&gt; &#xA; &lt;li&gt;The project needs/extensively uses &lt;strong&gt;dynamic optional dependencies&lt;/strong&gt; in its DI graphs.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Yatagan tackles both of these issues.&lt;/p&gt; &#xA;&lt;p&gt;Read more and dive into technical details in the Medium &lt;a href=&#34;https://medium.com/p/eb58ca20d52f/&#34;&gt;article&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Performance&lt;/h3&gt; &#xA;&lt;p&gt;As of the first point, performance gains can vary per project due to specific details and Yatagan usage configuration. Yatagan allows clients to &lt;strong&gt;apply processing to fewer project modules&lt;/strong&gt; in comparison to Dagger. Yatagan processing should only be applied to project modules, that contain &lt;em&gt;root components&lt;/em&gt;, and shouldn&#39;t be applied at all in case of reflection mode usage.&lt;/p&gt; &#xA;&lt;p&gt;Thus, a project will have the biggest performance gain from using Yatagan, if the majority of the project modules have only one annotation processor - Dagger. Then upon migration to Yatagan project modules without root components can have kapt completely switched off with it remaining in root-component modules. Furthermore, root-component modules can also become kapt-free with Reflection mode. In a good scenario Yatagan can make incremental builds &lt;strong&gt;up to two times faster&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If other annotation processors besides Dagger are used throughout the project in KAPT mode, then performance gain from using Yatagan will be lower. One can try and reorganise the project to limit other annotation processors appliance to small modules or use them in KSP mode if supported. Reflection mode is also supported for some frameworks that feature code generation. It can be enabled in debug builds if this allows to eliminate KAPT from the project module.&lt;/p&gt; &#xA;&lt;p&gt;The general idea is to remove KAPT from as many modules as possible, with large modules yielding more profit, so feel free to experiment with what Yatagan offers for this task.&lt;/p&gt; &#xA;&lt;p&gt;In the worst case scenario, where using Yatagan doesn&#39;t remove KAPT from any of the modules, profits can still be around ~ 10% due to Yatagan optimizations.&lt;/p&gt; &#xA;&lt;h3&gt;Runtime conditions&lt;/h3&gt; &#xA;&lt;p&gt;The second point can be clarified by the following code snippet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Singleton&#xA;class MyClass @Inject constructor(&#xA;    /**&#xA;     * Dynamic optional dependency, that is present/absent in DI-graph based on declared runtime condition.&#xA;     */&#xA;    val myOptionalDependency: Optional&amp;lt;MyClassUnderRuntimeCondition&amp;gt;,&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is one of the approaches that can be taken into coding optional dependencies. Naturally, such thing can be written with Dagger&#39;s &lt;code&gt;@Provides Optional&amp;lt;MyClassUnderRuntimeCondition&amp;gt; provide(..) { .. }&lt;/code&gt; yet such code is arguably difficult to maintain, verbose, and scales poorly with the growing number of conditions and classes under them.&lt;/p&gt; &#xA;&lt;p&gt;Yatagan solves this by introducing first-class runtime condition support with compile-time condition validation. See &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/#added-apis&#34;&gt;&lt;em&gt;Conditions&lt;/em&gt;/&lt;em&gt;Variants&lt;/em&gt; APIs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage (Gradle)&lt;/h2&gt; &#xA;&lt;p&gt;Code generation dependency is only required for project modules, that contain root component declarations (&lt;code&gt;@Component(isRoot = true/* default */)&lt;/code&gt;). For modules, that contain classes with &lt;code&gt;@Inject&lt;/code&gt;, &lt;code&gt;@Provides&lt;/code&gt;, etc.. no dependencies but &#34;api&#34; ones are required. This is different for Dagger, which requires you to apply annotation processing in every module with DI code to allow Gradle incremental compilation/annotation processing to work correctly.&lt;/p&gt; &#xA;&lt;p&gt;Yatagan can be used in various configurations. Choose one, that suits your project. See the following Gradle buildscript usage snippets (code is assumed to be inside a &lt;code&gt;dependencies {}&lt;/code&gt; block).&lt;/p&gt; &#xA;&lt;p&gt;For kotlin-only/mixed project using &lt;strong&gt;kapt&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Ensure `kotlin-kapt` plugin is applied&#xA;api(&#34;com.yandex.yatagan:api-compiled:${yataganVer}&#34;)&#xA;// kapt is slow but generally reliable for mixed projects.&#xA;kapt(&#34;com.yandex.yatagan:processor-jap:${yataganVer}&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For kotlin-only/mixed project using &lt;strong&gt;KSP&lt;/strong&gt; (use with caution for Java code): (&lt;a href=&#34;https://kotlinlang.org/docs/ksp-quickstart.html#use-your-own-processor-in-a-project&#34;&gt;How to&lt;/a&gt; apply KSP plugin)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Ensure `com.google.devtools.ksp` plugin is applied&#xA;api(&#34;com.yandex.yatagan:api-compiled:${yataganVer}&#34;)&#xA;// KSP implementation is unstable. Works best for pure-Kotlin projects.&#xA;ksp(&#34;com.yandex.yatagan:processor-jap:${yataganVer}&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To dramatically speed up build one can use &lt;strong&gt;runtime reflection&lt;/strong&gt; instead of codegen:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// No codegen dependency is required, the reflection engine comes as a dependency of the `api-dynamic` artifact.&#xA;api(&#34;com.yandex.yatagan:api-dynamic:${yataganVer}&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;strong&gt;java-only&lt;/strong&gt; project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;api(&#34;com.yandex.yatagan:api-compiled:${yataganVer}&#34;)&#xA;// best codegen backend for Java-only, no need to use kapt/ksp.&#xA;annotationProcessor(&#34;com.yandex.yatagan:processor-jap:${yataganVer}&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Android&lt;/strong&gt; projects are advised to follow the same usage guidelines, though make sure to read the &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/#android&#34;&gt;notes&lt;/a&gt; on reflection on Android. An example of a recommended way to use Yatagan for Android projects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Use reflection in debug builds.&#xA;debugApi(&#34;com.yandex.yatagan:api-dynamic:${yataganVer}&#34;)&#xA;&#xA;// Use codegen in releases&#xA;releaseApi(&#34;com.yandex.yatagan:api-compiled:${yataganVer}&#34;)&#xA;if (kspEnabled) {&#xA;    kspRelease(&#34;com.yandex.yatagan:processor-ksp:${yataganVer}&#34;)&#xA;} else {&#xA;    kaptRelease(&#34;com.yandex.yatagan:processor-jap:${yataganVer}&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One may want to create a shared library that exposes a piece of Yatagan graph, yet doesn&#39;t create any root components itself. In this case, the library can depend on &lt;code&gt;com.yandex.yatagan:api-public&lt;/code&gt;, which provides pure Yatagan API and no backend-specific entry-points.&lt;/p&gt; &#xA;&lt;h2&gt;Backends&lt;/h2&gt; &#xA;&lt;h3&gt;KAPT/APT&lt;/h3&gt; &#xA;&lt;p&gt;APT or KAPT (Yatagan qualifies the artifacts with &lt;code&gt;jap&lt;/code&gt;, &lt;strong&gt;j&lt;/strong&gt;ava &lt;strong&gt;a&lt;/strong&gt;nnotation &lt;strong&gt;p&lt;/strong&gt;rocessing) is a legacy backend, though it&#39;s stable and can be reliably used by default.&lt;/p&gt; &#xA;&lt;h3&gt;KSP support&lt;/h3&gt; &#xA;&lt;p&gt;Yatagan supports KSP in experimental mode. This is mostly due to the fact that Yatagan operates in terms of Java type system and is very sensitive to type equality. In Kotlin, &lt;code&gt;Collection&lt;/code&gt; and &lt;code&gt;MutableCollection&lt;/code&gt; are different types, though in Java it&#39;s the same type. From the other hand, Kotlin&#39;s &lt;code&gt;Int&lt;/code&gt; is represented in Java as &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;Integer&lt;/code&gt;. Choosing Java types to maintain semantic compatibility with Dagger, Yatagan converts Kotlin types into Java ones. KSP API related to JVM is explicitly marked as &lt;code&gt;@KspExperimental&lt;/code&gt;, and practice shows KSP support for modeling Java code is at least inconsistent.&lt;/p&gt; &#xA;&lt;p&gt;Thus, KSP can be adopted for Kotlin-only projects, or projects whose DI-code is mostly Kotlin. Additional care should be taken with Java projects.&lt;/p&gt; &#xA;&lt;p&gt;Also, KSP strictly depends on Kotlin compiler version, used in your project, so using KSP may force you to keep updating Kotlin compiler version frequently.&lt;/p&gt; &#xA;&lt;h3&gt;Reflection support&lt;/h3&gt; &#xA;&lt;p&gt;Reflection support is considered stable in Yatagan. There&#39;s already a very similar project for the vanilla Dagger - &lt;a href=&#34;https://github.com/JakeWharton/dagger-reflect&#34;&gt;dagger-reflect&lt;/a&gt;. However, Reflection mode in Yatagan has fist-class support and guaranteed to behave the same way, as generated implementation would. If a new feature is implemented in Yatagan, reflection automatically works with it.&lt;/p&gt; &#xA;&lt;p&gt;Technically, reflection mode can be used in production, though it&#39;s advised not to do so, as code generation naturally produces much more performant code. Also, reflection mode is broken by code minifiers, such as Proguard or R8.&lt;/p&gt; &#xA;&lt;p&gt;Read more in &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/rt/README.md&#34;&gt;reflection backend specific notes&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Android&lt;/h4&gt; &#xA;&lt;p&gt;Reflection backend fully supports Android applications starting with &lt;code&gt;minSdk = 24&lt;/code&gt;. Below that, static methods in interfaces are not directly supported in Android and have to be &#34;desugared&#34; by AGP. Yatagan Reflection doesn&#39;t currently read such desugared methods as they have no stable ABI and reading them will bring performance penalties. So consider using &lt;code&gt;minSdk = 24&lt;/code&gt; at least for debug build type to safely use Yatagan with Reflection.&lt;/p&gt; &#xA;&lt;h2&gt;Yatagan vs Dagger API reference&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Dagger2 API (&lt;code&gt;dagger.**&lt;/code&gt;)&lt;/th&gt; &#xA;   &lt;th&gt;Status in Yatagan&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@Component.Builder&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;supports factory method as well&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@Component.Factory&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟡 converged&lt;/td&gt; &#xA;   &lt;td&gt;functionality merged into &lt;code&gt;@Builder&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@Subcomponent&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟡 converged&lt;/td&gt; &#xA;   &lt;td&gt;replaced by &lt;code&gt;Component(isRoot = false)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@Subcomponent.{Builder/Factory}&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟡 converged&lt;/td&gt; &#xA;   &lt;td&gt;replaced by &lt;code&gt;Component.Builder&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Lazy&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;now also extends &lt;code&gt;javax.inject.Provider&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@Module&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@Binds&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟡 tweaked&lt;/td&gt; &#xA;   &lt;td&gt;can bind zero/multiple alternatives&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@BindsInstance&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@Provides&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;supports conditional provision&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@BindsOptionalOf&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟡 replaced&lt;/td&gt; &#xA;   &lt;td&gt;replaced with &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/#added-apis&#34;&gt;Variants API&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@Reusable&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🔴 unsupported&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;MembersInjector&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🔴 unsupported&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@MapKey&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟡 renamed*&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;IntoMap.Key&lt;/code&gt;, *&lt;code&gt;unwrap=false&lt;/code&gt; is unsupported&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@multibindings.IntoSet&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@multibindings.ElementsIntoSet&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟡 converged&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;IntoSet(flatten = true)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@multibindings.Multibinds&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@multibindings.IntoMap&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@multibindings.{Int,Class,String}Key&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;@multibindings.LongKey&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🔴 removed&lt;/td&gt; &#xA;   &lt;td&gt;can be declared manually if required&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;assisted.*&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟢 as is&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;producers.*&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🔴 unsupported&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;android.*&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🔴 unsupported&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;grpc.*&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🔴 unsupported&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;hilt.**&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🔴 unsupported&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;spi.*&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;🟡 replaced&lt;/td&gt; &#xA;   &lt;td&gt;Yatagan has its own model for &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/#plugins&#34;&gt;SPI&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Other behavioral changes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;@Binds&lt;/code&gt; can&#39;t be scoped (scope rebind is not allowed). Use scope on the implementation. Also, Yatagan supports declaring multiple scopes on bindings, so the binding is compatible with &lt;em&gt;every&lt;/em&gt; scope declared. Dagger only allowed doing so for components.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Yatagan requires components, builders, assisted inject factories to be declared as interfaces. Abstract classes are forbidden. This is due to the limitations of RT mode. Dagger-reflect has the same limitation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If codegen is used, generated component implementations are not named &lt;code&gt;Dagger&amp;lt;component-name&amp;gt;&lt;/code&gt;, their names are mangled, and the access should be made via &lt;code&gt;Yatagan.builder()&lt;/code&gt;/&lt;code&gt;Yatagan.create()&lt;/code&gt; entry-point invocations. This is made to support reflection backend. Actual &lt;code&gt;Yatagan&lt;/code&gt; implementations are provided within &lt;code&gt;com.yandex.yatagan:api-dynamic&lt;/code&gt; and &lt;code&gt;com.yandex.yatagan:api-compiled&lt;/code&gt; artifacts.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Yatagan does not support &lt;code&gt;@Nullable&lt;/code&gt; provisions. If a binding returns &lt;code&gt;null&lt;/code&gt;, or a &lt;code&gt;@BindsInstance&lt;/code&gt; is supplied with &lt;code&gt;null&lt;/code&gt;, an error will be thrown at run-time. Currently, no compile-time validation is done in the matter.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Declaring subcomponents only works explicitly via &lt;code&gt;Module.subcomponents&lt;/code&gt; list. Implicit bindings for subcomponent factory, when declaring entry-point of its type in a parent component, will not trigger subcomponent inclusion.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatic component factory/builder generation is not supported - an explicit one must be written if required.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Member inject in Kotlin code should be used with care: &lt;code&gt;@Inject lateinit var prop: SomeClass&lt;/code&gt; will work as expected, though &lt;code&gt;@Inject @Named(&#34;id&#34;) lateinit var prop: SomeClass&lt;/code&gt; will not - qualifier annotation will go to the &lt;em&gt;property&lt;/em&gt; instead of &lt;em&gt;field&lt;/em&gt;, and Yatagan will not be able to see it. In fact vanilla Dagger will also fail to see it in some scenarios, though it tries to do so on the best-effort basis. Yatagan can&#39;t read annotations from Kotlin properties, so the following explicit forms should be used instead: &lt;code&gt;@Inject @field:Named(&#34;id&#34;) lateinit var prop: SomeClass&lt;/code&gt; to inject directly to the field, or &lt;code&gt;@set:Inject @set:Named(&#34;id&#34;) lateinit var prop: SomeClass&lt;/code&gt; to inject via setter.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Yatagan was written from scratch, and as major known inconsistencies are documented here, there is a possibility for differences that are overlooked. If you happen to discover one, please report it.&lt;/p&gt; &#xA;&lt;h2&gt;Migration from Dagger&lt;/h2&gt; &#xA;&lt;p&gt;Strictly speaking, Yatagan and Dagger are &lt;em&gt;not directly compatible&lt;/em&gt;. Yatagan uses a separate binary-incompatible set of annotations and helpers to give it a degree of freedom to extend and enhance the API.&lt;/p&gt; &#xA;&lt;p&gt;Yet for the majority of cases, as documented in the &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/#yatagan-vs-dagger-api-reference&#34;&gt;api reference&lt;/a&gt;, annotations and classes differ only in package names, which makes migration from Dagger to Yatagan somewhat trivial.&lt;/p&gt; &#xA;&lt;p&gt;The general idea of steps one needs to take to migrate from Yatagan to Dagger:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Replace &lt;code&gt;import dagger\.multibindings\.&lt;/code&gt; -&amp;gt; &lt;code&gt;import com.yandex.yatagan.&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Replace &lt;code&gt;import dagger\.assisted\.&lt;/code&gt; -&amp;gt; &lt;code&gt;import com.yandex.yatagan.&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Replace &lt;code&gt;import dagger\.&lt;/code&gt; -&amp;gt; &lt;code&gt;import com.yandex.yatagan.&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Replace &lt;code&gt;@Subcomponent&lt;/code&gt; annotations with &lt;code&gt;@Component(isRoot = false)&lt;/code&gt; ones.&lt;/li&gt; &#xA; &lt;li&gt;Replace &lt;code&gt;@Component.Factory&lt;/code&gt; with &lt;code&gt;@Component.Builder&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Get rid of all nullable provisions. Yatagan does not support them.&lt;/li&gt; &#xA; &lt;li&gt;Replace &lt;code&gt;DaggerMyComponent.builder()&lt;/code&gt; with &lt;code&gt;Yatagan.builder(MyComponent.Builder::class.java)&lt;/code&gt; or similar.&lt;/li&gt; &#xA; &lt;li&gt;Mark all components, that are accessed from multiple threads as &lt;code&gt;@Component(.., multiThreadAccess = true)&lt;/code&gt;. If you are unsure, if a component is accessed from a single thread, but ideally it should be, you can set up a check with &lt;code&gt;Yatagan.setThreadAsserter()&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run build and fix all remaining inconsistencies (like implicitly included subcomponents, etc..).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Added APIs&lt;/h2&gt; &#xA;&lt;p&gt;Yatagan introduces the following new APIs, that can be utilized to work with &lt;strong&gt;conditional bindings&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The first one is &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/api/public/src/main/kotlin/Condition.kt&#34;&gt;&lt;code&gt;@Condition&lt;/code&gt;&lt;/a&gt;. With this annotation, one can declare a &lt;strong&gt;runtime condition&lt;/strong&gt; that can be evaluated and its value will determine the presence/absence of a binding under the condition.&lt;/p&gt; &#xA;&lt;p&gt;To put a binding under a given condition, one must use &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/api/public/src/main/kotlin/Conditional.kt&#34;&gt;&lt;code&gt;@Conditional&lt;/code&gt;&lt;/a&gt; annotation on a binding or a class with &lt;code&gt;@Inject&lt;/code&gt;-annotated constructor.&lt;/p&gt; &#xA;&lt;p&gt;Variant API ideally replaces Dagger&#39;s &lt;code&gt;@BindsOptionalOf&lt;/code&gt; and makes it more powerful. It&#39;s very alike to how Android works with flavors and dimensions, only here we can declare components having such flavors and include/exclude bindings based on them. To use that, one can employ &lt;code&gt;@Conditional(.., onlyIn = ...)&lt;/code&gt; and &lt;code&gt;@Component(variant = ...)&lt;/code&gt; attributes.&lt;/p&gt; &#xA;&lt;p&gt;Feel free to read a small tutorial doc, that includes &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/api/README.md&#34;&gt;how to use conditions and variants&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Plugins&lt;/h2&gt; &#xA;&lt;p&gt;One can write an extension for &lt;em&gt;validation&lt;/em&gt; pipeline for Yatagan to implement one&#39;s custom graph inspections. No additional code generation is currently supported for plugins, and they can not modify graphs under inspection. This works, as for Dagger, via SPI. Read more &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/validation/spi/README.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Options&lt;/h2&gt; &#xA;&lt;p&gt;Yatagan has some options, that tweak its behavior. They are provided as normal annotation processor options. However, reflection backend requires a different approach in specifying them, as documented &lt;a href=&#34;https://raw.githubusercontent.com/yandex/yatagan/main/rt/README.md#reflection-specific-api&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Option key&lt;/th&gt; &#xA;   &lt;th&gt;Default value&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;yatagan.enableStrictMode&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;true&lt;/td&gt; &#xA;   &lt;td&gt;if enabled, every &lt;em&gt;mandatory warning&lt;/em&gt; is reported as an error&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;yatagan.maxIssueEncounterPaths&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;the max number of places &lt;code&gt;Encountered in&lt;/code&gt; in an error message to be mentioned&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;yatagan.usePlainOutput&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;if enabled, reporting is done in plain text, without ANSI coloring&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>