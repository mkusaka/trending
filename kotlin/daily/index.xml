<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-15T01:39:05Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Houvven/Guise</title>
    <updated>2023-02-15T01:39:05Z</updated>
    <id>tag:github.com,2023-02-15:/Houvven/Guise</id>
    <link href="https://github.com/Houvven/Guise" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Put a sheep&#39;s skin on your Android app&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Xposed-Modules-Repo/com.houvven.guise.git&#34;&gt;https://github.com/Xposed-Modules-Repo/com.houvven.guise.git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/KHwang9883&#34;&gt;KHwang9883&lt;/a&gt;/&lt;strong&gt;&lt;a href=&#34;https://github.com/KHwang9883/MobileModels&#34;&gt;MobileModels&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gallonyin&#34;&gt;gallonyin&lt;/a&gt;/&lt;strong&gt;&lt;a href=&#34;https://github.com/gallonyin/weworkhook&#34;&gt;weworkhook&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent&#34;&gt;Tencent&lt;/a&gt;/&lt;strong&gt;&lt;a href=&#34;https://github.com/Tencent/MMKV&#34;&gt;MMKV&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>square/anvil</title>
    <updated>2023-02-15T01:39:05Z</updated>
    <id>tag:github.com,2023-02-15:/square/anvil</id>
    <link href="https://github.com/square/anvil" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Kotlin compiler plugin to make dependency injection with Dagger 2 easier.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Anvil&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://search.maven.org/search?q=g:%22com.squareup.anvil%22&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.squareup.anvil/gradle-plugin.svg?label=Maven%20Central&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/square/anvil/actions?query=branch%3Amain&#34;&gt;&lt;img src=&#34;https://github.com/square/anvil/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;&#34;When all you have is an anvil, every problem looks like a hammer.&#34;&lt;/em&gt; - &lt;a href=&#34;https://en.wikipedia.org/wiki/Law_of_the_instrument&#34;&gt;Abraham Maslow&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Anvil is a Kotlin compiler plugin to make dependency injection with &lt;a href=&#34;https://dagger.dev/&#34;&gt;Dagger&lt;/a&gt; easier by automatically merging Dagger modules and component interfaces. In a nutshell, instead of manually adding modules to a Dagger component and making the Dagger component extend all component interfaces, these modules and interfaces can be included in a component automatically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Module&#xA;@ContributesTo(AppScope::class)&#xA;class DaggerModule { .. }&#xA;&#xA;@ContributesTo(AppScope::class)&#xA;interface ComponentInterface {&#xA;  fun getSomething(): Something&#xA;  fun injectActivity(activity: MyActivity)&#xA;}&#xA;&#xA;// The real Dagger component.&#xA;@MergeComponent(AppScope::class)&#xA;interface AppComponent&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The generated &lt;code&gt;AppComponent&lt;/code&gt; interface that Dagger sees looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Component(modules = [DaggerModule::class])&#xA;interface AppComponent : ComponentInterface&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that &lt;code&gt;AppComponent&lt;/code&gt; automatically includes &lt;code&gt;DaggerModule&lt;/code&gt; and extends &lt;code&gt;ComponentInterface&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;The plugin consists of a Gradle plugin and Kotlin compiler plugin. The Gradle plugin automatically adds the Kotlin compiler plugin and annotation dependencies. It needs to be applied in all modules that either contribute classes to the dependency graph or merge them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;plugins {&#xA;  id &#39;com.squareup.anvil&#39; version &#34;${latest_version}&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can use the old way to apply a plugin:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildscript {&#xA;  repositories {&#xA;    mavenCentral()&#xA;  }&#xA;  dependencies {&#xA;    classpath &#34;com.squareup.anvil:gradle-plugin:${latest_version}&#34;&#xA;  }&#xA;}&#xA;&#xA;apply plugin: &#39;com.squareup.anvil&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;There are three important annotations to work with Anvil.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;@ContributesTo&lt;/code&gt; can be added to Dagger modules and component interfaces that should be included in the Dagger component. Classes with this annotation are automatically merged by the compiler plugin as long as they are on the compile classpath.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;@MergeComponent&lt;/code&gt; is used instead of the Dagger annotation &lt;code&gt;@Component&lt;/code&gt;. Anvil will generate the Dagger annotation and automatically include all modules and component interfaces that were contributed the same scope.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;@MergeSubcomponent&lt;/code&gt; is similar to &lt;code&gt;@MergeComponent&lt;/code&gt; and should be used for subcomponents instead.&lt;/p&gt; &#xA;&lt;h2&gt;Scopes&lt;/h2&gt; &#xA;&lt;p&gt;Scope classes are only markers. The class &lt;code&gt;AppScope&lt;/code&gt; from the sample could look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class AppScope private constructor()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These scope classes help Anvil make a connection between the Dagger component and which Dagger modules and other component interfaces to include.&lt;/p&gt; &#xA;&lt;p&gt;Scope classes are independent of the Dagger scopes. It&#39;s still necessary to set a scope for the Dagger component, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Singleton&#xA;@MergeComponent(AppScope::class)&#xA;interface AppComponent&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributed bindings&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;@ContributesBinding&lt;/code&gt; annotation generates a Dagger binding method for an annotated class and contributes this binding method to the given scope. Imagine this example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface Authenticator&#xA;&#xA;class RealAuthenticator @Inject constructor() : Authenticator&#xA;&#xA;@Module&#xA;@ContributesTo(AppScope::class)&#xA;abstract class AuthenticatorModule {&#xA;  @Binds abstract fun bindRealAuthenticator(authenticator: RealAuthenticator): Authenticator&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is a lot of boilerplate if you always want to use &lt;code&gt;RealAuthenticator&lt;/code&gt; when injecting &lt;code&gt;Authenticator&lt;/code&gt;. You can replace this entire Dagger module with the &lt;code&gt;@ContributesBinding&lt;/code&gt; annotation. The equivalent would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface Authenticator&#xA;&#xA;@ContributesBinding(AppScope::class)&#xA;class RealAuthenticator @Inject constructor() : Authenticator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;@ContributesBinding&lt;/code&gt; also supports qualifiers. You can annotate the class with any qualifier and the generated binding method will preserve the qualifier, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ContributesBinding(AppScope::class)&#xA;@Named(&#34;Prod&#34;)&#xA;class RealAuthenticator @Inject constructor() : Authenticator&#xA;&#xA;// Will generate:&#xA;@Binds @Named(&#34;Prod&#34;) &#xA;abstract fun bindRealAuthenticator(authenticator: RealAuthenticator): Authenticator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributed multibindings&lt;/h2&gt; &#xA;&lt;p&gt;Similar to contributed bindings, &lt;code&gt;@ContributesMultibinding&lt;/code&gt; will generate a multibindings method for (all/an) annotated class(es). Qualifiers are supported the same way as normal bindings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ContributesMultibinding(AppScope::class)&#xA;@Named(&#34;Prod&#34;)&#xA;class MainListener @Inject constructor() : Listener&#xA;&#xA;// Will generate this binding method.&#xA;@Binds @IntoSet @Named(&#34;Prod&#34;)&#xA;abstract fun bindMainListener(listener: MainListener): Listener&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the class is annotated with a map key annotation, then Anvil will generate a maps multibindings method instead of adding the element to a set:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@MapKey&#xA;annotation class BindingKey(val value: String)&#xA;&#xA;@ContributesMultibinding(AppScope::class)&#xA;@BindingKey(&#34;abc&#34;)&#xA;class MainListener @Inject constructor() : Listener&#xA;&#xA;// Will generate this binding method.&#xA;@Binds @IntoMap @BindingKey(&#34;abc&#34;)&#xA;abstract fun bindMainListener(listener: MainListener): Listener&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Exclusions&lt;/h2&gt; &#xA;&lt;p&gt;Dagger modules and component interfaces can be excluded in two different levels.&lt;/p&gt; &#xA;&lt;p&gt;One class can always replace another one. This is especially helpful for modules that provide different bindings for instrumentation tests, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Module&#xA;@ContributesTo(&#xA;    scope = AppScope::class,&#xA;    replaces = [DevelopmentApplicationModule::class]&#xA;)&#xA;object DevelopmentApplicationTestModule {&#xA;  @Provides&#xA;  fun provideEndpointSelector(): EndpointSelector = TestingEndpointSelector&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The compiler plugin will find both classes on the classpath. Adding both modules &lt;code&gt;DevelopmentApplicationModule&lt;/code&gt; and &lt;code&gt;DevelopmentApplicationTestModule&lt;/code&gt; to the Dagger graph would lead to duplicate bindings. Anvil sees that the test module wants to replace the other and ignores it. This replacement rule has a global effect for all applications which are including the classes on the classpath.&lt;/p&gt; &#xA;&lt;p&gt;Applications can exclude Dagger modules and component interfaces individually without affecting other applications.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@MergeComponent(&#xA;  scope = AppScope::class,&#xA;  exclude = [&#xA;    DaggerModule::class&#xA;  ]&#xA;)&#xA;interface AppComponent&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In a perfect build graph it’s unlikely that this feature is needed. However, due to legacy modules, wrong imports and deeply nested dependency chains applications might need to make use of it. The exclusion rule does what it implies. In this specific example &lt;code&gt;DaggerModule&lt;/code&gt; wishes to be contributed to this scope, but it has been excluded for this component and thus is not added.&lt;/p&gt; &#xA;&lt;h2&gt;Dagger Factory Generation&lt;/h2&gt; &#xA;&lt;p&gt;Anvil allows you to generate Factory classes that usually the Dagger annotation processor would generate for &lt;code&gt;@Provides&lt;/code&gt; methods, &lt;code&gt;@Inject&lt;/code&gt; constructors and &lt;code&gt;@Inject&lt;/code&gt; fields. The benefit of this feature is that you don&#39;t need to enable the Dagger annotation processor in this module. That often means you can skip KAPT and the stub generating task. In addition Anvil generates Kotlin instead of Java code, which allows Gradle to skip the Java compilation task. The result is faster builds.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;anvil {&#xA;  generateDaggerFactories = true // default is false&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In our codebase we measured that modules using Dagger build 65% faster with this new Anvil feature compared to using the Dagger annotation processor:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Stub generation&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Kapt&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Javac&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Kotlinc&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Sum&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Dagger&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;12.976&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;40.377&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;8.571&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;10.241&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;72.165&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Anvil&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;0&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;0&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;6.965&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;17.748&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;24.713&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For full builds of applications we measured savings of 16% on average.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/square/anvil/main/images/benchmark_dagger_factories.png?raw=true&#34; alt=&#34;Benchmark Dagger Factories&#34; title=&#34;Benchmark Dagger Factories&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This feature can only be enabled in Gradle modules that don&#39;t compile any Dagger component. Since Anvil only processes Kotlin code, you shouldn&#39;t enable it in modules with mixed Kotlin / Java sources either.&lt;/p&gt; &#xA;&lt;p&gt;When you enable this feature, don&#39;t forget to remove the Dagger annotation processor. You should keep all other dependencies.&lt;/p&gt; &#xA;&lt;h2&gt;Extending Anvil&lt;/h2&gt; &#xA;&lt;p&gt;Every codebase has its own dependency injection patterns where certain code structures need to be repeated over and over again. Here Anvil comes to the rescue and you can extend the compiler plugin with your own &lt;code&gt;CodeGenerator&lt;/code&gt;. For usage please take a look at the &lt;a href=&#34;https://raw.githubusercontent.com/square/anvil/main/compiler-api/README.md&#34;&gt;&lt;code&gt;compiler-api&lt;/code&gt; artifact&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Advantages of Anvil&lt;/h2&gt; &#xA;&lt;p&gt;Adding Dagger modules to components in a large modularized codebase with many application targets is overhead. You need to know where components are defined when creating a new Dagger module and which modules to add when setting up a new application. This task involves many syncs in the IDE after adding new module dependencies in the build graph. The process is tedious and cumbersome. With Anvil you only add a dependency in your build graph and then you can immediately test the build.&lt;/p&gt; &#xA;&lt;p&gt;Aligning the build graph and Dagger&#39;s dependency graph brings a lot of consistency. If code is on the compile classpath, then it&#39;s also included in the Dagger dependency graph.&lt;/p&gt; &#xA;&lt;p&gt;Modules implicitly have a scope, if provided objects are tied to a scope. Now the scope of a module is clear without looking at any binding.&lt;/p&gt; &#xA;&lt;p&gt;With Anvil you don&#39;t need any composite Dagger module anymore, which only purpose is to combine multiple modules to avoid repeating the setup for multiple applications. Composite modules easily become hairballs. If one application wants to exclude a module, then it has to repeat the setup. These forked graphs are painful and confusing. With Dagger you want to make the decision which modules fulfill dependencies as late as possible, ideally in the application module. Anvil makes this approach a lot easier by generating the code for included modules. Composite modules are redundant. You make the decision which bindings to use by importing the desired module in the application module.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;Anvil is a convenience tool. Similar to Dagger it doesn&#39;t improve build speed compared to writing all code manually before running a build. The savings are in developer time.&lt;/p&gt; &#xA;&lt;p&gt;The median overhead of Anvil is around 4%, which often means only a few hundred milliseconds on top. The overhead is marginal, because Kotlin code is still compiled incrementally and Kotlin compile tasks are skipped entirely, if nothing has changed. This doesn&#39;t change with Anvil.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/square/anvil/main/images/benchmark.png?raw=true&#34; alt=&#34;Benchmark&#34; title=&#34;Benchmark&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;On top of that, Anvil provides actual build time improvements by replacing the Dagger annotation processor in many modules if you enable &lt;a href=&#34;https://raw.githubusercontent.com/square/anvil/main/#dagger-factory-generation&#34;&gt;Dagger Factory generation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Kotlin compiler plugin&lt;/h2&gt; &#xA;&lt;p&gt;We investigated whether other alternatives like a bytecode transformer and an annotation processor would be a better option, but ultimately decided against them. For what we tried to achieve a bytecode transformer runs too late in the build process; after the Dagger components have been generated. An annotation processor especially when using KAPT would be too slow. Even though the Kotlin compiler plugin API isn&#39;t stable and contains bugs we decided to write a compiler plugin.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;h4&gt;No Java support&lt;/h4&gt; &#xA;&lt;p&gt;Anvil is a Kotlin compiler plugin, thus Java isn’t supported. You can use Anvil in modules with mixed Java and Kotlin code for Kotlin classes, though.&lt;/p&gt; &#xA;&lt;h4&gt;Correct error types disabled&lt;/h4&gt; &#xA;&lt;p&gt;KAPT has the option to &lt;a href=&#34;https://kotlinlang.org/docs/kapt.html#non-existent-type-correction&#34;&gt;correct non-existent types&lt;/a&gt;. This option however changes order of how compiler plugins and KAPT itself are invoked. The result is that Anvil cannot merge supertypes before the Dagger annotation processor runs and abstract functions won&#39;t be implemented properly in the final Dagger component.&lt;/p&gt; &#xA;&lt;p&gt;Anvil will automatically set &lt;code&gt;correctErrorTypes&lt;/code&gt; to false to avoid this issue.&lt;/p&gt; &#xA;&lt;h4&gt;Incremental Kotlin compilation breaks Anvil&#39;s feature to merge contributions&lt;/h4&gt; &#xA;&lt;p&gt;Anvil merges Dagger component interfaces and Dagger modules during the stub generating task when &lt;code&gt;@MergeComponent&lt;/code&gt; is used. This requires scanning the compile classpath for any contributions. Assume the scenario that a contributed type in a module dependency has changed, but the module using &lt;code&gt;@MergeComponent&lt;/code&gt; itself didn&#39;t change. With Kotlin incremental compilation enabled the compiler will notice that the module using &lt;code&gt;@MergeComponent&lt;/code&gt; doesn&#39;t need to be recompiled and therefore doesn&#39;t invoke compiler plugins. Anvil will miss the new contributed type from the module dependency.&lt;/p&gt; &#xA;&lt;p&gt;To avoid this issue, Anvil must disable incremental compilation for the stub generating task, which runs right before Dagger processes annotations. Normal Kotlin compilation isn&#39;t impacted by this workaround. The issue is captured in &lt;a href=&#34;https://youtrack.jetbrains.com/issue/KT-54850/Provide-mechanism-for-compiler-plugins-to-add-custom-information-into-binaries&#34;&gt;KT-54850 Provide mechanism for compiler plugins to add custom information into binaries&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Disabling incremental compilation for the stub generating task could have a negative impact on compile times, if you heavily rely on KAPT. While Anvil can &lt;a href=&#34;https://raw.githubusercontent.com/square/anvil/main/#dagger-factory-generation&#34;&gt;significantly help to improve build times&lt;/a&gt;, the wrong configuration and using KAPT in most modules could make things worse. The suggestion is to extract and isolate annotation processors in separate modules and avoid using Anvil in the same modules, e.g. a common practice is to move the Dagger component using &lt;code&gt;@MergeComponent&lt;/code&gt; into the final application module with little to no other code in the app module.&lt;/p&gt; &#xA;&lt;h2&gt;Hilt&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dagger.dev/hilt/&#34;&gt;Hilt&lt;/a&gt; is Google&#39;s opinionated guide how to dependency injection on Android. It provides a similar feature with &lt;code&gt;@InstallIn&lt;/code&gt; for entry points and modules as Anvil. If you use Hilt, then you don&#39;t need to use Anvil.&lt;/p&gt; &#xA;&lt;p&gt;Hilt includes many other features and comes with some restrictions. For us it was infeasible to migrate a codebase to Hilt with thousands of modules and many Dagger components while we only needed the feature to merge modules and component interfaces automatically. We also restrict the usage of the Dagger annotation processor to only &lt;a href=&#34;https://speakerdeck.com/vrallev/android-at-scale-at-square?slide=36&#34;&gt;specific modules&lt;/a&gt; for performance reasons. With Hilt we wouldn&#39;t be able to enforce this requirement anymore for component interfaces. The development of Anvil started long before Hilt was announced and the internal version is being used in production for a while.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright 2020 Square, Inc.&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;   http://www.apache.org/licenses/LICENSE-2.0&#xA;&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>