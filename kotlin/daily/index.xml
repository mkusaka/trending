<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-04T01:35:44Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>deliveryhero/whetstone</title>
    <updated>2022-10-04T01:35:44Z</updated>
    <id>tag:github.com,2022-10-04:/deliveryhero/whetstone</id>
    <link href="https://github.com/deliveryhero/whetstone" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Whetstone is a dependency injection framework for Android that greatly simplifies working with Dagger 2 using all the powers of Anvil&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Whetstone&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&#34;An Anvil forges a Dagger. A Whetstone sharpens it. And when you&#39;re not planning on using your Dagger, you may keep it in something that rhymes with kilt.&#34; â€” &lt;a href=&#34;https://github.com/laggedHero&#34;&gt;Tiago Cunha&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Whetstone provides a simplified way to incorporate &lt;a href=&#34;https://github.com/google/dagger&#34;&gt;Dagger&lt;/a&gt; and &lt;a href=&#34;https://github.com/square/anvil&#34;&gt;Anvil&lt;/a&gt; into an Android application.&lt;/p&gt; &#xA;&lt;p&gt;The goals of Whetstone are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To simplify Dagger-related infrastructure for Android apps.&lt;/li&gt; &#xA; &lt;li&gt;To create a standard set of components and scopes to ease setup, but allowing customizations.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Why would you use Whetstone instead of Hilt?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All generated code is in Kotlin, which can have significant benefits in a Kotlin only codebase&lt;/li&gt; &#xA; &lt;li&gt;Whetstone avoids KAPT completely for performance reasons by taking advantage of Anvil compiler.&lt;/li&gt; &#xA; &lt;li&gt;Whetstone is extensible by using the powers of Dagger and Anvil.&lt;/li&gt; &#xA; &lt;li&gt;Whetstone significantly reduces boiler plate.&lt;/li&gt; &#xA; &lt;li&gt;Whetstone doesn&#39;t do bytecode manipulation for complementing classes. Hilt does.&lt;/li&gt; &#xA; &lt;li&gt;Summarily, while philosophies are similar, whetstone is relatively easier to work with ;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;First you must apply whetstone plugin in the &lt;code&gt;build.gradle&lt;/code&gt; file of any module that requires dependency injection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;plugins {&#xA;    id(&#34;com.deliveryhero.whetstone&#34;).version(&#34;&amp;lt;latest version&amp;gt;&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can use the old way to apply a plugin:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// In root build.gradle.kts&#xA;buildscript {&#xA;  repositories {&#xA;    mavenCentral()&#xA;  }&#xA;  dependencies {&#xA;    classpath(&#34;com.deliveryhero.whetstone:whetstone-gradle-plugin:${latest_version}&#34;)&#xA;  }&#xA;}&#xA;&#xA;// In individual modules&#xA;apply(plugin = &#34;com.deliveryhero.whetstone&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This automatically configures Dagger and Anvil, and also adds the necessary whetstone dependencies for you.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;p&gt;To use whetstone, you must initialize it in your Application class.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ContributesAppInjector(generateAppComponent = true)&#xA;class MyApplication : Application(), ApplicationComponentOwner {&#xA;&#xA;    override val applicationComponent by lazy {&#xA;        GeneratedApplicationComponent.create(this)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: For more sophisticated use cases, the generated app component might not be sufficient for you. In such scenario, you can disable automatic generation of app component, and create your own instead. An example may look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Singleton // Optional. Can be omitted if you never use this annotation&#xA;@SingleIn(ApplicationScope::class)&#xA;@MergeComponent(ApplicationScope::class)&#xA;interface MyApplicationComponent : ApplicationComponent {&#xA;&#xA;    @Component.Factory&#xA;    interface Factory {&#xA;        fun create(&#xA;            @BindsInstance application: Application, // this is necessary for whetstone to set things up properly&#xA;            // ...&#xA;        ): MyApplicationComponent&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that, you can easily inject into any Android class (see below).&lt;/p&gt; &#xA;&lt;h3&gt;Guide&lt;/h3&gt; &#xA;&lt;p&gt;Unlike traditional Dagger, you do not need to define or instantiate Dagger components directly. Instead, we offer predefined components that are generated for you. Whetstone comes with a built-in set of components (and corresponding scope annotations) that are automatically integrated to the Android Framework. As expected, a binding in a child component can have dependencies on any binding in an ancestor component.&lt;/p&gt; &#xA;&lt;h3&gt;Component Lifecycle&lt;/h3&gt; &#xA;&lt;p&gt;Component lifetimes are generally bounded by the creation and destruction of a corresponding instance of an important event. The table below lists the scope annotation and bounded lifetime for each component.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Component&lt;/th&gt; &#xA;   &lt;th&gt;Scope&lt;/th&gt; &#xA;   &lt;th&gt;Created At&lt;/th&gt; &#xA;   &lt;th&gt;Destroyed At&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ApplicationComponent&lt;/td&gt; &#xA;   &lt;td&gt;@ApplicationScope&lt;/td&gt; &#xA;   &lt;td&gt;Application#onCreate&lt;/td&gt; &#xA;   &lt;td&gt;Application#onTerminate&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ActivityComponent&lt;/td&gt; &#xA;   &lt;td&gt;@ActivityScope&lt;/td&gt; &#xA;   &lt;td&gt;Activity#onCreate&lt;/td&gt; &#xA;   &lt;td&gt;Activity#onDestroy&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FragmentComponent&lt;/td&gt; &#xA;   &lt;td&gt;@FragmentScope&lt;/td&gt; &#xA;   &lt;td&gt;FragmentFactory#instantiate&lt;/td&gt; &#xA;   &lt;td&gt;Fragment#onDestroy&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ViewModelComponent&lt;/td&gt; &#xA;   &lt;td&gt;@ViewModelScope&lt;/td&gt; &#xA;   &lt;td&gt;ViewModelProvider.Factory#create&lt;/td&gt; &#xA;   &lt;td&gt;ViewModel#onCleared&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ViewComponent&lt;/td&gt; &#xA;   &lt;td&gt;@ViewScope&lt;/td&gt; &#xA;   &lt;td&gt;View#init&lt;/td&gt; &#xA;   &lt;td&gt;View#finalize&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/deliveryhero/whetstone/main/art/whetstone-scopes.png?raw=true&#34; alt=&#34;whetstone-scopes&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Application&lt;/h3&gt; &#xA;&lt;p&gt;Applications support field/method injection with Whetstone. Constructor injection is not supported here because the instantiation of applications is completely managed by the system&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ContributesAppInjector&#xA;class MyApplication : Application(), ApplicationComponentOwner {&#xA;&#xA;    override val applicationComponent by lazy {&#xA;        TODO(&#34;Create application component.&#34;)&#xA;    }&#xA;&#xA;    @Inject&#xA;    lateinit var dependency: MyDependency&#xA;&#xA;    fun onCreate() {&#xA;        Whetstone.inject(this)&#xA;        super.onCreate()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Activity&lt;/h3&gt; &#xA;&lt;p&gt;Similar to applications, activities only support field/method injection&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ContributesActivityInjector&#xA;class MainActivity : AppCompatActivity() {&#xA;&#xA;    @Inject&#xA;    lateinit var dependency: MyDependency&#xA;&#xA;    // Get the contributed ViewModel&#xA;    // We automatically handle process death and saved state handle wiring&#xA;    private val viewModel by injectedViewModel&amp;lt;MyViewModel&amp;gt;()&#xA;&#xA;    override fun onCreate(savedInstanceState: Bundle?) {&#xA;        Whetstone.inject(this)&#xA;        super.onCreate(savedInstanceState)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Service&lt;/h3&gt; &#xA;&lt;p&gt;Services should be generally avoided when possible. For most cases, work manager can be a great alternative and is highly recommended. See the &lt;a href=&#34;https://raw.githubusercontent.com/deliveryhero/whetstone/main/#workmanager&#34;&gt;workmanager&lt;/a&gt; section for more details about how to use it with Whetstone&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ContributesServiceInjector&#xA;class MyService : Service() {&#xA;&#xA;    @Inject&#xA;    lateinit var dependency: MyDependency&#xA;&#xA;    override fun onCreate() {&#xA;        Whetstone.inject(this)&#xA;        super.onCreate()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;View&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: View injection should be avoided by all means. This provision is considered legacy and may be completely removed in a later version of Whetstone.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ContributesViewInjector&#xA;class MyView @JvmOverloads constructor(&#xA;    context: Context,&#xA;    attrs: AttributeSet? = null,&#xA;) : View(context, attrs) {&#xA;&#xA;    @Inject&#xA;    lateinit var dependency: MainDependency&#xA;&#xA;    init {&#xA;        if (!isInEditMode) {&#xA;            Whetstone.inject(this)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fragments&lt;/h3&gt; &#xA;&lt;p&gt;Fragments support only construction injection, exclusively. This is possible because we are able to hook into the system to influence exactly how fragments should be created. To achieve this, the activity hosting the fragment must install Whetstone&#39;s fragment factory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MyActivity : Activity() {&#xA;&#xA;    override fun onCreate(savedInstanceState: Bundle?) {&#xA;        Whetstone.inject(this)&#xA;        super.onCreate(savedInstanceState)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you&#39;re able to use the injected fragments with as many constructor arguments as necessary, as long as all these dependencies can be satisfied by dependency injection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ContributesFragment&#xA;class MyFragment @Inject constructor(&#xA;    private val dependency: MyDependency,&#xA;    private val anotherDependency: AnotherDependency,&#xA;): Fragment() {&#xA;&#xA;    // Get the contributed ViewModel&#xA;    // We automatically handle process death and saved state handle wiring&#xA;    private val viewModel by injectedViewModel&amp;lt;MyViewModel&amp;gt;()&#xA;    private val activityViewModel by injectedActivityViewModel&amp;lt;ActivityViewModel&amp;gt;()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that all injected fragments must be created via the fragment manager. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val myFragment = fragmentManager.instantiate&amp;lt;MyFragment&amp;gt;()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For fragments that don&#39;t require any external dependencies, the simple no-arg constructor can still be used, and we gracefully fallback to the default behavior&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; A Fragment should &lt;strong&gt;NEVER&lt;/strong&gt; be scoped. The Android Framework controls the Lifecycle of &lt;strong&gt;ALL&lt;/strong&gt; Fragments.&lt;/p&gt; &#xA;&lt;h3&gt;ViewModels&lt;/h3&gt; &#xA;&lt;p&gt;Like fragments, view models also support full constructor injection&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ContributesViewModel&#xA;class MyViewModel @Inject constructor(&#xA;    private val savedStateHandle: SavedStateHandle,&#xA;): ViewModel()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; A ViewModel should &lt;strong&gt;NEVER&lt;/strong&gt; be scoped. The Android Framework controls the Lifecycle of &lt;strong&gt;ALL&lt;/strong&gt; ViewModels.&lt;/p&gt; &#xA;&lt;h3&gt;WorkManager&lt;/h3&gt; &#xA;&lt;p&gt;Workmanager integration is an extra add-on, and must be enabled explicitly in your &lt;code&gt;build.gradle&lt;/code&gt; file before use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;whetstone {&#xA;    addOns.workManager.set(true)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will automatically install Whetstone&#39;s worker factory (replacing the default factory), so that you can immediately start taking advantage of injected workers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@ContributesWorker&#xA;class UploadWorker @Inject constructor(&#xA;    @ForScope(WorkerScope::class) context: Context,&#xA;    workerParameters: WorkerParameters,&#xA;    private val dependency: MyDependency,&#xA;): Worker(appContext, workerParameters)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To disable automatic initialization, you can remove the initializer from your AndroidManifest.xml&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;provider&#xA;   android:name=&#34;androidx.startup.InitializationProvider&#34;&#xA;   android:authorities=&#34;${applicationId}.androidx-startup&#34;&#xA;   android:exported=&#34;false&#34;&#xA;   tools:node=&#34;merge&#34;&amp;gt;&#xA;   &amp;lt;meta-data&#xA;       android:name=&#34;com.deliveryhero.whetstone.worker.WhetstoneWorkerInitializer&#34;&#xA;       android:value=&#34;androidx.startup&#34;&#xA;       tools:node=&#34;remove&#34; /&amp;gt;&#xA;&amp;lt;/provider&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, you must make sure to install Whetstone&#39;s worker factory before the first call to &lt;code&gt;WorkManager#getInstance&lt;/code&gt; to avoid breaking the integration. Whetstone provides an injectable &lt;code&gt;WorkerFactory&lt;/code&gt; that can be used to configure the work manager. For example, you can update your application class to implement work manager&#39;s &lt;code&gt;Configuration.Provider&lt;/code&gt; and supply Whetstone&#39;s &lt;code&gt;WorkerFactory&lt;/code&gt; to the configuration builder See the official &lt;a href=&#34;https://developer.android.com/topic/libraries/architecture/workmanager/advanced/custom-configuration&#34;&gt;documentation&lt;/a&gt; for more details&lt;/p&gt; &#xA;&lt;h3&gt;Compose&lt;/h3&gt; &#xA;&lt;p&gt;Compose integration is an extra add-on, and must be enabled explicitly in your &lt;code&gt;build.gradle&lt;/code&gt; file before use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;whetstone {&#xA;    addOns.compose.set(true)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Currently, this artefact only exposes APIs for injecting ViewModels that have been contributed to Whetstone&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun MyScreen(viewModel: MyViewModel = injectedViewModel()) {&#xA;    // injectedViewModel takes care of providing the VM instance directly to this function&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright 2021 Delivery Hero, GmbH.&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;   http://www.apache.org/licenses/LICENSE-2.0&#xA;&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>