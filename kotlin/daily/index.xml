<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-31T01:41:32Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>square/wire</title>
    <updated>2023-01-31T01:41:32Z</updated>
    <id>tag:github.com,2023-01-31:/square/wire</id>
    <link href="https://github.com/square/wire" rel="alternate"></link>
    <summary type="html">&lt;p&gt;gRPC and protocol buffers for Android, Kotlin, and Java.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Wire&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;“A man got to have a code!”&lt;/em&gt; - Omar Little&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://square.github.io/wire/&#34;&gt;project website&lt;/a&gt; for documentation and APIs.&lt;/p&gt; &#xA;&lt;p&gt;As our teams and programs grow, the variety and volume of data also grows. Success will turn your simple data models into complex ones! Whether your application is storing data to disk or transmitting it over a network, the structure and interpretation of that data should be clear. Consumers work best with data they understand!&lt;/p&gt; &#xA;&lt;p&gt;Schemas describe and document data models. If you have data, you should have a schema.&lt;/p&gt; &#xA;&lt;h2&gt;Protocol Buffers&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34;&gt;Google&#39;s Protocol Buffers&lt;/a&gt; are built around a great schema language:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;It&#39;s cross platform and language independent. Whatever programming language you use, you&#39;ll be able to use proto schemas with your application.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Proto schemas are backwards-compatible and future-proof. You can evolve your schema as your application loses old features and gains new ones.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It&#39;s focused. Proto schemas describe your data models. That&#39;s it.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Protocol Buffer Examples&lt;/summary&gt; &#xA; &lt;p&gt;Here&#39;s a &lt;a href=&#34;https://raw.githubusercontent.com/square/wire/master/samples/simple-sample/src/main/proto/squareup/dinosaurs/dinosaur.proto&#34;&gt;sample message&lt;/a&gt; definition:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &#34;proto3&#34;;&#xA;&#xA;package squareup.dinosaurs;&#xA;&#xA;option java_package = &#34;com.squareup.dinosaurs&#34;;&#xA;&#xA;import &#34;squareup/geology/period.proto&#34;;&#xA;&#xA;message Dinosaur {&#xA;  // Common name of this dinosaur, like &#34;Stegosaurus&#34;.&#xA;  string name = 1;&#xA;&#xA;  // URLs with images of this dinosaur.&#xA;  repeated string picture_urls = 2;&#xA;&#xA;  squareup.geology.Period period = 5;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;And here&#39;s an &lt;a href=&#34;https://raw.githubusercontent.com/square/wire/master/samples/simple-sample/src/main/proto/squareup/geology/period.proto&#34;&gt;enum&lt;/a&gt; definition:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;syntax = &#34;proto3&#34;;&#xA;&#xA;package squareup.geology;&#xA;&#xA;&#xA;option java_package = &#34;com.squareup.geology&#34;;&#xA;&#xA;enum Period {&#xA;  // 145.5 million years ago — 66.0 million years ago.&#xA;  CRETACEOUS = 0;&#xA;&#xA;  // 201.3 million years ago — 145.0 million years ago.&#xA;  JURASSIC = 1;&#xA;&#xA;  // 252.17 million years ago — 201.3 million years ago.&#xA;  TRIASSIC = 2;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This schema language is Protocol Buffers&#39; best feature. You might even use it purely for documentation purposes, such as to describe a JSON API.&lt;/p&gt; &#xA; &lt;p&gt;Protocol Buffers also defines a compact binary encoding of messages that conform to the schema. This encoding is fast to encode, fast to decode, small to transmit, and small to store. The binary encoding uses numeric tags from the schema, like the &lt;code&gt;5&lt;/code&gt; for &lt;code&gt;period&lt;/code&gt; above.&lt;/p&gt; &#xA; &lt;p&gt;For example, let&#39;s encode this dinosaur:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;{&#xA;  name: &#34;Stegosaurus&#34;,&#xA;  period: JURASSIC&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The encoded value is just 15 bytes:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;Hex  Description&#xA; 0a  tag: name(1), field encoding: LENGTH_DELIMITED(2). 1 &amp;lt;&amp;lt; 3 | 2&#xA; 0b  &#34;Stegosaurus&#34;.length()&#xA; 53  &#39;S&#39;&#xA; 74  &#39;t&#39;&#xA; 65  &#39;e&#39;&#xA; 67  &#39;g&#39;&#xA; 6f  &#39;o&#39;&#xA; 73  &#39;s&#39;&#xA; 61  &#39;a&#39;&#xA; 75  &#39;u&#39;&#xA; 72  &#39;r&#39;&#xA; 75  &#39;u&#39;&#xA; 73  &#39;s&#39;&#xA; 28  tag: period(5), field encoding: VARINT(0). 5 &amp;lt;&amp;lt; 3 | 0&#xA; 02  JURASSIC(2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Why Wire?&lt;/h2&gt; &#xA;&lt;p&gt;The Protocol Buffers schema language and binary encoding are both defined by Google. Wire is an independent implementation from Square that&#39;s specifically designed for Android and Java.&lt;/p&gt; &#xA;&lt;p&gt;For each message type defined in the schema, Wire generates an immutable model class and its builder. The generated code looks like code you&#39;d write by hand: it&#39;s documented, formatted, and simple. Wire&#39;s APIs should feel at home to programmers who like &lt;a href=&#34;https://www.amazon.ca/Effective-Java-3rd-Joshua-Bloch/dp/0134685997/&#34;&gt;Effective Java&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;That said, there are some interesting design decisions in Wire:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Wire messages declare &lt;code&gt;public final&lt;/code&gt; fields instead of the usual getter methods. This cuts down on both code generated and code executed. Less code is particularly beneficial for Android programs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Wire avoids case mapping. A field declared as &lt;code&gt;picture_urls&lt;/code&gt; in a schema yields a Java field &lt;code&gt;picture_urls&lt;/code&gt; and not the conventional &lt;code&gt;pictureUrls&lt;/code&gt; camel case. Though the name feels awkward at first, it&#39;s fantastic whenever you use &lt;code&gt;grep&lt;/code&gt; or more sophisticated search tools. No more mapping when navigating between schema, Java source code, and data. It also provides a gentle reminder to calling code that proto messages are a bit special.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Primitive types are always boxed. If a field is absent, its value is &lt;code&gt;null&lt;/code&gt;. This is used for naturally optional fields, such as a dinosaur whose period is unknown. A field may also be null due to schema evolution: if tomorrow we add a &lt;code&gt;carnivore&lt;/code&gt; boolean to our message definition, today&#39;s data won’t have a value for that field.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Generated Java Code&lt;/summary&gt; &#xA; &lt;p&gt;Here&#39;s the compact &lt;a href=&#34;https://raw.githubusercontent.com/square/wire/master/samples/simple-sample/src/main/java/com/squareup/dinosaurs/Sample.java&#34;&gt;generated code&lt;/a&gt; for the &lt;code&gt;Dinosaur&lt;/code&gt; message defined above:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Code generated by Wire protocol buffer compiler, do not edit.&#xA;// Source: squareup.dinosaurs.Dinosaur in squareup/dinosaurs/dinosaur.proto&#xA;package com.squareup.dinosaurs;&#xA;&#xA;import com.squareup.geology.Period;&#xA;import com.squareup.wire.Message;&#xA;import com.squareup.wire.ProtoAdapter;&#xA;import com.squareup.wire.Syntax;&#xA;import com.squareup.wire.WireField;&#xA;import com.squareup.wire.internal.Internal;&#xA;import java.lang.Object;&#xA;import java.lang.Override;&#xA;import java.lang.String;&#xA;import java.util.List;&#xA;import okio.ByteString;&#xA;&#xA;public final class Dinosaur extends Message&amp;lt;Dinosaur, Dinosaur.Builder&amp;gt; {&#xA;  public static final ProtoAdapter&amp;lt;Dinosaur&amp;gt; ADAPTER = ProtoAdapter.newMessageAdapter(Dinosaur.class, &#34;type.googleapis.com/squareup.dinosaurs.Dinosaur&#34;, Syntax.PROTO_3);&#xA;&#xA;  private static final long serialVersionUID = 0L;&#xA;&#xA;  /**&#xA;   * Common name of this dinosaur, like &#34;Stegosaurus&#34;.&#xA;   */&#xA;  @WireField(&#xA;      tag = 1,&#xA;      adapter = &#34;com.squareup.wire.ProtoAdapter#STRING&#34;,&#xA;      label = WireField.Label.OMIT_IDENTITY&#xA;  )&#xA;  public final String name;&#xA;&#xA;  /**&#xA;   * URLs with images of this dinosaur.&#xA;   */&#xA;  @WireField(&#xA;      tag = 2,&#xA;      adapter = &#34;com.squareup.wire.ProtoAdapter#STRING&#34;,&#xA;      label = WireField.Label.REPEATED,&#xA;      jsonName = &#34;pictureUrls&#34;&#xA;  )&#xA;  public final List&amp;lt;String&amp;gt; picture_urls;&#xA;&#xA;  @WireField(&#xA;      tag = 5,&#xA;      adapter = &#34;com.squareup.geology.Period#ADAPTER&#34;,&#xA;      label = WireField.Label.OMIT_IDENTITY&#xA;  )&#xA;  public final Period period;&#xA;&#xA;  public Dinosaur(String name, List&amp;lt;String&amp;gt; picture_urls, Period period) {&#xA;    this(name, picture_urls, period, ByteString.EMPTY);&#xA;  }&#xA;&#xA;  public Dinosaur(String name, List&amp;lt;String&amp;gt; picture_urls, Period period, ByteString unknownFields) {&#xA;    super(ADAPTER, unknownFields);&#xA;    if (name == null) {&#xA;      throw new IllegalArgumentException(&#34;name == null&#34;);&#xA;    }&#xA;    this.name = name;&#xA;    this.picture_urls = Internal.immutableCopyOf(&#34;picture_urls&#34;, picture_urls);&#xA;    if (period == null) {&#xA;      throw new IllegalArgumentException(&#34;period == null&#34;);&#xA;    }&#xA;    this.period = period;&#xA;  }&#xA;&#xA;  @Override&#xA;  public Builder newBuilder() {&#xA;    Builder builder = new Builder();&#xA;    builder.name = name;&#xA;    builder.picture_urls = Internal.copyOf(picture_urls);&#xA;    builder.period = period;&#xA;    builder.addUnknownFields(unknownFields());&#xA;    return builder;&#xA;  }&#xA;&#xA;  @Override&#xA;  public boolean equals(Object other) {&#xA;    if (other == this) return true;&#xA;    if (!(other instanceof Dinosaur)) return false;&#xA;    Dinosaur o = (Dinosaur) other;&#xA;    return unknownFields().equals(o.unknownFields())&#xA;        &amp;amp;&amp;amp; Internal.equals(name, o.name)&#xA;        &amp;amp;&amp;amp; picture_urls.equals(o.picture_urls)&#xA;        &amp;amp;&amp;amp; Internal.equals(period, o.period);&#xA;  }&#xA;&#xA;  @Override&#xA;  public int hashCode() {&#xA;    int result = super.hashCode;&#xA;    if (result == 0) {&#xA;      result = unknownFields().hashCode();&#xA;      result = result * 37 + (name != null ? name.hashCode() : 0);&#xA;      result = result * 37 + picture_urls.hashCode();&#xA;      result = result * 37 + (period != null ? period.hashCode() : 0);&#xA;      super.hashCode = result;&#xA;    }&#xA;    return result;&#xA;  }&#xA;&#xA;  public static final class Builder extends Message.Builder&amp;lt;Dinosaur, Builder&amp;gt; {&#xA;    public String name;&#xA;&#xA;    public List&amp;lt;String&amp;gt; picture_urls;&#xA;&#xA;    public Period period;&#xA;&#xA;    public Builder() {&#xA;      name = &#34;&#34;;&#xA;      picture_urls = Internal.newMutableList();&#xA;      period = Period.CRETACEOUS;&#xA;    }&#xA;&#xA;    /**&#xA;     * Common name of this dinosaur, like &#34;Stegosaurus&#34;.&#xA;     */&#xA;    public Builder name(String name) {&#xA;      this.name = name;&#xA;      return this;&#xA;    }&#xA;&#xA;    /**&#xA;     * URLs with images of this dinosaur.&#xA;     */&#xA;    public Builder picture_urls(List&amp;lt;String&amp;gt; picture_urls) {&#xA;      Internal.checkElementsNotNull(picture_urls);&#xA;      this.picture_urls = picture_urls;&#xA;      return this;&#xA;    }&#xA;&#xA;    public Builder period(Period period) {&#xA;      this.period = period;&#xA;      return this;&#xA;    }&#xA;&#xA;    @Override&#xA;    public Dinosaur build() {&#xA;      return new Dinosaur(name, picture_urls, period, super.buildUnknownFields());&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The Java code to create and access proto models is compact and readable:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dinosaur stegosaurus = new Dinosaur.Builder()&#xA;    .name(&#34;Stegosaurus&#34;)&#xA;    .period(Period.JURASSIC)&#xA;    .build();&#xA;&#xA;System.out.println(&#34;My favorite dinosaur existed in the &#34; + stegosaurus.period + &#34; period.&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Each type has a corresponding &lt;code&gt;ProtoAdapter&lt;/code&gt; that can encode a message to bytes and decode bytes back into a message.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dinosaur stegosaurus = ...&#xA;byte[] stegosaurusBytes = Dinosaur.ADAPTER.encode(stegosaurus);&#xA;&#xA;byte[] tyrannosaurusBytes = ...&#xA;Dinosaur tyrannosaurus = Dinosaur.ADAPTER.decode(tyrannosaurusBytes);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;When accessing a field, use &lt;code&gt;Wire.get()&lt;/code&gt; to replace null values with the corresponding default:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Period period = Wire.get(stegosaurus.period, Dinosaur.DEFAULT_PERIOD);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This is equivalent to the following:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;Period period = stegosaurus.period != null ? stegosaurus.period : Dinosaur.DEFAULT_PERIOD;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Wire Kotlin&lt;/h2&gt; &#xA;&lt;p&gt;Since version 3.0.0, Wire can generate Kotlin code. See &lt;a href=&#34;https://raw.githubusercontent.com/square/wire/master/docs/wire_compiler.md&#34;&gt;Wire Compiler &amp;amp; Gradle Plugin&lt;/a&gt; to learn how to configure your build.&lt;/p&gt; &#xA;&lt;p&gt;Kotlin is a pragmatic and expressive programming language that makes it easy to model data. Here&#39;s how we used Kotlin to model Protocol Buffers messages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Messages feel like &lt;code&gt;data&lt;/code&gt; classes, but in fact they&#39;re not. Compiler still generates &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt;, &lt;code&gt;toString()&lt;/code&gt; and &lt;code&gt;copy()&lt;/code&gt; for you. Wire does not generate &lt;code&gt;componentN()&lt;/code&gt; functions though, we believe that destructuring declarations are not a good fit for Protocol Buffers: a change in the schema that removes or adds a field might lead to a situation when your destructuring declaration still compiles but now describes a completely different subset of fields, rendering your code incorrect.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;copy()&lt;/code&gt; is a substitute for the &lt;code&gt;Builder&lt;/code&gt;, which is not used anymore. If your program relies on the &lt;code&gt;Builder&lt;/code&gt; to be present, you may generate code in Java interoperability mode - &lt;a href=&#34;https://raw.githubusercontent.com/square/wire/master/docs/wire_compiler.md&#34;&gt;Wire Compiler &amp;amp; Gradle Plugin&lt;/a&gt; explains how that works.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fields are generated as properties. While this is idiomatic in Kotlin, Java code will now have to access fields using getters. If your program relies on accessing fields directly, use Java interoperability mode - the compiler will generate &lt;code&gt;@JvmField&lt;/code&gt; annotations for each field.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The nullability of each field&#39;s type depends on its label: &lt;code&gt;required&lt;/code&gt;, &lt;code&gt;repeated&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; fields get non-nullable types, whereas &lt;code&gt;optional&lt;/code&gt; fields are of nullable types.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;With the exception of &lt;code&gt;required&lt;/code&gt; fields, each field has a default value:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;null for &lt;code&gt;optional&lt;/code&gt; fields,&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;emptyList()&lt;/code&gt; for &lt;code&gt;repeated&lt;/code&gt; fields,&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;emptyMap()&lt;/code&gt; for &lt;code&gt;map&lt;/code&gt; fields.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Generated Kotlin Code&lt;/summary&gt; &#xA; &lt;p&gt;Here&#39;s the compact &lt;a href=&#34;https://raw.githubusercontent.com/square/wire/master/wire-tests/src/commonTest/proto-kotlin/com/squareup/dinosaurs/Dinosaur.kt&#34;&gt;generated code&lt;/a&gt; for the &lt;code&gt;Dinosaur&lt;/code&gt; message defined above:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Code generated by Wire protocol buffer compiler, do not edit.&#xA;// Source: squareup.dinosaurs.Dinosaur in squareup/dinosaurs/dinosaur.proto&#xA;package com.squareup.dinosaurs&#xA;&#xA;import com.squareup.geology.Period&#xA;import com.squareup.wire.FieldEncoding&#xA;import com.squareup.wire.Message&#xA;import com.squareup.wire.ProtoAdapter&#xA;import com.squareup.wire.ProtoReader&#xA;import com.squareup.wire.ProtoWriter&#xA;import com.squareup.wire.Syntax.PROTO_3&#xA;import com.squareup.wire.WireField&#xA;import com.squareup.wire.internal.immutableCopyOf&#xA;import com.squareup.wire.internal.sanitize&#xA;import kotlin.Any&#xA;import kotlin.AssertionError&#xA;import kotlin.Boolean&#xA;import kotlin.Deprecated&#xA;import kotlin.DeprecationLevel&#xA;import kotlin.Int&#xA;import kotlin.Long&#xA;import kotlin.Nothing&#xA;import kotlin.String&#xA;import kotlin.collections.List&#xA;import kotlin.hashCode&#xA;import kotlin.jvm.JvmField&#xA;import okio.ByteString&#xA;&#xA;class Dinosaur(&#xA;  /**&#xA;   * Common name of this dinosaur, like &#34;Stegosaurus&#34;.&#xA;   */&#xA;  @field:WireField(&#xA;    tag = 1,&#xA;    adapter = &#34;com.squareup.wire.ProtoAdapter#STRING&#34;,&#xA;    label = WireField.Label.OMIT_IDENTITY&#xA;  )&#xA;  val name: String = &#34;&#34;,&#xA;  picture_urls: List&amp;lt;String&amp;gt; = emptyList(),&#xA;  @field:WireField(&#xA;    tag = 5,&#xA;    adapter = &#34;com.squareup.geology.Period#ADAPTER&#34;,&#xA;    label = WireField.Label.OMIT_IDENTITY&#xA;  )&#xA;  val period: Period = Period.CRETACEOUS,&#xA;  unknownFields: ByteString = ByteString.EMPTY&#xA;) : Message&amp;lt;Dinosaur, Nothing&amp;gt;(ADAPTER, unknownFields) {&#xA;  /**&#xA;   * URLs with images of this dinosaur.&#xA;   */&#xA;  @field:WireField(&#xA;    tag = 2,&#xA;    adapter = &#34;com.squareup.wire.ProtoAdapter#STRING&#34;,&#xA;    label = WireField.Label.REPEATED,&#xA;    jsonName = &#34;pictureUrls&#34;&#xA;  )&#xA;  val picture_urls: List&amp;lt;String&amp;gt; = immutableCopyOf(&#34;picture_urls&#34;, picture_urls)&#xA;&#xA;  @Deprecated(&#xA;    message = &#34;Shouldn&#39;t be used in Kotlin&#34;,&#xA;    level = DeprecationLevel.HIDDEN&#xA;  )&#xA;  override fun newBuilder(): Nothing = throw AssertionError()&#xA;&#xA;  override fun equals(other: Any?): Boolean {&#xA;    if (other === this) return true&#xA;    if (other !is Dinosaur) return false&#xA;    if (unknownFields != other.unknownFields) return false&#xA;    if (name != other.name) return false&#xA;    if (picture_urls != other.picture_urls) return false&#xA;    if (period != other.period) return false&#xA;    return true&#xA;  }&#xA;&#xA;  override fun hashCode(): Int {&#xA;    var result = super.hashCode&#xA;    if (result == 0) {&#xA;      result = unknownFields.hashCode()&#xA;      result = result * 37 + name.hashCode()&#xA;      result = result * 37 + picture_urls.hashCode()&#xA;      result = result * 37 + period.hashCode()&#xA;      super.hashCode = result&#xA;    }&#xA;    return result&#xA;  }&#xA;&#xA;  override fun toString(): String {&#xA;    val result = mutableListOf&amp;lt;String&amp;gt;()&#xA;    result += &#34;&#34;&#34;name=${sanitize(name)}&#34;&#34;&#34;&#xA;    if (picture_urls.isNotEmpty()) result += &#34;&#34;&#34;picture_urls=${sanitize(picture_urls)}&#34;&#34;&#34;&#xA;    result += &#34;&#34;&#34;period=$period&#34;&#34;&#34;&#xA;    return result.joinToString(prefix = &#34;Dinosaur{&#34;, separator = &#34;, &#34;, postfix = &#34;}&#34;)&#xA;  }&#xA;&#xA;  fun copy(&#xA;    name: String = this.name,&#xA;    picture_urls: List&amp;lt;String&amp;gt; = this.picture_urls,&#xA;    period: Period = this.period,&#xA;    unknownFields: ByteString = this.unknownFields&#xA;  ): Dinosaur = Dinosaur(name, picture_urls, period, unknownFields)&#xA;&#xA;  companion object {&#xA;    @JvmField&#xA;    val ADAPTER: ProtoAdapter&amp;lt;Dinosaur&amp;gt; = object : ProtoAdapter&amp;lt;Dinosaur&amp;gt;(&#xA;      FieldEncoding.LENGTH_DELIMITED,&#xA;      Dinosaur::class,&#xA;      &#34;type.googleapis.com/squareup.dinosaurs.Dinosaur&#34;,&#xA;      PROTO_3,&#xA;      null&#xA;    ) {&#xA;      override fun encodedSize(value: Dinosaur): Int {&#xA;        var size = value.unknownFields.size&#xA;        if (value.name != &#34;&#34;) size += ProtoAdapter.STRING.encodedSizeWithTag(1, value.name)&#xA;        size += ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(2, value.picture_urls)&#xA;        if (value.period != Period.CRETACEOUS) size += Period.ADAPTER.encodedSizeWithTag(5,&#xA;            value.period)&#xA;        return size&#xA;      }&#xA;&#xA;      override fun encode(writer: ProtoWriter, value: Dinosaur) {&#xA;        if (value.name != &#34;&#34;) ProtoAdapter.STRING.encodeWithTag(writer, 1, value.name)&#xA;        ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 2, value.picture_urls)&#xA;        if (value.period != Period.CRETACEOUS) Period.ADAPTER.encodeWithTag(writer, 5, value.period)&#xA;        writer.writeBytes(value.unknownFields)&#xA;      }&#xA;&#xA;      override fun decode(reader: ProtoReader): Dinosaur {&#xA;        var name: String = &#34;&#34;&#xA;        val picture_urls = mutableListOf&amp;lt;String&amp;gt;()&#xA;        var period: Period = Period.CRETACEOUS&#xA;        val unknownFields = reader.forEachTag { tag -&amp;gt;&#xA;          when (tag) {&#xA;            1 -&amp;gt; name = ProtoAdapter.STRING.decode(reader)&#xA;            2 -&amp;gt; picture_urls.add(ProtoAdapter.STRING.decode(reader))&#xA;            5 -&amp;gt; try {&#xA;              period = Period.ADAPTER.decode(reader)&#xA;            } catch (e: ProtoAdapter.EnumConstantNotFoundException) {&#xA;              reader.addUnknownField(tag, FieldEncoding.VARINT, e.value.toLong())&#xA;            }&#xA;            else -&amp;gt; reader.readUnknownField(tag)&#xA;          }&#xA;        }&#xA;        return Dinosaur(&#xA;          name = name,&#xA;          picture_urls = picture_urls,&#xA;          period = period,&#xA;          unknownFields = unknownFields&#xA;        )&#xA;      }&#xA;&#xA;      override fun redact(value: Dinosaur): Dinosaur = value.copy(&#xA;        unknownFields = ByteString.EMPTY&#xA;      )&#xA;    }&#xA;&#xA;    private const val serialVersionUID: Long = 0L&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Creating and accessing proto models is easy:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val stegosaurus = Dinosaur(&#xA;    name = &#34;Stegosaurus&#34;,&#xA;    period = Period.JURASSIC&#xA;)&#xA;&#xA;println(&#34;My favorite dinosaur existed in the ${stegosaurus.period} period.&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Here&#39;s how you can modify the object to add extra fields:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val stegosaurus = stegosaurus.copy(&#xA;    picture_urls = listOf(&#34;https://www.flickr.com/photos/tags/Stegosaurus/&#34;)&#xA;)&#xA;&#xA;println(&#34;Here are some photos of ${stegosaurus.name}: ${stegosaurus.picture_urls}&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Wire Swift&lt;/h2&gt; &#xA;&lt;p&gt;Since version 3.3.0, Wire can generate Swift code. See &lt;a href=&#34;https://raw.githubusercontent.com/square/wire/master/docs/wire_compiler.md#swift-support&#34;&gt;Wire Compiler &amp;amp; Gradle Plugin&lt;/a&gt; to learn how to configure your build.&lt;/p&gt; &#xA;&lt;p&gt;Swift support is considered a &#34;beta&#34; and may still feature breaking changes. That being said, Block is shipping it in production apps and SDKs.&lt;/p&gt; &#xA;&lt;p&gt;Swift is a pragmatic and expressive programming language with rich support for value types. Here&#39;s how we used Swift to model Protocol Buffers messages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Messages are structs that conform to &lt;code&gt;Equatable&lt;/code&gt;, &lt;code&gt;Codable&lt;/code&gt; and &lt;code&gt;Sendable&lt;/code&gt;. All Messages have value semantics.&lt;/li&gt; &#xA; &lt;li&gt;Messages have a memberwise initializer to populate fields.&lt;/li&gt; &#xA; &lt;li&gt;Fields are generated as properties.&lt;/li&gt; &#xA; &lt;li&gt;The nullability of each field&#39;s type depends on its label: &lt;code&gt;required&lt;/code&gt;, &lt;code&gt;repeated&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; fields get non-nullable types, whereas &lt;code&gt;optional&lt;/code&gt; fields are of nullable types.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Generated Swift Code&lt;/summary&gt; &#xA; &lt;p&gt;Here&#39;s the compact &lt;a href=&#34;https://raw.githubusercontent.com/square/wire/master/wire-runtime-swift/src/test/swift/sample/Dinosaur.swift&#34;&gt;generated code&lt;/a&gt; for the &lt;code&gt;Dinosaur&lt;/code&gt; message defined above:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Code generated by Wire protocol buffer compiler, do not edit.&#xA;// Source: squareup.dinosaurs.Dinosaur in squareup/dinosaurs/dinosaur.proto&#xA;import Foundation&#xA;import Wire&#xA;&#xA;public struct Dinosaur {&#xA;&#xA;    /**&#xA;     * Common name of this dinosaur, like &#34;Stegosaurus&#34;.&#xA;     */&#xA;    public var name: String?&#xA;    /**&#xA;     * URLs with images of this dinosaur.&#xA;     */&#xA;    public var picture_urls: [String]&#xA;    public var length_meters: Double?&#xA;    public var mass_kilograms: Double?&#xA;    public var period: Period?&#xA;    public var unknownFields: Data = .init()&#xA;&#xA;    public init(&#xA;        name: String? = nil,&#xA;        picture_urls: [String] = [],&#xA;        length_meters: Double? = nil,&#xA;        mass_kilograms: Double? = nil,&#xA;        period: Period? = nil&#xA;    ) {&#xA;        self.name = name&#xA;        self.picture_urls = picture_urls&#xA;        self.length_meters = length_meters&#xA;        self.mass_kilograms = mass_kilograms&#xA;        self.period = period&#xA;    }&#xA;&#xA;}&#xA;&#xA;#if !WIRE_REMOVE_EQUATABLE&#xA;extension Dinosaur : Equatable {&#xA;}&#xA;#endif&#xA;&#xA;#if !WIRE_REMOVE_HASHABLE&#xA;extension Dinosaur : Hashable {&#xA;}&#xA;#endif&#xA;&#xA;#if swift(&amp;gt;=5.5)&#xA;extension Dinosaur : Sendable {&#xA;}&#xA;#endif&#xA;&#xA;extension Dinosaur : ProtoMessage {&#xA;    public static func protoMessageTypeURL() -&amp;gt; String {&#xA;        return &#34;type.googleapis.com/squareup.dinosaurs.Dinosaur&#34;&#xA;    }&#xA;}&#xA;&#xA;extension Dinosaur : Proto2Codable {&#xA;    public init(from reader: ProtoReader) throws {&#xA;        var name: String? = nil&#xA;        var picture_urls: [String] = []&#xA;        var length_meters: Double? = nil&#xA;        var mass_kilograms: Double? = nil&#xA;        var period: Period? = nil&#xA;&#xA;        let token = try reader.beginMessage()&#xA;        while let tag = try reader.nextTag(token: token) {&#xA;            switch tag {&#xA;            case 1: name = try reader.decode(String.self)&#xA;            case 2: try reader.decode(into: &amp;amp;picture_urls)&#xA;            case 3: length_meters = try reader.decode(Double.self)&#xA;            case 4: mass_kilograms = try reader.decode(Double.self)&#xA;            case 5: period = try reader.decode(Period.self)&#xA;            default: try reader.readUnknownField(tag: tag)&#xA;            }&#xA;        }&#xA;        self.unknownFields = try reader.endMessage(token: token)&#xA;&#xA;        self.name = name&#xA;        self.picture_urls = picture_urls&#xA;        self.length_meters = length_meters&#xA;        self.mass_kilograms = mass_kilograms&#xA;        self.period = period&#xA;    }&#xA;&#xA;    public func encode(to writer: ProtoWriter) throws {&#xA;        try writer.encode(tag: 1, value: self.name)&#xA;        try writer.encode(tag: 2, value: self.picture_urls)&#xA;        try writer.encode(tag: 3, value: self.length_meters)&#xA;        try writer.encode(tag: 4, value: self.mass_kilograms)&#xA;        try writer.encode(tag: 5, value: self.period)&#xA;        try writer.writeUnknownFields(unknownFields)&#xA;    }&#xA;}&#xA;&#xA;#if !WIRE_REMOVE_CODABLE&#xA;extension Dinosaur : Codable {&#xA;    public init(from decoder: Decoder) throws {&#xA;        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)&#xA;        self.name = try container.decodeIfPresent(String.self, forKey: &#34;name&#34;)&#xA;        self.picture_urls = try container.decodeProtoArray(String.self, firstOfKeys: &#34;pictureUrls&#34;, &#34;picture_urls&#34;)&#xA;        self.length_meters = try container.decodeIfPresent(Double.self, firstOfKeys: &#34;lengthMeters&#34;, &#34;length_meters&#34;)&#xA;        self.mass_kilograms = try container.decodeIfPresent(Double.self, firstOfKeys: &#34;massKilograms&#34;, &#34;mass_kilograms&#34;)&#xA;        self.period = try container.decodeIfPresent(Period.self, forKey: &#34;period&#34;)&#xA;    }&#xA;&#xA;    public func encode(to encoder: Encoder) throws {&#xA;        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)&#xA;        let preferCamelCase = encoder.protoKeyNameEncodingStrategy == .camelCase&#xA;        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include&#xA;&#xA;        try container.encodeIfPresent(self.name, forKey: &#34;name&#34;)&#xA;        if includeDefaults || !self.picture_urls.isEmpty {&#xA;            try container.encodeProtoArray(self.picture_urls, forKey: preferCamelCase ? &#34;pictureUrls&#34; : &#34;picture_urls&#34;)&#xA;        }&#xA;        try container.encodeIfPresent(self.length_meters, forKey: preferCamelCase ? &#34;lengthMeters&#34; : &#34;length_meters&#34;)&#xA;        try container.encodeIfPresent(self.mass_kilograms, forKey: preferCamelCase ? &#34;massKilograms&#34; : &#34;mass_kilograms&#34;)&#xA;        try container.encodeIfPresent(self.period, forKey: &#34;period&#34;)&#xA;    }&#xA;}&#xA;#endif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Creating and accessing proto models is easy:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let stegosaurus = Dinosaur(&#xA;    name: &#34;Stegosaurus&#34;,&#xA;    period: .JURASSIC&#xA;)&#xA;&#xA;print(&#34;My favorite dinosaur existed in the \(stegosaurus.period) period.&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Here&#39;s how you can modify the object to add extra fields:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var stegosaurus = stegosaurus&#xA;stegosaurus.picture_urls = [&#34;https://www.flickr.com/photos/tags/Stegosaurus/&#34;]&#xA;&#xA;print(&#34;Here are some photos of \(stegosaurus.name): \(stegosaurus.picture_urls)&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Wire gRPC&lt;/h2&gt; &#xA;&lt;p&gt;Since version 3.0.0, Wire supports &lt;a href=&#34;https://raw.githubusercontent.com/square/wire/master/docs/wire_grpc.md&#34;&gt;gRPC&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Generating Code With Wire&lt;/h2&gt; &#xA;&lt;p&gt;Wire can read &lt;code&gt;.proto&lt;/code&gt; files from the local file system and from within &lt;code&gt;.jar&lt;/code&gt; files.&lt;/p&gt; &#xA;&lt;p&gt;The compiler can optionally prune your schema to a subset of root types and their transitive dependencies. This is useful when sharing a schema between projects: a Java service and Android app may each use a subset of a larger shared schema.&lt;/p&gt; &#xA;&lt;p&gt;For more info on how to get started, see &lt;a href=&#34;https://raw.githubusercontent.com/square/wire/master/docs/wire_compiler.md&#34;&gt;Wire Compiler &amp;amp; Gradle Plugin&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t use Gradle, the compiler also has a command line interface. Just substitute &lt;code&gt;wire-compiler-VERSION-jar-with-dependencies.jar&lt;/code&gt; with the path to your jar. &lt;a href=&#34;https://search.maven.org/remote_content?g=com.squareup.wire&amp;amp;a=wire-compiler&amp;amp;c=jar-with-dependencies&amp;amp;v=LATEST&#34;&gt;Download&lt;/a&gt; the latest precompiled jar.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% java -jar wire-compiler-VERSION-jar-with-dependencies.jar \&#xA;    --proto_path=src/main/proto \&#xA;    --java_out=out \&#xA;    squareup/dinosaurs/dinosaur.proto \&#xA;    squareup/geology/period.proto&#xA;Writing com.squareup.dinosaurs.Dinosaur to out&#xA;Writing com.squareup.geology.Period to out&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supplying the &lt;code&gt;--android&lt;/code&gt; flag to the compiler causes Wire messages to implement &lt;code&gt;Parcelable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you use Proguard, then you need to add &lt;code&gt;keep&lt;/code&gt; rules. The simplest option is to tell Proguard not to touch the Wire runtime library and your generated protocol buffers (of course these simple rules will miss opportunities to shrink and optimize the code):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-keep class com.squareup.wire.** { *; }&#xA;-keep class com.yourcompany.yourgeneratedcode.** { *; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Get Wire&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;wire-runtime&lt;/code&gt; package contains runtime support libraries that must be included in applications that use Wire-generated code.&lt;/p&gt; &#xA;&lt;p&gt;With Maven:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;com.squareup.wire&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;wire-runtime-jvm&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;4.4.3&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With Gradle:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;api &#34;com.squareup.wire:wire-runtime:4.4.3&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Snapshots of the development version are available in &lt;a href=&#34;https://s01.oss.sonatype.org/content/repositories/snapshots/&#34;&gt;Sonatype&#39;s &lt;code&gt;snapshots&lt;/code&gt; repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Unsupported&lt;/h2&gt; &#xA;&lt;p&gt;Wire does not support:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Groups - they are skipped when parsing binary input data&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Wire supports custom options on messages and fields. Other custom options are ignored. Pass &lt;code&gt;--excludes=google.protobuf.*&lt;/code&gt; to the compiler to omit options from the generated code.&lt;/p&gt; &#xA;&lt;h2&gt;Further Documentation&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto&#34;&gt;Google&#39;s excellent documentation&lt;/a&gt; on the structure and syntax of proto schemas.&lt;/p&gt;</summary>
  </entry>
</feed>