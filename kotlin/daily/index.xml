<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-21T01:30:58Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>konigsoftware/konig-kontext</title>
    <updated>2023-10-21T01:30:58Z</updated>
    <id>tag:github.com,2023-10-21:/konigsoftware/konig-kontext</id>
    <link href="https://github.com/konigsoftware/konig-kontext" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A globally shared, request scoped, context for JVM based gRPC microservices&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Konig Kontext - A globally shared, request scoped, context for JVM based gRPC microservices&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/konigsoftware/konig-kontext/actions/workflows/build.yaml?query=branch%3Amain&#34;&gt;&lt;img src=&#34;https://github.com/konigsoftware/konig-kontext/actions/workflows/build.yaml/badge.svg?query=branch=main&#34; alt=&#34;Gradle Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://central.sonatype.com/search?q=com.konigsoftware%3Akonig-kontext&amp;amp;smo=true&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.konigsoftware/konig-kontext.svg?label=konig-kontext&#34; alt=&#34;konig-kontext&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A request context propagation framework which can carry values across gRPC microservice boundaries. Example context values might include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Security principals, or user credentials and identifiers. Add a user credential to the KonigKontext early in a request lifetime, and later access the credential from a different microservice.&lt;/li&gt; &#xA; &lt;li&gt;Distributed tracing information. Add a request trace id to the KonigKontext upon receiving a request and later access that id in any downstream microservice.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Konig Kontext is built to support any type of context value, so it can be extended to fit &lt;em&gt;your&lt;/em&gt; specific use cases as well.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Gradle:&lt;/h3&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;br&gt; Add the following to your `build.gradle.kts`: &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;implementation(&#34;com.konigsoftware:konig-kontext:1.1.0&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Groovy&lt;/summary&gt; &#xA; &lt;br&gt; Add the following to your `build.gradle`: &#xA; &lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;implementation &#39;com.konigsoftware:konig-kontext:1.1.0&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Maven:&lt;/h3&gt; &#xA;&lt;p&gt;Add the following to your &lt;code&gt;pom.xml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;com.konigsoftware&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;konig-kontext&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;1.1.0&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;h3&gt;1. Create KonigKontextKey&lt;/h3&gt; &#xA;&lt;p&gt;KonigKontext values are indexed by a &lt;code&gt;KonigKontextKey&lt;/code&gt;. To define a key, create an object that extends &lt;code&gt;KonigKontextKey&lt;/code&gt; and implement the interface. This object should live in a shared package accessible to all of your microservices.&lt;/p&gt; &#xA;&lt;p&gt;The following examples define a key with a value of type &lt;code&gt;String&lt;/code&gt; in both Kotlin and Java, although you can use &lt;em&gt;any&lt;/em&gt; type you like instead:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;object MyContextKey : KonigKontextKey&amp;lt;String&amp;gt;() {&#xA;    override val defaultValue: String = &#34;&#34;&#xA;&#xA;    override fun valueFromBinary(binaryValue: ByteArray): String = String(binaryValue)&#xA;&#xA;    override fun valueToBinary(value: String): ByteArray = value.toByteArray()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GlobalContextKeys {&#xA;    public static final KonigKontextKey&amp;lt;String&amp;gt; MY_CONTEXT_KEY = new KonigKontextKey&amp;lt;&amp;gt;() {&#xA;        @Override&#xA;        public String getDefaultValue() {&#xA;            return &#34;&#34;;&#xA;        }&#xA;&#xA;        @Override&#xA;        public byte[] valueToBinary(String s) {&#xA;            return s.getBytes(StandardCharsets.UTF_8);&#xA;        }&#xA;&#xA;        @Override&#xA;        public String valueFromBinary(byte[] bytes) {&#xA;            return new String(bytes, StandardCharsets.UTF_8);&#xA;        }&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h4&gt;Protobuf Message Based Type:&lt;/h4&gt; &#xA;&lt;p&gt;Using a protobuf message to type your Konig Kontext value is a good practice, as it allows for type changes in a backwards-compatible way. There&#39;s a helper class, &lt;code&gt;KonigKontextProtobufKey&lt;/code&gt;, that makes this easier. The following examples define a key with a value of type &lt;code&gt;MyContextMessage&lt;/code&gt;, where &lt;code&gt;MyContextMessage&lt;/code&gt; extends &lt;code&gt;com.google.protobuf.Message&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;object MyContextKey : KonigKontextProtobufKey&amp;lt;MyContextMessage&amp;gt;(MyContextMessage::class)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GlobalContextKeys {&#xA;    public static final KonigKontextProtobufKey&amp;lt;MyContextMessage&amp;gt; MY_CONTEXT_KEY = KonigKontextProtobufKey.fromJavaClass(MyContextMessage.class);&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;2. Client side setup:&lt;/h3&gt; &#xA;&lt;p&gt;Include the &lt;code&gt;KonigKontextClientInterceptor&lt;/code&gt; in all gRPC clients where you want to propagate the current &lt;code&gt;KonigKontext&lt;/code&gt;. Provide your previously defined &lt;code&gt;KonigKontextKey&lt;/code&gt; to the constructor:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val myServiceClient = MyServiceCoroutineStub(myManagedChannel)&#xA;    .withInterceptors(KonigKontextClientInterceptor(MyContextKey))&#xA;&#xA;// Or for a slightly more succinct way you can optionally use the Kotlin idiomatic helper function instead:&#xA;val myServiceClient = MyServiceCoroutineStub(myManagedChannel)&#xA;    .withKonigKontextInterceptor(MyContextKey)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MyServiceBlockingStub myServiceClient = MyServiceGrpc&#xA;        .newBlockingStub(ManagedChannelBuilder.forTarget(&#34;port here&#34;).usePlaintext().build())&#xA;        .withInterceptors(new KonigKontextClientInterceptor&amp;lt;&amp;gt;(GlobalContextKeys.MY_CONTEXT_KEY));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;3. Server side setup:&lt;/h3&gt; &#xA;&lt;p&gt;Include the &lt;code&gt;KonigKontextServerInterceptor&lt;/code&gt; in all gRPC servers that require access to the &lt;code&gt;KonigKontext&lt;/code&gt;. Provide your previously defined &lt;code&gt;KonigKontextKey&lt;/code&gt; to the constructor.&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val myServer = ServerBuilder&#xA;    .forPort(&amp;lt;port here&amp;gt;)&#xA;    .addService(MyService())&#xA;    .intercept(KonigKontextServerInterceptor(MyContextKey))&#xA;    .build()&#xA;&#xA;// Or for a slightly more succinct way you can optionally use the Kotlin idiomatic helper function instead:&#xA;val myServer = ServerBuilder&#xA;    .forPort(&amp;lt;port here&amp;gt;)&#xA;    .addService(MyService())&#xA;    .withKonigKontextInterceptor(MyContextKey)&#xA;    .build() &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Server myServer = ServerBuilder&#xA;        .forPort(&amp;lt;port here&amp;gt;)&#xA;        .addService(new MyService())&#xA;        .intercept(new KonigKontextServerInterceptor&amp;lt;&amp;gt;(GlobalContextKeys.MY_CONTEXT_KEY))&#xA;        .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;To set and get &lt;code&gt;KonigKontext&lt;/code&gt; values, follow these steps:&lt;/p&gt; &#xA;&lt;h3&gt;Setting value:&lt;/h3&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;withKonigKontext(KonigKontext.withValue(MyContextKey, /* ADD VALUE HERE */)) {&#xA;    // Remaining code path that will have access to the updated KonigKontext&#xA;&#xA;    // Any client stub RPC called from within this lambda will automatically give that RPC&#xA;    // access to the current KonigKontext. &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;KonigKontext.withValue(GlobalContextKeys.MY_CONTEXT_KEY, /* set value here */).run(() -&amp;gt; {&#xA;    // Remaining code path that will have access to the updated KonigKontext&#xA;    &#xA;    // Any client stub RPC called from within this lambda will automatically give that RPC&#xA;    // access to the current KonigKontext.    &#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Getting value:&lt;/h3&gt; &#xA;&lt;p&gt;Any KonigKontext scoped closure (see &lt;code&gt;withKonigKontext&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; above) will have access to get a KonigKontext value. Any downstream microservice RPC called from within a KonigKontext scoped closure can also access a previously set KonigKontext value.&lt;/p&gt; &#xA;&lt;p&gt;Access a KonigKontext value:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;KonigKontext.getValue(MyContextKey)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;KonigKontext.getValue(GlobalContextKeys.MY_CONTEXT_KEY)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Usage Example:&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s consider two services, ServiceA and ServiceB, running in separate containers. ServiceA handles an incoming request and then calls ServiceB:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Service A:&#xA;class ServiceA {&#xA;    val serviceBClient = ServiceBCoroutineStub(myManagedChannel)&#xA;        .withInterceptors(KonigKontextClientInterceptor(MyContextKey)) &#xA;    &#xA;    suspend fun handleRequest(userId: String): Response {&#xA;        return withKonigKontext(KonigKontext.withValue(MyKontextKey, userId)) {&#xA;            println(&#34;USER ID: ${KonigKontext.getValue(MyContextKey)}&#34;)&#xA;            &#xA;            val serviceBResponse = serviceBClient.doSomething(doSomethingRequest { })&#xA;            &#xA;            Response(serviceBResponse)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Service B:&#xA;class ServiceB : ServiceBCoroutineImplBase() {&#xA;    override suspend fun doSomething(DoSomethingRequest: request): Response {&#xA;        val userId = KonigKontext.getValue(MyContextKey)&#xA;        &#xA;        println(&#34;USER ID: $userId&#34;)&#xA;        &#xA;        return Response()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Service A:&#xA;public class ServiceA {&#xA;    var serviceBClient = ServiceBGrpc.newBlockingStub(myManagedChannel)&#xA;        .withInterceptors(new KonigKontextClientInterceptor&amp;lt;&amp;gt;(GlobalContextKeys.MY_CONTEXT_KEY)) &#xA;    &#xA;    public Response handleRequest(String userId) {&#xA;        var responseBuilder = Response.builder();&#xA;        &#xA;        KonigKontext.withValue(GlobalContextKeys.MY_CONTEXT_KEY, userId).run(() -&amp;gt; {&#xA;            System.out.println(&#34;USER ID: &#34; + userId);&#xA;            &#xA;            var getBalanceResponse = serviceBClient.doSomething(DoSomethingRequest.newBuilder().build());&#xA;            &#xA;            responseBuilder.setResponse(getBalanceResponse);&#xA;        });&#xA;        &#xA;        return responseBuilder.build(); &#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Service B:&#xA;public class ServiceB extends ServiceBImplBase {&#xA;    @Override&#xA;    public void doSomething(DoSomethingRequest request, StreamObserver&amp;lt;DoSomethingResponse&amp;gt; responseObserver) {&#xA;        var userId = KonigKontext.getValue(MyContextKey);&#xA;        &#xA;        println(&#34;USER ID: &#34; + userId);&#xA;&#xA;        responseObserver.onNext(DoSomethinResponse.newBuilder().build());&#xA;        responseObserver.onCompleted();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Calling &lt;code&gt;ServiceA.handleRequest(&#34;some_user_id&#34;)&lt;/code&gt; would first print: &lt;code&gt;USER ID: some_user_id&lt;/code&gt; in ServiceA and then also in ServiceB. Since &lt;code&gt;serviceBClient.doSomething()&lt;/code&gt; is called from within a KonigKontext scoped closure, the current KonigKontext is automatically propagated to ServiceB, even though the two services are running in entirely separate containers.&lt;/p&gt; &#xA;&lt;h3&gt;Full Examples:&lt;/h3&gt; &#xA;&lt;p&gt;See full example implementations in:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/konigsoftware/konig-kontext/tree/main/examples/example-kotlin&#34;&gt;Kotlin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/konigsoftware/konig-kontext/tree/main/examples/example-java&#34;&gt;Java&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>