<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-17T01:48:24Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hegaojian/JetpackMvvm</title>
    <updated>2022-08-17T01:48:24Z</updated>
    <id>tag:github.com,2022-08-17:/hegaojian/JetpackMvvm</id>
    <link href="https://github.com/hegaojian/JetpackMvvm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;🐔🏀一个Jetpack结合MVVM的快速开发框架，基于MVVM模式集成谷歌官方推荐的JetPack组件库：LiveData、ViewModel、Lifecycle、Navigation组件 使用Kotlin语言，添加大量拓展函数，简化代码 加入Retrofit网络请求,协程，帮你简化各种操作，让你快速开发项目&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/hegaojian/JetpackMvvm&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/platform-Android-blue.svg?sanitize=true&#34; alt=&#34;Platform&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/hegaojian/JetpackMvvm/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/hegaojian/JetpackMvvm.svg?sanitize=true&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/hegaojian/JetpackMvvm/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-Apache%202-blue.svg?sanitize=true&#34; alt=&#34;GitHub license&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;&lt;span&gt;🐔&lt;/span&gt;&lt;span&gt;🐔&lt;/span&gt;&lt;span&gt;🐔&lt;/span&gt;JetPackMvvm&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;基于MVVM模式集成谷歌官方推荐的JetPack组件库：LiveData、ViewModel、Lifecycle、Navigation组件&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;使用kotlin语言，添加大量拓展函数，简化代码&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;加入Retrofit网络请求,协程，帮你简化各种操作，让你快速请求网络&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;演示Demo&lt;/h2&gt; &#xA;&lt;p&gt;已用该库重构了我之前的玩安卓项目，利用Navigation组件以单Activity+Fragment架构编写，优化了很多代码，对比之前的mvp项目，开发效率与舒适度要提高了不少，想看之前MVP的项目可以去 &lt;a href=&#34;https://github.com/hegaojian/WanAndroid&#34;&gt;https://github.com/hegaojian/WanAndroid&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;效果图展示&lt;/h4&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/9305757-818106225dd01e65.gif?imageMogr2/auto-orient/strip&#34; alt=&#34;项目效果图&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;APK下载：&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/hegaojian/JetpackMvvm/releases/download/1.2.6/app-release.apk&#34;&gt;Github下载&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://d.6short.com/v9q7&#34;&gt;firm下载(推荐)&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;扫码下载(推荐)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/9305757-8ca8324f5690198e.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;1.如何集成&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;1.1 在root&#39;s build.gradle中加入Jitpack仓库&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;allprojects {&#xA;    repositories {&#xA;        ...&#xA;        maven { url &#39;https://jitpack.io&#39; }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;1.2 在app&#39;s build.gradle中添加依赖&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {&#xA;  ...&#xA;  implementation &#39;com.github.hegaojian:JetpackMvvm:1.2.7&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;1.3 在app&#39;s build.gradle中，android 模块下按需开启DataBinding与ViewBinding&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;AndroidStudio 4.0 以下版本------&amp;gt;&#xA;android {&#xA;    ...&#xA;    dataBinding {&#xA;        enabled = true &#xA;    }&#xA;    viewBinding {&#xA;        enabled = true&#xA;    }&#xA;}&#xA;&#xA;AndroidStudio 4.0及以上版本 ------&amp;gt;&#xA;android {&#xA;    ...&#xA;   buildFeatures {&#xA;        dataBinding = true&#xA;        viewBinding = true&#xA;    }&#xA;}&#xA; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;2.继承基类&lt;/h2&gt; &#xA;&lt;p&gt;一般我们项目中都会有一套自己定义的符合业务需求的基类 &lt;em&gt;&lt;strong&gt;BaseActivity/BaseFragment&lt;/strong&gt;&lt;/em&gt;，所以我们的基类需要&lt;strong&gt;继承本框架的Base类&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;不想用Databinding与ViewBinding-------可以继承 BaseVmActivity/BaseVmFragment&lt;/li&gt; &#xA; &lt;li&gt;用Databinding-----------可以继承BaseVmDbActivity/BaseVmDbFragment**&lt;/li&gt; &#xA; &lt;li&gt;用Viewbinding-----------可以继承BaseVmVbActivity/BaseVmVbFragment**&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Activity：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class BaseActivity&amp;lt;VM : BaseViewModel, DB : ViewDataBinding&amp;gt; : BaseVmDbActivity&amp;lt;VM, DB&amp;gt;() {&#xA;     /**&#xA;     * 当前Activity绑定的视图布局Id abstract修饰供子类实现&#xA;     */&#xA;    abstract override fun layoutId(): Int&#xA;    /**&#xA;     * 当前Activityc创建后调用的方法 abstract修饰供子类实现&#xA;     */&#xA;    abstract override fun initView(savedInstanceState: Bundle?)&#xA;&#xA;    /**&#xA;     * 创建liveData数据观察&#xA;     */&#xA;    override override fun createObserver()&#xA;&#xA;&#xA;    /**&#xA;     * 打开等待框 在这里实现你的等待框展示&#xA;     */&#xA;    override fun showLoading(message: String) {&#xA;       ...&#xA;    }&#xA;&#xA;    /**&#xA;     * 关闭等待框 在这里实现你的等待框关闭&#xA;     */&#xA;    override fun dismissLoading() {&#xA;       ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fragment：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;abstract class BaseFragment&amp;lt;VM : BaseViewModel,DB:ViewDataBinding&amp;gt; : BaseVmDbFragment&amp;lt;VM,DB&amp;gt;() {&#xA;   &#xA;    abstract override fun initView(savedInstanceState: Bundle?)&#xA;&#xA;    /**&#xA;     * 懒加载 只有当前fragment视图显示时才会触发该方法 abstract修饰供子类实现&#xA;     */&#xA;    abstract override fun lazyLoadData()&#xA;&#xA;    /**&#xA;     * 创建liveData数据观察 懒加载之后才会触发&#xA;     */&#xA;    override override fun createObserver()&#xA;  &#xA;    /**&#xA;     * Fragment执行onViewCreated后触发的方法 &#xA;     */&#xA;    override fun initData() {&#xA;&#xA;    }&#xA;    &#xA;   /**&#xA;     * 打开等待框 在这里实现你的等待框展示&#xA;     */&#xA;    override fun showLoading(message: String) {&#xA;       ...&#xA;    }&#xA;&#xA;    /**&#xA;     * 关闭等待框 在这里实现你的等待框关闭&#xA;     */&#xA;    override fun dismissLoading() {&#xA;       ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;3.编写一个登录功能&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;3.1 创建LoginViewModel类继承BaseViewModel&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;class LoginViewModel : BaseViewModel() {&#xA;  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;3.2 创建LoginFragment 继承基类传入相关泛型,第一个泛型为你创建的LoginViewModel,第二个泛型为ViewDataBind，保存fragment_login.xml后databinding会生成一个FragmentLoginBinding类。（如果没有生成，试着点击Build-&amp;gt;Clean Project）&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class LoginFragment : BaseFragment&amp;lt;LoginViewModel, FragmentLoginBinding&amp;gt;() {&#xA;    &#xA;    /**&#xA;     *  初始化操作&#xA;     */&#xA;    override fun initView(savedInstanceState: Bundle?) {&#xA;        ...&#xA;    }&#xA;    &#xA;    /**&#xA;     *  fragment 懒加载&#xA;     */&#xA;    override fun lazyLoadData() { &#xA;        ...&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;4.网络请求（Retrofit+协程）&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;4.1 新建请求配置类继承 BaseNetworkApi 示例：&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class NetworkApi : BaseNetworkApi() {&#xA;&#xA;   companion object {&#xA;         &#xA;        val instance: NetworkApi by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) { NetworkApi() }&#xA;&#xA;        //双重校验锁式-单例 封装NetApiService 方便直接快速调用&#xA;        val service: ApiService by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) {&#xA;            instance.getApi(ApiService::class.java, ApiService.SERVER_URL)&#xA;        }&#xA;    }&#xA;   &#xA;    /**&#xA;     * 实现重写父类的setHttpClientBuilder方法，&#xA;     * 在这里可以添加拦截器，可以对 OkHttpClient.Builder 做任意你想要做的骚操作&#xA;     */&#xA;    override fun setHttpClientBuilder(builder: OkHttpClient.Builder): OkHttpClient.Builder {&#xA;        builder.apply {&#xA;            //示例：添加公共heads，可以存放token，公共参数等， 注意要设置在日志拦截器之前，不然Log中会不显示head信息&#xA;            addInterceptor(MyHeadInterceptor())&#xA;            // 日志拦截器&#xA;            addInterceptor(LogInterceptor())&#xA;            //超时时间 连接、读、写&#xA;            connectTimeout(10, TimeUnit.SECONDS)&#xA;            readTimeout(5, TimeUnit.SECONDS)&#xA;            writeTimeout(5, TimeUnit.SECONDS)&#xA;        }&#xA;        return builder&#xA;    }&#xA;&#xA;    /**&#xA;     * 实现重写父类的setRetrofitBuilder方法，&#xA;     * 在这里可以对Retrofit.Builder做任意骚操作，比如添加GSON解析器，protobuf等&#xA;     */&#xA;    override fun setRetrofitBuilder(builder: Retrofit.Builder): Retrofit.Builder {&#xA;        return builder.apply {&#xA;            addConverterFactory(GsonConverterFactory.create(GsonBuilder().create()))&#xA;            addCallAdapterFactory(CoroutineCallAdapterFactory())&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;4.2如果你请求服务器返回的数据有基类（没有可忽略这一步）例如:&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;{&#xA;    &#34;data&#34;: ...,&#xA;    &#34;errorCode&#34;: 0,&#xA;    &#34;errorMsg&#34;: &#34;&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;该示例格式是 &lt;a href=&#34;https://www.wanandroid.com/blog/show/2&#34;&gt;玩Android Api&lt;/a&gt;返回的数据格式，如果errorCode等于0 请求成功，否则请求失败 作为开发者的角度来说，我们主要是想得到脱壳数据-data，且不想每次都判断errorCode==0请求是否成功或失败 这时我们可以在服务器返回数据基类中继承BaseResponse，实现相关方法：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;data class ApiResponse&amp;lt;T&amp;gt;(var errorCode: Int, var errorMsg: String, var data: T) : BaseResponse&amp;lt;T&amp;gt;() {&#xA;&#xA;    // 这里是示例，wanandroid 网站返回的 错误码为 0 就代表请求成功，请你根据自己的业务需求来编写&#xA;    override fun isSucces() = errorCode == 0&#xA;&#xA;    override fun getResponseCode() = errorCode&#xA;&#xA;    override fun getResponseData() = data&#xA;&#xA;    override fun getResponseMsg() = errorMsg&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;4.3 在ViewModel中发起请求，所有请求都是在viewModelScope中启动，请求会发生在IO线程，最终回调在主线程上，当页面销毁的时候，请求会统一取消，不用担心内存泄露的风险，框架做了2种请求使用方式&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;1、将请求数据包装给ResultState，在Activity/Fragment中去监听ResultState拿到数据做处理&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class RequestLoginViewModel: BaseViewModel {&#xA;&#xA;  //自动脱壳过滤处理请求结果，自动判断结果是否成功&#xA;    var loginResult = MutableLiveData&amp;lt;ResultState&amp;lt;UserInfo&amp;gt;&amp;gt;()&#xA;    &#xA;  //不用框架帮脱壳&#xA;    var loginResult2 = MutableLiveData&amp;lt;ResultState&amp;lt;ApiResponse&amp;lt;UserInfo&amp;gt;&amp;gt;&amp;gt;()&#xA;    &#xA;  fun login(username: String, password: String){&#xA;   //1.在 Activity/Fragment的监听回调中拿到已脱壳的数据（项目有基类的可以用）&#xA;        request(&#xA;            { HttpRequestCoroutine.login(username, password) }, //请求体&#xA;            loginResult,//请求的结果接收者，请求成功与否都会改变该值，在Activity或fragment中监听回调结果，具体可看loginActivity中的回调&#xA;            true,//是否显示等待框，，默认false不显示 可以默认不传&#xA;            &#34;正在登录中...&#34;//等待框内容，可以默认不填请求网络中...&#xA;        )&#xA;        &#xA;   //2.在Activity/Fragment中的监听拿到未脱壳的数据，你可以自己根据code做业务需求操作（项目没有基类的可以用）&#xA;        requestNoCheck(&#xA;          {HttpRequestCoroutine.login(username,password)},&#xA;          loginResult2,&#xA;          true,&#xA;          &#34;正在登录中...&#34;) &#xA;}&#xA;&#xA;&#xA;class LoginFragment : BaseFragment&amp;lt;LoginViewModel, FragmentLoginBinding&amp;gt;() {&#xA;    &#xA;    private val requestLoginRegisterViewModel: RequestLoginRegisterViewModel by viewModels()&#xA;    &#xA;    /**&#xA;     *  初始化操作&#xA;     */&#xA;    override fun initView(savedInstanceState: Bundle?) {&#xA;        ...&#xA;    }&#xA;    &#xA;    /**&#xA;     *  fragment 懒加载&#xA;     */&#xA;    override fun lazyLoadData() { &#xA;        ...&#xA;    }&#xA;    &#xA;    override fun createObserver(){&#xA;      //脱壳&#xA;       requestLoginRegisterViewModel.loginResult.observe(viewLifecycleOwner,&#xA;            Observer { resultState -&amp;gt;&#xA;                parseState(resultState, {&#xA;                    //登录成功 打印用户&#xA;                    it.username.logd()&#xA;                }, {&#xA;                    //登录失败(网络连接问题，服务器的结果码不正确...异常都会走在这里)&#xA;                    showMessage(it.errorMsg)&#xA;                })&#xA;            })&#xA;    &#xA;       //不脱壳&#xA;       requestLoginRegisterViewModel.loginResult2.observe(viewLifecycleOwner, Observer {resultState -&amp;gt;&#xA;               parseState(resultState,{&#xA;                   if(it.errorCode==0){&#xA;                       //登录成功 打印用户名&#xA;                       it.data.username.logd()&#xA;                   }else{&#xA;                       //登录失败&#xA;                       showMessage(it.errorMsg)&#xA;                   }&#xA;               },{&#xA;                   //请求发生了异常&#xA;                   showMessage(it.errorMsg)&#xA;               })&#xA;           })&#xA;   } &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;2、 直接在当前ViewModel中拿到请求结果&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class RequestLoginViewModel : BaseViewModel() {&#xA;    &#xA;  fun login(username: String, password: String){&#xA;   //1.拿到已脱壳的数据（项目有基类的可以用）&#xA;     request({HttpRequestCoroutine.login(username,password)},{&#xA;             //请求成功 已自动处理了 请求结果是否正常&#xA;             it.username.logd()&#xA;         },{&#xA;             //请求失败 网络异常，或者请求结果码错误都会回调在这里&#xA;             it.errorMsg.logd()&#xA;         },true,&#34;正在登录中...&#34;)&#xA;        &#xA;   //2.拿到未脱壳的数据，你可以自己根据code做业务需求操作（项目没有基类或者不想框架帮忙脱壳的可以用）&#xA;       requestNoCheck({HttpRequestCoroutine.login(username,password)},{&#xA;            //请求成功 自己拿到数据做业务需求操作&#xA;            if(it.errorCode==0){&#xA;                //结果正确&#xA;                it.data.username.logd()&#xA;            }else{&#xA;                //结果错误&#xA;                it.errorMsg.logd()&#xA;            }&#xA;        },{&#xA;            //请求失败 网络异常回调在这里&#xA;            it.errorMsg.logd()&#xA;        },true,&#34;正在登录中...&#34;)&#xA;}&#xA; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;注意：使用该请求方式时需要注意，如果该ViewModel并不是跟Activity/Fragment绑定的泛型ViewModel，而是&lt;/h3&gt; &#xA;&lt;p&gt;val mainViewModel:MainViewModel by viewModels() 或者 val mainViewModel：MainViewModel by activityViewModels() 获取的 如果请求时要弹出loading，你需要在Activity | Fragment中添加以下代码：&lt;/p&gt; &#xA;&lt;h3&gt;addLoadingObserve(viewModel)&lt;/h3&gt; &#xA;&lt;h2&gt;4.4 开启打印日志开关&lt;/h2&gt; &#xA;&lt;p&gt;设置全局jetpackMvvmLog变量 是否打开请求日志，默认false不打印，如需要打印日志功能，请设值为 true&lt;/p&gt; &#xA;&lt;h2&gt;5.获取ViewModel&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;5.1我们的activity/fragment会有多个ViewModel，按传统的写法感觉有点累&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt; val mainViewModel = ViewModelProvider(this,&#xA;            ViewModelProvider.AndroidViewModelFactory(application)).get(MainViewModel::class.java)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;**现在官方Ktx有拓展函数可以轻松调用&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;//在activity中获取当前Activity级别作用域的ViewModel&#xA; private val mainViewModel:MainViewModel by viewModels()&#xA; &#xA;//在activity中获取Application级别作用域的ViewModel（注，这个是本框架提供的，Application类继承框架的BaseApp才有用）&#xA; private val mainViewModel by lazy { getAppViewModel&amp;lt;MainViewModel&amp;gt;()}&#xA;&#xA;//在fragment中获取当前Fragment级别作用域的ViewModel&#xA; private val mainViewModel:MainViewModel by viewModels()&#xA;&#xA;//在fragment中获取父类Activity级别作用域的ViewModel&#xA;private val mainViewModel：MainViewModel by activityViewModels()&#xA;&#xA;//在fragment中获取Application级别作用域的ViewModel（注，这个是本框架提供的，Application类继承框架的BaseApp才有用）&#xA;private val mainViewModel by lazy { getAppViewModel&amp;lt;MainViewModel&amp;gt;()}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;6.写了一些常用的拓展函数&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt; 算了不写了，这个不重要，想具体看的话可以在&#xA; me.hgj.jetpackmvvm.ext.util&#xA; me.hgj.jetpackmvvm.ext.view&#xA; 的包中看，反正你也可以自己写，按照自己的喜好与需求来&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;7.混淆&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;-keep class me.hgj.jetpackmvvm.**{*;}&#xA;################ ViewBinding &amp;amp; DataBinding ###############&#xA;-keepclassmembers class * implements androidx.viewbinding.ViewBinding {&#xA;  public static * inflate(android.view.LayoutInflater);&#xA;  public static * inflate(android.view.LayoutInflater, android.view.ViewGroup, boolean);&#xA;  public static * bind(android.view.View);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;感谢&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/KunMinX/Jetpack-MVVM-Best-Practice&#34;&gt;Jetpack-MVVM-Best-Practice&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://xiaozhuanlan.com/kunminx?rel=8184827882&#34;&gt;重学安卓&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;联系&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;QQ交流群：419581249&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-license&#34;&gt; Copyright 2019, hegaojian(何高建)       &#xA;  &#xA;   Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;   you may not use this file except in compliance with the License.&#xA;   You may obtain a copy of the License at &#xA; &#xA;       http://www.apache.org/licenses/LICENSE-2.0 &#xA;&#xA;   Unless required by applicable law or agreed to in writing, software&#xA;   distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;   See the License for the specific language governing permissions and&#xA;   limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>zhaobozhen/LibChecker</title>
    <updated>2022-08-17T01:48:24Z</updated>
    <id>tag:github.com,2022-08-17:/zhaobozhen/LibChecker</id>
    <link href="https://github.com/zhaobozhen/LibChecker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An app to view libraries used in apps in your device.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LibChecker&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zhaobozhen/LibChecker/actions/workflows/android.yml&#34;&gt;&lt;img src=&#34;https://github.com/zhaobozhen/LibChecker/actions/workflows/android.yml/badge.svg?sanitize=true&#34; alt=&#34;Android CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://choosealicense.com/licenses/apache-2.0/&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/zhaobozhen/LibChecker?label=License&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://t.me/libcheckerr&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Telegram-Group-blue.svg?logo=telegram&#34; alt=&#34;Discussion&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zhaobozhen/LibChecker/master/source/header.png&#34; alt=&#34;Header&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s this?&lt;/h2&gt; &#xA;&lt;p&gt;This app is used to view the third-party libraries used by applications in your device. It can view the ABI architecture of the application&#39;s native library (in general, whether the application is 64-bit or 32-bit). It can also view well-known libraries marked by &lt;a href=&#34;https://github.com/zhaobozhen/LibChecker-Rules&#34;&gt;The Rule Repository&lt;/a&gt;, and can even sort and view them according to the number of libraries references.&lt;/p&gt; &#xA;&lt;h2&gt;Supported Versions&lt;/h2&gt; &#xA;&lt;p&gt;Android 7.0 ~ 13 Beta 4&lt;/p&gt; &#xA;&lt;p&gt;Android 6 &lt;a href=&#34;https://github.com/zhaobozhen/LibChecker/tree/marshmallow&#34;&gt;Marshmallow&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Document&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zhaobozhen/LibChecker-Docs&#34;&gt;LibChecker-Docs&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.coolapk.com/apk/com.absinthe.libchecker&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zhaobozhen/LibChecker/master/source/coolapk-badge.png&#34; width=&#34;323&#34; height=&#34;125&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://play.google.com/store/apps/details?id=com.absinthe.libchecker&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zhaobozhen/LibChecker/master/source/google-play-badge.png&#34; width=&#34;323&#34; height=&#34;125&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://f-droid.org/packages/com.absinthe.libchecker/&#34;&gt;&lt;img src=&#34;https://fdroid.gitlab.io/artwork/badge/get-it-on.png&#34; width=&#34;323&#34; height=&#34;125&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Discussions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zhaobozhen/LibChecker/discussions&#34;&gt;Github Discussions&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Telegram Group&lt;/h3&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/zhaobozhen/LibChecker/master/source/tg_group_dark.png#gh-dark-mode-only&#34; width=&#34;240&#34; height=&#34;240&#34;&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/zhaobozhen/LibChecker/master/source/tg_group_light.png#gh-light-mode-only&#34; width=&#34;240&#34; height=&#34;240&#34;&gt;</summary>
  </entry>
</feed>