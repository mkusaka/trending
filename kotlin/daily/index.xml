<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-12T01:31:26Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>EranBoudjnah/CleanArchitectureForAndroid</title>
    <updated>2023-08-12T01:31:26Z</updated>
    <id>tag:github.com,2023-08-12:/EranBoudjnah/CleanArchitectureForAndroid</id>
    <link href="https://github.com/EranBoudjnah/CleanArchitectureForAndroid" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Clean Architecture for Android - a sample project&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Clean Architecture for Android Sample Project&lt;/h1&gt; &#xA;&lt;p&gt;This project is a loose implementation of Clean Architecture as presented in my book, &lt;a href=&#34;https://amzn.to/43cUuhb&#34;&gt;Clean Architecture for Android&lt;/a&gt;. It is a native Android project written in Kotlin. It demonstrates the key principles presented in the book and how they apply to a real life project.&lt;/p&gt; &#xA;&lt;p&gt;I will endeavour to keep this project up to date and use it to demonstrate the strengths of the architecture: &lt;strong&gt;scalability&lt;/strong&gt;, &lt;strong&gt;testability&lt;/strong&gt; and &lt;strong&gt;flexibility&lt;/strong&gt; when it comes to choosing 3rd party solutions.&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Feature separation&lt;/li&gt; &#xA; &lt;li&gt;Layer separation &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;UI&lt;/li&gt; &#xA;   &lt;li&gt;Presentation&lt;/li&gt; &#xA;   &lt;li&gt;Domain&lt;/li&gt; &#xA;   &lt;li&gt;Data&lt;/li&gt; &#xA;   &lt;li&gt;Data Source&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Unit tests&lt;/li&gt; &#xA; &lt;li&gt;End-to-end tests&lt;/li&gt; &#xA; &lt;li&gt;Demonstrates use of &lt;a href=&#34;https://developer.android.com/jetpack/compose&#34;&gt;Jetpack Compose&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Demonstrates use of &lt;a href=&#34;https://kotlinlang.org/docs/coroutines-overview.html&#34;&gt;Coroutines&lt;/a&gt; including &lt;a href=&#34;https://kotlinlang.org/docs/flow.html&#34;&gt;Flow&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Demonstrates &lt;abbr title=&#34;Model View ViewModel&#34;&gt;MVVM&lt;/abbr&gt;&lt;/li&gt; &#xA; &lt;li&gt;Code quality checks using &lt;a href=&#34;https://github.com/pinterest/ktlint&#34;&gt;ktlint&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Code quality checks using &lt;a href=&#34;https://github.com/detekt/detekt&#34;&gt;detekt&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Continuous integration (CI) using &lt;a href=&#34;https://github.com/features/actions&#34;&gt;GitHub Actions&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Unit tests&lt;/li&gt; &#xA;   &lt;li&gt;Instrumentation tests&lt;/li&gt; &#xA;   &lt;li&gt;Linting&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Choices&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;&lt;strong&gt;Mappers as classes&lt;/strong&gt;&lt;/em&gt; &lt;strong&gt;vs.&lt;/strong&gt; &lt;em&gt;&lt;strong&gt;mapping extension functions&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &lt;p&gt;When mapping between models, we have several options. The primary decision is between mapper classes and mapping extension functions.&lt;/p&gt; &lt;p&gt;While extension functions are more concise, using them for mapping limits our choices of testing frameworks (&lt;a href=&#34;https://site.mockito.org/&#34;&gt;Mockito&lt;/a&gt;, for example, cannot stub static functions).&lt;/p&gt; &lt;p&gt;How about injecting the mapper extension functions? We could do that. However, this removes the benefits of conciseness almost entirely. It also makes navigation to the implementation harder.&lt;/p&gt; &lt;p&gt;And so, I opted for the slightly more verbose concrete mapper classes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Skipping Google&#39;s &lt;a href=&#34;https://developer.android.com/reference/androidx/lifecycle/package-summary&#34;&gt;Architecture Components&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;The greatest issue with Google&#39;s Architecture Components is that they leak Android details into the Presentation layer. This prevents the Presentation layer from being truly UI agnostic.&lt;/p&gt; &lt;p&gt;Another issue with the Architecture Components is that they give too much responsibility to the ViewModel. They make it persist state it does not own, leading to potential data synchronization bugs.&lt;/p&gt; &lt;p&gt;For these reasons, while still following MVVM, this project relies on &lt;strong&gt;Kotlin Flows&lt;/strong&gt; rather than &lt;strong&gt;LiveData&lt;/strong&gt;, and implements pure ViewModels rather than Google&#39;s.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Mocking framework&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Both &lt;a href=&#34;https://github.com/mockito/mockito-kotlin&#34;&gt;Mockito-Kotlin&lt;/a&gt; and &lt;a href=&#34;https://mockk.io/&#34;&gt;Mockk&lt;/a&gt; are used in this project to demonstrate how the use of each would look.&lt;/p&gt; &lt;p&gt;My personal preference remains &lt;strong&gt;Mockito-Kotlin&lt;/strong&gt;. I find the code easier to read and follow when using it. At the time of writing, judging by the number of stars on each repository, the industry seems to lean towards Mockk.&lt;/p&gt; &lt;p&gt;I was asked about using &lt;em&gt;fakes&lt;/em&gt;. I have explored fakes, and found them to be overly verbose and too expensive to maintain.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Dependency injection framework&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;A critical part of most modern apps, dependency injection (DI) helps us obtain the objects that build our app. It also helps manage their scope. The most popular choices in the Android world are &lt;a href=&#34;https://dagger.dev/hilt/&#34;&gt;Hilt&lt;/a&gt; (which is built on top of &lt;a href=&#34;https://dagger.dev/&#34;&gt;Dagger&lt;/a&gt;) and &lt;a href=&#34;https://insert-koin.io/&#34;&gt;Koin&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Hilt&lt;/strong&gt; was chosen for two main reasons:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Compile time safety&lt;/strong&gt; - having the confidence that all my dependencies are provided before the app starts is a huge time saver and helps maintain a stable app.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;Simplicity&lt;/strong&gt; - from experience, setting up and using Hilt (unlike the underlying Dagger) is considerably easier than using Koin. Hilt also introduces fewer breaking changes over time.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;&lt;strong&gt;XML&lt;/strong&gt;&lt;/em&gt; &lt;strong&gt;vs&lt;/strong&gt; &lt;em&gt;&lt;strong&gt;Jetpack Compose&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Why not both? I still have a lot of concerns around &lt;strong&gt;Jetpack Compose&lt;/strong&gt;. Even so, it was important to me to show the presented architecture works well regardless of the UI mechanism chosen. As an exercise, I invite you to try and replace the UI layer from Compose to XML or vice versa without updating the Presentation layer.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Links&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://amzn.to/43cUuhb&#34; title=&#34;Clean Architecture for Android&#34;&gt;Clean Architecture for Android on Amazon&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&#34; title=&#34;Clean Architecture&#34;&gt;Clean Architecture on the Clean Coder Blog&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>