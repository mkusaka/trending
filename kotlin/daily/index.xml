<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-28T01:42:24Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>abema/flagfit</title>
    <updated>2023-06-28T01:42:24Z</updated>
    <id>tag:github.com,2023-06-28:/abema/flagfit</id>
    <link href="https://github.com/abema/flagfit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Flexible Flag client for Android and Kotlin&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Flagfit&lt;/h1&gt; &#xA;&lt;p&gt;A Flexible Feature Flag Library for Android and Kotlin&lt;/p&gt; &#xA;&lt;p&gt;Flagfit is a powerful, lightweight library designed to turn your feature flags into easy-to-manage Kotlin interfaces. Whether you&#39;re a small startup or a large enterprise, you&#39;ll find Flagfit&#39;s versatility and simplicity beneficial to your software development cycle.&lt;/p&gt; &#xA;&lt;p&gt;By integrating Flagfit into your development workflow, you&#39;ll be able to:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Efficiently manage feature rollouts&lt;/strong&gt;: Toggle new features on or off without deploying new code, giving you the flexibility to test, iterate, and release at your own pace.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Perform A/B testing&lt;/strong&gt;: Easily create and manage multiple versions of your app for conducting experiments and making data-driven decisions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Mitigate risks&lt;/strong&gt;: Gradually roll out features to a subset of users to minimize the impact of potential bugs or issues.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In addition, Flagfit provides a set of robust tools for custom flag sources, async flag fetching with Kotlin Coroutines, custom annotations, and more. Use our built-in lint tool to warn about flag expiration times, ensuring that your flags stay up-to-date and relevant.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;To incorporate Flagfit into your Android project, add the following dependencies to your &lt;code&gt;build.gradle&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;allprojects {&#xA;    repositories {&#xA;        ...&#xA;        maven { url &#39;https://jitpack.io&#39; }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;dependencies {&#xA;    // Flagfit&#xA;    implementation &#39;com.github.abema.flagfit:flagfit:1.1.4&#39;&#xA;    // Flagfit flagtype&#xA;    implementation &#39;com.github.abema.flagfit:flagfit-flagtype:1.1.4&#39;&#xA;    // Flagfit lint&#xA;    lintChecks &#39;com.github.abema.flagfit:flagfit-lint:1.1.4&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to warn about the expiration time set in the Flag, please add the &lt;strong&gt;flagfit-lint&lt;/strong&gt; library as well.&lt;/p&gt; &#xA;&lt;h3&gt;Defining Feature Flags&lt;/h3&gt; &#xA;&lt;p&gt;With Flagfit, feature flags are defined using Kotlin interfaces. The &lt;code&gt;FlagType&lt;/code&gt; annotation specifies different flag types, allowing more control and information about how and when the flag is used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface FlagService {&#xA;    @BooleanFlag(&#xA;      key = &#34;awesome-feature&#34;,&#xA;      defaultValue = false&#xA;    )&#xA;    @FlagType.Experiment(&#xA;      owner = &#34;{GitHub UserId}&#34;,&#xA;      // If the flag expires, the lint will warn you.&#xA;      expiryDate = &#34;2023-06-13&#34;&#xA;    )&#xA;    fun awesomeFeatureEnabled(): Boolean&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Defining FlagSources&lt;/h3&gt; &#xA;&lt;p&gt;A &lt;code&gt;FlagSource&lt;/code&gt; is an abstraction that reads the actual state of a feature flag from a specific location, such as a server. Flagfit allows you to provide a list of &lt;code&gt;FlagSource&lt;/code&gt; instances, meaning you can retrieve flags from multiple sources:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class RemoteFlagSource(&#xA;    private val remoteFlags: RemoveFlags // Your actual implementation to communicate with server&#xA;): BlockingBooleanFlagSource,&#xA;    ExperimentFlagSource {&#xA;&#xA;  override fun get(&#xA;    key: String,&#xA;    defaultValue: Boolean,&#xA;    env: Map&amp;lt;String, Any&amp;gt;&#xA;  ): Boolean {&#xA;    return remoteFlags.get(key, defaultValue)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, &lt;code&gt;RemoteFlagSource&lt;/code&gt; is a class that communicates with a server to fetch the feature flag. &lt;code&gt;remoteFlags&lt;/code&gt; is a hypothetical API service that your application uses to communicate with the backend.&lt;/p&gt; &#xA;&lt;p&gt;Please replace &lt;code&gt;remoteFlags&lt;/code&gt; and &lt;code&gt;remoteFlags.get(key, defaultValue)&lt;/code&gt; with your actual implementation to communicate with the server or SDK like Firebase Remote Config.&lt;/p&gt; &#xA;&lt;h3&gt;Fetching Feature Flags&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val flagfit = Flagfit(&#xA;  flagSources = listOf(RemoteFlagSource(flags)),&#xA;  annotationAdapters = FlagType.annotationAdapters()&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Flagfit generates an implementation of the &lt;code&gt;FlagService&lt;/code&gt; interface which can then be invoked:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val flagService: FlagService = flagfit.create()&#xA;val awesomeFeatureEnabled = flagService.awesomeFeatureEnabled()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Controlling Features&lt;/h3&gt; &#xA;&lt;p&gt;Feature availability in your application can be controlled based on the flag types. For instance, a feature tagged with the &lt;code&gt;@WorkInProgress&lt;/code&gt; flag type won&#39;t be available when the app is released, preventing unintentional feature release.&lt;/p&gt; &#xA;&lt;p&gt;Explore further flag types like &lt;code&gt;@FlagType.WorkInProgress&lt;/code&gt;, &lt;code&gt;@FlagType.Ops&lt;/code&gt;, and &lt;code&gt;@FlagType.Permission&lt;/code&gt; in &lt;a href=&#34;https://github.com/abema/flagfit#flagfit-default-flag-types&#34;&gt;the FlagType documentation section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Flagfit core features&lt;/h2&gt; &#xA;&lt;h3&gt;Introduction&lt;/h3&gt; &#xA;&lt;p&gt;Flagfit turns your Feature Flags into Kotlin interface.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface FlagService {&#xA;    @BooleanFlag(&#xA;      key = &#34;new-awesome-feature&#34;,&#xA;      defaultValue = false&#xA;    )&#xA;    @DebugWith(True::class)&#xA;    @ReleaseWith(False::class)&#xA;    fun awesomeFeatureEnabled(): Boolean&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Flagfit class generates an implementation of the FlagService interface.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val flagfit = Flagfit(&#xA;  baseEnv = mapOf(&#xA;    ENV_IS_DEBUG_KEY to BuildConfig.DEBUG&#xA;  ),&#xA;  annotationAdapters = listOf(&#xA;    ReleaseAnnotationAdapter(),&#xA;    DebugAnnotationAdapter()&#xA;  )&#xA;)&#xA;val flagService: FlagService = flagfit.create()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use the flag by invoking it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val awesomeFeatureEnabled = flagService.awesomeFeatureEnabled()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom flag source&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface FlagService {&#xA;    @BooleanFlag(&#xA;      key = &#34;new-awesome-feature&#34;,&#xA;      defaultValue = false&#xA;    )&#xA;    @DebugWith(LocalFlagSource::class)&#xA;    @ReleaseWith(False::class)&#xA;    fun awesomeFeatureEnabled(): Boolean&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MyLocalFlagSource @Inject constructor(&#xA;  val disk: Disk&#xA;) : LocalFlagSource {&#xA;  override fun get(&#xA;    key: String,&#xA;    defaultValue: Boolean,&#xA;    env: Map&amp;lt;String, Any&amp;gt;&#xA;  ): Boolean {&#xA;    return disk.readFlag(key, defaultValue)&#xA;  }&#xA;}&#xA;&#xA;interface LocalFlagSource : BlockingBooleanFlagSource&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val flagfit = Flagfit(&#xA;  flagSources = listOf(localFlagSource),&#xA;  ...&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Asynchronous flag source&lt;/h3&gt; &#xA;&lt;p&gt;You can use Kotlin Coroutines &lt;code&gt;suspend&lt;/code&gt; function with &lt;code&gt;SuspendableBooleanFlagSource&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface FlagService {&#xA;    @BooleanFlag(&#xA;      key = &#34;new-awesome-feature&#34;,&#xA;      defaultValue = false&#xA;    )&#xA;    @DebugWith(RemoteFlagSource::class)&#xA;    @ReleaseWith(False::class)&#xA;    suspend fun awesomeFeatureEnabled(): Boolean&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MyRemoteFlagSource @Inject constructor(&#xA;  val api: Api&#xA;) : RemoteFlagSource {&#xA;  override suspend fun fetch(&#xA;    key: String,&#xA;    defaultValue: Boolean,&#xA;    env: Map&amp;lt;String, Any&amp;gt;&#xA;  ): Boolean {&#xA;    return api.fetchFlag(key, defaultValue)&#xA;  }&#xA;}&#xA;interface RemoteFlagSource : SuspendableBooleanFlagSource&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom annotation&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;annotation class DevelopWith(&#xA;  val value: KClass&amp;lt;out FlagSource&amp;gt;&#xA;)&#xA;&#xA;class DevelopAnnotationAdapter : AnnotationAdapter&amp;lt;DevelopWith&amp;gt; {&#xA;  override fun canHandle(&#xA;    annotation: DevelopWith,&#xA;    env: Map&amp;lt;String, Any&amp;gt;&#xA;  ): Boolean {&#xA;    return env[ENV_IS_DEVELOP_KEY] == true&#xA;  }&#xA;&#xA;  override fun flagSourceClass(annotation: DevelopWith): KClass&amp;lt;out FlagSource&amp;gt; {&#xA;    return annotation.value&#xA;  }&#xA;&#xA;  override fun annotationClass(): KClass&amp;lt;DevelopWith&amp;gt; {&#xA;    return DevelopWith::class&#xA;  }&#xA;&#xA;  companion object {&#xA;    const val ENV_IS_DEVELOP_KEY = &#34;ENV_IS_DEVELOP_KEY&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@DevelopWith(True::class)&#xA;fun awesomeFeatureEnabled(): Boolean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Testing&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val flagfit = Flagfit(&#xA;  flagSources = listOf(),&#xA;  baseEnv = mapOf(Flagfit.ENV_IS_DEBUG_KEY to true),&#xA;  annotationAdapters = listOf(&#xA;    ReleaseAnnotationAdapter(),&#xA;    DebugAnnotationAdapter()&#xA;  )&#xA;)&#xA;val flagService: FlagService = flagfit.create()&#xA;&#xA;val awesomeFeatureEnabled = flagService.awesomeFeatureEnabled()&#xA;&#xA;assertThat(awesomeFeatureEnabled).isTrue()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Variation Testing&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;enum class ABC {&#xA;  A, B, C;&#xA;&#xA;  companion object : VariationAdapter&amp;lt;ABC&amp;gt;(ABC::class) {&#xA;    override fun variationOf(value: String): ABC {&#xA;      return values().firstOrNull { it.name == value } ?: A&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface Service {&#xA;  @VariationFlag(&#xA;    key = &#34;variation&#34;,&#xA;    defaultValue = ABC.DEFAULT_VALUE&#xA;  )&#xA;  @DefaultWith(LocalFlagSource::class)&#xA;  fun variation(): ABC&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val flagfit = Flagfit(&#xA;  variationAdapters = listOf(ABC.Companion)&#xA;  ...&#xA;)&#xA;val service = flagfit.create(Service::class)&#xA;val abc = service.variation()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Overriding or Adding environment variable for function&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@DevelopWith(True::class)&#xA;@BooleanEnv(key = ENV_IS_DEVELOP_KEY, value = true)&#xA;fun awesomeFeatureEnabled(): Boolean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Debuggable feature&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val flagStates: List&amp;lt;Flagfit.FlagState&amp;gt; = flagfit.getFlagStates(FlagService::class)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;sealed class FlagState(&#xA;  open val method: Method,&#xA;  // mutable for debug&#xA;  open var flagSource: FlagSource?,&#xA;  open val isSuspendFunction: Boolean,&#xA;  open val env: Map&amp;lt;String, Any&amp;gt;&#xA;) {&#xA;  data class BooleanFlagState(&#xA;    val booleanFlag: BooleanFlag,&#xA;    override val method: Method,&#xA;    // mutable for debug&#xA;    override var flagSource: FlagSource?,&#xA;    override val isSuspendFunction: Boolean,&#xA;    override val env: Map&amp;lt;String, Any&amp;gt;&#xA;  ) : FlagState(method, flagSource, isSuspendFunction, env) {&#xA;    fun invokeFlag(service: Any): Boolean {&#xA;      return method.invoke(service) as Boolean&#xA;    }&#xA;  }&#xA;&#xA;  data class VariationFlagState(&#xA;    val variationFlag: VariationFlag,&#xA;    val variationAdapter: VariationAdapterInterface&amp;lt;*&amp;gt;,&#xA;    // mutable for debug&#xA;    override val method: Method,&#xA;    override var flagSource: FlagSource?,&#xA;    override val isSuspendFunction: Boolean,&#xA;    override val env: Map&amp;lt;String, Any&amp;gt;&#xA;  ) : FlagState(method, flagSource, isSuspendFunction, env) {&#xA;    fun invokeFlag(service: Any): Any {&#xA;      return method.invoke(service) as Any&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Flagfit default flag types&lt;/h2&gt; &#xA;&lt;p&gt;This library uses the Flagfit library and provides some intentional flag type annotations according to Feature Toggles articles.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://martinfowler.com/articles/feature-toggles.html&#34;&gt;https://martinfowler.com/articles/feature-toggles.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Introduction for default flag types&lt;/h3&gt; &#xA;&lt;p&gt;As we develop, we use Release Toggles, Experiment Toggles, and Opts Toggles for features.&lt;br&gt; We develop by switching these flags.&lt;/p&gt; &#xA;&lt;p&gt;We use the &lt;code&gt;@WorkInProgress&lt;/code&gt; as Release Toggles when we first start development.&lt;br&gt; If the flag using this &lt;code&gt;@FlagType.WorkInProgress&lt;/code&gt; is used properly, even if the feature is released, &lt;strong&gt;the false value will be used fixedly&lt;/strong&gt;, so the function will not be released by mistake.&lt;/p&gt; &#xA;&lt;p&gt;When using FlagType, please set &lt;code&gt;owner&lt;/code&gt; and &lt;code&gt;expiryDate&lt;/code&gt;. &lt;a href=&#34;https://raw.githubusercontent.com/abema/flagfit/main/README.md#Lint-check-based-on-expiration-date&#34;&gt;Please see section&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@BooleanFlag(&#xA;  key = &#34;awesome-feature&#34;,&#xA;  defaultValue = false&#xA;)&#xA;@FlagType.WorkInProgress(&#xA;  owner = &#34;{GitHub UserId}&#34;,&#xA;  expiryDate = &#34;2023-06-13&#34;&#xA;)&#xA;fun awesomeFeatureEnabled(): Boolean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, we do A / B testing and experiment with what we develop.&lt;br&gt; So we use &lt;code&gt;@FlagType.Experiment&lt;/code&gt;. With it, you can use any flag management tool, such as Firebase RemoteConfig, to get the flag and use it. You need to pass a FlagSource that implements &lt;code&gt;ExperimentFlagSource&lt;/code&gt; when initializing Flagfit.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@BooleanFlag(&#xA;  key = &#34;awesome-feature&#34;,&#xA;  defaultValue = false&#xA;)&#xA;@FlagType.Experiment(&#xA;  owner = &#34;{GitHub UserId}&#34;,&#xA;  expiryDate = &#34;2023-06-13&#34;&#xA;)&#xA;fun awesomeFeatureEnabled(): Boolean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, in the operation stage, it can be implemented using &lt;code&gt;@FlagType.Ops&lt;/code&gt; and OpsFlagSource as well.&lt;br&gt; If you implement &lt;code&gt;ExperimentFlagSource&lt;/code&gt; and &lt;code&gt;OpsFlagSource&lt;/code&gt;, you can use one flag management tool either.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;@FlagType.Ops&lt;/code&gt; and &lt;code&gt;@FlagType.Permission&lt;/code&gt; may sometimes have no expiry date, so please set them to &lt;code&gt;EXPIRY_DATE_INFINITE&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;import tv.abema.flagfit.FlagType.Companion.EXPIRY_DATE_INFINITE&#xA;&#xA;@BooleanFlag(&#xA;  key = &#34;awesome-feature&#34;,&#xA;  defaultValue = false&#xA;)&#xA;@FlagType.Ops(&#xA;  owner = &#34;{GitHub UserId}&#34;,&#xA;  expiryDate = EXPIRY_DATE_INFINITE&#xA;)&#xA;fun awesomeFeatureEnabled(): Boolean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There may be cases where you do not know the owner or do not want to intentionally generate an error due to not setting a property. In such cases, please set the value as follows&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;import tv.abema.flagfit.FlagType.Companion.EXPIRY_DATE_NOT_DEFINED&#xA;import tv.abema.flagfit.FlagType.Companion.OWNER_NOT_DEFINED&#xA;&#xA;@BooleanFlag(&#xA;  key = &#34;new-awesome-unknown-feature&#34;,&#xA;  defaultValue = false&#xA;)&#xA;@FlagType.WorkInProgress(&#xA;  owner = OWNER_NOT_DEFINED,&#xA;  expiryDate = EXPIRY_DATE_NOT_DEFINED&#xA;)&#xA;fun awesomeUnknownFeatureEnabled(): Boolean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setup for default flag types&lt;/h3&gt; &#xA;&lt;p&gt;You can use the default flag types as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MyLocalFlagSource @Inject constructor(&#xA;    val disk: Disk&#xA;) : BlockingBooleanFlagSource,&#xA;    /* **please implement ExperimentFlagSource ** */&#xA;    ExperimentFlagSource {&#xA;    override fun get(&#xA;        key: String,&#xA;        defaultValue: Boolean,&#xA;        env: Map&amp;lt;String, Any&amp;gt;&#xA;    ): Boolean {&#xA;        return disk.readFlag(key, defaultValue)&#xA;    }&#xA;}&#xA;&#xA;val flagfit = Flagfit(&#xA;  // To use @FlagType.Experiment or @FlagType.Ops, you need to set an object that implements ExperimentFlagSource or OpsFlagSource.&#xA;  flagSources = listOf(myLocalFlagSource),&#xA;  baseEnv = mapOf(&#xA;    Flagfit.ENV_IS_DEBUG_KEY to BuildConfig.DEBUG&#xA;  ),&#xA;  // You need to add annotation adapters to use flag type annotations.&#xA;  annotationAdapters = FlagType.annotationAdapters()&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Lint check based on expiration date&lt;/h2&gt; &#xA;&lt;p&gt;Flags that have passed their expiration date or are scheduled to expire within the next 7 days will be displayed as warnings in the IDE.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Explanation&lt;/th&gt; &#xA;   &lt;th&gt;Image&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;When the flag is about to expire&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img width=&#34;799&#34; alt=&#34;soon&#34; src=&#34;https://github.com/abema/flagfit/assets/51113946/7fc78bd3-54ba-44c5-9433-9531563b1388&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;When the flag has expired&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img width=&#34;687&#34; alt=&#34;expired&#34; src=&#34;https://github.com/abema/flagfit/assets/51113946/804e49b8-1555-413e-9455-f6bf21b6e622&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Automatic issue creation via workflow&lt;/h3&gt; &#xA;&lt;p&gt;Flags that have passed their expiration date will be automatically created as issues assigned to the creator through the workflow.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Please copy the &lt;a href=&#34;https://raw.githubusercontent.com/abema/flagfit/main/.github/workflows/lintIssues.yml&#34;&gt;workflow&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/abema/flagfit/main/scripts/maintain-flagfit-expiration-issue.main.kts&#34;&gt;script&lt;/a&gt; to the project you are using.&lt;/li&gt; &#xA; &lt;li&gt;The workflow allows you to set a cron schedule, so please set it as appropriate.&lt;/li&gt; &#xA; &lt;li&gt;When setting feature flags with Flagfit, you will likely use &lt;code&gt;@BooleanFlag&lt;/code&gt; or &lt;code&gt;@VariationFlag&lt;/code&gt;, but please make sure that the key value is always unique.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img width=&#34;1253&#34; alt=&#34;Sample issues&#34; src=&#34;https://github.com/abema/flagfit/assets/51113946/e4e5715d-f77a-4ffc-abbd-429544c1c1fa&#34;&gt;</summary>
  </entry>
  <entry>
    <title>SEAbdulbasit/recipe-app</title>
    <updated>2023-06-28T01:42:24Z</updated>
    <id>tag:github.com,2023-06-28:/SEAbdulbasit/recipe-app</id>
    <link href="https://github.com/SEAbdulbasit/recipe-app" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Recipe App in Compose Multiplatform&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Recipe App Compose Multiplatform&lt;/h2&gt; &#xA;&lt;p&gt;Inspired by &lt;a href=&#34;https://github.com/Roaa94&#34;&gt;Roaa Kadam&lt;/a&gt; flutter &lt;a href=&#34;https://github.com/Roaa94/recipes_ui_app/&#34;&gt;app&lt;/a&gt;, I wanted to do the same in Compose Multiplatform. There is a lot to explore in Compose Multiplatform from the aspect of this app like Heor Animation, Collapsable Toolbar, Staggered Animations, Gyroscope detection etc etc.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; It is still a work in progress&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Future Plan&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Initial implementation for Mobile Support (Android, iOS)&lt;/li&gt; &#xA; &lt;li&gt;Support for Desktop&lt;/li&gt; &#xA; &lt;li&gt;Support for Web via WASM&lt;/li&gt; &#xA; &lt;li&gt;Look into Android TV&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img width=&#34;615&#34; alt=&#34;Screenshot 2023-06-22 at 11 49 28 AM&#34; src=&#34;https://github.com/SEAbdulbasit/recipe-app/assets/33172684/ac19c301-8263-4d2c-8cfc-58f27d1acdb3&#34;&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/SEAbdulbasit/recipe-app/assets/33172684/132dafeb-c304-4470-b995-133cbf20d264&#34;&gt;https://github.com/SEAbdulbasit/recipe-app/assets/33172684/132dafeb-c304-4470-b995-133cbf20d264&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>