<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-08T01:39:57Z</updated>
  <subtitle>Daily Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SEAbdulbasit/MusicApp-KMP</title>
    <updated>2023-03-08T01:39:57Z</updated>
    <id>tag:github.com,2023-03-08:/SEAbdulbasit/MusicApp-KMP</id>
    <link href="https://github.com/SEAbdulbasit/MusicApp-KMP" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This is a music player app built using Compose Multiplatform UI that works on #Android, #iOS, #Desktop, and #Web platforms.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Music Player App Using Compose Multiplatform&lt;/h1&gt; &#xA;&lt;p&gt;This is a music player app built using Compose Multiplatform UI that works on #Android, #iOS, #Desktop, and #Web platforms.&lt;/p&gt; &#xA;&lt;h2&gt;Platforms&lt;/h2&gt; &#xA;&lt;p&gt;The app uses different media players on different platforms:&lt;/p&gt; &#xA;&lt;p&gt;For iOS, AVKit is used For Android, Media Player is used For Desktop, VLCJ media player is used For the Web, an HTML media player is used.&lt;/p&gt; &#xA;&lt;h2&gt;Integration with Low-Level APIs&lt;/h2&gt; &#xA;&lt;p&gt;One of the objectives of building this app was to explore how Compose UI interacts with low-level APIs. The experience was challenging yet fun, and the process taught me a lot. Out of all the media players used, integrating with the Web Media Player was the easiest. I&#39;m grateful to IceRock Development and Aleksey Mikhailov for their demo application, which was a fantastic learning resource.&lt;/p&gt; &#xA;&lt;h2&gt;Running the app&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone this repository:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/SEAbdulbasit/MusicApp-KMP.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open the project in Android Studio or IntelliJ IDEA.&lt;/li&gt; &#xA; &lt;li&gt;Search for &lt;strong&gt;&lt;em&gt;TOKEN&lt;/em&gt;&lt;/strong&gt; file in the code and replace the placeholder with your &lt;strong&gt;Spotify access token&lt;/strong&gt;. You can generate a new token from the &lt;a href=&#34;https://developer.spotify.com/console/get-album-tracks/&#34;&gt;Spotify Developer Dashboard&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run the app on your desired platform. There are a few known issues with the Music Player app using Compose Multiplatform UI:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Known Issues&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When you click &#34;Select All&#34; on Android, Web, and Desktop, the app will auto-play the selected tracks and continue playing the next track when the previous one ends. On iOS, there are issues with the callbacks for &lt;code&gt;onReady&lt;/code&gt; and &lt;code&gt;onVideoCompleted&lt;/code&gt; which is causing the player to not start automatically. I was unable to configure the callbacks but hopefully, will be fixing that soon.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Demo&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/33172684/222960302-eccb34b4-d77c-4c95-96af-3d4528323c42.png&#34; alt=&#34;Screenshot 2023-03-05 at 4 44 45 PM&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Repository&lt;/h2&gt; &#xA;&lt;p&gt;To explore what Compose UI can do, check out the repository for the latest updates: &lt;a href=&#34;https://github.com/SEAbdulbasit/MusicApp-KMP&#34;&gt;https://github.com/SEAbdulbasit/MusicApp-KMP&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re interested in getting started with Compose Multiplatform, I have a template for you here: &lt;a href=&#34;https://github.com/SEAbdulbasit/KMP-Compose-Template&#34;&gt;https://github.com/SEAbdulbasit/KMP-Compose-Template&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you find my work helpful, please consider giving it a ‚≠ê ‚ù§Ô∏è.&lt;/p&gt; &#xA;&lt;h2&gt;Other Projects&lt;/h2&gt; &#xA;&lt;p&gt;TravelApp: &lt;a href=&#34;https://github.com/SEAbdulbasit/TravelApp-KMP&#34;&gt;https://github.com/SEAbdulbasit/TravelApp-KMP&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Technologies and Libraries Used&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Kotlin&lt;/li&gt; &#xA; &lt;li&gt;Compose Multiplatform UI&lt;/li&gt; &#xA; &lt;li&gt;AVKit Media Player&lt;/li&gt; &#xA; &lt;li&gt;VLCJ media player&lt;/li&gt; &#xA; &lt;li&gt;HTML media player&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/qdsfdhvh/compose-imageloader&#34;&gt;Compose Image Loader&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;m grateful to IceRock Development and Aleksey Mikhailov for their demo application, which was an invaluable resource.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>OmGodse/Notally</title>
    <updated>2023-03-08T01:39:57Z</updated>
    <id>tag:github.com,2023-03-08:/OmGodse/Notally</id>
    <link href="https://github.com/OmGodse/Notally" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A beautiful notes app&lt;/p&gt;&lt;hr&gt;&lt;h3&gt;Background&lt;/h3&gt; &#xA;&lt;p&gt;Notally was created because I wanted to make something that was beautiful and at the same time, useful. It&#39;s extremely light, there are minimal dependencies and lines of code. (Without compromising on readability)&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Auto backup&lt;/li&gt; &#xA; &lt;li&gt;Adjustable text size&lt;/li&gt; &#xA; &lt;li&gt;Support for Lollipop devices and up&lt;/li&gt; &#xA; &lt;li&gt;APK size of 1.2 MB (1.6 MB uncompressed)&lt;/li&gt; &#xA; &lt;li&gt;Color, pin and label your notes for quick organisation&lt;/li&gt; &#xA; &lt;li&gt;Archive notes to keep them around, but out of your way&lt;/li&gt; &#xA; &lt;li&gt;Export notes as TXT, JSON, HTML or PDF files with formatting&lt;/li&gt; &#xA; &lt;li&gt;Create rich text notes with support for bold, italics, mono space and strike-through&lt;/li&gt; &#xA; &lt;li&gt;Add clickable links to notes with support for phone numbers, email addresses and web urls&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://play.google.com/store/apps/details?id=com.omgodse.notally&#34;&gt;&lt;img src=&#34;https://play.google.com/intl/en_us/badges/images/generic/en_badge_web_generic.png&#34; alt=&#34;Get it on Google Play&#34; height=&#34;70&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://f-droid.org/packages/com.omgodse.notally/&#34;&gt;&lt;img src=&#34;https://fdroid.gitlab.io/artwork/badge/get-it-on.png&#34; alt=&#34;Get it on F-Droid&#34; height=&#34;70&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Translations&lt;/h3&gt; &#xA;&lt;p&gt;All translations are crowd sourced. To contribute or point out any errors, email me or open a pull request.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/OmGodse/Notally/master/fastlane/metadata/android/en-US/images/phoneScreenshots/1.png&#34; width=&#34;250&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/OmGodse/Notally/master/fastlane/metadata/android/en-US/images/phoneScreenshots/2.png&#34; width=&#34;250&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/OmGodse/Notally/master/fastlane/metadata/android/en-US/images/phoneScreenshots/3.png&#34; width=&#34;250&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Hall of fame&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=bwz13aM0qJk&#34;&gt;Top 20 Android Apps 2021!&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=RQUEgwgV99I&#34;&gt;De-Googling Any Android Phone! (Google Apps Alternatives)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=BJw5tKPP1PY&#34;&gt;The BEST Private Notetaking Apps Explained&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.noteapps.ca/notally/&#34;&gt;Notally&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Roadmap&lt;/h3&gt; &#xA;&lt;p&gt;These are in works but they&#39;ll take time as this is a side project.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Images&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Auto backup&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Batch selection&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>skydoves/sandwich</title>
    <updated>2023-03-08T01:39:57Z</updated>
    <id>tag:github.com,2023-03-08:/skydoves/sandwich</id>
    <link href="https://github.com/skydoves/sandwich" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ü•™ A lightweight and pluggable sealed API library for modeling Retrofit responses and handling exceptions on Kotlin and Android.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/24237865/162602054-2010d249-8a81-4673-b9ae-1edff1080ab7.png&#34; alt=&#34;sandwich&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;&lt;img alt=&#34;License&#34; src=&#34;https://img.shields.io/badge/License-Apache%202.0-blue.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://android-arsenal.com/api?level=16&#34;&gt;&lt;img alt=&#34;API&#34; src=&#34;https://img.shields.io/badge/API-16%2B-brightgreen.svg?style=flat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/skydoves/Sandwich/actions&#34;&gt;&lt;img alt=&#34;Build Status&#34; src=&#34;https://github.com/skydoves/Sandwich/workflows/Android%20CI/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://devlibrary.withgoogle.com/products/android/repos/skydoves-Sandwich&#34;&gt;&lt;img alt=&#34;Google&#34; src=&#34;https://skydoves.github.io/badges/google-devlib.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://skydoves.medium.com/handling-success-data-and-error-callback-responses-from-a-network-for-android-projects-using-b53a26214cef&#34;&gt;&lt;img alt=&#34;Medium&#34; src=&#34;https://skydoves.github.io/badges/Story-Medium.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/skydoves&#34;&gt;&lt;img alt=&#34;Profile&#34; src=&#34;https://skydoves.github.io/badges/skydoves.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://youtu.be/agjbbn9Swkc&#34;&gt;&lt;img alt=&#34;Profile&#34; src=&#34;https://skydoves.github.io/badges/youtube-android-worldwide.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://skydoves.github.io/libraries/sandwich/html/sandwich/com.skydoves.sandwich/index.html&#34;&gt;&lt;img alt=&#34;Dokka&#34; src=&#34;https://skydoves.github.io/badges/dokka-sandwich.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Why Sandwich?&lt;/h2&gt; &#xA;&lt;p&gt;Sandwich was invented to construct standardized interfaces from the Retrofit network response on Kotlin. This library allows you to handle the body data, errors, and exceptional cases more concisely with functional operators in multi-layer architecture. You don&#39;t need to design and build wrapper classes such as &lt;code&gt;Resource&lt;/code&gt; or &lt;code&gt;Result&lt;/code&gt;, and it helps you to focus on your business codes. Sandwich supports &lt;a href=&#34;https://github.com/skydoves/sandwich#global-operator&#34;&gt;global responses handling&lt;/a&gt;, &lt;a href=&#34;https://github.com/skydoves/sandwich#mapper&#34;&gt;Mapper&lt;/a&gt;, &lt;a href=&#34;https://github.com/skydoves/sandwich#operator&#34;&gt;Operator&lt;/a&gt;, and great compatibilities, such as &lt;a href=&#34;https://github.com/skydoves/sandwich#toflow&#34;&gt;toFlow&lt;/a&gt;. You can also utilize Sandwich with &lt;a href=&#34;https://github.com/skydoves/sandwich#apiresponse-for-coroutines&#34;&gt;coroutines&lt;/a&gt; and &lt;a href=&#34;https://github.com/skydoves/sandwich#suspendonsuccess-suspendonerror-suspendonexception&#34;&gt;flow&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://search.maven.org/search?q=g:%22com.github.skydoves%22%20AND%20a:%22sandwich%22&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.github.skydoves/sandwich.svg?label=Maven%20Central&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;ü•™ Sandwich has been downloaded in more than &lt;strong&gt;200k&lt;/strong&gt; Android projects all over the globe! &lt;br&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/24237865/103460609-f18ee000-4d5a-11eb-81e2-17696e3a5804.png&#34; width=&#34;774&#34; height=&#34;224&#34;&gt; &#xA;&lt;h3&gt;Gradle&lt;/h3&gt; &#xA;&lt;p&gt;Add the dependency below into your &lt;strong&gt;module&lt;/strong&gt;&#39;s &lt;code&gt;build.gradle&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {&#xA;    implementation &#34;com.github.skydoves&lt;span&gt;ü•™&lt;/span&gt;1.3.4&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;SNAPSHOT&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://oss.sonatype.org/content/repositories/snapshots/com/github/skydoves/sandwich/&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=snapshot&amp;amp;message=sandwich&amp;amp;logo=apache%20maven&amp;amp;color=C71A36&#34; alt=&#34;Sandwich&#34;&gt;&lt;/a&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;See how to import the snapshot&lt;/summary&gt; &#xA; &lt;h3&gt;Including the SNAPSHOT&lt;/h3&gt; &#xA; &lt;p&gt;Snapshots of the current development version of Sandwich are available, which track &lt;a href=&#34;https://oss.sonatype.org/content/repositories/snapshots/com/github/skydoves/sandwich/&#34;&gt;the latest versions&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;p&gt;To import snapshot versions on your project, add the code snippet below on your gradle file:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-Gradle&#34;&gt;repositories {&#xA;   maven { url &#39;https://oss.sonatype.org/content/repositories/snapshots/&#39; }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Next, add the dependency below to your &lt;strong&gt;module&lt;/strong&gt;&#39;s &lt;code&gt;build.gradle&lt;/code&gt; file:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {&#xA;    implementation &#34;com.github.skydoves&lt;span&gt;ü•™&lt;/span&gt;1.3.5-SNAPSHOT&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Use Cases&lt;/h2&gt; &#xA;&lt;p&gt;You can also check out nice use cases of this library in the repositories below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/pokedex&#34;&gt;Pokedex&lt;/a&gt; - üó°Ô∏è Android Pokedex using Hilt, Motion, Coroutines, Flow, Jetpack (Room, ViewModel, LiveData) based on MVVM architecture.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/DisneyMotions&#34;&gt;DisneyMotions&lt;/a&gt; - ü¶Å A Disney app using transformation motions based on MVVM (ViewModel, Coroutines, LiveData, Room, Repository, Koin) architecture.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/marvelheroes&#34;&gt;MarvelHeroes&lt;/a&gt; - ‚ù§Ô∏è A sample Marvel heroes application based on MVVM (ViewModel, Coroutines, LiveData, Room, Repository, Koin) architecture.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/CarlosEsco/Neko&#34;&gt;Neko&lt;/a&gt; - Free, open source, unofficial MangaDex reader for Android.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/TheMovies2&#34;&gt;TheMovies2&lt;/a&gt; - üé¨ A demo project using The Movie DB based on Kotlin MVVM architecture and material design &amp;amp; animations.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#apiresponse&#34;&gt;ApiResponse&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#apiresponse-extensions&#34;&gt;onSuccess, onError, onException&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#apiresponse-for-coroutines&#34;&gt;ApiResponse for coroutines&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#apiresponse-extensions-for-coroutines&#34;&gt;ApiResponse Extensions for Coroutines&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#retrieve-success-data&#34;&gt;Retrieve success data&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#mapper&#34;&gt;Mapper&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#run-and-retry&#34;&gt;Run and Retry&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#operator&#34;&gt;Operator&lt;/a&gt;, &lt;a href=&#34;https://github.com/skydoves/sandwich#operator-with-coroutines&#34;&gt;Operator for coroutines&lt;/a&gt;, &lt;a href=&#34;https://github.com/skydoves/sandwich#global-operator&#34;&gt;Global Operator&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#merge&#34;&gt;Merge&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#toflow&#34;&gt;toFlow&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich#responsedatasource&#34;&gt;ResponseDataSource&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;ApiResponse&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ApiResponse&lt;/code&gt; is an interface to construct standardized responses from &lt;a href=&#34;https://github.com/square/retrofit&#34;&gt;Retrofit&lt;/a&gt; calls. It provides useful extensions for handling network payload such as body data and exceptional cases. You can get &lt;code&gt;ApiResponse&lt;/code&gt; with the &lt;code&gt;request&lt;/code&gt; scope extension from the &lt;a href=&#34;https://square.github.io/retrofit/2.x/retrofit/retrofit2/Call.html&#34;&gt;Call&lt;/a&gt;. The example below shows how to get an &lt;code&gt;ApiResponse&lt;/code&gt; from an instance of the &lt;code&gt;Call&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface DisneyService {&#xA;  @GET(&#34;/&#34;)&#xA;  fun fetchDisneyPosterList(): Call&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;&#xA;}&#xA;&#xA;val disneyService = retrofit.create(DisneyService::class.java)&#xA;// fetches a model list from the network and getting [ApiResponse] asynchronously.&#xA;disneyService.fetchDisneyPosterList().request { response -&amp;gt;&#xA;      when (response) {&#xA;        // handles the success case when the API request gets a successful response.&#xA;        is ApiResponse.Success -&amp;gt; {&#xA;          posterDao.insertPosterList(response.data)&#xA;          livedata.post(response.data)&#xA;        }&#xA;        // handles error cases when the API request gets an error response.&#xA;        // e.g., internal server error.&#xA;        is ApiResponse.Failure.Error -&amp;gt; {&#xA;          // stub error case&#xA;          Timber.d(message())&#xA;&#xA;          // handles error cases depending on the status code.&#xA;          when (statusCode) {&#xA;            StatusCode.InternalServerError -&amp;gt; toastLiveData.postValue(&#34;InternalServerError&#34;)&#xA;            StatusCode.BadGateway -&amp;gt; toastLiveData.postValue(&#34;BadGateway&#34;)&#xA;            else -&amp;gt; toastLiveData.postValue(&#34;$statusCode(${statusCode.code}): ${message()}&#34;)&#xA;          }&#xA;        }&#xA;        // handles exceptional cases when the API request gets an exception response.&#xA;        // e.g., network connection error, timeout.&#xA;        is ApiResponse.Failure.Exception -&amp;gt; {&#xA;          // stub exception case&#xA;        }&#xA;      }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ApiResponse has three types; &lt;strong&gt;Success&lt;/strong&gt;, &lt;strong&gt;Failure.Error&lt;/strong&gt;, and &lt;strong&gt;Failure.Exception&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;ApiResponse.Success&lt;/h3&gt; &#xA;&lt;p&gt;This represents the network request has been successful. You can get the body data of the response, and additional information such as &lt;code&gt;StatusCode&lt;/code&gt;, &lt;code&gt;Headers&lt;/code&gt;, and more from the &lt;code&gt;ApiResponse.Success&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val data: List&amp;lt;Poster&amp;gt;? = response.data&#xA;val statusCode: StatusCode = response.statusCode&#xA;val headers: Headers = response.headers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ApiResponse.Failure.Error&lt;/h3&gt; &#xA;&lt;p&gt;This represents the network request has been failed with bad requests or internal server errors. You can get an error message and additional information such as &lt;code&gt;StatusCode&lt;/code&gt;, &lt;code&gt;Headers&lt;/code&gt;, and more from the &lt;code&gt;ApiResponse.Failure.Error&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val message: String = response.message()&#xA;val errorBody: ResponseBody? = response.errorBody&#xA;val statusCode: StatusCode = response.statusCode&#xA;val headers: Headers = response.headers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ApiResponse.Failure.Exception&lt;/h3&gt; &#xA;&lt;p&gt;This represents the network request has been failed when unexpected exceptions occur while creating requests or processing a response from the client-side such as network connection failed. You can get an exception message from the &lt;code&gt;ApiResponse.Failure.Exception&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;ApiResponse Extensions&lt;/h3&gt; &#xA;&lt;p&gt;You can handle the &lt;code&gt;ApiResponse&lt;/code&gt; with the extensions below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;onSuccess&lt;/strong&gt;: Executes if the &lt;code&gt;ApiResponse&lt;/code&gt; is &lt;code&gt;ApiResponse.Success&lt;/code&gt;. You can access body data directly in this scope.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;onError&lt;/strong&gt;: Executes if the &lt;code&gt;ApiResponse&lt;/code&gt; is &lt;code&gt;ApiResponse.Failure.Error&lt;/code&gt;. You can access &lt;code&gt;message()&lt;/code&gt; and &lt;code&gt;errorBody&lt;/code&gt; in this scope.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;onException&lt;/strong&gt;: Executes if the &lt;code&gt;ApiResponse&lt;/code&gt; is &lt;code&gt;ApiResponse.Failure.Exception&lt;/code&gt;. You can access &lt;code&gt;message()&lt;/code&gt; in this scope.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;onFailure&lt;/strong&gt;: Executes if the &lt;code&gt;ApiResponse&lt;/code&gt; is &lt;code&gt;ApiResponse.Failure.Error&lt;/code&gt; or &lt;code&gt;ApiResponse.Failure.Exception&lt;/code&gt;. You can access &lt;code&gt;message()&lt;/code&gt; in this scope.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Each scope runs depending on its dedicated &lt;code&gt;ApiResponse&lt;/code&gt; type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;disneyService.fetchDisneyPosterList().request { response -&amp;gt;&#xA;    response.onSuccess {&#xA;     // this scope will be executed if the request successful.&#xA;     // handle the success case&#xA;    }.onError {&#xA;      // this scope will be executed when the request failed with errors.&#xA;      // handle the error case&#xA;    }.onException {&#xA;     // this scope will be executed when the request failed with exceptions.&#xA;     // handle the exception case&#xA;    }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ApiResponse for Coroutines&lt;/h3&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;suspend&lt;/code&gt; keyword in your Retrofit services with &lt;code&gt;ApiResponse&amp;lt;*&amp;gt;&lt;/code&gt; as a response type. First, build your &lt;code&gt;Retrofit&lt;/code&gt; with the &lt;code&gt;ApiResponseCallAdapterFactory&lt;/code&gt; call adapter factory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;.addCallAdapterFactory(ApiResponseCallAdapterFactory.create())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, you should define the service interface with the suspend keyword and &lt;code&gt;ApiResponse&amp;lt;*&amp;gt;&lt;/code&gt; as a response type. So eventually you will get the &lt;code&gt;ApiResponse&lt;/code&gt; from the Retrofit service call like the examples below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;interface DisneyCoroutinesService {&#xA;&#xA;  @GET(&#34;DisneyPosters.json&#34;)&#xA;  suspend fun fetchDisneyPosterList(): ApiResponse&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, you can execute the defined service like the examples below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainCoroutinesViewModel constructor(disneyService: DisneyCoroutinesService) : ViewModel() {&#xA;&#xA;  val posterListLiveData: MutableLiveData&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;&#xA;&#xA;  init {&#xA;     val response = disneyService.fetchDisneyPosterList()&#xA;     response.onSuccess {&#xA;       // handles the success case when the API request gets a successful response.&#xA;       posterListLiveData.post(data)&#xA;      }.onError {&#xA;       // handles error cases when the API request gets an error response.&#xA;      }.onException {&#xA;       // handles exceptional cases when the API request gets an exception response.&#xA;      }&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: If you&#39;re interested in injecting your own coroutine scope and unit testing with a test coroutine scope, check out the &lt;a href=&#34;https://github.com/skydoves/sandwich#injecting-a-custom-coroutinescope-and-unit-tests&#34;&gt;Injecting a custom CoroutineScope and Unit Tests&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;ApiResponse Extensions for Coroutines&lt;/h3&gt; &#xA;&lt;p&gt;You can handle the &lt;code&gt;ApiResponse&lt;/code&gt; with coroutines extensions below, which allows you can launch your suspend functions on the scopes.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;suspendOnSuccess&lt;/strong&gt;: Executes if the &lt;code&gt;ApiResponse&lt;/code&gt; is &lt;code&gt;ApiResponse.Success&lt;/code&gt;. You can access body data directly in this scope.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;suspendOnError&lt;/strong&gt;: Executes if the &lt;code&gt;ApiResponse&lt;/code&gt; is &lt;code&gt;ApiResponse.Failure.Error&lt;/code&gt;. You can access &lt;code&gt;message()&lt;/code&gt; and &lt;code&gt;errorBody&lt;/code&gt; in this scope.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;suspendOnException&lt;/strong&gt;: Executes if the &lt;code&gt;ApiResponse&lt;/code&gt; is &lt;code&gt;ApiResponse.Failure.Exception&lt;/code&gt;. You can access &lt;code&gt;message()&lt;/code&gt; in this scope.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;suspendOnFailure&lt;/strong&gt;: Executes if the &lt;code&gt;ApiResponse&lt;/code&gt; is &lt;code&gt;ApiResponse.Failure.Error&lt;/code&gt; or &lt;code&gt;ApiResponse.Failure.Exception&lt;/code&gt;. You can access &lt;code&gt;message()&lt;/code&gt; in this scope.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Each scope runs depending on the its dedicated &lt;code&gt;ApiResponse&lt;/code&gt; type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;flow {&#xA;  val response = disneyService.fetchDisneyPosterList()&#xA;  response.suspendOnSuccess {&#xA;    posterDao.insertPosterList(data) // insertPosterList(data) is a suspend function.&#xA;    emit(data)&#xA;  }.suspendOnError {&#xA;    // handles error cases&#xA;  }.suspendOnException {&#xA;    // handles exceptional cases&#xA;  }&#xA;}.flowOn(Dispatchers.IO)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Retrieve success data&lt;/h3&gt; &#xA;&lt;p&gt;If you want to retrieve the encapsulated body data from the &lt;code&gt;ApiResponse&lt;/code&gt; directly, you can use the functionalities below.&lt;/p&gt; &#xA;&lt;h4&gt;getOrNull&lt;/h4&gt; &#xA;&lt;p&gt;Returns the encapsulated data if this instance represents &lt;code&gt;ApiResponse.Success&lt;/code&gt; or returns null if this is failed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val data: List&amp;lt;Poster&amp;gt;? = disneyService.fetchDisneyPosterList().getOrNull()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;getOrElse&lt;/h4&gt; &#xA;&lt;p&gt;Returns the encapsulated data if this instance represents &lt;code&gt;ApiResponse.Success&lt;/code&gt; or returns a default value if this is failed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val data: List&amp;lt;Poster&amp;gt;? = disneyService.fetchDisneyPosterList().getOrElse(emptyList())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;getOrThrow&lt;/h4&gt; &#xA;&lt;p&gt;Returns the encapsulated data if this instance represents &lt;code&gt;ApiResponse.Success&lt;/code&gt; or throws the encapsulated &lt;code&gt;Throwable&lt;/code&gt; exception if this is failed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;try {&#xA;  val data: List&amp;lt;Poster&amp;gt;? = disneyService.fetchDisneyPosterList().getOrThrow()&#xA;} catch (e: Exception) {&#xA;  e.printStackTrace()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mapper&lt;/h3&gt; &#xA;&lt;p&gt;Mapper is useful when you want to transform the &lt;code&gt;ApiResponse.Success&lt;/code&gt; or &lt;code&gt;ApiResponse.Failure.Error&lt;/code&gt; to your custom model in &lt;code&gt;ApiResponse&lt;/code&gt; extension scopes.&lt;/p&gt; &#xA;&lt;h4&gt;ApiSuccessModelMapper&lt;/h4&gt; &#xA;&lt;p&gt;You can map the &lt;code&gt;ApiResponse.Success&lt;/code&gt; model to your custom model with the &lt;code&gt;SuccessPosterMapper&amp;lt;T, R&amp;gt;&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; extension like the examples below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;object SuccessPosterMapper : ApiSuccessModelMapper&amp;lt;List&amp;lt;Poster&amp;gt;, Poster?&amp;gt; {&#xA;&#xA;  override fun map(apiErrorResponse: ApiResponse.Success&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;): Poster? {&#xA;    return apiErrorResponse.data.first()&#xA;  }&#xA;}&#xA;&#xA;// Maps the success response data.&#xA;val poster: Poster? = map(SuccessPosterMapper)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;map&lt;/code&gt; extension with a lambda like the examples below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Maps the success response data using a lambda.&#xA;map(SuccessPosterMapper) { poster -&amp;gt;&#xA;  emit(poster) // you can use the `this` keyword instead of the poster.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to receive transformed body data in the scope, you can use the mapper as a parameter with the &lt;code&gt;onSuccess&lt;/code&gt; or &lt;code&gt;suspendOnSuccess&lt;/code&gt; extensions like the examples below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;.suspendOnSuccess(SuccessPosterMapper) {&#xA;    val poster = this&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ApiErrorModelMapper&lt;/h4&gt; &#xA;&lt;p&gt;You can map the &lt;code&gt;ApiResponse.Failure.Error&lt;/code&gt; model to your custom error model using the &lt;code&gt;ApiErrorModelMapper&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; extension as the examples bleow:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Create your custom error model.&#xA;data class ErrorEnvelope(&#xA;  val code: Int,&#xA;  val message: String&#xA;)&#xA;&#xA;// An error response mapper.&#xA;// Create an instance of your custom model using the `ApiResponse.Failure.Error` in the `map`.&#xA;object ErrorEnvelopeMapper : ApiErrorModelMapper&amp;lt;ErrorEnvelope&amp;gt; {&#xA;&#xA;  override fun map(apiErrorResponse: ApiResponse.Failure.Error&amp;lt;*&amp;gt;): ErrorEnvelope {&#xA;    return ErrorEnvelope(apiErrorResponse.statusCode.code, apiErrorResponse.message())&#xA;  }&#xA;}&#xA;&#xA;// Maps an error response.&#xA;response.onError {&#xA;  // Maps an ApiResponse.Failure.Error to a custom error model using the mapper.&#xA;  map(ErrorEnvelopeMapper) {&#xA;     val code = this.code&#xA;     val message = this.message&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to receive transformed data from in the scope, you can use the mapper as a parameter with the &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;suspendOnError&lt;/code&gt; extensions as the examples below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;.suspendOnError(ErrorEnvelopeMapper) {&#xA;    val message = this.message&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run and Retry&lt;/h3&gt; &#xA;&lt;p&gt;You can run and retry network requests by using &lt;code&gt;RetryPolicy&lt;/code&gt; interface and &lt;code&gt;runAndRetry&lt;/code&gt; extension like the code below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val retryPolicy = object : RetryPolicy {&#xA;  override fun shouldRetry(attempt: Int, message: String?): Boolean = attempt &amp;lt;= 3&#xA;&#xA;  override fun retryTimeout(attempt: Int, message: String?): Int = 3000&#xA;}&#xA;&#xA;val apiResponse = runAndRetry(retryPolicy) { attempt, reason -&amp;gt;&#xA;  mainRepository.fetchPosters()&#xA;}.onSuccess {&#xA;  // handle a success case&#xA;}.onFailure {&#xA;  // handle failure cases&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Operator&lt;/h3&gt; &#xA;&lt;p&gt;You can delegate the &lt;code&gt;onSuccess&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onException&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; extension and &lt;code&gt;ApiResponseOperator&lt;/code&gt;. &lt;strong&gt;Operator&lt;/strong&gt; is very useful if you want to handle &lt;code&gt;ApiResponse&lt;/code&gt;-s globally and reduce the boilerplates for your &lt;code&gt;ViewModel&lt;/code&gt; and &lt;code&gt;Repository&lt;/code&gt; classes. Here are some examples below:&lt;/p&gt; &#xA;&lt;h4&gt;ViewModel&lt;/h4&gt; &#xA;&lt;p&gt;We can delegate and operate the &lt;code&gt;CommonResponseOperator&lt;/code&gt; using the &lt;code&gt;operate&lt;/code&gt; extension.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;disneyService.fetchDisneyPosterList().operator(&#xA;      CommonResponseOperator(&#xA;        success = {&#xA;          emit(data)&#xA;          Timber.d(&#34;success data: $data&#34;)&#xA;        },&#xA;        application = getApplication()&#xA;      )&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;CommonResponseOperator&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;CommonResponseOperator&lt;/code&gt; extends &lt;code&gt;ApiResponseOperator&lt;/code&gt; with the &lt;code&gt;onSuccess&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onException&lt;/code&gt; override methods. They will be executed depending on the &lt;code&gt;ApiResponse&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/** A common response operator for handling [ApiResponse]s regardless of its type. */&#xA;class CommonResponseOperator&amp;lt;T&amp;gt; constructor(&#xA;  private val success: suspend (ApiResponse.Success&amp;lt;T&amp;gt;) -&amp;gt; Unit,&#xA;  private val application: Application&#xA;) : ApiResponseOperator&amp;lt;T&amp;gt;() {&#xA;&#xA;  // handles error cases when the API request gets an error response.&#xA;  override fun onSuccess(apiResponse: ApiResponse.Success&amp;lt;T&amp;gt;) = success(apiResponse)&#xA;&#xA;  // handles error cases depending on the status code.&#xA;  // e.g., internal server error.&#xA;  override fun onError(apiResponse: ApiResponse.Failure.Error&amp;lt;T&amp;gt;) {&#xA;    apiResponse.run {&#xA;      Timber.d(message())&#xA;      &#xA;      // map the ApiResponse.Failure.Error to a customized error model using the mapper.&#xA;      map(ErrorEnvelopeMapper) {&#xA;        Timber.d(&#34;[Code: $code]: $message&#34;)&#xA;      }&#xA;    }&#xA;  }&#xA;&#xA;  // handles exceptional cases when the API request gets an exception response.&#xA;  // e.g., network connection error, timeout.&#xA;  override fun onException(apiResponse: ApiResponse.Failure.Exception&amp;lt;T&amp;gt;) {&#xA;    apiResponse.run {&#xA;      Timber.d(message())&#xA;      toast(message())&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Operator for coroutines&lt;/h3&gt; &#xA;&lt;p&gt;If you want to operate and delegate a suspension lambda to the operator, you can use the &lt;code&gt;suspendOperator&lt;/code&gt; extension and &lt;code&gt;ApiResponseSuspendOperator&lt;/code&gt; class as the examples below:&lt;/p&gt; &#xA;&lt;h4&gt;ViewModel&lt;/h4&gt; &#xA;&lt;p&gt;You can use suspension functions like &lt;code&gt;emit&lt;/code&gt; in the &lt;code&gt;success&lt;/code&gt; scope.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;flow {&#xA;  disneyService.fetchDisneyPosterList().suspendOperator(&#xA;      CommonResponseOperator(&#xA;        success = {&#xA;          emit(data)&#xA;          Timber.d(&#34;success data: $data&#34;)&#xA;        },&#xA;        application = getApplication()&#xA;      )&#xA;    )&#xA;}.flowOn(Dispatchers.IO)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;CommonResponseOperator&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;CommonResponseOperator&lt;/code&gt; extends &lt;code&gt;ApiResponseSuspendOperator&lt;/code&gt; with suspend override methods as the examples below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class CommonResponseOperator&amp;lt;T&amp;gt; constructor(&#xA;  private val success: suspend (ApiResponse.Success&amp;lt;T&amp;gt;) -&amp;gt; Unit,&#xA;  private val application: Application&#xA;) : ApiResponseSuspendOperator&amp;lt;T&amp;gt;() {&#xA;&#xA;  // handles the success case when the API request gets a successful response.&#xA;  override suspend fun onSuccess(apiResponse: ApiResponse.Success&amp;lt;T&amp;gt;) = success(apiResponse)&#xA;&#xA;  // ... //&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Global operator&lt;/h3&gt; &#xA;&lt;p&gt;You can operate an operator globally whole &lt;code&gt;ApiResponse&lt;/code&gt;-s in your application with the &lt;code&gt;SandwichInitializer&lt;/code&gt;. So you don&#39;t need to create every instance of the &lt;strong&gt;Operator&lt;/strong&gt;s or use dependency injection for handling common operations. Here are some examples of handling a global operator for the &lt;code&gt;ApiResponse.Failure.Error&lt;/code&gt; and &lt;code&gt;ApiResponse.Failure.Exception&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Application class&lt;/h4&gt; &#xA;&lt;p&gt;First, you should initialize the global operator to the &lt;code&gt;SandwichInitializer.sandwichOperator&lt;/code&gt;. It&#39;s highly recommended to initialize this in the Application class.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class SandwichDemoApp : Application() {&#xA;&#xA;  override fun onCreate() {&#xA;    super.onCreate()&#xA;    &#xA;    // We will handle only the error and exceptional cases,&#xA;    // so we don&#39;t need to mind the generic type of the operator.&#xA;    SandwichInitializer.sandwichOperators += GlobalResponseOperator&amp;lt;Any&amp;gt;(this)&#xA;&#xA;    // ... //&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;GlobalResponseOperator&lt;/h4&gt; &#xA;&lt;p&gt;Next, create your own &lt;code&gt;GlobalResponseOperator&lt;/code&gt;, which extends operators such as &lt;code&gt;ApiResponseSuspendOperator&lt;/code&gt; and &lt;code&gt;ApiResponseOperator&lt;/code&gt; as the examples below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class GlobalResponseOperator&amp;lt;T&amp;gt; constructor(&#xA;  private val application: Application&#xA;) : ApiResponseSuspendOperator&amp;lt;T&amp;gt;() {&#xA;&#xA;  // The body is empty, because we will handle the success case manually.&#xA;  override suspend fun onSuccess(apiResponse: ApiResponse.Success&amp;lt;T&amp;gt;) { }&#xA;&#xA;  // handles error cases when the API request gets an error response.&#xA;  // e.g., internal server error.&#xA;  override suspend fun onError(apiResponse: ApiResponse.Failure.Error&amp;lt;T&amp;gt;) {&#xA;    withContext(Dispatchers.Main) {&#xA;      apiResponse.run {&#xA;        Timber.d(message())&#xA;&#xA;        // handling error based on status code.&#xA;        when (statusCode) {&#xA;          StatusCode.InternalServerError -&amp;gt; toast(&#34;InternalServerError&#34;)&#xA;          StatusCode.BadGateway -&amp;gt; toast(&#34;BadGateway&#34;)&#xA;          else -&amp;gt; toast(&#34;$statusCode(${statusCode.code}): ${message()}&#34;)&#xA;        }&#xA;&#xA;        // map the ApiResponse.Failure.Error to a customized error model using the mapper.&#xA;        map(ErrorEnvelopeMapper) {&#xA;          Timber.d(&#34;[Code: $code]: $message&#34;)&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;&#xA;  // handles exceptional cases when the API request gets an exception response.&#xA;  // e.g., network connection error, timeout.&#xA;  override suspend fun onException(apiResponse: ApiResponse.Failure.Exception&amp;lt;T&amp;gt;) {&#xA;    withContext(Dispatchers.Main) {&#xA;      apiResponse.run {&#xA;        Timber.d(message())&#xA;        toast(message())&#xA;      }&#xA;    }&#xA;  }&#xA;&#xA;  private fun toast(message: String) {&#xA;    Toast.makeText(application, message, Toast.LENGTH_SHORT).show()&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ViewModel&lt;/h4&gt; &#xA;&lt;p&gt;Finally, you don&#39;t need to use the &lt;code&gt;operator&lt;/code&gt; expression anymore. The global operator will be operated, so you should handle only the &lt;code&gt;ApiResponse.Success&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: This example didn&#39;t implement for the &lt;code&gt;onSuccess&lt;/code&gt; case.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;flow {&#xA;  disneyService.fetchDisneyPosterList().&#xA;    suspendOnSuccess {&#xA;      emit(data)&#xA;    }&#xA;}.flowOn(Dispatchers.IO).asLiveData()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Merge&lt;/h3&gt; &#xA;&lt;p&gt;You can merge multiple &lt;code&gt;ApiResponse&lt;/code&gt;s as a single &lt;code&gt;ApiResponse&lt;/code&gt; depending on policies. The example below shows how to merge three &lt;code&gt;ApiResponse&lt;/code&gt; as a single one if each three &lt;code&gt;ApiResponse&lt;/code&gt;s are successful.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;disneyService.fetchDisneyPosterList(page = 0).merge(&#xA;   disneyService.fetchDisneyPosterList(page = 1),&#xA;   disneyService.fetchDisneyPosterList(page = 2),&#xA;   mergePolicy = ApiResponseMergePolicy.PREFERRED_FAILURE&#xA;).onSuccess { &#xA;  // handles the success case when the API request gets a successful response.&#xA;}.onError { &#xA;  // handles error cases when the API request gets an error response.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ApiResponseMergePolicy&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;ApiResponseMergePolicy&lt;/code&gt; is a policy for merging response data depend on the success or not.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;IGNORE_FAILURE&lt;/strong&gt;: Regardless of the merging sequences, ignores failure responses in the responses.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;PREFERRED_FAILURE&lt;/strong&gt; (default): Regardless of the merging sequences, prefers failure responses in the responses.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;toFlow&lt;/h3&gt; &#xA;&lt;p&gt;You can get a &lt;code&gt;Flow&lt;/code&gt; that emits body data if the response is an &lt;code&gt;ApiResponse.Success&lt;/code&gt; and the data is not null.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;disneyService.fetchDisneyPosterList()&#xA;  .onError {&#xA;    // handles error cases when the API request gets an error response.&#xA;  }.onException {&#xA;    // handles exceptional cases when the API request gets an exception response.&#xA;  }.toFlow() // returns a coroutines flow&#xA;  .flowOn(Dispatchers.IO)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to transform the original data and take a &lt;code&gt;flow&lt;/code&gt; that contains transformed data, you can follow as the examples below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val response = pokedexClient.fetchPokemonList(page = page)&#xA;response.toFlow { pokemons -&amp;gt;&#xA;  pokemons.forEach { pokemon -&amp;gt; pokemon.page = page }&#xA;  pokemonDao.insertPokemonList(pokemons)&#xA;  pokemonDao.getAllPokemonList(page)&#xA;}.flowOn(Dispatchers.IO)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Injecting a custom CoroutineScope and Unit Tests&lt;/h3&gt; &#xA;&lt;p&gt;Sandwich uses an internal coroutine scope to execute network requests in the background thread, but can inject your custom &lt;code&gt;CoroutineScope&lt;/code&gt; by setting your scope on your &lt;code&gt;ApiResponseCallAdapterFactory&lt;/code&gt; like the below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;.addCallAdapterFactory(ApiResponseCallAdapterFactory.create(&#xA;  coroutineScope = `Your Coroutine Scope`&#xA;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can apply your coroutine scope globally for the &lt;code&gt;ApiResponseCallAdapterFactory&lt;/code&gt; by setting your scope on &lt;code&gt;SandwichInitializer&lt;/code&gt; as the below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;SandwichInitializer.sandwichScope = `Your Coroutine Scope`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, you can inject a test coroutine scope into the &lt;code&gt;ApiResponseCallAdapterFactory&lt;/code&gt; in your unit test cases.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val testScope = TestScope(coroutinesRule.testDispatcher)&#xA;val retrofit = Retrofit.Builder()&#xA;      .baseUrl(mockWebServer.url(&#34;/&#34;))&#xA;      .addConverterFactory(MoshiConverterFactory.create())&#xA;      .addCallAdapterFactory(ApiResponseCallAdapterFactory.create(testScope))&#xA;      .build()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img align=&#34;right&#34; width=&#34;90px&#34; src=&#34;https://user-images.githubusercontent.com/24237865/178630165-76855349-ac04-4474-8bcf-8eb5f8c41095.png&#34;&gt; &#xA;&lt;h2&gt;Kotlin Serialization&lt;/h2&gt; &#xA;&lt;p&gt;This library allows you to deserialize your error body of the Retrofit response as your custom error class with &lt;a href=&#34;https://kotlinlang.org/docs/serialization.html&#34;&gt;Kotlin&#39;s Serialization&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;For more information about setting up the plugin and dependency, check out &lt;a href=&#34;https://kotlinlang.org/docs/serialization.html&#34;&gt;Kotlin&#39;s Serialization&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://search.maven.org/search?q=g:%22com.github.skydoves%22%20AND%20a:%22sandwich%22&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.github.skydoves/sandwich.svg?label=Maven%20Central&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Add the dependency below to your &lt;strong&gt;module&lt;/strong&gt;&#39;s &lt;code&gt;build.gradle&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {&#xA;    implementation &#34;com.github.skydoves:sandwich-serialization:&amp;lt;version&amp;gt;&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Deserialize Error Body&lt;/h3&gt; &#xA;&lt;p&gt;You can deserialize your error body with &lt;code&gt;deserializeErrorBody&lt;/code&gt; extension and your custom error class. First, define your custom error class following your RESTful API formats as seen in the below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Serializable&#xA;public data class ErrorMessage(&#xA;  val code: Int,&#xA;  val message: String&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, gets the result of the error class from the &lt;code&gt;ApiResponse&lt;/code&gt; instance with the &lt;code&gt;deserializeErrorBody&lt;/code&gt; extension like the below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val apiResponse = pokemonService.fetchPokemonList()&#xA;val errorModel: ErrorMessage? = apiResponse.deserializeErrorBody()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can get deserialized error response directly with &lt;code&gt;onErrorDeserialize&lt;/code&gt; extension like the below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val apiResponse = mainRepository.fetchPosters()&#xA;apiResponse.onErrorDeserialize&amp;lt;List&amp;lt;Poster&amp;gt;, ErrorMessage&amp;gt; { errorMessage -&amp;gt;&#xA;  ..&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sandwich DataSource&lt;/h2&gt; &#xA;&lt;p&gt;This library provides additional solutions &lt;code&gt;DataSource&lt;/code&gt; for handing network responses.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://search.maven.org/search?q=g:%22com.github.skydoves%22%20AND%20a:%22sandwich%22&#34;&gt;&lt;img src=&#34;https://img.shields.io/maven-central/v/com.github.skydoves/sandwich.svg?label=Maven%20Central&#34; alt=&#34;Maven Central&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Add the dependency below to your &lt;strong&gt;module&lt;/strong&gt;&#39;s &lt;code&gt;build.gradle&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {&#xA;    implementation &#34;com.github.skydoves:sandwich-datasource:&amp;lt;version&amp;gt;&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ResponseDataSource&lt;/h3&gt; &#xA;&lt;p&gt;ResponseDataSource is an implementation of the &lt;code&gt;DataSource&lt;/code&gt; interface. &lt;br&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Asynchronously send requests.&lt;/li&gt; &#xA; &lt;li&gt;A temporarily response data holder from the REST API call for caching data on memory.&lt;/li&gt; &#xA; &lt;li&gt;Observable for every response.&lt;/li&gt; &#xA; &lt;li&gt;Retry fetching data when the request gets failure.&lt;/li&gt; &#xA; &lt;li&gt;Concat another &lt;code&gt;DataSource&lt;/code&gt; and request sequentially.&lt;/li&gt; &#xA; &lt;li&gt;Disposable of executing works.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Combine&lt;/h4&gt; &#xA;&lt;p&gt;Combine a &lt;code&gt;Call&lt;/code&gt; and lambda scope for constructing the DataSource.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val disneyService = retrofit.create(DisneyService::class.java)&#xA;&#xA;val dataSource = ResponseDataSource&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;()&#xA;dataSource.combine(disneyService.fetchDisneyPosterList()) { response -&amp;gt;&#xA;    // stubs&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Request&lt;/h4&gt; &#xA;&lt;p&gt;Request API network call asynchronously. &lt;br&gt; If the request is successful, this data source will hold the success response model.&lt;br&gt; In the next request after the success, request() returns the cached API response. &lt;br&gt; If we need to fetch a new response data or refresh, we can use &lt;code&gt;invalidate()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;dataSource.request()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Retry&lt;/h4&gt; &#xA;&lt;p&gt;Retry fetching data (re-request) if your request got failure.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// retry fetching data 3 times with 5000 milli-seconds time interval when the request gets failure.&#xA;dataSource.retry(3, 5000L)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ObserveResponse&lt;/h4&gt; &#xA;&lt;p&gt;Observes every response data &lt;code&gt;ApiResponse&lt;/code&gt; from the API call request.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;dataSource.observeResponse {&#xA;   Timber.d(&#34;observeResponse: $it&#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;RetainPolicy&lt;/h4&gt; &#xA;&lt;p&gt;We can limit the policy for retaining data on the temporarily internal storage.&lt;br&gt; The default policy is no retaining any fetched data from the network, but we can set the policy using &lt;code&gt;dataRetainPolicy&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Retain fetched data on the memory storage temporarily.&#xA;// If request again, returns the retained data instead of re-fetching from the network.&#xA;dataSource.dataRetainPolicy(DataRetainPolicy.RETAIN)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Invalidate&lt;/h4&gt; &#xA;&lt;p&gt;Invalidate a cached (holding) data and re-fetching the API request.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;dataSource.invalidate()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Concat&lt;/h4&gt; &#xA;&lt;p&gt;Concat an another &lt;code&gt;DataSource&lt;/code&gt; and request API call sequentially if the API call getting successful.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val dataSource2 = ResponseDataSource&amp;lt;List&amp;lt;PosterDetails&amp;gt;&amp;gt;()&#xA;dataSource2.retry(3, 5000L).combine(disneyService.fetchDetails()) {&#xA;    // stubs handling dataSource2 response&#xA;}&#xA;&#xA;dataSource1&#xA;   .request() // request() must be called before concat. &#xA;   .concat(dataSource2) // request dataSource2&#39;s API call after the success of the dataSource1.&#xA;   .concat(dataSource3) // request dataSource3&#39;s API call after the success of the dataSource2.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;asLiveData&lt;/h4&gt; &#xA;&lt;p&gt;we can observe fetched data via &lt;code&gt;DataSource&lt;/code&gt; as a &lt;code&gt;LiveData&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val posterListLiveData: LiveData&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;&#xA;&#xA;init {&#xA;    posterListLiveData = disneyService.fetchDisneyPosterList().toResponseDataSource()&#xA;      .retry(3, 5000L)&#xA;      .dataRetainPolicy(DataRetainPolicy.RETAIN)&#xA;      .request {&#xA;        // ... //&#xA;      }.asLiveData()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Disposable&lt;/h4&gt; &#xA;&lt;p&gt;We can make it joins onto &lt;code&gt;CompositeDisposable&lt;/code&gt; as a disposable using the &lt;code&gt;joinDisposable&lt;/code&gt; function. It must be called before &lt;code&gt;request()&lt;/code&gt; method. The below example is using in ViewModel. We can clear the &lt;code&gt;CompositeDisposable&lt;/code&gt; in the &lt;code&gt;onCleared()&lt;/code&gt; override method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;private val disposable = CompositeDisposable()&#xA;&#xA;init {&#xA;    disneyService.fetchDisneyPosterList().toResponseDataSource()&#xA;      // retry fetching data 3 times with 5000L interval when the request gets failure.&#xA;      .retry(3, 5000L)&#xA;      // joins onto CompositeDisposable as a disposable and dispose onCleared().&#xA;      .joinDisposable(disposable)&#xA;      .request {&#xA;        // ... //&#xA;      }&#xA;}&#xA;&#xA;override fun onCleared() {&#xA;    super.onCleared()&#xA;    if (!disposable.disposed) {&#xA;      disposable.clear()&#xA;    }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is the example of the &lt;code&gt;ResponseDataSource&lt;/code&gt; in the &lt;code&gt;MainViewModel&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel constructor(&#xA;  private val disneyService: DisneyService&#xA;) : ViewModel() {&#xA;&#xA;  // request API call Asynchronously and holding successful response data.&#xA;  private val dataSource = ResponseDataSource&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;()&#xA;&#xA;  val posterListLiveData = MutableLiveData&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;()&#xA;  val toastLiveData = MutableLiveData&amp;lt;String&amp;gt;()&#xA;  private val disposable = CompositeDisposable()&#xA;&#xA;  /** fetch poster list data from the network. */&#xA;  fun fetchDisneyPosters() {&#xA;    dataSource&#xA;      // retry fetching data 3 times with 5000 time interval when the request gets failure.&#xA;      .retry(3, 5000L)&#xA;      // joins onto CompositeDisposable as a disposable and dispose onCleared().&#xA;      .joinDisposable(disposable)&#xA;      // combine network service to the data source.&#xA;      .combine(disneyService.fetchDisneyPosterList()) { response -&amp;gt;&#xA;        // handles the success case when the API request gets a successful response.&#xA;        response.onSuccess {&#xA;          Timber.d(&#34;$data&#34;)&#xA;          posterListLiveData.postValue(data)&#xA;        }&#xA;          // handles error cases when the API request gets an error response.&#xA;          // e.g. internal server error.&#xA;          .onError {&#xA;            Timber.d(message())&#xA;&#xA;            // handling error based on status code.&#xA;            when (statusCode) {&#xA;              StatusCode.InternalServerError -&amp;gt; toastLiveData.postValue(&#34;InternalServerError&#34;)&#xA;              StatusCode.BadGateway -&amp;gt; toastLiveData.postValue(&#34;BadGateway&#34;)&#xA;              else -&amp;gt; toastLiveData.postValue(&#34;$statusCode(${statusCode.code}): ${message()}&#34;)&#xA;            }&#xA;&#xA;            // map the ApiResponse.Failure.Error to a customized error model using the mapper.&#xA;            map(ErrorEnvelopeMapper) {&#xA;              Timber.d(this.toString())&#xA;            }&#xA;          }&#xA;          // handles exceptional cases when the API request gets an exception response.&#xA;          // e.g. network connection error, timeout.&#xA;          .onException {&#xA;            Timber.d(message())&#xA;            toastLiveData.postValue(message())&#xA;          }&#xA;      }&#xA;      // observe every API request responses.&#xA;      .observeResponse {&#xA;        Timber.d(&#34;observeResponse: $it&#34;)&#xA;      }&#xA;      // request API network call asynchronously.&#xA;      // if the request is successful, the data source will hold the success data.&#xA;      // in the next request after success, returns the cached API response.&#xA;      // if you want to fetch a new response data, use invalidate().&#xA;      .request()&#xA;  }&#xA;&#xA;  override fun onCleared() {&#xA;    super.onCleared()&#xA;    if (!disposable.disposed) {&#xA;      disposable.clear()&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;DataSourceCallAdapterFactory&lt;/h3&gt; &#xA;&lt;p&gt;You can get the &lt;code&gt;DataSource&lt;/code&gt; directly from the Retrofit service. Add the &lt;code&gt;DataSourceCallAdapterFactory&lt;/code&gt; call adapter factory to your Retrofit builder. And change the return type of your Retrfot services &lt;code&gt;Call&lt;/code&gt; to &lt;code&gt;DataSource&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Retrofit.Builder()&#xA;    ...&#xA;    .addCallAdapterFactory(DataSourceCallAdapterFactory.create())&#xA;    .build()&#xA;&#xA;interface DisneyService {&#xA;  @GET(&#34;DisneyPosters.json&#34;)&#xA;  fun fetchDisneyPosterList(): DataSource&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here is an example of the &lt;code&gt;DataSource&lt;/code&gt; in the MainViewModel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainViewModel constructor(disneyService: DisneyService) : ViewModel() {&#xA;&#xA;  // request API call Asynchronously and holding successful response data.&#xA;  private val dataSource: DataSource&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;&#xA;&#xA;    init {&#xA;    Timber.d(&#34;initialized MainViewModel.&#34;)&#xA;&#xA;    dataSource = disneyService.fetchDisneyPosterList()&#xA;      // retry fetching data 3 times with 5000L interval when the request gets failure.&#xA;      .retry(3, 5000L)&#xA;      .observeResponse(object : ResponseObserver&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt; {&#xA;        override fun observe(response: ApiResponse&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;) {&#xA;          // handle the case when the API request gets a success response.&#xA;          response.onSuccess {&#xA;            Timber.d(&#34;$data&#34;)&#xA;            posterListLiveData.postValue(data)&#xA;          }&#xA;        }&#xA;      })&#xA;      .request() // must call request()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;DataSource with Coroutines&lt;/h3&gt; &#xA;&lt;p&gt;You can use the &lt;code&gt;DataSource&lt;/code&gt; in Retrofit services with &lt;code&gt;suspend&lt;/code&gt; keyword. &lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;Retrofit.Builder()&#xA;    ...&#xA;    .addCallAdapterFactory(DataSourceCallAdapterFactory.create())&#xA;    .build()&#xA;&#xA;interface DisneyService {&#xA;  @GET(&#34;DisneyPosters.json&#34;)&#xA;  suspend fun fetchDisneyPosterList(): DataSource&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is an exmaple of the &lt;code&gt;DataSource&lt;/code&gt; in the MainViewModel:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class MainCoroutinesViewModel constructor(disneyService: DisneyCoroutinesService) : ViewModel() {&#xA;&#xA;  val posterListLiveData: LiveData&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;&#xA;&#xA;  init {&#xA;    Timber.d(&#34;initialized MainViewModel.&#34;)&#xA;&#xA;    posterListLiveData = liveData(viewModelScope.coroutineContext + Dispatchers.IO) {&#xA;      emitSource(disneyService.fetchDisneyPosterList().toResponseDataSource()&#xA;        // retry fetching data 3 times with 5000L interval when the request gets failure.&#xA;        .retry(3, 5000L)&#xA;        // a retain policy for retaining data on the internal storage&#xA;        .dataRetainPolicy(DataRetainPolicy.RETAIN)&#xA;        // request API network call asynchronously.&#xA;        .request {&#xA;          // handle the case when the API request gets a success response.&#xA;          onSuccess {&#xA;            Timber.d(&#34;$data&#34;)&#xA;          }.onError { // handle the case when the API request gets a error response.&#xA;              Timber.d(message())&#xA;            }.onException {  // handle the case when the API request gets a exception response.&#xA;              Timber.d(message())&#xA;            }&#xA;        }.asLiveData())&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;toResponseDataSource&lt;/h4&gt; &#xA;&lt;p&gt;We can change &lt;code&gt;DataSource&lt;/code&gt; to &lt;code&gt;ResponseDataSource&lt;/code&gt; after getting instance from network call using the below method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;private val dataSource: ResponseDataSource&amp;lt;List&amp;lt;Poster&amp;gt;&amp;gt;&#xA;&#xA;  init {&#xA;    dataSource = disneyService.fetchDisneyPosterList().toResponseDataSource()&#xA;&#xA;    //...&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Find this library useful? &lt;span&gt;‚ù§Ô∏è&lt;/span&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Support it by joining &lt;strong&gt;&lt;a href=&#34;https://github.com/skydoves/sandwich/stargazers&#34;&gt;stargazers&lt;/a&gt;&lt;/strong&gt; for this repository. &lt;span&gt;‚≠ê&lt;/span&gt; &lt;br&gt; And &lt;strong&gt;&lt;a href=&#34;https://github.com/skydoves&#34;&gt;follow&lt;/a&gt;&lt;/strong&gt; me for my next creations! ü§©&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;Copyright 2020 skydoves (Jaewoong Eum)&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;   http://www.apache.org/licenses/LICENSE-2.0&#xA;&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>