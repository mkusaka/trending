<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-25T01:41:35Z</updated>
  <subtitle>Weekly Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>DroidKaigi/conference-app-2024</title>
    <updated>2024-08-25T01:41:35Z</updated>
    <id>tag:github.com,2024-08-25:/DroidKaigi/conference-app-2024</id>
    <link href="https://github.com/DroidKaigi/conference-app-2024" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Official Conference App for DroidKaigi 2024&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/11e73360-7a23-4e95-a549-da612aa20d7d&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;DroidKaigi 2024 official app&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://2024.droidkaigi.jp/&#34;&gt;DroidKaigi&lt;/a&gt; is celebrating 10th year this time! This is a conference tailored for Android developers for enhancing sharing knowledge and communication. It&#39;s scheduled to take place for 3 days, on 11-13 September 2024.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;In addition to the standard features of a conference app, the DroidKaigi 2024 official app offers the following functionalities:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Timetable&lt;/strong&gt;: View the conference schedule and bookmark sessions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Profile cards&lt;/strong&gt;: Create and share your profile card with other attendees.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Contributors&lt;/strong&gt;: Discover the contributors behind the app. ...and more!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/d1aeccc1-1e8e-475f-9c51-72fb595c6563&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Try the app&lt;/h2&gt; &#xA;&lt;p&gt;You can try the app on your device by clicking the button below. &lt;a href=&#34;https://dply.me/wfhpc2#install&#34;&gt;&lt;img src=&#34;https://dply.me/wfhpc2/button/large&#34; alt=&#34;Try it on your device via DeployGate&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We always welcome contributions!&lt;/p&gt; &#xA;&lt;p&gt;For a detailed step-by-step guide on how to contribute, please see &lt;a href=&#34;https://raw.githubusercontent.com/DroidKaigi/conference-app-2024/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;. This guide will walk you through the process from setting up your environment to submitting your pull request.&lt;/p&gt; &#xA;&lt;p&gt;For Japanese speakers, a Japanese version of the contribution guide is available at &lt;a href=&#34;https://raw.githubusercontent.com/DroidKaigi/conference-app-2024/main/CONTRIBUTING.ja.md&#34;&gt;CONTRIBUTING.ja.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;コントリビューションの詳細な手順については、&lt;a href=&#34;https://raw.githubusercontent.com/DroidKaigi/conference-app-2024/main/CONTRIBUTING.ja.md&#34;&gt;CONTRIBUTING.ja.md&lt;/a&gt;をご覧ください。初めての方でも分かりやすいステップバイステップのガイドを用意しています。&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;Stable Android Studio Koala or higher. You can download it from &lt;a href=&#34;https://developer.android.com/studio&#34;&gt;this page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Design&lt;/h2&gt; &#xA;&lt;p&gt;You can check out the design on Figma.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.figma.com/design/XUk8WMbKCeIdWD5cz9P9JC/DroidKaigi-2024-App-UI?node-id=54795-26746&amp;amp;t=DgZuFVd0sduq6vUy-0&#34;&gt;DroidKaigi 2024 App UI&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Designer&lt;/strong&gt;: &lt;a href=&#34;https://github.com/nobonobopurin&#34;&gt;nobonobopurin&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;h3&gt;Overview of the architecture&lt;/h3&gt; &#xA;&lt;p&gt;In addition to general Android practices, we are exploring and implementing various concepts. Details for each are discussed further in this README.&lt;/p&gt; &#xA;&lt;img width=&#34;806&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/b4f5682d-839b-4ab9-9f43-bcfde9a8eefb&#34;&gt; &#xA;&lt;h3&gt;Understanding the App&#39;s Data Flow&lt;/h3&gt; &#xA;&lt;p&gt;To contribute to the app effectively, understanding its data flow is crucial for comprehending the app&#39;s code structure. Let&#39;s examine this further.&lt;/p&gt; &#xA;&lt;h4&gt;1. Displaying Sessions on the Timetable Screen&lt;/h4&gt; &#xA;&lt;p&gt;This section explains how the TimetableScreen is set up to display sessions, detailing the flow from the presenter to the UI state. We are categorizing UI Composable functions according to &lt;a href=&#34;https://github.com/DroidKaigi/conference-app-2023?tab=readme-ov-file#composable-function-categorization&#34;&gt;last year&#39;s categorization&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;              TimetableScreenUiState&#xA;timetableScreenPresenter ----&amp;gt; TimetableScreen&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;img width=&#34;711&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/2032e34b-933d-4964-92a8-831ea254cedd&#34;&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun TimetableScreen(&#xA;    ...&#xA;    eventFlow: EventFlow&amp;lt;TimetableScreenEvent&amp;gt; = rememberEventFlow&amp;lt;TimetableScreenEvent&amp;gt;(),&#xA;    uiState: TimetableScreenUiState = timetableScreenPresenter(&#xA;        events = eventFlow,&#xA;    ),&#xA;) {&#xA;    ...&#xA;    TimetableScreen(&#xA;        uiState = uiState,&#xA;        onBookmarkClick = { item, bookmarked -&amp;gt;&#xA;            eventFlow.tryEmit(TimetableScreenEvent.Bookmark(item, bookmarked))&#xA;        },&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;2. User Interaction with the Bookmark Button&lt;/h4&gt; &#xA;&lt;p&gt;Here, the interaction of bookmarking a session is detailed, showcasing how events trigger updates within the presenter.&lt;/p&gt; &#xA;&lt;img width=&#34;494&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/715c053a-1b06-4523-8016-44d16f1a34f2&#34;&gt; &#xA;&lt;pre&gt;&lt;code&gt;      TimetableScreenEvent.Bookmark&#xA;TimetableScreen ----&amp;gt; timetableScreenPresenter -&amp;gt; sessionsRepository&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun timetableScreenPresenter(&#xA;    events: EventFlow&amp;lt;TimetableScreenEvent&amp;gt;,&#xA;    sessionsRepository: SessionsRepository = localSessionsRepository(),&#xA;): TimetableScreenUiState = providePresenterDefaults { userMessageStateHolder -&amp;gt;&#xA;    ...&#xA;    EventEffect(Unit) { event -&amp;gt;&#xA;        when (event) {&#xA;            is Bookmark -&amp;gt; {&#xA;                sessionsRepository.toggleBookmark(event.timetableItem.id)&#xA;            }&#xA;            ...&#xA;        }&#xA;    }&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;3. Saving the bookmarked session&lt;/h4&gt; &#xA;&lt;p&gt;This part outlines how bookmark changes are persisted in the user&#39;s data store, demonstrating the repository&#39;s role in data handling.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;        TimetableItemId&#xA;SessionsRepository ----&amp;gt; userDataStore&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;    override suspend fun toggleBookmark(id: TimetableItemId) {&#xA;        userDataStore.toggleFavorite(id)&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;4. Recomposing the Repository&#39;s Timetable Upon Bookmarking&lt;/h4&gt; &#xA;&lt;p&gt;Focuses on how user actions (like bookmarking) cause the repository to update and recompose the timetable data.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;      favoriteSessions&#xA;userDataStore ----&amp;gt; Repository&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;public override fun timetable(): Timetable {&#xA;    val timetable by remember {&#xA;        ...&#xA;    }.safeCollectAsRetainedState(Timetable())&#xA;    val favoriteSessions by remember {&#xA;        userDataStore.getFavoriteSessionStream()&#xA;    }.safeCollectAsRetainedState(persistentSetOf())&#xA;&#xA;    return timetable.copy(bookmarks = favoriteSessions)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;safeCollectAsRetainedState()&lt;/code&gt; is a utility function that allows us to safely collect a Flow in a Composable function. It retains the state across recompositions and Compose navigation, ensuring that the data is not lost when the Composable function is recomposed. For more information about retained states, refer to the &lt;a href=&#34;https://github.com/takahirom/Rin&#34;&gt;Rin&lt;/a&gt; library.&lt;/p&gt; &#xA;&lt;h4&gt;5. Passing the Updated Timetable to the Presenter&lt;/h4&gt; &#xA;&lt;p&gt;Describes the flow of updated session data back to the screen presenter, highlighting how the UI state is refreshed.&lt;/p&gt; &#xA;&lt;img width=&#34;386&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/6b69304a-ee4f-4ed7-93ff-6c4256264f8a&#34;&gt; &#xA;&lt;pre&gt;&lt;code&gt;                 Timetable&#xA;SessionsRepository ----&amp;gt; timetableScreenPresenter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun timetableScreenPresenter(&#xA;    events: EventFlow&amp;lt;TimetableScreenEvent&amp;gt;,&#xA;    sessionsRepository: SessionsRepository = localSessionsRepository(),&#xA;): TimetableScreenUiState = providePresenterDefaults { userMessageStateHolder -&amp;gt;&#xA;    // Sessions are updated in the timetable() function&#xA;    val sessions by rememberUpdatedState(sessionsRepository.timetable())&#xA;    ...&#xA;    val timetableUiState by rememberUpdatedState(&#xA;        timetableSheet(&#xA;            sessionTimetable = sessions,&#xA;            uiType = timetableUiType,&#xA;        ),&#xA;    )&#xA;    ...&#xA;    EventEffect(events) { event -&amp;gt;&#xA;        ...&#xA;    }&#xA;    TimetableScreenUiState(&#xA;        contentUiState = timetableUiState,&#xA;        timetableUiType = timetableUiType,&#xA;        userMessageStateHolder = userMessageStateHolder&#xA;    )&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;6. Displaying the Updated Timetable on the Screen&lt;/h4&gt; &#xA;&lt;p&gt;This final step illustrates how the updated timetable is displayed on the screen, completing the cycle of user interaction and data update. &lt;img width=&#34;483&#34; alt=&#34;image&#34; src=&#34;https://github.com/DroidKaigi/conference-app-2024/assets/1386930/0f4e3371-5a2e-47c4-a065-f0ad676b766f&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;          TimetableScreenUiState&#xA;timetableScreenPresenter ----&amp;gt; TimetableScreen&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;fun TimetableScreen(&#xA;    ...,&#xA;    uiState: TimetableScreenUiState = timetableScreenPresenter(&#xA;        events = eventFlow,&#xA;    ),&#xA;) {&#xA;    ...&#xA;    TimetableScreen(&#xA;        uiState = uiState,&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to Check Composable Preview&lt;/h3&gt; &#xA;&lt;p&gt;Currently, Android Studio doesn&#39;t support Composable Preview in the commonMain sourceset. Therefore, we are using the Roborazzi IDE Plugin to check Composable Preview.&lt;/p&gt; &#xA;&lt;p&gt;When you open a Composable file, you can see the RoborazziPreview on the right side of the file.&lt;/p&gt; &#xA;&lt;img width=&#34;48&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/3d0308d2-f435-4553-968c-1dcba77f615f&#34;&gt; &#xA;&lt;p&gt;To capture a screenshot of the Composable Preview, run the Roborazzi Gradle task in the RoborazziPreview.&lt;/p&gt; &#xA;&lt;img width=&#34;319&#34; alt=&#34;image&#34; src=&#34;https://github.com/user-attachments/assets/52d2d386-188c-4d26-8c33-d8f4f769927e&#34;&gt; &#xA;&lt;p&gt;After running the task, you should see the screenshot in the RoborazziPreview.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/8b38eb69-b737-4c2f-8e86-e3e5805d82e5&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Understanding the App&#39;s Testing&lt;/h3&gt; &#xA;&lt;p&gt;The DroidKaigi 2024 official app utilizes a comprehensive testing strategy that combines:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Behavior Driven Development (BDD)&lt;/strong&gt;: For clear, readable test scenarios&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Robolectric&lt;/strong&gt;: For fast, JVM-based Android tests&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Roborazzi&lt;/strong&gt;: For visual regression testing and providing debugging hints through screenshots&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Robot Pattern&lt;/strong&gt;: For maintainable UI test code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This integrated approach enhances app stability, ensures UI correctness, and streamlines the testing process.&lt;/p&gt; &#xA;&lt;h4&gt;Key Components&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Robolectric&lt;/strong&gt;: A framework that executes Android tests directly on the JVM, allowing tests to run without requiring a physical device or emulator. This approach significantly speeds up test execution and allows for easier integration with continuous integration systems.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@RunWith(ParameterizedRobolectricTestRunner::class)&#xA;@HiltAndroidTest&#xA;class TimetableScreenTest(private val testCase: DescribedBehavior&amp;lt;TimetableScreenRobot&amp;gt;) {&#xA;&#xA;    @get:Rule&#xA;    @BindValue val robotTestRule: RobotTestRule = RobotTestRule(this)&#xA;&#xA;    @Inject&#xA;    lateinit var timetableScreenRobot: TimetableScreenRobot&#xA;&#xA;    @Test&#xA;    fun runTest() {&#xA;        runRobot(timetableScreenRobot) {&#xA;            testCase.execute(timetableScreenRobot)&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;BDD&lt;/strong&gt;: Expresses clear behavior of the app.&lt;/p&gt; &#xA;&lt;p&gt;We will delve into BDD aspect in the next section.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;companion object {&#xA;        @JvmStatic&#xA;        @ParameterizedRobolectricTestRunner.Parameters(name = &#34;{0}&#34;)&#xA;        fun behaviors(): List&amp;lt;DescribedBehavior&amp;lt;TimetableScreenRobot&amp;gt;&amp;gt; {&#xA;            return describeBehaviors&amp;lt;TimetableScreenRobot&amp;gt;(name = &#34;TimetableScreen&#34;) {&#xA;                describe(&#34;when server is operational&#34;) {&#xA;                    run {&#xA;                        setupTimetableServer(ServerStatus.Operational)&#xA;                        setupTimetableScreenContent()&#xA;                    }&#xA;                    itShould(&#34;show timetable items&#34;) {&#xA;                        captureScreenWithChecks(checks = {&#xA;                            checkTimetableItemsDisplayed()&#xA;                        })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will generate test names like &lt;code&gt;TimetableScreen - when the server is operational - it should display timetable items&lt;/code&gt;.&lt;br&gt; And generate a image named &lt;code&gt;TimetableScreen - when the server is operational - it should display timetable items.png&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Robot Pattern&lt;/strong&gt;: Robots separate the &#34;what&#34; (test intent) from the &#34;how&#34; (UI interactions).&lt;/p&gt; &#xA;&lt;p&gt;Test Cases (What):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;itShould(&#34;show timetable items&#34;) {&#xA;    captureScreenWithChecks(checks = {&#xA;        checkTimetableItemsDisplayed() &#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Robot Implementation (How):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class TimetableScreenRobot {&#xA;    ...&#xA;    fun clickFirstSessionBookmark() {&#xA;        composeTestRule &#xA;            .onAllNodes(hasTestTag(TimetableItemCardBookmarkIconTestTag))&#xA;            .onFirst()&#xA;            .performClick()&#xA;        waitUntilIdle() &#xA;    }&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Roborazzi Integration&lt;/strong&gt;: Roborazzi captures screenshots during tests for visual regression detection.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun captureScreenWithChecks(checks: () -&amp;gt; Unit) {&#xA;        robotTestRule.captureScreen()&#xA;        checks()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;This Year&#39;s Experimental Challenges&lt;/h3&gt; &#xA;&lt;h4&gt;Rewriting Coroutine Flow to Composable Function&lt;/h4&gt; &#xA;&lt;p&gt;This year, we&#39;ve taken a significant step in our app architecture by leveraging Composable functions not just for UI, but also for ViewModels and Repositories. This approach aligns with the growing understanding in the Android community that Compose&#39;s runtime is a powerful tool for managing tree-like structures and state, extending far beyond its initial UI-focused perception.&lt;br&gt; Our motivation stems from the belief that Composable functions can lead to more readable, maintainable, and conceptually unified code across our application layers. This shift represents a move towards treating our entire app as a composable structure, not just its visual elements. Let&#39;s look at how this transformation has impacted our Repository implementation:&lt;/p&gt; &#xA;&lt;p&gt;Flow-based Repository (Old version)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;override fun getTimetableStream(): Flow&amp;lt;Timetable&amp;gt; = flow {&#xA;    var first = true&#xA;    combine(&#xA;        sessionCacheDataStore.getTimetableStream().catch { e -&amp;gt;&#xA;            Logger.d(&#xA;                &#34;DefaultSessionsRepository sessionCacheDataStore.getTimetableStream catch&#34;,&#xA;                e,&#xA;            )&#xA;            sessionCacheDataStore.save(sessionsApi.sessionsAllResponse())&#xA;            emitAll(sessionCacheDataStore.getTimetableStream())&#xA;        },&#xA;        userDataStore.getFavoriteSessionStream(),&#xA;    ) { timetable, favorites -&amp;gt;&#xA;        timetable.copy(bookmarks = favorites)&#xA;    }.collect {&#xA;        if (!it.isEmpty()) {&#xA;            emit(it)&#xA;        }&#xA;        if (first) {&#xA;            first = false&#xA;            Logger.d(&#34;DefaultSessionsRepository onStart getTimetableStream()&#34;)&#xA;            sessionCacheDataStore.save(sessionsApi.sessionsAllResponse())&#xA;            Logger.d(&#34;DefaultSessionsRepository onStart fetched&#34;)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can write a Repository like this. We don&#39;t need to use combine.&lt;/p&gt; &#xA;&lt;p&gt;Composable Function-based Repository (New version)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Composable&#xA;public override fun timetable(): Timetable {&#xA;    var first by remember { mutableStateOf(true) }&#xA;    SafeLaunchedEffect(first) {&#xA;        if (first) {&#xA;            Logger.d(&#34;DefaultSessionsRepository onStart getTimetableStream()&#34;)&#xA;            sessionCacheDataStore.save(sessionsApi.sessionsAllResponse())&#xA;            Logger.d(&#34;DefaultSessionsRepository onStart fetched&#34;)&#xA;            first = false&#xA;        }&#xA;    }&#xA;&#xA;    val timetable by remember {&#xA;        sessionCacheDataStore.getTimetableStream().catch { e -&amp;gt;&#xA;            Logger.d(&#xA;                &#34;DefaultSessionsRepository sessionCacheDataStore.getTimetableStream catch&#34;,&#xA;                e,&#xA;            )&#xA;            sessionCacheDataStore.save(sessionsApi.sessionsAllResponse())&#xA;            emitAll(sessionCacheDataStore.getTimetableStream())&#xA;        }&#xA;    }.safeCollectAsRetainedState(Timetable())&#xA;    val favoriteSessions by remember {&#xA;        userDataStore.getFavoriteSessionStream()&#xA;    }.safeCollectAsRetainedState(persistentSetOf())&#xA;&#xA;    Logger.d { &#34;DefaultSessionsRepository timetable() count=${timetable.timetableItems.size}&#34; }&#xA;    return timetable.copy(bookmarks = favoriteSessions)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We are exploring the possibility of using Compose.&lt;/p&gt; &#xA;&lt;h4&gt;Behavior driven development and screenshot testing&lt;/h4&gt; &#xA;&lt;p&gt;We aim to enhance our app&#39;s quality by adopting BDD methodologies similar to Ruby and JavaScript tests, alongside implementing screenshot testing.&lt;br&gt; We used to have a test like &lt;code&gt;@Test fun launchTimetableShot(){}&lt;/code&gt; that captures a screenshot of the timetable screen. But we found that we don&#39;t know what to check in the screenshot. The reason why we chose BDD is that it clearly defines the app&#39;s behavior and ensures that the app functions as expected.&lt;br&gt; To effectively capture screenshots, we utilize Robolectric integrated with &lt;a href=&#34;https://github.com/takahirom/roborazzi&#34;&gt;Roborazzi&lt;/a&gt;. Below is the Kotlin code snippet we employ for our BDD tests. The &lt;code&gt;describeBehaviors()&lt;/code&gt; function used here is from the &lt;a href=&#34;https://github.com/takahirom/robospec&#34;&gt;RoboSpec&lt;/a&gt; library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;companion object {&#xA;@JvmStatic&#xA;@ParameterizedRobolectricTestRunner.Parameters(name = &#34;{0}&#34;)&#xA;fun behaviors(): List&amp;lt;DescribedBehavior&amp;lt;TimetableScreenRobot&amp;gt;&amp;gt; {&#xA;    return describeBehaviors&amp;lt;TimetableScreenRobot&amp;gt;(name = &#34;TimetableScreen&#34;) {&#xA;        describe(&#34;when server is operational&#34;) {&#xA;            run {&#xA;                setupTimetableServer(ServerStatus.Operational)&#xA;                setupTimetableScreenContent()&#xA;            }&#xA;            itShould(&#34;show timetable items&#34;) {&#xA;                captureScreenWithChecks(checks = {&#xA;                    checkTimetableItemsDisplayed()&#xA;                })&#xA;            }&#xA;            describe(&#34;click first session bookmark&#34;) {&#xA;                run {&#xA;                    clickFirstSessionBookmark()&#xA;                }&#xA;                itShould(&#34;show bookmarked session&#34;) {&#xA;                    captureScreenWithChecks{&#xA;                        checkFirstSessionBookmarked()&#xA;                    }&#xA;                }&#xA;            }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The test names are formatted as follows: &lt;code&gt;TimetableScreen - when the server is operational - it should display timetable items&lt;/code&gt;.&lt;br&gt; Correspondingly, screenshots are saved with names like &lt;code&gt;TimetableScreen - when the server is operational - it should display timetable items.png&lt;/code&gt;.&lt;br&gt; While screenshots are invaluable for debugging, they alone do not suffice to ensure app quality, as changes can be missed. Therefore, we enforce rigorous content checks during screenshot capture using the &lt;code&gt;captureScreenWithChecks&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;h4&gt;Flexible Integration of Compose Multiplatform in iOS Apps&lt;/h4&gt; &#xA;&lt;p&gt;This feature demonstrates the practicality of Compose Multiplatform by showcasing its adaptability at various levels within an iOS application.&lt;br&gt; We introduce a settings screen that allows toggling Compose Multiplatform integration for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Full app integration (runs the entire app on iOS)&lt;/li&gt; &#xA; &lt;li&gt;Screen-level integration (e.g., Using @ContributorScreen in the iOS app)&lt;/li&gt; &#xA; &lt;li&gt;Presenter (ViewModel) integration (e.g., Using @contributorScreenPresenter in the iOS app with SwiftUI)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This approach demonstrates flexible adaptation between iOS and Android platforms, enabling performance optimization by using native components and versatile development strategies.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>iamr0s/Dhizuku</title>
    <updated>2024-08-25T01:41:35Z</updated>
    <id>tag:github.com,2024-08-25:/iamr0s/Dhizuku</id>
    <link href="https://github.com/iamr0s/Dhizuku" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Android Application for share DeviceOwner&lt;/p&gt;&lt;hr&gt;&lt;p&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/iamr0s/Dhizuku/main/README_zh_rCN.md&#34;&gt;简体中文&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/iamr0s/Dhizuku/main/README_ja.md&#34;&gt;日本語&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/iamr0s/Dhizuku/main/README_ru.md&#34;&gt;Русский&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Dhizuku&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/iamr0s/Dhizuku/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/downloads/iamr0s/Dhizuku/total?label=Downloads&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/iamr0s/Dhizuku/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/iamr0s/Dhizuku?label=Lastest&#34; alt=&#34;Lastest&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;A tool that can share DeviceOwner permissions to other application.&lt;/p&gt; &#xA;&lt;h2&gt;Activation tutorial&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/iamr0s/Dhizuku/discussions/19&#34;&gt;Github Discussions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported Versions&lt;/h2&gt; &#xA;&lt;p&gt;Android 5.0 ~ 14&lt;/p&gt; &#xA;&lt;h2&gt;For Developer（Join Dhizuku-API）&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/iamr0s/Dhizuku-API.git&#34;&gt;Dhizuku API&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Participate in translation&lt;/h2&gt; &#xA;&lt;p&gt;If you would like to get involved in translating Dhizuku, head over to &lt;a href=&#34;https://hosted.weblate.org/engage/dhizuku/&#34;&gt;Weblate&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hosted.weblate.org/engage/dhizuku/&#34;&gt;&lt;img src=&#34;https://hosted.weblate.org/widgets/dhizuku/-/multi-auto.svg?sanitize=true&#34; alt=&#34;status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Donation support&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://qr.alipay.com/fkx18580lfpydiop04dze47&#34;&gt;Alipay&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://missuo.ru/file/fee5df1381671c996b127.png&#34;&gt;Wechat&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://missuo.ru/file/28368c28d4ff28d59ed4b.jpg&#34;&gt;Binance&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Dhizuku is licensed under the &lt;a href=&#34;http://www.gnu.org/copyleft/gpl.html&#34;&gt;&lt;strong&gt;GNU General Public License v3 (GPL-3)&lt;/strong&gt;&lt;/a&gt; , And promises to continue to keep it open source in the future.&lt;/p&gt;</summary>
  </entry>
</feed>