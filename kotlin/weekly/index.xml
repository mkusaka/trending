<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Kotlin Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-14T01:58:44Z</updated>
  <subtitle>Weekly Trending of Kotlin in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>VegaBobo/DSU-Sideloader</title>
    <updated>2023-05-14T01:58:44Z</updated>
    <id>tag:github.com,2023-05-14:/VegaBobo/DSU-Sideloader</id>
    <link href="https://github.com/VegaBobo/DSU-Sideloader" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple app made to help users easily install GSIs via DSU&#39;s Android feature.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DSU Sideloader&lt;/h1&gt; &#xA;&lt;p&gt;A simple app made to help users easily install GSIs via DSU&#39;s Android feature.&lt;/p&gt; &#xA;&lt;div&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/VegaBobo/DSU-Sideloader/master/other/preview_1.png&#34; alt=&#34;preview&#34; width=&#34;200&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/VegaBobo/DSU-Sideloader/master/other/preview_2.png&#34; alt=&#34;preview&#34; width=&#34;200&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Android 10 or higher&lt;/li&gt; &#xA; &lt;li&gt;Unlocked Bootloader&lt;/li&gt; &#xA; &lt;li&gt;Device with Dynamic Partitions&lt;/li&gt; &#xA; &lt;li&gt;A GSI you want to use!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Community GSIs: &lt;a href=&#34;https://github.com/phhusson/treble_experimentations/wiki/Generic-System-Image-%28GSI%29-list&#34;&gt;https://github.com/phhusson/treble_experimentations/wiki/Generic-System-Image-%28GSI%29-list&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Google GSIs: &lt;a href=&#34;https://developer.android.com/topic/generic-system-image/releases&#34;&gt;https://developer.android.com/topic/generic-system-image/releases&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;*&lt;em&gt;Remember to use GSIs compatible with your architeture, vndk implementation..&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Downloads&lt;/h2&gt; &#xA;&lt;p&gt;Builds are available at:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;DSU Sideloader&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/VegaBobo/DSU-Sideloader/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/VegaBobo/DSU-Sideloader?label=GitHub&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://apt.izzysoft.de/fdroid/index/apk/vegabobo.dsusideloader&#34;&gt;&lt;img src=&#34;https://img.shields.io/endpoint?url=https://apt.izzysoft.de/fdroid/api/v1/shield/vegabobo.dsusideloader&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For testing builds, you can check artifacts at &lt;a href=&#34;https://github.com/VegaBobo/DSU-Sideloader/actions&#34;&gt;Actions&lt;/a&gt; tab&lt;/p&gt; &#xA;&lt;h2&gt;How to use?&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install app&lt;/li&gt; &#xA; &lt;li&gt;When opening for the first time, you need to give read/write permission to a folder, create a new folder and allow access&lt;br&gt; *&lt;em&gt;this folder will be used to store temporary files, like extracted GSIs from compressed files)&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Select a GSI to install&lt;br&gt; **accepted formats are: gz, xz, img and zip (only DSU packages)&lt;/li&gt; &#xA; &lt;li&gt;You can customize installation as you want&lt;br&gt; *&lt;em&gt;like changing userdata size for dynamic system&lt;/em&gt;&lt;br&gt; *&lt;em&gt;changing gsi file size is not recommended (let app do it automatically)&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;Tap on &#34;Install&#34;&lt;/li&gt; &#xA; &lt;li&gt;Wait until finishes! (it may take a some time)&lt;/li&gt; &#xA; &lt;li&gt;Once it finishes, next step may vary: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If built-in installer is enabled, no extra step is required.&lt;/li&gt; &#xA;   &lt;li&gt;When built-in installer is disabled, on rooted/system/shizuku operation mode, DSU screen will appear, prompting you to confirm installation, after that, check your notifications, DSU should start installing GSI.&lt;/li&gt; &#xA;   &lt;li&gt;On ADB operation mode, you will be prompted to run a command in adb, once you run, DSU screen will appear asking you to confirm installation, after that, DSU should start installing GSI.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Once dynamic system is ready, you can boot it through notifications, or, if operation mode is supported, directly from our app.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For more usage information, you can check &lt;a href=&#34;https://raw.githubusercontent.com/VegaBobo/DSU-Sideloader/master/#operation-modes&#34;&gt;Operation modes&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Operation modes&lt;/h2&gt; &#xA;&lt;p&gt;DSU Sideloader support multiple operation modes, they will define how our app will work, also, the operation mode is obtained automatically, and by now, is impossible to change it manually, the picked operation mode will be the best available (the priority is written below, in which, the most feature supported, is the highest number, and the most basic one is the lowest).&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;ADB: Default operation mode when other modes aren&#39;t available&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Only prepare selected image to be installed via DSU system-app&lt;/li&gt; &#xA; &lt;li&gt;Requires adb command to start installation (which will invoke DSU system-app to install the prepared file)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Shizuku: When running app with Shizuku (Obtained when Shizuku permission is granted)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Same as ADB, however, it does not require to run any adb command&lt;/li&gt; &#xA; &lt;li&gt;Support tracking installation progress ¬π ¬≤ ¬≥&lt;/li&gt; &#xA; &lt;li&gt;Support installation diagnostics (if a common error is detected, it may give you useful information) ¬π ¬≥&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Root: When running app with root permissions (Obtained when user grant root permission)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All features avaiable in Shizuku, however, does not require any special permissions&lt;/li&gt; &#xA; &lt;li&gt;DynamicSystem API features (check if DSU is installed, reboot to DSU, discard..., everthing directly from app)&lt;/li&gt; &#xA; &lt;li&gt;Support built-in DSU installer ‚Å¥ ‚Åµ&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;System mode: When running as system-app (Obtained by installing our Magisk module)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All features avaiable in Shizuku&lt;/li&gt; &#xA; &lt;li&gt;Fixes for some common gsi/dsu-related SELinux denials&lt;/li&gt; &#xA; &lt;li&gt;Custom gsid binary (can fix some installation errors in some devices ‚Åµ ‚Å∂&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;System/Root mode: When running as system-app with granted root permission (Obtained by installing our Magisk module and granting root permission)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All features available in root and system operation mode&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;¬π Requires READ_LOGS permission. &lt;br&gt; ¬≤ Partital support on Android 10 and 11. &lt;br&gt; ¬≥ Android 13 requires &#34;One-time log access&#34;. &lt;br&gt; ‚Å¥ Feature not supported on Android 10. &lt;br&gt; ‚Åµ Experimental feature, built-in installer code is &lt;a href=&#34;https://github.com/VegaBobo/DSU-Sideloader/raw/master/app/src/main/java/vegabobo/dsusideloader/installer/root/DSUInstaller.kt&#34;&gt;here&lt;/a&gt;. &lt;br&gt; ‚Å∂ Module including custom gsid binary is optional, changes made to AOSP gsid binary can be found &lt;a href=&#34;https://github.com/VegaBobo/DSU-Sideloader/tree/master/magisk-module/src/main/resources/aosp_patches&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Recomendations&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For non-rooted devices, Shizuku is a pretty nice operation mode, it support most features with no hassle, however, you need to install and setup &lt;a href=&#34;https://play.google.com/store/apps/details?id=moe.shizuku.privileged.api&#34;&gt;Shizuku&lt;/a&gt; app in your device.&lt;/li&gt; &#xA; &lt;li&gt;For rooted devices, Root operation mode is more than ok for most people.&lt;/li&gt; &#xA; &lt;li&gt;If you&#39;re having issues with DSU feature, go with System/Root.&lt;/li&gt; &#xA; &lt;li&gt;Rooted devices via Magisk, should be running Magisk v24 or higher, older versions may break DSU feature.&lt;/li&gt; &#xA; &lt;li&gt;We highly recommend using this app with Stock ROM, some Custom ROM builds may also work fine.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Common questions&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;DSU installation finishes with no errors, but device doesn&#39;t boot into installed DSU, what should i do?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It is likely that AVB is preventing device from booting installed images, try flashing disabled vbmeta, check &lt;a href=&#34;https://developer.android.com/topic/generic-system-image#flash-gsi&#34;&gt;this&lt;/a&gt; for more info.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Why isn&#39;t possible to set a high userdata value?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The more storage you have free, the more you can use to be your userdata, some Android versions limit the maximum allowed for allocation (this limitation is 40%, and is not our app limitation, it is a thing from Android itself, you can use our custom gsid binary, which reduces this limitation to 20%, is possible to eliminate it, but no clue if there is some implications, so, i just decided to decrease it).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Why &#34;Unmount SD&#34; option exists?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If available, DSU priorizes allocation in sdcard, but allocating in sdcard is not supported in some cases (it may depends on filesystem present on sd, and if the allocation in SD is allowed by OS itself), since allocating in SD may cause installation errors in some devices, that options is here to enforce allocation in device storage.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Why built-in installer requires root?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Because it uses Android&#39;s internal DynamicSystem API, which requires &#34;MANAGE_DYNAMIC_SYSTEM&#34;, which is a signature protection level, the convenient way to circumvent it, is by using root. shell (2000) has &#34;INSTALL_DYNAMIC_SYSTEM&#34;, which is able to call DSU system-app (this one has &#34;MANAGE_DYNAMIC_SYSTEM&#34;) to install images.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;How about updates?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Our app comes with a updater, you can check updates in &#34;About&#34; section.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;Other question? problem?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Feel free to start a issue, for troubleshooting, don&#39;t forget to send logs (logs can be obtained on installation phase, directly on app, when operation mode support installation diagnostics).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;About DSU&lt;/h2&gt; &#xA;&lt;p&gt;DSU (Dynamic System Updates), is a feature introduced on Android 10, that let developers boot GSIs without touching current system partition, this is done by creating new partitions to hold a GSI and a separated userdata, to boot on them when desired.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunelly, DSU depends on Dynamic Partitions (your device need to support, otherwise, won&#39;t work), and most GSIs requires unlocked bootloader to get them booting properly (since only OEM-Signed GSIs are allowed to boot on locked bootloader).&lt;/p&gt; &#xA;&lt;p&gt;GSIs can be installed via DSU without root access, using ADB, running some commands, you can read more about installation process here: &lt;a href=&#34;https://developer.android.com/topic/dsu&#34;&gt;https://developer.android.com/topic/dsu&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Once installation finishes, Android creates a persistent notification allowing you to boot into &#34;Dynamic System&#34; (GSI installed via DSU), and you can boot into installed GSI, without touching your system partition, or breaking the &#34;real userdata&#34; partition.&lt;/p&gt; &#xA;&lt;p&gt;After booting Dynamic System, you can try and test whatever you want, when you need to switch back to device&#39;s original system image, everything you need to do, is just, a simple reboot!&lt;/p&gt; &#xA;&lt;p&gt;When doing a long test, that may requires lots of reboots, this can be a pain, however, is possible to enable &#34;sticky mode&#34;, that enforces dynamic system, instead of device&#39;s original system image, once tests are done, you can disable sticky mode and return to original system image.&lt;/p&gt; &#xA;&lt;p&gt;That is basically a quickly explanation about DSU, a amazing feature, like a &#34;dual-boot&#34; solution, limited, however, very safe (since no read-only partition will be modified, and if GSI does not boot, just a simple reboot will return you to the original device&#39;s system image).&lt;/p&gt; &#xA;&lt;p&gt;You can read more about DSU here: &lt;a href=&#34;https://source.android.com/devices/tech/ota/dynamic-system-updates&#34;&gt;https://source.android.com/devices/tech/ota/dynamic-system-updates&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to enable Sticky Mode?&lt;/h2&gt; &#xA;&lt;p&gt;Reboot to Dynamic System, and:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;use this command on adb: &lt;code&gt;adb shell gsi_tool enable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;or from local adb shell: &lt;code&gt;gsi_tool enable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;or from local rooted shell (eg. Termux on rooted GSI): &lt;code&gt;su -c &#39;gsi_tool enable&#39;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When sticky mode is enabled, device will always boot into dynamic system, instead of device&#39;s original system image.&lt;/p&gt; &#xA;&lt;p&gt;To disable, use the same command, instead of &lt;code&gt;enable&lt;/code&gt; , use &lt;code&gt;disable&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Other&lt;/h2&gt; &#xA;&lt;p&gt;For translators, we now have a Crowdin, feel free send your translations: &lt;br&gt;&lt;a href=&#34;https://crowdin.com/translate/dsu-sideloader/&#34;&gt;https://crowdin.com/translate/dsu-sideloader/&lt;/a&gt;&lt;br&gt; App icon made by &lt;a href=&#34;https://github.com/WSTxda&#34;&gt;WSTxda&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>enricocid/Music-Player-GO</title>
    <updated>2023-05-14T01:58:44Z</updated>
    <id>tag:github.com,2023-05-14:/enricocid/Music-Player-GO</id>
    <link href="https://github.com/enricocid/Music-Player-GO" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üé∂üéº Very slim music player üë®‚Äçüé§ 100% made in Italy üçïüå≥üåûüçùüåÑ&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;128&#34; src=&#34;https://github.com/enricocid/Music-Player-GO/raw/main/fastlane/metadata/android/en-US/images/icon.png&#34;&gt; &lt;/p&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt;Music Player GO&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;400&#34; src=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/art16.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;!-- Latest Release --&gt; &lt;a href=&#34;https://github.com/enricocid/Music-Player-GO/releases&#34;&gt; &lt;img alt=&#34;GitHub release&#34; src=&#34;https://img.shields.io/static/v1?label=Tag&amp;amp;message=v4.4.23&amp;amp;color=58F5D1&#34;&gt; &lt;/a&gt; &#xA; &lt;!-- Minimum SDK --&gt; &lt;img alt=&#34;Minimum SDK&#34; src=&#34;https://img.shields.io/static/v1?label=API&amp;amp;message=21&amp;amp;color=32B5ED&#34;&gt; &#xA; &lt;!-- Android CI integration --&gt; &lt;a href=&#34;https://github.com/enricocid/Music-Player-GO/actions&#34;&gt; &lt;img alt=&#34;CI&#34; src=&#34;https://github.com/enricocid/Music-Player-GO/workflows/Android%20CI/badge.svg?sanitize=true&#34;&gt; &lt;/a&gt; &#xA; &lt;!-- Support Ukraine --&gt; &lt;a href=&#34;https://war.ukraine.ua/support-ukraine/&#34;&gt; &lt;img alt=&#34;Support Ukraine&#34; src=&#34;https://img.shields.io/static/v1?label=Support Ukraine&amp;amp;message=now!&amp;amp;color=005BBB&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h3 align=&#34;center&#34;&gt; &lt;a href=&#34;https://hosted.weblate.org/engage/music-player-go/&#34;&gt; &lt;img src=&#34;https://hosted.weblate.org/widgets/music-player-go/-/287x66-white.png&#34;&gt; &lt;/a&gt; &lt;/h3&gt; &#xA;&lt;h3 align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/PRIVACY_POLICY.md&#34;&gt;Privacy policy&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/FAQ.md&#34;&gt;FAQ&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/LIBS.md&#34;&gt;3rd party components&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/CONTRIBUTORS.md&#34;&gt;Contributors&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/FORMATS.md&#34;&gt;Formats&lt;/a&gt; &lt;/h3&gt;  &#xA;&lt;h1&gt;Table of contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/#description&#34;&gt;Description&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/#download&#34;&gt;Download&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/#translations&#34;&gt;Translations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;Home of &lt;strong&gt;Music Player GO&lt;/strong&gt;, a minimal yet fully-featured local Android music player aiming at &lt;strong&gt;simplicity&lt;/strong&gt; and performance&lt;/p&gt; &#xA;&lt;h1&gt;Download&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://f-droid.org/packages/com.iven.musicplayergo/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/enricocid/fdroid-custom-badges/main/badge_get-it-on.png&#34; alt=&#34;Get it on F-Droid&#34; height=&#34;80&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://play.google.com/store/apps/details?id=com.iven.musicplayergo&#34;&gt;&lt;img src=&#34;https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png&#34; alt=&#34;Get it on Google Play&#34; height=&#34;80&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Minimal interface&lt;/li&gt; &#xA; &lt;li&gt;Equalizer&lt;/li&gt; &#xA; &lt;li&gt;Music organised by artist, albums, songs and folders; tabs are organisable&lt;/li&gt; &#xA; &lt;li&gt;Light, dark, automatic themes and accents&lt;/li&gt; &#xA; &lt;li&gt;Pure black theme&lt;/li&gt; &#xA; &lt;li&gt;Queue&lt;/li&gt; &#xA; &lt;li&gt;Sleep timer&lt;/li&gt; &#xA; &lt;li&gt;Audio focus, precise volume and headset management&lt;/li&gt; &#xA; &lt;li&gt;Now playing, embedded covers, search, playback speed, pause on completion, sorting, shuffle, fast-seeking...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Translations&lt;/h1&gt; &#xA;&lt;p&gt;Help us to translate the project on &lt;a href=&#34;https://hosted.weblate.org/engage/music-player-go/&#34;&gt;Hosted Weblate&lt;/a&gt;. Consider sending some &lt;a href=&#34;https://weblate.org/donate/new/&#34;&gt;love&lt;/a&gt; to the Weblate guys who made easy translations possible. :)&lt;/p&gt; &#xA;&lt;a href=&#34;https://hosted.weblate.org/engage/music-player-go/&#34;&gt; &lt;img src=&#34;https://hosted.weblate.org/widgets/music-player-go/-/horizontal-auto.svg?sanitize=true&#34; alt=&#34;Stato traduzione&#34;&gt; &lt;/a&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;2022 ¬© &lt;strong&gt;Enrico D&#39;Ortenzio&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository is copylefted libre software, licensed &lt;a href=&#34;https://www.gnu.org/licenses/#GPL&#34;&gt;GPLv3&lt;/a&gt;, as described in the &lt;a href=&#34;https://raw.githubusercontent.com/enricocid/Music-Player-GO/main/LICENSE.md&#34;&gt;LICENSE&lt;/a&gt; file. Use, study, change and share at will; with all.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>square/moshi</title>
    <updated>2023-05-14T01:58:44Z</updated>
    <id>tag:github.com,2023-05-14:/square/moshi</id>
    <link href="https://github.com/square/moshi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A modern JSON library for Kotlin and Java.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Moshi&lt;/h1&gt; &#xA;&lt;p&gt;Moshi is a modern JSON library for Android, Java and Kotlin. It makes it easy to parse JSON into Java and Kotlin classes:&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: The Kotlin examples of this README assume use of either Kotlin code gen or &lt;code&gt;KotlinJsonAdapterFactory&lt;/code&gt; for reflection. Plain Java-based reflection is unsupported on Kotlin classes.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String json = ...;&#xA;&#xA;Moshi moshi = new Moshi.Builder().build();&#xA;JsonAdapter&amp;lt;BlackjackHand&amp;gt; jsonAdapter = moshi.adapter(BlackjackHand.class);&#xA;&#xA;BlackjackHand blackjackHand = jsonAdapter.fromJson(json);&#xA;System.out.println(blackjackHand);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val json: String = ...&#xA;&#xA;val moshi: Moshi = Moshi.Builder().build()&#xA;val jsonAdapter: JsonAdapter&amp;lt;BlackjackHand&amp;gt; = moshi.adapter&amp;lt;BlackjackHand&amp;gt;()&#xA;&#xA;val blackjackHand = jsonAdapter.fromJson(json)&#xA;println(blackjackHand)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;And it can just as easily serialize Java or Kotlin objects as JSON:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BlackjackHand blackjackHand = new BlackjackHand(&#xA;    new Card(&#39;6&#39;, SPADES),&#xA;    Arrays.asList(new Card(&#39;4&#39;, CLUBS), new Card(&#39;A&#39;, HEARTS)));&#xA;&#xA;Moshi moshi = new Moshi.Builder().build();&#xA;JsonAdapter&amp;lt;BlackjackHand&amp;gt; jsonAdapter = moshi.adapter(BlackjackHand.class);&#xA;&#xA;String json = jsonAdapter.toJson(blackjackHand);&#xA;System.out.println(json);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val blackjackHand = BlackjackHand(&#xA;    Card(&#39;6&#39;, SPADES),&#xA;    listOf(Card(&#39;4&#39;, CLUBS), Card(&#39;A&#39;, HEARTS))&#xA;  )&#xA;&#xA;val moshi: Moshi = Moshi.Builder().build()&#xA;val jsonAdapter: JsonAdapter&amp;lt;BlackjackHand&amp;gt; = moshi.adapter&amp;lt;BlackjackHand&amp;gt;()&#xA;&#xA;val json: String = jsonAdapter.toJson(blackjackHand)&#xA;println(json)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Built-in Type Adapters&lt;/h3&gt; &#xA;&lt;p&gt;Moshi has built-in support for reading and writing Java‚Äôs core data types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Primitives (int, float, char...) and their boxed counterparts (Integer, Float, Character...).&lt;/li&gt; &#xA; &lt;li&gt;Arrays, Collections, Lists, Sets, and Maps&lt;/li&gt; &#xA; &lt;li&gt;Strings&lt;/li&gt; &#xA; &lt;li&gt;Enums&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It supports your model classes by writing them out field-by-field. In the example above Moshi uses these classes:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class BlackjackHand {&#xA;  public final Card hidden_card;&#xA;  public final List&amp;lt;Card&amp;gt; visible_cards;&#xA;  ...&#xA;}&#xA;&#xA;class Card {&#xA;  public final char rank;&#xA;  public final Suit suit;&#xA;  ...&#xA;}&#xA;&#xA;enum Suit {&#xA;  CLUBS, DIAMONDS, HEARTS, SPADES;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class BlackjackHand(&#xA;  val hidden_card: Card,&#xA;  val visible_cards: List&amp;lt;Card&amp;gt;,&#xA;  ...&#xA;)&#xA;&#xA;class Card(&#xA;  val rank: Char,&#xA;  val suit: Suit&#xA;  ...&#xA;)&#xA;&#xA;enum class Suit {&#xA;  CLUBS, DIAMONDS, HEARTS, SPADES;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;to read and write this JSON:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;hidden_card&#34;: {&#xA;    &#34;rank&#34;: &#34;6&#34;,&#xA;    &#34;suit&#34;: &#34;SPADES&#34;&#xA;  },&#xA;  &#34;visible_cards&#34;: [&#xA;    {&#xA;      &#34;rank&#34;: &#34;4&#34;,&#xA;      &#34;suit&#34;: &#34;CLUBS&#34;&#xA;    },&#xA;    {&#xA;      &#34;rank&#34;: &#34;A&#34;,&#xA;      &#34;suit&#34;: &#34;HEARTS&#34;&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://square.github.io/moshi/1.x/moshi/&#34;&gt;Javadoc&lt;/a&gt; catalogs the complete Moshi API, which we explore below.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Type Adapters&lt;/h3&gt; &#xA;&lt;p&gt;With Moshi, it‚Äôs particularly easy to customize how values are converted to and from JSON. A type adapter is any class that has methods annotated &lt;code&gt;@ToJson&lt;/code&gt; and &lt;code&gt;@FromJson&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example, Moshi‚Äôs default encoding of a playing card is verbose: the JSON defines the rank and suit in separate fields: &lt;code&gt;{&#34;rank&#34;:&#34;A&#34;,&#34;suit&#34;:&#34;HEARTS&#34;}&lt;/code&gt;. With a type adapter, we can change the encoding to something more compact: &lt;code&gt;&#34;4H&#34;&lt;/code&gt; for the four of hearts or &lt;code&gt;&#34;JD&#34;&lt;/code&gt; for the jack of diamonds:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class CardAdapter {&#xA;  @ToJson String toJson(Card card) {&#xA;    return card.rank + card.suit.name().substring(0, 1);&#xA;  }&#xA;&#xA;  @FromJson Card fromJson(String card) {&#xA;    if (card.length() != 2) throw new JsonDataException(&#34;Unknown card: &#34; + card);&#xA;&#xA;    char rank = card.charAt(0);&#xA;    switch (card.charAt(1)) {&#xA;      case &#39;C&#39;: return new Card(rank, Suit.CLUBS);&#xA;      case &#39;D&#39;: return new Card(rank, Suit.DIAMONDS);&#xA;      case &#39;H&#39;: return new Card(rank, Suit.HEARTS);&#xA;      case &#39;S&#39;: return new Card(rank, Suit.SPADES);&#xA;      default: throw new JsonDataException(&#34;unknown suit: &#34; + card);&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class CardAdapter {&#xA;  @ToJson fun toJson(card: Card): String {&#xA;    return card.rank + card.suit.name.substring(0, 1)&#xA;  }&#xA;&#xA;  @FromJson fun fromJson(card: String): Card {&#xA;    if (card.length != 2) throw JsonDataException(&#34;Unknown card: $card&#34;)&#xA;&#xA;    val rank = card[0]&#xA;    return when (card[1]) {&#xA;      &#39;C&#39; -&amp;gt; Card(rank, Suit.CLUBS)&#xA;      &#39;D&#39; -&amp;gt; Card(rank, Suit.DIAMONDS)&#xA;      &#39;H&#39; -&amp;gt; Card(rank, Suit.HEARTS)&#xA;      &#39;S&#39; -&amp;gt; Card(rank, Suit.SPADES)&#xA;      else -&amp;gt; throw JsonDataException(&#34;unknown suit: $card&#34;)&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Register the type adapter with the &lt;code&gt;Moshi.Builder&lt;/code&gt; and we‚Äôre good to go.&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Moshi moshi = new Moshi.Builder()&#xA;    .add(new CardAdapter())&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val moshi = Moshi.Builder()&#xA;    .add(CardAdapter())&#xA;    .build()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Voil√†:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;hidden_card&#34;: &#34;6S&#34;,&#xA;  &#34;visible_cards&#34;: [&#xA;    &#34;4C&#34;,&#xA;    &#34;AH&#34;&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Another example&lt;/h4&gt; &#xA;&lt;p&gt;Note that the method annotated with &lt;code&gt;@FromJson&lt;/code&gt; does not need to take a String as an argument. Rather it can take input of any type and Moshi will first parse the JSON to an object of that type and then use the &lt;code&gt;@FromJson&lt;/code&gt; method to produce the desired final value. Conversely, the method annotated with &lt;code&gt;@ToJson&lt;/code&gt; does not have to produce a String.&lt;/p&gt; &#xA;&lt;p&gt;Assume, for example, that we have to parse a JSON in which the date and time of an event are represented as two separate strings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;title&#34;: &#34;Blackjack tournament&#34;,&#xA;  &#34;begin_date&#34;: &#34;20151010&#34;,&#xA;  &#34;begin_time&#34;: &#34;17:04&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We would like to combine these two fields into one string to facilitate the date parsing at a later point. Also, we would like to have all variable names in CamelCase. Therefore, the &lt;code&gt;Event&lt;/code&gt; class we want Moshi to produce like this:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Event {&#xA;  String title;&#xA;  String beginDateAndTime;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Event(&#xA;  val title: String,&#xA;  val beginDateAndTime: String&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Instead of manually parsing the JSON line per line (which we could also do) we can have Moshi do the transformation automatically. We simply define another class &lt;code&gt;EventJson&lt;/code&gt; that directly corresponds to the JSON structure:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class EventJson {&#xA;  String title;&#xA;  String begin_date;&#xA;  String begin_time;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class EventJson(&#xA;  val title: String,&#xA;  val begin_date: String,&#xA;  val begin_time: String&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;And another class with the appropriate &lt;code&gt;@FromJson&lt;/code&gt; and &lt;code&gt;@ToJson&lt;/code&gt; methods that are telling Moshi how to convert an &lt;code&gt;EventJson&lt;/code&gt; to an &lt;code&gt;Event&lt;/code&gt; and back. Now, whenever we are asking Moshi to parse a JSON to an &lt;code&gt;Event&lt;/code&gt; it will first parse it to an &lt;code&gt;EventJson&lt;/code&gt; as an intermediate step. Conversely, to serialize an &lt;code&gt;Event&lt;/code&gt; Moshi will first create an &lt;code&gt;EventJson&lt;/code&gt; object and then serialize that object as usual.&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class EventJsonAdapter {&#xA;  @FromJson Event eventFromJson(EventJson eventJson) {&#xA;    Event event = new Event();&#xA;    event.title = eventJson.title;&#xA;    event.beginDateAndTime = eventJson.begin_date + &#34; &#34; + eventJson.begin_time;&#xA;    return event;&#xA;  }&#xA;&#xA;  @ToJson EventJson eventToJson(Event event) {&#xA;    EventJson json = new EventJson();&#xA;    json.title = event.title;&#xA;    json.begin_date = event.beginDateAndTime.substring(0, 8);&#xA;    json.begin_time = event.beginDateAndTime.substring(9, 14);&#xA;    return json;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class EventJsonAdapter {&#xA;  @FromJson&#xA;  fun eventFromJson(eventJson: EventJson): Event {&#xA;    return Event(&#xA;      title = eventJson.title,&#xA;      beginDateAndTime = &#34;${eventJson.begin_date} ${eventJson.begin_time}&#34;&#xA;    )&#xA;  }&#xA;&#xA;  @ToJson&#xA;  fun eventToJson(event: Event): EventJson {&#xA;    return EventJson(&#xA;      title = event.title,&#xA;      begin_date = event.beginDateAndTime.substring(0, 8),&#xA;      begin_time = event.beginDateAndTime.substring(9, 14),&#xA;    )&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Again we register the adapter with Moshi.&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Moshi moshi = new Moshi.Builder()&#xA;    .add(new EventJsonAdapter())&#xA;    .build();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val moshi = Moshi.Builder()&#xA;    .add(EventJsonAdapter())&#xA;    .build()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;We can now use Moshi to parse the JSON directly to an &lt;code&gt;Event&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;JsonAdapter&amp;lt;Event&amp;gt; jsonAdapter = moshi.adapter(Event.class);&#xA;Event event = jsonAdapter.fromJson(json);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val jsonAdapter = moshi.adapter&amp;lt;Event&amp;gt;()&#xA;val event = jsonAdapter.fromJson(json)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Adapter convenience methods&lt;/h3&gt; &#xA;&lt;p&gt;Moshi provides a number of convenience methods for &lt;code&gt;JsonAdapter&lt;/code&gt; objects:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;nullSafe()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nonNull()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lenient()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;failOnUnknown()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;indent()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;serializeNulls()&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These factory methods wrap an existing &lt;code&gt;JsonAdapter&lt;/code&gt; into additional functionality. For example, if you have an adapter that doesn&#39;t support nullable values, you can use &lt;code&gt;nullSafe()&lt;/code&gt; to make it null safe:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String dateJson = &#34;\&#34;2018-11-26T11:04:19.342668Z\&#34;&#34;;&#xA;String nullDateJson = &#34;null&#34;;&#xA;&#xA;// Hypothetical IsoDateDapter, doesn&#39;t support null by default&#xA;JsonAdapter&amp;lt;Date&amp;gt; adapter = new IsoDateDapter();&#xA;&#xA;Date date = adapter.fromJson(dateJson);&#xA;System.out.println(date); // Mon Nov 26 12:04:19 CET 2018&#xA;&#xA;Date nullDate = adapter.fromJson(nullDateJson);&#xA;// Exception, com.squareup.moshi.JsonDataException: Expected a string but was NULL at path $&#xA;&#xA;Date nullDate = adapter.nullSafe().fromJson(nullDateJson);&#xA;System.out.println(nullDate); // null&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val dateJson = &#34;\&#34;2018-11-26T11:04:19.342668Z\&#34;&#34;&#xA;val nullDateJson = &#34;null&#34;&#xA;&#xA;// Hypothetical IsoDateDapter, doesn&#39;t support null by default&#xA;val adapter: JsonAdapter&amp;lt;Date&amp;gt; = IsoDateDapter()&#xA;&#xA;val date = adapter.fromJson(dateJson)&#xA;println(date) // Mon Nov 26 12:04:19 CET 2018&#xA;&#xA;val nullDate = adapter.fromJson(nullDateJson)&#xA;// Exception, com.squareup.moshi.JsonDataException: Expected a string but was NULL at path $&#xA;&#xA;val nullDate = adapter.nullSafe().fromJson(nullDateJson)&#xA;println(nullDate) // null&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;In contrast to &lt;code&gt;nullSafe()&lt;/code&gt; there is &lt;code&gt;nonNull()&lt;/code&gt; to make an adapter refuse null values. Refer to the Moshi JavaDoc for details on the various methods.&lt;/p&gt; &#xA;&lt;h3&gt;Parse JSON Arrays&lt;/h3&gt; &#xA;&lt;p&gt;Say we have a JSON string of this structure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[&#xA;  {&#xA;    &#34;rank&#34;: &#34;4&#34;,&#xA;    &#34;suit&#34;: &#34;CLUBS&#34;&#xA;  },&#xA;  {&#xA;    &#34;rank&#34;: &#34;A&#34;,&#xA;    &#34;suit&#34;: &#34;HEARTS&#34;&#xA;  }&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can now use Moshi to parse the JSON string into a &lt;code&gt;List&amp;lt;Card&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String cardsJsonResponse = ...;&#xA;Type type = Types.newParameterizedType(List.class, Card.class);&#xA;JsonAdapter&amp;lt;List&amp;lt;Card&amp;gt;&amp;gt; adapter = moshi.adapter(type);&#xA;List&amp;lt;Card&amp;gt; cards = adapter.fromJson(cardsJsonResponse);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val cardsJsonResponse: String = ...&#xA;// We can just use a reified extension!&#xA;val adapter = moshi.adapter&amp;lt;List&amp;lt;Card&amp;gt;&amp;gt;()&#xA;val cards: List&amp;lt;Card&amp;gt; = adapter.fromJson(cardsJsonResponse)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Fails Gracefully&lt;/h3&gt; &#xA;&lt;p&gt;Automatic databinding almost feels like magic. But unlike the black magic that typically accompanies reflection, Moshi is designed to help you out when things go wrong.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;JsonDataException: Expected one of [CLUBS, DIAMONDS, HEARTS, SPADES] but was ANCHOR at path $.visible_cards[2].suit&#xA;  at com.squareup.moshi.JsonAdapters$11.fromJson(JsonAdapters.java:188)&#xA;  at com.squareup.moshi.JsonAdapters$11.fromJson(JsonAdapters.java:180)&#xA;  ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Moshi always throws a standard &lt;code&gt;java.io.IOException&lt;/code&gt; if there is an error reading the JSON document, or if it is malformed. It throws a &lt;code&gt;JsonDataException&lt;/code&gt; if the JSON document is well-formed, but doesn‚Äôt match the expected format.&lt;/p&gt; &#xA;&lt;h3&gt;Built on Okio&lt;/h3&gt; &#xA;&lt;p&gt;Moshi uses &lt;a href=&#34;https://github.com/square/okio/&#34;&gt;Okio&lt;/a&gt; for simple and powerful I/O. It‚Äôs a fine complement to &lt;a href=&#34;https://github.com/square/okhttp/&#34;&gt;OkHttp&lt;/a&gt;, which can share buffer segments for maximum efficiency.&lt;/p&gt; &#xA;&lt;h3&gt;Borrows from Gson&lt;/h3&gt; &#xA;&lt;p&gt;Moshi uses the same streaming and binding mechanisms as &lt;a href=&#34;https://github.com/google/gson/&#34;&gt;Gson&lt;/a&gt;. If you‚Äôre a Gson user you‚Äôll find Moshi works similarly. If you try Moshi and don‚Äôt love it, you can even migrate to Gson without much violence!&lt;/p&gt; &#xA;&lt;p&gt;But the two libraries have a few important differences:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Moshi has fewer built-in type adapters.&lt;/strong&gt; For example, you need to configure your own date adapter. Most binding libraries will encode whatever you throw at them. Moshi refuses to serialize platform types (&lt;code&gt;java.*&lt;/code&gt;, &lt;code&gt;javax.*&lt;/code&gt;, and &lt;code&gt;android.*&lt;/code&gt;) without a user-provided type adapter. This is intended to prevent you from accidentally locking yourself to a specific JDK or Android release.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Moshi is less configurable.&lt;/strong&gt; There‚Äôs no field naming strategy, versioning, instance creators, or long serialization policy. Instead of naming a field &lt;code&gt;visibleCards&lt;/code&gt; and using a policy class to convert that to &lt;code&gt;visible_cards&lt;/code&gt;, Moshi wants you to just name the field &lt;code&gt;visible_cards&lt;/code&gt; as it appears in the JSON.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Moshi doesn‚Äôt have a &lt;code&gt;JsonElement&lt;/code&gt; model.&lt;/strong&gt; Instead it just uses built-in types like &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Map&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;No HTML-safe escaping.&lt;/strong&gt; Gson encodes &lt;code&gt;=&lt;/code&gt; as &lt;code&gt;\u003d&lt;/code&gt; by default so that it can be safely encoded in HTML without additional escaping. Moshi encodes it naturally (as &lt;code&gt;=&lt;/code&gt;) and assumes that the HTML encoder ‚Äì if there is one ‚Äì will do its job.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Custom field names with @Json&lt;/h3&gt; &#xA;&lt;p&gt;Moshi works best when your JSON objects and Java or Kotlin classes have the same structure. But when they don&#39;t, Moshi has annotations to customize data binding.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;@Json&lt;/code&gt; to specify how Java fields or Kotlin properties map to JSON names. This is necessary when the JSON name contains spaces or other characters that aren‚Äôt permitted in Java field or Kotlin property names. For example, this JSON has a field name containing a space:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;username&#34;: &#34;jesse&#34;,&#xA;  &#34;lucky number&#34;: 32&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With &lt;code&gt;@Json&lt;/code&gt; its corresponding Java or Kotlin class is easy:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Player {&#xA;  String username;&#xA;  @Json(name = &#34;lucky number&#34;) int luckyNumber;&#xA;&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Player {&#xA;  val username: String&#xA;  @Json(name = &#34;lucky number&#34;) val luckyNumber: Int&#xA;&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Because JSON field names are always defined with their Java or Kotlin fields, Moshi makes it easy to find fields when navigating between Java or Koltin and JSON.&lt;/p&gt; &#xA;&lt;h3&gt;Alternate type adapters with @JsonQualifier&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;@JsonQualifier&lt;/code&gt; to customize how a type is encoded for some fields without changing its encoding everywhere. This works similarly to the qualifier annotations in dependency injection tools like Dagger and Guice.&lt;/p&gt; &#xA;&lt;p&gt;Here‚Äôs a JSON message with two integers and a color:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;width&#34;: 1024,&#xA;  &#34;height&#34;: 768,&#xA;  &#34;color&#34;: &#34;#ff0000&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By convention, Android programs also use &lt;code&gt;int&lt;/code&gt; for colors:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Rectangle {&#xA;  int width;&#xA;  int height;&#xA;  int color;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Rectangle(&#xA;  val width: Int,&#xA;  val height: Int,&#xA;  val color: Int&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;But if we encoded the above Java or Kotlin class as JSON, the color isn&#39;t encoded properly!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;width&#34;: 1024,&#xA;  &#34;height&#34;: 768,&#xA;  &#34;color&#34;: 16711680&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The fix is to define a qualifier annotation, itself annotated &lt;code&gt;@JsonQualifier&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RUNTIME)&#xA;@JsonQualifier&#xA;public @interface HexColor {&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Retention(RUNTIME)&#xA;@JsonQualifier&#xA;annotation class HexColor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Next apply this &lt;code&gt;@HexColor&lt;/code&gt; annotation to the appropriate field:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Rectangle {&#xA;  int width;&#xA;  int height;&#xA;  @HexColor int color;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Rectangle(&#xA;  val width: Int,&#xA;  val height: Int,&#xA;  @HexColor val color: Int&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;And finally define a type adapter to handle it:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Converts strings like #ff0000 to the corresponding color ints. */&#xA;class ColorAdapter {&#xA;  @ToJson String toJson(@HexColor int rgb) {&#xA;    return String.format(&#34;#%06x&#34;, rgb);&#xA;  }&#xA;&#xA;  @FromJson @HexColor int fromJson(String rgb) {&#xA;    return Integer.parseInt(rgb.substring(1), 16);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/** Converts strings like #ff0000 to the corresponding color ints.  */&#xA;class ColorAdapter {&#xA;  @ToJson fun toJson(@HexColor rgb: Int): String {&#xA;    return &#34;#%06x&#34;.format(rgb)&#xA;  }&#xA;&#xA;  @FromJson @HexColor fun fromJson(rgb: String): Int {&#xA;    return rgb.substring(1).toInt(16)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Use &lt;code&gt;@JsonQualifier&lt;/code&gt; when you need different JSON encodings for the same type. Most programs shouldn‚Äôt need this &lt;code&gt;@JsonQualifier&lt;/code&gt;, but it‚Äôs very handy for those that do.&lt;/p&gt; &#xA;&lt;h3&gt;Omitting fields&lt;/h3&gt; &#xA;&lt;p&gt;Some models declare fields that shouldn‚Äôt be included in JSON. For example, suppose our blackjack hand has a &lt;code&gt;total&lt;/code&gt; field with the sum of the cards:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class BlackjackHand {&#xA;  private int total;&#xA;&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class BlackjackHand(&#xA;  private val total: Int,&#xA;&#xA;  ...&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;By default, all fields are emitted when encoding JSON, and all fields are accepted when decoding JSON. Prevent a field from being included by annotating them with &lt;code&gt;@Json(ignore = true)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class BlackjackHand {&#xA;  @Json(ignore = true)&#xA;  private int total;&#xA;&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class BlackjackHand(...) {&#xA;  @Json(ignore = true)&#xA;  var total: Int = 0&#xA;&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;These fields are omitted when writing JSON. When reading JSON, the field is skipped even if the JSON contains a value for the field. Instead, it will get a default value. In Kotlin, these fields &lt;em&gt;must&lt;/em&gt; have a default value if they are in the primary constructor.&lt;/p&gt; &#xA;&lt;p&gt;Note that you can also use Java‚Äôs &lt;code&gt;transient&lt;/code&gt; keyword or Kotlin&#39;s &lt;code&gt;@Transient&lt;/code&gt; annotation on these fields for the same effect.&lt;/p&gt; &#xA;&lt;h3&gt;Default Values &amp;amp; Constructors&lt;/h3&gt; &#xA;&lt;p&gt;When reading JSON that is missing a field, Moshi relies on the Java or Kotlin or Android runtime to assign the field‚Äôs value. Which value it uses depends on whether the class has a no-arguments constructor.&lt;/p&gt; &#xA;&lt;p&gt;If the class has a no-arguments constructor, Moshi will call that constructor and whatever value it assigns will be used. For example, because this class has a no-arguments constructor the &lt;code&gt;total&lt;/code&gt; field is initialized to &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note: This section only applies to Java reflections.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class BlackjackHand {&#xA;  private int total = -1;&#xA;  ...&#xA;&#xA;  private BlackjackHand() {&#xA;  }&#xA;&#xA;  public BlackjackHand(Card hidden_card, List&amp;lt;Card&amp;gt; visible_cards) {&#xA;    ...&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the class doesn‚Äôt have a no-arguments constructor, Moshi can‚Äôt assign the field‚Äôs default value, &lt;strong&gt;even if it‚Äôs specified in the field declaration&lt;/strong&gt;. Instead, the field‚Äôs default is always &lt;code&gt;0&lt;/code&gt; for numbers, &lt;code&gt;false&lt;/code&gt; for booleans, and &lt;code&gt;null&lt;/code&gt; for references. In this example, the default value of &lt;code&gt;total&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class BlackjackHand {&#xA;  private int total = -1;&#xA;  ...&#xA;&#xA;  public BlackjackHand(Card hidden_card, List&amp;lt;Card&amp;gt; visible_cards) {&#xA;    ...&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is surprising and is a potential source of bugs! For this reason consider defining a no-arguments constructor in classes that you use with Moshi, using &lt;code&gt;@SuppressWarnings(&#34;unused&#34;)&lt;/code&gt; to prevent it from being inadvertently deleted later:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class BlackjackHand {&#xA;  private int total = -1;&#xA;  ...&#xA;&#xA;  @SuppressWarnings(&#34;unused&#34;) // Moshi uses this!&#xA;  private BlackjackHand() {&#xA;  }&#xA;&#xA;  public BlackjackHand(Card hidden_card, List&amp;lt;Card&amp;gt; visible_cards) {&#xA;    ...&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Composing Adapters&lt;/h3&gt; &#xA;&lt;p&gt;In some situations Moshi&#39;s default Java-to-JSON conversion isn&#39;t sufficient. You can compose adapters to build upon the standard conversion.&lt;/p&gt; &#xA;&lt;p&gt;In this example, we turn serialize nulls, then delegate to the built-in adapter:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class TournamentWithNullsAdapter {&#xA;  @ToJson void toJson(JsonWriter writer, Tournament tournament,&#xA;      JsonAdapter&amp;lt;Tournament&amp;gt; delegate) throws IOException {&#xA;    boolean wasSerializeNulls = writer.getSerializeNulls();&#xA;    writer.setSerializeNulls(true);&#xA;    try {&#xA;      delegate.toJson(writer, tournament);&#xA;    } finally {&#xA;      writer.setLenient(wasSerializeNulls);&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class TournamentWithNullsAdapter {&#xA;  @ToJson fun toJson(writer: JsonWriter, tournament: Tournament?,&#xA;    delegate: JsonAdapter&amp;lt;Tournament?&amp;gt;) {&#xA;    val wasSerializeNulls: Boolean = writer.getSerializeNulls()&#xA;    writer.setSerializeNulls(true)&#xA;    try {&#xA;      delegate.toJson(writer, tournament)&#xA;    } finally {&#xA;      writer.setLenient(wasSerializeNulls)&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;When we use this to serialize a tournament, nulls are written! But nulls elsewhere in our JSON document are skipped as usual.&lt;/p&gt; &#xA;&lt;p&gt;Moshi has a powerful composition system in its &lt;code&gt;JsonAdapter.Factory&lt;/code&gt; interface. We can hook in to the encoding and decoding process for any type, even without knowing about the types beforehand. In this example, we customize types annotated &lt;code&gt;@AlwaysSerializeNulls&lt;/code&gt;, which an annotation we create, not built-in to Moshi:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(TYPE)&#xA;@Retention(RUNTIME)&#xA;public @interface AlwaysSerializeNulls {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Target(TYPE)&#xA;@Retention(RUNTIME)&#xA;annotation class AlwaysSerializeNulls&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@AlwaysSerializeNulls&#xA;static class Car {&#xA;  String make;&#xA;  String model;&#xA;  String color;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@AlwaysSerializeNulls&#xA;class Car(&#xA;  val make: String?,&#xA;  val model: String?,&#xA;  val color: String?&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Each &lt;code&gt;JsonAdapter.Factory&lt;/code&gt; interface is invoked by &lt;code&gt;Moshi&lt;/code&gt; when it needs to build an adapter for a user&#39;s type. The factory either returns an adapter to use, or null if it doesn&#39;t apply to the requested type. In our case we match all classes that have our annotation.&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Java&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static class AlwaysSerializeNullsFactory implements JsonAdapter.Factory {&#xA;  @Override public JsonAdapter&amp;lt;?&amp;gt; create(&#xA;      Type type, Set&amp;lt;? extends Annotation&amp;gt; annotations, Moshi moshi) {&#xA;    Class&amp;lt;?&amp;gt; rawType = Types.getRawType(type);&#xA;    if (!rawType.isAnnotationPresent(AlwaysSerializeNulls.class)) {&#xA;      return null;&#xA;    }&#xA;&#xA;    JsonAdapter&amp;lt;Object&amp;gt; delegate = moshi.nextAdapter(this, type, annotations);&#xA;    return delegate.serializeNulls();&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kotlin&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class AlwaysSerializeNullsFactory : JsonAdapter.Factory {&#xA;  override fun create(type: Type, annotations: Set&amp;lt;Annotation&amp;gt;, moshi: Moshi): JsonAdapter&amp;lt;*&amp;gt;? {&#xA;    val rawType: Class&amp;lt;*&amp;gt; = type.rawType&#xA;    if (!rawType.isAnnotationPresent(AlwaysSerializeNulls::class.java)) {&#xA;      return null&#xA;    }&#xA;    val delegate: JsonAdapter&amp;lt;Any&amp;gt; = moshi.nextAdapter(this, type, annotations)&#xA;    return delegate.serializeNulls()&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;After determining that it applies, the factory looks up Moshi&#39;s built-in adapter by calling &lt;code&gt;Moshi.nextAdapter()&lt;/code&gt;. This is key to the composition mechanism: adapters delegate to each other! The composition in this example is simple: it applies the &lt;code&gt;serializeNulls()&lt;/code&gt; transform on the delegate.&lt;/p&gt; &#xA;&lt;p&gt;Composing adapters can be very sophisticated:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;An adapter could transform the input object before it is JSON-encoded. A string could be trimmed or truncated; a value object could be simplified or normalized.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;An adapter could repair the output object after it is JSON-decoded. It could fill-in missing data or discard unwanted data.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The JSON could be given extra structure, such as wrapping values in objects or arrays.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Moshi is itself built on the pattern of repeatedly composing adapters. For example, Moshi&#39;s built-in adapter for &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; delegates to the adapter of &lt;code&gt;T&lt;/code&gt;, and calls it repeatedly.&lt;/p&gt; &#xA;&lt;h3&gt;Precedence&lt;/h3&gt; &#xA;&lt;p&gt;Moshi&#39;s composition mechanism tries to find the best adapter for each type. It starts with the first adapter or factory registered with &lt;code&gt;Moshi.Builder.add()&lt;/code&gt;, and proceeds until it finds an adapter for the target type.&lt;/p&gt; &#xA;&lt;p&gt;If a type can be matched multiple adapters, the earliest one wins.&lt;/p&gt; &#xA;&lt;p&gt;To register an adapter at the end of the list, use &lt;code&gt;Moshi.Builder.addLast()&lt;/code&gt; instead. This is most useful when registering general-purpose adapters, such as the &lt;code&gt;KotlinJsonAdapterFactory&lt;/code&gt; below.&lt;/p&gt; &#xA;&lt;h2&gt;Kotlin&lt;/h2&gt; &#xA;&lt;p&gt;Moshi is a great JSON library for Kotlin. It understands Kotlin‚Äôs non-nullable types and default parameter values. When you use Kotlin with Moshi you may use reflection, codegen, or both.&lt;/p&gt; &#xA;&lt;h4&gt;Reflection&lt;/h4&gt; &#xA;&lt;p&gt;The reflection adapter uses Kotlin‚Äôs reflection library to convert your Kotlin classes to and from JSON. Enable it by adding the &lt;code&gt;KotlinJsonAdapterFactory&lt;/code&gt; to your &lt;code&gt;Moshi.Builder&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val moshi = Moshi.Builder()&#xA;    .addLast(KotlinJsonAdapterFactory())&#xA;    .build()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Moshi‚Äôs adapters are ordered by precedence, so you should use &lt;code&gt;addLast()&lt;/code&gt; with &lt;code&gt;KotlinJsonAdapterFactory&lt;/code&gt;, and &lt;code&gt;add()&lt;/code&gt; with your custom adapters.&lt;/p&gt; &#xA;&lt;p&gt;The reflection adapter requires the following additional dependency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;com.squareup.moshi&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;moshi-kotlin&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;1.14.0&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;implementation(&#34;com.squareup.moshi:moshi-kotlin:1.14.0&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the reflection adapter transitively depends on the &lt;code&gt;kotlin-reflect&lt;/code&gt; library which is a 2.5 MiB .jar file.&lt;/p&gt; &#xA;&lt;h4&gt;Codegen&lt;/h4&gt; &#xA;&lt;p&gt;Moshi‚Äôs Kotlin codegen support can be used as an annotation processor (via &lt;a href=&#34;https://kotlinlang.org/docs/reference/kapt.html&#34;&gt;kapt&lt;/a&gt;) or Kotlin SymbolProcessor (&lt;a href=&#34;https://github.com/google/ksp&#34;&gt;KSP&lt;/a&gt;). It generates a small and fast adapter for each of your Kotlin classes at compile-time. Enable it by annotating each class that you want to encode as JSON:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@JsonClass(generateAdapter = true)&#xA;data class BlackjackHand(&#xA;  val hidden_card: Card,&#xA;  val visible_cards: List&amp;lt;Card&amp;gt;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The codegen adapter requires that your Kotlin types and their properties be either &lt;code&gt;internal&lt;/code&gt; or &lt;code&gt;public&lt;/code&gt; (this is Kotlin‚Äôs default visibility).&lt;/p&gt; &#xA;&lt;p&gt;Kotlin codegen has no additional runtime dependency. You‚Äôll need to enable kapt or KSP and then add the following to your build to enable the annotation processor:&lt;/p&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;KSP&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;plugins {&#xA;  id(&#34;com.google.devtools.ksp&#34;).version(&#34;1.6.10-1.0.4&#34;) // Or latest version of KSP&#xA;}&#xA;&#xA;dependencies {&#xA;  ksp(&#34;com.squareup.moshi:moshi-kotlin-codegen:1.14.0&#34;)&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Kapt&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;com.squareup.moshi&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;moshi-kotlin-codegen&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;1.14.0&amp;lt;/version&amp;gt;&#xA;  &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;kapt(&#34;com.squareup.moshi:moshi-kotlin-codegen:1.14.0&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h4&gt;Limitations&lt;/h4&gt; &#xA;&lt;p&gt;If your Kotlin class has a superclass, it must also be a Kotlin class. Neither reflection or codegen support Kotlin types with Java supertypes or Java types with Kotlin supertypes. If you need to convert such classes to JSON you must create a custom type adapter.&lt;/p&gt; &#xA;&lt;p&gt;The JSON encoding of Kotlin types is the same whether using reflection or codegen. Prefer codegen for better performance and to avoid the &lt;code&gt;kotlin-reflect&lt;/code&gt; dependency; prefer reflection to convert both private and protected properties. If you have configured both, generated adapters will be used on types that are annotated &lt;code&gt;@JsonClass(generateAdapter = true)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;Download &lt;a href=&#34;https://search.maven.org/classic/remote_content?g=com.squareup.moshi&amp;amp;a=moshi&amp;amp;v=LATEST&#34;&gt;the latest JAR&lt;/a&gt; or depend via Maven:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;com.squareup.moshi&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;moshi&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;1.14.0&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or Gradle:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;implementation(&#34;com.squareup.moshi:moshi:1.14.0&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Snapshots of the development version are available in &lt;a href=&#34;https://oss.sonatype.org/content/repositories/snapshots/com/squareup/moshi/&#34;&gt;Sonatype&#39;s &lt;code&gt;snapshots&lt;/code&gt; repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;R8 / ProGuard&lt;/h2&gt; &#xA;&lt;p&gt;Moshi contains minimally required rules for its own internals to work without need for consumers to embed their own. However if you are using reflective serialization and R8 or ProGuard, you must add keep rules in your proguard configuration file for your reflectively serialized classes.&lt;/p&gt; &#xA;&lt;h4&gt;Enums&lt;/h4&gt; &#xA;&lt;p&gt;Annotate enums with &lt;code&gt;@JsonClass(generateAdapter = false)&lt;/code&gt; to prevent them from being removed/obfuscated from your code by R8/ProGuard.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright 2015 Square, Inc.&#xA;&#xA;Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);&#xA;you may not use this file except in compliance with the License.&#xA;You may obtain a copy of the License at&#xA;&#xA;   http://www.apache.org/licenses/LICENSE-2.0&#xA;&#xA;Unless required by applicable law or agreed to in writing, software&#xA;distributed under the License is distributed on an &#34;AS IS&#34; BASIS,&#xA;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xA;See the License for the specific language governing permissions and&#xA;limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>