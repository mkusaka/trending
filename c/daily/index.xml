<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-05T01:24:18Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hannorein/rebound</title>
    <updated>2024-04-05T01:24:18Z</updated>
    <id>tag:github.com,2024-04-05:/hannorein/rebound</id>
    <link href="https://github.com/hannorein/rebound" rel="alternate"></link>
    <summary type="html">&lt;p&gt;💫 An open-source multi-purpose N-body code.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://rebound.readthedocs.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/rebound-v4.3.2-green.svg?style=flat&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://badge.fury.io/py/rebound&#34;&gt;&lt;img src=&#34;https://badge.fury.io/py/rebound.svg?sanitize=true&#34; alt=&#34;PyPI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/hannorein/rebound/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL-green.svg?style=flat&#34; alt=&#34;GPL&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/1110.4876&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/arXiv-1110.4876-green.svg?style=flat&#34; alt=&#34;Paper&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/1409.4779&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/arXiv-1409.4779-green.svg?style=flat&#34; alt=&#34;Paper&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/1506.01084&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/arXiv-1506.01084-green.svg?style=flat&#34; alt=&#34;Paper&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/1603.03424&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/arXiv-1603.03424-green.svg?style=flat&#34; alt=&#34;Paper&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/1701.07423&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/arXiv-1701.07423-green.svg?style=flat&#34; alt=&#34;Paper&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/1704.07715&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/arXiv-1704.07715-green.svg?style=flat&#34; alt=&#34;Paper&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/1903.04972&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/arXiv-1903.04972-green.svg?style=flat&#34; alt=&#34;Paper&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/1907.11335&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/arXiv-1907.11335-green.svg?style=flat&#34; alt=&#34;Paper&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://rebound.readthedocs.io/en/latest/?badge=latest&#34;&gt;&lt;img src=&#34;https://readthedocs.org/projects/rebound/badge/?version=latest&#34; alt=&#34;Docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mybinder.org/v2/gh/hannorein/rebound/main&#34;&gt;&lt;img src=&#34;https://mybinder.org/badge_logo.svg?sanitize=true&#34; alt=&#34;Binder&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/hannorein/rebound/actions/workflows/c.yml&#34;&gt;&lt;img src=&#34;https://github.com/hannorein/rebound/actions/workflows/c.yml/badge.svg?sanitize=true&#34; alt=&#34;REBOUND (C)&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/hannorein/rebound/actions/workflows/python.yml&#34;&gt;&lt;img src=&#34;https://github.com/hannorein/rebound/actions/workflows/python.yml/badge.svg?sanitize=true&#34; alt=&#34;REBOUND (python)&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Welcome to REBOUND&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/hannorein/rebound/raw/main/docs/img/reboundbanner.png&#34; alt=&#34;REBOUND Examples&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;REBOUND is an N-body integrator, i.e. a software package that can integrate the motion of particles under the influence of gravity. The particles can represent stars, planets, moons, ring or dust particles. REBOUND is very flexible and can be customized to accurately and efficiently solve many problems in astrophysics.&lt;/p&gt; &#xA;&lt;h2&gt;REBOUND 24 Meeting&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/hannorein/rebound/raw/main/docs/img/reb24flyer.png&#34; alt=&#34;REBOUND 24 Virtual Meeting&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Join us for the first virtual 2-day REBOUND meeting, aimed to bring REBOUND developers and users together. 1 day of science talks, 1 day of technical/hands-on talks, discussions on REBOUND&#39;s future + social events!&lt;/p&gt; &#xA;&lt;p&gt;Abstract submission and registration are now open at &lt;a href=&#34;https://hannorein.github.io/rebound24/&#34;&gt;https://hannorein.github.io/rebound24/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No dependencies on external libraries.&lt;/li&gt; &#xA; &lt;li&gt;Runs natively on Linux, MacOS, and Windows.&lt;/li&gt; &#xA; &lt;li&gt;Symplectic integrators WHFast, SEI, LEAPFROG, EOS.&lt;/li&gt; &#xA; &lt;li&gt;Hybrid symplectic integrators for planetary dynamics with close encounters MERCURIUS&lt;/li&gt; &#xA; &lt;li&gt;High order symplectic integrators for integrating planetary systems SABA, WH Kernel methods.&lt;/li&gt; &#xA; &lt;li&gt;High accuracy non-symplectic integrator with adaptive time-stepping IAS15.&lt;/li&gt; &#xA; &lt;li&gt;Can integrate arbitrary user-defined ODEs that are coupled to N-body dynamics for tides, spin, etc&lt;/li&gt; &#xA; &lt;li&gt;Support for collisional/granular dynamics, various collision detection routines&lt;/li&gt; &#xA; &lt;li&gt;The computationally intensive parts of the code are written entirely in C, conforming to the ISO standard C99, and can be used as a thread-safe shared library&lt;/li&gt; &#xA; &lt;li&gt;Easy-to-use Python module, installation in 3 words: &lt;code&gt;pip install rebound&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Real-time, 3D visualization, for both C and Python.&lt;/li&gt; &#xA; &lt;li&gt;Extensive set of example problems for both C and Python. You can run examples directly from your browser without the need to download or install anything.&lt;/li&gt; &#xA; &lt;li&gt;Parallelized WHFast512 integrator for super fast integrations of planetary systems with SIMD AVX512 instructions&lt;/li&gt; &#xA; &lt;li&gt;Parallelized with OpenMP (for shared memory systems)&lt;/li&gt; &#xA; &lt;li&gt;Parallelized with MPI is supported for some special use cases only (using an essential tree for gravity and collisions)&lt;/li&gt; &#xA; &lt;li&gt;The code is 100% open-source. All features are included in the public repository on github.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Try out REBOUND&lt;/h2&gt; &#xA;&lt;p&gt;You can try out REBOUND without installing it. Simply head over to &lt;a href=&#34;https://rebound.readthedocs.io/en/latest/examples/&#34;&gt;readthedocs.org&lt;/a&gt;. All the C examples have been compiled with emscripten and can run directly in your browser.&lt;/p&gt; &#xA;&lt;h2&gt;One minute installation&lt;/h2&gt; &#xA;&lt;p&gt;You can install REBOUND with pip if you want to only use the python version of REBOUND:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install rebound&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can run a simple REBOUND simulation such as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import rebound&#xA;sim = rebound.Simulation()&#xA;sim.add(m=1.0)&#xA;sim.add(m=1.0e-3, a=1.0)&#xA;sim.integrate(1000.)&#xA;sim.status()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use the C version of REBOUND simply copy and paste this line into your terminal (it won&#39;t do anything bad, we promise):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/hannorein/rebound &amp;amp;&amp;amp; cd rebound/examples/shearing_sheet &amp;amp;&amp;amp; make &amp;amp;&amp;amp; ./rebound&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The full documentation with many examples, changelogs and tutorials can be found at&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rebound.readthedocs.org&#34;&gt;https://rebound.readthedocs.org&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you have trouble installing or using REBOUND, please open an issue on github and we&#39;ll try to help as much as we can.&lt;/p&gt; &#xA;&lt;p&gt;There are also short YouTube videos describing various aspects of REBOUND available at &lt;a href=&#34;https://www.youtube.com/channel/UCNmrCzxcmWVTBwtDPPLxkkw&#34;&gt;https://www.youtube.com/channel/UCNmrCzxcmWVTBwtDPPLxkkw&lt;/a&gt; .&lt;/p&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;h3&gt;Additional physics&lt;/h3&gt; &#xA;&lt;p&gt;To easily incorporate additional physics modules such as migration forces, GR effects and spin into your REBOUND simulations, see REBOUNDx at &lt;a href=&#34;https://github.com/dtamayo/reboundx&#34;&gt;https://github.com/dtamayo/reboundx&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Analytical and semianalytical tools&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re interested in comparing numerical simulations to analytical and semianalytical tools for celestial mechanics, see Celmech at &lt;a href=&#34;https://github.com/shadden/celmech&#34;&gt;https://github.com/shadden/celmech&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Ephemeris-quality integrations of test particles&lt;/h3&gt; &#xA;&lt;p&gt;To generate ephemeris-quality integrations of test particles in the Solar System with a precision on par with JPL&#39;s small body integrator, see ASSIST at &lt;a href=&#34;https://github.com/matthewholman/assist&#34;&gt;https://github.com/matthewholman/assist&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Papers&lt;/h2&gt; &#xA;&lt;p&gt;There are several papers describing the functionality of REBOUND.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Rein &amp;amp; Liu 2012 (Astronomy and Astrophysics, Volume 537, A128) describes the code structure and the main feature including the gravity and collision routines for many particle systems. &lt;a href=&#34;http://adsabs.harvard.edu/abs/2012A%26A...537A.128R&#34;&gt;http://adsabs.harvard.edu/abs/2012A%26A...537A.128R&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rein &amp;amp; Tremaine 2011 (Monthly Notices of the Royal Astronomical Society, Volume 415, Issue 4, pp. 3168-3176) describes the Symplectic Epicycle integrator for shearing sheet simulations. &lt;a href=&#34;https://ui.adsabs.harvard.edu/abs/2011MNRAS.415.3168R&#34;&gt;https://ui.adsabs.harvard.edu/abs/2011MNRAS.415.3168R&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rein &amp;amp; Spiegel 2015 (Monthly Notices of the Royal Astronomical Society, Volume 446, Issue 2, p.1424-1437) describes the versatile high order integrator IAS15 which is now part of REBOUND. &lt;a href=&#34;http://adsabs.harvard.edu/abs/2015MNRAS.446.1424R&#34;&gt;http://adsabs.harvard.edu/abs/2015MNRAS.446.1424R&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rein &amp;amp; Tamayo 2015 (Monthly Notices of the Royal Astronomical Society, Volume 452, Issue 1, p.376-388) describes WHFast, the fast and unbiased implementation of a symplectic Wisdom-Holman integrator for long term gravitational simulations. &lt;a href=&#34;http://adsabs.harvard.edu/abs/2015MNRAS.452..376R&#34;&gt;http://adsabs.harvard.edu/abs/2015MNRAS.452..376R&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rein &amp;amp; Tamayo 2016 (Monthly Notices of the Royal Astronomical Society, Volume 459, Issue 3, p.2275-2285) develop the framework for second order variational equations. &lt;a href=&#34;https://ui.adsabs.harvard.edu/abs/2016MNRAS.459.2275R&#34;&gt;https://ui.adsabs.harvard.edu/abs/2016MNRAS.459.2275R&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rein &amp;amp; Tamayo 2017 (Monthly Notices of the Royal Astronomical Society, Volume 467, Issue 2, p.2377-2383) describes the Simulationarchive for exact reproducibility of N-body simulations. &lt;a href=&#34;https://ui.adsabs.harvard.edu/abs/2017MNRAS.467.2377R&#34;&gt;https://ui.adsabs.harvard.edu/abs/2017MNRAS.467.2377R&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rein &amp;amp; Tamayo 2018 (Monthly Notices of the Royal Astronomical Society, Volume 473, Issue 3, p.3351–3357) describes the integer based JANUS integrator. &lt;a href=&#34;https://ui.adsabs.harvard.edu/abs/2018MNRAS.473.3351R&#34;&gt;https://ui.adsabs.harvard.edu/abs/2018MNRAS.473.3351R&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rein, Hernandez, Tamayo, Brown, Eckels, Holmes, Lau, Leblanc &amp;amp; Silburt 2019 (Monthly Notices of the Royal Astronomical Society, Volume 485, Issue 4, p.5490-5497) describes the hybrid symplectic integrator MERCURIUS. &lt;a href=&#34;https://ui.adsabs.harvard.edu/abs/2019MNRAS.485.5490R&#34;&gt;https://ui.adsabs.harvard.edu/abs/2019MNRAS.485.5490R&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rein, Tamayo &amp;amp; Brown 2019 (Monthly Notices of the Royal Astronomical Society, Volume 489, Issue 4, November 2019, Pages 4632-4640) describes the implementation of the high order symplectic integrators SABA, SABAC, SABACL, WHCKL, WHCKM, and WHCKC. &lt;a href=&#34;https://ui.adsabs.harvard.edu/abs/&#34;&gt;https://ui.adsabs.harvard.edu/abs/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;If you use this code or parts of this code for results presented in a scientific publication, we would greatly appreciate a citation. please cite REBOUND. The simplest way to find the citations relevant to the specific setup of your REBOUND simulation is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sim = rebound.Simulation()&#xA;-your setup-&#xA;sim.cite()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Hanno Rein, University of Toronto, &lt;a href=&#34;mailto:hanno@hanno-rein.de&#34;&gt;hanno@hanno-rein.de&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Dan Tamayo, Harvey Mudd College, &lt;a href=&#34;mailto:dtamayo@hmc.edu&#34;&gt;dtamayo@hmc.edu&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;David S. Spiegel, Institute for Advanced Study Princeton, &lt;a href=&#34;mailto:dave@ias.edu&#34;&gt;dave@ias.edu&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Garett Brown, University of Toronto, &lt;a href=&#34;mailto:garett.brown@mail.utoronto.ca&#34;&gt;garett.brown@mail.utoronto.ca&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Shangfei Liu, Kavli Institute for Astronomy and Astrophysics at Peking University, &lt;a href=&#34;mailto:liushangfei@pku.edu.cn&#34;&gt;liushangfei@pku.edu.cn&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Ari Silburt, Penn State University, &lt;a href=&#34;mailto:ajs725@psu.edu&#34;&gt;ajs725@psu.edu&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;and many others! Check the git history to find out who contributed to the code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;REBOUND is open source and you are invited to contribute to this project!&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;REBOUND is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.&lt;/p&gt; &#xA;&lt;p&gt;REBOUND is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.&lt;/p&gt; &#xA;&lt;p&gt;You should have received a copy of the GNU General Public License along with REBOUND. If not, see &lt;a href=&#34;http://www.gnu.org/licenses/&#34;&gt;http://www.gnu.org/licenses/&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>renderlet/wander</title>
    <updated>2024-04-05T01:24:18Z</updated>
    <id>tag:github.com,2024-04-05:/renderlet/wander</id>
    <link href="https://github.com/renderlet/wander" rel="alternate"></link>
    <summary type="html">&lt;p&gt;wander - the Wasm Renderer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;wander - the Wasm Renderer&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/renderlet/wander/main/docs/wander-light.svg#gh-light-mode-only&#34; alt=&#34;logo light&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/renderlet/wander/main/docs/wander-dark.svg#gh-dark-mode-only&#34; alt=&#34;logo dark&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;wander&lt;/code&gt; is a GPU-based rendering framework designed to be fully embeddable in any application.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;wander&lt;/code&gt; to run &lt;code&gt;renderlets&lt;/code&gt; in any software - self contained, portable modules of graphics data and code compiled to WebAssembly.&lt;/p&gt; &#xA;&lt;h2&gt;What can this do?&lt;/h2&gt; &#xA;&lt;p&gt;With renderlet, developers can build modern, interactive visualizations that run on any platform.&lt;/p&gt; &#xA;&lt;p&gt;Many visual apps need a high-performance rendering engine that works in a browser or in a native app, where a JavaScript library won&#39;t scale, but a game engine is not the right application model.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;wander&lt;/code&gt; is designed to be a rendering engine for any high-performance application. It primarily is designed as the runtime to run &lt;code&gt;renderlet&lt;/code&gt; bundles, but also can be used more generically as a WebAssembly-based rendering engine that uses the GPU.&lt;/p&gt; &#xA;&lt;h3&gt;What are renderlets?&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;wander&lt;/code&gt; SDK brings all of the benefits of &lt;code&gt;renderlets&lt;/code&gt; into your own application:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;High performance 2D and 3D graphics&lt;/li&gt; &#xA; &lt;li&gt;Fully portable rendering pipelines &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Any app, device, client, or server&lt;/li&gt; &#xA;   &lt;li&gt;Sandboxed third party code execution&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Self contained rendering modules &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Reuse your graphics code as building blocks&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;No game engine / platform dependencies&lt;/li&gt; &#xA; &lt;li&gt;No GPU expertise required&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Example use-cases&lt;/h3&gt; &#xA;&lt;p&gt;Use &lt;code&gt;wander&lt;/code&gt; to build things like:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Modern CAD Apps: Use code to allow objects to describe how to render themselves&lt;/li&gt; &#xA; &lt;li&gt;Procedural Modeling and DataViz: Execute runtime code to view your data in new ways&lt;/li&gt; &#xA; &lt;li&gt;Product Visualization: Interact with dynamic objects in 3D on any device&lt;/li&gt; &#xA; &lt;li&gt;Composable User Interfaces: Render any UI module on top of an existing canvas or in any scene&lt;/li&gt; &#xA; &lt;li&gt;Interactive Animations: Like Adobe Flash, but with an actual programming language and GPUs&lt;/li&gt; &#xA; &lt;li&gt;Low/No-Code Graphics: Make a graphics pipelines out of existing building blocks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Platform Support&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;API&lt;/th&gt; &#xA;   &lt;th&gt;Windows&lt;/th&gt; &#xA;   &lt;th&gt;Linux/Android&lt;/th&gt; &#xA;   &lt;th&gt;macOS/iOS&lt;/th&gt; &#xA;   &lt;th&gt;Web (wasm)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OpenGL&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✅&lt;/span&gt; (GL 3.3)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;🛠&lt;/span&gt; (GL ES 3.0+)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✅&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;📐&lt;/span&gt; (WebGL2)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DX11&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✅&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DX12&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;🛠&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;WebGPU&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;🛠&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Vulkan&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;📐&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;📐&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;📐&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Metal&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;📐&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;span&gt;✅&lt;/span&gt; = Currently supported &lt;span&gt;🛠&lt;/span&gt; = In progress, coming soon &lt;span&gt;📐&lt;/span&gt; = In design or planned for the future&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;wander&lt;/code&gt; is delivered as a cross-platform C++ library. Simply add wander.h/wander.cpp to your build chain along with the included dependencies such as &lt;code&gt;wasmtime&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The basic API flow is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;const auto pal = wander::Factory::CreatePal(&#xA;        wander::EPalType::D3D11, baseDevice, baseDeviceContext);&#xA;auto runtime = wander::Factory::CreateRuntime(pal);&#xA;&#xA;auto renderlet_id = runtime-&amp;gt;LoadFromFile(L&#34;Building.wasm&#34;, &#34;run&#34;);&#xA;&#xA;auto tree_id = runtime-&amp;gt;Render(renderlet_id);&#xA;auto tree = runtime-&amp;gt;GetRenderTree(tree_id);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a PAL object based on your device&#39;s underlying GPU API&lt;/li&gt; &#xA; &lt;li&gt;Create a global &lt;code&gt;runtime&lt;/code&gt; object. This is not currently thread safe&lt;/li&gt; &#xA; &lt;li&gt;Load a &lt;code&gt;renderlet&lt;/code&gt; file (with an optional entry point name) and get it ready to run&lt;/li&gt; &#xA; &lt;li&gt;Run it! For static content this can be done once, but dynamic content could be per frame&lt;/li&gt; &#xA; &lt;li&gt;Get a (non-owning) pointer to the output&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Drawing the data is as simple as iterating the render tree:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;deviceContext-&amp;gt;PSSetShaderResources(0, 1, &amp;amp;textureViewWhite);&#xA;&#xA;for (auto i = 0; i &amp;lt; tree-&amp;gt;Length(); ++i)&#xA;{&#xA;    tree-&amp;gt;NodeAt(i)-&amp;gt;RenderFixedStride(runtime, stride);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s no need to manage the underlying graphics data / buffers - &lt;code&gt;wander&lt;/code&gt; takes care of it.&lt;/p&gt; &#xA;&lt;p&gt;To delete/free old content, simple call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;runtime-&amp;gt;DestroyRenderTree(tree_id);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, wander can tear down every object automatically on unload or close:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;runtime-&amp;gt;Release();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;Examples are provided in the &lt;a href=&#34;https://raw.githubusercontent.com/renderlet/wander/main/examples/&#34;&gt;examples folder&lt;/a&gt; for D3D11 and OpenGL 3.3 (Mac/Windows/Linux).&lt;/p&gt; &#xA;&lt;p&gt;CMake support is not yet implmented, but you can follow platform-specific examples below to integrate into your own app.&lt;/p&gt; &#xA;&lt;h4&gt;rive-renderer integration&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;wander&lt;/code&gt; has experimental support for 2D vector operations using &lt;a href=&#34;https://github.com/rive-app/rive-renderer&#34;&gt;&lt;code&gt;rive-renderer&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Currently this is only supported in the Windows / Direct3D11 backend. We are working on a &lt;code&gt;WebGPU&lt;/code&gt; build, and MacOS will require us to implement a &lt;code&gt;Metal&lt;/code&gt; backend.&lt;/p&gt; &#xA;&lt;p&gt;It is non-trivial to build &lt;code&gt;rive-renderer&lt;/code&gt; on Windows. We have provided a GitHub release with precompiled binaries / .lib files in &lt;a href=&#34;https://raw.githubusercontent.com/renderlet/wander/main/examples/DX11&#34;&gt;the D3D11 example&lt;/a&gt;. If you want to build yourself, here&#39;s some tips:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Ensure you have a &lt;code&gt;MinGW&lt;/code&gt; toolchain installed&lt;/li&gt; &#xA; &lt;li&gt;Clone this repo with &lt;code&gt;--recurvsive&lt;/code&gt; - &lt;code&gt;rive-renderer&lt;/code&gt; will be subbomduled in &lt;code&gt;libs&lt;/code&gt;, and will have &lt;code&gt;rive-cpp&lt;/code&gt; submoduled in &lt;code&gt;libs/rive-renderer/submodules/rive-cpp&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Follow the basic instructions using &lt;code&gt;MinGW&lt;/code&gt; for commands in the &lt;code&gt;README&lt;/code&gt; for &lt;code&gt;rive-renderer&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;You may manually have to run CMake for glfw: &lt;code&gt;cmake ../glfw -DBUILD_SHARED_LIBS=OFF -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded -DGLFW_BUILD_WAYLAND=OFF -A x64&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;For premake, &lt;code&gt;set PREMAKE_PATH=&amp;lt;path&amp;gt;wander\libs\rive-renderer\submodules\rive-cpp\build&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Then, &lt;code&gt;premake5 vs2022 --toolset=msc --with_rive_text --config=release --out=out/release&lt;/code&gt; (or debug)&lt;/li&gt; &#xA; &lt;li&gt;Open the output &lt;code&gt;rive.sln&lt;/code&gt;, and switch every project to &lt;code&gt;MD&lt;/code&gt; / &lt;code&gt;MDd&lt;/code&gt; to match most apps&lt;/li&gt; &#xA; &lt;li&gt;For &lt;code&gt;path_fiddle&lt;/code&gt;, upgrade to C++20 and on linker and C++ settings disable warnings as errors (&lt;code&gt;/WX-&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Now build all in Visual Studio or via MSBuild - the DX11 example will automatically pull from the submodule paths&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To use this, &lt;code&gt;RLT_RIVE&lt;/code&gt; globally in your project (the DX11 example does this automatically in the Release build), and &lt;code&gt;wander&lt;/code&gt; will automatically link to the output &lt;code&gt;.lib&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;p&gt;You can read more about the &lt;code&gt;rive-renderer&lt;/code&gt; &lt;a href=&#34;https://github.com/renderlet/wander/wiki/Using-renderlet-with-rive%E2%80%90renderer&#34;&gt;integration here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/renderlet/wander/raw/main/docs/wiki/vector-static.gif&#34; alt=&#34;animated&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Building the Examples&lt;/h4&gt; &#xA;&lt;h5&gt;On Windows&lt;/h5&gt; &#xA;&lt;p&gt;Ensure you have the latest Visual Studio 2022 and Windows 11 SDK, and use the &lt;code&gt;Examples.sln&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The DX11 example includes experimental &lt;code&gt;rive-renderer&lt;/code&gt; support for 2D vectors.&lt;/p&gt; &#xA;&lt;h5&gt;On OSX&lt;/h5&gt; &#xA;&lt;p&gt;Ensure you have a working &lt;code&gt;clang&lt;/code&gt; installation, then simply use the &lt;a href=&#34;https://raw.githubusercontent.com/renderlet/wander/main/examples/OpenGL/Makefile&#34;&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This should produce a new &lt;code&gt;opengl&lt;/code&gt; binary under &lt;code&gt;/src/examples/OpenGL&lt;/code&gt; and run it with the default scene.&lt;/p&gt; &#xA;&lt;h5&gt;On Linux&lt;/h5&gt; &#xA;&lt;p&gt;First, build the build container. From the repository root:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;podman build -t wander/buildimage -f ./Dockerfile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, use this container to build or rebuild the examples. To build the OpenGL example on Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;podman run --mount=type=bind,source=&#34;$(pwd)&#34;,target=/src,relabel=shared,U=true -w /src/examples/OpenGL wander/buildimage make buildlinux&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This should produce a new &lt;code&gt;opengl&lt;/code&gt; binary under &lt;code&gt;/src/examples/OpenGL&lt;/code&gt;. Take a look at the &lt;code&gt;Makefile&lt;/code&gt; for more info.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;span&gt;⚠&lt;/span&gt; Building renderlets&lt;/h3&gt; &#xA;&lt;p&gt;An example &lt;code&gt;renderlet&lt;/code&gt; is provided in the examples - a 3D procedural model of a building - &lt;code&gt;building.wasm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We are currently working on a compiler and tool to make it easy to build your own renderlets.&lt;/p&gt; &#xA;&lt;p&gt;If you want to experiment with building your own through raw wasm code, the wire format and signatures &lt;a href=&#34;https://github.com/renderlet/wander/raw/e86d549606e24a04ae4b25544336b2744aec4ce0/wander.cpp#L331&#34;&gt;can be found here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This format can and will change over time, so please only experiment with this if you are ok with breaking your renderlet on upgrade!&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Supported&lt;/th&gt; &#xA;   &lt;th&gt;Coming Soon&lt;/th&gt; &#xA;   &lt;th&gt;Future&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Untyped buffers&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✅&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Vertex buffers&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✅&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Geometry/Mesh support&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✅&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Materials&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;✅&lt;/span&gt; (*)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Index buffers&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;🛠&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Texture data&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;🛠&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CMake / x-platform build&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;🛠&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C API / other langs&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;🛠&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Buffer format specs&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;📐&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Dynamic render trees&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;📐&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Conditional rendering&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;📐&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Shaders&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;📐&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Distributed GPU compute&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;📐&lt;/span&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Web build&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;🛠&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Renderlet compiler toolset &lt;br&gt;(easily build your own renderlets)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;🛠&lt;/span&gt; (*)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;*unstable API&lt;/p&gt; &#xA;&lt;p&gt;Feature requests welcome, please submit an issue!&lt;/p&gt; &#xA;&lt;h2&gt;Architecture / Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;Current (V1) architecture allows arbitray data to be generated on the CPU in Wasm which is automatically uploaded to the GPU via the &lt;code&gt;wander&lt;/code&gt; SDK through the PAL.&lt;/p&gt; &#xA;&lt;p&gt;The host app must know the &#34;shape&#34; of the data and bind a shader stage to the host graphics API to render the geometry / texture data to the Canvas.&lt;/p&gt; &#xA;&lt;p&gt;Example - CAD, where arbitrary parts can generate geometry of a known format that the host app has the capability to shade&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/renderlet/wander/main/docs/v1-light.png#gh-light-mode-only&#34; alt=&#34;v1 light&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/renderlet/wander/main/docs/v1-dark.png#gh-dark-mode-only&#34; alt=&#34;v1 dark&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Future (V2) architecture allows arbitrary data to be fully rendered to an application&#39;s back buffer / canvas via an attachment to the graphics API exposed to Wasm.&lt;/p&gt; &#xA;&lt;p&gt;V2 will enable fully arbitrary rendering of any data onto any Canvas. V2 has a dependency on the upcoming &lt;code&gt;wasi-gpu&lt;/code&gt; spec.&lt;/p&gt; &#xA;&lt;p&gt;Example - Full 3rd-party UGC/Content - Rendering arbitrary 2D gauges (like Flash) / 3D content (avatars) onto an existing Canvas layer in an app&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/renderlet/wander/main/docs/v2-light.png#gh-light-mode-only&#34; alt=&#34;v2 light&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/renderlet/wander/main/docs/v2-dark.png#gh-dark-mode-only&#34; alt=&#34;v2 dark&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>