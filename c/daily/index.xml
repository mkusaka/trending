<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-13T01:32:47Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>xiph/flac</title>
    <updated>2022-09-13T01:32:47Z</updated>
    <id>tag:github.com,2022-09-13:/xiph/flac</id>
    <link href="https://github.com/xiph/flac" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Free Lossless Audio Codec&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Free Lossless Audio Codec (FLAC)&lt;/h1&gt; &#xA;&lt;p&gt;FLAC is open source software that can reduce the amount of storage space needed to store digital audio signals without needing to remove information in doing so.&lt;/p&gt; &#xA;&lt;p&gt;The files read and produced by this software are called FLAC files. As these files (which follow the &lt;a href=&#34;https://xiph.org/flac/format.html&#34;&gt;FLAC format&lt;/a&gt;) can be read from and written to by other software as well, this software is often referred to as the FLAC reference implementation.&lt;/p&gt; &#xA;&lt;p&gt;FLAC has been developed by volunteers. If you want to help out, see CONTRIBUTING.md for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Components&lt;/h2&gt; &#xA;&lt;p&gt;FLAC is comprised of&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;libFLAC, a library which implements reference encoders and decoders for native FLAC and Ogg FLAC, and a metadata interface&lt;/li&gt; &#xA; &lt;li&gt;libFLAC++, a C++ object wrapper library around libFLAC&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;flac&lt;/code&gt;, a command-line program for encoding and decoding files&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;metaflac&lt;/code&gt;, a command-line program for viewing and editing FLAC metadata&lt;/li&gt; &#xA; &lt;li&gt;player plugin for XMMS&lt;/li&gt; &#xA; &lt;li&gt;user and API documentation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The libraries (libFLAC, libFLAC++) are licensed under Xiph.org&#39;s BSD-like license (see COPYING.Xiph). All other programs and plugins are licensed under the GNU General Public License (see COPYING.GPL). The documentation is licensed under the GNU Free Documentation License (see COPYING.FDL).&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;For documentation of the &lt;code&gt;flac&lt;/code&gt; and &lt;code&gt;metaflac&lt;/code&gt; command line tools, see the directory man, which contains the files flac.md and metaflac.md&lt;/p&gt; &#xA;&lt;p&gt;The API documentation is in html and is generated by Doxygen. It can be found in the directory doc/html/api. It is included in a release tarball and must be build with Doxygen when the source is taken directly from git.&lt;/p&gt; &#xA;&lt;p&gt;The directory examples contains example source code on using libFLAC and libFLAC++.&lt;/p&gt; &#xA;&lt;p&gt;Documentation concerning the FLAC format itself (which can be used to create software reading and writing FLAC software independent from libFLAC) was included in previous releases, but can now be found on &lt;a href=&#34;https://datatracker.ietf.org/doc/draft-ietf-cellar-flac/&#34;&gt;https://datatracker.ietf.org/doc/draft-ietf-cellar-flac/&lt;/a&gt; Additionally a set of files for conformance testing called the FLAC decoder testbench can be found at &lt;a href=&#34;https://github.com/ietf-wg-cellar/flac-test-files&#34;&gt;https://github.com/ietf-wg-cellar/flac-test-files&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you have questions about FLAC that this document does not answer, please submit them at the following tracker so this document can be improved:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/xiph/flac/issues&#34;&gt;https://github.com/xiph/flac/issues&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Building FLAC&lt;/h2&gt; &#xA;&lt;p&gt;All components of the FLAC project can be build with a variety of compilers (including GCC, Clang, Visual Studio, Intel C++ Compiler) on many architectures (inluding x86, x86_64, ARMv7, ARMv8 and PowerPC) for many different operating systems.&lt;/p&gt; &#xA;&lt;p&gt;To do this, FLAC provides two build systems: one using GNU&#39;s autotools and one with CMake. Both differ slighly in configuration options, but should be considered equivalent for most use cases.&lt;/p&gt; &#xA;&lt;p&gt;FLAC used to provide files specifically for building with Visual Studio, but these have been removed in favor of using CMake.&lt;/p&gt; &#xA;&lt;h2&gt;Building with CMake&lt;/h2&gt; &#xA;&lt;p&gt;CMake is a cross-platform build system. FLAC can be built on Windows, Linux, Mac OS X using CMake.&lt;/p&gt; &#xA;&lt;p&gt;You can use either CMake&#39;s CLI or GUI. We recommend you to have a separate build folder outside the repository in order to not spoil it with generated files. It is possible however to do a so-called in-tree build, in that case /path/to/flac-build in the following examples is equal to /path/to/flac-source.&lt;/p&gt; &#xA;&lt;h3&gt;CMake CLI&lt;/h3&gt; &#xA;&lt;p&gt;Go to your build folder and run something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or e.g. in Windows shell&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;C:\path\to\flac-build&amp;gt; cmake \path\to\flac-source&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(provided that cmake is in your %PATH% variable)&lt;/p&gt; &#xA;&lt;p&gt;That will generate build scripts for the default build system (e.g. Makefiles for UNIX). After that you start build with a command like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And afterwards you can run tests or install the built libraries and headers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ make test&#xA;/path/to/flac-build$ make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want use a build system other than default add -G flag to cmake, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source -GNinja&#xA;/path/to/flac-build$ ninja&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source -GXcode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use cmake --help to see the list of available generators.&lt;/p&gt; &#xA;&lt;p&gt;By default CMake will search for OGG. If CMake fails to find it you can help CMake by specifying the exact path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source -DOGG_ROOT=/path/to/ogg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you would like CMake to build OGG alongside FLAC, you can place the ogg sources directly in the flac source directory as a subdirectory with the name ogg, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-source/ogg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t want to build flac with OGG support you can tell CMake not to look for OGG:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source -DWITH_OGG=OFF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other FLAC&#39;s options (e.g. building C++ lib or docs) can also be put to cmake through -D flag. If you want to know what options are available, use -LH:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/path/to/flac-build$ cmake /path/to/flac-source -LH&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CMake GUI (for Visual Studio)&lt;/h3&gt; &#xA;&lt;p&gt;It is likely that you would prefer to use the CMake GUI if you use Visual Studio to build FLAC. It&#39;s in essence the same process as building using CLI.&lt;/p&gt; &#xA;&lt;p&gt;Open cmake-gui. In the window select a source directory (the repository&#39;s root), a build directory (some other directory outside the repository). Then press button &#34;Configure&#34;. CMake will ask you which build system you prefer. Choose that version of Visual Studio which you have on your system, choose whether you want to build for Win32 or x64. Press OK.&lt;/p&gt; &#xA;&lt;p&gt;After CMake finishes you can change the configuration to your liking and if you change anything, run Configure again. With the &#34;Generate&#34; button, CMake creates Visual Studio files, which can be opened from Visual Studio. With the button &#34;Open Project&#34; CMake will launch Visual Studio and open the generated solution. You can use the project files as usual but remember that they were generated by CMake. That means that your changes (e.g. some additional compile flags) will be lost when you run CMake next time.&lt;/p&gt; &#xA;&lt;p&gt;CMake searches by default for OGG on your system and returns an error if it cannot find it. If you want to build OGG alongside FLAC, you can download the OGG sources and extract them in a subdirectory of the FLAC source directory with the name ogg (i.e. /path/to/flac-source/ogg) before running CMake. If you don&#39;t want to build FLAC with OGG support, untick the box following WITH_OGG flag in the list of variables in cmake-gui window and run &#34;Configure&#34; again.&lt;/p&gt; &#xA;&lt;p&gt;If CMake fails to find MSVC compiler then running cmake-gui from MS Developer comand prompt should help.&lt;/p&gt; &#xA;&lt;h2&gt;Building with GNU autotools&lt;/h2&gt; &#xA;&lt;p&gt;FLAC uses autoconf and libtool for configuring and building. To configure a build, open a commmand line/terminal and run &lt;code&gt;./configure&lt;/code&gt; You can provide options to this command, which are listed by running &lt;code&gt;./configure --help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In case the configure script is not present (for example when building from git and not from a release tarball), it can be generated by running &lt;code&gt;./autogen.sh&lt;/code&gt;. This may require a libtool development package though.&lt;/p&gt; &#xA;&lt;p&gt;After configuration, build with &lt;code&gt;make&lt;/code&gt;, verify the build with &lt;code&gt;make check&lt;/code&gt; and install with &lt;code&gt;make install&lt;/code&gt;. Installation might require administrator priviledged, i.e. &lt;code&gt;sudo make install&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &#39;make check&#39; step is optional; omit it to skip all the tests, which can take about an hour to complete. Even though it will stop with an explicit message on any failure, it does print out a lot of stuff so you might want to capture the output to a file if you&#39;re having a problem. Also, don&#39;t run &#39;make check&#39; as root because it confuses some of the tests.&lt;/p&gt; &#xA;&lt;p&gt;Summarizing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./configure&#xA;make &amp;amp;&amp;amp; make check&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Note to embedded developers&lt;/h2&gt; &#xA;&lt;p&gt;libFLAC has grown larger over time as more functionality has been included, but much of it may be unnecessary for a particular embedded implementation. Unused parts may be pruned by some simple editing of configure.ac and src/libFLAC/Makefile.am; the following dependency graph shows which modules may be pruned without breaking things further down:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;metadata.h&#xA;    stream_decoder.h&#xA;    format.h&#xA;&#xA;stream_encoder.h&#xA;    stream_decoder.h&#xA;    format.h&#xA;&#xA;stream_decoder.h&#xA;    format.h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In other words, for pure decoding applications, both the stream encoder and metadata editing interfaces can be safely removed. Note that this is specific to building the libraries for embedded use. The command line tools do not provide such compartmentalization, and require a complete libFLAC build to function.&lt;/p&gt; &#xA;&lt;p&gt;There is a section dedicated to embedded use in the libFLAC API HTML documentation (see doc/html/api/index.html).&lt;/p&gt; &#xA;&lt;p&gt;Also, there are several places in the libFLAC code with comments marked with &#34;OPT:&#34; where a #define can be changed to enable code that might be faster on a specific platform. Experimenting with these can yield faster binaries.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>axboe/fio</title>
    <updated>2022-09-13T01:32:47Z</updated>
    <id>tag:github.com,2022-09-13:/axboe/fio</id>
    <link href="https://github.com/axboe/fio" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Flexible I/O Tester&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Overview and history&lt;/h2&gt; &#xA;&lt;p&gt;Fio was originally written to save me the hassle of writing special test case programs when I wanted to test a specific workload, either for performance reasons or to find/reproduce a bug. The process of writing such a test app can be tiresome, especially if you have to do it often. Hence I needed a tool that would be able to simulate a given I/O workload without resorting to writing a tailored test case again and again.&lt;/p&gt; &#xA;&lt;p&gt;A test work load is difficult to define, though. There can be any number of processes or threads involved, and they can each be using their own way of generating I/O. You could have someone dirtying large amounts of memory in a memory mapped file, or maybe several threads issuing reads using asynchronous I/O. fio needed to be flexible enough to simulate both of these cases, and many more.&lt;/p&gt; &#xA;&lt;p&gt;Fio spawns a number of threads or processes doing a particular type of I/O action as specified by the user. fio takes a number of global parameters, each inherited by the thread unless otherwise parameters given to them overriding that setting is given. The typical use of fio is to write a job file matching the I/O load one wants to simulate.&lt;/p&gt; &#xA;&lt;h2&gt;Source&lt;/h2&gt; &#xA;&lt;p&gt;Fio resides in a git repo, the canonical place is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;https://git.kernel.dk/cgit/fio/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Snapshots are frequently generated and :file:&lt;code&gt;fio-git-*.tar.gz&lt;/code&gt; include the git meta data as well. Other tarballs are archives of official fio releases. Snapshots can download from:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;https://brick.kernel.dk/snaps/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are also two official mirrors. Both of these are automatically synced with the main repository, when changes are pushed. If the main repo is down for some reason, either one of these is safe to use as a backup:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;https://git.kernel.org/pub/scm/linux/kernel/git/axboe/fio.git&#xA;&#xA;https://github.com/axboe/fio.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Mailing list&lt;/h2&gt; &#xA;&lt;p&gt;The fio project mailing list is meant for anything related to fio including general discussion, bug reporting, questions, and development. For bug reporting, see REPORTING-BUGS.&lt;/p&gt; &#xA;&lt;p&gt;An automated mail detailing recent commits is automatically sent to the list at most daily. The list address is &lt;a href=&#34;mailto:fio@vger.kernel.org&#34;&gt;fio@vger.kernel.org&lt;/a&gt;, subscribe by sending an email to &lt;a href=&#34;mailto:majordomo@vger.kernel.org&#34;&gt;majordomo@vger.kernel.org&lt;/a&gt; with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;subscribe fio&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in the body of the email. Archives can be found here:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;https://www.spinics.net/lists/fio/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or here:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;https://lore.kernel.org/fio/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and archives for the old list can be found here:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;http://maillist.kernel.dk/fio-devel/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;Fio was written by Jens Axboe &lt;a href=&#34;mailto:axboe@kernel.dk&#34;&gt;axboe@kernel.dk&lt;/a&gt; to enable flexible testing of the Linux I/O subsystem and schedulers. He got tired of writing specific test applications to simulate a given workload, and found that the existing I/O benchmark/test tools out there weren&#39;t flexible enough to do what he wanted.&lt;/p&gt; &#xA;&lt;p&gt;Jens Axboe &lt;a href=&#34;mailto:axboe@kernel.dk&#34;&gt;axboe@kernel.dk&lt;/a&gt; 20060905&lt;/p&gt; &#xA;&lt;h2&gt;Maintainers&lt;/h2&gt; &#xA;&lt;p&gt;Fio is maintained by Jens Axboe &amp;lt;&lt;a href=&#34;mailto:axboe@kernel.dk&#34;&gt;axboe@kernel.dk&lt;/a&gt; and Vincent Fu &lt;a href=&#34;mailto:vincentfu@gmail.com&#34;&gt;vincentfu@gmail.com&lt;/a&gt; - however, for reporting bugs please use the fio reflector or the GitHub page rather than email any of them directly. By using the public resources, others will be able to learn from the responses too. Chances are also good that other members will be able to help with your inquiry as well.&lt;/p&gt; &#xA;&lt;h2&gt;Binary packages&lt;/h2&gt; &#xA;&lt;p&gt;Debian: Starting with Debian &#34;Squeeze&#34;, fio packages are part of the official Debian repository. &lt;a href=&#34;https://packages.debian.org/search?keywords=fio&#34;&gt;https://packages.debian.org/search?keywords=fio&lt;/a&gt; .&lt;/p&gt; &#xA;&lt;p&gt;Ubuntu: Starting with Ubuntu 10.04 LTS (aka &#34;Lucid Lynx&#34;), fio packages are part of the Ubuntu &#34;universe&#34; repository. &lt;a href=&#34;https://packages.ubuntu.com/search?keywords=fio&#34;&gt;https://packages.ubuntu.com/search?keywords=fio&lt;/a&gt; .&lt;/p&gt; &#xA;&lt;p&gt;Red Hat, Fedora, CentOS &amp;amp; Co: Starting with Fedora 9/Extra Packages for Enterprise Linux 4, fio packages are part of the Fedora/EPEL repositories. &lt;a href=&#34;https://packages.fedoraproject.org/pkgs/fio/&#34;&gt;https://packages.fedoraproject.org/pkgs/fio/&lt;/a&gt; .&lt;/p&gt; &#xA;&lt;p&gt;Mandriva: Mandriva has integrated fio into their package repository, so installing on that distro should be as easy as typing &lt;code&gt;urpmi fio&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Arch Linux: An Arch Linux package is provided under the Community sub-repository: &lt;a href=&#34;https://www.archlinux.org/packages/?sort=&amp;amp;q=fio&#34;&gt;https://www.archlinux.org/packages/?sort=&amp;amp;q=fio&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Solaris: Packages for Solaris are available from OpenCSW. Install their pkgutil tool (&lt;a href=&#34;http://www.opencsw.org/get-it/pkgutil/&#34;&gt;http://www.opencsw.org/get-it/pkgutil/&lt;/a&gt;) and then install fio via &lt;code&gt;pkgutil -i fio&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Windows: Beginning with fio 3.31 Windows installers are available on GitHub at &lt;a href=&#34;https://github.com/axboe/fio/releases&#34;&gt;https://github.com/axboe/fio/releases&lt;/a&gt;. Rebecca Cran &lt;a href=&#34;mailto:rebecca@bsdio.com&#34;&gt;rebecca@bsdio.com&lt;/a&gt; has fio packages for Windows at &lt;a href=&#34;https://bsdio.com/fio/&#34;&gt;https://bsdio.com/fio/&lt;/a&gt; . The latest builds for Windows can also be grabbed from &lt;a href=&#34;https://ci.appveyor.com/project/axboe/fio&#34;&gt;https://ci.appveyor.com/project/axboe/fio&lt;/a&gt; by clicking the latest x86 or x64 build and then selecting the Artifacts tab.&lt;/p&gt; &#xA;&lt;p&gt;BSDs: Packages for BSDs may be available from their binary package repositories. Look for a package &#34;fio&#34; using their binary package managers.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Just type::&lt;/p&gt; &#xA;&lt;p&gt;$ ./configure $ make $ make install&lt;/p&gt; &#xA;&lt;p&gt;Note that GNU make is required. On BSDs it&#39;s available from devel/gmake within ports directory; on Solaris it&#39;s in the SUNWgmake package. On platforms where GNU make isn&#39;t the default, type &lt;code&gt;gmake&lt;/code&gt; instead of &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Configure will print the enabled options. Note that on Linux based platforms, the libaio development packages must be installed to use the libaio engine. Depending on distro, it is usually called libaio-devel or libaio-dev.&lt;/p&gt; &#xA;&lt;p&gt;For gfio, gtk 2.18 (or newer), associated glib threads, and cairo are required to be installed. gfio isn&#39;t built automatically and can be enabled with a &lt;code&gt;--enable-gfio&lt;/code&gt; option to configure.&lt;/p&gt; &#xA;&lt;p&gt;To build fio with a cross-compiler::&lt;/p&gt; &#xA;&lt;p&gt;$ make clean $ make CROSS_COMPILE=/path/to/toolchain/prefix&lt;/p&gt; &#xA;&lt;p&gt;Configure will attempt to determine the target platform automatically.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s possible to build fio for ESX as well, use the &lt;code&gt;--esx&lt;/code&gt; switch to configure.&lt;/p&gt; &#xA;&lt;p&gt;Windows&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#xA;The minimum versions of Windows for building/runing fio are Windows 7/Windows&#xA;Server 2008 R2. On Windows, Cygwin (https://www.cygwin.com/) is required in&#xA;order to build fio. To create an MSI installer package install WiX from&#xA;https://wixtoolset.org and run :file:`dobuild.cmd` from the :file:`os/windows`&#xA;directory.&#xA;&#xA;How to compile fio on 64-bit Windows:&#xA;&#xA; 1. Install Cygwin (https://www.cygwin.com/). Install **make** and all&#xA;    packages starting with **mingw64-x86_64**. Ensure&#xA;    **mingw64-x86_64-zlib** are installed if you wish&#xA;    to enable fio&#39;s log compression functionality.&#xA; 2. Open the Cygwin Terminal.&#xA; 3. Go to the fio directory (source files).&#xA; 4. Run ``make clean &amp;amp;&amp;amp; make -j``.&#xA;&#xA;To build fio for 32-bit Windows, ensure the -i686 versions of the previously&#xA;mentioned -x86_64 packages are installed and run ``./configure&#xA;--build-32bit-win`` before ``make``.&#xA;&#xA;It&#39;s recommended that once built or installed, fio be run in a Command Prompt or&#xA;other &#39;native&#39; console such as console2, since there are known to be display and&#xA;signal issues when running it under a Cygwin shell (see&#xA;https://github.com/mintty/mintty/issues/56 and&#xA;https://github.com/mintty/mintty/wiki/Tips#inputoutput-interaction-with-alien-programs&#xA;for details).&#xA;&#xA;&#xA;Documentation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fio uses Sphinx_ to generate documentation from the reStructuredText_ files. To build HTML formatted documentation run &lt;code&gt;make -C doc html&lt;/code&gt; and direct your browser to :file:&lt;code&gt;./doc/output/html/index.html&lt;/code&gt;. To build manual page run &lt;code&gt;make -C doc man&lt;/code&gt; and then &lt;code&gt;man doc/output/man/fio.1&lt;/code&gt;. To see what other output formats are supported run &lt;code&gt;make -C doc help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;.. _reStructuredText: &lt;a href=&#34;https://www.sphinx-doc.org/rest.html&#34;&gt;https://www.sphinx-doc.org/rest.html&lt;/a&gt; .. _Sphinx: &lt;a href=&#34;https://www.sphinx-doc.org&#34;&gt;https://www.sphinx-doc.org&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Platforms&lt;/h2&gt; &#xA;&lt;p&gt;Fio works on (at least) Linux, Solaris, AIX, HP-UX, OSX, NetBSD, OpenBSD, Windows, FreeBSD, and DragonFly. Some features and/or options may only be available on some of the platforms, typically because those features only apply to that platform (like the solarisaio engine, or the splice engine on Linux).&lt;/p&gt; &#xA;&lt;p&gt;Some features are not available on FreeBSD/Solaris even if they could be implemented, I&#39;d be happy to take patches for that. An example of that is disk utility statistics and (I think) huge page support, support for that does exist in FreeBSD/Solaris.&lt;/p&gt; &#xA;&lt;p&gt;Fio uses pthread mutexes for signalling and locking and some platforms do not support process shared pthread mutexes. As a result, on such platforms only threads are supported. This could be fixed with sysv ipc locking or other locking alternatives.&lt;/p&gt; &#xA;&lt;p&gt;Other *BSD platforms are untested, but fio should work there almost out of the box. Since I don&#39;t do test runs or even compiles on those platforms, your mileage may vary. Sending me patches for other platforms is greatly appreciated. There&#39;s a lot of value in having the same test/benchmark tool available on all platforms.&lt;/p&gt; &#xA;&lt;p&gt;Note that POSIX aio is not enabled by default on AIX. Messages like these::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Symbol resolution failed for /usr/lib/libc.a(posix_aio.o) because:&#xA;    Symbol _posix_kaio_rdwr (number 2) is not exported from dependent module /unix.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;indicate one needs to enable POSIX aio. Run the following commands as root::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# lsdev -C -l posix_aio0&#xA;    posix_aio0 Defined  Posix Asynchronous I/O&#xA;# cfgmgr -l posix_aio0&#xA;# lsdev -C -l posix_aio0&#xA;    posix_aio0 Available  Posix Asynchronous I/O&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;POSIX aio should work now. To make the change permanent::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# chdev -l posix_aio0 -P -a autoconfig=&#39;available&#39;&#xA;    posix_aio0 changed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running fio&lt;/h2&gt; &#xA;&lt;p&gt;Running fio is normally the easiest part - you just give it the job file (or job files) as parameters::&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ fio [options] [jobfile] ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and it will start doing what the &lt;em&gt;jobfile&lt;/em&gt; tells it to do. You can give more than one job file on the command line, fio will serialize the running of those files. Internally that is the same as using the :option:&lt;code&gt;stonewall&lt;/code&gt; parameter described in the parameter section.&lt;/p&gt; &#xA;&lt;p&gt;If the job file contains only one job, you may as well just give the parameters on the command line. The command line parameters are identical to the job parameters, with a few extra that control global parameters. For example, for the job file parameter :option:&lt;code&gt;iodepth=2 &amp;lt;iodepth&amp;gt;&lt;/code&gt;, the mirror command line option would be :option:&lt;code&gt;--iodepth 2 &amp;lt;iodepth&amp;gt;&lt;/code&gt; or :option:&lt;code&gt;--iodepth=2 &amp;lt;iodepth&amp;gt;&lt;/code&gt;. You can also use the command line for giving more than one job entry. For each :option:&lt;code&gt;--name &amp;lt;name&amp;gt;&lt;/code&gt; option that fio sees, it will start a new job with that name. Command line entries following a :option:&lt;code&gt;--name &amp;lt;name&amp;gt;&lt;/code&gt; entry will apply to that job, until there are no more entries or a new :option:&lt;code&gt;--name &amp;lt;name&amp;gt;&lt;/code&gt; entry is seen. This is similar to the job file options, where each option applies to the current job until a new [] job entry is seen.&lt;/p&gt; &#xA;&lt;p&gt;fio does not need to run as root, except if the files or devices specified in the job section requires that. Some other options may also be restricted, such as memory locking, I/O scheduler switching, and decreasing the nice value.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;em&gt;jobfile&lt;/em&gt; is specified as &lt;code&gt;-&lt;/code&gt;, the job file will be read from standard input.&lt;/p&gt;</summary>
  </entry>
</feed>