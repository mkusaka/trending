<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-19T01:31:14Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>buzzm/postgresbson</title>
    <updated>2024-01-19T01:31:14Z</updated>
    <id>tag:github.com,2024-01-19:/buzzm/postgresbson</id>
    <link href="https://github.com/buzzm/postgresbson" rel="alternate"></link>
    <summary type="html">&lt;p&gt;postgres support for BSON&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;postgresbson&lt;/h1&gt; &#xA;&lt;p&gt;BSON support for PostgreSQL&lt;/p&gt; &#xA;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;p&gt;This PostgreSQL extension realizes the BSON data type, together with functions to create and inspect BSON objects for the purposes of expressive and performant querying.&lt;/p&gt; &#xA;&lt;p&gt;BSON (&lt;a href=&#34;http://bsonspec.org/&#34;&gt;http://bsonspec.org/&lt;/a&gt;) is a high-performance, richly-typed data carrier similar to JSON but offers a number of attractive features including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Datetimes, decimal (numeric), and byte[] are first class types. In pure JSON these must all be represented as a string, requiring conversion, potentially introducing lossiness, and impairing native operations like &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;=&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Performance. Moving binary BSON in and out of the database under some conditions is almost 10x faster than using native &lt;code&gt;jsonb&lt;/code&gt; or &lt;code&gt;json&lt;/code&gt; because it avoids to- and from-string and to-dictionary conversion.&lt;/li&gt; &#xA; &lt;li&gt;Roundtrip ability. BSON is binary spec, not a string. There is no whitespace, quoting rules, etc. BSON that goes into Postgres comes out &lt;em&gt;exactly&lt;/em&gt; the same way, each time, every time.&lt;/li&gt; &#xA; &lt;li&gt;Standard SDK implementations in upwards of 20 languages&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Roundtripping and many available language SDKs enables seamless creation, manipulation, transmission, and querying of data in a distributed system without coordinating IDLs, compile-time dependencies, nuances in platform type representation, etc. Here is an example of a typical processing chain: Java program -&amp;gt; message bus -&amp;gt; python util -&amp;gt; save to database -&amp;gt; other Java program wakes up on insert trigger:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Java program constructs an &lt;code&gt;org.bson.Document&lt;/code&gt; (which honors &lt;code&gt;java.util.Map&lt;/code&gt; interface), e.g. &lt;code&gt;doc.put(&#34;name&#34;, &#34;Steve&#34;)&lt;/code&gt;, &lt;code&gt;doc.put(&#34;balance&#34;, new BigDecimal(&#34;143.99&#34;))&lt;/code&gt; etc.&lt;/li&gt; &#xA; &lt;li&gt;Java program encodes &lt;code&gt;org.bson.Document&lt;/code&gt; using Java BSON SDK to a BSON &lt;code&gt;byte[]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Java program publishes &lt;code&gt;byte[]&lt;/code&gt; to a Kafka topic.&lt;/li&gt; &#xA; &lt;li&gt;python listener wakes up on topic and receives &lt;code&gt;byte[]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;python listener decodes &lt;code&gt;byte[]&lt;/code&gt; using python BSON SDK into &lt;code&gt;dict&lt;/code&gt;, &lt;strong&gt;not&lt;/strong&gt; a string. It is a fully reconstituted &lt;code&gt;dict&lt;/code&gt; object with substructures, &lt;code&gt;datetime.datetime&lt;/code&gt; for date fieldss, &lt;code&gt;Decimal&lt;/code&gt; for penny-precise fields, etc. The listener prints some things but does not change anything in the dict.&lt;/li&gt; &#xA; &lt;li&gt;python listener encodes &lt;code&gt;dict&lt;/code&gt; to back to &lt;code&gt;byte[]&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt;s it to a BSON column in Postgres using the &lt;code&gt;psycopg2&lt;/code&gt; module.&lt;/li&gt; &#xA; &lt;li&gt;A different Java program wakes up on a Postgres insert trigger and &lt;code&gt;SELECT&lt;/code&gt;s the BSON column as a &lt;code&gt;byte[]&lt;/code&gt; (e.g. &lt;code&gt;select bson_column::bytea where ...&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;This &lt;code&gt;byte[]&lt;/code&gt; is &lt;em&gt;identical&lt;/em&gt; to the one created in step 2.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The extension offers two kinds of accessor suites:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Typesafe high performance accessor functions that take a dotpath notation to get to a field e.g.&lt;br&gt; &lt;pre&gt;&lt;code&gt;select bson_get_datetime(bson_column, &#39;msg.header.event.ts&#39;) from table;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Arrow and double arrow operators similar to those found in the JSON type e.g.&lt;br&gt; &lt;pre&gt;&lt;code&gt;select (bson_column-&amp;gt;&#39;msg&#39;-&amp;gt;&#39;header&#39;-&amp;gt;&#39;event&#39;-&amp;gt;&amp;gt;&#39;ts&#39;)::timestamp from table;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The BSON type is castable to JSON in so-called &lt;a href=&#34;https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/&#34;&gt;EJSON&lt;/a&gt; format to preserve type fidelity. Thus, the wealth of functions and operations and even other extensions built around the JSON type can be used on BSON.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;select json_array_length(bson_column::json-&amp;gt;&#39;d&#39;-&amp;gt;&#39;payload&#39;-&amp;gt;&#39;vector&#39;) from table;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These of course can be combined:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-- Use dotpath to quickly get to event substructure, then cast to jsonb and&#xA;-- use ?@ operator to ask if both `id` and `type` are present as top level tags:&#xA;select (bson_get_bson(bson_column, &#39;msg.header.event&#39;)::jsonb) ?@ array[&#39;id&#39;,&#39;type&#39;] from table;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why dotpath accessors are better in BSON (&lt;em&gt;and&lt;/em&gt; native json and jsonb, too)&lt;/h2&gt; &#xA;&lt;p&gt;In general, the dotpath functions will be much faster and memory efficient especially for larger and/or deeper structures. This is because the dotpath implementation in the underlying C library itself will &#34;walk&#34; the BSON structure and only vend allocated material at the terminal of the path. The arrow operators necessitate the construction of a fully inflated substructure at each step in the path, which is exactly what happens with arrow operators and the native &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; types. For example, consider this instance with approx. 3K of data, from which we want to query where &lt;code&gt;id&lt;/code&gt; is &lt;code&gt;AAA&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  {&#xA;    header: { event: {id: &#34;E123&#34;} },&#xA;    data: {&#xA;        payload: {&#xA;&#x9;    product: {&#xA;&#x9;        definition: {&#xA;&#x9;            id: &#34;AAA&#34;,&#xA;&#x9;&#x9;    ... another 1K of data ...&#xA;&#x9;        },&#xA;&#x9;        constraints: {&#xA;&#x9;&#x9;    ... another 1K of data ...&#xA;&#x9;        },&#xA;&#x9;        approvals: {&#xA;&#x9;&#x9;    ... another 1K of data ...&#xA;                }&#xA;&#x9;    }&#xA;&#x9;}&#xA;    }&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The dotpath method will make postgres pass the 3K structure to the BSON extension (internally of course, not back to the client!), which will only have to examine roughly 64 bytes of data to dig down to the &lt;code&gt;id&lt;/code&gt; field to return a string which is then examined for equality to &lt;code&gt;AAA&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;select * from table where bson_get_string(bson_column, &#39;data.payload.product.definition.id&#39;) = &#39;AAA&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With arrow operators, &lt;em&gt;at each arrow&lt;/em&gt;, almost 3K of data has to be processed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   Remember double arrow operator yields text type, which fortunately is easily&#xA;   compared to a literal string; no casting necessary, but the journey there is&#xA;   tough because each single arrow forces construction of a whole new object to&#xA;   pass to the next stage.  This happens internal to the engine but still...&#xA;   &#xA;select * from table where&#xA;bson_column-&amp;gt;&#39;data&#39;-&amp;gt;&#39;payload&#39;-&amp;gt;&#39;product&#39;-&amp;gt;&#39;definition&#39;-&amp;gt;&amp;gt;&#39;id&#39; = &#39;AAA&#39;;&#xA;           ^       ^          ^          ^             ^     ^          &#xA;           |       |          |          |             |     | &#xA;           +- initial pull of a little more than 3K    |     | &#xA;                   |          |          |             |     |                 &#xA;                   +- almost 3K reprocessed            |     |&#xA;                              |          |             |     |&#xA;                              +- another 3K reprocessed|     |&#xA;                                         |             |     |&#xA;                                         +- another 3K |     |&#xA;                                                       |     |     &#xA;                                                       +- about 1K here&#xA;                                                             |&#xA;                                                             +- a handful of bytes&#xA;&#xA;Total: about 13K of data in 4 separate pass **and** construct chunks of 3K processed to extract 3 bytes.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Again, this is &lt;em&gt;exactly&lt;/em&gt; the same situation that occurs with native &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; types using the arrow operators; it is &lt;em&gt;not&lt;/em&gt; particular to BSON. This is why postgres provides the &lt;code&gt;#&amp;gt;&lt;/code&gt; operator and the corresponding &lt;code&gt;json_extract_path&lt;/code&gt; and &lt;code&gt;jsonb_extract_path&lt;/code&gt; functions for these native types.&lt;/p&gt; &#xA;&lt;h2&gt;Arrays, BSON, and JSON&lt;/h2&gt; &#xA;&lt;p&gt;Unlike JSON, BSON can only be created from a key:value object (which can be empty); it cannot be created from a simple scalar or in particular an array. In the course of descending into substructure, it is of course possible to encounter an array and have that returned. The C library gets around this problem by returning a string indexed object where the keys are the integer representation of the location in the array starting at offset zero. From the CLI, this will be seen as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;select bson_column-&amp;gt;&#39;d&#39;-&amp;gt;&#39;payload&#39;-&amp;gt;&#39;vector&#39; from ...&#xA;  returns  {&#34;0&#34;:&#34;some value&#34;, &#34;1&#34;:&#34;another value&#34;, &#34;2&#34;:{fldx:&#34;a rich shape&#34;}}&#xA;  not      [&#34;some value&#34;, &#34;another value&#34;, {fldx:&#34;a rich shape&#34;}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The postgres array type does not help here because postgres requires a homogenous type and BSON allows for heterogenous types.&lt;/p&gt; &#xA;&lt;p&gt;There are two ways to deal with this:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Access items using strings; note the double arrow!&lt;/p&gt; &lt;pre&gt;&lt;code&gt;select bson_column-&amp;gt;&#39;d&#39;-&amp;gt;&#39;payload&#39;-&amp;gt;&#39;vector&#39;-&amp;gt;&amp;gt;&#39;0&#39; from ...&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&#34;Back up one level&#34; in the arrow chain and cast to &lt;code&gt;jsonb&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;mydb=# select (bson_column-&amp;gt;&#39;d&#39;-&amp;gt;&#39;payload&#39;)::jsonb-&amp;gt;&#39;vector&#39; from ...&#xA; ?column?   &#xA;--------------&#xA;[21, 17, 19]&#xA;&#xA;mydb=# select (bson_column-&amp;gt;&#39;d&#39;-&amp;gt;&#39;payload&#39;)::jsonb-&amp;gt;&#39;vector&#39;-&amp;gt;&amp;gt;0 from ...&#xA; ?column?   &#xA;--------------&#xA;21&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Status&lt;/h1&gt; &#xA;&lt;p&gt;Experimental. All contribs / PRs / comments / issues welcome.&lt;/p&gt; &#xA;&lt;h1&gt;Example&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;CREATE EXTENSION pgbson;&#xA;CREATE TABLE data_collection ( data BSON );&#xA;&#xA;-- Programmatic insert of material through postgres SDK e.g. psycopg2&#xA;-- can use native types directly; this is this high-fidelity sweet spot&#xA;-- for the BSON extension:&#xA;&#xA;import bson  &#xA;import psycopg2&#xA;&#xA;import datetime&#xA;&#xA;conn = psycopg2.connect(DSN) # &#39;host=machine port=5432 dname=foo .... &#39;&#xA;sdata = {&#xA;    &#34;header&#34;: {&#xA;&#x9;&#34;ts&#34;: datetime.datetime(2022,5,5,12,13,14,456),&#xA;        &#34;evId&#34;:&#34;E23234&#34;&#xA;    },&#xA;    &#34;data&#34;: {&#xA;        &#34;id&#34;:&#34;ID0&#34;,&#xA;        &#34;notIndexed&#34;:&#34;N0&#34;,        &#xA;&#xA;        # BSON decimal128 adheres more strongly to IEEE spec than native&#xA;        # python Decimal esp. wrt NaN so we must use that.  We are&#xA;        # encoding to BSON later anyway so no extra dependencies here.&#xA;        &#34;amt&#34;: bson.decimal128.Decimal128(&#34;107.78&#34;),&#xA;&#xA;        &#34;txDate&#34;: datetime.datetime(2022,12,31),&#xA;        &#34;userPrefs&#34;: [&#xA;        {&#34;type&#34;: &#34;DEP&#34;, &#34;updated&#34;:datetime.datetime(2021,4,4,12,13,14),&#34;u&#34;:{&#xA;            &#34;favoriteCar&#34;:&#34;Bugatti&#34;,&#xA;            &#34;thumbnail&#34;: bson.binary.Binary(bytes(&#34;Pretend this is a JPEG&#34;, &#39;utf-8&#39;))&#xA;            }},&#xA;        {&#34;type&#34;: &#34;X2A&#34;, &#34;updated&#34;:datetime.datetime(2021,3,3,12,13,14),&#34;u&#34;:{&#xA;            &#34;listOfPrimes&#34;:[2,3,5,7,11,13,17,19],&#xA;            &#34;atomsInBowlOfSoup&#34;: 283572834759209881,&#xA;            &#34;pi&#34;: 3.1415926&#xA;            }}&#xA;        ]&#xA;    }&#xA;}&#xA;&#xA;# raw_bson is byte[].  BSON is castable to/from bytea type in PG:&#xA;raw_bson = bson.encode(sdata) &#xA;&#xA;curs = conn.cursor()&#xA;curs.execute(&#34;INSERT INTO bsontest (data) VALUES (%s)&#34;,(raw_bson,))&#xA;conn.commit()&#xA;&#xA;curs.execute(&#34;&#34;&#34;&#xA;SELECT&#xA;  2 * bson_get_decimal128(data, &#39;data.amt&#39;),&#xA;  4 + bson_get_datetime(data, &#39;data.txDate&#39;)::date&#xA;from bsontest&#xA;&#34;&#34;&#34;)&#xA;rr = curs.fetchall()[0] # one row&#xA;print(&#34;amt: &#34;, rr[0], type(rr[0]))  # amt:  215.56 &amp;lt;class &#39;decimal.Decimal&#39;&amp;gt; fetched as relaxed native Decimal type&#xA;print(&#34;txDate: &#34;, rr[1], type(rr[1])) # txDate:  2023-01-04 &amp;lt;class &#39;datetime.date&#39;&amp;gt;&#xA;&#xA;&#xA;&#xA;-- EJSON is recognized upon insertion. For example, the $date substructure&#xA;--   &#34;ts&#34;: {&#34;$date&#34;:&#34;2022-03-03T12:13:14.789Z&#34;}&#xA;-- is converted upon parse to a single scalar of type timestamp:&#xA;--   &#34;ts&#34;: timestamp&#xA;INSERT INTO data_collection (data) values (&#xA;   &#39;{&#34;d&#34;:{&#xA;       &#34;recordId&#34;:&#34;R1&#34;,&#xA;       &#34;notIndexed&#34;:&#34;N1&#34;,&#xA;       &#34;baz&#34;:27,&#xA;       &#34;bigint&#34;:{&#34;$numberLong&#34;:&#34;88888888888888888&#34;},&#xA;       &#34;dbl&#34;:3.1415,&#xA;       &#34;ts&#34;: {&#34;$date&#34;:&#34;2022-03-03T12:13:14.789Z&#34;},&#xA;       &#34;amt&#34;: {&#34;$numberDecimal&#34;:&#34;77777809838.97&#34;},&#xA;       &#34;payload&#34;: {&#xA;           &#34;fun&#34;:&#34;scootering&#34;,&#xA;           &#34;val&#34;:13,&#xA;           &#34;vector&#34;:[21,17,19],&#xA;           &#34;image&#34; : { &#34;$binary&#34; : { &#34;base64&#34; : &#34;VGhpcyBpcyBhIHRlc3Q=&#34;, &#34;subType&#34; : &#34;00&#34; } }&#xA;        }&#xA;     }&#xA;}&#39;&#xA;);&#xA;&#xA;&#xA;-- Functional indexes work as well, enabling high performance queries&#xA;-- into any part of the structure; note the dotpath in the example below:&#xA;CREATE INDEX ON data_collection( bson_get_string(data, &#39;d.recordId&#39;));&#xA;&#xA;-- ... and those indexes help.  Queries on peer fields in a substructure,&#xA;-- one with an index, one without, yields nearly a 10000x improvement in&#xA;-- performance.&#xA;&#xA;select count(*) from data_collection;&#xA;  count  &#xA;---------&#xA; 1000000&#xA;&#xA;explain analyze select count(*) from btest where bson_get_string(data,&#39;d.recordId&#39;) = &#39;R31&#39;;&#xA;---- QUERY PLAN&#xA; Aggregate  (cost=8.45..8.46 rows=1 width=8) (actual time=0.076..0.077 rows=1 loops=1)&#xA;   -&amp;gt;  Index Scan using btest_bson_get_string_idx on btest  (cost=0.42..8.44 rows=1 width=0) (actual time=0.070..0.071 rows=1 loops=1)&#xA;         Index Cond: (bson_get_string(data, &#39;d.recordId&#39;::cstring) = &#39;R31&#39;::text)&#xA; Planning Time: 0.296 ms&#xA; Execution Time: 0.108 ms&#xA;&#xA;&#xA;explain analyze select count(*) from btest where bson_get_string(data,&#39;d.notIndexed&#39;) = &#39;N31&#39;;&#xA; Aggregate  (cost=215012.50..215012.51 rows=1 width=8) (actual time=993.471..993.472 rows=1 loops=1)&#xA;   -&amp;gt;  Seq Scan on btest  (cost=0.00..215000.00 rows=5000 width=0) (actual time=0.124..993.464 rows=1 loops=1)&#xA;         Filter: (bson_get_string(data, &#39;d.notIndexed&#39;::cstring) = &#39;N31&#39;::text)&#xA;         Rows Removed by Filter: 999999&#xA; Planning Time: 0.079 ms&#xA; Execution Time: 993.505 ms&#xA;&#xA;&#xA;&#xA;-- These are equivalent queries but the dotpath accessors will be&#xA;-- significantly faster (and much more memory efficient) if the path depth &amp;gt; 3.&#xA;-- Note of course that the BSON accessor functions can be used in&#xA;-- a selection set (select), a predicate (where), or essentially anywhere else.&#xA;&#xA;select bson_get_bson(data, &#39;d.payload&#39;) from btest where bson_get_string(data,&#39;d.recordId&#39;) = &#39;R1&#39;;&#xA;&#xA;select data-&amp;gt;&#39;d&#39;-&amp;gt;&#39;payload&#39; from btest where bson_get_string(data,&#39;d.recordId&#39;) = &#39;R1&#39;;&#xA;                                                                                          ?column?                                                                                              &#xA;----------------------------------------------------------------------------------------------------------------------------------------------------------------    ------------------------------------&#xA;{ &#34;fun&#34; : &#34;scootering&#34;, &#34;val&#34; : 13, &#34;vector&#34; : [ 1, 2, 3 ], &#34;fancy&#34; : [ { &#34;A&#34; : 1 }, { &#34;B&#34; : [ &#34;X&#34;, &#34;Z&#34; ] } ], &#34;image&#34; : { &#34;$binary&#34; : { &#34;base64&#34; : &#34;VGhpcyBpcyBhIHRlc3Q=&#34;, &#34;subType&#34; : &#34;00&#34; } } }&#xA;&#xA;-- The -&amp;gt;&amp;gt; operator, like JSON, yields a text type, which you can cast&#xA;-- whatever you believe is appropriate&#xA;select (data-&amp;gt;&#39;d&#39;-&amp;gt;&amp;gt;&#39;amt&#39;)::numeric as my_amount from btest where bson_get_string(data,&#39;d.recordId&#39;) = &#39;R1&#39;;    &#xA;   my_amount&#xA;----------------&#xA; 77777809838.97&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Building&lt;/h1&gt; &#xA;&lt;p&gt;Tested on&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PG 14.4: OS X 10.15.7, OS X 13.2 Ventura, and RHEL 8.6.&lt;/li&gt; &#xA; &lt;li&gt;PG 15.5.3: OS X 13.2 Ventura, RHEL 9.3&lt;/li&gt; &#xA; &lt;li&gt;PG 16.1.3: OS X 13.2 Ventura, RHEL 9.3&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Requires:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;postgres development SDK (mostly for &lt;code&gt;.h&lt;/code&gt; files in &lt;code&gt;.../postgresql/server&lt;/code&gt;). On OS X you can use &lt;code&gt;brew&lt;/code&gt;. On RH 8 it is a little trickier because many repos do not have version 14.x. Here is a &lt;a href=&#34;https://www.linuxshelltips.com/install-postgresql-rhel&#34;&gt;a good step-by-step install of 14.4 for RH 8&lt;/a&gt; Note you will need both server and development (e.g. &lt;code&gt;postgresql14-devel&lt;/code&gt;) packages because you need &lt;code&gt;.h&lt;/code&gt; files. It is not necessary to do a complete build of postgres.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pg_config&lt;/code&gt; (which comes with postgres) and is used as part of the Makefile. Note that some earlier versions of postgres did not not include the &lt;code&gt;pg_config&lt;/code&gt; exec and the &lt;code&gt;pgxs&lt;/code&gt; environment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;libbson.so&lt;/code&gt; and BSON C SDK &lt;code&gt;.h&lt;/code&gt; files. You can make or install these separately and there is plenty of material on this topic. There are some quick tips at the top of the &lt;code&gt;Makefile&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;C compiler. No C++ used. The compiler arguments are driven by the environment set up by &lt;code&gt;pg_config&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    git clone https://github.com/buzzm/postgresbson.git&#xA;    # edit the Makefile to point at the BSON includes and dynamic lib; then:&#xA;    make PGUSER=postgres  # compiles pgbson.c to pgbson.so&#xA;    make PGUSER=postgres install  # copies .so, .sql, and .control files into target dirs in postgres environment&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are too many build directory permissions, install directory permissions, and other local oddments to document here, but neither postgres nor root privilege is required to compile and link the shared lib but &lt;em&gt;installation&lt;/em&gt; in your particular environment will vary. In general, on OS X using &lt;code&gt;brew&lt;/code&gt; you won&#39;t need root because root does not own &lt;code&gt;/opt/homebrew&lt;/code&gt; but on Linux, lots of things are done with &lt;code&gt;sudo yum&lt;/code&gt; and resources end up owned as root in &lt;code&gt;/usr/pgsql-nn&lt;/code&gt; and &lt;code&gt;/usr/lib64&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In addition, on RHEL 9, there appears to be an oddment around the compilation target in make trying to create a &lt;code&gt;.bc&lt;/code&gt; LLVM file using &lt;code&gt;clang&lt;/code&gt; in addition to the regular &lt;code&gt;.so&lt;/code&gt; shlib using &lt;code&gt;gcc&lt;/code&gt;. On many platforms, &lt;code&gt;clang&lt;/code&gt; may not be installed and even if it is, the &lt;code&gt;pg_config&lt;/code&gt; modified &lt;code&gt;Makefile&lt;/code&gt; may use the wrong path to it e.g. &lt;code&gt;/usr/lib64/ccache/clang&lt;/code&gt; instead of &lt;code&gt;/usr/bin/clang&lt;/code&gt; or just &lt;code&gt;clang&lt;/code&gt;. The good news it appears the &lt;code&gt;.bc&lt;/code&gt; LLVM output is &lt;em&gt;not&lt;/em&gt; necessary for the postgres extension. As long as the &lt;code&gt;.so&lt;/code&gt; is installed into the proper path the extension will work. At your discretion you can &#34;manually make&#34; the &lt;code&gt;.bc&lt;/code&gt; file by editing the command line and then running &lt;code&gt;make PGUSER=postgres install&lt;/code&gt; again.&lt;/p&gt; &#xA;&lt;p&gt;Make sure you install &lt;em&gt;and then restart&lt;/em&gt; your postgres server to properly pick up the new BSON extension.&lt;/p&gt; &#xA;&lt;h1&gt;Testing&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Make sure postgresql16-devel (or 14 or 15) is installed *first*. &#xA;# pip3 install psycopg2 uses pg_config; thus the PATH must also be set!&#xA;PATH=/path/to/pgsql-16/bin/pg_config:$PATH pip3 install psycopg2  &#xA;&#xA;pip3 install pymongo   # for bson only; we won&#39;t be using the mongo driver&#xA;&#xA;python3 pgbson_test.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See excuse at top of file regarding the non-standard test driver approach.&lt;/p&gt; &#xA;&lt;h1&gt;Quick reference&lt;/h1&gt; &#xA;&lt;p&gt;The module defines BSON data type with operator families defined for B-TREE and HASH indexes.&lt;/p&gt; &#xA;&lt;p&gt;Field access (supports dot notation):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;bson_get_string(bson_column, dotpath) RETURNS text&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;bson_get_int32(bson_column, dotpath) RETURNS int4&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;bson_get_int64(bson_column, dotpath) RETURNS int8&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;bson_get_double(bson_column, dotpath) RETURNS float8&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;bson_get_decimal(bson_column, dotpath) RETURNS numeric&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;bson_get_datetime(bson_column, dotpath) RETURNS timestamp without time zone&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;bson_get_binary(bson_column, dotpath) RETURNS bytea&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;bson_get_boolean(bson_column, dotpath) RETURNS boolean&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;bson_get_bson(bson_column, dotpath) RETURNS bson&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;bson_as_text(bson_column, dotpath) RETURNS text&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Operators and comparison:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Operators: =, &amp;lt;&amp;gt;, &amp;lt;=, &amp;lt;, &amp;gt;=, &amp;gt;, == (binary equality), &amp;lt;&amp;lt;&amp;gt;&amp;gt; (binary inequality)&lt;/li&gt; &#xA; &lt;li&gt;bson_hash(bson) RETURNS INT4&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;TO DO&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Significantly&lt;/strong&gt; tidy up test driver&lt;/li&gt; &#xA; &lt;li&gt;Need something better when extracting arrays.&lt;/li&gt; &#xA; &lt;li&gt;Need something better when bson_get_bson() resolves to a scalar because simple scalars like a string are not BSON. Currently, it just returns NULL which is &#34;technically correct&#34; but unsatisfying&lt;/li&gt; &#xA; &lt;li&gt;Need additional safety checks when doing BSON compare and other operations because corrupted BSON has a tendency to segfault the PG process.&lt;/li&gt; &#xA; &lt;li&gt;Need more docs or a more clever solution for when calling &lt;code&gt;bson_get_{type}&lt;/code&gt; points to a field that exists but the type is wrong. Currently it just returns null because that is &#34;safest.&#34;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;See also&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PostgreSQL - &lt;a href=&#34;http://www.postgresql.org/&#34;&gt;http://www.postgresql.org/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;BSON - &lt;a href=&#34;http://bsonspec.org/&#34;&gt;http://bsonspec.org/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;MongoDB - &lt;a href=&#34;http://mongodb.org&#34;&gt;http://mongodb.org&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>sched-ext/scx</title>
    <updated>2024-01-19T01:31:14Z</updated>
    <id>tag:github.com,2024-01-19:/sched-ext/scx</id>
    <link href="https://github.com/sched-ext/scx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;sched_ext schedulers and tools&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Sched_ext Schedulers and Tools&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sched-ext/scx&#34;&gt;sched_ext&lt;/a&gt; is a Linux kernel feature which enables implementing kernel thread schedulers in BPF and dynamically loading them. This repository contains various scheduler implementations and support utilities.&lt;/p&gt; &#xA;&lt;p&gt;sched_ext enables safe and rapid iterations of scheduler implementations, thus radically widening the scope of scheduling strategies that can be experimented with and deployed; even in massive and complex production environments.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/sched-ext/scx/raw/case-studies/case-studies/scx_layered.md&#34;&gt;scx_layered case study&lt;/a&gt; concretely demonstrates the power and benefits of sched_ext.&lt;/li&gt; &#xA; &lt;li&gt;For a high-level but thorough overview of the sched_ext (especially its motivation), please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/sched-ext/scx/main/OVERVIEW.md&#34;&gt;overview document&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;For a description of the schedulers shipped with this tree, please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/sched-ext/scx/main/scheds/README.md&#34;&gt;schedulers document&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The following video is the &lt;a href=&#34;https://github.com/sched-ext/scx/tree/main/scheds/rust/scx_rustland&#34;&gt;scx_rustland&lt;/a&gt; scheduler which makes most scheduling decisions in userspace Rust code showing better FPS in terraria while kernel is being compiled. This doesn&#39;t mean that scx_rustland is a better scheduler but does demonstrate how safe and easy it is to implement a scheduler which is generally usable and can outperform the default scheduler in certain scenarios.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sched-ext/scx/assets/1051723/42ec3bf2-9f1f-4403-80ab-bf5d66b7c2d5&#34;&gt;scx_rustland-terraria&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;While the kernel feature is not upstream yet, we believe sched_ext has a reasonable chance of landing upstream in the foreseeable future. Both Meta and Google are fully committed to sched_ext and Meta is in the process of mass production deployment. See (#kernel-feature-status) for more details.&lt;/p&gt; &#xA;&lt;p&gt;In all example shell commands, &lt;code&gt;$SCX&lt;/code&gt; refers to the root of this repository.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;All that&#39;s necessary for running sched_ext schedulers is a kernel with sched_ext support and the scheduler binaries along with the libraries they depend on. Switching to a sched_ext scheduler is as simple as running a sched_ext binary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;root@test ~# head -2 /sys/kernel/debug/sched/ext&#xA;ops                           :&#xA;enabled                       : 0&#xA;root@test ~# scx_simple&#xA;local=1 global=0&#xA;local=74 global=15&#xA;local=78 global=32&#xA;local=82 global=42&#xA;local=86 global=54&#xA;^Zfish: Job 1, &#39;scx_simple&#39; has stopped&#xA;root@test ~# head -2 /sys/kernel/debug/sched/ext&#xA;ops                           : simple&#xA;enabled                       : 1&#xA;root@test ~# fg&#xA;Send job 1 (scx_simple) to foreground&#xA;local=635 global=179&#xA;local=696 global=192&#xA;^CEXIT: BPF scheduler unregistered&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sched-ext/scx/raw/main/scheds/c/scx_simple.bpf.c&#34;&gt;&lt;code&gt;scx_simple&lt;/code&gt;&lt;/a&gt; is a very simple global vtime scheduler which can behave acceptably on CPUs with a simple topology (single socket and single L3 cache domain).&lt;/p&gt; &#xA;&lt;p&gt;Above, we switch the whole system to use &lt;code&gt;scx_simple&lt;/code&gt; by running the binary, suspend it with &lt;code&gt;ctrl-z&lt;/code&gt; to confirm that it&#39;s loaded, and then switch back to the kernel default scheduler by terminating the process with &lt;code&gt;ctrl-c&lt;/code&gt;. For &lt;code&gt;scx_simple&lt;/code&gt;, suspending the scheduler process doesn&#39;t affect scheduling behavior because all that the userspace component does is print statistics. This doesn&#39;t hold for all schedulers.&lt;/p&gt; &#xA;&lt;p&gt;In addition to terminating the program, there are two more ways to disable a sched_ext scheduler - &lt;code&gt;sysrq-S&lt;/code&gt; and the watchdog timer. Ignoring kernel bugs, the worst damage a sched_ext scheduler can do to a system is starving some threads until the watchdog timer triggers.&lt;/p&gt; &#xA;&lt;p&gt;As illustrated, once the kernel and binaries are in place, using sched_ext schedulers is straightforward and safe. While developing and building schedulers in this repository isn&#39;t complicated either, sched_ext makes use of many new BPF features, some of which require build tools which are newer than what many distros are currently shipping. This should become less of an issue in the future. For the time being, the following custom repositories are provided for select distros.&lt;/p&gt; &#xA;&lt;h3&gt;Ubuntu&lt;/h3&gt; &#xA;&lt;p&gt;Experimental sched_ext support for Ubuntu is provided by the following launchpad project:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://launchpad.net/~arighi/+archive/ubuntu/sched-ext&#34;&gt;https://launchpad.net/~arighi/+archive/ubuntu/sched-ext&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Upgrading to 24.04 (NobleNumbat)&lt;/h4&gt; &#xA;&lt;p&gt;Currently, only the 24.04 release is supported. You can upgrade to 24.04 using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo do-release-upgrade -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Installing the Kernel and Schedulers&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo add-apt-repository -y --enable-source ppa:arighi/sched-ext&#xA;$ sudo apt install -y linux-generic-wip scx&#xA;$ sudo reboot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After the reboot, the scheduler binaries in &lt;code&gt;/usr/sbin/scx_*&lt;/code&gt; should be usable. Note: they must be called with &lt;code&gt;sudo&lt;/code&gt; like other BPF programs e.g. &lt;code&gt;sudo scx_simple&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Setting up Dev Environment&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ apt source scx&#xA;$ sudo apt build-dep scx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Arch Linux&lt;/h3&gt; &#xA;&lt;h4&gt;Adding the Repository&lt;/h4&gt; &#xA;&lt;p&gt;Import and locally sign the packager&#39;s GPG key. This can be skipped if the signature checking is disabled when adding the repo.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo pacman-key --recv-keys 697C63013E65270255EBC2608744DC1EB26B5A9A&#xA;$ sudo pacman-key --lsign-key 697C63013E65270255EBC2608744DC1EB26B5A9A&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add the following custom repository section to &lt;code&gt;/etc/pacman.conf&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[scx]&#xA;Server = https://github.com/sched-ext/scx-packaging-arch/releases/download/repo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you haven&#39;t imported the GPG key, append the following line.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;SigLevel = Never&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Installing the Kernel and Schedulers&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo pacman -Sy scx/linux scx/libbpf scx/scx-scheds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the above replaces the default kernel and libbpf packages. The latter won&#39;t be unnecessary once libbpf is updated to &amp;gt;=1.3.0 in the Arch repository. After a reboot, the scheduler binaries &lt;code&gt;/usr/bin/scx_*&lt;/code&gt; should be usable.&lt;/p&gt; &#xA;&lt;h4&gt;Setting Up Dev Environment&lt;/h4&gt; &#xA;&lt;p&gt;In addition to the packages from the previous step, install the following.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo pacman -Sy scx/linux-headers scx/clang-github-bin meson cargo bpf pahole&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;clang-github-bin&lt;/code&gt; is necessary because the recommended &lt;code&gt;clang&lt;/code&gt; version is 17 while Arch is still shipping 16. It&#39;s built from the &lt;a href=&#34;https://aur.archlinux.org/packages/clang-github-bin&#34;&gt;AUR package&lt;/a&gt; of the same name. This is a repackage of the official LLVM release in &lt;code&gt;.deb&lt;/code&gt; format.&lt;/p&gt; &#xA;&lt;h2&gt;Repository Structure&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;scx&#xA;|-- scheds               : Sched_ext scheduler implementations&#xA;|   |-- include          : Shared BPF and user C include files including vmlinux.h&#xA;|   |-- c                : Example schedulers - userspace code written C&#xA;|   \-- rust             : Example schedulers - userspace code written Rust&#xA;\-- rust                 : Rust support code&#xA;    \-- scx_utils        : Common utility library for rust schedulers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build &amp;amp; Install&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;meson&lt;/code&gt; is the main build system but each Rust sub-project is its own self-contained cargo project and can be built and published separately. The followings are the dependencies and version requirements.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Many distros only have earlier versions of &lt;code&gt;meson&lt;/code&gt;, in that case just &lt;a href=&#34;https://mesonbuild.com/Quick-guide.html#installation-from-source&#34;&gt;clone the meson repo&lt;/a&gt; and call &lt;code&gt;meson.py&lt;/code&gt; e.g. &lt;code&gt;/path/to/meson/repo/meson.py compile -C build&lt;/code&gt;. Alternatively, use &lt;code&gt;pip&lt;/code&gt; e.g. &lt;code&gt;pip install meson&lt;/code&gt; or &lt;code&gt;pip install meson --break-system-packages&lt;/code&gt; (if needed).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;meson&lt;/code&gt;: &amp;gt;=1.2, build scripts under &lt;code&gt;meson-scripts/&lt;/code&gt; use &lt;code&gt;bash&lt;/code&gt; and standard utilities including &lt;code&gt;awk&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clang&lt;/code&gt;: &amp;gt;=16 required, &amp;gt;=17 recommended&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;libbpf&lt;/code&gt;: &amp;gt;=1.2.2 required, &amp;gt;=1.3 recommended (&lt;code&gt;RESIZE_ARRAY&lt;/code&gt; support is new in 1.3)&lt;/li&gt; &#xA; &lt;li&gt;Rust toolchain: &amp;gt;=1.72&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;libelf&lt;/code&gt;, &lt;code&gt;libz&lt;/code&gt;, &lt;code&gt;libzstd&lt;/code&gt; if linking against staic &lt;code&gt;libbpf.a&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bpftool&lt;/code&gt; (usually available in &lt;code&gt;linux-tools-common&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Setting Up and Building&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;meson&lt;/code&gt; always uses a separate build directory. Running the following commands in the root of the tree builds and installs all schedulers under &lt;code&gt;~/bin&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $SCX&#xA;$ meson setup build --prefix ~&#xA;$ meson compile -C build&#xA;$ meson install -C build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;meson compile&lt;/code&gt; step is not strictly necessary as &lt;code&gt;install&lt;/code&gt; implies &lt;code&gt;compile&lt;/code&gt;. The above also will build debug binaries with optimizations turned off, which is useful for development but they aren&#39;t optimized and big. For actual use you want to build release binaries. &lt;code&gt;meson&lt;/code&gt; uses &lt;code&gt;-D&lt;/code&gt; argument to specify build options. The configuration options can be specified at &lt;code&gt;setup&lt;/code&gt; time but can also be changed afterwards and &lt;code&gt;meson&lt;/code&gt; will do the right thing. To switch to release builds, run the following in the build directory and then compile and install again.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ meson configure -Dbuildtype=release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running &lt;code&gt;meson configure&lt;/code&gt; without any argument shows all current build options. For more information on &lt;code&gt;meson&lt;/code&gt; arguments and built-in options, please refer to &lt;code&gt;meson --help&lt;/code&gt; and its &lt;a href=&#34;https://mesonbuild.com/Builtin-options.html&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Building Specific Schedulers and Binary Locations&lt;/h3&gt; &#xA;&lt;p&gt;If you just want to build a subset of schedulers, you can specify the scheduler names as arguments to &lt;code&gt;meson compile&lt;/code&gt;. For example, if we just want to build the simple example scheduler &lt;code&gt;scheds/c/scx_simple&lt;/code&gt; and the Rust userspace scheduler &lt;code&gt;scheds/rust/scx_rusty&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $SCX&#xA;$ meson setup build -Dbuildtype=release&#xA;$ meson compile -C build scx_simple scx_rusty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify &lt;code&gt;-v&lt;/code&gt; if you want to see the commands being used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ meson compile -C build -v scx_pair&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For C userspace schedulers such as the ones under &lt;code&gt;scheds/c&lt;/code&gt;, the built binaries are located in the same directory under the build root. For example, here, the &lt;code&gt;scx_simple&lt;/code&gt; binary can be found at &lt;code&gt;$SCX/build/scheds/c/scx_simple&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For Rust userspace schedulers such as the ones under &lt;code&gt;scheds/rust&lt;/code&gt;, the same directory under the build root is used as the cargo build target directory. Thus, here, the &lt;code&gt;scx_rusty&lt;/code&gt; binary can be found at &lt;code&gt;$SCX/build/scheds/rust/scx_rusty/release/scx_rusty&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;SCX specific build options&lt;/h3&gt; &#xA;&lt;p&gt;While the default options should work in most cases, it may be desirable to override some of the toolchains and dependencies - e.g. to directly use &lt;code&gt;libbpf&lt;/code&gt; built from the kernel source tree. The following &lt;code&gt;meson&lt;/code&gt; build options can be used in such cases.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;bpf_clang&lt;/code&gt;: &lt;code&gt;clang&lt;/code&gt; to use when compiling &lt;code&gt;.bpf.c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bpftool&lt;/code&gt;: &lt;code&gt;bpftool&lt;/code&gt; to use when generating &lt;code&gt;.bpf.skel.h&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;libbpf_a&lt;/code&gt;: Static &lt;code&gt;libbpf.a&lt;/code&gt; to use&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;libbpf_h&lt;/code&gt;: &lt;code&gt;libbpf&lt;/code&gt; header directories, only meaningful with &lt;code&gt;libbpf_a&lt;/code&gt; option&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo&lt;/code&gt;: &lt;code&gt;cargo&lt;/code&gt; to use when building rust sub-projects&lt;/li&gt; &#xA; &lt;li&gt;&#39;cargo_home&#39;: &#39;CARGO_HOME env to use when invoking cargo&#39;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;offline&lt;/code&gt;: &#39;Compilation step should not access the internet&#39;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;enable_rust&lt;/code&gt;: &#39;Enable the build of rust sub-projects&#39;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example, let&#39;s say you want to use &lt;code&gt;bpftool&lt;/code&gt; and &lt;code&gt;libbpf&lt;/code&gt; shipped in the kernel tree located at &lt;code&gt;$KERNEL&lt;/code&gt;. We need to build &lt;code&gt;bpftool&lt;/code&gt; in the kernel tree first, set up SCX build with the related options and then build &amp;amp; install.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $KERNEL&#xA;$ make -C tools/bpf/bpftool&#xA;$ cd $SCX&#xA;$ BPFTOOL=$KERNEL/tools/bpf/bpftool&#xA;$ meson setup build -Dbuildtype=release -Dprefix=~/bin \&#xA;    -Dbpftool=$BPFTOOL/bpftool \&#xA;    -Dlibbpf_a=$BPFTOOL/libbpf/libbpf.a \&#xA;    -Dlibbpf_h=$BPFTOOL/libbpf/include&#xA;$ meson install -C build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that we use &lt;code&gt;libbpf&lt;/code&gt; which was produced as a part of &lt;code&gt;bpftool&lt;/code&gt; build process rather than buliding &lt;code&gt;libbpf&lt;/code&gt; directly. This is necessary because &lt;code&gt;libbpf&lt;/code&gt; header files need to be installed for them to be in the expected relative locations.&lt;/p&gt; &#xA;&lt;h3&gt;Offline Compilation&lt;/h3&gt; &#xA;&lt;p&gt;Rust builds automatically download dependencies from crates.io; however, some build environments might not allow internet access requiring all dependencies to be available offline. The &lt;code&gt;fetch&lt;/code&gt; target and &lt;code&gt;offline&lt;/code&gt; option are provided for such cases.&lt;/p&gt; &#xA;&lt;p&gt;The following downloads all Rust dependencies into &lt;code&gt;$HOME/cargo-deps&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $SCX&#xA;$ meson setup build -Dcargo_home=$HOME/cargo-deps&#xA;$ meson compile -C build fetch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following builds the schedulers without accessing the internet. The &lt;code&gt;build&lt;/code&gt; directory doesn&#39;t have to be the same one. The only requirement is that the &lt;code&gt;cargo_home&lt;/code&gt; option points to a directory which contains the content generated from the previous step.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $SCX&#xA;$ meson setup build -Dcargo_home=$HOME/cargo-deps -Doffline=true -Dbuildtype=release&#xA;$ meson compile -C build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Working with Rust Sub-projects&lt;/h3&gt; &#xA;&lt;p&gt;Each Rust sub-project is its own self-contained cargo project. When buildng as a part of this repository, &lt;code&gt;meson&lt;/code&gt; invokes &lt;code&gt;cargo&lt;/code&gt; with the appropriate options and environment variables to sync the build environment. When building separately by running &lt;code&gt;cargo build&lt;/code&gt; directly in a sub-project directory, it will automatically figure out build environment. Please take a look at the &lt;a href=&#34;https://docs.rs/scx_utils/latest/scx_utils/struct.BpfBuilder.html&#34;&gt;&lt;code&gt;scx_utils::BpfBuilder&lt;/code&gt;&lt;/a&gt; documentation for details.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following builds and runs the &lt;code&gt;scx_rusty&lt;/code&gt; scheduler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd $SCX/scheds/rust/scx_rusty&#xA;$ cargo build --release&#xA;$ cargo run --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here too, the &lt;code&gt;build&lt;/code&gt; step is not strictly necessary as it&#39;s implied by &lt;code&gt;run&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that Rust userspace schedulers are published on &lt;code&gt;crates.io&lt;/code&gt; and can be built and installed without cloning this repository as long as the necessary toolchains are available. Simply run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cargo install scx_rusty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and &lt;code&gt;scx_rusty&lt;/code&gt; will be built and installed as &lt;code&gt;~/.cargo/bin/scx_rusty&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Kernel Feature Status&lt;/h2&gt; &#xA;&lt;p&gt;The kernel feature is not yet upstream and can be found in the &lt;a href=&#34;https://github.com/sched-ext/sched_ext&#34;&gt;sched_ext&lt;/a&gt; repository. The followings are important branches:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sched-ext/sched_ext&#34;&gt;&lt;code&gt;sched_ext&lt;/code&gt;&lt;/a&gt;: The main development branch. This branch periodically pulls from the &lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/&#34;&gt;bpf-next&lt;/a&gt; tree to stay in sync with the kernel and BPF developments.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sched_ext-release-*&lt;/code&gt;: sched_ext backports on top of released kernels. We plan to maintain backports for a few recent kernel releases until sched_ext is merged upstream. Currently maintained backports: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/sched-ext/sched_ext/tree/sched_ext-release-v6.6&#34;&gt;&lt;code&gt;sched_ext-release-v6.6&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sched_ext-vN&lt;/code&gt;: Patchsets posted upstream. The v4 LKML thread has high-level discussions. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/htejun/sched_ext&#34;&gt;RFC&lt;/a&gt;: &lt;a href=&#34;http://lkml.kernel.org/r/20221130082313.3241517-1-tj@kernel.org&#34;&gt;LMKL thread&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/sched-ext/sched_ext/tree/sched_ext-v2&#34;&gt;`sched_ext-v2&#39;&lt;/a&gt;: &lt;a href=&#34;http://lkml.kernel.org/r/20230128001639.3510083-1-tj@kernel.org&#34;&gt;LKML thread&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/sched-ext/sched_ext/tree/sched_ext-v3&#34;&gt;`sched_ext-v3&#39;&lt;/a&gt;: &lt;a href=&#34;http://lkml.kernel.org/r/20230317213333.2174969-1-tj@kernel.org&#34;&gt;LKML thread&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/sched-ext/sched_ext/tree/sched_ext-v4&#34;&gt;`sched_ext-v4&#39;&lt;/a&gt;: &lt;a href=&#34;http://lkml.kernel.org/r/20230711011412.100319-1-tj@kernel.org&#34;&gt;LKML thread&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/sched-ext/sched_ext/tree/sched_ext-v5&#34;&gt;`sched_ext-v5&#39;&lt;/a&gt;: &lt;a href=&#34;http://lkml.kernel.org/r/20231111024835.2164816-1-tj@kernel.org&#34;&gt;LKML thread&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting in Touch&lt;/h2&gt; &#xA;&lt;p&gt;We aim to build a friendly and approachable community around sched_ext. You can reach us through the following channels:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;github: &lt;a href=&#34;https://github.com/sched-ext/scx&#34;&gt;https://github.com/sched-ext/scx&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Slack: &lt;a href=&#34;https://schedextworkspace.slack.com&#34;&gt;https://schedextworkspace.slack.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Reddit: &lt;a href=&#34;https://reddit.com/r/sched_ext&#34;&gt;https://reddit.com/r/sched_ext&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We also hold weekly office hours every monday. Please see the #office-hours channel on slack for details. To join the slack community, you can use &lt;a href=&#34;https://bit.ly/scx_slack&#34;&gt;this link&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Additional Resources&lt;/h2&gt; &#xA;&lt;p&gt;There are blog posts and articles about sched_ext, which helps you to explore sched_ext in various ways. Followings are some examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://lwn.net/Articles/922405/&#34;&gt;LWN: The extensible scheduler class (February, 2023)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://arighi.blogspot.com/2023/07/implement-your-own-cpu-scheduler-in.html&#34;&gt;arighi&#39;s blog: Implement your own kernel CPU scheduler in Ubuntu with sched-ext (July, 2023)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blogs.igalia.com/changwoo/sched-ext-a-bpf-extensible-scheduler-class-part-1/&#34;&gt;Changwoo&#39;s blog: sched_ext: a BPF-extensible scheduler class (Part 1) (December, 2023)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>