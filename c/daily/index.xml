<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-11T01:31:14Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fogleman/Craft</title>
    <updated>2022-12-11T01:31:14Z</updated>
    <id>tag:github.com,2022-12-11:/fogleman/Craft</id>
    <link href="https://github.com/fogleman/Craft" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A simple Minecraft clone written in C using modern OpenGL (shaders).&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Craft&lt;/h2&gt; &#xA;&lt;p&gt;Minecraft clone for Windows, Mac OS X and Linux. Just a few thousand lines of C using modern OpenGL (shaders). Online multiplayer support is included using a Python-based server.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.michaelfogleman.com/craft/&#34;&gt;http://www.michaelfogleman.com/craft/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SH7wcas.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple but nice looking terrain generation using perlin / simplex noise.&lt;/li&gt; &#xA; &lt;li&gt;More than 10 types of blocks and more can be added easily.&lt;/li&gt; &#xA; &lt;li&gt;Supports plants (grass, flowers, trees, etc.) and transparency (glass).&lt;/li&gt; &#xA; &lt;li&gt;Simple clouds in the sky (they don&#39;t move).&lt;/li&gt; &#xA; &lt;li&gt;Day / night cycles and a textured sky dome.&lt;/li&gt; &#xA; &lt;li&gt;World changes persisted in a sqlite3 database.&lt;/li&gt; &#xA; &lt;li&gt;Multiplayer support!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Download&lt;/h3&gt; &#xA;&lt;p&gt;Mac and Windows binaries are available on the website.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.michaelfogleman.com/craft/&#34;&gt;http://www.michaelfogleman.com/craft/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;See below to run from source.&lt;/p&gt; &#xA;&lt;h3&gt;Install Dependencies&lt;/h3&gt; &#xA;&lt;h4&gt;Mac OS X&lt;/h4&gt; &#xA;&lt;p&gt;Download and install &lt;a href=&#34;http://www.cmake.org/cmake/resources/software.html&#34;&gt;CMake&lt;/a&gt; if you don&#39;t already have it. You may use &lt;a href=&#34;http://brew.sh&#34;&gt;Homebrew&lt;/a&gt; to simplify the installation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;brew install cmake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Linux (Ubuntu)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install cmake libglew-dev xorg-dev libcurl4-openssl-dev&#xA;sudo apt-get build-dep glfw&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;p&gt;Download and install &lt;a href=&#34;http://www.cmake.org/cmake/resources/software.html&#34;&gt;CMake&lt;/a&gt; and &lt;a href=&#34;http://www.mingw.org/&#34;&gt;MinGW&lt;/a&gt;. Add &lt;code&gt;C:\MinGW\bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Download and install &lt;a href=&#34;http://curl.haxx.se/download.html&#34;&gt;cURL&lt;/a&gt; so that CURL/lib and CURL/include are in your Program Files directory.&lt;/p&gt; &#xA;&lt;p&gt;Use the following commands in place of the ones described in the next section.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -G &#34;MinGW Makefiles&#34;&#xA;mingw32-make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compile and Run&lt;/h3&gt; &#xA;&lt;p&gt;Once you have the dependencies (see above), run the following commands in your terminal.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/fogleman/Craft.git&#xA;cd Craft&#xA;cmake .&#xA;make&#xA;./craft&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Multiplayer&lt;/h3&gt; &#xA;&lt;p&gt;After many years, craft.michaelfogleman.com has been taken down. See the &lt;a href=&#34;https://raw.githubusercontent.com/fogleman/Craft/master/#server&#34;&gt;Server&lt;/a&gt; section for info on self-hosting.&lt;/p&gt; &#xA;&lt;h4&gt;Client&lt;/h4&gt; &#xA;&lt;p&gt;You can connect to a server with command line arguments...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./craft [HOST [PORT]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, with the &#34;/online&#34; command in the game itself.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/online [HOST [PORT]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Server&lt;/h4&gt; &#xA;&lt;p&gt;You can run your own server or connect to mine. The server is written in Python but requires a compiled DLL so it can perform the terrain generation just like the client.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc -std=c99 -O3 -fPIC -shared -o world -I src -I deps/noise deps/noise/noise.c src/world.c&#xA;python server.py [HOST [PORT]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Controls&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;WASD to move forward, left, backward, right.&lt;/li&gt; &#xA; &lt;li&gt;Space to jump.&lt;/li&gt; &#xA; &lt;li&gt;Left Click to destroy a block.&lt;/li&gt; &#xA; &lt;li&gt;Right Click or Cmd + Left Click to create a block.&lt;/li&gt; &#xA; &lt;li&gt;Ctrl + Right Click to toggle a block as a light source.&lt;/li&gt; &#xA; &lt;li&gt;1-9 to select the block type to create.&lt;/li&gt; &#xA; &lt;li&gt;E to cycle through the block types.&lt;/li&gt; &#xA; &lt;li&gt;Tab to toggle between walking and flying.&lt;/li&gt; &#xA; &lt;li&gt;ZXCVBN to move in exact directions along the XYZ axes.&lt;/li&gt; &#xA; &lt;li&gt;Left shift to zoom.&lt;/li&gt; &#xA; &lt;li&gt;F to show the scene in orthographic mode.&lt;/li&gt; &#xA; &lt;li&gt;O to observe players in the main view.&lt;/li&gt; &#xA; &lt;li&gt;P to observe players in the picture-in-picture view.&lt;/li&gt; &#xA; &lt;li&gt;T to type text into chat.&lt;/li&gt; &#xA; &lt;li&gt;Forward slash (/) to enter a command.&lt;/li&gt; &#xA; &lt;li&gt;Backquote (`) to write text on any block (signs).&lt;/li&gt; &#xA; &lt;li&gt;Arrow keys emulate mouse movement.&lt;/li&gt; &#xA; &lt;li&gt;Enter emulates mouse click.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Chat Commands&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;/goto [NAME]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Teleport to another user. If NAME is unspecified, a random user is chosen.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/list&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Display a list of connected users.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/login NAME&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Switch to another registered username. The login server will be re-contacted. The username is case-sensitive.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/logout&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unauthenticate and become a guest user. Automatic logins will not occur again until the /login command is re-issued.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/offline [FILE]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Switch to offline mode. FILE specifies the save file to use and defaults to &#34;craft&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/online HOST [PORT]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Connect to the specified server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/pq P Q&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Teleport to the specified chunk.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/spawn&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Teleport back to the spawn point.&lt;/p&gt; &#xA;&lt;h3&gt;Screenshot&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/foYz3aN.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Implementation Details&lt;/h3&gt; &#xA;&lt;h4&gt;Terrain Generation&lt;/h4&gt; &#xA;&lt;p&gt;The terrain is generated using Simplex noise - a deterministic noise function seeded based on position. So the world will always be generated the same way in a given location.&lt;/p&gt; &#xA;&lt;p&gt;The world is split up into 32x32 block chunks in the XZ plane (Y is up). This allows the world to be “infinite” (floating point precision is currently a problem at large X or Z values) and also makes it easier to manage the data. Only visible chunks need to be queried from the database.&lt;/p&gt; &#xA;&lt;h4&gt;Rendering&lt;/h4&gt; &#xA;&lt;p&gt;Only exposed faces are rendered. This is an important optimization as the vast majority of blocks are either completely hidden or are only exposing one or two faces. Each chunk records a one-block width overlap for each neighboring chunk so it knows which blocks along its perimeter are exposed.&lt;/p&gt; &#xA;&lt;p&gt;Only visible chunks are rendered. A naive frustum-culling approach is used to test if a chunk is in the camera’s view. If it is not, it is not rendered. This results in a pretty decent performance improvement as well.&lt;/p&gt; &#xA;&lt;p&gt;Chunk buffers are completely regenerated when a block is changed in that chunk, instead of trying to update the VBO.&lt;/p&gt; &#xA;&lt;p&gt;Text is rendered using a bitmap atlas. Each character is rendered onto two triangles forming a 2D rectangle.&lt;/p&gt; &#xA;&lt;p&gt;“Modern” OpenGL is used - no deprecated, fixed-function pipeline functions are used. Vertex buffer objects are used for position, normal and texture coordinates. Vertex and fragment shaders are used for rendering. Matrix manipulation functions are in matrix.c for translation, rotation, perspective, orthographic, etc. matrices. The 3D models are made up of very simple primitives - mostly cubes and rectangles. These models are generated in code in cube.c.&lt;/p&gt; &#xA;&lt;p&gt;Transparency in glass blocks and plants (plants don’t take up the full rectangular shape of their triangle primitives) is implemented by discarding magenta-colored pixels in the fragment shader.&lt;/p&gt; &#xA;&lt;h4&gt;Database&lt;/h4&gt; &#xA;&lt;p&gt;User changes to the world are stored in a sqlite database. Only the delta is stored, so the default world is generated and then the user changes are applied on top when loading.&lt;/p&gt; &#xA;&lt;p&gt;The main database table is named “block” and has columns p, q, x, y, z, w. (p, q) identifies the chunk, (x, y, z) identifies the block position and (w) identifies the block type. 0 represents an empty block (air).&lt;/p&gt; &#xA;&lt;p&gt;In game, the chunks store their blocks in a hash map. An (x, y, z) key maps to a (w) value.&lt;/p&gt; &#xA;&lt;p&gt;The y-position of blocks are limited to 0 &amp;lt;= y &amp;lt; 256. The upper limit is mainly an artificial limitation to prevent users from building unnecessarily tall structures. Users are not allowed to destroy blocks at y = 0 to avoid falling underneath the world.&lt;/p&gt; &#xA;&lt;h4&gt;Multiplayer&lt;/h4&gt; &#xA;&lt;p&gt;Multiplayer mode is implemented using plain-old sockets. A simple, ASCII, line-based protocol is used. Each line is made up of a command code and zero or more comma-separated arguments. The client requests chunks from the server with a simple command: C,p,q,key. “C” means “Chunk” and (p, q) identifies the chunk. The key is used for caching - the server will only send block updates that have been performed since the client last asked for that chunk. Block updates (in realtime or as part of a chunk request) are sent to the client in the format: B,p,q,x,y,z,w. After sending all of the blocks for a requested chunk, the server will send an updated cache key in the format: K,p,q,key. The client will store this key and use it the next time it needs to ask for that chunk. Player positions are sent in the format: P,pid,x,y,z,rx,ry. The pid is the player ID and the rx and ry values indicate the player’s rotation in two different axes. The client interpolates player positions from the past two position updates for smoother animation. The client sends its position to the server at most every 0.1 seconds (less if not moving).&lt;/p&gt; &#xA;&lt;p&gt;Client-side caching to the sqlite database can be performance intensive when connecting to a server for the first time. For this reason, sqlite writes are performed on a background thread. All writes occur in a transaction for performance. The transaction is committed every 5 seconds as opposed to some logical amount of work completed. A ring / circular buffer is used as a queue for what data is to be written to the database.&lt;/p&gt; &#xA;&lt;p&gt;In multiplayer mode, players can observe one another in the main view or in a picture-in-picture view. Implementation of the PnP was surprisingly simple - just change the viewport and render the scene again from the other player’s point of view.&lt;/p&gt; &#xA;&lt;h4&gt;Collision Testing&lt;/h4&gt; &#xA;&lt;p&gt;Hit testing (what block the user is pointing at) is implemented by scanning a ray from the player’s position outward, following their sight vector. This is not a precise method, so the step rate can be made smaller to be more accurate.&lt;/p&gt; &#xA;&lt;p&gt;Collision testing simply adjusts the player’s position to remain a certain distance away from any adjacent blocks that are obstacles. (Clouds and plants are not marked as obstacles, so you pass right through them.)&lt;/p&gt; &#xA;&lt;h4&gt;Sky Dome&lt;/h4&gt; &#xA;&lt;p&gt;A textured sky dome is used for the sky. The X-coordinate of the texture represents time of day. The Y-values map from the bottom of the sky sphere to the top of the sky sphere. The player is always in the center of the sphere. The fragment shaders for the blocks also sample the sky texture to determine the appropriate fog color to blend with based on the block’s position relative to the backing sky.&lt;/p&gt; &#xA;&lt;h4&gt;Ambient Occlusion&lt;/h4&gt; &#xA;&lt;p&gt;Ambient occlusion is implemented as described on this page:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://0fps.wordpress.com/2013/07/03/ambient-occlusion-for-minecraft-like-worlds/&#34;&gt;http://0fps.wordpress.com/2013/07/03/ambient-occlusion-for-minecraft-like-worlds/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Dependencies&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GLEW is used for managing OpenGL extensions across platforms.&lt;/li&gt; &#xA; &lt;li&gt;GLFW is used for cross-platform window management.&lt;/li&gt; &#xA; &lt;li&gt;CURL is used for HTTPS / SSL POST for the authentication process.&lt;/li&gt; &#xA; &lt;li&gt;lodepng is used for loading PNG textures.&lt;/li&gt; &#xA; &lt;li&gt;sqlite3 is used for saving the blocks added / removed by the user.&lt;/li&gt; &#xA; &lt;li&gt;tinycthread is used for cross-platform threading.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>strongswan/strongswan</title>
    <updated>2022-12-11T01:31:14Z</updated>
    <id>tag:github.com,2022-12-11:/strongswan/strongswan</id>
    <link href="https://github.com/strongswan/strongswan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;strongSwan - IPsec-based VPN&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;strongSwan Configuration&lt;/h1&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;strongSwan is an OpenSource IPsec-based VPN solution.&lt;/p&gt; &#xA;&lt;p&gt;This document is just a short introduction of the strongSwan &lt;strong&gt;swanctl&lt;/strong&gt; command which uses the modern &lt;a href=&#34;https://raw.githubusercontent.com/strongswan/strongswan/master/src/libcharon/plugins/vici/README.md&#34;&gt;&lt;strong&gt;vici&lt;/strong&gt;&lt;/a&gt; &lt;em&gt;Versatile IKE Configuration Interface&lt;/em&gt;. The deprecated &lt;strong&gt;ipsec&lt;/strong&gt; command using the legacy &lt;strong&gt;stroke&lt;/strong&gt; configuration interface is described &lt;a href=&#34;https://raw.githubusercontent.com/strongswan/strongswan/master/README_LEGACY.md&#34;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;. For more detailed information consult the man pages, our new &lt;a href=&#34;https://docs.strongswan.org&#34;&gt;&lt;strong&gt;documentation site&lt;/strong&gt;&lt;/a&gt; and the legacy &lt;a href=&#34;https://wiki.strongswan.org&#34;&gt;&lt;strong&gt;wiki&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Certificates for users, hosts and gateways are issued by a fictitious strongSwan CA. In our example scenarios the CA certificate &lt;code&gt;strongswanCert.pem&lt;/code&gt; must be present on all VPN endpoints in order to be able to authenticate the peers. For your particular VPN application you can either use certificates from any third-party CA or generate the needed private keys and certificates yourself with the strongSwan &lt;strong&gt;pki&lt;/strong&gt; tool, the use of which will be explained in one of the sections following below.&lt;/p&gt; &#xA;&lt;h3&gt;Site-to-Site Case&lt;/h3&gt; &#xA;&lt;p&gt;In this scenario two security gateways &lt;em&gt;moon&lt;/em&gt; and &lt;em&gt;sun&lt;/em&gt; will connect the two subnets &lt;em&gt;moon-net&lt;/em&gt; and &lt;em&gt;sun-net&lt;/em&gt; with each other through a VPN tunnel set up between the two gateways:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10.1.0.0/16 -- | 192.168.0.1 | === | 192.168.0.2 | -- 10.2.0.0/16&#xA;  moon-net          moon                 sun           sun-net&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        net-net {&#xA;            remote_addrs = 192.168.0.2&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = moonCert.pem&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = &#34;C=CH, O=strongSwan, CN=sun.strongswan.org&#34;&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                    remote_ts = 10.2.0.0/16&#xA;                    start_action = trap&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;sun&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/sunCert.pem&#xA;/etc/swanctl/private/sunKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        net-net {&#xA;            remote_addrs = 192.168.0.1&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = sunCert.pem&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = &#34;C=CH, O=strongSwan, CN=moon.strongswan.org&#34;&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.2.0.0/16&#xA;                    remote_ts = 10.1.0.0/16&#xA;                    start_action = trap&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The local and remote identities used in this scenario are the &lt;em&gt;subjectDistinguishedNames&lt;/em&gt; contained in the end entity certificates. The certificates and private keys are loaded into the &lt;strong&gt;charon&lt;/strong&gt; daemon with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;swanctl --load-creds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;whereas&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;swanctl --load-conns&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;loads the connections defined in &lt;code&gt;swanctl.conf&lt;/code&gt;. With &lt;code&gt;start_action = trap&lt;/code&gt; the IPsec connection is automatically set up with the first plaintext payload IP packet wanting to go through the tunnel.&lt;/p&gt; &#xA;&lt;h3&gt;Host-to-Host Case&lt;/h3&gt; &#xA;&lt;p&gt;This is a setup between two single hosts which don&#39;t have a subnet behind them. Although IPsec transport mode would be sufficient for host-to-host connections we will use the default IPsec tunnel mode.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;| 192.168.0.1 | === | 192.168.0.2 |&#xA;     moon                sun&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on host &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        host-host {&#xA;            remote_addrs = 192.168.0.2&#xA;&#xA;            local {&#xA;                auth=pubkey&#xA;                certs = moonCert.pem&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = &#34;C=CH, O=strongSwan, CN=sun.strongswan.org&#34;&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    start_action = trap&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on host &lt;em&gt;sun&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/sunCert.pem&#xA;/etc/swanctl/private/sunKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        host-host {&#xA;            remote_addrs = 192.168.0.1&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = sunCert.pem&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = &#34;C=CH, O=strongSwan, CN=moon.strongswan.org&#34;&#xA;            }&#xA;            children {&#xA;                host-host {&#xA;                    start_action = trap&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Roadwarrior Case&lt;/h3&gt; &#xA;&lt;p&gt;This is a very common case where a strongSwan gateway serves an arbitrary number of remote VPN clients usually having dynamic IP addresses.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10.1.0.0/16 -- | 192.168.0.1 | === | x.x.x.x |&#xA;  moon-net          moon              carol&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        rw {&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = moonCert.pem&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on roadwarrior &lt;em&gt;carol&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/carolCert.pem&#xA;/etc/swanctl/private/carolKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        home {&#xA;            remote_addrs = moon.strongswan.org&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = carolCert.pem&#xA;                id = carol@strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            children {&#xA;                home {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                    start_action = start&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;code&gt;remote_addrs&lt;/code&gt; the hostname &lt;code&gt;moon.strongswan.org&lt;/code&gt; was chosen which will be resolved by DNS at runtime into the corresponding IP destination address. In this scenario the identity of the roadwarrior &lt;code&gt;carol&lt;/code&gt; is the email address &lt;code&gt;carol@strongswan.org&lt;/code&gt; which must be included as a &lt;em&gt;subjectAlternativeName&lt;/em&gt; in the roadwarrior certificate &lt;code&gt;carolCert.pem&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Roadwarrior Case with Virtual IP&lt;/h3&gt; &#xA;&lt;p&gt;Roadwarriors usually have dynamic IP addresses assigned by the ISP they are currently attached to. In order to simplify the routing from &lt;em&gt;moon-net&lt;/em&gt; back to the remote access client &lt;em&gt;carol&lt;/em&gt; it would be desirable if the roadwarrior had an inner IP address chosen from a pre-defined pool.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10.1.0.0/16 -- | 192.168.0.1 | === | x.x.x.x | -- 10.3.0.1&#xA;  moon-net          moon              carol       virtual IP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In our example the virtual IP address is chosen from the address pool &lt;code&gt;10.3.0.0/16&lt;/code&gt; which can be configured by adding the section&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pools {&#xA;    rw_pool {&#xA;        addrs = 10.3.0.0/16&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to the gateway&#39;s &lt;code&gt;swanctl.conf&lt;/code&gt; from where they are loaded into the &lt;strong&gt;charon&lt;/strong&gt; daemon using the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;swanctl --load-pools&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To request an IP address from this pool a roadwarrior can use IKEv1 mode config or IKEv2 configuration payloads. The configuration for both is the same&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;vips = 0.0.0.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        rw {&#xA;            pools = rw_pool&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = moonCert.pem&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    pools {&#xA;        rw_pool {&#xA;            addrs = 10.30.0.0/16&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on roadwarrior &lt;em&gt;carol&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/carolCert.pem&#xA;/etc/swanctl/private/carolKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        home {&#xA;            remote_addrs = moon.strongswan.org&#xA;            vips = 0.0.0.0&#xA;&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = carolCert.pem&#xA;                id = carol@strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            children {&#xA;                home {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                    start_action = start&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Roadwarrior Case with EAP Authentication&lt;/h3&gt; &#xA;&lt;p&gt;This is a very common case where a strongSwan gateway serves an arbitrary number of remote VPN clients which authenticate themselves via a password based &lt;em&gt;Extended Authentication Protocol&lt;/em&gt; as e.g. &lt;em&gt;EAP-MD5&lt;/em&gt; or &lt;em&gt;EAP-MSCHAPv2&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10.1.0.0/16 -- | 192.168.0.1 | === | x.x.x.x |&#xA;  moon-net          moon              carol&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        rw {&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = moonCert.pem&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = eap-md5&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                }&#xA;            }&#xA;            send_certreq = no&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;swanctl.conf&lt;/code&gt; file additionally contains a &lt;code&gt;secrets&lt;/code&gt; section defining all client credentials&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    secrets {&#xA;        eap-carol {&#xA;            id = carol@strongswan.org&#xA;            secret = Ar3etTnp&#xA;        }&#xA;        eap-dave {&#xA;            id = dave@strongswan.org&#xA;            secret = W7R0g3do&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on roadwarrior &lt;em&gt;carol&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        home {&#xA;            remote_addrs = moon.strongswan.org&#xA;&#xA;            local {&#xA;                auth = eap&#xA;                id = carol@strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            children {&#xA;                home {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                    start_action = start&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    secrets {&#xA;        eap-carol {&#xA;            id = carol@strongswan.org&#xA;            secret = Ar3etTnp&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Roadwarrior Case with EAP Identity&lt;/h3&gt; &#xA;&lt;p&gt;Often a client EAP identity is exchanged via EAP which differs from the external IKEv2 identity. In this example the IKEv2 identity defaults to the IPv4 address of the client.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10.1.0.0/16 -- | 192.168.0.1 | === | x.x.x.x |&#xA;  moon-net          moon              carol&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on gateway &lt;em&gt;moon&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;/etc/swanctl/x509/moonCert.pem&#xA;/etc/swanctl/private/moonKey.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        rw {&#xA;            local {&#xA;                auth = pubkey&#xA;                certs = moonCert.pem&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            remote {&#xA;                auth = eap-md5&#xA;                eap_id = %any&#xA;            }&#xA;            children {&#xA;                net-net {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                }&#xA;            }&#xA;            send_certreq = no&#xA;        }&#xA;    }&#xA;&#xA;    secrets {&#xA;        eap-carol {&#xA;            id = carol&#xA;            secret = Ar3etTnp&#xA;        }&#xA;        eap-dave {&#xA;            id = dave&#xA;            secret = W7R0g3do&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Configuration on roadwarrior &lt;em&gt;carol&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/etc/swanctl/x509ca/strongswanCert.pem&#xA;&#xA;/etc/swanctl/swanctl.conf:&#xA;&#xA;    connections {&#xA;        home {&#xA;            remote_addrs = moon.strongswan.org&#xA;&#xA;            local {&#xA;                auth = eap&#xA;                eap_id = carol&#xA;            }&#xA;            remote {&#xA;                auth = pubkey&#xA;                id = moon.strongswan.org&#xA;            }&#xA;            children {&#xA;                home {&#xA;                    local_ts  = 10.1.0.0/16&#xA;                    start_action = start&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    secrets {&#xA;        eap-carol {&#xA;            id = carol&#xA;            secret = Ar3etTnp&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Generating Certificates and CRLs&lt;/h2&gt; &#xA;&lt;p&gt;This section is not a full-blown tutorial on how to use the strongSwan &lt;strong&gt;pki&lt;/strong&gt; tool. It just lists a few points that are relevant if you want to generate your own certificates and CRLs for use with strongSwan.&lt;/p&gt; &#xA;&lt;h3&gt;Generating a CA Certificate&lt;/h3&gt; &#xA;&lt;p&gt;The pki statement&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --gen --type ed25519 --outform pem &amp;gt; strongswanKey.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;generates an elliptic Edwards-Curve key with a cryptographic strength of 128 bits. The corresponding public key is packed into a self-signed CA certificate with a lifetime of 10 years (3652 days)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --self --ca --lifetime 3652 --in strongswanKey.pem \&#xA;           --dn &#34;C=CH, O=strongSwan, CN=strongSwan Root CA&#34; \&#xA;           --outform pem &amp;gt; strongswanCert.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which can be listed with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --print --in strongswanCert.pem&#xA;&#xA;subject:  &#34;C=CH, O=strongSwan, CN=strongSwan Root CA&#34;&#xA;issuer:   &#34;C=CH, O=strongSwan, CN=strongSwan Root CA&#34;&#xA;validity:  not before May 18 08:32:06 2017, ok&#xA;           not after  May 18 08:32:06 2027, ok (expires in 3651 days)&#xA;serial:    57:e0:6b:3a:9a:eb:c6:e0&#xA;flags:     CA CRLSign self-signed&#xA;subjkeyId: 2b:95:14:5b:c3:22:87&lt;span&gt;🇩🇪&lt;/span&gt;d1:42:91:88:63:b3:d5:c1:92:7a:0f:5d&#xA;pubkey:    ED25519 256 bits&#xA;keyid:     a7:e1:6a:3f:e7:6f:08:9d:89:ec:23:92:a9:a1:14:3c:78:a8:7a:f7&#xA;subjkey:   2b:95:14:5b:c3:22:87&lt;span&gt;🇩🇪&lt;/span&gt;d1:42:91:88:63:b3:d5:c1:92:7a:0f:5d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you prefer the CA private key and X.509 certificate to be in binary DER format then just omit the &lt;code&gt;--outform pem&lt;/code&gt; option. The directory &lt;code&gt;/etc/swanctl/x509ca&lt;/code&gt; contains all required CA certificates either in binary DER or in Base64 PEM format. Irrespective of the file suffix the correct format will be determined by strongSwan automagically.&lt;/p&gt; &#xA;&lt;h3&gt;Generating a Host or User End Entity Certificate&lt;/h3&gt; &#xA;&lt;p&gt;Again we are using the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --gen --type ed25519 --outform pem &amp;gt; moonKey.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to generate an Ed25519 private key for the host &lt;code&gt;moon&lt;/code&gt;. Alternatively you could type&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --gen --type rsa --size 3072 &amp;gt; moonKey.der&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to generate a traditional 3072 bit RSA key and store it in binary DER format. As an alternative a &lt;strong&gt;TPM 2.0&lt;/strong&gt; &lt;em&gt;Trusted Platform Module&lt;/em&gt; available on every recent Intel platform could be used as a virtual smartcard to securely store an RSA or ECDSA private key. For details, refer to the TPM 2.0 &lt;a href=&#34;https://docs.strongswan.org/docs/5.9/tpm/tpm2.html&#34;&gt;HOWTO&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In a next step the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --req --type priv --in moonKey.pem \&#xA;          --dn &#34;C=CH, O=strongswan, CN=moon.strongswan.org&#34; \&#xA;          --san moon.strongswan.org --outform pem &amp;gt; moonReq.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;creates a PKCS#10 certificate request that has to be signed by the CA. Through the [multiple] use of the &lt;code&gt;--san&lt;/code&gt; parameter any number of desired &lt;em&gt;subjectAlternativeNames&lt;/em&gt; can be added to the request. These can be of the form&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--san sun.strongswan.org     # fully qualified host name&#xA;--san carol@strongswan.org   # RFC822 user email address&#xA;--san 192.168.0.1            # IPv4 address&#xA;--san fec0::1                # IPv6 address&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Based on the certificate request the CA issues a signed end entity certificate with the following command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --issue --cacert strongswanCert.pem --cakey strongswanKey.pem \&#xA;            --type pkcs10 --in moonReq.pem --serial 01 --lifetime 1826 \&#xA;            --outform pem &amp;gt; moonCert.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the &lt;code&gt;--serial&lt;/code&gt; parameter with a hexadecimal argument is omitted then a random serial number is generated. Some third party VPN clients require that a VPN gateway certificate contains the &lt;em&gt;TLS Server Authentication&lt;/em&gt; Extended Key Usage (EKU) flag which can be included with the following option&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--flag serverAuth&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to use the dynamic CRL fetching feature described in one of the following sections then you may include one or several &lt;em&gt;crlDistributionPoints&lt;/em&gt; in your end entity certificates using the &lt;code&gt;--crl&lt;/code&gt; parameter&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--crl  http://crl.strongswan.org/strongswan.crl&#xA;--crl &#34;ldap://ldap.strongswan.org/cn=strongSwan Root CA, o=strongSwan,c=CH?certificateRevocationList&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The issued host certificate can be listed with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --print --in moonCert.pem&#xA;&#xA;subject:  &#34;C=CH, O=strongSwan, CN=moon.strongswan.org&#34;&#xA;issuer:   &#34;C=CH, O=strongSwan, CN=strongSwan Root CA&#34;&#xA;validity:  not before May 19 10:28:19 2017, ok&#xA;           not after  May 19 10:28:19 2022, ok (expires in 1825 days)&#xA;serial:    01&#xA;altNames:  moon.strongswan.org&#xA;flags:     serverAuth&#xA;CRL URIs:  http://crl.strongswan.org/strongswan.crl&#xA;authkeyId: 2b:95:14:5b:c3:22:87&lt;span&gt;🇩🇪&lt;/span&gt;d1:42:91:88:63:b3:d5:c1:92:7a:0f:5d&#xA;subjkeyId: 60:9d&lt;span&gt;🇩🇪&lt;/span&gt;30:a6:ca:b9:8e:87:bb:33:23:61:19:18:b8:c4:7e:23:8f&#xA;pubkey:    ED25519 256 bits&#xA;keyid:     39:1b:b3:c2:34:72:1a:01:08:40:ce:97:75:b8:be:ce:24:30:26:29&#xA;subjkey:   60:9d&lt;span&gt;🇩🇪&lt;/span&gt;30:a6:ca:b9:8e:87:bb:33:23:61:19:18:b8:c4:7e:23:8f&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Usually, a Windows, OSX, Android or iOS based VPN client needs its private key, its host or user certificate and the CA certificate. The most convenient way to load this information is to put everything into a PKCS#12 container:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;openssl pkcs12 -export -inkey carolKey.pem \&#xA;               -in carolCert.pem -name &#34;carol&#34; \&#xA;               -certfile strongswanCert.pem -caname &#34;strongSwan Root CA&#34; \&#xA;               -out carolCert.p12&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The strongSwan &lt;strong&gt;pki&lt;/strong&gt; tool currently is not able to create PKCS#12 containers so that &lt;strong&gt;openssl&lt;/strong&gt; must be used.&lt;/p&gt; &#xA;&lt;h3&gt;Generating a CRL&lt;/h3&gt; &#xA;&lt;p&gt;An empty CRL that is signed by the CA can be generated with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --signcrl --cacert strongswanCert.pem --cakey strongswanKey.pem \&#xA;              --lifetime 30 &amp;gt; strongswan.crl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you omit the &lt;code&gt;--lifetime&lt;/code&gt; option then the default value of 15 days is used. CRLs can either be uploaded to a HTTP or LDAP server or put in binary DER or Base64 PEM format into the &lt;code&gt;/etc/swanctl/x509crl&lt;/code&gt; directory from where they are loaded into the &lt;strong&gt;charon&lt;/strong&gt; daemon with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;swanctl --load-creds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Revoking a Certificate&lt;/h3&gt; &#xA;&lt;p&gt;A specific end entity certificate is revoked with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --signcrl --cacert strongswanCert.pem --cakey strongswanKey.pem \&#xA;              --lifetime 30 --lastcrl strongswan.crl \&#xA;              --reason key-compromise --cert moonCert.pem &amp;gt; new.crl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of the certificate file (in our example moonCert.pem), the serial number of the certificate to be revoked can be indicated using the &lt;code&gt;--serial&lt;/code&gt; parameter. The &lt;code&gt;pki --signcrl --help&lt;/code&gt; command documents all possible revocation reasons but the &lt;code&gt;--reason&lt;/code&gt; parameter can also be omitted. The content of the new CRL file can be listed with the command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pki --print --type crl --in new.crl&#xA;&#xA;issuer:   &#34;C=CH, O=strongSwan, CN=strongSwan Root CA&#34;&#xA;update:    this on May 19 11:13:01 2017, ok&#xA;           next on Jun 18 11:13:01 2017, ok (expires in 29 days)&#xA;serial:    02&#xA;authKeyId: 2b:95:14:5b:c3:22:87&lt;span&gt;🇩🇪&lt;/span&gt;d1:42:91:88:63:b3:d5:c1:92:7a:0f:5d&#xA;1 revoked certificate:&#xA;  01: May 19 11:13:01 2017, key compromise&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Local Caching of CRLs&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;strongswan.conf&lt;/code&gt; option&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;charon {&#xA;    cache_crls = yes&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;activates the local caching of CRLs that were dynamically fetched from an HTTP or LDAP server. Cached copies are stored in &lt;code&gt;/etc/swanctl/x509crl&lt;/code&gt; using a unique filename formed from the issuer&#39;s &lt;em&gt;subjectKeyIdentifier&lt;/em&gt; and the suffix &lt;code&gt;.crl&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With the cached copy the CRL is immediately available after startup. When the local copy has become stale, an updated CRL is automatically fetched from one of the defined CRL distribution points during the next IKEv2 authentication.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>eunomia-bpf/bpf-developer-tutorial</title>
    <updated>2022-12-11T01:31:14Z</updated>
    <id>tag:github.com,2022-12-11:/eunomia-bpf/bpf-developer-tutorial</id>
    <link href="https://github.com/eunomia-bpf/bpf-developer-tutorial" rel="alternate"></link>
    <summary type="html">&lt;p&gt;eBPF developer tutorials to build CO-RE libbpf tools: generated by ChatGPT and teach ChatGPT to write eBPF programs! ( eBPF 工具开发实践教程: 通过例子学习 eBPF）&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;bpf-develop-tutorial: learn CO-RE ebpf with example tools&lt;/h1&gt; &#xA;&lt;p&gt;这是一个基于 &lt;code&gt;CO-RE&lt;/code&gt;（一次编译，到处运行）的 &lt;code&gt;libbpf&lt;/code&gt; 的 eBPF 的开发教程，提供了从入门到进阶的 eBPF 开发实践指南，包括基本概念、代码实例、实际应用等内容。我们主要提供了一些 eBPF 工具的案例，帮助开发者学习 eBPF 的开发方法和技巧。教程内容可以在目录中找到，每个目录都是一个独立的 eBPF 工具案例。&lt;/p&gt; &#xA;&lt;p&gt;在学习 eBPF 的过程中，我们受到了 &lt;a href=&#34;https://github.com/iovisor/bcc/raw/master/docs/tutorial_bcc_python_developer.md&#34;&gt;tutorial_bcc_python_developer&lt;/a&gt; 的许多启发和帮助，但从 2022 年的角度出发，使用 libbpf 开发 eBPF 的应用是目前相对更好的选择。但目前似乎很少有基于 libbpf 和 BPF CO-RE 出发的、通过案例和工具介绍 eBPF 开发的教程，因此我们发起了这个项目，采用类似 tutorial_bcc_python_developer 的组织方式，但使用 CO-RE 的 libbpf 进行开发。&lt;/p&gt; &#xA;&lt;p&gt;本项目主要基于 &lt;a href=&#34;https://github.com/libbpf/libbpf-bootstrap&#34;&gt;libbpf-boostrap&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/eunomia-bpf/eunomia-bpf&#34;&gt;eunomia-bpf&lt;/a&gt; 两个框架完成，并使用 eunomia-bpf 帮助简化一部分 libbpf eBPF 用户态代码的编写，让开发者专注于内核态的 eBPF 代码的开发。&lt;/p&gt; &#xA;&lt;p&gt;教程主要关注于可观察性，并简要介绍了 eBPF 的其他应用，例如网络、安全等等。&lt;/p&gt; &#xA;&lt;p&gt;Gitee 镜像： &lt;a href=&#34;https://gitee.com/yunwei37/bpf-developer-tutorial&#34;&gt;https://gitee.com/yunwei37/bpf-developer-tutorial&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;让 chatGPT 来帮助我们&lt;/h2&gt; &#xA;&lt;p&gt;本教程大部分内容由 chatGPT 生成，我们尝试教会 chatGPT 编写 eBPF 程序：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;告诉它基本的 eBPF 编程相关的常识&lt;/li&gt; &#xA; &lt;li&gt;告诉它一些案例：hello world，eBPF 程序的基本结构，如何使用 eBPF 程序进行追踪，并且让它开始编写教程&lt;/li&gt; &#xA; &lt;li&gt;手动调整教程，并纠正代码和文档中的错误&lt;/li&gt; &#xA; &lt;li&gt;把修改后的代码再喂给 chatGPT，让它继续学习&lt;/li&gt; &#xA; &lt;li&gt;尝试让 chatGPT 自动生成 eBPF 程序和对应的教程文档！例如&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/imgs/ebpf-chatgpt-signal.png&#34; alt=&#34;ebpf-chatgpt-signal&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;完整的对话记录可以在这里找到: &lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/chatGPT.md&#34;&gt;chatGPT.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;目录&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/0-introduce/README.md&#34;&gt;lesson 0-introduce&lt;/a&gt; 介绍 eBPF 的基本概念和常见的开发工具&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/1-helloworld/README.md&#34;&gt;lesson 1-helloworld&lt;/a&gt; 使用 eBPF 开发最简单的「Hello World」程序，介绍 eBPF 的基本框架和开发流程&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/2-kprobe-unlink/README.md&#34;&gt;lesson 2-kprobe-unlink&lt;/a&gt; 在 eBPF 中使用 kprobe 捕获 unlink 系统调用&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/3-fentry-unlink/README.md&#34;&gt;lesson 3-fentry-unlink&lt;/a&gt; 在 eBPF 中使用 fentry 捕获 unlink 系统调用&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/4-opensnoop/README.md&#34;&gt;lesson 4-opensnoop&lt;/a&gt; 使用 eBPF 捕获进程打开文件的系统调用集合，使用全局变量在 eBPF 中过滤进程 pid&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/5-uprobe-bashreadline/README.md&#34;&gt;lesson 5-uprobe-bashreadline&lt;/a&gt; 在 eBPF 中使用 uprobe 捕获 bash 的 readline 函数调用&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/6-sigsnoop/README.md&#34;&gt;lesson 6-sigsnoop&lt;/a&gt; 捕获进程发送信号的系统调用集合，使用 hash map 保存状态&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/7-execsnoop/README.md&#34;&gt;lesson 7-execsnoop&lt;/a&gt; 捕获进程执行时间，通过 perf event array 向用户态打印输出&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/8-exitsnoop/README.md&#34;&gt;lesson 8-execsnoop&lt;/a&gt; 捕获进程退出事件，使用 ring buffer 向用户态打印输出&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/9-runqlat/README.md&#34;&gt;lesson 9-runqlat&lt;/a&gt; 捕获进程调度延迟，以直方图方式记录&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/10-hardirqs/README.md&#34;&gt;lesson 10-hardirqs&lt;/a&gt; 使用 hardirqs 或 softirqs 捕获中断事件&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/11-bootstrap/README.md&#34;&gt;lesson 11-bootstrap&lt;/a&gt; 使用 libbpf-boostrap 为 eBPF 编写原生的 libbpf 用户态代码，并建立完整的 libbpf 工程。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/12-profile/README.md&#34;&gt;lesson 12-profile&lt;/a&gt; 使用 eBPF 进行性能分析&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/13-tcpconnlat/README.md&#34;&gt;lesson 13-tcpconnlat&lt;/a&gt; 记录 TCP 连接延迟，并使用 libbpf-boostrap 或 Webassembly （WASM）在用户态处理数据&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/14-tcpstates/README.md&#34;&gt;lesson 14-tcpstates&lt;/a&gt; 记录 TCP 连接状态&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/15-tcprtt/README.md&#34;&gt;lesson 15-tcprtt&lt;/a&gt; 以直方图方式记录 TCP RTT，并使用 libbpf-boostrap 或 WASM 在用户态采样 map 信息&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/16-memleak/README.md&#34;&gt;lesson 16-memleak&lt;/a&gt; 检测内存泄漏&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/17-biopattern/README.md&#34;&gt;lesson 17-biopattern&lt;/a&gt; 捕获磁盘 IO 模式&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/18-further-reading/README.md&#34;&gt;lesson 18-further-reading&lt;/a&gt; 更进一步的相关资料？&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/19-lsm-connect/README.md&#34;&gt;lesson 19-lsm-connect&lt;/a&gt; 使用 LSM 进行安全检测防御&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/20-tc/README.md&#34;&gt;lesson 20-tc&lt;/a&gt; 使用 eBPF 进行 tc 流量控制&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eunomia-bpf/bpf-developer-tutorial/main/20-xdp/README.md&#34;&gt;lesson 21-xdp&lt;/a&gt; 使用 eBPF 进行 XDP 报文处理&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;为什么需要基于 libbpf 和 BPF CO-RE 的教程？&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;历史上，当需要开发一个BPF应用时可以选择BCC 框架，在实现各种用于Tracepoints的BPF程序时需要将BPF程序加载到内核中。BCC提供了内置的Clang编译器，可以在运行时编译BPF代码，并将其定制为符合特定主机内核的程序。这是在不断变化的内核内部下开发可维护的BPF应用程序的唯一方法。在BPF的可移植性和CO-RE一文中详细介绍了为什么会这样，以及为什么BCC是之前唯一的可行方式，此外还解释了为什么 libbpf 是目前比较好的选择。去年，Libbpf的功能和复杂性得到了重大提升，消除了与BCC之间的很多差异(特别是对Tracepoints应用来说)，并增加了很多BCC不支持的新的且强大的特性(如全局变量和BPF skeletons)。&lt;/p&gt; &#xA; &lt;p&gt;诚然，BCC会竭尽全力简化BPF开发人员的工作，但有时在获取便利性的同时也增加了问题定位和修复的困难度。用户必须记住其命名规范以及自动生成的用于Tracepoints的结构体，且必须依赖这些代码的重写来读取内核数据和获取kprobe参数。当使用BPF map时，需要编写一个半面向对象的C代码，这与内核中发生的情况并不完全匹配。除此之外，BCC使得用户在用户空间编写了大量样板代码，且需要手动配置最琐碎的部分。&lt;/p&gt; &#xA; &lt;p&gt;如上所述，BCC依赖运行时编译，且本身嵌入了庞大的LLVM/Clang库，由于这些原因，BCC与理想的使用有一定差距：&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;编译时的高资源利用率(内存和CPU)，在繁忙的服务器上时有可能干扰主流程。&lt;/li&gt; &#xA;  &lt;li&gt;依赖内核头文件包，不得不在每台目标主机上进行安装。即使这样，如果需要某些没有通过公共头文件暴露的内核内容时，需要将类型定义拷贝黏贴到BPF代码中，通过这种方式达成目的。&lt;/li&gt; &#xA;  &lt;li&gt;即使是很小的编译时错误也只能在运行时被检测到，之后不得不重新编译并重启用户层的应用；这大大影响了开发的迭代时间(并增加了挫败感...)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;Libbpf + BPF CO-RE (Compile Once – Run Everywhere) 选择了一个不同的方式，其思想在于将BPF程序视为一个普通的用户空间的程序：仅需要将其编译成一些小的二进制，然后不用经过修改就可以部署到目的主机上。libbpf扮演了BPF程序的加载器，负责配置工作(重定位，加载和校验BPF程序，创建BPF maps，附加到BPF钩子上等)，开发者仅需要关注BPF程序的正确性和性能即可。这种方式使得开销降到了最低，消除了大量依赖，提升了整体开发者的开发体验。&lt;/p&gt; &#xA; &lt;p&gt;在API和代码约定方面，libbpf坚持&#34;最少意外&#34;的哲学，即大部分内容都需要明确地阐述：不会隐含任何头文件，也不会重写代码。仅使用简单的C代码和适当的辅助宏即可消除大部分单调的环节。 此外，用户编写的是需要执行的内容，BPF应用程序的结构是一对一的，最终由内核验证并执行。&lt;/p&gt; &#xA; &lt;p&gt;参考：&lt;a href=&#34;https://www.ebpf.top/post/bcc-to-libbpf-guid/&#34;&gt;BCC 到libbpf 的转换指南【译】 - 深入浅出eBPF: https://www.ebpf.top/post/bcc-to-libbpf-guid/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;eunomia-bpf&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/eunomia-bpf/eunomia-bpf&#34;&gt;eunomia-bpf&lt;/a&gt; 是一个开源的 eBPF 动态加载运行时和开发工具链，是为了简化 eBPF 程序的开发、构建、分发、运行而设计的，基于 libbpf 的 CO-RE 轻量级开发框架。&lt;/p&gt; &#xA;&lt;p&gt;使用 eunomia-bpf ，可以：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;在编写 eBPF 程序或工具时只编写 libbpf 内核态代码，自动获取内核态导出信息；&lt;/li&gt; &#xA; &lt;li&gt;使用 WASM 进行用户态交互程序的开发，在 WASM 虚拟机内部控制整个 eBPF 程序的加载和执行，以及处理相关数据；&lt;/li&gt; &#xA; &lt;li&gt;eunomia-bpf 可以将预编译的 eBPF 程序打包为通用的 JSON 或 WASM 模块，跨架构和内核版本进行分发，无需重新编译即可动态加载运行。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;eunomia-bpf 由一个编译工具链和一个运行时库组成, 对比传统的 BCC、原生 libbpf 等框架，大幅简化了 eBPF 程序的开发流程，在大多数时候只需编写内核态代码，即可轻松构建、打包、发布完整的 eBPF 应用，同时内核态 eBPF 代码保证和主流的 libbpf, libbpfgo, libbpf-rs 等开发框架的 100% 兼容性。需要编写用户态代码的时候，也可以借助 Webassembly 实现通过多种语言进行用户态开发。和 bpftrace 等脚本工具相比, eunomia-bpf 保留了类似的便捷性, 同时不仅局限于 trace 方面, 可以用于更多的场景, 如网络、安全等等。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;eunomia-bpf 项目 Github 地址: &lt;a href=&#34;https://github.com/eunomia-bpf/eunomia-bpf&#34;&gt;https://github.com/eunomia-bpf/eunomia-bpf&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;gitee 镜像: &lt;a href=&#34;https://gitee.com/anolis/eunomia&#34;&gt;https://gitee.com/anolis/eunomia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
</feed>