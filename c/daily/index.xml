<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-27T01:33:52Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>memtest86plus/memtest86plus</title>
    <updated>2022-10-27T01:33:52Z</updated>
    <id>tag:github.com,2022-10-27:/memtest86plus/memtest86plus</id>
    <link href="https://github.com/memtest86plus/memtest86plus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Official repo for Memtest86+ v6.00 (based on pcmemtest)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Memtest86+&lt;/h1&gt; &#xA;&lt;p&gt;Memtest86+ is a free, open-source, stand-alone memory tester for x86 and x86-64 architecture computers. It provides a much more thorough memory check than that provided by BIOS memory tests.&lt;/p&gt; &#xA;&lt;p&gt;It is also able to access almost all the computer&#39;s memory, not being restricted by the memory used by the operating system and not depending on any underlying software like UEFI libraries.&lt;/p&gt; &#xA;&lt;p&gt;Memtest86+ can be loaded and run either directly by a PC BIOS (legacy or UEFI) or via an intermediate bootloader that supports the Linux 16-bit, 32-bit, 64-bit, or EFI handover boot protocol. It should work on any Pentium class or later 32-bit or 64-bit CPU.&lt;/p&gt; &#xA;&lt;p&gt;Binary releases (both stable and nightly dev builds) are available on &lt;a href=&#34;https://memtest.org&#34;&gt;memtest.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#origins&#34;&gt;Origins&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#licensing&#34;&gt;Licensing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#build-and-installation&#34;&gt;Build and Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#boot-options&#34;&gt;Boot Options&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#keyboard-selection&#34;&gt;Keyboard Selection&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#operation&#34;&gt;Operation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#error-reporting&#34;&gt;Error Display&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#trouble-shooting-memory-errors&#34;&gt;Trouble-shooting Memory Errors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#execution-time&#34;&gt;Execution Time&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#memory-testing-philosophy&#34;&gt;Memtest86+ Test Algorithms&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#individual-test-descriptions&#34;&gt;Individual Test Descriptions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#known-limitations-and-bugs&#34;&gt;Known Limitations and Bugs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#code-contributions&#34;&gt;Code Contributions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/memtest86plus/memtest86plus/main/#acknowledgments&#34;&gt;Acknowledgments&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Origins&lt;/h2&gt; &#xA;&lt;p&gt;Memtest86+ v6.00 was based on PCMemTest, which was a fork and rewrite of the earlier Memtest86+ v5, which in turn was a fork of MemTest-86. The purpose of the PCMemTest rewrite was to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;make the code more readable and easier to maintain&lt;/li&gt; &#xA; &lt;li&gt;make the code 64-bit clean and support UEFI boot&lt;/li&gt; &#xA; &lt;li&gt;fix failures seen when building with newer versions of GCC&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In the process of creating PCMemTest, a number of features of Memtest86+ v5 that were not strictly required for testing the system memory were dropped. In particular, no attempt was made to measure the cache and main memory speed, or to identify and report the DRAM type. These features were added back and expanded in Memtest86+ v6.0 to create a unified, fully-featured release.&lt;/p&gt; &#xA;&lt;h2&gt;Licensing&lt;/h2&gt; &#xA;&lt;p&gt;Memtest86+ is released under the terms of the GNU General Public License version 2 (GPLv2). Other than the provisions of the GPL there are no restrictions for use, private or commercial. See the LICENSE file for details.&lt;/p&gt; &#xA;&lt;h2&gt;Build and Installation&lt;/h2&gt; &#xA;&lt;p&gt;Build is only tested on a Linux system, but should be possible on any system using the GNU toolchain and the ELF file format. The tools required are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GCC&lt;/li&gt; &#xA; &lt;li&gt;binutils&lt;/li&gt; &#xA; &lt;li&gt;make&lt;/li&gt; &#xA; &lt;li&gt;dosfstools and mtools (optional)&lt;/li&gt; &#xA; &lt;li&gt;xorrisofs (optional)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To build a 32-bit image, change directory into the &lt;code&gt;build32&lt;/code&gt; directory and type &lt;code&gt;make&lt;/code&gt;. The result is a &lt;code&gt;memtest.bin&lt;/code&gt; binary image file which can be booted directly by a legacy BIOS (in floppy mode) or by an intermediate bootloader using the Linux 16-bit boot protocol and a &lt;code&gt;memtest.efi&lt;/code&gt; binary image file which can be booted directly by a 32-bit UEFI BIOS. Either image can be booted by an intermediate bootloader using the Linux 32-bit or 32-bit EFI handover boot protocols.&lt;/p&gt; &#xA;&lt;p&gt;To build a 64-bit image, change directory into the &lt;code&gt;build64&lt;/code&gt; directory and type &lt;code&gt;make&lt;/code&gt;. The result is a &lt;code&gt;memtest.bin&lt;/code&gt; binary image file which can be booted directly by a legacy BIOS (in floppy mode) or by an intermediate bootloader using the Linux 16-bit boot protocol and a &lt;code&gt;memtest.efi&lt;/code&gt; binary image file which can be booted directly by a 64-bit UEFI BIOS. Either image can be booted by an intermediate bootloader using the Linux 32-bit, 64-bit, or 64-bit EFI handover boot protocols.&lt;/p&gt; &#xA;&lt;p&gt;In either case, to build an ISO image that can be used to create a bootable CD, DVD, or USB Flash drive, type &lt;code&gt;make iso&lt;/code&gt;, The result is a &lt;code&gt;memtest.iso&lt;/code&gt; ISO image file. This can then be written directly to a blank CD or DVD, or to a USB Flash drive, which can then be booted directly by a legacy or UEFI PC BIOS.&lt;/p&gt; &#xA;&lt;p&gt;Note that when writing to a USB Flash drive, the ISO image must be written directly (&#39;dumped&#39;) to the raw device, either by using the &lt;code&gt;dd&lt;/code&gt; command or by using a utility that provides the same functionality.&lt;/p&gt; &#xA;&lt;p&gt;When using an intermediate bootloader, either the &lt;code&gt;memtest.bin&lt;/code&gt; file or the &lt;code&gt;memtest.efi&lt;/code&gt; file should be stored in a disk partition the bootloader can access, and the bootloader configuration should be updated to boot from that file as if it were a Linux kernel with no initial RAM disk. Several boot command line options are recognised, as described below. If using the 16-bit boot protocol, Memtest86+ will use the display in text mode (640x400). If using the 32-bit or 64-bit boot protocols, Memtest86+ will use the display in either text mode or graphics mode, as specified in the &lt;code&gt;boot_params&lt;/code&gt; struct passed to it by the bootloader. If in graphics mode, the supplied framebuffer must be at least 640x400 pixels; if larger, the display will be centred. If the system was booted in UEFI mode, graphics mode must be used.&lt;/p&gt; &#xA;&lt;p&gt;For test purposes, there is also an option to build an ISO image that uses GRUB as an intermediate bootloader. See the &lt;code&gt;Makefile&lt;/code&gt; in the &lt;code&gt;build32&lt;/code&gt; or &lt;code&gt;build64&lt;/code&gt; directory for details. The ISO image is both legacy and UEFI bootable, so you need GRUB modules for both legacy and EFI boot installed on your build system (e.g. on Debian, the required GRUB modules are located in packages &lt;code&gt;grub-pc-bin&lt;/code&gt;, &lt;code&gt;grub-efi-ia32-bin&lt;/code&gt; and &lt;code&gt;grub-efi-amd64-bin&lt;/code&gt;). You may need to adjust some path and file names in the Makefile to match the naming on your system.&lt;/p&gt; &#xA;&lt;p&gt;The GRUB configuration files contained in the &lt;code&gt;grub&lt;/code&gt; directory are there for use on the test ISO, but also serve as an example of how to boot Memtest86+ from GRUB.&lt;/p&gt; &#xA;&lt;h2&gt;Boot Options&lt;/h2&gt; &#xA;&lt;p&gt;An intermediate bootloader may pass a boot command line to Memtest86+. The command line may contain one or more options, separated by spaces. Each option consists of an option name, optionally followed by an &lt;code&gt;=&lt;/code&gt; sign and one or more parameters, separated by commas. The following options are recognised:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;nosmp &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;disables ACPI table parsing and the use of multiple CPU cores&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;nobench &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;disables the integrated memory benchmark&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;nosm &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;disables SMBUS/SPD parsing, DMI decoding and memory benchmark&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;nopause &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;skips the pause for configuration at startup&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;keyboard=&lt;em&gt;type&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;where &lt;em&gt;type&lt;/em&gt; is one of &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;legacy&lt;/li&gt; &#xA;     &lt;li&gt;usb&lt;/li&gt; &#xA;     &lt;li&gt;both&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;usbdebug &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;pauses after probing for USB keyboards&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;usbinit=&lt;em&gt;mode&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;where &lt;em&gt;mode&lt;/em&gt; is one of &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;1 = use the two-step init sequence for high speed devices&lt;/li&gt; &#xA;     &lt;li&gt;2 = add a second USB reset in the init sequence&lt;/li&gt; &#xA;     &lt;li&gt;3 = the combination of modes 1 and 2&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;console=ttyS&lt;em&gt;x&lt;/em&gt;,&lt;em&gt;y&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;activate serial/tty console output, where &lt;em&gt;x&lt;/em&gt; is one of the following IO port &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;0 = 0x3F8&lt;/li&gt; &#xA;     &lt;li&gt;1 = 0x2F8&lt;/li&gt; &#xA;     &lt;li&gt;2 = 0x3E8&lt;/li&gt; &#xA;     &lt;li&gt;3 = 0x2E8&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;and &lt;em&gt;y&lt;/em&gt; is an optional baud rate to choose from the following list &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;9600&lt;/li&gt; &#xA;     &lt;li&gt;19200&lt;/li&gt; &#xA;     &lt;li&gt;38400&lt;/li&gt; &#xA;     &lt;li&gt;54600&lt;/li&gt; &#xA;     &lt;li&gt;115200 (default if not specified or invalid)&lt;/li&gt; &#xA;     &lt;li&gt;230400&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Keyboard Selection&lt;/h2&gt; &#xA;&lt;p&gt;Memtest86+ supports both the legacy keyboard interface (using I/O ports 0x60 and 0x64) and USB keyboards (using its own USB device drivers). One or the other or both can be selected via the boot command line, If not specified on the command line, the default is to use both if the system was booted in UEFI mode, otherwise to only use the legacy interface.&lt;/p&gt; &#xA;&lt;p&gt;Older BIOSs usually support USB legacy keyboard emulation, which makes USB keyboards act like legacy keyboards connected to ports 0x60 and 0x64. This can often be enabled or disabled in the BIOS setup menus. If Memtest86+&#39;s USB device drivers are enabled, they will override this and access any USB keyboards directly. The downside of that is that the USB controllers and device drivers require some memory to be reserved for their private use, which means that memory can&#39;t then be covered by the memory tests. So to maximise test coverage, if it is supported, enable USB legacy keyboard emulation and, if booting in UEFI mode, add &lt;code&gt;keyboard=legacy&lt;/code&gt; on the boot command line.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Some UEFI BIOSs only support USB legacy keyboard emulation when you enable the Compatibility System Module (CSM) in the BIOS setup. Others only support it when actually booting in legacy mode.&lt;/p&gt; &#xA;&lt;p&gt;Many USB devices don&#39;t fully conform to the USB specification. If the USB keyboard probe hangs or fails to detect your keyboard, try the various workarounds provided by the &#34;usbinit&#34; boot option.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Hot-plugging is not currently supported by the Memtest86+ USB drivers. When using these, your USB keyboard should be plugged in before running Memtest86+ and should remain plugged in throughout the test.&lt;/p&gt; &#xA;&lt;h2&gt;Operation&lt;/h2&gt; &#xA;&lt;p&gt;Once booted, Memtest86+ will initialise its display, then pause for a few seconds to allow the user to configure its operation. If no key is pressed, it will automatically start running all tests using a single CPU core, continuing indefinitely until the user reboots or halts the machine.&lt;/p&gt; &#xA;&lt;p&gt;At startup, and when running tests, Memtest86+ responds to the following keys:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;F1 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;enters the configuration menu&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;F2 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;toggles use of multiple CPU cores (SMP)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Space &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;toggles scroll lock (stops/starts error message scrolling)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Enter &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;single message scroll (only when scroll lock enabled)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Escape &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;exits the test and reboots the machine&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that testing is stalled when scroll lock is enabled and the scroll region is full.&lt;/p&gt; &#xA;&lt;p&gt;The configuration menu allows the user to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;select which tests are run (default: all tests)&lt;/li&gt; &#xA; &lt;li&gt;limit the address range over which tests are performed (default: all memory)&lt;/li&gt; &#xA; &lt;li&gt;select the CPU sequencing mode (default: parallel) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;parallel &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;each CPU core works in parallel on a subset of the memory region being tested&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;sequential &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;each CPU core works in turn on the full memory region being tested&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;round robin &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a single CPU core works on the full memory region being tested, with a new CPU core being selected (in round-robin fashion) for each test&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;select the error reporting mode (default: individual errors) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;error counts only&lt;/li&gt; &#xA;   &lt;li&gt;error summary&lt;/li&gt; &#xA;   &lt;li&gt;individual errors&lt;/li&gt; &#xA;   &lt;li&gt;BadRAM patterns&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;select which of the available CPU cores are used (at startup only) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;a maximum of 256 CPU cores can be selected, due to memory and display limits&lt;/li&gt; &#xA;   &lt;li&gt;the bootstrap processor (BSP) cannot be deselected&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;enable or disable the temperature display (at startup only)&lt;/li&gt; &#xA; &lt;li&gt;enable or disable boot tracing for debug (at startup only)&lt;/li&gt; &#xA; &lt;li&gt;skip to the next test (when running tests)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In all cases, the number keys may be used as alternatives to the function keys (1 = F1, 2 = F2, ... 0 = F10).&lt;/p&gt; &#xA;&lt;h2&gt;Error Reporting&lt;/h2&gt; &#xA;&lt;p&gt;The error reporting mode may be changed at any time without disrupting the current test sequence. Error statistics are collected regardless of the current error reporting mode (so switching to error summary mode will show the accumulated statistics since the current test sequence started). BadRAM patterns are only accumulated when in BadRAM mode.&lt;/p&gt; &#xA;&lt;p&gt;Any change to the selected tests, address range, or CPU sequencing mode will start a new test sequence and reset the error statistics.&lt;/p&gt; &#xA;&lt;h3&gt;Error Counts Only&lt;/h3&gt; &#xA;&lt;p&gt;The error counts only mode just displays the total number of errors found since the current test sequence started.&lt;/p&gt; &#xA;&lt;h3&gt;Error Summary&lt;/h3&gt; &#xA;&lt;p&gt;The error summary mode displays the following information:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lowest Error Address &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the lowest address that where an error has been reported&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Highest Error Address &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the highest address that where an error has been reported&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Bits in Error Mask &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;a hexadecimal mask of all bits that have been in error&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Bits in Error &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;total bits in error for all error instances and the min, max and average number of bits in error across each error instance&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Max Contiguous Errors &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the maximum of contiguous addresses with errors&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Test Errors &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the total number of errors for each individual test&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Individual Errors&lt;/h3&gt; &#xA;&lt;p&gt;The individual error mode displays the following information for each error instance:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;pCPU &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the physical CPU core number that detected the error&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Pass &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the test pass number where the error occurred (a test pass is a single run over all the currently selected tests)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Test &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the individual test number where the error occurred&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Failing Address &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the memory address where the error occurred&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Expected &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the hexadecimal data pattern expected to be found&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Found &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;the hexadecimal data pattern read from the failing address&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Err Bits (only in 32-bit builds) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;a hexadecimal mask showing the bits in error&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;BadRAM Patterns&lt;/h3&gt; &#xA;&lt;p&gt;The BadRAM patterns mode accumulates and displays error patterns for use with the &lt;a href=&#34;http://rick.vanrein.org/linux/badram/&#34;&gt;Linux BadRAM feature&lt;/a&gt;. Lines are printed in the form &lt;code&gt;badram=F1,M1,F2,M2...&lt;/code&gt; In each &lt;code&gt;F,M&lt;/code&gt; pair, the &lt;code&gt;F&lt;/code&gt; represents a fault address and the &lt;code&gt;M&lt;/code&gt; is a bitmask for that address. These patterns state that faults have occurred in addresses that equal F on all &lt;code&gt;1&lt;/code&gt; bits in M. Such a pattern may capture more errors that actually exist, but at least all the errors are captured. These patterns have been designed to capture regular patterns of errors caused by the hardware structure in a terse syntax.&lt;/p&gt; &#xA;&lt;p&gt;The BadRAM patterns are grown incrementally rather than calculated from an overview of all errors. The number of pairs is constrained to ten for a number of practical reasons. As a result, handcrafting patterns from the output in address printing mode may, in exceptional cases, yield better results.&lt;/p&gt; &#xA;&lt;h2&gt;Trouble-shooting Memory Errors&lt;/h2&gt; &#xA;&lt;p&gt;Please be aware that not all errors reported by Memtest86+ are due to bad memory. The test implicitly tests the CPU, caches, and motherboard. It is impossible for the test to determine what causes the failure to occur. Most failures will be due to a problem with memory. When it is not, the only option is to replace parts until the failure is corrected.&lt;/p&gt; &#xA;&lt;p&gt;Once a memory error has been detected, determining the failing module is not a clear cut procedure. With the large number of motherboard vendors and possible combinations of memory slots it would be difficult if not impossible to assemble complete information about how a particular error would map to a failing memory module. However, there are steps that may be taken to determine the failing module. Here are some techniques that you may wish to use:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Removing modules&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This is the simplest method for isolating a failing modules, but may only be employed when one or more modules can be removed from the system. By selectively removing modules from the system and then running the test you will be able to find the bad module(s). Be sure to note exactly which modules are in the system when the test passes and when the test fails.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rotating modules&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;When none of the modules can be removed then you may wish to rotate modules to find the failing one. This technique can only be used if there are three or more modules in the system. Change the location of two modules at a time. For example put the module from slot 1 into slot 2 and put the module from slot 2 in slot 1. Run the test and if either the failing bit or address changes then you know that the failing module is one of the ones just moved. By using several combinations of module movement you should be able to determine which module is failing.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Replacing modules&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If you are unable to use either of the previous techniques then you are left to selective replacement of modules to find the failure.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sometimes memory errors show up due to component incompatibility. A memory module may work fine in one system and not in another. This is not uncommon and is a source of confusion. The components are not necessarily bad but certain combinations may need to be avoided.&lt;/p&gt; &#xA;&lt;p&gt;In the vast majority of cases errors reported by Memtest86+ are valid. There are some systems that cause Memtest86+ to be confused about the size of memory and it will try to test non-existent memory. This will cause a large number of consecutive addresses to be reported as bad and generally there will be many bits in error. If you have a relatively small number of failing addresses and only one or two bits in error you can be certain that the errors are valid. Also intermittent errors are always valid.&lt;/p&gt; &#xA;&lt;p&gt;All valid memory errors should be corrected. It is possible that a particular error will never show up in normal operation. However, operating with marginal memory is risky and can result in data loss and even disk corruption.&lt;/p&gt; &#xA;&lt;p&gt;Memtest86+ can not diagnose many types of PC failures. For example a faulty CPU that causes your OS to crash will most likely just cause Memtest86+ to crash in the same way.&lt;/p&gt; &#xA;&lt;h2&gt;Execution Time&lt;/h2&gt; &#xA;&lt;p&gt;The time required for a complete pass of Memtest86+ will vary greatly depending on CPU speed, memory speed, and memory size. Memtest86+ executes indefinitely. The pass counter increments each time that all of the selected tests have been run. Generally a single pass is sufficient to catch all but the most obscure errors. However, for complete confidence when intermittent errors are suspected testing for a longer period is advised.&lt;/p&gt; &#xA;&lt;h2&gt;Memory Testing Philosophy&lt;/h2&gt; &#xA;&lt;p&gt;There are many good approaches for testing memory. However, many tests simply throw some patterns at memory without much thought or knowledge of memory architecture or how errors can best be detected. This works fine for hard memory failures but does little to find intermittent errors. BIOS based memory tests are useless for finding intermittent memory errors.&lt;/p&gt; &#xA;&lt;p&gt;Memory chips consist of a large array of tightly packed memory cells, one for each bit of data. The vast majority of the intermittent failures are a result of interaction between these memory cells. Often writing a memory cell can cause one of the adjacent cells to be written with the same data. An effective memory test attempts to test for this condition. Therefore, an ideal strategy for testing memory would be the following:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;write a cell with a zero&lt;/li&gt; &#xA; &lt;li&gt;write all of the adjacent cells with a one, one or more times&lt;/li&gt; &#xA; &lt;li&gt;check that the first cell still has a zero&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;It should be obvious that this strategy requires an exact knowledge of how the memory cells are laid out on the chip. In addition there is a never ending number of possible chip layouts for different chip types and manufacturers making this strategy impractical. However, there are testing algorithms that can approximate this ideal strategy.&lt;/p&gt; &#xA;&lt;h2&gt;Memtest86+ Test Algorithms&lt;/h2&gt; &#xA;&lt;p&gt;Memtest86+ uses two algorithms that provide a reasonable approximation of the ideal test strategy above. The first of these strategies is called moving inversions. The moving inversion tests work as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fill memory with a pattern&lt;/li&gt; &#xA; &lt;li&gt;Starting at the lowest address &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;check that the pattern has not changed&lt;/li&gt; &#xA;   &lt;li&gt;write the pattern&#39;s complement&lt;/li&gt; &#xA;   &lt;li&gt;increment the address&lt;/li&gt; &#xA;   &lt;li&gt;repeat 2.i to 2.iii&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;Starting at the highest address &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;check that the pattern has not changed&lt;/li&gt; &#xA;   &lt;li&gt;write the pattern&#39;s complement&lt;/li&gt; &#xA;   &lt;li&gt;decrement the address&lt;/li&gt; &#xA;   &lt;li&gt;repeat 3.i - 3.iii&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This algorithm is a good approximation of an ideal memory test but there are some limitations. Most high density chips today store data 4 to 16 bits wide. With chips that are more than one bit wide it is impossible to selectively read or write just one bit. This means that we cannot guarantee that all adjacent cells have been tested for interaction. In this case the best we can do is to use some patterns to ensure that all adjacent cells have at least been written with all possible one and zero combinations.&lt;/p&gt; &#xA;&lt;p&gt;It can also be seen that caching, buffering, and out of order execution will interfere with the moving inversions algorithm and make it less effective. It is possible to turn off caching but the memory buffering in new high performance chips cannot be disabled. To address this limitation a new algorithm called Modulo-20 was created. This algorithm is not affected by caching or buffering. The algorithm works as follows:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;For starting offsets of 0 - 19 do &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;write every 20th location with a pattern&lt;/li&gt; &#xA;   &lt;li&gt;write all other locations with the pattern&#39;s complement&lt;/li&gt; &#xA;   &lt;li&gt;repeat 1.ii one or more times&lt;/li&gt; &#xA;   &lt;li&gt;check every 20th location for the pattern&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This algorithm accomplishes nearly the same level of adjacency testing as moving inversions but is not affected by caching or buffering. Since separate write passes (1.i, 1.ii) and the read pass (1.iv) are done for all of memory we can be assured that all of the buffers and cache have been flushed between passes. The selection of 20 as the stride size was somewhat arbitrary. Larger strides may be more effective but would take longer to execute. The choice of 20 seemed to be a reasonable compromise between speed and thoroughness.&lt;/p&gt; &#xA;&lt;h2&gt;Individual Test Descriptions&lt;/h2&gt; &#xA;&lt;p&gt;Memtest86+ executes a series of numbered tests to check for errors. These tests consist of a combination of test algorithm, data pattern and caching. The execution order for these tests were arranged so that errors will be detected as rapidly as possible. A description of each test follows.&lt;/p&gt; &#xA;&lt;p&gt;To allow testing of more than 4GB of memory on 32-bit CPUs, the physical address range is split into 1GB windows which are be mapped one at a time into a virtual memory window. Each 1GB window may contain one or more contiguous memory regions. For most tests, the test is performed on each memory region in turn. Caching is enabled for all but the first test.&lt;/p&gt; &#xA;&lt;h3&gt;Test 0 : Address test, walking ones, no cache&lt;/h3&gt; &#xA;&lt;p&gt;In each memory region in turn, tests all address bits by using a walking ones address pattern. Errors from this test are not used to calculate BadRAM patterns.&lt;/p&gt; &#xA;&lt;h3&gt;Test 1 : Address test, own address in window&lt;/h3&gt; &#xA;&lt;p&gt;In each memory region in turn, each address is written with its own address and then each address is checked for consistency. This test is performed sequentially with each available CPU, regardless of the CPU sequencing mode selected by the user.&lt;/p&gt; &#xA;&lt;h3&gt;Test 2 : Address test, own address + window&lt;/h3&gt; &#xA;&lt;p&gt;Across all memory regions, each address is written with its own address plus the window number and then each address is checked for consistency. This catches any errors in the high order address bits that would be missed when testing each window in turn. This test is performed sequentially with each available CPU, regardless of the CPU sequencing mode selected by the user.&lt;/p&gt; &#xA;&lt;h3&gt;Test 3 : Moving inversions, ones &amp;amp; zeros&lt;/h3&gt; &#xA;&lt;p&gt;In each memory region in turn, and for each pattern in turn, uses the moving inversions algorithm with patterns of all ones and all zeros.&lt;/p&gt; &#xA;&lt;h3&gt;Test 4 : Moving inversions, 8 bit pattern&lt;/h3&gt; &#xA;&lt;p&gt;In each memory region in turn, and for each pattern in turn, uses the moving inversions algorithm with patterns of 8-bit wide walking ones and walking zeros.&lt;/p&gt; &#xA;&lt;h3&gt;Test 5 : Moving inversions, random pattern&lt;/h3&gt; &#xA;&lt;p&gt;In each memory region in turn, and for each pattern in turn, uses the moving inversions algorithm with patterns of a random number and its complement. The random number is different on each test pass so multiple passes increase effectiveness.&lt;/p&gt; &#xA;&lt;h3&gt;Test 6 : Moving inversions, 32/64 bit pattern&lt;/h3&gt; &#xA;&lt;p&gt;In each memory region in turn, and for each pattern in turn, uses the moving inversions algorithm with patterns of 32-bit wide (on 32-bit builds) or 64-bit wide (on 64-bit builds) walking ones and walking zeros. Unlike previous tests, the pattern is rotated 1 bit on each successive address.&lt;/p&gt; &#xA;&lt;h3&gt;Test 7 : Block move, 64 moves&lt;/h3&gt; &#xA;&lt;p&gt;This test stresses memory by using block move (movs) instructions and is based on Robert Redelmeier&#39;s burnBX test.&lt;/p&gt; &#xA;&lt;p&gt;In each memory region in turn, memory is initialized with shifting patterns that are inverted every 8 bytes. Then blocks of memory are moved around using the movs instruction. After the moves are completed the data patterns are checked. Because the data is checked only after the memory moves are completed it is not possible to know where the error occurred. The addresses reported are only for where the bad pattern was found. In consequence, errors from this test are not used to calculate BadRAM patterns.&lt;/p&gt; &#xA;&lt;h3&gt;Test 8 : Random number sequence&lt;/h3&gt; &#xA;&lt;p&gt;In each memory region in turn, each address is written with a random number, then each address is checked for consistency and written with the complement of the original data, then each address is again checked for consistency.&lt;/p&gt; &#xA;&lt;h3&gt;Test 9 : Modulo 20, random pattern&lt;/h3&gt; &#xA;&lt;p&gt;In each memory region in turn, and for each pattern in turn, uses the Modulo-20 algorithm with patterns of a random number and its complement. The random number is different on each test pass so multiple passes increase effectiveness.&lt;/p&gt; &#xA;&lt;h3&gt;Test 10 : Bit fade test, 2 patterns&lt;/h3&gt; &#xA;&lt;p&gt;Across all memory regions, and for each pattern in turn, initialises each memory location with a pattern, sleeps for a period of time, then checks each memory location for consistency. The test is performed with patterns of all zeros and all ones.&lt;/p&gt; &#xA;&lt;h2&gt;Known Limitations and Bugs&lt;/h2&gt; &#xA;&lt;p&gt;Please see the list of &lt;a href=&#34;https://github.com/memtest86plus/memtest86plus/issues&#34;&gt;open issues&lt;/a&gt; and &lt;a href=&#34;https://github.com/memtest86plus/memtest86plus/discussions&#34;&gt;enhancement requests&lt;/a&gt; on GitHub.&lt;/p&gt; &#xA;&lt;p&gt;Feel free to submit bug reports!&lt;/p&gt; &#xA;&lt;h2&gt;Code Contributions&lt;/h2&gt; &#xA;&lt;p&gt;Code contributions are welcomed, either to fix bugs or to make enhancements. See the README_DEVEL.md in the doc directory for some basic guidelines.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;Memtest86+ v6.0 was based on PCMemTest, developed by Martin Whitaker, which was based on Memtest86+ v5.01, developed by Samuel Demeulemeester, which in turn was based on Memtest86, developed by Chris Brady with the resources and assistance listed below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The initial versions of the source files bootsect.S, setup.S, head.S and build.c are from the Linux 1.2.1 kernel and have been heavily modified.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Doug Sisk provided code to support a console connected via a serial port. (not currently used)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Code to create BadRAM patterns was provided by Rick van Rein.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The block move test is based on Robert Redelmeier&#39;s burnBX test.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Screen buffer code was provided by Jani Averbach. (not used by Memtest86+ v6.0)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Eric Biederman provided all of the feature content for version 3.0 plus many bugfixes and significant code cleanup.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Major enhancements to hardware detection and reporting in version 3.2, 3.3 and 3.4 provided by Samuel Demeulemeester (from Memtest86+ v1.11, v1.60 and v1.70).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition, several bug fixes for Memtest86+ were imported from &lt;a href=&#34;https://github.com/anphsw/memtest86&#34;&gt;anphsw/memtest86&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>open5gs/open5gs</title>
    <updated>2022-10-27T01:33:52Z</updated>
    <id>tag:github.com,2022-10-27:/open5gs/open5gs</id>
    <link href="https://github.com/open5gs/open5gs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open5GS is a C-language Open Source implementation for 5G Core and EPC, i.e. the core network of LTE/NR network (Release-16)&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;https://open5gs.org&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;img width=&#34;100&#34; src=&#34;https://open5gs.org/assets/img/open5gs-logo-only.png&#34; alt=&#34;Open5GS logo&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Please follow the &lt;a href=&#34;https://open5gs.org/open5gs/docs/&#34;&gt;documentation&lt;/a&gt; at &lt;a href=&#34;https://open5gs.org/&#34;&gt;open5gs.org&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;p&gt;If you find Open5GS useful for work, please consider supporting this Open Source project by &lt;a href=&#34;https://github.com/sponsors/acetcom&#34;&gt;Becoming a sponsor&lt;/a&gt;. To manage the funding transactions transparently, you can donate through &lt;a href=&#34;https://opencollective.com/open5gs&#34;&gt;OpenCollective&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a target=&#34;_blank&#34; href=&#34;https://open5gs.org/#sponsors&#34;&gt; &lt;img alt=&#34;sponsors&#34; src=&#34;https://open5gs.org/assets/img/sponsors.svg?sanitize=true&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Problem with Open5GS can be filed as &lt;a href=&#34;https://github.com/open5gs/open5gs/issues&#34;&gt;issues&lt;/a&gt; in this repository.&lt;/li&gt; &#xA; &lt;li&gt;Other topics related to this project are happening on the &lt;a href=&#34;https://github.com/open5gs/open5gs/discussions&#34;&gt;discussions&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Voice and text chat are available in Open5GS&#39;s &lt;a href=&#34;https://discordapp.com/&#34;&gt;Discord&lt;/a&gt; workspace. Use &lt;a href=&#34;https://discord.gg/GreNkuc&#34;&gt;this link&lt;/a&gt; to get started.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re contributing through a pull request to Open5GS project on GitHub, please read the &lt;a href=&#34;https://open5gs.org/open5gs/cla/&#34;&gt;Contributor License Agreement&lt;/a&gt; in advance.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open5GS Open Source files are made available under the terms of the GNU Affero General Public License (&lt;a href=&#34;https://www.gnu.org/licenses/agpl-3.0.html&#34;&gt;GNU AGPL v3.0&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://open5gs.org/open5gs/support/&#34;&gt;Commercial licenses&lt;/a&gt; are also available from &lt;a href=&#34;https://neoplane.io/&#34;&gt;NeoPlane&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>azure-rtos/threadx</title>
    <updated>2022-10-27T01:33:52Z</updated>
    <id>tag:github.com,2022-10-27:/azure-rtos/threadx</id>
    <link href="https://github.com/azure-rtos/threadx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Azure RTOS ThreadX is an advanced real-time operating system (RTOS) designed specifically for deeply embedded applications.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/azure-rtos/threadx/workflows/cortex_m0/badge.svg?sanitize=true&#34; alt=&#34;cortex_m0&#34;&gt; &lt;img src=&#34;https://github.com/azure-rtos/threadx/workflows/cortex_m3/badge.svg?sanitize=true&#34; alt=&#34;cortex_m3&#34;&gt; &lt;img src=&#34;https://github.com/azure-rtos/threadx/workflows/cortex_m4/badge.svg?sanitize=true&#34; alt=&#34;cortex_m4&#34;&gt; &lt;img src=&#34;https://github.com/azure-rtos/threadx/workflows/cortex_m7/badge.svg?sanitize=true&#34; alt=&#34;cortex_m7&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Azure RTOS ThreadX&lt;/h1&gt; &#xA;&lt;p&gt;This advanced real-time operating system (RTOS) is designed specifically for deeply embedded applications. Among the multiple benefits it provides are advanced scheduling facilities, message passing, interrupt management, and messaging services. Azure RTOS ThreadX has many advanced features, including picokernel architecture, preemption threshold, event chaining, and a rich set of system services.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Documentation for this library can be found here: &lt;a href=&#34;http://docs.microsoft.com/azure/rtos/threadx&#34;&gt;http://docs.microsoft.com/azure/rtos/threadx&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Understanding inter-component dependencies&lt;/h1&gt; &#xA;&lt;p&gt;The main components of Azure RTOS are each provided in their own repository, but there are dependencies between them--shown in the following graph--that are important to understand when setting up your builds.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/azure-rtos/threadx/master/docs/deps.png&#34; alt=&#34;dependency graph&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Building and using the library&lt;/h1&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;p&gt;Install the following tools:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cmake.org/download/&#34;&gt;CMake&lt;/a&gt; version 3.0 or later&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads&#34;&gt;GCC compilers for arm-none-eabi&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://ninja-build.org/&#34;&gt;Ninja&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Cloning the repo&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/azure-rtos/threadx.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building as a static library&lt;/h2&gt; &#xA;&lt;p&gt;Each component of Azure RTOS comes with a composable CMake-based build system that supports many different MCUs and host systems. Integrating any of these components into your device app code is as simple as adding a git submodule and then including it in your build using the CMake command &lt;code&gt;add_subdirectory()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;While the typical usage pattern is to include threadx into your device code source tree to be built &amp;amp; linked with your code, you can compile this project as a standalone static library to confirm your build is set up correctly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake -Bbuild -DCMAKE_TOOLCHAIN_FILE=cmake/cortex_m4.cmake -GNinja .&#xA;&#xA;$ cmake --build ./build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: You will have to take the dependency graph above into account when building anything other than threadx itself.&lt;/p&gt; &#xA;&lt;h1&gt;Repository Structure and Usage&lt;/h1&gt; &#xA;&lt;h2&gt;Branches &amp;amp; Releases&lt;/h2&gt; &#xA;&lt;p&gt;The master branch has the most recent code with all new features and bug fixes. It does not represent the latest General Availability (GA) release of the library.&lt;/p&gt; &#xA;&lt;h2&gt;Releases&lt;/h2&gt; &#xA;&lt;p&gt;Each official release (preview or GA) will be tagged to mark the commit and push it into the Github releases tab, e.g. &lt;code&gt;v6.0-rel&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Directory layout&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;- cmake&#xA;- common&#xA;  - inc&#xA;  - src&#xA;- ports&#xA;  - cortex_m0/gnu&#xA;    - inc&#xA;    - src&#xA;  - cortex_m3/gnu&#xA;    - inc&#xA;    - src&#xA;  - cortex_m4/gnu&#xA;    - inc&#xA;    - src&#xA;  - cortex_m7/gnu&#xA;    - inc&#xA;    - src&#xA;- samples&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Security&lt;/h1&gt; &#xA;&lt;p&gt;Azure RTOS provides OEMs with components to secure communication and to create code and data isolation using underlying MCU/MPU hardware protection mechanisms. It is ultimately the responsibility of the device builder to ensure the device fully meets the evolving security requirements associated with its specific use case.&lt;/p&gt; &#xA;&lt;h1&gt;Adaptation layer for ThreadX&lt;/h1&gt; &#xA;&lt;p&gt;Azure RTOS ThreadX is an advanced real-time operating system (RTOS) designed specifically for deeply embedded applications. To help ease application migration to Azure RTOS, ThreadX provides &lt;a href=&#34;https://github.com/azure-rtos/threadx/tree/master/utility/rtos_compatibility_layers&#34;&gt;adaption layers&lt;/a&gt; for various legacy RTOS APIs (FreeRTOS, POSIX, OSEK, etc.).&lt;/p&gt; &#xA;&lt;h1&gt;Licensing&lt;/h1&gt; &#xA;&lt;p&gt;License terms for using Azure RTOS are defined in the LICENSE.txt file of this repo. Please refer to this file for all definitive licensing information. No additional license fees are required for deploying Azure RTOS on hardware defined in the LICENSED-HARDWARE.txt file. If you are using hardware not defined in the LICENSED-HARDWARE.txt file or have licensing questions in general, please contact Microsoft directly at &lt;a href=&#34;https://aka.ms/azrtos-license&#34;&gt;https://aka.ms/azrtos-license&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Contribution, feedback, issues, and professional support&lt;/h1&gt; &#xA;&lt;p&gt;If you encounter any bugs, have suggestions for new features, or if you would like to become an active contributor to this project, please follow the instructions provided in the contribution guideline for the corresponding repo.&lt;/p&gt; &#xA;&lt;p&gt;For basic support, click Issues in the command bar or post a question to &lt;a href=&#34;http://stackoverflow.com/questions/tagged/azure-rtos+threadx&#34;&gt;Stack Overflow&lt;/a&gt; using the &lt;code&gt;threadx&lt;/code&gt; and &lt;code&gt;azure-rtos&lt;/code&gt; tags.&lt;/p&gt; &#xA;&lt;p&gt;Professional support plans (&lt;a href=&#34;https://azure.microsoft.com/en-us/support/options/&#34;&gt;https://azure.microsoft.com/en-us/support/options/&lt;/a&gt;) are available from Microsoft.&lt;/p&gt; &#xA;&lt;h1&gt;Additional Resources&lt;/h1&gt; &#xA;&lt;p&gt;The following are references to additional Azure RTOS and Azure IoT in general:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Content&lt;/th&gt; &#xA;   &lt;th&gt;Link&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TraceX Installer&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://aka.ms/azrtos-tracex-installer&#34;&gt;https://aka.ms/azrtos-tracex-installer&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Azure RTOS Documentation and Guides:&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://docs.microsoft.com/azure/rtos&#34;&gt;https://docs.microsoft.com/azure/rtos&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Azure RTOS Website:&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://azure.microsoft.com/services/rtos/&#34;&gt;https://azure.microsoft.com/services/rtos/&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Azure RTOS Sales Questions:&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://aka.ms/azrtos-license&#34;&gt;https://aka.ms/azrtos-license&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Azure RTOS Product Support Policy&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://aka.ms/azrtos/lts&#34;&gt;https://aka.ms/azrtos/lts&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Azure RTOS Functional Safety Artifacts&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://aka.ms/azrtos/tuv&#34;&gt;https://aka.ms/azrtos/tuv&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;For technical questions check out Microsoft Q/A for Azure IoT&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://aka.ms/QnA/azure-rtos&#34;&gt;https://aka.ms/QnA/azure-rtos&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Internet of Things Show for latest announcements and online training&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://aka.ms/iotshow&#34;&gt;https://aka.ms/iotshow&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;IoT Tech Community&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://aka.ms/community/azure-rtos&#34;&gt;https://aka.ms/community/azure-rtos&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>