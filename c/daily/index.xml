<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-30T01:28:02Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>HarbourMasters/2ship2harkinian</title>
    <updated>2024-05-30T01:28:02Z</updated>
    <id>tag:github.com,2024-05-30:/HarbourMasters/2ship2harkinian</id>
    <link href="https://github.com/HarbourMasters/2ship2harkinian" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;2 Ship 2 Harkinian&lt;/h1&gt; &#xA;&lt;h3&gt;Playtesting&lt;/h3&gt; &#xA;&lt;p&gt;If you want to playtest a continuous integration build, you can find them at the links below. Keep in mind that these are for playtesting only, and you will likely encounter bugs and possibly crashes.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nightly.link/HarbourMasters/2ship2harkinian/workflows/main/develop/2ship-windows.zip&#34;&gt;Windows&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nightly.link/HarbourMasters/2ship2harkinian/workflows/main/develop/2ship-linux.zip&#34;&gt;Linux&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nightly.link/HarbourMasters/2ship2harkinian/workflows/main/develop/2ship-mac.zip&#34;&gt;Mac&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>No-Chicken/OV-Watch</title>
    <updated>2024-05-30T01:28:02Z</updated>
    <id>tag:github.com,2024-05-30:/No-Chicken/OV-Watch</id>
    <link href="https://github.com/No-Chicken/OV-Watch" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A powerful Smart Watch based on STM32, FreeRTOS, LVGL. It only cost ￥80 RMB ( $12 USD ).&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;OV-Watch&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://img.shields.io/badge/version-2.4.0-blue&#34;&gt; &#xA; &lt;img src=&#34;https://img.shields.io/badge/License-GPL3.0-green)&#34;&gt; &#xA; &lt;img src=&#34;https://img.shields.io/github/stars/No-Chicken/OV-Watch.svg?sanitize=true&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;&lt;span&gt;📒&lt;/span&gt; Overview&lt;/h2&gt; &#xA;&lt;p&gt;A powerful Smart Watch&lt;/p&gt; &#xA;&lt;p&gt;如果你觉得这个手表的硬件难焊接难复刻，又想进行代码的学习，可以试一下新的STM32F411开发板：&lt;/p&gt; &#xA;&lt;p&gt;FriPi炸鸡派：&lt;a href=&#34;https://github.com/No-Chicken/FryPi&#34;&gt;https://github.com/No-Chicken/FryPi&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/MCU-STM32F411CEU6-blue&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/UI-LVGL-red&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/OS-FreeRTOS-green&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;50%&#34; src=&#34;./images/演示动图.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;50%&#34; src=&#34;./images/界面.jpg&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;🔗&lt;/span&gt;视频链接：&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://space.bilibili.com/34154740&#34;&gt;bilibili主页 &lt;/a&gt; | &lt;a href=&#34;https://oshwhub.com/no_chicken/zhi-neng-shou-biao-OV-Watch_V2.2&#34;&gt;硬件开源 &lt;/a&gt;| &lt;a href=&#34;https://www.bilibili.com/video/BV19g4y1N7YR/&#34;&gt;V2.3新增功能视频 &lt;/a&gt; | &lt;a href=&#34;https://www.bilibili.com/video/BV1hh4y1J7TS&#34;&gt;V2.2演示视频 &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;🚀&lt;/span&gt; 增加的功能说明&lt;/h2&gt; &#xA;&lt;p&gt;V2.4.0相对V2.3.2修改的功能包括：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;更改了Back板硬件, 将蓝牙的使能电路修改，以前不能完全关闭，现在可以不用蓝牙时直接关了蓝牙，就可以不用KT6328A了，直接使用KT6368A, 有SPP功能, 可以无线升级.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;增加了BootLoader程序, 即分离了Boot和App.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;增加了IAP OTA功能, 即可以通过蓝牙升级程序.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;修改了一些bug.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;&lt;span&gt;✒&lt;/span&gt;如何烧录：&lt;/h2&gt; &#xA;&lt;p&gt;由于具体的步骤太多这里不放了, 详细见Firmware中的README文件: &lt;a href=&#34;https://raw.githubusercontent.com/No-Chicken/OV-Watch/main/Firmware/README.md&#34;&gt;BootLoader和APP烧录说明&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;如果你觉得带BootLoader的V2.4.0版本太麻烦了, 可以自行去下载&lt;a href=&#34;https://github.com/No-Chicken/OV-Watch/tree/ver2.3.2&#34;&gt;ver2.3.2分支&lt;/a&gt;, 用以前的代码.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;📑&lt;/span&gt;功能表如下图所示：&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;75%&#34; src=&#34;./images/功能表.jpg&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;🌟&lt;/span&gt;实物图&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;50%&#34; src=&#34;./images/实物图.jpg&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;50%&#34; src=&#34;./images/实物图2.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;50%&#34; src=&#34;./images/实物图3.png&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;50%&#34; src=&#34;https://raw.githubusercontent.com/No-Chicken/OV-Watch/main/images/front.jpg&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;50%&#34; src=&#34;https://raw.githubusercontent.com/No-Chicken/OV-Watch/main/images/back.jpg&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;💻&lt;/span&gt;软件部分设计细节：&lt;/h2&gt; &#xA;&lt;h3&gt;1.低功耗设计&lt;/h3&gt; &#xA;&lt;p&gt;手表的模式分为3个。第一个是正常的运行模式，手表正常运行；第二个是睡眠模式，MCU进入STOP模式，MPU6050仍在记步数；第三个是关机模式，TPS63020直接关闭使能，此时无3V3供电，只有Vbat有供电。&lt;/p&gt; &#xA;&lt;p&gt;在最开始的时候，手表从睡眠到唤醒使用的是MPU6050的运动功能，打开中断，唤醒，但是这样尝试过，有个问题就是需要抖动幅度很大才能触发中断。所以最后还是用的RTC定时中断，然后定时检测当前手势状态，如果有抬腕动作则唤醒。&lt;/p&gt; &#xA;&lt;p&gt;MPU6050不能直接使用DMP库，初始化后功耗很高，需要进行一些改动，才能让功耗下来，具体看工程代码。&lt;/p&gt; &#xA;&lt;p&gt;蓝牙使用了KT6328A后，不建议关闭蓝牙使能，他的待机功耗很低。&lt;/p&gt; &#xA;&lt;p&gt;最后接3V3测试，运行模式70-80mA，待机模式1mA左右，关机模式基本不耗电只有RTC在工作。当然后面没有测试电源接到Vbat端经过DCDC供电的情况，这个功耗就完全看DCDC的效率的。&lt;/p&gt; &#xA;&lt;h3&gt;2.心率血氧&lt;/h3&gt; &#xA;&lt;p&gt;血氧部分暂时还没有写。&lt;/p&gt; &#xA;&lt;p&gt;心率计算本来使用的官方的库，但是计算太慢了，后面改为自己写的一个简易的峰值检测的算法。EM7028的PPG信号如下图所示&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;50%&#34; src=&#34;./images/EM7028的测量曲线.jpg&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;3.数据存储&lt;/h3&gt; &#xA;&lt;p&gt;目前使用的外部的EEPROM进行数据存储，主要用于存储设置等，详细可以看&lt;code&gt;Datasave.c&lt;/code&gt;文件。&lt;/p&gt; &#xA;&lt;h3&gt;4.页面切换逻辑&lt;/h3&gt; &#xA;&lt;p&gt;为了实现页面切换，可以返回上次的界面，这里使用了一个栈来存储页面对应的，例如，使用&lt;code&gt;user_Stack_Pop(&amp;amp;ScrRenewStack);&lt;/code&gt;弹出上一个界面，然后进入到新的界面再使用 &lt;code&gt;user_Stack_Push(&amp;amp;ScrRenewStack,(long long int)&amp;amp;ui_HomePage);&lt;/code&gt;入栈一个界面的指针地址。注意不能直接在push操作使用类似&lt;code&gt;ui_HomePage&lt;/code&gt;入栈，它是会动态变化的，这是个很大的坑。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//key1 pressed&#xA;if(keystr == 1)&#xA;{&#xA;    user_Stack_Pop(&amp;amp;ScrRenewStack);&#xA;    if(user_Stack_isEmpty(&amp;amp;ScrRenewStack))&#xA;    {&#xA;        ui_MenuPage_screen_init();&#xA;        lv_scr_load_anim(ui_MenuPage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);&#xA;        user_Stack_Push(&amp;amp;ScrRenewStack,(long long int)&amp;amp;ui_HomePage);&#xA;        user_Stack_Push(&amp;amp;ScrRenewStack,(long long int)&amp;amp;ui_MenuPage);&#xA;    }&#xA;    else if(ScrRenewStack.Data[ScrRenewStack.Top_Point-1] == (long long int)&amp;amp;ui_HomePage)&#xA;    {&#xA;        ui_HomePage_screen_init();&#xA;        lv_scr_load_anim(ui_HomePage,LV_SCR_LOAD_ANIM_MOVE_RIGHT,0,0,true);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;5.计算器逻辑&lt;/h3&gt; &#xA;&lt;p&gt;计算器的逻辑就是很经典的计算器问题，经典的就是开两个栈，一个存放符号，一个存数字，然后进行出栈计算等等操作，以&lt;code&gt;1+2*6/3&lt;/code&gt;为例，具体的过程如下动图所示。但是会有一个问题就是小数点，这个动图展示的只是整数计算的逻辑，带小数点的详细见代码。&lt;/p&gt; &#xA;&lt;p&gt;具体过程是：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;遍历表达式，当遇到操作数，将其压入操作数栈。&lt;/li&gt; &#xA; &lt;li&gt;遇到运算符时，如果运算符栈为空，则直接将其压入运算符栈。&lt;/li&gt; &#xA; &lt;li&gt;如果运算符栈不为空，那就与运算符栈顶元素进行比较：如果当前运算符优先级比栈顶运算符高，则继续将其压入运算符栈，如果当前运算符优先级比栈顶运算符低或者相等，则从操作数符栈顶取两个元素，从栈顶取出运算符进行运算，并将运算结果压入操作数栈。&lt;/li&gt; &#xA; &lt;li&gt;继续将当前运算符与运算符栈顶元素比较。&lt;/li&gt; &#xA; &lt;li&gt;继续按照以上步骤进行遍历，当遍历结束之后，则将当前两个栈内元素取出来进行运算即可得到最终结果。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;50%&#34; src=&#34;./images/计算.gif&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;6.LVGL在windows在vscode的仿真配置参考&lt;/h3&gt; &#xA;&lt;p&gt;参考链接: &lt;a href=&#34;https://blog.csdn.net/weixin_49337111/article/details/136536375&#34;&gt;https://blog.csdn.net/weixin_49337111/article/details/136536375&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;已经更改好的可以跑的代码放在了&lt;code&gt;lv_sim_vscode_win&lt;/code&gt;这个文件夹中，应该可以直接使用vscode打开。&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img border=&#34;1px&#34; width=&#34;70%&#34; src=&#34;https://raw.githubusercontent.com/No-Chicken/OV-Watch/main/images/LVGL_sim.jpg&#34;&gt; &lt;/p&gt;</summary>
  </entry>
</feed>