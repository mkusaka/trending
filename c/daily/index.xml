<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-19T01:35:41Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bytecodealliance/wasm-micro-runtime</title>
    <updated>2022-06-19T01:35:41Z</updated>
    <id>tag:github.com,2022-06-19:/bytecodealliance/wasm-micro-runtime</id>
    <link href="https://github.com/bytecodealliance/wasm-micro-runtime" rel="alternate"></link>
    <summary type="html">&lt;p&gt;WebAssembly Micro Runtime (WAMR)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;WebAssembly Micro Runtime&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md&#34;&gt;Build WAMR&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/README.md#build-wamrc-aot-compiler&#34;&gt;Build AOT Compiler&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/embed_wamr.md&#34;&gt;Embed WAMR&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/export_native_api.md&#34;&gt;Export Native API&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wasm_app.md&#34;&gt;Build WASM Apps&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/README.md#samples&#34;&gt;Samples&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;A &lt;a href=&#34;https://bytecodealliance.org/&#34;&gt;Bytecode Alliance&lt;/a&gt; project&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;WebAssembly Micro Runtime (WAMR) is a lightweight standalone WebAssembly (WASM) runtime with small footprint, high performance and highly configurable features for applications cross from embedded, IoT, edge to Trusted Execution Environment (TEE), smart contract, cloud native and so on. It includes a few parts as below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/README.md#iwasm-vm-core&#34;&gt;&lt;strong&gt;&#34;iwasm&#34; VM core&lt;/strong&gt;&lt;/a&gt; to run WASM applications, supporting interpreter mode, AOT mode (Ahead-of-Time compilation) and JIT mode (Just-in-Time compilation)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/README.md#build-wamrc-aot-compiler&#34;&gt;&lt;strong&gt;&#34;wamrc&#34; AOT compiler&lt;/strong&gt;&lt;/a&gt; to compile WASM file into AOT file for best performance and smaller runtime footprint, which is run by &#34;iwasm&#34; VM Core&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/README.md#application-framework&#34;&gt;&lt;strong&gt;application framework&lt;/strong&gt;&lt;/a&gt; and the supporting APIs for the WASM applications&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/README.md#remote-application-management&#34;&gt;&lt;strong&gt;dynamic management&lt;/strong&gt;&lt;/a&gt; of the WASM applications&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Getting started&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md&#34;&gt;Build iwasm VM core&lt;/a&gt; on &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#linux&#34;&gt;Linux&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/linux_sgx.md&#34;&gt;SGX&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#macos&#34;&gt;MacOS&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#windows&#34;&gt;Windows&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/README.md#build-wamrc-aot-compiler&#34;&gt;Build wamrc AOT compiler&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/embed_wamr.md&#34;&gt;Embed WAMR into host applications&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/embed_wamr.md&#34;&gt;Embed into C/C++&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/language-bindings/python&#34;&gt;Embed into Python&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/language-bindings/go&#34;&gt;Embed into Go&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/export_native_api.md&#34;&gt;Register native APIs for WASM applications&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wasm_app.md&#34;&gt;Build WASM applications&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/port_wamr.md&#34;&gt;Port WAMR to a new platform&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/tests/benchmarks&#34;&gt;Benchmarks&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples&#34;&gt;Samples&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;iwasm VM core&lt;/h1&gt; &#xA;&lt;h3&gt;Key features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Full compliant to the W3C WASM MVP&lt;/li&gt; &#xA; &lt;li&gt;Small runtime binary size (~85K for interpreter and ~50K for AOT) and low memory usage&lt;/li&gt; &#xA; &lt;li&gt;Near to native speed by AOT and JIT&lt;/li&gt; &#xA; &lt;li&gt;Self-implemented AOT module loader to enable AOT working on Linux, Windows, MacOS, Android, SGX and MCU systems&lt;/li&gt; &#xA; &lt;li&gt;Choices of WASM application libc support: the built-in libc subset for the embedded environment or &lt;a href=&#34;https://github.com/WebAssembly/WASI&#34;&gt;WASI&lt;/a&gt; for the standard libc&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/embed_wamr.md&#34;&gt;The simple C APIs to embed WAMR into host environment&lt;/a&gt;, see &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/embed_wamr.md&#34;&gt;how to integrate WAMR&lt;/a&gt; and the &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/core/iwasm/include/wasm_export.h&#34;&gt;API list&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/export_native_api.md&#34;&gt;The mechanism to export native APIs to WASM applications&lt;/a&gt;, see &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/export_native_api.md&#34;&gt;how to register native APIs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/multi_module.md&#34;&gt;Multiple modules as dependencies&lt;/a&gt;, ref to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/multi_module.md&#34;&gt;document&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/multi-module&#34;&gt;sample&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/pthread_library.md&#34;&gt;Multi-thread, pthread APIs and thread management&lt;/a&gt;, ref to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/pthread_library.md&#34;&gt;document&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/multi-thread&#34;&gt;sample&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/linux_sgx.md&#34;&gt;Linux SGX (Intel Software Guard Extension) support&lt;/a&gt;, ref to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/linux_sgx.md&#34;&gt;document&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/source_debugging.md&#34;&gt;Source debugging support&lt;/a&gt;, ref to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/source_debugging.md&#34;&gt;document&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/test-tools/wamr-ide&#34;&gt;WAMR-IDE (Experimental)&lt;/a&gt; to develop WebAssembly applications with build, run and debug support, ref to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/test-tools/wamr-ide&#34;&gt;document&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/xip.md&#34;&gt;XIP (Execution In Place) support&lt;/a&gt;, ref to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/xip.md&#34;&gt;document&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/socket_api.md&#34;&gt;Berkeley/Posix Socket support&lt;/a&gt;, ref to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/socket_api.md&#34;&gt;document&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/socket-api&#34;&gt;sample&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;WASM post-MVP features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WebAssembly/wasm-c-api&#34;&gt;wasm-c-api&lt;/a&gt;, ref to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/wasm_c_api.md&#34;&gt;document&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/wasm-c-api&#34;&gt;sample&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WebAssembly/simd&#34;&gt;128-bit SIMD&lt;/a&gt;, ref to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/workload&#34;&gt;samples/workload&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WebAssembly/reference-types&#34;&gt;Reference Types&lt;/a&gt;, ref to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/ref_types.md&#34;&gt;document&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/ref-types&#34;&gt;sample&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WebAssembly/nontrapping-float-to-int-conversions&#34;&gt;Non-trapping float-to-int conversions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WebAssembly/sign-extension-ops&#34;&gt;Sign-extension operators&lt;/a&gt;, &lt;a href=&#34;https://github.com/WebAssembly/bulk-memory-operations&#34;&gt;Bulk memory operations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WebAssembly/multi-value&#34;&gt;Multi-value&lt;/a&gt;, &lt;a href=&#34;https://github.com/WebAssembly/tail-call&#34;&gt;Tail-call&lt;/a&gt;, &lt;a href=&#34;https://github.com/WebAssembly/threads/raw/main/proposals/threads/Overview.md#shared-linear-memory&#34;&gt;Shared memory&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Supported architectures and platforms&lt;/h3&gt; &#xA;&lt;p&gt;The iwasm supports the following architectures:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;X86-64, X86-32&lt;/li&gt; &#xA; &lt;li&gt;ARM, THUMB (ARMV7 Cortex-M7 and Cortex-A15 are tested)&lt;/li&gt; &#xA; &lt;li&gt;AArch64 (Cortex-A57 and Cortex-A53 are tested)&lt;/li&gt; &#xA; &lt;li&gt;RISCV64, RISCV32 (RISC-V LP64 and RISC-V LP64D are tested)&lt;/li&gt; &#xA; &lt;li&gt;XTENSA, MIPS, ARC&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following platforms are supported, click each link below for how to build iwasm on that platform. Refer to &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/port_wamr.md&#34;&gt;WAMR porting guide&lt;/a&gt; for how to port WAMR to a new platform.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#linux&#34;&gt;Linux&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/linux_sgx.md&#34;&gt;Linux SGX (Intel Software Guard Extension)&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#macos&#34;&gt;MacOS&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#android&#34;&gt;Android&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#windows&#34;&gt;Windows&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#mingw&#34;&gt;Windows (MinGW)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#zephyr&#34;&gt;Zephyr&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#alios-things&#34;&gt;AliOS-Things&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#vxworks&#34;&gt;VxWorks&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#nuttx&#34;&gt;NuttX&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#RT-Thread&#34;&gt;RT-Thread&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#esp-idf&#34;&gt;ESP-IDF&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Build iwasm VM core (mini product)&lt;/h3&gt; &#xA;&lt;p&gt;WAMR supports building the iwasm VM core only (no app framework) to the mini product. The WAMR mini product takes the WASM application file name or AOT file name as input and then executes it. For the detailed procedure, please see &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md&#34;&gt;build WAMR VM core&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wasm_app.md&#34;&gt;build and run WASM application&lt;/a&gt;&lt;/strong&gt;. Also we can click the link of each platform above to see how to build iwasm on it.&lt;/p&gt; &#xA;&lt;h3&gt;Build wamrc AOT compiler&lt;/h3&gt; &#xA;&lt;p&gt;Both wasm binary file and AOT file are supported by iwasm. The wamrc AOT compiler is to compile wasm binary file to AOT file which can also be run by iwasm. Execute following commands to build &lt;strong&gt;wamrc&lt;/strong&gt; compiler for Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd wamr-compiler&#xA;./build_llvm.sh (or &#34;./build_llvm_xtensa.sh&#34; to support xtensa target)&#xA;mkdir build &amp;amp;&amp;amp; cd build&#xA;cmake .. (or &#34;cmake .. -DWAMR_BUILD_PLATFORM=darwin&#34; for MacOS)&#xA;make&#xA;# wamrc is generated under current directory&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For &lt;strong&gt;Windows&lt;/strong&gt;：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd wamr-compiler&#xA;python build_llvm.py&#xA;mkdir build &amp;amp;&amp;amp; cd build&#xA;cmake ..&#xA;cmake --build . --config Release&#xA;# wamrc.exe is generated under .\Release directory&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Performance and Footprint&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bytecodealliance/wasm-micro-runtime/wiki/Performance&#34;&gt;Performance and footprint data&lt;/a&gt;: checkout &lt;a href=&#34;https://github.com/bytecodealliance/wasm-micro-runtime/wiki/Performance&#34;&gt;here&lt;/a&gt; for the performance and footprint data&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/memory_tune.md&#34;&gt;Memory usage tunning&lt;/a&gt;: checkout &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/memory_tune.md&#34;&gt;here&lt;/a&gt; for the memory model and how to tune the memory usage&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#enable-memory-profiling-experiment&#34;&gt;Memory usage profiling&lt;/a&gt;: checkout &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/build_wamr.md#enable-memory-profiling-experiment&#34;&gt;here&lt;/a&gt; for how to profile the memory usage&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/tests/benchmarks&#34;&gt;Benchmarks&lt;/a&gt;: checkout these links for how to run the benchmarks: &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/tests/benchmarks/polybench&#34;&gt;PolyBench&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/tests/benchmarks/coremark&#34;&gt;CoreMark&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/tests/benchmarks/sightglass&#34;&gt;Sightglass&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/tests/benchmarks/jetstream&#34;&gt;JetStream2&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;User cases&lt;/h3&gt; &#xA;&lt;p&gt;WAMR is widely used in a lot areas, here are some cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hyperledger-labs/private-data-objects/raw/main/common/interpreter/wawaka_wasm/README.md&#34;&gt;Hyperledger Private Data Objects&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alibaba/inclavare-containers&#34;&gt;Inclavare Containers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/faasm/faasm&#34;&gt;Fassm&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.aliyun.com/article/787582&#34;&gt;Waft&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy&#34;&gt;Envoy Proxy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://teaclave.apache.org/docs/executing-wasm&#34;&gt;Apache Teaclave&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Application framework&lt;/h1&gt; &#xA;&lt;p&gt;By using the iwasm VM core, we are flexible to build different application frameworks for the specific domains, although it would take quite some effort.&lt;/p&gt; &#xA;&lt;p&gt;The WAMR has offered a comprehensive framework for programming WASM applications for device and IoT usages. The framework supports running multiple applications, that are based on the event driven programming model. Here are the supporting API sets by the &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/wamr_api.md&#34;&gt;WAMR application framework library&lt;/a&gt; :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Timer, Inter-app communication (request/response and pub/sub), Sensor, Connectivity and data transmission, 2D graphic UI&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Browse the folder &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/core/app-framework&#34;&gt;core/app-framework&lt;/a&gt; for how to extend the application framework.&lt;/p&gt; &#xA;&lt;h1&gt;Remote application management&lt;/h1&gt; &#xA;&lt;p&gt;The WAMR application manager supports &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/core/app-mgr&#34;&gt;remote application management&lt;/a&gt; from the host environment or the cloud through any physical communications such as TCP, UPD, UART, BLE, etc. Its modular design makes it able to support application management for different managed runtimes.&lt;/p&gt; &#xA;&lt;p&gt;The tool &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/test-tools/host-tool&#34;&gt;host_tool&lt;/a&gt; communicates to the WAMR app manager for installing/uninstalling the WASM applications on companion chip from the host system. And the &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/test-tools/IoT-APP-Store-Demo/&#34;&gt;IoT App Store Demo&lt;/a&gt; shows the conception of remotely managing the device applications from the cloud.&lt;/p&gt; &#xA;&lt;h1&gt;WAMR SDK&lt;/h1&gt; &#xA;&lt;p&gt;Usually there are two tasks for integrating the WAMR into a particular project:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Select what WAMR components (vmcore, libc, app-mgr, app-framework components) to be integrated, and get the associated source files added into the project building configuration&lt;/li&gt; &#xA; &lt;li&gt;Generate the APP SDK for developing the WASM apps on the selected libc and framework components&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/wamr-sdk&#34;&gt;WAMR SDK&lt;/a&gt;&lt;/strong&gt; tools is helpful to finish the two tasks quickly. It supports menu configuration for selecting WAMR components and builds the WAMR to a SDK package that includes &lt;strong&gt;runtime SDK&lt;/strong&gt; and &lt;strong&gt;APP SDK&lt;/strong&gt;. The runtime SDK is used for building the native application and the APP SDK should be shipped to WASM application developers.&lt;/p&gt; &#xA;&lt;h1&gt;Samples&lt;/h1&gt; &#xA;&lt;p&gt;The WAMR &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples&#34;&gt;samples&lt;/a&gt; integrate the iwasm VM core, application manager and selected application framework components.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/basic&#34;&gt;&lt;strong&gt;basic&lt;/strong&gt;&lt;/a&gt;: Demonstrating how to use runtime exposed API&#39;s to call WASM functions, how to register native functions and call them, and how to call WASM function from native function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/simple/README.md&#34;&gt;simple&lt;/a&gt;&lt;/strong&gt;: The runtime is integrated with most of the WAMR APP libraries, and a few WASM applications are provided for testing the WAMR APP API set. It uses &lt;strong&gt;built-in libc&lt;/strong&gt; and executes apps in &lt;strong&gt;interpreter&lt;/strong&gt; mode by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/littlevgl/README.md&#34;&gt;littlevgl&lt;/a&gt;&lt;/strong&gt;: Demonstrating the graphic user interface application usage on WAMR. The whole &lt;a href=&#34;https://github.com/lvgl/lvgl&#34;&gt;LVGL&lt;/a&gt; 2D user graphic library and the UI application are built into WASM application. It uses &lt;strong&gt;WASI libc&lt;/strong&gt; and executes apps in &lt;strong&gt;AOT mode&lt;/strong&gt; by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/gui/README.md&#34;&gt;gui&lt;/a&gt;&lt;/strong&gt;: Move the &lt;a href=&#34;https://github.com/lvgl/lvgl&#34;&gt;LVGL&lt;/a&gt; library into the runtime and define a WASM application interface by wrapping the littlevgl API. It uses &lt;strong&gt;WASI libc&lt;/strong&gt; and executes apps in &lt;strong&gt;interpreter&lt;/strong&gt; mode by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/multi-thread/&#34;&gt;multi-thread&lt;/a&gt;&lt;/strong&gt;: Demonstrating how to run wasm application which creates multiple threads to execute wasm functions concurrently, and uses mutex/cond by calling pthread related API&#39;s.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/spawn-thread&#34;&gt;spawn-thread&lt;/a&gt;&lt;/strong&gt;: Demonstrating how to execute wasm functions of the same wasm application concurrently, in threads created by host embedder or runtime, but not the wasm application itself.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/multi-module&#34;&gt;multi-module&lt;/a&gt;&lt;/strong&gt;: Demonstrating the &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/doc/multi_module.md&#34;&gt;multiple modules as dependencies&lt;/a&gt; feature which implements the &lt;a href=&#34;https://webassembly.org/docs/dynamic-linking/&#34;&gt;load-time dynamic linking&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/ref-types&#34;&gt;ref-types&lt;/a&gt;&lt;/strong&gt;: Demonstrating how to call wasm functions with argument of externref type introduced by &lt;a href=&#34;https://github.com/WebAssembly/reference-types&#34;&gt;reference types proposal&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/wasm-c-api/README.md&#34;&gt;wasm-c-api&lt;/a&gt;&lt;/strong&gt;: Demonstrating how to run some samples from &lt;a href=&#34;https://github.com/WebAssembly/wasm-c-api&#34;&gt;wasm-c-api proposal&lt;/a&gt; and showing the supported API&#39;s.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/socket-api/README.md&#34;&gt;socket-api&lt;/a&gt;&lt;/strong&gt;: Demonstrating how to run wasm tcp server and tcp client applications, and how they communicate with each other.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/samples/workload/README.md&#34;&gt;workload&lt;/a&gt;&lt;/strong&gt;: Demonstrating how to build and run some complex workloads, e.g. tensorflow-lite, XNNPACK, wasm-av1, meshoptimizer and bwa.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Project Technical Steering Committee&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/wasm-micro-runtime/main/TSC_Charter.md&#34;&gt;WAMR PTSC Charter&lt;/a&gt; governs the operations of the project TSC. The current TSC members:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lum1n0us&#34;&gt;lum1n0us&lt;/a&gt; - &lt;strong&gt;Liang He&lt;/strong&gt;， &lt;a href=&#34;mailto:liang.he@intel.com&#34;&gt;liang.he@intel.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/no1wudi&#34;&gt;no1wudi&lt;/a&gt; &lt;strong&gt;Qi Huang&lt;/strong&gt;, &lt;a href=&#34;mailto:huangqi3@xiaomi.com&#34;&gt;huangqi3@xiaomi.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/qinxk-inter&#34;&gt;qinxk-inter&lt;/a&gt; - &lt;strong&gt;Xiaokang Qin&lt;/strong&gt;， &lt;a href=&#34;mailto:xiaokang.qxk@antgroup.com&#34;&gt;xiaokang.qxk@antgroup.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wei-tang&#34;&gt;wei-tang&lt;/a&gt; - &lt;strong&gt;Wei Tang&lt;/strong&gt;， &lt;a href=&#34;mailto:tangwei.tang@antgroup.com&#34;&gt;tangwei.tang@antgroup.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wenyongh&#34;&gt;wenyongh&lt;/a&gt; - &lt;strong&gt;Wenyong Huang&lt;/strong&gt;， &lt;a href=&#34;mailto:wenyong.huang@intel.com&#34;&gt;wenyong.huang@intel.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xujuntwt95329&#34;&gt;xujuntwt95329&lt;/a&gt; - &lt;strong&gt;Jun Xu&lt;/strong&gt;， &lt;a href=&#34;mailto:Jun1.Xu@intel.com&#34;&gt;Jun1.Xu@intel.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xwang98&#34;&gt;xwang98&lt;/a&gt; - &lt;strong&gt;Xin Wang&lt;/strong&gt;， &lt;a href=&#34;mailto:xin.wang@intel.com&#34;&gt;xin.wang@intel.com&lt;/a&gt; (chair)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;WAMR uses the same license as LLVM: the &lt;code&gt;Apache 2.0 license&lt;/code&gt; with the LLVM exception. See the LICENSE file for details. This license allows you to freely use, modify, distribute and sell your own products based on WAMR. Any contributions you make will be under the same license.&lt;/p&gt; &#xA;&lt;h1&gt;More resources&lt;/h1&gt; &#xA;&lt;p&gt;Check out the &lt;a href=&#34;https://github.com/bytecodealliance/wasm-micro-runtime/wiki&#34;&gt;Wiki documents &lt;/a&gt; for more resources:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bytecodealliance/wasm-micro-runtime/wiki/Events&#34;&gt;Community news and events&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bytecodealliance/wasm-micro-runtime/wiki/Roadmap&#34;&gt;Roadmap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bytecodealliance/wasm-micro-runtime/wiki/TSC-meeting&#34;&gt;WAMR TSC meetings&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Technical documents&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>libuv/libuv</title>
    <updated>2022-06-19T01:35:41Z</updated>
    <id>tag:github.com,2022-06-19:/libuv/libuv</id>
    <link href="https://github.com/libuv/libuv" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cross-platform asynchronous I/O&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/libuv/libuv/master/img/banner.png&#34; alt=&#34;libuv&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;libuv is a multi-platform support library with a focus on asynchronous I/O. It was primarily developed for use by &lt;a href=&#34;http://nodejs.org/&#34;&gt;Node.js&lt;/a&gt;, but it&#39;s also used by &lt;a href=&#34;http://luvit.io/&#34;&gt;Luvit&lt;/a&gt;, &lt;a href=&#34;http://julialang.org/&#34;&gt;Julia&lt;/a&gt;, &lt;a href=&#34;https://github.com/MagicStack/uvloop&#34;&gt;uvloop&lt;/a&gt;, and &lt;a href=&#34;https://github.com/libuv/libuv/raw/v1.x/LINKS.md&#34;&gt;others&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Feature highlights&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Full-featured event loop backed by epoll, kqueue, IOCP, event ports.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Asynchronous TCP and UDP sockets&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Asynchronous DNS resolution&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Asynchronous file and file system operations&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;File system events&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;ANSI escape code controlled TTY&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;IPC with socket sharing, using Unix domain sockets or named pipes (Windows)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Child processes&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Thread pool&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Signal handling&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;High resolution clock&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Threading and synchronization primitives&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Versioning&lt;/h2&gt; &#xA;&lt;p&gt;Starting with version 1.0.0 libuv follows the &lt;a href=&#34;http://semver.org/&#34;&gt;semantic versioning&lt;/a&gt; scheme. The API change and backwards compatibility rules are those indicated by SemVer. libuv will keep a stable ABI across major releases.&lt;/p&gt; &#xA;&lt;p&gt;The ABI/API changes can be tracked &lt;a href=&#34;http://abi-laboratory.pro/tracker/timeline/libuv/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Licensing&lt;/h2&gt; &#xA;&lt;p&gt;libuv is licensed under the MIT license. Check the &lt;a href=&#34;https://raw.githubusercontent.com/libuv/libuv/v1.x/LICENSE&#34;&gt;LICENSE file&lt;/a&gt;. The documentation is licensed under the CC BY 4.0 license. Check the &lt;a href=&#34;https://raw.githubusercontent.com/libuv/libuv/v1.x/LICENSE-docs&#34;&gt;LICENSE-docs file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/libuv/libuv/discussions&#34;&gt;Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://groups.google.com/group/libuv&#34;&gt;Mailing list&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;h3&gt;Official documentation&lt;/h3&gt; &#xA;&lt;p&gt;Located in the docs/ subdirectory. It uses the &lt;a href=&#34;http://sphinx-doc.org/&#34;&gt;Sphinx&lt;/a&gt; framework, which makes it possible to build the documentation in multiple formats.&lt;/p&gt; &#xA;&lt;p&gt;Show different supported building options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build documentation as HTML:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make html&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build documentation as HTML and live reload it when it changes (this requires sphinx-autobuild to be installed and is only supported on Unix):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make livehtml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build documentation as man pages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make man&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build documentation as ePub:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make epub&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: Windows users need to use make.bat instead of plain &#39;make&#39;.&lt;/p&gt; &#xA;&lt;p&gt;Documentation can be browsed online &lt;a href=&#34;http://docs.libuv.org&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/libuv/libuv/tree/master/test&#34;&gt;tests and benchmarks&lt;/a&gt; also serve as API specification and usage examples.&lt;/p&gt; &#xA;&lt;h3&gt;Other resources&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=nGn60vDSxQ4&#34;&gt;LXJS 2012 talk&lt;/a&gt; — High-level introductory talk about libuv.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/thlorenz/libuv-dox&#34;&gt;libuv-dox&lt;/a&gt; — Documenting types and methods of libuv, mostly by reading uv.h.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/thlorenz/learnuv&#34;&gt;learnuv&lt;/a&gt; — Learn uv for fun and profit, a self guided workshop to libuv.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These resources are not handled by libuv maintainers and might be out of date. Please verify it before opening new issues.&lt;/p&gt; &#xA;&lt;h2&gt;Downloading&lt;/h2&gt; &#xA;&lt;p&gt;libuv can be downloaded either from the &lt;a href=&#34;https://github.com/libuv/libuv&#34;&gt;GitHub repository&lt;/a&gt; or from the &lt;a href=&#34;http://dist.libuv.org/dist/&#34;&gt;downloads site&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Before verifying the git tags or signature files, importing the relevant keys is necessary. Key IDs are listed in the &lt;a href=&#34;https://github.com/libuv/libuv/raw/master/MAINTAINERS.md&#34;&gt;MAINTAINERS&lt;/a&gt; file, but are also available as git blob objects for easier use.&lt;/p&gt; &#xA;&lt;p&gt;Importing a key the usual way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gpg --keyserver pool.sks-keyservers.net --recv-keys AE9BC059&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Importing a key from a git blob object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git show pubkey-saghul | gpg --import&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Verifying releases&lt;/h3&gt; &#xA;&lt;p&gt;Git tags are signed with the developer&#39;s key, they can be verified as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git verify-tag v1.6.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Starting with libuv 1.7.0, the tarballs stored in the &lt;a href=&#34;http://dist.libuv.org/dist/&#34;&gt;downloads site&lt;/a&gt; are signed and an accompanying signature file sit alongside each. Once both the release tarball and the signature file are downloaded, the file can be verified as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gpg --verify libuv-1.7.0.tar.gz.sign&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build Instructions&lt;/h2&gt; &#xA;&lt;p&gt;For UNIX-like platforms, including macOS, there are two build methods: autotools or &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For Windows, &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt; is the only supported build method and has the following prerequisites:&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;One of: &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://visualstudio.microsoft.com/visual-cpp-build-tools/&#34;&gt;Visual C++ Build Tools&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://www.visualstudio.com/vs/older-downloads/&#34;&gt;Visual Studio 2015 Update 3&lt;/a&gt;, all editions including the Community edition (remember to select &#34;Common Tools for Visual C++ 2015&#34; feature during installation).&lt;/li&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://www.visualstudio.com/downloads/&#34;&gt;Visual Studio 2017&lt;/a&gt;, any edition (including the Build Tools SKU). &lt;strong&gt;Required Components:&lt;/strong&gt; &#34;MSbuild&#34;, &#34;VC++ 2017 v141 toolset&#34; and one of the Windows SDKs (10 or 8.1).&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;Basic Unix tools required for some tests, &lt;a href=&#34;http://git-scm.com/download/win&#34;&gt;Git for Windows&lt;/a&gt; includes Git Bash and tools which can be included in the global &lt;code&gt;PATH&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;To build with autotools:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sh autogen.sh&#xA;$ ./configure&#xA;$ make&#xA;$ make check&#xA;$ make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build with &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir -p build&#xA;&#xA;$ (cd build &amp;amp;&amp;amp; cmake .. -DBUILD_TESTING=ON) # generate project with tests&#xA;$ cmake --build build                       # add `-j &amp;lt;n&amp;gt;` with cmake &amp;gt;= 3.12&#xA;&#xA;# Run tests:&#xA;$ (cd build &amp;amp;&amp;amp; ctest -C Debug --output-on-failure)&#xA;&#xA;# Or manually run tests:&#xA;$ build/uv_run_tests                        # shared library build&#xA;$ build/uv_run_tests_a                      # static library build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To cross-compile with &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt; (unsupported but generally works):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake ../..                 \&#xA;  -DCMAKE_SYSTEM_NAME=Windows \&#xA;  -DCMAKE_SYSTEM_VERSION=6.1  \&#xA;  -DCMAKE_C_COMPILER=i686-w64-mingw32-gcc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install with Homebrew&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ brew install --HEAD libuv&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note to OS X users:&lt;/p&gt; &#xA;&lt;p&gt;Make sure that you specify the architecture you wish to build for in the &#34;ARCHS&#34; flag. You can specify more than one by delimiting with a space (e.g. &#34;x86_64 i386&#34;).&lt;/p&gt; &#xA;&lt;h3&gt;Running tests&lt;/h3&gt; &#xA;&lt;p&gt;Some tests are timing sensitive. Relaxing test timeouts may be necessary on slow or overloaded machines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ env UV_TEST_TIMEOUT_MULTIPLIER=2 build/uv_run_tests # 10s instead of 5s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Run one test&lt;/h4&gt; &#xA;&lt;p&gt;The list of all tests is in &lt;code&gt;test/test-list.h&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This invocation will cause the test driver to fork and execute &lt;code&gt;TEST_NAME&lt;/code&gt; in a child process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ build/uv_run_tests_a TEST_NAME&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This invocation will cause the test driver to execute the test in the same process:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ build/uv_run_tests_a TEST_NAME TEST_NAME&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Debugging tools&lt;/h4&gt; &#xA;&lt;p&gt;When running the test from within the test driver process (&lt;code&gt;build/uv_run_tests_a TEST_NAME TEST_NAME&lt;/code&gt;), tools like gdb and valgrind work normally.&lt;/p&gt; &#xA;&lt;p&gt;When running the test from a child of the test driver process (&lt;code&gt;build/uv_run_tests_a TEST_NAME&lt;/code&gt;), use these tools in a fork-aware manner.&lt;/p&gt; &#xA;&lt;h5&gt;Fork-aware gdb&lt;/h5&gt; &#xA;&lt;p&gt;Use the &lt;a href=&#34;https://sourceware.org/gdb/onlinedocs/gdb/Forks.html&#34;&gt;follow-fork-mode&lt;/a&gt; setting:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gdb --args build/uv_run_tests_a TEST_NAME&#xA;&#xA;(gdb) set follow-fork-mode child&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Fork-aware valgrind&lt;/h5&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;--trace-children=yes&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ valgrind --trace-children=yes -v --tool=memcheck --leak-check=full --track-origins=yes --leak-resolution=high --show-reachable=yes --log-file=memcheck-%p.log build/uv_run_tests_a TEST_NAME&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running benchmarks&lt;/h3&gt; &#xA;&lt;p&gt;See the section on running tests. The benchmark driver is &lt;code&gt;./uv_run_benchmarks_a&lt;/code&gt; and the benchmarks are listed in &lt;code&gt;test/benchmark-list.h&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Supported Platforms&lt;/h2&gt; &#xA;&lt;p&gt;Check the &lt;a href=&#34;https://raw.githubusercontent.com/libuv/libuv/v1.x/SUPPORTED_PLATFORMS.md&#34;&gt;SUPPORTED_PLATFORMS file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;-fno-strict-aliasing&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;It is recommended to turn on the &lt;code&gt;-fno-strict-aliasing&lt;/code&gt; compiler flag in projects that use libuv. The use of ad hoc &#34;inheritance&#34; in the libuv API may not be safe in the presence of compiler optimizations that depend on strict aliasing.&lt;/p&gt; &#xA;&lt;p&gt;MSVC does not have an equivalent flag but it also does not appear to need it at the time of writing (December 2019.)&lt;/p&gt; &#xA;&lt;h3&gt;AIX Notes&lt;/h3&gt; &#xA;&lt;p&gt;AIX compilation using IBM XL C/C++ requires version 12.1 or greater.&lt;/p&gt; &#xA;&lt;p&gt;AIX support for filesystem events requires the non-default IBM &lt;code&gt;bos.ahafs&lt;/code&gt; package to be installed. This package provides the AIX Event Infrastructure that is detected by &lt;code&gt;autoconf&lt;/code&gt;. &lt;a href=&#34;http://www.ibm.com/developerworks/aix/library/au-aix_event_infrastructure/&#34;&gt;IBM documentation&lt;/a&gt; describes the package in more detail.&lt;/p&gt; &#xA;&lt;h3&gt;z/OS Notes&lt;/h3&gt; &#xA;&lt;p&gt;z/OS compilation requires &lt;a href=&#34;https://github.com/ibmruntimes/zoslib&#34;&gt;ZOSLIB&lt;/a&gt; to be installed. When building with &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt;, use the flag &lt;code&gt;-DZOSLIB_DIR&lt;/code&gt; to specify the path to &lt;a href=&#34;https://github.com/ibmruntimes/zoslib&#34;&gt;ZOSLIB&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ (cd build &amp;amp;&amp;amp; cmake .. -DBUILD_TESTING=ON -DZOSLIB_DIR=/path/to/zoslib)&#xA;$ cmake --build build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;z/OS creates System V semaphores and message queues. These persist on the system after the process terminates unless the event loop is closed.&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;ipcrm&lt;/code&gt; command to manually clear up System V resources.&lt;/p&gt; &#xA;&lt;h2&gt;Patches&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/libuv/libuv/raw/master/CONTRIBUTING.md&#34;&gt;guidelines for contributing&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>vedderb/bldc</title>
    <updated>2022-06-19T01:35:41Z</updated>
    <id>tag:github.com,2022-06-19:/vedderb/bldc</id>
    <link href="https://github.com/vedderb/bldc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The VESC motor control firmware&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;VESC firmware&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-GPLv3-blue.svg?sanitize=true&#34; alt=&#34;License: GPL v3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.com/vedderb/bldc&#34;&gt;&lt;img src=&#34;https://travis-ci.com/vedderb/bldc.svg?branch=master&#34; alt=&#34;Travis CI Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.codacy.com/app/vedderb/bldc?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=vedderb/bldc&amp;amp;utm_campaign=Badge_Grade&#34;&gt;&lt;img src=&#34;https://api.codacy.com/project/badge/Grade/75e90ffbd46841a3a7be2a9f7a94c242&#34; alt=&#34;Codacy Badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/vedderb/bldc/graphs/contributors&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/contributors/vedderb/bldc.svg?sanitize=true&#34; alt=&#34;Contributors&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/vedderb/bldc/watchers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/watchers/vedderb/bldc.svg?sanitize=true&#34; alt=&#34;Watchers&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/vedderb/bldc/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/vedderb/bldc.svg?sanitize=true&#34; alt=&#34;Stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/vedderb/bldc/network/members&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/forks/vedderb/bldc.svg?sanitize=true&#34; alt=&#34;Forks&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;An open source motor controller firmware.&lt;/p&gt; &#xA;&lt;p&gt;This is the source code for the VESC DC/BLDC/FOC controller. Read more at &lt;a href=&#34;https://vesc-project.com/&#34;&gt;https://vesc-project.com/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Supported boards&lt;/h2&gt; &#xA;&lt;p&gt;All of them!&lt;/p&gt; &#xA;&lt;p&gt;Check the supported boards by typing &lt;code&gt;make&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Firmware]&#xA;     fw   - Build firmware for default target&#xA;                            supported boards are: 100_250 100_250_no_limits 100_500...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are also many other options that can be changed in &lt;a href=&#34;https://raw.githubusercontent.com/vedderb/bldc/master/conf_general.h&#34;&gt;conf_general.h&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;h3&gt;On Ubuntu (Linux)/macOS&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tools: &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;wget&lt;/code&gt;, and &lt;code&gt;make&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Additional Linux requirements: &lt;code&gt;libgl-dev&lt;/code&gt; and &lt;code&gt;libxcb-xinerama0&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Helpful Ubuntu commands:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install git build-essential libgl-dev libxcb-xinerama0 wget git-gui&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Helpful macOS tools:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install stlink&#xA;brew install openocd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;On Windows&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Chocolately: &lt;a href=&#34;https://chocolatey.org/install&#34;&gt;https://chocolatey.org/install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Git: &lt;a href=&#34;https://git-scm.com/download/win&#34;&gt;https://git-scm.com/download/win&lt;/a&gt;. Make sure to click any boxes to add Git to your Environment (aka PATH)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install Dev environment and build&lt;/h2&gt; &#xA;&lt;h3&gt;On Ubuntu (Linux)/MacOS&lt;/h3&gt; &#xA;&lt;p&gt;Open up a terminal&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;git clone http://github.com/vedderb/bldc.git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd bldc&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Continue with &lt;a href=&#34;https://raw.githubusercontent.com/vedderb/bldc/master/#on-all-platforms&#34;&gt;On all platforms&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;On Windows&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open up a Windows Powershell terminal (Resist the urge to run Powershell as administrator, that will break things)&lt;/li&gt; &#xA; &lt;li&gt;Type &lt;code&gt;choco install make&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;git clone http://github.com/vedderb/bldc&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd bldc&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Continue with &lt;a href=&#34;https://raw.githubusercontent.com/vedderb/bldc/master/#on-all-platforms&#34;&gt;On all platforms&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;On all platforms&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;git checkout origin/master&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make arm_sdk_install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make&lt;/code&gt; &amp;lt;-- Pick out the name of your target device from the supported boards list. For instance, I have a Trampa &lt;strong&gt;VESC 100/250&lt;/strong&gt;, so my target is &lt;code&gt;100_250&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make 100_250&lt;/code&gt; &amp;lt;-- This will build the &lt;strong&gt;VESC 100/250&lt;/strong&gt; firmware and place it into the &lt;code&gt;bldc/builds/100_250/&lt;/code&gt; directory&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Other tools&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Linux Optional - Add udev rules to use the stlink v2 programmer without being root&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget vedder.se/Temp/49-stlinkv2.rules&#xA;sudo mv 49-stlinkv2.rules /etc/udev/rules.d/&#xA;sudo udevadm trigger&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;IDE&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;h4&gt;On macOS/Linux&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;python3&lt;/code&gt;, and &lt;code&gt;pip&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;On Windows&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Python 3: &lt;a href=&#34;https://www.python.org/downloads/&#34;&gt;https://www.python.org/downloads/&lt;/a&gt;. Make sure to click the box to add Python3 to your Environment.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;All platforms&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;pip install aqtinstall&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make qt_install&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Upload to VESC&lt;/h2&gt; &#xA;&lt;h3&gt;Method 1 - Flash it using an STLink SWD debugger&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Build and flash the &lt;a href=&#34;https://github.com/vedderb/bldc-bootloader&#34;&gt;bootloader&lt;/a&gt; first&lt;/li&gt; &#xA; &lt;li&gt;Then &lt;code&gt;_flash&lt;/code&gt; to the target of your choice. So for instance, for the VESC 100/250:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make 100_250_flash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Method 2 - Upload Firmware via VESC tool through USB&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Clone and build the firmware in &lt;strong&gt;.bin&lt;/strong&gt; format as in the above Build instructions&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In VESC tool&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Connect to the VESC&lt;/li&gt; &#xA; &lt;li&gt;Navigate to the Firmware tab on the left side menu&lt;/li&gt; &#xA; &lt;li&gt;Click on Custom file tab&lt;/li&gt; &#xA; &lt;li&gt;Click on the folder icon to select the built firmware in .bin format (e.g. &lt;code&gt;build/100_250/100_250.bin&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h5&gt;[ Reminder : It is normal to see VESC disconnects during the firmware upload process ]&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;strong&gt;[ Warning : DO NOT DISCONNECT POWER/USB to VESC during the upload process, or you will risk bricking your VESC ]&lt;/strong&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;strong&gt;[ Warning : ONLY DISCONNECT your VESC 10s after the upload loading bar completed and &#34;FW Upload DONE&#34; ]&lt;/strong&gt;&lt;/h5&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;Press the upload firmware button (downward arrow) on the bottom right to start upload the selected firmware.&lt;/li&gt; &#xA; &lt;li&gt;Wait for &lt;strong&gt;10s&lt;/strong&gt; after the loading bar completed (Warning: unplug sooner will risk bricking your VESC)&lt;/li&gt; &#xA; &lt;li&gt;The VESC will disconnect itself after new firmware is uploaded.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;In case you bricked your VESC&lt;/h2&gt; &#xA;&lt;p&gt;you will need to upload a new working firmware to the VESC.&lt;br&gt; However, to upload a firmware to a bricked VESC, you have to use a SWD Debugger.&lt;/p&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Head to the &lt;a href=&#34;https://vesc-project.com/forum&#34;&gt;forums&lt;/a&gt; to get involved and improve this project. Join the &lt;a href=&#34;https://discord.gg/JgvV5NwYts&#34;&gt;Discord&lt;/a&gt; for real-time support and chat&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The software is released under the GNU General Public License version 3.0&lt;/p&gt;</summary>
  </entry>
</feed>