<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-14T01:37:18Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pietroborrello/CustomProcessingUnit</title>
    <updated>2022-08-14T01:37:18Z</updated>
    <id>tag:github.com,2022-08-14:/pietroborrello/CustomProcessingUnit</id>
    <link href="https://github.com/pietroborrello/CustomProcessingUnit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The first dynamic analysis framework for CPU microcode&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Custom Processing Unit&lt;/h1&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pietroborrello/CustomProcessingUnit/master/images/cpu_logo.svg?sanitize=true&#34; width=&#34;150&#34;&gt; &#xA;&lt;p&gt;Custom Processing Unit is the first dynamic analysis framework able to hook, patch and trace CPU microcode at the software level.&lt;/p&gt; &#xA;&lt;p&gt;It works by leveraging &lt;a href=&#34;https://github.com/chip-red-pill/udbgInstr&#34;&gt;undocumented instructions&lt;/a&gt; in Intel CPUs that allow access to the CRBUS. Using our &lt;a href=&#34;https://github.com/pietroborrello/ghidra-atom-microcode&#34;&gt;microcode decompiler&lt;/a&gt; we reverse engineered how the CPU uses the CRBUS and by replicating the interactions we have full control of the CPU.&lt;/p&gt; &#xA;&lt;p&gt;Find the static analysis framework at &lt;a href=&#34;https://github.com/pietroborrello/ghidra-atom-microcode&#34;&gt;https://github.com/pietroborrello/ghidra-atom-microcode&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Check out our slides describing this work &lt;a href=&#34;https://raw.githubusercontent.com/pietroborrello/CustomProcessingUnit/master/slides.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Custom Processing Unit requires a Red-Unlocked CPU: currently, only &lt;a href=&#34;https://en.wikipedia.org/wiki/Goldmont&#34;&gt;Goldmont CPUs&lt;/a&gt; (GLM) have a &lt;a href=&#34;https://github.com/ptresearch/IntelTXE-PoC&#34;&gt;public Red Unlock&lt;/a&gt;. We tested Gigabyte GB-BPCE-3350C with CPU stepping 0x9 and 0xa (cpuid 0x000506C9 and 0x000506CA).&lt;/p&gt; &#xA;&lt;p&gt;Custom Processing Unit is made up of a UEFI application and a few libraries. The UEFI application interacts with the GLM CPU, while the libraries provide different helpers to compile microcode into the UEFI application and analyze its output.&lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Follow the steps to red unlock your Goldmont CPU from &lt;a href=&#34;https://github.com/ptresearch/IntelTXE-PoC&#34;&gt;https://github.com/ptresearch/IntelTXE-PoC&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Create a bootable USB key with an EFI shell&lt;/li&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://wiki.osdev.org/GNU-EFI&#34;&gt;gnu-efi&lt;/a&gt; on your main host&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;GNU_EFI_DIR=&amp;lt;path_to_gnu_efi&amp;gt; make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will build the source microcode files and the UEFI application into &lt;code&gt;cpu.efi&lt;/code&gt;. Copy &lt;code&gt;cpu.efi&lt;/code&gt; into the &lt;code&gt;\EFI\&lt;/code&gt; folder of the USB key, plug it in the GLM and boot into the EFI shell.&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;map -r&lt;/code&gt; in the efi shell to identify the USB key device and &lt;code&gt;&amp;lt;deviceid&amp;gt;:&lt;/code&gt; to mount it.&lt;/p&gt; &#xA;&lt;h2&gt;Run Custom Processing Unit&lt;/h2&gt; &#xA;&lt;p&gt;Run &lt;code&gt;./cpu.efi&lt;/code&gt; to print the help:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage:&#xA;  patch:        &amp;lt;tool&amp;gt; p&#xA;  patch &amp;amp; exec: &amp;lt;tool&amp;gt; x&#xA;  perf:         &amp;lt;tool&amp;gt; f&#xA;  zero out m&amp;amp;p: &amp;lt;tool&amp;gt; z&#xA;  hook:         &amp;lt;tool&amp;gt; h  [m&amp;amp;p idx] [uop addr] [patch addr]&#xA;  template:     &amp;lt;tool&amp;gt; m&#xA;  dump imms:    &amp;lt;tool&amp;gt; di&#xA;  dump rom:     &amp;lt;tool&amp;gt; dr&#xA;  dump msrs:    &amp;lt;tool&amp;gt; dm&#xA;  dump SMM:     &amp;lt;tool&amp;gt; ds [address] [size]&#xA;  cpuid:        &amp;lt;tool&amp;gt; c  [rax] [rcx]&#xA;  rdmsr:        &amp;lt;tool&amp;gt; rm [msr]&#xA;  wrmsr:        &amp;lt;tool&amp;gt; wm [msr]&#xA;  read:         &amp;lt;tool&amp;gt; r  [cmd] [addr]&#xA;  write:        &amp;lt;tool&amp;gt; w  [cmd] [addr] [value]&#xA;  invoke:       &amp;lt;tool&amp;gt; i  [addr]&#xA;  update ucode: &amp;lt;tool&amp;gt; u  [size]&#xA;  ldat read:    &amp;lt;tool&amp;gt; lr [port] [array] [bank] [idx] [addr] [optional size]&#xA;  ldat write:   &amp;lt;tool&amp;gt; lw [port] [array] [bank] [idx] [addr] [value]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Simple instructions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cpu&lt;/code&gt; provides helpers to run simple instructions from the command line:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;cpuid&lt;/li&gt; &#xA; &lt;li&gt;rdmsr&lt;/li&gt; &#xA; &lt;li&gt;wrmsr&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Complex actions&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cpu&lt;/code&gt; provides interfaces to complex CPU routines that are interesting to execute to study cpu behavior:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;u&lt;/code&gt;: update the CPU ucode with the provided (signed) patch&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;f&lt;/code&gt;: collect performance counters while running microcode&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Raw udbgrd and udbwr&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cpu&lt;/code&gt; provides raw interfaces to the undocumented instructions &lt;code&gt;udbrd&lt;/code&gt; and &lt;code&gt;udbgwr&lt;/code&gt;. The most interesting commands they provide are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;0x0: access CRBUS&lt;/li&gt; &#xA; &lt;li&gt;0x10: access UROM&lt;/li&gt; &#xA; &lt;li&gt;0x40: access stgbuf&lt;/li&gt; &#xA; &lt;li&gt;0xd8: invoke ucode routine from address&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;LDAT access&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cpu&lt;/code&gt; exposes LDAT access routines to read and write. Specify the parameters &lt;code&gt;[port] [array] [bank] [idx] [addr]&lt;/code&gt; to read or write there. Interesting ports are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;0x6a0: microcode sequencer, which has access to the internal the ucode ROM and RAM&lt;/li&gt; &#xA; &lt;li&gt;0x120: load/store buffers&lt;/li&gt; &#xA; &lt;li&gt;0x3c0: instruction cache&lt;/li&gt; &#xA; &lt;li&gt;0x630: ITLB&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please notice that accessing some of these internal components may cause the CPU to freeze.&lt;/p&gt; &#xA;&lt;h3&gt;Patch microcode&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;cpu&lt;/code&gt; provides functionalities to install patches in the microcode.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Write your microcode patch in &lt;code&gt;bios/ucode_patches/ucode_patch.u&lt;/code&gt; (look at the other patches for examples)&lt;/li&gt; &#xA; &lt;li&gt;Build the UEFI application&lt;/li&gt; &#xA; &lt;li&gt;Execute &lt;code&gt;cpu.efi p&lt;/code&gt; to install the patch at the address provided in &lt;code&gt;.org&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Notice that in the microcode, only the addresses between 0x7c00 and 0x7e00 are writable and meaningful to patch.&lt;/p&gt; &#xA;&lt;p&gt;Running &lt;code&gt;cpu.efi x&lt;/code&gt;, it will also execute the microcode patched and print the &lt;code&gt;rax, rbx, rcx, rdx&lt;/code&gt; registers as result.&lt;/p&gt; &#xA;&lt;h3&gt;Match &amp;amp; Patch&lt;/h3&gt; &#xA;&lt;p&gt;To automatically execute microcode at certain CPU events or microcode points, &lt;code&gt;cpu&lt;/code&gt; leverages the Match and Patch. It defines a microcode address to hook and the microcode address to jump to when the hook is triggered.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;z&lt;/code&gt;: resets all the match &amp;amp; patch.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;h&lt;/code&gt;: installs an hook, given an index (0-0x20), an address to hook (0-0x7c00) and a target address to execute (0x7c00-0x7e00).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Tracing microcode&lt;/h3&gt; &#xA;&lt;p&gt;By installing multiple hooks and continuously executing an instruction, &lt;code&gt;cpu&lt;/code&gt; is able to trace the microoperations performed by such an instruction, and dump them. To trace:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Write the instruction to be traced after the &lt;code&gt;// [TRACED INSTRUCTION HERE]&lt;/code&gt; in &lt;code&gt;get_trace_clock_at()&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Build the UEFI application.&lt;/li&gt; &#xA; &lt;li&gt;Trace with: &lt;code&gt;cpu.efi m&lt;/code&gt;. It will create a &lt;code&gt;trace.txt&lt;/code&gt; file that contains all the addresses that have been hit.&lt;/li&gt; &#xA; &lt;li&gt;Execute &lt;code&gt;uasm-lib/uasm.py -t trace.txt &amp;gt; parsed_trace.txt&lt;/code&gt;. It will generate a full trace of the microcode executed during the instruction.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Notice that &lt;code&gt;uasm.py&lt;/code&gt; will leverage the &lt;code&gt;ms_arrayX.txt&lt;/code&gt; files in its folder to generate a disassembly of the microinstructions executed. These are for GLM with stepping 0x9 (cpuid 0x000506C9). Please generate the proper arrays in case you have a different stepping. You can use the LDAT dump functionalities for this purpose.&lt;/p&gt; &#xA;&lt;h3&gt;Secret memory dumpers&lt;/h3&gt; &#xA;&lt;p&gt;The CPU has different inaccessible buffers from the architecture, for which we provide routines to dump:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;smm&lt;/code&gt;: SMROM (or any other address while disabling SMM protection)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rom&lt;/code&gt;: internal ROM&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;imms&lt;/code&gt;: CPU hardcoded immediates&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;msrs&lt;/code&gt;: internal MSRs configurations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Writing microcode patches&lt;/h3&gt; &#xA;&lt;p&gt;We provide an assembler that generates header files to be compiled into the &lt;code&gt;cpu.efi&lt;/code&gt; UEFI application. Look into the provided patches in &lt;code&gt;bios/ucode_patches&lt;/code&gt; for the syntax. It supports simple operations and labels. Assemble a microcode patch with &lt;code&gt;uasm.py -i ucode_patch.u -o ucode_patch.h&lt;/code&gt;. &lt;code&gt;cpu.efi&lt;/code&gt; will be compiled and automatically include the microcode patch that you want to apply.&lt;/p&gt; &#xA;&lt;h4&gt;Example&lt;/h4&gt; &#xA;&lt;p&gt;file: &lt;code&gt;code_patch.u&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.org 0x7c00&#xA;&#xA;rax:= ZEROEXT_DSZ32(0x00001337)&#xA;rbx:= ZEROEXT_DSZ32(0x00001337)&#xA;rcx:= ZEROEXT_DSZ32(0x00001337)&#xA;rdx:= ZEROEXT_DSZ32(0x00001337)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;recompile, then run in the GLM:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cpu.efi z # zero out match &amp;amp; patch&#xA;cpu.efi p # apply the patch&#xA;cpu.efi h 0 0x0428 0x7c00 # rdrand entry point&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;now every time &lt;code&gt;rdrand&lt;/code&gt; is executed, it will return &lt;code&gt;0x1337&lt;/code&gt; in the registers.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>LuaJIT/LuaJIT</title>
    <updated>2022-08-14T01:37:18Z</updated>
    <id>tag:github.com,2022-08-14:/LuaJIT/LuaJIT</id>
    <link href="https://github.com/LuaJIT/LuaJIT" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mirror of the LuaJIT git repository&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;README for LuaJIT 2.1.0-beta3&lt;/h2&gt; &#xA;&lt;p&gt;LuaJIT is a Just-In-Time (JIT) compiler for the Lua programming language.&lt;/p&gt; &#xA;&lt;p&gt;Project Homepage: &lt;a href=&#34;https://luajit.org/&#34;&gt;https://luajit.org/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;LuaJIT is Copyright (C) 2005-2022 Mike Pall. LuaJIT is free software, released under the MIT license. See full Copyright Notice in the COPYRIGHT file or in luajit.h.&lt;/p&gt; &#xA;&lt;p&gt;Documentation for LuaJIT is available in HTML format. Please point your favorite browser to:&lt;/p&gt; &#xA;&lt;p&gt;doc/luajit.html&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>wolfSSL/wolfssl</title>
    <updated>2022-08-14T01:37:18Z</updated>
    <id>tag:github.com,2022-08-14:/wolfSSL/wolfssl</id>
    <link href="https://github.com/wolfSSL/wolfssl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The wolfSSL library is a small, fast, portable implementation of TLS/SSL for embedded devices to the cloud. wolfSSL supports up to TLS 1.3!&lt;/p&gt;&lt;hr&gt;&lt;a href=&#34;https://repology.org/project/wolfssl/versions&#34;&gt; &lt;img src=&#34;https://repology.org/badge/vertical-allrepos/wolfssl.svg?sanitize=true&#34; alt=&#34;Packaging status&#34; align=&#34;right&#34;&gt; &lt;/a&gt; &#xA;&lt;h1&gt;wolfSSL Embedded SSL/TLS Library&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://www.wolfssl.com/products/wolfssl/&#34;&gt;wolfSSL embedded SSL library&lt;/a&gt; (formerly CyaSSL) is a lightweight SSL/TLS library written in ANSI C and targeted for embedded, RTOS, and resource-constrained environments - primarily because of its small size, speed, and feature set. It is commonly used in standard operating environments as well because of its royalty-free pricing and excellent cross platform support. wolfSSL supports industry standards up to the current &lt;a href=&#34;https://www.wolfssl.com/tls13&#34;&gt;TLS 1.3&lt;/a&gt; and DTLS 1.2, is up to 20 times smaller than OpenSSL, and offers progressive ciphers such as ChaCha20, Curve25519, Blake2b and Post-Quantum TLS 1.3 groups. User benchmarking and feedback reports dramatically better performance when using wolfSSL over OpenSSL.&lt;/p&gt; &#xA;&lt;p&gt;wolfSSL is powered by the wolfCrypt cryptography library. Two versions of wolfCrypt have been FIPS 140-2 validated (Certificate #2425 and certificate #3389). FIPS 140-3 validation is in progress. For additional information, visit the &lt;a href=&#34;https://www.wolfssl.com/license/fips/&#34;&gt;wolfCrypt FIPS FAQ&lt;/a&gt; or contact &lt;a href=&#34;mailto:fips@wolfssl.com&#34;&gt;fips@wolfssl.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Why Choose wolfSSL?&lt;/h2&gt; &#xA;&lt;p&gt;There are many reasons to choose wolfSSL as your embedded, desktop, mobile, or enterprise SSL/TLS solution. Some of the top reasons include size (typical footprint sizes range from 20-100 kB), support for the newest standards (SSL 3.0, TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3, DTLS 1.0, and DTLS 1.2), current and progressive cipher support (including stream ciphers), multi-platform, royalty free, and an OpenSSL compatibility API to ease porting into existing applications which have previously used the OpenSSL package. For a complete feature list, see &lt;a href=&#34;https://www.wolfssl.com/docs/wolfssl-manual/ch4/&#34;&gt;Chapter 4&lt;/a&gt; of the wolfSSL manual.&lt;/p&gt; &#xA;&lt;h2&gt;Notes, Please Read&lt;/h2&gt; &#xA;&lt;h3&gt;Note 1&lt;/h3&gt; &#xA;&lt;p&gt;wolfSSL as of 3.6.6 no longer enables SSLv3 by default. wolfSSL also no longer supports static key cipher suites with PSK, RSA, or ECDH. This means if you plan to use TLS cipher suites you must enable DH (DH is on by default), or enable ECC (ECC is on by default), or you must enable static key cipher suites with one or more of the following defines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;WOLFSSL_STATIC_DH&#xA;WOLFSSL_STATIC_RSA&#xA;WOLFSSL_STATIC_PSK&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Though static key cipher suites are deprecated and will be removed from future versions of TLS. They also lower your security by removing PFS.&lt;/p&gt; &#xA;&lt;p&gt;When compiling &lt;code&gt;ssl.c&lt;/code&gt;, wolfSSL will now issue a compiler error if no cipher suites are available. You can remove this error by defining &lt;code&gt;WOLFSSL_ALLOW_NO_SUITES&lt;/code&gt; in the event that you desire that, i.e., you&#39;re not using TLS cipher suites.&lt;/p&gt; &#xA;&lt;h3&gt;Note 2&lt;/h3&gt; &#xA;&lt;p&gt;wolfSSL takes a different approach to certificate verification than OpenSSL does. The default policy for the client is to verify the server, this means that if you don&#39;t load CAs to verify the server you&#39;ll get a connect error, no signer error to confirm failure (-188).&lt;/p&gt; &#xA;&lt;p&gt;If you want to mimic OpenSSL behavior of having &lt;code&gt;SSL_connect&lt;/code&gt; succeed even if verifying the server fails and reducing security you can do this by calling:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;wolfSSL_CTX_set_verify(ctx, WOLFSSL_VERIFY_NONE, NULL);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;before calling &lt;code&gt;wolfSSL_new();&lt;/code&gt;. Though it&#39;s not recommended.&lt;/p&gt; &#xA;&lt;h3&gt;Note 3&lt;/h3&gt; &#xA;&lt;p&gt;The enum values SHA, SHA256, SHA384, SHA512 are no longer available when wolfSSL is built with &lt;code&gt;--enable-opensslextra&lt;/code&gt; (&lt;code&gt;OPENSSL_EXTRA&lt;/code&gt;) or with the macro &lt;code&gt;NO_OLD_SHA_NAMES&lt;/code&gt;. These names get mapped to the OpenSSL API for a single call hash function. Instead the name &lt;code&gt;WC_SHA&lt;/code&gt;, &lt;code&gt;WC_SHA256&lt;/code&gt;, &lt;code&gt;WC_SHA384&lt;/code&gt; and &lt;code&gt;WC_SHA512&lt;/code&gt; should be used for the enum name.&lt;/p&gt; &#xA;&lt;h1&gt;wolfSSL Release 5.4.0 (July 11, 2022)&lt;/h1&gt; &#xA;&lt;p&gt;Note: ** Future releases of wolfSSL will turn off TLS 1.1 by default ** Release 5.4.0 made SP math the default math implementation. To make an equivalent build as –disable-fastmath from previous versions of wolfSSL, now requires using the configure option –enable-heapmath instead.&lt;/p&gt; &#xA;&lt;p&gt;Release 5.4.0 of wolfSSL embedded TLS has bug fixes and new features including:&lt;/p&gt; &#xA;&lt;h2&gt;Vulnerabilities&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[High] Potential for DTLS DoS attack. In wolfSSL versions before 5.4.0 the return-routability check is wrongly skipped in a specific edge case. The check on the return-routability is there for stopping attacks that either consume excessive resources on the server, or try to use the server as an amplifier sending an excessive amount of messages to a victim IP. If using DTLS 1.0/1.2 on the server side users should update to avoid the potential DoS attack. CVE-2022-34293&lt;/li&gt; &#xA; &lt;li&gt;[Medium] Ciphertext side channel attack on ECC and DH operations. Users on systems where rogue agents can monitor memory use should update the version of wolfSSL and change private ECC keys. Thanks to Sen Deng from Southern University of Science and Technology (SUSTech) for the report.&lt;/li&gt; &#xA; &lt;li&gt;[Medium] Public disclosure of a side channel vulnerability that has been fixed since wolfSSL version 5.1.0. When running on AMD there is the potential to leak private key information with ECDSA operations due to a ciphertext side channel attack. Users on AMD doing ECDSA operations with wolfSSL versions less than 5.1.0 should update their wolfSSL version used. Thanks to professor Yinqian Zhang from Southern University of Science and Technology (SUSTech), his Ph.D. student Mengyuan Li from The Ohio State University, and his M.S students Sen Deng and Yining Tang from SUStech along with other collaborators; Luca Wilke, Jan Wichelmann and Professor Thomas Eisenbarth from the University of Lubeck, Professor Shuai Wang from Hong Kong University of Science and Technology, Professor Radu Teodorescu from The Ohio State University, Huibo Wang, Kang Li and Yueqiang Cheng from Baidu Security and Shoumeng Yang from Ant Financial Services Group. CVE-2020-12966 &lt;a href=&#34;https://www.amd.com/en/corporate/product-security/bulletin/amd-sb-1013&#34;&gt;https://www.amd.com/en/corporate/product-security/bulletin/amd-sb-1013&lt;/a&gt; CVE-2021-46744 &lt;a href=&#34;https://www.amd.com/en/corporate/product-security/bulletin/amd-sb-1033&#34;&gt;https://www.amd.com/en/corporate/product-security/bulletin/amd-sb-1033&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;New Feature Additions&lt;/h2&gt; &#xA;&lt;h3&gt;DTLS 1.3&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for using the new DTLSv1.3 protocol was added&lt;/li&gt; &#xA; &lt;li&gt;Enhancements to bundled examples for an event driven server with DTLS 1.3 was added&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Ports&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Update for the version of VxWorks supported, adding in support for version 6.x&lt;/li&gt; &#xA; &lt;li&gt;Support for new DPP and EAP-TEAP/EAP-FAST in wpa_supplicant&lt;/li&gt; &#xA; &lt;li&gt;Update for TSIP version support, adding support for version 1.15 for RX65N and RX72N&lt;/li&gt; &#xA; &lt;li&gt;Improved TSIP build to handle having the options WOLFSSL_AEAD_ONLY defined or NO_AES_CBC defined&lt;/li&gt; &#xA; &lt;li&gt;Added support for offloading TLS1.3 operations to Renesas RX boards with TSIP&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Misc.&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Constant time improvements due to development of new constant time tests&lt;/li&gt; &#xA; &lt;li&gt;Initial translation of API headers to Japanese and expansion of Japanese help message support in example applications&lt;/li&gt; &#xA; &lt;li&gt;Add support for some FPKI (Federal PKI) certificate cases, UUID, FASC-N, PIV extension for use with smart cards&lt;/li&gt; &#xA; &lt;li&gt;Add support for parsing additional CSR attributes such as unstructured name and content type&lt;/li&gt; &#xA; &lt;li&gt;Add support for Linux getrandom() when defining the macro WOLFSSL_GETRANDOM&lt;/li&gt; &#xA; &lt;li&gt;Add TLS 1.2 ciphersuite ECDHE_PSK_WITH_AES_128_GCM_SHA256 from RFC 8442&lt;/li&gt; &#xA; &lt;li&gt;Expand CAAM support with QNX to include i.MX8 boards and add AES-CTR support&lt;/li&gt; &#xA; &lt;li&gt;Enhanced glitching protection by hardening the TLS encrypt operations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Math and Performance&lt;/h2&gt; &#xA;&lt;h3&gt;SP Math Additions&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for ARMv3, ARMv6 and ARMv7a &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Changes and improvements to get SP building for armv7-a&lt;/li&gt; &#xA;   &lt;li&gt;Updated assembly for moving large immediate values on ARMv6&lt;/li&gt; &#xA;   &lt;li&gt;Support for architectures with no ldrd/strd and clz&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Reworked generation using common asm ruby code for 32bit ARM&lt;/li&gt; &#xA; &lt;li&gt;Enable wolfSSL SP math all by default (sp_int.c)&lt;/li&gt; &#xA; &lt;li&gt;Update SP math all to not use sp_int_word when SQR_MUL_ASM is available&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;SP Math Fixes&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixes for constant time with div function&lt;/li&gt; &#xA; &lt;li&gt;Fix casting warnings for Windows builds and assembly changes to support XMM6-15 being non-volatile&lt;/li&gt; &#xA; &lt;li&gt;Fix for div_word when not using div function&lt;/li&gt; &#xA; &lt;li&gt;Fixes for user settings with SP ASM and ED/Curve25519 small&lt;/li&gt; &#xA; &lt;li&gt;Additional Wycheproof tests ran and fixes&lt;/li&gt; &#xA; &lt;li&gt;Fix for SP math ECC non-blocking to always check &lt;code&gt;hashLen&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fix for SP math handling edge case with submod&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Improvements and Optimizations&lt;/h2&gt; &#xA;&lt;h3&gt;Compatibility Layer&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Provide access to &#34;Finished&#34; messages outside of compatibility layer builds&lt;/li&gt; &#xA; &lt;li&gt;Remove unneeded FIPS guard on wolfSSL_EVP_PKEY_derive&lt;/li&gt; &#xA; &lt;li&gt;Fix control command issues with AES-GCM, control command EVP_CTRL_GCM_IV_GEN&lt;/li&gt; &#xA; &lt;li&gt;Add support for importing private only EC key to a WOLFSSL_EVP_PKEY struct&lt;/li&gt; &#xA; &lt;li&gt;Add support for more extensions to wolfSSL_X509_print_ex&lt;/li&gt; &#xA; &lt;li&gt;Update for internal to DER (i2d) AIPs to move the buffer pointer when passed in and the operation is successful&lt;/li&gt; &#xA; &lt;li&gt;Return subject and issuer X509_NAME object even when not set&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Ports&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Renesas RA6M4 example update and fixes&lt;/li&gt; &#xA; &lt;li&gt;Support multi-threaded use cases with Renesas SCE protected mode and TSIP&lt;/li&gt; &#xA; &lt;li&gt;Add a global variable for heap-hint for use with TSIP&lt;/li&gt; &#xA; &lt;li&gt;Changes to support v5.3.0 cube pack for STM32&lt;/li&gt; &#xA; &lt;li&gt;Use the correct mutex type for embOS&lt;/li&gt; &#xA; &lt;li&gt;ESP-IDF build cleanup and enhancements, adding in note regarding ESP-IDF Version&lt;/li&gt; &#xA; &lt;li&gt;Support for SEGGER embOS and emNET&lt;/li&gt; &#xA; &lt;li&gt;Fix to handle WOLFSSL_DTLS macro in Micrium build&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Build Options&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Support for verify only and no-PSS builds updated&lt;/li&gt; &#xA; &lt;li&gt;Add the enable options wolfssh (mapped to the existing –enable-ssh)&lt;/li&gt; &#xA; &lt;li&gt;Remove WOLFSSL_ALT_NAMES restriction on notBefore/notAfter use in Cert struct&lt;/li&gt; &#xA; &lt;li&gt;Move several more definitions outside the BUILDING_WOLFSSL gate with linux kernel module build&lt;/li&gt; &#xA; &lt;li&gt;Modify --enable-openssh to not enable non-FIPS algos for FIPS builds&lt;/li&gt; &#xA; &lt;li&gt;Remove the Python wrappers from wolfSSL source (use pip install instead of using wolfSSL with Python and our separate Python repository)&lt;/li&gt; &#xA; &lt;li&gt;Add --enable-openldap option to configure.ac for building the OpenLDAP port&lt;/li&gt; &#xA; &lt;li&gt;Resolve DTLS build to handle not having –enable-hrrcookie when not needed&lt;/li&gt; &#xA; &lt;li&gt;Add an --enable-strongswan option to configure.ac for building the Strongswan port&lt;/li&gt; &#xA; &lt;li&gt;Improve defaults for 64-bit BSDs in configure&lt;/li&gt; &#xA; &lt;li&gt;Crypto only build can now be used openssl extra&lt;/li&gt; &#xA; &lt;li&gt;Update ASN template build to properly handle WOLFSSL_CERT_EXT and HAVE_OID_ENCODING&lt;/li&gt; &#xA; &lt;li&gt;Allow using 3DES and MD5 with FIPS 140-3, as they fall outside of the FIPS boundary&lt;/li&gt; &#xA; &lt;li&gt;Add the build option --enable-dh=const which replaces setting the macro WOLFSSL_DH_CONST and now conditionally link to -lm as needed&lt;/li&gt; &#xA; &lt;li&gt;Add the macro WOLFSSL_HOSTNAME_VERIFY_ALT_NAME_ONLY which is used to verify hostname/ip address using alternate name (SAN) only and does not use the common name&lt;/li&gt; &#xA; &lt;li&gt;WOLFSSL_DTLS_NO_HVR_ON_RESUME macro added (off by default to favor more security). If defined, a DTLS server will not do a cookie exchange on successful client resumption: the resumption will be faster (one RTT less) and will consume less bandwidth (one ClientHello and one HelloVerifyRequest less). On the other hand, if a valid SessionID is collected, forged clientHello messages will consume resources on the server.&lt;/li&gt; &#xA; &lt;li&gt;Misc.&lt;/li&gt; &#xA; &lt;li&gt;Refactoring of some internal TLS functions to reduce the memory usage&lt;/li&gt; &#xA; &lt;li&gt;Make old less secure TimingPadVerify implementation available&lt;/li&gt; &#xA; &lt;li&gt;Add support for aligned data with clang LLVM&lt;/li&gt; &#xA; &lt;li&gt;Remove subject/issuer email from the list of alt. Email names in the DecodedCerts struct&lt;/li&gt; &#xA; &lt;li&gt;Zeroizing of pre-master secret buffer in TLS 1.3&lt;/li&gt; &#xA; &lt;li&gt;Update to allow TLS 1.3 application server to send session ticket&lt;/li&gt; &#xA; &lt;li&gt;Improve the sniffer asynchronous test case to support multiple concurrent streams&lt;/li&gt; &#xA; &lt;li&gt;Clean up wolfSSL_clear() and add more logging&lt;/li&gt; &#xA; &lt;li&gt;Update to not error out on bad CRL next date if using NO_VERIFY when parsing&lt;/li&gt; &#xA; &lt;li&gt;Add an example C# PSK client&lt;/li&gt; &#xA; &lt;li&gt;Add ESP-IDF WOLFSSL_ESP8266 setting for ESP8266 devices&lt;/li&gt; &#xA; &lt;li&gt;Support longer sigalg list for post quantum use cases and inter-op with OQS&#39;s OpenSSL fork&lt;/li&gt; &#xA; &lt;li&gt;Improve AES-GCM word implementation of GMULT to be constant time&lt;/li&gt; &#xA; &lt;li&gt;Additional sanity check with Ed25519/Ed448, now defaults to assume public key is not trusted&lt;/li&gt; &#xA; &lt;li&gt;Support PSK ciphersuites in benchmark apps&lt;/li&gt; &#xA; &lt;li&gt;FIPS in core hash using SHA2-256 and SHA2-384&lt;/li&gt; &#xA; &lt;li&gt;Add ability to store issuer name components when parsing a certificate&lt;/li&gt; &#xA; &lt;li&gt;Make the critical extension flags in DecodedCert always available&lt;/li&gt; &#xA; &lt;li&gt;Updates to the default values for basic constraint with X509’s&lt;/li&gt; &#xA; &lt;li&gt;Support using RSA OAEP with no malloc and add additional sanity checks&lt;/li&gt; &#xA; &lt;li&gt;Leverage async code paths to support WANT_WRITE while sending packet fragments&lt;/li&gt; &#xA; &lt;li&gt;New azsphere example for continuous integration testing&lt;/li&gt; &#xA; &lt;li&gt;Update RSA key generation function to handle pairwise consistency tests with static memory pools used&lt;/li&gt; &#xA; &lt;li&gt;Resolve build time warning by passing in and checking output length with internal SetCurve function&lt;/li&gt; &#xA; &lt;li&gt;Support DTLS bidirectional shutdown in the examples&lt;/li&gt; &#xA; &lt;li&gt;Improve DTLS version negotiation and downgrade capability&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;General Fixes&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fixes for STM32 Hash/PKA, add some missing mutex frees, and add an additional benchmark&lt;/li&gt; &#xA; &lt;li&gt;Fix missing return checks in KSDK ED25519 code&lt;/li&gt; &#xA; &lt;li&gt;Fix compilation warnings from IAR&lt;/li&gt; &#xA; &lt;li&gt;Fixes for STM32U5/H7 hash/crypto support&lt;/li&gt; &#xA; &lt;li&gt;Fix for using track memory feature with FreeRTOS&lt;/li&gt; &#xA; &lt;li&gt;Fixup XSTR processing for MICRIUM&lt;/li&gt; &#xA; &lt;li&gt;Update Zephyr fs.h path&lt;/li&gt; &#xA; &lt;li&gt;DTLS fixes with WANT_WRITE simulations&lt;/li&gt; &#xA; &lt;li&gt;Fixes for BER use with PKCS7 to have additional sanity checks and guards on edge cases&lt;/li&gt; &#xA; &lt;li&gt;Fix to handle exceptional edge case with TFM mp_exptmod_ex&lt;/li&gt; &#xA; &lt;li&gt;Fix for stack and heap measurements of a 32-bit build&lt;/li&gt; &#xA; &lt;li&gt;Fix to allow enabling AES key wrap (direct) with KCAPI&lt;/li&gt; &#xA; &lt;li&gt;Fix --enable-openssh FIPS detection syntax in configure.ac&lt;/li&gt; &#xA; &lt;li&gt;Fix to move wolfSSL_ERR_clear_error outside gate for OPENSSL_EXTRA&lt;/li&gt; &#xA; &lt;li&gt;Remove MCAPI project&#39;s dependency on zlib version&lt;/li&gt; &#xA; &lt;li&gt;Only use __builtin_offset on supported GCC versions (4+)&lt;/li&gt; &#xA; &lt;li&gt;Fix for c89 builds with using WOLF_C89&lt;/li&gt; &#xA; &lt;li&gt;Fix 64bit postfix for constants building with powerpc&lt;/li&gt; &#xA; &lt;li&gt;Fixed async Sniffer with TLS v1.3, async removal of &lt;code&gt;WC_HW_WAIT_E&lt;/code&gt; and sanitize leak&lt;/li&gt; &#xA; &lt;li&gt;Fix for QAT ECC to gate use of HW based on marker&lt;/li&gt; &#xA; &lt;li&gt;Fix the supported version extension to always check minDowngrade&lt;/li&gt; &#xA; &lt;li&gt;Fix for TLS v1.1 length sanity check for large messages&lt;/li&gt; &#xA; &lt;li&gt;Fixes for loading a long DER/ASN.1 certificate chain&lt;/li&gt; &#xA; &lt;li&gt;Fix to expose the RSA public DER export functions with certgen&lt;/li&gt; &#xA; &lt;li&gt;Fixes for building with small version of SHA3&lt;/li&gt; &#xA; &lt;li&gt;Fix configure with WOLFSSL_WPAS_SMALL&lt;/li&gt; &#xA; &lt;li&gt;Fix to free PKCS7 recipient list in error cases&lt;/li&gt; &#xA; &lt;li&gt;Sanity check to confirm ssl-&amp;gt;hsHashes is not NULL before attempting to dereference it&lt;/li&gt; &#xA; &lt;li&gt;Clear the leftover byte count in Aes struct when setting IV&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For additional vulnerability information visit the vulnerability page at: &lt;a href=&#34;https://www.wolfssl.com/docs/security-vulnerabilities/&#34;&gt;https://www.wolfssl.com/docs/security-vulnerabilities/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;See INSTALL file for build instructions. More info can be found on-line at: &lt;a href=&#34;https://wolfssl.com/wolfSSL/Docs.html&#34;&gt;https://wolfssl.com/wolfSSL/Docs.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Resources&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.wolfssl.com/&#34;&gt;wolfSSL Website&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wolfSSL/wolfssl/wiki&#34;&gt;wolfSSL Wiki&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://wolfssl.com/license/fips&#34;&gt;FIPS 140-2/140-3 FAQ&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://wolfssl.com/wolfSSL/Docs.html&#34;&gt;wolfSSL Documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://wolfssl.com/wolfSSL/Docs-wolfssl-manual-toc.html&#34;&gt;wolfSSL Manual&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://wolfssl.com/wolfSSL/Docs-wolfssl-manual-17-wolfssl-api-reference.html&#34;&gt;wolfSSL API Reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://wolfssl.com/wolfSSL/Docs-wolfssl-manual-18-wolfcrypt-api-reference.html&#34;&gt;wolfCrypt API Reference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.wolfssl.com/docs/tls13/&#34;&gt;TLS 1.3&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.wolfssl.com/docs/security-vulnerabilities/&#34;&gt;wolfSSL Vulnerabilities&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wolfssl/wolfssl-examples&#34;&gt;Additional wolfSSL Examples&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>