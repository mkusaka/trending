<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-11-01T01:29:20Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>haad/proxychains</title>
    <updated>2024-11-01T01:29:20Z</updated>
    <id>tag:github.com,2024-11-01:/haad/proxychains</id>
    <link href="https://github.com/haad/proxychains" rel="alternate"></link>
    <summary type="html">&lt;p&gt;proxychains - a tool that forces any TCP connection made by any given application to follow through proxy like TOR or any other SOCKS4, SOCKS5 or HTTP(S) proxy. Supported auth-types: &#34;user/pass&#34; for SOCKS4/5, &#34;basic&#34; for HTTP.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ProxyChains ver. 4.3.0 README&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/haad/proxychains/actions/workflows/buildci.yml/badge.svg?sanitize=true&#34; alt=&#34;build-badge&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;ProxyChains is a UNIX program, that hooks network-related libc functions in dynamically linked programs via a preloaded DLL and redirects the connections through SOCKS4a/5 or HTTP proxies.&lt;/p&gt; &#xA;&lt;p&gt;WARNING: this program works only on dynamically linked programs. also both proxychains and the program to call must use the same dynamic linker (i.e. same libc)&lt;/p&gt; &#xA;&lt;h2&gt;Known limitations of the current version&lt;/h2&gt; &#xA;&lt;p&gt;when a process forks, does a DNS lookup in the child, and then uses the ip in the parent, the corresponding ip mapping will not be found, this is because the fork can&#39;t write back into the parents mapping table. IRSSI shows this behavior, so you have to pass the resolved ip address to it. (you can use the proxyresolv script (requires &#34;dig&#34;) to do so)&lt;/p&gt; &#xA;&lt;p&gt;this means that you can&#39;t currently use tor onion urls for irssi. to solve this issue, an external data store (file, pipe, ...) has to manage the dns &amp;lt;-&amp;gt; ip mapping. of course there has to be proper locking. shm_open, mkstemp, are possible candidates for a file based approach, the other option is to spawn some kind of server process that manages the map lookups. since connect() etc are hooked, this must not be a TCP server.&lt;/p&gt; &#xA;&lt;p&gt;I am reluctant on doing this change, because the described behavior seems pretty idiotic (doing a fork only for a DNS lookup), and irssi is currently the only known affected program.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Using release version&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;Proxychains-4.3.0&lt;/em&gt; are available with pkgsrc to everyone using it on &lt;em&gt;Linux&lt;/em&gt;, &lt;em&gt;NetBSD&lt;/em&gt;, &lt;em&gt;FreeBSD&lt;/em&gt;, &lt;em&gt;OpenBSD&lt;/em&gt;, &lt;em&gt;DragonFlyBSD&lt;/em&gt; or &lt;em&gt;Mac OS X&lt;/em&gt;. You just need to install pkgsrc-wip repository and run make install in a wip/proxychains directory.&lt;/p&gt; &#xA;&lt;p&gt;You can find out more about pkgsrc on link:&lt;a href=&#34;http://www.pkgsrc.org%5Bpkgsrc%5D&#34;&gt;http://www.pkgsrc.org[pkgsrc]&lt;/a&gt; and about pkgsrc-wip on link:&lt;a href=&#34;https://pkgsrc.org/wip%5BPkgsrc-wip&#34;&gt;https://pkgsrc.org/wip[Pkgsrc-wip&lt;/a&gt; homepage]&lt;/p&gt; &#xA;&lt;h3&gt;Installing on Mac OS X with homebrew&lt;/h3&gt; &#xA;&lt;p&gt;You can install current proxychains on Mac OS X with an homebrew. You have to download unofficial link:&lt;a href=&#34;https://gist.github.com/3792521%5Bhomebrew&#34;&gt;https://gist.github.com/3792521[homebrew&lt;/a&gt; formula] from to your BREW_HOME by default /usr/local/Library/Formula/ and run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ brew install proxychains&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Running Current Source code version&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;# needs a working C compiler, preferably gcc&#xA;./configure&#xA;make&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Changelog&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Version (4.x)&lt;/em&gt; removes the dnsresolver script which required a dynamically linked &#34;dig&#34; binary to be present with remote DNS lookup. this speeds up any operation involving DNS, as the old script had to use TCP. additionally it allows to use .onion urls when used with TOR. also it removed the broken autoconf build system with a simple Makefile. there&#39;s a ./configure script though for convenience. it also adds support for a config file passed via command line switches/ environment variables.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Version (3.x)&lt;/em&gt; introduces support for DNS resolving through proxy it supports SOCKS4, SOCKS5 and HTTP CONNECT proxy servers.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Auth-types ** socks - &#34;user/pass&#34;, ** http - &#34;basic&#34;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;When to use it&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When the only way to get &#34;outside&#34; from your LAN is through proxy server.&lt;/li&gt; &#xA; &lt;li&gt;To get out from behind restrictive firewall which filters outgoing ports.&lt;/li&gt; &#xA; &lt;li&gt;To use two (or more) proxies in chain:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;   like: your_host &amp;lt;--&amp;gt; proxy1 &amp;lt;--&amp;gt; proxy2 &amp;lt;--&amp;gt; target_host&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To &#34;proxify&#34; some program with no proxy support built-in (like telnet)&lt;/li&gt; &#xA; &lt;li&gt;Access intranet from outside via proxy.&lt;/li&gt; &#xA; &lt;li&gt;To use DNS behind proxy.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Some cool features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This program can mix different proxy types in the same chain&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;  like: your_host &amp;lt;--&amp;gt;socks5 &amp;lt;--&amp;gt; http &amp;lt;--&amp;gt; socks4 &amp;lt;--&amp;gt; target_host&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Different chaining options supported random order from the list ( user defined length of chain ). exact order (as they appear in the list ) dynamic order (smart exclude dead proxies from chain)&lt;/li&gt; &#xA; &lt;li&gt;You can use it with any TCP client application, even network scanners yes, yes - you can make portscan via proxy (or chained proxies) for example with Nmap scanner by fyodor (&lt;a href=&#34;http://www.insecure.org/nmap&#34;&gt;www.insecure.org/nmap&lt;/a&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;  proxychains nmap -sT -PO -p 80 -iR  (find some webservers through proxy)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can use it with servers, like squid, sendmail, or whatever.&lt;/li&gt; &#xA; &lt;li&gt;DNS resolving through proxy.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;proxychains looks for configuration in the following order:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SOCKS5 proxy host ip and port in environment variable ${PROXYCHAINS_SOCKS5_HOST} ${PROXYCHAINS_SOCKS5_PORT} (if ${PROXYCHAINS_SOCKS5_PORT} is set, no further configuration will be searched. if ${PROXYCHAINS_SOCKS5_HOST} isn&#39;t set, host ip will become &#34;127.0.0.1&#34;)&lt;/li&gt; &#xA; &lt;li&gt;file listed in environment variable ${PROXYCHAINS_CONF_FILE} or provided as a -f argument to proxychains script or binary.&lt;/li&gt; &#xA; &lt;li&gt;./proxychains.conf&lt;/li&gt; &#xA; &lt;li&gt;$(HOME)/.proxychains/proxychains.conf&lt;/li&gt; &#xA; &lt;li&gt;/etc/proxychains.conf&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;see more in &lt;em&gt;/etc/proxychains.conf&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ proxychains4 telnet targethost.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in this example it will run telnet through proxy(or chained proxies) specified by &lt;em&gt;proxychains.conf&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ proxychains4 -f /etc/proxychains-other.conf targethost2.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in this example it will use different configuration file then &lt;em&gt;proxychains.conf&lt;/em&gt; to connect to targethost2.com host.&lt;/p&gt; &#xA;&lt;h3&gt;Usage Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ proxyresolv targethost.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in this example it will resolve targethost.com through proxy(or chained proxies) specified by &lt;em&gt;proxychains.conf&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Usage Example:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ssh -fN -D 4321 some.example.com&#xA;$ PROXYCHAINS_SOCKS5_HOST=127.0.0.1 PROXYCHAINS_SOCKS5_PORT=4321 proxychains zsh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in this example, it will run a shell with all traffic proxied through OpenSSH&#39;s &#34;dynamic proxy&#34; (SOCKS5 proxy) on localhost port 4321.&lt;/p&gt; &#xA;&lt;h3&gt;Usage Example:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ export PROXY_DNS_SERVER=8.8.8.8&#xA;$ proxychains4 telnet targethost.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in this example, it will telnet to targethost.com using the 8.8.8.8 nameserver supplied by the user through the PROXY_DNS_SERVER&lt;/p&gt;</summary>
  </entry>
</feed>