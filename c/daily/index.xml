<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-29T01:30:19Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>maoabc/nmmp</title>
    <updated>2023-07-29T01:30:19Z</updated>
    <id>tag:github.com,2023-07-29:/maoabc/nmmp</id>
    <link href="https://github.com/maoabc/nmmp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;dex-vm used to protect the android classes.dex file&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;nmmp&lt;/h1&gt; &#xA;&lt;p&gt;基于dex-vm运行dalvik字节码从而对dex进行保护，增加反编译难度。 项目分为两部分nmm-protect是纯java项目，对dex进行转换，把dex里数据转为c结构体，opcode随机化生成ndk项目,编译后生成加固后的apk。nmmvm是一个安卓项目，包含dex-vm实现及各种dalvik指令的测试等。&lt;/p&gt; &#xA;&lt;h1&gt;nmm-protect&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;配置ndk及环境变量&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;不编译nmm-protect，可以直接看使用它生成项目及最后的apk，&lt;a href=&#34;https://github.com/maoabc/nmmp/releases/download/demo/demo.zip&#34;&gt;一个对apk处理的例子&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;例子在linux环境下测试的，windows也应该没问题,先安装好JDK及android sdk和ndk。&lt;/p&gt; &#xA;&lt;p&gt;下载&lt;a href=&#34;https://github.com/maoabc/nmmp/releases/download/last/vm-protect-2023-07-08-0942.jar&#34;&gt;vm-protect.jar&lt;/a&gt;,配置好环境变量ANDROID_SDK_HOME、ANDROID_NDK_HOME:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export ANDROID_SDK_HOME=/opt/android-sdk&#xA;export ANDROID_NDK_HOME=/opt/android-sdk/ndk/22.1.7171670&#xA;export CMAKE_PATH=/opt/android-sdk/cmake/3.18.1/   #可选，不配置的话直接使用/bin/cmake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;apk加固&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar vm-protect-xxx.jar apk input.apk convertRules.txt mapping.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;执行完毕会在input.apk所在的目录下生成一个build目录，里面包含最后输出的apk(build/input-protect.apk)，完整的c项目dex2c(基于cmake)及处理过程中生成的.dex等。&lt;br&gt; 第一次运行后会在jar位置生成tools目录，里面有config.json可以编辑它配置安卓sdk，ndk相关路径。&lt;/p&gt; &#xA;&lt;p&gt;生成的apk需要使用zipalign对齐（新版本已使用zipflinger处理apk,可以不用使用单独的zipalign）及apksigner签名才能安装使用&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apksigner sign --ks ~/.myapp.jks build/input-protect-align.apk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;aab加固&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar vm-protect-xxx.jar aab test.aab convertRules.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;之后需要使用jarsigner签名，也可以集成signflinger进行签名&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;jarsigner -keystore ~/.myapp.jks -storepass pass -keypass pass test-protect.aab keyAlias&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;aar加固&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;java -jar vm-protect-xxx.jar aar testModule.aar convertRules.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;下载及编译项目&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/maoabc/nmmp.git&#xA;cd nmmp/nmm-protect&#xA;./gradlew arsc:build&#xA;./gradlew build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;成功后会在build/libs生成可直接执行的fatjar。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;需要转换的类和方法规则&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;无转换规则文件，则会转换dex里所有class里的方法（除了构造方法和静态初始化方法）。规则只支持一些简单的情况：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//支持的规则比较简单，*只是被转成正则表达式的.*，支持一些简单的继承关系&#xA;class * extends android.app.Activity&#xA;class * implements java.io.Serializable&#xA;class my.package.AClass&#xA;class my.package.* { *; }&#xA;class * extends java.util.ArrayList {&#xA;  if*;&#xA;}&#xA;&#xA;&#xA;class A {&#xA;}&#xA;class B extends A {&#xA;}&#xA;class C extends B {&#xA;}&#xA;//比如&#39;class * extends A&#39; 只会匹配B而不会再匹配C&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;nmmvm&lt;/h1&gt; &#xA;&lt;p&gt;nmmvm是dex虚拟机具体实现，入口就一个函数:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;jvalue vmInterpret(&#xA;        JNIEnv *env,&#xA;        const vmCode *code,&#xA;        const vmResolver *dvmResolver&#xA;);&#xA;&#xA;typedef struct {&#xA;    const u2 *insns;             //指令&#xA;    const u4 insnsSize;          //指令大小&#xA;    regptr_t *regs;                    //寄存器&#xA;    u1 *reg_flags;               //寄存器数据类型标记,主要标记是否为对象&#xA;    const u1 *triesHandlers;     //异常表&#xA;} vmCode;&#xA;&#xA;&#xA;typedef struct {&#xA;&#xA;    const vmField *(*dvmResolveField)(JNIEnv *env, u4 idx, bool isStatic);&#xA;&#xA;    const vmMethod *(*dvmResolveMethod)(JNIEnv *env, u4 idx, bool isStatic);&#xA;&#xA;    //从类型常量池取得类型名&#xA;    const char *(*dvmResolveTypeUtf)(JNIEnv *env, u4 idx);&#xA;&#xA;    //直接返回jclass对象,本地引用需要释放引用&#xA;    jclass (*dvmResolveClass)(JNIEnv *env, u4 idx);&#xA;&#xA;    //根据类型名得到class&#xA;    jclass (*dvmFindClass)(JNIEnv *env, const char *type);&#xA;&#xA;    //const_string指令加载的字符串对象&#xA;    jstring (*dvmConstantString)(JNIEnv *env, u4 idx);&#xA;&#xA;} vmResolver;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;vmCode提供执行所需要的指令、异常表及寄存器空间，vmResolver包含一组函数指针，提供运行时的符号，比如field，method等。通过自定义这两个参数来实现不同的加固方式，比如项目里的test.cpp有一个简单的基于libdex实现的vmResolver，它主要用于开发测试。而nmm-protect实现的是把.dex相关数据转换为c结构体，还包含了opcode随机化等，基本可实际使用。&lt;/p&gt; &#xA;&lt;h1&gt;aar模块加固&lt;/h1&gt; &#xA;&lt;p&gt;目前已实现模块相关加固，用法同apk加固类似，如果有问题可以提issue。&lt;/p&gt; &#xA;&lt;h1&gt;Licences&lt;/h1&gt; &#xA;&lt;p&gt;nmm-protect 以gpl协议发布,&lt;a href=&#34;https://github.com/maoabc/nmmp/raw/master/nmm-protect/LICENSE&#34;&gt;nmm-protect licence&lt;/a&gt;, dex-vm部分以Apache协议发布, &lt;a href=&#34;https://github.com/maoabc/nmmp/raw/master/nmmvm/LICENSE&#34;&gt;nmmvm licence&lt;/a&gt;. 只有vm部分会打包进apk中, nmm-protect只是转换dex,协议不影响生成的结果.&lt;/p&gt;</summary>
  </entry>
</feed>