<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-16T01:30:13Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>HansKristian-Work/vkd3d-proton</title>
    <updated>2022-12-16T01:30:13Z</updated>
    <id>tag:github.com,2022-12-16:/HansKristian-Work/vkd3d-proton</id>
    <link href="https://github.com/HansKristian-Work/vkd3d-proton" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fork of VKD3D. Development branches for Proton&#39;s Direct3D 12 implementation.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;VKD3D-Proton&lt;/h1&gt; &#xA;&lt;p&gt;VKD3D-Proton is a fork of VKD3D, which aims to implement the full Direct3D 12 API on top of Vulkan. The project serves as the development effort for Direct3D 12 support in &lt;a href=&#34;https://github.com/ValveSoftware/Proton&#34;&gt;Proton&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Upstream&lt;/h2&gt; &#xA;&lt;p&gt;The original project is available at &lt;a href=&#34;https://source.winehq.org/git/vkd3d.git/&#34;&gt;WineHQ&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Priorities&lt;/h2&gt; &#xA;&lt;p&gt;Performance and game compatibility are important targets, at the expense of compatibility with older drivers and systems. Modern Vulkan extensions and features are aggressively made use of to improve game performance and compatibility. It is recommended to use the very latest drivers you can get your hands on for the best experience. Backwards compatibility with the vkd3d standalone API is not a goal of this project.&lt;/p&gt; &#xA;&lt;h2&gt;Drivers&lt;/h2&gt; &#xA;&lt;p&gt;There are some hard requirements on drivers to be able to implement D3D12 in a reasonably performant way.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Vulkan 1.1&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_EXT_descriptor_indexing&lt;/code&gt; with at least 1000000 UpdateAfterBind descriptors for all types except UniformBuffer. Essentially all features in &lt;code&gt;VkPhysicalDeviceDescriptorIndexingFeatures&lt;/code&gt; must be supported.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_KHR_timeline_semaphore&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_KHR_sampler_mirror_clamp_to_edge&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_EXT_robustness2&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_KHR_separate_depth_stencil_layouts&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_KHR_bind_memory2&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_KHR_copy_commands2&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_KHR_dynamic_rendering&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_EXT_extended_dynamic_state&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_EXT_extended_dynamic_state2&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_KHR_buffer_device_address&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_KHR_push_descriptor&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some notable extensions that &lt;strong&gt;should&lt;/strong&gt; be supported for optimal or correct behavior. These extensions will likely become mandatory later.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;VK_EXT_image_view_min_lod&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;VK_EXT_mutable_descriptor_type&lt;/code&gt; (or the vendor &lt;code&gt;VALVE&lt;/code&gt; alias) is also highly recommended, but not mandatory.&lt;/p&gt; &#xA;&lt;h3&gt;AMD (RADV)&lt;/h3&gt; &#xA;&lt;p&gt;For AMD, RADV is the recommended driver and the one that sees most testing on AMD GPUs. The minimum requirement at the moment is Mesa 22.0 since it supports &lt;code&gt;VK_KHR_dynamic_rendering&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: For older Mesa versions, use the v2.6 release.&lt;/p&gt; &#xA;&lt;h3&gt;NVIDIA&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://developer.nvidia.com/vulkan-driver&#34;&gt;Vulkan beta drivers&lt;/a&gt; generally contain the latest driver fixes that we identify while getting games to work. The latest drivers (stable, beta or Vulkan beta tracks) are always preferred. If you&#39;re having problems, always try the latest drivers.&lt;/p&gt; &#xA;&lt;h3&gt;Intel&lt;/h3&gt; &#xA;&lt;p&gt;We have not done any testing against Intel iGPUs yet.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Cloning the repo&lt;/h2&gt; &#xA;&lt;p&gt;To clone the repo you should run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone --recursive https://github.com/HansKristian-Work/vkd3d-proton&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;in order to pull in all the submodules which are needed for building.&lt;/p&gt; &#xA;&lt;h2&gt;Building VKD3D-Proton&lt;/h2&gt; &#xA;&lt;h3&gt;Requirements:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.winehq.org/&#34;&gt;wine&lt;/a&gt; (for &lt;code&gt;widl&lt;/code&gt;) [for native builds] &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;On Windows this may be substituted for &lt;a href=&#34;http://strawberryperl.com/&#34;&gt;Strawberry Perl&lt;/a&gt; as it ships &lt;code&gt;widl&lt;/code&gt; and is easy to find and install -- although this dependency may be eliminated in the future.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://mesonbuild.com/&#34;&gt;Meson&lt;/a&gt; build system (at least version 0.49)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/KhronosGroup/glslang&#34;&gt;glslang&lt;/a&gt; compiler&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://mingw-w64.org/&#34;&gt;Mingw-w64&lt;/a&gt; compiler, headers and tools (at least version 7.0) [for cross-builds for d3d12.dll which are default]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building:&lt;/h3&gt; &#xA;&lt;h4&gt;The simple way&lt;/h4&gt; &#xA;&lt;p&gt;Inside the VKD3D-Proton directory, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./package-release.sh master /your/target/directory --no-package&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create a folder &lt;code&gt;vkd3d-master&lt;/code&gt; in &lt;code&gt;/your/target/directory&lt;/code&gt;, which contains both 32-bit and 64-bit versions of VKD3D-Proton, which can be set up in the same way as the release versions as noted above.&lt;/p&gt; &#xA;&lt;p&gt;If you want to build natively (ie. for &lt;code&gt;libvkd3d-proton.so&lt;/code&gt;), pass &lt;code&gt;--native&lt;/code&gt; to the build script. This option will make it build using your system&#39;s compilers.&lt;/p&gt; &#xA;&lt;p&gt;In order to preserve the build directories for development, pass &lt;code&gt;--dev-build&lt;/code&gt; to the script. This option implies &lt;code&gt;--no-package&lt;/code&gt;. After making changes to the source code, you can then do the following to rebuild VKD3D-Proton:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# change to build.86 for 32-bit&#xA;ninja -C /your/target/directory/build.64 install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Compiling manually (cross for d3d12.dll, default)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;# 64-bit build.&#xA;meson --cross-file build-win64.txt --buildtype release --prefix /your/vkd3d-proton/directory build.64&#xA;ninja -C build.64 install&#xA;&#xA;# 32-bit build&#xA;meson --cross-file build-win32.txt --buildtype release --prefix /your/vkd3d-proton/directory build.86&#xA;ninja -C build.86 install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Compiling manually (native)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;# 64-bit build.&#xA;meson --buildtype release --prefix /your/vkd3d-proton/directory build.64&#xA;ninja -C build.64 install&#xA;&#xA;# 32-bit build&#xA;CC=&#34;gcc -m32&#34; CXX=&#34;g++ -m32&#34; \&#xA;PKG_CONFIG_PATH=&#34;/usr/lib32/pkgconfig:/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib/pkgconfig&#34; \&#xA;meson --buildtype release --prefix /your/vkd3d-proton/directory build.86&#xA;ninja -C build.86 install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using VKD3D-Proton&lt;/h2&gt; &#xA;&lt;p&gt;The intended way to use VKD3D-Proton is as a native Win32 d3d12.dll. This serves as a drop-in replacement for D3D12, and can be used in Wine (Proton or vanilla flavors), or on Windows.&lt;/p&gt; &#xA;&lt;p&gt;VKD3D-Proton does not supply the necessary DXGI component. VKD3D-Proton can be used with either DXVK&#39;s DXGI implementation, or Wine&#39;s DXGI implementation. VKD3D-Proton implements its own IDXGISwapChain when built as a native d3d12.dll.&lt;/p&gt; &#xA;&lt;h3&gt;A note on using VKD3D-Proton on Windows&lt;/h3&gt; &#xA;&lt;p&gt;Native Windows use is mostly relevant for developer testing purposes. Do not expect games running on Windows 7 or 8.1 to magically make use of VKD3D-Proton, as many games will only even attempt to load d3d12.dll if they are running on Windows 10.&lt;/p&gt; &#xA;&lt;h3&gt;Native Linux build&lt;/h3&gt; &#xA;&lt;p&gt;A native Linux binary can be built, but it is not intended to be compatible with upstream Wine. A native option is mostly relevant for development purposes.&lt;/p&gt; &#xA;&lt;h2&gt;Environment variables&lt;/h2&gt; &#xA;&lt;p&gt;Most of the environment variables used by VKD3D-Proton are for debugging purposes. The environment variables are not considered a part of API and might be changed or removed in the future versions of VKD3D-Proton.&lt;/p&gt; &#xA;&lt;p&gt;Some of debug variables are lists of elements. Elements must be separated by commas or semicolons.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_CONFIG&lt;/code&gt; - a list of options that change the behavior of vkd3d-proton. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;vk_debug&lt;/code&gt; - enables Vulkan debug extensions and loads validation layer.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;skip_application_workarounds&lt;/code&gt; - Skips all application workarounds. For debugging purposes.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;dxr&lt;/code&gt; - Enables DXR support if supported by device.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;dxr11&lt;/code&gt; - Enables DXR tier 1.1 support if supported by device.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;force_static_cbv&lt;/code&gt; - Unsafe speed hack on NVIDIA. May or may not give a significant performance uplift.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;single_queue&lt;/code&gt; - Do not use asynchronous compute or transfer queues.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;no_upload_hvv&lt;/code&gt; - Blocks any attempt to use host-visible VRAM (large/resizable BAR) for the UPLOAD heap. May free up vital VRAM in certain critical situations, at cost of lower GPU performance. A fraction of VRAM is reserved for resizable BAR allocations either way, so it should not be a real issue even on lower VRAM cards.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;force_host_cached&lt;/code&gt; - Forces all host visible allocations to be CACHED, which greatly accelerates captures.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;no_invariant_position&lt;/code&gt; - Avoids workarounds for invariant position. The workaround is enabled by default.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_DEBUG&lt;/code&gt; - controls the debug level for log messages produced by vkd3d-proton. Accepts the following values: none, err, info, fixme, warn, trace.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_SHADER_DEBUG&lt;/code&gt; - controls the debug level for log messages produced by the shader compilers. See &lt;code&gt;VKD3D_DEBUG&lt;/code&gt; for accepted values.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_LOG_FILE&lt;/code&gt; - If set, redirects &lt;code&gt;VKD3D_DEBUG&lt;/code&gt; logging output to a file instead.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_VULKAN_DEVICE&lt;/code&gt; - a zero-based device index. Use to force the selected Vulkan device.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_FILTER_DEVICE_NAME&lt;/code&gt; - skips devices that don&#39;t include this substring.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_DISABLE_EXTENSIONS&lt;/code&gt; - a list of Vulkan extensions that vkd3d-proton should not use even if available.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_TEST_DEBUG&lt;/code&gt; - enables additional debug messages in tests. Set to 0, 1 or 2.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_TEST_FILTER&lt;/code&gt; - a filter string. Only the tests whose names matches the filter string will be run, e.g. &lt;code&gt;VKD3D_TEST_FILTER=clear_render_target&lt;/code&gt;. Useful for debugging or developing new tests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_TEST_EXCLUDE&lt;/code&gt; - excludes tests of which the name is included in the string, e.g. &lt;code&gt;VKD3D_TEST_EXCLUDE=test_root_signature_priority,test_conservative_rasterization_dxil&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_TEST_PLATFORM&lt;/code&gt; - can be set to &#34;wine&#34;, &#34;windows&#34; or &#34;other&#34;. The test platform controls the behavior of todo(), todo_if(), bug_if() and broken() conditions in tests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_TEST_BUG&lt;/code&gt; - set to 0 to disable bug_if() conditions in tests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_PROFILE_PATH&lt;/code&gt; - If profiling is enabled in the build, a profiling block is emitted to &lt;code&gt;${VKD3D_PROFILE_PATH}.${pid}&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Shader cache&lt;/h2&gt; &#xA;&lt;p&gt;By default, vkd3d-proton manages its own driver cache. This cache is intended to cache DXBC/DXIL -&amp;gt; SPIR-V conversion. This reduces stutter (when pipelines are created last minute and app relies on hot driver cache) and load times (when applications do the right thing of loading PSOs up front).&lt;/p&gt; &#xA;&lt;p&gt;Behavior is designed to be close to DXVK state cache.&lt;/p&gt; &#xA;&lt;h4&gt;Default behavior&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;vkd3d-proton.cache&lt;/code&gt; (and &lt;code&gt;vkd3d-proton.cache.write&lt;/code&gt;) are placed in the current working directory. Generally, this is the game install folder when running in Steam.&lt;/p&gt; &#xA;&lt;h4&gt;Custom directory&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;VKD3D_SHADER_CACHE_PATH=/path/to/directory&lt;/code&gt; overrides the directory where &lt;code&gt;vkd3d-proton.cache&lt;/code&gt; is placed.&lt;/p&gt; &#xA;&lt;h4&gt;Disable cache&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;VKD3D_SHADER_CACHE_PATH=0&lt;/code&gt; disables the internal cache, and any caching would have to be explicitly managed by application.&lt;/p&gt; &#xA;&lt;h3&gt;Behavior of ID3D12PipelineLibrary&lt;/h3&gt; &#xA;&lt;p&gt;When explicit shader cache is used, the need for application managed pipeline libraries is greatly diminished, and the cache applications interact with is a dummy cache. If the vkd3d-proton shader cache is disabled, ID3D12PipelineLibrary stores everything relevant for a full cache, i.e. SPIR-V and PSO driver cache blob. &lt;code&gt;VKD3D_CONFIG=pipeline_library_app_cache&lt;/code&gt; is an alternative to &lt;code&gt;VKD3D_SHADER_CACHE_PATH=0&lt;/code&gt; and can be automatically enabled based on app-profiles if relevant in the future if applications manage the caches better than vkd3d-proton can do automagically.&lt;/p&gt; &#xA;&lt;h2&gt;CPU profiling (development)&lt;/h2&gt; &#xA;&lt;p&gt;Pass &lt;code&gt;-Denable_profiling=true&lt;/code&gt; to Meson to enable a profiled build. With a profiled build, use &lt;code&gt;VKD3D_PROFILE_PATH&lt;/code&gt; environment variable. The profiling dumps out a binary blob which can be analyzed with &lt;code&gt;programs/vkd3d-profile.py&lt;/code&gt;. The profile is a trivial system which records number of iterations and total ticks (ns) spent. It is easy to instrument parts of code you are working on optimizing.&lt;/p&gt; &#xA;&lt;h2&gt;Advanced shader debugging&lt;/h2&gt; &#xA;&lt;p&gt;These features are only meant to be used by vkd3d-proton developers. For any builtin RenderDoc related functionality pass &lt;code&gt;-Denable_renderdoc=true&lt;/code&gt; to Meson.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_SHADER_DUMP_PATH&lt;/code&gt; - path where shader bytecode is dumped. Bytecode is dumped in format of &lt;code&gt;$hash.{spv,dxbc,dxil}&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_SHADER_OVERRIDE&lt;/code&gt; - path to where overridden shaders can be found. If application is creating a pipeline with &lt;code&gt;$hash&lt;/code&gt; and &lt;code&gt;$VKD3D_SHADER_OVERRIDE/$hash.spv&lt;/code&gt; exists, that SPIR-V file will be used instead.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_AUTO_CAPTURE_SHADER&lt;/code&gt; - If this is set to a shader hash, and the RenderDoc layer is enabled, vkd3d-proton will automatically make a capture when a specific shader is encountered.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;VKD3D_AUTO_CAPTURE_COUNTS&lt;/code&gt; - A comma-separated list of indices. This can be used to control which queue submissions to capture. E.g., use &lt;code&gt;VKD3D_AUTO_CAPTURE_COUNTS=0,4,10&lt;/code&gt; to capture the 0th (first submission), 4th and 10th submissions which are candidates for capturing. If &lt;code&gt;VKD3D_AUTO_CAPTURE_COUNTS&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;, the entire app runtime can be turned into one big capture. This is only intended to be used when capturing something like the test suite, or tiny applications with a finite runtime to make it easier to debug cross submission work.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If only &lt;code&gt;VKD3D_AUTO_CAPTURE_COUNTS&lt;/code&gt; is set, any queue submission is considered for capturing. If only &lt;code&gt;VKD3D_AUTO_CAPTURE_SHADER&lt;/code&gt; is set, &lt;code&gt;VKD3D_AUTO_CAPTURE_COUNTS&lt;/code&gt; is considered to be equal to &lt;code&gt;&#34;0&#34;&lt;/code&gt;, i.e. a capture is only made on first encounter with the target shader. If both are set, the capture counter is only incremented and considered when a submission contains the use of the target shader.&lt;/p&gt; &#xA;&lt;h3&gt;Breadcrumbs debugging&lt;/h3&gt; &#xA;&lt;p&gt;For debugging GPU hangs, it&#39;s useful to know where crashes happen. If the build has trace enabled (non-release builds), breadcrumbs support is also enabled.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;VKD3D_CONFIG=breadcrumbs&lt;/code&gt; will instrument command lists with &lt;code&gt;VK_AMD_buffer_marker&lt;/code&gt; or &lt;code&gt;VK_NV_device_checkpoints&lt;/code&gt;. On GPU device lost or timeout, crash dumps are written to the log. For best results on RADV, use &lt;code&gt;RADV_DEBUG=syncshaders&lt;/code&gt;. The logs will print a digested form of the command lists which were executing at the time, and attempt to narrow down the possible range of commands which could have caused a crash.&lt;/p&gt; &#xA;&lt;h3&gt;Shader logging&lt;/h3&gt; &#xA;&lt;p&gt;It is possible to log the output of replaced shaders, essentially a custom shader printf. To enable this feature, &lt;code&gt;VK_KHR_buffer_device_address&lt;/code&gt; must be supported. First, use &lt;code&gt;VKD3D_SHADER_DEBUG_RING_SIZE_LOG2=28&lt;/code&gt; for example to set up a 256 MiB ring buffer in host memory. Since this buffer is allocated in host memory, feel free to make it as large as you want, as it does not consume VRAM. A worker thread will read the data as it comes in and log it. There is potential here to emit more structured information later. The main reason this is implemented instead of the validation layer printf system is run-time performance, and avoids any possible accidental hiding of bugs by introducing validation layers which add locking, etc. Using &lt;code&gt;debugPrintEXT&lt;/code&gt; is also possible if that fits better with your debugging scenario. With this shader replacement scheme, we&#39;re able to add shader logging as unintrusive as possible.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Inside folder full of override shaders, build everything with:&#xA;make -C /path/to/include/shader-debug M=$PWD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The shader can then include &lt;code&gt;#include &#34;debug_channel.h&#34;&lt;/code&gt; and use various functions below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void DEBUG_CHANNEL_INIT(uvec3 ID);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is used somewhere in your replaced shader. This should be initialized with &lt;code&gt;gl_GlobalInvocationID&lt;/code&gt; or similar. This ID will show up in the log. For each subgroup which calls &lt;code&gt;DEBUG_CHANNEL_INIT&lt;/code&gt;, an instance counter is generated. This allows you to correlate several messages which all originate from the same instance counter, which is logged alongside the ID. An invocation can be uniquely identified with the instance + &lt;code&gt;DEBUG_CHANNEL_INIT&lt;/code&gt; id. &lt;code&gt;DEBUG_CHANNEL_INIT&lt;/code&gt; can be called from non-uniform control flow, as it does not use &lt;code&gt;barrier()&lt;/code&gt; or similar constructs. It can also be used in vertex and fragment shaders for this reason.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void DEBUG_CHANNEL_MSG();&#xA;void DEBUG_CHANNEL_MSG(uint v0);&#xA;void DEBUG_CHANNEL_MSG(uint v0, uint v1, ...); // Up to 4 components, can be expanded as needed up to 16.&#xA;void DEBUG_CHANNEL_MSG(int v0);&#xA;void DEBUG_CHANNEL_MSG(int v0, int v1, ...); // Up to 4 components, ...&#xA;void DEBUG_CHANNEL_MSG(float v0);&#xA;void DEBUG_CHANNEL_MSG(float v0, float v1, ...); // Up to 4 components, ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These functions log, formatting is &lt;code&gt;#%x&lt;/code&gt; for uint, &lt;code&gt;%d&lt;/code&gt; for int and &lt;code&gt;%f&lt;/code&gt; for float type.&lt;/p&gt; &#xA;&lt;h2&gt;Descriptor debugging&lt;/h2&gt; &#xA;&lt;p&gt;If &lt;code&gt;-Denable_descriptor_qa=true&lt;/code&gt; is enabled in build, you can set the &lt;code&gt;VKD3D_DESCRIPTOR_QA_LOG&lt;/code&gt; env-var to a file. All descriptor updates and copies are logged so that it&#39;s possible to correlate descriptors with GPU crash dumps. &lt;code&gt;enable_descriptor_qa&lt;/code&gt; is not enabled by default, since it adds some flat overhead in an extremely hot code path.&lt;/p&gt; &#xA;&lt;h3&gt;GPU-assisted debugging&lt;/h3&gt; &#xA;&lt;p&gt;If &lt;code&gt;VKD3D_CONFIG=descriptor_qa_checks&lt;/code&gt; is set with a build which enables &lt;code&gt;-Denable_descriptor_qa=true&lt;/code&gt;, all shaders will be instrumented to check for invalid access. In the log, you will see this to make sure the feature is enabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;932:info:vkd3d_descriptor_debug_init_once: Enabling descriptor QA checks!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The main motivation is the tight integration and high performance. GPU-assisted debugging can be run at well over playable speeds.&lt;/p&gt; &#xA;&lt;h4&gt;Descriptor heap index out of bounds&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;============&#xA;Fault type: HEAP_OUT_OF_RANGE&#xA;Fault type: MISMATCH_DESCRIPTOR_TYPE&#xA;CBV_SRV_UAV heap cookie: 1800&#xA;Shader hash and instruction: edbaf1b5ed344467 (1)&#xA;Accessed resource/view cookie: 0&#xA;Shader desired descriptor type: 8 (STORAGE_BUFFER)&#xA;Found descriptor type in heap: 0 (NONE)&#xA;Failed heap index: 1024000&#xA;==========&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The instruction &lt;code&gt;(1)&lt;/code&gt;, is reported as well, and a disassembly of the shader in question can be used to pinpoint exactly where things are going wrong. Dump all shaders with &lt;code&gt;VKD3D_SHADER_DUMP_PATH=/my/folder&lt;/code&gt;, and run &lt;code&gt;spirv-cross -V /my/folder/edbaf1b5ed344467.spv&lt;/code&gt;. (NOTE: clear out the folder before dumping, existing files are not overwritten). The faulting instruction can be identified by looking at last argument, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;uint fixup_index = descriptor_qa_check(heap_index, descriptor_type, 1u /* instruction ID */);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Mismatch descriptor type&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;============&#xA;Fault type: MISMATCH_DESCRIPTOR_TYPE&#xA;CBV_SRV_UAV heap cookie: 1800 // Refer to VKD3D_DESCRIPTOR_QA_LOG&#xA;Shader hash and instruction: edbaf1b5ed344467 (1)&#xA;Accessed resource/view cookie: 1802 // Refer to VKD3D_DESCRIPTOR_QA_LOG&#xA;Shader desired descriptor type: 8 (STORAGE_BUFFER)&#xA;Found descriptor type in heap: 1 (SAMPLED_IMAGE)&#xA;Failed heap index: 1025&#xA;==========&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Accessing destroyed resource&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;============&#xA;Fault type: DESTROYED_RESOURCE&#xA;CBV_SRV_UAV heap cookie: 1800&#xA;Shader hash and instruction: edbaf1b5ed344467 (2)&#xA;Accessed resource/view cookie: 1806&#xA;Shader desired descriptor type: 1 (SAMPLED_IMAGE)&#xA;Found descriptor type in heap: 1 (SAMPLED_IMAGE)&#xA;Failed heap index: 1029&#xA;==========&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Debugging descriptor crashes with RADV dumps (hardcore ultra nightmare mode)&lt;/h3&gt; &#xA;&lt;p&gt;For when you&#39;re absolutely desperate, there is a way to debug GPU hangs. First, install &lt;a href=&#34;https://gitlab.freedesktop.org/tomstdenis/umr&#34;&gt;umr&lt;/a&gt; and make the binary setsuid.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ACO_DEBUG=force-waitcnt RADV_DEBUG=hang VKD3D_DESCRIPTOR_QA_LOG=/somewhere/desc.txt %command%&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;It is possible to use &lt;code&gt;RADV_DEBUG=hang,umr&lt;/code&gt; as well, but from within Wine, there are weird things happening where UMR dumps do not always succeed. Instead, it is possible to invoke umr manually from an SSH shell when the GPU hangs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;mkdir -p &#34;$HOME/umr-dump&#34;&#xA;&#xA;# For Navi, older GPUs might have different rings. See RADV source.&#xA;umr -R gfx_0.0.0 &amp;gt; &#34;$HOME/umr-dump/ring.txt&#34; 2&amp;gt;&amp;amp;1&#xA;umr -O halt_waves -wa gfx_0.0.0 &amp;gt; &#34;$HOME/umr-dump/halt-waves-1.txt&#34; 2&amp;gt;&amp;amp;1&#xA;umr -O bits,halt_waves -wa gfx_0.0.0 &amp;gt; &#34;$HOME/umr-dump/halt-waves-2.txt&#34; 2&amp;gt;&amp;amp;1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A folder is placed in &lt;code&gt;~/radv_dumps*&lt;/code&gt; by RADV, and the UMR script will place wave dumps in &lt;code&gt;~/umr-dump&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;First, we can study the wave dumps to see where things crash, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    pgm[6@0x800120e26c00 + 0x584 ] = 0xf0001108&#x9;&#x9;image_load v47, v[4:5], s[48:55] dmask:0x1 dim:SQ_RSRC_IMG_2D unorm&#xA;    pgm[6@0x800120e26c00 + 0x588 ] = 0x000c2f04&#x9;;;&#xA;    pgm[6@0x800120e26c00 + 0x58c ] = 0xbf8c3f70&#x9;&#x9;s_waitcnt vmcnt(0)&#xA; *  pgm[6@0x800120e26c00 + 0x590 ] = 0x930118c0&#x9;&#x9;s_mul_i32 s1, 64, s24&#xA;    pgm[6@0x800120e26c00 + 0x594 ] = 0xf40c0c09&#x9;&#x9;s_load_dwordx8 s[48:55], s[18:19], s1&#xA;    pgm[6@0x800120e26c00 + 0x598 ] = 0x02000000&#x9;;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;excp: 256 is a memory error (at least on 5700xt).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;TRAPSTS[50000100]:&#xA;&#x9;                excp:      256 |         illegal_inst:        0 |           buffer_oob:        0 |           excp_cycle:        0 |&#xA;&#x9;       excp_wave64hi:        0 |          xnack_error:        1 |              dp_rate:        2 |      excp_group_mask:        0 |&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can inspect all VGPRs and all SGPRs, here for the image descriptor.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    [  48..  51] = { 0130a000, c0500080, 810dc1df, 93b00204 }&#xA;    [  52..  55] = { 00000000, 00400000, 002b0000, 800130c8 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Decode the VA and study &lt;code&gt;bo_history.log&lt;/code&gt;. There is a script in RADV which lets you query history for a VA. This lets us verify that the VA in question was freed at some point. At point of writing, there is no easy way to decode raw descriptor blobs, but when you&#39;re desperate enough you can do it by hand :|&lt;/p&gt; &#xA;&lt;p&gt;In &lt;code&gt;pipeline.log&lt;/code&gt; we have the full SPIR-V (with OpSource reference to the source DXIL/DXBC) and disassembly of the crashed pipeline. Here we can study the code to figure out which descriptor was read.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    // s7 is the descriptor heap index, s1 is the offset (64 bytes per image descriptor),&#xA;    // s[18:19] is the descriptor heap.&#xA;    s_mul_i32 s1, 64, s7                                        ; 930107c0&#xA;    s_load_dwordx8 s[48:55], s[18:19], s1                       ; f40c0c09 02000000&#xA;    s_waitcnt lgkmcnt(0)                                        ; bf8cc07f&#xA;    image_load v47, v[4:5], s[48:55] dmask:0x1 dim:SQ_RSRC_IMG_2D unorm ; f0001108 000c2f04&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;    [   4..   7] = { 03200020, ffff8000, 0000002b, 00000103 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which is descriptor index #259. Based on this, we can inspect the descriptor QA log and verify that the application did indeed do something invalid, which caused the GPU hang.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>deepinstinct/Dirty-Vanity</title>
    <updated>2022-12-16T01:30:13Z</updated>
    <id>tag:github.com,2022-12-16:/deepinstinct/Dirty-Vanity</id>
    <link href="https://github.com/deepinstinct/Dirty-Vanity" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A POC for the new injection technique, abusing windows fork API to evade EDRs. https://www.blackhat.com/eu-22/briefings/schedule/index.html#dirty-vanity-a-new-approach-to-code-injection--edr-bypass-28417&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Dirty Vanity&lt;/h1&gt; &#xA;&lt;p&gt;A POC for the new injection technique, abusing windows fork API to evade EDRs.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;DirtyVanity.exe [TARGET_PID_TO_REFLECT]&lt;/p&gt; &#xA;&lt;h3&gt;Runtime steps&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Allocate and write shellcode to [TARGET_PID_TO_REFLECT]&lt;/li&gt; &#xA; &lt;li&gt;Fork [TARGET_PID_TO_REFLECT] to a new process&lt;/li&gt; &#xA; &lt;li&gt;Set the forked process&#39;s start address to the cloned shellcode&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Shellcode&lt;/h3&gt; &#xA;&lt;p&gt;The reflected shellcode works with ntdll API. It is generated from the included generation project &lt;code&gt;shellcode_template&lt;/code&gt;, curtesy of &lt;a href=&#34;https://github.com/rainerzufalldererste/windows_x64_shellcode_template&#34;&gt;https://github.com/rainerzufalldererste/windows_x64_shellcode_template&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Shellcode customization&lt;/h3&gt; &#xA;&lt;p&gt;To customize the shellcode with ease:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Edit the &lt;code&gt;shellcode_template&lt;/code&gt; function inside the &lt;code&gt;shellcode_template&lt;/code&gt; project, according to the instructions in &lt;a href=&#34;https://github.com/rainerzufalldererste/windows_x64_shellcode_template&#34;&gt;https://github.com/rainerzufalldererste/windows_x64_shellcode_template&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Compile it&lt;/li&gt; &#xA; &lt;li&gt;Crop the &lt;code&gt;shellcode_template&lt;/code&gt; function bytes using your faivorite PE parsing tool (eg IDA)&lt;/li&gt; &#xA; &lt;li&gt;Those bytes are position independet shellcode. place them in &lt;code&gt;DirtyVanity.cpp&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Execute DirtyVanity to watch them get Reflected&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>apple-oss-distributions/xnu</title>
    <updated>2022-12-16T01:30:13Z</updated>
    <id>tag:github.com,2022-12-16:/apple-oss-distributions/xnu</id>
    <link href="https://github.com/apple-oss-distributions/xnu" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;What is XNU?&lt;/h1&gt; &#xA;&lt;p&gt;XNU kernel is part of the Darwin operating system for use in macOS and iOS operating systems. XNU is an acronym for X is Not Unix. XNU is a hybrid kernel combining the Mach kernel developed at Carnegie Mellon University with components from FreeBSD and a C++ API for writing drivers called IOKit. XNU runs on x86_64 for both single processor and multi-processor configurations.&lt;/p&gt; &#xA;&lt;h1&gt;XNU Source Tree&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;config&lt;/code&gt; - configurations for exported apis for supported architecture and platform&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SETUP&lt;/code&gt; - Basic set of tools used for configuring the kernel, versioning and kextsymbol management.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;EXTERNAL_HEADERS&lt;/code&gt; - Headers sourced from other projects to avoid dependency cycles when building. These headers should be regularly synced when source is updated.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;libkern&lt;/code&gt; - C++ IOKit library code for handling of drivers and kexts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;libsa&lt;/code&gt; - kernel bootstrap code for startup&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;libsyscall&lt;/code&gt; - syscall library interface for userspace programs&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;libkdd&lt;/code&gt; - source for user library for parsing kernel data like kernel chunked data.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;makedefs&lt;/code&gt; - top level rules and defines for kernel build.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;osfmk&lt;/code&gt; - Mach kernel based subsystems&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pexpert&lt;/code&gt; - Platform specific code like interrupt handling, atomics etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;security&lt;/code&gt; - Mandatory Access Check policy interfaces and related implementation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bsd&lt;/code&gt; - BSD subsystems code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;tools&lt;/code&gt; - A set of utilities for testing, debugging and profiling kernel.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How to build XNU&lt;/h1&gt; &#xA;&lt;h2&gt;Building &lt;code&gt;DEVELOPMENT&lt;/code&gt; kernel&lt;/h2&gt; &#xA;&lt;p&gt;The xnu make system can build kernel based on &lt;code&gt;KERNEL_CONFIGS&lt;/code&gt; &amp;amp; &lt;code&gt;ARCH_CONFIGS&lt;/code&gt; variables as arguments. Here is the syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make SDKROOT=&amp;lt;sdkroot&amp;gt; ARCH_CONFIGS=&amp;lt;arch&amp;gt; KERNEL_CONFIGS=&amp;lt;variant&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Where:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&amp;lt;sdkroot&amp;gt;: path to macOS SDK on disk. (defaults to &lt;code&gt;/&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&amp;lt;variant&amp;gt;: can be &lt;code&gt;debug&lt;/code&gt;, &lt;code&gt;development&lt;/code&gt;, &lt;code&gt;release&lt;/code&gt;, &lt;code&gt;profile&lt;/code&gt; and configures compilation flags and asserts throughout kernel code.&lt;/li&gt; &#xA; &lt;li&gt;&amp;lt;arch&amp;gt; : can be valid arch to build for. (E.g. &lt;code&gt;X86_64&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To build a kernel for the same architecture as running OS, just type&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make&#xA;$ make SDKROOT=macosx.internal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, there is support for configuring architectures through &lt;code&gt;ARCH_CONFIGS&lt;/code&gt; and kernel configurations with &lt;code&gt;KERNEL_CONFIGS&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=DEVELOPMENT&#xA;$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=&#34;RELEASE DEVELOPMENT DEBUG&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;By default, architecture is set to the build machine architecture, and the default kernel config is set to build for DEVELOPMENT.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This will also create a bootable image, kernel.[config], and a kernel binary with symbols, kernel.[config].unstripped.&lt;/p&gt; &#xA;&lt;p&gt;To intall the kernel into a DSTROOT, use the &lt;code&gt;install_kernels&lt;/code&gt; target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make install_kernels DSTROOT=/tmp/xnu-dst&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hint: For a more satisfying kernel debugging experience, with access to all local variables and arguments, but without all the extra check of the DEBUG kernel, add something like: CFLAGS_DEVELOPMENTARM64=&#34;-O0 -g -DKERNEL_STACK_MULTIPLIER=2&#34; CXXFLAGS_DEVELOPMENTARM64=&#34;-O0 -g -DKERNEL_STACK_MULTIPLIER=2&#34; to your make command. Replace DEVELOPMENT and ARM64 with the appropriate build and platform.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;To build with RELEASE kernel configuration&lt;/p&gt; &lt;pre&gt;&lt;code&gt;make KERNEL_CONFIGS=RELEASE SDKROOT=/path/to/SDK&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building FAT kernel binary&lt;/h2&gt; &#xA;&lt;p&gt;Define architectures in your environment or when running a make command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make ARCH_CONFIGS=&#34;X86_64&#34; exporthdrs all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Other makefile options&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;$ make MAKEJOBS=-j8 # this will use 8 processes during the build. The default is 2x the number of active CPUS.&lt;/li&gt; &#xA; &lt;li&gt;$ make -j8 # the standard command-line option is also accepted&lt;/li&gt; &#xA; &lt;li&gt;$ make -w # trace recursive make invocations. Useful in combination with VERBOSE=YES&lt;/li&gt; &#xA; &lt;li&gt;$ make BUILD_LTO=0 # build without LLVM Link Time Optimization&lt;/li&gt; &#xA; &lt;li&gt;$ make BOUND_CHECKS=0 # disable -fbound-attributes for this build&lt;/li&gt; &#xA; &lt;li&gt;$ make REMOTEBUILD=user@remotehost # perform build on remote host&lt;/li&gt; &#xA; &lt;li&gt;$ make BUILD_JSON_COMPILATION_DATABASE=1 # Build Clang JSON Compilation Database&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The XNU build system can optionally output color-formatted build output. To enable this, you can either set the &lt;code&gt;XNU_LOGCOLORS&lt;/code&gt; environment variable to &lt;code&gt;y&lt;/code&gt;, or you can pass &lt;code&gt;LOGCOLORS=y&lt;/code&gt; to the make command.&lt;/p&gt; &#xA;&lt;h1&gt;Debug information formats&lt;/h1&gt; &#xA;&lt;p&gt;By default, a DWARF debug information repository is created during the install phase; this is a &#34;bundle&#34; named kernel.development.&amp;lt;variant&amp;gt;.dSYM To select the older STABS debug information format (where debug information is embedded in the kernel.development.unstripped image), set the BUILD_STABS environment variable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ export BUILD_STABS=1&#xA;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Building KernelCaches&lt;/h1&gt; &#xA;&lt;p&gt;To test the xnu kernel, you need to build a kernelcache that links the kexts and kernel together into a single bootable image. To build a kernelcache you can use the following mechanisms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Using automatic kernelcache generation with &lt;code&gt;kextd&lt;/code&gt;. The kextd daemon keeps watching for changing in &lt;code&gt;/System/Library/Extensions&lt;/code&gt; directory. So you can setup new kernel as&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ cp BUILD/obj/DEVELOPMENT/X86_64/kernel.development /System/Library/Kernels/&#xA;$ touch /System/Library/Extensions&#xA;$ ps -e | grep kextd&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Manually invoking &lt;code&gt;kextcache&lt;/code&gt; to build new kernelcache.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ kextcache -q -z -a x86_64 -l -n -c /var/tmp/kernelcache.test -K /var/tmp/kernel.test /System/Library/Extensions&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Running KernelCache on Target machine&lt;/h1&gt; &#xA;&lt;p&gt;The development kernel and iBoot supports configuring boot arguments so that we can safely boot into test kernel and, if things go wrong, safely fall back to previously used kernelcache. Following are the steps to get such a setup:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Create kernel cache using the kextcache command as &lt;code&gt;/kernelcache.test&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Copy exiting boot configurations to alternate file&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ cp /Library/Preferences/SystemConfiguration/com.apple.Boot.plist /next_boot.plist&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Update the kernelcache and boot-args for your setup&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ plutil -insert &#34;Kernel Cache&#34; -string &#34;kernelcache.test&#34; /next_boot.plist&#xA;$ plutil -replace &#34;Kernel Flags&#34; -string &#34;debug=0x144 -v kernelsuffix=test &#34; /next_boot.plist&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Copy the new config to &lt;code&gt;/Library/Preferences/SystemConfiguration/&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ cp /next_boot.plist /Library/Preferences/SystemConfiguration/boot.plist&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Bless the volume with new configs.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ sudo -n bless  --mount / --setBoot --nextonly --options &#34;config=boot&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;--nextonly&lt;/code&gt; flag specifies that use the &lt;code&gt;boot.plist&lt;/code&gt; configs only for one boot. So if the kernel panic&#39;s you can easily power reboot and recover back to original kernel.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Creating tags and cscope&lt;/h1&gt; &#xA;&lt;p&gt;Set up your build environment and from the top directory, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make tags     # this will build ctags and etags on a case-sensitive volume, only ctags on case-insensitive&#xA;$ make TAGS     # this will build etags&#xA;$ make cscope   # this will build cscope database&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;How to install a new header file from XNU&lt;/h1&gt; &#xA;&lt;p&gt;XNU installs header files at the following locations -&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a. $(DSTROOT)/System/Library/Frameworks/Kernel.framework/Headers&#xA;b. $(DSTROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeaders&#xA;c. $(DSTROOT)/usr/include/&#xA;d. $(DSTROOT)/usr/local/include/&#xA;e. $(DSTROOT)/System/DriverKit/usr/include/&#xA;f. $(DSTROOT)/System/Library/Frameworks/IOKit.framework/Headers&#xA;g. $(DSTROOT)/System/Library/Frameworks/IOKit.framework/PrivateHeaders&#xA;h. $(DSTROOT)/System/Library/Frameworks/System.framework/PrivateHeaders&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Kernel.framework&lt;/code&gt; is used by kernel extensions.&lt;br&gt; The &lt;code&gt;System.framework&lt;/code&gt;, &lt;code&gt;/usr/include&lt;/code&gt; and &lt;code&gt;/usr/local/include&lt;/code&gt; are used by user level applications. &lt;br&gt; &lt;code&gt;IOKit.framework&lt;/code&gt; is used by IOKit userspace clients. &lt;br&gt; &lt;code&gt;/System/DriverKit/usr/include&lt;/code&gt; is used by userspace drivers. &lt;br&gt; The header files in framework&#39;s &lt;code&gt;PrivateHeaders&lt;/code&gt; are only available for ** Apple Internal Development **.&lt;/p&gt; &#xA;&lt;p&gt;The directory containing the header file should have a Makefile that creates the list of files that should be installed at different locations. If you are adding the first header file in a directory, you will need to create Makefile similar to &lt;code&gt;xnu/bsd/sys/Makefile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Add your header file to the correct file list depending on where you want to install it. The default locations where the header files are installed from each file list are -&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a. `DATAFILES` : To make header file available in user level -&#xA;   `$(DSTROOT)/usr/include`&#xA;   `$(DSTROOT)/System/Library/Frameworks/System.framework/PrivateHeaders`&#xA;&#xA;b. `DRIVERKIT_DATAFILES` : To make header file available to DriverKit userspace drivers -&#xA;   `$(DSTROOT)/System/DriverKit/usr/include`&#xA;&#xA;c. `PRIVATE_DATAFILES` : To make header file available to Apple internal in&#xA;   user level -&#xA;   `$(DSTROOT)/System/Library/Frameworks/System.framework/PrivateHeaders`&#xA;&#xA;d. `EMBEDDED_PRIVATE_DATAFILES` : To make header file available in user&#xA;   level for macOS as `EXTRA_DATAFILES`, but Apple internal in user level&#xA;   for embedded OSes as `EXTRA_PRIVATE_DATAFILES` -&#xA;   `$(DSTROOT)/usr/include` (`EXTRA_DATAFILES`)&#xA;   `$(DSTROOT)/usr/local/include` (`EXTRA_PRIVATE_DATAFILES`)&#xA;&#xA;d. `KERNELFILES` : To make header file available in kernel level -&#xA;   `$(DSTROOT)/System/Library/Frameworks/Kernel.framework/Headers`&#xA;   `$(DSTROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeaders`&#xA;&#xA;e. `PRIVATE_KERNELFILES` : To make header file available to Apple internal&#xA;   for kernel extensions -&#xA;   `$(DSTROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeaders`&#xA;&#xA;f. `MODULEMAPFILES` : To make module map file available in user level -&#xA;   `$(DSTROOT)/usr/include`&#xA;&#xA;g. `PRIVATE_MODULEMAPFILES` : To make module map file available to Apple&#xA;   internal in user level -&#xA;   `$(DSTROOT)/usr/local/include`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Makefile combines the file lists mentioned above into different install lists which are used by build system to install the header files. There are two types of install lists: machine-dependent and machine-independent. These lists are indicated by the presence of &lt;code&gt;MD&lt;/code&gt; and &lt;code&gt;MI&lt;/code&gt; in the build setting, respectively. If your header is architecture-specific, then you should use a machine-dependent install list (e.g. &lt;code&gt;INSTALL_MD_LIST&lt;/code&gt;). If your header should be installed for all architectures, then you should use a machine-independent install list (e.g. &lt;code&gt;INSTALL_MI_LIST&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If the install list that you are interested does not exist, create it by adding the appropriate file lists. The default install lists, its member file lists and their default location are described below -&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a. `INSTALL_MI_LIST`, `INSTALL_MODULEMAP_MI_LIST` : Installs header and module map&#xA;   files to a location that is available to everyone in user level.&#xA;   Locations -&#xA;       $(DSTROOT)/usr/include&#xA;   Definition -&#xA;       INSTALL_MI_LIST = ${DATAFILES}&#xA;       INSTALL_MODULEMAP_MI_LIST = ${MODULEMAPFILES}&#xA;&#xA;b. `INSTALL_DRIVERKIT_MI_LIST` : Installs header file to a location that is&#xA;    available to DriverKit userspace drivers.&#xA;    Locations -&#xA;       $(DSTROOT)/System/DriverKit/usr/include&#xA;   Definition -&#xA;       INSTALL_DRIVERKIT_MI_LIST = ${DRIVERKIT_DATAFILES}&#xA;&#xA;c.  `INSTALL_MI_LCL_LIST`, `INSTALL_MODULEMAP_MI_LCL_LIST` : Installs header and&#xA;   module map files to a location that is available for Apple internal in user level.&#xA;   Locations -&#xA;       $(DSTROOT)/usr/local/include&#xA;   Definition -&#xA;       INSTALL_MI_LCL_LIST =&#xA;       INSTALL_MODULEMAP_MI_LCL_LIST = ${PRIVATE_MODULEMAPFILES}&#xA;&#xA;d. `INSTALL_IF_MI_LIST` : Installs header file to location that is available&#xA;   to everyone for IOKit userspace clients.&#xA;   Locations -&#xA;        $(DSTROOT)/System/Library/Frameworks/IOKit.framework/Headers&#xA;   Definition -&#xA;        INSTALL_IF_MI_LIST = ${DATAFILES}&#xA;&#xA;e. `INSTALL_IF_MI_LCL_LIST` : Installs header file to location that is&#xA;   available to Apple internal for IOKit userspace clients.&#xA;   Locations -&#xA;        $(DSTROOT)/System/Library/Frameworks/IOKit.framework/PrivateHeaders&#xA;   Definition -&#xA;        INSTALL_IF_MI_LCL_LIST = ${DATAFILES} ${PRIVATE_DATAFILES}&#xA;&#xA;f.  `INSTALL_SF_MI_LCL_LIST` : Installs header file to a location that is available&#xA;   for Apple internal in user level.&#xA;   Locations -&#xA;       $(DSTROOT)/System/Library/Frameworks/System.framework/PrivateHeaders&#xA;   Definition -&#xA;       INSTALL_SF_MI_LCL_LIST = ${DATAFILES} ${PRIVATE_DATAFILES}&#xA;&#xA;g. `INSTALL_KF_MI_LIST` : Installs header file to location that is available&#xA;   to everyone for kernel extensions.&#xA;   Locations -&#xA;        $(DSTROOT)/System/Library/Frameworks/Kernel.framework/Headers&#xA;   Definition -&#xA;        INSTALL_KF_MI_LIST = ${KERNELFILES}&#xA;&#xA;h. `INSTALL_KF_MI_LCL_LIST` : Installs header file to location that is&#xA;   available for Apple internal for kernel extensions.&#xA;   Locations -&#xA;        $(DSTROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeaders&#xA;   Definition -&#xA;        INSTALL_KF_MI_LCL_LIST = ${KERNELFILES} ${PRIVATE_KERNELFILES}&#xA;&#xA;i. `EXPORT_MI_LIST` : Exports header file to all of xnu (bsd/, osfmk/, etc.)&#xA;   for compilation only. Does not install anything into the SDK.&#xA;   Definition -&#xA;        EXPORT_MI_LIST = ${KERNELFILES} ${PRIVATE_KERNELFILES}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to install the header file in a sub-directory of the paths described in (1), specify the directory name using two variables &lt;code&gt;INSTALL_MI_DIR&lt;/code&gt; and &lt;code&gt;EXPORT_MI_DIR&lt;/code&gt; as follows -&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;INSTALL_MI_DIR = dirname&#xA;EXPORT_MI_DIR = dirname&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to install the module map file in a sub-directory, specify the directory name using the variable &lt;code&gt;INSTALL_MODULEMAP_MI_DIR&lt;/code&gt; as follows -&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;INSTALL_MODULEMAP_MI_DIR = dirname&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A single header file can exist at different locations using the steps mentioned above. However it might not be desirable to make all the code in the header file available at all the locations. For example, you want to export a function only to kernel level but not user level.&lt;/p&gt; &#xA;&lt;p&gt;You can use C language&#39;s pre-processor directive (#ifdef, #endif, #ifndef) to control the text generated before a header file is installed. The kernel only includes the code if the conditional macro is TRUE and strips out code for FALSE conditions from the header file.&lt;/p&gt; &#xA;&lt;p&gt;Some pre-defined macros and their descriptions are -&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a. `PRIVATE` : If defined, enclosed definitions are considered System&#xA;Private Interfaces. These are visible within xnu and&#xA;exposed in user/kernel headers installed within the AppleInternal&#xA;&#34;PrivateHeaders&#34; sections of the System and Kernel frameworks.&#xA;b. `KERNEL_PRIVATE` : If defined, enclosed code is available to all of xnu&#xA;kernel and Apple internal kernel extensions and omitted from user&#xA;headers.&#xA;c. `BSD_KERNEL_PRIVATE` : If defined, enclosed code is visible exclusively&#xA;within the xnu/bsd module.&#xA;d. `MACH_KERNEL_PRIVATE`: If defined, enclosed code is visible exclusively&#xA;within the xnu/osfmk module.&#xA;e. `XNU_KERNEL_PRIVATE`: If defined, enclosed code is visible exclusively&#xA;within xnu.&#xA;f. `KERNEL` :  If defined, enclosed code is available within xnu and kernel&#xA;   extensions and is not visible in user level header files.  Only the&#xA;   header files installed in following paths will have the code -&#xA;&#xA;        $(DSTROOT)/System/Library/Frameworks/Kernel.framework/Headers&#xA;        $(DSTROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeaders&#xA;g. `DRIVERKIT`: If defined, enclosed code is visible exclusively in the&#xA;DriverKit SDK headers used by userspace drivers.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Module map file name convention&lt;/h1&gt; &#xA;&lt;p&gt;In the simple case, a subdirectory of &lt;code&gt;usr/include&lt;/code&gt; or &lt;code&gt;usr/local/include&lt;/code&gt; can be represented by a standalone module. Where this is the case, set &lt;code&gt;INSTALL_MODULEMAP_MI_DIR&lt;/code&gt; to &lt;code&gt;INSTALL_MI_DIR&lt;/code&gt; and install a &lt;code&gt;module.modulemap&lt;/code&gt; file there. &lt;code&gt;module.modulemap&lt;/code&gt; is used even for private modules in &lt;code&gt;usr/local/include&lt;/code&gt;; &lt;code&gt;module.private.modulemap&lt;/code&gt; is not used. Caveat: in order to stay in the simple case, the module name needs to be exactly the same as the directory name. If that&#39;s not possible, then the following method will need to be applied.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;xnu&lt;/code&gt; contributes to the modules defined in CoreOSModuleMaps by installing module map files that are sourced from &lt;code&gt;usr/include/module.modulemap&lt;/code&gt; and &lt;code&gt;usr/local/include/module.modulemap&lt;/code&gt;. The naming convention for the &lt;code&gt;xnu&lt;/code&gt; module map files are as follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a. Ideally the module map file covers an entire directory. A module map&#xA;   file covering `usr/include/a/b/c` would be named `a_b_c.modulemap`.&#xA;   `usr/local/include/a/b/c` would be `a_b_c_private.modulemap`.&#xA;b. Some headers are special and require their own module. In that case,&#xA;   the module map file would be named after the module it defines.&#xA;   A module map file defining the module `One.Two.Three` would be named&#xA;   `one_two_three.modulemap`.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Conditional compilation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;xnu&lt;/code&gt; offers the following mechanisms for conditionally compiling code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a. *CPU Characteristics* If the code you are guarding has specific&#xA;characterstics that will vary only based on the CPU architecture being&#xA;targeted, use this option. Prefer checking for features of the&#xA;architecture (e.g. `__LP64__`, `__LITTLE_ENDIAN__`, etc.).&#xA;b. *New Features* If the code you are guarding, when taken together,&#xA;implements a feature, you should define a new feature in `config/MASTER`&#xA;and use the resulting `CONFIG` preprocessor token (e.g. for a feature&#xA;named `config_virtual_memory`, check for `#if CONFIG_VIRTUAL_MEMORY`).&#xA;This practice ensures that existing features may be brought to other&#xA;platforms by simply changing a feature switch.&#xA;c. *Existing Features* You can use existing features if your code is&#xA;strongly tied to them (e.g. use `SECURE_KERNEL` if your code implements&#xA;new functionality that is exclusively relevant to the trusted kernel and&#xA;updates the definition/understanding of what being a trusted kernel means).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is recommended that you avoid compiling based on the target platform. &lt;code&gt;xnu&lt;/code&gt; does not define the platform macros from &lt;code&gt;TargetConditionals.h&lt;/code&gt; (&lt;code&gt;TARGET_OS_OSX&lt;/code&gt;, &lt;code&gt;TARGET_OS_IOS&lt;/code&gt;, etc.).&lt;/p&gt; &#xA;&lt;h1&gt;Debugging xnu&lt;/h1&gt; &#xA;&lt;p&gt;By default, the kernel reboots in the event of a panic. This behavior can be overriden by the &lt;code&gt;debug&lt;/code&gt; boot-arg -- &lt;code&gt;debug=0x14e&lt;/code&gt; will cause a panic to wait for a debugger to attach. To boot a kernel so it can be debugged by an attached machine, override the &lt;code&gt;kdp_match_name&lt;/code&gt; boot-arg with the appropriate &lt;code&gt;ifconfig&lt;/code&gt; interface. Ethernet, Thunderbolt, and serial debugging are supported, depending on the hardware.&lt;/p&gt; &#xA;&lt;p&gt;Use LLDB to debug the kernel:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;; xcrun -sdk macosx lldb &amp;lt;path-to-unstripped-kernel&amp;gt;&#xA;(lldb) gdb-remote [&amp;lt;host-ip&amp;gt;:]&amp;lt;port&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The debug info for the kernel (dSYM) comes with a set of macros to support kernel debugging. To load these macros automatically when attaching to the kernel, add the following to &lt;code&gt;~/.lldbinit&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;settings set target.load-script-from-symbol-file true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;tools/lldbmacros&lt;/code&gt; contains the source for these commands. See the README in that directory for their usage, or use the built-in LLDB help with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(lldb) help showcurrentstacks&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>