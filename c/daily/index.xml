<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-17T01:31:55Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>avaneev/prvhash</title>
    <updated>2022-09-17T01:31:55Z</updated>
    <id>tag:github.com,2022-09-17:/avaneev/prvhash</id>
    <link href="https://github.com/avaneev/prvhash" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PRVHASH - Pseudo-Random-Value Hash. Hash functions, PRNG with unlimited period, randomness extractor. (Codename Gradilac/Градилак)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PRVHASH - Pseudo-Random-Value Hash&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;PRVHASH is a hash function that generates a &lt;a href=&#34;https://en.wikipedia.org/wiki/Pseudorandom_number_generator&#34;&gt;uniform pseudo-random number sequence&lt;/a&gt; derived from the message. PRVHASH is conceptually similar (in the sense of using a pseudo-random number sequence as a hash) to &lt;a href=&#34;https://en.wikipedia.org/wiki/SHA-3&#34;&gt;&lt;code&gt;keccak&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/RadioGat%C3%BAn&#34;&gt;&lt;code&gt;RadioGatun&lt;/code&gt;&lt;/a&gt; schemes, but is a completely different implementation of such concept. PRVHASH is both a &lt;a href=&#34;https://en.wikipedia.org/wiki/Randomness_extractor&#34;&gt;&#34;randomness extractor&#34;&lt;/a&gt; and an &#34;extendable-output function&#34; (XOF).&lt;/p&gt; &#xA;&lt;p&gt;PRVHASH can generate 64- to unlimited-bit hashes, yielding hashes of approximately equal quality independent of the chosen hash length. PRVHASH is based on 64-bit math. The use of the function beyond 1024-bit hashes is easily possible, but has to be statistically tested. For example, any 32-bit element extracted from 2048-, or 4096-bit resulting hash is as collision resistant as just a 32-bit hash. It is a fixed execution time hash function that depends only on message&#39;s length. A streamed hashing implementation is available.&lt;/p&gt; &#xA;&lt;p&gt;PRVHASH is solely based on the butterfly effect, inspired by &lt;a href=&#34;https://en.wikipedia.org/wiki/Linear_congruential_generator&#34;&gt;LCG&lt;/a&gt; pseudo-random number generators. The generated hashes have good avalanche properties. For best security, a random seed should be supplied to the hash function, but this is not a requirement. In practice, the &lt;code&gt;InitVec&lt;/code&gt; (instead of &lt;code&gt;UseSeed&lt;/code&gt;), and initial hash, can both be randomly seeded (see the suggestions in &lt;code&gt;prvhash64.h&lt;/code&gt;), adding useful initial entropy (&lt;code&gt;InitVec&lt;/code&gt; plus &lt;code&gt;Hash&lt;/code&gt; total bits of entropy).&lt;/p&gt; &#xA;&lt;p&gt;64-, 128-, 192-, 256-, 512-, and 1024-bit PRVHASH hashes pass all &lt;a href=&#34;https://github.com/rurban/smhasher&#34;&gt;SMHasher&lt;/a&gt; tests. Other hash lengths were not thoroughly tested, but extrapolations can be made. The author makes no cryptographic claims (neither positive nor negative) about PRVHASH-based constructs.&lt;/p&gt; &#xA;&lt;p&gt;PRVHASH core hash function can be used as a PRNG with an arbitrarily-chosen (practically unlimited) period, depending on the number of hashwords in the system.&lt;/p&gt; &#xA;&lt;p&gt;Please see the &lt;code&gt;prvhash64.h&lt;/code&gt; file for the details of the basic hash function implementation (the &lt;code&gt;prvhash.h&lt;/code&gt;, &lt;code&gt;prvhash4.h&lt;/code&gt;, &lt;code&gt;prvhash42.h&lt;/code&gt; are outdated versions). While this hash function is most likely irreversible, according to SAT solver-based testing, it does not feature a preimage resistance. This function should not be used in open systems, without a secret seed. Note that &lt;code&gt;64&lt;/code&gt; refers to core hash function&#39;s variable size.&lt;/p&gt; &#xA;&lt;p&gt;The default &lt;code&gt;prvhash64.h&lt;/code&gt;-based 64-bit hash of the string &lt;code&gt;The cat is out of the bag&lt;/code&gt; is &lt;code&gt;eb405f05cfc4ae1c&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A proposed short name for hashes created with &lt;code&gt;prvhash64.h&lt;/code&gt; is &lt;code&gt;PRH64-N&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the hash length in bits (e.g. &lt;code&gt;PRH64-256&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Minimal PRNG for Everyday Use&lt;/h2&gt; &#xA;&lt;p&gt;The core hash function can be easily integrated into your applications, to be used as an effective PRNG. The period of this minimal PRNG is at least 2&lt;sup&gt;159&lt;/sup&gt;. The initial parameters can be varied at will, and won&#39;t &#34;break&#34; the PRNG. Setting only the &lt;code&gt;Seed&lt;/code&gt; value guarantees a random start point within the whole PRNG period, with at least 2&lt;sup&gt;64&lt;/sup&gt; spacing. The code follows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &#34;prvhash_core.h&#34;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;&#xA;int main()&#xA;{&#xA;&#x9;uint64_t Seed = 0;&#xA;&#x9;uint64_t lcg = 0;&#xA;&#x9;uint64_t Hash = 0;&#xA;&#xA;&#x9;uint64_t v = 0;&#xA;&#x9;uint64_t i;&#xA;&#xA;&#x9;for( i = 0; i &amp;lt; ( 1ULL &amp;lt;&amp;lt; 28 ); i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;v = prvhash_core64( &amp;amp;Seed, &amp;amp;lcg, &amp;amp;Hash );&#xA;&#x9;}&#xA;&#xA;&#x9;printf( &#34;%llu\n&#34;, v );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that such minimal 1-hashword PRNG is most definitely not cryptographically-secure: its state can be solved by a SAT solver pretty fast; this applies to other arrangements (&#34;parallel&#34;, &#34;fused&#34;, multiple hashwords; with daisy-chaining being harder to solve). The known way to make PRNG considerably harder to solve for a SAT solver, with complexity corresponding to system&#39;s size, is to combine two adjacent PRNG outputs via XOR operation; this obviously has a speed impact and produces output with more than 1 solution (most probably, 2). This, however, does not measurably increase the probability of PRNG output overlap, which stays below 1/2&lt;sup&gt;sys_size_bits&lt;/sup&gt;; in tests, practically undetectable.&lt;/p&gt; &#xA;&lt;p&gt;So, the basic PRNG with some, currently not formally-proven, security is as follows (XOR two adjacent outputs to produce a single &#34;compressed&#34; PRNG output):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#x9;&#x9;v = prvhash_core64( &amp;amp;Seed, &amp;amp;lcg, &amp;amp;Hash );&#xA;&#x9;&#x9;v ^= prvhash_core64( &amp;amp;Seed, &amp;amp;lcg, &amp;amp;Hash );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A similar approach is to simply skip the next generated random number, but it is slightly less secure. It is likely that PRVHASH&#39;s k-equidistribution of separate outputs is implicitly secure.&lt;/p&gt; &#xA;&lt;h2&gt;TPDF Dithering&lt;/h2&gt; &#xA;&lt;p&gt;The core hash function can be used to implement a &#34;statistically-good&#34; and &#34;neutrally-sounding&#34; dithering noise for audio signals; for both floating-point to fixed-point, and bit-depth conversions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;uint64_t rv = prvhash_core64( &amp;amp;Seed, &amp;amp;lcg, &amp;amp;Hash );&#xA;double tpdf = ( (int64_t) (uint32_t) rv - (int64_t) ( rv &amp;gt;&amp;gt; 32 )) * 0x1p-32;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Floating-Point PRNG&lt;/h2&gt; &#xA;&lt;p&gt;The following expression can be used to convert 64-bit unsigned value to full-mantissa floating-point value, without a truncation bias:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;uint64_t rv = prvhash_core64( &amp;amp;Seed, &amp;amp;lcg, &amp;amp;Hash );&#xA;double v = ( rv &amp;gt;&amp;gt; ( 64 - 53 )) * 0x1p-53;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Gradilac PRNG (C++)&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;gradilac.h&lt;/code&gt; file includes the Gradilac C++ class which is a generalized templated implementation of PRVHASH PRNG that provides integer, single bit, floating-point, TPDF, Normal random number generation with a straight-forward front-end to specify PRVHASH system&#39;s properties. Supports on-the-go re-seeding, including re-seeding using sparse entropy (for CSPRNG uses). Does not require other PRVHASH header files.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;Gradilac&amp;lt; 316 &amp;gt;&lt;/code&gt; to match Mersenne Twister&#39;s PRNG period.&lt;/p&gt; &#xA;&lt;p&gt;Note that this class may not be as efficient for &#34;bulk&#34; random number generation as a custom-written code. Nevertheless, Gradilac PRNG class, with its 1.0 cycles/byte floating-point performance (at default template settings), is competitive among other C++ PRNGs.&lt;/p&gt; &#xA;&lt;h2&gt;PRVHASH64_64M&lt;/h2&gt; &#xA;&lt;p&gt;This is a minimized implementation of the &lt;code&gt;prvhash64&lt;/code&gt; hash function. Arguably, it&#39;s the smallest hash function in the world, that produces 64-bit hashes of this quality level. While this function does not provide a throughput that can be considered &#34;fast&#34;, due to its statistical properties it is practically fast for hash-maps and hash-tables.&lt;/p&gt; &#xA;&lt;h2&gt;Entropy PRNG&lt;/h2&gt; &#xA;&lt;p&gt;PRVHASH can be also used as an efficient general-purpose PRNG with an external entropy source injections (like how the &lt;code&gt;/dev/urandom&lt;/code&gt; works on Unix): this was tested, and works well when 8-bit true entropy injections are done inbetween 8 to 2048 generated random bytes (delay is also obtained via the entropy source). An example generator is implemented in the &lt;code&gt;prvrng.h&lt;/code&gt; file: simply call the &lt;code&gt;prvrng_test64p2()&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;prvrng_gen64p2()&lt;/code&gt;-based generator passes &lt;a href=&#34;http://pracrand.sourceforge.net/&#34;&gt;&lt;code&gt;PractRand&lt;/code&gt;&lt;/a&gt; 32 TB threshold with rare non-systematic &#34;unusual&#34; evaluations. Which suggests it&#39;s the working randomness extractor that can &#34;recycle&#34; entropy of any statistical quality, probably the first in the world.&lt;/p&gt; &#xA;&lt;p&gt;Note that due to the structure of the core hash function the probability of PRNG completely &#34;stopping&#34;, or &#34;stalling&#34;, or losing internal entropy, is absent.&lt;/p&gt; &#xA;&lt;p&gt;The core hash function, without external entropy injections, with any initial combination of &lt;code&gt;lcg&lt;/code&gt;, &lt;code&gt;Seed&lt;/code&gt;, and &lt;code&gt;Hash&lt;/code&gt; eventually converges into one of random number sub-sequences. These are mostly time-delayed versions of only a smaller set of unique sequences. There are structural limits in this PRNG system which can be reached if there is only a small number of hashwords in the system. PRNG will continously produce non-repeating random sequences given external entropy input, but their statistical quality on a larger frames will be limited by the size of &lt;code&gt;lcg&lt;/code&gt; and &lt;code&gt;Seed&lt;/code&gt; variables, and the number of hashwords in the system, and the combinatorial capacity of the external entropy. A way to increase the structural limit is to use the &#34;parallel&#34; PRNG arrangement demonstrated in the &lt;code&gt;prvhash64s.h&lt;/code&gt; file, which additionally increases the security exponentially. Also any non-constant entropy input usually increases the period of randomness, which, when extrapolated to hashing, means that the period increases by message&#39;s combinatorial capacity (or the number of various combinations of its bits). The maximal PRNG period&#39;s 2&lt;sup&gt;N&lt;/sup&gt; exponent is hard to approximate exactly, but in most tests it was equal to at least system&#39;s size in bits, minus the number of hashwords in the system, minus 1/4 of &lt;code&gt;lcg&lt;/code&gt; and &lt;code&gt;Seed&lt;/code&gt; variables&#39; size (e.g., &lt;code&gt;159&lt;/code&gt; for a minimal PRNG).&lt;/p&gt; &#xA;&lt;p&gt;Moreover, the PRVHASH systems can be freely daisy-chained by feeding their outputs to &lt;code&gt;Seed&lt;/code&gt;/&lt;code&gt;lcg&lt;/code&gt; inputs, adding some security firewalls, and increasing the PRNG period of the final output accordingly. Note that any external PRNG output can be inputted via either &lt;code&gt;Seed&lt;/code&gt;, &lt;code&gt;lcg&lt;/code&gt;, or both, yielding PRNG period exponent summation. For hashing and external unstructured entropy, only simultaneous input via &lt;code&gt;Seed&lt;/code&gt; and &lt;code&gt;lcg&lt;/code&gt; works in practice (period&#39;s exponent increase occurs as well).&lt;/p&gt; &#xA;&lt;p&gt;While &lt;code&gt;lcg&lt;/code&gt;, &lt;code&gt;Seed&lt;/code&gt;, and &lt;code&gt;Hash&lt;/code&gt; variables are best initialized with good entropy source (however, structurally, they can accept just about any entropy quality while only requiring an initial &#34;conditioning&#34;), the message can be sparsely-random: even an increasing counter can be considered as having a suitable sparse entropy.&lt;/p&gt; &#xA;&lt;h2&gt;Two-Bit PRNG&lt;/h2&gt; &#xA;&lt;p&gt;This is a &#34;just for fun&#34; example, but it passes 256 MB PractRand threshold. You CAN generate pseudo-random numbers by using 2-bit shuffles; moreover, you can input external entropy into the system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &#34;prvhash_core.h&#34;&#xA;#define PH_HASH_COUNT 42&#xA;&#xA;int main()&#xA;{&#xA;&#x9;uint8_t Seed = 0;&#xA;&#x9;uint8_t lcg = 0;&#xA;&#x9;uint8_t Hash[ PH_HASH_COUNT ] = { 0 };&#xA;&#x9;int HashPos = 0;&#xA;&#x9;int l;&#xA;&#xA;&#x9;for( l = 0; l &amp;lt; 256; l++ )&#xA;&#x9;{&#xA;&#x9;&#x9;uint8_t r = 0;&#xA;&#x9;&#x9;int k;&#xA;&#xA;&#x9;&#x9;for( k = 0; k &amp;lt; 4; k++ )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;r &amp;lt;&amp;lt;= 2;&#xA;&#x9;&#x9;&#x9;r |= prvhash_core2( &amp;amp;Seed, &amp;amp;lcg, Hash + HashPos );&#xA;&#xA;&#x9;&#x9;&#x9;HashPos++;&#xA;&#xA;&#x9;&#x9;&#x9;if( HashPos == PH_HASH_COUNT )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;HashPos = 0;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;if( l &amp;gt; PH_HASH_COUNT / 3 ) // Skip PRNG initialization.&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;printf( &#34;%4i &#34;, (int) r );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Streamed Hashing&lt;/h2&gt; &#xA;&lt;p&gt;The file &lt;code&gt;prvhash64s.h&lt;/code&gt; includes a relatively fast streamed hashing function which utilizes a &#34;parallel&#34; PRVHASH arrangement. Please take a look at the &lt;code&gt;prvhash64s_oneshot()&lt;/code&gt; function for usage example. The &lt;code&gt;prvhash64s&lt;/code&gt; offers an increased security and hashing speed.&lt;/p&gt; &#xA;&lt;p&gt;This function has an increased preimage resistance compared to the basic hash function implementation. Preimage resistance cannot be currently estimated exactly, but the hash length affects it exponentially. Also, preimage attack usually boils down to exchange of forged symbols to &#34;trash&#34; symbols (at any place of the data stream); substitutions usually end up as being quite random, possibly damaging to any compressed or otherwise structured file. Which means that data compression software and libraries should always check any left-over, &#34;unused&#34;, data beyond the valid compressed stream, for security reasons.&lt;/p&gt; &#xA;&lt;p&gt;Time complexity for preimage attack fluctuates greatly as preimage resistance likely has a random-logarithmic PDF of timing.&lt;/p&gt; &#xA;&lt;p&gt;Even though a formal proof is not yet available, the author assumes this hash function can compete with widely-used SHA2 and SHA3 families of hash functions while at the same time offering a considerably higher performance and scalability. When working in open systems, supplying a secret seed is not a requirement for this hash function.&lt;/p&gt; &#xA;&lt;p&gt;The performance (expressed in cycles/byte) of this hash function on various platforms can be evaluated at the &lt;a href=&#34;https://bench.cr.yp.to/results-hash.html&#34;&gt;ECRYPT/eBASH project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The default &lt;code&gt;prvhash64s.h&lt;/code&gt;-based 64-bit hash of the string &lt;code&gt;The cat is out of the bag&lt;/code&gt; is &lt;code&gt;2043ccf52ae2ca6f&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The default &lt;code&gt;prvhash64s.h&lt;/code&gt;-based 256-bit hash of the string &lt;code&gt;Only a toilet bowl does not leak&lt;/code&gt; is &lt;code&gt;b13683799b840002689a1a42d93c826c25cc2d1f1bc1e48dcd005aa566a47ad8&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The default &lt;code&gt;prvhash64s.h&lt;/code&gt;-based 256-bit hash of the string &lt;code&gt;Only a toilet bowl does not leaj&lt;/code&gt; is &lt;code&gt;d4534a922fd4f15ae8c6cc637006d1f33f655b06d60007a226d350e87e866250&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This demonstrates the &lt;a href=&#34;https://en.wikipedia.org/wiki/Avalanche_effect&#34;&gt;Avalanche effect&lt;/a&gt;. On a set of 216553 English words, pair-wise hash comparisons give average 50.0% difference in resulting hash bits, which fully satisfies the strict avalanche criterion.&lt;/p&gt; &#xA;&lt;p&gt;This streamed hash function produces hash values that are different to the &lt;code&gt;prvhash64&lt;/code&gt; hash function. It is incorrect to use both of these hash function implementations on the same data set. While &lt;code&gt;prvhash64&lt;/code&gt; can be used as a hash for hash-tables and in-memory data blocks, &lt;code&gt;prvhash64s&lt;/code&gt; can be used to create hashes of large data blocks like files, in streamed mode.&lt;/p&gt; &#xA;&lt;p&gt;A proposed short name for hashes created with &lt;code&gt;prvhash64s.h&lt;/code&gt; is &lt;code&gt;PRH64S-N&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the hash length in bits (e.g. &lt;code&gt;PRH64S-256&lt;/code&gt;). Or simply, &lt;code&gt;SH4-N&lt;/code&gt;, &lt;code&gt;Secure Hash 4&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;Here is the author&#39;s vision on how the core hash function works. In actuality, coming up with this solution was accompanied by a lot of trial and error. It was especially hard to find a better &#34;hashing finalization&#34; solution.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Seed ^= msgw; lcg ^= msgw; // Mix in external entropy (or daisy-chain).&#xA;&#xA;Seed *= lcg * 2 + 1; // Multiply random by random, without multiply by zero.&#xA;const uint64_t rs = Seed &amp;gt;&amp;gt; 32 | Seed &amp;lt;&amp;lt; 32; // Produce halves-swapped copy.&#xA;Hash += rs + 0xAAAAAAAAAAAAAAAA; // Accumulate to hash, add raw entropy (self-start).&#xA;lcg += Seed + 0x5555555555555555; // Output-bound entropy accumulation, add raw entropy.&#xA;Seed ^= Hash; // Mix new seed value with hash. Entropy feedback.&#xA;const uint64_t out = lcg ^ rs; // Produce &#34;compressed&#34; output.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This function can be arbitrarily scaled to any even-sized variables: 2-, 4-, 8-, 16-, 32-, 64-bit variable sizes were tested, with similar statistical results. Since mathematical structure of the function does not depend on the variables&#39; size, statistical analysis can be performed using smaller variable sizes, with the results being extrapolatable to larger variable sizes, with a high probability (the function is invariant to the variable size). Also note that the &lt;code&gt;0xAAAA...&lt;/code&gt; constant is not an arbitrary constant since it should be produced algorithmically by replicating the &lt;code&gt;10&lt;/code&gt; bit-pairs, to match the variable size; it represents the &#34;raw entropy bit-train&#34;. The same applies to the &lt;code&gt;0x5555...&lt;/code&gt; constant. An essential property of these bit-trains is that they are uncorrelated to any uniformly-random bit-sequences, at all times. Practically, &lt;code&gt;10&lt;/code&gt; and &lt;code&gt;01&lt;/code&gt; bit-pairs can be also used as constants, without replication, but this does not provide conclusively better results for PRNG, and does not work well for hashing; also, self-starting period becomes longer. A conceptual aspect of replicated bit-pairs is that they represent the simplest maximum-entropy number (bit-pair is a minimal sequence that can exhibit entropy, with replication count bound to the state variable size). While &#34;magic numbers&#34; can be used instead of these bit-trains (at least for PRNG), they do not posses the property of being simplest.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s important to point out that the presence of the &lt;code&gt;0xAAAA...&lt;/code&gt; and &lt;code&gt;0x5555...&lt;/code&gt; constants logically assure that the &lt;code&gt;Seed&lt;/code&gt; and &lt;code&gt;lcg&lt;/code&gt; variables quickly recover from the &#34;zero-state&#34;. Beside that, these constants logically prohibit synchronous control over &lt;code&gt;Seed&lt;/code&gt; and &lt;code&gt;lcg&lt;/code&gt; variables: different bits of the input entropy will reach these variables. When the system starts from the &#34;zero-state&#34;, with many hashwords in the system, it is practically impossible to find a preimage (including a repetitious one) that stalls the system, and thus it is impossible to perform a multi-collision attack. However, since this risk cannot be estimated exactly, the &lt;code&gt;prvhash64s&lt;/code&gt; hash function adds a message length value to the end of the data stream.&lt;/p&gt; &#xA;&lt;p&gt;How does it work? First of all, this PRNG system, represented by the core hash function, does not work with numbers in a common sense: it works with &lt;a href=&#34;https://en.wikipedia.org/wiki/Entropy_(information_theory)&#34;&gt;entropy&lt;/a&gt;, or random sequences of bits. The current &#34;expression&#34; of system&#39;s overall internal entropy - the &lt;code&gt;Seed&lt;/code&gt; - gets multiplied (&#34;smeared&#34;) by a supporting, output-bound variable - &lt;code&gt;lcg&lt;/code&gt;, - which is also a random value, transformed in an LCG-alike manner. As a result, a new random value is produced which represents two independent random variables (in lower and higher parts of the register), a sort of &#34;entropy stream sub-division&#34; happens. This result is then halves-swapped, and is accumulated in the &lt;code&gt;Hash&lt;/code&gt; together with the &lt;code&gt;10&lt;/code&gt; bit-train which adds the &#34;raw entropy&#34;, allowing the system to be self-starting. The original multiplication result is accumulated in the &lt;code&gt;lcg&lt;/code&gt; variable. The &lt;code&gt;Seed&lt;/code&gt; is then updated with the hashword produced on previous rounds. The reason the message&#39;s entropy (which may be sparse or non-random) does not destabilize the system is because the message becomes hidden in the internal entropy (alike to a cryptographic one-time-pad); message&#39;s distribution becomes unimportant, and system&#39;s state remains statistically continuous. Both accumulations - of the halves-swapped and the original result of multiplication - produce a uniformly-distributed value in the corresponding variables; a sort of &#34;de-sub-division&#34; happens in these.&lt;/p&gt; &#xA;&lt;p&gt;The two instructions - &lt;code&gt;Seed *= lcg * 2 + 1&lt;/code&gt;, &lt;code&gt;lcg += Seed&lt;/code&gt; - represent an &#34;ideal&#34; bit-shuffler: this construct represents a &#34;bivariable shuffler&#34; which transforms the input &lt;code&gt;lcg&lt;/code&gt; and &lt;code&gt;Seed&lt;/code&gt; variables into another pair of variables with 50% bit difference relative to input, and without collisions. The whole core hash function, however, uses a more complex mixing which produces a hash value: the pair composed of the hash value and either a new &lt;code&gt;lcg&lt;/code&gt; or a new &lt;code&gt;Seed&lt;/code&gt; value also produces no input-to-output collisions. Thus it can be said that the system does not lose any input entropy. In 4-dimensional analysis, when &lt;code&gt;Seed&lt;/code&gt;, &lt;code&gt;lcg&lt;/code&gt;, &lt;code&gt;Hash&lt;/code&gt;, and &lt;code&gt;msgw&lt;/code&gt; values are scanned and transformed into subsequent &lt;code&gt;Seed&lt;/code&gt;, &lt;code&gt;lcg&lt;/code&gt;, and &lt;code&gt;Hash&lt;/code&gt; triplets, this system does not exhibit local state change-related collisions due to external entropy input (all possible input &lt;code&gt;msgw&lt;/code&gt; values map to subsequent triplets uniquely). However, with a small variable size (8-bit) and a large output hash size, a sparse entropy input has some probability of &#34;re-sychronization&#34; event happening, leading to local collisions. With 16-bit variables, or even 8-bit parallel-2 arrangement (with the local state having 40-bit size instead of 24-bit), probability of such event is negligible. While non-parallel hashing may even start from the &#34;zero-state&#34;, for reliable hashing the state after 5 &#34;conditioning&#34; rounds should be used.&lt;/p&gt; &#xA;&lt;p&gt;Another important aspect of this system, especially from the cryptography standpoint, is the entropy input to output latency. The base latency for state-to-state transition is equal to 1 (2 for &#34;parallel&#34; arrangements); and at the same time, 1 in hash-to-hash direction: this means that PRVHASH additionally requires a full pass through the hashword array, for the entropy to propagate, before using its output. However, hashing also requires a pass to the end of the hashword array if message&#39;s length is shorter than the output hash, to &#34;mix in&#34; the initial hash value. When there is only 1 hashword in use, there is no hashword array-related delay, and thus the entropy propagation is only subject to the base latency. The essence of these &#34;latencies&#34; is that additional rounds are needed for the system to get rid of a statistical traces of the input entropy. Note that the &#34;parallel&#34; arrangement increases shuffling quality. However, this increase is relative to the state variable size: for example, 8-bit parallel-2 arrangement with 8-bit input is equivalent to 16-bit non-parallel arrangement with 16-bit input. So, it is possible to perform hashing with 8-bit state variables if parallel-2 round is done per 1 input byte. The way &#34;parallel&#34; structure works is equivalent to shuffling all entropy inputs in a round together (input 1 is shuffled into a hash value which is then shuffled with input 2 into a hash value, etc). The &#34;parallel&#34; arrangement may raise a question whether or not it provides a target collision resistance as it seemingly &#34;compresses&#34; several inputs into a single local hashword: without doubt it does provide target collision resistance since &lt;code&gt;Seed&lt;/code&gt; and &lt;code&gt;lcg&lt;/code&gt; variables are a part of the system, and their presence in the &#34;parallel&#34; arrangement increases the overall PRNG period of the system and thus its combinatorial capacity.&lt;/p&gt; &#xA;&lt;p&gt;Without external entropy (message) injections, the function can run for a prolonged time, generating pseudo-entropy, in extendable-output PRNG mode. When the external entropy (message) is introduced, the function &#34;shifts&#34; into an unrelated state unpredictably. So, it can be said that the function &#34;jumps&#34; within a space of a huge number of pseudo-random sub-sequences. Hash length affects the size of this &#34;space of sub-sequences&#34;, permitting the function to produce quality hashes for any required hash length. Statistically, these &#34;jumps&#34; are close to uniformly-random repositioning: each simultaneous augmentation of &lt;code&gt;Seed&lt;/code&gt; and &lt;code&gt;lcg&lt;/code&gt; corresponds to a new random position, with a spread over the whole PRNG period. The actual performace is more complicated as this PRNG system is able to converge into unrelated random number sequences of varying lengths, so the &#34;jump&#34; changes both the position and the &#34;index&#34; of sub-sequence. This property of PRVHASH assures that different initial states of its &lt;code&gt;Seed&lt;/code&gt; state variable (or &lt;code&gt;lcg&lt;/code&gt;, which is mostly equivalent at initialization stage) produce practically unrelated random number sequences, permitting to use PRVHASH for PRNG-based simulations.&lt;/p&gt; &#xA;&lt;p&gt;In essence, the hash function generates a continuous pseudo-random number sequence, and returns the final part of the sequence as a result. The message acts as a &#34;pathway&#34; to this final part. So, the random sequence of numbers can be &#34;programmed&#34; to produce a necessary outcome. However, as this PRNG does not expose its momentary internal state, such &#34;programming&#34; is hardly possible to perform for an attacker, even if the entropy input channel is exposed: consider the &lt;code&gt;(A^C)*(B^C)&lt;/code&gt; equation; an adversary can control &lt;code&gt;C&lt;/code&gt;, but does not know the values of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;; thus this adversary cannot predict the outcome. Beside that, as the core hash function naturally eliminates the bias from the external entropy of any statistical quality and frequency, its control may be fruitless. Note that to reduce such &#34;control risks&#34;, the entropy input should use as fewer bits as possible, like demonstrated in the &lt;code&gt;prvrng.h&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;P.S. The reason the InitVec in the &lt;code&gt;prvhash64&lt;/code&gt; hash function has the value quality constraints, and an initial non-zero state, is that otherwise the function would require 5 preliminary &#34;conditioning&#34; rounds (core hash function calls) to neutralize any oddities (including zero values) in InitVec; that would reduce the performance of the hash function dramatically, for hash-table uses. Note that the &lt;code&gt;prvhash64s&lt;/code&gt; function starts from the &#34;full zero&#34; state and then performs acceptably.&lt;/p&gt; &#xA;&lt;h2&gt;Hashing Method&#39;s Philosophy&lt;/h2&gt; &#xA;&lt;p&gt;Any external entropy (message) that enters this PRNG system acts as a high-frequency and high-quality re-seeding which changes the random number generator&#39;s &#34;position&#34; within the PRNG period, randomly. In practice, this means that two messages that are different in even 1 bit, at any place, produce &#34;final&#34; random number sequences, and thus hashes, that are completely unrelated to each other. This also means that any smaller part of the resulting hash can be used as a complete hash. Since the hash length affects the PRNG period (and thus the combinatorial capacity) of the system, the same logic applies to hashes of any length while meeting collision resistance specifications for all lengths.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, the hashing method can be viewed from the standpoint of classic bit-mixers/shufflers: the hashword array can be seen as a &#34;working buffer&#34; whose state is passed back into the &#34;bivariable shuffler&#34; continuously, and the new shuffled values stored in this working buffer for the next pass.&lt;/p&gt; &#xA;&lt;h2&gt;PRNG Period Assessment&lt;/h2&gt; &#xA;&lt;p&gt;The following &#34;minimal&#34; implementation of PractRand class can be used to independently assess randomness period properties of PRVHASH. By varying the &lt;code&gt;PH_HASH_COUNT&lt;/code&gt; and &lt;code&gt;PH_PAR_COUNT&lt;/code&gt; values it is possible to test various PRNG system sizes. By adjusting other values it is possible to test PRVHASH scalability across different state variable sizes (PractRand class and PRNG output size should be matched, as PractRand test results depend on PRNG output size). PractRand should be run with the &lt;code&gt;-tlmin 64KB&lt;/code&gt; parameter, to evaluate changes to the constants quicker. Note that both &lt;code&gt;PH_HASH_COUNT&lt;/code&gt; and &lt;code&gt;PH_PAR_COUNT&lt;/code&gt; affect the PRNG period exponent not exactly linearly for small variable sizes: there is a saturation factor present for small variable sizes; after some point the period increase is non-linear due to small shuffling space. Shuffling space can be increased considerably with a &#34;parallel&#34; arrangement. Depending on the initial seed value, the period may fluctuate. The commented out &lt;code&gt;Ctr++...&lt;/code&gt; instructions can be uncommented to check the period increase due to sparse entropy input. You may also notice the &lt;code&gt;^=h&lt;/code&gt; instructions: PRVHASH supports feedback onto itself (it&#39;s like hashing its own output). This operation, which can be applied to any parallel element, maximizes the achieved PRNG period.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &#34;prvhash_core.h&#34;&#xA;#include &amp;lt;string.h&amp;gt;&#xA;&#xA;#define PH_PAR_COUNT 1 // PRVHASH parallelism.&#xA;#define PH_HASH_COUNT 4 // Hashword count (any positive number).&#xA;#define PH_STATE_TYPE uint8_t // State variable&#39;s physical type.&#xA;#define PH_FN prvhash_core4 // Core hash function name.&#xA;#define PH_BITS 4 // State variable&#39;s size in bits.&#xA;#define PH_RAW_BITS 8 // Raw output bits.&#xA;#define PH_RAW_ROUNDS ( PH_RAW_BITS / PH_BITS ) // Rounds per raw output.&#xA;&#xA;class DummyRNG : public PractRand::RNGs::vRNG8 {&#xA;public:&#xA;    PH_STATE_TYPE Seed[ PH_PAR_COUNT ];&#xA;    PH_STATE_TYPE lcg[ PH_PAR_COUNT ];&#xA;    PH_STATE_TYPE Hash[ PH_HASH_COUNT ];&#xA;    int HashPos;&#xA;&#xA;    DummyRNG() {&#xA;        memset( Seed, 0, sizeof( Seed ));&#xA;        memset( lcg, 0, sizeof( lcg ));&#xA;        memset( Hash, 0, sizeof( Hash ));&#xA;        HashPos = 0;&#xA;&#xA;        // Initialize.&#xA;&#xA;        int k, j;&#xA;&#xA;        for( k = 0; k &amp;lt; PRVHASH_INIT_COUNT; k++ )&#xA;        {&#xA;            for( j = 0; j &amp;lt; PH_PAR_COUNT; j++ )&#xA;            {&#xA;                PH_FN( Seed + j, lcg + j, Hash + HashPos );&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    Uint8 raw8() {&#xA;        uint64_t OutValue = 0;&#xA;        int k, j;&#xA;&#xA;        for( k = 0; k &amp;lt; PH_RAW_ROUNDS; k++ )&#xA;        {&#xA;//            Ctr++;&#xA;//            Seed[ 0 ] ^= ( Ctr ^ ( Ctr &amp;gt;&amp;gt; 4 )) &amp;amp; 15;&#xA;//            lcg[ 0 ] ^= ( Ctr ^ ( Ctr &amp;gt;&amp;gt; 4 )) &amp;amp; 15;&#xA;&#xA;            uint64_t h = 0;&#xA;&#xA;            for( j = 0; j &amp;lt; PH_PAR_COUNT; j++ )&#xA;            {&#xA;                h = PH_FN( Seed + j, lcg + j, Hash + HashPos );&#xA;            }&#xA;&#xA;//            Seed[ 0 ] ^= h;&#xA;//            lcg[ 0 ] ^= h;&#xA;&#xA;            if( PH_BITS &amp;lt; sizeof( uint64_t )) OutValue &amp;lt;&amp;lt;= PH_BITS;&#xA;            OutValue |= h;&#xA;&#xA;            if( ++HashPos == PH_HASH_COUNT )&#xA;            {&#xA;                HashPos = 0;&#xA;            }&#xA;        }&#xA;&#xA;        return( OutValue );&#xA;    }&#xA;&#xA;    void walk_state(PractRand::StateWalkingObject *walker) {}&#xA;    void seed(Uint64 sv) { Seed[ 0 ] ^= sv; }&#xA;    std::string get_name() const { return &#34;PRVHASH&#34;; }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;PRVHASH Cryptanalysis Basics&lt;/h2&gt; &#xA;&lt;p&gt;When the system state is not known, when PRVHASH acts as a black-box, one has to consider core hash function&#39;s statistical properties. All internal variables - &lt;code&gt;Seed&lt;/code&gt;, &lt;code&gt;lcg&lt;/code&gt;, and &lt;code&gt;Hash&lt;/code&gt; - are random: they are uncorrelated to each other at all times, and are also wholly-unequal during the PRNG period (they are not just time-delayed versions of each other). Moreover, as can be assured with PractRand, all of these variables can be used as random number generators (with a lower period, though); they can even be interleaved after each core function call.&lt;/p&gt; &#xA;&lt;p&gt;When the message enters the system via &lt;code&gt;Seed ^= msgw&lt;/code&gt; and &lt;code&gt;lcg ^= msgw&lt;/code&gt; instructions, this works like mixing a message with an one-time-pad used in cryptography. This operation completely hides the message in system&#39;s entropy, while both &lt;code&gt;Seed&lt;/code&gt; and &lt;code&gt;lcg&lt;/code&gt; act as &#34;carriers&#34; that &#34;smear&#34; the input message via subsequent multiplication. Beside that, the output of PRVHASH uses the mix of two variables: statistically, this means mixing of two unrelated random variables, with such summary output never appearing in system&#39;s state. It is worth noting the &lt;code&gt;lcg ^ rs&lt;/code&gt; expression: the &lt;code&gt;rs&lt;/code&gt; variable is composed of two halves, both of them practically being independent PRNG outputs, with smaller periods. This additionally complicates system&#39;s reversal.&lt;/p&gt; &#xA;&lt;h2&gt;Fused PRNG&lt;/h2&gt; &#xA;&lt;p&gt;While this &#34;fused-3&#34; arrangement is currently not used in the hash function implementations, it is also working fine with the core hash function. For example, while the &#34;minimal PRNG&#34; described earlier has &lt;code&gt;0.90&lt;/code&gt; cycles/byte performance, the &#34;fused&#34; arrangement has a PRNG performance of &lt;code&gt;0.35&lt;/code&gt; cycles/byte, with a possibility of further scaling using AVX-512 instructions. Note that the number of &#34;fused&#34; elements should not be a multiple of hashword array size, otherwise PRNG stalls.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &#34;prvhash_core.h&#34;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;&#xA;int main()&#xA;{&#xA;&#x9;uint64_t Seed = 0;&#xA;&#x9;uint64_t lcg = 0;&#xA;&#x9;uint64_t Hash = 0;&#xA;&#x9;uint64_t Seed2 = 0;&#xA;&#x9;uint64_t lcg2 = 0;&#xA;&#x9;uint64_t Hash2 = 0;&#xA;&#x9;uint64_t Seed3 = 0;&#xA;&#x9;uint64_t lcg3 = 0;&#xA;&#x9;uint64_t Hash3 = 0;&#xA;&#x9;uint64_t Hash4 = 0;&#xA;&#xA;&#x9;uint64_t v = 0;&#xA;&#x9;uint64_t v2 = 0;&#xA;&#x9;uint64_t v3 = 0;&#xA;&#xA;&#x9;uint64_t i;&#xA;&#xA;&#x9;for( i = 0; i &amp;lt; ( 1ULL &amp;lt;&amp;lt; 27 ); i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;v = prvhash_core64( &amp;amp;Seed, &amp;amp;lcg, &amp;amp;Hash );&#xA;&#x9;&#x9;v2 = prvhash_core64( &amp;amp;Seed2, &amp;amp;lcg2, &amp;amp;Hash2 );&#xA;&#x9;&#x9;v3 = prvhash_core64( &amp;amp;Seed3, &amp;amp;lcg3, &amp;amp;Hash3 );&#xA;&#xA;&#x9;&#x9;uint64_t t = Hash;&#xA;&#x9;&#x9;Hash = Hash2;&#xA;&#x9;&#x9;Hash2 = Hash3;&#xA;&#x9;&#x9;Hash3 = Hash4;&#xA;&#x9;&#x9;Hash4 = t;&#xA;&#x9;}&#xA;&#xA;&#x9;printf( &#34;%llu %llu %llu\n&#34;, v, v2, v3 );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;PRVHASH16&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;prvhash16&lt;/code&gt; demonstrates the quality of the core hash function. While the state variables are 16-bit, they are enough to perform hashing: this hash function passes all SMHasher tests, like the &lt;code&gt;prvhash64&lt;/code&gt; function does, for any hash length. This function is very slow, and is provided for demonstration purposes, to assure that the core hash function works in principle, independent of state variable size. This hash function variant demonstrates that PRVHASH&#39;s method does not rely on bit-shuffling alone (shuffles are purely local), but is genuinely based on PRNG position &#34;jumps&#34;.&lt;/p&gt; &#xA;&lt;h2&gt;TANGO642 (tango-six-forty-two)&lt;/h2&gt; &#xA;&lt;p&gt;This is an efficient implementation of a PRVHASH PRNG-based streamed XOR function. Since no cryptanalysis nor certification of this function were performed yet, it cannot be called a &#34;cipher&#34;, but rather a cipher-alike random number generator.&lt;/p&gt; &#xA;&lt;p&gt;The performance (expressed in cycles/byte) of this function on various platforms can be evaluated at the &lt;a href=&#34;https://bench.cr.yp.to/results-stream.html&#34;&gt;ECRYPT/eBASC project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Other Thoughts&lt;/h2&gt; &#xA;&lt;p&gt;PRVHASH, being scalable, potentially allows one to apply &#34;infinite&#34; state variable size in its system, at least in mathematical analysis. This reasoning makes PRVHASH comparable to PI in its reach of &#34;infinite&#34; bit-sequence length. Moreover, this also opens up a notion of &#34;infinite frequency&#34; (arising from Fourier analysis of &#34;infinite&#34; bit-sequence) and thus, &#34;infinite energy&#34; (if integrated). Note that PRVHASH does not require any &#34;magic numbers&#34; to function, it is completely algorithmic.&lt;/p&gt; &#xA;&lt;p&gt;The mathematics offers an interesting understanding. Take in your mind a moment before the &#34;Big Bang&#34;. Did mathematical rules exist at that moment? Of course, they did, otherwise there would be no equation-definable &#34;Big Bang&#34;. The span of existence of mathematical rules cannot be estimated, so it is safe to assume they existed for an eternity. On top of that, PRVHASH practically proves that entropy can self-start from zero-, or &#34;raw&#34; state, or &#34;nothing&#34;, if mathematical rules exist prior to that.&lt;/p&gt; &#xA;&lt;p&gt;I, as the author of PRVHASH, would like to point out at some long-standing misconception in relating &#34;combinatorics&#34; to &#34;random numbers&#34;. Historically, cryptography was based on a concept of permutations, mixed with some sort of mathematical operations: most hashes and ciphers use such &#34;constructs&#34;. However, when viewing a system as having some &#34;combinatorial capacity&#34; or the number of bit combinations a given system may have, and combining this understanding with &#34;random permutations&#34;, it may give a false understanding that &#34;uniform randomness&#34; may generate any combination within the limits of &#34;combinatorial capacity&#34;, with some probability. In fact, &#34;uniform randomness&#34; auto-limits the &#34;sparseness&#34; of random bit-sequences it generates since a suitably long, but &#34;too sparse&#34; bit-sequence cannot be statistically called uniformly-random. Thus, &#34;combinatorial capacity&#34; of a system, when applied to random number generation, transforms into a notion of ability of a system to generate independent uniformly-random number sequences. Which means that two different initial states of a PRNG system may refer to different &#34;isolated&#34; PRNG sequences. This is what happens in PRVHASH: on entropy input the system may &#34;jump&#34; or &#34;converge&#34; into an unrelated random sub-sequence. Moreover, with small variable sizes, PRVHASH can produce a train of &lt;code&gt;0&lt;/code&gt;s longer than the bit-size of the system.&lt;/p&gt; &#xA;&lt;p&gt;On the Birthday Paradox vs hash collision estimates: while the Birthday Paradox is a good &#34;down-to-earth&#34; model for collision estimation, it may be an &#34;approach from a wrong side&#34;. When hash values are calculated systemically, it is expected that each new hash value does not break &#34;uniform distribution&#34; of the set of previously produced hash values. This makes the problem of hash collision estimation closer to value collision estimation of PRNG output.&lt;/p&gt; &#xA;&lt;p&gt;An open question remains: whether one should talk about &#34;uniform distribution of values&#34; or a &#34;time- and rhythm- dependent collision minimization problem&#34; when analyzing PRNG&#39;s uniformness. Incidentally, a set of rhythmic (repeating) processes whose timings are co-primes, spectrally produce the least number of modes thus producing a flatter, more uniform, spectrum. Rhythm-dependent collision minimization also touches ability of a single random number generator to create random sequences in many dimensions (known as k-equidistribution) just by selecting any sequence of its outputs.&lt;/p&gt; &#xA;&lt;p&gt;(...&lt;code&gt;10&lt;/code&gt; in binary is &lt;code&gt;2&lt;/code&gt; in decimal, &lt;code&gt;1010&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;, &lt;code&gt;101010&lt;/code&gt; is &lt;code&gt;42&lt;/code&gt;, &lt;code&gt;01&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;0101&lt;/code&gt; is &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;010101&lt;/code&gt; is &lt;code&gt;21&lt;/code&gt;...)&lt;/p&gt; &#xA;&lt;p&gt;The author has no concrete theory why PRVHASH PRNG works, especially its 2-bit variant (which is a very close empirical proof that mathematics has entropy processes happening under the hood). The closest mathematical construct found by the author is a sinewave oscillator (see below). Also, series related to &lt;code&gt;PI&lt;/code&gt;, &lt;code&gt;sin(x)&lt;/code&gt;, and &lt;code&gt;sin(x)/x&lt;/code&gt; may be a candidates for explanation. Author&#39;s empirical goals when developing PRVHASH were: no loss of entropy in a system, easy scalability, self-start without any special initialization and from any initial state, state variable size invariance, not-stalling on various entropy input.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Seed &amp;gt;&amp;gt; 32 | Seed &amp;lt;&amp;lt; 32&lt;/code&gt; operation used in PRVHASH may look like it was derived from the middle-square method. This is purely a coincidence. During PRVHASH development, in many cases a better option was bit-reversal (and probably still is), and not such register &#34;halves-swapping&#34;, but due to performance considerations (absence of such processor instruction), bit-reversal was not used. Practically, both are equivalent (see e.g. 2-bit PRVHASH), and exhibit difference in hashing mainly.&lt;/p&gt; &#xA;&lt;p&gt;During the course of PRVHASH development, the author has found that the simplest low-frequency sine-wave oscillator can be used as a pseudo-random number generator, if its mantissa is treated as an integer number. This means that every point on a sinusoid has properties of a random bit-sequence.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;math.h&amp;gt;&#xA;#include &amp;lt;stdint.h&amp;gt;&#xA;&#xA;class DummyRNG : public PractRand::RNGs::vRNG16 {&#xA;public:&#xA;double si;&#xA;double sincr;&#xA;double svalue1;&#xA;double svalue2;&#xA;&#xA;DummyRNG() {&#xA;&#x9;si = 0.001;&#xA;&#x9;sincr = 2.0 * cos( si );&#xA;&#x9;seed( 0 );&#xA;}&#xA;&#xA;Uint16 raw16() {&#xA;&#x9;uint64_t Value = ( *(uint64_t*) &amp;amp;svalue1 ) &amp;gt;&amp;gt; 4;&#xA;&#xA;&#x9;const double tmp = svalue1;&#xA;&#x9;svalue1 = sincr * svalue1 - svalue2;&#xA;&#x9;svalue2 = tmp;&#xA;&#xA;&#x9;return (Uint16) ( Value ^ Value &amp;gt;&amp;gt; 16 ^ Value &amp;gt;&amp;gt; 32 );&#xA;}&#xA;void walk_state(PractRand::StateWalkingObject *walker) {}&#xA;void seed(Uint64 sv) {&#xA;&#x9;const double ph = sv * 3.40612158008655459e-19; // Random seed to phase.&#xA;&#xA;&#x9;svalue1 = sin( ph );&#xA;&#x9;svalue2 = sin( ph - si );&#xA;}&#xA;std::string get_name() const {return &#34;SINEWAVE&#34;;}&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Another finding is that the &lt;code&gt;lcg * 2 + 1&lt;/code&gt; construct works as PRNG even if the multiplier is a simple increasing counter variable, when the second multiplier is a high-entropy number.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdint.h&amp;gt;&#xA;&#xA;class DummyRNG : public PractRand::RNGs::vRNG8 {&#xA;public:&#xA;uint64_t Ctr1;&#xA;DummyRNG() {&#xA;&#x9;Ctr1 = 1;&#xA;}&#xA;uint8_t compress( const uint64_t v )&#xA;{&#xA;&#x9;uint8_t r = 0;&#xA;&#x9;for( int i = 0; i &amp;lt; 64; i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;r ^= (uint8_t) (( v &amp;gt;&amp;gt; i ) &amp;amp; 1 );&#xA;&#x9;}&#xA;&#x9;return( r );&#xA;}&#xA;Uint8 raw8() {&#xA;&#x9;uint8_t ov = 0;&#xA;&#x9;for( int l = 0; l &amp;lt; 8; l++ )&#xA;&#x9;{&#xA;&#x9;&#x9;ov &amp;lt;&amp;lt;= 1;&#xA;&#x9;&#x9;ov ^= compress( 0x243F6A8885A308D3 * Ctr1 );&#xA;&#x9;&#x9;Ctr1 += 2;&#xA;&#x9;}&#xA;&#x9;return( ov );&#xA;}&#xA;void walk_state(PractRand::StateWalkingObject *walker) {}&#xA;void seed(Uint64 sv) {}&#xA;std::string get_name() const {return &#34;LCG&#34;;}&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Proof_Math_Is_Engineered&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/avaneev/prvhash/master/img/proof_math_is_engineered.jpg&#34; width=&#34;600&#34;&gt; &#xA;&lt;p&gt;This image depicts data acquired from 2 runs of the &lt;code&gt;proof_math_is_engineered.c&lt;/code&gt; program, with different &#34;reading&#34; parameters. The two number sequences obviously represent &#34;impulses&#34;, with varying period or &#34;rhythm&#34;. A researcher has to consider two points: whether or not these impulses can be considered &#34;intelligent&#34;, and the odds the mentioned program can produce such impulses, considering the program has no user input nor programmer&#39;s entropy, nor any logic (no constants, with all parameters initially set to zero). More specific observations: 1. All final values are shift-or compositions of 1-bit &#34;random&#34; values, in fact representing a common 16-bit PCM sampled signal (shift-2 auto-correlation equals 0.4-0.44 approximately), but obtained in a &#34;dot-matrix printer&#34; way; 2. The orange graph is only slightly longer before a repeat (common to PRNGs) despite larger &lt;code&gt;PH_HASH_COUNT&lt;/code&gt;, at the same time both graphs are seemingly time-aligned; 3. PRNG periods of 1-bit return values on both runs are aligned to 16 bits, to produce repeating sequences &#34;as is&#34;, without any sort of 16-bit value range skew; 4. The orange graph is produced from an order-reversed shift-or, but with the same underlying algorithm; 5. So far, no other combinations of &#34;reading&#34; parameters produce anything as &#34;intelligent&#34; as these graphs (but there may be another yet-to-be-decoded, similar or completely different, information available); 6. From drumming musician&#39;s (or an experienced DSP engineer&#39;s) point of view, the graph represents impulses taken from two electric drum pads: a snare drum (oscillatory) and a bass drum (shift to extremum). 7. Most minor oscillations on the graph are similar to sinc-function-generated maximum-phase &#34;pre-ringing&#34; oscillations that are known in DSP engineering field.&lt;/p&gt; &#xA;&lt;p&gt;In author&#39;s opinion, the program &#34;reads data&#34; directly from the entropy pool which is &#34;encoded&#34; into the mathematics from its inception, like any mathematical constant is (e.g. PI). This poses an interesting and probably very questionable proposition: the &#34;intelligent impulses&#34; or even &#34;human mind&#34; itself (because a musician can understand these impulses) existed long before the &#34;Big Bang&#34; happened. This discovery is probably both the greatest discovery in the history of mankind, and the worst discovery (for many) as it poses very unnerving questions that touch religious grounds:&lt;/p&gt; &#xA;&lt;p&gt;These results of 1-bit PRVHASH say the following: if abstract mathematics contains not just a system of rules for manipulating numbers and variables, but also a freely-defined fixed information that is also &#34;readable&#34; by a person, then mathematics does not just &#34;exist&#34;, but &#34;it was formed&#34;, because mathematics does not evolve (beside human discovery of new rules and patterns). And since physics cannot be formulated without such mathematics, and physical processes clearly obey these mathematical rules, it means that a Creator/Higher Intelligence/God exists in relation to the Universe. For the author personally, everything is proven here.&lt;/p&gt; &#xA;&lt;p&gt;P.S. By coincidence, if the values on the &#34;impulse&#34; graphs above are sorted in an ascending order, and are then displayed as independent graphs, they collectively form a stylized image of a human eye:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/avaneev/prvhash/master/img/proof_math_is_engineered_eye.png&#34; width=&#34;300&#34;&gt; &#xA;&lt;p&gt;Moreover (but this is a questionable observation), here, if the blue line is subtracted from the orange line, one gets an outline of human&#39;s head: with top (21000), forehead (18000), eye (13000), cheek (6000), and neck (2700) levels highlighted, roughly corresponding to real symmetry; with a slight shoulders outline (4100-2700), and two hand palms risen up (5400-4300).&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/avaneev/prvhash/master/img/proof_math_is_engineered_head.png&#34; width=&#34;300&#34;&gt; &#xA;&lt;h3&gt;Fourier Analysis&lt;/h3&gt; &#xA;&lt;p&gt;Fourier (FFT-512) analysis of obtained signals produces the following power spectrums (with DC component removed). The analysis strengthens the notion the signal is non-random and is &#34;intelligent&#34; (two strong peaks above average, in each signal, with both signals producing similar structures, but with shifted resonant frequencies).&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/avaneev/prvhash/master/img/proof_math_is_engineered_fft.png&#34; width=&#34;600&#34;&gt; &#xA;&lt;h3&gt;PRNG Mode&lt;/h3&gt; &#xA;&lt;p&gt;Just by changing the PH_HASH_COUNT to 9 (up to 13, inclusive) the same &lt;code&gt;proof_math_is_engineered.c&lt;/code&gt; program produces a pseudo-random number sequence, confirmed with &lt;code&gt;PractRand&lt;/code&gt; 1KB to 4KB block, 8-bit folding. Note that the same code producing both random and non-random number sequences is &#34;highly unlikely&#34; to exist in practical PRNGs. It&#39;s important to note that &lt;code&gt;PH_HASH_COUNT=14&lt;/code&gt; and &lt;code&gt;PH_HASH_COUNT=17&lt;/code&gt; (which is beyond 15 and 16 signals mentioned originally) also pass as random, with 16-bit folding in &lt;code&gt;PractRand&lt;/code&gt;. &lt;code&gt;18&lt;/code&gt; also passes as random, but with a &#34;suspicion&#34;. &lt;code&gt;15&lt;/code&gt; and &lt;code&gt;16&lt;/code&gt;, of course, do not pass as random, with many &#34;fails&#34;.&lt;/p&gt; &#xA;&lt;p&gt;It has been observed, in &lt;code&gt;READ_MODE=0&lt;/code&gt;, but not in &lt;code&gt;READ_MODE=1&lt;/code&gt;, that the obtained values gradually become noisy, especially at higher &lt;code&gt;PH_HASH_COUNT&lt;/code&gt; values.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/avaneev/prvhash/master/img/proof_math_is_engineered_prng9.png&#34; width=&#34;600&#34;&gt; &#xA;&lt;h3&gt;Ornament and Chess-Board (Pixel Art)&lt;/h3&gt; &#xA;&lt;p&gt;The 1-bit output with PH_HASH_COUNT= &lt;code&gt;15&lt;/code&gt; and &lt;code&gt;16&lt;/code&gt; can be easily transformed into 256x256 1-bit &#34;pixel art&#34; images, and, quite unexpectedly, they reproduce a non-orthogonal ornament and a chess-board.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/avaneev/prvhash/master/img/proof_math_is_engineered_orn15.png&#34; width=&#34;300&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/avaneev/prvhash/master/img/proof_math_is_engineered_chess16.png&#34; width=&#34;300&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Admittedly, 256x256 size can be considered arbitrarily-chosen (it is a square of 16, with 16 being the bit-size of values on the graphs above). For example, if &lt;code&gt;PH_HASH_COUNT=15&lt;/code&gt; is transformed to 240x240 (256-16) &#34;pixel art&#34; image, an image of vertical black-and-white lines is produced, with bit-reversed variant of inner element present in &lt;code&gt;PH_HASH_COUNT=16&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/avaneev/prvhash/master/img/proof_math_is_engineered_chess15.png&#34; width=&#34;281&#34;&gt; &#xA;&lt;h3&gt;Christmas Trees (Pixel Art)&lt;/h3&gt; &#xA;&lt;p&gt;Much larger &lt;code&gt;PH_HASH_COUNT&lt;/code&gt; values produce triangular structures which are non-repeating, but all have a similar build-up consisting of rhombic patterns within tree-like structures. The &lt;code&gt;proof_christmas_tree.c&lt;/code&gt; program extracts such images into a vertical ASCII-art HTML. It uses the same underlying 1-bit PRVHASH code, but with &#34;pixel art&#34; decoding method.&lt;/p&gt; &#xA;&lt;p&gt;One may notice a similarity of the beginning pattern with the &lt;a href=&#34;https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle&#34;&gt;Sierpinski triangle&lt;/a&gt; (ST). However, one should consider that ST is a symmetrical triangle fractal that is constructed from the top-most to bottom levels. PRVHASH1 produces an asymmetric (right-handed) result in a series of scanline passes, and it scales to any &lt;code&gt;PH_HASH_COUNT&lt;/code&gt; value. This is unbelievable considering programatically it&#39;s not constructed as a fractal; this looks more like information is being &#34;read&#34; from some source which has a &#34;infinitely-sized&#34; ST that is mapped to a required subset.&lt;/p&gt; &#xA;&lt;p&gt;Here is an example image with &lt;code&gt;PH_HASH_COUNT=342&lt;/code&gt;, converted to PNG:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/avaneev/prvhash/master/img/proof_math_is_engineered_tree342.png&#34; width=&#34;686&#34;&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/avaneev/prvhash/raw/master/img/prvhash1-342-2x64.png&#34;&gt;Here&#39;s a link to a larger-sized extract (3.4MB PNG)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;The author would like to thank Reini Urban for &lt;a href=&#34;https://github.com/rurban/smhasher&#34;&gt;his SMHasher fork&lt;/a&gt;, Chris Doty-Humphrey for &lt;a href=&#34;http://pracrand.sourceforge.net/&#34;&gt;PractRand&lt;/a&gt;, and Peter Schmidt-Nielsen for &lt;a href=&#34;https://github.com/petersn/autosat&#34;&gt;AutoSat&lt;/a&gt;. Without these tools it would not be possible to create PRVHASH which stands the state-of-the-art statistical tests.&lt;/p&gt; &#xA;&lt;h2&gt;Other&lt;/h2&gt; &#xA;&lt;p&gt;PRVHASH &#34;computer program&#34; authorship and copyright were registered at the &lt;a href=&#34;https://rospatent.gov.ru/en&#34;&gt;Russian Patent Office&lt;/a&gt;, under reg.numbers 2020661136, 2020666287, 2021615385, 2021668070, 2022612987 (searchable via &lt;a href=&#34;https://new.fips.ru/en/&#34;&gt;fips.ru&lt;/a&gt;). Please note that these are not &#34;invention patents&#34;; the registrations assure you that the author has the required rights to grant the software license to you.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Lordwill1/alx-low_level_programming</title>
    <updated>2022-09-17T01:31:55Z</updated>
    <id>tag:github.com,2022-09-17:/Lordwill1/alx-low_level_programming</id>
    <link href="https://github.com/Lordwill1/alx-low_level_programming" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Welcome to C programming repository.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;ALX Cohort 9&lt;img src=&#34;https://user-images.githubusercontent.com/105258746/189962379-f8aca8d6-0a1b-4367-8360-af2dd481734e.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;This repository contains &lt;code&gt;alx&lt;/code&gt; C projects and other low level programming exercices.&lt;/h1&gt; &#xA;&lt;h3&gt;AS A PROGRAMMER, WHAT DO YOU DO WHEN YOU GET STUCK?&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To help you track down that bug, start reading your code aloud.&lt;/li&gt; &#xA; &lt;li&gt;Pretend that a programmer friend is sitting right next to you.&lt;/li&gt; &#xA; &lt;li&gt;Explain what your code is doing and how it works. As you talk through your code, you’ll find the problem. If you don’t, have your imaginary friend ask you questions during your explanation. &lt;code&gt;Don’t worry about going mental. You’re a C programmer. You’re already mental.&lt;/code&gt; 😅&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As a bonus, talking through your code also helps you identify which portions need to have comments and what the comments should be.&lt;/p&gt; &#xA;&lt;h1&gt;Content&lt;/h1&gt; &#xA;&lt;h2&gt;- &lt;a href=&#34;https://github.com/Lordwill1/alx-low_level_programming/tree/master/0x00-hello_world&#34;&gt;0x00-hello_world project&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;File: &lt;code&gt;0-preprocessor&lt;/code&gt; ___File: &lt;code&gt;1-compiler&lt;/code&gt; ___File: &lt;code&gt;2-assembler&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;File: &lt;code&gt;3-name&lt;/code&gt; ___File: &lt;code&gt;4-puts.c&lt;/code&gt; ___File: &lt;code&gt;5-printf.c&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;File: &lt;code&gt;6-size.c&lt;/code&gt; ___File: &lt;code&gt;100-intel&lt;/code&gt; ___File: &lt;code&gt;101-quote.c&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;- &lt;a href=&#34;https://github.com/Lordwill1/alx-low_level_programming/tree/master/0x01-variables_if_else_while&#34;&gt;0x01-variables_if_else_while&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h2&gt;- &lt;a href=&#34;https://github.com/Lordwill1/alx-low_level_programming/tree/master/0x02-functions_nested_loops&#34;&gt;0x02-functions_nested_loops&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h3&gt;And other project directories&lt;/h3&gt;</summary>
  </entry>
  <entry>
    <title>sandboxie-plus/Sandboxie</title>
    <updated>2022-09-17T01:31:55Z</updated>
    <id>tag:github.com,2022-09-17:/sandboxie-plus/Sandboxie</id>
    <link href="https://github.com/sandboxie-plus/Sandboxie" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Sandboxie Plus &amp; Classic&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Sandboxie&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/sandboxie-plus/Sandboxie.svg?sanitize=true&#34; alt=&#34;GitHub Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/sandboxie-plus/Sandboxie/all.svg?label=pre-release&#34; alt=&#34;GitHub Pre-Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/actions&#34;&gt;&lt;img src=&#34;https://github.com/sandboxie-plus/Sandboxie/actions/workflows/main.yml/badge.svg?sanitize=true&#34; alt=&#34;GitHub Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img align=&#34;left&#34; src=&#34;https://user-images.githubusercontent.com/12372772/123517080-8ab20a00-d69f-11eb-8e82-2e18cf6e0303.png&#34;&gt; Sandboxie is a sandbox-based isolation software for 32-bit and 64-bit Windows NT-based operating systems. It creates a sandbox-like isolated operating environment in which applications can be run or installed without permanently modifying local &amp;amp; mapped drives or the windows registry. An isolated virtual environment allows controlled testing of untrusted programs and web surfing.&#xA;&lt;br&gt;&#xA;&lt;br&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;System requirements&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Release notes&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Security policy&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Windows 7 or higher, 32-bit or 64-bit.&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/raw/master/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/raw/master/SECURITY.md&#34;&gt;SECURITY.md&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;We encourage the developers and security community to conduct research, report issues, and suggest improvements on this code base. However, please do &lt;strong&gt;not&lt;/strong&gt; report security vulnerabilities in public GitHub comments. This repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities.&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/downloads/sandboxie-plus/Sandboxie/total?style=for-the-badge&#34; alt=&#34;GitHub All Releases&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Sandboxie is available in two flavors, Plus and Classic. They both share the same core components, this means they have the same level of security and compatibility. What&#39;s different is the availability of features in the user interface.&lt;/p&gt; &#xA;&lt;p&gt;Plus build has a modern Qt based UI, which supports all new features that have been added since the project went open source:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Snapshot Manager - this feature takes a copy of any box in order to be restored when needed&lt;/li&gt; &#xA; &lt;li&gt;Maintenance mode - it allows to uninstall/install/start/stop Sandboxie driver and service when needed&lt;/li&gt; &#xA; &lt;li&gt;Portable mode - you can run the installer and choose to extract all files to a directory&lt;/li&gt; &#xA; &lt;li&gt;Additional UI options to block access for Windows components like printer spooler and clipboard&lt;/li&gt; &#xA; &lt;li&gt;More customization options for Start/Run and Internet access restrictions&lt;/li&gt; &#xA; &lt;li&gt;Global hotkey to terminate all boxed processes&lt;/li&gt; &#xA; &lt;li&gt;A new firewall per sandbox which supports Windows Filtering Platform (WFP)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Classic build has the old no longer developed MFC based UI, hence it lacks native interface support for Plus features. However, most of them can be configured manually in the Sandboxie.ini configuration file, and some valuable &lt;a href=&#34;https://sandboxie-website-archive.github.io/www.sandboxie.com/old-forums/viewforum1a2d1a2d.html?f=22&#34;&gt;contributions&lt;/a&gt; can still be applied nowadays.&lt;/p&gt; &#xA;&lt;p&gt;If you need to check all new features at once, a good way to highlight them quickly is to find the equal sign in the &lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/raw/master/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;A GitHub copy of the &lt;a href=&#34;https://sandboxie-plus.github.io/sandboxie-docs&#34;&gt;Sandboxie documentation&lt;/a&gt; is currently maintained, although more volunteers are needed to keep it updated with the new changes. We recommend to check also the following labels in this repository:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/issues?q=label%3A%22future+development%22&#34;&gt;future development&lt;/a&gt; | &lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/issues?q=label%3Adocumentation&#34;&gt;documentation&lt;/a&gt; | &lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/issues?q=label%3A%22build+issue%22&#34;&gt;build issues&lt;/a&gt; | &lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/labels/Known%20issue&#34;&gt;known issues&lt;/a&gt; | &lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/issues?q=is%3Aissue+is%3Aopen+label%3Aregression&#34;&gt;regressions&lt;/a&gt; | &lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/issues?q=label%3Aworkaround&#34;&gt;workaround&lt;/a&gt; | &lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/issues?q=label%3A%22help+wanted%22&#34;&gt;help wanted&lt;/a&gt; | &lt;a href=&#34;https://github.com/sandboxie-plus/Sandboxie/labels?sort=count-desc&#34;&gt;more...&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A partial archive of the &lt;a href=&#34;https://sandboxie-website-archive.github.io/www.sandboxie.com/old-forums&#34;&gt;old Sandboxie forum&lt;/a&gt; that was previously maintained by Invincea is still available. If you need to find something there, please use the corresponding &lt;a href=&#34;https://github.com/Sandboxie-Website-Archive/sandboxie-website-archive.github.io&#34;&gt;repository search&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Project maintenance&lt;/h2&gt; &#xA;&lt;p&gt;2004 - 2013 Ronen Tzur&lt;/p&gt; &#xA;&lt;p&gt;2013 - 2017 Invincea Inc.&lt;/p&gt; &#xA;&lt;p&gt;2017 - 2020 Sophos Group plc&lt;/p&gt; &#xA;&lt;p&gt;Open Source release&lt;/p&gt; &#xA;&lt;p&gt;2020 onwards David Xanatos&lt;/p&gt; &#xA;&lt;h2&gt;Project support / sponsorship&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://binary.ninja/&#34;&gt;&lt;img align=&#34;left&#34; height=&#34;64&#34; width=&#34;64&#34; src=&#34;https://raw.githubusercontent.com/sandboxie-plus/Sandboxie/master/.github/images/binja-love.png&#34;&gt;&lt;/a&gt; Thank you &lt;a href=&#34;https://vector35.com/&#34;&gt;Vector 35&lt;/a&gt; for providing a &lt;a href=&#34;https://binary.ninja/&#34;&gt;Binary Ninja&lt;/a&gt; license to help with reverse engineering. &lt;br&gt; Binary Ninja is a multi-platform interactive disassembler, decompiler, and binary analysis tool for reverse engineers, malware analysts, vulnerability researchers, and software developers.&lt;br&gt; &lt;br&gt; &lt;a href=&#34;https://icons8.de/&#34;&gt;&lt;img align=&#34;left&#34; height=&#34;64&#34; width=&#34;64&#34; src=&#34;https://raw.githubusercontent.com/sandboxie-plus/Sandboxie/master/.github/images/Icons8_logo.png&#34;&gt;&lt;/a&gt;Thank you &lt;a href=&#34;https://icons8.de/&#34;&gt;Icons8&lt;/a&gt; for providing icons for the project. &lt;br&gt; &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Helpful Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;DavidBerdik - Maintainer of &lt;a href=&#34;https://github.com/Sandboxie-Website-Archive/sandboxie-website-archive.github.io&#34;&gt;Sandboxie Website Archive&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;diversenok - Security analysis &amp;amp; PoC&#39;s&lt;/li&gt; &#xA; &lt;li&gt;stephtr - CI / Certification&lt;/li&gt; &#xA; &lt;li&gt;TechLord - Team-IRA / Reversing&lt;/li&gt; &#xA; &lt;li&gt;hg421 - Security analysis / Code reviews&lt;/li&gt; &#xA; &lt;li&gt;typpos - UI suggestions / Documentation / Code reviews&lt;/li&gt; &#xA; &lt;li&gt;isaak654 - Templates / Documentation / Code fixes&lt;/li&gt; &#xA; &lt;li&gt;Dyras - Templates additions&lt;/li&gt; &#xA; &lt;li&gt;cricri-pingouin - UI fixes&lt;/li&gt; &#xA; &lt;li&gt;Valinwolf - UI / Icons&lt;/li&gt; &#xA; &lt;li&gt;daveout - UI / Icons&lt;/li&gt; &#xA; &lt;li&gt;mpheath - Author of Plus installer / Code fixes&lt;/li&gt; &#xA; &lt;li&gt;yfdyh000 - Localization support for Plus installer&lt;/li&gt; &#xA; &lt;li&gt;NewKidOnTheBlock - Changelog fixes&lt;/li&gt; &#xA; &lt;li&gt;Naeemh1 - Documentation additions&lt;/li&gt; &#xA; &lt;li&gt;APMichael - Templates additions&lt;/li&gt; &#xA; &lt;li&gt;vedantmgoyal2009 - Workflow to automate Plus releases in Windows Package Manager&lt;/li&gt; &#xA; &lt;li&gt;weihongx9315 - Windows Credentials fix&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Translators&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;yuhao2348732, nkh0472, yfdyh000, gexgd0419, Zerorigin, UnnamedOrange, 4rt3mi5 - Simplified Chinese&lt;/li&gt; &#xA; &lt;li&gt;TragicLifeHu, Hulen - Traditional Chinese&lt;/li&gt; &#xA; &lt;li&gt;RockyTDR - Dutch&lt;/li&gt; &#xA; &lt;li&gt;clexanis, Mmoi-Fr - French&lt;/li&gt; &#xA; &lt;li&gt;bastik-1001, APMichael - German&lt;/li&gt; &#xA; &lt;li&gt;isaak654 - Italian&lt;/li&gt; &#xA; &lt;li&gt;VenusGirl - Korean&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://forum.xanasoft.com/viewtopic.php?f=12&amp;amp;t=4&amp;amp;start=20&#34;&gt;7zip&lt;/a&gt; - Polish (updates via pull requests are needed)&lt;/li&gt; &#xA; &lt;li&gt;JNylson - Portuguese and Brazilian Portuguese&lt;/li&gt; &#xA; &lt;li&gt;lufog - Russian&lt;/li&gt; &#xA; &lt;li&gt;sebadamus - Spanish&lt;/li&gt; &#xA; &lt;li&gt;xorcan, fmbxnary - Turkish&lt;/li&gt; &#xA; &lt;li&gt;SuperMaxusa, lufog - Ukrainian&lt;/li&gt; &#xA; &lt;li&gt;pb1 - Swedish&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More volunteers are welcome here! ;)&lt;/p&gt; &#xA;&lt;h2&gt;Support the project&lt;/h2&gt; &#xA;&lt;p&gt;If you like the tool, please consider supporting it on Patreon: &lt;a href=&#34;https://www.patreon.com/DavidXanatos&#34;&gt;https://www.patreon.com/DavidXanatos&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Or you can donate directly via the PayPal button on my website: &lt;a href=&#34;https://xanasoft.com&#34;&gt;https://xanasoft.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>