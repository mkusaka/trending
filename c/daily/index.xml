<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-07T01:31:38Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>corsix/amx</title>
    <updated>2022-09-07T01:31:38Z</updated>
    <id>tag:github.com,2022-09-07:/corsix/amx</id>
    <link href="https://github.com/corsix/amx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Apple AMX Instruction Set&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Contemporary M1 / M2 machines from Apple have (at least) four different ways for low-level programmers to perform heavy computations:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Standard ARMv8 SIMD/NEON vector instructions on CPU cores (128 bits wide, issue &lt;a href=&#34;https://dougallj.github.io/applecpu/firestorm-simd.html&#34;&gt;up to four per cycle on Firestorm&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Apple&#39;s undocumented AMX instructions, issued from CPU, executed on a special accelerator execution unit&lt;/li&gt; &#xA; &lt;li&gt;The Neural Engine (called ANE or NPU)&lt;/li&gt; &#xA; &lt;li&gt;The GPU (e.g. &lt;a href=&#34;https://developer.apple.com/documentation/metal/performing_calculations_on_a_gpu&#34;&gt;Metal Compute Shaders&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This repository is all about the 2&lt;sup&gt;nd&lt;/sup&gt; of those: Apple&#39;s AMX instructions. Note that these instructions are neither documented nor supported by Apple. As a source of potential great confusion, Apple&#39;s AMX instructions are completely distinct from &lt;a href=&#34;https://en.wikipedia.org/wiki/Advanced_Matrix_Extensions&#34;&gt;Intel&#39;s AMX instructions&lt;/a&gt;, though both are intended for issuing matrix multiply operations from a CPU.&lt;/p&gt; &#xA;&lt;p&gt;The research was done on an Apple M1 Max (2021). Older or newer chips might have different AMX instructions. &lt;a href=&#34;https://nod.ai/comparing-apple-m1-with-amx2-m1-with-neon/&#34;&gt;Some sources&lt;/a&gt; report that the M1 contains version 2 of the AMX instructions, which seems plausible (possibly everything using 7-bit writemasks comes from version 1, and everything using 9-bit writemasks is new in version 2).&lt;/p&gt; &#xA;&lt;p&gt;A good one-image summary of AMX is the following figure from &lt;a href=&#34;https://patents.google.com/patent/US20180074824A1/en&#34;&gt;abandoned patent US20180074824A1&lt;/a&gt;. Consider a 32x32 grid of compute units, where each unit can perform 16-bit multiply-accumulate, or a 2x2 subgrid of units can perform 32-bit multiply-accumulate, or a 4x4 subgrid can perform 64-bit multiply-accumulate. To feed this grid, there is a pool of X registers each containing 32 16-bit elements (or 16 32-bit elements, or 8 64-bit elements) and a pool of Y registers similarly containing 32 16-bit elements (or 16 32-bit elements, or 8 64-bit elements). A single instruction can perform a full outer product: multiply every element of an X register with every element of a Y register, and accumulate with the Z element in the corresponding position.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/corsix/amx/main/fig2.png&#34; alt=&#34;US20180074824A1 Figure 2&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A single row of the 32x32 grid can also be used to perform vector operations (rather than matrix operations) between X and Y&lt;sup&gt;T&lt;/sup&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In terms of available data types, the general pattern is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;IEEE754 f16 or f32 or f64 (same width for all three fused-multiply-add operands)&lt;/li&gt; &#xA; &lt;li&gt;IEEE754 f16 multiplicands, accumulating onto f32&lt;/li&gt; &#xA; &lt;li&gt;Integer 8-bit or 16-bit multiplicands, accumulating onto 16 or 32 bits (in various signednesses)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This repository provides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/corsix/amx/main/aarch64.h&#34;&gt;A tiny header for accessing AMX instructions&lt;/a&gt; (use at your own risk)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/corsix/amx/main/RegisterFile.md&#34;&gt;A description of the register file&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/corsix/amx/main/Instructions.md&#34;&gt;A full description of every instruction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/corsix/amx/main/test.md&#34;&gt;C code matching the behaviour of every instruction&lt;/a&gt; (using inline ARMv8 assembly to express certain things)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/corsix/amx/main/References.md&#34;&gt;References for further reading&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>libopencm3/libopencm3</title>
    <updated>2022-09-07T01:31:38Z</updated>
    <id>tag:github.com,2022-09-07:/libopencm3/libopencm3</id>
    <link href="https://github.com/libopencm3/libopencm3" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open source ARM Cortex-M microcontroller library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;README&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/libopencm3/libopencm3&#34;&gt;&lt;img src=&#34;https://travis-ci.org/libopencm3/libopencm3.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gitter.im/libopencm3/discuss&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/libopencm3/discuss.svg?sanitize=true&#34; alt=&#34;Gitter channel&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The libopencm3 project aims to create an open-source firmware library for various ARM Cortex-M microcontrollers.&lt;/p&gt; &#xA;&lt;p&gt;Currently (at least partly) supported microcontrollers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ST STM32 F0xx/F1xx/F2xx/F30x/F37x/F4xx/F7xx/H7xx series&lt;/li&gt; &#xA; &lt;li&gt;ST STM32 G0xx G4xx L0xx L1xx L4xx series&lt;/li&gt; &#xA; &lt;li&gt;Atmel SAM3A/3N/3S/3U/3X series, as well as SAMDxx and friends&lt;/li&gt; &#xA; &lt;li&gt;NXP LPC1311/13/17/42/43&lt;/li&gt; &#xA; &lt;li&gt;Stellaris LM3S series (discontinued, without replacement)&lt;/li&gt; &#xA; &lt;li&gt;TI (Tiva) LM4F series (continuing as TM4F, pin and peripheral compatible)&lt;/li&gt; &#xA; &lt;li&gt;EFM32 Gecko series (only core support)&lt;/li&gt; &#xA; &lt;li&gt;Freescale Vybrid VF6xx&lt;/li&gt; &#xA; &lt;li&gt;Qorvo (formerly ActiveSemi) PAC55XX&lt;/li&gt; &#xA; &lt;li&gt;Synwit SWM050&lt;/li&gt; &#xA; &lt;li&gt;Nordic NRF51x and NRF52x&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The library is written completely from scratch based on the vendor datasheets, programming manuals, and application notes. The code is meant to be used with a GCC toolchain for ARM (arm-elf or arm-none-eabi), flashing of the code to a microcontroller can be done using the OpenOCD ARM JTAG software.&lt;/p&gt; &#xA;&lt;h2&gt;Status and API&lt;/h2&gt; &#xA;&lt;p&gt;The libopencm3 project is (and presumably, always will be) a work in progress. Not all subsystems of all microcontrollers are supported, yet, though some parts have more complete support than others.&lt;/p&gt; &#xA;&lt;p&gt;Prior to version 0.8.0, the api was largely in flux. Attempts were made to provide backwards compatibility, but this was not always considered critical.&lt;/p&gt; &#xA;&lt;p&gt;From 0.8.0 to 1.0, we&#39;ll atempt to follow semver, but &lt;strong&gt;EXPECT CHANGES&lt;/strong&gt;, as we attempt to clear up old APIs and remove deprecated functions. The 0.8.0 tag was placed to provide the &#34;old stable&#34; point before all the new code started landing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;preview&lt;/em&gt; code often lands in the &#34;wildwest-N&#34; branches that appear and disappear in the repository. Pull requests marked as &#34;merged-dev&#34; will be in this branch, and will be closed when they merge to master. This is useful for bigger interdependent patch sets, and also allows review of merge conflicts in public.&lt;/p&gt; &#xA;&lt;p&gt;From 1.0, expect to follow semver, with functions (and defines!) being deprecated for a release before being removed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;TIP&lt;/em&gt;: Include this repository as a Git submodule in your project to make sure your users get the right version of the library to compile your project. For how that can be done refer to the &lt;a href=&#34;https://github.com/libopencm3/libopencm3-template&#34;&gt;libopencm3-template&lt;/a&gt; repository.&lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;p&gt;Building requires Python (some code is generated).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;For Ubuntu/Fedora:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;An arm-none-eabi/arm-elf toolchain.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;For Windows:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Download and install:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;msys - &lt;a href=&#34;http://sourceforge.net/projects/mingw/files/MSYS/Base/msys-core/msys-1.0.11/MSYS-1.0.11.exe&#34;&gt;http://sourceforge.net/projects/mingw/files/MSYS/Base/msys-core/msys-1.0.11/MSYS-1.0.11.exe&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Python - &lt;a href=&#34;https://www.python.org/downloads/windows/&#34;&gt;https://www.python.org/downloads/windows/&lt;/a&gt; (any release)&lt;/li&gt; &#xA; &lt;li&gt;arm-none-eabi/arm-elf toolchain (for example this one &lt;a href=&#34;https://launchpad.net/gcc-arm-embedded&#34;&gt;https://launchpad.net/gcc-arm-embedded&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Run msys shell and set the path without standard Windows paths (adjusting to your version of Python), so Windows programs such as &#39;find&#39; won&#39;t interfere:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export PATH=&#34;/c//Program Files/Python 3.9:/c/ARMToolchain/bin:/usr/local/bin:/usr/bin:/bin&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that you can navigate to the folder where you&#39;ve extracted libopencm3 and build it.&lt;/p&gt; &#xA;&lt;h2&gt;Toolchain&lt;/h2&gt; &#xA;&lt;p&gt;The most heavily tested toolchain is &#34;gcc-arm-embedded&#34; &lt;a href=&#34;https://launchpad.net/gcc-arm-embedded&#34;&gt;https://launchpad.net/gcc-arm-embedded&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Other toolchains &lt;em&gt;should&lt;/em&gt; work, but they have not been nearly as well tested. Toolchains targeting Linux, such as &#34;gcc-arm-linux-gnu&#34; or the like are &lt;em&gt;not&lt;/em&gt; appropriate.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;: We recommend that you use gcc-arm-embedded version 4.8 2014q3 or newer to build all platforms covered by libopencm3 successfully.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have an arm-elf toolchain (uncommon) you may want to override the toolchain prefix (arm-none-eabi is the default)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ PREFIX=arm-elf make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a more verbose build you can use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make V=1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can reduce the build time by specifying a particular MCU series&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make TARGETS=&#39;stm32/f1 stm32/f4&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supported targets can be listed using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make list-targets&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Fine-tuning the build&lt;/h2&gt; &#xA;&lt;p&gt;The build may be fine-tuned with a limited number of parameters, by specifying them as environment variables, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ VARIABLE=value make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;FP_FLAGS&lt;/code&gt; - Control the floating-point ABI&lt;/p&gt; &lt;p&gt;If the Cortex-M core supports a hard float ABI, it will be compiled with the best floating-point support by default. In cases where this is not desired, the behavior can be specified by setting &lt;code&gt;FP_FLAGS&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Currently, M4F cores default to &lt;code&gt;-mfloat-abi=hard -mfpu=fpv4-sp-d16&lt;/code&gt;, and M7 cores defaults to double precision &lt;code&gt;-mfloat-abi=hard -mfpu=fpv5-d16&lt;/code&gt; if available, and single precision &lt;code&gt;-mfloat-abi=hard -mfpu=fpv5-sp-d16&lt;/code&gt; otherwise. Other architectures use no FP flags, in otherwords, traditional softfp.&lt;/p&gt; &lt;p&gt;You may find which FP_FLAGS you can use in a particular architecture in the readme.txt file shipped with the gcc-arm-embedded package.&lt;/p&gt; &lt;p&gt;Examples:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  $ FP_FLAGS=&#34;-mfloat-abi=soft&#34; make               # No hardfloat&#xA;  $ FP_FLAGS=&#34;-mfloat-abi=hard -mfpu=magic&#34; make   # New FPU we don&#39;t know of&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;CFLAGS&lt;/code&gt; - Add to or supersede compiler flags&lt;/p&gt; &lt;p&gt;If the library needs to be compiled with additional flags, they can be passed to the build system via the environment variable &lt;code&gt;CFLAGS&lt;/code&gt;. The contents of &lt;code&gt;CFLAGS&lt;/code&gt; will be placed after all flags defined by the build system, giving the user a way to override any default if necessary.&lt;/p&gt; &lt;p&gt;Examples:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  $ CFLAGS=&#34;-fshort-wchar&#34; make    # Compile lib with 2 byte wide wchar_t&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example projects&lt;/h2&gt; &#xA;&lt;p&gt;The libopencm3 community has written and is maintaining a huge collection of examples, displaying the capabilities and uses of the library. You can find all of them in the libopencm3-examples repository:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/libopencm3/libopencm3-examples&#34;&gt;https://github.com/libopencm3/libopencm3-examples&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you just wish to test your toolchain and build environment, a collection of mini blink projects is available too. This covers &lt;em&gt;many&lt;/em&gt; more boards, but, as the name suggests, only demonstrates blinking LEDs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/libopencm3/libopencm3-miniblink&#34;&gt;https://github.com/libopencm3/libopencm3-miniblink&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Simply pass -I and -L flags to your own project. See the &lt;a href=&#34;https://github.com/libopencm3/libopencm3-template&#34;&gt;libopencm3-template&lt;/a&gt; repository for a template repository using this library as a Git submodule, the most popular method of use. The libopencm3-examples is another example of this.&lt;/p&gt; &#xA;&lt;p&gt;It is strongly advised that you do not attempt to install this library to any path inside your toolchain itself. While this means you don&#39;t have to include any &lt;code&gt;-I&lt;/code&gt; or &lt;code&gt;-L&lt;/code&gt; flags in your projects, it is &lt;em&gt;very&lt;/em&gt; easy to confuse a multi-library linker from picking the right versions of libraries. Common symptoms are hardfaults caused by branches into ARM code. You can use &lt;code&gt;arm-none-eabi-objdump&lt;/code&gt; to check for this in your final ELF file. You have been warned.&lt;/p&gt; &#xA;&lt;h2&gt;Coding style and development guidelines&lt;/h2&gt; &#xA;&lt;p&gt;See HACKING.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The libopencm3 code is released under the terms of the GNU Lesser General Public License (LGPL), version 3 or later.&lt;/p&gt; &#xA;&lt;p&gt;See COPYING.GPL3 and COPYING.LGPL3 for details.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Our &lt;a href=&#34;https://gitter.im/libopencm3/discuss&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/libopencm3/discuss.svg?sanitize=true&#34; alt=&#34;Gitter channel&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Our IRC channel on the libera.chat IRC network is called #libopencm3&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Mailing lists&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Developer mailing list (for patches and discussions): &lt;a href=&#34;https://lists.sourceforge.net/lists/listinfo/libopencm3-devel&#34;&gt;https://lists.sourceforge.net/lists/listinfo/libopencm3-devel&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Commits mailing list (receives one mail per &lt;code&gt;git push&lt;/code&gt;): &lt;a href=&#34;https://lists.sourceforge.net/lists/listinfo/libopencm3-commits&#34;&gt;https://lists.sourceforge.net/lists/listinfo/libopencm3-commits&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Website&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://libopencm3.org&#34;&gt;http://libopencm3.org&lt;/a&gt; - contains daily autogenerated API documentation&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>gameprive/win2k</title>
    <updated>2022-09-07T01:31:38Z</updated>
    <id>tag:github.com,2022-09-07:/gameprive/win2k</id>
    <link href="https://github.com/gameprive/win2k" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Windows 2000 source code&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;win2k&lt;/h1&gt; &#xA;&lt;p&gt;Windows 2000 source code&lt;/p&gt; &#xA;&lt;p&gt;有修改,非原始.&lt;/p&gt;</summary>
  </entry>
</feed>