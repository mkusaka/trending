<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-26T01:35:04Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>peng-zhihui/ElectronBot</title>
    <updated>2022-07-26T01:35:04Z</updated>
    <id>tag:github.com,2022-07-26:/peng-zhihui/ElectronBot</id>
    <link href="https://github.com/peng-zhihui/ElectronBot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ElectronBot: Mini Desktop Robot&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;本项目是一个桌面级小机器工具人，外观设计的灵感来源是WALL-E里面的EVE~机器人具备USB通信显示画面功能，具备6个自由度（手部roll、pitch，颈部，腰部各一个），使用自己修改的特制舵机支持关节角度回传。&lt;/p&gt; &#xA; &lt;p&gt;本项目提供了配套的全套开发资料和对应SDK以供二次开发，SDK使用说明见后文。&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;视频介绍&lt;/strong&gt;：&lt;a href=&#34;https://www.bilibili.com/video/BV1ka411b76m/&#34;&gt;【自制】我做了个能动的 电 脑 配 件！【软核】_哔哩哔哩&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Video&lt;/strong&gt; : &lt;a href=&#34;https://www.youtube.com/watch?v=F29vrvUwqS4&#34;&gt;I made a cute mini desktop robot ! - YouTube&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;注意：Issues里面是讨论项目开发相关话题的，不要在里面发无意义的消息，不然watch了仓库的人都会收到通知邮件会给别人造成困扰的！！！灌水可以在仓库的Discuss里讨论！&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/ElectronBot/main/5.Docs/Images/robot1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;更新说明：&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;22.4.5更新：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;添加单独的USB通信功能测试工程以及预编译文件，在&lt;code&gt;6.Tests\TestDisplayUSB\_Released&lt;/code&gt;目录；使用方法是直接给STM32F4烧录hex文件，然后直接在电脑端运行&lt;code&gt;Sample.exe&lt;/code&gt;，硬件正常的话屏幕会显示文件夹里的视频。&lt;/li&gt; &#xA; &lt;li&gt;上述预编译文件的源码和固件也在文件夹里有提供，相当于一个最小测试工程，可以自己查看代码进行调试。&lt;/li&gt; &#xA; &lt;li&gt;注意在6个舵机没有测试验证成功之前，调试代码不要使用舵机收发指令的功能，不然总线会阻塞导致程序卡住，推荐的方式是先单独一个一个功能调试，完成了之后再整合做联调。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;安装教程可以参考：&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/1668139036&#34;&gt;数码甲鱼的简单生活&lt;/a&gt; 同学的胎教级教程：&lt;a href=&#34;https://www.bilibili.com/video/BV1sY4y1Y7t6&#34;&gt;https://www.bilibili.com/video/BV1sY4y1Y7t6&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://space.bilibili.com/25228512&#34;&gt;绿荫阿广&lt;/a&gt;同学的安装视频 ：&lt;a href=&#34;https://www.bilibili.com/video/BV1oY4y1v7oN&#34;&gt;https://www.bilibili.com/video/BV1oY4y1v7oN&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;22.4.17更新：&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;添加语音识别版电子，感谢&lt;a href=&#34;https://github.com/jinsonli/ElectronBot-Voice&#34;&gt;jinsonli/ElectronBot-Voice &lt;/a&gt;的分享，演示效果可以看这个视频：&lt;a href=&#34;https://www.bilibili.com/video/BV18a411v7JS&#34;&gt;我复刻了电脑配件机器人electronbot【语音版】&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;视频中演示的舵机调试工具已添加到本仓库&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;1.项目文件说明&lt;/h3&gt; &#xA;&lt;h4&gt;1.1 Hardware&lt;/h4&gt; &#xA;&lt;p&gt;Hardware文件夹内是ElectronBot里面用到的所有电路的原理图和PCB文件，提供Altium Designer格式的源文件以及Gerber格式的光绘文件用于提供给厂家进行直接加工。&lt;/p&gt; &#xA;&lt;p&gt;一共有如下几块板子：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;ElectronBot&lt;/strong&gt;：头部的主控板，包含主控MCUSTM32F405RGT6，圆形屏幕GC9A01，USB-HS的PHY芯片USB3300，以及SD卡。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;SensorBoard&lt;/strong&gt;：肚子里的传感器板子，包含一个手势传感器，一个USB-HUB芯片，5个I2C舵机的接口，一个MPU6050加速度计&amp;amp;陀螺仪等（USB摄像头也是连接到这个板子的）。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;BaseConnector&lt;/strong&gt;：底座上的USB Type-C插座，通过8-Pin的FFC排线和SensorBoard连接，因为机器人本体需要旋转所以使用了柔性排线。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;ServoDrive&lt;/strong&gt;：用于魔改舵机替换舵机驱动板的电路，通过I2C总线接口和SensorBoard以及头部主控连接。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;ServoDrive-DK&lt;/strong&gt;：同上，但是把PCB的触点接口换成了接插件，方便调试，调试完了下载代码到上面的板子（因为体积太小所以上面的板子没有下载口接插件，所以不方便调试，这里单独提供一个DK版本）。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;1.2 Firmware&lt;/h4&gt; &#xA;&lt;p&gt;Firmware中提供了上面所有板子的固件源码，主要包含以下两个工程：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;ElectronBot-fw&lt;/strong&gt;：头部主控板的固件代码，用于驱动圆形屏幕，实现USB-CDC协议的自定义设备，以及进行舵机控制。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ServoDrive-fw&lt;/strong&gt;：ServoDrive板子的固件，包含舵机的电位器ADC采样，I2C从机通信和协议解析，电机控制的PWM输出，以及PID闭环算法实现。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ServoDrive-fw-LL&lt;/strong&gt;：也是ServoDrive板子的固件，与上面不同的是改用LL库而不是HAL库实现，所以Flash占用会小一些，可以放进16K的MCU，大家根据自己的情况选择需要的固件。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;工程都是基于STM32HAL实现的，所以提供了对应的&lt;code&gt;.ioc&lt;/code&gt;文件，可以自行用STM32CubeMX打开，生成对应的keil或者STM32IDE工程文件。当让也可以像我一样，用CLion进行编译和下载，把CLion变成STM32的IDE的方法参考我之前发的一篇教程：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/145801160&#34;&gt;配置CLion用于STM32开发【优雅の嵌入式开发】&lt;/a&gt; 。&lt;/p&gt; &#xA;&lt;h4&gt;1.3 Software&lt;/h4&gt; &#xA;&lt;p&gt;Software中提供了视频里演示的上位机软件ElectronStudio的Unity工程源码，以及SDK库和SDK源文件，库的层级关系由下至上分别是：&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ElectronBotSDK-LowLevel&lt;/code&gt; -&amp;gt; &lt;code&gt;ElectronBotSDK-Player&lt;/code&gt; -&amp;gt; &lt;code&gt;ElectronBotSDK-UnityBridge&lt;/code&gt; -&amp;gt; &lt;code&gt;Electron-Studio&lt;/code&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;SDK的使用方法见后文。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;此外文件夹里还包含了BotDriver也就是ElectronBot连接电脑需要安装的USB驱动文件，安装方法是在设备管理器里右键更新驱动，然后选择自定义目录导航到这个文件夹即可安装。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;安装过程需要禁用Windows的强制驱动签名（没钱给M$买签名），禁用方法根据你的操作系统版本有不同，可以百度一下。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;1.4 CAD-Model&lt;/h4&gt; &#xA;&lt;p&gt;文件夹中包含了ElectronBot的结构设计图纸，&lt;code&gt;.step&lt;/code&gt;通用格式可以在所有软件里打开编辑；同时为了满足有的同学想要Fusion360里面的原始工程，我也共享了&lt;code&gt;.f3d&lt;/code&gt;格式源文件，源文件里包含了完整的编辑建模时间轴。&lt;/p&gt; &#xA;&lt;p&gt;共享连接：&lt;a href=&#34;https://a360.co/3t6CUMS&#34;&gt;https://a360.co/3t6CUMS&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;此目录下也包含了视频里演示的&lt;a href=&#34;https://space.bilibili.com/38053181&#34;&gt;oooooohmygosh&lt;/a&gt;同学设计的表情包动画，其中每个表情的动画都包含了三个片段：&lt;code&gt;进入-循环-退出&lt;/code&gt;，进入和退出是可以和其他动画进行无缝衔接的，因此可以方便用代码调用这些表情包实现很多效果。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;表情文件需要修改为英文名和路径后使用。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;我把视频结尾提到的收纳盒也上传了，可以用FDM打印，5%填充即可。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/ElectronBot/main/5.Docs/Images/robot8.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;1.5 Docs&lt;/h4&gt; &#xA;&lt;p&gt;相关的参考文件，包括芯片的Datasheet等。&lt;/p&gt; &#xA;&lt;p&gt;此目录下还有个_LargeFiles文件夹，是软件过程项目中依赖的一些库（比如OpenCV）因为DLL比较大超过了100MB，GitHub需要开启LFS才能提交，而我不想开启LFS，因此单独拿出来压缩了提交到仓库，编译工程的时候需要把这些库放到对应工程目录下，具体的路径见 &lt;code&gt;_path.txt&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;h3&gt;2.硬件架构说明&lt;/h3&gt; &#xA;&lt;p&gt;机器人的硬件分为&lt;strong&gt;结构&lt;/strong&gt;和&lt;strong&gt;电路&lt;/strong&gt;。&lt;/p&gt; &#xA;&lt;h4&gt;2.1 结构设计&lt;/h4&gt; &#xA;&lt;p&gt;结构设计方面大家可以研究3D图纸，值得注意的点如下：&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;主要部件的加工方式？&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;我是用3D打印加工的，因为包含了齿轮等精密部件，传统FDM打印的精度可能不太理想，光固化是可以的，但是支撑问题可能导致打印机表面不平整，而且LCD光固化的零件强度不太够。所以推荐使用HP尼龙打印，可以去嘉立创（三维猴）打印，价格这几个零件加起来应该是200-300元左右。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;也用到了几个轴承和一些特殊的螺丝，轴承型号的话肩膀关节的型号是&lt;code&gt;6x10x3mm&lt;/code&gt;，腰部轴承型号是&lt;code&gt;25x32x4mm&lt;/code&gt;。特殊螺丝是肩膀roll自由度的推杆，使用了&lt;code&gt;M2x25mm&lt;/code&gt;的半牙螺丝。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;手臂推杆还用到了一个小挡块，这个挡块不用打印加工，直接用一段橡胶电线剪下一小段即可（视频里有演示），这个挡块是需要和推杆的螺丝固定到一起的，可以使用502粘合。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;手臂的驱动原理？&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;视频里其实演示了，我自己设计了一个比较巧妙的驱动方式，pitch方向运动很好理解就是齿轮传动，roll方向使用了T型推杆如下：&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/ElectronBot/main/5.Docs/Images/robot2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;推杆被M2螺丝的帽以及一个挡块限制住，当黄色的组件转动的时候，带动推杆左右移动，而推杆的另一端在手臂组件内由一个导槽限制运动方向从而将动力传递到转轴，此方案的力矩是可以双向传递的&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/ElectronBot/main/5.Docs/Images/robot3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;脸部的透明玻璃如何制作的&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;tb搜索&lt;code&gt;表蒙子&lt;/code&gt;，我用的&lt;code&gt;31.5mm&lt;/code&gt;直径的。&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/ElectronBot/main/5.Docs/Images/robot6.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;安装顺序？&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;可以参考这位&lt;a href=&#34;https://space.bilibili.com/25228512&#34;&gt;绿荫阿广&lt;/a&gt;同学的安装视频 ：&lt;a href=&#34;https://www.bilibili.com/video/BV1oY4y1v7oN&#34;&gt;https://www.bilibili.com/video/BV1oY4y1v7oN&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;安装过程中还有一点值得注意的是，因为机身体积太极限，几个舵机的安装架有的是需要剪短一边的不然塞不下，然后如果自己的打印机比较脆螺丝固定不牢的话，也可以使用热熔胶固定。&lt;/li&gt; &#xA; &lt;li&gt;另外手臂的推杆可以稍微打磨一下并加上润滑脂使其推动更顺畅。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;2.2 电路设计&lt;/h4&gt; &#xA;&lt;p&gt;电路没啥好分析的，直接看原理图吧。&lt;/p&gt; &#xA;&lt;p&gt;值得提一下的是USB-HUB的拓扑，如下：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/ElectronBot/main/5.Docs/Images/robot4.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;关于芯片选型？&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;主控的STM32F4，这个不可替换，因为F4以下的型号不支持USB-HS外接PHY。&lt;/li&gt; &#xA; &lt;li&gt;舵机驱动的STM32F0，这个可以替换，而且建议有能力的同学替换，因为我项目中用到的STM32F042P6芯片比较贵（买的十多元一片），而舵机驱动对于芯片的性能要求没那么高，完全可以用STM8之类的8位MCU替代，所以大家可以参考我的固件源码寻求能够替换的MCU改进一下方案。&lt;/li&gt; &#xA; &lt;li&gt;替换STM32F0的MCU需要支持以下特性：带一个ADC采样、带两路PWM输出、带一个I2C接口，Flash和SRAM大小根据我的代码需要32K和4K或者更大（我固件用了HAL库以及C++特性，如果你可以基于LL库或者不适用C++的话应该需求还可以小一半）。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;关于烧录方式？&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;使用JLink、STLink之类的调试器烧录，注意驱动板因为体积限制只留了三个烧录触点，需要使用&lt;code&gt;SH1.0&lt;/code&gt;的接插件接触进行烧写。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;关于舵机的改造？&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;通常的RC-Servo都是使用电位器进行绝对角度的测量的，因此我在驱动板中也是使用ADC读取电位器的电压值转换成角度反馈，而驱动芯片使用了我找到的封装最小的一个芯片&lt;code&gt;FM116B&lt;/code&gt;。大家改造舵机的时候，注意区分电机两根接线的方向，如果调试发现电机不闭环的话，可能需要交换一下接线顺序。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;另外那个小的3g舵机的改造需要把盖子拆开去掉（空间实在是太小加了盖子驱动塞不进去），然后去掉了后盖的舵机需要换成M1x10mm的螺丝进行固定不然会散架的。&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;其实最理想的情况是找舵机厂家定制一个这样的迷你舵机，但是因为我一个人小批量做人家肯定不接单的，大家有渠道的话可以尝试一下。&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;关于摄像头选型？&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;我是用的是这款：&lt;a href=&#34;https://item.taobao.com/item.htm?id=567717780577&#34;&gt;https://item.taobao.com/item.htm?id=567717780577&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/ElectronBot/main/5.Docs/Images/robot5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;当然大家可以根据需要自己替换别的USB摄像头（黑白的、高帧率的），只要塞得下就行，摄像头是直接拆了接线焊在SensorBoard上的 。&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;值得注意的是，&lt;strong&gt;我用的USB-HUB芯片的1拖4的&lt;/strong&gt;，目前使用了三个口，还剩一个其实可以再集成一个USB麦克风，这样ElectronBot也能当作电脑的麦克风使用了。&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;3.软件架构说明&lt;/h3&gt; &#xA;&lt;h4&gt;3.1 固件代码&lt;/h4&gt; &#xA;&lt;p&gt;固件代码的细节和流程说明比较繁琐，晚点我慢慢补充吧，总之可以直接基于前面提到的方式进行编译下载，然后慢慢研究源码。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;STM32F4的源码如果通过&lt;code&gt;.ioc&lt;/code&gt;重新生成工程的话，记得要把USB相关的几个文件预先备份，生成完代码后再替换回我原来的文件，因为CubeMX会覆盖生成把相关代码修改掉（我实际是使用Git的文件版本回退操作的 ）。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;3.2 舵机I2C协议&lt;/h4&gt; &#xA;&lt;p&gt;魔改后的舵机通过I2C接口和控制板进行通信，STM32F4的控制板为主机，舵机为从机。通信的过程始终是主机发起的，主机首先下发位置、参数等指令，然后即时取回相关数据完成一个通信来回。&lt;/p&gt; &#xA;&lt;p&gt;每个舵机作为从机接收两个地址的指令：&lt;strong&gt;自己的ID号&lt;/strong&gt;，以及&lt;strong&gt;0号广播&lt;/strong&gt;。广播用于在没有给舵机设置地址的时候作为通配地址使用（比如你刚烧写完舵机固件，此时舵机的Flash是没有储存自己的ID的，只能通过0号地址通信）。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;值得注意的是：舵机和主机的上电需要有先后顺序，一定要先让从机初始化完成开始监听数据，再让主机发送指令！&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;如果主机发送指令的时候从机不响应，或者多个舵机地址相同同时响应，都可能引起通信错误，因此需要保证上述的顺序。&lt;/p&gt; &#xA; &lt;p&gt;由于硬件上主机和舵机上电都是同时的，所以在主机的固件代码中，有一个延时2S的代码（其实可以不用那么久），就是等待舵机都上电初始化完成再开始通信。&lt;/p&gt; &#xA; &lt;p&gt;调试的时候，一个舵机一个舵机调试，注释掉其他未连接的舵机的通信代码，不然也会造成轮询等待超时。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;关于舵机的指令含义，感谢 &lt;strong&gt;&lt;a href=&#34;https://github.com/leazer&#34;&gt;leazer&lt;/a&gt;&lt;/strong&gt; 同学在Issues整理的表格：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://pengzhihui-markdown.oss-cn-shanghai.aliyuncs.com/img/20220322010150.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;指令后续可能会更新。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;3.3 SDK使用说明&lt;/h4&gt; &#xA;&lt;p&gt;SDK架构设计如图：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/peng-zhihui/ElectronBot/main/5.Docs/Images/robot7.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;具体的使用方法可以参考SDK工程中给出的&lt;code&gt;sample.cpp&lt;/code&gt;，我是用CLion+MSVC工具链编译的，大家也可以把源码复制到自己的Visual Studio工程编译。&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ElectronBotSDK-UnityBridge&lt;/code&gt;工程编译生成的DLL文件需要拷贝到&lt;code&gt;Unity\ElectronBot-Studio\Assets\Plugins&lt;/code&gt;目录下，用于连接本地的C++代码和Unity中C#环境。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;对了，注意ElectronStudio中目前选择图片视频文件还不支持中文路径！&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;关于SDK的具体实现细节可以阅读源码，我晚点有空也会再更新描述。&lt;/p&gt; &#xA;&lt;h3&gt;有的问题在Issues里面已经解答了，问问题之前先翻一下open/closed的Issues。&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;感谢以下项目：&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/opencv/opencv&#34;&gt;opencv/opencv: Open Source Computer Vision Library (github.com)&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/CMU-Perceptual-Computing-Lab/openpose&#34;&gt;https://github.com/CMU-Perceptual-Computing-Lab/openpose&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/Lexikos/AutoHotkey_L&#34;&gt;Lexikos/AutoHotkey_L: AutoHotkey - macro-creation and automation-oriented scripting utility for Windows. (github.com)&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/pq8888168/article/details/85781908&#34;&gt;https://blog.csdn.net/pq8888168/article/details/85781908&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
  <entry>
    <title>kevinlawler/kerf1</title>
    <updated>2022-07-26T01:35:04Z</updated>
    <id>tag:github.com,2022-07-26:/kevinlawler/kerf1</id>
    <link href="https://github.com/kevinlawler/kerf1" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Kerf&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/kevinlawler/kerf1/raw/master/repl-header.png&#34; alt=&#34;REPL&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Source&lt;/h2&gt; &#xA;&lt;p&gt;kerf1: &lt;a href=&#34;https://github.com/kevinlawler/kerf1/tree/master/src&#34;&gt;https://github.com/kevinlawler/kerf1/tree/master/src&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;kerf2 (kerf): &lt;a href=&#34;https://github.com/kevinlawler/kerf/&#34;&gt;https://github.com/kevinlawler/kerf/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is Kerf?&lt;/h2&gt; &#xA;&lt;p&gt;Kerf is a columnar tick database and time-series language for Linux/OSX/BSD/iOS/Android. It is written in C and natively speaks JSON and SQL. Kerf can be used for trading platforms, feedhandlers, low-latency networking, high-volume analysis of realtime and historical data, logfile processing, and more.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Manual&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The manual, currently in progress, is here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kevinlawler/kerf1/tree/master/manual&#34;&gt;https://github.com/kevinlawler/kerf1/tree/master/manual&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The manual covers much more than the whirlwind guide below.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Guides&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kerf Screencast - Stock Basics &lt;a href=&#34;https://youtu.be/CcJP8TX7CVc&#34;&gt;https://youtu.be/CcJP8TX7CVc&lt;/a&gt;&lt;br&gt; Kerf Screencast - Stock Basics II: Stats &lt;a href=&#34;https://youtu.be/Pi6FXIYvTkk&#34;&gt;https://youtu.be/Pi6FXIYvTkk&lt;/a&gt;&lt;br&gt; Kerf Screencast - CSV &amp;amp; Text Tricks: &lt;a href=&#34;https://youtu.be/aDETohEScJM&#34;&gt;https://youtu.be/aDETohEScJM&lt;/a&gt;&lt;br&gt; Kerf Screencast - Bloomberg B-PIPE Datafeed: &lt;a href=&#34;https://youtu.be/eVu50oSBZAE&#34;&gt;https://youtu.be/eVu50oSBZAE&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Time Bars - &lt;a href=&#34;https://getkerf.wordpress.com/2016/06/21/time-bars/&#34;&gt;https://getkerf.wordpress.com/2016/06/21/time-bars/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Whirlwind Language Guide:&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;TYPES&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  CHAR &#xA;         &#34;abc&#34; or &#39;abc&#39;&#xA;  &#xA;  INT  &#xA;          1&#xA;  &#xA;  FLOAT&#xA;          2.0 or 1e6 or 1.2E+01&#xA;  &#xA;  STAMP&#xA;          2015.03.31 or 01:23:45.877 or 2015.03.31T01:23:45.123&#xA;  &#xA;  NULL&#xA;          null&#xA;  &#xA;  ARRAY &#xA;          [5, 6, 7, 8]&#xA;  &#xA;  MAP  &#xA;          {b:2, c:3, d:4}&#xA;  &#xA;  TABLE   &#xA;         {{b:2, c:3, d:4}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a few other types which we&#39;ll skip discussing for now.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;OPERATIONS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s look at some good ways to make arrays. &#39;Range&#39; comes directly from Python and accepts 1, 2, or 3 arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;range(4)&#xA;  [0, 1, 2, 3]&#xA;&#xA;range(2, 6)&#xA;  [2, 3, 4, 5]&#xA;&#xA;range(0, 20, 3)&#xA;  [0, 3, 6, 9, 12, 15, 18]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&#39;Rand&#39; accepts 0, 1, or 2 arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rand()       //FLOAT from [0,1)&#xA;  0.164771&#xA;&#xA;rand(5)      //INT&#xA;  2&#xA;&#xA;rand(9.0)    //FLOAT&#xA;  8.86153&#xA;&#xA;rand(4, 3.0) //4x FLOAT&#xA;  [2.44598, 2.87178, 1.14531, 0.676305]&#xA;&#xA;rand(4, [11, 22]) //from a list&#xA;  [22, 11, 11, 22]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rand may return different values for you.&lt;/p&gt; &#xA;&lt;p&gt;Now let&#39;s look ahead:&lt;/p&gt; &#xA;&lt;p&gt;The exponentiation operator ** comes from Ruby and Python.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;range(10**6) //a big list&#xA;&#xA;timing true&#xA;sum(range(10**6))  //sum first million numbers&#xA;  499999500000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now back to basic arithmetic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;+ - * / ** plus minus times divide pow&#xA;        //wait, which is the operation and which is the name?&#xA;2 + 2&#xA;plus(2, 2)&#xA;        //I guess they both work&#xA;2 plus 2&#xA;        //and that works too&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is nice because parenthesized prefix notation disambiguates dyadic/binary infix operations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;        //oh, one of those guys&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then the ambiguous-appearing&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;0.5 * x**2 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;becomes&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;times(1/2, x**2) &#xA;        //well that&#39;s not so bad&#xA;        //&#xA;        //actually, I like that better... I wonder why?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, emphasizing the center operation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(divide(1, 2) * pow(x,2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Neither of these are ambiguous. Of course, you can always fall back to parentheses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;((1 / 2) * (x**2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Format code as if order-of-operations does not exist.&lt;/p&gt; &#xA;&lt;p&gt;I find the &#34;functional&#34; notation for arithmetic also helps when the arguments are arrays or maps instead of scalars. This can cue the reader that something heavier-duty is happening.&lt;/p&gt; &#xA;&lt;p&gt;Other common operators are present. The exclamation point &#39;!&#39; is not, the percent sign &#39;%&#39; is modulo, and so on.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;!0&#xA; 1&#xA;not 0&#xA; 1&#xA;&#xA;-33 % 4&#xA;  3  //mathematical definition&#xA;-33 mod 4&#xA;  3&#xA;&#xA;.Math.TAU / 2&#xA;  3.14159&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kerf speaks JSON:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;eval(&#39;1+1&#39;)&#xA;  2&#xA;&#xA;a: [[1, 2, 3], {a:&#34;alpha&#34;, b:&#34;bravo&#34;, c:&#34;3pO&#34;}, null]&#xA;match(a, eval(json_from_kerf(a)))&#xA;  1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;ASSIGNMENT&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Assignment is &#39;:&#39;, the colon character. It&#39;s colon and not &#39;=&#39; because:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;JSON uses : for assignment, as in {a:1}&lt;/li&gt; &#xA; &lt;li&gt;SQL uses = for comparison, as in WHERE user_id=456&lt;/li&gt; &#xA; &lt;li&gt;Kerf is a superset of both JSON and SQL.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Which looks like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a: [11, 22, 33, 44]&#xA;a[2]&#xA;    33&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We could force assignment to be &#39;=&#39; but I don&#39;t think it improves the language.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a[0]:5&#xA;a&#xA;  [5, 22, 33, 44]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Indexing into maps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a: {b:2, c:3}&#xA;a[&#39;c&#39;]&#xA;  3&#xA;{b:2, c:3}[&#39;c&#39;]&#xA;  3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;VECTOR OPERATIONS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Arrays vectorize automatically. This means CHAR, INT, FLOAT, and STAMP types are fast and efficient in lists of the same kind. Arrays also mostly keep track of when they&#39;re sorted. This means Kerf will invisibly use binary search or interpolation search if it appears advantageous.&lt;/p&gt; &#xA;&lt;p&gt;The following notion of conformability comes from K:&lt;/p&gt; &#xA;&lt;p&gt;Adding a single value to a longer list applies it like so: &lt;code&gt;100 + [0, 10, 20]&lt;/code&gt; gives &lt;code&gt; [100, 110, 120]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kerf extends this notion to work with lists of length 1 as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[100] + [0, 10, 20]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;gives&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  [100, 110, 120]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This also works piecewise:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  [100, 110, 120] + [40, 50, 60]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;gives&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    [140, 160, 180]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Conformability extends all the way down. This&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[[1], [1,1,1]] + [[2], [2, 2, 2]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;gives&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  [[3], [3, 3, 3]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Flatten? Sure&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;flatten [[3], [3, 3, 3]]&#xA;  [3, 3, 3, 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Works with maps and tables, too.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{a:2, b:20} + {a:3, b:30, c:100}&#xA;  {a:5, b:50, c:100}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some operations yield array-wise results.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;![0, 1, 0]&#xA;  [1, 0, 1]&#xA;&#xA;[2, 3, 4, 4, 4] &amp;lt;= [3, 3, 3, 3, 3]&#xA;  [1, 1, 0, 0, 0]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Operations are optimized for vectors&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;timing 1&#xA;a: range(10**6)&#xA;sum(a)&#xA;a+a&#xA;min(a)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;TABLES&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kerf extends JSON to include the concept of tables. Tables are created just like maps except you use double curly-braces. The names of the keys in that case are instead the names of the columns. So &lt;code&gt;{{a:1, b:2}}&lt;/code&gt; is a table and &lt;code&gt;{a:1, b:2}&lt;/code&gt; is a map. The convenience constructor &lt;code&gt;{{a,b,c}}&lt;/code&gt; also creates a table. This table will have empty arrays for columns. Table columns are always arrays. If you pass something that isn&#39;t an array it will be coerced into an array.&lt;/p&gt; &#xA;&lt;p&gt;The following are all equivalent ways to make a table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  {{id:1, time:now(), brightness:48.6}}&#xA;is the same as &#xA;  {{id:[1], time:[now()], brightness:[48.6]}}&#xA;is the same as &#xA;  INSERT INTO {{id, time, brightness}} VALUES [[1], [now()], [48.6]] //bulk insert/append&#xA;is the same as&#xA;  INSERT INTO {{id, time, brightness}} VALUES {id:1, time:now(), brightness:48.6}   //insert map&#xA;is the same as&#xA;  INSERT INTO {{id, time, brightness}} VALUES {{id:1, time:now(), brightness:48.6}} //append table&#xA;is the same as&#xA;  INSERT INTO {{}} VALUES {id:1, time:now(), brightness:48.6} //empty tables are special&#xA;is the same as&#xA;  a:{{}}&#xA;  INSERT INTO a VALUES {id:1, time:now(), brightness:48.6}&#xA;is the same as&#xA;  id:[1]&#xA;  time:[now()]&#xA;  brightness:[48.6]&#xA;  {{id:id, time:time, brightness:brightness}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;They are all printed as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;┌──┬───────────────────────┬──────────┐&#xA;│id│time                   │brightness│&#xA;├──┼───────────────────────┼──────────┤&#xA;│ 1│2015.07.06T16:23:50.509│      48.6│&#xA;└──┴───────────────────────┴──────────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SQL inserts and updates are forms of assignment: they are always &#34;saved&#34;. Bulk inserts are much faster than single inserts. The columns id, time, and brightness are vectorized as INT, STAMP, and FLOAT vectors respectively. The preceding tables all exist in-memory only.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;READS/WRITES&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can read and write arbitrary objects, including in-memory tables, using the following functions. These are not really designed for transactional reads and writes, more like per-session reads and writes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  read_from_path(&#39;path.to.file&#39;)&#xA;  write_to_path(&#39;path.to.file&#39;, object);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For an on-disk table that handles transactional writes, you&#39;ll want a mapped object. On Linux, OSX, BSD and other systems, the virtual memory limit for mapped objects is slightly less than 47-bits, or 128T, which for most people is effectively unlimited.&lt;/p&gt; &#xA;&lt;p&gt;Apple&#39;s iOS operating system restricts &lt;em&gt;virtual&lt;/em&gt; memory allocations to something less than 2G in size, &lt;em&gt;even on&lt;/em&gt; devices with 64-bit pointers. So mapping very large tables will not get far around the memory limitations of the mobile device. Apple really should look into raising it: it may be a legacy restriction from some now-outdated concerns. On OS X the virtual memory limit is effectively unrestricted.&lt;/p&gt; &#xA;&lt;p&gt;You can open tables on disk via the &lt;code&gt;open_table(filepath)&lt;/code&gt; call. Here it is via the Objective-C API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;NSString *path = [[kerf suggestedTableDirectoryPath] stringByAppendingPathComponent:@&#34;my.table&#34;];&#xA;[kerf jsonObjectFromCall:@&#34;a: open_table($1)&#34; withArgumentArray:@[path]]&#xA;[kerf jsonObjectFromCall:@&#34;insert into a values {{id: 4}}&#34;]);&#xA;[kerf jsonObjectFromCall:@&#34;a&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Modifications to the variable cause the inserts to persist to the disk. They will be there the next time you open the table. Most variables in Kerf use reference counting or copy-on-write to ensure uniqueness. Mapped values like opened tables are different: all reference the same open item. Changes to one affect the other.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CSV/TSV/ETC LOADING&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Loading CSVs into tables should be easy. The function for reading a CSV into an in-memory table is &lt;code&gt;read_table_from_csv&lt;/code&gt;, and it is used in this way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;read_table_from_csv(csv_file, fields, header_rows)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;so that&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;csv_file: &#39;my_logs01.csv&#39;&#xA;fields: &#39;SFI&#39;&#xA;header_rows: 1&#xA;table: read_table_from_csv(csv_file, fields, header_rows)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will load a file that looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Racer, Max Speed, Wins&#xA;Mario, 30.01, 10&#xA;Luigi, 28.02, 12&#xA;Toad,  25.00,  7&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;as so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;KeRF&amp;gt; t: read_table_from_csv(&#39;my_logs01.csv&#39;, &#39;SFI&#39;, 1)&#xA;┌─────┬─────────┬────┐&#xA;│Racer│Max Speed│Wins│&#xA;├─────┼─────────┼────┤&#xA;│Mario│    30.01│  10│&#xA;│Luigi│    28.02│  12│&#xA;│ Toad│     25.0│   7│&#xA;└─────┴─────────┴────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The currently supported list of field identifiers is &#34;IFSEGNZz*&#34; integers floats strings enumerated-strings guids/uuids ips custom-datetime custom-datetime2 skipped-field. IP addresses are converted to integers using inet_pton. The custom datetime parser format is set like this&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.Parse.strptime_format: &#39;%d-%b-%y %H:%M:%S&#39;  //format for &#39;Z&#39;&#xA;.Parse.strptime_format2:&#39;%d-%b-%y %H:%M:%S&#39;  //format for &#39;z&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and relies directly on the system &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&#34;&gt;strptime format&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Similar functions exist for TSVs and for arbitrary character-delimited files (e.g., pipe-delimited):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;read_table_from_tsv(&#39;prices.tsv&#39;, &#34;SFFF&#34;, 1)&#xA;read_table_from_delimited_file(&#39;\t&#39;, &#39;prices.tsv&#39;, &#34;SFFF&#34;, 1)&#xA;read_table_from_delimited_file(&#39;|&#39;,  &#39;prices.psv&#39;, &#34;SFFF&#34;, 1)&#xA;&#xA;┌─────────┬──────┬──────┬──────┐&#xA;│id       │rent_1│rent_2│rent_3│&#xA;├─────────┼──────┼──────┼──────┤&#xA;│E01004236│1100.0│1275.0│1500.0│&#xA;│E01004237│1150.0│1550.0│1725.0│&#xA;│E01004234│1050.0│1375.0│1650.0│&#xA;│E01004235│1025.0│1300.0│1500.0│&#xA;│E01004232│ 975.0│1300.0│2025.0│&#xA;│E01004233│1050.0│1425.0│1800.0│&#xA;│E01004230│1125.0│1300.0│2025.0│&#xA;│E01004231│1175.0│1550.0│1725.0│&#xA;│       ..│    ..│    ..│    ..│&#xA;└─────────┴──────┴──────┴──────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you&#39;ve stored such a table in a variable in memory, you can write it to disk for later use using &lt;code&gt;write_to_path&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; t: read_table_from_csv(&#39;prices.csv&#39;, &#39;SFF&#39;, 1)&#xA; write_to_path(&#39;prices.table&#39;, t);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To open such a table later call&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;t: read_from_path(&#39;prices.table&#39;)  //in-memory only version table&#xA;or&#xA;t: open_table(&#39;prices.table&#39;)      //on-disk memory-mapped version of table&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;CSV/TSV/ETC WRITING&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are two methods for writing delimited files. The first is a convenience method for CSVs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;write_csv_from_table&#xA;&#xA;path: &#39;my_logs01.csv&#39;&#xA;table: my_table&#xA;write_csv_from_table(path, table)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The second is the generalized method that lets you specify the delimiter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;write_delimited_file_from_table&#xA;&#xA;path: &#39;my_logs01.csv&#39;&#xA;table: my_table&#xA;write_delimited_file_from_table(&#34;\t&#34;, path, table) //for TSV&#xA;&#xA;write_delimited_file_from_table(&#34;|&#34;,  path, table) //for PSV&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All of these methods require your data to be collected in a table before writing. This simplifies the output process considerably.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;FIXED-WIDTH FILE LOADING&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kerf supports fixed-width file loading. The motivating use-case for this is the NYSE TAQ fixed-width format. Perhaps the best way to understand how this works is to look at the &lt;a href=&#34;https://github.com/kevinlawler/kerf/raw/master/scripts/taq.kerf&#34;&gt;NYSE TAQ loading example script&lt;/a&gt;. In addition to the fields supported by the CSV-style readers, the fixed-width reader supports the fields &#34;QR&#34;, representing NYSE&#39;s strange timestamp format, and an enumerated NYSE dot-delimited symbol column.&lt;/p&gt; &#xA;&lt;p&gt;To invoke the fixed-width field reader, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;file:&#39;path/to/file.ext&#39;&#xA;attributes: {fields: &#39;Q*R*IF******&#39;,  widths: 9 1 16 4 9 11 1 2 16 1 1 2}&#xA;read_table_from_fixed_file(file, attributes)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &#34;attibutes&#34; argument is map. Relevant keys are &#34;fields widths titles header_rows line_limit&#34;. &#34;Titles&#34; are column titles. Some keys, such as &#34;line_limit&#34; are not required.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;SCRIPTS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kerf code can be stored in scripts. The suggested extension is &lt;code&gt;.kerf&lt;/code&gt; for Kerf scriptfiles. You can load scripts from the console using &lt;code&gt;load&lt;/code&gt;, so that if a file &lt;code&gt;myscript.kerf&lt;/code&gt; contains the code&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a:11&#xA;b:22&#xA;c:a+b&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then a terminal session that loads the script might look as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;KeRF&amp;gt; load &#39;myscript.kerf&#39;&#xA;KeRF&amp;gt; c&#xA;  33&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scripts following the binary&#39;s name on the command line will be executed in order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./kerf myscript.kerf b.kerf c.kerf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If a script named &#34;startup.kerf&#34; is present in Kerf&#39;s working directory, then it will be executed at startup, before any other command-line scripts. Scripts may be loaded from other scripts.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;FLAGS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;-x&lt;/code&gt; flag executes and prints its argument. The &lt;code&gt;-e&lt;/code&gt; flag executes its argument without printing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./kerf -x &#39;1+1&#39;&#xA;2&#xA;$ ./kerf -e &#39;1+1&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;-q&lt;/code&gt; or quiet flag starts Kerf without a banner. It has no arugment. The &lt;code&gt;-p&lt;/code&gt; flag opens an IPC port on its argument.&lt;/p&gt; &#xA;&lt;p&gt;Logging is enabled using the &lt;code&gt;-l&lt;/code&gt; flag. Currently this logs all incoming network requests to the file &lt;code&gt;kerf.log&lt;/code&gt; for possible future replay.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;EXITING&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;From the console, pressing &lt;code&gt;ctrl+d&lt;/code&gt; will exit the process. (This sends an end-of-transmission control character.) The Kerf function &lt;code&gt;exit()&lt;/code&gt; will end the process via code execution. If you like, you can optionally pass an argument to &lt;code&gt;exit&lt;/code&gt; that will be returned by the Kerf process to the shell.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;exit()&#xA;exit(0)&#xA;exit(-1)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;TIME MATH&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;We previously saw absolute time stamps of the form&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;2015.04.01 or 2015.03.31T01:23:45.877&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can compare them&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;2015.04.02 &amp;lt; 2015.05.01 &#xA;  1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can modify them using relative times of the form &lt;code&gt;1y&lt;/code&gt; or &lt;code&gt;1y3d&lt;/code&gt; or &lt;code&gt;4h55i06s&lt;/code&gt; and so on. So&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;2015.04.01 + 1y1m1d&#xA;  2016.05.02&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or alternatively as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  2015.04.01 + 1y + 1m + 1d&#xA;    2016.05.02&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And &lt;code&gt;2015.04.01 + 1h2i3s&lt;/code&gt; gives &lt;code&gt;2015.04.01T01:02:03.000&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;now_date() + 1d&#xA;  2015.04.02&#xA;&#xA;now_time()&#xA;  21:36:00.762&#xA;&#xA;minus(now_time(), 25 * 1h)&#xA;  20:36:02.005&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The current list of possibilities is: &lt;code&gt;ymdhis&lt;/code&gt; year month day hour minute second.&lt;/p&gt; &#xA;&lt;p&gt;Note that while &lt;code&gt;minus&lt;/code&gt; could be perfectly well defined as an operation on absolute STAMPs (for a given reduced form, it could return a relative stamp), at least for the time being in Kerf it throws a type error. This is easy to get around, do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  2015.04.07 + 1d &amp;lt;= 2015.04.08&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;instead of&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  (2015.04.08 - 2015.04.07) &amp;lt;= 1d &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason you might want to avoid producing relative times is that the full range of useful relative dates and times exceeds a 64-bit width and so is not vectorized.&lt;/p&gt; &#xA;&lt;p&gt;Timestamps are nanosecond granularity. By default only millisecond precision is displayed. But this is cosmetic.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  2001.01.01T01:01:01.012345678[&#39;nanosecond&#39;]&#xA;12345678&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To extract individual parts from times, use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a: 2015.03.16T04:05:06.7890123456&#xA;a: [a, a] //optional, to see how it works in vector form&#xA;&#xA;a[&#39;date&#39;]   //stamp&#xA;a[&#39;time&#39;]   //stamp&#xA;a[&#39;year&#39;]   //int&#xA;a[&#39;month&#39;] &#xA;a[&#39;day&#39;]&#xA;a[&#39;hour&#39;]&#xA;a[&#39;minute&#39;]&#xA;a[&#39;second&#39;]&#xA;a[&#39;millisecond&#39;]&#xA;a[&#39;nanosecond&#39;] &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;SQL (SELECT)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kerf is a superset of SQL. This means Kerf speaks SQL, and you can write SQL anywhere inside of Kerf code. Let&#39;s start by building a suitable table.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;n: 10**4&#xA;ids: range(1, n+1)&#xA;stamps: plus(NOW(), 1s + mapright range(n))&#xA;heartrates: 80 + rand(n, 100.0)  &#xA;labels: range(6)&#xA;lanes: take(n, join(labels, reverse labels))&#xA;running: {{id: ids, stamp: stamps, heartrate: heartrates, lane: lanes}} &#xA;&#xA;&#xA;┌──┬───────────────────────┬─────────┬────┐&#xA;│id│stamp                  │heartrate│lane│&#xA;├──┼───────────────────────┼─────────┼────┤&#xA;│ 1│2015.07.06T16:24:55.543│  96.4771│   0│&#xA;│ 2│2015.07.06T16:24:56.543│  107.397│   1│&#xA;│ 3│2015.07.06T16:24:57.543│  108.356│   2│&#xA;│ 4│2015.07.06T16:24:58.543│  92.2126│   3│&#xA;│ 5│2015.07.06T16:24:59.543│  125.115│   4│&#xA;│ 6│2015.07.06T16:25:00.543│  161.533│   5│&#xA;│ 7│2015.07.06T16:25:01.543│  175.726│   5│&#xA;│ 8│2015.07.06T16:25:02.543│  118.177│   4│&#xA;│..│                     ..│      .. │  ..│&#xA;└──┴───────────────────────┴─────────┴────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Someone is running a zigzag across a six-lane track with a random heartbeat. This is not exactly realistic data but let&#39;s go with it. We can count the number of rows in the table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;select count(*) as rows from running&#xA;┌─────┐&#xA;│rows │&#xA;├─────┤&#xA;│10000│&#xA;└─────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And there&#39;s no reason we can&#39;t run SQL inside of JSON:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[{a:1, b: select count(*) from running}, select count(*) from running]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s verify the count of the table:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;equal(count(running), n)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Peek at the first 3 rows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;first(3, running)&#xA;┌──┬───────────────────────┬─────────┬────┐&#xA;│id│stamp                  │heartrate│lane│&#xA;├──┼───────────────────────┼─────────┼────┤&#xA;│ 1│2015.07.06T16:24:55.543│  96.4771│   0│&#xA;│ 2│2015.07.06T16:24:56.543│  107.397│   1│&#xA;│ 3│2015.07.06T16:24:57.543│  108.356│   2│&#xA;└──┴───────────────────────┴─────────┴────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Get the bounds on the time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;select first(stamp), last(stamp) from running&#xA;┌───────────────────────┬───────────────────────┐&#xA;│stamp                  │stamp1                 │&#xA;├───────────────────────┼───────────────────────┤&#xA;│2015.07.06T16:24:55.543│2015.07.06T19:11:34.543│&#xA;└───────────────────────┴───────────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[first(running.stamp), last(running.stamp)]&#xA;[2015.04.01T19:13:33.917, 2015.04.01T22:00:12.917]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And perform GROUP BY and WHERE queries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;select avg(heartrate) from running where heartrate &amp;gt; 100 group by lane&#xA;┌────┬─────────┐&#xA;│lane│heartrate│&#xA;├────┼─────────┤&#xA;│   1│  139.192│&#xA;│   2│  140.283│&#xA;│   4│  139.772│&#xA;│   5│   140.24│&#xA;│   3│  140.167│&#xA;│   0│  138.541│&#xA;└────┴─────────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Nested subqueries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;select * from (select avg(heartrate) from running where heartrate &amp;gt; 100 group by lane) where heartrate = max(heartrate)&#xA;┌────┬─────────┐&#xA;│lane│heartrate│&#xA;├────┼─────────┤&#xA;│   2│  140.283│&#xA;└────┴─────────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can store the results of queries in other variables.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;b: select max(heartrate) from running where lane = 2&#xA;┌─────────┐&#xA;│heartrate│&#xA;├─────────┤&#xA;│  179.976│&#xA;└─────────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And retrieve the cell value only like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;first(b.heartrate)&#xA;  179.952&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The supported SQL WHERE comparison methods currently are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  &amp;lt; &amp;gt; = &amp;lt;= &amp;gt;= == != &amp;lt;&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Conjunction in a WHERE clause is indicated using commas, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;select from running where lane = 2, heartrate = 108.356&#xA;&#xA;┌──┬───────────────────────┬─────────┬────┐&#xA;│id│stamp                  │heartrate│lane│&#xA;├──┼───────────────────────┼─────────┼────|&#xA;│ 3│2015.07.06T16:24:57.543│  108.356│   2│&#xA;└──┴───────────────────────┴─────────┴────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In Kerf &#34;and&#34; and &#34;or&#34; have different meanings and will operate on the columns prior to serving them up for consideration as indices. When using &#34;or&#34; or &#34;and&#34;, be sure to parenthesize the subexpressions. So&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;select from running where (lane = 2) or (heartrate = 108.356)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following also works:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;select from running where or(lane = 2, heartrate = 108.356)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The supported SQL GROUP BY aggregation methods currently are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  min max sum count first last avg std var&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Kerf can use our nicely sorted ID range to perform fast lookups even without an index. Table traits are undocumented at this point.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;LEFT JOIN&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A basic left join can be accomplished with the &lt;code&gt;left_join&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;t:{{a:1 2 2 3, b:10 20 30 40}}&#xA;u:{{a:2 3, c:1.5 3}}&#xA;left_join(t,u,&#34;a&#34;)&#xA;&#xA;┌─┬──┬───┐&#xA;│a│b │c  │&#xA;├─┼──┼───┤&#xA;│1│10│nan│&#xA;│2│20│1.5│&#xA;│2│30│1.5│&#xA;│3│40│3.0│&#xA;└─┴──┴───┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The third argument indicates the key or keys to match on. The argument is a string or an array of strings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;u:{{a:2 3, b:30 40, c:1.5 3}}&#xA;left_join(t,u,[&#34;a&#34;,&#34;b&#34;])&#xA;&#xA;┌─┬──┬───┐&#xA;│a│b │c  │&#xA;├─┼──┼───┤&#xA;│1│10│nan│&#xA;│2│20│nan│&#xA;│2│30│1.5│&#xA;│3│40│3.0│&#xA;└─┴──┴───┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your tables don&#39;t match on column names, no sweat, use a map.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;t:{{a:1 2 2 3, b:10 20 30 40}}&#xA;u:{{z:2 3, c:1.5 3}}&#xA;left_join(t, u, {&#39;a&#39;:&#39;z&#39;})&#xA;&#xA;┌─┬──┬───┐&#xA;│a│b │c  │&#xA;├─┼──┼───┤&#xA;│1│10│nan│&#xA;│2│20│1.5│&#xA;│2│30│1.5│&#xA;│3│40│3.0│&#xA;└─┴──┴───┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;ASOF JOIN&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;One useful time-series operation is the asof join, which is predictably called using the &lt;code&gt;asof_join&lt;/code&gt; function. The function accepts four arguments. The first three are the same as in the case of left join, and operate similarly. The third argument indicates columns whose items must match exactly. The fourth argument is a string or array of strings indicating column names. Typically these refer to time columns, though that is not required.&lt;/p&gt; &#xA;&lt;p&gt;If the columns in the third argument require &#34;exact&#34; matches, then the columns in the fourth argument accept &#34;fuzzy&#34; matches: they&#39;ll match on any value up to and including the time in question. Perhaps this is best illustrated with an example. This style of matching is useful for seeing what the latest value at a specific time was, when in reality the last update may have occured some time in the past.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;//Example taken from timestored.com&#xA;KeRF&amp;gt; trades: {{time: 07:00 08:30 09:59 10:00 12:00 16:00, sym:enum[&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;], price: .9 1.5 1.9 2 9 10, size: 100 700 200 400 500 800}}&#xA;&#xA;┌────────────┬───┬─────┬────┐&#xA;│time        │sym│price│size│&#xA;├────────────┼───┼─────┼────┤&#xA;│07:00:00.000│  a│  0.9│ 100│&#xA;│08:30:00.000│  a│  1.5│ 700│&#xA;│09:59:00.000│  a│  1.9│ 200│&#xA;│10:00:00.000│  a│  2.0│ 400│&#xA;│12:00:00.000│  b│  9.0│ 500│&#xA;│16:00:00.000│  a│ 10.0│ 800│&#xA;└────────────┴───┴─────┴────┘&#xA;&#xA;KeRF&amp;gt; quotes: {{time: 08:00 09:00 10:00 11:00 12:00 13:00 14:00 15:00, sym:enum[&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;], bid: 1 9 2 8 8.5 3 7 4}}&#xA;&#xA;┌────────────┬───┬───┐&#xA;│time        │sym│bid│&#xA;├────────────┼───┼───┤&#xA;│08:00:00.000│  a│1.0│&#xA;│09:00:00.000│  b│9.0│&#xA;│10:00:00.000│  a│2.0│&#xA;│11:00:00.000│  b│8.0│&#xA;│12:00:00.000│  b│8.5│&#xA;│13:00:00.000│  a│3.0│&#xA;│14:00:00.000│  b│7.0│&#xA;│15:00:00.000│  a│4.0│&#xA;└────────────┴───┴───┘&#xA;&#xA;KeRF&amp;gt; asof_join(trades, quotes, [&#39;sym&#39;], [&#39;time&#39;])                                                                                            &#xA;┌────────────┬───┬─────┬────┬───┐&#xA;│time        │sym│price│size│bid│&#xA;├────────────┼───┼─────┼────┼───┤&#xA;│07:00:00.000│  a│  0.9│ 100│nan│&#xA;│08:30:00.000│  a│  1.5│ 700│1.0│&#xA;│09:59:00.000│  a│  1.9│ 200│1.0│&#xA;│10:00:00.000│  a│  2.0│ 400│2.0│&#xA;│12:00:00.000│  b│  9.0│ 500│8.5│&#xA;│16:00:00.000│  a│ 10.0│ 800│4.0│&#xA;└────────────┴───┴─────┴────┴───┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Time-series events are necessarily logged at discrete times. Asof Join is a tool that lets us treat a discrete series as if it were continuous.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;SQL (DELETE)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The major tradeoff in using columnar storage is that deletes take O(n) time. For millions of rows in memory, this will take in the milliseconds, and so doesn&#39;t matter. For on-disk storage, you may want to avoid an architecture that incorporates repeated deletes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;KeRF&amp;gt; n:10**6; t:{{a:range(n), b:rand(n,100.0)}}&#xA;&#xA;┌─┬───────┐&#xA;│a│b      │&#xA;├─┼───────┤&#xA;│0│16.4771│&#xA;│1│27.3974│&#xA;│2│28.3558│&#xA;│3│12.2126│&#xA;│4│45.1148│&#xA;│5│81.5326│&#xA;│6│ 95.726│&#xA;│7│38.1769│&#xA;│.│     ..│&#xA;└─┴───────┘&#xA;&#xA;    14 ms&#xA;&#xA;KeRF&amp;gt; count t&#xA;  1000000&#xA;&#xA;KeRF&amp;gt; delete from t where b between [0,50]&#xA;  &#34;t&#34;&#xA;&#xA;KeRF&amp;gt; count t&#xA;  499326&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;ADVANCED TYPES&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are two advanced types which we can use for specialized columns:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ENUM (HASH)&#xA;              enum [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;]  or hash [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;]&#xA;INDEX (SORT)&#xA;              index [1, 2, 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both are variations on ARRAYs or VECTORs. An &lt;code&gt;enum&lt;/code&gt; is like a &#34;local&#34; string interning object. It keeps only one reference to each object and stores appearances as fixed-width indices. It is useful for storing repetitions of strings and lists, which cannot otherwise efficiently be stored as vectors. In all other respects an &lt;code&gt;enum&lt;/code&gt; appears to be an array.&lt;/p&gt; &#xA;&lt;p&gt;An &lt;code&gt;index&lt;/code&gt; is like an array except with an attached b-tree. This can make lookups and range queries more efficient. (The storage format of the index will be breaking after the alpha.) Don&#39;t use an &lt;code&gt;index&lt;/code&gt; for data you can guarantee will always be sorted ascending, such as autoincrementing primary keys: Kerf will track sorted arrays and doesn&#39;t need a special index.&lt;/p&gt; &#xA;&lt;p&gt;Lambdas are also a type which can be stored.&lt;/p&gt; &#xA;&lt;p&gt;There is another hypothetical advanced type called an &lt;code&gt;ATLAS&lt;/code&gt;, which is the schemaless NoSQL equivalent of a table. Atlases are automatically indexed in such a way that all key-queries are indexed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;INTERPROCESS COMMUNICATION&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kerf instances are designed to be networked. The data structures serialize directly without any intermediate conversion.&lt;/p&gt; &#xA;&lt;p&gt;To start a Kerf server on port 1234 execute the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./kerf -p 1234&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can communicate with this instance either via a Kerf client or via the Kerf SDK/API from another program (e.g., Python or Java or Objective-C).&lt;/p&gt; &#xA;&lt;p&gt;A client can be a plain old Kerf instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./kerf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: the server and the client should be separate instances. In the client paste each of the lines individually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;socket: open_socket(&#34;localhost&#34;,&#34;1234&#34;)&#xA;&#xA;send_async(socket, &#34;table: {{sym:hash[], time:[], price:[]}}&#34;)&#xA;&#xA;do(100) {send_async(socket, &#34;insert into table values {sym:$1, time:$2, price:$3}&#34;, [rand([&#34;AAPL&#34;,&#34;MSFT&#34;,&#34;IBM&#34;]), now(),  20.0 + rand(10.0) ])}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then in the server execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;root&#xA;&#xA;table&#xA;&#xA;select avg(price) from table group by sym&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then in the client execute&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;close_socket(socket)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Currently IPC requires the user to store the socket handle. Probably what will happen is we will remove this and have all IPC calls use the server and port. It would be simple for Kerf to manage a hashtable of hosts and ports pointing to socket handles, and to keep or refresh them as necessary, and so we should probably do that.&lt;/p&gt; &#xA;&lt;p&gt;See a longer exposition of this topic on TimeStored: &lt;a href=&#34;http://www.timestored.com/time-series-data/kerf-database&#34;&gt;http://www.timestored.com/time-series-data/kerf-database&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;As you might guess, &lt;code&gt;send_sync&lt;/code&gt; is also available. The difference from &lt;code&gt;send_async&lt;/code&gt; is that &lt;code&gt;send_sync&lt;/code&gt; blocks and returns the evaluated reponse from the remote server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;KeRF&amp;gt; socket: open_socket(&#34;localhost&#34;,&#34;1234&#34;)&#xA;KeRF&amp;gt; send_sync(socket,&#34;1+11&#34;,[])&#xA;12&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some IPC-related variables:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.Net.client - current integer handle of the now-processing client&#xA;.Net.on_close - one-argument function called on the integer handle of the closing client&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;.Net.on_close: {[x] out &#39;client closed: &#39; join (string x) join &#39;\n&#39;}&#xA;&#xA;send_async(socket, &#34;a:2; display .Net.client; out &#39; is the client\n&#39;&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;CONTROL FLOW&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Control flow is designed to be as generic as possible. You probably don&#39;t need it yet, but Kerf uses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;if(b){x} else if(c){y} else{z} &#xA;do(n){x} &#xA;while(b){x}&#xA;for(a;b;c){x} &#xA;def myfunc(arg1, arg2) {x}&#xA;function myfunc(arg1, arg2) {x}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All portions must be properly (parenthesized) and {curly-braced}: no skipping. Lambdas are: &lt;code&gt;{[arg1, arg2] arg1+arg2}&lt;/code&gt;. Lambda function recursion is &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;this&lt;/code&gt;. Early return is &lt;code&gt;return&lt;/code&gt;, otherwise return the final eval. Note: ending the final eval with a semicolon causes null to be returned. Commas &lt;code&gt;,&lt;/code&gt; and semicolons &lt;code&gt;;&lt;/code&gt; are usually interchangeable. Comments are &lt;code&gt;//&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;MISC CODE SAMPLES&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Examples for average, standard deviation, and variance (avg, std, var).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;a: [12, 2.4, 8]   //assign an array to &#39;a&#39; using JSON notation&#xA;a: range(6)       //integers [0, 1, 2, 3, 4, 5]&#xA;a: rand(8, 100.0) //eight random floats from the interval [0.0, 100.0)&#xA;&#xA;REPL or API (Cheating):&#xA;  avg(a)&#xA;  std(a)&#xA;  var(a)&#xA;&#xA;REPL or API (Simplified):&#xA;  (sum a)/count a              &#xA;  sqrt var a                   &#xA;  (sum (a - avg a)**2)/count a &#xA;&#xA;REPL or API (Traditional):&#xA;  sum(a)/count(a)               &#xA;  sqrt(var(a))                  &#xA;  sum((a - avg(a))**2)/count(a)&#xA;&#xA;API Argument Passing, each with 1 argument (Traditional):&#xA;  sum($1)/count($1)               &#xA;  sqrt(var($1))                  &#xA;  sum(($1 - avg($1))**2)/count($1)&#xA;&#xA;Function Definition (Traditional):&#xA;  def my_func_avg(a) {sum(a)/count(a)}&#xA;  def my_func_std(a) {sqrt(var(a))}&#xA;  def my_func_var(a) {sum((a - avg(a))**2)/count(a)}&#xA;&#xA;Lambdas (Traditional):&#xA;  {[a] sum(a)/count(a)}&#xA;  {[a] sqrt(var(a))}&#xA;  {[a] sum((a - avg(a))**2)/count(a)}&#xA;&#xA;REPL or API (Variant Takes)&#xA;  (plus fold a)/len(a)&#xA;  sum((a minus avg(a)) pow 2) divide count(a)&#xA;  pow(std a, 2) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;LEGAL&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;MISC LANGUAGE SPECS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kerf is written in C. Kerf is a superset of both JSON and SQL. Kerf compiles to Kerf bytecode. Memory management is automatic and invisible to the user. Internally, Kerf uses reference counting. Kerf does not garbage collect. Kerf uses copy-on-write. Kerf uses a memory pool, so warmed operations are faster. Kerf does not expose pointers. It does not use globally interned strings. Certain objects will intern strings locally. Kerf data structures use optimized hash tables and b-trees. All Kerf objects serialize automatically and use the same [decompressed] representation in-memory, on-disk, and over the network. IPC is compressed when it would lower transfer times. By default the PRNG is initialized with a nondeterministic seed. By default times are UTC.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>86Box/86Box</title>
    <updated>2022-07-26T01:35:04Z</updated>
    <id>tag:github.com,2022-07-26:/86Box/86Box</id>
    <link href="https://github.com/86Box/86Box" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emulator of x86-based machines based on PCem.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;86Box&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://ci.86box.net/job/86Box&#34;&gt;&lt;img src=&#34;http://ci.86box.net/job/86Box/badge/icon&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;86Box&lt;/strong&gt; is a low level x86 emulator that runs older operating systems and software designed for IBM PC systems and compatibles from 1981 through fairly recent system designs based on the PCI bus.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Easy to use interface inspired by mainstream hypervisor software&lt;/li&gt; &#xA; &lt;li&gt;Low level emulation of 8086-based processors up to the Pentium with focus on accuracy&lt;/li&gt; &#xA; &lt;li&gt;Great range of customizability of virtual machines&lt;/li&gt; &#xA; &lt;li&gt;Many available systems, such as the very first IBM PC 5150 from 1981, or the more obscure IBM PS/2 line of systems based on the Micro Channel Architecture&lt;/li&gt; &#xA; &lt;li&gt;Lots of supported peripherals including video adapters, sound cards, network adapters, hard disk controllers, and SCSI adapters&lt;/li&gt; &#xA; &lt;li&gt;MIDI output to Windows built-in MIDI support, FluidSynth, or emulated Roland synthesizers&lt;/li&gt; &#xA; &lt;li&gt;Supports running MS-DOS, older Windows versions, OS/2, many Linux distributions, or vintage systems such as BeOS or NEXTSTEP, and applications for these systems&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;System requirements and recommendations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Intel Core 2 or AMD Athlon 64 processor&lt;/li&gt; &#xA; &lt;li&gt;Windows version: Windows 7 Service Pack 1, Windows 8.1 or Windows 10&lt;/li&gt; &#xA; &lt;li&gt;Linux version: Ubuntu 16.04, Debian 9.0 or other distributions from 2016 onwards&lt;/li&gt; &#xA; &lt;li&gt;4 GB of RAM&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Performance may vary depending on both host and guest configuration. Most emulation logic is executed in a single thread, therefore generally systems with better IPC (instructions per clock) should be able to emulate higher clock speeds.&lt;/p&gt; &#xA;&lt;p&gt;It is also recommended to use a manager application with 86Box for easier handling of multiple virtual machines.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/86Box/86BoxManager&#34;&gt;86Box Manager&lt;/a&gt; by &lt;a href=&#34;https://github.com/daviunic&#34;&gt;Overdoze&lt;/a&gt; (Windows only)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/insanemal/86box_manager_py&#34;&gt;86Box Manager Lite&lt;/a&gt; by &lt;a href=&#34;https://github.com/insanemal&#34;&gt;Insanemal&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/86Box/WinBox-for-86Box&#34;&gt;WinBox for 86Box&lt;/a&gt; by Laci bá&#39; (Windows only)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;However, it is also possible to use 86Box on its own with the &lt;code&gt;--vmpath&lt;/code&gt;/&lt;code&gt;-P&lt;/code&gt; command line option.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://86box.readthedocs.io/en/latest/index.html&#34;&gt;our documentation&lt;/a&gt; for an overview of the emulator&#39;s features and user interface.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;We operate an IRC channel and a Discord server for discussing 86Box, its development and anything related to retro computing. We look forward to hearing from you!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://kiwiirc.com/client/irc.ringoflightning.net/?nick=86box%7C?#86Box&#34;&gt;&lt;img src=&#34;https://kiwiirc.com/buttons/irc.ringoflightning.net/86Box.png&#34; alt=&#34;Visit our IRC channel&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/QXK9XTv&#34;&gt;&lt;img src=&#34;https://discordapp.com/api/guilds/262614059009048590/embed.png&#34; alt=&#34;Visit our Discord server&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Licensing&lt;/h2&gt; &#xA;&lt;p&gt;86Box is released under the &lt;a href=&#34;https://www.gnu.org/licenses/old-licenses/gpl-2.0.html&#34;&gt;GNU General Public License, version 2&lt;/a&gt; or later. For more information, see the &lt;code&gt;COPYING&lt;/code&gt; file in the root of the repository.&lt;/p&gt; &#xA;&lt;p&gt;The emulator can also optionally make use of &lt;a href=&#34;https://github.com/munt/munt&#34;&gt;munt&lt;/a&gt;, &lt;a href=&#34;https://www.fluidsynth.org/&#34;&gt;FluidSynth&lt;/a&gt;, &lt;a href=&#34;https://www.ghostscript.com/&#34;&gt;Ghostscript&lt;/a&gt; and &lt;a href=&#34;https://discord.com/developers/docs/game-sdk/sdk-starter-guide&#34;&gt;Discord Game SDK&lt;/a&gt;, which are distributed under their respective licenses.&lt;/p&gt; &#xA;&lt;h2&gt;Donations&lt;/h2&gt; &#xA;&lt;p&gt;We do not charge you for the emulator but donations are still welcome: &lt;a href=&#34;https://paypal.me/86Box&#34;&gt;https://paypal.me/86Box&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also support the project on Patreon: &lt;a href=&#34;https://www.patreon.com/86box&#34;&gt;https://www.patreon.com/86box&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>