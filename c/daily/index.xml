<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-18T01:31:23Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>LloydLabs/shellcode-plain-sight</title>
    <updated>2023-02-18T01:31:23Z</updated>
    <id>tag:github.com,2023-02-18:/LloydLabs/shellcode-plain-sight</id>
    <link href="https://github.com/LloydLabs/shellcode-plain-sight" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Hiding shellcode in plain sight within a large memory region. Inspired by technique used by Raspberry Robin&#39;s Roshtyak&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Hiding Shellcode In Plain Sight&lt;/h1&gt; &#xA;&lt;p&gt;This technique is very simple, a RW memory region 2048 the size of the shellcode is allocated. This region is then filled with randomized data data (&lt;code&gt;RtlGenRandom&lt;/code&gt;), the shellcode is then placed &lt;strong&gt;randomly&lt;/strong&gt; somewhere within this massive region each time. This makes it hard for an AV/EDR solution, or an analyst, to simply see where the shellcode is in-memory. To summarize:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Allocate a large &lt;code&gt;PAGE_READWRITE&lt;/code&gt; region, &lt;code&gt;2048 * size&lt;/code&gt; of the target shellcode, and align to &lt;code&gt;0x1000&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fill this allocated region with random data&lt;/li&gt; &#xA; &lt;li&gt;Write the shellcode to a random location within this region, save position&lt;/li&gt; &#xA; &lt;li&gt;Change the page permissions to &lt;code&gt;PAGE_EXECUTE&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Execute the shellcode (page + position)&lt;/li&gt; &#xA; &lt;li&gt;Zero the memory where the entire large region is to ensure the data does not persist after being freed, using the &lt;code&gt;RtlZeroMemory&lt;/code&gt; macro&lt;/li&gt; &#xA; &lt;li&gt;Free the region of memory&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Example&lt;/h1&gt; &#xA;&lt;p&gt;As can be seen below, the entropy does not change much at all. It is not obvious, from e.g. a memory dump, where the shellcode is actually situated. This can be seen inside &lt;code&gt;example_pop_calc.c&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/96ixWdw.png&#34; alt=&#34;Memory dump entropy&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can execute the shellcode however you wish. This code is simply to demonstrate the simple technique. This technique was originally detailed in Avast&#39;s Raspberry Robin writeup &lt;a href=&#34;https://decoded.avast.io/janvojtesek/raspberry-robins-roshtyak-a-little-lesson-in-trickery/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>wagiminator/CH552-USB-Knob</title>
    <updated>2023-02-18T01:31:23Z</updated>
    <id>tag:github.com,2023-02-18:/wagiminator/CH552-USB-Knob</id>
    <link href="https://github.com/wagiminator/CH552-USB-Knob" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rotary Encoder with NeoPixels and USB Interface&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CH552E USB Knob - Rotary Encoder with USB Interface&lt;/h1&gt; &#xA;&lt;p&gt;The USB Knob is a versatile device that combines the functionality of a rotary encoder with the convenience of a USB interface. It is based on either the CH552E or CH554E microcontroller and is equipped with addressable LEDs, commonly known as NeoPixels. The unique combination of these components makes the USB Knob an ideal choice for a wide range of applications, including volume control for PCs.&lt;/p&gt; &#xA;&lt;p&gt;One of the standout features of the USB Knob is that it requires no driver installation, making it incredibly easy to use. The device acts as a HID custom keyboard, meaning that it can be recognized and utilized by most computers without the need for additional software.&lt;/p&gt; &#xA;&lt;p&gt;The accompanying example firmware for the USB Knob further streamlines the process of using this device, providing users with a simple and effective means of controlling the volume on their computer. The code implements a volume control knob that can be used to adjust the volume levels of a PC, making it easy to regulate the audio output without having to navigate through menus or use complicated software.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wagiminator/CH552-USB-Knob/main/documentation/USB_Knob_pic1.jpg&#34; alt=&#34;USB_Knob_pic1.jpg&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Hardware&lt;/h1&gt; &#xA;&lt;h2&gt;Schematic&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wagiminator/CH552-USB-Knob/main/documentation/USB_Knob_wiring.png&#34; alt=&#34;USB_Knob_wiring.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;CH552E 8-bit USB Device Microcontroller&lt;/h2&gt; &#xA;&lt;p&gt;The CH552E is a low-cost, enhanced E8051 core microcontroller compatible with the MCS51 instruction set. It has an integrated USB 2.0 controller with full-speed data transfer (12 Mbit/s) and supports up to 64 byte data packets with integrated FIFO and direct memory access (DMA). The CH552E has a factory built-in bootloader so firmware can be uploaded directly via USB without the need for an additional programming device.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wagiminator/CH552-USB-Knob/main/documentation/USB_Knob_pic2.jpg&#34; alt=&#34;USB_Knob_pic2.jpg&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Compiling and Installing Firmware&lt;/h1&gt; &#xA;&lt;h2&gt;Installing Toolchain for CH55x&lt;/h2&gt; &#xA;&lt;p&gt;Install the &lt;a href=&#34;https://github.com/Blinkinlabs/ch554_sdcc&#34;&gt;CH55x Software Development Kit for the SDCC compiler&lt;/a&gt;. Follow the instructions on the website. In order for the programming tool to work, Python3 must be installed on your system. To do this, follow these &lt;a href=&#34;https://www.pythontutorial.net/getting-started/install-python/&#34;&gt;instructions&lt;/a&gt;. In addition &lt;a href=&#34;https://github.com/pyusb/pyusb&#34;&gt;PyUSB&lt;/a&gt; must be installed. On Linux (Debian-based), all of this can be done with the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install sdcc python3 python3-pip&#xA;sudo pip install pyusb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installing Drivers for the CH55x Bootloader&lt;/h2&gt; &#xA;&lt;p&gt;On Linux you do not need to install a driver. However, by default Linux will not expose enough permission to upload your code with the USB bootloader. In order to fix this, open a terminal and run the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo &#39;SUBSYSTEM==&#34;usb&#34;, ATTR{idVendor}==&#34;4348&#34;, ATTR{idProduct}==&#34;55e0&#34;, MODE=&#34;666&#34;&#39; | sudo tee /etc/udev/rules.d/99-ch55x.rules&#xA;sudo service udev restart&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Windows you will need the &lt;a href=&#34;https://zadig.akeo.ie/&#34;&gt;Zadig tool&lt;/a&gt; to install the correct driver for the CH55x bootloader. Click &#34;Options&#34; and &#34;List All Devices&#34; to select the USB module, then install the libusb-win32 driver.&lt;/p&gt; &#xA;&lt;h2&gt;Entering CH55x Bootloader Mode&lt;/h2&gt; &#xA;&lt;p&gt;A brand new chip starts automatically in bootloader mode as soon as it is connected to the PC via USB. Once firmware has been uploaded, the bootloader must be started manually for new uploads. To do this, the board must first be disconnected from the USB port and all voltage sources. Now press the BOOT button and keep it pressed while reconnecting the board to the USB port of your PC. The chip now starts again in bootloader mode, the BOOT button can be released and new firmware can be uploaded within the next couple of seconds.&lt;/p&gt; &#xA;&lt;h2&gt;Compiling and Uploading Firmware&lt;/h2&gt; &#xA;&lt;p&gt;Open a terminal and navigate to the folder with the makefile. Run &lt;code&gt;make flash&lt;/code&gt; to compile and upload the firmware. If you don&#39;t want to compile the firmware yourself, you can also upload the precompiled binary. To do this, just run &lt;code&gt;python3 ./tools/chprog.py usb_knob.bin&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;References, Links and Notes&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://oshwlab.com/wagiminator&#34;&gt;EasyEDA Design Files&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.wch-ic.com/downloads/CH552DS1_PDF.html&#34;&gt;CH551/552 Datasheet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://sdcc.sourceforge.net/&#34;&gt;SDCC Compiler&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wagiminator/ATtiny85-TinyKnob&#34;&gt;ATtiny85 TinyKnob&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wagiminator/CH552-USB-Knob/main/documentation/USB_Knob_pic3.jpg&#34; alt=&#34;USB_Knob_pic3.jpg&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wagiminator/CH552-USB-Knob/main/documentation/USB_Knob_pic4.jpg&#34; alt=&#34;USB_Knob_pic4.jpg&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.creativecommons.org/l/by-sa/3.0/88x31.png&#34; alt=&#34;license.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This work is licensed under Creative Commons Attribution-ShareAlike 3.0 Unported License. (&lt;a href=&#34;http://creativecommons.org/licenses/by-sa/3.0/&#34;&gt;http://creativecommons.org/licenses/by-sa/3.0/&lt;/a&gt;)&lt;/p&gt;</summary>
  </entry>
</feed>