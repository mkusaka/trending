<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-09-30T01:29:09Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>OpenPrinting/cups-browsed</title>
    <updated>2024-09-30T01:29:09Z</updated>
    <id>tag:github.com,2024-09-30:/OpenPrinting/cups-browsed</id>
    <link href="https://github.com/OpenPrinting/cups-browsed" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OpenPrinting cups-browsed v2.0.1 - 2024-08-15&lt;/h1&gt; &#xA;&lt;p&gt;Looking for compile instructions? Read the file &#34;INSTALL&#34; instead...&lt;/p&gt; &#xA;&lt;h2&gt;INTRODUCTION&lt;/h2&gt; &#xA;&lt;p&gt;CUPS is a standards-based, open-source printing system used by Apple&#39;s Mac OS® and other UNIX®-like operating systems, especially also Linux. CUPS uses the Internet Printing Protocol (&#34;IPP&#34;) and provides System V and Berkeley command-line interfaces, a web interface, and a C API to manage printers and print jobs.&lt;/p&gt; &#xA;&lt;p&gt;This package contains cups-browsed, a helper daemon to browse the network for remote CUPS queues and IPP network printers and automatically create local queues pointing to them.&lt;/p&gt; &#xA;&lt;p&gt;cups-browsed has the following functionality:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Auto-discover print services advertised via DNS-SD (network printers, IPP-over-USB printers, Printer Applications, remote CUPS queues) and create local queues pointing to them. CUPS usually automatically creates temporary queues for such print services, but several print dialogs use old CUPS APIs and therefore require permanent local queues to see such printers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Auto-discover shared printers on remote CUPS servers running CUPS 1.5.x or older via legacy CUPS browsing. This is intended for settings with print servers running long-term-support enterprise distributions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Broadcast shared local printers using legacy CUPS browsing (of CUPS 1.5.x) for settings with printing clients running long-term-support enterprise distributions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Creating printer clusters where jobs are printed to one single queue and get automatically passed on to a suitable member printer.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Manual (via config file) and automatic (equally-named remote CUPS printers form local cluster, as in legacy CUPS 1.5.x and older) creation of cluster queues&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;If member printers are different models/types, the local queue gets the totality of all their features, options, and choices. Job goes to printer which actually supports the user-selected job settings. So in a cluster of photo printer, fast laser, and large format selecting photo paper for example makes the job go to the photo printer, duplex makes it go to the laser, A2 paper to the large format ... So user has one queue for all printers, they select features, not printers for their jobs ...&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Automatic selection of destination printer depending on job option settings&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Load balancing on equally suitable printers&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;implicitclass&lt;/code&gt; backend holds the job, waits for instructions about the destination printer of cups-browsed, converts the (PDF) job to one of the destination&#39;s (driverless) input formats, and passes on the job.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Highly configurable: Which printers are considered? For which type of printers queues are created? Cluster types and member printers? which names auto-created queues should get? DNS-SD and/or legacy browsing? ...&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Multi-threading allows several tasks to be done in parallel and assures responsiveness of the daemon when there is a large amount of printers available in the network.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For compiling and using this package CUPS (2.2.2 or newer), libcupsfilters 2.x, libppd, libavahi-common, libavahi-client, libdbus, and glib are needed.&lt;/p&gt; &#xA;&lt;p&gt;It also needs gcc (C compiler), automake, autoconf, autopoint, and libtool. On Debian, Ubuntu, and distributions derived from them you could also install the &#34;build-essential&#34; package to auto-install most of these packages.&lt;/p&gt; &#xA;&lt;p&gt;Report bugs to &lt;a href=&#34;https://github.com/OpenPrinting/cups-browsed/issues&#34;&gt;GitHub Issues for cups-browsed&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;See the &#34;COPYING&#34;, &#34;LICENCE&#34;, and &#34;NOTICE&#34; files for legal information. The license is the same as for CUPS, for a maximum of compatibility.&lt;/p&gt; &#xA;&lt;h2&gt;LINKS&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://openprinting.github.io/achievements/#cups-browsed&#34;&gt;Short history of cups-browsed&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;TEST SUITE&lt;/h2&gt; &#xA;&lt;p&gt;The script test/run-tests.sh creates emulations of IPP printers via &#34;ippeveprinter&#34; (of CUPS 2.x) and checks whether cups-browsed creates corresponding CUPS queues, whether a job to such a queue gets actually printed, and whether cups-browsed removes the queues again when the printers are shut down.&lt;/p&gt; &#xA;&lt;p&gt;SIDE EFFECT: By developing this script cups-browsed got tested running as non-root user (only needs to be member of the &#34;lpadmin&#34; group) and works properly this way. Appropriate distribution packaging is recommended to improve system security.&lt;/p&gt; &#xA;&lt;p&gt;REQUIREMENTS:&lt;/p&gt; &#xA;&lt;p&gt;Most of these are already needed for building or using cups-browsed.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;CUPS 2.x must be installed: cupsd, lpstat, lp, ippevepriner, cups-config, and everything needed to run cupsd.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;cups-filters 2.x needs to be installed, providing the filters for processing print jobs and the &#34;driverless&#34; utility to discover printers via shell script.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;cups-browsed 2.x needs to be installed for test mode 3 or for running the script as root.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The script has different modes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Run without arguments by &#34;make&#34; it goes into &#34;make check&#34; mode, copying the files of the system&#39;s CUPS (to pull it out of the distro&#39;s AppArmor harness of the distro, run it as normal user, and modify the configuration) to run an own CUPS instance on port 8631, and running the cups-browsed executable built by &#34;make&#34;, attached to this CUPS instance.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run without arguments directly it asks the use for the test mode and whether tey want to run the daemons under Valgrind. Modes are&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;0: Only start cupsd and cups-browsed, for manual testing independent of the system&#39;s environment&lt;/li&gt; &#xA;   &lt;li&gt;1: As 0, but also run the 2 ippeveprinter instances to emulate printers&lt;/li&gt; &#xA;   &lt;li&gt;2: Run the &#34;make check&#34; mode described above.&lt;/li&gt; &#xA;   &lt;li&gt;3: Do the same tests as in &#34;make check&#34; mode, but use the system&#39;s CUPS and cups-browsed. This mode is for the autopkgtest of Debian and Ubuntu, or for CI tests in general.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run with a number (0-3) as argument the appropriate mode is selected, run with a number (0-3) as first and &#34;yes&#34; or &#34;no&#34; as second argument using or not using Valgrind is also selected.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Running the script as root always uses the system&#39;s CUPS and cups-browsed.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The test&#39;s CUPS instance and all log files are held in /tmp/cups-browsed${USER}/.&lt;/p&gt; &#xA;&lt;h2&gt;DOCUMENTATION FROM CUPS-FILTERS 1.x&lt;/h2&gt; &#xA;&lt;p&gt;Most of this is still valid for the current cups-browsed.&lt;/p&gt; &#xA;&lt;h3&gt;HELPER DAEMON FOR BROWSING REMOTE CUPS PRINTERS AND IPP NETWORK PRINTERS&lt;/h3&gt; &#xA;&lt;p&gt;From version 1.6.0 on in CUPS the CUPS broadcasting/browsing facility was dropped, in favour of Bonjour-based broadcasting of shared printers. This is done as Bonjour broadcasting of shared printers is a standard, established by the PWG (Printing Working Group, &lt;a href=&#34;http://www.pwg.org/&#34;&gt;http://www.pwg.org/&lt;/a&gt;), and most other network services (shared file systems, shared media files/streams, remote desktop services, ...) are also broadcasted via Bonjour.&lt;/p&gt; &#xA;&lt;p&gt;Problem is that CUPS only broadcasts its shared printers but does not browse broadcasts of other CUPS servers to make the shared remote printers available locally without any configuration efforts. This is a regression compared to the old CUPS broadcasting/browsing. The intention of CUPS upstream is that the application&#39;s print dialogs browse the Bonjour broadcasts as an AirPrint-capable iPhone does, but it will take its time until all toolkit developers add the needed functionality, and programs using old toolkits or no toolkits at all, or the command line stay uncovered.&lt;/p&gt; &#xA;&lt;p&gt;The solution is cups-browsed, a helper daemon running in parallel to the CUPS daemon which listens to Bonjour broadcasts of shared CUPS printers on remote machines in the local network via Avahi, and can also listen for (and send) CUPS Browsing broadcasts. For each reported remote printer it creates a local raw queue pointing to the remote printer so that the printer appears in local print dialogs and is also available for printing via the command line. As with the former CUPS broadcasting/browsing with this queue the driver on the server is used and the local print dialogs give access to all options of the server-side printer driver.&lt;/p&gt; &#xA;&lt;p&gt;Note that CUPS broadcasting/browsing is available for legacy support, to let the local CUPS daemon work seamlessly together with remote CUPS daemons of version 1.5.x and older which only support CUPS broadcasting/browsing. In networks with only CUPS 1.6.x servers (or Ubuntu or Fedora/Red Hat servers with CUPS 1.5.x) please use the native Bonjour broadcasting of your servers and cups-browsed, configured for Bonjour browsing only on the clients.&lt;/p&gt; &#xA;&lt;p&gt;Also high availability with redundant print servers and load balancing is supported. If there is more than one server providing a shared print queue with the same name, cups-browsed forms a cluster locally with this name as queue name and printing through the &#34;implicitclass&#34; backend. Each job triggers cups-browsed to check which remote queue is suitable for the job, meaning that it is enabled, accepts jobs, and is not currently printing. If none of the remote queues fulfills these criteria, we check again in 5 seconds, until a printer gets free to accommodate the job. When we search for a free printer, we do not start at the first in the list, but always on the one after the last one used (as CUPS also does with classes), so that all printer get used, even if the frequency of jobs is low. This is also what CUPS formerly did with implicit classes. Optionally, jobs can be sent immediately into the remote queue with the lowest number of waiting jobs, so that no local queue of waiting jobs is built up.&lt;/p&gt; &#xA;&lt;p&gt;For maximum security cups-browsed uses IPPS (encrypted IPP) whenever possible.&lt;/p&gt; &#xA;&lt;p&gt;In addition, cups-browsed is also capable of discovering IPP network printers (native printers, not CUPS queues) with known page description languages (PWG Raster, Apple Raster, PDF, PostScript, PCL XL, PCL 5c/e) in the local network and auto-create print queues with auto-created PPD files. This functionality is primarily for mobile devices running CUPS to not need a printer setup tool nor a collection of printer drivers and PPDs.&lt;/p&gt; &#xA;&lt;p&gt;cups-browsed can also be started on-demand, for example to save resources on mobile devices. For this, cups-browsed can be set into an auto shutdown mode so that it stops automatically when it has no remote printers to take care of any more, especially if an on-demand running avahi-daemon stops. Note that CUPS must stay running for cups-browsed removing its queues and so being able to shut down. Ideal is if CUPS stays running another 30 seconds after finishing its last job so that cups-browsed can take down the queue. For how to set up and control this mode via command line, configuration directives, or sending signals see the man pages cups-browsed(8) and cups-browsed.conf(5).&lt;/p&gt; &#xA;&lt;p&gt;The configuration file for cups-browsed is /etc/cups/cups-browsed.conf. This file can include limited forms of the original CUPS BrowseRemoteProtocols, BrowseLocalProtocols, BrowsePoll, and BrowseAllow directives. It also can contain the new CreateIPPPrinterQueues to activate discovering of IPP network printers and creating PPD-less queues for them.&lt;/p&gt; &#xA;&lt;p&gt;Note that cups-browsed does not work with remote CUPS servers specified by a client.conf file. It always connects to the local CUPS daemon by setting the CUPS_SERVER environment variable and so overriding client.conf. If your local CUPS daemon uses a non-standard domain socket as only way of access, you need to specify it via the DomainSocket directive in /etc/cups/cups-browsed.conf.&lt;/p&gt; &#xA;&lt;p&gt;The &#34;make install&#34; process installs init scripts which make the daemon automatically started during boot. You can also manually start it with (as root):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/usr/sbin/cups-browsed &amp;amp;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or in debug mode with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/usr/sbin/cups-browsed --debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Shut it down by sending signal 2 (SIGINT) or 15 (SIGTERM) to it. The queues which it has created get removed then (except a queue set as system default, to not loose its system default state).&lt;/p&gt; &#xA;&lt;p&gt;On systems using systemd use a /usr/lib/systemd/system/cups-browsed.service file like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Unit]&#xA;Description=Make remote CUPS printers available locally&#xA;After=cups.service avahi-daemon.service&#xA;Wants=cups.service avahi-daemon.service&#xA;&#xA;[Service]&#xA;ExecStart=/usr/sbin/cups-browsed&#xA;&#xA;[Install]&#xA;WantedBy=multi-user.target&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On systems using Upstart use an /etc/init/cups-browsed.conf file like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;start on (filesystem&#xA;          and (started cups or runlevel [2345]))&#xA;stop on runlevel [016]&#xA;&#xA;respawn&#xA;respawn limit 3 240&#xA;&#xA;pre-start script&#xA;    [ -x /usr/sbin/cups-browsed ]&#xA;end script&#xA;&#xA;exec /usr/sbin/cups-browsed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These files are included in the source distribution as utils/cups-browsed.service and utils/cups-browsed-upstart.conf.&lt;/p&gt; &#xA;&lt;p&gt;In the examples we start cups-browsed after starting avahi-daemon. This is not required. If cups-browsed starts first, then Bonjour/DNS-SD browsing kicks in as soon as avahi-daemon comes up. cups-browsed is also robust against any shutdown and restart of avahi-daemon.&lt;/p&gt; &#xA;&lt;p&gt;Here is some info on how cups-browsed works internally (first concept of a daemon which does only Bonjour browsing):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- Daemon start&#xA;  o Wait for CUPS daemon if it is not running&#xA;  o Read out all CUPS queues created by this daemon (in former sessions)&#xA;  o Mark them unconfirmed and set timeout 10 sec from now&#xA;- Main loop (use avahi_simple_poll_iterate() to do queue list maintenance&#xA;             regularly)&#xA;  o Event: New printer shows up&#xA;    + Queue for printer is already created by this daemon -&amp;gt; Mark list&#xA;      entry confirmed, if discovered printer is ipps but existing queue ipp,&#xA;  upgrade existing queue by setting URI to ipps. Set status to&#xA;  to-be-created and timeout to now-1 sec to make the CUPS queue be&#xA;  updated.&#xA;    + Queue does not yet exist -&amp;gt; Mark as to-be-created and set&#xA;  timeout to now-1 sec.&#xA;  o Event: A printer disappears&#xA;    + If we have listed a queue for it, mark the entry as disappeared, set&#xA;      timeout to now-1 sec&#xA;  o On any of the above events and every 2 sec&#xA;    + Check through list of our listed queues&#xA;      - If queue is unconfirmed and timeout has passed, mark it as&#xA;        disappeared, set timeout to now-1 sec&#xA;      - If queue is marked disappered and timeout has passed, check whether&#xA;    there are still jobs in it, if yes, set timeout to 10 sec from now,&#xA;    if no, remove the CUPS queue and the queue entry in our list. If&#xA;    removal fails, set timeout to 10 sec.&#xA;  - If queue is to-be-created, create it, if succeeded set to&#xA;    confirmed, if not, set timeout to 10 sec fron now. printer-is-shared&#xA;    must be set to false.&#xA;- Daemon shutdown&#xA;  o Remove all CUPS queues in our list, as long as they do not have jobs.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Do not overwrite existing queues which are not created by us If the simple &amp;lt;remote_printer&amp;gt; name is already taken, try to create a &amp;lt;remote_printer&amp;gt;@&#xA; &lt;server&gt;&#xA;   name, if this is also taken, ignore the remote printer. Do not retry, to avoid polling CUPS all the time.&#xA; &lt;/server&gt;&lt;/p&gt; &#xA;&lt;p&gt;Do not remove queues which are not created by us. We do this by listing only our queues and remove only listed queues.&lt;/p&gt; &#xA;&lt;p&gt;Queue names: Use the name of the remote queue. If a queue with the same name from another server already exists, mark the new queue as duplicate and when a queue disappears, check whether it has duplicates and change the URI of the disappeared queue to the URI of the first duplicate, mark the queue as to-be-created with timeout now-1 sec (to update the URI of the CUPS queue) and mark the duplicate disappeared with timeout now-1 sec. In terms of high availability we replace the old load balancing of the implicit class by a failover solution. Alternatively (not implemented), if queue with same name but from other server appears, create new queue as &#xA; &lt;original name&gt;&#xA;  @&amp;lt;server name without .local&amp;gt;. When queue with simple name is removed, replace the first of the others by one with simple name (mark old queue disappeared with timeout now-1 sec and create new queue with simple name).&#xA; &lt;/original&gt;&lt;/p&gt; &#xA;&lt;p&gt;Fill description of the created CUPS queue with the Bonjour service name (= original description) and location with the server name without .local.&lt;/p&gt; &#xA;&lt;p&gt;stderr messages only in debug mode (command line options: &#34;--debug&#34; or &#34;-d&#34; or &#34;-v&#34;).&lt;/p&gt; &#xA;&lt;p&gt;Queue identified as from this daemon by doing the equivalent of &#34;lpadmin -p printer -o cups-browsed-default&#34;, this generates a &#34;cups-browsed&#34; attribute in printers.conf with value &#34;true&#34;.&lt;/p&gt;</summary>
  </entry>
</feed>