<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-14T01:31:34Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nodejs/http-parser</title>
    <updated>2023-01-14T01:31:34Z</updated>
    <id>tag:github.com,2023-01-14:/nodejs/http-parser</id>
    <link href="https://github.com/nodejs/http-parser" rel="alternate"></link>
    <summary type="html">&lt;p&gt;http request/response parser for c&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;HTTP Parser&lt;/h1&gt; &#xA;&lt;p&gt;http-parser is &lt;a href=&#34;https://github.com/nodejs/http-parser/issues/522&#34;&gt;&lt;strong&gt;not&lt;/strong&gt; actively maintained&lt;/a&gt;. New projects and projects looking to migrate should consider &lt;a href=&#34;https://github.com/nodejs/llhttp&#34;&gt;llhttp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/nodejs/http-parser&#34;&gt;&lt;img src=&#34;https://api.travis-ci.org/nodejs/http-parser.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is a parser for HTTP messages written in C. It parses both requests and responses. The parser is designed to be used in performance HTTP applications. It does not make any syscalls nor allocations, it does not buffer data, it can be interrupted at anytime. Depending on your architecture, it only requires about 40 bytes of data per message stream (in a web server that is per connection).&lt;/p&gt; &#xA;&lt;p&gt;Features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;No dependencies&lt;/li&gt; &#xA; &lt;li&gt;Handles persistent streams (keep-alive).&lt;/li&gt; &#xA; &lt;li&gt;Decodes chunked encoding.&lt;/li&gt; &#xA; &lt;li&gt;Upgrade support&lt;/li&gt; &#xA; &lt;li&gt;Defends against buffer overflow attacks.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The parser extracts the following information from HTTP messages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Header fields and values&lt;/li&gt; &#xA; &lt;li&gt;Content-Length&lt;/li&gt; &#xA; &lt;li&gt;Request method&lt;/li&gt; &#xA; &lt;li&gt;Response status code&lt;/li&gt; &#xA; &lt;li&gt;Transfer-Encoding&lt;/li&gt; &#xA; &lt;li&gt;HTTP version&lt;/li&gt; &#xA; &lt;li&gt;Request URL&lt;/li&gt; &#xA; &lt;li&gt;Message body&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;One &lt;code&gt;http_parser&lt;/code&gt; object is used per TCP connection. Initialize the struct using &lt;code&gt;http_parser_init()&lt;/code&gt; and set the callbacks. That might look something like this for a request parser:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;http_parser_settings settings;&#xA;settings.on_url = my_url_callback;&#xA;settings.on_header_field = my_header_field_callback;&#xA;/* ... */&#xA;&#xA;http_parser *parser = malloc(sizeof(http_parser));&#xA;http_parser_init(parser, HTTP_REQUEST);&#xA;parser-&amp;gt;data = my_socket;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When data is received on the socket execute the parser and check for errors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;size_t len = 80*1024, nparsed;&#xA;char buf[len];&#xA;ssize_t recved;&#xA;&#xA;recved = recv(fd, buf, len, 0);&#xA;&#xA;if (recved &amp;lt; 0) {&#xA;  /* Handle error. */&#xA;}&#xA;&#xA;/* Start up / continue the parser.&#xA; * Note we pass recved==0 to signal that EOF has been received.&#xA; */&#xA;nparsed = http_parser_execute(parser, &amp;amp;settings, buf, recved);&#xA;&#xA;if (parser-&amp;gt;upgrade) {&#xA;  /* handle new protocol */&#xA;} else if (nparsed != recved) {&#xA;  /* Handle error. Usually just close the connection. */&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;http_parser&lt;/code&gt; needs to know where the end of the stream is. For example, sometimes servers send responses without Content-Length and expect the client to consume input (for the body) until EOF. To tell &lt;code&gt;http_parser&lt;/code&gt; about EOF, give &lt;code&gt;0&lt;/code&gt; as the fourth parameter to &lt;code&gt;http_parser_execute()&lt;/code&gt;. Callbacks and errors can still be encountered during an EOF, so one must still be prepared to receive them.&lt;/p&gt; &#xA;&lt;p&gt;Scalar valued message information such as &lt;code&gt;status_code&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt;, and the HTTP version are stored in the parser structure. This data is only temporally stored in &lt;code&gt;http_parser&lt;/code&gt; and gets reset on each new message. If this information is needed later, copy it out of the structure during the &lt;code&gt;headers_complete&lt;/code&gt; callback.&lt;/p&gt; &#xA;&lt;p&gt;The parser decodes the transfer-encoding for both requests and responses transparently. That is, a chunked encoding is decoded before being sent to the on_body callback.&lt;/p&gt; &#xA;&lt;h2&gt;The Special Problem of Upgrade&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;http_parser&lt;/code&gt; supports upgrading the connection to a different protocol. An increasingly common example of this is the WebSocket protocol which sends a request like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    GET /demo HTTP/1.1&#xA;    Upgrade: WebSocket&#xA;    Connection: Upgrade&#xA;    Host: example.com&#xA;    Origin: http://example.com&#xA;    WebSocket-Protocol: sample&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;followed by non-HTTP data.&lt;/p&gt; &#xA;&lt;p&gt;(See &lt;a href=&#34;https://tools.ietf.org/html/rfc6455&#34;&gt;RFC6455&lt;/a&gt; for more information the WebSocket protocol.)&lt;/p&gt; &#xA;&lt;p&gt;To support this, the parser will treat this as a normal HTTP message without a body, issuing both on_headers_complete and on_message_complete callbacks. However http_parser_execute() will stop parsing at the end of the headers and return.&lt;/p&gt; &#xA;&lt;p&gt;The user is expected to check if &lt;code&gt;parser-&amp;gt;upgrade&lt;/code&gt; has been set to 1 after &lt;code&gt;http_parser_execute()&lt;/code&gt; returns. Non-HTTP data begins at the buffer supplied offset by the return value of &lt;code&gt;http_parser_execute()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Callbacks&lt;/h2&gt; &#xA;&lt;p&gt;During the &lt;code&gt;http_parser_execute()&lt;/code&gt; call, the callbacks set in &lt;code&gt;http_parser_settings&lt;/code&gt; will be executed. The parser maintains state and never looks behind, so buffering the data is not necessary. If you need to save certain data for later usage, you can do that from the callbacks.&lt;/p&gt; &#xA;&lt;p&gt;There are two types of callbacks:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;notification &lt;code&gt;typedef int (*http_cb) (http_parser*);&lt;/code&gt; Callbacks: on_message_begin, on_headers_complete, on_message_complete.&lt;/li&gt; &#xA; &lt;li&gt;data &lt;code&gt;typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);&lt;/code&gt; Callbacks: (requests only) on_url, (common) on_header_field, on_header_value, on_body;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Callbacks must return 0 on success. Returning a non-zero value indicates error to the parser, making it exit immediately.&lt;/p&gt; &#xA;&lt;p&gt;For cases where it is necessary to pass local information to/from a callback, the &lt;code&gt;http_parser&lt;/code&gt; object&#39;s &lt;code&gt;data&lt;/code&gt; field can be used. An example of such a case is when using threads to handle a socket connection, parse a request, and then give a response over that socket. By instantiation of a thread-local struct containing relevant data (e.g. accepted socket, allocated memory for callbacks to write into, etc), a parser&#39;s callbacks are able to communicate data between the scope of the thread and the scope of the callback in a threadsafe manner. This allows &lt;code&gt;http_parser&lt;/code&gt; to be used in multi-threaded contexts.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt; typedef struct {&#xA;  socket_t sock;&#xA;  void* buffer;&#xA;  int buf_len;&#xA; } custom_data_t;&#xA;&#xA;&#xA;int my_url_callback(http_parser* parser, const char *at, size_t length) {&#xA;  /* access to thread local custom_data_t struct.&#xA;  Use this access save parsed data for later use into thread local&#xA;  buffer, or communicate over socket&#xA;  */&#xA;  parser-&amp;gt;data;&#xA;  ...&#xA;  return 0;&#xA;}&#xA;&#xA;...&#xA;&#xA;void http_parser_thread(socket_t sock) {&#xA; int nparsed = 0;&#xA; /* allocate memory for user data */&#xA; custom_data_t *my_data = malloc(sizeof(custom_data_t));&#xA;&#xA; /* some information for use by callbacks.&#xA; * achieves thread -&amp;gt; callback information flow */&#xA; my_data-&amp;gt;sock = sock;&#xA;&#xA; /* instantiate a thread-local parser */&#xA; http_parser *parser = malloc(sizeof(http_parser));&#xA; http_parser_init(parser, HTTP_REQUEST); /* initialise parser */&#xA; /* this custom data reference is accessible through the reference to the&#xA; parser supplied to callback functions */&#xA; parser-&amp;gt;data = my_data;&#xA;&#xA; http_parser_settings settings; /* set up callbacks */&#xA; settings.on_url = my_url_callback;&#xA;&#xA; /* execute parser */&#xA; nparsed = http_parser_execute(parser, &amp;amp;settings, buf, recved);&#xA;&#xA; ...&#xA; /* parsed information copied from callback.&#xA; can now perform action on data copied into thread-local memory from callbacks.&#xA; achieves callback -&amp;gt; thread information flow */&#xA; my_data-&amp;gt;buffer;&#xA; ...&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case you parse HTTP message in chunks (i.e. &lt;code&gt;read()&lt;/code&gt; request line from socket, parse, read half headers, parse, etc) your data callbacks may be called more than once. &lt;code&gt;http_parser&lt;/code&gt; guarantees that data pointer is only valid for the lifetime of callback. You can also &lt;code&gt;read()&lt;/code&gt; into a heap allocated buffer to avoid copying memory around if this fits your application.&lt;/p&gt; &#xA;&lt;p&gt;Reading headers may be a tricky task if you read/parse headers partially. Basically, you need to remember whether last header callback was field or value and apply the following logic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(on_header_field and on_header_value shortened to on_h_*)&#xA; ------------------------ ------------ --------------------------------------------&#xA;| State (prev. callback) | Callback   | Description/action                         |&#xA; ------------------------ ------------ --------------------------------------------&#xA;| nothing (first call)   | on_h_field | Allocate new buffer and copy callback data |&#xA;|                        |            | into it                                    |&#xA; ------------------------ ------------ --------------------------------------------&#xA;| value                  | on_h_field | New header started.                        |&#xA;|                        |            | Copy current name,value buffers to headers |&#xA;|                        |            | list and allocate new buffer for new name  |&#xA; ------------------------ ------------ --------------------------------------------&#xA;| field                  | on_h_field | Previous name continues. Reallocate name   |&#xA;|                        |            | buffer and append callback data to it      |&#xA; ------------------------ ------------ --------------------------------------------&#xA;| field                  | on_h_value | Value for current header started. Allocate |&#xA;|                        |            | new buffer and copy callback data to it    |&#xA; ------------------------ ------------ --------------------------------------------&#xA;| value                  | on_h_value | Value continues. Reallocate value buffer   |&#xA;|                        |            | and append callback data to it             |&#xA; ------------------------ ------------ --------------------------------------------&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Parsing URLs&lt;/h2&gt; &#xA;&lt;p&gt;A simplistic zero-copy URL parser is provided as &lt;code&gt;http_parser_parse_url()&lt;/code&gt;. Users of this library may wish to use it to parse URLs constructed from consecutive &lt;code&gt;on_url&lt;/code&gt; callbacks.&lt;/p&gt; &#xA;&lt;p&gt;See examples of reading in headers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://gist.github.com/155877&#34;&gt;partial example&lt;/a&gt; in C&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/joyent/http-parser/blob/37a0ff8/test.c#L403&#34;&gt;from http-parser tests&lt;/a&gt; in C&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://github.com/joyent/node/blob/842eaf4/src/http.js#L284&#34;&gt;from Node library&lt;/a&gt; in Javascript&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>greenbone/openvas-scanner</title>
    <updated>2023-01-14T01:31:34Z</updated>
    <id>tag:github.com,2023-01-14:/greenbone/openvas-scanner</id>
    <link href="https://github.com/greenbone/openvas-scanner" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This repository contains the scanner component for Greenbone Community Edition.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://www.greenbone.net/wp-content/uploads/gb_new-logo_horizontal_rgb_small.png&#34; alt=&#34;Greenbone Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;OpenVAS Scanner&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/greenbone/openvas-scanner/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release/greenbone/openvas-scanner.svg?sanitize=true&#34; alt=&#34;GitHub releases&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/greenbone/openvas-scanner&#34;&gt;&lt;img src=&#34;https://img.shields.io/codecov/c/github/greenbone/openvas-scanner.svg?label=Doc%20Coverage&amp;amp;logo=codecov&#34; alt=&#34;Code Documentation Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hub.docker.com/r/greenbone/openvas-scanner/&#34;&gt;&lt;img src=&#34;https://img.shields.io/docker/pulls/greenbone/openvas-scanner.svg?sanitize=true&#34; alt=&#34;Docker Pulls&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hub.docker.com/r/greenbone/openvas-scanner/&#34;&gt;&lt;img src=&#34;https://img.shields.io/docker/image-size/greenbone/openvas-scanner.svg?maxAge=2592000&#34; alt=&#34;Docker Image Size&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/greenbone/openvas-scanner/actions/workflows/ci-c.yml?query=branch%3Amain++&#34;&gt;&lt;img src=&#34;https://github.com/greenbone/openvas-scanner/actions/workflows/ci-c.yml/badge.svg?branch=main&#34; alt=&#34;Build and test&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is the OpenVAS Scanner of the Greenbone Community Edition.&lt;/p&gt; &#xA;&lt;p&gt;It is used for the Greenbone Enterprise appliances and is a full-featured scan engine that executes a continuously updated and extended feed of Vulnerability Tests (VTs).&lt;/p&gt; &#xA;&lt;h2&gt;Releases&lt;/h2&gt; &#xA;&lt;p&gt;All &lt;a href=&#34;https://github.com/greenbone/openvas/releases&#34;&gt;release files&lt;/a&gt; are signed with the &lt;a href=&#34;https://community.greenbone.net/t/gcf-managing-the-digital-signatures/101&#34;&gt;Greenbone Community Feed integrity key&lt;/a&gt;. This gpg key can be downloaded at &lt;a href=&#34;https://www.greenbone.net/GBCommunitySigningKey.asc&#34;&gt;https://www.greenbone.net/GBCommunitySigningKey.asc&lt;/a&gt; and the fingerprint is &lt;code&gt;8AE4 BE42 9B60 A59B 311C 2E73 9823 FAA6 0ED1 E580&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;This module can be configured, built and installed with following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake .&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For detailed installation requirements and instructions, please see the file &lt;a href=&#34;https://raw.githubusercontent.com/greenbone/openvas-scanner/main/INSTALL.md&#34;&gt;INSTALL.md&lt;/a&gt;. The file also contains instructions for setting up &lt;code&gt;openvas&lt;/code&gt; and for making the scanner available to other GVM modules.&lt;/p&gt; &#xA;&lt;p&gt;If you are not familiar or comfortable building from source code, we recommend that you use the Greenbone Enterprise TRIAL, a prepared virtual machine with a readily available setup. Information regarding the virtual machine is available at &lt;a href=&#34;https://www.greenbone.net/en/testnow&#34;&gt;https://www.greenbone.net/en/testnow&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Docker, &lt;a href=&#34;https://greenbone.github.io/docs/latest/22.4/container/&#34;&gt;Greenbone Community Containers&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;If you want to use the docker files provided in this repository you can pull them from &lt;a href=&#34;https://hub.docker.com/r/greenbone/openvas-scanner&#34;&gt;here&lt;/a&gt;. You can also locally build them using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker build -t &amp;lt;image-name&amp;gt; -f .docker/prod.Dockerfile .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information about building docker images, see &lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/build/&#34;&gt;official man&lt;/a&gt;. We also provide a &lt;a href=&#34;https://greenbone.github.io/docs/latest/22.4/container/&#34;&gt;fully containerized solution&lt;/a&gt; for the Greenbone Community Edition.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Please beware: The Greenbone Community Container are currently under development.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;For any question on the usage of &lt;code&gt;openvas&lt;/code&gt; please use the &lt;a href=&#34;https://community.greenbone.net/&#34;&gt;Greenbone Community Portal&lt;/a&gt;. If you found a problem with the software, please &lt;a href=&#34;https://github.com/greenbone/openvas-scanner/issues&#34;&gt;create an issue&lt;/a&gt; on GitHub. If you are a Greenbone customer you may alternatively or additionally forward your issue to the Greenbone Support Portal.&lt;/p&gt; &#xA;&lt;h2&gt;Maintainer&lt;/h2&gt; &#xA;&lt;p&gt;This project is maintained by &lt;a href=&#34;https://www.greenbone.net/&#34;&gt;Greenbone Networks GmbH&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Your contributions are highly appreciated. Please &lt;a href=&#34;https://github.com/greenbone/openvas-scanner/pulls&#34;&gt;create a pull request&lt;/a&gt; on GitHub. Bigger changes need to be discussed with the development team via the &lt;a href=&#34;https://github.com/greenbone/openvas-scanner/issues&#34;&gt;issues section at GitHub&lt;/a&gt; first.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This module is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/greenbone/openvas-scanner/main/COPYING.GPLv2&#34;&gt;GNU General Public License v2.0 only&lt;/a&gt;. Single files, however, are licensed either the GNU General Public License v2.0 only or under GNU General Public License v2.0 or later, please see the &lt;a href=&#34;https://raw.githubusercontent.com/greenbone/openvas-scanner/main/COPYING&#34;&gt;COPYING&lt;/a&gt; file for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kiddin9/openwrt-packages</title>
    <updated>2023-01-14T01:31:34Z</updated>
    <id>tag:github.com,2023-01-14:/kiddin9/openwrt-packages</id>
    <link href="https://github.com/kiddin9/openwrt-packages" rel="alternate"></link>
    <summary type="html">&lt;p&gt;openwrt packages&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;适用于openwrt 19.07 及以上的分支.&lt;/h2&gt; &#xA;&lt;h2&gt;所有插件都为网上收集的开源插件,感谢作者们的付出.&lt;/h2&gt; &#xA;&lt;h2&gt;本仓库所有插件已编译IPK下载&lt;/h2&gt; &#xA;&lt;h3&gt;使用软件源请删除 opkg配置(/etc/opkg.conf) 中的 option check_signature&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;CPU架构&lt;/th&gt; &#xA;   &lt;th&gt;下载地址&lt;/th&gt; &#xA;   &lt;th&gt;适用设备&lt;/th&gt; &#xA;   &lt;th&gt;软件源&lt;/th&gt; &#xA;   &lt;th&gt;更新频率&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;X86_64&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/x86_64/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;64位PC软路由&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/x86_64&#34;&gt;https://op.supes.top/packages/x86_64&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;i386_pentium4&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/i386_pentium4/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;32位PC软路由&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/i386_pentium4&#34;&gt;https://op.supes.top/packages/i386_pentium4&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;aarch64_generic&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/aarch64_generic/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;R2S/R4S等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/aarch64_generic&#34;&gt;https://op.supes.top/packages/aarch64_generic&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;aarch64_cortex-a72&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/aarch64_cortex-a72/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;树莓派4B等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/aarch64_cortex-a72&#34;&gt;https://op.supes.top/packages/aarch64_cortex-a72&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;mipsel_24kc&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/mipsel_24kc/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;k2p,ac2100等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/mipsel_24kc&#34;&gt;https://op.supes.top/packages/mipsel_24kc&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;mips_24kc&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/mips_24kc/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;GL-AR300M,NETGEAR WNDR4300等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/mips_24kc&#34;&gt;https://op.supes.top/packages/mips_24kc&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;aarch64_cortex-a53&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/aarch64_cortex-a53/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;N1,红米AX6,小米AX6S等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/aarch64_cortex-a53&#34;&gt;https://op.supes.top/packages/aarch64_cortex-a53&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;arm_cortex-a9&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a9/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;斐讯K3,华硕RT-AC68U,RT-AC88U等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a9&#34;&gt;https://op.supes.top/packages/arm_cortex-a9&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;arm_cortex-a7_neon-vfpv4&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a7_neon-vfpv4/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;华硕RT-ACRH17,RT-AC58U等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a7_neon-vfpv4&#34;&gt;https://op.supes.top/packages/arm_cortex-a7_neon-vfpv4&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;arm_cortex-a7&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a7/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;GL-iNet AXT1800、AX1800等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a7&#34;&gt;https://op.supes.top/packages/arm_cortex-a7&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;arm_cortex-a9_vfpv3-d16&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a9_vfpv3-d16/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Linksys WRT1900ACS等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a9_vfpv3-d16&#34;&gt;https://op.supes.top/packages/arm_cortex-a9_vfpv3-d16&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;arm_cortex-a5_vfpv4&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a5_vfpv4/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;玩客云等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a5_vfpv4&#34;&gt;https://op.supes.top/packages/arm_cortex-a5_vfpv4&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;arm_cortex-a15_neon-vfpv4&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a15_neon-vfpv4/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;NETGEAR R7800等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/arm_cortex-a15_neon-vfpv4&#34;&gt;https://op.supes.top/packages/arm_cortex-a15_neon-vfpv4&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;arm_xscale&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://op.supes.top/packages/arm_xscale/&#34;&gt;📥&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Linksys EA4500等&lt;/td&gt; &#xA;   &lt;td&gt;src/gz openwrt_kiddin9 &lt;a href=&#34;https://op.supes.top/packages/arm_xscale&#34;&gt;https://op.supes.top/packages/arm_xscale&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;日更&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>