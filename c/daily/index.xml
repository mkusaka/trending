<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-20T01:27:35Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kparc/ksimple</title>
    <updated>2024-01-20T01:27:35Z</updated>
    <id>tag:github.com,2024-01-20:/kparc/ksimple</id>
    <link href="https://github.com/kparc/ksimple" rel="alternate"></link>
    <summary type="html">&lt;p&gt;bare minimum atw-style interpreter for learning purposes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;k/simple&lt;/h1&gt; &#xA;&lt;p&gt;a tiny k interpreter for educational purposes by arthur whitney&lt;/p&gt; &#xA;&lt;h2&gt;target audience&lt;/h2&gt; &#xA;&lt;p&gt;the contents of this repository assume readership who have read and understood &lt;a href=&#34;https://en.wikipedia.org/wiki/The_C_Programming_Language&#34;&gt;k&amp;amp;r&lt;/a&gt; at some point in their careers. any experience with using interpreters of vector languages is beneficial but not necessary. any experience with &lt;strong&gt;implementing&lt;/strong&gt; language interpreters would definitely be of help.&lt;/p&gt; &#xA;&lt;h2&gt;background&lt;/h2&gt; &#xA;&lt;p&gt;in early january 2024, a group of motivated individuals asked &lt;a href=&#34;https://en.wikipedia.org/wiki/Arthur_Whitney_(computer_scientist)&#34;&gt;arthur whitney&lt;/a&gt; to demonstrate the fundamentals of the design, organization and style of his method of writing interpreters in c in the most succinct and approachable way possible.&lt;/p&gt; &#xA;&lt;p&gt;about a day later, arthur offered a tiny interpreter of a toy vector language, implemented in about 25 lines of c with a small header file. his code is published in this repository under &lt;a href=&#34;https://raw.githubusercontent.com/kparc/ksimple/main/ref&#34;&gt;/ref&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;a few days later, the regents of kparc were invited to share their impressions on this codebase, and optionally provide some additional commentary.&lt;/p&gt; &#xA;&lt;p&gt;our commentary is offered in form of two files &lt;code&gt;a.[ch]&lt;/code&gt; in the root of this repository, which serve a number of purposes:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;both files can be seen as two chapters of a small &#34;essay&#34;, header file &lt;a href=&#34;https://raw.githubusercontent.com/kparc/ksimple/main/a.h&#34;&gt;a.h&lt;/a&gt; being the first chapter, &lt;a href=&#34;https://raw.githubusercontent.com/kparc/ksimple/main/a.c&#34;&gt;&lt;code&gt;a.c&lt;/code&gt;&lt;/a&gt; source file being the second. not only the text seeks to explain the code in reasonable detail, which is strictly line by line, but also takes a few liberties and diversions in a bid to elucidate the &#34;bigger picture&#34; behind this tiny piece of code.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;for the ease of comprehension, the narrative has been made &lt;strong&gt;completely linear&lt;/strong&gt;, and hopefully makes for an easy, entertaining and useful read. to make this possible, the original code had seen some very minor restructuring and regrouping; however, no refactoring, no changes to logic or naming conventions have taken place, except for a handful cosmetic enhancements which have been discussed with atw and are seen as beneficial to the cause. the net amount of non-cosmetic changes made to &lt;a href=&#34;https://raw.githubusercontent.com/kparc/ksimple/main/ref/a.c&#34;&gt;ref/a.c&lt;/a&gt; should be in range of 20-25 keystrokes. a number of less trivial one-line functions (e.g. &lt;code&gt;e()&lt;/code&gt;) are presented in &#34;exploded view&#34; to simplify discussion of their control flow and role of individual components.&lt;/p&gt; &lt;p&gt;although the c code of &lt;code&gt;k/simple&lt;/code&gt; is formatted to fit on mobile phone screens in portrait mode, for a more comfortable reading experience we recommend using professional equipment.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;with help of the included &lt;a href=&#34;https://raw.githubusercontent.com/kparc/ksimple/main/makefile&#34;&gt;makefile&lt;/a&gt;, kparc&#39;s &#34;essay&#34; can be built to any available architecture, e.g. riscv, arm, wasm32, xtensa or even x86. default make target assumes presence of a recent gcc, clang or tinyc compiler. there are also two additional handy build targets: &lt;code&gt;make mm&lt;/code&gt;, which removes kparc remarks from the code except for the most essential markup, while the &lt;code&gt;make m&lt;/code&gt; target removes it completely and restores the formatting to resemble the original as close as possible for the ease of reference. these build targets assume presence of a python interpreter and produce files &lt;code&gt;a.min.c&lt;/code&gt; and &lt;code&gt;a.m.c&lt;/code&gt; respectively, build them, and perform a bitwise diff to ensure all three resulting binaries are identical.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;quick start&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd &amp;amp;&amp;amp; git clone https://github.com/kparc/ksimple&#xA;$ cd ksimple &amp;amp;&amp;amp; make&#xA;$ ./a&#xA;k/simple (c) 2024 atw/kpc&#xA; 2+2&#xA;4&#xA; x:!9&#xA; y:2+!9&#xA; x-y&#xA;-2 -2 -2 -2 -2 -2 -2 -2 -2&#xA; z:x,y&#xA; #z&#xA;18&#xA; x+!3&#xA;Add:length&#xA; x@1,5,7&#xA;1 5 7&#xA; ^C&#xA;$ vim k.c&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;language specification / disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;caveat emptor&lt;/em&gt;, manage your expectations. this interpreter is useless for any practical purpose except the stated one, which is education. the language is as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;although k/simple is a computer language, its grammar is defined in terms we normally use to denote parts of human speech. that is, k expression is composed of &lt;strong&gt;verbs&lt;/strong&gt; and &lt;strong&gt;nouns&lt;/strong&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;the definition of &lt;strong&gt;verb&lt;/strong&gt; is something in between definitons of &lt;strong&gt;operation&lt;/strong&gt; in mathematics and &lt;strong&gt;operator&lt;/strong&gt; in computer science. to make things simple, we define &lt;em&gt;verb&lt;/em&gt; as an instruction to the interpreter to do something with exactly one or exactly two operands, or &lt;strong&gt;nouns&lt;/strong&gt;. a verb that takes one noun to operate on is called monadic, and verb that takes two nouns is called dyadic. consider the following two sentences:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;em&gt;shuffle this deck of cards&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;em&gt;take three random cards from this deck&lt;/em&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;in linguistics, the structure of the first sentence is known as verb-only predicate, while the second is a verb-plus-direct-object predicate. in k, we recognize the verb &#34;shuffle&#34; in the first sentence to be monadic, while the second is a dyadic verb &#34;take&#34;. the semantics of an action of a verb is defined by the number of operands given to it, also called &#34;rank&#34; or &#34;valence&#34;. this means that monadic &lt;code&gt;+x&lt;/code&gt; and dyadic &lt;code&gt;x+y&lt;/code&gt; have two entirely different meanings.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;a &lt;strong&gt;verb&lt;/strong&gt; in k/simple can be either an &lt;strong&gt;atom&lt;/strong&gt; (aka scalar value) or a &lt;strong&gt;vector&lt;/strong&gt; (aka ordered list of atoms).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;the one and only type of &lt;strong&gt;atom&lt;/strong&gt; formally supported by k/simple is a signed 8-bit integer (-127,127).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;a vector of atoms is limited in length to unsigned 8-bit integer, that is no more than 255 items.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;k/simple supports 6 verbs, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;, all of which have different meanings depending on their &lt;strong&gt;rank&lt;/strong&gt;. these meanings are very well documented in &lt;a href=&#34;https://raw.githubusercontent.com/kparc/ksimple/main/a.c&#34;&gt;a.c&lt;/a&gt; where they are also declared and defined.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;k expressions are evaluated in a way you&#39;re probably not familiar with, which is &lt;em&gt;right to left&lt;/em&gt;, or, in math speak, &lt;em&gt;left of right&lt;/em&gt;. this only sounds nonsensical until you get lit:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt; 3+2+1     /take 1, add 2, add 3&#xA;6&#xA;&#xA; 3*2+1     /take 1, add 2, multiply by 3&#xA;9&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;k/simple is simple enough to get away without tokenizer and parser. instead, it accepts user input as a string of up to 99 tokens, and evaluiates it token by token strictly left of right (see above). a token in k/simple is a single character, which can be either a verb &lt;code&gt;[+-!#@&lt;/code&gt;,a noun &lt;code&gt;0..9&lt;/code&gt; or a name of a global variable &lt;code&gt;abc..xyz&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;assignment of a value to a global variable is not a verb, and is not &lt;code&gt;=&lt;/code&gt;. instead, it is &lt;code&gt;:&lt;/code&gt;. for example:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;x:42&#xA;x:x+1&#xA;x&#xA; 43&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;no memory management is implemented and no garbage is collected. that is, k/simple devours memory and never releases it, which is fine because it does it with a teaspoon. if you&#39;re not happy with that, it brings you conveniently to the next section of this README.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;suggested exercise&lt;/h2&gt; &#xA;&lt;p&gt;the authors hope that this material enables and inspires further experimentation on reader&#39;s own, which can be a very rewarding and fun pastime. for example, one might consider the following toy problems of various degrees of difficulty:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;i&#39;m too young to die:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;implement a few more simple verbs, e.g. dyadic &lt;code&gt;f*x&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;modify repl to support the exit command (traditionally, a double backslash &lt;code&gt;\\&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;add workspace size monitor (i.e. memory allocation) e.g. to prompt or via extra command (&lt;code&gt;\w&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;hurt me plenty:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;inspect verb implementations provided by atw for edge cases, and add checks (which are intentionally omitted)&lt;/li&gt; &#xA; &lt;li&gt;extend maximum vector length to &lt;code&gt;MAX_UINT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;find and fix at least three segfaults&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;ultraviolence:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;change base type from 8bit integer to &lt;code&gt;long long&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;fix tokenizer to support integer numerals greater than 9 and less than 0&lt;/li&gt; &#xA; &lt;li&gt;fix tokenizer to support efficient direct vector input (e.g. &lt;code&gt;42 57 1010&lt;/code&gt; instead of &lt;code&gt;1,2,3,4&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;implement memory management by refcounting&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;nightmare:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;implement a simple parser (e.g. to support quoted strings and parens)&lt;/li&gt; &#xA; &lt;li&gt;implement nested vectors, and verb &lt;code&gt;flip&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;make vector arithmetic penetrating&lt;/li&gt; &#xA; &lt;li&gt;implement adverbs &lt;code&gt;scan&lt;/code&gt; and &lt;code&gt;over&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;progress takes sacrifice:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;implement floating point type&lt;/li&gt; &#xA; &lt;li&gt;implement functions and local scope&lt;/li&gt; &#xA; &lt;li&gt;implement a test suite for your &lt;code&gt;k&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;//:~&lt;/code&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>janoglezcampos/llvm-yx-callobfuscator</title>
    <updated>2024-01-20T01:27:35Z</updated>
    <id>tag:github.com,2024-01-20:/janoglezcampos/llvm-yx-callobfuscator</id>
    <link href="https://github.com/janoglezcampos/llvm-yx-callobfuscator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;LLVM plugin to transparently apply stack spoofing and indirect syscalls to Windows x64 native calls at compile time.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LLVM-YX-CALLOBFUSCATOR&lt;/h1&gt; &#xA;&lt;p&gt;LLVM plugin to transparently apply stack spoofing and indirect syscalls to Windows x64 native calls at compile time.&lt;/p&gt; &#xA;&lt;h2&gt;&#34;I&#39;ve 5 mins, what is this?&#34;&lt;/h2&gt; &#xA;&lt;p&gt;This project is a plugin meant to be used with &lt;a href=&#34;https://llvm.org/docs/CommandGuide/opt.html&#34;&gt;opt&lt;/a&gt;, the LLVM optimizer. Opt will use the pass included in this plugin to hook calls to Windows functions based on a config file and point those calls to a single function, which, given an ID identifying the function to be called, will apply dynamic stack obfuscation, and if the function is a syscall stub, will invoke it using &#34;indirect syscalling&#34;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Usage brief&lt;/strong&gt;: Set up a config file indicating the functions to be hooked, write your C code without caring about Windows function calls, compile with clang to generate .ir files, give them to opt along with this plugin, opt hooks functions, llc compiles the .ir to a.obj, and ld links it to an executable that automatically obfuscates function calls.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/janoglezcampos/llvm-yx-callobfuscator/main/#setup&#34;&gt;Setup&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/janoglezcampos/llvm-yx-callobfuscator/main/#usage-and-example&#34;&gt;Usage and example&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/janoglezcampos/llvm-yx-callobfuscator/main/#developer-guide&#34;&gt;Developer guide&lt;/a&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/janoglezcampos/llvm-yx-callobfuscator/main/#file-distribution&#34;&gt;File distribution&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/janoglezcampos/llvm-yx-callobfuscator/main/#how-the-pass-works&#34;&gt;How the pass works&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/janoglezcampos/llvm-yx-callobfuscator/main/#how-the-dispatching-system-works&#34;&gt;How the dispatching system works&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/janoglezcampos/llvm-yx-callobfuscator/main/#thanks&#34;&gt;Thanks&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/janoglezcampos/llvm-yx-callobfuscator/main/#todo&#34;&gt;TODO&lt;/a&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;This instructions are written for Windows, but it should be possible to setup this environment in Linux easily (still output executables can only be built for Windows x64). Tested with LLVM 16.x and 17.x.&lt;/p&gt; &#xA;&lt;p&gt;All the commands described in the following steps are supossed to be used in an MSYS2 terminal ie they have Linux format.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Dependencies&lt;/strong&gt;:&lt;/p&gt; &lt;p&gt;To be able to compile this project, we mainly need 2 things: LLVM (libraries and headers, along with some tools) and CMAKE.&lt;/p&gt; &lt;p&gt;LLVM libraries and tools can be either compiled from source, downloaded from the LLVM releases, or installed through MSYS2 (using pacman). To make it easier, here we will use MSYS2. We also need to set up CMAKE and our build tools. Clang is required to compile the helpers library. For the linker, we don&#39;t care too much. Lastly, as a generator, I prefer Ninja, but make, nmake or msbuild will work.&lt;/p&gt; &lt;p&gt;Everything listed above can be installed with pacman by using MSYS2.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Download and install &lt;a href=&#34;https://www.msys2.org/&#34;&gt;MSYS2&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Launch an MSYS2 Mingw64 terminal and install the following packages:&lt;/li&gt; &#xA;   &lt;li&gt;Install LLVM: &lt;code&gt;pacman -S mingw-w64-x86_64-llvm&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Install Clang: &lt;code&gt;pacman -S mingw-w64-x86_64-clang&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Install Nasm: &lt;code&gt;pacman -S mingw-w64-x86_64-nasm&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Install Cmake: &lt;code&gt;pacman -S mingw-w64-x86_64-cmake&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Install Ninja: &lt;code&gt;pacman -S mingw-w64-x86_64-ninja&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Install Git: &lt;code&gt;pacman -S git&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Restart the MSYS2 terminal, It may help with env variables, and gives luck for the following building ritual.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Building&lt;/strong&gt;:&lt;/p&gt; &lt;p&gt;First, clone this project, pretty obvious:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  git clone https://github.com/janoglezcampos/llvm-yx-callobfuscator&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;To build this project, we will be using CMAKE. Because I find it convenient, I use VScode with the CMake extension. You can find my VSCODE config at &lt;code&gt;.vscode_conf/setting.json&lt;/code&gt;&lt;/p&gt; &lt;p&gt;In any other case, launch an MSYS2 Mingw64 terminal and do exactly what I say (without checking what any of the commands Im giving you will do to your beloved machine):&lt;/p&gt; &lt;p&gt;Go to the root directory of this repo:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  cd &amp;lt;whatever&amp;gt;/llvm-yx-obfuscator&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Create a build directory and change the directory to it:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  mkdir build; cd build&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Choose an install location. I recommend doing this so it will be easier to either get the files in the right place or just be able to pick them up easily. Also, the &lt;a href=&#34;https://raw.githubusercontent.com/janoglezcampos/llvm-yx-callobfuscator/main/#usage-and-example&#34;&gt;usage&lt;/a&gt; section will use this folder as the relative folder for accessing these files when needed, so if you add it to the PATH, the commands will work right away. I use &amp;nbsp;&lt;code&gt;C:/Users/&amp;lt;my-user&amp;gt;/llvm-plugins&lt;/code&gt;, but creating a folder in the project directory called &lt;code&gt;install&lt;/code&gt;, side by side with &lt;code&gt;build&lt;/code&gt; will do. This folder will not be edited if you don&#39;t run the install command, but you will have to go get the files in the build folder.&lt;/p&gt; &lt;p&gt;Configure the project; here you specify the installation folder. &lt;code&gt;DCMAKE_BUILD_TYPE&lt;/code&gt; will set the default mode: Debug, Release or MinSizeRel. Depending on which generator you are using, you are going to be able to change this later or not (means you will have to reconfigure or not). I use Nija as generator, but you can use any other.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  cmake -G Ninja -DCMAKE_INSTALL_PREFIX=&#34;&amp;lt;path_to_install_folder&amp;gt;&#34; -DCMAKE_BUILD_TYPE=Release ./..&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Build the project; optionally choose mode with &lt;code&gt;â€”-config Release&lt;/code&gt; (if your generator lets you):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  cmake --build .&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Move the generated files to the install directory you chose before. If you don&#39;t want to use the install &#34;feature&#34; of CMake, just get the files (&lt;code&gt;libCallObfuscatorHelpers.a&lt;/code&gt; and &lt;code&gt;CallObfuscatorPlugin.dll&lt;/code&gt;) from the build directory and put them in a place you remember; you will need them.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  cmake --build . --target install&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;At this point, you should have two files:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;libCallObfuscatorHelpers.a&lt;/code&gt;: A C library that includes all the logic that needs to be executed at runtime. &amp;nbsp;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;CallObfuscatorPlugin.dll&lt;/code&gt;: &amp;nbsp;The actual plugin containing the pass, will be given as an offer to opt.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Once all this is done I like to add the path I used to install the plugin to the user path, so it is easier to import it after. To do this, add the following line to &lt;code&gt;~/.bash_profile&lt;/code&gt; if exists, if not, add it to &lt;code&gt;~/.profile&lt;/code&gt;. Also, modify the library path, so you wont need to specify the path to helpers everytime you link.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  export PATH=$PATH:&#34;&amp;lt;path_to_install_folder&amp;gt;&#34;&#xA;  export LIBRARY_PATH=$ LIBRARY_PATH:&#34;&amp;lt;path_to_install_folder&amp;gt;/llvm-yx-callobfuscator/plugin-helpers&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Remember the path format changes from Windows, where C: becomes /c/ (because PATH separator is &lt;code&gt;:&lt;/code&gt;), for example, in my case would:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  export PATH=$PATH:&#34;/c/Users/&amp;lt;user&amp;gt;/llvm-plugins&#34;&#xA;  export LIBRARY_PATH=$LIBRARY_PATH:&#34;/c/Users/&amp;lt;user&amp;gt;/llvm-plugins/llvm-yx-callobfuscator/plugin-helpers&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage and example&lt;/h2&gt; &#xA;&lt;p&gt;First of all, we need to set up our configuration file. In this section, we will be using the config file found in the &lt;code&gt;./example&lt;/code&gt; folder. You can add any number of functions to the file, and the functions do not need to appear in the program.&lt;/p&gt; &#xA;&lt;p&gt;The plugin will get the path to the config file from an environment variable called &lt;code&gt;LLVM_OBF_FUNCTIONS&lt;/code&gt;. You can either add it along with all the other environment variables for the user, the system, or just set it up for the current terminal. You can also set it from a makefile, if using one. To set the example config for the current terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    export LLVM_OBF_FUNCTIONS=&amp;lt;absolute path to callobfuscator.conf&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now it is time to run the pass. A more detailed explanation about every step can be found &lt;a href=&#34;https://github.com/janoglezcampos/llvm-pass-plugin-skeleton?tab=readme-ov-file#running-you-pass&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Go inside the example folder and create a build folder; inside, create 2 folders: irs and objs.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  cd example; mkdir build; mkdir build/irs; mkdir build/objs&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;NOTE: Any path in MYSYS2 must be written using / and not \&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Compile the C files to LLVM-IR:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  clang -O0 -Xclang -disable-O0-optnone -S -emit-llvm ./source/utils.c -Iheaders -o ./build/irs/utils.ll&#xA;&#xA;  clang -O0 -Xclang -disable-O0-optnone -S -emit-llvm ./source/main.c -Iheaders -o ./build/irs/main.ll&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Merge all files:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  llvm-link ./build/irs/main.ll ./build/irs/utils.ll -S -o ./build/irs/example.ll&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run obfusction pass:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  opt -S -load-pass-plugin=&#34;&amp;lt;path to the pass dll&amp;gt;&#34; -passes=&#34;callobfuscator-pass&#34; ./build/irs/example.ll -o ./build/irs/example.obf.ll&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If added install path to user or system path, then:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  opt -S -load-pass-plugin=&#34;llvm-yx-callobfuscator/CallObfuscatorPlugin.dll&#34; -passes=&#34;callobfuscator-pass&#34; ./build/irs/example.ll -o ./build/irs/example.obf.ll&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run optimization passes:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  opt -S -O3 ./build/irs/example.obf.ll -o ./build/irs/example.op.ll&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Compile to windows x86_64 assembly:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  llc --mtriple=x86_64-pc-windows-msvc -filetype=obj ./build/irs/example.op.ll -o ./build/objs/example.obj&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Link:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  clang ./build/objs/example.obj -o ./build/example.exe -L&#34;&amp;lt;path to folder containing libCallObfuscatorHelpers.a&amp;gt; -lCallObfuscatorHelpers &#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If added helpers path to LIBRARY_PATH then you can ommit the &lt;code&gt;-L&lt;/code&gt; option.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  clang ./build/objs/example.obj -o ./build/example.exe -lCallObfuscatorHelpers&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Now you should have &lt;code&gt;./build/example.exe&lt;/code&gt;, the final executable.&lt;/p&gt; &#xA;&lt;p&gt;In case you are thinking that those are a lot of commands, well, they are always &#34;the same&#34;, so writing makefiles helps, Im leaving a makefile example inside the example folder to compile the same code as before.&lt;/p&gt; &#xA;&lt;h2&gt;Developer guide&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h3&gt;File distribution&lt;/h3&gt; &#xA;  &lt;hr&gt; &lt;p&gt;The code is always divided into two folders, one called headers, for definitions and macros mainly, and the other called source, containing the actual source code. For every source code file, there is a header file matching the relative path to the source folder. Documentation for functions is always found at headers files.&lt;/p&gt; &lt;p&gt;You will find two source codebases in this project:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;strong&gt;CallObfuscatorPlugin&lt;/strong&gt;: The actual plugin, written in C++, that will be compiled and linked to a dll.&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;strong&gt;CallObfuscator&lt;/strong&gt;: Includes the logic to transparently apply call obfucation at compile time.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;strong&gt;CallObfuscatorPass&lt;/strong&gt;: Initalization and management of the obfuscator pass.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;strong&gt;CallObfuscatorPluginRegister&lt;/strong&gt;: Plugin registration.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;strong&gt;CallObfuscatorHelpers&lt;/strong&gt;: A C library that includes all the logic that needs to be executed at runtime.&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;strong&gt;common&lt;/strong&gt;: Common functionality that is used across the project.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;strong&gt;pe&lt;/strong&gt;: Utilities to manipulate and work with in-memory PEs.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;strong&gt;callDispatcher&lt;/strong&gt;: Functionality to invoke Windows native functions applying obfuscation.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;strong&gt;stackSpoof&lt;/strong&gt;: Functionality to apply dynamic stack spoofing in Windows x64 environments.&lt;/li&gt; &#xA;     &lt;li&gt;&lt;strong&gt;syscalls&lt;/strong&gt;: Utilities to work with Windows x64 syscalls.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;How the pass works&lt;/h3&gt; &#xA;  &lt;hr&gt; &lt;p&gt;Knoledge about common terms like hooks, register, stack... is assumed. This is not an in-depth guide, just enough to get you throw the execution flow.&lt;/p&gt; &lt;p&gt;First, we go through every defined function in the code; if any of them is found in the config file, we store it. Once we find all the functions that will be obfuscated, we create two tables:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;__callobf_dllTable&lt;/code&gt;: This contains all required dlls for obfuscated functions; each dll has an ID, which is its index in the table.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;__callobf_functionTable&lt;/code&gt;: This contains all obfuscated functions and information about which dll contains them, the number of arguments of the function, if it is a syscall, etc.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;At compile time, this tables will be partially initialized, but the only value we need at this moment is the function ID (its index in the function table).&lt;/p&gt; &lt;p&gt;After building the tables, we find every call to the obfuscated functions; for each of them, replace the call by a call to &lt;code&gt;__callobf_callDispatcher&lt;/code&gt;, and pass the ID as the first argument, then pass all the other function arguments.&lt;/p&gt; &lt;p&gt;&lt;code&gt;__callobf_callDispatcher&lt;/code&gt; is defined as &lt;code&gt;PVOID __callobf_callDispatcher(DWORD32 index, ...)&lt;/code&gt;. It will get all the info it needs from the function table by using the ID (index) in the first argument.&lt;/p&gt; &lt;p&gt;A function has its entry partially initialized until it is called; at that moment, &lt;code&gt;__callobf_callDispatcher&lt;/code&gt; will store all the required information to call and obfuscate the function and pass the other arguments to the function being called.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;How the dispatching system works&lt;/h3&gt; &#xA;  &lt;hr&gt; &lt;p&gt;The dispatching system starts by initializing the entry in the function table.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Get the dll from the dll table and load it if needed.&lt;/li&gt; &#xA;   &lt;li&gt;Find the function in the IAT and store the address in the function table.&lt;/li&gt; &#xA;   &lt;li&gt;Find if the call is a syscall; if it is, get the ssn and store it in the function table.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;If not already done, initialize the frame table (&lt;code&gt;__callobf_globalFrameTable&lt;/code&gt;), used to cache posible frames and gadgets that will be used to build the obfuscated stack. The obfuscation method is the same as explained &lt;a href=&#34;https://klezvirus.github.io/RedTeaming/AV_Evasion/StackSpoofing/&#34;&gt;here&lt;/a&gt;, still an outstanding job.&lt;/p&gt; &lt;p&gt;After the the function is loaded and the frame table is initialized:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Build a fake stack using the values stored in the frame table and store it over the current stack pointer.&lt;/li&gt; &#xA;   &lt;li&gt;Update the ciclic value used to pick which values are used for building the stack.&lt;/li&gt; &#xA;   &lt;li&gt;Move arguments to their right place.&lt;/li&gt; &#xA;   &lt;li&gt;Change rsp to match the start of the fake stack.&lt;/li&gt; &#xA;   &lt;li&gt;If syscall, set ssn in rax.&lt;/li&gt; &#xA;   &lt;li&gt;If syscall, set r10 to hold the first argument.&lt;/li&gt; &#xA;   &lt;li&gt;Jump to the function or syscall instruction.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;To Arash Parsa, aka &lt;a href=&#34;https://twitter.com/waldoirc&#34;&gt;waldoirc&lt;/a&gt;, Athanasios Tserpelis, aka &lt;a href=&#34;https://twitter.com/trickster012&#34;&gt;trickster0&lt;/a&gt; and Alessandro Magnosi, aka &lt;a href=&#34;https://twitter.com/klezVirus&#34;&gt;klezVirus&lt;/a&gt; because of &lt;a href=&#34;https://klezvirus.github.io/RedTeaming/AV_Evasion/StackSpoofing/&#34;&gt;SilentMoonwalk&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;h2&gt;TODO:&lt;/h2&gt; &#xA; &lt;p&gt;This includes things that I really dont want to forget, but more stuff could be added here. Not by now&lt;/p&gt; &#xA; &lt;h3&gt;Docs/formatting:&lt;/h3&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Somehow improve stackSpoofHelper.x64.asm readability. &amp;nbsp;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;h3&gt;Opsec:&lt;/h3&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;EAF bypass.&lt;/li&gt; &#xA;  &lt;li&gt;Encript strings that cant be hashed.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;h3&gt;General quality:&lt;/h3&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Group all globals, or somehow make it clear in the code where all globals are declared.&lt;/li&gt; &#xA;  &lt;li&gt;Put MIN_ADD_RSP_FRAME_SIZE to work.&lt;/li&gt; &#xA;  &lt;li&gt;Optionally validate config file entries against local dlls.&lt;/li&gt; &#xA;  &lt;li&gt;Optionally return load errors through messagebox pop ups, similarly to what ms does with CRTs.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;h3&gt;Functionality:&lt;/h3&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Handle invoke instructions and exception stuff (should not happen in C but...)&lt;/li&gt; &#xA;  &lt;li&gt;Handle indirect calls&lt;/li&gt; &#xA;  &lt;li&gt;Handle function address reads (In fact indirect calls always start with a value read, so they are the same case)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
</feed>