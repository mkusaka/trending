<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-05T01:29:44Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>slippedandmissed/XLSL</title>
    <updated>2023-08-05T01:29:44Z</updated>
    <id>tag:github.com,2023-08-05:/slippedandmissed/XLSL</id>
    <link href="https://github.com/slippedandmissed/XLSL" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A rendering engine for Microsoft Excel&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;XLSL — The Excel Shader Language&lt;/h1&gt; &#xA;&lt;p&gt;This project aims to define a programming language (XLSL), and a compiler which converts XLSL source code into Excel formulae (with no VBA).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/slippedandmissed/XLSL/raw/main/docs/raytrace.png&#34; alt=&#34;Raytrace&#34;&gt; This is an example of a simple Excel ray tracer written in XLSL.&lt;/p&gt; &#xA;&lt;h2&gt;Language features&lt;/h2&gt; &#xA;&lt;h3&gt;Data types&lt;/h3&gt; &#xA;&lt;p&gt;The standard data types in XLSL are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;number&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;text&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;logical&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These correspond to built-in data types in Excel&lt;/p&gt; &#xA;&lt;h3&gt;Functions&lt;/h3&gt; &#xA;&lt;p&gt;Functions are defined in a C-like way.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;number addTen(number x) {&#xA;  return x + 10;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Functions can also be recursive using the &lt;code&gt;self&lt;/code&gt; keyword&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;number factorial(number n) {&#xA;  return n &amp;lt;= 1 ? 1 : n * self(n-1);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Structs&lt;/h3&gt; &#xA;&lt;p&gt;Custom data types can be defined using the &lt;code&gt;struct&lt;/code&gt; keyword. A struct consists of several member declarations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Vector3 {&#xA;  number x;&#xA;  number y;&#xA;  number z;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Structs can be instantiated as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Vector3 position = Vector3 { 1, 7, 2 };&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The arguments to a struct instantiation can be literals, function calls, or any other expression whose type is the same as that of the corresponding member of the struct;&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, XLSL does not yet natively support functions which return instances of a struct (although passing an instance of a struct as an &lt;em&gt;argument&lt;/em&gt; to a function works fine). Instead, structs can define &lt;code&gt;serialize&lt;/code&gt; and &lt;code&gt;deserialize&lt;/code&gt; methods which convert to and from &lt;code&gt;text&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Vector3 {&#xA;  number x;&#xA;  number y;&#xA;  number z;&#xA;&#xA;  serialize {&#xA;    return Std.Typing.numberToText(x) + &#34;,&#34; + Std.Typing.numberToText(y) + &#34;,&#34; + Std.Typing.numberToText(x); &#xA;  }&#xA;&#xA;  deserialize {&#xA;    number x = Std.Typing.textToNumber(Std.Split.head(serialized, &#34;,&#34;));&#xA;    number y = Std.Typing.textToNumber(Std.Split.nth(serialized, &#34;,&#34;, 1));&#xA;    number z = Std.Typing.textToNumber(Std.Split.nth(serialized, &#34;,&#34;, 2));&#xA;    return Vector3 { x, y, z };&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that in the &lt;code&gt;serialize&lt;/code&gt; method, the fields of the struct are referred to by their names, and in the &lt;code&gt;deserialize&lt;/code&gt; method, the &lt;code&gt;text&lt;/code&gt; to deserialized can be referenced via the implicitly defined &lt;code&gt;serialized&lt;/code&gt; variable.&lt;/p&gt; &#xA;&lt;p&gt;These methods can be used as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;text scale(Vector3 vector, number scale) {&#xA;  Vector3 result = Vector3 {&#xA;    scale*vector.x,&#xA;    scale*vector.y,&#xA;    scale*vector.z&#xA;  };&#xA;  return serialize(result);&#xA;}&#xA;&#xA;void main() {&#xA;  Vector3 p = Vector3 { 1, 2, 3 };&#xA;  Vector3 q = deserialize&amp;lt;Vector3&amp;gt;(scale(p, 2));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Namespaces&lt;/h3&gt; &#xA;&lt;p&gt;Namespaces can be defined using the &lt;code&gt;namespace&lt;/code&gt; keyword. Functions and structs can be defined within a namespace. Expressions which try to access these structs and functions from outside the namespace must include the namespace identifier. An example is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;namespace Math {&#xA;  number sqrt(number x) {&#xA;    // Something here&#xA;  }&#xA;}&#xA;&#xA;number y = Math.sqrt(5);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Namespaces can be nested. An example is shown below of a nested namespace with a function &lt;code&gt;foo&lt;/code&gt;, and how you would reference &lt;code&gt;foo&lt;/code&gt; from different areas of the program.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;namespace A {&#xA;  namespace B {&#xA;    void foo() {&#xA;      // Something here&#xA;    }&#xA;&#xA;    //     foo();&#xA;    // or  B.foo();&#xA;    // or  A.B.foo();&#xA;  }&#xA;&#xA;  //    B.foo();&#xA;  // or A.B.foo();&#xA;&#xA;  namespace C {&#xA;    //    B.foo();&#xA;    // or A.B.foo();&#xA;  }&#xA;&#xA;  namespace B {&#xA;    //     foo();&#xA;    // or  B.foo();&#xA;    // or  A.B.foo();&#xA;  }&#xA;}&#xA;&#xA;// A.B.foo();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Imports&lt;/h3&gt; &#xA;&lt;p&gt;Other XLSL scripts can be imported at the top of the program using the following syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;import &#34;stdlib.xlsl&#34; as Std;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The specified path can be relative to the current XLSL file, or can be an absolute path to a file. All of the structs and functions available in the global scope of the specified file will be placed into a namespace in the current program (in this case, the namespace would be called &lt;code&gt;Std&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Ternary operators&lt;/h3&gt; &#xA;&lt;p&gt;XLSL does not have &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;for&lt;/code&gt; loops. In fact, the only conditional operation is the ternary operator. Much like in other languages, this can be used as an expression in XLSL as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;condition ? expressionIfTrue : expressionIfFalse&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The only way to create loops in XLSL is to use the ternary operator in conjunction with recursive functions.&lt;/p&gt; &#xA;&lt;h3&gt;Literals&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;text&lt;/code&gt; literals can be single-quoted or double-quoted strings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;text x = &#34;Lorem ipsum&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;number&lt;/code&gt; literals can be any decimal number:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;number x = 1.729;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;logical&lt;/code&gt; literals are either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;logical x = true;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Direct formula access&lt;/h3&gt; &#xA;&lt;p&gt;Excel has a lot of built-in functions which you wouldn&#39;t want to rewrite from scratch. These can be called like normal &lt;code&gt;XLSL&lt;/code&gt; functions by prepending their names with a dollar sign (&lt;code&gt;$&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;number factorial(number x) {&#xA;  return $FACT(x);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s important to put this in its own function because the XLSL compiler cannot determine its return type, and so must rely on the return type of the enclosing XLSL funciton.&lt;/p&gt; &#xA;&lt;h2&gt;Using the compiler&lt;/h2&gt; &#xA;&lt;p&gt;After cloning the repo, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to build the compiler.&lt;/p&gt; &#xA;&lt;p&gt;Instead of using the compiler (&lt;code&gt;build/compile&lt;/code&gt;) directly, it is recommended that you use the wrapper script &lt;code&gt;render.py&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This script takes an XLSL source code file and outputs a &lt;code&gt;.xlsx&lt;/code&gt; Excel spreadsheet file.&lt;/p&gt; &#xA;&lt;p&gt;The formula in the specified output cells of the spreadsheet will be the compiled version of the &lt;code&gt;main&lt;/code&gt; function in the XLSL source code file provided. Any inputs required for the &lt;code&gt;main&lt;/code&gt; function will be taken from a set of cells specified from the command line.&lt;/p&gt; &#xA;&lt;p&gt;Example usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./render.py ./examples/greeting.xlsl -i B1:B2 -l left D1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can specify multiple output cells on the command line, and the same formula will be put into each of them. The behaviour of the cells can be customised by using Direct Formula Access with the &lt;code&gt;$ROW()&lt;/code&gt; and &lt;code&gt;$COLUMN()&lt;/code&gt; excel formulae. This is what makes XLSL a &#34;shader&#34; language — each output cell is executing the same formula, based on its coordinates it can produce a different result.&lt;/p&gt; &#xA;&lt;p&gt;A template spreadsheet can also be specified on the command line, and the render script will use this file as a starting point. This allows you to customise the formatting of your spreadsheet in a way that won&#39;t be lost every time you recompile the XLSL code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./render.py ./examples/raytrace.xlsl A1:CB45 -i CE47:CE60 -l left -t ./examples/templates/raytrace_template.xlsx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Future work&lt;/h2&gt; &#xA;&lt;p&gt;There are lots of improvements I&#39;d like to make to the XLSL compiler in the future. If you feel so inclined, feel free to submit a pull request!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;XLSL is very unoptimized. The formulae it outputs are nowhere near the simplest/shortest which would achieve the same result. In the future I&#39;d like to improve this.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The lexer and parser errors are very unhelpful. Often they are just &lt;code&gt;syntax error&lt;/code&gt; with no further explanation. I&#39;d like to improve error reporting.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There are several bugs in the lexer and parser I&#39;d like to address:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Order of operations is somewhat broken. While &lt;code&gt;1+2*3&lt;/code&gt; correctly gets parsed, the expression &lt;code&gt;(1+2)*3&lt;/code&gt; results in a syntax error.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Nested structs access is broken. Suppose you had a struct instance &lt;code&gt;foo&lt;/code&gt; with a member named &lt;code&gt;bar&lt;/code&gt; which in turn was a struct instance with a member named &lt;code&gt;baz&lt;/code&gt;. The expression &lt;code&gt;foo.bar.baz&lt;/code&gt; is not handled correctly. Similarly, &lt;code&gt;MyStruct x = foo.bar; x.baz&lt;/code&gt; fails, but seemingly for a different reason. Further investigation is required.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Variables cannot be used as conditions in a ternary operator. The expression &lt;code&gt;someLogicalVar ? 1 : 0&lt;/code&gt; results in a syntax error. Instead, the programmer must use &lt;code&gt;(someLogicalVar == true) ? 1 : 0&lt;/code&gt; which isn&#39;t ideal.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There&#39;s a limit on function complexity. Due to Excel&#39;s limit of 8192 characters per formula, if an individual XLSL function compiles to a formula that is too long, while the compiler throws no warnings or errors, Excel will refuse to open the resulting spreadsheet. This is not necessarily an awful thing, as the XLSL programmer can simply split their function into multiple smaller functions, but it would be nice for the compiler to throw a warning.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Import file paths aren&#39;t unescaped properly. This could cause a problem when a referenced file path contains a character which must be escaped in a string literal.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>paxo-rch/paxos_8</title>
    <updated>2023-08-05T01:29:44Z</updated>
    <id>tag:github.com,2023-08-05:/paxo-rch/paxos_8</id>
    <link href="https://github.com/paxo-rch/paxos_8" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PaxOS 8&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/paxo-rch/paxos_8/main/logo.png&#34; alt=&#34;Logo of the paxo project&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;PaxOS 8&lt;/strong&gt; is the latest version of &lt;strong&gt;PaxOS&lt;/strong&gt;, a lightweight operating system for PaxoPhones.&lt;/p&gt; &#xA;&lt;h2&gt;what&#39;s new ?&lt;/h2&gt; &#xA;&lt;p&gt;It brings a very reliable event system allowing a very fluid use of the device. Its new graphic module adds new, more aesthetic widgets in a precise theme designed on figma!&lt;/p&gt; &#xA;&lt;p&gt;The homepage features 8 simplistic apps but none too many:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The phone app for making calls&lt;/li&gt; &#xA; &lt;li&gt;The message app, to send bubble messages to contacts&lt;/li&gt; &#xA; &lt;li&gt;The contacts app, which allows you to add and delete contacts that can be used in other applications&lt;/li&gt; &#xA; &lt;li&gt;The Calculator&lt;/li&gt; &#xA; &lt;li&gt;Tte Clock, which will allows you to program alarms and launch stopwatches and timers&lt;/li&gt; &#xA; &lt;li&gt;The Map to calculate its GPS coordinates&lt;/li&gt; &#xA; &lt;li&gt;The Snake&lt;/li&gt; &#xA; &lt;li&gt;The game 2048&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Many improvements are coming soon.&lt;/p&gt; &#xA;&lt;p&gt;Feel free to suggest contributions.&lt;/p&gt; &#xA;&lt;p&gt;See more on &lt;a href=&#34;https://www.paxo.fr&#34;&gt;paxo.fr&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>