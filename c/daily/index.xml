<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-02T01:32:25Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tsoding/olive.c</title>
    <updated>2022-12-02T01:32:25Z</updated>
    <id>tag:github.com,2022-12-02:/tsoding/olive.c</id>
    <link href="https://github.com/tsoding/olive.c" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple 2D Graphics Library for C&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Olive.c&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://tsoding.github.io/olive.c/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tsoding/olive.c/master/assets/olivec-200.png&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;IMPORTANT! THIS LIBRARY IS A WORK IN PROGRESS! ANYTHING CAN CHANGE AT ANY MOMENT WITHOUT ANY NOTICE! USE THIS LIBRARY AT YOUR OWN RISK!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Simple graphics library that does not have any dependencies and renders everything into the given memory pixel by pixel.&lt;/p&gt; &#xA;&lt;p&gt;Visit &lt;a href=&#34;https://tsoding.github.io/olive.c/&#34;&gt;https://tsoding.github.io/olive.c/&lt;/a&gt; to see some demos.&lt;/p&gt; &#xA;&lt;p&gt;The library is not concerned with displaying the image. It only fills up the memory with pixels. It&#39;s up to you what to do with those pixels.&lt;/p&gt; &#xA;&lt;p&gt;The name is pronounced as &#34;olivets&#39;&#34; which is a Ukrainian word for &#34;pencil&#34; (&lt;a href=&#34;https://translate.google.com/?sl=uk&amp;amp;tl=en&amp;amp;text=%D0%BE%D0%BB%D1%96%D0%B2%D0%B5%D1%86%D1%8C&amp;amp;op=translate&#34;&gt;&#34;олівець&#34;&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The library itself does not require any special building. You can simply copy-paste &lt;a href=&#34;https://raw.githubusercontent.com/tsoding/olive.c/master/olive.c&#34;&gt;./olive.c&lt;/a&gt; to your project and &lt;code&gt;#include&lt;/code&gt; it. (Because the truly reusable code is the one that you can simply copy-paste).&lt;/p&gt; &#xA;&lt;p&gt;Olive.c is a classical &lt;a href=&#34;https://github.com/nothings/stb&#34;&gt;stb-style&lt;/a&gt; single header library. That is by default it acts like a header, but if you &lt;code&gt;#define OLIVEC_IMPLEMENTATION&lt;/code&gt; prior including the library it acts like a source file. The &lt;code&gt;.c&lt;/code&gt; extension might be confusing, but it&#39;s a part of the name of the library (why JavaScript people can use &lt;code&gt;.js&lt;/code&gt; as part of the name of a library and I cannot?)&lt;/p&gt; &#xA;&lt;h2&gt;Quick Example (Flag of Japan)&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;This example also uses &lt;a href=&#34;https://raw.githubusercontent.com/nothings/stb/master/stb_image_write.h&#34;&gt;stb_image_write.h&lt;/a&gt; to create the PNG image&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// flag_jp.c&#xA;#define OLIVEC_IMPLEMENTATION&#xA;#include &#34;olive.c&#34;&#xA;&#xA;#define STB_IMAGE_WRITE_IMPLEMENTATION&#xA;#include &#34;stb_image_write.h&#34;&#xA;&#xA;#define WIDTH 900&#xA;#define HEIGHT 600&#xA;&#xA;uint32_t pixels[WIDTH*HEIGHT];&#xA;&#xA;int main(void)&#xA;{&#xA;    Olivec_Canvas oc = olivec_canvas(pixels, WIDTH, HEIGHT, WIDTH);&#xA;    // Taken from https://upload.wikimedia.org/wikipedia/en/9/9e/Flag_of_Japan.svg&#xA;    olivec_fill(oc, 0xFFFFFFFF);&#xA;    olivec_circle(oc, WIDTH/2, HEIGHT/2, 180, 0xFF2D00BC);&#xA;&#xA;    const char *file_path = &#34;flag_jp.png&#34;;&#xA;    if (!stbi_write_png(file_path, WIDTH, HEIGHT, 4, pixels, sizeof(uint32_t)*WIDTH)) {&#xA;        fprintf(stderr, &#34;ERROR: could not write %s\n&#34;, file_path);&#xA;        return 1;&#xA;    }&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building the Tests and Demos&lt;/h2&gt; &#xA;&lt;p&gt;Even though the library does not require any special building, the tests and demos do. We use &lt;a href=&#34;https://github.com/tsoding/nobuild&#34;&gt;nobuild&lt;/a&gt; build system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ clang -o nobuild nobuild.c&#xA;$ ./nobuild&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tests&lt;/h2&gt; &#xA;&lt;p&gt;Run the tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./build/test run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the expected behavior of the library has changed in the way that breaks current test cases, you probably want to update them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./build/test update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more info see the help:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./build/test help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Demos&lt;/h2&gt; &#xA;&lt;p&gt;The source code for demos is located at &lt;a href=&#34;https://raw.githubusercontent.com/tsoding/olive.c/master/demos/&#34;&gt;demos&lt;/a&gt;. Each demo is compiled for 3 different &#34;platforms&#34; that is 3 different ways to display the generated images:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.libsdl.org/&#34;&gt;SDL&lt;/a&gt; -- displays the images via &lt;a href=&#34;https://wiki.libsdl.org/SDL_Texture&#34;&gt;SDL_Texture&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Terminal -- converts the images into ASCII art and prints them into the terminal.&lt;/li&gt; &#xA; &lt;li&gt;WASM -- displays the images in &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API&#34;&gt;HTML5 canvas&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To run the SDL version of a demo do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./build/demos/&amp;lt;demo&amp;gt;.sdl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the Terminal version of a demo do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./build/demos/&amp;lt;demo&amp;gt;.term&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the WASM versions of the demos from &lt;a href=&#34;https://tsoding.github.io/olive.c/&#34;&gt;https://tsoding.github.io/olive.c/&lt;/a&gt; locally do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ python3 -m http.server 6969&#xA;$ iexplore.exe http://localhost:6969/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Virtual Console&lt;/h3&gt; &#xA;&lt;p&gt;The support for several platforms is provided by Demo Virtual Console. It is implemented in two files:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tsoding/olive.c/master/demos/vc.c&#34;&gt;./demos/vc.c&lt;/a&gt; -- the C runtime required by all platforms.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tsoding/olive.c/master/js/vc.js&#34;&gt;./js/vc.js&lt;/a&gt; -- the JavaScript runtime for running in a browser when compiled to WebAssembly.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The Demo Virtual Console is not part of the main library and is designed specifically for demos. (I do consider including it into the main library, &#39;cause it looks pretty useful. The library is still in development).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cnlohr/mini-rv32ima</title>
    <updated>2022-12-02T01:32:25Z</updated>
    <id>tag:github.com,2022-12-02:/cnlohr/mini-rv32ima</id>
    <link href="https://github.com/cnlohr/mini-rv32ima" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A tiny C header-only risc-v emulator.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;riscv_emufun (mini-rv32ima)&lt;/h1&gt; &#xA;&lt;p&gt;Click below for the YouTube video introducing this project:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=YT5vB3UqU_E&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/YT5vB3UqU_E/0.jpg&#34; alt=&#34;Writing a Really Tiny RISC-V Emulator&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What&lt;/h2&gt; &#xA;&lt;p&gt;mini-rv32ima is a single-file-header, &lt;a href=&#34;https://github.com/cnlohr/riscv_emufun/raw/master/mini-rv32ima/mini-rv32ima.h&#34;&gt;mini-rv32ima.h&lt;/a&gt;, in the &lt;a href=&#34;https://github.com/nothings/stb&#34;&gt;STB Style library&lt;/a&gt; that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Implements a RISC-V &lt;strong&gt;rv32ima/Zifencei+Zicsr&lt;/strong&gt; (and partial su), with CLINT and MMIO.&lt;/li&gt; &#xA; &lt;li&gt;Is about &lt;strong&gt;400 lines&lt;/strong&gt; of actual code.&lt;/li&gt; &#xA; &lt;li&gt;Has &lt;strong&gt;no dependencies&lt;/strong&gt;, not even libc.&lt;/li&gt; &#xA; &lt;li&gt;Is &lt;strong&gt;easily extensible&lt;/strong&gt;. So you can easily add CSRs, instructions, MMIO, etc!&lt;/li&gt; &#xA; &lt;li&gt;Is pretty &lt;strong&gt;performant&lt;/strong&gt;. (~450 coremark on my laptop, about 1/2 the speed of QEMU)&lt;/li&gt; &#xA; &lt;li&gt;Is human-readable and in &lt;strong&gt;basic C&lt;/strong&gt; code.&lt;/li&gt; &#xA; &lt;li&gt;Is &#34;&lt;strong&gt;incomplete&lt;/strong&gt;&#34; in that it didn&#39;t implement the tons of the spec that Linux doesn&#39;t (and you shouldn&#39;t) use.&lt;/li&gt; &#xA; &lt;li&gt;Is trivially &lt;strong&gt;embeddable&lt;/strong&gt; in applications.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It has a &lt;a href=&#34;https://github.com/cnlohr/riscv_emufun/raw/master/mini-rv32ima/mini-rv32ima.c&#34;&gt;demo wrapper&lt;/a&gt; that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Implements a CLI, SYSCON, UART, DTB and Kernel image loading.&lt;/li&gt; &#xA; &lt;li&gt;And it only around &lt;strong&gt;250 lines&lt;/strong&gt; of code, itself.&lt;/li&gt; &#xA; &lt;li&gt;Compiles down to a &lt;strong&gt;~18kB executable&lt;/strong&gt; and only relies on libc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Just see the &lt;code&gt;mini-rv32ima&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s &#34;fully functional&#34; now in that I can run Linux, apps, etc. Compile flat binaries and drop them in an image.&lt;/p&gt; &#xA;&lt;h2&gt;Why&lt;/h2&gt; &#xA;&lt;p&gt;I&#39;m working on a really really simple C Risc-V emultor. So simple it doesn&#39;t even have an MMU (Memory Management Unit). I have a few goals, they include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Furthering RV32-NOMMU work to improve Linux support for RV32-NOMMU. (Imagine if we could run Linux on the $1 ESP32-C3)&lt;/li&gt; &#xA; &lt;li&gt;Learning more about RV32 and writing emulators.&lt;/li&gt; &#xA; &lt;li&gt;Being further inspired by @pimaker&#39;s amazing work on &lt;a href=&#34;https://blog.pimaker.at/texts/rvc1/&#34;&gt;Running Linux in a Pixel Shader&lt;/a&gt; and having the sneaking suspicion performance could be even better!&lt;/li&gt; &#xA; &lt;li&gt;Hoping to port it to some weird places.&lt;/li&gt; &#xA; &lt;li&gt;Understand the &lt;em&gt;most simplistic&lt;/em&gt; system you can run Linux on and trying to push that boundary.&lt;/li&gt; &#xA; &lt;li&gt;Continue to include my [education of people about assembly language].(&lt;a href=&#34;https://www.youtube.com/watch?v=Gelf0AyVGy4&#34;&gt;https://www.youtube.com/watch?v=Gelf0AyVGy4&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How&lt;/h2&gt; &#xA;&lt;p&gt;Windows instructions (Just playing with the image)&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone this repo.&lt;/li&gt; &#xA; &lt;li&gt;Install or have TinyCC. &lt;a href=&#34;https://github.com/cntools/Install-TCC&#34;&gt;Powershell Installer&lt;/a&gt; or &lt;a href=&#34;https://github.com/cnlohr/tinycc-win64-installer/releases/tag/v0_0.9.27&#34;&gt;Regular Windows Installer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;winrun.ps&lt;/code&gt; in the &lt;code&gt;windows&lt;/code&gt; folder.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Linux instructions (both):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone this repo.&lt;/li&gt; &#xA; &lt;li&gt;Install &lt;code&gt;git build-essential&lt;/code&gt; and/or whatever other requirements are in place for &lt;a href=&#34;https://buildroot.org/&#34;&gt;buildroot&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make testdlimage&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;It automatically downloads the image (~1MB) and runs the emulator.&lt;/li&gt; &#xA; &lt;li&gt;Should be up and running in about 2.5s depending on internet speed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can do in-depth work on Linux by:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;make everything&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to play with the bare metal system, see below, or if you have the toolchain installed, just:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;make testbare&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Questions?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Why not rv64? &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Because then I can&#39;t run it as easily in a pixel shader if I ever hope to.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Can I add an MMU? &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Yes. It actually probably wouldn&#39;t be too difficult.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Should I add an MMU? &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;No. It is important to further support for nommu systems to empower minimal Risc-V designs!&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Everything else: Contact us on my Discord: &lt;a href=&#34;https://discord.com/invite/CCeyWyZ&#34;&gt;https://discord.com/invite/CCeyWyZ&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Hopeful goals?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Further drive down needed features to run Linux. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Remove need for RV32A extension on systems with only one CPU.&lt;/li&gt; &#xA;   &lt;li&gt;Support for relocatable ELF executables.&lt;/li&gt; &#xA;   &lt;li&gt;Add support for an unreal UART. One that&#39;s &lt;strong&gt;much&lt;/strong&gt; simpler than the current 8250 driver.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Maybe run this in a pixelshader too!&lt;/li&gt; &#xA; &lt;li&gt;Get opensbi working with this.&lt;/li&gt; &#xA; &lt;li&gt;Be able to &#34;embed&#34; rv32 emulators in random projects.&lt;/li&gt; &#xA; &lt;li&gt;Can I use early console to be a full system console?&lt;/li&gt; &#xA; &lt;li&gt;Can I increase the maximum contiguous memory allocatable?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Special Thanks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For @regymm and their &lt;a href=&#34;https://github.com/regymm/buildroot&#34;&gt;patches to buildroot&lt;/a&gt; and help! &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;callout: Regymm&#39;s &lt;a href=&#34;https://github.com/regymm/quasiSoC/&#34;&gt;quazisoc project&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Buildroot (For being so helpful).&lt;/li&gt; &#xA; &lt;li&gt;@vowstar and their team working on &lt;a href=&#34;https://github.com/vowstar/k210-linux-nommu&#34;&gt;k210-linux-nommu&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;This &lt;a href=&#34;https://jborza.com/emulation/2020/04/09/riscv-environment.html&#34;&gt;guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://luplab.gitlab.io/rvcodecjs/&#34;&gt;rvcodecjs&lt;/a&gt; I probably went through over 1,000 codes here.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;More details&lt;/h2&gt; &#xA;&lt;p&gt;If you want to build the kernel yourself:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;make everything&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;About 20 minutes. (Or 4+ hours if you&#39;re on &lt;a href=&#34;https://github.com/microsoft/WSL/issues/4197&#34;&gt;Windows Subsytem for Linux 2&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;And you should be dropped into a Linux busybox shell with some little tools that were compiled here.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to use bare metal to build your binaries so you don&#39;t need buildroot, you can use the rv64 gcc in 32-bit mode built into Ubuntu 20.04 and up.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install gcc-multilib gcc-riscv64-unknown-elf make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;Hackaday Supercon 2022: Charles Lohr - Assembly in 2022: Yes! We Still Use it and Here&#39;s Why&#34; : &lt;a href=&#34;https://www.youtube.com/watch?v=Gelf0AyVGy4&#34;&gt;https://www.youtube.com/watch?v=Gelf0AyVGy4&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;WSL notes.&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can&#39;t have spaces in your paths. Try this: &lt;code&gt;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/mnt/c/Windows/system32:/snap/bin&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Attic&lt;/h2&gt; &#xA;&lt;h2&gt;General notes:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cnlohr/riscv_emufun/commit/2f09cdeb378dc0215c07eb63f5a6fb43dbbf1871#diff-b48ccd795ae9aced07d022bf010bf9376232c4d78210c3113d90a8d349c59b3dL440&#34;&gt;https://github.com/cnlohr/riscv_emufun/commit/2f09cdeb378dc0215c07eb63f5a6fb43dbbf1871#diff-b48ccd795ae9aced07d022bf010bf9376232c4d78210c3113d90a8d349c59b3dL440&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(These things don&#39;t currently work)&lt;/p&gt; &#xA;&lt;h3&gt;Building Tests&lt;/h3&gt; &#xA;&lt;p&gt;(This does not work, now)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd riscv-tests&#xA;export CROSS_COMPILE=riscv64-linux-gnu-&#xA;export PLATFORM_RISCV_XLEN=32&#xA;CC=riscv64-linux-gnu-gcc ./configure&#xA;make XLEN=32 RISCV_PREFIX=riscv64-unknown-elf- RISCV_GCC_OPTS=&#34;-g -O1 -march=rv32imaf -mabi=ilp32f -I/usr/include&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building OpenSBI&lt;/h3&gt; &#xA;&lt;p&gt;(This does not currently work!)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd opensbi&#xA;export CROSS_COMPILE=riscv64-unknown-elf-&#xA;export PLATFORM_RISCV_XLEN=32&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Extra links&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clear outline of CSRs: &lt;a href=&#34;https://five-embeddev.com/riscv-isa-manual/latest/priv-csrs.html&#34;&gt;https://five-embeddev.com/riscv-isa-manual/latest/priv-csrs.html&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>