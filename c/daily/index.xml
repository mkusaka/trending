<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-02T01:34:54Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>raspberrypi/pico-examples</title>
    <updated>2022-07-02T01:34:54Z</updated>
    <id>tag:github.com,2022-07-02:/raspberrypi/pico-examples</id>
    <link href="https://github.com/raspberrypi/pico-examples" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Raspberry Pi Pico SDK Examples&lt;/h1&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://rptl.io/pico-get-started&#34;&gt;Getting Started with the Raspberry Pi Pico&lt;/a&gt; and the README in the &lt;a href=&#34;https://github.com/raspberrypi/pico-sdk&#34;&gt;pico-sdk&lt;/a&gt; for information on getting up and running.&lt;/p&gt; &#xA;&lt;h3&gt;First Examples&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Link to prebuilt UF2&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/hello_world/serial&#34;&gt;hello_serial&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The obligatory Hello World program for Pico (Output over serial version)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/hello_world/usb&#34;&gt;hello_usb&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The obligatory Hello World program for Pico (Output over USB version)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://rptl.io/pico-hello-usb&#34;&gt;https://rptl.io/pico-hello-usb&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/blink&#34;&gt;blink&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Blink an LED on and off.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://rptl.io/pico-blink&#34;&gt;https://rptl.io/pico-blink&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;ADC&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/adc/hello_adc&#34;&gt;hello_adc&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Display the voltage from an ADC input.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/adc/joystick_display&#34;&gt;joystick_display&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Display a Joystick X/Y input based on two ADC inputs.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/adc/adc_console&#34;&gt;adc_console&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An interactive shell for playing with the ADC. Includes example of free-running capture mode.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/adc/onboard_temperature&#34;&gt;onboard_temperature&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Display the value of the onboard temperature sensor.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/adc/microphone_adc&#34;&gt;microphone_adc&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Read analog values from a microphone and plot the measured sound amplitude.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Clocks&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/clocks/hello_48MHz&#34;&gt;hello_48MHz&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Change the system clock frequency to 48 MHz while running.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/clocks/hello_gpout&#34;&gt;hello_gpout&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use the general purpose clock outputs (GPOUT) to drive divisions of internal clocks onto GPIO outputs.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/clocks/hello_resus&#34;&gt;hello_resus&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enable the clock resuscitate feature, &#34;accidentally&#34; stop the system clock, and show how we recover.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;CMake&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/cmake/build_variants&#34;&gt;build_variants&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Builds two version of the same app with different configurations&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;DMA&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/dma/hello_dma&#34;&gt;hello_dma&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use the DMA to copy data in memory.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/dma/control_blocks&#34;&gt;control_blocks&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Build a control block list, to program a longer sequence of DMA transfers to the UART.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/dma/channel_irq&#34;&gt;channel_irq&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use an IRQ handler to reconfigure a DMA channel, in order to continuously drive data through a PIO state machine.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Flash&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/flash/cache_perfctr&#34;&gt;cache_perfctr&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Read and clear the cache performance counters. Show how they are affected by different types of flash reads.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/flash/nuke&#34;&gt;nuke&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Obliterate the contents of flash. An example of a NO_FLASH binary (UF2 loaded directly into SRAM and runs in-place there). A useful utility to drag and drop onto your Pico if the need arises.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/flash/program&#34;&gt;program&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Erase a flash sector, program one flash page, and read back the data.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/flash/xip_stream&#34;&gt;xip_stream&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Stream data using the XIP stream hardware, which allows data to be DMA&#39;d in the background whilst executing code from flash.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/flash/ssi_dma&#34;&gt;ssi_dma&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;DMA directly from the flash interface (continuous SCK clocking) for maximum bulk read performance.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;GPIO&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/gpio/hello_7segment&#34;&gt;hello_7segment&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use the GPIOs to drive a seven segment LED display.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/gpio/hello_gpio_irq&#34;&gt;hello_gpio_irq&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Register an interrupt handler to run when a GPIO is toggled.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/gpio/dht_sensor&#34;&gt;dht_sensor&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use GPIO to bitbang the serial protocol for a DHT temperature/humidity sensor.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;See also: &lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/blink&#34;&gt;blink&lt;/a&gt;, blinking an LED attached to a GPIO.&lt;/p&gt; &#xA;&lt;h3&gt;HW divider&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/divider&#34;&gt;hello_divider&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Show how to directly access the hardware integer dividers, in case AEABI injection is disabled.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;I2C&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/bus_scan&#34;&gt;bus_scan&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Scan the I2C bus for devices and display results.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/bmp280_i2c&#34;&gt;bmp280_i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Read and convert temperature and pressure data from a BMP280 sensor, attached to an I2C bus.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/lcd_1602_i2c&#34;&gt;lcd_1602_i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Display some text on a generic 16x2 character LCD display, via I2C.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/lis3dh_i2c&#34;&gt;lis3dh_i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Read acceleration and temperature value from a LIS3DH sensor via I2C&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/mcp9808_i2c&#34;&gt;mcp9808_i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Read temperature, set limits and raise alerts when limits are surpassed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/mma8451_i2c&#34;&gt;mma8451_i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Read acceleration from a MMA8451 accelerometer and set range and precision for the data.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/mpl3115a2_i2c&#34;&gt;mpl3115a2_i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Interface with an MPL3115A2 altimeter, exploring interrupts and advanced board features, via I2C.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/mpu6050_i2c&#34;&gt;mpu6050_i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Read acceleration and angular rate values from a MPU6050 accelerometer/gyro, attached to an I2C bus.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/oled_i2c&#34;&gt;oled_i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Convert and display a bitmap on a 128x32 SSD1306-driven OLED display&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/pa1010d_i2c&#34;&gt;pa1010d_i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Read GPS location data, parse and display data via I2C.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/i2c/pcf8523_i2c&#34;&gt;pcf8523_i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Read time and date values from a real time clock. Set current time and alarms on it.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Interpolator&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/interp/hello_interp&#34;&gt;hello_interp&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A bundle of small examples, showing how to access the core-local interpolator hardware, and use most of its features.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Multicore&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/multicore/hello_multicore&#34;&gt;hello_multicore&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Launch a function on the second core, printf some messages on each core, and pass data back and forth through the mailbox FIFOs.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/multicore/multicore_fifo_irqs&#34;&gt;multicore_fifo_irqs&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;On each core, register and interrupt handler for the mailbox FIFOs. Show how the interrupt fires when that core receives a message.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/multicore/multicore_runner&#34;&gt;multicore_runner&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Set up the second core to accept, and run, any function pointer pushed into its mailbox FIFO. Push in a few pieces of code and get answers back.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Pico Board&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/picoboard/blinky&#34;&gt;blinky&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Blink &#34;hello, world&#34; in Morse code on Pico&#39;s LED&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/picoboard/button&#34;&gt;button&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use Pico&#39;s BOOTSEL button as a regular button input, by temporarily suspending flash access.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Pico W Networking&lt;/h3&gt; &#xA;&lt;p&gt;These eaxmples are for the Pico W, and are only available for &lt;code&gt;PICO_BOARD=pico_w&lt;/code&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/access_point&#34;&gt;picow_access_point&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Starts a WiFi access point, and fields DHCP requests.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/blink&#34;&gt;picow_blink&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Blinks the on-board LED (which is connected via the WiFi chip).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/iperf&#34;&gt;picow_iperf_server&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs an &#34;iperf&#34; server for WiFi speed testing.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/ntp_client&#34;&gt;picow_ntp_client&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Connects to an NTP server to fetch and display the current time.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/tcp_client&#34;&gt;picow_tcp_client&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A simple TCP client. You can run &lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/python_test_tcp/python_test_tcp_server.py&#34;&gt;python_test_tcp_server.py&lt;/a&gt; for it to connect to.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/tcp_server&#34;&gt;picow_tcp_server&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A simple TCP server. You can use &lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/python_test_tcp/python_test_tcp_client.py&#34;&gt;python_test_tcp_client.py&lt;/a&gt; to connect to it.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/wifi_scan&#34;&gt;picow_wifi_scan&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Scans for WiFi networks and prints the results.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;FreeRTOS examples&lt;/h4&gt; &#xA;&lt;p&gt;These are examples of integrating Pico W networking under FreeRTOS, and require you to set the &lt;code&gt;FREERTOS_KERNEL_PATH&lt;/code&gt; to point to the FreeRTOS Kernel.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/freertos/iperf&#34;&gt;picow_freertos_iperf_server_nosys&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs an &#34;iperf&#34; server for WiFi speed testing under FreeRTOS in NO_SYS=1 mode. The LED is blinked in another task&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/freertos/iperf&#34;&gt;picow_freertos_iperf_server_sys&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs an &#34;iperf&#34; server for WiFi speed testing under FreeRTOS in NO_SYS=0 (i.e. full FreeRTOS integration) mode. The LED is blinked in another task&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/freertos/ping&#34;&gt;picow_freertos_ping_nosys&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs the lwip-contrib/apps/ping test app under FreeRTOS in NO_SYS=1 mode.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pico_w/freertos/iperf&#34;&gt;picow_freertos_iperf_server_sys&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs the lwip-contrib/apps/ping test app under FreeRTOS in NO_SYS=0 (i.e. full FreeRTOS integration) mode. The test app uses the lwIP \em socket API in this case.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;PIO&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/hello_pio&#34;&gt;hello_pio&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Absolutely minimal example showing how to control an LED by pushing values into a PIO FIFO.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/apa102&#34;&gt;apa102&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Rainbow pattern on on a string of APA102 addressable RGB LEDs.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/differential_manchester&#34;&gt;differential_manchester&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Send and receive differential Manchester-encoded serial (BMC).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/hub75&#34;&gt;hub75&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Display an image on a 128x64 HUB75 RGB LED matrix.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/i2c&#34;&gt;i2c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Scan an I2C bus.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/ir_nec&#34;&gt;ir_nec&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Sending and receiving IR (infra-red) codes using the PIO.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/logic_analyser&#34;&gt;logic_analyser&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use PIO and DMA to capture a logic trace of some GPIOs, whilst a PWM unit is driving them.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/manchester_encoding&#34;&gt;manchester_encoding&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Send and receive Manchester-encoded serial.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/pio_blink&#34;&gt;pio_blink&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Set up some PIO state machines to blink LEDs at different frequencies, according to delay counts pushed into their FIFOs.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/pwm&#34;&gt;pwm&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Pulse width modulation on PIO. Use it to gradually fade the brightness of an LED.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/spi&#34;&gt;spi&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use PIO to erase, program and read an external SPI flash chip. A second example runs a loopback test with all four CPHA/CPOL combinations.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/squarewave&#34;&gt;squarewave&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Drive a fast square wave onto a GPIO. This example accesses low-level PIO registers directly, instead of using the SDK functions.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/st7789_lcd&#34;&gt;st7789_lcd&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Set up PIO for 62.5 Mbps serial output, and use this to display a spinning image on a ST7789 serial LCD.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/quadrature_encoder&#34;&gt;quadrature_encoder&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A quadrature encoder using PIO to maintain counts independent of the CPU.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/uart_rx&#34;&gt;uart_rx&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Implement the receive component of a UART serial port. Attach it to the spare Arm UART to see it receive characters.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/uart_tx&#34;&gt;uart_tx&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Implement the transmit component of a UART serial port, and print hello world.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/ws2812&#34;&gt;ws2812&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Examples of driving WS2812 addressable RGB LEDs.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pio/addition&#34;&gt;addition&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Add two integers together using PIO. Only around 8 billion times slower than Cortex-M0+.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;PWM&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pwm/hello_pwm&#34;&gt;hello_pwm&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Minimal example of driving PWM output on GPIOs.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pwm/led_fade&#34;&gt;led_fade&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fade an LED between low and high brightness. An interrupt handler updates the PWM slice&#39;s output level each time the counter wraps.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/pwm/measure_duty_cycle&#34;&gt;measure_duty_cycle&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Drives a PWM output at a range of duty cycles, and uses another PWM slice in input mode to measure the duty cycle.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Reset&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/reset/hello_reset&#34;&gt;hello_reset&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Perform a hard reset on some peripherals, then bring them back up.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;RTC&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/rtc/hello_rtc&#34;&gt;hello_rtc&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Set a date/time on the RTC, then repeatedly print the current time, 10 times per second, to show it updating.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/rtc/rtc_alarm&#34;&gt;rtc_alarm&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Set an alarm on the RTC to trigger an interrupt at a date/time 5 seconds into the future.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/rtc/rtc_alarm_repeat&#34;&gt;rtc_alarm_repeat&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Trigger an RTC interrupt once per minute.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;SPI&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/spi/bme280_spi&#34;&gt;bme280_spi&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Attach a BME280 temperature/humidity/pressure sensor via SPI.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/spi/mpu9250_spi&#34;&gt;mpu9250_spi&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Attach a MPU9250 accelerometer/gyoscope via SPI.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/spi/spi_dma&#34;&gt;spi_dma&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use DMA to transfer data both to and from the SPI simultaneously. The SPI is configured for loopback.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/spi/spi_flash&#34;&gt;spi_flash&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Erase, program and read a serial flash device attached to one of the SPI controllers.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/spi/spi_master_slave&#34;&gt;spi_master_slave&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Demonstrate SPI communication as master and slave.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/spi/max7219_8x7seg_spi&#34;&gt;max7219_8x7seg_spi&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Attaching a Max7219 driving an 8 digit 7 segment display via SPI&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/spi/max7219_32x8_spi&#34;&gt;max7219_32x8_spi&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Attaching a Max7219 driving an 32x8 LED display via SPI&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;System&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/system/hello_double_tap&#34;&gt;hello_double_tap&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An LED blink with the &lt;code&gt;pico_bootsel_via_double_reset&lt;/code&gt; library linked. This enters the USB bootloader when it detects the system being reset twice in quick succession, which is useful for boards with a reset button but no BOOTSEL button.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/system/narrow_io_write&#34;&gt;narrow_io_write&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Demonstrate the effects of 8-bit and 16-bit writes on a 32-bit IO register.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/system/unique_board_id&#34;&gt;unique_board_id&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Read the 64 bit unique ID from external flash, which serves as a unique identifier for the board.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Timer&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/timer/hello_timer&#34;&gt;hello_timer&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Set callbacks on the system timer, which repeat at regular intervals. Cancel the timer when we&#39;re done.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/timer/periodic_sampler&#34;&gt;periodic_sampler&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Sample GPIOs in a timer callback, and push the samples into a concurrency-safe queue. Pop data from the queue in code running in the foreground.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/timer/timer_lowlevel&#34;&gt;timer_lowlevel&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Example of direct access to the timer hardware. Not generally recommended, as the SDK may use the timer for IO timeouts.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;UART&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/uart/hello_uart&#34;&gt;hello_uart&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Print some text from one of the UART serial ports, without going through &lt;code&gt;stdio&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/uart/lcd_uart&#34;&gt;lcd_uart&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Display text and symbols on a 16x02 RGB LCD display via UART&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/uart/uart_advanced&#34;&gt;uart_advanced&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use some other UART features like RX interrupts, hardware control flow, and data formats other than 8n1.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;USB Device&lt;/h3&gt; &#xA;&lt;h4&gt;TinyUSB Examples&lt;/h4&gt; &#xA;&lt;p&gt;Most of the USB device examples come directly from the TinyUSB device examples directory &lt;a href=&#34;https://github.com/hathach/tinyusb/tree/master/examples/device&#34;&gt;here&lt;/a&gt;. Those that are supported on RP2040 devices are automatically included as part of the pico-examples build as targets named &lt;code&gt;tinyusb_dev_&amp;lt;example_name&amp;gt;&lt;/code&gt;, e.g. &lt;a href=&#34;https://github.com/hathach/tinyusb/tree/master/examples/device/hid_composite&#34;&gt;https://github.com/hathach/tinyusb/tree/master/examples/device/hid_composite&lt;/a&gt; is built as &lt;code&gt;tinyusb_dev_hid_composite&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;At the time of writing, these examples are available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;tinyusb_dev_audio_4_channel_mic&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_audio_test&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_board_test&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_cdc_dual_ports&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_cdc_msc&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_dfu&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_dfu_runtime&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_dynamic_configuration&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_hid_composite&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_hid_generic_inout&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_hid_multiple_interface&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_midi_test&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_msc_dual_lun&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_net_lwip_webserver&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_uac2_headset&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_usbtmc&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_video_capture&lt;/li&gt; &#xA; &lt;li&gt;tinyusb_dev_webusb_serial&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Whilst these examples ably demonstrate how to use TinyUSB in device mode, their &lt;code&gt;CMakeLists.txt&lt;/code&gt; is set up in a way tailored to how TinyUSB builds their examples within their source tree.&lt;/p&gt; &#xA;&lt;p&gt;For a better example of how to configure &lt;code&gt;CMakeLists.txt&lt;/code&gt; for using TinyUSB in device mode with the Raspberry Pi SDK see below:&lt;/p&gt; &#xA;&lt;h4&gt;SDK build example&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/usb/device/dev_hid_composite&#34;&gt;dev_hid_composite&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A copy of the TinyUSB device example with the same name, but with a CMakeLists.txt which demonstrates how to add a dependency on the TinyUSB device libraries with the Raspberry Pi Pico SDK&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Low Level example&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/usb/device/dev_lowlevel&#34;&gt;dev_lowlevel&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A USB Bulk loopback implemented with direct access to the USB hardware (no TinyUSB)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;USB Host&lt;/h3&gt; &#xA;&lt;p&gt;All the USB host examples come directly from the TinyUSB host examples directory &lt;a href=&#34;https://github.com/hathach/tinyusb/tree/master/examples/host&#34;&gt;here&lt;/a&gt;. Those that are supported on RP2040 devices are automatically included as part of the pico-examples build as targets named &lt;code&gt;tinyusb_host_&amp;lt;example_name&amp;gt;&lt;/code&gt;, e.g. &lt;a href=&#34;https://github.com/hathach/tinyusb/tree/master/examples/host/cdc_msc_hid&#34;&gt;https://github.com/hathach/tinyusb/tree/master/examples/host/cdc_msc_hid&lt;/a&gt; is built as &lt;code&gt;tinyusb_host_cdc_msc_hid&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;At the time of writing, there is only one host example available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;tinyusb_host_cdc_msc_hid&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Watchdog&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;App&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/pico-examples/master/watchdog/hello_watchdog&#34;&gt;hello_watchdog&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Set the watchdog timer, and let it expire. Detect the reboot, and halt.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
  <entry>
    <title>containers/bubblewrap</title>
    <updated>2022-07-02T01:34:54Z</updated>
    <id>tag:github.com,2022-07-02:/containers/bubblewrap</id>
    <link href="https://github.com/containers/bubblewrap" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Unprivileged sandboxing tool&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Bubblewrap&lt;/h1&gt; &#xA;&lt;p&gt;Many container runtime tools like &lt;code&gt;systemd-nspawn&lt;/code&gt;, &lt;code&gt;docker&lt;/code&gt;, etc. focus on providing infrastructure for system administrators and orchestration tools (e.g. Kubernetes) to run containers.&lt;/p&gt; &#xA;&lt;p&gt;These tools are not suitable to give to unprivileged users, because it is trivial to turn such access into a fully privileged root shell on the host.&lt;/p&gt; &#xA;&lt;h2&gt;User namespaces&lt;/h2&gt; &#xA;&lt;p&gt;There is an effort in the Linux kernel called &lt;a href=&#34;https://www.google.com/search?q=user+namespaces+site%3Ahttps%3A%2F%2Flwn.net&#34;&gt;user namespaces&lt;/a&gt; which attempts to allow unprivileged users to use container features. While significant progress has been made, there are &lt;a href=&#34;https://lwn.net/Articles/673597/&#34;&gt;still concerns&lt;/a&gt; about it, and it is not available to unprivileged users in several production distributions such as CentOS/Red Hat Enterprise Linux 7, Debian Jessie, etc.&lt;/p&gt; &#xA;&lt;p&gt;See for example &lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-3135&#34;&gt;CVE-2016-3135&lt;/a&gt; which is a local root vulnerability introduced by userns. &lt;a href=&#34;https://lkml.org/lkml/2016/3/9/555&#34;&gt;This March 2016 post&lt;/a&gt; has some more discussion.&lt;/p&gt; &#xA;&lt;p&gt;Bubblewrap could be viewed as setuid implementation of a &lt;em&gt;subset&lt;/em&gt; of user namespaces. Emphasis on subset - specifically relevant to the above CVE, bubblewrap does not allow control over iptables.&lt;/p&gt; &#xA;&lt;p&gt;The original bubblewrap code existed before user namespaces - it inherits code from &lt;a href=&#34;https://cgit.freedesktop.org/xdg-app/xdg-app/tree/common/xdg-app-helper.c?id=4c3bf179e2e4a2a298cd1db1d045adaf3f564532&#34;&gt;xdg-app helper&lt;/a&gt; which in turn distantly derives from &lt;a href=&#34;https://git.gnome.org/browse/linux-user-chroot&#34;&gt;linux-user-chroot&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;The maintainers of this tool believe that it does not, even when used in combination with typical software installed on that distribution, allow privilege escalation. It may increase the ability of a logged in user to perform denial of service attacks, however.&lt;/p&gt; &#xA;&lt;p&gt;In particular, bubblewrap uses &lt;code&gt;PR_SET_NO_NEW_PRIVS&lt;/code&gt; to turn off setuid binaries, which is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Chroot#Limitations&#34;&gt;traditional way&lt;/a&gt; to get out of things like chroots.&lt;/p&gt; &#xA;&lt;h2&gt;Users&lt;/h2&gt; &#xA;&lt;p&gt;This program can be shared by all container tools which perform non-root operation, such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.flatpak.org&#34;&gt;Flatpak&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/projectatomic/rpm-ostree/pull/209&#34;&gt;rpm-ostree unprivileged&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/projectatomic/bwrap-oci&#34;&gt;bwrap-oci&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We would also like to see this be available in Kubernetes/OpenShift clusters. Having the ability for unprivileged users to use container features would make it significantly easier to do interactive debugging scenarios and the like.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;bubblewrap is available in the package repositories of the most Linux distributions and can be installed from there.&lt;/p&gt; &#xA;&lt;p&gt;If you need to build bubblewrap from source, you can do this with meson or autotools.&lt;/p&gt; &#xA;&lt;p&gt;meson:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;meson _builddir&#xA;meson compile -C _builddir&#xA;meson install -C _builddir&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;autotools:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./autogen.sh&#xA;make&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;bubblewrap works by creating a new, completely empty, mount namespace where the root is on a tmpfs that is invisible from the host, and will be automatically cleaned up when the last process exits. You can then use commandline options to construct the root filesystem and process environment and command to run in the namespace.&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s a larger &lt;a href=&#34;https://raw.githubusercontent.com/containers/bubblewrap/main/demos/bubblewrap-shell.sh&#34;&gt;demo script&lt;/a&gt; in the source code, but here&#39;s a trimmed down version which runs a new shell reusing the host&#39;s &lt;code&gt;/usr&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bwrap --ro-bind /usr /usr --symlink usr/lib64 /lib64 --proc /proc --dev /dev --unshare-pid bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is an incomplete example, but useful for purposes of illustration. More often, rather than creating a container using the host&#39;s filesystem tree, you want to target a chroot. There, rather than creating the symlink &lt;code&gt;lib64 -&amp;gt; usr/lib64&lt;/code&gt; in the tmpfs, you might have already created it in the target rootfs.&lt;/p&gt; &#xA;&lt;h2&gt;Sandboxing&lt;/h2&gt; &#xA;&lt;p&gt;The goal of bubblewrap is to run an application in a sandbox, where it has restricted access to parts of the operating system or user data such as the home directory.&lt;/p&gt; &#xA;&lt;p&gt;bubblewrap always creates a new mount namespace, and the user can specify exactly what parts of the filesystem should be visible in the sandbox. Any such directories you specify mounted &lt;code&gt;nodev&lt;/code&gt; by default, and can be made readonly.&lt;/p&gt; &#xA;&lt;p&gt;Additionally you can use these kernel features:&lt;/p&gt; &#xA;&lt;p&gt;User namespaces (&lt;a href=&#34;http://linux.die.net/man/2/clone&#34;&gt;CLONE_NEWUSER&lt;/a&gt;): This hides all but the current uid and gid from the sandbox. You can also change what the value of uid/gid should be in the sandbox.&lt;/p&gt; &#xA;&lt;p&gt;IPC namespaces (&lt;a href=&#34;http://linux.die.net/man/2/clone&#34;&gt;CLONE_NEWIPC&lt;/a&gt;): The sandbox will get its own copy of all the different forms of IPCs, like SysV shared memory and semaphores.&lt;/p&gt; &#xA;&lt;p&gt;PID namespaces (&lt;a href=&#34;http://linux.die.net/man/2/clone&#34;&gt;CLONE_NEWPID&lt;/a&gt;): The sandbox will not see any processes outside the sandbox. Additionally, bubblewrap will run a trivial pid1 inside your container to handle the requirements of reaping children in the sandbox. This avoids what is known now as the &lt;a href=&#34;https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/&#34;&gt;Docker pid 1 problem&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Network namespaces (&lt;a href=&#34;http://linux.die.net/man/2/clone&#34;&gt;CLONE_NEWNET&lt;/a&gt;): The sandbox will not see the network. Instead it will have its own network namespace with only a loopback device.&lt;/p&gt; &#xA;&lt;p&gt;UTS namespace (&lt;a href=&#34;http://linux.die.net/man/2/clone&#34;&gt;CLONE_NEWUTS&lt;/a&gt;): The sandbox will have its own hostname.&lt;/p&gt; &#xA;&lt;p&gt;Seccomp filters: You can pass in seccomp filters that limit which syscalls can be done in the sandbox. For more information, see &lt;a href=&#34;https://en.wikipedia.org/wiki/Seccomp&#34;&gt;Seccomp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Related project comparison: Firejail&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/netblue30/firejail/tree/HEAD/src/firejail&#34;&gt;Firejail&lt;/a&gt; is similar to Flatpak before bubblewrap was split out in that it combines a setuid tool with a lot of desktop-specific sandboxing features. For example, Firejail knows about Pulseaudio, whereas bubblewrap does not.&lt;/p&gt; &#xA;&lt;p&gt;The bubblewrap authors believe it&#39;s much easier to audit a small setuid program, and keep features such as Pulseaudio filtering as an unprivileged process, as now occurs in Flatpak.&lt;/p&gt; &#xA;&lt;p&gt;Also, @cgwalters thinks trying to &lt;a href=&#34;https://github.com/netblue30/firejail/raw/37a5a3545ef6d8d03dad8bbd888f53e13274c9e5/src/firejail/fs_whitelist.c#L176&#34;&gt;whitelist file paths&lt;/a&gt; is a bad idea given the myriad ways users have to manipulate paths, and the myriad ways in which system administrators may configure a system. The bubblewrap approach is to only retain a few specific Linux capabilities such as &lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;, but to always access the filesystem as the invoking uid. This entirely closes &lt;a href=&#34;https://cwe.mitre.org/data/definitions/367.html&#34;&gt;TOCTTOU attacks&lt;/a&gt; and such.&lt;/p&gt; &#xA;&lt;h2&gt;Related project comparison: Sandstorm.io&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sandstorm.io/&#34;&gt;Sandstorm.io&lt;/a&gt; requires unprivileged user namespaces to set up its sandbox, though it could easily be adapted to operate in a setuid mode as well. @cgwalters believes their code is fairly good, but it could still make sense to unify on bubblewrap. However, @kentonv (of Sandstorm) feels that while this makes sense in principle, the switching cost outweighs the practical benefits for now. This decision could be re-evaluated in the future, but it is not being actively pursued today.&lt;/p&gt; &#xA;&lt;h2&gt;Related project comparison: runc/binctr&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/opencontainers/runc&#34;&gt;runC&lt;/a&gt; is currently working on supporting &lt;a href=&#34;https://github.com/opencontainers/runc/pull/774&#34;&gt;rootless containers&lt;/a&gt;, without needing &lt;code&gt;setuid&lt;/code&gt; or any other privileges during installation of runC (using unprivileged user namespaces rather than &lt;code&gt;setuid&lt;/code&gt;), creation, and management of containers. However, the standard mode of using runC is similar to &lt;a href=&#34;https://www.freedesktop.org/software/systemd/man/systemd-nspawn.html&#34;&gt;systemd nspawn&lt;/a&gt; in that it is tooling intended to be invoked by root.&lt;/p&gt; &#xA;&lt;p&gt;The bubblewrap authors believe that runc and systemd-nspawn are not designed to be made setuid, and are distant from supporting such a mode. However with rootless containers, runC will be able to fulfill certain usecases that bubblewrap supports (with the added benefit of being a standardised and complete OCI runtime).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jfrazelle/binctr&#34;&gt;binctr&lt;/a&gt; is just a wrapper for runC, so inherits all of its design tradeoffs.&lt;/p&gt; &#xA;&lt;h2&gt;What&#39;s with the name?!&lt;/h2&gt; &#xA;&lt;p&gt;The name bubblewrap was chosen to convey that this tool runs as the parent of the application (so wraps it in some sense) and creates a protective layer (the sandbox) around it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/containers/bubblewrap/main/bubblewrap.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;(Bubblewrap cat by &lt;a href=&#34;https://www.flickr.com/photos/27549668@N03/&#34;&gt;dancing_stupidity&lt;/a&gt;)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>raspberrypi/pico-sdk</title>
    <updated>2022-07-02T01:34:54Z</updated>
    <id>tag:github.com,2022-07-02:/raspberrypi/pico-sdk</id>
    <link href="https://github.com/raspberrypi/pico-sdk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Raspberry Pi Pico SDK&lt;/h1&gt; &#xA;&lt;p&gt;The Raspberry Pi Pico SDK (henceforth the SDK) provides the headers, libraries and build system necessary to write programs for the RP2040-based devices such as the Raspberry Pi Pico in C, C++ or assembly language.&lt;/p&gt; &#xA;&lt;p&gt;The SDK is designed to provide an API and programming environment that is familiar both to non-embedded C developers and embedded C developers alike. A single program runs on the device at a time and starts with a conventional &lt;code&gt;main()&lt;/code&gt; method. Standard C/C++ libraries are supported along with C level libraries/APIs for accessing all of the RP2040&#39;s hardware include PIO (Programmable IO).&lt;/p&gt; &#xA;&lt;p&gt;Additionally the SDK provides higher level libraries for dealing with timers, synchronization, USB (TinyUSB) and multi-core programming along with various utilities.&lt;/p&gt; &#xA;&lt;p&gt;The SDK can be used to build anything from simple applications, to fully fledged runtime environments such as MicroPython, to low level software such as RP2040&#39;s on-chip bootrom itself.&lt;/p&gt; &#xA;&lt;p&gt;Additional libraries/APIs that are not yet ready for inclusion in the SDK can be found in &lt;a href=&#34;https://github.com/raspberrypi/pico-extras&#34;&gt;pico-extras&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://rptl.io/pico-get-started&#34;&gt;Getting Started with the Raspberry Pi Pico&lt;/a&gt; for information on how to setup your hardware, IDE/environment and for how to build and debug software for the Raspberry Pi Pico and other RP2040-based devices.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://rptl.io/pico-c-sdk&#34;&gt;Raspberry Pi Pico C/C++ SDK&lt;/a&gt; to learn more about programming using the SDK, to explore more advanced features, and for complete PDF-based API documentation.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://rptl.io/pico-doxygen&#34;&gt;Online Raspberry Pi Pico SDK API docs&lt;/a&gt; for HTML-based API documentation.&lt;/p&gt; &#xA;&lt;h1&gt;Example code&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/raspberrypi/pico-examples&#34;&gt;pico-examples&lt;/a&gt; for example code you can build.&lt;/p&gt; &#xA;&lt;h1&gt;Quick-start your own project&lt;/h1&gt; &#xA;&lt;p&gt;These instructions are extremely terse, and Linux-based only. For detailed steps, instructions for other platforms, and just in general, we recommend you see &lt;a href=&#34;https://rptl.io/pico-c-sdk&#34;&gt;Raspberry Pi Pico C/C++ SDK&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install CMake (at least version 3.13), and GCC cross compiler&lt;/p&gt; &lt;pre&gt;&lt;code&gt;sudo apt install cmake gcc-arm-none-eabi libnewlib-arm-none-eabi libstdc++-arm-none-eabi-newlib&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Set up your project to point to use the Raspberry Pi Pico SDK&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Either by cloning the SDK locally (most common) :&lt;/p&gt; &#xA;    &lt;ol&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;code&gt;git clone&lt;/code&gt; this Raspberry Pi Pico SDK repository&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;Copy &lt;a href=&#34;https://github.com/raspberrypi/pico-sdk/raw/master/external/pico_sdk_import.cmake&#34;&gt;pico_sdk_import.cmake&lt;/a&gt; from the SDK into your project directory&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;Set &lt;code&gt;PICO_SDK_PATH&lt;/code&gt; to the SDK location in your environment, or pass it (&lt;code&gt;-DPICO_SDK_PATH=&lt;/code&gt;) to cmake later.&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;Setup a &lt;code&gt;CMakeLists.txt&lt;/code&gt; like:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;cmake_minimum_required(VERSION 3.13)&#xA;&#xA;# initialize the SDK based on PICO_SDK_PATH&#xA;# note: this must happen before project()&#xA;include(pico_sdk_import.cmake)&#xA;&#xA;project(my_project)&#xA;&#xA;# initialize the Raspberry Pi Pico SDK&#xA;pico_sdk_init()&#xA;&#xA;# rest of your project&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Or with the Raspberry Pi Pico SDK as a submodule :&lt;/p&gt; &#xA;    &lt;ol&gt; &#xA;     &lt;li&gt; &lt;p&gt;Clone the SDK as a submodule called &lt;code&gt;pico-sdk&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;Setup a &lt;code&gt;CMakeLists.txt&lt;/code&gt; like:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;cmake_minimum_required(VERSION 3.13)&#xA;&#xA;# initialize pico-sdk from submodule&#xA;# note: this must happen before project()&#xA;include(pico-sdk/pico_sdk_init.cmake)&#xA;&#xA;project(my_project)&#xA;&#xA;# initialize the Raspberry Pi Pico SDK&#xA;pico_sdk_init()&#xA;&#xA;# rest of your project&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Or with automatic download from GitHub :&lt;/p&gt; &#xA;    &lt;ol&gt; &#xA;     &lt;li&gt; &lt;p&gt;Copy &lt;a href=&#34;https://github.com/raspberrypi/pico-sdk/raw/master/external/pico_sdk_import.cmake&#34;&gt;pico_sdk_import.cmake&lt;/a&gt; from the SDK into your project directory&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;Setup a &lt;code&gt;CMakeLists.txt&lt;/code&gt; like:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;cmake_minimum_required(VERSION 3.13)&#xA;&#xA;# initialize pico-sdk from GIT&#xA;# (note this can come from environment, CMake cache etc)&#xA;set(PICO_SDK_FETCH_FROM_GIT on)&#xA;&#xA;# pico_sdk_import.cmake is a single file copied from this SDK&#xA;# note: this must happen before project()&#xA;include(pico_sdk_import.cmake)&#xA;&#xA;project(my_project)&#xA;&#xA;# initialize the Raspberry Pi Pico SDK&#xA;pico_sdk_init()&#xA;&#xA;# rest of your project&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Or by cloning the SDK locally, but without copying &lt;code&gt;pico_sdk_import.cmake&lt;/code&gt;:&lt;/p&gt; &#xA;    &lt;ol&gt; &#xA;     &lt;li&gt; &lt;p&gt;&lt;code&gt;git clone&lt;/code&gt; this Raspberry Pi Pico SDK repository&lt;/p&gt; &lt;/li&gt; &#xA;     &lt;li&gt; &lt;p&gt;Setup a &lt;code&gt;CMakeLists.txt&lt;/code&gt; like:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;cmake_minimum_required(VERSION 3.13)&#xA;&#xA;# initialize the SDK directly&#xA;include(/path/to/pico-sdk/pico_sdk_init.cmake)&#xA;&#xA;project(my_project)&#xA;&#xA;# initialize the Raspberry Pi Pico SDK&#xA;pico_sdk_init()&#xA;&#xA;# rest of your project&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Write your code (see &lt;a href=&#34;https://github.com/raspberrypi/pico-examples&#34;&gt;pico-examples&lt;/a&gt; or the &lt;a href=&#34;https://rptl.io/pico-c-sdk&#34;&gt;Raspberry Pi Pico C/C++ SDK&lt;/a&gt; documentation for more information)&lt;/p&gt; &lt;p&gt;About the simplest you can do is a single source file (e.g. hello_world.c)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &#34;pico/stdlib.h&#34;&#xA;&#xA;int main() {&#xA;    setup_default_uart();&#xA;    printf(&#34;Hello, world!\n&#34;);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;And add the following to your &lt;code&gt;CMakeLists.txt&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;add_executable(hello_world&#xA;    hello_world.c&#xA;)&#xA;&#xA;# Add pico_stdlib library which aggregates commonly used features&#xA;target_link_libraries(hello_world pico_stdlib)&#xA;&#xA;# create map/bin/hex/uf2 file in addition to ELF.&#xA;pico_add_extra_outputs(hello_world)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Note this example uses the default UART for &lt;em&gt;stdout&lt;/em&gt;; if you want to use the default USB see the &lt;a href=&#34;https://github.com/raspberrypi/pico-examples/tree/master/hello_world/usb&#34;&gt;hello-usb&lt;/a&gt; example.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Setup a CMake build directory. For example, if not using an IDE:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$ mkdir build&#xA;$ cd build&#xA;$ cmake ..&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Make your target from the build directory you created.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ make hello_world&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You now have &lt;code&gt;hello_world.elf&lt;/code&gt; to load via a debugger, or &lt;code&gt;hello_world.uf2&lt;/code&gt; that can be installed and run on your Raspberry Pi Pico via drag and drop.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>