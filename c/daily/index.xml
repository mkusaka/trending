<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-10T01:32:19Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pgvector/pgvector</title>
    <updated>2023-02-10T01:32:19Z</updated>
    <id>tag:github.com,2023-02-10:/pgvector/pgvector</id>
    <link href="https://github.com/pgvector/pgvector" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open-source vector similarity search for Postgres&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;pgvector&lt;/h1&gt; &#xA;&lt;p&gt;Open-source vector similarity search for Postgres&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE items (embedding vector(3));&#xA;CREATE INDEX ON items USING ivfflat (embedding vector_l2_ops);&#xA;SELECT * FROM items ORDER BY embedding &amp;lt;-&amp;gt; &#39;[1,2,3]&#39; LIMIT 5;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supports L2 distance, inner product, and cosine distance&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pgvector/pgvector/actions&#34;&gt;&lt;img src=&#34;https://github.com/pgvector/pgvector/workflows/build/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Compile and install the extension (supports Postgres 11+)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone --branch v0.4.0 https://github.com/pgvector/pgvector.git&#xA;cd pgvector&#xA;make&#xA;make install # may need sudo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then load it in databases where you want to use it&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE EXTENSION vector;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also install it with &lt;a href=&#34;https://raw.githubusercontent.com/pgvector/pgvector/master/#docker&#34;&gt;Docker&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/pgvector/pgvector/master/#homebrew&#34;&gt;Homebrew&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/pgvector/pgvector/master/#pgxn&#34;&gt;PGXN&lt;/a&gt;, or &lt;a href=&#34;https://raw.githubusercontent.com/pgvector/pgvector/master/#conda-forge&#34;&gt;conda-forge&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Create a vector column with 3 dimensions&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE items (embedding vector(3));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Insert values&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO items VALUES (&#39;[1,2,3]&#39;), (&#39;[4,5,6]&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Get the nearest neighbor by L2 distance&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM items ORDER BY embedding &amp;lt;-&amp;gt; &#39;[3,1,2]&#39; LIMIT 1;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also supports inner product (&lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt;) and cosine distance (&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;p&gt;Note: &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt; returns the negative inner product since Postgres only supports &lt;code&gt;ASC&lt;/code&gt; order index scans on operators&lt;/p&gt; &#xA;&lt;h2&gt;Indexing&lt;/h2&gt; &#xA;&lt;p&gt;Speed up queries with an approximate index. Add an index for each distance function you want to use.&lt;/p&gt; &#xA;&lt;p&gt;L2 distance&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX ON items USING ivfflat (embedding vector_l2_ops);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Inner product&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX ON items USING ivfflat (embedding vector_ip_ops);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Cosine distance&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX ON items USING ivfflat (embedding vector_cosine_ops);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Indexes should be created after the table has some data for optimal clustering. Also, unlike typical indexes which only affect performance, you may see different results for queries after adding an approximate index. Vectors with up to 2,000 dimensions can be indexed.&lt;/p&gt; &#xA;&lt;h3&gt;Index Options&lt;/h3&gt; &#xA;&lt;p&gt;Specify the number of inverted lists (100 by default)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX ON items USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://github.com/facebookresearch/faiss/issues/112&#34;&gt;good place to start&lt;/a&gt; is &lt;code&gt;4 * sqrt(rows)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Query Options&lt;/h3&gt; &#xA;&lt;p&gt;Specify the number of probes (1 by default)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET ivfflat.probes = 1;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A higher value improves recall at the cost of speed.&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;SET LOCAL&lt;/code&gt; inside a transaction to set it for a single query&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;BEGIN;&#xA;SET LOCAL ivfflat.probes = 1;&#xA;SELECT ...&#xA;COMMIT;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Indexing Progress&lt;/h3&gt; &#xA;&lt;p&gt;Check &lt;a href=&#34;https://www.postgresql.org/docs/current/progress-reporting.html#CREATE-INDEX-PROGRESS-REPORTING&#34;&gt;indexing progress&lt;/a&gt; with Postgres 12+&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT phase, tuples_done, tuples_total FROM pg_stat_progress_create_index;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The phases are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;initializing&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;performing k-means&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sorting tuples&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;loading tuples&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note: &lt;code&gt;tuples_done&lt;/code&gt; and &lt;code&gt;tuples_total&lt;/code&gt; are only populated during the &lt;code&gt;loading tuples&lt;/code&gt; phase&lt;/p&gt; &#xA;&lt;h3&gt;Partial Indexes&lt;/h3&gt; &#xA;&lt;p&gt;Consider &lt;a href=&#34;https://www.postgresql.org/docs/current/indexes-partial.html&#34;&gt;partial indexes&lt;/a&gt; for queries with a &lt;code&gt;WHERE&lt;/code&gt; clause&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM items WHERE category_id = 123 ORDER BY embedding &amp;lt;-&amp;gt; &#39;[3,1,2]&#39; LIMIT 5;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;can be indexed with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX ON items USING ivfflat (embedding vector_l2_ops) WHERE (category_id = 123);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To index many different values of &lt;code&gt;category_id&lt;/code&gt;, consider &lt;a href=&#34;https://www.postgresql.org/docs/current/ddl-partitioning.html&#34;&gt;partitioning&lt;/a&gt; on &lt;code&gt;category_id&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE items (embedding vector(3), category_id int) PARTITION BY LIST(category_id);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;To speed up queries without an index, increase &lt;code&gt;max_parallel_workers_per_gather&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET max_parallel_workers_per_gather = 4;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To speed up queries with an index, increase the number of inverted lists (at the expense of recall).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE INDEX ON items USING ivfflat (embedding vector_l2_ops) WITH (lists = 1000);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;h3&gt;Vector Type&lt;/h3&gt; &#xA;&lt;p&gt;Each vector takes &lt;code&gt;4 * dimensions + 8&lt;/code&gt; bytes of storage. Each element is a single precision floating-point number (like the &lt;code&gt;real&lt;/code&gt; type in Postgres), and all elements must be finite (no &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt; or &lt;code&gt;-Infinity&lt;/code&gt;). Vectors can have up to 16,000 dimensions.&lt;/p&gt; &#xA;&lt;h3&gt;Vector Operators&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Operator&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;+&lt;/td&gt; &#xA;   &lt;td&gt;element-wise addition&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;element-wise subtraction&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&amp;lt;-&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;Euclidean distance&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&amp;lt;#&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;negative inner product&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&amp;lt;=&amp;gt;&lt;/td&gt; &#xA;   &lt;td&gt;cosine distance&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Vector Functions&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Function&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;cosine_distance(vector, vector) → double precision&lt;/td&gt; &#xA;   &lt;td&gt;cosine distance&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;inner_product(vector, vector) → double precision&lt;/td&gt; &#xA;   &lt;td&gt;inner product&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;l2_distance(vector, vector) → double precision&lt;/td&gt; &#xA;   &lt;td&gt;Euclidean distance&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;vector_dims(vector) → integer&lt;/td&gt; &#xA;   &lt;td&gt;number of dimensions&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;vector_norm(vector) → double precision&lt;/td&gt; &#xA;   &lt;td&gt;Euclidean norm&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Aggregate Functions&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Function&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;avg(vector) → vector&lt;/td&gt; &#xA;   &lt;td&gt;arithmetic mean&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Libraries&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Language&lt;/th&gt; &#xA;   &lt;th&gt;Libraries&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Python&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pgvector/pgvector-python&#34;&gt;pgvector-python&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Ruby&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ankane/neighbor&#34;&gt;Neighbor&lt;/a&gt;, &lt;a href=&#34;https://github.com/pgvector/pgvector-ruby&#34;&gt;pgvector-ruby&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Node&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pgvector/pgvector-node&#34;&gt;pgvector-node&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Go&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pgvector/pgvector-go&#34;&gt;pgvector-go&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;PHP&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pgvector/pgvector-php&#34;&gt;pgvector-php&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Rust&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pgvector/pgvector-rust&#34;&gt;pgvector-rust&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;C++&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pgvector/pgvector-cpp&#34;&gt;pgvector-cpp&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Elixir&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/pgvector/pgvector-elixir&#34;&gt;pgvector-elixir&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Frequently Asked Questions&lt;/h2&gt; &#xA;&lt;h4&gt;How many vectors can be stored in a single table?&lt;/h4&gt; &#xA;&lt;p&gt;A non-partitioned table has a limit of 32 TB by default in Postgres. A partitioned table can have thousands of partitions of that size.&lt;/p&gt; &#xA;&lt;h4&gt;Is replication supported?&lt;/h4&gt; &#xA;&lt;p&gt;Yes, pgvector uses the write-ahead log (WAL), which allows for replication and point-in-time recovery.&lt;/p&gt; &#xA;&lt;h4&gt;What if I want to index vectors with more than 2,000 dimensions?&lt;/h4&gt; &#xA;&lt;p&gt;Two things you can try are:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;use dimensionality reduction&lt;/li&gt; &#xA; &lt;li&gt;compile Postgres with a larger block size (&lt;code&gt;./configure --with-blocksize=32&lt;/code&gt;) and edit the limit in &lt;code&gt;src/ivfflat.h&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Additional Installation Methods&lt;/h2&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;p&gt;Get the &lt;a href=&#34;https://hub.docker.com/r/ankane/pgvector&#34;&gt;Docker image&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker pull ankane/pgvector&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This adds pgvector to the &lt;a href=&#34;https://hub.docker.com/_/postgres&#34;&gt;Postgres image&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also build the image manually&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone --branch v0.4.0 https://github.com/pgvector/pgvector.git&#xA;cd pgvector&#xA;docker build -t pgvector .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Homebrew&lt;/h3&gt; &#xA;&lt;p&gt;With Homebrew Postgres, you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install pgvector/brew/pgvector&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;PGXN&lt;/h3&gt; &#xA;&lt;p&gt;Install from the &lt;a href=&#34;https://pgxn.org/dist/vector&#34;&gt;PostgreSQL Extension Network&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pgxn install vector&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;conda-forge&lt;/h3&gt; &#xA;&lt;p&gt;Install from &lt;a href=&#34;https://anaconda.org/conda-forge/pgvector&#34;&gt;conda-forge&lt;/a&gt; with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;conda install -c conda-forge pgvector&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method is &lt;a href=&#34;https://github.com/conda-forge/pgvector-feedstock&#34;&gt;community-maintained&lt;/a&gt; by &lt;a href=&#34;https://github.com/mmcauliffe&#34;&gt;@mmcauliffe&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Hosted Postgres&lt;/h2&gt; &#xA;&lt;p&gt;pgvector is available on &lt;a href=&#34;https://github.com/pgvector/pgvector/issues/54&#34;&gt;these providers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To request a new extension on other providers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Amazon RDS - follow the instructions on &lt;a href=&#34;https://aws.amazon.com/rds/postgresql/faqs/&#34;&gt;this page&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Google Cloud SQL - vote or comment on &lt;a href=&#34;https://issuetracker.google.com/issues/265172065&#34;&gt;this page&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;DigitalOcean Managed Databases - vote or comment on &lt;a href=&#34;https://ideas.digitalocean.com/app-framework-services/p/pgvector-extension-for-postgresql&#34;&gt;this page&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Azure Database - vote or comment on &lt;a href=&#34;https://feedback.azure.com/d365community/idea/7b423322-6189-ed11-a81b-000d3ae49307&#34;&gt;this page&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Upgrading&lt;/h2&gt; &#xA;&lt;p&gt;Install the latest version and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER EXTENSION vector UPDATE;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Upgrade Notes&lt;/h2&gt; &#xA;&lt;h3&gt;0.4.0&lt;/h3&gt; &#xA;&lt;p&gt;If upgrading with Postgres &amp;lt; 13, remove this line from &lt;code&gt;sql/vector--0.3.2--0.4.0.sql&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER TYPE vector SET (STORAGE = extended);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run &lt;code&gt;make install&lt;/code&gt; and &lt;code&gt;ALTER EXTENSION vector UPDATE;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;0.3.1&lt;/h3&gt; &#xA;&lt;p&gt;If upgrading from 0.2.7 or 0.3.0, recreate all &lt;code&gt;ivfflat&lt;/code&gt; indexes after upgrading to ensure all data is indexed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- Postgres 12+&#xA;REINDEX INDEX CONCURRENTLY index_name;&#xA;&#xA;-- Postgres &amp;lt; 12&#xA;CREATE INDEX CONCURRENTLY temp_name ON table USING ivfflat (column opclass);&#xA;DROP INDEX CONCURRENTLY index_name;&#xA;ALTER INDEX temp_name RENAME TO index_name;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://dl.acm.org/doi/pdf/10.1145/3318464.3386131&#34;&gt;PASE: PostgreSQL Ultra-High-Dimensional Approximate Nearest Neighbor Search Extension&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/facebookresearch/faiss&#34;&gt;Faiss: A Library for Efficient Similarity Search and Clustering of Dense Vectors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.aaai.org/Papers/ICML/2003/ICML03-022.pdf&#34;&gt;Using the Triangle Inequality to Accelerate k-means&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://theory.stanford.edu/~sergei/papers/kMeansPP-soda.pdf&#34;&gt;k-means++: The Advantage of Careful Seeding&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.cs.utexas.edu/users/inderjit/public_papers/concept_mlj.pdf&#34;&gt;Concept Decompositions for Large Sparse Text Data using Clustering&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;p&gt;View the &lt;a href=&#34;https://github.com/pgvector/pgvector/raw/master/CHANGELOG.md&#34;&gt;changelog&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Everyone is encouraged to help improve this project. Here are a few ways you can help:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pgvector/pgvector/issues&#34;&gt;Report bugs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Fix bugs and &lt;a href=&#34;https://github.com/pgvector/pgvector/pulls&#34;&gt;submit pull requests&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Write, clarify, or fix documentation&lt;/li&gt; &#xA; &lt;li&gt;Suggest or add new features&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To get started with development:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/pgvector/pgvector.git&#xA;cd pgvector&#xA;make&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run all tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make installcheck        # regression tests&#xA;make prove_installcheck  # TAP tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run single tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make installcheck REGRESS=functions                    # regression test&#xA;make prove_installcheck PROVE_TESTS=test/t/001_wal.pl  # TAP test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To enable benchmarking:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;make clean &amp;amp;&amp;amp; PG_CFLAGS=-DIVFFLAT_BENCH make &amp;amp;&amp;amp; make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Resources for contributors&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.postgresql.org/docs/current/extend-pgxs.html&#34;&gt;Extension Building Infrastructure&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.postgresql.org/docs/current/indexam.html&#34;&gt;Index Access Method Interface Definition&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.postgresql.org/docs/13/generic-wal.html&#34;&gt;Generic WAL Records&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>sarah-walker-pcem/pcem</title>
    <updated>2023-02-10T01:32:19Z</updated>
    <id>tag:github.com,2023-02-10:/sarah-walker-pcem/pcem</id>
    <link href="https://github.com/sarah-walker-pcem/pcem" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PCem&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://pcem-emulator.co.uk/&#34;&gt;PCem&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/sarah-walker-pcem/pcem/actions/workflows/test-debug-builds.yml/badge.svg?sanitize=true&#34; alt=&#34;Test Debug Builds&#34;&gt; &lt;img src=&#34;https://github.com/sarah-walker-pcem/pcem/actions/workflows/test-release-builds.yml/badge.svg?sanitize=true&#34; alt=&#34;Test Release Builds&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Download: &lt;a href=&#34;https://pcem-emulator.co.uk/files/PCemV17Win.zip&#34;&gt;Windows&lt;/a&gt;/&lt;a href=&#34;https://pcem-emulator.co.uk/files/PCemV17Linux.tar.gz&#34;&gt;Linux&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Latest version: &lt;b&gt;v17&lt;/b&gt; &lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/CHANGELOG.md&#34;&gt;Changelog&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;PCem is licensed under GPL v2.0, see &lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/COPYING&#34;&gt;COPYING&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;You can submit patches on our &lt;a href=&#34;https://pcem-emulator.co.uk/phpBB3&#34;&gt;forum&lt;/a&gt;. Before you do, please note the &lt;a href=&#34;https://pcem-emulator.co.uk/phpBB3/viewtopic.php?f=3&amp;amp;t=5&#34;&gt;guidelines&lt;/a&gt; for submitting patches.&lt;/p&gt; &#xA;&lt;p&gt;&lt;span&gt;❗&lt;/span&gt; Note: &lt;b&gt;NO COPYRIGHTED ROM FILES ARE INCLUDED NOR WILL THEY BE. PLEASE DO NOT ASK FOR THEM.&lt;/b&gt;&lt;/p&gt; &#xA;&lt;h2&gt;BSD and Linux supplement (v17)&lt;/h2&gt; &#xA;&lt;p&gt;You will need the following libraries and buildtools (and their dependencies):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SDL2&lt;/li&gt; &#xA; &lt;li&gt;wxWidgets 3.x&lt;/li&gt; &#xA; &lt;li&gt;OpenAL&lt;/li&gt; &#xA; &lt;li&gt;CMake&lt;/li&gt; &#xA; &lt;li&gt;Ninja (Recommended, but you can use a Makefile generator if you prefer)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Open a terminal window, navigate to the PCem directory then enter:&lt;/p&gt; &#xA;&lt;h3&gt;Linux/BSD&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -G &#34;Ninja&#34; -DCMAKE_BUILD_TYPE=Release .&#xA;ninja&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Windows (MSYS2)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -G &#34;Ninja&#34; -DMSYS=TRUE -DCMAKE_BUILD_TYPE=Release .&#xA;ninja&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then &lt;code&gt;./src/pcem&lt;/code&gt; to run.&lt;/p&gt; &#xA;&lt;p&gt;The Linux/BSD versions store BIOS ROM images, configuration files, and other data in &lt;code&gt;~/.pcem&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can specify the Display Engine using &lt;code&gt;-DPCEM_DISPLAY_ENGINE=&lt;/code&gt; The options you have are wxWidgets, and Qt configure options are :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  -DCMAKE_BUILD_TYPE=Release : Generate release build. Recommended for regular use.&#xA;  -DCMAKE_BUILD_TYPE=Debug   : Compile with debugging enabled.&#xA;  -DUSE_NETWORKING=OFF       : Build with networking support.&#xA;  -DUSE_PCAP_NETWORKING=ON   : Build with pcap networking support. (Needs USE_NETWORKING to compile) Requires libpcap.&#xA;  -DUSE_ALSA=OFF             : Build with support for MIDI output through ALSA. Requires libasound. (Linux Only)&#xA;  -DPLUGIN_ENGINE=OFF        : Build with plugin support. Builds libpcem-plugin-api and links PCem with it. &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are using -DCMAKE_BUILD_TYPE=Debug, there are some more debug options you can enable if needed&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  -DPCEM_SLIRP_DEBUG=ON           : Build PCem with SLIRP_DEBUG debug output&#xA;  -DPCEM_RECOMPILER_DEBUG=ON      : Build PCem with RECOMPILER_DEBUG debug output&#xA;  -DPCEM_NE2000_DEBUG=ON          : Build PCem with NE2000_DEBUG debug output&#xA;  -DPCEM_EMU8K_DEBUG_REGISTERS=ON : Build PCem with EMU8K_DEBUG_REGISTERS debug output&#xA;  -DPCEM_SB_DSP_RECORD_DEBUG=ON   : Build PCem with SB_DSP_RECORD_DEBUG debug output&#xA;  -DPCEM_MACH64_DEBUG=ON          : Build PCem with MACH64_DEBUG debug output&#xA;  -DPCEM_DEBUG_EXTRA=ON           : Build PCem with DEBUG_EXTRA debug output&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are using -DCMAKE_BUILD_TYPE=RelWithDebInfo, there are additional options you can do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  -DPCEM_RELDEB_AS_RELEASE=ON     : Builds RelWithDebInfo with debugging logging enabled when this is off&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;They are some extra modules you can add if you build with &lt;code&gt;-DUSE_EXPERIMENTAL=ON&lt;/code&gt;. These modules are untested. incomplete, and may or may not be in a future build of PCem. We do not provide builds with these enabled as well. It is also possible they may not even build.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  -DUSE_EXPERIMENTAL_PGC=ON       : Build PCem with Professional Graphics Controller support.&#xA;  -DUSE_EXPERIMENTAL_PRINTER=ON   : Build PCem with Printer support. Requires freetype.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The menu is a pop-up menu in the Linux/BSD port. Right-click on the main window when mouse is not captured.&lt;/p&gt; &#xA;&lt;p&gt;CD-ROM support currently only accesses &lt;code&gt;/dev/cdrom&lt;/code&gt;. It has not been heavily tested.&lt;/p&gt; &#xA;&lt;h2&gt;Links&lt;/h2&gt; &#xA;&lt;h3&gt;PCem emulates the following hardware (as of v17):&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Hardware&lt;/th&gt; &#xA;   &lt;th&gt;Links&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Systems&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#8088-based&#34;&gt;8088&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#8086-based&#34;&gt;8086&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#286-based&#34;&gt;286&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#386-based&#34;&gt;386&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#486-based&#34;&gt;486&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#pentium-based&#34;&gt;Pentium&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#super-socket-7-based&#34;&gt;Super Socket 7&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Graphics&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#basic-cards&#34;&gt;Basic&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#unaccelerated-svga-cards&#34;&gt;Unaccelerated (S)VGA cards&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#2d-accelerated-svga-cards&#34;&gt;2D accelerated SVGA cards&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#3d-accelerated-svga-cards&#34;&gt;3D accelerated SVGA cards&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#3d-only-cards&#34;&gt;3D only cards&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Sound&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#sound-cards&#34;&gt;Cards&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;HDD Controller&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#hdd-controller-cards&#34;&gt;Cards&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Misc&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#misc-cards&#34;&gt;Cards&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/TESTED.md&#34;&gt;Software Tested&lt;/a&gt; (list)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/TESTED.md#dos&#34;&gt;DOS&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/TESTED.md#windows&#34;&gt;Windows&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/TESTED.md#windows-nt&#34;&gt;Windows NT&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/TESTED.md#os2&#34;&gt;OS/2&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/TESTED.md#linux&#34;&gt;Linux&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/TESTED.md#applications&#34;&gt;Applications&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/TESTED.md#games&#34;&gt;Games&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/TESTED.md#demos&#34;&gt;Demos&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/TESTED.md#emulators&#34;&gt;Emulators&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Systems&lt;/h2&gt; &#xA;&lt;h3&gt;8088 based&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Machine&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1981&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PC&lt;/b&gt;&lt;br&gt;8088 at 4.77 MHz&lt;br&gt;16KB - 640KB RAM (min. 64KB)&lt;/td&gt; &#xA;   &lt;td&gt;ibmpc/pc102782.bin&lt;br&gt;ibmpc/basicc11.f6&lt;br&gt;ibmpc/basicc11.f8&lt;br&gt;ibmpc/basicc11.fa&lt;br&gt;ibmpc/basicc11.fc&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1983&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Compaq Portable Plus&lt;/b&gt;&lt;br&gt;8088 at 4.77 MHz&lt;br&gt;128KB - 640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;compaq_pip/Compaq Portable Plus 100666-001 Rev C.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1983&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM XT&lt;/b&gt;&lt;br&gt;8088 at 4.77 MHz&lt;br&gt;64KB - 640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;ibmxt/5000027.u19&lt;br&gt;ibmxt/1501512.u18&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1983&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Leading Edge Model M&lt;/b&gt;&lt;br&gt;8088 at 7.16 MHz&lt;br&gt;128KB - 704KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;leadingedge_modelm/Leading Edge - Model M - BIOS ROM - Version 4.71.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1984&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PCjr&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8088 at 4.77 MHz&lt;br&gt;64KB - 640KB RAM (min. 128KB)&lt;br&gt;Built-in 16 colour graphics&lt;br&gt;3 voice sound&lt;br&gt;Not generally PC compatible.&lt;/td&gt; &#xA;   &lt;td&gt;ibmpcjr/bios.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1984&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Tandy 1000&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8088 at 4.77 MHz&lt;br&gt;128KB - 640KB RAM&lt;br&gt;Built-in 16 colour graphics&lt;br&gt;3 voice sound&lt;/td&gt; &#xA;   &lt;td&gt;tandy/tandy1t1.020&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1985&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Commodore PC10&lt;/b&gt;&lt;br&gt;8088 at 4.77 MHz&lt;br&gt;640KB RAM CGA/Monochrome&lt;/td&gt; &#xA;   &lt;td&gt;cbm_pc10/cbm-pc10c-bios-v4.41-318085-08.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1985&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;NCR PC4i&lt;/b&gt;&lt;br&gt;8088 at 4.77 MHz&lt;br&gt;256KB - 640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;ncr_pc4i/NCR_PC4i_BIOSROM_1985.BIN&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1986&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;DTK Clone XT&lt;/b&gt;&lt;br&gt;8088 at 8/10 MHz&lt;br&gt;64KB - 640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;dtk/dtk_erso_2.42_2764.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1986&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Phoenix XT clone&lt;/b&gt;&lt;br&gt;8088 at 8/10 MHz&lt;br&gt;64KB - 640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;pxxt/000p001.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1987&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Hyundai Super 16T&lt;/b&gt;&lt;br&gt;8088/8087 at 4.77/8.0 MHz&lt;br&gt;640KB RAM&lt;br&gt;EGA 16 colour graphics&lt;br&gt;&lt;/td&gt; &#xA;   &lt;td&gt;super16t/hyundai-super-16t-system-bios-hea-v1.12ta.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1987&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Tandy 1000HX&lt;/b&gt;&lt;br&gt;8088 at 7.16 MHz&lt;br&gt;256KB - 640KB RAM&lt;br&gt;Built-in 16 colour graphics&lt;br&gt;3 voice sound&lt;br&gt;Has DOS 2.11 in ROM&lt;/td&gt; &#xA;   &lt;td&gt;tandy1000hx/v020000.u12&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1987&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Thomson TO16 PC&lt;/b&gt;&lt;br&gt;8088 at 9.54 MHz&lt;br&gt;512KB - 640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;to16_pc/TO16_103.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1987&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Toshiba T1000&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-1&#34;&gt;[1]&lt;/a&gt;&lt;/i&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8088 at 4.77 MHz&lt;br&gt;512KB - 1024KB RAM&lt;br&gt;CGA on built-in LCD&lt;/td&gt; &#xA;   &lt;td&gt;t1000/t1000.rom&lt;br&gt;t1000/t1000font.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1987&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;VTech Laser Turbo XT&lt;/b&gt;&lt;br&gt;8088 at 10 MHz&lt;br&gt;640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;ltxt/27c64.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1987&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Zenith Data SupersPort&lt;/b&gt;&lt;br&gt;8088 at 8 MHz&lt;br&gt;128KB - 640KB RAM&lt;br&gt;Built-in LCD video is not currently emulated&lt;/td&gt; &#xA;   &lt;td&gt;zdsupers/z184m v3.1d.10d&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;©Anonymous Generic Turbo XT BIOS&lt;/b&gt;&lt;br&gt;8088 at 8+ MHz&lt;br&gt;64KB - 640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;genxt/pcxt.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Atari PC3&lt;/b&gt;&lt;br&gt;8088 at 8 MHz&lt;br&gt;640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;ataripc3/AWARD_ATARI_PC_BIOS_3.08.BIN&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Juko XT clone&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;jukopc/000o001.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Schneider Euro PC&lt;/b&gt;&lt;br&gt;8088 at 9.54 MHz&lt;br&gt;512KB - 640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;europc/50145&lt;br&gt;europc/50146&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1989&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;AMI XT clone&lt;/b&gt;&lt;br&gt;8088 at 8+ MHz&lt;br&gt;64KB - 640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;amixt/ami_8088_bios_31jan89.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1989&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Hyundai Super 16TE&lt;/b&gt;&lt;br&gt;8088/8087 at 10 MHz&lt;br&gt;640KB RAM&lt;br&gt;EGA 16 colour graphics&lt;br&gt;&lt;/td&gt; &#xA;   &lt;td&gt;super16te/hyundai-super-16te-system-bios-v2.00id.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2015&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Xi8088&lt;/b&gt;&lt;br&gt;8088 at 4.77-13.33 MHz&lt;br&gt;640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;xi8088/bios-xi8088.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;8086 based&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Machine&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1984&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Compaq Deskpro&lt;/b&gt;&lt;br&gt;8086 at 8 MHz&lt;br&gt;128KB - 640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;deskpro/Compaq - BIOS - Revision J - 106265-002.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1984&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Olivetti M24&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8086 at 8 MHz&lt;br&gt;128KB - 640KB RAM&lt;br&gt;Built-in enhanced CGA (supports 640x400x2)&lt;/td&gt; &#xA;   &lt;td&gt;olivetti_m24/olivetti_m24_version_1.43_low.bin&lt;br&gt;olivetti_m24/olivetti_m24_version_1.43_high.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1986&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad PC1512&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8086 at 8 MHz&lt;br&gt;512KB - 640KB RAM&lt;br&gt;Enhanced CGA (supports 640x200x16)&lt;br&gt;Custom mouse port&lt;/td&gt; &#xA;   &lt;td&gt;pc1512/40043.v1&lt;br&gt;pc1512/40044.v2&lt;br&gt;pc1512/40078.ic127&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1987&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad PC1640&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8086 at 8 MHz&lt;br&gt;640KB RAM&lt;br&gt;Built-in Paradise EGA&lt;br&gt;Custom mouse port&lt;/td&gt; &#xA;   &lt;td&gt;pc1640/40043.v3&lt;br&gt;pc1640/40044.v3&lt;br&gt;pc1640/40100&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1987&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Toshiba T1200&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-1&#34;&gt;[1]&lt;/a&gt;&lt;/i&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8086 at 9.54 MHz&lt;br&gt;1MB - 2MB RAM&lt;br&gt;CGA on built-in LCD&lt;/td&gt; &#xA;   &lt;td&gt;t1200/t1200_019e.ic15.bin&lt;br&gt;t1200/t1000font.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad PPC512/640&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8086 at 8 MHz&lt;br&gt;512KB - 640KB RAM&lt;br&gt;Built-in CGA w/ plasma display&lt;/td&gt; &#xA;   &lt;td&gt;ppc512/40107.v2&lt;br&gt;ppc512/40108.v2&lt;br&gt;ppc512/40109.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Sinclair PC200/Amstrad PC20&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8086 at 8 MHz&lt;br&gt;512KB - 640KB RAM&lt;br&gt;Built-in CGA (supports TV-out 50hz PAL)&lt;/td&gt; &#xA;   &lt;td&gt;pc200/pc20v2.0&lt;br&gt;pc200/pc20v2.1&lt;br&gt;pc200/40109.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;VTech Laser XT3&lt;/b&gt;&lt;br&gt;8086 at 10 MHz&lt;br&gt;512KB - 1152KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;lxt3/27c64d.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1989&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad PC2086&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8086 at 8 MHz&lt;br&gt;640KB RAM&lt;br&gt;Built-in VGA&lt;/td&gt; &#xA;   &lt;td&gt;pc2086/40179.ic129&lt;br&gt;pc2086/40180.ic132&lt;br&gt;pc2086/40186.ic171&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1989&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Tandy 1000SL/2&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8086 at 9.54 MHz&lt;br&gt;512KB - 768KB RAM&lt;br&gt;Built-in 16 colour graphics&lt;br&gt;4 voice sound&lt;/td&gt; &#xA;   &lt;td&gt;tandy1000sl2/8079047.hu1&lt;br&gt;tandy1000sl2/8079048.hu2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1990&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad PC3086&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;8086 at 8 MHz&lt;br&gt;640KB RAM&lt;br&gt;Built-in VGA&lt;/td&gt; &#xA;   &lt;td&gt;pc3086/fc00.bin&lt;br&gt;pc3086/c000.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1991&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad PC5086&lt;/b&gt;&lt;br&gt;8086 at 8 MHz&lt;br&gt;640KB RAM&lt;/td&gt; &#xA;   &lt;td&gt;pc5086/sys_rom.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;286 based&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Machine&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1984&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM AT&lt;/b&gt;&lt;br&gt;286 at 6 or 8 MHz&lt;br&gt;256KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;ibmat/at111585.0&lt;br&gt;ibmat/at111585.1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1986&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Compaq Portable II&lt;/b&gt;&lt;br&gt;286 at 8 MHz&lt;br&gt;256KB - 15MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;compaq_pii/109739-001.rom&lt;br&gt;compaq_pii/109740-001.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1986&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM XT Model 286&lt;/b&gt;&lt;br&gt;286 at 6 MHz&lt;br&gt;256KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;ibmxt286/BIOS_5162_21APR86_U34_78X7460_27256.BIN&lt;br&gt;ibmxt286/BIOS_5162_21APR86_U35_78X7461_27256.BIN&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1986&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Toshiba T3100e&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-1&#34;&gt;[1]&lt;/a&gt;&lt;/i&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;286 at 12 MHz&lt;br&gt;1MB - 5MB RAM&lt;br&gt;CGA on gas-plasma display&lt;/td&gt; &#xA;   &lt;td&gt;t3100e/t3100e_font.bin&lt;br&gt;t3100e/t3100e.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1987&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/2 Model 50&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;286 at 10 MHz&lt;br&gt;1MB - 16MB RAM&lt;br&gt;Built-in VGA&lt;br&gt;MCA bus&lt;/td&gt; &#xA;   &lt;td&gt;i8550021/90x7420.zm13&lt;br&gt;i8550021/90x7423.zm14&lt;br&gt;i8550021/90x7426.zm16&lt;br&gt;i8550021/90x7429.zm18&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Bull Micral 45&lt;/b&gt;&lt;br&gt;286 at 12 MHz&lt;br&gt;1MB - 6MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;bull_micral_45/even.fil&lt;br&gt;bull_micral_45/odd.fil&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Commodore PC30-III&lt;/b&gt;&lt;br&gt;286 at 12 MHz&lt;br&gt;512KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;cmdpc30/commodore pc 30 iii even.bin&lt;br&gt;cmdpc30/commodore pc 30 iii odd.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/2 Model 30-286&lt;/b&gt;&lt;br&gt;286 at 10 MHz&lt;br&gt;1MB - 16MB RAM&lt;br&gt;Built-in VGA&lt;br&gt;MCA bus&lt;/td&gt; &#xA;   &lt;td&gt;ibmps2_m30_286/33f5381a.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1989&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Epson PC AX&lt;/b&gt;&lt;br&gt;286&lt;br&gt;256KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;epson_pcax/EVAX&lt;br&gt;epson_pcax/ODAX&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1989&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Epson PC AX2e&lt;/b&gt;&lt;br&gt;286 at 12 MHz&lt;br&gt;256KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;epson_pcax2e/EVAX&lt;br&gt;epson_pcax2e/ODAX&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1990&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;AMI 286 clone&lt;/b&gt;&lt;br&gt;286 at 8+ MHz&lt;br&gt;512KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;ami286/amic206.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1990&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Award 286 clone&lt;/b&gt;&lt;br&gt;286 at 8+ MHz&lt;br&gt;512KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;award286/award.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1990&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Dell System 200&lt;/b&gt;&lt;br&gt;286 at 12 MHz&lt;br&gt;640KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;dells200/dell0.bin&lt;br&gt;dells200/dell1.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1990&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/1 Model 2011&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;286 at 10 MHz&lt;br&gt;512KB - 16MB RAM&lt;br&gt;Built-in VGA&lt;br&gt;DOS 4.01 + GUI menu system in ROM&lt;/td&gt; &#xA;   &lt;td&gt;ibmps1/f80000.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Goldstar GDC-212M&lt;/b&gt;&lt;br&gt;286 at 12 MHz&lt;br&gt;512KB - 4MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;gdc212m/gdc212m_72h.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;GW-286CT GEAR&lt;/b&gt;&lt;br&gt;286 at 8+ MHz&lt;br&gt;512KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;gw286ct/2ctc001.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Hyundai Super-286TR&lt;/b&gt;&lt;br&gt;286 at 12 MHz&lt;br&gt;1MB - 4MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;super286tr/award.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Samsung SPC-4200P&lt;/b&gt;&lt;br&gt;286 at 12 MHz&lt;br&gt;512KB - 2MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;spc4200p/u8.01&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Samsung SPC-4216P&lt;/b&gt;&lt;br&gt;286 at 12 MHz&lt;br&gt;1MB - 5MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;spc4216p/phoenix.bin&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;i&gt;or&lt;/i&gt;&lt;br&gt;spc4216p/7101.u8&lt;br&gt;spc4216p/ac64.u10&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Samsung SPC-4620P&lt;/b&gt;&lt;br&gt;286 at 12 MHz&lt;br&gt;1MB - 5MB RAM&lt;br&gt;Built-in Korean ATI-28800&lt;/td&gt; &#xA;   &lt;td&gt;spc4620p/31005h.u8&lt;br&gt;spc4620p/31005h.u10&lt;br&gt;spc4620p/svb6120a_font.rom&lt;br&gt;spc4620p/31005h.u8&lt;br&gt;spc4620p/31005h.u10&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Tulip AT Compact&lt;/b&gt;&lt;br&gt;286&lt;br&gt;640KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;tulip_tc7/tc7be.bin&lt;br&gt;tulip_tc7/tc7bo.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;386 based&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Machine&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1987&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/2 Model 80&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;386DX at 20 MHz&lt;br&gt;1MB - 12MB RAM&lt;br&gt;Built-in VGA&lt;br&gt;MCA bus&lt;/td&gt; &#xA;   &lt;td&gt;i8580111/15f6637.bin&lt;br&gt;i8580111/15f6639.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1988&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;ECS 386/32&lt;/b&gt;&lt;br&gt;386DX at 20 MHz&lt;br&gt;1MB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;ecs386_32/386_32_even.bin&lt;br&gt;ecs386_32/386_32_odd.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1989&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/2 Model 70 (type 3)&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;386DX at 25 MHz&lt;br&gt;2MB - 16MB RAM&lt;br&gt;Built-in VGA&lt;br&gt;MCA bus&lt;/td&gt; &#xA;   &lt;td&gt;ibmps2_m70_type3/70-a_even.bin&lt;br&gt;ibmps2_m70_type3/70-a_odd.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1989&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Compaq Deskpro 386&lt;/b&gt;&lt;br&gt;386DX at 20 MHz&lt;br&gt;1MB - 15MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;deskpro386/109592-005.u11.bin&lt;br&gt;deskpro386/109591-005.u13.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1989&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Epson PC AX3&lt;/b&gt;&lt;br&gt;386SX at 16 MHz&lt;br&gt;256KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;epson_pcax3/EVAX3&lt;br&gt;epson_pcax3/ODAX3&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1989&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/2 Model 55SX&lt;/b&gt;&lt;br&gt;386SX at 16 MHz&lt;br&gt;1MB - 8MB RAM&lt;br&gt;Built-in VGA&lt;br&gt;MCA bus&lt;/td&gt; &#xA;   &lt;td&gt;i8555081/33f8146.zm41&lt;br&gt;i8555081/33f8145.zm40&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1990&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;DTK 386SX clone&lt;/b&gt;&lt;br&gt;386SX&lt;br&gt;512KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;dtk386/3cto001.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1990&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/1 Model 2121&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;386SX at 20 MHz&lt;br&gt;1MB - 16MB RAM&lt;br&gt;Built-in VGA&lt;/td&gt; &#xA;   &lt;td&gt;ibmps1_2121/fc0000.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1990&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Samsung SPC-6000A&lt;/b&gt;&lt;br&gt;386DX&lt;br&gt;1MB - 32 MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;spc6000a/3c80.u27&lt;br&gt;spc6000a/9f80.u26&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1992&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Acermate 386SX/25N&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;386SX at 25 MHz&lt;br&gt;2MB - 16MB RAM&lt;br&gt;Built-in Oak SVGA&lt;/td&gt; &#xA;   &lt;td&gt;acer386/acer386.bin&lt;br&gt;acer386/oti067.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1992&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad MegaPC&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-2&#34;&gt;[2]&lt;/a&gt;&lt;/i&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;386SX at 25 MHz&lt;br&gt;1MB - 16MB RAM&lt;br&gt;Built-in VGA&lt;br&gt;&lt;/td&gt; &#xA;   &lt;td&gt;megapc/41651-bios lo.u18&lt;br&gt;megapc/211253-bios hi.u19&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1992&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Commodore SL386SX-25&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;386SX at 25 MHz&lt;br&gt;1MB - 16MB RAM&lt;br&gt;Built-in AVGA2&lt;/td&gt; &#xA;   &lt;td&gt;cbm_sl386sx25/f000.bin&lt;br&gt;cbm_sl386sx25/c000.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1992&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Packard Bell Legend 300SX&lt;/b&gt;&lt;br&gt;386SX at 16 MHz&lt;br&gt;1MB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;pb_l300sx/pb_l300sx.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1992&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Samsung SPC-6033P&lt;/b&gt;&lt;br&gt;386SX at 33 MHz&lt;br&gt;2MB - 12 MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;spc6033p/phoenix.bin&lt;br&gt;spc6033p/svb6120a_font.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1994&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;AMI 386DX clone&lt;/b&gt;&lt;br&gt;386DX at 40 MHz&lt;br&gt;1MB - 32MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;ami386dx/opt495sx.ami&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1994&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;AMI 386SX clone&lt;/b&gt;&lt;br&gt;386SX at 25 MHz&lt;br&gt;1MB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;ami386/ami386.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1994&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;MR 386DX clone&lt;/b&gt;&lt;br&gt;This is a generic 386DX clone with an MR BIOS&lt;/td&gt; &#xA;   &lt;td&gt;mr386dx/opt495sx.mr&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;KMX-C-02&lt;/b&gt;&lt;br&gt;386SX&lt;br&gt;512KB - 16MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;kmxc02/3ctm005.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;486 based&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Machine&lt;br&gt;(+ addl. hardware)&lt;/th&gt; &#xA;   &lt;th&gt;CPU(s) Supported&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1990&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/2 Model 70 (type 4)&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-3&#34;&gt;[3]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;2MB - 16MB RAM&lt;br&gt;Built-in VGA&lt;br&gt;MCA bus&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;486DX&lt;/b&gt; at 25 MHz&lt;/td&gt; &#xA;   &lt;td&gt;ibmps2_m70_type3/70-a_even.bin&lt;br&gt;ibmps2_m70_type3/70-a_odd.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1993&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;AMI 486 clone&lt;/b&gt;&lt;br&gt;1MB - 32MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;486&lt;/b&gt; at 16-66 MHz&lt;/td&gt; &#xA;   &lt;td&gt;ami486/ami486.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1993&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Elonex PC-425X&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;1MB - 256MB RAM&lt;br&gt;Built-in Trident TGUI9440CXi&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;486SX&lt;/b&gt; at 25 MHz&lt;/td&gt; &#xA;   &lt;td&gt;elx_pc425x/elx_pc425x.bin&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;i&gt;or&lt;/i&gt;&lt;br&gt;elx_pc425x/elx_pc425x_bios.bin&lt;br&gt;elx_pc425x/elx_pc425x_vbios.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1993&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/1 Model 2133 (EMEA 451)&lt;/b&gt;&lt;br&gt;2MB - 64MB RAM&lt;br&gt;Built-in Cirrus Logic GD5426&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;486SX&lt;/b&gt; at 25 MHz&lt;/td&gt; &#xA;   &lt;td&gt;ibmps1_2133/PS1_2133_52G2974_ROM.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1993&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Packard Bell PB410A&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;1MB - 64MB RAM&lt;br&gt;Built-in HT-216 video&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;486&lt;/b&gt; at 25-120 MHz&lt;br&gt;&lt;b&gt;Am5x86&lt;/b&gt; at 133-160 MHz&lt;br&gt;&lt;b&gt;Cx5x86&lt;/b&gt; at 100-133 MHz&lt;br&gt;&lt;b&gt;Pentium Overdrive&lt;/b&gt; at 63-83 MHz&lt;/td&gt; &#xA;   &lt;td&gt;pb410a/PB410A.080337.4ABF.U25.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1994&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;AMI WinBIOS 486 clone&lt;/b&gt;&lt;br&gt;1MB - 32MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;486&lt;/b&gt; at 16-66 MHz&lt;/td&gt; &#xA;   &lt;td&gt;win486/ali1429g.amw&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1995&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Award SiS 496/497&lt;/b&gt;&lt;br&gt;1MB - 64MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;486&lt;/b&gt; at 16-120 MHz&lt;br&gt;&lt;b&gt;Am5x86&lt;/b&gt; at 133-160 MHz&lt;br&gt;&lt;b&gt;Cx5x86&lt;/b&gt; at 100-133 MHz&lt;br&gt;&lt;b&gt;Pentium Overdrive&lt;/b&gt; at 63-83 MHz&lt;/td&gt; &#xA;   &lt;td&gt;sis496/sis496-1.awa&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Pentium based&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Machine&lt;br&gt;(+ addl. hardware)&lt;/th&gt; &#xA;   &lt;th&gt;CPU(s) Supported&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1994&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Intel Premiere/PCI (Batman&#39;s Revenge)&lt;/b&gt;&lt;br&gt;1MB - 128MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium&lt;/b&gt; at 60-66 MHz&lt;br&gt;&lt;b&gt;Pentium Overdrive&lt;/b&gt; at 120-133 MHz&lt;/td&gt; &#xA;   &lt;td&gt;revenge/1009af2_.bi0&lt;br&gt;revenge/1009af2_.bi1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1995&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Intel Advanced/EV (Endeavor)&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-4&#34;&gt;[4]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;1MB - 128MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium&lt;/b&gt; at 75-133 MHz&lt;br&gt;&lt;b&gt;Pentium Overdrive&lt;/b&gt; at 125-200 MHz&lt;/td&gt; &#xA;   &lt;td&gt;endeavor/1006cb0_.bi0&lt;br&gt;endeavor/1006cb0_.bi1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1995&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Intel Advanced/ZP (Zappa)&lt;/b&gt;&lt;br&gt;1MB - 128MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium&lt;/b&gt; at 75-133 MHz&lt;br&gt;&lt;b&gt;Pentium Overdrive&lt;/b&gt; at 125-200 MHz&lt;/td&gt; &#xA;   &lt;td&gt;zappa/1006bs0_.bio&lt;br&gt;zappa/1006bs0_.bi1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1995&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Packard Bell PB520R (Robin LC)&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;1MB - 128MB RAM&lt;br&gt;Built-in Cirrus Logic GD-5434&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium&lt;/b&gt; at 60-66 MHz&lt;br&gt;&lt;b&gt;Pentium Overdrive&lt;/b&gt; at 120-133 MHz&lt;/td&gt; &#xA;   &lt;td&gt;pb520r/1009bc0r.bio&lt;br&gt;pb520r/1009bc0r.bi1&lt;br&gt;pb520r/gd5434.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1995&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Packard Bell PB570 (Hillary)&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;br&gt;1MB - 128MB RAM&lt;br&gt;Built-in Cirrus Logic GD-5430&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium&lt;/b&gt; at 75-133 MHz&lt;br&gt;&lt;b&gt;Pentium Overdrive&lt;/b&gt; at 125-200 MHz&lt;/td&gt; &#xA;   &lt;td&gt;pb570/1007by0r.bio&lt;br&gt;pb570/1007by0r.bi1&lt;br&gt;pb570/gd5430.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1996&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;ASUS P/I-P55TVP4&lt;/b&gt;&lt;br&gt;1MB - 128MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium&lt;/b&gt; at 75-200 MHz&lt;br&gt;&lt;b&gt;Pentium MMX&lt;/b&gt; at 166-233 MHz&lt;br&gt;&lt;b&gt;Mobile Pentium MMX&lt;/b&gt; at 120-300 MHz&lt;br&gt;&lt;b&gt;Cyrix 6x86&lt;/b&gt; at PR90&lt;i&gt;(80 MHz)&lt;/i&gt;-PR200&lt;i&gt;(200 MHz)&lt;/i&gt;&lt;br&gt;&lt;b&gt;Cyrix 6x86MX/MII&lt;/b&gt; at PR166&lt;i&gt;(133 MHz)&lt;/i&gt;-PR400&lt;i&gt;(285 MHz)&lt;/i&gt;&lt;br&gt;&lt;b&gt;IDT WinChip&lt;/b&gt; at 75-240 MHz&lt;br&gt;&lt;b&gt;IDT Winchip 2&lt;/b&gt; at 200-240 MHz&lt;br&gt;&lt;b&gt;IDT Winchip 2A&lt;/b&gt; at 200-233 MHz&lt;br&gt;&lt;b&gt;AMD K6&lt;/b&gt; at 166-300 MHz&lt;br&gt;&lt;b&gt;AMD K6-2&lt;/b&gt; &lt;i&gt;(AFR-66)&lt;/i&gt; at 233-300 MHz&lt;/td&gt; &#xA;   &lt;td&gt;p55tvp4/tv5i0204.awd&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1996&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;ASUS P/I-P55T2P4&lt;/b&gt;&lt;br&gt;1MB - 512MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium&lt;/b&gt; at 75-200 MHz&lt;br&gt;&lt;b&gt;Pentium MMX&lt;/b&gt; at 166-233 MHz&lt;br&gt;&lt;b&gt;Mobile Pentium MMX&lt;/b&gt; at 120-300 MHz&lt;br&gt;&lt;b&gt;Cyrix 6x86&lt;/b&gt; at PR90&lt;i&gt;(80 MHz)&lt;/i&gt;-PR200&lt;i&gt;(200 MHz)&lt;/i&gt;&lt;br&gt;&lt;b&gt;Cyrix 6x86MX/MII&lt;/b&gt; at PR166&lt;i&gt;(133 MHz)&lt;/i&gt;-PR400&lt;i&gt;(285 MHz)&lt;/i&gt;&lt;br&gt;&lt;b&gt;IDT WinChip&lt;/b&gt; at 75-240 MHz&lt;br&gt;&lt;b&gt;IDT Winchip 2&lt;/b&gt; at 200-240 MHz&lt;br&gt;&lt;b&gt;IDT Winchip 2A&lt;/b&gt; at 200-233 MHz&lt;br&gt;&lt;b&gt;AMD K6&lt;/b&gt; at 166-300 MHz&lt;br&gt;&lt;b&gt;AMD K6-2&lt;/b&gt; &lt;i&gt;(AFR-66)&lt;/i&gt; at 233-300 MHz&lt;/td&gt; &#xA;   &lt;td&gt;p55t2p4/0207_j2.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1996&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Award 430VX PCI&lt;/b&gt;&lt;br&gt;1MB - 128MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium&lt;/b&gt; at 75-200 MHz&lt;br&gt;&lt;b&gt;Pentium MMX&lt;/b&gt; at 166-233 MHz&lt;br&gt;&lt;b&gt;Mobile Pentium MMX&lt;/b&gt; at 120-300 MHz&lt;br&gt;&lt;b&gt;Cyrix 6x86&lt;/b&gt; at PR90&lt;i&gt;(80 MHz)&lt;/i&gt;-PR200&lt;i&gt;(200 MHz)&lt;/i&gt;&lt;br&gt;&lt;b&gt;Cyrix 6x86MX/MII&lt;/b&gt; at PR166&lt;i&gt;(133 MHz)&lt;/i&gt;-PR400&lt;i&gt;(285 MHz)&lt;/i&gt;&lt;br&gt;&lt;b&gt;IDT WinChip&lt;/b&gt; at 75-240 MHz&lt;br&gt;&lt;b&gt;IDT Winchip 2&lt;/b&gt; at 200-240 MHz&lt;br&gt;&lt;b&gt;IDT Winchip 2A&lt;/b&gt; at 200-233 MHz&lt;br&gt;&lt;b&gt;AMD K6&lt;/b&gt; at 166-300 MHz&lt;br&gt;&lt;b&gt;AMD K6-2&lt;/b&gt; &lt;i&gt;(AFR-66)&lt;/i&gt; at 233-300 MHz&lt;/td&gt; &#xA;   &lt;td&gt;430vx/55xwuq0e.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1996&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Itautec Infoway Multimidia&lt;/b&gt;&lt;br&gt;8MB - 128MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium&lt;/b&gt; at 75-133 MHz&lt;br&gt;&lt;b&gt;Pentium Overdrive&lt;/b&gt; at 125-200 MHz&lt;/td&gt; &#xA;   &lt;td&gt;infowaym/1006bs0_.bio&lt;br&gt;infowaym/1006bs0_.bi1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1997&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Epox P55-VA&lt;/b&gt;&lt;br&gt;1MB - 128MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium&lt;/b&gt; at 75-200 MHz&lt;br&gt;&lt;b&gt;Pentium MMX&lt;/b&gt; at 166-233 MHz&lt;br&gt;&lt;b&gt;Mobile Pentium MMX&lt;/b&gt; at 120-300 MHz&lt;br&gt;&lt;b&gt;Cyrix 6x86&lt;/b&gt; at PR90&lt;i&gt;(80 MHz)&lt;/i&gt;-PR200&lt;i&gt;(200 MHz)&lt;/i&gt;&lt;br&gt;&lt;b&gt;Cyrix 6x86MX/MII&lt;/b&gt; at PR166&lt;i&gt;(133 MHz)&lt;/i&gt;-PR400&lt;i&gt;(285 MHz)&lt;/i&gt;&lt;br&gt;&lt;b&gt;IDT WinChip&lt;/b&gt; at 75-240 MHz&lt;br&gt;&lt;b&gt;IDT Winchip 2&lt;/b&gt; at 200-240 MHz&lt;br&gt;&lt;b&gt;IDT Winchip 2A&lt;/b&gt; at 200-233 MHz&lt;br&gt;&lt;b&gt;AMD K6&lt;/b&gt; at 166-300 MHz&lt;br&gt;&lt;b&gt;AMD K6-2&lt;/b&gt; &lt;i&gt;(AFR-66)&lt;/i&gt; at 233-300 MHz&lt;/td&gt; &#xA;   &lt;td&gt;p55va/va021297.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Super Socket 7 based&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Machine&lt;br&gt;(+ addl. hardware)&lt;/th&gt; &#xA;   &lt;th&gt;CPU(s) Supported&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1998&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;FIC VA-503+&lt;/b&gt;&lt;br&gt;1MB - 512MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;AMD K6&lt;/b&gt; at 166-300 MHz&lt;br&gt;&lt;b&gt;AMD K6-2&lt;/b&gt; at 233-550 MHz&lt;br&gt;&lt;b&gt;AMD K6-2+&lt;/b&gt; at 450-550 MHz&lt;br&gt;&lt;b&gt;AMD K6-III&lt;/b&gt; at 400-450 MHz&lt;br&gt;&lt;b&gt;AMD K6-III+&lt;/b&gt; at 400-500 MHz&lt;br&gt;&lt;b&gt;Pentium&lt;/b&gt; at 75-200 MHz&lt;br&gt;&lt;b&gt;Pentium MMX&lt;/b&gt; at 166-233 MHz&lt;br&gt;&lt;b&gt;Mobile Pentium MMX&lt;/b&gt; at 120-300 MHz&lt;br&gt;&lt;b&gt;Cyrix 6x86&lt;/b&gt; at PR90&lt;i&gt;(80 MHz)&lt;/i&gt;-PR200&lt;i&gt;(200 MHz)&lt;/i&gt;&lt;br&gt;&lt;b&gt;Cyrix 6x86MX/MII&lt;/b&gt; at PR166&lt;i&gt;(133 MHz)&lt;/i&gt;-PR400&lt;i&gt;(285 MHz)&lt;/i&gt;&lt;br&gt;&lt;b&gt;IDT WinChip&lt;/b&gt; at 75-240 MHz&lt;br&gt;&lt;b&gt;IDT WinChip2&lt;/b&gt; at 200-250 MHz&lt;br&gt;&lt;b&gt;IDT Winchip 2A&lt;/b&gt; at PR200&lt;i&gt;(200 MHz)&lt;/i&gt;-PR300&lt;i&gt;(250 MHz)&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;fic_va503p/je4333.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Socket 8 based&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Machine&lt;br&gt;(+ addl. hardware)&lt;/th&gt; &#xA;   &lt;th&gt;CPU(s) Supported&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1996&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Intel VS440FX&lt;/b&gt;&lt;br&gt;8MB - 256 MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium Pro&lt;/b&gt; at 150-200 MHz&lt;br&gt;&lt;b&gt;Pentium II Overdrive&lt;/b&gt; at 300-333 MHz&lt;/td&gt; &#xA;   &lt;td&gt;vs440fx/1018CS1_.BI1&lt;br&gt;vs440fx/1018CS1_.BI2&lt;br&gt;vs440fx/1018CS1_.BI3&lt;br&gt;vs440fx/1018CS1_.BIO&lt;br&gt;vs440fx/1018CS1_.RCV&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Slot 1 based&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Release&lt;/th&gt; &#xA;   &lt;th&gt;Machine&lt;br&gt;(+ addl. hardware)&lt;/th&gt; &#xA;   &lt;th&gt;CPU(s) Supported&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1998&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Gigabyte GA-686BX&lt;/b&gt;&lt;br&gt;8MB - 512MB RAM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Pentium II&lt;/b&gt; at 233-450 MHz&lt;br&gt;&lt;b&gt;Celeron&lt;/b&gt; at 266-533 MHz&lt;br&gt;&lt;b&gt;Cyrix III&lt;/b&gt;at 500 MHz&lt;/td&gt; &#xA;   &lt;td&gt;ga686bx/6BX.F2a&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Additional Notes&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a name=&#34;system-note-1&#34;&gt;&lt;code&gt;[1]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;Toshiba Button Mapping&lt;/b&gt;: PCem maps [Fn] to &lt;code&gt;right-Ctrl&lt;/code&gt; and &lt;code&gt;right-Alt&lt;/code&gt;. The following functions are supported:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Key Combo&lt;/th&gt; &#xA;   &lt;th&gt;Function&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Fn + Num Lock&lt;/td&gt; &#xA;   &lt;td&gt;toggle numpad&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Fn + Home&lt;/td&gt; &#xA;   &lt;td&gt;Internal LCD display&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Fn + Page Down&lt;/td&gt; &#xA;   &lt;td&gt;Turbo on&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Fn + Right&lt;/td&gt; &#xA;   &lt;td&gt;Toggle LCD font&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Fn + End&lt;/td&gt; &#xA;   &lt;td&gt;External CRT display&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Fn + SysRQ&lt;/td&gt; &#xA;   &lt;td&gt;Toggle window&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;a name=&#34;system-note-2&#34;&gt;&lt;code&gt;[2]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;Amstrad MegaPC&lt;/b&gt; &lt;i&gt;(386SX)&lt;/i&gt;: The original machine had a built-in Sega MegaDrive. This is not emulated in PCem.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;system-note-3&#34;&gt;&lt;code&gt;[3]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;IBM PS/2 Model 70 (type 4)&lt;/b&gt; &lt;i&gt;(486DX)&lt;/i&gt;: PCem&#39;s FPU emulation is not bit accurate and can not pass IBM&#39;s floating point tests. As a result, this machine will always print 12903 and 162 errors on bootup. These can be ignored - F1 will boot the machine.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;system-note-4&#34;&gt;&lt;code&gt;[4]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;Intel Advanced/EV (Endeavor)&lt;/b&gt; &lt;i&gt;(Pentium)&lt;/i&gt;: The real board has a Sound Blaster 16 onboard and optionally an S3 Trio64V+. Neither are emulated as onboard devices.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;system-note-5&#34;&gt;&lt;code&gt;[5]&lt;/code&gt;&lt;/a&gt; Some systems have fixed graphics adapters:&lt;br&gt; &lt;i&gt;** = Can use external video card.&lt;/i&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;System&lt;/th&gt; &#xA;   &lt;th&gt;Graphics&lt;/th&gt; &#xA;   &lt;th&gt;Addl. Info&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;**&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad MegaPC&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Paradise 90C11&lt;/td&gt; &#xA;   &lt;td&gt;A development of the PVGA1 with 512KB VRAM&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Acer 386SX/25N&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Oak OTI-067&lt;/td&gt; &#xA;   &lt;td&gt;Another 512KB SVGA clone&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad PC1512&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;CGA&lt;/td&gt; &#xA;   &lt;td&gt;Has a new mode (640x200x16)&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad PC1640&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Paradise EGA&lt;/td&gt; &#xA;   &lt;td&gt;&amp;nbsp;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad PC2086/PC3086&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Paradise PVGA1&lt;/td&gt; &#xA;   &lt;td&gt;An early SVGA clone with 256KB VRAM&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Amstrad PPC512/640&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;CGA/MDA&lt;/td&gt; &#xA;   &lt;td&gt;Outputs to 640x200 plasma display&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Commodore SL386SX-25&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;AVGA2&lt;/td&gt; &#xA;   &lt;td&gt;256KB - 512KB VRAM&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Elonex PC-425X&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Trident TGUI9400CXi&lt;/td&gt; &#xA;   &lt;td&gt;512KB VRAM&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PCjr&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;CGA&lt;/td&gt; &#xA;   &lt;td&gt;Has various new modes: &lt;br&gt;160x200 x 16&lt;br&gt;320x200 x 16&lt;br&gt;640x200 x 4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/1 Model 2011&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Stock VGA&lt;/td&gt; &#xA;   &lt;td&gt;256KB VRAM&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/1 Model 2121&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Basic (and unknown) SVGA&lt;/td&gt; &#xA;   &lt;td&gt;256KB VRAM&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM PS/2 machines&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Stock VGA&lt;/td&gt; &#xA;   &lt;td&gt;256KB VRAM&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Olivetti M24&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#system-note-6&#34;&gt;[6]&lt;/a&gt;&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;CGA&lt;/td&gt; &#xA;   &lt;td&gt;Has double-res text modes + 640x400 mode&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Packard Bell PB410A&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Headland HT-216&lt;/td&gt; &#xA;   &lt;td&gt;&amp;nbsp;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Packard Bell PB520R&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Cirrus Logic GD-5434&lt;/td&gt; &#xA;   &lt;td&gt;&amp;nbsp;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Packard Bell PB570&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Cirrus Logic GD-5430&lt;/td&gt; &#xA;   &lt;td&gt;&amp;nbsp;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Sinclair PC200&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;CGA&lt;/td&gt; &#xA;   &lt;td&gt;Can output to TV @ 50hz (UK)&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Tandy 1000&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Clone of PCjr video&lt;/td&gt; &#xA;   &lt;td&gt;Widely supported in 80s games&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Tandy 1000 SL/2&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Improved Tandy 1000&lt;/td&gt; &#xA;   &lt;td&gt;Has support for 640x200x16&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Toshiba T-series&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;CGA&lt;/td&gt; &#xA;   &lt;td&gt;Outputs to built-in LCD or plasma display&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;X&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;a name=&#34;system-note-6&#34;&gt;&lt;code&gt;[6]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;Olivetti M24 (display)&lt;/b&gt;: I haven&#39;t seen a dump of the font ROM for this yet, so if one is not provided the MDA font will be used - which looks slightly odd as it is 14-line instead of 16-line.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Graphics Cards&lt;/h2&gt; &#xA;&lt;h3&gt;Basic cards&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Hardware&lt;/th&gt; &#xA;   &lt;th&gt;Addl. Info&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;MDA&lt;/b&gt; &lt;i&gt;(1981)&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;80x25 monochrome text&lt;/td&gt; &#xA;   &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;CGA&lt;/b&gt; &lt;i&gt;(1981)&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;40x25 and 80x25 text&lt;br&gt;320x200 in 4 colours&lt;br&gt;620x200 in 2 colours&lt;br&gt;Supports composite output for ~16 colours.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Hercules&lt;/b&gt; &lt;i&gt;(1982)&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;80x25 monochrome text&lt;br&gt;720x348 in monochrome&lt;/td&gt; &#xA;   &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Plantronics ColorPlus&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An enhanced CGA board with support for 320x200x16 and 640x200x4&lt;/td&gt; &#xA;   &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Wyse WY-700&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A CGA-compatible board with support for a 1280x800 mode&lt;/td&gt; &#xA;   &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;MDSI Genius&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Mono portrait board with support for a 728x1008 mode&lt;/td&gt; &#xA;   &lt;td&gt;8x12.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM EGA&lt;/b&gt; &lt;i&gt;(1984)&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Text up to 80x43&lt;br&gt;Graphics up to 640x350 in 16 colours&lt;/td&gt; &#xA;   &lt;td&gt;ibm_6277356_ega_card_u44_27128.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;ATI EGA Wonder 800+&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An enhanced EGA-compatible board with support for up to 800x600 in 16 colours&lt;/td&gt; &#xA;   &lt;td&gt;ATI EGA Wonder 800+ N1.00.BIN&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Hercules InColor&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An enhanced Hercules with a custom 720x350 16 colour mode&lt;/td&gt; &#xA;   &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Unaccelerated (S)VGA cards&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Hardware&lt;/th&gt; &#xA;   &lt;th&gt;Addl. Info&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;ATI Korean VGA&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ATI-28800 based.&lt;br&gt;512KB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;br&gt;Korean font support&lt;/td&gt; &#xA;   &lt;td&gt;atikorvga.bin&lt;br&gt;ati_ksc5601.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;ATI VGA Edge-16&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ATI-18800 based&lt;br&gt;512KB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;/td&gt; &#xA;   &lt;td&gt;vgaedge16.vbi&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;ATI VGA Charger&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ATI-28800 based&lt;br&gt;512KB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;/td&gt; &#xA;   &lt;td&gt;bios.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;AVGA2&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Also known as Cirrus Logic GD5402&lt;br&gt;256KB - 512KB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;/td&gt; &#xA;   &lt;td&gt;avga2vram.vbi&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM VGA&lt;/b&gt; &lt;i&gt;(1987)&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;256KB VRAM&lt;br&gt;Text up to 80x50&lt;br&gt;Graphics up to 320x200 in 256 colours or 640x480 in 16 colours&lt;/td&gt; &#xA;   &lt;td&gt;ibm_vga.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Kasan Hangulmadang-16&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ET4000AX based&lt;br&gt;1MB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;br&gt;Korean font support&lt;/td&gt; &#xA;   &lt;td&gt;et4000_kasan16.bin&lt;br&gt;kasan_ksc5601.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;OAK OTI-037C&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;256KB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;/td&gt; &#xA;   &lt;td&gt;oti037/bios.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;OAK OTI-067&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;256KB - 512KB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;/td&gt; &#xA;   &lt;td&gt;oti067/bios.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Olivetti GO481 (Paradise PVGA1A)&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;256KB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;/td&gt; &#xA;   &lt;td&gt;oli_go481_lo.bin&lt;br&gt;oli_go481_hi.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Trident 8900D SVGA&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;256KB - 1MB VRAM&lt;br&gt;Supports up to 24-bit colour&lt;/td&gt; &#xA;   &lt;td&gt;trident.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Trident 9000B SVGA&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;512KB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;/td&gt; &#xA;   &lt;td&gt;tvga9000b/BIOS.BIN&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Trident TGUI9400CXi&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1MB - 2MB VRAM&lt;br&gt;Supports up to 24-bit colour&lt;/td&gt; &#xA;   &lt;td&gt;9440.vbi&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Trigem Korean VGA&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ET4000AX based&lt;br&gt;1MB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;br&gt;Korean font support&lt;/td&gt; &#xA;   &lt;td&gt;tgkorvga.bin&lt;br&gt;tg_ksc5601.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Tseng ET4000AX SVGA&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1MB VRAM&lt;br&gt;Supports up to 8-bit colour&lt;/td&gt; &#xA;   &lt;td&gt;et4000.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;2D Accelerated SVGA cards&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Hardware&lt;/th&gt; &#xA;   &lt;th&gt;Addl. Info&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;ATI Graphics Pro Turbo&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Mach64GX based&lt;br&gt;1MB - 4MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;mach64gx/bios.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;ATI Video Xpression&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Mach64VT2 based&lt;br&gt;2MB - 4MB VRAM&lt;br&gt;Has video acceleration&lt;/td&gt; &#xA;   &lt;td&gt;atimach64vt2pci.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Cirrus Logic GD-5428&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1MB - 2MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;Machspeed_VGA_GUI_2100_VLB.vbi&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Cirrus Logic GD-5429&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1MB - 2MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;5429.vbi&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Cirrus Logic GD-5430&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1MB - 2MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;gd5430/pci.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Cirrus Logic GD-5434&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#graphics-note-1&#34;&gt;[1]&lt;/a&gt;&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;2MB - 4MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;gd5434.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Diamond Stealth 32 SVGA&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ET4000/W32p based&lt;br&gt;1MB - 2MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;et4000w32.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM 1MB SVGA Adapter/A&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Cirrus Logic GD5428 based&lt;br&gt;1 MB VRAM&lt;br&gt;Only supported on PS/2 models&lt;/td&gt; &#xA;   &lt;td&gt;SVGA141.ROM&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Number Nine 9FX&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;S3 Trio64 based&lt;br&gt;1MB - 2MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;s3_764.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Paradise Bahamas 64&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;S3 Vision864 based&lt;br&gt;1MB - 4MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;bahamas64.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Phoenix S3 Trio32&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;S3 Trio32 based&lt;br&gt;512KB - 2MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;86c732p.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Phoenix S3 Trio64&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;S3 Trio64 based&lt;br&gt;1MB - 4MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;86c764x1.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Trident TGUI9440&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1MB - 2MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;9440.vbi&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;3D Accelerated SVGA cards&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Hardware&lt;/th&gt; &#xA;   &lt;th&gt;Addl. Info&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;3DFX Voodoo Banshee (reference)&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Voodoo Banshee based&lt;br&gt;8MB - 16MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;pci_sg.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;3DFX Voodoo 3 2000&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Voodoo 3 based&lt;br&gt;16MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;voodoo3_2000/2k11sd.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;3DFX Voodoo 3 3000&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Voodoo 3 based&lt;br&gt;16MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;voodoo3_3000/3k12sd.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Creative Labs 3D Blaster Banshee&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Voodoo Banshee based&lt;br&gt;16MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;blasterpci.rom&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Diamond Stealth 3D 2000&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#graphics-note-2&#34;&gt;[2]&lt;/a&gt;&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;S3 ViRGE/325 based&lt;br&gt;2MB - 4MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;s3virge.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;S3 ViRGE/DX&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#graphics-note-3&#34;&gt;[3]&lt;/a&gt;&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;S3 ViRGE/DX based&lt;br&gt;2MB - 4MB VRAM&lt;/td&gt; &#xA;   &lt;td&gt;86c375_1.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;3D only cards&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Hardware&lt;/th&gt; &#xA;   &lt;th&gt;Addl. Info&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;3DFX Voodoo Graphics&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#graphics-note-4&#34;&gt;[4]&lt;/a&gt;&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;3D accelerator. Widely supported in late 90s games.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Obsidian SB50&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#graphics-note-5&#34;&gt;[5]&lt;/a&gt;&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Voodoo with 2 TMUs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;3DFX Voodoo 2&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#graphics-note-6&#34;&gt;[6]&lt;/a&gt;&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Improved Voodoo Graphics&lt;br&gt;Higher clocks&lt;br&gt;2 TMUs&lt;br&gt;Triangle setup, etc.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Additional Notes&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a name=&#34;graphics-note-1&#34;&gt;&lt;code&gt;[1]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;Cirrus Logic GD-5434&lt;/b&gt;: Real chip also supports 1MB configurations, however this is not currently supported in PCem.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;graphics-note-2&#34;&gt;&lt;code&gt;[2]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;Diamond Stealth 3D 2000&lt;/b&gt;: PCem emulates the ViRGE S3D engine in software. This works with most games I tried, but there may be some issues. The Direct3D drivers for the /325 are fairly poor (often showing as missing triangles), so use of the /DX instead is recommended.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;graphics-note-3&#34;&gt;&lt;code&gt;[3]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;S3 ViRGE/DX&lt;/b&gt;: The drivers that come with Windows are similar to those for the /325, however better ones do exist (try the 8-21-1997 version). With the correct drivers, many early Direct3D games work okay (if slowly).&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;graphics-note-4&#34;&gt;&lt;code&gt;[4]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;3DFX Voodoo Graphics&lt;/b&gt;: PCem emulates this in software. The emulation is a lot faster than in v10 (thanks to a new dynamic recompiler) and should be capable of hitting Voodoo 1 performance on most machines when two render threads are used. As before, the emulated CPU is the bottleneck for most games. &lt;br&gt;&lt;br&gt;PCem can emulate 6 and 8 MB configurations, but defaults to 4 MB for compatibility. It can also emulate the screen filter present on the original card, though this does at present have a noticeable performance hit.&lt;br&gt;&lt;br&gt;Almost everything I&#39;ve tried works okay, with a very few exceptions - Screamer 2 and Rally have serious issues.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;graphics-note-5&#34;&gt;&lt;code&gt;[5]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;Obsidian SB50&lt;/b&gt;: Drivers for this are a bit limited - the official drivers don&#39;t support 2 TMUs in Direct3D.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;graphics-note-6&#34;&gt;&lt;code&gt;[6]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;3DFX Voodoo 2&lt;/b&gt;: PCem can emulate both 8 and 12 MB configurations. It can also emulate 6 and 10 MB configurations (with 2MB framebuffer memory), which were never sold into the PC market but do exist for arcade systems.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Sound Cards&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Hardware&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;PC speaker&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The standard beeper on all PCs. Supports samples/RealSound.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Tandy PSG&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The Texas Instruments chip in the PCjr and Tandy 1000. Supports 3 voices plus noise. I reused the emulator in B-em for this (slightly modified). PCem emulates the differences between the SN76496 (PCjr and Tandy 1000), and the NCR8496 (currently assigned to the Tandy 1000HX). Maniac Mansion and Zak McKraken will only sound correct on the latter.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Tandy PSSJ&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Used on the Tandy 1000SL/2, this clones the NCR8496, adding an addition frequency divider (did any software actually use this?) and an 8-bit DAC.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;PS/1 audio card&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An SN76496 clone plus an 8-bit DAC. The SN76496 isn&#39;t at the same address as PCjr/Tandy, so most software doesn&#39;t support it.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Gameblaster&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The Creative Labs Gameblaster/Creative Music System, Creative&#39;s first sound card introduced in 1987. Has two Philips SAA1099, giving 12 voices of square waves plus 4 noise voices. In stereo!&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Adlib&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Has a Yamaha YM3812, giving 9 voices of 2 op FM, or 6 voices plus a rhythm section. PCem uses the DOSBox dbopl emulator.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Adlib Gold&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;OPL3 with YM318Z 12-bit digital section. Possibly some bugs (not a lot of software to test). The surround module is now emulated.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Sound Blaster&lt;/b&gt; &lt;i&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sarah-walker-pcem/pcem/dev/#sound-note-1&#34;&gt;[1]&lt;/a&gt;&lt;/i&gt;&lt;/td&gt; &#xA;   &lt;td&gt;See linked note for more details.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Gravis Ultrasound&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;32 voice sample playback. Port address is fixed to 240, IRQ and DMA can be changed from the drivers. Emulation is improved significantly over previous versions.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Windows Sound System&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;16-bit digital + OPL3. Note that this only emulates WSS itself, and should not be used with drivers from compatible boards with additional components (eg Turtle Beach Monte Carlo)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Aztech Sound Galaxy Pro 16 AB (Washington)&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;SB compatible + WSS compatible&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Innovation SSI-2001&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;SID6581. Emulated using resid-fp. Board is fixed to port 280.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;b&gt;Ensoniq AudioPCI (ES1371)&lt;br&gt;Sound Blaster PCI 128&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Basic PCI sound card. Emulates Sound Blaster in software.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Additional Notes&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a name=&#34;sound-note-1&#34;&gt;&lt;code&gt;[1]&lt;/code&gt;&lt;/a&gt; &lt;b&gt;Sound Blaster&lt;/b&gt;: Several Sound Blasters are emulated.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SB v1.0 - The original. Limited to 22khz, and no auto-init DMA (can cause crackles sometimes).&lt;/li&gt; &#xA; &lt;li&gt;SB v1.5 - Adds auto-init DMA&lt;/li&gt; &#xA; &lt;li&gt;SB v2.0 - Upped to 41khz&lt;/li&gt; &#xA; &lt;li&gt;SB Pro v1.0 - Stereo with twin OPL2 chips.&lt;/li&gt; &#xA; &lt;li&gt;SB Pro v2.0 - Stereo with OPL 3 chip&lt;/li&gt; &#xA; &lt;li&gt;SB 16 - 16 bit stereo&lt;/li&gt; &#xA; &lt;li&gt;SB AWE32 - SB 16 + wavetable MIDI. This requires a ROM dump from a real AWE32.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All cards are set to Address 220, IRQ 7 and DMA 1 (and High DMA 5). IRQ and DMA can be changed for the SB16 &amp;amp; AWE32 in the drivers. The relevant SET line for autoexec.bat is &lt;code&gt;SET BLASTER = A220 I7 D1 Tx&lt;/code&gt; - where Tx is T1 for SB v1.0, T3 for SB v2.0, T4 for SB Pro, and T6 for SB16.&lt;/p&gt; &#xA;&lt;p&gt;AWE32 requires a ROM dump called &lt;code&gt;awe32.raw&lt;/code&gt;. AWE-DUMP is a utility which can get a dump from a real card. Most EMU8000 functionality should work, however filters are not correct and reverb/chorus effects are not currently emulated.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;HDD Controller Cards&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Int.&lt;/th&gt; &#xA;   &lt;th&gt;Hardware&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;   &lt;th&gt;ROM file needed&lt;br&gt;(within ./roms/ folder)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;MFM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Fixed Disk Adapter (Xebec)&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;MFM controller originally included in the IBM XT. This controller only supports HD types 0, 2, 13, and 16.&lt;/td&gt; &#xA;   &lt;td&gt;ibm_xebec_62x0822_1985.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;MFM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;DTC 5150X&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;8-bit MFM controller.&lt;br&gt;To configure drive types, run &lt;code&gt;DEBUG.EXE&lt;/code&gt; and enter &lt;code&gt;g=c800:5&lt;/code&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;dtc_cxd21a.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;MFM&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;AT Fixed Disk Adapter&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;MFM controller originally included in the IBM AT. Supported by all AT-compatible BIOSes.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;ESDI&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Western Digital WD1007V-SE1&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;16-bit ESDI controller&lt;/td&gt; &#xA;   &lt;td&gt;62-000279-061.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;ESDI&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM ESDI Fixed Disk Controller&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;MCA ESDI controller. Only supported on PS/2 models.&lt;/td&gt; &#xA;   &lt;td&gt;90x8969.bin&lt;br&gt;90x8970.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;IDE&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Standard IDE&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Standard IDE controller. Supported by all AT-compatible BIOSes. Use this if in any doubt!&lt;/td&gt; &#xA;   &lt;td&gt;&lt;i&gt;(none)&lt;/i&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;IDE&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;XTIDE&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;8-bit IDE controller. The BIOS is available &lt;a href=&#34;http://code.google.com/p/xtideuniversalbios/&#34;&gt;here&lt;/a&gt;. &lt;br&gt;v2.0.0 beta 1 is the version I&#39;ve mostly tested. v2.0.0 beta 3 is known to have some issues.&lt;/td&gt; &#xA;   &lt;td&gt;ide_xt.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;IDE&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;XTIDE (AT)&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;16-bit IDE controller.&lt;/td&gt; &#xA;   &lt;td&gt;ide_at.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;IDE&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;XTIDE (PS/1)&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;IDE controller for the PS/1 model 2033. For this machine you will need BIOS version v1.1.5. The PS/1 is a bit fussy with XTIDE, and I&#39;ve found that it works best when the XTIDE configuration has &#39;Full Operating Mode&#39; disabled.&lt;/td&gt; &#xA;   &lt;td&gt;ide_at_1_1_5.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;SCSI&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Longshine LCS-6821N&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;8-bit SCSI controller.&lt;/td&gt; &#xA;   &lt;td&gt;Longshine LCS-6821N - BIOS version 1.04.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;SCSI&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Rancho RT1000B&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;8-bit SCSI controller.&lt;/td&gt; &#xA;   &lt;td&gt;Rancho_RT1000_RTBios_version_8.10R.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;SCSI&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Trantor T130B&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;8-bit SCSI controller.&lt;/td&gt; &#xA;   &lt;td&gt;trantor_t130b_bios_v2.14.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;SCSI&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;IBM SCSI Adapter with Cache&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;MCA SCSI controller. Only supported on PS/2 models.&lt;/td&gt; &#xA;   &lt;td&gt;92F2244.U68&lt;br&gt;92F2245.U69&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;SCSI&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;Adaptec AHA-1542C&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;16-bit SCSI controller.&lt;/td&gt; &#xA;   &lt;td&gt;adaptec_aha1542c_bios_534201-00.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;SCSI&lt;/td&gt; &#xA;   &lt;td&gt;&lt;b&gt;BusLogic BT-545S&lt;/b&gt;&lt;/td&gt; &#xA;   &lt;td&gt;16-bit SCSI controller.&lt;/td&gt; &#xA;   &lt;td&gt;BusLogic_BT-545S_U15_27128_5002026-4.50.bin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Misc Cards&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Hardware&lt;/th&gt; &#xA;   &lt;th&gt;Note&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Serial mouse&lt;/td&gt; &#xA;   &lt;td&gt;A Microsoft compatible serial mouse on COM1. Compatible drivers are all over the place for this.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;M24 mouse&lt;/td&gt; &#xA;   &lt;td&gt;I haven&#39;t seen a DOS mouse driver for this yet but the regular scancode mode works as does the Windows 1.x driver.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;PC1512 mouse&lt;/td&gt; &#xA;   &lt;td&gt;The PC1512&#39;s perculiar quadrature mouse. You need Amstrad&#39;s actual driver for this one.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;PS/2 mouse&lt;/td&gt; &#xA;   &lt;td&gt;A standard 2 button PS/2 mouse. As with serial, compatible drivers are common.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Microsoft PS/2 Intellimouse&lt;/td&gt; &#xA;   &lt;td&gt;A PS/2 mouse with mouse wheel.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ATAPI CD-ROM&lt;/td&gt; &#xA;   &lt;td&gt;Works with OAKCDROM.SYS, VDD-IDE.SYS, and the internal drivers of every OS I&#39;ve tried.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
  <entry>
    <title>antirez/aocla</title>
    <updated>2023-02-10T01:32:19Z</updated>
    <id>tag:github.com,2023-02-10:/antirez/aocla</id>
    <link href="https://github.com/antirez/aocla" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A small stack based, written to bring Advent of Code 2022 Day 13 puzzle to the extreme consequences&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Aocla: the Advent of Code toy language&lt;/h2&gt; &#xA;&lt;p&gt;Aocla (Advent of Code inspired Language) is a toy stack-based programming language written as an extension of &lt;a href=&#34;https://adventofcode.com/2022/day/13&#34;&gt;day 13 Advent of Code 2022 puzzle&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This story starts with me doing Advent of Code for the first time in my life. I hadn&#39;t written a single line of code for two years, busy, as I was, writing my &lt;a href=&#34;https://www.amazon.com/Wohpe-English-Rimmel-Salvatore-Sanfilippo-ebook/dp/B0BQ3HRDPF/&#34;&gt;sci-fi novel&lt;/a&gt;. I wanted to start coding again, but without a project in my hands, what to do? The AoC puzzles helped quite a lot, at first, but they become repetitive and a bit futile quite soon. After completing day 13, a puzzle about comparing nested lists, I saw many other solutions resorting to &lt;code&gt;eval&lt;/code&gt;. They are missing the point, I thought. To me, the puzzle seemed a hint at writing parsers for nested objects.&lt;/p&gt; &#xA;&lt;p&gt;Now, a nice fact about parsers of lists with integers and nested lists is that they are dangerously near to become interpreters of Lisp-alike or FORTH-alike programming languages.&lt;/p&gt; &#xA;&lt;p&gt;The gentle reader should be aware that I&#39;ve a soft spot for &lt;a href=&#34;http://oldblog.antirez.com/page/picol.html&#34;&gt;little languages&lt;/a&gt;. However, Picol was too much of a toy, while &lt;a href=&#34;http://jim.tcl.tk/index.html/doc/www/www/index.html&#34;&gt;Jim&lt;/a&gt; was too big as a coding example. Other than interpreters, I like writing small programs that serve as &lt;a href=&#34;https://github.com/antirez/kilo&#34;&gt;examples&lt;/a&gt; of how you could design bigger programs, while retaining a manageable size. Don&#39;t take me wrong: it&#39;s not like I believe my code should be taken as an example, it&#39;s just that I learned a lot from such small programs, so, from time to time, I like writing new ones, and while I&#39;m at it I share them in the hope somebody could be interested. This time I wanted to obtain something of roughly the size of the Kilo editor, that is around ~1000 lines of code, showing the real world challenges arising when writing an actual interpreter for a programming language more complex than Picol. That&#39;s the result, and as a side effect I really started programming again: after Aocla I wrote more and more code, and now &lt;a href=&#34;https://github.com/antirez/protoview&#34;&gt;I&#39;ve a new project, too&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Let&#39;s start&lt;/h2&gt; &#xA;&lt;p&gt;This README will first explain the language briefly. Later we will talk extensively about the implementation and its design. Without counting comments, the Aocla implementation is shorter than 1000 lines of code, and the core itself is around 500 lines (the rest of the code is the library implementation, the REPL, and other accessory parts). I hope you will find the code easy to follow, even if you are not used to C and to writing interpreters. I tried to keep all simple, as I always do when I write code, for myself and the others having the misfortune of reading or modifying it in the future.&lt;/p&gt; &#xA;&lt;p&gt;Not every feature I desired to have is implemented, and certain data types, like the string type, lack any useful procedure to work with them. This choice was made in order to avoid making the source code more complex than needed, and also, on my side, to avoid writing too much useless code, given that this language will never be used in the real world. Besides, implementing some of the missing parts is a good exercise for the willing reader, assuming she or he are new to this kind of stuff. Even with all this limitations, it is possible to write small working programs with Aocla, and that&#39;s all we need for our goals.&lt;/p&gt; &#xA;&lt;h2&gt;Aocla overview&lt;/h2&gt; &#xA;&lt;p&gt;Aocla is a very simple language, more similar to Joy than to FORTH (higher level). It has a total of six datatypes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lists: &lt;code&gt;[1 2 3 &#34;foo&#34;]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Symbols: &lt;code&gt;mysymbol&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;$x&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Integers: &lt;code&gt;500&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Booleans: &lt;code&gt;#t&lt;/code&gt; or &lt;code&gt;#f&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Tuples: &lt;code&gt;(x y z)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Strings: &lt;code&gt;&#34;Hello World!\n&#34;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Floating point numbers are not provided for simplicity (writing an implementation should not be too hard, and is a good exercise). Aocla programs are valid Aocla lists, so the language is &lt;a href=&#34;https://en.wikipedia.org/wiki/Homoiconicity&#34;&gt;homoiconic&lt;/a&gt;. While Aocla is a stack-based language, like FORTH, Joy and Factor, it introduces the idea of &lt;em&gt;local variables capturing&lt;/em&gt;. Because of this construct, Aocla programs look a bit different (and simpler to write and understand in my opinion) compared to other stack-based languages. Locals capturing is optional: any program using locals can be rewritten to avoid using them, yet the existence of this feature deeply affects the language in many ways.&lt;/p&gt; &#xA;&lt;h2&gt;Our first program&lt;/h2&gt; &#xA;&lt;p&gt;The following is a valid Aocla program, taking 5 and squaring it, to obtain 25.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[5 dup *]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since all the programs must be valid lists, and thus are enclosed between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, both the Aocla CLI (Command Line Interface) and the execution of programs from files are designed to avoid needing the brackets. Aocla will put the program inside &lt;code&gt;[]&lt;/code&gt; for you, so the above program should be written like that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;5 dup *&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Programs are executed from left to right, &lt;em&gt;word by word&lt;/em&gt;. If a word is not a symbol nor a tuple, its execution results into pushing its value on the stack. Symbols will produce a procedure call: the symbol name will be looked up in the table of procedures, and if a procedure with a matching name is found, it gets called. So the above program will perform the following steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;5&lt;/code&gt;: the value 5 is pushed on the stack. The stack will contain &lt;code&gt;(5)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dup&lt;/code&gt;: is a symbol. A procedure called &lt;code&gt;dup&lt;/code&gt; is looked up and executed. What &lt;code&gt;dup&lt;/code&gt; does is to take the top value on the stack and duplicate it, so now the stack will contain &lt;code&gt;(5 5)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;*&lt;/code&gt;: is another symbol. The procedure is called. It will take the last two elements on the stack, check if they are integers, multiply them together and push the result on the stack. Now the stack will contain &lt;code&gt;(25)&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If an Aocla word is a tuple, like &lt;code&gt;(x y)&lt;/code&gt;, its execution has the effect of removing a corresponding number of elements from the stack and binding them to the local variables having the specified names:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;10 20 (x y)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After the above program is executed, the stack will be empty and the local variables x and y will contain 10 and 20.&lt;/p&gt; &#xA;&lt;p&gt;Finally, if an Aocla word is a symbol starting with the &lt;code&gt;$&lt;/code&gt; character and a single additional character, the object stored at the specified variable is pushed on the stack. So the program to square 5 we wrote earlier can be rewritten as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;5 (x) $x $x *&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The ability to capture stack values into locals allow to make complex stack manipulations in a simple way, and makes programs more explicit to read and easier to write. Still locals have the remarkable quality of not making the language semantically more complex (if not for a small thing we will cover later -- search &lt;code&gt;upeval&lt;/code&gt; inside this document if you want to know ASAP, but if you know the Tcl programming language, you already understood from the name, that is similar to Tcl&#39;s &lt;code&gt;uplevel&lt;/code&gt;). In general, while locals help the handling of the stack in the local context of the procedure, words communicate via the stack, so the main advantages of stack-based languages are untouched.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: why locals must have just single letter names? The only reason is to make the implementation of the Aocla interpreter simpler to understand. This way, we don&#39;t need to make use of any dictionary data structure. If I would design Aocla to be a real language, I would remove this limitation.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;We said that symbols normally trigger a procedure call. But symbols can also be pushed on the stack like any other value. To do so, symbols must be quoted, with the &lt;code&gt;&#39;&lt;/code&gt; character at the start.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#39;Hello printnl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;printnl&lt;/code&gt; procedure prints the last element on the stack and also prints a newline character, so the above program will just print &lt;code&gt;Hello&lt;/code&gt; on the screen. You may wonder what&#39;s the point of quoting symbols. After all, you could just use strings, but later we&#39;ll see how this is important in order to write Aocla programs that write Aocla programs.&lt;/p&gt; &#xA;&lt;p&gt;Quoting also works with tuples, so if you want to push the tuple &lt;code&gt;(a b c)&lt;/code&gt; on the stack, instead of capturing the variables a, b and c, you can write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#39;(a b c) printnl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Inspecting the stack content&lt;/h2&gt; &#xA;&lt;p&gt;When you start the Aocla interpreter without a file name, it gets executed in REPL mode (Read Eval Print Loop). You write a code fragment, press enter, the code gets executed and the current state of the stack is shown:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 1&#xA;1&#xA;aocla&amp;gt; 2&#xA;1 2&#xA;aocla&amp;gt; [a b &#34;foo&#34;]&#xA;1 2 [a b &#34;foo&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This way you always know the stack content. When you execute programs from files, in order to debug their executions you can print the stack content using the &lt;code&gt;showstack&lt;/code&gt; procedure.&lt;/p&gt; &#xA;&lt;h2&gt;User defined procedures&lt;/h2&gt; &#xA;&lt;p&gt;Aocla programs are just lists, and Aocla functions are lists bound to a name. The name is given as a symbol, and the way to bind a list with a symbol is an Aocla procedure itself. No special syntax is required.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[dup *] &#39;square def&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;def&lt;/code&gt; procedure will bind the list &lt;code&gt;[dup *]&lt;/code&gt; to the &lt;code&gt;square&lt;/code&gt; symbol, so later we can use the &lt;code&gt;square&lt;/code&gt; symbol and it will call our procedure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 5 square&#xA;25&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Calling a symbol that is not bound to any list will produce an error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; foobar&#xA;Symbol not bound to procedure: &#39;foobar&#39; in unknown:0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Working with lists&lt;/h2&gt; &#xA;&lt;p&gt;Lists are the central data structure of the language: they are used to represent programs and are useful as a general purpose data structure to represent data. So most of the very few built-in procedures that Aocla offers are lists manipulation procedures.&lt;/p&gt; &#xA;&lt;p&gt;The more direct way to show how to write Aocla programs is probably showing examples via its REPL, so I&#39;ll procede in this way.&lt;/p&gt; &#xA;&lt;p&gt;To push an empty list on the stack, you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; []&#xA;[]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then it is possible to add elements to the tail or the head of the list using the &lt;code&gt;&amp;lt;-&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; procedures:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 1 swap -&amp;gt;&#xA;[1] &#xA;aocla&amp;gt; 2 swap -&amp;gt;&#xA;[1 2] &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that these procedures are designed to insert the penultimate element on the stack into the list that is the last element on the stack, so, in this specific case, we have to swap the order of the last two elements on the stack before calling &lt;code&gt;-&amp;gt;&lt;/code&gt;. It is possible to design these procedures in a different way, that is: to the expect &lt;code&gt;list, element&lt;/code&gt; on the stack instead of &lt;code&gt;element, list&lt;/code&gt;. There is no clear winner: one or the other approach is better or worse depending on the use case (but I believe I didn&#39;t write enough Aocla code to really pick the best way). In Aocla, local variables make all this less important compared to other stack based languages. It is always possible to make things more explicit, like in the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; [1 2 3] &#xA;[1 2 3] &#xA;aocla&amp;gt; (l) 4 $l -&amp;gt;&#xA;[1 2 3 4] &#xA;aocla&amp;gt; (l) 5 $l -&amp;gt;&#xA;[1 2 3 4 5] &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, to know how many elements there are in the list, we can use the &lt;code&gt;len&lt;/code&gt; procedure, that also works for other data types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; [&#39;a &#39;b 1 2] &#xA;[a b 1 2] &#xA;aocla&amp;gt; len&#xA;4 &#xA;aocla&amp;gt; &#34;foo&#34;&#xA;4 &#34;foo&#34; &#xA;aocla&amp;gt; len&#xA;4 3 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other useful list operations are the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; [1 2 3] [4 5 6] cat&#xA;[1 2 3 4 5 6]&#xA;aocla&amp;gt; [1 2 3] first&#xA;1&#xA;aocla&amp;gt; [1 2 3] rest&#xA;[2 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: cat also works with strings, tuples, symbols.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;There is, of course, map:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; [1 2 3] [dup *] map&#xA;[1 4 9]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to do something with list elements, in an imperative way, you can use foreach:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; [1 2 3] [printnl] foreach&#xA;1&#xA;2&#xA;3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a few more list procedures. There is &lt;code&gt;get@&lt;/code&gt; to get a specific element in a given position, &lt;code&gt;sort&lt;/code&gt;, to sort a list, and if I remember correctly nothing more about lists. Many of the above procedures are implemented inside the C source code of Aocla, in Aocla language itself. Others are implemented in C because of performance concerns or because it was simpler to do so. For instance, this is the implementation of &lt;code&gt;foreach&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[(l f) // list and function to call with each element.&#xA;    $l len (e)  // Get list len in &#34;e&#34;&#xA;    0 (j)       // j is our current index&#xA;    [$j $e &amp;lt;] [&#xA;        $l $j get@  // Get list[j]&#xA;        $f upeval   // We want to evaluate in the context of the caller&#xA;        $j 1 + (j)  // Go to the next index&#xA;    ] while&#xA;] &#39;foreach def&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see from the above code, Aocla syntax also supports comments. Anything starting from &lt;code&gt;//&lt;/code&gt; to the end of the line is ignored.&lt;/p&gt; &#xA;&lt;h2&gt;Conditionals&lt;/h2&gt; &#xA;&lt;p&gt;Aocla conditionals are just &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;ifelse&lt;/code&gt;. There is also a quite imperative looping construct, that is &lt;code&gt;while&lt;/code&gt;. You could loop in the Scheme way, using recursion, but I wanted to give the language a Common Lisp vibe, where you can write imperative code, too.&lt;/p&gt; &#xA;&lt;p&gt;The words &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;ifelse&lt;/code&gt; do what you could imagine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 5 (a)&#xA;5&#xA;aocla&amp;gt; [$a 2 &amp;gt;] [&#34;a is &amp;gt; 2&#34; printnl] if&#xA;a is &amp;gt; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So &lt;code&gt;if&lt;/code&gt; takes two programs (two lists), one is evaluated to see if it is true or false. The other is executed only if the first program is true.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;ifelse&lt;/code&gt; procedure works similarly, but it takes three programs: condition, true-program, false-program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 9 (a)&#xA;aocla&amp;gt; [$a 11 ==] [&#34;11 reached&#34; printnl] [$a 1 + (a)] ifelse&#xA;aocla&amp;gt; [$a 11 ==] [&#34;11 reached&#34; printnl] [$a 1 + (a)] ifelse&#xA;aocla&amp;gt; [$a 11 ==] [&#34;11 reached&#34; printnl] [$a 1 + (a)] ifelse&#xA;11 reached&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And finally, an example of while:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 10 [dup 0 &amp;gt;] [dup printnl 1 -] while&#xA;10&#xA;9&#xA;8&#xA;7&#xA;6&#xA;5&#xA;4&#xA;3&#xA;2&#xA;1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, for a longer but more recognizable program making use of Aocla locals:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 10 (x) [$x 0 &amp;gt;] [$x printnl $x 1 - (x)] while&#xA;10&#xA;9&#xA;8&#xA;7&#xA;6&#xA;5&#xA;4&#xA;3&#xA;2&#xA;1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In some way, two programming styles are possible: one that uses the stack mainly in order to pass state from different procedures, and otherwise uses locals a lot for local state, and another one where almost everything will use the stack, like in FORTH. Even in the second case, locals can be used from time to time when stack manipulation is more clear using them. For instance Imagine I&#39;ve three values on the stack:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 1 2 3&#xA;1 2 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If I want to sum the first and the third, and leave the second one on the stack, even in a programming style where the code mainly uses the stack to hold state, one could write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; (a _ b) $_ $a $b +&#xA;2 4 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Evaluating lists&lt;/h2&gt; &#xA;&lt;p&gt;Words like &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; are written in Aocla itself. They are not implemented in C, even if they could and probably should for performance reasons (and this is why &lt;code&gt;while&lt;/code&gt; is implemented in C).&lt;/p&gt; &#xA;&lt;p&gt;In order to implement procedures that execute code, Aocla provides the &lt;code&gt;eval&lt;/code&gt; built-in word. It just consumes the list at the top of the stack and evaluates it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 5 [dup dup dup] eval&#xA;5 5 5 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the above example, we executed the list containing the program that calls &lt;code&gt;dup&lt;/code&gt; three times. Let&#39;s write a better example, a procedure that executes the same code a specified number of times:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[(n l)&#xA;    [$n 0 &amp;gt;]&#xA;    [$l eval $n 1 - (n)]&#xA;    while&#xA;] &#39;repeat def&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 3 [&#34;Hello!&#34; printnl] repeat&#xA;Hello!&#xA;Hello!&#xA;Hello!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Eval and local variables&lt;/h2&gt; &#xA;&lt;p&gt;There is a problem with the above implementation of &lt;code&gt;repeat&lt;/code&gt;, it does not mix well with local variables. The following program will not have the expected behavior:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 10 (x) 3 [$x printnl] repeat&#xA;Unbound local var: &#39;$x&#39; in eval:0  in unknown:0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here the problem is that once we call a new procedure, that is &lt;code&gt;repeat&lt;/code&gt;, the local variable &lt;code&gt;x&lt;/code&gt; no longer exists in the context of the called procedure. It belongs to the previous procedure, that is, in this specific case, the &lt;em&gt;top level&lt;/em&gt; execution stack frame. So when &lt;code&gt;repeat&lt;/code&gt; evaluates our program we get an error.&lt;/p&gt; &#xA;&lt;p&gt;This is the only case where Aocla local variables make the semantics of Aocla more complex than other stack based languages without this feature. In order to solve the problem above, Aocla has a special form of &lt;code&gt;eval&lt;/code&gt; called &lt;code&gt;upeval&lt;/code&gt;: it executes a program in the context (again, stack frame, in low level terms) of the caller. Let&#39;s rewrite the &lt;code&gt;repeat&lt;/code&gt; procedure using &lt;code&gt;upeval&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[(n l)&#xA;    [$n 0 &amp;gt;]&#xA;    [$l upeval $n 1 - (n)]&#xA;    while&#xA;] &#39;repeat def&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After the change, it works as expected:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;aocla&amp;gt; 10 (x) 3 [$x printnl] repeat&#xA;10&#xA;10&#xA;10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, out of the blue, without even knowing how Aocla is implemented, let&#39;s check the C implementation of &lt;code&gt;uplevel&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/* Like eval, but the code is evaluated in the stack frame of the calling&#xA; * procedure, if any. */&#xA;int procUpeval(aoclactx *ctx) {&#xA;    if (checkStackType(ctx,1,OBJ_TYPE_LIST)) return 1;&#xA;    obj *l = stackPop(ctx);&#xA;    stackframe *saved = NULL;&#xA;    if (ctx-&amp;gt;frame-&amp;gt;prev) {&#xA;        saved = ctx-&amp;gt;frame;&#xA;        ctx-&amp;gt;frame = ctx-&amp;gt;frame-&amp;gt;prev;&#xA;    }&#xA;    int retval = eval(ctx,l);&#xA;    if (saved) ctx-&amp;gt;frame = saved;&#xA;    release(l);&#xA;    return retval;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What happens here is quite clear: we check to see if the stack contains a list, as top level element. If so, we capture that value in the variable &lt;code&gt;l&lt;/code&gt;, then save the current stack frame, that contains our local variables for the current procedure, and substitute it with the &lt;em&gt;previous procedure&lt;/em&gt; stack frame. Now we can call &lt;code&gt;eval()&lt;/code&gt; and finally restore the original stack frame.&lt;/p&gt; &#xA;&lt;h2&gt;Creating programs at runtime&lt;/h2&gt; &#xA;&lt;p&gt;Aocla is homoiconic, as we already said earlier. Programs are represented with the same data structures that Aocla code can manipulate. Because of that, we can write programs writing programs. For instance let&#39;s create a program that creates a procedure incrementing a variable of the specified name.&lt;/p&gt; &#xA;&lt;p&gt;The procedure expects two objects on the stack: the name of the procedure we want to create, and the variable name that the procedure will increment. Two symbols, basically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;proc-name, var-name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is the listing of the procedure. Even if each line is commented, being written in a language that you didn&#39;t know until ten minutes ago, and even a strange enough language, you may want to carefully read each word it is composed of.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[ (p v) // Procedure, var.&#xA;    []                      // Accumulate our program into an empty list&#xA;    &#39;$ $v cat swap -&amp;gt;       // Push $&amp;lt;varname&amp;gt; into the stack&#xA;    1 swap -&amp;gt;               // Push 1&#xA;    &#39;+ swap -&amp;gt;              // Call +&#xA;    $v [] -&amp;gt; make-tuple swap -&amp;gt; // Capture back value into &amp;lt;varname&amp;gt;&#xA;    [] -&amp;gt;                       // Put all into a nested list&#xA;    &#39;upeval swap -&amp;gt;             // Call upeval against the program&#xA;    $p def // Create the procedure  // Bind to the specified proc name&#xA;] &#39;create-incrementing-proc def&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Basically calling &lt;code&gt;create-incrementing-proc&lt;/code&gt; will end generating a list like that (you can check the intermediate results by adding &lt;code&gt;showstack&lt;/code&gt; calls in your programs):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[[$x 1 + (x)] upeval]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And finally the list is bound to the specified symbol using &lt;code&gt;def&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: programs like the above show that, after all, maybe the &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;-&lt;/code&gt; operators should expect the arguments in reverse order. Maybe I&#39;ll change my mind.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Certain times, programs that write programs can be quite useful. They are a central feature in many Lisp dialects. However in the specific case of Aocla, different procedures can be composed via the stack, and we also have &lt;code&gt;uplevel&lt;/code&gt;, so I feel their usefulness is greatly reduced. Also note that if Aocla was a serious language, it would have a lot more constructs to make writing programs that write programs a lot simpler than the above. Anyway, as you saw earlier, when we implemented the &lt;code&gt;repeat&lt;/code&gt; procedure, in Aocla it is possible to do interesting stuff without using this programming paradigm.&lt;/p&gt; &#xA;&lt;p&gt;Ok, I think that&#39;s enough. We saw the basic of stack languages, the specific stuff Aocla adds and how the language feels like. This isn&#39;t a course on stack languages, nor I would be the best person to talk about the argument. This is a course on how to write a small interpreter in C, so let&#39;s dive into the Aocla interpreter internals.&lt;/p&gt; &#xA;&lt;h1&gt;From puzzle 13 to Aocla&lt;/h1&gt; &#xA;&lt;p&gt;At the start of this README I told you Aocla started from an Advent of Code puzzle. The Puzzle could be solved by parsing the literal representation of lists like the one below, and then writing a comparison function for the the list internal representation (well, actually this is how I solved it, but one could even take the approach of comparing &lt;em&gt;while&lt;/em&gt; parsing, probably). This is an example of such lists:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    [1,[2,[3,[4,[5,6,7]]]],8,9]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Parsing flat lists is not particularly hard, however this is not a single-level object. It has elements that are sub-lists. So a recursive parser was the most obvious solution. This is what I wrote back then, the 13th of December:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/* This describes our elf object type. It can be used to represent&#xA; * nested lists of lists and/or integers. */&#xA;#define ELFOBJ_TYPE_INT  0&#xA;#define ELFOBJ_TYPE_LIST 1&#xA;typedef struct elfobj {&#xA;    int type;       /* ELFOBJ_TYPE_... */&#xA;    union {&#xA;        int i;      /* Integer value. */&#xA;        struct {    /* List value. */&#xA;            struct elfobj **ele;&#xA;            size_t len;&#xA;        } l;&#xA;    } val;&#xA;} elfobj;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Why &lt;code&gt;elfobj&lt;/code&gt;? Well, because it was Christmas and AoC is about elves. The structure above is quite trivial, just two types and a union in order to represent both types.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s see the parser, that is surely more interesting.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/* Given the string &#39;s&#39; return the elfobj representing the list or&#xA; * NULL on syntax error. &#39;*next&#39; is set to the next byte to parse, after&#xA; * the current value was completely parsed. */&#xA;elfobj *parseList(const char *s, const char **next) {&#xA;    elfobj *obj = elfalloc(sizeof(*obj));&#xA;    while(isspace(s[0])) s++;&#xA;    if (s[0] == &#39;-&#39; || isdigit(s[0])) {&#xA;        char buf[64];&#xA;        size_t len = 0;&#xA;        while((*s == &#39;-&#39; || isdigit(*s)) &amp;amp;&amp;amp; len &amp;lt; sizeof(buf)-1)&#xA;            buf[len++] = *s++;&#xA;        buf[len] = 0;&#xA;        obj-&amp;gt;type = ELFOBJ_TYPE_INT;&#xA;        obj-&amp;gt;val.i = atoi(buf);&#xA;        if (next) *next = s;&#xA;        return obj;&#xA;    } else if (s[0] == &#39;[&#39;) {&#xA;        obj-&amp;gt;type = ELFOBJ_TYPE_LIST;&#xA;        obj-&amp;gt;val.l.len = 0;&#xA;        obj-&amp;gt;val.l.ele = NULL;&#xA;        s++;&#xA;        /* Parse comma separated elements. */&#xA;        while(1) {&#xA;            /* The list may be empty, so we need to parse for &#34;]&#34;&#xA;             * ASAP. */&#xA;            while(isspace(s[0])) s++;&#xA;            if (s[0] == &#39;]&#39;) {&#xA;                if (next) *next = s+1;&#xA;                return obj;&#xA;            }&#xA;&#xA;            /* Parse the current sub-element recursively. */&#xA;            const char *nextptr;&#xA;            elfobj *element = parseList(s,&amp;amp;nextptr);&#xA;            if (element == NULL) {&#xA;                freeElfObj(obj);&#xA;                return NULL;&#xA;            }&#xA;            obj-&amp;gt;val.l.ele = elfrealloc(obj-&amp;gt;val.l.ele,&#xA;                                        sizeof(elfobj*)*(obj-&amp;gt;val.l.len+1));&#xA;            obj-&amp;gt;val.l.ele[obj-&amp;gt;val.l.len++] = element;&#xA;            s = nextptr; /* Continue from first byte not parsed. */&#xA;&#xA;            while(isspace(s[0])) s++;&#xA;            if (s[0] == &#39;]&#39;) continue; /* Will be handled by the loop. */&#xA;            if (s[0] == &#39;,&#39;) {&#xA;                s++;&#xA;                continue; /* Parse next element. */&#xA;            }&#xA;&#xA;            /* Syntax error. */&#xA;            freeElfObj(obj);&#xA;            return NULL;&#xA;        }&#xA;        /* Syntax error (list not closed). */&#xA;        freeElfObj(obj);&#xA;        return NULL;&#xA;    } else {&#xA;        /* In a serious program you don&#39;t printf() in the middle of&#xA;         * a function. Just return NULL. */&#xA;        fprintf(stderr,&#34;Syntax error parsing &#39;%s&#39;\n&#34;, s);&#xA;        return NULL;&#xA;    }&#xA;    return obj;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;OK, what are the important parts of the above code? First: the parser is, as I already said, recursive. To parse each element of the list we call the same function again and again. This will make the magic of handling any complex nested list without having to do anything special. I know, I know. This is quite obvious for experienced enough programmers, but I claim it is still kinda of a revelation, like a Mandelbrot set, like standing with a mirror in front of another mirror admiring the infinite repeating images one inside the other. Recursion remains magic even after it is understood.&lt;/p&gt; &#xA;&lt;p&gt;The second point to note: the function gets a pointer to a string, and returns the object parsed and also, by referene, the pointer to the start of the &lt;em&gt;next&lt;/em&gt; object to parse, that is just at some offset inside the same string. This is a very comfortable way to write such a parser: we can call the same function again to get the next object in a loop to parse all the tokens and sub-tokens. And I&#39;m saying tokens for a reason, because the same exact structure can be used also when writing tokenizers that just return tokens one after the other, without any conversion to object.&lt;/p&gt; &#xA;&lt;p&gt;Now, what I did was to take this program and make it the programming language you just learned about in the first part of this README. How? Well, to start I upgraded the object structure for more complex object types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/* Type are defined so that each type ID is a different set bit, this way&#xA; * in checkStackType() we may ask the function to check if some argument&#xA; * is one among a list of types just bitwise-oring the type IDs together. */&#xA;#define OBJ_TYPE_INT    (1&amp;lt;&amp;lt;0)&#xA;#define OBJ_TYPE_LIST   (1&amp;lt;&amp;lt;1)&#xA;#define OBJ_TYPE_TUPLE  (1&amp;lt;&amp;lt;2)&#xA;#define OBJ_TYPE_STRING (1&amp;lt;&amp;lt;3)&#xA;#define OBJ_TYPE_SYMBOL (1&amp;lt;&amp;lt;4)&#xA;#define OBJ_TYPE_BOOL   (1&amp;lt;&amp;lt;5)&#xA;#define OBJ_TYPE_ANY    INT_MAX /* All bits set. For checkStackType(). */&#xA;typedef struct obj {&#xA;    int type;       /* OBJ_TYPE_... */&#xA;    int refcount;   /* Reference count. */&#xA;    int line;       /* Source code line number where this was defined, or 0. */&#xA;    union {&#xA;        int i;      /* Integer. Literal: 1234 */&#xA;        int istrue; /* Boolean. Literal: #t or #f */&#xA;        struct {    /* List or Tuple: Literal: [1 2 3 4] or (a b c) */&#xA;            struct obj **ele;&#xA;            size_t len;&#xA;            int quoted; /* Used for quoted tuples. Don&#39;t capture vars if true.&#xA;                           Just push the tuple on stack. */&#xA;        } l;&#xA;        struct {    /* Mutable string &amp;amp; unmutable symbol. */&#xA;            char *ptr;&#xA;            size_t len;&#xA;            int quoted; /* Used for quoted symbols: when quoted they are&#xA;                           not executed, but just pushed on the stack by&#xA;                           eval(). */&#xA;        } str;&#xA;    };&#xA;} obj;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A few important things to note, since this may look like just a trivial extension of the original puzzle structure, but it&#39;s not:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We now use reference counting. When the object is allocated, it gets a &lt;em&gt;refcount&lt;/em&gt; of 1. Then the functions &lt;code&gt;retain()&lt;/code&gt; and &lt;code&gt;release()&lt;/code&gt; are used in order to increment the reference count when we store the same object elsewhere, or when we want to remove a reference. Finally, when the references drop to zero, the object gets freed.&lt;/li&gt; &#xA; &lt;li&gt;The object types now are all powers of two: single bits, in binary representation. This means we can store or pass multiple types at once in a single integer, just performing the &lt;em&gt;bitwise or&lt;/em&gt;. It is useful in practice. No need for functions with a variable number of arguments just to pass many times at once.&lt;/li&gt; &#xA; &lt;li&gt;There is information about the line number where a given object was defined in the source code. Aocla can be a toy, but a toy that will try to give you some stack trace if there is a runtime error.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;This is the release() function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/* Recursively free an Aocla object, if the refcount just dropped to zero. */&#xA;void release(obj *o) {&#xA;    if (o == NULL) return;&#xA;    assert(o-&amp;gt;refcount &amp;gt;= 0);&#xA;    if (--o-&amp;gt;refcount == 0) {&#xA;        switch(o-&amp;gt;type) {&#xA;        case OBJ_TYPE_LIST:&#xA;        case OBJ_TYPE_TUPLE:&#xA;            for (size_t j = 0; j &amp;lt; o-&amp;gt;l.len; j++)&#xA;                release(o-&amp;gt;l.ele[j]);&#xA;            free(o-&amp;gt;l.ele);&#xA;            break;&#xA;        case OBJ_TYPE_SYMBOL:&#xA;        case OBJ_TYPE_STRING:&#xA;            free(o-&amp;gt;str.ptr);&#xA;            break;&#xA;        default:&#xA;            break;&#xA;            /* Nothing special to free. */&#xA;        }&#xA;        free(o);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that in this implementation, deeply nested data structures will produce many recursive calls. This can be avoided using &lt;em&gt;lazy freeing&lt;/em&gt;, but that&#39;s not needed for something like Aocla. However some reader may want to search &lt;em&gt;lazy freeing&lt;/em&gt; on the web.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to our parser (that is just a more complex version of the initial day 13 puzzle parser, and is not worth showing here), we can take an Aocla program, in the form of a string, parse it and get an Aocla object (&lt;code&gt;obj*&lt;/code&gt; type) back. Now, in order to run an Aocla program, we have to &lt;em&gt;execute&lt;/em&gt; this object. Stack based languages are particularly simple to execute: we just go form left to right, and depending on the object type, we do different actions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If the object is a symbol (and is not quoted, see the &lt;code&gt;quoted&lt;/code&gt; field in the object structure), we try to lookup a procedure with that name, and if it exists we execute the procedure. How? By recursively executing the list bound to the symbol.&lt;/li&gt; &#xA; &lt;li&gt;If the object is a tuple with single characters elements, we capture the variables on the stack.&lt;/li&gt; &#xA; &lt;li&gt;If it&#39;s a symbol starting with &lt;code&gt;$&lt;/code&gt; we push the variable on the stack, and if the variable is not bound, we raise an error.&lt;/li&gt; &#xA; &lt;li&gt;For any other type of object, we just push it on the stack.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The function responsible to execute the program is called &lt;code&gt;eval()&lt;/code&gt;, and is so short we can put it fully here, but I&#39;ll present the function split in different parts, to explain each one carefully. I will start showing just the first three lines, as they already tell us something.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;int eval(aoclactx *ctx, obj *l) {&#xA;    assert (l-&amp;gt;type == OBJ_TYPE_LIST);&#xA;&#xA;    for (size_t j = 0; j &amp;lt; l-&amp;gt;l.len; j++) {&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here there are three things going on. Eval() takes a context and a list. The list is our program, and it is scanned left-to-right, as Aocla programs are executed left to right, word by word. All should be clear but the context. What is an execution context for our program?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/* Interpreter state. */&#xA;#define ERRSTR_LEN 256&#xA;typedef struct aoclactx {&#xA;    size_t stacklen;        /* Stack current len. */&#xA;    obj **stack;&#xA;    aproc *proc;            /* Defined procedures. */&#xA;    stackframe *frame;      /* Stack frame with locals. */&#xA;    /* Syntax error context. */&#xA;    char errstr[ERRSTR_LEN]; /* Syntax error or execution error string. */&#xA;} aoclactx;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It contains the following elements:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The stack. Aocla is a stack based language, so we need a stack where to push and pop Aocla objects.&lt;/li&gt; &#xA; &lt;li&gt;A list of procedures: lists bound to symbols, via the &lt;code&gt;def&lt;/code&gt; word.&lt;/li&gt; &#xA; &lt;li&gt;A stack frame, that is just what contains our local variables:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;    /* We have local vars, so we need a stack frame. We start with a top level&#xA;     * stack frame. Each time a procedure is called, we create a new stack frame&#xA;     * and free it once the procedure returns. */&#xA;    #define AOCLA_NUMVARS 256&#xA;    typedef struct stackframe {&#xA;        obj *locals[AOCLA_NUMVARS];/* Local var names are limited to a,b,c,...,z. */&#xA;        aproc *curproc;            /* Current procedure executing or NULL.  */&#xA;        int curline;               /* Current line number during execution. */&#xA;        struct stackframe *prev;   /* Upper level stack frame or NULL. */&#xA;    } stackframe;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The stack frame has a pointer to the previous stack frame. This is useful both in order to implement &lt;code&gt;upeval&lt;/code&gt; and to show a stack trace when an exception happens and the program is halted.&lt;/p&gt; &#xA;&lt;p&gt;We can continue looking at the remaining parts of eval() now. We stopped at the &lt;code&gt;for&lt;/code&gt; loop, so now we are inside the iteration doing something with each element of the list:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;obj *o = l-&amp;gt;l.ele[j];&#xA;aproc *proc;&#xA;ctx-&amp;gt;frame-&amp;gt;curline = o-&amp;gt;line;&#xA;&#xA;switch(o-&amp;gt;type) {&#xA;case OBJ_TYPE_TUPLE:                /* Capture variables. */&#xA;    /* Quoted tuples just get pushed on the stack, losing&#xA;     * their quoted status. */&#xA;    if (o-&amp;gt;l.quoted) {&#xA;        obj *notq = deepCopy(o);&#xA;        notq-&amp;gt;l.quoted = 0;&#xA;        stackPush(ctx,notq);&#xA;        break;&#xA;    }&#xA;&#xA;    if (ctx-&amp;gt;stacklen &amp;lt; o-&amp;gt;l.len) {&#xA;        setError(ctx,o-&amp;gt;l.ele[ctx-&amp;gt;stacklen]-&amp;gt;str.ptr,&#xA;            &#34;Out of stack while capturing local&#34;);&#xA;        return 1;&#xA;    }&#xA;&#xA;    /* Bind each variable to the corresponding locals array,&#xA;     * removing it from the stack. */&#xA;    ctx-&amp;gt;stacklen -= o-&amp;gt;l.len;&#xA;    for (size_t i = 0; i &amp;lt; o-&amp;gt;l.len; i++) {&#xA;        int idx = o-&amp;gt;l.ele[i]-&amp;gt;str.ptr[0];&#xA;        release(ctx-&amp;gt;frame-&amp;gt;locals[idx]);&#xA;        ctx-&amp;gt;frame-&amp;gt;locals[idx] =&#xA;            ctx-&amp;gt;stack[ctx-&amp;gt;stacklen+i];&#xA;    }&#xA;    break;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The essence of the loop is a &lt;code&gt;switch&lt;/code&gt; statement doing something different depending on the object type. The object is just the current element of the list. The first case is the tuple. Tuples capture local variables, unless they are quoted like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(a b c)  // Normal tuple -- This will capture variables&#xA;`(a b c) // Quoted tuple -- This will be pushed on the stack&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So if the tuple is not quoted, we check if there are enough stack elements according to the tuple length. Then, element after element, we move objects from the Aocla stack to the stack frame, into the array representing the locals. Note that there could be already an object bound to a given local, so we &lt;code&gt;release()&lt;/code&gt; it before the new assignment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;case OBJ_TYPE_SYMBOL:&#xA;    /* Quoted symbols don&#39;t generate a procedure call, but like&#xA;     * any other object they get pushed on the stack. */&#xA;    if (o-&amp;gt;str.quoted) {&#xA;        obj *notq = deepCopy(o);&#xA;        notq-&amp;gt;str.quoted = 0;&#xA;        stackPush(ctx,notq);&#xA;        break;&#xA;    }&#xA;&#xA;    /* Not quoted symbols get looked up and executed if they&#xA;     * don&#39;t start with &#34;$&#34;. Otherwise are handled as locals&#xA;     * push on the stack. */&#xA;    if (o-&amp;gt;str.ptr[0] == &#39;$&#39;) {     /* Push local var. */&#xA;        int idx = o-&amp;gt;str.ptr[1];&#xA;        if (ctx-&amp;gt;frame-&amp;gt;locals[idx] == NULL) {&#xA;            setError(ctx,o-&amp;gt;str.ptr, &#34;Unbound local var&#34;);&#xA;            return 1;&#xA;        }&#xA;        stackPush(ctx,ctx-&amp;gt;frame-&amp;gt;locals[idx]);&#xA;        retain(ctx-&amp;gt;frame-&amp;gt;locals[idx]);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For symbols, as we did for tuples, we check if the symbol is quoted, an in such case we just push it on the stack. Otherwise, we handle two different cases. The above is the one where symbol names start with a &lt;code&gt;$&lt;/code&gt;. It is, basically, the reverse operation of what we saw earlier in tuples capturing local vars. This time the local variable is transferred to the stack. However &lt;strong&gt;we still take the reference&lt;/strong&gt; in the local variable array, as the program may want to push the same variable again and again, so, after pushing the object on the stack, we have to call &lt;code&gt;retain()&lt;/code&gt; to increment the reference count of the object.&lt;/p&gt; &#xA;&lt;p&gt;If the symbol does not start with &lt;code&gt;$&lt;/code&gt;, then it&#39;s a procedure call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;} else {                        /* Call procedure. */&#xA;    proc = lookupProc(ctx,o-&amp;gt;str.ptr);&#xA;    if (proc == NULL) {&#xA;        setError(ctx,o-&amp;gt;str.ptr,&#xA;            &#34;Symbol not bound to procedure&#34;);&#xA;        return 1;&#xA;    }&#xA;    if (proc-&amp;gt;cproc) {&#xA;        /* Call a procedure implemented in C. */&#xA;        aproc *prev = ctx-&amp;gt;frame-&amp;gt;curproc;&#xA;        ctx-&amp;gt;frame-&amp;gt;curproc = proc;&#xA;        int err = proc-&amp;gt;cproc(ctx);&#xA;        ctx-&amp;gt;frame-&amp;gt;curproc = prev;&#xA;        if (err) return err;&#xA;    } else {&#xA;        /* Call a procedure implemented in Aocla. */&#xA;        stackframe *oldsf = ctx-&amp;gt;frame;&#xA;        ctx-&amp;gt;frame = newStackFrame(ctx);&#xA;        ctx-&amp;gt;frame-&amp;gt;curproc = proc;&#xA;        int err = eval(ctx,proc-&amp;gt;proc);&#xA;        freeStackFrame(ctx-&amp;gt;frame);&#xA;        ctx-&amp;gt;frame = oldsf;&#xA;        if (err) return err;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;lookupProc()&lt;/code&gt; function just scans a linked list of procedures and returns a list object or, if there is no such procedure defined, NULL. Now what happens immediately after is much more interesting. Aocla procedures are just list objects, but it is possible to implement Aocla procedures directly in C. If the &lt;code&gt;cproc&lt;/code&gt; is not NULL, then it is a C function pointer implementing a procedure, otherwise the procedure is &lt;em&gt;user defined&lt;/em&gt;, that menas it is written in Aocla, and we need to evaluate it. We do this with a nested &lt;code&gt;eval()&lt;/code&gt; call. As you can see, recursion is crucial in writing interpreters.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;A little digression: if we would like to speedup procedure call, we could cache the procedure lookup directly inside the symbol object. However in Aocla procedures can be redefined, so the next time the same procedure name may be bound to a different procedure. To still cache lookedup procedures, a simple way is to use the concept of &#34;epoch&#34;. The context has a 64 bit integer called epoch, that is incremented every time a procedure is redefined. So, when we cache the procedure lookup into the object, we also store the current value of the epoch. Then, before using the cached value, we check if the epoch maches. If there is no match, we perform the lookup again, and update the cached procedure and the epoch.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sorry, let&#39;s go back to our &lt;code&gt;eval&lt;/code&gt; function. Another important thing that&#39;s worth noting is that each new Aocla procedure call has its own set of local variables. The scope of local variables, in Aocla, is the lifetime of the procedure call, like in many other languages. So, in the code above, before calling an Aocla procedure we allocate a new stack frame using &lt;code&gt;newStackFrame()&lt;/code&gt;, then we can finally call &lt;code&gt;eval()&lt;/code&gt;, free the stack frame and store the old stack frame back in the context structure. Procedures implemented in C don&#39;t need a stack frame, as they will not make any use of Aocla local variables. The following is the last part of the &lt;code&gt;eval()&lt;/code&gt; function implementation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;default:&#xA;    stackPush(ctx,o);&#xA;    retain(o);&#xA;    break;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is the default behavior for all the other object types. They get pushed on the stack, and that&#39;s it.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s see how Aocla C-coded procedures are implemented, by observing the C function implementing basic mathematical operations such as +, -, ...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/* Implements +, -, *, %, ... */&#xA;int procBasicMath(aoclactx *ctx) {&#xA;    if (checkStackType(ctx,2,OBJ_TYPE_INT,OBJ_TYPE_INT)) return 1;&#xA;    obj *b = stackPop(ctx);&#xA;    obj *a = stackPop(ctx);&#xA;&#xA;    int res;&#xA;    const char *fname = ctx-&amp;gt;frame-&amp;gt;curproc-&amp;gt;name;&#xA;    if (fname[0] == &#39;+&#39; &amp;amp;&amp;amp; fname[1] == 0) res = a-&amp;gt;i + b-&amp;gt;i;&#xA;    if (fname[0] == &#39;-&#39; &amp;amp;&amp;amp; fname[1] == 0) res = a-&amp;gt;i - b-&amp;gt;i;&#xA;    if (fname[0] == &#39;*&#39; &amp;amp;&amp;amp; fname[1] == 0) res = a-&amp;gt;i * b-&amp;gt;i;&#xA;    if (fname[0] == &#39;/&#39; &amp;amp;&amp;amp; fname[1] == 0) res = a-&amp;gt;i / b-&amp;gt;i;&#xA;    stackPush(ctx,newInt(res));&#xA;    release(a);&#xA;    release(b);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here I cheated: the code required to implement each math procedure separately would be almost the same. So we bind all the operators to the same C function, and check the name of the procedure called inside a single implementation (see the above function). Here is where we register many procedures to the same C function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void loadLibrary(aoclactx *ctx) {&#xA;    addProc(ctx,&#34;+&#34;,procBasicMath,NULL);&#xA;    addProc(ctx,&#34;-&#34;,procBasicMath,NULL);&#xA;    addProc(ctx,&#34;*&#34;,procBasicMath,NULL);&#xA;    addProc(ctx,&#34;/&#34;,procBasicMath,NULL);&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;procBasicMath()&lt;/code&gt; is quite self-documenting, I guess. The proof of that is that I didn&#39;t add any comment inside the function. When comments are needed, I add them automatically, I can&#39;t help myself. Anyway, what it does is the following: it checks the type of the top objects on the stack, as they must be integers. Get them with &lt;code&gt;stackPop()&lt;/code&gt;, perform the math, push a new integer object, release the two old ones. That&#39;s it.&lt;/p&gt; &#xA;&lt;h2&gt;Deep copy of objects&lt;/h2&gt; &#xA;&lt;p&gt;Believe it or not, that&#39;s it: you already saw all the most important parts of the Aocla interpreter. But there are a few corner cases that are forth a few more paragraphs of this README.&lt;/p&gt; &#xA;&lt;p&gt;Imagine the execution of the following Aocla program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[1 2 3] (x)&#x9;// The varialbe x contains the list now&#xA;4 $x -&amp;gt;&#x9;&#x9;// Now the stack contains the list [1 2 3 4]&#xA;$x&#x9;&#x9;// What will be x now? [1 2 3] or [1 2 3 4]?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Aocla is designed to be kinda of a &lt;em&gt;pure&lt;/em&gt; language: words manipulate objects by taking them from the stack and pushing new objects to the stack, that result from certain operations. We don&#39;t want to expose the idea of references in such a language, I feel like that would be a mess, a design error, and a programming nightmare. So if the variable &lt;code&gt;x&lt;/code&gt; is bound to the list &lt;code&gt;[1 2 3]&lt;/code&gt;, pushing it to the stack and adding new elements to the list should &lt;strong&gt;not produce changes&lt;/strong&gt; to the list stored at &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;At the same time, we don&#39;t want to write an inefficient crap where each value is copied again and again. When we push our variable content on the stack, we just push the pointer to the object and increment the reference count. In order to have the best of both worlds, we want to implement something called &lt;em&gt;copy on write&lt;/em&gt;. So normally our objects can be shared, and thanks to the count of references we know if and object is shared or not. However, as soon as some operation is going to alter an object whose reference count is greater than one, it gets copied first, only later modified.&lt;/p&gt; &#xA;&lt;p&gt;In the above program, the list reference count is 2, because the same list is stored in the array of local variables and on the stack. Let&#39;s give a look at the implementation of the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/* Implements -&amp;gt; and &amp;lt;-, appending element x in list with stack&#xA; *&#xA; * (x [1 2 3]) =&amp;gt; ([1 2 3 x]) | ([x 1 2 3])&#xA; *&#xA; * &amp;lt;- is very inefficient as it memmoves all N elements. */&#xA;int procListAppend(aoclactx *ctx) {&#xA;    int tail = ctx-&amp;gt;frame-&amp;gt;curproc-&amp;gt;name[0] == &#39;-&#39;;     /* Append on tail? */&#xA;    if (checkStackType(ctx,2,OBJ_TYPE_ANY,OBJ_TYPE_LIST)) return 1;&#xA;    obj *l = getUnsharedObject(stackPop(ctx));&#xA;    obj *ele = stackPop(ctx);&#xA;    l-&amp;gt;l.ele = myrealloc(l-&amp;gt;l.ele,sizeof(obj*)*(l-&amp;gt;l.len+1));&#xA;    if (tail) {&#xA;        l-&amp;gt;l.ele[l-&amp;gt;l.len] = ele;&#xA;    } else {&#xA;        memmove(l-&amp;gt;l.ele+1,l-&amp;gt;l.ele,sizeof(obj*)*l-&amp;gt;l.len);&#xA;        l-&amp;gt;l.ele[0] = ele;&#xA;    }&#xA;    l-&amp;gt;l.len++;&#xA;    stackPush(ctx,l);&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The interesting line here is the following one:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;obj *l = getUnsharedObject(stackPop(ctx));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We want an object that is not shared, right? This function will abstract the work for us. Let&#39;s check, in turn, its implementation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;obj *getUnsharedObject(obj *o) {&#xA;    if (o-&amp;gt;refcount &amp;gt; 1) {&#xA;        release(o);&#xA;        return deepCopy(o);&#xA;    } else {&#xA;        return o;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So if the object is already not shared (its &lt;em&gt;refcount&lt;/em&gt; is one), just return it as it is. Otherwise create a copy and remove a reference from the original object. Why, on copy, we need to remove a reference from the passed object? This may look odd at a first glance, but think at it: the invariant here should be that the caller of this function is the only owner of the object. We want the caller to be able to abstract totally what happens inside the &lt;code&gt;getUnsharedObject()&lt;/code&gt; function. If the object was shared and we returned the caller a copy, the reference the caller had for the old object should be gone. Let&#39;s look at the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;obj *o = stackPop(ctx);&#xA;o = getUnsharedObject(o);&#xA;doSomethingThatChanges(o);&#xA;stackPush(ctx,o);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Stack pop and push functions don&#39;t change the reference count of the object, so if the object is not shared we get it with a single reference, change it, push it on the stack and the object has still a single reference.&lt;/p&gt; &#xA;&lt;p&gt;Now imagine that, instead, the object is shared and also lives in a variable. In this case we pop an object that has two references, call &lt;code&gt;getUnsharedObject()&lt;/code&gt; that will return us a copy with a &lt;em&gt;recount&lt;/em&gt; of one. We change the object and push it to the stack. The new object will have a single reference on the stack, and has a reference count of one: all is fine. What about the old object stored in the local variable? It should have a reference count of one as well, but if we don&#39;t &lt;code&gt;release()&lt;/code&gt; it in &lt;code&gt;getUnsharedObject()&lt;/code&gt; it would have two, causing a memory leak.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ll not show the &lt;code&gt;deepCopy()&lt;/code&gt; function, it just allocates a new object of the specified type and copy the content. But guess what? It&#39;s a recursive function, too. That&#39;s why it is a &lt;em&gt;deep&lt;/em&gt; copy.&lt;/p&gt; &#xA;&lt;h1&gt;The end&lt;/h1&gt; &#xA;&lt;p&gt;That&#39;s it, and thanks for reading that far. To know more about interpreters you have only one thing to do: write your own, or radically modify Aocla in some crazy way. Get your hands dirty, it&#39;s super fun and rewarding. I can only promise that what you will learn will be worthwhile, even if you&#39;ll never write an interpreter again.&lt;/p&gt; &#xA;&lt;h2&gt;Appendix: Aocla locals and Fibonacci&lt;/h2&gt; &#xA;&lt;p&gt;I believe the Fibonacci implementation written in Aocla, versus the implementation written in other stack-based languages, is quite telling about the jump forward in readability and usability provided by this simple feature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[(n)&#xA;    [$n 1 &amp;lt;=]&#xA;    [&#xA;        $n&#xA;    ]&#xA;    [&#xA;        $n 1 - fib&#xA;        $n 2 - fib&#xA;        +&#xA;    ] ifelse&#xA;] &#39;fib def&#xA;&#xA;10 fib&#xA;printnl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So, while Aocla is a toy language, I believe this feature should be looked more carefully by actual stack-based language designers.&lt;/p&gt;</summary>
  </entry>
</feed>