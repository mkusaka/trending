<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-22T01:31:19Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>lem0nSec/CreateRemoteThreadPlus</title>
    <updated>2023-01-22T01:31:19Z</updated>
    <id>tag:github.com,2023-01-22:/lem0nSec/CreateRemoteThreadPlus</id>
    <link href="https://github.com/lem0nSec/CreateRemoteThreadPlus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CreateRemoteThread: how to pass multiple parameters to the remote thread function without shellcode.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CreateRemoteThreadPlus&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;CreateRemoteThread: how to pass multiple parameters to the remote thread function without shellcode.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;The Function&lt;/h2&gt; &#xA;&lt;p&gt;As stated by the related MSDN page, the CreateRemoteThread API from kernel32.dll &lt;em&gt;creates a thread that runs in the virtual address space of another process.&lt;/em&gt; This API is often used for process or shellcode injection purposes. Standard dll injection is perhaps the most common amongst these techniques. CreateRemoteThread can &#39;force&#39; the remote process to load an arbitrary .dll by opening a new thread in it. The LoadLibrary address is passed to the API as LPTHREAD_START_ROUTINE (4th parameter), while a pointer to the string (.dll to be loaded) written in the remote process is passed as 5th parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;HANDLE CreateRemoteThread(&#xA;  [in]  HANDLE                 hProcess,&#xA;  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,&#xA;  [in]  SIZE_T                 dwStackSize,&#xA;  [in]  LPTHREAD_START_ROUTINE lpStartAddress,&#xA;  [in]  LPVOID                 lpParameter,&#xA;  [in]  DWORD                  dwCreationFlags,&#xA;  [out] LPDWORD                lpThreadId&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;The Problem&lt;/h2&gt; &#xA;&lt;p&gt;Standard .dll injection works because the LoadLibrary API expects one parameter only. But what if the remote function expects multiple parameters? What if the function is MessageBox for instance? (MessageBox expects four parameters). I wanted to create this repository because some people on the Internet have said that passing more than one argument to the remote function is impossible.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/CreateRemoteThreadPlus/master/pictures/argument.png&#34; alt=&#34;&#34;&gt; &lt;strong&gt;Figure 1. People&#39;s argument (1)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/CreateRemoteThreadPlus/master/pictures/argument1.png&#34; alt=&#34;&#34;&gt; &lt;strong&gt;Figure 2. People&#39;s argument (2)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;The Solution&lt;/h2&gt; &#xA;&lt;p&gt;This code shows how to handle the aforementioned situation by doing the followings:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Writing a data structure containing the parameters into the remote process. This is our LPVOID lpParameter.&lt;/li&gt; &#xA; &lt;li&gt;Writing a __stdcall instruction set into the remote process (no shellcode). This is our LPTHREAD_START_ROUTINE.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Creating a data structure that holds parameters&lt;/h3&gt; &#xA;&lt;p&gt;MessageBox expects a HWND as first parameter, the second and third parameters are pointers to constant strings (messagebox text and title), the fourth parameter is a UINT (content and behaviour of the messagebox). The data structure will be the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct _USER32_LIB_INPUT_DATA {&#xA;&#xA;&#x9;LPCSTR&#x9;text;&#xA;&#x9;LPCSTR&#x9;title;&#xA;&#x9;HWND&#x9;hwnd;&#xA;&#x9;UINT&#x9;uType;&#xA;&#xA;} USER32_LIB_INPUT_DATA, * PUSER32_LIB_INPUT_DATA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;HWND and UINT are integers, writing them into the struct is as simple as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&amp;lt;snip&amp;gt;&#xA;&#xA;iData = (PUSER32_LIB_INPUT_DATA)LocalAlloc(LPTR, FIELD_OFFSET(USER32_LIB_INPUT_DATA, uType) + sizeof(UINT)); // Allocate the struct&#xA;iData-&amp;gt;hwnd = inputHwnd;&#xA;iData-&amp;gt;uType = uType;&#xA;&#xA;&amp;lt;snip&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The LPCSTR parameters are pointers to constant strings in the remote process. So the strings are first written into the target process, then the related addresses will be written into the struct like this (lpTextAllocation and lpCaptionAllocation are the returning values of previous calls to VirtualAllocEx):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&amp;lt;snip&amp;gt;&#xA;&#xA;iData-&amp;gt;text = (LPCSTR)lpTextAllocation;&#xA;iData-&amp;gt;title = (LPCSTR)lpCaptionAllocation;&#xA;&#xA;&amp;lt;snip&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result will be a data structure that has to be written into the remote process. The address of this structure will be passed to the LPVOID lpParameter parameter of CreateRemoteThread.&lt;/p&gt; &#xA;&lt;h3&gt;Creating a __stdcall instruction set before the function call&lt;/h3&gt; &#xA;&lt;p&gt;The remote thread first has to execute instructions that populate the right registers with the right values from the previously written struct. So the program copies the instructions set generated by the function below into the remote process. This will be the &#39;LPTHREAD_START_ROUTINE lpStartAddress&#39; parameter of CreateRemoteThread.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&amp;lt;snip&amp;gt;&#xA;&#xA;DWORD WINAPI U32MessageBoxGenerateFunctionInstructions(PUSER32_LIB_DATA lpParameter)&#xA;{&#xA;&#x9;lpParameter-&amp;gt;output.outputStatus = ((PMESSAGEBOXA)0x4141414141414141)(lpParameter-&amp;gt;input.hwnd, lpParameter-&amp;gt;input.text, lpParameter-&amp;gt;input.title, lpParameter-&amp;gt;input.uType);&#xA;&#x9;return STATUS_SUCCESS;&#xA;}&#xA;DWORD U32MessageBoxGenerateFunctionInstructions_End()&#xA;{&#xA;&#x9;return 0; &#xA;}&#xA;&#xA;&amp;lt;snip&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;MessageBoxA is manually declared as WINAPI (&#39;#define __stdcall&#39;). 0x4141414141414141 is just a dummy value that will be swapped with the MessageBoxA address later in the code. This function will generate an instruction set which will properly populate registers to make a MessageBoxA call in accordance with the __stdcall calling convention. The result is the following:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/CreateRemoteThreadPlus/master/pictures/function_instruction_set.png&#34; alt=&#34;MessageBoxA instruction set&#34;&gt; &lt;strong&gt;Figure 3. MessageBoxA instruction set&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lem0nSec/CreateRemoteThreadPlus/master/pictures/payload_execution.png&#34; alt=&#34;Remote thread executes MessageBoxA&#34;&gt; &lt;strong&gt;Figure 4. Remote thread executes MessageBoxA&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://guidedhacking.com/threads/how-to-pass-multiple-arguments-with-createremotethread-to-injected-dll.15373/&#34;&gt;https://guidedhacking.com/threads/how-to-pass-multiple-arguments-with-createremotethread-to-injected-dll.15373/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/25354393/passing-multiple-parameters-using-createremotethread-in-c-sharp&#34;&gt;https://stackoverflow.com/questions/25354393/passing-multiple-parameters-using-createremotethread-in-c-sharp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gentilkiwi/mimikatz&#34;&gt;https://github.com/gentilkiwi/mimikatz&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>otya128/winevdm</title>
    <updated>2023-01-22T01:31:19Z</updated>
    <id>tag:github.com,2023-01-22:/otya128/winevdm</id>
    <link href="https://github.com/otya128/winevdm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;16-bit Windows (Windows 1.x, 2.x, 3.0, 3.1, etc.) on 64-bit Windows&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;winevdm on 64-bit Windows&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/otya128/winevdm/master/screenshot.PNG&#34; alt=&#34;screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/otya128/winevdm/releases&#34;&gt;Download stable version&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ci.appveyor.com/project/otya128/winevdm/&#34;&gt;Download latest version (unstable)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;16-bit Windows (Windows 1.x, 2.x, 3.0, 3.1, etc.) on 64-bit Windows&lt;/p&gt; &#xA;&lt;p&gt;An altered version of winevdm (a 16-bit Windows emulator), ported to 64-bit Windows.&lt;/p&gt; &#xA;&lt;h1&gt;How to run&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you get an error that VCRUNTIME140.dll is missing, install &lt;a href=&#34;https://aka.ms/vs/15/release/vc_redist.x86.exe&#34;&gt;Microsoft Visual C++ Redistributable for Visual Studio 2017 (32-bit)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Drag and drop Win16 executable file to otvdm.exe or execute otvdmw.exe.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How to install&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download or compile&lt;/li&gt; &#xA; &lt;li&gt;Run &#34;install&#34; shortcut or right-click on install.inf and select &#34;Install&#34;&lt;/li&gt; &#xA; &lt;li&gt;You can execute Win16 binaries directly!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If the registry is initialized by Windows Update, perform the above procedure again.&lt;/p&gt; &#xA;&lt;p&gt;You can uninstall it by running uninstall.reg.&lt;/p&gt; &#xA;&lt;h1&gt;Configuration&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/otya128/winevdm/master/otvdm.ini&#34;&gt;otvdm.ini&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;How to compile(Visual Studio)&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install Visual Studio 2017&lt;/li&gt; &#xA; &lt;li&gt;Edit PropertySheet.props&lt;/li&gt; &#xA; &lt;li&gt;Compile&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How to compile(cmake)&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/otya128/winevdm.git&#xA;cd winevdm&#xA;mkdir build&#xA;cd build&#xA;cmake ..&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;How does it work?&lt;/h1&gt; &#xA;&lt;p&gt;This program contains the following items&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CPU Emulator &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;64-bit Windows cannot modify LDT(NtSetInformationProcess(,ProcessLdtInformation,,) always returns error)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;wine based Win16-&amp;gt;Win32 conversion codes: &lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;BOOL16 WINAPI DestroyWindow16( HWND16 hwnd )&#xA;{&#xA;    return DestroyWindow( WIN_Handle32(hwnd) );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; Relay routines from 16-bit to 32-bit are autogenerated by convspec &lt;pre&gt;&lt;code class=&#34;language-spec&#34;&gt;53  pascal -ret16 DestroyWindow(word) DestroyWindow16&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;DOS emulation for Win16&lt;/li&gt; &#xA; &lt;li&gt;16-bit &amp;lt;=&amp;gt; native HANDLE conversion&lt;/li&gt; &#xA; &lt;li&gt;Fix compatibility problems, fix compatibility problems&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;install.inf&lt;/h2&gt; &#xA;&lt;p&gt;When 64-bit Windows detects a 16-bit installer, it has a mechanism to start an alternative installer which is not 16-bit. This program uses it.&lt;/p&gt; &#xA;&lt;h2&gt;WINDOWS directory redirection&lt;/h2&gt; &#xA;&lt;p&gt;Some Win16 programs try to save their settings in %WINDIR%&amp;lt;filename&amp;gt;.ini&lt;/p&gt; &#xA;&lt;p&gt;In recent Windows, it is not allowed to save to %WINDIR%, so it redirects.&lt;/p&gt; &#xA;&lt;h1&gt;winevdm&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;winevdm.exe [--app-name app.exe] command line&#xA;winevdm.exe CALC.EXE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can also run DOS executables (DOS emulator-like). You can set the DOS version with the VDMDOSVER environment variable.&lt;/p&gt; &#xA;&lt;p&gt;DOS emulation is incomplete and it is recommended to use DOSBox or &lt;a href=&#34;http://takeda-toshiya.my.coocan.jp/msdos/&#34;&gt;MS-DOS Player&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>n64decomp/sm64</title>
    <updated>2023-01-22T01:31:19Z</updated>
    <id>tag:github.com,2023-01-22:/n64decomp/sm64</id>
    <link href="https://github.com/n64decomp/sm64" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Super Mario 64 decompilation, brought to you by a bunch of clever folks.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Super Mario 64&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This repo contains a full decompilation of Super Mario 64 (J), (U), (E), and (SH).&lt;/li&gt; &#xA; &lt;li&gt;Naming and documentation of the source code and data structures are in progress.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It builds the following ROMs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;sm64.jp.z64 &lt;code&gt;sha1: 8a20a5c83d6ceb0f0506cfc9fa20d8f438cafe51&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;sm64.us.z64 &lt;code&gt;sha1: 9bef1128717f958171a4afac3ed78ee2bb4e86ce&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;sm64.eu.z64 &lt;code&gt;sha1: 4ac5721683d0e0b6bbb561b58a71740845dceea9&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;sm64.sh.z64 &lt;code&gt;sha1: 3f319ae697533a255a1003d09202379d78d5a2e0&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This repo does not include all assets necessary for compiling the ROMs. A prior copy of the game is required to extract the assets.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Start (for Ubuntu)&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install prerequisites: &lt;code&gt;sudo apt install -y build-essential git binutils-mips-linux-gnu python3&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Clone the repo from within Linux: &lt;code&gt;git clone https://github.com/n64decomp/sm64.git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Place a Super Mario 64 ROM called &lt;code&gt;baserom.&amp;lt;VERSION&amp;gt;.z64&lt;/code&gt; into the project folder for asset extraction, where &lt;code&gt;VERSION&lt;/code&gt; can be &lt;code&gt;us&lt;/code&gt;, &lt;code&gt;jp&lt;/code&gt;, &lt;code&gt;eu&lt;/code&gt;, or &lt;code&gt;sh&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;make&lt;/code&gt; to build. Qualify the version through &lt;code&gt;make VERSION=&amp;lt;VERSION&amp;gt;&lt;/code&gt;. Add &lt;code&gt;-j4&lt;/code&gt; to improve build speed (hardware dependent).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Ensure the repo path length does not exceed 255 characters. Long path names result in build errors.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;p&gt;Install WSL and a distro of your choice following &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/wsl/install-win10&#34;&gt;Windows Subsystem for Linux Installation Guide for Windows 10.&lt;/a&gt; We recommend either Debian or Ubuntu 18.04 Linux distributions under WSL. Note: WSL1 does not currently support Ubuntu 20.04.&lt;/p&gt; &#xA;&lt;p&gt;Next, clone the SM64 repo from within the Linux shell: &lt;code&gt;git clone https://github.com/n64decomp/sm64.git&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then continue following the directions in the &lt;a href=&#34;https://raw.githubusercontent.com/n64decomp/sm64/master/#linux&#34;&gt;Linux&lt;/a&gt; installation section below.&lt;/p&gt; &#xA;&lt;h3&gt;Linux&lt;/h3&gt; &#xA;&lt;p&gt;There are 3 steps to set up a working build.&lt;/p&gt; &#xA;&lt;h4&gt;Step 1: Install dependencies&lt;/h4&gt; &#xA;&lt;p&gt;The build system has the following package requirements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;binutils-mips&lt;/li&gt; &#xA; &lt;li&gt;capstone&lt;/li&gt; &#xA; &lt;li&gt;pkgconf&lt;/li&gt; &#xA; &lt;li&gt;python3 &amp;gt;= 3.6&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Dependency installation instructions for common Linux distros are provided below:&lt;/p&gt; &#xA;&lt;h5&gt;Debian / Ubuntu&lt;/h5&gt; &#xA;&lt;p&gt;To install build dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install -y binutils-mips-linux-gnu build-essential git libcapstone-dev pkgconf python3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Arch Linux&lt;/h5&gt; &#xA;&lt;p&gt;To install build dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo pacman -S base-devel capstone python&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install the following AUR packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://aur.archlinux.org/packages/mips64-elf-binutils&#34;&gt;mips64-elf-binutils&lt;/a&gt; (AUR)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Other Linux distributions&lt;/h5&gt; &#xA;&lt;p&gt;Most modern Linux distributions should have equivalent packages to the other two listed above. You may have to use a different version of GNU binutils. Listed below are fully compatible binutils distributions with support in the makefile, and examples of distros that offer them:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;mips64-elf-&lt;/code&gt; (Arch AUR)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mips-linux-gnu-&lt;/code&gt; (Ubuntu and other Debian-based distros)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mips64-linux-gnu-&lt;/code&gt; (RHEL/CentOS/Fedora)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You may also use &lt;a href=&#34;https://raw.githubusercontent.com/n64decomp/sm64/master/#docker-installation&#34;&gt;Docker&lt;/a&gt; to handle installing an image with minimal dependencies.&lt;/p&gt; &#xA;&lt;h4&gt;Step 2: Copy baserom(s) for asset extraction&lt;/h4&gt; &#xA;&lt;p&gt;For each version (jp/us/eu/sh) for which you want to build a ROM, put an existing ROM at &lt;code&gt;./baserom.&amp;lt;VERSION&amp;gt;.z64&lt;/code&gt; for asset extraction.&lt;/p&gt; &#xA;&lt;h5&gt;Step 3: Build the ROM&lt;/h5&gt; &#xA;&lt;p&gt;Run &lt;code&gt;make&lt;/code&gt; to build the ROM (defaults to &lt;code&gt;VERSION=us&lt;/code&gt;). Other examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make VERSION=jp -j4       # build (J) version instead with 4 jobs&#xA;make VERSION=eu COMPARE=0 # build (EU) version but do not compare ROM hashes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Resulting artifacts can be found in the &lt;code&gt;build&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;The full list of configurable variables are listed below, with the default being the first listed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;VERSION&lt;/code&gt;: &lt;code&gt;us&lt;/code&gt;, &lt;code&gt;jp&lt;/code&gt;, &lt;code&gt;eu&lt;/code&gt;, &lt;code&gt;sh&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GRUCODE&lt;/code&gt;: &lt;code&gt;f3d_old&lt;/code&gt;, &lt;code&gt;f3d_new&lt;/code&gt;, &lt;code&gt;f3dex&lt;/code&gt;, &lt;code&gt;f3dex2&lt;/code&gt;, &lt;code&gt;f3dzex&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;COMPARE&lt;/code&gt;: &lt;code&gt;1&lt;/code&gt; (compare ROM hash), &lt;code&gt;0&lt;/code&gt; (do not compare ROM hash)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NON_MATCHING&lt;/code&gt;: Use functionally equivalent C implementations for non-matchings (Currently there aren&#39;t any non-matchings, but this will apply to iQue). Also will avoid instances of undefined behavior.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CROSS&lt;/code&gt;: Cross-compiler tool prefix (Example: &lt;code&gt;mips64-elf-&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;macOS&lt;/h3&gt; &#xA;&lt;p&gt;With macOS, you may either use Homebrew or &lt;a href=&#34;https://raw.githubusercontent.com/n64decomp/sm64/master/#docker-installation&#34;&gt;Docker&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Homebrew&lt;/h4&gt; &#xA;&lt;h4&gt;Step 1: Install dependencies&lt;/h4&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://brew.sh&#34;&gt;Homebrew&lt;/a&gt; and the following dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;brew update&#xA;brew install capstone coreutils make pkg-config tehzz/n64-dev/mips64-elf-binutils&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Step 2: Copy baserom(s) for asset extraction&lt;/h4&gt; &#xA;&lt;p&gt;For each version (jp/us/eu/sh) for which you want to build a ROM, put an existing ROM at &lt;code&gt;./baserom.&amp;lt;VERSION&amp;gt;.z64&lt;/code&gt; for asset extraction.&lt;/p&gt; &#xA;&lt;h5&gt;Step 3: Build the ROM&lt;/h5&gt; &#xA;&lt;p&gt;Use Homebrew&#39;s GNU make because the version included with macOS is too old.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gmake VERSION=jp -j4       # build (J) version instead with 4 jobs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Docker Installation&lt;/h3&gt; &#xA;&lt;h4&gt;Create Docker image&lt;/h4&gt; &#xA;&lt;p&gt;After installing and starting Docker, create the docker image. This only needs to be done once.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker build -t sm64 .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Build&lt;/h4&gt; &#xA;&lt;p&gt;To build, mount the local filesystem into the Docker container and build the ROM with &lt;code&gt;docker run sm64 make&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;macOS example for (U):&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run --rm --mount type=bind,source=&#34;$(pwd)&#34;,destination=/sm64 sm64 make VERSION=us -j4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Linux example for (U):&lt;/h5&gt; &#xA;&lt;p&gt;For a Linux host, Docker needs to be instructed which user should own the output files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run --rm --mount type=bind,source=&#34;$(pwd)&#34;,destination=/sm64 --user $UID:$GID sm64 make VERSION=us -j4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Resulting artifacts can be found in the &lt;code&gt;build&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Project Structure&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;sm64&#xA;├── actors: object behaviors, geo layout, and display lists&#xA;├── asm: handwritten assembly code, rom header&#xA;│   └── non_matchings: asm for non-matching sections&#xA;├── assets: animation and demo data&#xA;│   ├── anims: animation data&#xA;│   └── demos: demo data&#xA;├── bin: C files for ordering display lists and textures&#xA;├── build: output directory&#xA;├── data: behavior scripts, misc. data&#xA;├── doxygen: documentation infrastructure&#xA;├── enhancements: example source modifications&#xA;├── include: header files&#xA;├── levels: level scripts, geo layout, and display lists&#xA;├── lib: SDK library code&#xA;├── rsp: audio and Fast3D RSP assembly code&#xA;├── sound: sequences, sound samples, and sound banks&#xA;├── src: C source code for game&#xA;│   ├── audio: audio code&#xA;│   ├── buffers: stacks, heaps, and task buffers&#xA;│   ├── engine: script processing engines and utils&#xA;│   ├── game: behaviors and rest of game source&#xA;│   ├── goddard: Mario intro screen&#xA;│   └── menu: title screen and file, act, and debug level selection menus&#xA;├── text: dialog, level names, act names&#xA;├── textures: skybox and generic texture data&#xA;└── tools: build tools&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;clang-format&lt;/code&gt; on your code to ensure it meets the project&#39;s coding standards.&lt;/p&gt; &#xA;&lt;p&gt;Official Discord: &lt;a href=&#34;https://discord.gg/DuYH3Fh&#34;&gt;discord.gg/DuYH3Fh&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>