<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-12T01:29:13Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zherczeg/sljit</title>
    <updated>2024-07-12T01:29:13Z</updated>
    <id>tag:github.com,2024-07-12:/zherczeg/sljit</id>
    <link href="https://github.com/zherczeg/sljit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Platform independent low-level JIT compiler&lt;/p&gt;&lt;hr&gt;&lt;pre&gt;&lt;code&gt;                 SLJIT - Stack Less JIT Compiler&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Purpose: A low-level, machine independent JIT compiler, which is suitable for translating interpreted byte code into machine code. The sljitLir.h describes the LIR (low-level intermediate representation) of SLJIT.&lt;/p&gt; &#xA;&lt;p&gt;Key features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports several target architectures: x86 32/64, ARM 32/64, RiscV 32/64, s390x 64, PowerPC 32/64, LoongArch 64, MIPS 32/64&lt;/li&gt; &#xA; &lt;li&gt;Supports a large number of operations &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Supports self-modifying code&lt;/li&gt; &#xA;   &lt;li&gt;Supports tail calls&lt;/li&gt; &#xA;   &lt;li&gt;Support fast calls (non-ABI compatible)&lt;/li&gt; &#xA;   &lt;li&gt;Supports byte order reverse (endianness switching)&lt;/li&gt; &#xA;   &lt;li&gt;Supports unaligned memory accesses&lt;/li&gt; &#xA;   &lt;li&gt;Supports SIMD / atomic operations on certain CPUs&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Direct register access, both integer and floating point&lt;/li&gt; &#xA; &lt;li&gt;Stack space allocated for function local variables can be accessed as a linear memory area&lt;/li&gt; &#xA; &lt;li&gt;All-in-one compilation is supported&lt;/li&gt; &#xA; &lt;li&gt;When sljitLir.c is directly included by a C source file, the jit compiler API can be completely hidden from external use (see SLJIT_CONFIG_STATIC macro) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Code can be generated for multiple target cpus by including sljitLir.c in different C files, where each compiler instance is configured to target a different architecture&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The compiler can be serialized into a byte buffer &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Useful for ahead-of-time compiling&lt;/li&gt; &#xA;   &lt;li&gt;Code generation can be resumed after deserialization (partial ahead-of-time compiling)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Compatible: C99 (C++) compilers.&lt;/p&gt; &#xA;&lt;p&gt;Using sljit: Copy the content of sljit_src directory into your project source directory. Add sljitLir.c source file to your build environment. All other files are included by sljitLir.c (if required). Define the machine by SLJIT_CONFIG_* selector. See sljitConfigCPU.h for all possible values. For C++ compilers, rename sljitLir.c to sljitLir.cpp.&lt;/p&gt; &#xA;&lt;p&gt;More info: &lt;a href=&#34;https://zherczeg.github.io/sljit/&#34;&gt;https://zherczeg.github.io/sljit/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Contact: &lt;a href=&#34;mailto:hzmester@freemail.hu&#34;&gt;hzmester@freemail.hu&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Special thanks: Alexander Nasonov Carlo Marcelo Arenas Belón Christian Persch Daniel Richard G. Giuseppe D&#39;Angelo H.J. Lu James Cowgill Jason Hood Jiong Wang (TileGX support) Marc Mutz Martin Storsjö Michael McConville Mingtao Zhou (LoongArch support) Walter Lee Wen Xichang YunQiang Su&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>yarrick/iodine</title>
    <updated>2024-07-12T01:29:13Z</updated>
    <id>tag:github.com,2024-07-12:/yarrick/iodine</id>
    <link href="https://github.com/yarrick/iodine" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Official git repo for iodine dns tunnel&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;iodine - &lt;a href=&#34;https://code.kryo.se/iodine&#34;&gt;https://code.kryo.se/iodine&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;This is a piece of software that lets you tunnel IPv4 data through a DNS server. This can be usable in different situations where internet access is firewalled, but DNS queries are allowed.&lt;/p&gt; &#xA;&lt;h2&gt;COMPILING&lt;/h2&gt; &#xA;&lt;p&gt;Iodine has no configure script. There are two optional features for Linux (SELinux and systemd support) that will be enabled automatically if the relevant header files are found in &lt;code&gt;/usr/include&lt;/code&gt;. (See script at &lt;code&gt;./src/osflags&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;make&lt;/code&gt; to compile the server and client binaries. Run &lt;code&gt;make install&lt;/code&gt; to copy binaries and manpage to the destination directory. Run &lt;code&gt;make test&lt;/code&gt; to compile and run the unit tests. (Requires the &lt;code&gt;check&lt;/code&gt; library)&lt;/p&gt; &#xA;&lt;h2&gt;QUICKSTART&lt;/h2&gt; &#xA;&lt;p&gt;Try it out within your own LAN! Follow these simple steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;On your server, run: &lt;code&gt;./iodined -f 10.0.0.1 test.com&lt;/code&gt;. If you already use the &lt;code&gt;10.0.0.0&lt;/code&gt; network, use another internal net like &lt;code&gt;172.16.0.0&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Enter a password.&lt;/li&gt; &#xA; &lt;li&gt;On the client, run: &lt;code&gt;./iodine -f -r 192.168.0.1 test.com&lt;/code&gt;. Replace &lt;code&gt;192.168.0.1&lt;/code&gt; with your server&#39;s ip address.&lt;/li&gt; &#xA; &lt;li&gt;Enter the same password.&lt;/li&gt; &#xA; &lt;li&gt;Now the client has the tunnel ip &lt;code&gt;10.0.0.2&lt;/code&gt; and the server has &lt;code&gt;10.0.0.1&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Try pinging each other through the tunnel.&lt;/li&gt; &#xA; &lt;li&gt;Done! :)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To actually use it through a relaying nameserver, see below.&lt;/p&gt; &#xA;&lt;h2&gt;HOW TO USE&lt;/h2&gt; &#xA;&lt;p&gt;Note: server and client are required to speak the exact same protocol. In most cases, this means running the same iodine version. Unfortunately, implementing backward and forward protocol compatibility is usually not feasible.&lt;/p&gt; &#xA;&lt;h3&gt;Server side&lt;/h3&gt; &#xA;&lt;p&gt;To use this tunnel, you need control over a real domain (like &lt;code&gt;mydomain.com&lt;/code&gt;), and a server with a public IP address to run &lt;code&gt;iodined&lt;/code&gt; on. If this server already runs a DNS program, change its listening port and then use &lt;code&gt;iodined&lt;/code&gt;&#39;s &lt;code&gt;-b&lt;/code&gt; option to let &lt;code&gt;iodined&lt;/code&gt; forward the DNS requests. (Note that this procedure is not advised in production environments, because &lt;code&gt;iodined&lt;/code&gt;&#39;s DNS forwarding is not completely transparent, for example zone transfers will not work.) Alternatively you can forward the subdomain from your DNS server to &lt;code&gt;iodined&lt;/code&gt; which must then run on a different port (&lt;code&gt;-p&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Then, delegate a subdomain (say, &lt;code&gt;t1.mydomain.com&lt;/code&gt;) to the iodined server. If you use BIND for your domain, add two lines like these to the zone file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;t1&#x9;&#x9;IN&#x9;NS&#x9;t1ns.mydomain.com.&#x9;&#x9;; note the dot!&#xA;t1ns&#x9;&#x9;IN&#x9;A&#x9;10.15.213.99&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;NS&lt;/code&gt; line is all that&#39;s needed to route queries for the &lt;code&gt;t1&lt;/code&gt; subdomain to the &lt;code&gt;t1ns&lt;/code&gt; server. We use a short name for the subdomain, to keep as much space as possible available for the data traffic. At the end of the &lt;code&gt;NS&lt;/code&gt; line is the name of your &lt;code&gt;iodined&lt;/code&gt; server. This can be any name, pointing anywhere, but in this case it&#39;s easily kept in the same zone file. It must be a name (not an IP address), and that name itself must have an &lt;code&gt;A&lt;/code&gt; record (not a &lt;code&gt;CNAME&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If your &lt;code&gt;iodined&lt;/code&gt; server has a dynamic IP, use a dynamic DNS provider. Simply point the &lt;code&gt;NS&lt;/code&gt; line to it, and leave the &lt;code&gt;A&lt;/code&gt; line out:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;t1&#x9;&#x9;IN&#x9;NS&#x9;myname.mydyndnsprovider.com.&#x9;; note the dot!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then reload or restart your nameserver program. Now any DNS queries for domains ending in &lt;code&gt;t1.mydomain.com&lt;/code&gt; will be sent to your &lt;code&gt;iodined&lt;/code&gt; server.&lt;/p&gt; &#xA;&lt;p&gt;Finally start &lt;code&gt;iodined&lt;/code&gt; on your server. The first argument is the IP address inside the tunnel, which can be from any range that you don&#39;t use yet (for example &lt;code&gt;192.168.99.1&lt;/code&gt;), and the second argument is the assigned domain (in this case &lt;code&gt;t1.mydomain.com&lt;/code&gt;). Using the &lt;code&gt;-f&lt;/code&gt; option will keep iodined running in the foreground, which helps when testing. iodined will open a virtual interface (&#34;tun device&#34;), and will also start listening for DNS queries on UDP port 53. Either enter a password on the commandline (&lt;code&gt;-P pass&lt;/code&gt;) or after the server has started. Now everything is ready for the client.&lt;/p&gt; &#xA;&lt;p&gt;If there is a chance you&#39;ll be using an iodine tunnel from unexpected environments, start &lt;code&gt;iodined&lt;/code&gt; with a &lt;code&gt;-c&lt;/code&gt; option. Resulting commandline in this example situation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./iodined -f -c -P secretpassword 192.168.99.1 t1.mydomain.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Client side&lt;/h3&gt; &#xA;&lt;p&gt;All the setup is done, just start &lt;code&gt;iodine&lt;/code&gt;. It takes one or two arguments, the first is the local relaying DNS server (optional) and the second is the domain you used (&lt;code&gt;t1.mydomain.com&lt;/code&gt;). If you don&#39;t specify the first argument, the system&#39;s current DNS setting will be consulted.&lt;/p&gt; &#xA;&lt;p&gt;If DNS queries are allowed to any computer, you can directly give the &lt;code&gt;iodined&lt;/code&gt; server&#39;s address as first argument (in the example: &lt;code&gt;t1ns.mydomain.com&lt;/code&gt; or &lt;code&gt;10.15.213.99&lt;/code&gt;). In that case, it may also happen that &lt;em&gt;any&lt;/em&gt; traffic is allowed to the DNS port (53 UDP) of any computer. Iodine will detect this, and switch to raw UDP tunneling if possible. To force DNS tunneling in any case, use the &lt;code&gt;-r&lt;/code&gt; option (especially useful when testing within your own network).&lt;/p&gt; &#xA;&lt;p&gt;The client&#39;s tunnel interface will get an IP close to the server&#39;s (in this case &lt;code&gt;192.168.99.2&lt;/code&gt; or &lt;code&gt;.3&lt;/code&gt; etc.) and a suitable MTU. Enter the same password as on the server either as commandline option or after the client has started. Using the &lt;code&gt;-f&lt;/code&gt; option will keep the iodine client running in the foreground.&lt;/p&gt; &#xA;&lt;p&gt;Resulting commandline in this example situation, adding -r forces DNS tunneling even if raw UDP tunneling would be possible:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./iodine -f -P secretpassword t1.mydomain.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From either side, you should now be able to ping the IP address on the other end of the tunnel. In this case, &lt;code&gt;ping 192.168.99.1&lt;/code&gt; from the iodine client, and &lt;code&gt;192.168.99.2&lt;/code&gt; from the iodine server.&lt;/p&gt; &#xA;&lt;h3&gt;MISC. INFO&lt;/h3&gt; &#xA;&lt;h4&gt;IPv6&lt;/h4&gt; &#xA;&lt;p&gt;The data inside the tunnel is IPv4 only.&lt;/p&gt; &#xA;&lt;p&gt;The server listens to both IPv4 and IPv6 for incoming requests by default. Use options &lt;code&gt;-4&lt;/code&gt; or &lt;code&gt;-6&lt;/code&gt; to only listen on one protocol. Raw mode will be attempted on the same protocol as used for the login.&lt;/p&gt; &#xA;&lt;p&gt;The client can use IPv4 or IPv6 nameservers to connect to iodined. The relay nameservers will translate between protocols automatically if needed. Use options &lt;code&gt;-4&lt;/code&gt; or &lt;code&gt;-6&lt;/code&gt; to force the client to use a specific IP version for its DNS queries.&lt;/p&gt; &#xA;&lt;p&gt;If your server is listening on IPv6 and is reachable, add an AAAA record for it to your DNS setup. Extending the example above would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;t1&#x9;&#x9;IN&#x9;NS&#x9;t1ns.mydomain.com.&#x9;&#x9;; note the dot!&#xA;t1ns&#x9;&#x9;IN&#x9;A&#x9;10.15.213.99&#xA;t1ns&#x9;&#x9;IN&#x9;AAAA&#x9;2001:db8::1001:99&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Routing&lt;/h4&gt; &#xA;&lt;p&gt;It is possible to route all traffic through the DNS tunnel. To do this, first add a host route to the nameserver used by iodine over the wired/wireless interface with the default gateway as gateway. Then replace the default gateway with the iodined server&#39;s IP address inside the DNS tunnel, and configure the server to do NAT.&lt;/p&gt; &#xA;&lt;p&gt;However, note that the tunneled data traffic is not encrypted at all, and can be read and changed by external parties relatively easily. For maximum security, run a VPN through the DNS tunnel (=double tunneling), or use secure shell (SSH) access, possibly with port forwarding. The latter can also be used for web browsing, when you run a web proxy (for example Privoxy) on your server.&lt;/p&gt; &#xA;&lt;h4&gt;Testing&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;iodined&lt;/code&gt; server replies to &lt;code&gt;NS&lt;/code&gt; requests sent for subdomains of the tunnel domain. If your iodined subdomain is &lt;code&gt;t1.mydomain.com&lt;/code&gt;, send a &lt;code&gt;NS&lt;/code&gt; request for &lt;code&gt;foo123.t1.mydomain.com&lt;/code&gt; to see if the delegation works. &lt;code&gt;dig&lt;/code&gt; is a good tool for this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% dig -t NS foo123.t1.mydomain.com&#xA;ns.io.citronna.de.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, the iodined server will answer requests starting with &#39;z&#39; for any of the supported request types, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;dig -t TXT z456.t1.mydomain.com&#xA;dig -t SRV z456.t1.mydomain.com&#xA;dig -t CNAME z456.t1.mydomain.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reply should look like garbled text in all these cases.&lt;/p&gt; &#xA;&lt;h4&gt;Mac OS X&lt;/h4&gt; &#xA;&lt;p&gt;On Mac OS X 10.6 and later, iodine supports the native utun devices built into the OS - use &lt;code&gt;-d utunX&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Operational info&lt;/h2&gt; &#xA;&lt;p&gt;The DNS-response fragment size is normally autoprobed to get maximum bandwidth. To force a specific value (and speed things up), use the &lt;code&gt;-m&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;p&gt;The DNS hostnames are normally used up to their maximum length, 255 characters. Some DNS relays have been found that answer full-length queries rather unreliably, giving widely varying (and mostly very bad) results of the fragment size autoprobe on repeated tries. In these cases, use the &lt;code&gt;-M&lt;/code&gt; switch to reduce the DNS hostname length to, for example 200 characters, which makes these DNS relays much more stable. This is also useful on some “de-optimizing” DNS relays that stuff the response with two full copies of the query, leaving very little space for downstream data (also not capable of EDNS0). The &lt;code&gt;-M&lt;/code&gt; switch can trade some upstream bandwidth for downstream bandwidth. Note that the minimum &lt;code&gt;-M&lt;/code&gt; value is about 100, since the protocol can split packets (1200 bytes max) in only 16 fragments, requiring at least 75 real data bytes per fragment.&lt;/p&gt; &#xA;&lt;p&gt;The upstream data is sent gzipped encoded with Base32; or Base64 if the relay server supports mixed case and &lt;code&gt;+&lt;/code&gt; in domain names; or Base64u if &lt;code&gt;_&lt;/code&gt; is supported instead; or Base128 if high-byte-value characters are supported. This upstream encoding is autodetected. The DNS protocol allows one query per packet, and one query can be max 256 chars. Each domain name part can be max 63 chars. So your domain name and subdomain should be as short as possible to allow maximum upstream throughput.&lt;/p&gt; &#xA;&lt;p&gt;Several DNS request types are supported, with the &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;PRIVATE&lt;/code&gt; types expected to provide the largest downstream bandwidth. The &lt;code&gt;PRIVATE&lt;/code&gt; type uses value 65399 in the private-use range. Other available types are &lt;code&gt;TXT&lt;/code&gt;, &lt;code&gt;SRV&lt;/code&gt;, &lt;code&gt;MX&lt;/code&gt;, &lt;code&gt;CNAME&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; (returning &lt;code&gt;CNAME&lt;/code&gt;), in decreasing bandwidth order. Normally the “best” request type is autodetected and used. However, DNS relays may impose limits on for example NULL and TXT, making SRV or MX actually the best choice. This is not autodetected, but can be forced using the &lt;code&gt;-T&lt;/code&gt; option. It is advisable to try various alternatives especially when the autodetected request type provides a downstream fragment size of less than 200 bytes.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;SRV&lt;/code&gt;, &lt;code&gt;MX&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; (returning &lt;code&gt;CNAME&lt;/code&gt;) queries may/will cause additional lookups by &#34;smart&#34; caching nameservers to get an actual IP address, which may either slow down or fail completely.&lt;/p&gt; &#xA;&lt;p&gt;DNS responses for non-&lt;code&gt;NULL/PRIVATE&lt;/code&gt; queries can be encoded with the same set of codecs as upstream data. This is normally also autodetected, but no fully exhaustive tests are done, so some problems may not be noticed when selecting more advanced codecs. In that case, you&#39;ll see failures/corruption in the fragment size autoprobe. In particular, several DNS relays have been found that change replies returning hostnames (&lt;code&gt;SRV&lt;/code&gt;, &lt;code&gt;MX&lt;/code&gt;, &lt;code&gt;CNAME&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;) to lowercase only when that hostname exceeds ca. 180 characters. In these and similar cases, use the &lt;code&gt;-O&lt;/code&gt; option to try other downstream codecs; Base32 should always work.&lt;/p&gt; &#xA;&lt;p&gt;Normal operation now is for the server to &lt;em&gt;not&lt;/em&gt; answer a DNS request until the next DNS request has come in, a.k.a. being “lazy”. This way, the server will always have a DNS request handy when new downstream data has to be sent. This greatly improves (interactive) performance and latency, and allows to slow down the quiescent ping requests to 4 second intervals by default, and possibly much slower. In fact, the main purpose of the pings now is to force a reply to the previous ping, and prevent DNS server timeouts (usually at least 5-10 seconds per RFC1035). Some DNS servers are more impatient and will give SERVFAIL errors (timeouts) in periods without tunneled data traffic. All data should still get through in these cases, but &lt;code&gt;iodine&lt;/code&gt; will reduce the ping interval to 1 second anyway (-I1) to reduce the number of error messages. This may not help for very impatient DNS relays like &lt;code&gt;dnsadvantage.com&lt;/code&gt; (ultradns), which time out in 1 second or even less. Yet data will still get trough, and you can ignore the &lt;code&gt;SERVFAIL&lt;/code&gt; errors.&lt;/p&gt; &#xA;&lt;p&gt;If you are running on a local network without any DNS server in-between, try &lt;code&gt;-I 50&lt;/code&gt; (iodine and iodined close the connection after 60 seconds of silence). The only time you&#39;ll notice a slowdown, is when DNS reply packets go missing; the &lt;code&gt;iodined&lt;/code&gt; server then has to wait for a new ping to re-send the data. You can speed this up by generating some upstream traffic (keypress, ping). If this happens often, check your network for bottlenecks and/or run with &lt;code&gt;-I1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The delayed answering in lazy mode will cause some “carrier grade” commercial DNS relays to repeatedly re-send the same DNS query to the iodined server. If the DNS relay is actually implemented as a pool of parallel servers, duplicate requests may even arrive from multiple sources. This effect will only be visible in the network traffic at the &lt;code&gt;iodined&lt;/code&gt; server, and will not affect the client&#39;s connection. Iodined will notice these duplicates, and send the same answer (when its time has come) to both the original query and the latest duplicate. After that, the full answer is cached for a short while. Delayed duplicates that arrive at the server even later, get a reply that the iodine client will ignore (if it ever arrives there).&lt;/p&gt; &#xA;&lt;p&gt;If you have problems, try inspecting the traffic with network monitoring tools like tcpdump or ethereal/wireshark, and make sure that the relaying DNS server has not cached the response. A cached error message could mean that you started the client before the server. The &lt;code&gt;-D&lt;/code&gt; (and &lt;code&gt;-DD&lt;/code&gt;) option on the server can also show received and sent queries.&lt;/p&gt; &#xA;&lt;h2&gt;TIPS &amp;amp; TRICKS&lt;/h2&gt; &#xA;&lt;p&gt;If your port 53 is taken on a specific interface by an application that does not use it, use &lt;code&gt;-p&lt;/code&gt; on iodined to specify an alternate port (like &lt;code&gt;-p 5353&lt;/code&gt;) and use for instance iptables (on Linux) to forward the traffic:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;iptables -t nat -A PREROUTING -i eth0 -p udp --dport 53 -j DNAT --to :5353&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Sent in by Tom Schouten)&lt;/p&gt; &#xA;&lt;p&gt;Iodined will reject data from clients that have not been active (data/pings) for more than 60 seconds. Similarly, iodine will exit when no downstream data has been received for 60 seconds. In case of a long network outage or similar, just restart iodine (re-login), possibly multiple times until you get your old IP address back. Once that&#39;s done, just wait a while, and you&#39;ll eventually see the tunneled TCP traffic continue to flow from where it left off before the outage.&lt;/p&gt; &#xA;&lt;p&gt;With the introduction of the downstream packet queue in the server, its memory usage has increased with several megabytes in the default configuration. For use in low-memory environments (e.g. running on your DSL router), you can decrease USERS and undefine OUTPACKETQ_LEN in user.h without any ill conse- quence, assuming at most one client will be connected at any time. A small DNSCACHE_LEN is still advised, preferably 2 or higher, however you can also undefine it to save a few more kilobytes.&lt;/p&gt; &#xA;&lt;p&gt;One iodine server can handle multiple domains. Set up different NS records on the same domain all pointing to the same host, and use a wildcard at the start of the topdomain argument (example &lt;code&gt;*.mydomain.com&lt;/code&gt;). iodine will accept tunnel traffic for all domains matching that pattern. The wildcard has to be at the start of the topdomain argument and be followed by a dot.&lt;/p&gt; &#xA;&lt;h2&gt;PERFORMANCE&lt;/h2&gt; &#xA;&lt;p&gt;This section tabulates some performance measurements. To view properly, use a fixed-width font like Courier.&lt;/p&gt; &#xA;&lt;p&gt;Measurements were done in protocol 00000502 in lazy mode; upstream encoding always Base128; &lt;code&gt;iodine -M255&lt;/code&gt;; &lt;code&gt;iodined -m1130&lt;/code&gt;. Network conditions were not extremely favorable; results are not benchmarks but a realistic indication of real-world performance that can be expected in similar situations.&lt;/p&gt; &#xA;&lt;p&gt;Upstream/downstream throughput was measured by &lt;code&gt;scp&lt;/code&gt;&#39;ing a file previously read from &lt;code&gt;/dev/urandom&lt;/code&gt; (i.e. incompressible), and measuring size with &lt;code&gt;ls -l ; sleep 30 ; ls -l&lt;/code&gt; on a separate non-tunneled connection. Given the large &lt;code&gt;scp&lt;/code&gt; block size of 16 kB, this gives a resolution of 4.3 kbit/s, which explains why some values are exactly equal. Ping round-trip times measured with &lt;code&gt;ping -c100&lt;/code&gt;, presented are average rtt and mean deviation (indicating spread around the average), in milliseconds.&lt;/p&gt; &#xA;&lt;h3&gt;Situation 1: &lt;code&gt;Laptop -&amp;gt; Wifi AP -&amp;gt; Home server -&amp;gt; DSL provider -&amp;gt; Datacenter&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt; iodine    DNS &#34;relay&#34;        bind9           DNS cache        iodined&#xA;&#xA;                        downstr.  upstream downstr.  ping-up       ping-down&#xA;                        fragsize   kbit/s   kbit/s  avg +/-mdev   avg +/-mdev&#xA;-----------------------------------------------------------------------------&#xA;&#xA;iodine -&amp;gt; Wifi AP :53&#xA;  -Tnull (= -Oraw)           982    43.6    131.0   28.0    4.6   26.8    3.4&#xA;&#xA;iodine -&amp;gt; Home server :53&#xA;  -Tnull (= -Oraw)          1174    48.0    305.8   26.6    5.0   26.9    8.4&#xA;&#xA;iodine -&amp;gt; DSL provider :53&#xA;  -Tnull (= -Oraw)          1174    56.7    367.0   20.6    3.1   21.2    4.4&#xA;  -Ttxt -Obase32             730    56.7    174.7*&#xA;  -Ttxt -Obase64             874    56.7    174.7&#xA;  -Ttxt -Obase128           1018    56.7    174.7&#xA;  -Ttxt -Oraw               1162    56.7    358.2&#xA;  -Tsrv -Obase128            910    56.7    174.7&#xA;  -Tcname -Obase32           151    56.7     43.6&#xA;  -Tcname -Obase128          212    56.7     52.4&#xA;&#xA;iodine -&amp;gt; DSL provider :53&#xA;  wired (no Wifi) -Tnull    1174    74.2    585.4   20.2    5.6   19.6    3.4&#xA;&#xA; [174.7* : these all have 2frag/packet]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Situation 2: &lt;code&gt;Laptop -&amp;gt; Wifi+vpn / wired -&amp;gt; Home server&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt; iodine                            iodined&#xA;&#xA;                        downstr.  upstream downstr.  ping-up       ping-down&#xA;                        fragsize   kbit/s   kbit/s  avg +/-mdev   avg +/-mdev&#xA;-----------------------------------------------------------------------------&#xA;&#xA;wifi + openvpn  -Tnull      1186   166.0   1022.3    6.3    1.3    6.6    1.6&#xA;&#xA;wired  -Tnull               1186   677.2   2464.1    1.3    0.2    1.3    0.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Notes&lt;/h3&gt; &#xA;&lt;p&gt;Performance is strongly coupled to low ping times, as iodine requires confirmation for every data fragment before moving on to the next. Allowing multiple fragments in-flight like TCP could possibly increase performance, but it would likely cause serious overload for the intermediary DNS servers. The current protocol scales performance with DNS responsivity, since the DNS servers are on average handling at most one DNS request per client.&lt;/p&gt; &#xA;&lt;h2&gt;PORTABILITY&lt;/h2&gt; &#xA;&lt;p&gt;iodine has been tested on Linux (arm, ia64, x86, AMD64 and SPARC64), FreeBSD (ia64, x86), OpenBSD (x86), NetBSD (x86), MacOS X (ppc and x86, with &lt;a href=&#34;http://tuntaposx.sourceforge.net/&#34;&gt;http://tuntaposx.sourceforge.net/&lt;/a&gt;). and Windows (with OpenVPN TAP32 driver, see win32 readme file). It should be easy to port to other unix-like systems that have TUN/TAP tunneling support. Let us know if you get it to run on other platforms.&lt;/p&gt; &#xA;&lt;h2&gt;THE NAME&lt;/h2&gt; &#xA;&lt;p&gt;The name iodine was chosen since it starts with IOD (IP Over DNS) and since iodine has atomic number 53, which happens to be the DNS port number.&lt;/p&gt; &#xA;&lt;h2&gt;THANKS&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To kuxien for FreeBSD and OS X testing&lt;/li&gt; &#xA; &lt;li&gt;To poplix for code audit&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;AUTHORS &amp;amp; LICENSE&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) 2006-2014 Erik Ekman &lt;a href=&#34;mailto:yarrick@kryo.se&#34;&gt;yarrick@kryo.se&lt;/a&gt;, 2006-2009 Bjorn Andersson &lt;a href=&#34;mailto:flex@kryo.se&#34;&gt;flex@kryo.se&lt;/a&gt;. Also major contributions by Anne Bezemer.&lt;/p&gt; &#xA;&lt;p&gt;Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.&lt;/p&gt; &#xA;&lt;p&gt;MD5 implementation by L. Peter Deutsch (license and source in &lt;code&gt;src/md5.[ch]&lt;/code&gt;) Copyright (C) 1999, 2000, 2002 Aladdin Enterprises. All rights reserved.&lt;/p&gt;</summary>
  </entry>
</feed>