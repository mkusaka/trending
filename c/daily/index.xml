<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-27T01:25:17Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>floesen/EventLogCrasher</title>
    <updated>2024-01-27T01:25:17Z</updated>
    <id>tag:github.com,2024-01-27:/floesen/EventLogCrasher</id>
    <link href="https://github.com/floesen/EventLogCrasher" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;EventLogCrasher&lt;/h1&gt; &#xA;&lt;p&gt;Proof of concept for a bug, that allows any user to crash the Windows Event Log service of any other Windows 10/Windows Server 2022 machine on the same domain. The crash occurs in &lt;code&gt;wevtsvc!VerifyUnicodeString&lt;/code&gt; when an attacker sends a malformed &lt;code&gt;UNICODE_STRING&lt;/code&gt; object to the &lt;code&gt;ElfrRegisterEventSourceW&lt;/code&gt; method exposed by the RPC-based EventLog Remoting Protocol.&lt;/p&gt; &#xA;&lt;h1&gt;Demo&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/floesen/EventLogCrasher/raw/main/demo.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/AFL</title>
    <updated>2024-01-27T01:25:17Z</updated>
    <id>tag:github.com,2024-01-27:/google/AFL</id>
    <link href="https://github.com/google/AFL" rel="alternate"></link>
    <summary type="html">&lt;p&gt;american fuzzy lop - a security-oriented fuzzer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;american fuzzy lop&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/google/AFL&#34;&gt;&lt;img src=&#34;https://travis-ci.org/google/AFL.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Originally developed by Michal Zalewski &lt;a href=&#34;mailto:lcamtuf@google.com&#34;&gt;lcamtuf@google.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/QuickStartGuide.txt&#34;&gt;QuickStartGuide.txt&lt;/a&gt; if you don&#39;t have time to read this file.&lt;/p&gt; &#xA;&lt;h2&gt;1) Challenges of guided fuzzing&lt;/h2&gt; &#xA;&lt;p&gt;Fuzzing is one of the most powerful and proven strategies for identifying security issues in real-world software; it is responsible for the vast majority of remote code execution and privilege escalation bugs found to date in security-critical software.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, fuzzing is also relatively shallow; blind, random mutations make it very unlikely to reach certain code paths in the tested code, leaving some vulnerabilities firmly outside the reach of this technique.&lt;/p&gt; &#xA;&lt;p&gt;There have been numerous attempts to solve this problem. One of the early approaches - pioneered by Tavis Ormandy - is corpus distillation. The method relies on coverage signals to select a subset of interesting seeds from a massive, high-quality corpus of candidate files, and then fuzz them by traditional means. The approach works exceptionally well, but requires such a corpus to be readily available. In addition, block coverage measurements provide only a very simplistic understanding of program state, and are less useful for guiding the fuzzing effort in the long haul.&lt;/p&gt; &#xA;&lt;p&gt;Other, more sophisticated research has focused on techniques such as program flow analysis (&#34;concolic execution&#34;), symbolic execution, or static analysis. All these methods are extremely promising in experimental settings, but tend to suffer from reliability and performance problems in practical uses - and currently do not offer a viable alternative to &#34;dumb&#34; fuzzing techniques.&lt;/p&gt; &#xA;&lt;h2&gt;2) The afl-fuzz approach&lt;/h2&gt; &#xA;&lt;p&gt;American Fuzzy Lop is a brute-force fuzzer coupled with an exceedingly simple but rock-solid instrumentation-guided genetic algorithm. It uses a modified form of edge coverage to effortlessly pick up subtle, local-scale changes to program control flow.&lt;/p&gt; &#xA;&lt;p&gt;Simplifying a bit, the overall algorithm can be summed up as:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Load user-supplied initial test cases into the queue,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Take next input file from the queue,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Attempt to trim the test case to the smallest size that doesn&#39;t alter the measured behavior of the program,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Repeatedly mutate the file using a balanced and well-researched variety of traditional fuzzing strategies,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If any of the generated mutations resulted in a new state transition recorded by the instrumentation, add mutated output as a new entry in the queue.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Go to 2.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The discovered test cases are also periodically culled to eliminate ones that have been obsoleted by newer, higher-coverage finds; and undergo several other instrumentation-driven effort minimization steps.&lt;/p&gt; &#xA;&lt;p&gt;As a side result of the fuzzing process, the tool creates a small, self-contained corpus of interesting test cases. These are extremely useful for seeding other, labor- or resource-intensive testing regimes - for example, for stress-testing browsers, office applications, graphics suites, or closed-source tools.&lt;/p&gt; &#xA;&lt;p&gt;The fuzzer is thoroughly tested to deliver out-of-the-box performance far superior to blind fuzzing or coverage-only tools.&lt;/p&gt; &#xA;&lt;h2&gt;3) Instrumenting programs for use with AFL&lt;/h2&gt; &#xA;&lt;p&gt;When source code is available, instrumentation can be injected by a companion tool that works as a drop-in replacement for gcc or clang in any standard build process for third-party code.&lt;/p&gt; &#xA;&lt;p&gt;The instrumentation has a fairly modest performance impact; in conjunction with other optimizations implemented by afl-fuzz, most programs can be fuzzed as fast or even faster than possible with traditional tools.&lt;/p&gt; &#xA;&lt;p&gt;The correct way to recompile the target program may vary depending on the specifics of the build process, but a nearly-universal approach would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ CC=/path/to/afl/afl-gcc ./configure&#xA;$ make clean all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For C++ programs, you&#39;d would also want to set &lt;code&gt;CXX=/path/to/afl/afl-g++&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The clang wrappers (afl-clang and afl-clang++) can be used in the same way; clang users may also opt to leverage a higher-performance instrumentation mode, as described in llvm_mode/README.llvm.&lt;/p&gt; &#xA;&lt;p&gt;When testing libraries, you need to find or write a simple program that reads data from stdin or from a file and passes it to the tested library. In such a case, it is essential to link this executable against a static version of the instrumented library, or to make sure that the correct .so file is loaded at runtime (usually by setting &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;). The simplest option is a static build, usually possible via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ CC=/path/to/afl/afl-gcc ./configure --disable-shared&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Setting &lt;code&gt;AFL_HARDEN=1&lt;/code&gt; when calling &#39;make&#39; will cause the CC wrapper to automatically enable code hardening options that make it easier to detect simple memory bugs. Libdislocator, a helper library included with AFL (see libdislocator/README.dislocator) can help uncover heap corruption issues, too.&lt;/p&gt; &#xA;&lt;p&gt;PS. ASAN users are advised to review &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/notes_for_asan.txt&#34;&gt;notes_for_asan.txt&lt;/a&gt; file for important caveats.&lt;/p&gt; &#xA;&lt;h2&gt;4) Instrumenting binary-only apps&lt;/h2&gt; &#xA;&lt;p&gt;When source code is &lt;em&gt;NOT&lt;/em&gt; available, the fuzzer offers experimental support for fast, on-the-fly instrumentation of black-box binaries. This is accomplished with a version of QEMU running in the lesser-known &#34;user space emulation&#34; mode.&lt;/p&gt; &#xA;&lt;p&gt;QEMU is a project separate from AFL, but you can conveniently build the feature by doing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd qemu_mode&#xA;$ ./build_qemu_support.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For additional instructions and caveats, see qemu_mode/README.qemu.&lt;/p&gt; &#xA;&lt;p&gt;The mode is approximately 2-5x slower than compile-time instrumentation, is less conducive to parallelization, and may have some other quirks.&lt;/p&gt; &#xA;&lt;h2&gt;5) Choosing initial test cases&lt;/h2&gt; &#xA;&lt;p&gt;To operate correctly, the fuzzer requires one or more starting file that contains a good example of the input data normally expected by the targeted application. There are two basic rules:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Keep the files small. Under 1 kB is ideal, although not strictly necessary. For a discussion of why size matters, see &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/perf_tips.txt&#34;&gt;perf_tips.txt&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use multiple test cases only if they are functionally different from each other. There is no point in using fifty different vacation photos to fuzz an image library.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can find many good examples of starting files in the testcases/ subdirectory that comes with this tool.&lt;/p&gt; &#xA;&lt;p&gt;PS. If a large corpus of data is available for screening, you may want to use the afl-cmin utility to identify a subset of functionally distinct files that exercise different code paths in the target binary.&lt;/p&gt; &#xA;&lt;h2&gt;6) Fuzzing binaries&lt;/h2&gt; &#xA;&lt;p&gt;The fuzzing process itself is carried out by the afl-fuzz utility. This program requires a read-only directory with initial test cases, a separate place to store its findings, plus a path to the binary to test.&lt;/p&gt; &#xA;&lt;p&gt;For target binaries that accept input directly from stdin, the usual syntax is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For programs that take input from a file, use &#39;@@&#39; to mark the location in the target&#39;s command line where the input file name should be placed. The fuzzer will substitute this for you:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use the -f option to have the mutated data written to a specific file. This is useful if the program expects a particular file extension or so.&lt;/p&gt; &#xA;&lt;p&gt;Non-instrumented binaries can be fuzzed in the QEMU mode (add -Q in the command line) or in a traditional, blind-fuzzer mode (specify -n).&lt;/p&gt; &#xA;&lt;p&gt;You can use -t and -m to override the default timeout and memory limit for the executed process; rare examples of targets that may need these settings touched include compilers and video decoders.&lt;/p&gt; &#xA;&lt;p&gt;Tips for optimizing fuzzing performance are discussed in &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/perf_tips.txt&#34;&gt;perf_tips.txt&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that afl-fuzz starts by performing an array of deterministic fuzzing steps, which can take several days, but tend to produce neat test cases. If you want quick &amp;amp; dirty results right away - akin to zzuf and other traditional fuzzers - add the -d option to the command line.&lt;/p&gt; &#xA;&lt;h2&gt;7) Interpreting output&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/status_screen.txt&#34;&gt;status_screen.txt&lt;/a&gt; file for information on how to interpret the displayed stats and monitor the health of the process. Be sure to consult this file especially if any UI elements are highlighted in red.&lt;/p&gt; &#xA;&lt;p&gt;The fuzzing process will continue until you press Ctrl-C. At minimum, you want to allow the fuzzer to complete one queue cycle, which may take anywhere from a couple of hours to a week or so.&lt;/p&gt; &#xA;&lt;p&gt;There are three subdirectories created within the output directory and updated in real time:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;queue/ - test cases for every distinctive execution path, plus all the starting files given by the user. This is the synthesized corpus mentioned in section 2. Before using this corpus for any other purposes, you can shrink it to a smaller size using the afl-cmin tool. The tool will find a smaller subset of files offering equivalent edge coverage.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;crashes/ - unique test cases that cause the tested program to receive a fatal signal (e.g., SIGSEGV, SIGILL, SIGABRT). The entries are grouped by the received signal.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;hangs/ - unique test cases that cause the tested program to time out. The default time limit before something is classified as a hang is the larger of 1 second and the value of the -t parameter. The value can be fine-tuned by setting AFL_HANG_TMOUT, but this is rarely necessary.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Crashes and hangs are considered &#34;unique&#34; if the associated execution paths involve any state transitions not seen in previously-recorded faults. If a single bug can be reached in multiple ways, there will be some count inflation early in the process, but this should quickly taper off.&lt;/p&gt; &#xA;&lt;p&gt;The file names for crashes and hangs are correlated with parent, non-faulting queue entries. This should help with debugging.&lt;/p&gt; &#xA;&lt;p&gt;When you can&#39;t reproduce a crash found by afl-fuzz, the most likely cause is that you are not setting the same memory limit as used by the tool. Try:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ LIMIT_MB=50&#xA;$ ( ulimit -Sv $[LIMIT_MB &amp;lt;&amp;lt; 10]; /path/to/tested_binary ... )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Change LIMIT_MB to match the -m parameter passed to afl-fuzz. On OpenBSD, also change -Sv to -Sd.&lt;/p&gt; &#xA;&lt;p&gt;Any existing output directory can be also used to resume aborted jobs; try:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./afl-fuzz -i- -o existing_output_dir [...etc...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have gnuplot installed, you can also generate some pretty graphs for any active fuzzing task using afl-plot. For an example of how this looks like, see &lt;a href=&#34;http://lcamtuf.coredump.cx/afl/plot/&#34;&gt;http://lcamtuf.coredump.cx/afl/plot/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;8) Parallelized fuzzing&lt;/h2&gt; &#xA;&lt;p&gt;Every instance of afl-fuzz takes up roughly one core. This means that on multi-core systems, parallelization is necessary to fully utilize the hardware. For tips on how to fuzz a common target on multiple cores or multiple networked machines, please refer to &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/parallel_fuzzing.txt&#34;&gt;parallel_fuzzing.txt&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The parallel fuzzing mode also offers a simple way for interfacing AFL to other fuzzers, to symbolic or concolic execution engines, and so forth; again, see the last section of &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/parallel_fuzzing.txt&#34;&gt;parallel_fuzzing.txt&lt;/a&gt; for tips.&lt;/p&gt; &#xA;&lt;h2&gt;9) Fuzzer dictionaries&lt;/h2&gt; &#xA;&lt;p&gt;By default, afl-fuzz mutation engine is optimized for compact data formats - say, images, multimedia, compressed data, regular expression syntax, or shell scripts. It is somewhat less suited for languages with particularly verbose and redundant verbiage - notably including HTML, SQL, or JavaScript.&lt;/p&gt; &#xA;&lt;p&gt;To avoid the hassle of building syntax-aware tools, afl-fuzz provides a way to seed the fuzzing process with an optional dictionary of language keywords, magic headers, or other special tokens associated with the targeted data type -- and use that to reconstruct the underlying grammar on the go:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html&#34;&gt;http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To use this feature, you first need to create a dictionary in one of the two formats discussed in dictionaries/README.dictionaries; and then point the fuzzer to it via the -x option in the command line.&lt;/p&gt; &#xA;&lt;p&gt;(Several common dictionaries are already provided in that subdirectory, too.)&lt;/p&gt; &#xA;&lt;p&gt;There is no way to provide more structured descriptions of the underlying syntax, but the fuzzer will likely figure out some of this based on the instrumentation feedback alone. This actually works in practice, say:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html&#34;&gt;http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;PS. Even when no explicit dictionary is given, afl-fuzz will try to extract existing syntax tokens in the input corpus by watching the instrumentation very closely during deterministic byte flips. This works for some types of parsers and grammars, but isn&#39;t nearly as good as the -x mode.&lt;/p&gt; &#xA;&lt;p&gt;If a dictionary is really hard to come by, another option is to let AFL run for a while, and then use the token capture library that comes as a companion utility with AFL. For that, see libtokencap/README.tokencap.&lt;/p&gt; &#xA;&lt;h2&gt;10) Crash triage&lt;/h2&gt; &#xA;&lt;p&gt;The coverage-based grouping of crashes usually produces a small data set that can be quickly triaged manually or with a very simple GDB or Valgrind script. Every crash is also traceable to its parent non-crashing test case in the queue, making it easier to diagnose faults.&lt;/p&gt; &#xA;&lt;p&gt;Having said that, it&#39;s important to acknowledge that some fuzzing crashes can be difficult to quickly evaluate for exploitability without a lot of debugging and code analysis work. To assist with this task, afl-fuzz supports a very unique &#34;crash exploration&#34; mode enabled with the -C flag.&lt;/p&gt; &#xA;&lt;p&gt;In this mode, the fuzzer takes one or more crashing test cases as the input, and uses its feedback-driven fuzzing strategies to very quickly enumerate all code paths that can be reached in the program while keeping it in the crashing state.&lt;/p&gt; &#xA;&lt;p&gt;Mutations that do not result in a crash are rejected; so are any changes that do not affect the execution path.&lt;/p&gt; &#xA;&lt;p&gt;The output is a small corpus of files that can be very rapidly examined to see what degree of control the attacker has over the faulting address, or whether it is possible to get past an initial out-of-bounds read - and see what lies beneath.&lt;/p&gt; &#xA;&lt;p&gt;Oh, one more thing: for test case minimization, give afl-tmin a try. The tool can be operated in a very simple way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./afl-tmin -i test_case -o minimized_result -- /path/to/program [...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The tool works with crashing and non-crashing test cases alike. In the crash mode, it will happily accept instrumented and non-instrumented binaries. In the non-crashing mode, the minimizer relies on standard AFL instrumentation to make the file simpler without altering the execution path.&lt;/p&gt; &#xA;&lt;p&gt;The minimizer accepts the -m, -t, -f and @@ syntax in a manner compatible with afl-fuzz.&lt;/p&gt; &#xA;&lt;p&gt;Another recent addition to AFL is the afl-analyze tool. It takes an input file, attempts to sequentially flip bytes, and observes the behavior of the tested program. It then color-codes the input based on which sections appear to be critical, and which are not; while not bulletproof, it can often offer quick insights into complex file formats. More info about its operation can be found near the end of &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/technical_details.txt&#34;&gt;technical_details.txt&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;11) Going beyond crashes&lt;/h2&gt; &#xA;&lt;p&gt;Fuzzing is a wonderful and underutilized technique for discovering non-crashing design and implementation errors, too. Quite a few interesting bugs have been found by modifying the target programs to call abort() when, say:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Two bignum libraries produce different outputs when given the same fuzzer-generated input,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;An image library produces different outputs when asked to decode the same input image several times in a row,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A serialization / deserialization library fails to produce stable outputs when iteratively serializing and deserializing fuzzer-supplied data,&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A compression library produces an output inconsistent with the input file when asked to compress and then decompress a particular blob.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Implementing these or similar sanity checks usually takes very little time; if you are the maintainer of a particular package, you can make this code conditional with &lt;code&gt;#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION&lt;/code&gt; (a flag also shared with libfuzzer) or &lt;code&gt;#ifdef __AFL_COMPILER&lt;/code&gt; (this one is just for AFL).&lt;/p&gt; &#xA;&lt;h2&gt;12) Common-sense risks&lt;/h2&gt; &#xA;&lt;p&gt;Please keep in mind that, similarly to many other computationally-intensive tasks, fuzzing may put strain on your hardware and on the OS. In particular:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Your CPU will run hot and will need adequate cooling. In most cases, if cooling is insufficient or stops working properly, CPU speeds will be automatically throttled. That said, especially when fuzzing on less suitable hardware (laptops, smartphones, etc), it&#39;s not entirely impossible for something to blow up.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Targeted programs may end up erratically grabbing gigabytes of memory or filling up disk space with junk files. AFL tries to enforce basic memory limits, but can&#39;t prevent each and every possible mishap. The bottom line is that you shouldn&#39;t be fuzzing on systems where the prospect of data loss is not an acceptable risk.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fuzzing involves billions of reads and writes to the filesystem. On modern systems, this will be usually heavily cached, resulting in fairly modest &#34;physical&#34; I/O - but there are many factors that may alter this equation. It is your responsibility to monitor for potential trouble; with very heavy I/O, the lifespan of many HDDs and SSDs may be reduced.&lt;/p&gt; &lt;p&gt;A good way to monitor disk I/O on Linux is the &#39;iostat&#39; command:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    $ iostat -d 3 -x -k [...optional disk ID...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;13) Known limitations &amp;amp; areas for improvement&lt;/h2&gt; &#xA;&lt;p&gt;Here are some of the most important caveats for AFL:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;AFL detects faults by checking for the first spawned process dying due to a signal (SIGSEGV, SIGABRT, etc). Programs that install custom handlers for these signals may need to have the relevant code commented out. In the same vein, faults in child processed spawned by the fuzzed target may evade detection unless you manually add some code to catch that.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;As with any other brute-force tool, the fuzzer offers limited coverage if encryption, checksums, cryptographic signatures, or compression are used to wholly wrap the actual data format to be tested.&lt;/p&gt; &lt;p&gt;To work around this, you can comment out the relevant checks (see experimental/libpng_no_checksum/ for inspiration); if this is not possible, you can also write a postprocessor, as explained in experimental/post_library/.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There are some unfortunate trade-offs with ASAN and 64-bit binaries. This isn&#39;t due to any specific fault of afl-fuzz; see &lt;a href=&#34;https://raw.githubusercontent.com/google/AFL/master/docs/notes_for_asan.txt&#34;&gt;notes_for_asan.txt&lt;/a&gt; for tips.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There is no direct support for fuzzing network services, background daemons, or interactive apps that require UI interaction to work. You may need to make simple code changes to make them behave in a more traditional way. Preeny may offer a relatively simple option, too - see: &lt;a href=&#34;https://github.com/zardus/preeny&#34;&gt;https://github.com/zardus/preeny&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Some useful tips for modifying network-based services can be also found at: &lt;a href=&#34;https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop&#34;&gt;https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;AFL doesn&#39;t output human-readable coverage data. If you want to monitor coverage, use afl-cov from Michael Rash: &lt;a href=&#34;https://github.com/mrash/afl-cov&#34;&gt;https://github.com/mrash/afl-cov&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Occasionally, sentient machines rise against their creators. If this happens to you, please consult &lt;a href=&#34;http://lcamtuf.coredump.cx/prep/&#34;&gt;http://lcamtuf.coredump.cx/prep/&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Beyond this, see INSTALL for platform-specific tips.&lt;/p&gt; &#xA;&lt;h2&gt;14) Special thanks&lt;/h2&gt; &#xA;&lt;p&gt;Many of the improvements to afl-fuzz wouldn&#39;t be possible without feedback, bug reports, or patches from:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  Jann Horn                             Hanno Boeck&#xA;  Felix Groebert                        Jakub Wilk&#xA;  Richard W. M. Jones                   Alexander Cherepanov&#xA;  Tom Ritter                            Hovik Manucharyan&#xA;  Sebastian Roschke                     Eberhard Mattes&#xA;  Padraig Brady                         Ben Laurie&#xA;  @dronesec                             Luca Barbato&#xA;  Tobias Ospelt                         Thomas Jarosch&#xA;  Martin Carpenter                      Mudge Zatko&#xA;  Joe Zbiciak                           Ryan Govostes&#xA;  Michael Rash                          William Robinet&#xA;  Jonathan Gray                         Filipe Cabecinhas&#xA;  Nico Weber                            Jodie Cunningham&#xA;  Andrew Griffiths                      Parker Thompson&#xA;  Jonathan Neuschfer                    Tyler Nighswander&#xA;  Ben Nagy                              Samir Aguiar&#xA;  Aidan Thornton                        Aleksandar Nikolich&#xA;  Sam Hakim                             Laszlo Szekeres&#xA;  David A. Wheeler                      Turo Lamminen&#xA;  Andreas Stieger                       Richard Godbee&#xA;  Louis Dassy                           teor2345&#xA;  Alex Moneger                          Dmitry Vyukov&#xA;  Keegan McAllister                     Kostya Serebryany&#xA;  Richo Healey                          Martijn Bogaard&#xA;  rc0r                                  Jonathan Foote&#xA;  Christian Holler                      Dominique Pelle&#xA;  Jacek Wielemborek                     Leo Barnes&#xA;  Jeremy Barnes                         Jeff Trull&#xA;  Guillaume Endignoux                   ilovezfs&#xA;  Daniel Godas-Lopez                    Franjo Ivancic&#xA;  Austin Seipp                          Daniel Komaromy&#xA;  Daniel Binderman                      Jonathan Metzman&#xA;  Vegard Nossum                         Jan Kneschke&#xA;  Kurt Roeckx                           Marcel Bohme&#xA;  Van-Thuan Pham                        Abhik Roychoudhury&#xA;  Joshua J. Drake                       Toby Hutton&#xA;  Rene Freingruber                      Sergey Davidoff&#xA;  Sami Liedes                           Craig Young&#xA;  Andrzej Jackowski                     Daniel Hodson&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Thank you!&lt;/p&gt; &#xA;&lt;h2&gt;15) Contact&lt;/h2&gt; &#xA;&lt;p&gt;Questions? Concerns? Bug reports? Please use GitHub.&lt;/p&gt; &#xA;&lt;p&gt;There is also a mailing list for the project; to join, send a mail to &lt;a href=&#34;mailto:afl-users+subscribe@googlegroups.com&#34;&gt;afl-users+subscribe@googlegroups.com&lt;/a&gt;. Or, if you prefer to browse archives first, try: &lt;a href=&#34;https://groups.google.com/group/afl-users&#34;&gt;https://groups.google.com/group/afl-users&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>libdriver/bmp280</title>
    <updated>2024-01-27T01:25:17Z</updated>
    <id>tag:github.com,2024-01-27:/libdriver/bmp280</id>
    <link href="https://github.com/libdriver/bmp280" rel="alternate"></link>
    <summary type="html">&lt;p&gt;BMP280 full function driver library for general MCU and Linux.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/README.md&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/README_zh-Hans.md&#34;&gt; 简体中文&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/README_zh-Hant.md&#34;&gt;繁體中文&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/README_ja.md&#34;&gt;日本語&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/README_de.md&#34;&gt;Deutsch&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/README_ko.md&#34;&gt;한국어&lt;/a&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/doc/image/logo.svg?sanitize=true&#34; width=&#34;400&#34; height=&#34;150&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;LibDriver BMP280&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/misra/README.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/misra-compliant-brightgreen.svg?sanitize=true&#34; alt=&#34;MISRA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.libdriver.com/docs/bmp280/index.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/api-reference-blue.svg?sanitize=true&#34; alt=&#34;API&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-brightgreen.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The BMP280 is an absolute barometric pressure sensor, which is especially feasible for mobile applications. Its small dimensions and its low power consumption allow for the implementation in battery-powered devices such as mobile phones, GPS modules or watches. The BMP280 is based on Bosch’s proven piezo-resistive pressure sensor technology featuring high accuracy and linearity as well as long-term stability and high EMC robustness. Numerous device operation options guarantee for highest flexibility. The device is optimized in terms of power consumption, resolution and filter performance.&lt;/p&gt; &#xA;&lt;p&gt;LibDriver BMP280 is a full function driver of BMP280 launched by LibDriver.It provides continuous reading of pressure and temperature, single reading of pressure and temperature and other functions. LibDriver is MISRA compliant.&lt;/p&gt; &#xA;&lt;h3&gt;Table of Contents&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/#Instruction&#34;&gt;Instruction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/#Install&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/#Usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/#example-basic&#34;&gt;example basic&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/#example-shot&#34;&gt;example shot&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/#Document&#34;&gt;Document&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/#Contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/#License&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/libdriver/bmp280/master/#Contact-Us&#34;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Instruction&lt;/h3&gt; &#xA;&lt;p&gt;/src includes LibDriver BMP280 source files.&lt;/p&gt; &#xA;&lt;p&gt;/interface includes LibDriver BMP280 IIC, SPI platform independent template.&lt;/p&gt; &#xA;&lt;p&gt;/test includes LibDriver BMP280 driver test code and this code can test the chip necessary function simply.&lt;/p&gt; &#xA;&lt;p&gt;/example includes LibDriver BMP280 sample code.&lt;/p&gt; &#xA;&lt;p&gt;/doc includes LibDriver BMP280 offline document.&lt;/p&gt; &#xA;&lt;p&gt;/datasheet includes BMP280 datasheet.&lt;/p&gt; &#xA;&lt;p&gt;/project includes the common Linux and MCU development board sample code. All projects use the shell script to debug the driver and the detail instruction can be found in each project&#39;s README.md.&lt;/p&gt; &#xA;&lt;p&gt;/misra includes the LibDriver MISRA code scanning results.&lt;/p&gt; &#xA;&lt;h3&gt;Install&lt;/h3&gt; &#xA;&lt;p&gt;Reference /interface IIC, SPI platform independent template and finish your platform IIC, SPI driver.&lt;/p&gt; &#xA;&lt;p&gt;Add /src, /interface and /example to your project.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;h4&gt;example basic&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &#34;driver_bmp280_basic.h&#34;&#xA;&#xA;uint8_t res;&#xA;uint32_t i;&#xA;float temperature_c;&#xA;float pressure_pa;&#xA;&#xA;/* basic init */&#xA;res = bmp280_basic_init(BMP280_INTERFACE_IIC, BMP280_ADDRESS_ADO_LOW);&#xA;if (res != 0)&#xA;{&#xA;    return 1;&#xA;}&#xA;&#xA;...&#xA;    &#xA;/* loop */&#xA;for (i = 0; i &amp;lt; 3; i++)&#xA;{&#xA;    /* delay 1000ms */&#xA;    bmp280_interface_delay_ms(1000);&#xA;&#xA;    /* read data */&#xA;    res = bmp280_basic_read((float *)&amp;amp;temperature_c, (float *)&amp;amp;pressure_pa);&#xA;    if (res != 0)&#xA;    {&#xA;        (void)bmp280_basic_deinit();&#xA;&#xA;        return 1;&#xA;    }&#xA;&#xA;    /* output */&#xA;    bmp280_interface_debug_print(&#34;bmp280: %d/%d.\n&#34;, i + 1, 3);&#xA;    bmp280_interface_debug_print(&#34;bmp280: temperature is %0.2fC.\n&#34;, temperature_c);&#xA;    bmp280_interface_debug_print(&#34;bmp280: pressure is %0.2fPa.\n&#34;, pressure_pa);&#xA;    &#xA;    ...&#xA;}&#xA;&#xA;...&#xA;    &#xA;/* deinit */&#xA;(void)bmp280_basic_deinit();&#xA;&#xA;return 0;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;example shot&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &#34;driver_bmp280_shot.h&#34;&#xA;&#xA;uint8_t res;&#xA;uint32_t i;&#xA;float temperature_c;&#xA;float pressure_pa;&#xA;&#xA;/* shot init */&#xA;res = bmp280_shot_init(BMP280_INTERFACE_IIC, BMP280_ADDRESS_ADO_LOW);&#xA;if (res != 0)&#xA;{&#xA;    return 1;&#xA;}&#xA;&#xA;...&#xA;    &#xA;/* loop */&#xA;for (i = 0; i &amp;lt; 3; i++)&#xA;{&#xA;    /* delay 1000ms */&#xA;    bmp280_interface_delay_ms(1000);&#xA;&#xA;    /* read data */&#xA;    res = bmp280_shot_read((float *)&amp;amp;temperature_c, (float *)&amp;amp;pressure_pa);&#xA;    if (res != 0)&#xA;    {&#xA;        (void)bmp280_shot_deinit();&#xA;&#xA;        return 1;&#xA;    }&#xA;&#xA;    /* output */&#xA;    bmp280_interface_debug_print(&#34;bmp280: %d/%d.\n&#34;, i + 1, 3);&#xA;    bmp280_interface_debug_print(&#34;bmp280: temperature is %0.2fC.\n&#34;, temperature_c);&#xA;    bmp280_interface_debug_print(&#34;bmp280: pressure is %0.2fPa.\n&#34;, pressure_pa);&#xA;    &#xA;    ...&#xA;}&#xA;&#xA;...&#xA;    &#xA;/* deinit */&#xA;(void)bmp280_shot_deinit();&#xA;&#xA;return 0;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Document&lt;/h3&gt; &#xA;&lt;p&gt;Online documents: &lt;a href=&#34;https://www.libdriver.com/docs/bmp280/index.html&#34;&gt;https://www.libdriver.com/docs/bmp280/index.html&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Offline documents: /doc/html/index.html.&lt;/p&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;p&gt;Please refer to CONTRIBUTING.md.&lt;/p&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;Copyright (c) 2015 - present LibDriver All rights reserved&lt;/p&gt; &#xA;&lt;p&gt;The MIT License (MIT)&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy&lt;/p&gt; &#xA;&lt;p&gt;of this software and associated documentation files (the &#34;Software&#34;), to deal&lt;/p&gt; &#xA;&lt;p&gt;in the Software without restriction, including without limitation the rights&lt;/p&gt; &#xA;&lt;p&gt;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&lt;/p&gt; &#xA;&lt;p&gt;copies of the Software, and to permit persons to whom the Software is&lt;/p&gt; &#xA;&lt;p&gt;furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all&lt;/p&gt; &#xA;&lt;p&gt;copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&lt;/p&gt; &#xA;&lt;p&gt;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&lt;/p&gt; &#xA;&lt;p&gt;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&lt;/p&gt; &#xA;&lt;p&gt;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&lt;/p&gt; &#xA;&lt;p&gt;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&lt;/p&gt; &#xA;&lt;p&gt;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&lt;/p&gt; &#xA;&lt;p&gt;SOFTWARE.&lt;/p&gt; &#xA;&lt;h3&gt;Contact Us&lt;/h3&gt; &#xA;&lt;p&gt;Please sent an e-mail to &lt;a href=&#34;mailto:lishifenging@outlook.com&#34;&gt;lishifenging@outlook.com&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>