<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-13T01:28:32Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Hugobros3/shady</title>
    <updated>2024-01-13T01:28:32Z</updated>
    <id>tag:github.com,2024-01-13:/Hugobros3/shady</id>
    <link href="https://github.com/Hugobros3/shady" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Research shading language IR&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Shady&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Hugobros3/shady/master/logo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;shady&lt;/code&gt; is a small intermediate shading language and compiler for research purposes. It strives to be a testbed for improved GPU programming models, and also provide support for emulating features either missing from SPIR-V, or suffering from poor support.&lt;/p&gt; &#xA;&lt;p&gt;Shady is ideal for projects that aim to target SPIR-V, but already make use of features that are not found in vanilla Vulkan compute. See feature support below.&lt;/p&gt; &#xA;&lt;p&gt;Shady is used as part of the &lt;a href=&#34;https://anydsl.github.io&#34;&gt;AnyDSL&lt;/a&gt; to provide experimental Vulkan accelerator support. Technical discussion about shady and SPIR-V in general can be had on &lt;a href=&#34;https://twitter.com/gobrosse/status/1441323225128968197&#34;&gt;this discord server&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Feature support&lt;/h2&gt; &#xA;&lt;p&gt;Not all supported features are listed, these are just the more notable ones that are either already working, or are planned.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; True function calls (thanks to a CPS transformation) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Function pointers/indirect calls&lt;/li&gt; &#xA;   &lt;li&gt;Recursion (with a stack)&lt;/li&gt; &#xA;   &lt;li&gt;Divergent calls&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Arbitrary control flow inside functions: &lt;code&gt;goto&lt;/code&gt;, including non-uniform is allowed &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;This makes &lt;code&gt;shady&lt;/code&gt; easy to target from existing compilers.&lt;/li&gt; &#xA;   &lt;li&gt;Reconvergence is explicit and dataflow driven, not reliant on a CFG analysis.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Subgroup memory (known as &lt;code&gt;simdgroup&lt;/code&gt; in Metal)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Physical pointers (cast-able pointers where the layout of objects in memory is observable) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; For &#39;private&#39; memory&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; For &#39;shared&#39; memory&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&#39;Wide&#39; subgroup operations (with arbitrary types) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Ballot&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Shuffles&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Int8, Int16 and Int64 support everywhere&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; FP 64 emulation&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Generic (tagged) pointers&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Printf debug support&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Adapt code generation to the target through a &lt;code&gt;runtime&lt;/code&gt; component.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Platform support&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compiles on Windows/MacOS/Linux with any C11 compliant toolchain: GCC, Clang and recent versions of MSVC &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Windows SDKs older than 10.0.20348.0 are missing important C11 features and are unsupported.&lt;/li&gt; &#xA;   &lt;li&gt;Will run as far back as &lt;a href=&#34;https://mastodon.gamedev.place/@gob/109580697549344123&#34;&gt;Windows XP&lt;/a&gt; - using MinGW based toolchains.&lt;/li&gt; &#xA;   &lt;li&gt;We ran the compiler on IA32, AMD64, AArch64 and RISCV 64 machines with no issues.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The following Vulkan drivers have been tested: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;radv&lt;/code&gt; Open-source mesa driver for AMD GPUs &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Tested on multiple RDNA2 and GCN devices&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;amdvlk&lt;/code&gt; works too&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;anv&lt;/code&gt; Open-source mesa driver for Intel GPUs&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Intel proprietary Windows drivers (UHD 630, A750/A770)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; NVidia proprietary drivers (requiring a &lt;a href=&#34;https://github.com/Hugobros3/shady/commit/f3ef83dbff7f29654fc11f8901ba67494864c085&#34;&gt;small hack&lt;/a&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; MoltenVK does not work properly due to issues with SPIRV-Cross&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Imagination closed-source driver on the VisionFive 2 board: driver crash&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additionally, the compiler supports alternative backends:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GLSL (untested - no runtime component yet)&lt;/li&gt; &#xA; &lt;li&gt;ISPC (no runtime component either, but useful for debugging on the host)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Metal shading language and C backends are on the table in the future.&lt;/p&gt; &#xA;&lt;h2&gt;Compiler design&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Semi-immutable impure IR: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Qualified value types (&lt;code&gt;uniform&lt;/code&gt; or &lt;code&gt;varying&lt;/code&gt;), type system can enforce uniformity for sensitive operations&lt;/li&gt; &#xA;   &lt;li&gt;Meta-instructions for conventional structured control flow (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt;), no convergence annotations required&lt;/li&gt; &#xA;   &lt;li&gt;Experimental new dynamically structured control flow primitives (paper/writeup coming later)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Nodes are either nominal (top-level declarations, variables and basic blocks) or structural (everything else). Structural nodes are immutable and subject to hash-consing and folding ops during construction.&lt;/li&gt; &#xA; &lt;li&gt;Shady is written in standard C11 and requires few dependencies to build: CMake, JSON-C and the SPIRV-Headers.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The grammar is defined in &lt;a href=&#34;https://raw.githubusercontent.com/Hugobros3/shady/master/include/shady/grammar.json&#34;&gt;grammar.json&lt;/a&gt;, this file is used to define the various nodes in the IR, and generate much of the boilerplate code (node hashing, rewriting, visitors, ...). Some finer concepts are expressed in &lt;a href=&#34;https://raw.githubusercontent.com/Hugobros3/shady/master/include/shady/grammar.h&#34;&gt;ir.h&lt;/a&gt; or even &lt;a href=&#34;https://raw.githubusercontent.com/Hugobros3/shady/master/src/shady/type.h&#34;&gt;type.h&lt;/a&gt;. There is also a number of x-macros used as &#34;rich&#34; enums.&lt;/p&gt; &#xA;&lt;h2&gt;Language syntax&lt;/h2&gt; &#xA;&lt;p&gt;The textual syntax of the language is C-like in that return types come first. Variance annotations are supported. Overall the language is structurally close to SPIR-V and LLVM, very much on purpose. There is a &#39;front-end&#39; (slim) variant of the IR that allows for mutable variables and using instructions as values.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// line comments are supported&#xA;fn identity varying i32(varying i32 i) {&#xA;    return (i);&#xA;};&#xA;&#xA;fn f i32(varying i32 i) {&#xA;    val j = call(identity, i);&#xA;    val k = add(j, 1);&#xA;    return (k);&#xA;};&#xA;&#xA;const i32 answer = 42;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The textual syntax allows nesting basic blocks inside functions. The syntax is superficially similar to C labels, but with an added parameters list. Note that this is mostly for making handwritten examples look nicer, the actual nesting of functions/continuations is determined by the CFG analysis after name binding.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;fn f i32(varying bool b) {&#xA;    jump bb1(7);&#xA;&#xA;    cont bb1(varying i32 n) {&#xA;        branch (b, bb2(), bb3(n));&#xA;    }&#xA;&#xA;    cont bb2() {&#xA;        return (0);&#xA;    }&#xA;&#xA;    cont bb3(varying i32 n) {&#xA;        return (n);&#xA;    }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>