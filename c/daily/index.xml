<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-10T01:27:00Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Battelle/movfuscator</title>
    <updated>2023-11-10T01:27:00Z</updated>
    <id>tag:github.com,2023-11-10:/Battelle/movfuscator</id>
    <link href="https://github.com/Battelle/movfuscator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The single instruction C compiler&lt;/p&gt;&lt;hr&gt;&lt;pre&gt;&lt;code&gt;       ___     ___            ___    ___     ___     ___     ___          ___     ___      &#xA;      /\  \   /\  \    ___   /\__\  /\  \   /\__\   /\__\   /\  \        /\  \   /\  \    .&#xA;     |::\  \ /::\  \  /\  \ /:/ _/_ \:\  \ /:/ _/_ /:/  /  /::\  \  ___ /::\  \ /::\  \   .&#xA;     |:::\  \:/\:\  \ \:\  \:/ /\__\ \:\  \:/ /\  \:/  /  /:/\:\  \/\__\:/\:\  \:/\:\__\  .&#xA;   __|:|\:\  \  \:\  \ \:\  \ /:/  /  \:\  \ /::\  \  /  _:/ /::\  \/  //  \:\  \ /:/  /   &#xA;  /::::|_\:\__\/ \:\__\ \:\__\:/  / \  \:\__\:/\:\__\/  /\__\:/\:\__\_//__/ \:\__\:/__/___ &#xA;  \:\~~\  \/__/\ /:/  / |:|  |/  /\  \ /:/  // /:/  /\ /:/  //  \/__/ \\  \ /:/  /::::/  / &#xA;   \:\  \  \:\  /:/  / \|:|  |__/\:\  /:/  // /:/  /  /:/  //__/:/\:\  \\  /:/  //~~/~~~~  &#xA;    \:\  \  \:\/:/  /\__|:|__|  \ \:\/:/  //_/:/  /:\/:/  /:\  \/__\:\  \\/:/  /:\~~\     .&#xA;     \:\__\  \::/  /\::::/__/:\__\ \::/  /  /:/  / \::/  / \:\__\   \:\__\:/  / \:\__\    .&#xA;      \/__/   \/__/  ~~~~    \/__/  \/__/   \/__/   \/__/   \/__/    \/__/ __/   \/__/    2&#xA;                                                                                           &#xA;&#xA; M/o/Vfuscator2&#xA;&#xA; github.com/xoreaxeaxeax/movfuscator :: the single instruction C compiler&#xA; chris domas           @xoreaxeaxeax&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The M/o/Vfuscator (short &#39;o&#39;, sounds like &#34;mobfuscator&#34;) compiles programs into &#34;mov&#34; instructions, and only &#34;mov&#34; instructions. Arithmetic, comparisons, jumps, function calls, and everything else a program needs are all performed through mov operations; there is no self-modifying code, no transport-triggered calculation, and no other form of non-mov cheating.&lt;/p&gt; &#xA;&lt;p&gt;The basic effects of the process can be seen in &lt;a href=&#34;https://raw.githubusercontent.com/Battelle/movfuscator/master/overview/&#34;&gt;overview&lt;/a&gt;, which illustates compiling a simple prime number function with gcc and the M/o/Vfuscator.&lt;/p&gt; &#xA;&lt;p&gt;Assembly:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;GCC&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;M/o/Vfuscator&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Battelle/movfuscator/master/overview/gcc_asm.png&#34; alt=&#34;gcc asm&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Battelle/movfuscator/master/overview/mov_asm.png&#34; alt=&#34;mov asm&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Control flow graphs:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;GCC&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;M/o/Vfuscator&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Battelle/movfuscator/master/overview/gcc_cfg.png&#34; alt=&#34;gcc CFG&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Battelle/movfuscator/master/overview/mov_cfg.png&#34; alt=&#34;mov CFG&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;In action:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;movcc prime.c -o prime&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Battelle/movfuscator/master/overview/demo_mov.gif&#34; alt=&#34;demo_mov&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Of course, as a complete C compiler, it is not limited to simple programs:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;movcc nibbles.c -o nibbles -lncurses&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Battelle/movfuscator/master/overview/demo_nibbles.gif&#34; alt=&#34;demo_nibbles&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The compiler currently targets the C programming language and x86 processor architecture, but is easily adaptable to other languages and architectures.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;The M/o/Vfuscator uses LCC as the compiler frontend. The included build script will automatically download LCC, configure it for the mov backend, and build the M/o/Vfuscator tool.&lt;/p&gt; &#xA;&lt;p&gt;If you are building on a 64 bit system, ensure that you have a 32 bit libc available (for example, &#39;apt-get install libc6-dev-i386&#39; or &#39;yum install glibc-devel.i686&#39;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/xoreaxeaxeax/movfuscator&#xA;cd movfuscator&#xA;./build.sh&#xA;sudo ./install.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have trouble building LCC, you can get more details on the LCC build process at: &lt;a href=&#34;http://drh.github.io/lcc/current/doc/install.html&#34;&gt;http://drh.github.io/lcc/current/doc/install.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;Check that the build was successful with the check script. This will automatically download an open source AES implementation, compile it to mov instructions, objdump the result, and run the program.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./check.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Compile programs as you would with any traditional C compiler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;movcc example.c -o example&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Flags&lt;/h2&gt; &#xA;&lt;p&gt;Flags are passed to the compiler proper via -Wfflag, e.g. -Wf--no-mov-id&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--mov-id&#xA;  Add reference instructions for each basic block to assist debugging.&#xA;&#xA;--no-mov-id&#xA;  Do not add reference instructions.  This is the default.&#xA;&#xA;--mov-flow&#xA;  Use mov instructions in implementing control flow.  This is the default.&#xA;&#xA;--no-mov-flow&#xA;  Use jmp instructions in implementing control flow.  This will substantially&#xA;  speed up execution in larger projects.&#xA;&#xA;--mov-extern&#xA;  Use mov instructions to implement external function calls.  This is the&#xA;  default.&#xA;&#xA;--no-mov-extern&#xA;  Use jmp instructions to implement external function calls.  This is useful for&#xA;  debugging.&#xA;&#xA;--mov-loop&#xA;  Use mov instructions to implement the primary execution loop.  This is the&#xA;  default.&#xA;&#xA;--no-mov-loop&#xA;  Use jmp instructions to implement the primary execution loop.  This is useful&#xA;  for debugging.&#xA;&#xA;--crt0&#xA;  Build the M/o/Vfuscator crt0 library (_start routines).&#xA;&#xA;--crtf&#xA;  Build the M/o/Vfuscator crtf library (primary execution loop routines).&#xA;&#xA;--crtd&#xA;  Build the M/o/Vfuscator crtd library (data tables).&#xA;&#xA;--crt&#xA;  Same as --crt0 --crtf --crtd.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Floats&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The M/o/Vfuscator contains a complete mov-only floating point emulator. Since it is approximately 500,000 instructions, you must explicitly link to it if you need it. Use the smaller softfloat32.o if you only use floats, softfloat64.o if you need floats and doubles, and softfloatfull.o for a full IEEE floating point emulator.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;movcc your_code.c movfuscator/lib/softfloat32.o&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Recommendations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Due to the lookup tables used for arithmetic, the symbol tables in the compiled binary can be extremely large. Stripping symbols with the -s flag can cut the final binary size by half.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;movcc example.c -s&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Warnings&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You may occassionally run into ABI conflicts when calling into libraries compiled with other compilers. These are relatively rare, but do occassionally pop up. Watch out for:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;Passing a pointer to a callback function into a library. The M/o/Vfuscator will clobber registers the library was expecting to have preserved.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Using the long long type. The M/o/Vfuscator uses a 32 bit long long; your library may be expecting 64 bits.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Such ABI issues are relatively rare; they can be roughly fixed with some coding caution, or more robustly fixed by recompiling your libraries with the M/o/Vfuscator.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;LCC is a C89 compiler. If you try to compile C99 code, you will get errors. Don&#39;t use C99 features like bool, for (int ...), etc. Don&#39;t declare variables in the middle of blocks.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To generate code correctly, the M/o/Vfuscator must be able to determine when a call is being made to a shared library. If a function is used before it is declared, this determination may be incorrect. If your executable hangs, it may be because a function prototype was missing.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;LCC strongly enforces type and const rules. You may not be able to compile code with unsafe type or const conversions, unless you explicitly cast for it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;These are by far the most common causes of the M/o/Vfuscator &#34;breaking&#34;. Make sure you handle these before you try to compile your code.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Calls to external functions (printf, etc) through function pointers are not yet implemented. That is,&lt;/p&gt; &lt;pre&gt;&lt;code&gt;getchar()&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;works, but&lt;/p&gt; &lt;pre&gt;&lt;code&gt;int (*f)(void)=getchar; f();&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;does not.&lt;/p&gt; &lt;p&gt;If you need to do this, wrap the function internally:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;int g(void) { return getchar(); }&#xA;int (*f)(void)=g; f();&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;MOV violations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;When calling into libraries compiled with other compilers, an occassional non-mov instruction is necessary. This can be fixed by compiling all of your libraries with the M/o/Vfuscator. To be clear, this is not a limitation of the M/o/Vfuscator, or a violation of mov Turing-completeness - non-mov instructions are only necessary to accommodate non-mov calling conventions. If you do not recompile your libraries, the non-mov instructions are as follows:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;A single jmp instruction at the end of the program is used to dispatch the program&#39;s external functions. If you wish to avoid this jmp instruction to have a truly mov only program, compile with --no-mov-extern, and avoid calling into shared libraries. If you still need an external function, recompile the library with the M/o/Vfuscator, and statically link it to your program.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;An fstp instruction is used following every call to an external function returning a float or a double. This is because there is no way to access the x86 floating point registers with a mov instruction. To get rid of the fstp instruction, recompile your libraries to use the M/o/Vfuscator&#39;s floating point emulator, instead of the x86 FPU.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Post-processing&lt;/h2&gt; &#xA;&lt;p&gt;The M/o/Vfuscator post-processors take assembly from the M/o/Vfuscator and translate it for additional obfuscation, new instructions, or optimization. At some point they may be integrated into the actual compiler; for now they are separate scripts.&lt;/p&gt; &#xA;&lt;p&gt;Current post-processing scripts include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Instruction shuffling and register renaming, to prevent simple decompilation through pattern matching.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Assembly translation into only: XOR, SUB, ADD, XADD, ADC, SBB, AND/OR, PUSH/POP, 1-bit shifts, or CMPXCHG/XCHG instructions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Translation into only 32 bit register-to-memory and memory-to-register transfers. This may assist in translating M/o/Vfuscated code to other instructions or architectures.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Translation into only indexed addressing forms.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Randomization of the above translations.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other source languages&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The M/o/Vfuscator currently uses C as the source language. The following proof of concept, provided by Adam Schwalm, illustrates how to use a variety of other source languages:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;# Compile c++ to llvm bytecode&#xA;clang++ -S -emit-llvm -o bytecode.ll $1&#xA;&#xA;# Convert bytecode to C&#xA;llc -march=c -o code.c bytecode.ll&#xA;&#xA;# &#39;fix&#39; static inline. This is a workaround for a bug&#xA;# in one of the parsers, I think.&#xA;sed -i &#39;s/static inline.*//&#39; code.c&#xA;&#xA;# hack&#xA;sed -i &#39;s/extern unsigned char \*__dso_handle;/unsigned char \*__dso_handle=0;/&#39; code.c&#xA;&#xA;# Compile the resulting C as usual (but with the c++ stdlib)&#xA;movcc code.c -lstdc++&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other architectures&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A common observation on the M/o/Vfuscator output is that it uses all available forms and addressing modes for the mov instruction. Although the point was never anything different, the RISC post-processor (risc.py) illustrates transforming the program into RISC-like data transfers, reducing the program to 4 byte memory accesses, only indexed addressing modes, and only two registers. With this, all mov instructions become either &#34;mov esi/edi, [BASE+esi/edi]&#34; or &#34;mov [BASE+esi/edi], esi/edi&#34;, where BASE is some constant address. This should demonstrate the applicability of the approach on non-x86 architectures, and deter complaints about the diversity of the x86 mov instruction.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;While Dolan&#39;s paper required a jmp instruction, the M/o/Vfuscator does not - it uses a faulting mov instruction to achieve the infinite execution loop. If you&#39;re worried that this is still &#34;jumping&#34;, the same effect could be achieved through pages aliased to the same address, wrapping execution around the upper range of memory, ring 0 exception handling, or simply repeating the mov loop indefinitely. A jmp &lt;em&gt;is&lt;/em&gt; currently used to dispatch external functions - if this is a problem, avoid using external functions, or compile libraries with the M/o/Vfuscator as well.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;History&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The original M/o/Vfuscator (M/o/Vfuscator 1.0) compiles programs from the esoteric language BrainF@$!, and is best used in conjunction with the BFBASIC compiler by Jeffry Johnston. It is still available as a proof of concept in the &lt;a href=&#34;https://raw.githubusercontent.com/Battelle/movfuscator/master/poc/&#34;&gt;poc&lt;/a&gt; directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;M/o/Vfuscator2 is a complete single-instruction C compiler.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;F.A.Q.&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Q: Why did you make this? A: I thought it would be funny.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;A presentation explaining the ideation, design, and goals of the M/o/Vfuscator can be found &lt;a href=&#34;https://www.youtube.com/watch?v=R7EEoWg6Ekk&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Slides outlining the mechanisms used are &lt;a href=&#34;https://raw.githubusercontent.com/Battelle/movfuscator/master/slides/domas_2015_the_movfuscator.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The inspiration for the compiler is the paper &lt;a href=&#34;http://www.cl.cam.ac.uk/~sd601/papers/mov.pdf&#34;&gt;&#34;mov is Turing-complete&#34;, by Stephen Dolan&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;chris domas, @xoreaxeaxeax&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>FeijiangHan/dead_code_analyzer</title>
    <updated>2023-11-10T01:27:00Z</updated>
    <id>tag:github.com,2023-11-10:/FeijiangHan/dead_code_analyzer</id>
    <link href="https://github.com/FeijiangHan/dead_code_analyzer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Using DynamoRIO and XED to find redundant executions (Dead code)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DeadCode Detection Tool&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using DynamoRIO and XED to find redundant executions (Dead code)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://gitee.com/han-feijiang/img-store/raw/master/2023/poster-Feijiang%20Han.png&#34; alt=&#34;poster-Feijiang Han&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] This tool aims to detect and analyze dead code (redundant executions) in binary files using DynamoRIO and XED.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;The process can be summarized as follows:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Obtain the binary file (trace) that needs to be parsed.&lt;/li&gt; &#xA; &lt;li&gt;Extract the necessary code from DynamoRIO for parsing the target binary. This step gathers detailed information about instructions, such as read/write operations and parameter details.&lt;/li&gt; &#xA; &lt;li&gt;Utilize &lt;a href=&#34;https://intelxed.github.io/&#34;&gt;Intel XED&lt;/a&gt; to decode register details and analyze fine-grained parameters.&lt;/li&gt; &#xA; &lt;li&gt;Modify the dead code detection logic in &lt;a href=&#34;https://github.com/FeijiangHan/DeadCodeDetection/raw/main/src/dead_code_analysis.cpp&#34;&gt;dead_code_analysis.cpp&lt;/a&gt;. The implementation includes detecting redundant reads and redundant writes.&lt;/li&gt; &#xA; &lt;li&gt;The results of the analysis will be output to the &#39;out&#39; file, which can be further analyzed.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;TODO:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Optimize the output format for better readability.&lt;/li&gt; &#xA; &lt;li&gt;Implement more sophisticated dead code detection logic.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more information and access to the source code, please refer to the project repository.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>fortra/No-Consolation</title>
    <updated>2023-11-10T01:27:00Z</updated>
    <id>tag:github.com,2023-11-10:/fortra/No-Consolation</id>
    <link href="https://github.com/fortra/No-Consolation" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A BOF that runs unmanaged PEs inline&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;No-Consolation&lt;/h1&gt; &#xA;&lt;p&gt;This is a Beacon Object File (BOF) that executes unmanaged PEs inline and retrieves their output without allocating a console (i.e. spawning &lt;code&gt;conhost.exe&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/No-Consolation/main/resources/demo.png&#34; alt=&#34;screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports 64 and 32 bits&lt;/li&gt; &#xA; &lt;li&gt;Supports EXEs and DLLs&lt;/li&gt; &#xA; &lt;li&gt;Does not create new processes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Summary: Run an unmanaged EXE/DLL inside Beacon&#39;s memory.&#xA;&#xA;Usage: noconsolation [--local] [--timeout 60] [-k] [--method funcname] [-w] [--no-output] [--alloc-console] [--close-handles] [--free-libraries] /path/to/binary.exe arg1 arg2&#xA;    --local, -l                           Optional. The binary should be loaded from the target Windows machine&#xA;    --timeout NUM_SECONDS, -t NUM_SECONDS Optional. The number of seconds you wish to wait for the PE to complete running. Default 60 seconds. Set to 0 to disable&#xA;    -k                                    Optional. Overwrite the PE headers&#xA;    --method EXPORT_NAME, -m EXPORT_NAME  Optional. Method or function name to execute in case of DLL. If not provided, DllMain will be executed&#xA;    -w                                    Optional. Command line is passed to unmanaged DLL function in UNICODE format. (default is ANSI)&#xA;    --no-output, -no                      Optional. Do not try to obtain the output&#xA;    --alloc-console, -ac                  Optional. Allocate a console. This will spawn a new process&#xA;    --close-handles, -ch                  Optional. Close Pipe handles once finished. If PowerShell was already ran, this will break the output for PowerShell in the future&#xA;    --free-libraries, -fl                 Optional. Free all loaded DLLs&#xA;    /path/to/binary.exe                   Required. Full path to the windows EXE/DLL you wish you run inside Beacon&#xA;    ARG1 ARG2                             Optional. Parameters for the PE. Must be provided after the path&#xA;&#xA;    Example: noconsolation --local C:\windows\system32\windowspowershell\v1.0\powershell.exe $ExecutionContext.SessionState.LanguageMode&#xA;    Example: noconsolation /tmp/mimikatz.exe privilege::debug token::elevate exit&#xA;    Example: noconsolation --local C:\windows\system32\cmd.exe /c ipconfig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/octoberfest73&#34;&gt;Octoberfest7&lt;/a&gt; for &lt;a href=&#34;https://github.com/Octoberfest7/Inline-Execute-PE&#34;&gt;Inline-Execute-PE&lt;/a&gt; which was my inspiration for this project&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/TheRealWover&#34;&gt;TheWover&lt;/a&gt; for the PE load logic from &lt;a href=&#34;https://github.com/TheWover/donut&#34;&gt;donut&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/rad9800&#34;&gt;rad9800&lt;/a&gt; for his &lt;a href=&#34;https://github.com/rad9800/hwbp4mw&#34;&gt;HWBP engine&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>