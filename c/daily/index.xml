<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-07T01:35:15Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hepingood/mifare_classic</title>
    <updated>2022-08-07T01:35:15Z</updated>
    <id>tag:github.com,2022-08-07:/hepingood/mifare_classic</id>
    <link href="https://github.com/hepingood/mifare_classic" rel="alternate"></link>
    <summary type="html">&lt;p&gt;mifare classic full function driver&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/README.md&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/README_zh-Hans.md&#34;&gt; 简体中文&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/README_zh-Hant.md&#34;&gt;繁體中文&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/README_ja.md&#34;&gt;日本語&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/README_de.md&#34;&gt;Deutsch&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/README_ko.md&#34;&gt;한국어&lt;/a&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/doc/image/logo.png&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;LibDriver MIFARE_Classic&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/misra/README.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/misra-compliant-brightgreen.svg?sanitize=true&#34; alt=&#34;MISRA&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.libdriver.com/docs/mifare_classic/index.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/api-reference-blue.svg?sanitize=true&#34; alt=&#34;API&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-brightgreen.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;NXP Semiconductors has developed the MIFARE Classic EV1 contactless IC MF1S50yyX/V1 to be used in a contactless smart card according to ISO/IEC 14443 Type A.The MIFARE Classic EV1 with 1K memory MF1S50yyX/V1 IC is used in applications like public transport ticketing and can also be used for various other applications.MIFARE_Classic can be used in Public transportation, Electronic toll collection, School and campus cards and so on.&lt;/p&gt; &#xA;&lt;p&gt;LibDriver MIFARE_Classic is the full function driver of MIFARE_Classic launched by LibDriver.It provides the function of read block, write block, value increment, value decrement and so on. LibDriver is MISRA compliant.&lt;/p&gt; &#xA;&lt;h3&gt;Table of Contents&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/#Instruction&#34;&gt;Instruction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/#Install&#34;&gt;Install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/#Usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/#example-basic&#34;&gt;example basic&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/#Document&#34;&gt;Document&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/#Contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/#License&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hepingood/mifare_classic/master/#Contact-Us&#34;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Instruction&lt;/h3&gt; &#xA;&lt;p&gt;/src includes LibDriver MIFARE_Classic source files.&lt;/p&gt; &#xA;&lt;p&gt;/interface includes LibDriver MIFARE_Classic RF platform independent template。&lt;/p&gt; &#xA;&lt;p&gt;/test includes LibDriver MIFARE_Classic driver test code and this code can test the chip necessary function simply。&lt;/p&gt; &#xA;&lt;p&gt;/example includes LibDriver MIFARE_Classic sample code.&lt;/p&gt; &#xA;&lt;p&gt;/doc includes LibDriver MIFARE_Classic offline document.&lt;/p&gt; &#xA;&lt;p&gt;/datasheet includes MIFARE_Classic datasheet。&lt;/p&gt; &#xA;&lt;p&gt;/project includes the common Linux and MCU development board sample code. All projects use the shell script to debug the driver and the detail instruction can be found in each project&#39;s README.md.&lt;/p&gt; &#xA;&lt;h3&gt;Install&lt;/h3&gt; &#xA;&lt;p&gt;Reference /interface RF platform independent template and finish your platform RF driver.&lt;/p&gt; &#xA;&lt;p&gt;Add /src, /interface and /example to your project.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;h4&gt;example basic&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;uint8_t res;&#xA;mifare_classic_authentication_key_t key_type;&#xA;uint8_t key[6];&#xA;mifare_classic_type_t type; &#xA;uint8_t id[4];&#xA;uint8_t data[16];&#xA;&#xA;/* init */&#xA;res = mifare_classic_basic_init();&#xA;if (res != 0)&#xA;{&#xA;    return 1;&#xA;}&#xA;&#xA;...&#xA;    &#xA;/* search */&#xA;res = mifare_classic_basic_search(&amp;amp;type, id, 50);&#xA;if (res != 0)&#xA;{&#xA;    (void)mifare_classic_basic_deinit();&#xA;&#xA;    return 1;&#xA;}&#xA;&#xA;/* ouput the type */&#xA;if (type == MIFARE_CLASSIC_TYPE_S50)&#xA;{&#xA;    mifare_classic_interface_debug_print(&#34;mifare_classic: find S50 card.\n&#34;);&#xA;}&#xA;else if (type == MIFARE_CLASSIC_TYPE_S70)&#xA;{&#xA;    mifare_classic_interface_debug_print(&#34;mifare_classic: find S70 card.\n&#34;);&#xA;}&#xA;else&#xA;{&#xA;    mifare_classic_interface_debug_print(&#34;mifare_classic: invalid type.\n&#34;);&#xA;    (void)mifare_classic_basic_deinit();&#xA;&#xA;    return 1;&#xA;}&#xA;mifare_classic_interface_debug_print(&#34;mifare_classic: id is &#34;);&#xA;for (i = 0; i &amp;lt; 4; i++)&#xA;{&#xA;    mifare_classic_interface_debug_print(&#34;0x%02X &#34;, id[i]);&#xA;}&#xA;mifare_classic_interface_debug_print(&#34;\n&#34;);&#xA;&#xA;...&#xA;&#xA;key_type = MIFARE_CLASSIC_AUTHENTICATION_KEY_A;&#xA;key[0] = 0xFF;&#xA;key[1] = 0xFF;&#xA;key[2] = 0xFF;&#xA;key[3] = 0xFF;&#xA;key[4] = 0xFF;&#xA;key[5] = 0xFF;&#xA;&#xA;...&#xA;    &#xA;/* read */&#xA;res = mifare_classic_basic_read(1, data, key_type, key);&#xA;if (res != 0)&#xA;{&#xA;    (void)mifare_classic_basic_deinit();&#xA;&#xA;    return 1;&#xA;}&#xA;&#xA;...&#xA;&#xA;/* write */&#xA;res = mifare_classic_basic_write(1, data, key_type, key);&#xA;if (res != 0)&#xA;{&#xA;    (void)mifare_classic_basic_deinit();&#xA;&#xA;    return 1;&#xA;}&#xA;&#xA;...&#xA;&#xA;/* value init */&#xA;res = mifare_classic_basic_value_init(2, 2, 2, key_type, key);&#xA;if (res != 0)&#xA;{&#xA;    (void)mifare_classic_basic_deinit();&#xA;&#xA;    return 1;&#xA;}&#xA;&#xA;...&#xA;&#xA;/* write the value */&#xA;res = mifare_classic_basic_value_write(2, 100, 2, key_type, key);&#xA;if (res != 0)&#xA;{&#xA;    (void)mifare_classic_basic_deinit();&#xA;&#xA;    return 1;&#xA;}    &#xA;&#xA;...&#xA;&#xA;/* read the value */&#xA;res = mifare_classic_basic_value_read(2, &amp;amp;value, &amp;amp;addr, key_type, key);&#xA;if (res != 0)&#xA;{&#xA;    (void)mifare_classic_basic_deinit();&#xA;&#xA;    return 1;&#xA;}&#xA;&#xA;...&#xA;&#xA;/* increment the value */&#xA;res = mifare_classic_basic_value_increment(2, 10, key_type, key);&#xA;if (res != 0)&#xA;{&#xA;    (void)mifare_classic_basic_deinit();&#xA;&#xA;    return 1;&#xA;}&#xA;&#xA;...&#xA;&#xA;/* decrement the value */&#xA;res = mifare_classic_basic_value_decrement(2, 20, key_type, key);&#xA;if (res != 0)&#xA;{&#xA;    (void)mifare_classic_basic_deinit();&#xA;&#xA;    return 1;&#xA;}&#xA;&#xA;...&#xA;&#xA;(void)mifare_classic_basic_deinit();&#xA;&#xA;return 0;    &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Document&lt;/h3&gt; &#xA;&lt;p&gt;Online documents: &lt;a href=&#34;https://www.libdriver.com/docs/mifare_classic/index.html&#34;&gt;https://www.libdriver.com/docs/mifare_classic/index.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Offline documents: /doc/html/index.html&lt;/p&gt; &#xA;&lt;h3&gt;Contributing&lt;/h3&gt; &#xA;&lt;p&gt;Please sent an e-mail to &lt;a href=&#34;mailto:lishifenging@outlook.com&#34;&gt;lishifenging@outlook.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;License&lt;/h3&gt; &#xA;&lt;p&gt;Copyright (c) 2015 - present LibDriver All rights reserved&lt;/p&gt; &#xA;&lt;p&gt;The MIT License (MIT)&lt;/p&gt; &#xA;&lt;p&gt;Permission is hereby granted, free of charge, to any person obtaining a copy&lt;/p&gt; &#xA;&lt;p&gt;of this software and associated documentation files (the &#34;Software&#34;), to deal&lt;/p&gt; &#xA;&lt;p&gt;in the Software without restriction, including without limitation the rights&lt;/p&gt; &#xA;&lt;p&gt;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&lt;/p&gt; &#xA;&lt;p&gt;copies of the Software, and to permit persons to whom the Software is&lt;/p&gt; &#xA;&lt;p&gt;furnished to do so, subject to the following conditions:&lt;/p&gt; &#xA;&lt;p&gt;The above copyright notice and this permission notice shall be included in all&lt;/p&gt; &#xA;&lt;p&gt;copies or substantial portions of the Software.&lt;/p&gt; &#xA;&lt;p&gt;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&lt;/p&gt; &#xA;&lt;p&gt;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&lt;/p&gt; &#xA;&lt;p&gt;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&lt;/p&gt; &#xA;&lt;p&gt;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&lt;/p&gt; &#xA;&lt;p&gt;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&lt;/p&gt; &#xA;&lt;p&gt;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&lt;/p&gt; &#xA;&lt;p&gt;SOFTWARE.&lt;/p&gt; &#xA;&lt;h3&gt;Contact Us&lt;/h3&gt; &#xA;&lt;p&gt;Please sent an e-mail to &lt;a href=&#34;mailto:lishifenging@outlook.com&#34;&gt;lishifenging@outlook.com&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>veritas501/CVE-2022-34918</title>
    <updated>2022-08-07T01:35:15Z</updated>
    <id>tag:github.com,2022-08-07:/veritas501/CVE-2022-34918</id>
    <link href="https://github.com/veritas501/CVE-2022-34918" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CVE-2022-34918 netfilter nf_tables 本地提权 POC&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CVE-2022-34918 LPE POC&lt;/h1&gt; &#xA;&lt;p&gt;尝试结合了一下360提出的&lt;a href=&#34;https://vul.360.net/archives/391&#34;&gt;USMA&lt;/a&gt;利用思路，还不错。&lt;/p&gt; &#xA;&lt;p&gt;Chinese writeup: &lt;a href=&#34;https://tttang.com/archive/1693/&#34;&gt;https://tttang.com/archive/1693/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;!! &lt;strong&gt;For educational / research purposes only. Use at your own risk.&lt;/strong&gt; !!&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/veritas501/CVE-2022-34918/master/assets/lpe.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;参考&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/randorisec/CVE-2022-34918-LPE-PoC&#34;&gt;https://github.com/randorisec/CVE-2022-34918-LPE-PoC&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://randorisec.fr/crack-linux-firewall/&#34;&gt;https://randorisec.fr/crack-linux-firewall/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://starlabs.sg/blog/2022/06-io_uring-new-code-new-bugs-and-a-new-exploit-technique/&#34;&gt;https://starlabs.sg/blog/2022/06-io_uring-new-code-new-bugs-and-a-new-exploit-technique/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://vul.360.net/archives/391&#34;&gt;https://vul.360.net/archives/391&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>u-boot/u-boot</title>
    <updated>2022-08-07T01:35:15Z</updated>
    <id>tag:github.com,2022-08-07:/u-boot/u-boot</id>
    <link href="https://github.com/u-boot/u-boot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&#34;Das U-Boot&#34; Source Tree&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SPDX-License-Identifier: GPL-2.0+&lt;/h1&gt; &#xA;&lt;h1&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;(C) Copyright 2000 - 2013&lt;/h1&gt; &#xA;&lt;h1&gt;Wolfgang Denk, DENX Software Engineering, &lt;a href=&#34;mailto:wd@denx.de&#34;&gt;wd@denx.de&lt;/a&gt;.&lt;/h1&gt; &#xA;&lt;h1&gt;Summary:&lt;/h1&gt; &#xA;&lt;p&gt;This directory contains the source code for U-Boot, a boot loader for Embedded boards based on PowerPC, ARM, MIPS and several other processors, which can be installed in a boot ROM and used to initialize and test the hardware or to download and run application code.&lt;/p&gt; &#xA;&lt;p&gt;The development of U-Boot is closely related to Linux: some parts of the source code originate in the Linux source tree, we have some header files in common, and special provision has been made to support booting of Linux images.&lt;/p&gt; &#xA;&lt;p&gt;Some attention has been paid to make this software easily configurable and extendable. For instance, all monitor commands are implemented with the same call interface, so that it&#39;s very easy to add new commands. Also, instead of permanently adding rarely used code (for instance hardware test utilities) to the monitor, you can load and run it dynamically.&lt;/p&gt; &#xA;&lt;h1&gt;Status:&lt;/h1&gt; &#xA;&lt;p&gt;In general, all boards for which a configuration option exists in the Makefile have been tested to some extent and can be considered &#34;working&#34;. In fact, many of them are used in production systems.&lt;/p&gt; &#xA;&lt;p&gt;In case of problems see the CHANGELOG file to find out who contributed the specific port. In addition, there are various MAINTAINERS files scattered throughout the U-Boot source identifying the people or companies responsible for various boards and subsystems.&lt;/p&gt; &#xA;&lt;p&gt;Note: As of August, 2010, there is no longer a CHANGELOG file in the actual U-Boot source tree; however, it can be created dynamically from the Git log using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make CHANGELOG&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Where to get help:&lt;/h1&gt; &#xA;&lt;p&gt;In case you have questions about, problems with or contributions for U-Boot, you should send a message to the U-Boot mailing list at &lt;a href=&#34;mailto:u-boot@lists.denx.de&#34;&gt;u-boot@lists.denx.de&lt;/a&gt;. There is also an archive of previous traffic on the mailing list - please search the archive before asking FAQ&#39;s. Please see &lt;a href=&#34;https://lists.denx.de/pipermail/u-boot&#34;&gt;https://lists.denx.de/pipermail/u-boot&lt;/a&gt; and &lt;a href=&#34;https://marc.info/?l=u-boot&#34;&gt;https://marc.info/?l=u-boot&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Where to get source code:&lt;/h1&gt; &#xA;&lt;p&gt;The U-Boot source code is maintained in the Git repository at &lt;a href=&#34;https://source.denx.de/u-boot/u-boot.git&#34;&gt;https://source.denx.de/u-boot/u-boot.git&lt;/a&gt; ; you can browse it online at &lt;a href=&#34;https://source.denx.de/u-boot/u-boot&#34;&gt;https://source.denx.de/u-boot/u-boot&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &#34;Tags&#34; links on this page allow you to download tarballs of any version you might be interested in. Official releases are also available from the DENX file server through HTTPS or FTP. &lt;a href=&#34;https://ftp.denx.de/pub/u-boot/&#34;&gt;https://ftp.denx.de/pub/u-boot/&lt;/a&gt; &lt;a href=&#34;ftp://ftp.denx.de/pub/u-boot/&#34;&gt;ftp://ftp.denx.de/pub/u-boot/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Where we come from:&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;start from 8xxrom sources&lt;/li&gt; &#xA; &lt;li&gt;create PPCBoot project (&lt;a href=&#34;https://sourceforge.net/projects/ppcboot&#34;&gt;https://sourceforge.net/projects/ppcboot&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;clean up code&lt;/li&gt; &#xA; &lt;li&gt;make it easier to add custom boards&lt;/li&gt; &#xA; &lt;li&gt;make it possible to add other [PowerPC] CPUs&lt;/li&gt; &#xA; &lt;li&gt;extend functions, especially: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Provide extended interface to Linux boot loader&lt;/li&gt; &#xA;   &lt;li&gt;S-Record download&lt;/li&gt; &#xA;   &lt;li&gt;network boot&lt;/li&gt; &#xA;   &lt;li&gt;ATA disk / SCSI ... boot&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;create ARMBoot project (&lt;a href=&#34;https://sourceforge.net/projects/armboot&#34;&gt;https://sourceforge.net/projects/armboot&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;add other CPU families (starting with ARM)&lt;/li&gt; &#xA; &lt;li&gt;create U-Boot project (&lt;a href=&#34;https://sourceforge.net/projects/u-boot&#34;&gt;https://sourceforge.net/projects/u-boot&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;current project page: see &lt;a href=&#34;https://www.denx.de/wiki/U-Boot&#34;&gt;https://www.denx.de/wiki/U-Boot&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Names and Spelling:&lt;/h1&gt; &#xA;&lt;p&gt;The &#34;official&#34; name of this project is &#34;Das U-Boot&#34;. The spelling &#34;U-Boot&#34; shall be used in all written text (documentation, comments in source files etc.). Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;This is the README file for the U-Boot project.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;File names etc. shall be based on the string &#34;u-boot&#34;. Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;include/asm-ppc/u-boot.h&#xA;&#xA;#include &amp;lt;asm/u-boot.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Variable names, preprocessor constants etc. shall be either based on the string &#34;u_boot&#34; or on &#34;U_BOOT&#34;. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;U_BOOT_VERSION&#x9;&#x9;u_boot_logo&#xA;IH_OS_U_BOOT&#x9;&#x9;u_boot_hush_start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Versioning:&lt;/h1&gt; &#xA;&lt;p&gt;Starting with the release in October 2008, the names of the releases were changed from numerical release numbers without deeper meaning into a time stamp based numbering. Regular releases are identified by names consisting of the calendar year and month of the release date. Additional fields (if present) indicate release candidates or bug fix releases in &#34;stable&#34; maintenance trees.&lt;/p&gt; &#xA;&lt;p&gt;Examples: U-Boot v2009.11 - Release November 2009 U-Boot v2009.11.1 - Release 1 in version November 2009 stable tree U-Boot v2010.09-rc1 - Release candidate 1 for September 2010 release&lt;/p&gt; &#xA;&lt;h1&gt;Directory Hierarchy:&lt;/h1&gt; &#xA;&lt;p&gt;/arch Architecture-specific files /arc Files generic to ARC architecture /arm Files generic to ARM architecture /m68k Files generic to m68k architecture /microblaze Files generic to microblaze architecture /mips Files generic to MIPS architecture /nios2 Files generic to Altera NIOS2 architecture /powerpc Files generic to PowerPC architecture /riscv Files generic to RISC-V architecture /sandbox Files generic to HW-independent &#34;sandbox&#34; /sh Files generic to SH architecture /x86 Files generic to x86 architecture /xtensa Files generic to Xtensa architecture /api Machine/arch-independent API for external apps /board Board-dependent files /boot Support for images and booting /cmd U-Boot commands functions /common Misc architecture-independent functions /configs Board default configuration files /disk Code for disk drive partition handling /doc Documentation (a mix of ReST and READMEs) /drivers Device drivers /dts Makefile for building internal U-Boot fdt. /env Environment support /examples Example code for standalone applications, etc. /fs Filesystem code (cramfs, ext2, jffs2, etc.) /include Header Files /lib Library routines generic to all architectures /Licenses Various license files /net Networking code /post Power On Self Test /scripts Various build scripts and Makefiles /test Various unit test files /tools Tools to build and sign FIT images, etc.&lt;/p&gt; &#xA;&lt;h1&gt;Software Configuration:&lt;/h1&gt; &#xA;&lt;h2&gt;Selection of Processor Architecture and Board Type:&lt;/h2&gt; &#xA;&lt;p&gt;For all supported boards there are ready-to-use default configurations available; just type &#34;make &amp;lt;board_name&amp;gt;_defconfig&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Example: For a TQM823L module type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd u-boot&#xA;make TQM823L_defconfig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: If you&#39;re looking for the default configuration file for a board you&#39;re sure used to be there but is now missing, check the file doc/README.scrapyard for a list of no longer supported boards.&lt;/p&gt; &#xA;&lt;h2&gt;Sandbox Environment:&lt;/h2&gt; &#xA;&lt;p&gt;U-Boot can be built natively to run on a Linux host using the &#39;sandbox&#39; board. This allows feature development which is not board- or architecture- specific to be undertaken on a native platform. The sandbox is also used to run some of U-Boot&#39;s tests.&lt;/p&gt; &#xA;&lt;p&gt;See doc/arch/sandbox.rst for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Board Initialisation Flow:&lt;/h2&gt; &#xA;&lt;p&gt;This is the intended start-up flow for boards. This should apply for both SPL and U-Boot proper (i.e. they both follow the same rules).&lt;/p&gt; &#xA;&lt;p&gt;Note: &#34;SPL&#34; stands for &#34;Secondary Program Loader,&#34; which is explained in more detail later in this file.&lt;/p&gt; &#xA;&lt;p&gt;At present, SPL mostly uses a separate code path, but the function names and roles of each function are the same. Some boards or architectures may not conform to this. At least most ARM boards which use CONFIG_SPL_FRAMEWORK conform to this.&lt;/p&gt; &#xA;&lt;p&gt;Execution typically starts with an architecture-specific (and possibly CPU-specific) start.S file, such as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;- arch/arm/cpu/armv7/start.S&#xA;- arch/powerpc/cpu/mpc83xx/start.S&#xA;- arch/mips/cpu/start.S&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and so on. From there, three functions are called; the purpose and limitations of each of these functions are described below.&lt;/p&gt; &#xA;&lt;p&gt;lowlevel_init(): - purpose: essential init to permit execution to reach board_init_f() - no global_data or BSS - there is no stack (ARMv7 may have one but it will soon be removed) - must not set up SDRAM or use console - must only do the bare minimum to allow execution to continue to board_init_f() - this is almost never needed - return normally from this function&lt;/p&gt; &#xA;&lt;p&gt;board_init_f(): - purpose: set up the machine ready for running board_init_r(): i.e. SDRAM and serial UART - global_data is available - stack is in SRAM - BSS is not available, so you cannot use global/static variables, only stack variables and global_data&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Non-SPL-specific notes:&#xA;- dram_init() is called to set up DRAM. If already done in SPL this&#xA;&#x9;can do nothing&#xA;&#xA;SPL-specific notes:&#xA;- you can override the entire board_init_f() function with your own&#xA;&#x9;version as needed.&#xA;- preloader_console_init() can be called here in extremis&#xA;- should set up SDRAM, and anything needed to make the UART work&#xA;- there is no need to clear BSS, it will be done by crt0.S&#xA;- for specific scenarios on certain architectures an early BSS *can*&#xA;  be made available (via CONFIG_SPL_EARLY_BSS by moving the clearing&#xA;  of BSS prior to entering board_init_f()) but doing so is discouraged.&#xA;  Instead it is strongly recommended to architect any code changes&#xA;  or additions such to not depend on the availability of BSS during&#xA;  board_init_f() as indicated in other sections of this README to&#xA;  maintain compatibility and consistency across the entire code base.&#xA;- must return normally from this function (don&#39;t call board_init_r()&#xA;&#x9;directly)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here the BSS is cleared. For SPL, if CONFIG_SPL_STACK_R is defined, then at this point the stack and global_data are relocated to below CONFIG_SPL_STACK_R_ADDR. For non-SPL, U-Boot is relocated to run at the top of memory.&lt;/p&gt; &#xA;&lt;p&gt;board_init_r(): - purpose: main execution, common code - global_data is available - SDRAM is available - BSS is available, all static/global variables can be used - execution eventually continues to main_loop()&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Non-SPL-specific notes:&#xA;- U-Boot is relocated to the top of memory and is now running from&#xA;&#x9;there.&#xA;&#xA;SPL-specific notes:&#xA;- stack is optionally in SDRAM, if CONFIG_SPL_STACK_R is defined and&#xA;&#x9;CONFIG_SYS_FSL_HAS_CCI400&#xA;&#xA;&#x9;Defined For SoC that has cache coherent interconnect&#xA;&#x9;CCN-400&#xA;&#xA;&#x9;CONFIG_SYS_FSL_HAS_CCN504&#xA;&#xA;&#x9;Defined for SoC that has cache coherent interconnect CCN-504&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following options need to be configured:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;CPU Type: Define exactly one, e.g. CONFIG_MPC85XX.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Board Type: Define exactly one, e.g. CONFIG_MPC8540ADS.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;85xx CPU Options: CONFIG_SYS_PPC64&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Specifies that the core is a 64-bit PowerPC implementation (implements&#xA;  the &#34;64&#34; category of the Power ISA). This is necessary for ePAPR&#xA;  compliance, among other possible reasons.&#xA;&#xA;  CONFIG_SYS_FSL_TBCLK_DIV&#xA;&#xA;  Defines the core time base clock divider ratio compared to the&#xA;  system clock.  On most PQ3 devices this is 8, on newer QorIQ&#xA;  devices it can be 16 or 32.  The ratio varies from SoC to Soc.&#xA;&#xA;  CONFIG_SYS_FSL_PCIE_COMPAT&#xA;&#xA;  Defines the string to utilize when trying to match PCIe device&#xA;  tree nodes for the given platform.&#xA;&#xA;  CONFIG_SYS_FSL_ERRATUM_A004510&#xA;&#xA;  Enables a workaround for erratum A004510.  If set,&#xA;  then CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV and&#xA;  CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY must be set.&#xA;&#xA;  CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV&#xA;  CONFIG_SYS_FSL_ERRATUM_A004510_SVR_REV2 (optional)&#xA;&#xA;  Defines one or two SoC revisions (low 8 bits of SVR)&#xA;  for which the A004510 workaround should be applied.&#xA;&#xA;  The rest of SVR is either not relevant to the decision&#xA;  of whether the erratum is present (e.g. p2040 versus&#xA;  p2041) or is implied by the build target, which controls&#xA;  whether CONFIG_SYS_FSL_ERRATUM_A004510 is set.&#xA;&#xA;  See Freescale App Note 4493 for more information about&#xA;  this erratum.&#xA;&#xA;  CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY&#xA;&#xA;  This is the value to write into CCSR offset 0x18600&#xA;  according to the A004510 workaround.&#xA;&#xA;  CONFIG_SYS_FSL_DSP_DDR_ADDR&#xA;  This value denotes start offset of DDR memory which is&#xA;  connected exclusively to the DSP cores.&#xA;&#xA;  CONFIG_SYS_FSL_DSP_M2_RAM_ADDR&#xA;  This value denotes start offset of M2 memory&#xA;  which is directly connected to the DSP core.&#xA;&#xA;  CONFIG_SYS_FSL_DSP_M3_RAM_ADDR&#xA;  This value denotes start offset of M3 memory which is directly&#xA;  connected to the DSP core.&#xA;&#xA;  CONFIG_SYS_FSL_DSP_CCSRBAR_DEFAULT&#xA;  This value denotes start offset of DSP CCSR space.&#xA;&#xA;  CONFIG_SYS_FSL_SINGLE_SOURCE_CLK&#xA;  Single Source Clock is clocking mode present in some of FSL SoC&#39;s.&#xA;  In this mode, a single differential clock is used to supply&#xA;  clocks to the sysclock, ddrclock and usbclock.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Generic CPU options: CONFIG_SYS_BIG_ENDIAN, CONFIG_SYS_LITTLE_ENDIAN&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Defines the endianess of the CPU. Implementation of those&#xA;  values is arch specific.&#xA;&#xA;  CONFIG_SYS_FSL_DDR&#xA;  Freescale DDR driver in use. This type of DDR controller is&#xA;  found in mpc83xx, mpc85xx as well as some ARM core SoCs.&#xA;&#xA;  CONFIG_SYS_FSL_DDR_ADDR&#xA;  Freescale DDR memory-mapped register base.&#xA;&#xA;  CONFIG_SYS_FSL_DDRC_GEN1&#xA;  Freescale DDR1 controller.&#xA;&#xA;  CONFIG_SYS_FSL_DDRC_GEN2&#xA;  Freescale DDR2 controller.&#xA;&#xA;  CONFIG_SYS_FSL_DDRC_GEN3&#xA;  Freescale DDR3 controller.&#xA;&#xA;  CONFIG_SYS_FSL_DDRC_GEN4&#xA;  Freescale DDR4 controller.&#xA;&#xA;  CONFIG_SYS_FSL_DDRC_ARM_GEN3&#xA;  Freescale DDR3 controller for ARM-based SoCs.&#xA;&#xA;  CONFIG_SYS_FSL_DDR1&#xA;  Board config to use DDR1. It can be enabled for SoCs with&#xA;  Freescale DDR1 or DDR2 controllers, depending on the board&#xA;  implemetation.&#xA;&#xA;  CONFIG_SYS_FSL_DDR2&#xA;  Board config to use DDR2. It can be enabled for SoCs with&#xA;  Freescale DDR2 or DDR3 controllers, depending on the board&#xA;  implementation.&#xA;&#xA;  CONFIG_SYS_FSL_DDR3&#xA;  Board config to use DDR3. It can be enabled for SoCs with&#xA;  Freescale DDR3 or DDR3L controllers.&#xA;&#xA;  CONFIG_SYS_FSL_DDR3L&#xA;  Board config to use DDR3L. It can be enabled for SoCs with&#xA;  DDR3L controllers.&#xA;&#xA;  CONFIG_SYS_FSL_IFC_CLK_DIV&#xA;  Defines divider of platform clock(clock input to IFC controller).&#xA;&#xA;  CONFIG_SYS_FSL_LBC_CLK_DIV&#xA;  Defines divider of platform clock(clock input to eLBC controller).&#xA;&#xA;  CONFIG_SYS_FSL_DDR_BE&#xA;  Defines the DDR controller register space as Big Endian&#xA;&#xA;  CONFIG_SYS_FSL_DDR_LE&#xA;  Defines the DDR controller register space as Little Endian&#xA;&#xA;  CONFIG_SYS_FSL_DDR_SDRAM_BASE_PHY&#xA;  Physical address from the view of DDR controllers. It is the&#xA;  same as CONFIG_SYS_DDR_SDRAM_BASE for  all Power SoCs. But&#xA;  it could be different for ARM SoCs.&#xA;&#xA;  CONFIG_SYS_FSL_DDR_MAIN_NUM_CTRLS&#xA;  Number of controllers used as main memory.&#xA;&#xA;  CONFIG_SYS_FSL_OTHER_DDR_NUM_CTRLS&#xA;  Number of controllers used for other than main memory.&#xA;&#xA;  CONFIG_SYS_FSL_SEC_BE&#xA;  Defines the SEC controller register space as Big Endian&#xA;&#xA;  CONFIG_SYS_FSL_SEC_LE&#xA;  Defines the SEC controller register space as Little Endian&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MIPS CPU options: CONFIG_XWAY_SWAP_BYTES&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Enable compilation of tools/xway-swap-bytes needed for Lantiq&#xA;  XWAY SoCs for booting from NOR flash. The U-Boot image needs to&#xA;  be swapped if a flash programmer is used.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;ARM options: CONFIG_SYS_EXCEPTION_VECTORS_HIGH&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Select high exception vectors of the ARM core, e.g., do not&#xA;  clear the V bit of the c1 register of CP15.&#xA;&#xA;  COUNTER_FREQUENCY&#xA;  Generic timer clock source frequency.&#xA;&#xA;  COUNTER_FREQUENCY_REAL&#xA;  Generic timer clock source frequency if the real clock is&#xA;  different from COUNTER_FREQUENCY, and can only be determined&#xA;  at run time.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Tegra SoC options: CONFIG_TEGRA_SUPPORT_NON_SECURE&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Support executing U-Boot in non-secure (NS) mode. Certain&#xA;  impossible actions will be skipped if the CPU is in NS mode,&#xA;  such as ARM architectural timer initialization.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Linux Kernel Interface: CONFIG_MEMSIZE_IN_BYTES [relevant for MIPS only]&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  When transferring memsize parameter to Linux, some versions&#xA;  expect it to be in bytes, others in MB.&#xA;  Define CONFIG_MEMSIZE_IN_BYTES to make it in bytes.&#xA;&#xA;  CONFIG_OF_LIBFDT&#xA;&#xA;  New kernel versions are expecting firmware settings to be&#xA;  passed using flattened device trees (based on open firmware&#xA;  concepts).&#xA;&#xA;  CONFIG_OF_LIBFDT&#xA;   * New libfdt-based support&#xA;   * Adds the &#34;fdt&#34; command&#xA;   * The bootm command automatically updates the fdt&#xA;&#xA;  OF_TBCLK - The timebase frequency.&#xA;&#xA;  boards with QUICC Engines require OF_QE to set UCC MAC&#xA;  addresses&#xA;&#xA;  CONFIG_OF_IDE_FIXUP&#xA;&#xA;  U-Boot can detect if an IDE device is present or not.&#xA;  If not, and this new config option is activated, U-Boot&#xA;  removes the ATA node from the DTS before booting Linux,&#xA;  so the Linux IDE driver does not probe the device and&#xA;  crash. This is needed for buggy hardware (uc101) where&#xA;  no pull down resistor is connected to the signal IDE5V_DD7.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;vxWorks boot parameters:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  bootvx constructs a valid bootline using the following&#xA;  environments variables: bootdev, bootfile, ipaddr, netmask,&#xA;  serverip, gatewayip, hostname, othbootargs.&#xA;  It loads the vxWorks image pointed bootfile.&#xA;&#xA;  Note: If a &#34;bootargs&#34; environment is defined, it will override&#xA;  the defaults discussed just above.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Cache Configuration for ARM: CONFIG_SYS_L2_PL310 - Enable support for ARM PL310 L2 cache controller CONFIG_SYS_PL310_BASE - Physical base address of PL310 controller register space&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Serial Ports: CONFIG_PL011_CLOCK&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  If you have Amba PrimeCell PL011 UARTs, set this variable to&#xA;  the clock speed of the UARTs.&#xA;&#xA;  CONFIG_PL01x_PORTS&#xA;&#xA;  If you have Amba PrimeCell PL010 or PL011 UARTs on your board,&#xA;  define this to a list of base addresses for each (supported)&#xA;  port. See e.g. include/configs/versatile.h&#xA;&#xA;  CONFIG_SERIAL_HW_FLOW_CONTROL&#xA;&#xA;  Define this variable to enable hw flow control in serial driver.&#xA;  Current user of this option is drivers/serial/nsl16550.c driver&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Serial Download Echo Mode: CONFIG_LOADS_ECHO If defined to 1, all characters received during a serial download (using the &#34;loads&#34; command) are echoed back. This might be needed by some terminal emulations (like &#34;cu&#34;), but may as well just take time on others. This setting #define&#39;s the initial value of the &#34;loads_echo&#34; environment variable.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Removal of commands If no commands are needed to boot, you can disable CONFIG_CMDLINE to remove them. In this case, the command line will not be available, and when U-Boot wants to execute the boot command (on start-up) it will call board_run_command() instead. This can reduce image size significantly for very simple boot procedures.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Regular expression support: CONFIG_REGEX If this variable is defined, U-Boot is linked against the SLRE (Super Light Regular Expression) library, which adds regex support to some commands, as for example &#34;env grep&#34; and &#34;setexpr&#34;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Watchdog: CONFIG_SYS_WATCHDOG_FREQ Some platforms automatically call WATCHDOG_RESET() from the timer interrupt handler every CONFIG_SYS_WATCHDOG_FREQ interrupts. If not set by the board configuration file, a default of CONFIG_SYS_HZ/2 (i.e. 500) is used. Setting CONFIG_SYS_WATCHDOG_FREQ to 0 disables calling WATCHDOG_RESET() from the timer interrupt.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Real-Time Clock:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  When CONFIG_CMD_DATE is selected, the type of the RTC&#xA;  has to be selected, too. Define exactly one of the&#xA;  following options:&#xA;&#xA;  CONFIG_RTC_PCF8563&#x9;- use Philips PCF8563 RTC&#xA;  CONFIG_RTC_MC13XXX&#x9;- use MC13783 or MC13892 RTC&#xA;  CONFIG_RTC_MC146818&#x9;- use MC146818 RTC&#xA;  CONFIG_RTC_DS1307&#x9;- use Maxim, Inc. DS1307 RTC&#xA;  CONFIG_RTC_DS1337&#x9;- use Maxim, Inc. DS1337 RTC&#xA;  CONFIG_RTC_DS1338&#x9;- use Maxim, Inc. DS1338 RTC&#xA;  CONFIG_RTC_DS1339&#x9;- use Maxim, Inc. DS1339 RTC&#xA;  CONFIG_RTC_DS164x&#x9;- use Dallas DS164x RTC&#xA;  CONFIG_RTC_ISL1208&#x9;- use Intersil ISL1208 RTC&#xA;  CONFIG_RTC_MAX6900&#x9;- use Maxim, Inc. MAX6900 RTC&#xA;  CONFIG_RTC_DS1337_NOOSC&#x9;- Turn off the OSC output for DS1337&#xA;  CONFIG_SYS_RV3029_TCR&#x9;- enable trickle charger on&#xA;  &#x9;&#x9;&#x9;  RV3029 RTC.&#xA;&#xA;  Note that if the RTC uses I2C, then the I2C interface&#xA;  must also be configured. See I2C Support, below.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;GPIO Support: CONFIG_PCA953X - use NXP&#39;s PCA953X series I2C GPIO&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  The CONFIG_SYS_I2C_PCA953X_WIDTH option specifies a list of&#xA;  chip-ngpio pairs that tell the PCA953X driver the number of&#xA;  pins supported by a particular chip.&#xA;&#xA;  Note that if the GPIO device uses I2C, then the I2C interface&#xA;  must also be configured. See I2C Support, below.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;I/O tracing: When CONFIG_IO_TRACE is selected, U-Boot intercepts all I/O accesses and can checksum them or write a list of them out to memory. See the &#39;iotrace&#39; command for details. This is useful for testing device drivers since it can confirm that the driver behaves the same way before and after a code change. Currently this is supported on sandbox and arm. To add support for your architecture, add &#39;#include &amp;lt;iotrace.h&amp;gt;&#39; to the bottom of arch/&#xA;   &lt;arch&gt;&#xA;    /include/asm/io.h and test.&#xA;   &lt;/arch&gt;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Example output from the &#39;iotrace stats&#39; command is below.&#xA;  Note that if the trace buffer is exhausted, the checksum will&#xA;  still continue to operate.&#xA;&#xA;  &#x9;iotrace is enabled&#xA;  &#x9;Start:  10000000&#x9;(buffer start address)&#xA;  &#x9;Size:   00010000&#x9;(buffer size)&#xA;  &#x9;Offset: 00000120&#x9;(current buffer offset)&#xA;  &#x9;Output: 10000120&#x9;(start + offset)&#xA;  &#x9;Count:  00000018&#x9;(number of trace records)&#xA;  &#x9;CRC32:  9526fb66&#x9;(CRC32 of all trace records)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Timestamp Support:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  When CONFIG_TIMESTAMP is selected, the timestamp&#xA;  (date and time) of an image is printed by image&#xA;  commands like bootm or iminfo. This option is&#xA;  automatically enabled when you select CONFIG_CMD_DATE .&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Partition Labels (disklabels) Supported: Zero or more of the following: CONFIG_MAC_PARTITION Apple&#39;s MacOS partition table. CONFIG_ISO_PARTITION ISO partition table, used on CDROM etc. CONFIG_EFI_PARTITION GPT partition table, common when EFI is the bootloader. Note 2TB partition limit; see disk/part_efi.c CONFIG_SCSI) you must configure support for at least one non-MTD partition type as well.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NETWORK Support (PCI): CONFIG_E1000_SPI Utility code for direct access to the SPI bus on Intel 8257x. This does not do anything useful unless you set at least one of CONFIG_CMD_E1000 or CONFIG_E1000_SPI_GENERIC.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  CONFIG_NATSEMI&#xA;  Support for National dp83815 chips.&#xA;&#xA;  CONFIG_NS8382X&#xA;  Support for National dp8382[01] gigabit chips.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;NETWORK Support (other): CONFIG_CALXEDA_XGMAC Support for the Calxeda XGMAC device&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  CONFIG_LAN91C96&#xA;  Support for SMSC&#39;s LAN91C96 chips.&#xA;&#xA;  &#x9;CONFIG_LAN91C96_USE_32_BIT&#xA;  &#x9;Define this to enable 32 bit addressing&#xA;&#xA;  CONFIG_SMC91111&#xA;  Support for SMSC&#39;s LAN91C111 chip&#xA;&#xA;  &#x9;CONFIG_SMC91111_BASE&#xA;  &#x9;Define this to hold the physical address&#xA;  &#x9;of the device (I/O space)&#xA;&#xA;  &#x9;CONFIG_SMC_USE_32_BIT&#xA;  &#x9;Define this if data bus is 32 bits&#xA;&#xA;  &#x9;CONFIG_SMC_USE_IOFUNCS&#xA;  &#x9;Define this to use i/o functions instead of macros&#xA;  &#x9;(some hardware wont work with macros)&#xA;&#xA;  &#x9;CONFIG_SYS_DAVINCI_EMAC_PHY_COUNT&#xA;  &#x9;Define this if you have more then 3 PHYs.&#xA;&#xA;  CONFIG_FTGMAC100&#xA;  Support for Faraday&#39;s FTGMAC100 Gigabit SoC Ethernet&#xA;&#xA;  &#x9;CONFIG_FTGMAC100_EGIGA&#xA;  &#x9;Define this to use GE link update with gigabit PHY.&#xA;  &#x9;Define this if FTGMAC100 is connected to gigabit PHY.&#xA;  &#x9;If your system has 10/100 PHY only, it might not occur&#xA;  &#x9;wrong behavior. Because PHY usually return timeout or&#xA;  &#x9;useless data when polling gigabit status and gigabit&#xA;  &#x9;control registers. This behavior won&#39;t affect the&#xA;  &#x9;correctnessof 10/100 link speed update.&#xA;&#xA;  CONFIG_SH_ETHER&#xA;  Support for Renesas on-chip Ethernet controller&#xA;&#xA;  &#x9;CONFIG_SH_ETHER_USE_PORT&#xA;  &#x9;Define the number of ports to be used&#xA;&#xA;  &#x9;CONFIG_SH_ETHER_PHY_ADDR&#xA;  &#x9;Define the ETH PHY&#39;s address&#xA;&#xA;  &#x9;CONFIG_SH_ETHER_CACHE_WRITEBACK&#xA;  &#x9;If this option is set, the driver enables cache flush.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;TPM Support: CONFIG_TPM Support TPM devices.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  CONFIG_TPM_TIS_INFINEON&#xA;  Support for Infineon i2c bus TPM devices. Only one device&#xA;  per system is supported at this time.&#xA;&#xA;  &#x9;CONFIG_TPM_TIS_I2C_BURST_LIMITATION&#xA;  &#x9;Define the burst count bytes upper limit&#xA;&#xA;  CONFIG_TPM_ST33ZP24&#xA;  Support for STMicroelectronics TPM devices. Requires DM_TPM support.&#xA;&#xA;  &#x9;CONFIG_TPM_ST33ZP24_I2C&#xA;  &#x9;Support for STMicroelectronics ST33ZP24 I2C devices.&#xA;  &#x9;Requires TPM_ST33ZP24 and I2C.&#xA;&#xA;  &#x9;CONFIG_TPM_ST33ZP24_SPI&#xA;  &#x9;Support for STMicroelectronics ST33ZP24 SPI devices.&#xA;  &#x9;Requires TPM_ST33ZP24 and SPI.&#xA;&#xA;  CONFIG_TPM_ATMEL_TWI&#xA;  Support for Atmel TWI TPM device. Requires I2C support.&#xA;&#xA;  CONFIG_TPM_TIS_LPC&#xA;  Support for generic parallel port TPM devices. Only one device&#xA;  per system is supported at this time.&#xA;&#xA;  &#x9;CONFIG_TPM_TIS_BASE_ADDRESS&#xA;  &#x9;Base address where the generic TPM device is mapped&#xA;  &#x9;to. Contemporary x86 systems usually map it at&#xA;  &#x9;0xfed40000.&#xA;&#xA;  CONFIG_TPM&#xA;  Define this to enable the TPM support library which provides&#xA;  functional interfaces to some TPM commands.&#xA;  Requires support for a TPM device.&#xA;&#xA;  CONFIG_TPM_AUTH_SESSIONS&#xA;  Define this to enable authorized functions in the TPM library.&#xA;  Requires CONFIG_TPM and CONFIG_SHA1.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;USB Support: At the moment only the UHCI host controller is supported (PIP405, MIP405); define CONFIG_USB_UHCI to enable it. define CONFIG_USB_KEYBOARD to enable the USB Keyboard and define CONFIG_USB_STORAGE to enable the USB storage devices. Note: Supported are USB Keyboards and USB Floppy drives (TEAC FD-05PUB).&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  CONFIG_USB_DWC2_REG_ADDR the physical CPU address of the DWC2&#xA;  HW module registers.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;USB Device: Define the below if you wish to use the USB console. Once firmware is rebuilt from a serial console issue the command &#34;setenv stdin usbtty; setenv stdout usbtty&#34; and attach your USB cable. The Unix command &#34;dmesg&#34; should print it has found a new device. The environment variable usbtty can be set to gserial or cdc_acm to enable your device to appear to a USB host as a Linux gserial device or a Common Device Class Abstract Control Model serial device. If you select usbtty = gserial you should be able to enumerate a Linux host by # modprobe usbserial vendor=0xVendorID product=0xProductID else if using cdc_acm, simply setting the environment variable usbtty to be cdc_acm should suffice. The following might be defined in YourBoardName.h&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  &#x9;CONFIG_USB_DEVICE&#xA;  &#x9;Define this to build a UDC device&#xA;&#xA;  &#x9;CONFIG_USB_TTY&#xA;  &#x9;Define this to have a tty type of device available to&#xA;  &#x9;talk to the UDC device&#xA;&#xA;  &#x9;CONFIG_USBD_HS&#xA;  &#x9;Define this to enable the high speed support for usb&#xA;  &#x9;device and usbtty. If this feature is enabled, a routine&#xA;  &#x9;int is_usbd_high_speed(void)&#xA;  &#x9;also needs to be defined by the driver to dynamically poll&#xA;  &#x9;whether the enumeration has succeded at high speed or full&#xA;  &#x9;speed.&#xA;&#xA;  If you have a USB-IF assigned VendorID then you may wish to&#xA;  define your own vendor specific values either in BoardName.h&#xA;  or directly in usbd_vendor_info.h. If you don&#39;t define&#xA;  CONFIG_USBD_MANUFACTURER, CONFIG_USBD_PRODUCT_NAME,&#xA;  CONFIG_USBD_VENDORID and CONFIG_USBD_PRODUCTID, then U-Boot&#xA;  should pretend to be a Linux device to it&#39;s target host.&#xA;&#xA;  &#x9;CONFIG_USBD_MANUFACTURER&#xA;  &#x9;Define this string as the name of your company for&#xA;  &#x9;- CONFIG_USBD_MANUFACTURER &#34;my company&#34;&#xA;&#xA;  &#x9;CONFIG_USBD_PRODUCT_NAME&#xA;  &#x9;Define this string as the name of your product&#xA;  &#x9;- CONFIG_USBD_PRODUCT_NAME &#34;acme usb device&#34;&#xA;&#xA;  &#x9;CONFIG_USBD_VENDORID&#xA;  &#x9;Define this as your assigned Vendor ID from the USB&#xA;  &#x9;Implementors Forum. This *must* be a genuine Vendor ID&#xA;  &#x9;to avoid polluting the USB namespace.&#xA;  &#x9;- CONFIG_USBD_VENDORID 0xFFFF&#xA;&#xA;  &#x9;CONFIG_USBD_PRODUCTID&#xA;  &#x9;Define this as the unique Product ID&#xA;  &#x9;for your device&#xA;  &#x9;- CONFIG_USBD_PRODUCTID 0xFFFF&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;ULPI Layer Support: The ULPI (UTMI Low Pin (count) Interface) PHYs are supported via the generic ULPI layer. The generic layer accesses the ULPI PHY via the platform viewport, so you need both the genric layer and the viewport enabled. Currently only Chipidea/ARC based viewport is supported. To enable the ULPI layer support, define CONFIG_USB_ULPI and CONFIG_USB_ULPI_VIEWPORT in your board configuration file. If your ULPI phy needs a different reference clock than the standard 24 MHz then you have to define CONFIG_ULPI_REF_CLK to the appropriate value in Hz.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MMC Support: CONFIG_SH_MMCIF Support for Renesas on-chip MMCIF controller&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  &#x9;CONFIG_SH_MMCIF_ADDR&#xA;  &#x9;Define the base address of MMCIF registers&#xA;&#xA;  &#x9;CONFIG_SH_MMCIF_CLK&#xA;  &#x9;Define the clock frequency for MMCIF&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;USB Device Firmware Update (DFU) class support: CONFIG_DFU_OVER_USB This enables the USB portion of the DFU USB class&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  CONFIG_DFU_NAND&#xA;  This enables support for exposing NAND devices via DFU.&#xA;&#xA;  CONFIG_DFU_RAM&#xA;  This enables support for exposing RAM via DFU.&#xA;  Note: DFU spec refer to non-volatile memory usage, but&#xA;  allow usages beyond the scope of spec - here RAM usage,&#xA;  one that would help mostly the developer.&#xA;&#xA;  CONFIG_SYS_DFU_DATA_BUF_SIZE&#xA;  Dfu transfer uses a buffer before writing data to the&#xA;  raw storage device. Make the size (in bytes) of this buffer&#xA;  configurable. The size of this buffer is also configurable&#xA;  through the &#34;dfu_bufsiz&#34; environment variable.&#xA;&#xA;  CONFIG_SYS_DFU_MAX_FILE_SIZE&#xA;  When updating files rather than the raw storage device,&#xA;  we use a static buffer to copy the file into and then write&#xA;  the buffer once we&#39;ve been given the whole file.  Define&#xA;  this to the maximum filesize (in bytes) for the buffer.&#xA;  Default is 4 MiB if undefined.&#xA;&#xA;  DFU_DEFAULT_POLL_TIMEOUT&#xA;  Poll timeout [ms], is the timeout a device can send to the&#xA;  host. The host must wait for this timeout before sending&#xA;  a subsequent DFU_GET_STATUS request to the device.&#xA;&#xA;  DFU_MANIFEST_POLL_TIMEOUT&#xA;  Poll timeout [ms], which the device sends to the host when&#xA;  entering dfuMANIFEST state. Host waits this timeout, before&#xA;  sending again an USB request to the device.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Journaling Flash filesystem support: CONFIG_SYS_JFFS2_FIRST_SECTOR, CONFIG_SYS_JFFS2_FIRST_BANK, CONFIG_SYS_JFFS2_NUM_BANKS Define these for a default partition on a NOR device&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Keyboard Support: See Kconfig help for available keyboard drivers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;LCD Support: CONFIG_LCD&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Define this to enable LCD support (for output to LCD&#xA;  display); also select one of the supported displays&#xA;  by defining one of these:&#xA;&#xA;  CONFIG_NEC_NL6448AC33:&#xA;&#xA;  &#x9;NEC NL6448AC33-18. Active, color, single scan.&#xA;&#xA;  CONFIG_NEC_NL6448BC20&#xA;&#xA;  &#x9;NEC NL6448BC20-08. 6.5&#34;, 640x480.&#xA;  &#x9;Active, color, single scan.&#xA;&#xA;  CONFIG_NEC_NL6448BC33_54&#xA;&#xA;  &#x9;NEC NL6448BC33-54. 10.4&#34;, 640x480.&#xA;  &#x9;Active, color, single scan.&#xA;&#xA;  CONFIG_SHARP_16x9&#xA;&#xA;  &#x9;Sharp 320x240. Active, color, single scan.&#xA;  &#x9;It isn&#39;t 16x9, and I am not sure what it is.&#xA;&#xA;  CONFIG_SHARP_LQ64D341&#xA;&#xA;  &#x9;Sharp LQ64D341 display, 640x480.&#xA;  &#x9;Active, color, single scan.&#xA;&#xA;  CONFIG_HLD1045&#xA;&#xA;  &#x9;HLD1045 display, 640x480.&#xA;  &#x9;Active, color, single scan.&#xA;&#xA;  CONFIG_OPTREX_BW&#xA;&#xA;  &#x9;Optrex&#x9; CBL50840-2 NF-FW 99 22 M5&#xA;  &#x9;or&#xA;  &#x9;Hitachi&#x9; LMG6912RPFC-00T&#xA;  &#x9;or&#xA;  &#x9;Hitachi&#x9; SP14Q002&#xA;&#xA;  &#x9;320x240. Black &amp;amp; white.&#xA;&#xA;  CONFIG_LCD_ALIGNMENT&#xA;&#xA;  Normally the LCD is page-aligned (typically 4KB). If this is&#xA;  defined then the LCD will be aligned to this value instead.&#xA;  For ARM it is sometimes useful to use MMU_SECTION_SIZE&#xA;  here, since it is cheaper to change data cache settings on&#xA;  a per-section basis.&#xA;&#xA;&#xA;  CONFIG_LCD_ROTATION&#xA;&#xA;  Sometimes, for example if the display is mounted in portrait&#xA;  mode or even if it&#39;s mounted landscape but rotated by 180degree,&#xA;  we need to rotate our content of the display relative to the&#xA;  framebuffer, so that user can read the messages which are&#xA;  printed out.&#xA;  Once CONFIG_LCD_ROTATION is defined, the lcd_console will be&#xA;  initialized with a given rotation from &#34;vl_rot&#34; out of&#xA;  &#34;vidinfo_t&#34; which is provided by the board specific code.&#xA;  The value for vl_rot is coded as following (matching to&#xA;  fbcon=rotate:&amp;lt;n&amp;gt; linux-kernel commandline):&#xA;  0 = no rotation respectively 0 degree&#xA;  1 = 90 degree rotation&#xA;  2 = 180 degree rotation&#xA;  3 = 270 degree rotation&#xA;&#xA;  If CONFIG_LCD_ROTATION is not defined, the console will be&#xA;  initialized with 0degree rotation.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MII/PHY support: CONFIG_PHY_CLOCK_FREQ (ppc4xx)&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  The clock frequency of the MII bus&#xA;&#xA;  CONFIG_PHY_CMD_DELAY (ppc4xx)&#xA;&#xA;  Some PHY like Intel LXT971A need extra delay after&#xA;  command issued before MII status register can be read&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;IP address: CONFIG_IPADDR&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Define a default value for the IP address to use for&#xA;  the default Ethernet interface, in case this is not&#xA;  determined through e.g. bootp.&#xA;  (Environment variable &#34;ipaddr&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Server IP address: CONFIG_SERVERIP&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Defines a default value for the IP address of a TFTP&#xA;  server to contact when using the &#34;tftboot&#34; command.&#xA;  (Environment variable &#34;serverip&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Gateway IP address: CONFIG_GATEWAYIP&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Defines a default value for the IP address of the&#xA;  default router where packets to other networks are&#xA;  sent to.&#xA;  (Environment variable &#34;gatewayip&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Subnet mask: CONFIG_NETMASK&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Defines a default value for the subnet mask (or&#xA;  routing prefix) which is used to determine if an IP&#xA;  address belongs to the local subnet or needs to be&#xA;  forwarded through a router.&#xA;  (Environment variable &#34;netmask&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;BOOTP Recovery Mode: CONFIG_BOOTP_RANDOM_DELAY&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  If you have many targets in a network that try to&#xA;  boot using BOOTP, you may want to avoid that all&#xA;  systems send out BOOTP requests at precisely the same&#xA;  moment (which would happen for instance at recovery&#xA;  from a power failure, when all systems will try to&#xA;  boot, thus flooding the BOOTP server. Defining&#xA;  CONFIG_BOOTP_RANDOM_DELAY causes a random delay to be&#xA;  inserted before sending out BOOTP requests. The&#xA;  following delays are inserted then:&#xA;&#xA;  1st BOOTP request:&#x9;delay 0 ... 1 sec&#xA;  2nd BOOTP request:&#x9;delay 0 ... 2 sec&#xA;  3rd BOOTP request:&#x9;delay 0 ... 4 sec&#xA;  4th and following&#xA;  BOOTP requests:&#x9;&#x9;delay 0 ... 8 sec&#xA;&#xA;  CONFIG_BOOTP_ID_CACHE_SIZE&#xA;&#xA;  BOOTP packets are uniquely identified using a 32-bit ID. The&#xA;  server will copy the ID from client requests to responses and&#xA;  U-Boot will use this to determine if it is the destination of&#xA;  an incoming response. Some servers will check that addresses&#xA;  aren&#39;t in use before handing them out (usually using an ARP&#xA;  ping) and therefore take up to a few hundred milliseconds to&#xA;  respond. Network congestion may also influence the time it&#xA;  takes for a response to make it back to the client. If that&#xA;  time is too long, U-Boot will retransmit requests. In order&#xA;  to allow earlier responses to still be accepted after these&#xA;  retransmissions, U-Boot&#39;s BOOTP client keeps a small cache of&#xA;  IDs. The CONFIG_BOOTP_ID_CACHE_SIZE controls the size of this&#xA;  cache. The default is to keep IDs for up to four outstanding&#xA;  requests. Increasing this will allow U-Boot to accept offers&#xA;  from a BOOTP client in networks with unusually high latency.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;DHCP Advanced Options:&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Link-local IP address negotiation: Negotiate with other link-local clients on the local network for an address that doesn&#39;t require explicit configuration. This is especially useful if a DHCP server cannot be guaranteed to exist in all environments that the device must operate.&lt;/p&gt; &lt;pre&gt;&lt;code&gt; See doc/README.link-local for more information.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MAC address from environment variables&lt;/p&gt; &lt;pre&gt;&lt;code&gt; FDT_SEQ_MACADDR_FROM_ENV&#xA;&#xA; Fix-up device tree with MAC addresses fetched sequentially from&#xA; environment variables. This config work on assumption that&#xA; non-usable ethernet node of device-tree are either not present&#xA; or their status has been marked as &#34;disabled&#34;.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CDP Options: CONFIG_CDP_DEVICE_ID&lt;/p&gt; &lt;pre&gt;&lt;code&gt; The device id used in CDP trigger frames.&#xA;&#xA; CONFIG_CDP_DEVICE_ID_PREFIX&#xA;&#xA; A two character string which is prefixed to the MAC address&#xA; of the device.&#xA;&#xA; CONFIG_CDP_PORT_ID&#xA;&#xA; A printf format string which contains the ascii name of&#xA; the port. Normally is set to &#34;eth%d&#34; which sets&#xA; eth0 for the first Ethernet, eth1 for the second etc.&#xA;&#xA; CONFIG_CDP_CAPABILITIES&#xA;&#xA; A 32bit integer which indicates the device capabilities;&#xA; 0x00000010 for a normal host which does not forwards.&#xA;&#xA; CONFIG_CDP_VERSION&#xA;&#xA; An ascii string containing the version of the software.&#xA;&#xA; CONFIG_CDP_PLATFORM&#xA;&#xA; An ascii string containing the name of the platform.&#xA;&#xA; CONFIG_CDP_TRIGGER&#xA;&#xA; A 32bit integer sent on the trigger.&#xA;&#xA; CONFIG_CDP_POWER_CONSUMPTION&#xA;&#xA; A 16bit integer containing the power consumption of the&#xA; device in .1 of milliwatts.&#xA;&#xA; CONFIG_CDP_APPLIANCE_VLAN_TYPE&#xA;&#xA; A byte containing the id of the VLAN.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Status LED: CONFIG_LED_STATUS&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Several configurations allow to display the current&#xA;  status using a LED. For instance, the LED will blink&#xA;  fast while running U-Boot code, stop blinking as&#xA;  soon as a reply to a BOOTP request was received, and&#xA;  start blinking slow once the Linux kernel is running&#xA;  (supported by a status LED driver in the Linux&#xA;  kernel). Defining CONFIG_LED_STATUS enables this&#xA;  feature in U-Boot.&#xA;&#xA;  Additional options:&#xA;&#xA;  CONFIG_LED_STATUS_GPIO&#xA;  The status LED can be connected to a GPIO pin.&#xA;  In such cases, the gpio_led driver can be used as a&#xA;  status LED backend implementation. Define CONFIG_LED_STATUS_GPIO&#xA;  to include the gpio_led driver in the U-Boot binary.&#xA;&#xA;  CONFIG_GPIO_LED_INVERTED_TABLE&#xA;  Some GPIO connected LEDs may have inverted polarity in which&#xA;  case the GPIO high value corresponds to LED off state and&#xA;  GPIO low value corresponds to LED on state.&#xA;  In such cases CONFIG_GPIO_LED_INVERTED_TABLE may be defined&#xA;  with a list of GPIO LEDs that have inverted polarity.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;I2C Support: CONFIG_SYS_NUM_I2C_BUSES Hold the number of i2c buses you want to use.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  CONFIG_SYS_I2C_DIRECT_BUS&#xA;  define this, if you don&#39;t use i2c muxes on your hardware.&#xA;  if CONFIG_SYS_I2C_MAX_HOPS is not defined or == 0 you can&#xA;  omit this define.&#xA;&#xA;  CONFIG_SYS_I2C_MAX_HOPS&#xA;  define how many muxes are maximal consecutively connected&#xA;  on one i2c bus. If you not use i2c muxes, omit this&#xA;  define.&#xA;&#xA;  CONFIG_SYS_I2C_BUSES&#xA;  hold a list of buses you want to use, only used if&#xA;  CONFIG_SYS_I2C_DIRECT_BUS is not defined, for example&#xA;  a board with CONFIG_SYS_I2C_MAX_HOPS = 1 and&#xA;  CONFIG_SYS_NUM_I2C_BUSES = 9:&#xA;&#xA;   CONFIG_SYS_I2C_BUSES&#x9;{{0, {I2C_NULL_HOP}}, \&#xA;  &#x9;&#x9;&#x9;{0, {{I2C_MUX_PCA9547, 0x70, 1}}}, \&#xA;  &#x9;&#x9;&#x9;{0, {{I2C_MUX_PCA9547, 0x70, 2}}}, \&#xA;  &#x9;&#x9;&#x9;{0, {{I2C_MUX_PCA9547, 0x70, 3}}}, \&#xA;  &#x9;&#x9;&#x9;{0, {{I2C_MUX_PCA9547, 0x70, 4}}}, \&#xA;  &#x9;&#x9;&#x9;{0, {{I2C_MUX_PCA9547, 0x70, 5}}}, \&#xA;  &#x9;&#x9;&#x9;{1, {I2C_NULL_HOP}}, \&#xA;  &#x9;&#x9;&#x9;{1, {{I2C_MUX_PCA9544, 0x72, 1}}}, \&#xA;  &#x9;&#x9;&#x9;{1, {{I2C_MUX_PCA9544, 0x72, 2}}}, \&#xA;  &#x9;&#x9;&#x9;}&#xA;&#xA;  which defines&#xA;  &#x9;bus 0 on adapter 0 without a mux&#xA;  &#x9;bus 1 on adapter 0 with a PCA9547 on address 0x70 port 1&#xA;  &#x9;bus 2 on adapter 0 with a PCA9547 on address 0x70 port 2&#xA;  &#x9;bus 3 on adapter 0 with a PCA9547 on address 0x70 port 3&#xA;  &#x9;bus 4 on adapter 0 with a PCA9547 on address 0x70 port 4&#xA;  &#x9;bus 5 on adapter 0 with a PCA9547 on address 0x70 port 5&#xA;  &#x9;bus 6 on adapter 1 without a mux&#xA;  &#x9;bus 7 on adapter 1 with a PCA9544 on address 0x72 port 1&#xA;  &#x9;bus 8 on adapter 1 with a PCA9544 on address 0x72 port 2&#xA;&#xA;  If you do not have i2c muxes on your board, omit this define.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Legacy I2C Support: If you use the software i2c interface (CONFIG_SYS_I2C_SOFT) then the following macros need to be defined (examples are from include/configs/lwmon.h):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  I2C_INIT&#xA;&#xA;  (Optional). Any commands necessary to enable the I2C&#xA;  controller or configure ports.&#xA;&#xA;  eg: #define I2C_INIT (immr-&amp;gt;im_cpm.cp_pbdir |=&#x9;PB_SCL)&#xA;&#xA;  I2C_ACTIVE&#xA;&#xA;  The code necessary to make the I2C data line active&#xA;  (driven).  If the data line is open collector, this&#xA;  define can be null.&#xA;&#xA;  eg: #define I2C_ACTIVE (immr-&amp;gt;im_cpm.cp_pbdir |=  PB_SDA)&#xA;&#xA;  I2C_TRISTATE&#xA;&#xA;  The code necessary to make the I2C data line tri-stated&#xA;  (inactive).  If the data line is open collector, this&#xA;  define can be null.&#xA;&#xA;  eg: #define I2C_TRISTATE (immr-&amp;gt;im_cpm.cp_pbdir &amp;amp;= ~PB_SDA)&#xA;&#xA;  I2C_READ&#xA;&#xA;  Code that returns true if the I2C data line is high,&#xA;  false if it is low.&#xA;&#xA;  eg: #define I2C_READ ((immr-&amp;gt;im_cpm.cp_pbdat &amp;amp; PB_SDA) != 0)&#xA;&#xA;  I2C_SDA(bit)&#xA;&#xA;  If &amp;lt;bit&amp;gt; is true, sets the I2C data line high. If it&#xA;  is false, it clears it (low).&#xA;&#xA;  eg: #define I2C_SDA(bit) \&#xA;  &#x9;if(bit) immr-&amp;gt;im_cpm.cp_pbdat |=  PB_SDA; \&#xA;  &#x9;else&#x9;immr-&amp;gt;im_cpm.cp_pbdat &amp;amp;= ~PB_SDA&#xA;&#xA;  I2C_SCL(bit)&#xA;&#xA;  If &amp;lt;bit&amp;gt; is true, sets the I2C clock line high. If it&#xA;  is false, it clears it (low).&#xA;&#xA;  eg: #define I2C_SCL(bit) \&#xA;  &#x9;if(bit) immr-&amp;gt;im_cpm.cp_pbdat |=  PB_SCL; \&#xA;  &#x9;else&#x9;immr-&amp;gt;im_cpm.cp_pbdat &amp;amp;= ~PB_SCL&#xA;&#xA;  I2C_DELAY&#xA;&#xA;  This delay is invoked four times per clock cycle so this&#xA;  controls the rate of data transfer.  The data rate thus&#xA;  is 1 / (I2C_DELAY * 4). Often defined to be something&#xA;  like:&#xA;&#xA;  #define I2C_DELAY  udelay(2)&#xA;&#xA;  CONFIG_SOFT_I2C_GPIO_SCL / CONFIG_SOFT_I2C_GPIO_SDA&#xA;&#xA;  If your arch supports the generic GPIO framework (asm/gpio.h),&#xA;  then you may alternatively define the two GPIOs that are to be&#xA;  used as SCL / SDA.  Any of the previous I2C_xxx macros will&#xA;  have GPIO-based defaults assigned to them as appropriate.&#xA;&#xA;  You should define these to the GPIO value as given directly to&#xA;  the generic GPIO functions.&#xA;&#xA;  CONFIG_SYS_I2C_INIT_BOARD&#xA;&#xA;  When a board is reset during an i2c bus transfer&#xA;  chips might think that the current transfer is still&#xA;  in progress. On some boards it is possible to access&#xA;  the i2c SCLK line directly, either by using the&#xA;  processor pin as a GPIO or by having a second pin&#xA;  connected to the bus. If this option is defined a&#xA;  custom i2c_init_board() routine in boards/xxx/board.c&#xA;  is run early in the boot sequence.&#xA;&#xA;  CONFIG_I2C_MULTI_BUS&#xA;&#xA;  This option allows the use of multiple I2C buses, each of which&#xA;  must have a controller.&#x9; At any point in time, only one bus is&#xA;  active.&#x9; To switch to a different bus, use the &#39;i2c dev&#39; command.&#xA;  Note that bus numbering is zero-based.&#xA;&#xA;  CONFIG_SYS_I2C_NOPROBES&#xA;&#xA;  This option specifies a list of I2C devices that will be skipped&#xA;  when the &#39;i2c probe&#39; command is issued.&#x9; If CONFIG_I2C_MULTI_BUS&#xA;  is set, specify a list of bus-device pairs.  Otherwise, specify&#xA;  a 1D array of device addresses&#xA;&#xA;  e.g.&#xA;  &#x9;#undef&#x9;CONFIG_I2C_MULTI_BUS&#xA;  &#x9;#define CONFIG_SYS_I2C_NOPROBES {0x50,0x68}&#xA;&#xA;  will skip addresses 0x50 and 0x68 on a board with one I2C bus&#xA;&#xA;  &#x9;#define CONFIG_I2C_MULTI_BUS&#xA;  &#x9;#define CONFIG_SYS_I2C_NOPROBES&#x9;{{0,0x50},{0,0x68},{1,0x54}}&#xA;&#xA;  will skip addresses 0x50 and 0x68 on bus 0 and address 0x54 on bus 1&#xA;&#xA;  CONFIG_SYS_RTC_BUS_NUM&#xA;&#xA;  If defined, then this indicates the I2C bus number for the RTC.&#xA;  If not defined, then U-Boot assumes that RTC is on I2C bus 0.&#xA;&#xA;  CONFIG_SOFT_I2C_READ_REPEATED_START&#xA;&#xA;  defining this will force the i2c_read() function in&#xA;  the soft_i2c driver to perform an I2C repeated start&#xA;  between writing the address pointer and reading the&#xA;  data.  If this define is omitted the default behaviour&#xA;  of doing a stop-start sequence will be used.  Most I2C&#xA;  devices can use either method, but some require one or&#xA;  the other.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;SPI Support: CONFIG_SPI&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Enables SPI driver (so far only tested with&#xA;  SPI EEPROM, also an instance works with Crystal A/D and&#xA;  D/As on the SACSng board)&#xA;&#xA;  CONFIG_SYS_SPI_MXC_WAIT&#xA;  Timeout for waiting until spi transfer completed.&#xA;  default: (CONFIG_SYS_HZ/100)     /* 10 ms */&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;FPGA Support: CONFIG_FPGA&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Enables FPGA subsystem.&#xA;&#xA;  CONFIG_FPGA_&amp;lt;vendor&amp;gt;&#xA;&#xA;  Enables support for specific chip vendors.&#xA;  (ALTERA, XILINX)&#xA;&#xA;  CONFIG_FPGA_&amp;lt;family&amp;gt;&#xA;&#xA;  Enables support for FPGA family.&#xA;  (SPARTAN2, SPARTAN3, VIRTEX2, CYCLONE2, ACEX1K, ACEX)&#xA;&#xA;  CONFIG_SYS_FPGA_CHECK_BUSY&#xA;&#xA;  Enable checks on FPGA configuration interface busy&#xA;  status by the configuration function. This option&#xA;  will require a board or device specific function to&#xA;  be written.&#xA;&#xA;  CONFIG_FPGA_DELAY&#xA;&#xA;  If defined, a function that provides delays in the FPGA&#xA;  configuration driver.&#xA;&#xA;  CONFIG_SYS_FPGA_CHECK_ERROR&#xA;&#xA;  Check for configuration errors during FPGA bitfile&#xA;  loading. For example, abort during Virtex II&#xA;  configuration if the INIT_B line goes low (which&#xA;  indicated a CRC error).&#xA;&#xA;  CONFIG_SYS_FPGA_WAIT_INIT&#xA;&#xA;  Maximum time to wait for the INIT_B line to de-assert&#xA;  after PROB_B has been de-asserted during a Virtex II&#xA;  FPGA configuration sequence. The default time is 500&#xA;  ms.&#xA;&#xA;  CONFIG_SYS_FPGA_WAIT_BUSY&#xA;&#xA;  Maximum time to wait for BUSY to de-assert during&#xA;  Virtex II FPGA configuration. The default is 5 ms.&#xA;&#xA;  CONFIG_SYS_FPGA_WAIT_CONFIG&#xA;&#xA;  Time to wait after FPGA configuration. The default is&#xA;  200 ms.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Vendor Parameter Protection:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  U-Boot considers the values of the environment&#xA;  variables &#34;serial#&#34; (Board Serial Number) and&#xA;  &#34;ethaddr&#34; (Ethernet Address) to be parameters that&#xA;  are set once by the board vendor / manufacturer, and&#xA;  protects these variables from casual modification by&#xA;  the user. Once set, these variables are read-only,&#xA;  and write or delete attempts are rejected. You can&#xA;  change this behaviour:&#xA;&#xA;  If CONFIG_ENV_OVERWRITE is #defined in your config&#xA;  file, the write protection for vendor parameters is&#xA;  completely disabled. Anybody can change or delete&#xA;  these parameters.&#xA;&#xA;  Alternatively, if you define _both_ an ethaddr in the&#xA;  default env _and_ CONFIG_OVERWRITE_ETHADDR_ONCE, a default&#xA;  Ethernet address is installed in the environment,&#xA;  which can be changed exactly ONCE by the user. [The&#xA;  serial# is unaffected by this, i. e. it remains&#xA;  read-only.]&#xA;&#xA;  The same can be accomplished in a more flexible way&#xA;  for any variable by configuring the type of access&#xA;  to allow for those variables in the &#34;.flags&#34; variable&#xA;  or define CONFIG_ENV_FLAGS_LIST_STATIC.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Protected RAM: CONFIG_PRAM&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Define this variable to enable the reservation of&#xA;  &#34;protected RAM&#34;, i. e. RAM which is not overwritten&#xA;  by U-Boot. Define CONFIG_PRAM to hold the number of&#xA;  kB you want to reserve for pRAM. You can overwrite&#xA;  this default value by defining an environment&#xA;  variable &#34;pram&#34; to the number of kB you want to&#xA;  reserve. Note that the board info structure will&#xA;  still show the full amount of RAM. If pRAM is&#xA;  reserved, a new environment variable &#34;mem&#34; will&#xA;  automatically be defined to hold the amount of&#xA;  remaining RAM in a form that can be passed as boot&#xA;  argument to Linux, for instance like that:&#xA;&#xA;  &#x9;setenv bootargs ... mem=\${mem}&#xA;  &#x9;saveenv&#xA;&#xA;  This way you can tell Linux not to use this memory,&#xA;  either, which results in a memory region that will&#xA;  not be affected by reboots.&#xA;&#xA;  *WARNING* If your board configuration uses automatic&#xA;  detection of the RAM size, you must make sure that&#xA;  this memory test is non-destructive. So far, the&#xA;  following board configurations are known to be&#xA;  &#34;pRAM-clean&#34;:&#xA;&#xA;  &#x9;IVMS8, IVML24, SPD8xx,&#xA;  &#x9;HERMES, IP860, RPXlite, LWMON,&#xA;  &#x9;FLAGADM&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Error Recovery: Note:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  In the current implementation, the local variables&#xA;  space and global environment variables space are&#xA;  separated. Local variables are those you define by&#xA;  simply typing `name=value&#39;. To access a local&#xA;  variable later on, you have write `$name&#39; or&#xA;  `${name}&#39;; to execute the contents of a variable&#xA;  directly type `$name&#39; at the command prompt.&#xA;&#xA;  Global environment variables are those you use&#xA;  setenv/printenv to work with. To run a command stored&#xA;  in such a variable, you need to use the run command,&#xA;  and you must not use the &#39;$&#39; sign to access them.&#xA;&#xA;  To store commands and special characters in a&#xA;  variable, please use double quotation marks&#xA;  surrounding the whole text of the variable, instead&#xA;  of the backslashes before semicolons and special&#xA;  symbols.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Default Environment: CONFIG_EXTRA_ENV_SETTINGS&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Define this to contain any number of null terminated&#xA;  strings (variable = value pairs) that will be part of&#xA;  the default environment compiled into the boot image.&#xA;&#xA;  For example, place something like this in your&#xA;  board&#39;s config file:&#xA;&#xA;  #define CONFIG_EXTRA_ENV_SETTINGS \&#xA;  &#x9;&#34;myvar1=value1\0&#34; \&#xA;  &#x9;&#34;myvar2=value2\0&#34;&#xA;&#xA;  Warning: This method is based on knowledge about the&#xA;  internal format how the environment is stored by the&#xA;  U-Boot code. This is NOT an official, exported&#xA;  interface! Although it is unlikely that this format&#xA;  will change soon, there is no guarantee either.&#xA;  You better know what you are doing here.&#xA;&#xA;  Note: overly (ab)use of the default environment is&#xA;  discouraged. Make sure to check other ways to preset&#xA;  the environment like the &#34;source&#34; command or the&#xA;  boot command first.&#xA;&#xA;  CONFIG_DELAY_ENVIRONMENT&#xA;&#xA;  Normally the environment is loaded when the board is&#xA;  initialised so that it is available to U-Boot. This inhibits&#xA;  that so that the environment is not available until&#xA;  explicitly loaded later by U-Boot code. With CONFIG_OF_CONTROL&#xA;  this is instead controlled by the value of&#xA;  /config/load-environment.&#xA;&#xA;  CONFIG_STANDALONE_LOAD_ADDR&#xA;&#xA;  This option defines a board specific value for the&#xA;  address where standalone program gets loaded, thus&#xA;  overwriting the architecture dependent default&#xA;  settings.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatic software updates via TFTP server CONFIG_UPDATE_TFTP CONFIG_UPDATE_TFTP_CNT_MAX CONFIG_UPDATE_TFTP_MSEC_MAX&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  These options enable and control the auto-update feature;&#xA;  for a more detailed description refer to doc/README.update.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MTD Support (mtdparts command, UBI support) CONFIG_MTD_UBI_WL_THRESHOLD This parameter defines the maximum difference between the highest erase counter value and the lowest erase counter value of eraseblocks of UBI devices. When this threshold is exceeded, UBI starts performing wear leveling by means of moving data from eraseblock with low erase counter to eraseblocks with high erase counter.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  The default value should be OK for SLC NAND flashes, NOR flashes and&#xA;  other flashes which have eraseblock life-cycle 100000 or more.&#xA;  However, in case of MLC NAND flashes which typically have eraseblock&#xA;  life-cycle less than 10000, the threshold should be lessened (e.g.,&#xA;  to 128 or 256, although it does not have to be power of 2).&#xA;&#xA;  default: 4096&#xA;&#xA;  CONFIG_MTD_UBI_BEB_LIMIT&#xA;  This option specifies the maximum bad physical eraseblocks UBI&#xA;  expects on the MTD device (per 1024 eraseblocks). If the&#xA;  underlying flash does not admit of bad eraseblocks (e.g. NOR&#xA;  flash), this value is ignored.&#xA;&#xA;  NAND datasheets often specify the minimum and maximum NVM&#xA;  (Number of Valid Blocks) for the flashes&#39; endurance lifetime.&#xA;  The maximum expected bad eraseblocks per 1024 eraseblocks&#xA;  then can be calculated as &#34;1024 * (1 - MinNVB / MaxNVB)&#34;,&#xA;  which gives 20 for most NANDs (MaxNVB is basically the total&#xA;  count of eraseblocks on the chip).&#xA;&#xA;  To put it differently, if this value is 20, UBI will try to&#xA;  reserve about 1.9% of physical eraseblocks for bad blocks&#xA;  handling. And that will be 1.9% of eraseblocks on the entire&#xA;  NAND chip, not just the MTD partition UBI attaches. This means&#xA;  that if you have, say, a NAND flash chip admits maximum 40 bad&#xA;  eraseblocks, and it is split on two MTD partitions of the same&#xA;  size, UBI will reserve 40 eraseblocks when attaching a&#xA;  partition.&#xA;&#xA;  default: 20&#xA;&#xA;  CONFIG_MTD_UBI_FASTMAP&#xA;  Fastmap is a mechanism which allows attaching an UBI device&#xA;  in nearly constant time. Instead of scanning the whole MTD device it&#xA;  only has to locate a checkpoint (called fastmap) on the device.&#xA;  The on-flash fastmap contains all information needed to attach&#xA;  the device. Using fastmap makes only sense on large devices where&#xA;  attaching by scanning takes long. UBI will not automatically install&#xA;  a fastmap on old images, but you can set the UBI parameter&#xA;  CONFIG_MTD_UBI_FASTMAP_AUTOCONVERT to 1 if you want so. Please note&#xA;  that fastmap-enabled images are still usable with UBI implementations&#xA;  without&#x9;fastmap support. On typical flash devices the whole fastmap&#xA;  fits into one PEB. UBI will reserve PEBs to hold two fastmaps.&#xA;&#xA;  CONFIG_MTD_UBI_FASTMAP_AUTOCONVERT&#xA;  Set this parameter to enable fastmap automatically on images&#xA;  without a fastmap.&#xA;  default: 0&#xA;&#xA;  CONFIG_MTD_UBI_FM_DEBUG&#xA;  Enable UBI fastmap debug&#xA;  default: 0&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;SPL framework CONFIG_SPL Enable building of SPL globally.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  CONFIG_SPL_PANIC_ON_RAW_IMAGE&#xA;  When defined, SPL will panic() if the image it has&#xA;  loaded does not have a signature.&#xA;  Defining this is useful when code which loads images&#xA;  in SPL cannot guarantee that absolutely all read errors&#xA;  will be caught.&#xA;  An example is the LPC32XX MLC NAND driver, which will&#xA;  consider that a completely unreadable NAND block is bad,&#xA;  and thus should be skipped silently.&#xA;&#xA;  CONFIG_SPL_DISPLAY_PRINT&#xA;  For ARM, enable an optional function to print more information&#xA;  about the running system.&#xA;&#xA;  CONFIG_SPL_MPC83XX_WAIT_FOR_NAND&#xA;  Set this for NAND SPL on PPC mpc83xx targets, so that&#xA;  start.S waits for the rest of the SPL to load before&#xA;  continuing (the hardware starts execution after just&#xA;  loading the first page rather than the full 4K).&#xA;&#xA;  CONFIG_SPL_UBI&#xA;  Support for a lightweight UBI (fastmap) scanner and&#xA;  loader&#xA;&#xA;  CONFIG_SYS_NAND_5_ADDR_CYCLE, CONFIG_SYS_NAND_PAGE_COUNT,&#xA;  CONFIG_SYS_NAND_PAGE_SIZE, CONFIG_SYS_NAND_OOBSIZE,&#xA;  CONFIG_SYS_NAND_BLOCK_SIZE, CONFIG_SYS_NAND_BAD_BLOCK_POS,&#xA;  CONFIG_SYS_NAND_ECCPOS, CONFIG_SYS_NAND_ECCSIZE,&#xA;  CONFIG_SYS_NAND_ECCBYTES&#xA;  Defines the size and behavior of the NAND that SPL uses&#xA;  to read U-Boot&#xA;&#xA;  CONFIG_SYS_NAND_U_BOOT_DST&#xA;  Location in memory to load U-Boot to&#xA;&#xA;  CONFIG_SYS_NAND_U_BOOT_SIZE&#xA;  Size of image to load&#xA;&#xA;  CONFIG_SYS_NAND_U_BOOT_START&#xA;  Entry point in loaded image to jump to&#xA;&#xA;  CONFIG_SYS_NAND_HW_ECC_OOBFIRST&#xA;  Define this if you need to first read the OOB and then the&#xA;  data. This is used, for example, on davinci platforms.&#xA;&#xA;  CONFIG_SPL_RAM_DEVICE&#xA;  Support for running image already present in ram, in SPL binary&#xA;&#xA;  CONFIG_SPL_FIT_PRINT&#xA;  Printing information about a FIT image adds quite a bit of&#xA;  code to SPL. So this is normally disabled in SPL. Use this&#xA;  option to re-enable it. This will affect the output of the&#xA;  bootm command when booting a FIT image.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Interrupt support (PPC):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  There are common interrupt_init() and timer_interrupt()&#xA;  for all PPC archs. interrupt_init() calls interrupt_init_cpu()&#xA;  for CPU specific initialization. interrupt_init_cpu()&#xA;  should set decrementer_count to appropriate value. If&#xA;  CPU resets decrementer automatically after interrupt&#xA;  (ppc4xx) it should set decrementer_count to zero.&#xA;  timer_interrupt() calls timer_interrupt_cpu() for CPU&#xA;  specific handling. If board has watchdog / status_led&#xA;  / other_activity_monitor it works automatically from&#xA;  general timer_interrupt().&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Board initialization settings:&lt;/h2&gt; &#xA;&lt;p&gt;During Initialization u-boot calls a number of board specific functions to allow the preparation of board specific prerequisites, e.g. pin setup before drivers are initialized. To enable these callbacks the following configuration macros have to be defined. Currently this is architecture specific, so please check arch/your_architecture/lib/board.c typically in board_init_f() and board_init_r().&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CONFIG_BOARD_EARLY_INIT_F: Call board_early_init_f()&lt;/li&gt; &#xA; &lt;li&gt;CONFIG_BOARD_EARLY_INIT_R: Call board_early_init_r()&lt;/li&gt; &#xA; &lt;li&gt;CONFIG_BOARD_LATE_INIT: Call board_late_init()&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Configuration Settings:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;MEM_SUPPORT_64BIT_DATA: Defined automatically if compiled as 64-bit. Optionally it can be defined to support 64-bit memory commands.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_LONGHELP: Defined when you want long help messages included; undefine this when you&#39;re short of memory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_HELP_CMD_WIDTH: Defined when you want to override the default width of the commands listed in the &#39;help&#39; command output.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_PROMPT: This is what U-Boot prints on the console to prompt for user input.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_BAUDRATE_TABLE: List of legal baudrate settings for this board.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_MEM_RESERVE_SECURE Only implemented for ARMv8 for now. If defined, the size of CONFIG_SYS_MEM_RESERVE_SECURE memory is substracted from total RAM and won&#39;t be reported to OS. This memory can be used as secure memory. A variable gd-&amp;gt;arch.secure_ram is used to track the location. In systems the RAM base is not zero, or RAM is divided into banks, this variable needs to be recalcuated to get the address.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_LOADS_BAUD_CHANGE: Enable temporary baudrate change while serial download&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_SDRAM_BASE: Physical start address of SDRAM. &lt;em&gt;Must&lt;/em&gt; be 0 here.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_FLASH_BASE: Physical start address of Flash memory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_MONITOR_LEN: Size of memory reserved for monitor code, used to determine &lt;em&gt;at_compile_time&lt;/em&gt; (!) if the environment is embedded within the U-Boot image, or in a separate flash sector.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_MALLOC_LEN: Size of DRAM reserved for malloc() use.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_MALLOC_F_LEN Size of the malloc() pool for use before relocation. If this is defined, then a very simple malloc() implementation will become available before relocation. The address is just below the global data, and the stack is moved down to make space.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  This feature allocates regions with increasing addresses&#xA;  within the region. calloc() is supported, but realloc()&#xA;  is not available. free() is supported but does nothing.&#xA;  The memory will be freed (or in fact just forgotten) when&#xA;  U-Boot relocates itself.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_MALLOC_SIMPLE Provides a simple and small malloc() and calloc() for those boards which do not use the full malloc in SPL (which is enabled with CONFIG_SYS_SPL_MALLOC).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_NONCACHED_MEMORY: Size of non-cached memory area. This area of memory will be typically located right below the malloc() area and mapped uncached in the MMU. This is useful for drivers that would otherwise require a lot of explicit cache maintenance. For some drivers it&#39;s also impossible to properly maintain the cache. For example if the regions that need to be flushed are not a multiple of the cache-line size, &lt;em&gt;and&lt;/em&gt; padding cannot be allocated between the regions to align them (i.e. if the HW requires a contiguous array of regions, and the size of each region is not cache-aligned), then a flush of one region may result in overwriting data that hardware has written to another region in the same cache-line. This can happen for example in network drivers where descriptors for buffers are typically smaller than the CPU cache-line (e.g. 16 bytes vs. 32 or 64 bytes).&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Non-cached memory is only supported on 32-bit ARM at present.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_BOOTMAPSZ: Maximum size of memory mapped by the startup code of the Linux kernel; all data that must be processed by the Linux kernel (bd_info, boot arguments, FDT blob if used) must be put below this limit, unless &#34;bootm_low&#34; environment variable is defined and non-zero. In such case all data for the Linux kernel must be between &#34;bootm_low&#34; and &#34;bootm_low&#34; + CONFIG_SYS_BOOTMAPSZ. The environment variable &#34;bootm_mapsize&#34; will override the value of CONFIG_SYS_BOOTMAPSZ. If CONFIG_SYS_BOOTMAPSZ is undefined, then the value in &#34;bootm_size&#34; will be used instead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_BOOT_GET_CMDLINE: Enables allocating and saving kernel cmdline in space between &#34;bootm_low&#34; and &#34;bootm_low&#34; + BOOTMAPSZ.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_BOOT_GET_KBD: Enables allocating and saving a kernel copy of the bd_info in space between &#34;bootm_low&#34; and &#34;bootm_low&#34; + BOOTMAPSZ.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_FLASH_PROTECTION If defined, hardware flash sectors protection is used instead of U-Boot software protection.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_FLASH_CFI: Define if the flash driver uses extra elements in the common flash structure for storing flash geometry.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_FLASH_CFI_DRIVER This option also enables the building of the cfi_flash driver in the drivers directory&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_FLASH_CFI_MTD This option enables the building of the cfi_mtd driver in the drivers directory. The driver exports CFI flash to the MTD layer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_FLASH_USE_BUFFER_WRITE Use buffered writes to flash.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_FLASH_SPANSION_S29WS_N s29ws-n MirrorBit flash has non-standard addresses for buffered write commands.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_FLASH_SHOW_PROGRESS If defined (must be an integer), print out countdown digits and dots. Recommended value: 45 (9..1) for 80 column displays, 15 (3..1) for 40 column displays.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_FLASH_VERIFY If defined, the content of the flash (destination) is compared against the source after the write operation. An error message will be printed when the contents are not identical. Please note that this option is useless in nearly all cases, since such flash programming errors usually are detected earlier while unprotecting/erasing/programming. Please only enable this option if you really know what you are doing.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_ENV_FLAGS_LIST_DEFAULT&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_ENV_FLAGS_LIST_STATIC Enable validation of the values given to environment variables when calling env set. Variables can be restricted to only decimal, hexadecimal, or boolean. If CONFIG_CMD_NET is also defined, the variables can also be restricted to IP address or MAC address.&lt;/p&gt; &lt;p&gt;The format of the list is: type_attribute = [s|d|x|b|i|m] access_attribute = [a|r|o|c] attributes = type_attribute[access_attribute] entry = variable_name[:attributes] list = entry[,list]&lt;/p&gt; &lt;p&gt;The type attributes are: s - String (default) d - Decimal x - Hexadecimal b - Boolean ([1yYtT|0nNfF]) i - IP address m - MAC address&lt;/p&gt; &lt;p&gt;The access attributes are: a - Any (default) r - Read-only o - Write-once c - Change-default&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;CONFIG_ENV_FLAGS_LIST_DEFAULT Define this to a list (string) to define the &#34;.flags&#34; environment variable in the default or embedded environment.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;CONFIG_ENV_FLAGS_LIST_STATIC Define this to a list (string) to define validation that should be done if an entry is not found in the &#34;.flags&#34; environment variable. To override a setting in the static list, simply add an entry for the same variable name to the &#34;.flags&#34; variable.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;If CONFIG_REGEX is defined, the variable_name above is evaluated as a regular expression. This allows multiple variables to define the same flags without explicitly listing them for each variable.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following definitions that deal with the placement and management of environment data (variable area); in general, we support the following configurations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_BUILD_ENVCRC:&lt;/p&gt; &lt;p&gt;Builds up envcrc with the target environment so that external utils may easily extract it and embed it in final U-Boot images.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;BE CAREFUL! The first access to the environment happens quite early in U-Boot initialization (when we try to get the setting of for the console baudrate). You &lt;em&gt;MUST&lt;/em&gt; have mapped your NVRAM area then, or U-Boot will hang.&lt;/p&gt; &#xA;&lt;p&gt;Please note that even with NVRAM we still use a copy of the environment in RAM: we could work on NVRAM directly, but we want to keep settings there always unmodified except somebody uses &#34;saveenv&#34; to save the current settings.&lt;/p&gt; &#xA;&lt;p&gt;BE CAREFUL! For some special cases, the local device can not use &#34;saveenv&#34; command. For example, the local device will get the environment stored in a remote NOR flash by SRIO or PCIE link, but it can not erase, write this NOR flash by SRIO or PCIE interface.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_NAND_ENV_DST&lt;/p&gt; &lt;p&gt;Defines address in RAM to which the nand_spl code should copy the environment. If redundant environment is used, it will be copied to CONFIG_NAND_ENV_DST + CONFIG_ENV_SIZE.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please note that the environment is read-only until the monitor has been relocated to RAM and a RAM copy of the environment has been created; also, when using EEPROM you will have to use env_get_f() until then to read environment variables.&lt;/p&gt; &#xA;&lt;p&gt;The environment is protected by a CRC32 checksum. Before the monitor is relocated into RAM, as a result of a bad CRC you will be working with the compiled-in default environment - &lt;em&gt;silently&lt;/em&gt;!!! [This is necessary, because the first environment variable we need is the &#34;baudrate&#34; setting for the console - if we have a bad CRC, we don&#39;t have any device yet where we could complain.]&lt;/p&gt; &#xA;&lt;p&gt;Note: once the monitor has been relocated, then it will complain if the default environment is used; a new CRC is computed as soon as you use the &#34;saveenv&#34; command to store a valid environment.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_FAULT_MII_ADDR: MII address of the PHY to check for the Ethernet link state.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_NS16550_MIN_FUNCTIONS: Define this if you desire to only have use of the NS16550_init and NS16550_putc functions for the serial driver located at drivers/serial/ns16550.c. This option is useful for saving space for already greatly restricted images, including but not limited to NAND_SPL configurations.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_DISPLAY_BOARDINFO Display information about the board that U-Boot is running on when U-Boot starts up. The board function checkboard() is called to do this.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_DISPLAY_BOARDINFO_LATE Similar to the previous option, but display this information later, once stdio is running and output goes to the LCD, if present.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Low Level (hardware related) configuration options:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_CACHELINE_SIZE: Cache Line Size of the CPU.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_CCSRBAR_DEFAULT: Default (power-on reset) physical address of CCSR on Freescale PowerPC SOCs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_CCSRBAR: Virtual address of CCSR. On a 32-bit build, this is typically the same value as CONFIG_SYS_CCSRBAR_DEFAULT.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_CCSRBAR_PHYS: Physical address of CCSR. CCSR can be relocated to a new physical address, if desired. In this case, this macro should be set to that address. Otherwise, it should be set to the same value as CONFIG_SYS_CCSRBAR_DEFAULT. For example, CCSR is typically relocated on 36-bit builds. It is recommended that this macro be defined via the _HIGH and _LOW macros:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  #define CONFIG_SYS_CCSRBAR_PHYS ((CONFIG_SYS_CCSRBAR_PHYS_HIGH&#xA;  &#x9;* 1ull) &amp;lt;&amp;lt; 32 | CONFIG_SYS_CCSRBAR_PHYS_LOW)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_CCSRBAR_PHYS_HIGH: Bits 33-36 of CONFIG_SYS_CCSRBAR_PHYS. This value is typically either 0 (32-bit build) or 0xF (36-bit build). This macro is used in assembly code, so it must not contain typecasts or integer size suffixes (e.g. &#34;ULL&#34;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_CCSRBAR_PHYS_LOW: Lower 32-bits of CONFIG_SYS_CCSRBAR_PHYS. This macro is used in assembly code, so it must not contain typecasts or integer size suffixes (e.g. &#34;ULL&#34;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_IMMR: Physical address of the Internal Memory. DO NOT CHANGE unless you know exactly what you&#39;re doing! (11-4) [MPC8xx systems only]&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_INIT_RAM_ADDR:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  Start address of memory area that can be used for&#xA;  initial data and stack; please note that this must be&#xA;  writable memory that is working WITHOUT special&#xA;  initialization, i. e. you CANNOT use normal RAM which&#xA;  will become available only after programming the&#xA;  memory controller and running certain initialization&#xA;  sequences.&#xA;&#xA;  U-Boot uses the following memory types:&#xA;  - MPC8xx: IMMR (internal memory of the CPU)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_SCCR: System Clock and reset Control Register (15-27)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_OR_TIMING_SDRAM: SDRAM timing&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_MAMR_PTA: periodic timer for refresh&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_SRIO: Chip has SRIO or not&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SRIO1: Board has SRIO 1 port available&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SRIO2: Board has SRIO 2 port available&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SRIO_PCIE_BOOT_MASTER Board can support master function for Boot from SRIO and PCIE&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_SRIOn_MEM_VIRT: Virtual Address of SRIO port &#39;n&#39; memory region&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_SRIOn_MEM_PHYxS: Physical Address of SRIO port &#39;n&#39; memory region&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_SRIOn_MEM_SIZE: Size of SRIO port &#39;n&#39; memory region&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_NAND_BUSWIDTH_16BIT Defined to tell the NAND controller that the NAND chip is using a 16 bit bus. Not all NAND drivers use this symbol. Example of drivers that use it: - drivers/mtd/nand/raw/ndfc.c - drivers/mtd/nand/raw/mxc_nand.c&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_NDFC_EBC0_CFG Sets the EBC0_CFG register for the NDFC. If not defined a default value will be used.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SPD_EEPROM Get DDR timing information from an I2C EEPROM. Common with pluggable memory modules such as SODIMMs&lt;/p&gt; &lt;p&gt;SPD_EEPROM_ADDRESS I2C address of the SPD EEPROM&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_SPD_BUS_NUM If SPD EEPROM is on an I2C bus other than the first one, specify here. Note that the value must resolve to something your driver can deal with.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_FSL_DDR_INTERACTIVE Enable interactive DDR debugging. See doc/README.fsl-ddr.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_FSL_DDR_SYNC_REFRESH Enable sync of refresh for multiple controllers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_FSL_DDR_BIST Enable built-in memory test for Freescale DDR controllers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_RMII Enable RMII mode for all FECs. Note that this is a global option, we can&#39;t have one FEC in standard MII mode and another in RMII mode.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_CRC32_VERIFY Add a verify option to the crc32 command. The syntax is:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  =&amp;gt; crc32 -v &amp;lt;address&amp;gt; &amp;lt;count&amp;gt; &amp;lt;crc32&amp;gt;&#xA;&#xA;  Where address/count indicate a memory area&#xA;  and crc32 is the correct crc32 which the&#xA;  area should have.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_LOOPW Add the &#34;loopw&#34; memory command. This only takes effect if the memory commands are activated globally (CONFIG_CMD_MEMORY).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_CMD_MX_CYCLIC Add the &#34;mdc&#34; and &#34;mwc&#34; memory commands. These are cyclic &#34;md/mw&#34; commands. Examples:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  =&amp;gt; mdc.b 10 4 500&#xA;  This command will print 4 bytes (10,11,12,13) each 500 ms.&#xA;&#xA;  =&amp;gt; mwc.l 100 12345678 10&#xA;  This command will write 12345678 to address 100 all 10 ms.&#xA;&#xA;  This only takes effect if the memory commands are activated&#xA;  globally (CONFIG_CMD_MEMORY).&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SPL_BUILD Set when the currently-running compilation is for an artifact that will end up in the SPL (as opposed to the TPL or U-Boot proper). Code that needs stage-specific behavior should check this.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_TPL_BUILD Set when the currently-running compilation is for an artifact that will end up in the TPL (as opposed to the SPL or U-Boot proper). Code that needs stage-specific behavior should check this.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_ARCH_MAP_SYSMEM Generally U-Boot (and in particular the md command) uses effective address. It is therefore not necessary to regard U-Boot address as virtual addresses that need to be translated to physical addresses. However, sandbox requires this, since it maintains its own little RAM buffer which contains all addressable memory. This option causes some memory accesses to be mapped through map_sysmem() / unmap_sysmem().&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_X86_RESET_VECTOR If defined, the x86 reset vector code is included. This is not needed when U-Boot is running from Coreboot.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_NAND_NO_SUBPAGE_WRITE Option to disable subpage write in NAND driver driver that uses this: drivers/mtd/nand/raw/davinci_nand.c&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Freescale QE/FMAN Firmware Support:&lt;/h2&gt; &#xA;&lt;p&gt;The Freescale QUICCEngine (QE) and Frame Manager (FMAN) both support the loading of &#34;firmware&#34;, which is encoded in the QE firmware binary format. This firmware often needs to be loaded during U-Boot booting, so macros are used to identify the storage device (NOR flash, SPI, etc) and the address within that device.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_FMAN_FW_ADDR The address in the storage device where the FMAN microcode is located. The meaning of this address depends on which CONFIG_SYS_QE_FMAN_FW_IN_xxx macro is also specified.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_QE_FW_ADDR The address in the storage device where the QE microcode is located. The meaning of this address depends on which CONFIG_SYS_QE_FMAN_FW_IN_xxx macro is also specified.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_QE_FMAN_FW_LENGTH The maximum possible size of the firmware. The firmware binary format has a field that specifies the actual size of the firmware, but it might not be possible to read any part of the firmware unless some local storage is allocated to hold the entire firmware first.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_QE_FMAN_FW_IN_NOR Specifies that QE/FMAN firmware is located in NOR flash, mapped as normal addressable memory via the LBC. CONFIG_SYS_FMAN_FW_ADDR is the virtual address in NOR flash.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_QE_FMAN_FW_IN_NAND Specifies that QE/FMAN firmware is located in NAND flash. CONFIG_SYS_FMAN_FW_ADDR is the offset within NAND flash.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_QE_FMAN_FW_IN_MMC Specifies that QE/FMAN firmware is located on the primary SD/MMC device. CONFIG_SYS_FMAN_FW_ADDR is the byte offset on that device.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CONFIG_SYS_QE_FMAN_FW_IN_REMOTE Specifies that QE/FMAN firmware is located in the remote (master) memory space. CONFIG_SYS_FMAN_FW_ADDR is a virtual address which can be mapped from slave TLB-&amp;gt;slave LAW-&amp;gt;slave SRIO or PCIE outbound window-&amp;gt;master inbound window-&amp;gt;master LAW-&amp;gt;the ucode address in master&#39;s memory space.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Freescale Layerscape Management Complex Firmware Support:&lt;/h2&gt; &#xA;&lt;p&gt;The Freescale Layerscape Management Complex (MC) supports the loading of &#34;firmware&#34;. This firmware often needs to be loaded during U-Boot booting, so macros are used to identify the storage device (NOR flash, SPI, etc) and the address within that device.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CONFIG_FSL_MC_ENET Enable the MC driver for Layerscape SoCs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Freescale Layerscape Debug Server Support:&lt;/h2&gt; &#xA;&lt;p&gt;The Freescale Layerscape Debug Server Support supports the loading of &#34;Debug Server firmware&#34; and triggering SP boot-rom. This firmware often needs to be loaded during U-Boot booting.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CONFIG_SYS_MC_RSV_MEM_ALIGN Define alignment of reserved memory MC requires&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Reproducible builds&lt;/h2&gt; &#xA;&lt;p&gt;In order to achieve reproducible builds, timestamps used in the U-Boot build process have to be set to a fixed value.&lt;/p&gt; &#xA;&lt;p&gt;This is done using the SOURCE_DATE_EPOCH environment variable. SOURCE_DATE_EPOCH is to be set on the build host&#39;s shell, not as a configuration option for U-Boot or an environment variable in U-Boot.&lt;/p&gt; &#xA;&lt;p&gt;SOURCE_DATE_EPOCH should be set to a number of seconds since the epoch, in UTC.&lt;/p&gt; &#xA;&lt;h1&gt;Building the Software:&lt;/h1&gt; &#xA;&lt;p&gt;Building U-Boot has been tested in several native build environments and in many different cross environments. Of course we cannot support all possibly existing versions of cross development tools in all (potentially obsolete) versions. In case of tool chain problems we recommend to use the ELDK (see &lt;a href=&#34;https://www.denx.de/wiki/DULG/ELDK&#34;&gt;https://www.denx.de/wiki/DULG/ELDK&lt;/a&gt;) which is extensively used to build and test U-Boot.&lt;/p&gt; &#xA;&lt;p&gt;If you are not using a native environment, it is assumed that you have GNU cross compiling tools available in your path. In this case, you must set the environment variable CROSS_COMPILE in your shell. Note that no changes to the Makefile or any other source files are necessary. For example using the ELDK on a 4xx CPU, please enter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ CROSS_COMPILE=ppc_4xx-&#xA;$ export CROSS_COMPILE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;U-Boot is intended to be simple to build. After installing the sources you must configure U-Boot for one specific board type. This is done by typing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make NAME_defconfig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &#34;NAME_defconfig&#34; is the name of one of the existing configu- rations; see configs/*_defconfig for supported names.&lt;/p&gt; &#xA;&lt;p&gt;Note: for some boards special configuration names may exist; check if additional information is available from the board vendor; for instance, the TQM823L systems are available without (standard) or with LCD support. You can select such additional &#34;features&#34; when choosing the configuration, i. e.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  make TQM823L_defconfig&#xA;- will configure for a plain TQM823L, i. e. no LCD support&#xA;&#xA;  make TQM823L_LCD_defconfig&#xA;- will configure for a TQM823L with U-Boot console on LCD&#xA;&#xA;  etc.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, type &#34;make all&#34;, and you should get some working U-Boot images ready for download to / installation on your system:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;u-boot.bin&#34; is a raw binary image&lt;/li&gt; &#xA; &lt;li&gt;&#34;u-boot&#34; is an image in ELF binary format&lt;/li&gt; &#xA; &lt;li&gt;&#34;u-boot.srec&#34; is in Motorola S-Record format&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default the build is performed locally and the objects are saved in the source directory. One of the two methods can be used to change this behavior and build U-Boot to some external directory:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add O= to the make command line invocations:&lt;/p&gt; &lt;p&gt;make O=/tmp/build distclean make O=/tmp/build NAME_defconfig make O=/tmp/build all&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Set environment variable KBUILD_OUTPUT to point to the desired location:&lt;/p&gt; &lt;p&gt;export KBUILD_OUTPUT=/tmp/build make distclean make NAME_defconfig make all&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note that the command line &#34;O=&#34; setting overrides the KBUILD_OUTPUT environment variable.&lt;/p&gt; &#xA;&lt;p&gt;User specific CPPFLAGS, AFLAGS and CFLAGS can be passed to the compiler by setting the according environment variables KCPPFLAGS, KAFLAGS and KCFLAGS. For example to treat all compiler warnings as errors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make KCFLAGS=-Werror&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please be aware that the Makefiles assume you are using GNU make, so for instance on NetBSD you might need to use &#34;gmake&#34; instead of native &#34;make&#34;.&lt;/p&gt; &#xA;&lt;p&gt;If the system board that you have is not listed, then you will need to port U-Boot to your hardware platform. To do this, follow these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a new directory to hold your board specific code. Add any files you need. In your board directory, you will need at least the &#34;Makefile&#34; and a &#34;&#xA;  &lt;board&gt;&#xA;   .c&#34;.&#xA;  &lt;/board&gt;&lt;/li&gt; &#xA; &lt;li&gt;Create a new configuration file &#34;include/configs/&#xA;  &lt;board&gt;&#xA;   .h&#34; for your board.&#xA;  &lt;/board&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you&#39;re porting U-Boot to a new CPU, then also create a new directory to hold your CPU specific code. Add any files you need.&lt;/li&gt; &#xA; &lt;li&gt;Run &#34;make &#xA;  &lt;board&gt;&#xA;   _defconfig&#34; with your new name.&#xA;  &lt;/board&gt;&lt;/li&gt; &#xA; &lt;li&gt;Type &#34;make&#34;, and you should get a working &#34;u-boot.srec&#34; file to be installed on your target system.&lt;/li&gt; &#xA; &lt;li&gt;Debug and solve any problems that might arise. [Of course, this last step is much harder than it sounds.]&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Testing of U-Boot Modifications, Ports to New Hardware, etc.:&lt;/h1&gt; &#xA;&lt;p&gt;If you have modified U-Boot sources (for instance added a new board or support for new devices, a new CPU, etc.) you are expected to provide feedback to the other developers. The feedback normally takes the form of a &#34;patch&#34;, i.e. a context diff against a certain (latest official or latest in the git repository) version of U-Boot sources.&lt;/p&gt; &#xA;&lt;p&gt;But before you submit such a patch, please verify that your modifi- cation did not break existing code. At least make sure that &lt;em&gt;ALL&lt;/em&gt; of the supported boards compile WITHOUT ANY compiler warnings. To do so, just run the buildman script (tools/buildman/buildman), which will configure and build U-Boot for ALL supported system. Be warned, this will take a while. Please see the buildman README, or run &#39;buildman -H&#39; for documentation.&lt;/p&gt; &#xA;&lt;p&gt;See also &#34;U-Boot Porting Guide&#34; below.&lt;/p&gt; &#xA;&lt;h1&gt;Monitor Commands - Overview:&lt;/h1&gt; &#xA;&lt;p&gt;go - start application at address &#39;addr&#39; run - run commands in an environment variable bootm - boot application image from memory bootp - boot image via network using BootP/TFTP protocol bootz - boot zImage from memory tftpboot- boot image via network using TFTP protocol and env variables &#34;ipaddr&#34; and &#34;serverip&#34; (and eventually &#34;gatewayip&#34;) tftpput - upload a file via network using TFTP protocol rarpboot- boot image via network using RARP/TFTP protocol diskboot- boot from IDE devicebootd - boot default, i.e., run &#39;bootcmd&#39; loads - load S-Record file over serial line loadb - load binary file over serial line (kermit mode) loadm - load binary blob from source address to destination address md - memory display mm - memory modify (auto-incrementing) nm - memory modify (constant address) mw - memory write (fill) ms - memory search cp - memory copy cmp - memory compare crc32 - checksum calculation i2c - I2C sub-system sspi - SPI utility commands base - print or set address offset printenv- print environment variables pwm - control pwm channels setenv - set environment variables saveenv - save environment variables to persistent storage protect - enable or disable FLASH write protection erase - erase FLASH memory flinfo - print FLASH memory information nand - NAND memory operations (see doc/README.nand) bdinfo - print Board Info structure iminfo - print header information for application image coninfo - print console devices and informations ide - IDE sub-system loop - infinite loop on address range loopw - infinite write loop on address range mtest - simple RAM test icache - enable or disable instruction cache dcache - enable or disable data cache reset - Perform RESET of the CPU echo - echo args to console version - print monitor version help - print online help ? - alias for &#39;help&#39;&lt;/p&gt; &#xA;&lt;h1&gt;Monitor Commands - Detailed Description:&lt;/h1&gt; &#xA;&lt;p&gt;TODO.&lt;/p&gt; &#xA;&lt;p&gt;For now: just type &#34;help &lt;command&gt;&#34;.&lt;/p&gt; &#xA;&lt;h1&gt;Note for Redundant Ethernet Interfaces:&lt;/h1&gt; &#xA;&lt;p&gt;Some boards come with redundant Ethernet interfaces; U-Boot supports such configurations and is capable of automatic selection of a &#34;working&#34; interface when needed. MAC assignment works as follows:&lt;/p&gt; &#xA;&lt;p&gt;Network interfaces are numbered eth0, eth1, eth2, ... Corresponding MAC addresses can be stored in the environment as &#34;ethaddr&#34; (=&amp;gt;eth0), &#34;eth1addr&#34; (=&amp;gt;eth1), &#34;eth2addr&#34;, ...&lt;/p&gt; &#xA;&lt;p&gt;If the network interface stores some valid MAC address (for instance in SROM), this is used as default address if there is NO correspon- ding setting in the environment; if the corresponding environment variable is set, this overrides the settings in the card; that means:&lt;/p&gt; &#xA;&lt;p&gt;o If the SROM has a valid MAC address, and there is no address in the environment, the SROM&#39;s address is used.&lt;/p&gt; &#xA;&lt;p&gt;o If there is no valid address in the SROM, and a definition in the environment exists, then the value from the environment variable is used.&lt;/p&gt; &#xA;&lt;p&gt;o If both the SROM and the environment contain a MAC address, and both addresses are the same, this MAC address is used.&lt;/p&gt; &#xA;&lt;p&gt;o If both the SROM and the environment contain a MAC address, and the addresses differ, the value from the environment is used and a warning is printed.&lt;/p&gt; &#xA;&lt;p&gt;o If neither SROM nor the environment contain a MAC address, an error is raised. If CONFIG_NET_RANDOM_ETHADDR is defined, then in this case a random, locally-assigned MAC is used.&lt;/p&gt; &#xA;&lt;p&gt;If Ethernet drivers implement the &#39;write_hwaddr&#39; function, valid MAC addresses will be programmed into hardware as part of the initialization process. This may be skipped by setting the appropriate &#39;ethmacskip&#39; environment variable. The naming convention is as follows: &#34;ethmacskip&#34; (=&amp;gt;eth0), &#34;eth1macskip&#34; (=&amp;gt;eth1) etc.&lt;/p&gt; &#xA;&lt;h1&gt;Image Formats:&lt;/h1&gt; &#xA;&lt;p&gt;U-Boot is capable of booting (and performing other auxiliary operations on) images in two formats:&lt;/p&gt; &#xA;&lt;h2&gt;New uImage format (FIT)&lt;/h2&gt; &#xA;&lt;p&gt;Flexible and powerful format based on Flattened Image Tree -- FIT (similar to Flattened Device Tree). It allows the use of images with multiple components (several kernels, ramdisks, etc.), with contents protected by SHA1, MD5 or CRC32. More details are found in the doc/uImage.FIT directory.&lt;/p&gt; &#xA;&lt;h2&gt;Old uImage format&lt;/h2&gt; &#xA;&lt;p&gt;Old image format is based on binary files which can be basically anything, preceded by a special header; see the definitions in include/image.h for details; basically, the header defines the following image properties:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Target Operating System (Provisions for OpenBSD, NetBSD, FreeBSD, 4.4BSD, Linux, SVR4, Esix, Solaris, Irix, SCO, Dell, NCR, VxWorks, LynxOS, pSOS, QNX, RTEMS, INTEGRITY; Currently supported: Linux, NetBSD, VxWorks, QNX, RTEMS, INTEGRITY).&lt;/li&gt; &#xA; &lt;li&gt;Target CPU Architecture (Provisions for Alpha, ARM, Intel x86, IA64, MIPS, Nios II, PowerPC, IBM S390, SuperH, Sparc, Sparc 64 Bit; Currently supported: ARM, Intel x86, MIPS, Nios II, PowerPC).&lt;/li&gt; &#xA; &lt;li&gt;Compression Type (uncompressed, gzip, bzip2)&lt;/li&gt; &#xA; &lt;li&gt;Load Address&lt;/li&gt; &#xA; &lt;li&gt;Entry Point&lt;/li&gt; &#xA; &lt;li&gt;Image Name&lt;/li&gt; &#xA; &lt;li&gt;Image Timestamp&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The header is marked by a special Magic Number, and both the header and the data portions of the image are secured against corruption by CRC32 checksums.&lt;/p&gt; &#xA;&lt;h1&gt;Linux Support:&lt;/h1&gt; &#xA;&lt;p&gt;Although U-Boot should support any OS or standalone application easily, the main focus has always been on Linux during the design of U-Boot.&lt;/p&gt; &#xA;&lt;p&gt;U-Boot includes many features that so far have been part of some special &#34;boot loader&#34; code within the Linux kernel. Also, any &#34;initrd&#34; images to be used are no longer part of one big Linux image; instead, kernel and &#34;initrd&#34; are separate images. This implementation serves several purposes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;the same features can be used for other OS or standalone applications (for instance: using compressed images to reduce the Flash memory footprint)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;it becomes much easier to port new Linux kernel versions because lots of low-level, hardware dependent stuff are done by U-Boot&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;the same Linux kernel image can now be used with different &#34;initrd&#34; images; of course this also means that different kernel images can be run with the same &#34;initrd&#34;. This makes testing easier (you don&#39;t have to build a new &#34;zImage.initrd&#34; Linux image when you just change a file in your &#34;initrd&#34;). Also, a field-upgrade of the software is easier now.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Linux HOWTO:&lt;/h1&gt; &#xA;&lt;h2&gt;Porting Linux to U-Boot based systems:&lt;/h2&gt; &#xA;&lt;p&gt;U-Boot cannot save you from doing all the necessary modifications to configure the Linux device drivers for use with your target hardware (no, we don&#39;t intend to provide a full virtual machine interface to Linux :-).&lt;/p&gt; &#xA;&lt;p&gt;But now you can ignore ALL boot loader code (in arch/powerpc/mbxboot).&lt;/p&gt; &#xA;&lt;p&gt;Just make sure your machine specific header file (for instance include/asm-ppc/tqm8xx.h) includes the same definition of the Board Information structure as we define in include/asm-&#xA; &lt;arch&gt;&#xA;  /u-boot.h, and make sure that your definition of IMAP_ADDR uses the same value as your U-Boot configuration in CONFIG_SYS_IMMR.&#xA; &lt;/arch&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that U-Boot now has a driver model, a unified model for drivers. If you are adding a new driver, plumb it into driver model. If there is no uclass available, you are encouraged to create one. See doc/driver-model.&lt;/p&gt; &#xA;&lt;h2&gt;Configuring the Linux kernel:&lt;/h2&gt; &#xA;&lt;p&gt;No specific requirements for U-Boot. Make sure you have some root device (initial ramdisk, NFS) for your target system.&lt;/p&gt; &#xA;&lt;h2&gt;Building a Linux Image:&lt;/h2&gt; &#xA;&lt;p&gt;With U-Boot, &#34;normal&#34; build targets like &#34;zImage&#34; or &#34;bzImage&#34; are not used. If you use recent kernel source, a new build target &#34;uImage&#34; will exist which automatically builds an image usable by U-Boot. Most older kernels also have support for a &#34;pImage&#34; target, which was introduced for our predecessor project PPCBoot and uses a 100% compatible format.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make TQM850L_defconfig&#xA;make oldconfig&#xA;make dep&#xA;make uImage&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &#34;uImage&#34; build target uses a special tool (in &#39;tools/mkimage&#39;) to encapsulate a compressed Linux kernel image with header information, CRC32 checksum etc. for use with U-Boot. This is what we are doing:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;build a standard &#34;vmlinux&#34; kernel image (in ELF binary format):&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;convert the kernel into a raw binary image:&lt;/p&gt; &lt;p&gt;${CROSS_COMPILE}-objcopy -O binary &lt;br&gt; -R .note -R .comment &lt;br&gt; -S vmlinux linux.bin&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;compress the binary image:&lt;/p&gt; &lt;p&gt;gzip -9 linux.bin&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;package compressed binary image for U-Boot:&lt;/p&gt; &lt;p&gt;mkimage -A ppc -O linux -T kernel -C gzip &lt;br&gt; -a 0 -e 0 -n &#34;Linux Kernel Image&#34; &lt;br&gt; -d linux.bin.gz uImage&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &#34;mkimage&#34; tool can also be used to create ramdisk images for use with U-Boot, either separated from the Linux kernel image, or combined into one file. &#34;mkimage&#34; encapsulates the images with a 64 byte header containing information about target architecture, operating system, image type, compression method, entry points, time stamp, CRC32 checksums, etc.&lt;/p&gt; &#xA;&lt;p&gt;&#34;mkimage&#34; can be called in two ways: to verify existing images and print the header information, or to build new images.&lt;/p&gt; &#xA;&lt;p&gt;In the first form (with &#34;-l&#34; option) mkimage lists the information contained in the header of an existing U-Boot image; this includes checksum verification:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tools/mkimage -l image&#xA;  -l ==&amp;gt; list image header information&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The second form (with &#34;-d&#34; option) is used to build a U-Boot image from a &#34;data file&#34; which is used as image payload:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tools/mkimage -A arch -O os -T type -C comp -a addr -e ep \&#xA;&#x9;      -n name -d data_file image&#xA;  -A ==&amp;gt; set architecture to &#39;arch&#39;&#xA;  -O ==&amp;gt; set operating system to &#39;os&#39;&#xA;  -T ==&amp;gt; set image type to &#39;type&#39;&#xA;  -C ==&amp;gt; set compression type &#39;comp&#39;&#xA;  -a ==&amp;gt; set load address to &#39;addr&#39; (hex)&#xA;  -e ==&amp;gt; set entry point to &#39;ep&#39; (hex)&#xA;  -n ==&amp;gt; set image name to &#39;name&#39;&#xA;  -d ==&amp;gt; use image data from &#39;datafile&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Right now, all Linux kernels for PowerPC systems use the same load address (0x00000000), but the entry point address depends on the kernel version:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;2.2.x kernels have the entry point at 0x0000000C,&lt;/li&gt; &#xA; &lt;li&gt;2.3.x and later kernels have the entry point at 0x00000000.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;So a typical call to build a U-Boot image would read:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-&amp;gt; tools/mkimage -n &#39;2.4.4 kernel for TQM850L&#39; \&#xA;&amp;gt; -A ppc -O linux -T kernel -C gzip -a 0 -e 0 \&#xA;&amp;gt; -d /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/powerpc/coffboot/vmlinux.gz \&#xA;&amp;gt; examples/uImage.TQM850L&#xA;Image Name:   2.4.4 kernel for TQM850L&#xA;Created:      Wed Jul 19 02:34:59 2000&#xA;Image Type:   PowerPC Linux Kernel Image (gzip compressed)&#xA;Data Size:    335725 Bytes = 327.86 kB = 0.32 MB&#xA;Load Address: 0x00000000&#xA;Entry Point:  0x00000000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To verify the contents of the image (or check for corruption):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-&amp;gt; tools/mkimage -l examples/uImage.TQM850L&#xA;Image Name:   2.4.4 kernel for TQM850L&#xA;Created:      Wed Jul 19 02:34:59 2000&#xA;Image Type:   PowerPC Linux Kernel Image (gzip compressed)&#xA;Data Size:    335725 Bytes = 327.86 kB = 0.32 MB&#xA;Load Address: 0x00000000&#xA;Entry Point:  0x00000000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: for embedded systems where boot time is critical you can trade speed for memory and install an UNCOMPRESSED image instead: this needs more space in Flash, but boots much faster since it does not need to be uncompressed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-&amp;gt; gunzip /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/powerpc/coffboot/vmlinux.gz&#xA;-&amp;gt; tools/mkimage -n &#39;2.4.4 kernel for TQM850L&#39; \&#xA;&amp;gt; -A ppc -O linux -T kernel -C none -a 0 -e 0 \&#xA;&amp;gt; -d /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/powerpc/coffboot/vmlinux \&#xA;&amp;gt; examples/uImage.TQM850L-uncompressed&#xA;Image Name:   2.4.4 kernel for TQM850L&#xA;Created:      Wed Jul 19 02:34:59 2000&#xA;Image Type:   PowerPC Linux Kernel Image (uncompressed)&#xA;Data Size:    792160 Bytes = 773.59 kB = 0.76 MB&#xA;Load Address: 0x00000000&#xA;Entry Point:  0x00000000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similar you can build U-Boot images from a &#39;ramdisk.image.gz&#39; file when your kernel is intended to use an initial ramdisk:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-&amp;gt; tools/mkimage -n &#39;Simple Ramdisk Image&#39; \&#xA;&amp;gt; -A ppc -O linux -T ramdisk -C gzip \&#xA;&amp;gt; -d /LinuxPPC/images/SIMPLE-ramdisk.image.gz examples/simple-initrd&#xA;Image Name:   Simple Ramdisk Image&#xA;Created:      Wed Jan 12 14:01:50 2000&#xA;Image Type:   PowerPC Linux RAMDisk Image (gzip compressed)&#xA;Data Size:    566530 Bytes = 553.25 kB = 0.54 MB&#xA;Load Address: 0x00000000&#xA;Entry Point:  0x00000000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &#34;dumpimage&#34; tool can be used to disassemble or list the contents of images built by mkimage. See dumpimage&#39;s help output (-h) for details.&lt;/p&gt; &#xA;&lt;h2&gt;Installing a Linux Image:&lt;/h2&gt; &#xA;&lt;p&gt;To downloading a U-Boot image over the serial (console) interface, you must convert the image to S-Record format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;objcopy -I binary -O srec examples/image examples/image.srec&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &#39;objcopy&#39; does not understand the information in the U-Boot image header, so the resulting S-Record file will be relative to address 0x00000000. To load it to a given address, you need to specify the target address as &#39;offset&#39; parameter with the &#39;loads&#39; command.&lt;/p&gt; &#xA;&lt;p&gt;Example: install the image to address 0x40100000 (which on the TQM8xxL is in the first Flash bank):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;=&amp;gt; erase 40100000 401FFFFF&#xA;&#xA;.......... done&#xA;Erased 8 sectors&#xA;&#xA;=&amp;gt; loads 40100000&#xA;## Ready for S-Record download ...&#xA;~&amp;gt;examples/image.srec&#xA;1 2 3 4 5 6 7 8 9 10 11 12 13 ...&#xA;...&#xA;15989 15990 15991 15992&#xA;[file transfer complete]&#xA;[connected]&#xA;## Start Addr = 0x00000000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can check the success of the download using the &#39;iminfo&#39; command; this includes a checksum verification so you can be sure no data corruption happened:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;=&amp;gt; imi 40100000&#xA;&#xA;## Checking Image at 40100000 ...&#xA;   Image Name:&#x9; 2.2.13 for initrd on TQM850L&#xA;   Image Type:&#x9; PowerPC Linux Kernel Image (gzip compressed)&#xA;   Data Size:&#x9; 335725 Bytes = 327 kB = 0 MB&#xA;   Load Address: 00000000&#xA;   Entry Point:&#x9; 0000000c&#xA;   Verifying Checksum ... OK&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Boot Linux:&lt;/h2&gt; &#xA;&lt;p&gt;The &#34;bootm&#34; command is used to boot an application that is stored in memory (RAM or Flash). In case of a Linux kernel image, the contents of the &#34;bootargs&#34; environment variable is passed to the kernel as parameters. You can check and modify this variable using the &#34;printenv&#34; and &#34;setenv&#34; commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;=&amp;gt; printenv bootargs&#xA;bootargs=root=/dev/ram&#xA;&#xA;=&amp;gt; setenv bootargs root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2&#xA;&#xA;=&amp;gt; printenv bootargs&#xA;bootargs=root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2&#xA;&#xA;=&amp;gt; bootm 40020000&#xA;## Booting Linux kernel at 40020000 ...&#xA;   Image Name:&#x9; 2.2.13 for NFS on TQM850L&#xA;   Image Type:&#x9; PowerPC Linux Kernel Image (gzip compressed)&#xA;   Data Size:&#x9; 381681 Bytes = 372 kB = 0 MB&#xA;   Load Address: 00000000&#xA;   Entry Point:&#x9; 0000000c&#xA;   Verifying Checksum ... OK&#xA;   Uncompressing Kernel Image ... OK&#xA;Linux version 2.2.13 (wd@denx.local.net) (gcc version 2.95.2 19991024 (release)) #1 Wed Jul 19 02:35:17 MEST 2000&#xA;Boot arguments: root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2&#xA;time_init: decrementer frequency = 187500000/60&#xA;Calibrating delay loop... 49.77 BogoMIPS&#xA;Memory: 15208k available (700k kernel code, 444k data, 32k init) [c0000000,c1000000]&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to boot a Linux kernel with initial RAM disk, you pass the memory addresses of both the kernel and the initrd image (PPBCOOT format!) to the &#34;bootm&#34; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;=&amp;gt; imi 40100000 40200000&#xA;&#xA;## Checking Image at 40100000 ...&#xA;   Image Name:&#x9; 2.2.13 for initrd on TQM850L&#xA;   Image Type:&#x9; PowerPC Linux Kernel Image (gzip compressed)&#xA;   Data Size:&#x9; 335725 Bytes = 327 kB = 0 MB&#xA;   Load Address: 00000000&#xA;   Entry Point:&#x9; 0000000c&#xA;   Verifying Checksum ... OK&#xA;&#xA;## Checking Image at 40200000 ...&#xA;   Image Name:&#x9; Simple Ramdisk Image&#xA;   Image Type:&#x9; PowerPC Linux RAMDisk Image (gzip compressed)&#xA;   Data Size:&#x9; 566530 Bytes = 553 kB = 0 MB&#xA;   Load Address: 00000000&#xA;   Entry Point:&#x9; 00000000&#xA;   Verifying Checksum ... OK&#xA;&#xA;=&amp;gt; bootm 40100000 40200000&#xA;## Booting Linux kernel at 40100000 ...&#xA;   Image Name:&#x9; 2.2.13 for initrd on TQM850L&#xA;   Image Type:&#x9; PowerPC Linux Kernel Image (gzip compressed)&#xA;   Data Size:&#x9; 335725 Bytes = 327 kB = 0 MB&#xA;   Load Address: 00000000&#xA;   Entry Point:&#x9; 0000000c&#xA;   Verifying Checksum ... OK&#xA;   Uncompressing Kernel Image ... OK&#xA;## Loading RAMDisk Image at 40200000 ...&#xA;   Image Name:&#x9; Simple Ramdisk Image&#xA;   Image Type:&#x9; PowerPC Linux RAMDisk Image (gzip compressed)&#xA;   Data Size:&#x9; 566530 Bytes = 553 kB = 0 MB&#xA;   Load Address: 00000000&#xA;   Entry Point:&#x9; 00000000&#xA;   Verifying Checksum ... OK&#xA;   Loading Ramdisk ... OK&#xA;Linux version 2.2.13 (wd@denx.local.net) (gcc version 2.95.2 19991024 (release)) #1 Wed Jul 19 02:32:08 MEST 2000&#xA;Boot arguments: root=/dev/ram&#xA;time_init: decrementer frequency = 187500000/60&#xA;Calibrating delay loop... 49.77 BogoMIPS&#xA;...&#xA;RAMDISK: Compressed image found at block 0&#xA;VFS: Mounted root (ext2 filesystem).&#xA;&#xA;bash#&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Boot Linux and pass a flat device tree:&lt;/h2&gt; &#xA;&lt;p&gt;First, U-Boot must be compiled with the appropriate defines. See the section titled &#34;Linux Kernel Interface&#34; above for a more in depth explanation. The following is an example of how to start a kernel and pass an updated flat device tree:&lt;/p&gt; &#xA;&lt;p&gt;=&amp;gt; print oftaddr oftaddr=0x300000 =&amp;gt; print oft oft=oftrees/mpc8540ads.dtb =&amp;gt; tftp $oftaddr $oft Speed: 1000, full duplex Using TSEC0 device TFTP from server 192.168.1.1; our IP address is 192.168.1.101 Filename &#39;oftrees/mpc8540ads.dtb&#39;. Load address: 0x300000 Loading: # done Bytes transferred = 4106 (100a hex) =&amp;gt; tftp $loadaddr $bootfile Speed: 1000, full duplex Using TSEC0 device TFTP from server 192.168.1.1; our IP address is 192.168.1.2 Filename &#39;uImage&#39;. Load address: 0x200000 Loading:############ done Bytes transferred = 1029407 (fb51f hex) =&amp;gt; print loadaddr loadaddr=200000 =&amp;gt; print oftaddr oftaddr=0x300000 =&amp;gt; bootm $loadaddr - $oftaddr&lt;/p&gt; &#xA;&lt;h2&gt;Booting image at 00200000 ...&lt;/h2&gt; &#xA;&lt;p&gt;Image Name: Linux-2.6.17-dirty Image Type: PowerPC Linux Kernel Image (gzip compressed) Data Size: 1029343 Bytes = 1005.2 kB Load Address: 00000000 Entry Point: 00000000 Verifying Checksum ... OK Uncompressing Kernel Image ... OK Booting using flat device tree at 0x300000 Using MPC85xx ADS machine description Memory CAM mapping: CAM0=256Mb, CAM1=256Mb, CAM2=0Mb residual: 0Mb [snip]&lt;/p&gt; &#xA;&lt;h2&gt;More About U-Boot Image Types:&lt;/h2&gt; &#xA;&lt;p&gt;U-Boot supports the following image types:&lt;/p&gt; &#xA;&lt;p&gt;&#34;Standalone Programs&#34; are directly runnable in the environment provided by U-Boot; it is expected that (if they behave well) you can continue to work in U-Boot after return from the Standalone Program. &#34;OS Kernel Images&#34; are usually images of some Embedded OS which will take over control completely. Usually these programs will install their own set of exception handlers, device drivers, set up the MMU, etc. - this means, that you cannot expect to re-enter U-Boot except by resetting the CPU. &#34;RAMDisk Images&#34; are more or less just data blocks, and their parameters (address, size) are passed to an OS kernel that is being started. &#34;Multi-File Images&#34; contain several images, typically an OS (Linux) kernel image and one or more data images like RAMDisks. This construct is useful for instance when you want to boot over the network using BOOTP etc., where the boot server provides just a single image file, but you want to get for instance an OS kernel and a RAMDisk image.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;Multi-File Images&#34; start with a list of image sizes, each&#xA;image size (in bytes) specified by an &#34;uint32_t&#34; in network&#xA;byte order. This list is terminated by an &#34;(uint32_t)0&#34;.&#xA;Immediately after the terminating 0 follow the images, one by&#xA;one, all aligned on &#34;uint32_t&#34; boundaries (size rounded up to&#xA;a multiple of 4 bytes).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&#34;Firmware Images&#34; are binary images containing firmware (like U-Boot or FPGA images) which usually will be programmed to flash memory.&lt;/p&gt; &#xA;&lt;p&gt;&#34;Script files&#34; are command sequences that will be executed by U-Boot&#39;s command interpreter; this feature is especially useful when you configure U-Boot to use a real shell (hush) as command interpreter.&lt;/p&gt; &#xA;&lt;h2&gt;Booting the Linux zImage:&lt;/h2&gt; &#xA;&lt;p&gt;On some platforms, it&#39;s possible to boot Linux zImage. This is done using the &#34;bootz&#34; command. The syntax of &#34;bootz&#34; command is the same as the syntax of &#34;bootm&#34; command.&lt;/p&gt; &#xA;&lt;p&gt;Note, defining the CONFIG_SUPPORT_RAW_INITRD allows user to supply kernel with raw initrd images. The syntax is slightly different, the address of the initrd must be augmented by it&#39;s size, in the following format: &#34;&#xA; &lt;initrd addres&gt;&#xA;  :&#xA;  &lt;initrd size&gt;&#xA;   &#34;.&#xA;  &lt;/initrd&gt;&#xA; &lt;/initrd&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Standalone HOWTO:&lt;/h1&gt; &#xA;&lt;p&gt;One of the features of U-Boot is that you can dynamically load and run &#34;standalone&#34; applications, which can use some resources of U-Boot like console I/O functions or interrupt services.&lt;/p&gt; &#xA;&lt;p&gt;Two simple examples are included with the sources:&lt;/p&gt; &#xA;&lt;h2&gt;&#34;Hello World&#34; Demo:&lt;/h2&gt; &#xA;&lt;p&gt;&#39;examples/hello_world.c&#39; contains a small &#34;Hello World&#34; Demo application; it is automatically compiled when you build U-Boot. It&#39;s configured to run at address 0x00040004, so you can play with it like that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;=&amp;gt; loads&#xA;## Ready for S-Record download ...&#xA;~&amp;gt;examples/hello_world.srec&#xA;1 2 3 4 5 6 7 8 9 10 11 ...&#xA;[file transfer complete]&#xA;[connected]&#xA;## Start Addr = 0x00040004&#xA;&#xA;=&amp;gt; go 40004 Hello World! This is a test.&#xA;## Starting application at 0x00040004 ...&#xA;Hello World&#xA;argc = 7&#xA;argv[0] = &#34;40004&#34;&#xA;argv[1] = &#34;Hello&#34;&#xA;argv[2] = &#34;World!&#34;&#xA;argv[3] = &#34;This&#34;&#xA;argv[4] = &#34;is&#34;&#xA;argv[5] = &#34;a&#34;&#xA;argv[6] = &#34;test.&#34;&#xA;argv[7] = &#34;&amp;lt;NULL&amp;gt;&#34;&#xA;Hit any key to exit ...&#xA;&#xA;## Application terminated, rc = 0x0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Another example, which demonstrates how to register a CPM interrupt handler with the U-Boot code, can be found in &#39;examples/timer.c&#39;. Here, a CPM timer is set up to generate an interrupt every second. The interrupt service routine is trivial, just printing a &#39;.&#39; character, but this is just a demo program. The application can be controlled by the following keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;? - print current values og the CPM Timer registers&#xA;b - enable interrupts and start timer&#xA;e - stop timer and disable interrupts&#xA;q - quit application&#xA;&#xA;=&amp;gt; loads&#xA;## Ready for S-Record download ...&#xA;~&amp;gt;examples/timer.srec&#xA;1 2 3 4 5 6 7 8 9 10 11 ...&#xA;[file transfer complete]&#xA;[connected]&#xA;## Start Addr = 0x00040004&#xA;&#xA;=&amp;gt; go 40004&#xA;## Starting application at 0x00040004 ...&#xA;TIMERS=0xfff00980&#xA;Using timer 1&#xA;  tgcr @ 0xfff00980, tmr @ 0xfff00990, trr @ 0xfff00994, tcr @ 0xfff00998, tcn @ 0xfff0099c, ter @ 0xfff009b0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Hit &#39;b&#39;: [q, b, e, ?] Set interval 1000000 us Enabling timer Hit &#39;?&#39;: [q, b, e, ?] ........ tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0xef6, ter=0x0 Hit &#39;?&#39;: [q, b, e, ?] . tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x2ad4, ter=0x0 Hit &#39;?&#39;: [q, b, e, ?] . tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x1efc, ter=0x0 Hit &#39;?&#39;: [q, b, e, ?] . tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x169d, ter=0x0 Hit &#39;e&#39;: [q, b, e, ?] ...Stopping timer Hit &#39;q&#39;: [q, b, e, ?] ## Application terminated, rc = 0x0&lt;/p&gt; &#xA;&lt;h1&gt;Minicom warning:&lt;/h1&gt; &#xA;&lt;p&gt;Over time, many people have reported problems when trying to use the &#34;minicom&#34; terminal emulation program for serial download. I (wd) consider minicom to be broken, and recommend not to use it. Under Unix, I recommend to use C-Kermit for general purpose use (and especially for kermit binary protocol download (&#34;loadb&#34; command), and use &#34;cu&#34; for S-Record download (&#34;loads&#34; command). See &lt;a href=&#34;https://www.denx.de/wiki/view/DULG/SystemSetup#Section_4.3&#34;&gt;https://www.denx.de/wiki/view/DULG/SystemSetup#Section_4.3&lt;/a&gt;. for help with kermit.&lt;/p&gt; &#xA;&lt;p&gt;Nevertheless, if you absolutely want to use it try adding this configuration to your &#34;File transfer protocols&#34; section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   Name&#x9;   Program&#x9;&#x9;&#x9;Name U/D FullScr IO-Red. Multi&#xA;X  kermit  /usr/bin/kermit -i -l %l -s&#x9; Y    U&#x9;   Y&#x9;   N&#x9;  N&#xA;Y  kermit  /usr/bin/kermit -i -l %l -r&#x9; N    D&#x9;   Y&#x9;   N&#x9;  N&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;NetBSD Notes:&lt;/h1&gt; &#xA;&lt;p&gt;Starting at version 0.9.2, U-Boot supports NetBSD both as host (build U-Boot) and target system (boots NetBSD/mpc8xx).&lt;/p&gt; &#xA;&lt;p&gt;Building requires a cross environment; it is known to work on NetBSD/i386 with the cross-powerpc-netbsd-1.3 package (you will also need gmake since the Makefiles are not compatible with BSD make). Note that the cross-powerpc package does not install include files; attempting to build U-Boot will fail because &amp;lt;machine/ansi.h&amp;gt; is missing. This file has to be installed and patched manually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# cd /usr/pkg/cross/powerpc-netbsd/include&#xA;# mkdir powerpc&#xA;# ln -s powerpc machine&#xA;# cp /usr/src/sys/arch/powerpc/include/ansi.h powerpc/ansi.h&#xA;# ${EDIT} powerpc/ansi.h&#x9;## must remove __va_list, _BSD_VA_LIST&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Native builds &lt;em&gt;don&#39;t&lt;/em&gt; work due to incompatibilities between native and U-Boot include files.&lt;/p&gt; &#xA;&lt;p&gt;Booting assumes that (the first part of) the image booted is a stage-2 loader which in turn loads and then invokes the kernel proper. Loader sources will eventually appear in the NetBSD source tree (probably in sys/arc/mpc8xx/stand/u-boot_stage2/); in the meantime, see &lt;a href=&#34;ftp://ftp.denx.de/pub/u-boot/ppcboot_stage2.tar.gz&#34;&gt;ftp://ftp.denx.de/pub/u-boot/ppcboot_stage2.tar.gz&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Implementation Internals:&lt;/h1&gt; &#xA;&lt;p&gt;The following is not intended to be a complete description of every implementation detail. However, it should help to understand the inner workings of U-Boot and make it easier to port it to custom hardware.&lt;/p&gt; &#xA;&lt;h2&gt;Initial Stack, Global Data:&lt;/h2&gt; &#xA;&lt;p&gt;The implementation of U-Boot is complicated by the fact that U-Boot starts running out of ROM (flash memory), usually without access to system RAM (because the memory controller is not initialized yet). This means that we don&#39;t have writable Data or BSS segments, and BSS is not initialized as zero. To be able to get a C environment working at all, we have to allocate at least a minimal stack. Implementation options for this are defined and restricted by the CPU used: Some CPU models provide on-chip memory (like the IMMR area on MPC8xx and MPC826x processors), on others (parts of) the data cache can be locked as (mis-) used as memory, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Chris Hallinan posted a good summary of these issues to the&#xA;U-Boot mailing list:&#xA;&#xA;Subject: RE: [U-Boot-Users] RE: More On Memory Bank x (nothingness)?&#xA;From: &#34;Chris Hallinan&#34; &amp;lt;clh@net1plus.com&amp;gt;&#xA;Date: Mon, 10 Feb 2003 16:43:46 -0500 (22:43 MET)&#xA;...&#xA;&#xA;Correct me if I&#39;m wrong, folks, but the way I understand it&#xA;is this: Using DCACHE as initial RAM for Stack, etc, does not&#xA;require any physical RAM backing up the cache. The cleverness&#xA;is that the cache is being used as a temporary supply of&#xA;necessary storage before the SDRAM controller is setup. It&#39;s&#xA;beyond the scope of this list to explain the details, but you&#xA;can see how this works by studying the cache architecture and&#xA;operation in the architecture and processor-specific manuals.&#xA;&#xA;OCM is On Chip Memory, which I believe the 405GP has 4K. It&#xA;is another option for the system designer to use as an&#xA;initial stack/RAM area prior to SDRAM being available. Either&#xA;option should work for you. Using CS 4 should be fine if your&#xA;board designers haven&#39;t used it for something that would&#xA;cause you grief during the initial boot! It is frequently not&#xA;used.&#xA;&#xA;CONFIG_SYS_INIT_RAM_ADDR should be somewhere that won&#39;t interfere&#xA;with your processor/board/system design. The default value&#xA;you will find in any recent u-boot distribution in&#xA;walnut.h should work for you. I&#39;d set it to a value larger&#xA;than your SDRAM module. If you have a 64MB SDRAM module, set&#xA;it above 400_0000. Just make sure your board has no resources&#xA;that are supposed to respond to that address! That code in&#xA;start.S has been around a while and should work as is when&#xA;you get the config right.&#xA;&#xA;-Chris Hallinan&#xA;DS4.COM, Inc.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is essential to remember this, since it has some impact on the C code for the initialization procedures:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Initialized global data (data segment) is read-only. Do not attempt to write it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Do not use any uninitialized global data (or implicitly initialized as zero data - BSS segment) at all - this is undefined, initiali- zation is performed later (when relocating to RAM).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Stack space is very limited. Avoid big data buffers or things like that.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Having only the stack as writable memory limits means we cannot use normal global data to share information between the code. But it turned out that the implementation of U-Boot can be greatly simplified by making a global data structure (gd_t) available to all functions. We could pass a pointer to this data as argument to &lt;em&gt;all&lt;/em&gt; functions, but this would bloat the code. Instead we use a feature of the GCC compiler (Global Register Variables) to share the data: we place a pointer (gd) to the global data into a register which we reserve for this purpose.&lt;/p&gt; &#xA;&lt;p&gt;When choosing a register for such a purpose we are restricted by the relevant (E)ABI specifications for the current architecture, and by GCC&#39;s implementation.&lt;/p&gt; &#xA;&lt;p&gt;For PowerPC, the following registers have specific use: R1: stack pointer R2: reserved for system use R3-R4: parameter passing and return values R5-R10: parameter passing R13: small data area pointer R30: GOT pointer R31: frame pointer&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;(U-Boot also uses R12 as internal GOT pointer. r12&#xA;is a volatile register so r12 needs to be reset when&#xA;going back and forth between asm and C)&#xA;&#xA;==&amp;gt; U-Boot will use R2 to hold a pointer to the global data&#xA;&#xA;Note: on PPC, we could use a static initializer (since the&#xA;address of the global data structure is known at compile time),&#xA;but it turned out that reserving a register results in somewhat&#xA;smaller code - although the code savings are not that big (on&#xA;average for all boards 752 bytes for the whole U-Boot image,&#xA;624 text + 127 data).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On ARM, the following registers are used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;R0:&#x9;function argument word/integer result&#xA;R1-R3:&#x9;function argument word&#xA;R9:&#x9;platform specific&#xA;R10:&#x9;stack limit (used only if stack checking is enabled)&#xA;R11:&#x9;argument (frame) pointer&#xA;R12:&#x9;temporary workspace&#xA;R13:&#x9;stack pointer&#xA;R14:&#x9;link register&#xA;R15:&#x9;program counter&#xA;&#xA;==&amp;gt; U-Boot will use R9 to hold a pointer to the global data&#xA;&#xA;Note: on ARM, only R_ARM_RELATIVE relocations are supported.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Nios II, the ABI is documented here: &lt;a href=&#34;https://www.altera.com/literature/hb/nios2/n2cpu_nii51016.pdf&#34;&gt;https://www.altera.com/literature/hb/nios2/n2cpu_nii51016.pdf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;==&amp;gt; U-Boot will use gp to hold a pointer to the global data&#xA;&#xA;Note: on Nios II, we give &#34;-G0&#34; option to gcc and don&#39;t use gp&#xA;to access small data sections, so gp is free.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On RISC-V, the following registers are used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;x0: hard-wired zero (zero)&#xA;x1: return address (ra)&#xA;x2:&#x9;stack pointer (sp)&#xA;x3:&#x9;global pointer (gp)&#xA;x4:&#x9;thread pointer (tp)&#xA;x5:&#x9;link register (t0)&#xA;x8:&#x9;frame pointer (fp)&#xA;x10-x11:&#x9;arguments/return values (a0-1)&#xA;x12-x17:&#x9;arguments (a2-7)&#xA;x28-31:&#x9; temporaries (t3-6)&#xA;pc:&#x9;program counter (pc)&#xA;&#xA;==&amp;gt; U-Boot will use gp to hold a pointer to the global data&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Memory Management:&lt;/h2&gt; &#xA;&lt;p&gt;U-Boot runs in system state and uses physical addresses, i.e. the MMU is not used either for address mapping nor for memory protection.&lt;/p&gt; &#xA;&lt;p&gt;The available memory is mapped to fixed addresses using the memory controller. In this process, a contiguous block is formed for each memory type (Flash, SDRAM, SRAM), even when it consists of several physical memory banks.&lt;/p&gt; &#xA;&lt;p&gt;U-Boot is installed in the first 128 kB of the first Flash bank (on TQM8xxL modules this is the range 0x40000000 ... 0x4001FFFF). After booting and sizing and initializing DRAM, the code relocates itself to the upper end of DRAM. Immediately below the U-Boot code some memory is reserved for use by malloc() [see CONFIG_SYS_MALLOC_LEN configuration setting]. Below that, a structure with global Board Info data is placed, followed by the stack (growing downward).&lt;/p&gt; &#xA;&lt;p&gt;Additionally, some exception handler code is copied to the low 8 kB of DRAM (0x00000000 ... 0x00001FFF).&lt;/p&gt; &#xA;&lt;p&gt;So a typical memory configuration with 16 MB of DRAM could look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;0x0000 0000&#x9;Exception Vector code&#xA;      :&#xA;0x0000 1FFF&#xA;0x0000 2000&#x9;Free for Application Use&#xA;      :&#xA;      :&#xA;&#xA;      :&#xA;      :&#xA;0x00FB FF20&#x9;Monitor Stack (Growing downward)&#xA;0x00FB FFAC&#x9;Board Info Data and permanent copy of global data&#xA;0x00FC 0000&#x9;Malloc Arena&#xA;      :&#xA;0x00FD FFFF&#xA;0x00FE 0000&#x9;RAM Copy of Monitor Code&#xA;...&#x9;&#x9;eventually: LCD or video framebuffer&#xA;...&#x9;&#x9;eventually: pRAM (Protected RAM - unchanged by reset)&#xA;0x00FF FFFF&#x9;[End of RAM]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;System Initialization:&lt;/h2&gt; &#xA;&lt;p&gt;In the reset configuration, U-Boot starts at the reset entry point (on most PowerPC systems at address 0x00000100). Because of the reset configuration for CS0# this is a mirror of the on board Flash memory. To be able to re-map memory U-Boot then jumps to its link address. To be able to implement the initialization code in C, a (small!) initial stack is set up in the internal Dual Ported RAM (in case CPUs which provide such a feature like), or in a locked part of the data cache. After that, U-Boot initializes the CPU core, the caches and the SIU.&lt;/p&gt; &#xA;&lt;p&gt;Next, all (potentially) available memory banks are mapped using a preliminary mapping. For example, we put them on 512 MB boundaries (multiples of 0x20000000: SDRAM on 0x00000000 and 0x20000000, Flash on 0x40000000 and 0x60000000, SRAM on 0x80000000). Then UPM A is programmed for SDRAM access. Using the temporary configuration, a simple memory test is run that determines the size of the SDRAM banks.&lt;/p&gt; &#xA;&lt;p&gt;When there is more than one SDRAM bank, and the banks are of different size, the largest is mapped first. For equal size, the first bank (CS2#) is mapped first. The first mapping is always for address 0x00000000, with any additional banks following immediately to create contiguous memory starting from 0.&lt;/p&gt; &#xA;&lt;p&gt;Then, the monitor installs itself at the upper end of the SDRAM area and allocates memory for use by malloc() and for the global Board Info data; also, the exception vector code is copied to the low RAM pages, and the final stack is set up.&lt;/p&gt; &#xA;&lt;p&gt;Only after this relocation will you have a &#34;normal&#34; C environment; until that you are restricted in several ways, mostly because you are running from ROM, and because the code will have to be relocated to a new address in RAM.&lt;/p&gt; &#xA;&lt;h2&gt;U-Boot Porting Guide:&lt;/h2&gt; &#xA;&lt;p&gt;[Based on messages by Jerry Van Baren in the U-Boot-Users mailing list, October 2002]&lt;/p&gt; &#xA;&lt;p&gt;int main(int argc, char *argv[]) { sighandler_t no_more_time;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;signal(SIGALRM, no_more_time);&#xA;alarm(PROJECT_DEADLINE - toSec (3 * WEEK));&#xA;&#xA;if (available_money &amp;gt; available_manpower) {&#xA;&#x9;Pay consultant to port U-Boot;&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;Download latest U-Boot source;&#xA;&#xA;Subscribe to u-boot mailing list;&#xA;&#xA;if (clueless)&#xA;&#x9;email(&#34;Hi, I am new to U-Boot, how do I get started?&#34;);&#xA;&#xA;while (learning) {&#xA;&#x9;Read the README file in the top level directory;&#xA;&#x9;Read https://www.denx.de/wiki/bin/view/DULG/Manual;&#xA;&#x9;Read applicable doc/README.*;&#xA;&#x9;Read the source, Luke;&#xA;&#x9;/* find . -name &#34;*.[chS]&#34; | xargs grep -i &amp;lt;keyword&amp;gt; */&#xA;}&#xA;&#xA;if (available_money &amp;gt; toLocalCurrency ($2500))&#xA;&#x9;Buy a BDI3000;&#xA;else&#xA;&#x9;Add a lot of aggravation and time;&#xA;&#xA;if (a similar board exists) {&#x9;/* hopefully... */&#xA;&#x9;cp -a board/&amp;lt;similar&amp;gt; board/&amp;lt;myboard&amp;gt;&#xA;&#x9;cp include/configs/&amp;lt;similar&amp;gt;.h include/configs/&amp;lt;myboard&amp;gt;.h&#xA;} else {&#xA;&#x9;Create your own board support subdirectory;&#xA;&#x9;Create your own board include/configs/&amp;lt;myboard&amp;gt;.h file;&#xA;}&#xA;Edit new board/&amp;lt;myboard&amp;gt; files&#xA;Edit new include/configs/&amp;lt;myboard&amp;gt;.h&#xA;&#xA;while (!accepted) {&#xA;&#x9;while (!running) {&#xA;&#x9;&#x9;do {&#xA;&#x9;&#x9;&#x9;Add / modify source code;&#xA;&#x9;&#x9;} until (compiles);&#xA;&#x9;&#x9;Debug;&#xA;&#x9;&#x9;if (clueless)&#xA;&#x9;&#x9;&#x9;email(&#34;Hi, I am having problems...&#34;);&#xA;&#x9;}&#xA;&#x9;Send patch file to the U-Boot email list;&#xA;&#x9;if (reasonable critiques)&#xA;&#x9;&#x9;Incorporate improvements from email list code review;&#xA;&#x9;else&#xA;&#x9;&#x9;Defend code as written;&#xA;}&#xA;&#xA;return 0;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;}&lt;/p&gt; &#xA;&lt;p&gt;void no_more_time (int sig) { hire_a_guru(); }&lt;/p&gt; &#xA;&lt;h2&gt;Coding Standards:&lt;/h2&gt; &#xA;&lt;p&gt;All contributions to U-Boot should conform to the Linux kernel coding style; see the kernel coding style guide at &lt;a href=&#34;https://www.kernel.org/doc/html/latest/process/coding-style.html&#34;&gt;https://www.kernel.org/doc/html/latest/process/coding-style.html&lt;/a&gt;, and the script &#34;scripts/Lindent&#34; in your Linux kernel source directory.&lt;/p&gt; &#xA;&lt;p&gt;Source files originating from a different project (for example the MTD subsystem) are generally exempt from these guidelines and are not reformatted to ease subsequent migration to newer versions of those sources.&lt;/p&gt; &#xA;&lt;p&gt;Please note that U-Boot is implemented in C (and to some small parts in Assembler); no C++ is used, so please do not use C++ style comments (//) in your code.&lt;/p&gt; &#xA;&lt;p&gt;Please also stick to the following formatting rules:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;remove any trailing white space&lt;/li&gt; &#xA; &lt;li&gt;use TAB characters for indentation and vertical alignment, not spaces&lt;/li&gt; &#xA; &lt;li&gt;make sure NOT to use DOS &#39;\r\n&#39; line feeds&lt;/li&gt; &#xA; &lt;li&gt;do not add more than 2 consecutive empty lines to source files&lt;/li&gt; &#xA; &lt;li&gt;do not add trailing empty lines to source files&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Submissions which do not conform to the standards may be returned with a request to reformat the changes.&lt;/p&gt; &#xA;&lt;h2&gt;Submitting Patches:&lt;/h2&gt; &#xA;&lt;p&gt;Since the number of patches for U-Boot is growing, we need to establish some rules. Submissions which do not conform to these rules may be rejected, even when they contain important and valuable stuff.&lt;/p&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://www.denx.de/wiki/U-Boot/Patches&#34;&gt;https://www.denx.de/wiki/U-Boot/Patches&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;Patches shall be sent to the u-boot mailing list &lt;a href=&#34;mailto:u-boot@lists.denx.de&#34;&gt;u-boot@lists.denx.de&lt;/a&gt;; see &lt;a href=&#34;https://lists.denx.de/listinfo/u-boot&#34;&gt;https://lists.denx.de/listinfo/u-boot&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;When you send a patch, please include the following information with it:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;For bug fixes: a description of the bug and how your patch fixes this bug. Please try to include a way of demonstrating that the patch actually fixes something.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For new features: a description of the feature and your implementation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For major contributions, add a MAINTAINERS file with your information and associated file and directory references.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;When you add support for a new board, don&#39;t forget to add a maintainer e-mail address to the boards.cfg file, too.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If your patch adds new configuration options, don&#39;t forget to document these in the README file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The patch itself. If you are using git (which is &lt;em&gt;strongly&lt;/em&gt; recommended) you can easily generate the patch using the &#34;git format-patch&#34;. If you then use &#34;git send-email&#34; to send it to the U-Boot mailing list, you will avoid most of the common problems with some other mail clients.&lt;/p&gt; &lt;p&gt;If you cannot use git, use &#34;diff -purN OLD NEW&#34;. If your version of diff does not support these options, then get the latest version of GNU diff.&lt;/p&gt; &lt;p&gt;The current directory when running this command shall be the parent directory of the U-Boot source tree (i. e. please make sure that your patch includes sufficient directory information for the affected files).&lt;/p&gt; &lt;p&gt;We prefer patches as plain text. MIME attachments are discouraged, and compressed attachments must not be used.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If one logical set of modifications affects or creates several files, all these changes shall be submitted in a SINGLE patch file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Changesets that contain different, unrelated modifications shall be submitted as SEPARATE patches, one patch per changeset.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Notes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Before sending the patch, run the buildman script on your patched source tree and make sure that no errors or warnings are reported for any of the boards.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Keep your modifications to the necessary minimum: A patch containing several unrelated changes or arbitrary reformats will be returned with a request to re-formatting / split it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you modify existing code, make sure that your new code does not add to the memory footprint of the code ;-) Small is beautiful! When adding new features, these should compile conditionally only (using #ifdef), and the resulting code with the new feature disabled must not need more memory than the old code without your modification.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Remember that there is a size limit of 100 kB per message on the u-boot mailing list. Bigger patches will be moderated. If they are reasonable and not too big, they will be acknowledged. But patches bigger than the size limit should be avoided.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>