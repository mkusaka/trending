<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-03T01:33:46Z</updated>
  <subtitle>Daily Trending of C in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sksalahuddin2828/C_Programming</title>
    <updated>2023-07-03T01:33:46Z</updated>
    <id>tag:github.com,2023-07-03:/sksalahuddin2828/C_Programming</id>
    <link href="https://github.com/sksalahuddin2828/C_Programming" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Testing in CPython&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>abishekvashok/cmatrix</title>
    <updated>2023-07-03T01:33:46Z</updated>
    <id>tag:github.com,2023-07-03:/abishekvashok/cmatrix</id>
    <link href="https://github.com/abishekvashok/cmatrix" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Terminal based &#34;The Matrix&#34; like implementation&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;CMatrix&lt;/h1&gt; &#xA;&lt;h3 align=&#34;center&#34;&gt; Matrix like effect in your terminal &lt;/h3&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://travis-ci.org/abishekvashok/cmatrix&#34;&gt; &lt;img src=&#34;https://travis-ci.org/abishekvashok/cmatrix.svg?branch=master&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/COPYING&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/license/abishekvashok/cmatrix?color=blue&#34;&gt; &lt;/a&gt; &lt;img src=&#34;https://img.shields.io/badge/contributions-welcome-orange&#34;&gt; &lt;a href=&#34;https://github.com/abishekvashok/cmatrix/stargazers&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/stars/abishekvashok/cmatrix&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/abishekvashok/cmatrix/network&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/forks/abishekvashok/cmatrix&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png&#34; alt=&#34;-----------------------------------------------------&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#build-dependencies&#34;&gt;Build Dependencies&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#building-and-installing-cmatrix&#34;&gt;Building and Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#using-configure-(recommended-for-most-linux%2Fmingw-users)&#34;&gt;Using configure (recommended)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#using-cmake&#34;&gt;Using CMake&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#captures&#34;&gt;Captures&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#screenshots&#34;&gt;Screenshots&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#screencasts&#34;&gt;Screencasts&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#maintainers&#34;&gt;Maintainer&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#our-contributors&#34;&gt;Contributors&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#contribution-guide&#34;&gt;Contribution Guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png&#34; alt=&#34;-----------------------------------------------------&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;‚òÅ&lt;/span&gt; Overview&lt;/h2&gt; &#xA;&lt;p&gt;CMatrix is based on the screensaver from The Matrix website. It shows text flying in and out in a terminal like as seen in &#34;The Matrix&#34; movie. It can scroll lines all at the same rate or asynchronously and at a user-defined speed.&lt;/p&gt; &#xA;&lt;p&gt;CMAtrix is inspired from &#39;The Matrix&#39; movie. If you haven‚Äôt seen this movie and you are a fan of computers or sci-fi in general, go see this movie!!!&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;‚ùï&lt;/span&gt;&lt;code&gt;Disclaimer&lt;/code&gt; : We are in no way affiliated in any way with the movie &#34;The Matrix&#34;, &#34;Warner Bros&#34; nor any of its affiliates in any way, just fans.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png&#34; alt=&#34;-----------------------------------------------------&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üìÇ&lt;/span&gt; Build Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;You&#39;ll probably need a decent ncurses library to get this to work. On Windows, using mingw-w64-ncurses is recommended (PDCurses will also work, but it does not support colors or bold text). &lt;br&gt;&lt;/p&gt; &#xA;&lt;h5&gt;&lt;span&gt;üîπ&lt;/span&gt; For Linux&lt;br&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Run this command to check the version of ncurses.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ldconfig -p | grep ncurses&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you get no output then you need to install ncurses. Click below to install ncurses in Linux.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.cyberciti.biz/faq/linux-install-ncurses-library-headers-on-debian-ubuntu-centos-fedora/&#34;&gt;ncurses&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png&#34; alt=&#34;-----------------------------------------------------&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üíæ&lt;/span&gt; Building and installing cmatrix&lt;/h2&gt; &#xA;&lt;p&gt;To install cmatrix, Clone this repo in your local system and use either of the following methods from within the cmatrix directory.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;span&gt;üîπ&lt;/span&gt; Using &lt;code&gt;configure&lt;/code&gt; (recommended for most linux/mingw users)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;autoreconf -i  # skip if using released tarball&#xA;./configure&#xA;make&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;&lt;span&gt;üîπ&lt;/span&gt; Using CMake&lt;/h4&gt; &#xA;&lt;p&gt;Here we also show an out-of-source build in the sub directory &#34;build&#34;. (Doesn&#39;t work on Windows, for now).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir -p build&#xA;cd build&#xA;# to install to &#34;/usr/local&#34;&#xA;cmake ..&#xA;# OR &#xA;# to install to &#34;/usr&#34;&#xA;#cmake -DCMAKE_INSTALL_PREFIX=/usr ..&#xA;make&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png&#34; alt=&#34;-----------------------------------------------------&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üìë&lt;/span&gt; Usage&lt;/h2&gt; &#xA;&lt;p&gt;After you have installed &lt;strong&gt;cmatrix&lt;/strong&gt; just type the command &lt;code&gt;cmatrix&lt;/code&gt; to run it :)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cmatrix&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run with different arguments to get different effects.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cmatrix [-abBflohnsmVx] [-u update] [-C color]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cmatrix -ba -u 2 -C red&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more options and &lt;strong&gt;help&lt;/strong&gt; run &lt;code&gt;cmatrix -h&lt;/code&gt; &lt;br&gt;OR&lt;br&gt; Read Manual Page by running command &lt;code&gt;man cmatrix&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;To get the program to look most like the movie, use &lt;code&gt;cmatrix -lba&lt;/code&gt;&lt;/em&gt; &lt;em&gt;To get the program to look most like the Win/Mac screensaver, use &lt;code&gt;cmatrix -ol&lt;/code&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;span&gt;üìç&lt;/span&gt; &lt;em&gt;Note: cmatrix is probably not particularly portable or efficient, but it won&#39;t hog &lt;strong&gt;too&lt;/strong&gt; much CPU time.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png&#34; alt=&#34;-----------------------------------------------------&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üì∑&lt;/span&gt; Captures&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;span&gt;üîπ&lt;/span&gt; Screenshots&lt;/h4&gt; &#xA;&lt;!-- ![Special Font &amp; bold](data/img/capture_bold_font.png?raw=true &#34;cmatrix -bx&#34;) --&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/data/img/capture_bold_font.png&#34; alt=&#34;cmatrix screenshot&#34;&gt; &lt;/p&gt; &#xA;&lt;h4&gt;&lt;span&gt;üîπ&lt;/span&gt; Screencasts&lt;/h4&gt; &#xA;&lt;!-- ![Movie-Like Cast](data/img/capture_orig.gif?raw=true &#34;cmatrix -xba&#34;) --&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/data/img/capture_orig.gif&#34; alt=&#34;cmatrix screencast&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png&#34; alt=&#34;-----------------------------------------------------&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;‚ö°&lt;/span&gt; Maintainers&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;‚û§ &lt;strong&gt;Abishek V Ashok&lt;/strong&gt; [Core] - &lt;a href=&#34;mailto:abishekvashok@gmail.com&#34;&gt;abishekvashok@gmail.com&lt;/a&gt;&lt;br&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://twitter.com/abishekvashok&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Twitter-1DA1F2?style=for-the-badge&amp;amp;logo=twitter&amp;amp;logoColor=white&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/abishekvashok&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/GitHub-100000?style=for-the-badge&amp;amp;logo=github&amp;amp;logoColor=white&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üë•&lt;/span&gt; Our Contributors&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;span&gt;üî∏&lt;/span&gt; Thanks to:&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;‚û§ &lt;strong&gt;Chris Allegretta&lt;/strong&gt; &lt;a href=&#34;mailto:chrisa@asty.org&#34;&gt;chrisa@asty.org&lt;/a&gt; for writing cmatrix up in a fortnight and giving us the responsibility to further improve it.&lt;/li&gt; &#xA; &lt;li&gt;‚û§ &lt;strong&gt;Krisjon Hanson&lt;/strong&gt; and &lt;strong&gt;Bjoern Ganslandt&lt;/strong&gt; for helping with bold support and Bjoern again for the cursor removal code, helping with the &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; modes/flags, and Makefile improvements.&lt;/li&gt; &#xA; &lt;li&gt;‚û§ &lt;strong&gt;Adam Gurno&lt;/strong&gt; for multi-color support.&lt;/li&gt; &#xA; &lt;li&gt;‚û§ &lt;strong&gt;Garrick West&lt;/strong&gt; for debian consolefont dir support.&lt;/li&gt; &#xA; &lt;li&gt;‚û§ &lt;strong&gt;Nemo&lt;/strong&gt; for design thoughts and continuous help and support.&lt;/li&gt; &#xA; &lt;li&gt;‚û§ &lt;strong&gt;John Donahue&lt;/strong&gt; for helping with transparent term support&lt;/li&gt; &#xA; &lt;li&gt;‚û§ &lt;strong&gt;Ben Esacove&lt;/strong&gt; for Redhat 6 compatibility w/matrix.psf.gz&lt;/li&gt; &#xA; &lt;li&gt;‚û§ &lt;strong&gt;jwz&lt;/strong&gt; for the xmatrix module to xscreensaver at &lt;a href=&#34;http://www.jwz.org/xscreensaver&#34;&gt;http://www.jwz.org/xscreensaver&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Chris Allegretta&#39;s girlfriend &lt;strong&gt;Amy&lt;/strong&gt; for not killing him when he stayed up till 3 AM writing code.&lt;/li&gt; &#xA; &lt;li&gt;‚û§ &lt;strong&gt;Sumit Kumar Soni&lt;/strong&gt; for beautifying the README.&lt;/li&gt; &#xA; &lt;li&gt;The makers of the Matrix for one kickass movie!&lt;/li&gt; &#xA; &lt;li&gt;‚û§ Everyone who has sent (and who will send) us and Chris mails regarding bugs, comments, patches or just a simple hello.&lt;/li&gt; &#xA; &lt;li&gt;‚û§ Everyone who has contributed to the project by opening issues and PRs on the github repository.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png&#34; alt=&#34;-----------------------------------------------------&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üìñ&lt;/span&gt; Contribution Guide&lt;/h2&gt; &#xA;&lt;p&gt;If you have any suggestions/flames/patches to send, please feel free to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Open issues and if possible label them, so that it is easy to categorise features, bugs etc.&lt;/li&gt; &#xA; &lt;li&gt;If you solved some problems or made some valuable changes, Please open a Pull Request on Github.&lt;/li&gt; &#xA; &lt;li&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/CONTRIBUTING.md&#34;&gt;contributing.md&lt;/a&gt; for more details.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/rainbow.png&#34; alt=&#34;-----------------------------------------------------&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&lt;span&gt;üìÑ&lt;/span&gt; License&lt;/h2&gt; &#xA;&lt;p&gt;This software is provided under the GNU GPL v3. &lt;a href=&#34;https://raw.githubusercontent.com/abishekvashok/cmatrix/master/COPYING&#34;&gt;View License&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>fortra/CVE-2023-28252</title>
    <updated>2023-07-03T01:33:46Z</updated>
    <id>tag:github.com,2023-07-03:/fortra/CVE-2023-28252</id>
    <link href="https://github.com/fortra/CVE-2023-28252" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Since February 2022 was reported a new ransomware that appears to be using a Windows 0-day vulnerability, according to the research conducted by Trend Micro.&lt;br&gt; More information about this ransomware can be found at this &lt;a href=&#34;https://www.securityweek.com/windows-zero-day-exploited-in-nokoyawa-ransomware-attacks/&#34;&gt;link&lt;/a&gt;.&lt;br&gt; According to analysis by Kaspersky, the Nokoyawa ransomware group has used other exploits targeting the Common Log File System (CLFS) driver since June 2022, with similar but distinct characteristics, all linked to a single exploit developer.&lt;br&gt; In April 2023 when Microsoft released the patch, the &lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-28252&#34;&gt;CVE-2023-28252&lt;/a&gt; as assigned.&lt;br&gt; Previously, in 2022 a similar bug in the same component was researched by us, and documented in &lt;a href=&#34;https://www.coresecurity.com/core-labs/articles/understanding-cve-2022-37969-windows-clfs-lpe&#34;&gt;this blogpost&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Common Log File System (CLFS) file format:&lt;/h1&gt; &#xA;&lt;p&gt;To face the analysis, it‚Äôs necessary to know the &lt;strong&gt;.&lt;em&gt;blf&lt;/em&gt;&lt;/strong&gt; file format, that is handled by the vulnerable Common &lt;em&gt;Log File System&lt;/em&gt; driver called &lt;strong&gt;CLFS.sys&lt;/strong&gt; and that is in driver‚Äôs folder within system32.&lt;/p&gt; &#xA;&lt;p&gt;More information about this filetype can be found in the links below:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.zscaler.com/blogs/security-research/technical-analysis-windows-clfs-zero-day-vulnerability-cve-2022-37969-part&#34;&gt;https://www.zscaler.com/blogs/security-research/technical-analysis-windows-clfs-zero-day-vulnerability-cve-2022-37969-part&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-the-common-log-file-system&#34;&gt;https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-the-common-log-file-system&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ionescu007/clfs-docs/raw/main/README.md&#34;&gt;https://github.com/ionescu007/clfs-docs/blob/main/README.md&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.coresecurity.com/core-labs/articles/understanding-cve-2022-37969-windows-clfs-lpe&#34;&gt;https://www.coresecurity.com/core-labs/articles/understanding-cve-2022-37969-windows-clfs-lpe&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;The vulnerability:&lt;/h1&gt; &#xA;&lt;p&gt;This analysis is made for &lt;em&gt;Windows 11 21H2&lt;/em&gt;, &lt;em&gt;clfs.sys version 10.0.22000.1574&lt;/em&gt; although it also works on &lt;em&gt;Windows 10 21H2&lt;/em&gt;, &lt;em&gt;Windows 10&lt;/em&gt; 22H2, &lt;em&gt;Windows 11 22H2&lt;/em&gt; and &lt;em&gt;Windows server 2022&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In previous Windows versions, it‚Äôs necessary to adjust some values, otherwise we would produce a BSOD.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-28252&#34;&gt;Microsoft Patch Tuesday april de 2023&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image1.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;You can check the driver version as shown&lt;/p&gt; &#xA;&lt;p&gt;When the vulnerability was published, in April 2023 I started with Esteban Kazimirow to perform the reversing of the CLFS.sys driver, although in this case, just analyzing the patch was very difficult to deduce where the bug was and how to trigger it, since the exploitation is very complex.&lt;/p&gt; &#xA;&lt;p&gt;Later, a &lt;a href=&#34;https://ti.qianxin.com/blog/articles/CVE-2023-28252-Analysis-of-In-the-Wild-Exploit-Sample-of-CLFS-Privilege-Escalation-Vulnerability/&#34;&gt;&lt;em&gt;blogpost&lt;/em&gt;&lt;/a&gt; came out whose author, from a sample of a malware, showed some parts of the code decompiled by &lt;em&gt;HexRays&lt;/em&gt; and some information that guided where the exploitation had to be faced.&lt;/p&gt; &#xA;&lt;p&gt;Obviously the provided info was not complete, but without this help it would have been unlikely to have come to build the PoC and later a functional exploit.&lt;/p&gt; &#xA;&lt;p&gt;To make it easier to understand, we will first explain how to build the PoC and then we will do the vulnerability analysis.&lt;/p&gt; &#xA;&lt;p&gt;This blogpost contains two sections:&lt;/p&gt; &#xA;&lt;p&gt;Building the PoC:&lt;/p&gt; &#xA;&lt;p&gt;1-Get the kernel addresses we need for exploitation&lt;/p&gt; &#xA;&lt;p&gt;2-Preparing the Path to create the .blf files:&lt;/p&gt; &#xA;&lt;p&gt;3-Create the &#34;trigger blf&#34; file using the CreateLogFile() function&lt;/p&gt; &#xA;&lt;p&gt;4-Crafting the ‚Äútrigger blf‚Äù file&lt;/p&gt; &#xA;&lt;p&gt;5-Getting the kernel address of the BASE BLOCK of trigger blf&lt;/p&gt; &#xA;&lt;p&gt;6-Calling AddLogContainer with the handle of trigger blf&lt;/p&gt; &#xA;&lt;p&gt;7-Preparing the spray blf files&lt;/p&gt; &#xA;&lt;p&gt;8-Preparing the memory to perform the spray&lt;/p&gt; &#xA;&lt;p&gt;9-Triggering the bug&lt;/p&gt; &#xA;&lt;p&gt;Debugging:&lt;/p&gt; &#xA;&lt;p&gt;1-Checking the memory spray&lt;/p&gt; &#xA;&lt;p&gt;2-Looking at the RecordOffset[12] of trigger blf&lt;/p&gt; &#xA;&lt;p&gt;3-Looking at the iFlushBlock value in spray blf file&lt;/p&gt; &#xA;&lt;p&gt;4-Why does it read from BLOCK 1 SHADOW instead of BLOCK 0 CONTROL ?&lt;/p&gt; &#xA;&lt;p&gt;5-Why the checksum is equal to zero in blf spray files ?&lt;/p&gt; &#xA;&lt;p&gt;6-Ending the exploitation.&lt;/p&gt; &#xA;&lt;p&gt;7-The real patch&lt;/p&gt; &#xA;&lt;h1&gt;Building the PoC:&lt;/h1&gt; &#xA;&lt;h1&gt;1-Get the kernel addresses we need for exploitation&lt;/h1&gt; &#xA;&lt;p&gt;I‚Äôll create a function named &lt;strong&gt;InitEnvironment&lt;/strong&gt; to obtain some necessary Kernel addresses.&lt;/p&gt; &#xA;&lt;p&gt;Get the EPROCESS address of my process and store it in the &lt;strong&gt;g_EProcessAddress&lt;/strong&gt; variable, then the EPROCESS address of the &lt;strong&gt;SYSTEM&lt;/strong&gt; process, and store it in &lt;strong&gt;system_EPROCESS&lt;/strong&gt;, then the &lt;strong&gt;EHTREAD&lt;/strong&gt; address of the &lt;em&gt;main thread&lt;/em&gt; of my process, and I store it in &lt;strong&gt;g_EThreadAddress&lt;/strong&gt; and finally the address of the &lt;strong&gt;PREVIOUS MODE&lt;/strong&gt; that in this version of the PoC will not be used.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image2.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This method is well known, the &lt;strong&gt;GetObjectKernelAddress function,&lt;/strong&gt; calls &lt;strong&gt;NtQuerySystemInformation&lt;/strong&gt; twice with the first argument &lt;em&gt;SystemExtendedHandleInformation&lt;/em&gt;, the first call is passed with an incorrect size and returns error, but also returns the correct size that is used in the second call and obtains the information of all the handles, then going through in a loop the information of each handle and in the field &lt;strong&gt;Object&lt;/strong&gt; of the correct &lt;strong&gt;handleinfo&lt;/strong&gt; gets the address searched in kernel.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image3.png&#34; alt=&#34;A picture containing text, screenshot, font, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;I also need the kernel addresses of the following functions exported by &lt;strong&gt;CLFS.sys&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;p&gt;‚Ä¢ &lt;strong&gt;ClfsEarlierLsn&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;‚Ä¢ &lt;strong&gt;ClfsMgmtDeregisterManagedClient&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;And the exported functions from &lt;strong&gt;NTOSKRNL.exe&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;‚Ä¢ &lt;strong&gt;RtlClearBit&lt;/strong&gt;/&lt;strong&gt;PoFxProcessorNotification&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;‚Ä¢ &lt;strong&gt;SeSetAccessStateGenericMapping&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;To get these addresses uses a similar method that is used to get the kernel base of both modules, by calling &lt;strong&gt;NtQuerySystemInformation&lt;/strong&gt; twice, but in this case the first argument will be *SYSTEM_INFORMATION_CLASS (*in the PoC we use the &lt;strong&gt;FindKernelModulesBase&lt;/strong&gt; function for this purpose).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image4.png&#34; alt=&#34;A picture containing text, font, screenshot, line Description automatically generated&#34;&gt;Then it loads &lt;strong&gt;CLFS.sys&lt;/strong&gt; and &lt;strong&gt;NTOSKRNL.exe&lt;/strong&gt; as normal modules in user mode by calling to &lt;strong&gt;LoadLibrary&lt;/strong&gt;, obtains the addresses in user mode with &lt;strong&gt;GetProcAddress&lt;/strong&gt; and then subtracts the imagebase from each one, which obtains the offset of the function and finally adds each offset to the corresponding kernel bases and thereby obtains the kernel addresses of all the necessary functions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image5.png&#34; alt=&#34;A picture containing text, font, line, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;2-Preparing the Path to create the .blf files:&lt;/h1&gt; &#xA;&lt;p&gt;I create a function called &lt;strong&gt;createInitialTriggerBlfFile&lt;/strong&gt; which will generate and write a &lt;strong&gt;.blf file&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The path that is used as an argument in the &lt;strong&gt;CreateLogFile&lt;/strong&gt; is different from a normal path, for example to open the file &lt;em&gt;1280.blf&lt;/em&gt; located in the &lt;em&gt;C:\Users\Public&lt;/em&gt; folder, we must set the path &lt;strong&gt;LOG:C:\Users\Public\1280.&lt;/strong&gt; This will be saved in the &lt;strong&gt;stored_name_CreateLog&lt;/strong&gt; variable.&lt;/p&gt; &#xA;&lt;p&gt;I do this by using &lt;strong&gt;wsprintfW()&lt;/strong&gt; since &lt;strong&gt;stored_env&lt;/strong&gt; stores the path &lt;strong&gt;C:\Users\Public&lt;/strong&gt;, previously obtained from the environment variables. To this string I will prepend the string &lt;strong&gt;LOG:&lt;/strong&gt; and a random name at the end, without the .&lt;strong&gt;blf&lt;/strong&gt; extension.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image6.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This will be the path to my initial file that I‚Äôll call &#34;&lt;strong&gt;trigger blf&#34;.&lt;/strong&gt; Of course, I also must save the normal path to the same file without the &lt;strong&gt;LOG:&lt;/strong&gt; in front and with the &lt;strong&gt;BLF&lt;/strong&gt; extension to open it and modify it with &lt;strong&gt;CreateFile(), WriteFIle()&lt;/strong&gt; as any other file, this path will be, for example: &lt;em&gt;C:\Users\Public\1280.blf&lt;/em&gt;, and it will be stored in the &lt;strong&gt;stored_name_fopen&lt;/strong&gt; variable**.**&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image7.png&#34; alt=&#34;A picture containing text, font, line, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Of course, both paths correspond to the same file, and I must use one or the other as appropriate.&lt;/p&gt; &#xA;&lt;h1&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;3-Create the &#34;trigger blf&#34; file using the CreateLogFile() function.&lt;/h1&gt; &#xA;&lt;p&gt;The CreateLogFile function fulfills a function quite similar to &lt;strong&gt;CreateFile()&lt;/strong&gt; (creates new files or open existing files and get their handle), even some arguments are similar, but &lt;strong&gt;CreateLogFile()&lt;/strong&gt; only works with &lt;em&gt;blf&lt;/em&gt; files.&lt;/p&gt; &#xA;&lt;p&gt;In addition, when it opens an existing file, it verifies that the format is ok, even if each block has a checksum and if this is not correct it will return an error.&lt;/p&gt; &#xA;&lt;p&gt;I‚Äôll create 2 kinds of BLF files:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The Trigger blf&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The Spray blf&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Both are blf files but modified in a different way.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image8.png&#34; alt=&#34;A close-up of a computer code Description automatically generated with low confidence&#34;&gt;In this way the PoC first creates the &#34;&lt;strong&gt;trigger blf&lt;/strong&gt;&#34; file, using &lt;strong&gt;CreateLogFile&lt;/strong&gt;, with the path for example: &lt;strong&gt;LOG:C:\Users\Public\1280&lt;/strong&gt; that I have set up before, and was stored in the &lt;strong&gt;stored_name_CreateLog&lt;/strong&gt; variable.&lt;/p&gt; &#xA;&lt;p&gt;The fifth argument &lt;strong&gt;fCreateDisposition&lt;/strong&gt;, as in &lt;em&gt;&lt;strong&gt;CreateFileA()&lt;/strong&gt;&lt;/em&gt;, can take the following values:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image9.png&#34; alt=&#34;A picture containing text, font, line, receipt Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In this case I‚Äôll use the &lt;em&gt;OPEN_ALWAYS&lt;/em&gt; argument, so the file will be created if it does not exist and if it exists it will be opened. Since the file doesn&#39;t exist yet, it will be created with a random name.&lt;/p&gt; &#xA;&lt;p&gt;logFile = CreateLogFile(stored_name_CreateLog, GENERIC_READ | GENERIC_WRITE, &lt;strong&gt;1&lt;/strong&gt;, &lt;strong&gt;0&lt;/strong&gt;, &lt;strong&gt;4&lt;/strong&gt;, &lt;strong&gt;0&lt;/strong&gt;);&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CreateLogFile()&lt;/strong&gt; will create our &#34;&lt;strong&gt;trigger blf&#34;&lt;/strong&gt; file with its 6 blocks and their corresponding checksums and will return the handle that will be stored in the &lt;strong&gt;logFile&lt;/strong&gt; variable.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image10.png&#34; alt=&#34;A picture containing text, screenshot, font, number Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Each block will have from the offset showed at left column, a header whose size is 0x70 bytes.&lt;/p&gt; &#xA;&lt;p&gt;So, for example, the header of the &lt;strong&gt;CONTROL BLOCK&lt;/strong&gt; goes from offset 0x0 to 0x70.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image11.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;All headers of all blocks have the same structure called &lt;strong&gt;_CLFS_LOG_BLOCK_HEADER&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is the header structure:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image12.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;At offset 0xC of the header I can find the &lt;strong&gt;checksum,&lt;/strong&gt; so as the &lt;strong&gt;CONTROL BLOCK&lt;/strong&gt; starts at offset 0, the checksum will be in the offset 0xC of the file and so each block will have its checksum at 0xC from the beginning of its block.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image13.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;4-Crafting the ‚Äútrigger blf‚Äù file:&lt;/h1&gt; &#xA;&lt;p&gt;To modify the &lt;strong&gt;trigger blf&lt;/strong&gt; file, I must open it as a normal file either with &lt;strong&gt;CreateFileA&lt;/strong&gt; or with &lt;strong&gt;fopen&lt;/strong&gt; and then modify it with &lt;strong&gt;WriteFile&lt;/strong&gt; or &lt;strong&gt;fwrite&lt;/strong&gt; respectively, I perform this at the beginning of the &lt;strong&gt;fun_prepare&lt;/strong&gt; function of the PoC.&lt;/p&gt; &#xA;&lt;p&gt;Remember that the normal path is stored in the &lt;strong&gt;stored_name_fopen&lt;/strong&gt; variable, so I use it to open the file with &lt;strong&gt;wfopen_s&lt;/strong&gt; (which is a variant of &lt;strong&gt;fopen&lt;/strong&gt; that supports Unicode strings).&lt;/p&gt; &#xA;&lt;p&gt;The file is modified in the &lt;strong&gt;craftTriggerBlfFile&lt;/strong&gt; function called from &lt;strong&gt;fun_prepare&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image14.png&#34; alt=&#34;A picture containing text, line, font, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then I call &lt;strong&gt;fseek&lt;/strong&gt; to point to the offset to be changed and then with &lt;strong&gt;fwrite&lt;/strong&gt; the file is modified.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image15.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;The changes to be made to the &#34;&lt;strong&gt;trigger blf&#34;&lt;/strong&gt; file are as follows:&lt;/p&gt; &#xA;&lt;p&gt;After making these changes, the &lt;strong&gt;FixCRCFile&lt;/strong&gt; is called to calculate the new checksum and fix the checksums of the first 4 blocks. The next two blocks do not have any changes, so it is not necessary to recalculate their checksums.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image16.png&#34; alt=&#34;A picture containing text, font, screenshot, number Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;5-Getting the kernel address of the BASE BLOCK of trigger blf:&lt;/h1&gt; &#xA;&lt;p&gt;The CLFS.sys driver reads the six blocks of the file, and to store their content makes an allocation in the Kernel pool.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image10.png&#34; alt=&#34;A picture containing text, screenshot, font, number Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;There‚Äôs a very important structure of size 0x90 that in the previous &lt;a href=&#34;https://www.coresecurity.com/core-labs/articles/understanding-cve-2022-37969-windows-clfs-lpe&#34;&gt;blogpost of CVE-2022-37969&lt;/a&gt;, through reversing I found some fields and called it &lt;strong&gt;pool_0x90&lt;/strong&gt;. After much more reversing, now I know that its real name is &lt;strong&gt;m_rgBlocks&lt;/strong&gt; and as the controller goes allocating memory to copy from the file the contents of each block, there it saves the size of each block, the start offset, and the kernel address where it was stored.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image17.png&#34; alt=&#34;A picture containing text, screenshot, font Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It has six CLFS_METADATA_BLOCK that correspond to each block by its number.&lt;/p&gt; &#xA;&lt;p&gt;Each structure CLFS_METADATA_BLOCK is 0x18 bytes long. (&lt;strong&gt;0x18*6=0x90&lt;/strong&gt;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image18.png&#34; alt=&#34;A picture containing text, font, line, number Description automatically generated&#34;&gt;In offset 0 there is a union, but at least in this exploit only the &lt;strong&gt;pbImage&lt;/strong&gt; field is used, so simplifying it would be:&lt;/p&gt; &#xA;&lt;p&gt;The allocation of that structure can be done from two different places of CLFS.sys driver, according to the creation of a new file or if an existing one is opened. In the case of when a new file is created, the driver allocates the 0x90 bytes from &lt;strong&gt;CClfsBaseFilePersisted::CreateImage+28A,&lt;/strong&gt; while in the case of an existing file it allocates from &lt;strong&gt;CClfsBaseFilePersisted&lt;/strong&gt;: &lt;strong&gt;ReadImage+6E.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;After that, I‚Äôll get the start address of block 2 that corresponds to the &lt;strong&gt;trigger blf&lt;/strong&gt; file, called &lt;strong&gt;BASE BLOCK&lt;/strong&gt; that begins at offset &lt;strong&gt;0x800&lt;/strong&gt; and its length is &lt;strong&gt;0x7a00&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image19.png&#34; alt=&#34;A picture containing text, screenshot, font, number Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Inside the &lt;strong&gt;fun_prepare&lt;/strong&gt; function below this address will be found in kernel using this piece of the code.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image20.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;First, the &lt;strong&gt;getBigPoolInfo&lt;/strong&gt; function finds all the allocations in the pool that have the &#34;Clfs&#34; tag and a size of 0x7a00, then stores them in an array.&lt;/p&gt; &#xA;&lt;p&gt;After that it opens again the &lt;strong&gt;trigger blf&lt;/strong&gt; file previously modified by using &lt;strong&gt;CreateLogFile&lt;/strong&gt; with the &lt;strong&gt;OPEN_EXISTING&lt;/strong&gt; argument, so it opens an existing file, this will perform the allocation of its BASE BLOCK.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;strong&gt;getBigPoolInfo&lt;/strong&gt; is called again, there‚Äôll be one new ‚ÄúClfs‚Äù pool of size 0x7a00, and its address is retrieved by calling &lt;strong&gt;NtQuerySystemInformation&lt;/strong&gt; twice.&lt;/p&gt; &#xA;&lt;p&gt;The address of the &lt;strong&gt;BASE BLOCK&lt;/strong&gt; of &lt;strong&gt;trigger blf&lt;/strong&gt; file is stored in the &lt;strong&gt;CLFS_kernelAddrArray&lt;/strong&gt; variable.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image21.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that if the modified &lt;strong&gt;trigger blf&lt;/strong&gt; file does not have the correct checksum, the &lt;strong&gt;CreateLogFile()&lt;/strong&gt; function will fail.&lt;/p&gt; &#xA;&lt;h1&gt;6-Calling AddLogContainer with the handle of trigger blf:&lt;/h1&gt; &#xA;&lt;p&gt;The last part of the &lt;strong&gt;fun_prepare&lt;/strong&gt; function, calls the &lt;strong&gt;AddLogContainer&lt;/strong&gt; api using the handle of the &lt;strong&gt;trigger blf&lt;/strong&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image22.png&#34; alt=&#34;A close-up of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;7-Preparing the spray blf files:&lt;/h1&gt; &#xA;&lt;p&gt;In the last function of the PoC called &lt;strong&gt;to_trigger&lt;/strong&gt; a second type of blf file will be created,&lt;/p&gt; &#xA;&lt;p&gt;I‚Äôll name it &lt;strong&gt;spray blf.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;This kind of file will be used to fill a memory space (spray), 10 equals of this kind are needed, but initially only one is created. &lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image23.png&#34; alt=&#34;A picture containing text, font, line, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Three arrays will be created to store the random names of this files:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;stored_log_arrays:&lt;/strong&gt; store ten new random names of .blf files that will be used with &lt;strong&gt;CreateLogFile.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;stored_container_arrays:&lt;/strong&gt; store random names to create ten new container files.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;stored_fopen_arrays:&lt;/strong&gt; store the log files names of the first array (&lt;strong&gt;stored_log_arrays&lt;/strong&gt; variable), but with their normal path (without the ‚ÄúLOG:‚Äù string) and with the .blf extension.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image24.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;On each iteration the &lt;strong&gt;blf&lt;/strong&gt; file is copied using &lt;strong&gt;CopyFileW,&lt;/strong&gt; the names that are stored in the arrays are assigned.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;fun_trigger&lt;/strong&gt; function calls &lt;strong&gt;craftSprayBlfFile&lt;/strong&gt; where modifications are made to each file and &lt;strong&gt;FixCRCFile&lt;/strong&gt; will fix the CRCs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image25.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Summarizing, I‚Äôve created 10 similar files (spray blf) with random names with the following modifications:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image26.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The last change is to copy the entire block 0 (CONTROL BLOCK) to block 1 (CONTROL BLOCK SHADOW)&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image27.png&#34; alt=&#34;A screen shot of a computer Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The effect of these changes, plus those made to the &lt;strong&gt;trigger blf&lt;/strong&gt; file, will be explained later in the debugging chapter.&lt;/p&gt; &#xA;&lt;p&gt;Some of these changes are those that produce vulnerability, while others are only necessary to bypass the driver checks.&lt;/p&gt; &#xA;&lt;p&gt;At this point the files are already created and modified, ready to perform the spray, then when they are opened with &lt;strong&gt;CreateLogFile&lt;/strong&gt;, they will be located in the memory area that we want, as will show later.&lt;/p&gt; &#xA;&lt;h1&gt;8-Preparing the memory to perform the spray&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image28.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the &lt;strong&gt;to_trigger&lt;/strong&gt; function, an array of 12 elements is created, containing the address of the &lt;strong&gt;BASE BLOCK&lt;/strong&gt; of &lt;em&gt;trigger blf&lt;/em&gt; file plus 0x30.&lt;/p&gt; &#xA;&lt;p&gt;Then, in the &lt;strong&gt;fun_pipeSpray&lt;/strong&gt; function, the memory is filled with a spray of pipes, inside there‚Äôs a loop that calls to &lt;strong&gt;CreatePipe&lt;/strong&gt; and creates the number of pipes that is passed as a first argument, the second argument is an array that will store the handles of all the pipes created.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image29.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image30.png&#34; alt=&#34;&#34;&gt;Within a loop, it calls to &lt;strong&gt;CreatePipe&lt;/strong&gt; creating read-write pipes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image31.png&#34; alt=&#34;&#34;&gt;In this way first 0x5000 pipes will be created and then call again to create other 0x4000 pipes.&lt;/p&gt; &#xA;&lt;p&gt;Then uses WriteFile to write to the first 5000 pipes, the array recently created with the addresses of BASE BLOCK + 0x30 of the &lt;strong&gt;trigger blf&lt;/strong&gt; file**.**&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image32.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now already has a compact block created in memory, it will release 0x667 pipes from the number 0x2000 and up to the 0x2667, since in memory the pipes are not in the same order as were created, what will happen is that there will be free spaces in this memory block.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image33.png&#34; alt=&#34;A picture containing text, screenshot, font, software Description automatically generated&#34;&gt;Note that the allocations of the pipes have as user size of 0x90 bytes, so when be released we‚Äôll have&lt;/p&gt; &#xA;&lt;p&gt;It frees the memory spaces of size 0x90 between the memory full of pipes.&lt;br&gt; Then it loops to call &lt;strong&gt;CreateLogFile&lt;/strong&gt; with the 10 &lt;strong&gt;spray blf&lt;/strong&gt; files.&lt;br&gt; When &lt;strong&gt;CreateLogFile&lt;/strong&gt; is called to open existing files, the allocation of 0x90 bytes is performed for the &lt;strong&gt;m_rgBlocks&lt;/strong&gt; one for each &lt;strong&gt;spray blf&lt;/strong&gt; file**,** so these allocations will occupy gaps that were left when releasing the pipes since they are the same size.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image34.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then repeat the process of writing in the final 0x4000 pipes the array that has the address of BASE BLOCK +0x30 of &lt;strong&gt;trigger blf.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;9-Triggering the bug&lt;/h1&gt; &#xA;&lt;p&gt;All these manipulations creates a controlled memory space, I will show you how it is when is being debugged, but the idea is that the &lt;strong&gt;m_rgBlocks&lt;/strong&gt; of each &lt;strong&gt;spray blf&lt;/strong&gt; file occupy the 0x90 byte gaps that were released.&lt;/p&gt; &#xA;&lt;p&gt;Then already in the final part, the bug is triggered within a while( 1 ) using a call to &lt;strong&gt;AddLogContainer&lt;/strong&gt; to the &lt;strong&gt;spray blf&lt;/strong&gt; files.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image35.png&#34; alt=&#34;A picture containing text, font, line, number Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Within this while the bug is triggered:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image36.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This while will exit when it finds the System token, using the &lt;strong&gt;NtFsControlFile&lt;/strong&gt; function that will read the pipes attributes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image37.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then using &lt;strong&gt;CreateLogFile,&lt;/strong&gt; again overwrites the token of our process with the recently found System Token and in this way we achieve the elevation of privilege.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image38.png&#34; alt=&#34;A picture containing text, font, line, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then restore some values, close the handles of the pipes and the blf files, and run a Notepad as System to verify that we have raised correctly.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image39.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note the blf files created on the PUBLIC folder. Remember that if you want to do another try, you must first delete the created files. some will be locked and cannot be deleted, but the PoC will still work.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image40.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Debugging:&lt;/h1&gt; &#xA;&lt;h1&gt;1- Checking the memory spray&lt;/h1&gt; &#xA;&lt;p&gt;Before I start with the effect of changes to &lt;strong&gt;trigger blf&lt;/strong&gt; and &lt;strong&gt;spray blf&lt;/strong&gt; files to perform the exploitation, I must verify that &lt;strong&gt;m_rgBlocks&lt;/strong&gt; of &lt;strong&gt;spray blf files&lt;/strong&gt; are located in holes that occur in memory distribution, after performing the pipe spray and the subsequent release of a fixed number of pipes.&lt;/p&gt; &#xA;&lt;p&gt;When this procedure ends, a pipe should be located under the 0x90 bytes of &lt;strong&gt;m_rgBlocks&lt;/strong&gt;, so when &lt;strong&gt;m_rgBlocks&lt;/strong&gt; is used, an &lt;strong&gt;OUT OF BOUNDS&lt;/strong&gt; will occur and it will read from that pipe that is below.&lt;/p&gt; &#xA;&lt;p&gt;The PoC has an ideal point to place a breakpoint:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image41.png&#34; alt=&#34;A screen shot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;At this point, the opening of &lt;strong&gt;spray blf&lt;/strong&gt; files is complete and the &lt;strong&gt;AddLogContainer&lt;/strong&gt; function is still not called.&lt;/p&gt; &#xA;&lt;p&gt;To debug in user mode, I will use x64dbg and for kernel mode, IDA with the &lt;strong&gt;Windbg&lt;/strong&gt; plugin.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image42.png&#34; alt=&#34;A screen shot of a computer Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;At this point the memory should already be prepared, and I can see the distribution.&lt;/p&gt; &#xA;&lt;p&gt;I‚Äôll pause IDA to find an interesting point to put a breakpoint.&lt;/p&gt; &#xA;&lt;p&gt;I‚Äôll set up a breakpoint at &lt;strong&gt;CClfsBaseFilePersisted::AddContainer&lt;/strong&gt;, which is called from &lt;strong&gt;AddLogContainer&lt;/strong&gt; and at the beginning, it has the &lt;strong&gt;RCX&lt;/strong&gt; register pointing to &lt;strong&gt;CClfsBaseFilePersisted&lt;/strong&gt; structure and at offset 0x30 there‚Äôs a pointer to &lt;strong&gt;m_rgBlocks&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image43.png&#34; alt=&#34;A screen shot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;When the breakpoint is reached, I check on call stack that &lt;strong&gt;AddLogContainer&lt;/strong&gt; is being called from my PoC.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image44.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;the &lt;strong&gt;RCX&lt;/strong&gt; register points to:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image45.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with low confidence&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image45.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The first field is the pointer to a vtable (&lt;strong&gt;CLFS! CClfsBaseFilePersisted::&#39;vftable&#39;&lt;/strong&gt;) and at offset 0x30 is the pointer to &lt;strong&gt;m_rgBlocks.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image46.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The blocks 0, 1, 4 and 5 have not saved the &lt;strong&gt;pbImage&lt;/strong&gt; yet, while blocks 2 (BASE BLOCK) and 3 (SHADOW BLOCK) have.&lt;/p&gt; &#xA;&lt;p&gt;Each block in &lt;strong&gt;m_rgBlocks&lt;/strong&gt; table has its &lt;strong&gt;cbOffset&lt;/strong&gt; which is the offset where the block starts in file, &lt;strong&gt;cbImage&lt;/strong&gt; is the block size, and &lt;strong&gt;eBlockType&lt;/strong&gt; is the block type.&lt;/p&gt; &#xA;&lt;p&gt;If the spray is correct, below the &lt;strong&gt;m_rgBlocks&lt;/strong&gt; there should be a pipe and within, the pointers to &lt;strong&gt;BASE BLOCK + 0x30&lt;/strong&gt; of &lt;strong&gt;trigger blf&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image47.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &#34;&lt;strong&gt;!pool&lt;/strong&gt;&#34; command on windbg displays the memory distribution:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image48.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Each &lt;strong&gt;m_rgBlocks&lt;/strong&gt; has a ‚Äú&lt;strong&gt;Clfs‚Äù&lt;/strong&gt; tag and its size is &lt;strong&gt;0xa0&lt;/strong&gt; because it is the &lt;strong&gt;0x90&lt;/strong&gt; user size plus &lt;strong&gt;0x10&lt;/strong&gt; header and below there‚Äôs a pipe with the ‚Äú&lt;strong&gt;NpFr&lt;/strong&gt;‚Äù tag that has the same &lt;strong&gt;0x90&lt;/strong&gt; user size + &lt;strong&gt;0x10&lt;/strong&gt; header.&lt;/p&gt; &#xA;&lt;p&gt;Since distribution isn&#39;t an exact science, some ‚Äú&lt;strong&gt;Clfs‚Äù&lt;/strong&gt; were placed continuously, which is undesirable, but the one I&#39;m working with, is correctly placed followed by a pipe.&lt;/p&gt; &#xA;&lt;h1&gt;2-Looking at the RecordOffset[12] of trigger blf&lt;/h1&gt; &#xA;&lt;p&gt;One of the first changes that affects is the one made in &lt;strong&gt;trigger&lt;/strong&gt; &lt;strong&gt;blf&lt;/strong&gt; file at offset &lt;strong&gt;0x858&lt;/strong&gt;, where the value &lt;strong&gt;0x369&lt;/strong&gt; is stored.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image49.png&#34; alt=&#34;A close-up of a sign Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;BASE BLOCK&lt;/strong&gt; starts at the offset &lt;strong&gt;0x800&lt;/strong&gt; in the file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image50.png&#34; alt=&#34;A picture containing text, screenshot, font, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Inside the &lt;strong&gt;_CLFS_LOG_BLOCK_HEADER&lt;/strong&gt; at offset &lt;strong&gt;0x800+0x58&lt;/strong&gt; (&lt;strong&gt;0x58&lt;/strong&gt; from the beginning of &lt;strong&gt;BASE BLOCK&lt;/strong&gt; header).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image51.png&#34; alt=&#34;A picture containing text, screenshot, font, display Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;At offset 0x28 the array &lt;strong&gt;RecordOffsets&lt;/strong&gt; (DWORD) begins.&lt;/p&gt; &#xA;&lt;p&gt;Moving &lt;strong&gt;0x30&lt;/strong&gt; bytes forward, at offset &lt;strong&gt;0x58&lt;/strong&gt; (0x828+0x30=0x858 from the beginning), is &lt;strong&gt;field 12&lt;/strong&gt; of &lt;strong&gt;RecordOffsets&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image52.png&#34; alt=&#34;A picture containing text, font, screenshot, graphics Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;I run the PoC to &lt;strong&gt;CreateLogFile&lt;/strong&gt; as shown in the image below:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image53.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image53.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image54.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Before I enter to &lt;strong&gt;CreateLogFile&lt;/strong&gt; I&#39;m going to put a breakpoint in a place where value 0x369 hasn&#39;t been used yet.&lt;/p&gt; &#xA;&lt;p&gt;In a case that &lt;strong&gt;CreateLogFile&lt;/strong&gt; opens an existing file, the &lt;strong&gt;m_rgBlocks&lt;/strong&gt; structure is allocated here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CClfsBaseFilePersisted::ReadImage+6E&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;So, I‚Äôll set a breakpoint on IDA right here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image55.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;When breakpoint is triggered**:**&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image56.png&#34; alt=&#34;A picture containing text, screenshot, font, number Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In &lt;strong&gt;m_rgBlocks&lt;/strong&gt; there is still some garbage because it‚Äôs still uninitialized, but as soon as &lt;strong&gt;pbImage&lt;/strong&gt; of block 2 is allocated, the address will be saved in offset &lt;strong&gt;0x30&lt;/strong&gt; from the start, since the first field inside each &lt;strong&gt;CLFS_METADATA_BLOCK&lt;/strong&gt; is &lt;strong&gt;pbImage&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image57.png&#34; alt=&#34;A screen shot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image58.png&#34; alt=&#34;A picture containing text, screenshot, font, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now I set up a hardware breakpoint on write: &lt;strong&gt;ba w1 ffffd003&#39;7f5bea30&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;After initializing to zero, it stops when it saves &lt;strong&gt;pbImage&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image59.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The analysis says that it corresponds to &lt;strong&gt;block0&lt;/strong&gt;, because it does not consider the constant &lt;strong&gt;r14*8&lt;/strong&gt; which is &lt;strong&gt;0x30&lt;/strong&gt; afterwards, as a result is really writing the &lt;strong&gt;pbImage&lt;/strong&gt; of &lt;strong&gt;block&lt;/strong&gt; &lt;strong&gt;2&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image60.png&#34; alt=&#34;A picture containing text, screenshot, font Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;strong&gt;CClfsBaseFilePersisted::ReadMetadataBlock&lt;/strong&gt; is used to allocate any of the blocks, using the size passed as argument.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image61.png&#34; alt=&#34;A picture containing text, font, screenshot, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now set a &lt;strong&gt;read/write&lt;/strong&gt; breakpoint at &lt;strong&gt;0x58&lt;/strong&gt; from the base block, to see when it uses the value &lt;strong&gt;0x369&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;ba r1 FFFF978A&#39;16ECF000+0x58&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image62.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;When the breakpoint is hit, reads the value &lt;strong&gt;0x369&lt;/strong&gt; located at the &lt;strong&gt;RecordOffset[12],&lt;/strong&gt; adds it to a weird pointer on &lt;strong&gt;r14&lt;/strong&gt; and increments the contents of &lt;strong&gt;RAX+r14&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A few lines above in the code, &lt;strong&gt;ESI&lt;/strong&gt; has the value &lt;strong&gt;0x13&lt;/strong&gt; and multiplies by &lt;strong&gt;0x18&lt;/strong&gt;, which is the size of each block in &lt;strong&gt;m_rgBlocks&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;WINDBG&amp;gt;? &lt;strong&gt;0x18*0x13&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Evaluate expression: 456 = 00000000&#39;0000&lt;strong&gt;01c8&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;If I add the value of &lt;strong&gt;r8= 0x1c8&lt;/strong&gt; that is greater than &lt;strong&gt;0x90&lt;/strong&gt;, to the initial address of &lt;strong&gt;m_rgBlocks&lt;/strong&gt;, it‚Äôll be reading &lt;strong&gt;OUT OF BOUNDS&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image63.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image64.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Below &lt;strong&gt;m_rgBlocks&lt;/strong&gt;, is the pipe with the pointer to &lt;strong&gt;BASE BLOCK + 0x30,&lt;/strong&gt; it reads this pointer that was strategically placed inside the pipe.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image65.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with low confidence&#34;&gt;The current position in the code was called from the &lt;strong&gt;while(1)&lt;/strong&gt; statement of main module.&lt;/p&gt; &#xA;&lt;p&gt;Inside &lt;strong&gt;spray blf&lt;/strong&gt; file I‚Äôve strategically placed the value &lt;strong&gt;0x13&lt;/strong&gt; at offset &lt;strong&gt;0x48a&lt;/strong&gt; (&lt;strong&gt;iFlushBlock&lt;/strong&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image66.png&#34; alt=&#34;A picture containing text, font, line, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;3-Looking at the iFlushBlock value in spray blf file.&lt;/h1&gt; &#xA;&lt;p&gt;At offset 0x8a of &lt;strong&gt;spray blf&lt;/strong&gt; file, &lt;strong&gt;iFlushBlock&lt;/strong&gt; of &lt;strong&gt;BLOCK 0&lt;/strong&gt; is located, whose value is &lt;strong&gt;4&lt;/strong&gt;, while offset &lt;strong&gt;0x48a&lt;/strong&gt; belongs to &lt;strong&gt;iFlushBlock&lt;/strong&gt; of &lt;strong&gt;BLOCK 1&lt;/strong&gt;, and its value is &lt;strong&gt;0x13&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image67.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now I have to find out why it reads &lt;strong&gt;iFlushBlock = 0x13&lt;/strong&gt; from &lt;strong&gt;BLOCK 1&lt;/strong&gt; instead of &lt;strong&gt;iFlushBlock = 4&lt;/strong&gt; from &lt;strong&gt;BLOCK 0.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;4-Why does it read from BLOCK 1 SHADOW instead of BLOCK 0 CONTROL?&lt;/h1&gt; &#xA;&lt;p&gt;If I look back to find out where the &lt;strong&gt;0x13&lt;/strong&gt; came from, I see on call stack that &lt;strong&gt;WriteMetadataBlock&lt;/strong&gt; is called from &lt;strong&gt;CClfsBaseFilePersisted::ExtendMetadataBlock+416&lt;/strong&gt;, there the second &lt;strong&gt;iFlushBlock&lt;/strong&gt; argument is &lt;strong&gt;EDX=0x13&lt;/strong&gt;, which comes from &lt;strong&gt;r9w&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image68.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image69.png&#34; alt=&#34;A picture containing text, screenshot, font, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image70.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with low confidence&#34;&gt;A couple of lines before, &lt;strong&gt;CClfsBaseFile::GetControlRecord&lt;/strong&gt; was called to retrieve the address of &lt;strong&gt;BLOCK 0&lt;/strong&gt;, maybe the problem is here, so I&#39;ll reboot and put a breakpoint on it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;GetControlRecord&lt;/strong&gt; calls &lt;strong&gt;CClfsBaseFile::AcquireMetadataBlock&lt;/strong&gt; who should fill the &lt;strong&gt;m_rgBlocks&lt;/strong&gt; table with the address of &lt;strong&gt;block 0&lt;/strong&gt;, when I step over this function gets the address of &lt;strong&gt;block 1&lt;/strong&gt;, so, the problem occurs inside &lt;strong&gt;CClfsBaseFile::AcquireMetadataBlock.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;By adding &lt;strong&gt;0x8A&lt;/strong&gt; to the address retrieved, I can confirm that the &lt;strong&gt;0x13&lt;/strong&gt; value that belongs to &lt;strong&gt;BLOCK 1&lt;/strong&gt; is present.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image71.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;I will reboot and set a breakpoint there:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image72.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;CClfsBaseFile::GetControlRecord+27 call &lt;strong&gt;CClfsBaseFile::AcquireMetadataBlock&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image73.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The second argument passed to &lt;strong&gt;AcquireMetadataBlock&lt;/strong&gt; is &lt;strong&gt;zero&lt;/strong&gt;, it corresponds to &lt;strong&gt;block 0&lt;/strong&gt;, it is going to copy from the file and store its address in &lt;strong&gt;m_rgBlocks&lt;/strong&gt; &lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image74.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In &lt;strong&gt;_CLFS_METADATA_BLOCK_TYPE&lt;/strong&gt; block type &lt;strong&gt;enumeration&lt;/strong&gt;, they have different names than I used, but they are the same 6 blocks.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image75.png&#34; alt=&#34;A picture containing text, screenshot, font, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;After checking that the block type is less than the maximum &lt;strong&gt;m_cBlocks=6,&lt;/strong&gt; it saves a &lt;strong&gt;reference&lt;/strong&gt; value to avoid reading the same block two times.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image76.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;ReadMetadataBlock&lt;/strong&gt; is called, the problem of reading &lt;strong&gt;block 1&lt;/strong&gt; instead of &lt;strong&gt;block 0&lt;/strong&gt; would be inside this function.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image77.png&#34; alt=&#34;A picture containing text, font, number, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;If everything is fine, it allocates using &lt;strong&gt;cbImage&lt;/strong&gt; as size and it stores the address in field &lt;strong&gt;block 0-&amp;gt;&lt;/strong&gt; &lt;strong&gt;pbImage&lt;/strong&gt; in &lt;strong&gt;m_rgBlocks.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image78.png&#34; alt=&#34;A picture containing text, font, line, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;!pool&lt;/strong&gt; command displays the &lt;strong&gt;tag&lt;/strong&gt; and &lt;strong&gt;size&lt;/strong&gt; allocated.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image79.png&#34; alt=&#34;A picture containing text, screenshot, font, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image79.png&#34; alt=&#34;A picture containing text, screenshot, font, line Description automatically generated&#34;&gt;So, I already have the address of &lt;strong&gt;pbImage&lt;/strong&gt; of &lt;strong&gt;block 0&lt;/strong&gt; stored in &lt;strong&gt;m_rgBlocks&lt;/strong&gt;, so I need to see why it copies the bytes of &lt;strong&gt;block 1&lt;/strong&gt; there instead of bytes of &lt;strong&gt;block 0&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;I get to a call to &lt;strong&gt;CClfsContainer::ReadSector&lt;/strong&gt; where a pointer to a variable containing &lt;strong&gt;pbImage&lt;/strong&gt; is passed, to write the bytes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image80.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Notice the changes made in &lt;strong&gt;pbimage&lt;/strong&gt; content when stepping over &lt;strong&gt;ReadSector.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image81.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Adding &lt;strong&gt;0x8a&lt;/strong&gt; to &lt;strong&gt;pbImage&lt;/strong&gt; I can find the value &lt;strong&gt;4&lt;/strong&gt; which is correct value, instead of &lt;strong&gt;0x13&lt;/strong&gt;, so the problem must occur later.&lt;/p&gt; &#xA;&lt;p&gt;After calling &lt;strong&gt;ClfsDecodeBlock&lt;/strong&gt; It returns an error &lt;strong&gt;0x0C01A000A&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CClfsBaseFilePersisted::ReadMetadataBlock+153&lt;/strong&gt; calls to &lt;strong&gt;ClfsDecodeBlock&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;After this error, it adds 1 to the type and calls &lt;strong&gt;CClfsBaseFilePersisted::ReadMetadataBlock&lt;/strong&gt; again but with type &lt;strong&gt;1&lt;/strong&gt; to read block 1.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image82.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In &lt;strong&gt;CClfsBaseFilePersisted::ReadMetadataBlock&lt;/strong&gt; It allocates and stores a new &lt;strong&gt;pbImage&lt;/strong&gt; in &lt;strong&gt;m_rgBlocks&lt;/strong&gt; for &lt;strong&gt;block 1.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image83.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Blocks 0&lt;/strong&gt; and &lt;strong&gt;1&lt;/strong&gt; have different addresses, now if I add &lt;strong&gt;0x8a&lt;/strong&gt; to the address of &lt;strong&gt;block 1&lt;/strong&gt; its value is &lt;strong&gt;0x13.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Maybe since &lt;strong&gt;block 0&lt;/strong&gt; returned an error, it uses &lt;strong&gt;block 1&lt;/strong&gt; and returns it to &lt;strong&gt;GetControlRecord&lt;/strong&gt; as Control Block.&lt;/p&gt; &#xA;&lt;p&gt;As shown before, when it uses &lt;strong&gt;0x13&lt;/strong&gt; value instead of &lt;strong&gt;4&lt;/strong&gt;, it goes outside the bounds of &lt;strong&gt;m_rgBlocks&lt;/strong&gt; and reads the pipe spray values controlled by me.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image84.png&#34; alt=&#34;A picture containing text, screenshot, font Description automatically generated&#34;&gt;Then it frees the &lt;strong&gt;pbImage from block 0&lt;/strong&gt; and it copies the pointer from &lt;strong&gt;block 1 to block 0&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image85.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It would be necessary to find the value that causes the error &lt;strong&gt;0x0C01A000A&lt;/strong&gt; inside &lt;strong&gt;ClfsDecodeBlock&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Inside &lt;strong&gt;ClfsDecodeBlock&lt;/strong&gt; the &lt;strong&gt;checksum&lt;/strong&gt; of the first block is zero, this is the error &lt;strong&gt;0xC01A000A&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image86.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;5-Why the checksum is equal to zero in blf spray files?&lt;/h1&gt; &#xA;&lt;p&gt;Before calling to &lt;strong&gt;AddLogContainer,&lt;/strong&gt; opening any &lt;strong&gt;spray blf&lt;/strong&gt; file with a hexadecimal editor, the &lt;strong&gt;checksum&lt;/strong&gt; was changed to &lt;strong&gt;zero&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image87.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;it should have been changed before when it was opened with &lt;strong&gt;CreateLogFile&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image88.png&#34; alt=&#34;A picture containing text, screenshot, display, font Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For some reason &lt;strong&gt;spray blf&lt;/strong&gt; files end up after exiting &lt;strong&gt;CreateLogFile&lt;/strong&gt; with checksum of &lt;strong&gt;block 0 equal to 0&lt;/strong&gt; and return a &lt;strong&gt;valid&lt;/strong&gt; &lt;strong&gt;handle&lt;/strong&gt;, let&#39;s see why this happens.&lt;/p&gt; &#xA;&lt;p&gt;I stop at &lt;strong&gt;CreateLogFile&lt;/strong&gt; before opening some spray blf file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image89.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that before calling &lt;strong&gt;CreateLogFile&lt;/strong&gt;, &lt;strong&gt;spray files&lt;/strong&gt; have the correct &lt;strong&gt;checksum&lt;/strong&gt; in &lt;strong&gt;block 0&lt;/strong&gt; and after completing the function, the checksum value changes to zero.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image90.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;So, I set a breakpoint on &lt;strong&gt;CClfsBaseFile::GetControlRecord&lt;/strong&gt;, to look inside.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image91.png&#34; alt=&#34;A picture containing text, screenshot, font, line Description automatically generated&#34;&gt;After passing &lt;strong&gt;CClfsContainer::ReadSector&lt;/strong&gt; the &lt;strong&gt;checksum&lt;/strong&gt; is not zero.&lt;/p&gt; &#xA;&lt;p&gt;Before entering to calculate the CRC32, it puts the &lt;strong&gt;checksum&lt;/strong&gt; field to zero in memory to calculate the CRC, and the result is correct.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image92.png&#34; alt=&#34;A picture containing text, font, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image93.png&#34; alt=&#34;A picture containing text, font, line, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then it checks the value of &lt;strong&gt;eExtendState =2&lt;/strong&gt; and it goes to &lt;strong&gt;WriteMetadataBlock&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image94.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here the checksum is still zero in memory, I just need to see when this value is written in the file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image95.png&#34; alt=&#34;A picture containing text, font, line, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It checks some values that are crafted in &lt;strong&gt;blf spray&lt;/strong&gt; file to reach &lt;strong&gt;CClfsBaseFilePersisted::ExtendMetadataBlock.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image96.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;After a loop to read blocks that have not been read yet, &lt;strong&gt;block 0&lt;/strong&gt; continues with &lt;strong&gt;checksum = 0&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image97.png&#34; alt=&#34;A white rectangle with black text Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Arriving at &lt;strong&gt;WriteMetadataBlock&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image98.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Since I&#39;m running before it replaces block 0 with 1, the &lt;strong&gt;iFlushBlock&lt;/strong&gt; value of the &lt;strong&gt;blf spray&lt;/strong&gt; file is still &lt;strong&gt;4&lt;/strong&gt; the correct value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image99.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now it‚Äôs working with &lt;strong&gt;block 4&lt;/strong&gt;, and it will write block 4 in file, here is not the problem yet.&lt;/p&gt; &#xA;&lt;p&gt;Then it comes to &lt;strong&gt;CClfsBaseFilePersisted::FlushControlRecord&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image100.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Inside it reaches &lt;strong&gt;WriteMetadataBlock&lt;/strong&gt;, but with &lt;strong&gt;argument 0&lt;/strong&gt;, to write &lt;strong&gt;block&lt;/strong&gt; &lt;strong&gt;0&lt;/strong&gt; to file**.**&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image101.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then the &lt;strong&gt;ClfsEncodeBlock&lt;/strong&gt; returns error &lt;strong&gt;0xC01A000A,&lt;/strong&gt; although it will write the file with the bad &lt;strong&gt;block 0&lt;/strong&gt; in &lt;strong&gt;CClfsContainer::WriteSector&lt;/strong&gt;, just below.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image102.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The variable &lt;strong&gt;var_54&lt;/strong&gt; stores the &lt;strong&gt;0xC01A000A&lt;/strong&gt; error value and will be checked before exiting the function.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image103.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;But after calling &lt;strong&gt;CClfsContainer::WriteSector&lt;/strong&gt; which returns no error, the content of &lt;strong&gt;var_54&lt;/strong&gt; is overwritten with zero.&lt;/p&gt; &#xA;&lt;p&gt;So, the function returns zero with no error and it continues working since &lt;strong&gt;CreateLogFile&lt;/strong&gt; will return a &lt;strong&gt;handle&lt;/strong&gt; instead of an error value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image104.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;6-Ending the exploitation.&lt;/h1&gt; &#xA;&lt;p&gt;The value 0x13 in &lt;strong&gt;iFlushBlock&lt;/strong&gt; causes it to go &lt;strong&gt;out of bounds&lt;/strong&gt; and it will read the pointer that is in the pipes that points to the &lt;strong&gt;Base Block +30&lt;/strong&gt; of &lt;strong&gt;trigger blf&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image105.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then it adds 0x28 to that pointer, ( &lt;strong&gt;0x58&lt;/strong&gt; from the beginning of the base block of the &lt;strong&gt;trigger blf)&lt;/strong&gt; that has the value &lt;strong&gt;0x369.&lt;/strong&gt; &lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image106.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image107.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The INC instruction will increase the value 0x14 by 1 and repeats 4 times, so 0x14 ends to 0x18.&lt;/p&gt; &#xA;&lt;p&gt;WINDBG&amp;gt;&lt;strong&gt;db r14+369&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;ffffcb82&#39;091e7397 14 00 00 00&lt;/p&gt; &#xA;&lt;p&gt;After that, &lt;strong&gt;CreateLogFile&lt;/strong&gt; is called, and reads the &lt;strong&gt;0x1858&lt;/strong&gt; value.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image108.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image109.png&#34; alt=&#34;A close-up of a card Description automatically generated with low confidence&#34;&gt;GetSymbol checks if the fake block previously created in &lt;strong&gt;trigger blf&lt;/strong&gt;, pointed by the offset &lt;strong&gt;0x1858,&lt;/strong&gt; has the correct values.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image110.png&#34; alt=&#34;A picture containing text, font, line, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;if the pointer had not been incremented several times, it would have the original value &lt;strong&gt;0x1458&lt;/strong&gt; and will point to the right block.&lt;/p&gt; &#xA;&lt;p&gt;After exit &lt;strong&gt;GetSymbol,&lt;/strong&gt; it will use that &lt;strong&gt;fake block&lt;/strong&gt; here.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image111.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image112.png&#34; alt=&#34;&#34;&gt;Then it will read the value of offset &lt;strong&gt;0x18&lt;/strong&gt; of fake block where I place &lt;strong&gt;0x05000000&lt;/strong&gt; and jump to content of what is there.&lt;/p&gt; &#xA;&lt;p&gt;WINDBG&amp;gt;dps &lt;strong&gt;0x5000000&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;00000000&#39;05000000 00000000&#39;&lt;strong&gt;05001000&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image113.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It reads the content of 0x05000000 and its &lt;strong&gt;0x05001000&lt;/strong&gt; and there it is &lt;strong&gt;ClfsEarlierLsn.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image114.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This function is used to return the value &lt;strong&gt;0xFFFFFFFF&lt;/strong&gt; in &lt;strong&gt;RDX&lt;/strong&gt; although this first time that value is not used.&lt;/p&gt; &#xA;&lt;p&gt;The second call occurs here, it calls &lt;strong&gt;PoFxProcessorNotification&lt;/strong&gt; which was on &lt;strong&gt;0x501000 +8&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image115.png&#34; alt=&#34;A picture containing text, font, screenshot, line Description automatically generated&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image115.png&#34; alt=&#34;A picture containing text, font, screenshot, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;WINDBG&amp;gt;dps 00000000**&#39;05001000**&lt;/p&gt; &#xA;&lt;p&gt;00000000&#39;05001000 fffff805&#39;7ab13220 CLFS! ClfsEarlierLsn&lt;/p&gt; &#xA;&lt;p&gt;00000000&#39;05001008 fffff805&#39;769dc3b0 &lt;strong&gt;nt! PoFxProcessorNotification&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image116.png&#34; alt=&#34;A screenshot of a computer screen Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;in this function &lt;strong&gt;RCX =&lt;/strong&gt; &lt;strong&gt;0x05000000&lt;/strong&gt; , it checks that 0x40 bytes later must be nonzero&lt;/p&gt; &#xA;&lt;p&gt;WINDBG&amp;gt;&lt;strong&gt;dps rcx+40&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;00000000&#39;05000040 00000000&#39;05000000&lt;/p&gt; &#xA;&lt;p&gt;The address to jump will be &lt;strong&gt;0x68&lt;/strong&gt; later.&lt;/p&gt; &#xA;&lt;p&gt;WINDBG&amp;gt;&lt;strong&gt;dps rcx+68&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;00000000&#39;05000068 fffff805&#39;7ab2bfb0 CLFS! ClfsMgmtDeregisterManagedClient&lt;/p&gt; &#xA;&lt;p&gt;And the argument will be &lt;strong&gt;0x48&lt;/strong&gt; bytes later.&lt;/p&gt; &#xA;&lt;p&gt;WINDBG&amp;gt;&lt;strong&gt;dps rcx+48&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;00000000&#39;05000048 00000000&#39;05000400&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;ClfsMgmtDeregisterManagedClient&lt;/strong&gt;, it&#39;s a convenient function because I can control the argument and I also have two jumps to functions controlled by me.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image117.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The first call is again to &lt;strong&gt;ClfsEarlierLsn&lt;/strong&gt; that returned in &lt;strong&gt;RDX=0xFFFFFFFF.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image118.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image119.png&#34; alt=&#34;A screen shot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;it will take the source to write from the content of &lt;strong&gt;RDX=0xFFFFFFFF&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;WINDBG&amp;gt;dps rdx&lt;/p&gt; &#xA;&lt;p&gt;00000000&#39;ffffffff &lt;strong&gt;ffff8005&#39;3a4ee000&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;At address 0xFFFFFFFF I had stored the &lt;strong&gt;system_EPROCESS &amp;amp; 0xfffffffffffff000.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image120.png&#34; alt=&#34;A picture containing text, font, line, number Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The destination is the pointer located at &lt;strong&gt;0x5000400&lt;/strong&gt; &lt;strong&gt;+0x48&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;*(UINT64*)&lt;strong&gt;0x5000448&lt;/strong&gt; = &lt;strong&gt;para_PipeAttributeobjInkernel + 0x18&lt;/strong&gt;;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image121.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;PipeAttribute&lt;/strong&gt; pointer in kernel that points to a buffer filled with ‚ÄúA‚Äù will be overwritten with the high part of the SYSTEM EPROCESS pointer.&lt;/p&gt; &#xA;&lt;p&gt;This pointer was created when I previously called &lt;strong&gt;_NtFsControlFile&lt;/strong&gt; with a buffer full of ‚Äú&lt;strong&gt;A‚Äù&lt;/strong&gt; .&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image122.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The content of that attribute can be read using &lt;strong&gt;NtFsControlFile.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image123.png&#34; alt=&#34;A screenshot of a computer screen Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now the pipe attribute no longer points to the buffer with &lt;strong&gt;‚ÄúA‚Äù&lt;/strong&gt; but to &lt;strong&gt;system_EPROCESS &amp;amp; 0xffffffffffffff000.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image124.png&#34; alt=&#34;A screenshot of a computer program Description automatically generated with low confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This code will be repeated until the system token is retrieved.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image125.png&#34; alt=&#34;A screenshot of a computer code Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image126.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;On windows 11 the system token is at offset 0x4b8 of the EPROCESS structure recently read.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image127.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;I only need to write that system token in my process by calling &lt;strong&gt;CreateLogFile&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image128.png&#34; alt=&#34;A picture containing text, font, line, screenshot Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;To do this job, just repeat the step used to read the system token.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image129.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the double call, it first calls &lt;strong&gt;ClfsEarlierLsn&lt;/strong&gt; to return &lt;strong&gt;0xFFFFFFFF&lt;/strong&gt; in &lt;strong&gt;RDX&lt;/strong&gt; and then calls nt_&lt;strong&gt;SeSetAccessStateGenericMapping&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image130.png&#34; alt=&#34;A picture containing text, screenshot, font, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;I check that the value pointed by &lt;strong&gt;RDX&lt;/strong&gt; is the &lt;strong&gt;System Token.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image131.png&#34; alt=&#34;A picture containing text, screenshot, font Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The token of my process is:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image132.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It‚Äôs going to write there.&lt;/p&gt; &#xA;&lt;p&gt;WINDBG&amp;gt;dps rax+8&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;ffff9b8b&#39;fc446578&lt;/strong&gt; ffffc402&#39;f601c06c&lt;/p&gt; &#xA;&lt;p&gt;WINDBG&amp;gt;dps rax+8&lt;/p&gt; &#xA;&lt;p&gt;ffff9b8b&#39;fc446578 &lt;strong&gt;ffffc402&#39;ef841919&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now my process is &lt;strong&gt;System&lt;/strong&gt; I can run a Notepad to verify.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image133.png&#34; alt=&#34;A picture containing text, screenshot, font, line Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image134.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image135.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;7-The real patch&lt;/h1&gt; &#xA;&lt;p&gt;BINDIFF shows a lot of changed functions&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image136.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The vulnerable function is here:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image137.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image138.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The primary is the patched version, the secondary is the vulnerable version.&lt;/p&gt; &#xA;&lt;p&gt;The patch tests the return value of &lt;strong&gt;CflsEncodeBlock&lt;/strong&gt;, which is &lt;strong&gt;0xC01A000A&lt;/strong&gt;, stores it into the variable &lt;strong&gt;var_54&lt;/strong&gt;, and since it is negative, checks it and avoids the &lt;strong&gt;WriteSector&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The patch, in addition to not writing the file, the function returns correctly 0xc01a000a, with which &lt;strong&gt;CreateLogFile&lt;/strong&gt; does not return any handle and the exploitation cannot continue.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image139.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image140.png&#34; alt=&#34;A screenshot of a computer Description automatically generated&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Only if &lt;strong&gt;ClfsDecodeBlock&lt;/strong&gt; is not negative, it goes to &lt;strong&gt;WriteSector&lt;/strong&gt; but leaves returning the negative value &lt;strong&gt;0xC01A000A&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fortra/CVE-2023-28252/master/media/image139.png&#34; alt=&#34;A screenshot of a computer Description automatically generated with medium confidence&#34;&gt;This is the actual patch that really prevents the exploitation using the PoC that I just attached.&lt;/p&gt; &#xA;&lt;p&gt;At this point we have explained how the bug was exploited, it leads to controlling the functions that allows us to read the SYSTEM token and write it in our own process to achieve the local privilege escalation. You can find the functional PoC at&amp;nbsp;&lt;a href=&#34;https://github.com/fortra/CVE-2023-28252&#34;&gt;Fortra‚Äôs GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We hope you find it useful, if you have any doubt can contact us:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;mailto:%20%C2%A0Ricardo.narvaja@fortra.com&#34;&gt;Ricardo.narvaja@fortra.com&amp;nbsp;&lt;br&gt; &lt;/a&gt;&lt;a href=&#34;https://twitter.com/ricnar456&#34;&gt;@ricnar456&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&amp;nbsp;&lt;a href=&#34;mailto:Esteban.kazimirow@fortra.com&#34;&gt;Esteban.kazimirow@fortra.com&lt;br&gt; &lt;/a&gt;&lt;a href=&#34;https://twitter.com/solidclt&#34;&gt;@solidclt&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>